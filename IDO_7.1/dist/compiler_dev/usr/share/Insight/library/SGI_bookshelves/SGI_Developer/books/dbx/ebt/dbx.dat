#EDIR DATA#
LANG="C"dbx User's GuideDocument Number 007-0906-110CONTRIBUTORSWritten by Wendy Ferguson, Ken Jones and Leif WennerbergEdited by Christina CaryProduction by Gloria Ackley, Kay Maitz, and Lorrie WilliamsEngineering contributions by Dave Anderson, Alan Foster, Jay Gischer, Ray Milkey and Jon Templeton© Copyright 1996 Silicon Graphics, Inc.name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' All Rights ReservedThis document contains proprietary and confidential information of Silicon Graphics, Inc. The contents of this document may not be disclosed to third parties, copied, or duplicated in any form, in whole or in part, without the prior written permission of Silicon Graphics, Inc.RESTRICTED RIGHTS LEGENDUse, duplication, or disclosure of the technical data contained in this document by the Government is subject to restrictions as set forth in subdivision (c) (1) (ii) of the Rights in Technical Data and Computer Software clause at DFARS 52.227-7013 and/or in similar or successor clauses in the FAR, or in the DOD or NASA FAR Supplement. Unpublished rights reserved under the Copyright Laws of the United States. Contractor/manufacturer is Silicon Graphics, Inc., 2011 N. Shoreline Blvd., Mountain View, CA 94043-1389.Silicon Graphics and IRIS are registered trademarks and IRIX is a trademark of Silicon Graphics, Inc. This product documents the duel program developed by Michael Golan.About This GuideThis guide explains how to use the source level debugger, dbx. You can use dbx to debug programs in C, C++, Fortran, and assembly language.LBL="" HELPID=""What This Guide ContainsThis guide describes the features of dbx and provides simple examples of how to use dbx to debug programs. Specifically, this guide includes:IDREF="27706" TYPE="TITLE"Chapter 1, "Getting Started With dbx," introduces some basic dbx commands and offers some tips about how to approach a debugging session.IDREF="88264" TYPE="TITLE"Chapter 2, "Running dbx," explains how to run dbx and perform basic dbx control functions.IDREF="93044" TYPE="TITLE"Chapter 3, "Examining Source Files," explains how to examine source files under dbx.IDREF="64712" TYPE="TITLE"Chapter 4, "Controlling dbx," describes features of dbx that affect its operation while debugging a program.IDREF="80179" TYPE="TITLE"Chapter 5, "Examining and Changing Data," describes how to examine and change data in your program while running it under dbx.IDREF="91063" TYPE="TITLE"Chapter 6, "Controlling Program Execution," describes how to use the dbx commands that control execution of your program.IDREF="33796" TYPE="TITLE"Chapter 7, "Debugging Machine Language Code," explains how to debug machine language code.IDREF="42908" TYPE="TITLE"Chapter 8, "Multiple Process Debugging," explains multiprocess debugging procedures.IDREF="74957" TYPE="TITLE"Appendix A, "dbx Commands," lists and describes all dbx commands.IDREF="56444" TYPE="TITLE"Appendix B, "Predefined Aliases," lists and describes all predefined dbx aliases.IDREF="80540" TYPE="TITLE"Appendix C, "Predefined dbx Variables," lists and describes all predefined dbx variables.LBL="" HELPID=""What You Should Know Before Reading This GuideThis manual is written for programmers, and assumes that you are familiar with general debugging techniques.LBL="" HELPID=""Suggestions for Further ReadingThis dbx User's Guide is part of the IRIS Developer Option (IDO), which provides the software and documentation that you can use to write applications for Silicon Graphics platforms. A few IDO online and printed manuals that may be of interest to you are listed below. Programming on Silicon Graphics Systems:An Overview provides information about the IRIX programming environment and tools available for application programming. Topics covered include IRIX operating system, compilers, user interface and developer tools, and application libraries.Compiling and Performance Tuning Guide describes the compiler system and programming tools and interfaces, and explains how to improve program performance.Topics in IRIX Programming presents information about internationalizing an application, working with fonts, file and record locking, and inter-process communication.C Language Reference Manual covers the syntax and semantics of the C programming language as implemented on the IRIX operating system.Silicon Graphics offers software options to assist in software development. The CASEVision/Workshop option provides the WorkShop toolset: Debugger, Static Analyzer, Performance Analyzer, Tester, and Build Manager. You can order a printed manual from Silicon Graphics by calling SGI Direct at 1-800-800-SGI1 (800-7441). Outside the U.S. and Canada, contact your local sales office or distributor.Silicon Graphics also provides manuals online. To read an online manual after installing it, type insight or double-click the InSight icon. It's easy to print sections and chapters of the online manuals from InSight. LBL="" HELPID=""Conventions Used in This GuideThe conventions used in this manual help make information easy to access and understand. The following list describes the conventions and how they are used:Command names, including dbx commands, appear in italics. For example:The edit command lets you edit files from within dbx.Examples, shell prompts, and information displayed on the screen appear in a typewriter font. For example:Process 946: [6] trace count in mainExamples of what you enter are in boldface typewriter font. This example illustrates entering edit soar.c in response to a (dbx) prompt:(dbx) edit soar.cCommand arguments you replace with actual values appear in italics. In this example, you replace name with the name of an alias:alias nameOptional arguments are enclosed in square brackets ([ ... ]). In the following example, you can provide one or more directory names as arguments to the command:use [ dir ... ]Mutually exclusive arguments to a command are enclosed in braces ({ ... }) and separated by a pipe character (|). In the first example below, you can provide either an activation level or a procedure name as an argument to the command. In the second example, because the argument choices are enclosed in square brackets, you can use either the call or return argument, or omit an argument to the command:func { activation_level | procedure }
syscall catch [{ call | return }]File and directory names appear in italics. For example:You can put any dbx command in the .dbxinit file.New terms appear in italics. For example:Each procedure on the stack defines an activation level.LBL="1"ID="27706"Getting Started With dbxYou can use dbx to trace problems in a program at the source code level, rather than at the machine code level. ID="01.start1"dbx enables you to control a program's execution, symbolically monitoring program control flow, variables, and memory locations. You can also use dbx to trace the logic and flow of control to acquaint yourself with a program written by someone else.This chapter introduces some basic dbx commands and discusses some tips about how to approach a debugging session. Specifically, this chapter covers:IDREF="89331" TYPE="TITLE""Examining Core Dumps to Determine Cause of Failure"IDREF="84992" TYPE="TITLE""Debugging Your Programs"IDREF="30965" TYPE="TITLE""Studying a New Program"IDREF="85965" TYPE="TITLE""Avoiding Common Pitfalls"LBL="" HELPID=""ID="89331"Examining Core Dumps to Determine Cause of FailureEven if your program compiles successfully, it still can crash when you try to run it. When a program crashes, it generates a terminating signal that instructs the system to write out to a ID="01.start2"ID="01.start3"core file. The core file is the memory image of the program at the time it crashed.You can examine the core file with dbx to determine at what point your program crashed. To determine the point of failure, follow these steps:If the core file is not in the current directory, specify the pathname of the core file on the dbx command line.NoteIf the source code for the program is on a different machine or the source was moved, provide dbx with the pathname to search for source code (also see IDREF="35657" TYPE="TITLE""Specifying Source Directories"). Invoke ID="01.start4"dbx for the failed program as described in IDREF="67611" TYPE="TITLE""Invoking dbx".dbx automatically reads in the local core file.Perform a stack trace using the ID="01.start5"whereID="01.start6" command (described in IDREF="50445" TYPE="TITLE""Examining the Stack") to locate the failure point.For example, suppose you examine the core file for a program called test. Suppose the stack trace appears as follows:(dbx) where
>  0 foo2(i = 5) ["/usr/tmp/test.c":44, 0x1000109c]
   1 foo(i = 4) ["/usr/tmp/test.c":38, 0x1000105c]
   2 main(argc = 1, argv = 0xffffffad78) ["/usr/tmp/test.c":55, 0x10001104]
   3 __start() ["/shamu/crt1text.s":137, 0x10000ee4]In this case, test crashed at line 44 of the source file test.c. The program crashed while executing the function foo2. foo2 was called from line 38 in the function foo, which was in turn called from line 55 in the function main. You can use the other features of dbx to examine values of program variables and otherwise investigate why test crashed.If you use dbx to debug code that wasn't compiled using the ID="01.start7"­g option, local variables are invisible to dbx, and source lines may appear to jump around as a result of various optimizations. If the code is stripped of its debugging information, ID="01.start8"dbx displays very little information. LBL="" HELPID=""ID="84992"Debugging Your ProgramsDebugging a program consists primarily of stopping your program under certain conditions and then examining the state of the program stack and the values stored in program variables.ID="01.start9"You stop execution of your program by setting ID="01.start10"breakpoints in your program. Breakpoints can be ID="01.start11"unconditional, in which case they always stop your program when encountered, or ID="01.start12"conditional, in which case they stop your program only if a test condition that you specify is true. (See IDREF="23865" TYPE="TITLE""Setting Breakpoints" for more information.)To use breakpoints to debug your program, examine your program carefully to determine where problems are likely to occur, and set breakpoints in these problem areas. If your program crashes, first determine which line causes it to crash, then set a breakpoint just before that line.You can use several dbx commands to trace a variable's value. Here's a simple method for tracing a program variable:Use the stopID="01.start13" command (see IDREF="23865" TYPE="TITLE""Setting Breakpoints") to set breakpoints in the program at locations where you want to examine the state of the program stack or the values stored in program variables.ID="01.start14"Use the runID="01.start15" or rerunID="01.start16" command (described in IDREF="23899" TYPE="TITLE""Running Your Program") to run your program under dbx. The program stops at the first breakpoint that it encounters during execution.Examine the program variable as described in ID="01.start17"IDREF="85784" TYPE="TITLE""Displaying the Value of a Variable". Examine the program stack as described in ID="01.start18"IDREF="50445" TYPE="TITLE""Examining the Stack".Use the cont command (see IDREF="31983" TYPE="TITLE""Continuing Execution After a Breakpoint") to continue execution past a breakpoint. However, you cannot continue execution past a line that crashes the program.ID="01.start19"LBL="" HELPID=""ID="30965"Studying a New ProgramUseID="01.start20" dbx to examine the flow of control in a program. When studying the flow of control within a program, use the dbx commands stop, run/rerun, printID="01.start21", nextID="01.start22", stepID="01.start23", and cont. To study a new program:Use the stop command to set breakpoints in the program. When you execute the program under dbx, it stops execution at the breakpoints.If you want to review every line in the program, set a breakpoint on the first executable line. If you don't want to look at each line, set breakpoints just before the sections you intend to review.Use the run and rerun commands to run the program under dbx. The program stops at the first breakpoint.Use the printID="01.start24" command to print the value of a program variable at a breakpoint.ID="01.start25"Use the step, next, or cont command to continue past a breakpoint and execute the rest of the program.step executes the next line of the program. If the next line is a procedure call, ID="01.start26"step steps down into the procedure. step is described in IDREF="33387" TYPE="TITLE""Stepping Using the step Command".next executes the next line; if it is a procedure, next executes it but does not step down into it. next is described in IDREF="24643" TYPE="TITLE""Stepping Using the next Command".cont resumes execution of the program past a breakpoint and does not stop until it reaches the next breakpoint or the end of the program. cont is explained in IDREF="31983" TYPE="TITLE""Continuing Execution After a Breakpoint".Another tool that you can use to follow the execution of your program is the traceID="01.start27" command (described in IDREF="19256" TYPE="TITLE""Tracing Program Execution"). With it you can examine:values of variables at specific points in your program or whenever variables change valueID="01.start28"parameters passed to and values returned from functionsID="01.start29"line numbers as they are executedID="01.start30"LBL="" HELPID=""ID="85965"Avoiding Common PitfallsYou may encounter some problems when you debug a program. Common problems and their solutions are listed below.ID="01.start31"If ID="01.start32"dbx does not display variables, recompile the program with the ID="01.start33"­g compiler option. Note that in some cases, this may cause the problem to go away, or its symptoms to change.If the debugger's listing seems confused, try separating the lines of source code into logical units. The debugger may get confused if more than one source statement occurs on the same line.ID="01.start34"If the debugger's executable version of the code doesn't match the source, recompile the source code. The code displayed in the debugger is identical to the executable version of the code.ID="01.start35"If code appears to be missing, it may be contained in an include file or a macro. The debugger treats macros as single lines. To debug a macro, expand the macro in the source code.ID="01.start36"ID="01.start37"ID="01.start38"ID="01.start39"ID="01.start40"LBL="2"ID="88264"Running dbxThis chapter explains how to run dbxname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'specifically, it covers:IDREF="97214" TYPE="TITLE""Compiling a Program for Debugging Under dbx"IDREF="68536" TYPE="TITLE""Compiling and Linking Programs With Dynamic Shared Objects"IDREF="67611" TYPE="TITLE""Invoking dbx" from a shellIDREF="23899" TYPE="TITLE""Running Your Program"IDREF="87665" TYPE="TITLE""Automatically Executing Commands on Startup"IDREF="92439" TYPE="TITLE""Using Online Help"IDREF="79140" TYPE="TITLE""Entering Multiple Commands on a Single Line"IDREF="94741" TYPE="TITLE""Spanning a Command Across Multiple Lines"IDREF="38587" TYPE="TITLE""Invoking a Shell" from dbxIDREF="10584" TYPE="TITLE""Quitting dbx"LBL="" HELPID=""ID="97214"Compiling a Program for Debugging Under dbxBefore using ID="02.run1"dbx to debug a program, compile the program using the ID="02.run2"­g option (for example, cc ­g). The ­g option includes additional debugging information in your program object so that dbx can list local variables and find source lines.If you use dbx to debug code that was not compiled using the ­g option, local variables are invisible to dbx, and source lines may appear to jump around oddly as a result of various optimizations. It is more difficult to debug code without reliable references to lines of source code.LBL="" HELPID=""ID="68536"Compiling and Linking Programs With Dynamic Shared ObjectsThis section summarizes a few things you need to know if you compile and link your program with Dynamic Shared Objects (DSOs). A DSO is a relocatable shared library. By linking with a DSO, you keep your program size small and use memory efficiently. ID="02.run3"If you compile and link with DSOs, dbx automatically notices their use in the program and picks up the relevant debugging information. The dbx command ID="02.run4"listobj shows any DSOs in a process. The dbx command ID="02.run5"whichobj lists all DSOs in which a specified variable is present. The dbx command listregions identifies DSO addresses at run time.The dbx help section on hint_dso has more information on dbx and DSOs. For more information on DSOs, see "Using Dynamic Shared Objects" in the Compiling and Performance Tuning Guide. LBL="" HELPID=""ID="67611"Invoking dbxThis section describes how to invoke dbx and includes:IDREF="16626" TYPE="TITLE""dbx Options"IDREF="89350" TYPE="TITLE""Specifying Object and Core Files"IDREF="14382" TYPE="TITLE""The dbx Prompt"IDREF="83396" TYPE="TITLE""Specifying Files with dbx Commands"To invoke ID="02.run6"dbx from the shell command line, type dbx. The syntax is:dbx [options] [object_file [corefile]]LBL="" HELPID=""ID="16626"dbx OptionsIDREF="38456" TYPE="TABLE"Table 2-1 lists options you can give to dbx. These options are described in detail later in this chapter.COLUMNS="2"LBL="2-1"Table 2-1 (continued)        ID="38456" dbx Command-Line OptionsLEFT="0" WIDTH="81"OptionLEFT="90" WIDTH="243"DescriptionLEFT="0" WIDTH="81"ID="02.run7"­cfile LEFT="90" WIDTH="243"Selects a command file other than ID="02.run8".dbxinit to execute on 
starting dbx. For information on .dbxinit, see IDREF="87665" TYPE="TITLE""Automatically 
Executing Commands on Startup."LEFT="0" WIDTH="81"ID="02.run9"­dLEFT="90" WIDTH="243"Provides startup information to the shell when a program is 
started with the run command.LEFT="0" WIDTH="81"ID="02.run10"­enumLEFT="90" WIDTH="243"Chooses a large size for the evaluation stack (as large as you 
want). The default stack size is 20,000 bytes. ID="02.run11"num = number 
of bytes. If you see the message toolargetoevaluate, 
rerun dbx suppling a value greater than 20,000. LEFT="0" WIDTH="81"ID="02.run12"­iLEFT="90" WIDTH="243"Uses interactive mode. This option prompts for source even 
when it reads from a file and treats data in a file as if it comes 
from a terminal (stdin). This option does not treat "#" 
characters as comments in a file. ID="02.run13"LEFT="0" WIDTH="81"ID="02.run14"­IdirLEFT="90" WIDTH="243"Tells dbx to look in the specified directory (in addition to the 
current directory and the object file's directory) for source 
files. To specify multiple directories, use a separate ID="02.run15"­I for 
each. If no directory is specified when you invoke dbx, it 
looks for source files in the current directory and in the 
object file's directory. From dbx, changes the directories 
searched for source files with the ID="02.run16"use and ID="02.run17"dir commands.LEFT="0" WIDTH="81"ID="02.run18"­kLEFT="90" WIDTH="243"Turns on kernel debugging. When debugging a running 
system, specify ID="02.run19"/dev/kmem as the core file.LEFT="0" WIDTH="81"ID="02.run20"­NLEFT="90" WIDTH="243"Sets the dbx variable $nonstop to 1 on startup: attaching to a 
process does not stop the process. Affectsonlythe dbx 
options -p and -P and the addproc command.LEFT="0" WIDTH="81"ID="02.run21"­PnameLEFT="90" WIDTH="243"Debugs the running process with the specified ID="02.run22"name (name as 
described in the ps(1) reference page).LEFT="0" WIDTH="81"ID="02.run23"­ppidLEFT="90" WIDTH="243"Debugs the process specified by the pid number.LEFT="0" WIDTH="81"ID="02.run24"­RLEFT="90" WIDTH="243"Allows breakpoints in rld.LEFT="0" WIDTH="81"ID="02.run25"­rprogram [arg]LEFT="90" WIDTH="243"Runs the named program upon entering ID="02.run26"dbx, using the 
specified arguments. The .dbxinit file (if any) is read and 
executed after executing the object_file. You cannot specify 
a core file with ­r.LBL="" HELPID=""ID="89350"Specifying Object and Core FilesThe object_file is the name of the executable object file that you want to debug. It provides both the code that ID="02.run27"dbx executes and the symbol table that provides variable and procedure names and maps executable code to its corresponding source code in source files.A corefileID="02.run28" is produced when a program exits abnormally and produces a core dump. dbx allows you to provide the name of a core file that it uses as "the contents of memory" for the program that you specify. If you provide a core file, dbx lists the point of program failure. You can then perform stack traces and examine variable values to determine why a program crashed. However, you cannot force the program to execute past the line that caused it to crash.If you don't specify a corefile, dbx examines the current directory for a file named core. If it finds core, and if core seems (based on data in the core file) to be a core dump of the program you specified, dbx acts as if you had specified core as the core file.You can specify object and core files either as arguments when you invoke ID="02.run29"ID="02.run30"dbx or as commands that you enter at the dbx prompt.LBL="" HELPID=""ID="14382"The dbx PromptOnce dbx starts, it displays the prompt:ID="02.run31"(dbx) To change this prompt, change the value of the dbxID="02.run32"$prompt variable. IDREF="78540" TYPE="TITLE""Setting dbx Variables" describes how to set dbx variables.LBL="" HELPID=""ID="83396"Specifying Files with dbx CommandsThe ID="02.run33"givenfile and ID="02.run34"corefiledbx commands allow you to set the object file and the core file, respectively, while dbx is running.givenfileID="02.run35" [file]If you provide a filename, dbx kills the currently running processes and loads the executable code and debugging information found in file.If you do not provide a filename, dbx displays the name of the program that it is currently debugging without changing it.corefileID="02.run36" [file]If you provide a filename, dbx uses the program data stored in the core dump file.If you do not provide a filename, dbx displays the name of the current core file without changing it.LBL="" HELPID=""ID="23899"Running Your ProgramYou can start your program under ID="02.run37"dbx using the ID="02.run38"run or ID="02.run39"rerun command.runID="02.run40" run-arguments The run command starts your program and passes to it any arguments that you provide. The command uses your shell (the program named in the SHELL environment variable or /bin/sh if an environment variable does not exist) to process a run command. The syntax allowed in your shell is allowed on the run command line. All shell processing is accepted, such as expansion and substitution of * and ? in filenames. Redirection of the program's standard input and standard output, and/or standard error is also done by the shell.In other words, the ID="02.run41"ID="02.run42"ID="02.run43"run command does exactly what typing target run-arguments at the shell prompt does. You can specify target either on dbx invocation or in a prior givenfile command. dbx passes ./target as argv[0] to target when you specify it as a relative pathname.The run command does not invoke the initialization files of the Bourne, C, and Korn shells before it starts a program. If you use a non-standard shell, before you run a program set the dbx variable ID="02.run44"$shellparameters to a string that will instruct the shell to not load the initialization file. For example, for the C shell you would enter set $shellparameters = "-f".To verify exactly how your application is being started by the run or rerun command, start dbx with the -d option.If the environment variable SHELL is set to a C shell and your program has file-descriptors other than the default values: 0,1,2, switch to the Bourne shell before you invoke the run command. This means you can only use sh-style redirections, but csh would close the extra file-descriptors. Make the switch, for the purpose of running your program, with the dbx command ID="02.run45"setenv SHELL /bin/sh.A run command must appear on a line by itself and cannot be followed by another dbx command separated by a semi-colon (;). Terminate the command line with a return (new-line). Note that you cannot include a run command in the command list of a when command.rerunID="02.run46" [run-arguments]The ID="02.run47"rerun command, without any arguments, repeats the last run command if applicable. Otherwise rerun is equivalent to the run command without any arguments.The sort command takes an input file and produces a sorted output file; you can specify input and output files either through command-line arguments or file redirection. For example, from the command line you can enter:% sort -i input -o output
% sort < input2 > output2If you are debugging the sort program, the equivalent dbx commands are:(dbx) run -i input -o output
(dbx) run < input2 > output2If you execute these run commands in the order presented, you can repeat the last run command by using the rerun command:(dbx) rerunLBL="" HELPID=""ID="87665"Automatically Executing Commands on StartupYou can use an editor to create a ID="02.run48".dbxinit command file. This file contains various dbx commands that automatically execute when you invoke dbx. You can put any dbx command in the .dbxinit file. If a command requires input, the system prompts you for it when you invoke dbx.On invocation, dbx looks for a .dbxinit file in the current directory. If the current directory does not contain a .dbxinit file, dbx looks for one in your home directory. (This assumes that you have set the IRIX system ID="02.run49"HOME environment variable.)LBL="" HELPID=""ID="92439"Using Online HelpThe ID="02.run50"dbx command ID="02.run51"help has several options:helpshows the supported dbx commandshelp keywordshows information pertaining to the given keyword, such as alias, help, most_used, quit, playback, record, and so onhelp allshows the entire dbx help fileWhen you type help all, dbx displays the file using the command name given by the dbxID="02.run52"$pager variable. The dbx help file is large and can be difficult to read even if you use a simple paging program like more(1). You can set the $pager variable to a text editor like vi(1) or to your favorite editor. For example, just add the following command in your .dbxinit file:set $pager = "vi"When the above entry is in your .dbxinit file, dbx displays the help file in vi. You can then use the editor's search commands to look through the help file quickly. Quit the editor to return to dbx.LBL="" HELPID=""ID="79140"Entering Multiple Commands on a Single LineYou can use a semicolon (ID="02.run53";) as a separator to include multiple commands on the same command line. This is useful with commands such as when (described in IDREF="89878" TYPE="TITLE""Writing Conditional Commands") as it allows you to include multiple commands in the command block. For example:(dbx) when at "myfile.c":37 {print a ; where ; print b}LBL="" HELPID=""ID="94741"Spanning a Command Across Multiple LinesYou can use a backslash (ID="02.run54"\) at the end of a line of input to indicate that the command is continued on the next line. This can be convenient when entering complex commands such as an alias definition (aliases are discussed in IDREF="37216" TYPE="TITLE""Creating and Removing dbx Aliases"). For example:(dbx) alias foll "print *(struct list *)$p ; \
set $p = (int)((struct list *)($p))->next"HintYou can also use the hed command for creating and modifying commands. IDREF="59470" TYPE="TITLE""The History Editor" has details on this command.LBL="" HELPID=""ID="38587"Invoking a ShellTo invoke a subshell, enter ID="02.run55"sh at the dbx prompt, or enter sh and a shell command at the dbx prompt. After invoking a subshell, type exit or <Ctrl-d> to return to dbx.The syntax for the sh command is:shID="02.run56"Invoke a subshell.sh commandExecute the specified shell command. ID="02.run57"dbx interprets the rest of the line as a command to pass to the spawned shell process, unless you enclose the command in double-quotes or you terminate your shell command with a semicolon (;).For example, to spawn a subshell, enter:(dbx) sh
% To display the end of the file datafile, enter:(dbx) sh tail datafileLBL="" HELPID=""ID="10584"Quitting dbxTo end a ID="02.run58"dbx debugging session, enter the ID="02.run59"quit command at the dbx prompt:(dbx) quitLBL="3"ID="93044"Examining Source FilesThis chapter explains how to examine source files under dbx. It describes:IDREF="35657" TYPE="TITLE""Specifying Source Directories"IDREF="59599" TYPE="TITLE""Listing Source Code"IDREF="91727" TYPE="TITLE""Searching Through Source Code"IDREF="41684" TYPE="TITLE""Changing Source Files"IDREF="51670" TYPE="TITLE""Listing Inlines and Clones"IDREF="33324" TYPE="TITLE""Calling an Editor"LBL="" HELPID=""ID="35657"Specifying Source DirectoriesBased on the information contained in an object file's symbol table, dbx determines from which source files the program was compiled and prints portions of these files as appropriate.ID="03.examin1"Object files compiled with ID="03.examin2"ID="03.examin3"­g record the absolute path names to the source files. Each time dbx needs a source file, it first searches the absolute path for the source file. If the source file is not present (or if the object file was not compiled with ­g), dbx checks its own list of directories for source files.By default, the dbx directory list contains only the current directory (from which you invoked ID="03.examin4"dbx) and the object file's directory (if it is different from the current directory). Each time dbx searches this list, it searches all directories in the list in the order in which they appear until it finds the file with the specified name.LBL="" HELPID=""Specifying Source Directories With ArgumentsYou can specify additional source directories when you invoke ID="03.examin5"dbx with the ID="03.examin6"­I option. To specify multiple directories, use a separate ­I for each.For example, consider debugging a program called look in /usr/local/bin, the source for which resides in /usr/local/src/look.c. To debug this program, you can invoke dbx from the /usr/local/bin directory by entering:% dbx -I /usr/local/src lookLBL="" HELPID=""Specifying Source Directories With dbx CommandsThe ID="03.examin7"dir and ID="03.examin8"use commands allow you to specify a source directory list while dbx is running.dirID="03.examin9" [dir ...]If you provide one or more directories, ID="03.examin10"dbx adds those directories to the end of the source directory list. If you do not provide any directories, dbx displays the current source directory list.use ID="03.examin11"[dir ...]If you provide one or more directories, ID="03.examin12"dbx replaces the source directory list with the directories that you provide.If you do not provide any options, dbx displays the current source directory list.NoteBoth the dir and use commands recognize absolute and relative pathnames (for example, ../src); however, they do not recognize C shell tilde (~) syntax (for example, ~kim/src) or environment variables (for example, $HOME/src).LBL="" HELPID=""Examples of dir and useLet's debug the look program in /usr/local/bin. Recall that the source resides in /usr/local/src/look.c. If you invoke dbx from the /usr/local/bin directory without specifying /usr/local/src as a source directory, it will not initially appear in the directory list:(dbx) dir
.However, you can add /usr/local/src with the dir command by entering:(dbx) dir /usr/local/src
(dbx) dir
. /usr/local/srcIf you use the use command instead, the current directory is no longer contained in the source directory list:(dbx) use /usr/local/src
(dbx) use
/usr/local/srcLBL="" HELPID=""Path RemappingThe debugging information for programs compiled with ID="03.examin13"­g includes the full pathnames for source files. By default, dbx uses these pathnames to search for source files. However, if you are debugging a program that was compiled somewhere else and you want to specify a new path to the sources, you can use path remapping. You can substitute one pattern for another to remap the path so dbx can find the source file.dir ID="03.examin14"pattern1:pattern2The ID="03.examin15"dir (or use) command allows you to remap directories and specify a new path to the source. dbx substitutes pattern2 for pattern1.For example, a compiled program's source is /x/y/z/kk.c and the source was moved to /x/y/zzz/kk/kk.c. Specify the dir (or use) command to remap the path:(dbx) dir /z/:/zzz/kk/The new path is /x/y/zzz/kk/kk.c, where /z/ has been remapped to the string following the colon. LBL="" HELPID=""Controlling use of Path Remappings and Your Source-Directory ListThe dbx variable ID="03.examin16"$sourcepathrule controls how, in a source-file search, dbx uses path remappings and the source-directory list created by the dir and use commands. IDREF="92830" TYPE="TABLE"Table 3-1 summarizes the effects of $sourcepathrule.COLUMNS="2"LBL="3-1"Table 3-1 ID="92830"(continued)         Effect of 
$sourcepathrule on Use of Path Remapping and Source Directory ListLEFT="0" WIDTH="63"ValueLEFT="70" WIDTH="261"EffectLEFT="0" WIDTH="63"0 (default)LEFT="70" WIDTH="261"Search for a source file by: a) using the pathname in the object file's debugging information; 
if the file is not found, then b) examine pathnames remapped by the dir or use command; if the file is still not found, thenc) reduce full pathnames to base file names and search the list of 
directories created by the dir or use command.LEFT="0" WIDTH="63"1 LEFT="70" WIDTH="261"Permute the default source-file search sequence to: step b, step c, 
then step a.LEFT="0" WIDTH="63"2LEFT="70" WIDTH="261"Use only steps b and c of the default source-file search sequence. $sourcepathrule = 1 is useful when, for example, you move source files after you compile your program. You can direct dbx to the correct files.$sourcepathrule = 2 is useful when, for example, your network is slow and you have full pathnames in your debugging information that point to files on other machines. The debugger ignores all pathnames in the debugging information and, hence, will not attempt access over the network.LBL="" HELPID=""ID="41684"Changing Source FilesThe ID="03.examin17"file command changes the current source file to a file that you specify. The new file becomes the current source file, on which you can search, list, and perform other operations. For example, to set the current source file to ID="03.examin18"ID="03.examin19""Examining the Stack" on page 54procedure.c, enter:(dbx) file procedure.cNoteIf your program is large, typically you store the source code in multiple files. dbx automatically selects the proper source file for the section of code that you are examining. Thus, many dbx commands reset the current source file as a side effect. For example, when you move up and down activation levels in the stack using the up and down commands, dbx changes the current source file to whatever file contains the source for the procedure (see IDREF="50445" TYPE="TITLE""Examining the Stack" for more information on activation levels).If you enter the file command without any arguments, dbx prints the current source file:(dbx) file
procedure.cYou can also change the current source file by typing:(dbx) funcprocedureYou can use the tag command to search the tag file for procedure:(dbx) tag procedureThe tag command finds C preprocessor macros if they have arguments (funcprocedure cannot). For more information about the tag file, see ctags(1).LBL="" HELPID=""ID="59599"Listing Source CodeThe list command displays lines of source code. The dbx variable ID="03.examin20"$listwindow defines the number of lines dbx lists by default. The list command uses the active frame and line of the current source file unless overridden by a file command. Any execution of the program overrides the file command by establishing a new current source file. The syntax for the list command is:listID="03.examin21"Lists ID="03.examin22"$listwindow lines beginning at the current line (or list the line of the current pc if the current line is unknown or not set). list expLists ID="03.examin23"$listwindow lines starting with the line number given by the expression exp. The expression can be any valid expression that evaluates to an integer value as described in IDREF="25993" TYPE="TITLE""Using Expressions".list exp1:exp2Lists exp2 lines, beginning at line exp1.list exp1,exp2Lists all source between line exp1 and line exp2 inclusive.list funcLists $listwindow lines starting at procedure func.list func,expLists all source between func and exp, inclusive.list func:expLists exp lines, beginning at func.A > symbol prints to the left of the line that is the current line. A * symbol prints to the left of the line of the current pc location. For example, to list lines 20­35 of a file, enter:(dbx) list 20,35In response to this command, dbx displays lines 20 through 35 and sets the current line to 36.To list 15 lines starting with line 75, enter:(dbx) list 75:15In response to this command, dbx displays lines 75 through 89 and sets the current line to 90.LBL="" HELPID=""ID="51670"Listing Inlines and ClonesThe compiler may inline routines, replacing a call with quotes of code from the called routine, either as a result of optimization or C++ inline directives. Clones are specialized versions of routines that you can use to get faster-running code. The source for cloned routines is called a ID="03.examin24"ID="03.examin25"root.In special cases, you may want to find inlined routines or clones. The commands listinlines and listclones find the routines, if enough debugging information is available. Compilations with the -32 option or with IRIX 6.2 and earlier base compilers do not have the necessary information; listinlines and listclones will show nothing.The syntax for the listinlines command is:ID="03.examin26"listinlines Lists all inlined routines with their start and end addresses.listinlines funcLists all the inlined instances of func with their start and end addresses. For example, ::MultPoints is a C++ routine and you enter:(dbx) listinlines ::MultPoints The dbx output lists the address ranges of all the instances where ::MultPoints is inlined.The syntax for the listclones command is similar:ID="03.examin27"listclones Lists all the root functions and their derived clones. listclones funcLists the root and all derived clones for func.LBL="" HELPID=""ID="91727"Searching Through Source CodeUse the forward slash (ID="03.examin28"/ID="03.examin29") and question mark (?ID="03.examin30") commands to search through the current file for regular expressions in source code. For a description of regular expressions, see the ed(1) reference page.The search commands have the following syntax:ID="03.examin31"/[reg_exp]Search forward through the current file from the current line for the regular expression reg_exp. If dbx reaches the end of the file without finding the regular expression, it wraps around to the beginning of the file. dbx prints the first source line containing a match of the search expression.If you don't supply a regular expression, dbx searches forward based on the last regular expression searched.ID="03.examin32"?[reg_exp]Search backward through the current file from the current line for the regular expression reg_exp. If dbx reaches the beginning of the file without finding the regular expression, it wraps around to the end of the file. dbx prints the first source line containing a match of the search expression.If you don't supply a regular expression, dbx searches backward based on the last regular expression searched.For example, to search forward for the next occurrence of the string "errno," enter:(dbx) /errnoTo search backward for the previous occurrence of either "img" or "Img," enter:(dbx) ?[iI]mgLBL="" HELPID=""ID="33324"Calling an EditorThe ID="03.examin33"edit command lets you edit files from within ID="03.examin34"dbx:editID="03.examin35"The edit command invokes an editor (vi by default) on the current source file. If you set the dbx variable ID="03.examin36"$editor to the name of an editor, the edit command invokes that editor. If you do not set the $editor, dbx checks the environment variable ID="03.examin37"EDITOR and, if set, invokes that editor. When you exit the editor, you return to the dbx prompt.edit fileInvokes the editor on the given file. edit procedureInvokes the editor on the file that contains the source for the specified procedure. dbx extended naming does not work. You may only name procedures that dbx can find with a simple name: procedures in the current activation stack and global procedures.For example, to edit a file named soar.c from within dbx, type:(dbx) edit soar.cThe edit command is also useful for editing dbx script files. See IDREF="60766" TYPE="TITLE""Executing dbx Scripts" for more information on script files.LBL="4"ID="64712"Controlling dbxThis chapter describes features of dbx that affect its operation while debugging a program. Specifically, this chapter covers:IDREF="88718" TYPE="TITLE""Creating and Removing dbx Variables"IDREF="82250" TYPE="TITLE""Using the History Feature and the History Editor"IDREF="37216" TYPE="TITLE""Creating and Removing dbx Aliases"IDREF="43528" TYPE="TITLE""Recording and Playing Back dbx Input and Output"IDREF="60766" TYPE="TITLE""Executing dbx Scripts"LBL="" HELPID=""ID="88718"Creating and Removing dbx Variablesdbx allows you to define variables that you can use within ID="04.cntrl1"dbx to store values. These variables exist entirely in dbx; they are not part of your program. You can use dbx variables for a variety of purposes while debugging. For example, you can use dbx variables as temporary storage, counters, or pointers that you use to step through arrays.dbx also provides many predefined variables that control how various ID="04.cntrl2"dbx commands function. IDREF="80540" TYPE="TITLE"Appendix C, "Predefined dbx Variables" provides a complete list of predefined dbx variables and their purposes.A dbx variable does not have a fixed type. You can assign a dbx variable any type of value, even if it already has a value of a different type. However, a variable predefined by dbx does have a fixed predefined type.You can use almost any name for dbx variables. A good practice to follow is to use a dollar sign ($) as the first character of all dbx variables to prevent conflicts with most program variable names. All of dbx's predefined variables begin with a dollar sign.The commands described in this section apply only to the manipulations of dbx variables, not program variables. IDREF="50911" TYPE="TITLE""Displaying and Changing Program Variables" describes how to manipulate program variables.LBL="" HELPID=""ID="78540"Setting dbx VariablesThe ID="04.cntrl3"ID="04.cntrl4"set command sets a dbx variable to a given value, defining the variable if it does not exist:setID="04.cntrl5" var = expDefine (or redefine) the specified ID="04.cntrl6"dbx variable, setting its value to that of the expression you provide.You can display the value of a variable with the ID="04.cntrl7"print command. For example:(dbx) set $k = 1
(dbx) print $k
1
(dbx) set $k = $k +23
(dbx) print $k
24
(dbx) print $k / 11
2In the above example, dbx performs an integer division because both the variable $k and the constant 11 are integers. If you assign a floating point value to $k and evaluate the expression again, dbx performs a floating point division:(dbx) set $k = 24.0
(dbx) print $k
24.0
(dbx) print $k / 11
2.1818181818181817NoteWe recommend that you begin a dbx variable with a $ to avoid confusion with a program variable. A dbx variable without a leading $ hides any program variable that has the same name. The only way to see the program variable is to remove the dbx variable with an unset command.LBL="" HELPID=""Listing dbx VariablesIf you enter the ID="04.cntrl8"ID="04.cntrl9"set command without providing any arguments, dbx displays (in alphabetical order) a list of all currently defined dbx variables, including predefined variables. Partial output looks like this:(dbx) set
$addrfmt        "0x%x"
$addrfmt64      "0x%llx"
$assignverify   1
$casesense      2
$ctypenames     1
$curevent       3
$curline        44
$curpc          268439708
...
$stacktracelimit        1024
$stdc           0
$stepintoall    0
$tagfile        "tags"LBL="" HELPID=""Removing VariablesThe ID="04.cntrl10"ID="04.cntrl11"unset command removes a dbx variable. For example, to delete the variable $k, enter:(dbx) unset $kLBL="" HELPID=""ID="82250"Using the History Feature and the History EditorThe dbx history feature is similar to the C shell's history feature in that it allows you to repeat commands that you have entered previously. However, unlike the C shell's history feature, ID="04.cntrl12"ID="04.cntrl13"dbx does not allow you to execute a history command anywhere except the beginning of a line. Also, dbx does not support history substitution of command arguments such as the C shell !$ argument.LBL="" HELPID=""Examining the History Listdbx stores all commands that you enter in the history list. The value of the ID="04.cntrl14"dbx variable $lines determines how many commands are stored in the history list. The default value is 100.Display the history list with the ID="04.cntrl15"ID="04.cntrl16"history command. For example, after setting a breakpoint, running a program, and examining some variables, your history list might look something like this:(dbx) history
  1     set $prompt = "(dbx)"
  2     set $page=0
  3     set $pimode=1
  4     stop in main
  5     historyLBL="" HELPID=""Repeating CommandsYou can execute any of the commands contained in the history list. Each history command begins with an exclamation point (ID="04.cntrl17"ID="04.cntrl18"!):ID="04.cntrl19"!!Repeats the previous command. If the value of the dbx variable ID="04.cntrl20"$repeatmode is set to 1, then entering a carriage return at an empty line is equivalent to executing !!. By default, $repeatmode is set to 0.ID="04.cntrl21"!stringRepeats the most recent command that starts with the specified string.ID="04.cntrl22"!integerRepeats the command associated with the specified integer in the history list.ID="04.cntrl23"!-integerRepeats the command that occurred integer times before the most recent command. Entering !-1 executes the previous command, !-2 the command before that, and so forth.You can use the !! command to facilitate single-stepping through your program. (Single-stepping is described in IDREF="31135" TYPE="TITLE""Stepping Through Your Program".) The following illustrates using the next command to execute 5 lines of source code and then using the !! command to repeat the next command. For example:(dbx) next 5
Process 22545 (test) stopped at [main:60 ,0x10001150]
  60  total += j;
(dbx) !!
(!! = next 5)
Process 22545 (test) stopped at [main:65 ,0x100011a0]
  65  printf("i = %d, j = %d, total = %d\n",i,j,total);Another convenient way to repeat a commonly used command is with !string. For example, suppose that you occasionally print the values of certain variables using the printf command while running your program under dbx. (The printf command is described in IDREF="17137" TYPE="TITLE""Printing Expressions".) In this case, as long as you do not enter any command beginning with "pr" after you enter the printf command, you can repeat the printf command by entering !pr. For example:(dbx) printf "i = %d, j = %d, total = %d\n", i, j, total
i = 4, j = 25, total = 1
  ...
(dbx) !pr
i = 12, j = 272, total = 529Using !integer, you can repeat any command in the history list. If you want to repeat the printf command, but you have entered a subsequent print command, examine the history list and then explicitly repeat the printf command using its reference number. For example:(dbx) history
  1     set $prompt = "(dbx)"
  2     set $page=0
  ...
  45    printf "i = %d, j = %d, total = %d\n", i, j, total
  46    next
  ...
  49    print j
  ...
  53    history
(dbx) !45
(!45 = printf "i = %d, j = %d, total = %d\n", i, j, total)
i = 9, j = 43, total = 1084LBL="" HELPID=""ID="59470"The History EditorThe history editor, ID="04.cntrl24"ID="04.cntrl25"hed, lets you use your favorite editor on any or all of the commands in the current dbx history list. When you enter the ID="04.cntrl26"hed command, dbx copies all or part of the history list into a temporary file that you can edit. When you quit the editor, any commands left in this temporary file are automatically executed by dbx.If you have set the dbx variable ID="04.cntrl27"$editor to the name of an editor, the hed command invokes that editor. If you have not set the dbx variable $editor, dbx checks whether you have set the environment variable ID="04.cntrl28"EDITOR and, if so, invokes that editor. If you have not set either the dbx variable or the environment variable, dbx invokes the vi editor.The syntax for the hed commands is:hedID="04.cntrl29"Edits only the last line of the history list (the last command executed).hed num1Edits line num1 in the history list.hedID="04.cntrl30" num1,num2Edits the lines in the history list from num1 through num2.hed allID="04.cntrl31"Edits the entire history list.By default, dbx doesn't display the commands that it executes as a result of the hed command (the dbx variable $pimode is set to 0). If ID="04.cntrl32"$pimode is set to 1, dbx displays the commands as it executes them. See $pimode in IDREF="80540" TYPE="TITLE"Appendix C, "Predefined dbx Variables" for more information.LBL="" HELPID=""ID="37216"Creating and Removing dbx AliasesYou can create dbx aliases for debugger commands. Use these aliases as you would any other ID="04.cntrl33"dbx command. When dbx encounters an alias, it expands the alias using the definition you provided.dbx has a group of predefined aliases that you can modify or delete. These aliases are listed and described in ID="04.cntrl34"IDREF="56444" TYPE="TITLE"Appendix B, "Predefined Aliases."If you find that you often create the same aliases in your debugging sessions, you can include their definitions in your .dbxinit file so that they are automatically defined for you. See IDREF="87665" TYPE="TITLE""Automatically Executing Commands on Startup" for more information on the .dbxinit file.LBL="" HELPID=""Listing AliasesYou can display the definition of aliases using the ID="04.cntrl35"ID="04.cntrl36"alias command:aliasID="04.cntrl37"Lists all existing aliases.aliasID="04.cntrl38" nameLists the alias definition for name.For example, to display the definitions of the predefined aliases "l" and "bp," enter:(dbx) alias l
"list"
(dbx) alias bp
"stop in"LBL="" HELPID=""Creating Command AliasesYou can use the ID="04.cntrl39"ID="04.cntrl40"alias command to define new aliases:aliasID="04.cntrl41" name commandDefines ID="04.cntrl42"name as an alias for command.aliasID="04.cntrl43" name "string"Defines ID="04.cntrl44"name as an alias for string. With this form of the alias command, you can provide command arguments in the alias definition.aliasID="04.cntrl45" name(arg1 [, ... argN]) "string"Defines ID="04.cntrl46"name as an alias for string. arg1 through argN are arguments to the alias, appearing in the string definition. When you use the alias, you must provide values for the arguments, which dbx then substitutes in string.The simplest form of an alias is to redefine a dbx command with a short alias. Many of the predefined dbx aliases fall into this category: "a" is an alias for the assign command, "s" is an alias for the step command. When you use one of these aliases, dbx simply replaces it with the command for which it is an alias. Any arguments that you include on the command line are passed to the command.For example, if you to create "gf" as an alias for the givenfile command, enter:(dbx) alias gf givenfile
(dbx) alias gf
"givenfile"
(dbx) gf
Current givenfile is test
(dbx) gf test2
Process 22545 (test) terminated
Executable /usr/var/tmp/dbx_examples/test2
(dbx) gf
Current givenfile is test2More complex alias definitions require more than the name of a command. In these cases, you must enclose the entire alias definition string in double quotation marks. For example, you can define a brief alias to print the value of a variable that you commonly examine. Note that you must use the escape character (\) to include the double quotation marks as part of the alias definition. For example:(dbx) alias pa "print \"a =\", a"
(dbx) alias pa
"print "a =", a"
(dbx) pa
a = 3You can also define an alias so that you can pass arguments to it, much in the same way that you can provide arguments in a C language macro definition. When you use the alias, you must include the arguments. dbx then substitutes the values that you provide in the alias definition.To illustrate this, consider the following alias definition:(dbx) alias p(arg1, arg2, arg3, arg4) "print '|arg1|arg2|arg3|arg4|'"
(dbx) alias p
(arg1, arg2, arg3, arg4)"print '|arg1|arg2|arg3|arg4|'"The "p" alias takes four arguments and prints them surrounded by vertical bars (|). For example:(dbx) p(1,2,3,4)
|1|2|3|4|
(dbx) p( first, second, 3rd,4)
| first| second| 3rd|4|In the previous example, dbx retains any spaces that you enter when calling an alias.You can also omit arguments when calling an alias as long as you include the commas as argument separators in the alias call:(dbx) p(a,,b,c)
|a||b|c|
(dbx) p(,first missing, preceding space,)
||first missing| preceding space||
(dbx) delete
deleteLBL="" HELPID=""Removing Command AliasesThe ID="04.cntrl47"ID="04.cntrl48"unalias command removes the alias you provide as an argument. For example, to remove the "pa" alias defined in the previous section, enter:(dbx) unalias paYou can remove any of the predefined dbx aliases; however, these aliases are restored the next time you start dbx.LBL="" HELPID=""Alias ExampleOne way to follow linked lists is to use aliases and casts, another is to use the ID="04.cntrl49"duel command (See IDREF="58809" TYPE="TITLE""Using the High-Level Debugging Language duel" in Chapter 5). This example shows how to construct an alias that follows a simple linked list with members defined by the following structure:ID="04.cntrl50"struct list { struct list *next; int value; };In this example, a dbx variable called $p is used as a pointer to a member of the linked list. You can define an alias called "foll" to print the contents of the list member to which $p currently points and then advance to the next list member. Because the command is too long to fit onto one line, this example uses the backslash character (\) to continue the command on a second line:(dbx) alias foll "print *(struct list *)$p ; \
set $p = (long)((struct list *)($p))->next"Casting $p to an integer type when following the link (the second assignment in the alias) is essential. If omitted, dbx may leave the $p reference symbolic and if so, goes into an infinite loop. (Type Ctrl-c to interrupt dbx if it gets into the infinite loop.)Before using this alias, you must set $p to point at the first list member. In this example, assume that the program variable top points to the first list member. Then you can use the "foll" alias to follow the linked list, printing the contents of each member as you proceed:(dbx) set $p = top
(dbx) foll
struct list {
    next = 0x7fffc71c
    value = 57
} 
(dbx) foll
struct list {
    next = 0x7fffc724
    value = 3
} 
(dbx) foll
struct list {
    next = 0x7fffc72c
    value = 12
}LBL="" HELPID=""ID="43528"Recording and Playing Back dbx Input and Outputdbx allows you to play back your input and record ID="04.cntrl51"ID="04.cntrl52"dbx's output. ID="04.cntrl53"ID="04.cntrl54"dbx saves the information that you capture in files, which allows you to create command scripts that you can use in subsequent dbx sessions.LBL="" HELPID=""Recording InputUse the ID="04.cntrl55"record input command to start an input recording session. Once you start an input recording session, all commands to dbx are copied to the specified file. If the specified file already exists, dbx appends the input to the existing file. You can start and run as many simultaneous dbx input recording sessions as you need.Each recording session is assigned a number when you begin it. Use this number to reference the recording session with the unrecord command described in IDREF="30241" TYPE="TITLE""Ending a Recording Session".After you end the input recording session, use the command file with the ID="04.cntrl56"playbackinput or pi commands to execute again all the commands saved to the file. See IDREF="38563" TYPE="TITLE""Playing Back Input".For example, to save the recorded input in a file called script, enter:(dbx) record input script
[4] record input script (0 lines)If you do not specify a file to record input, dbx creates a temporary dbx file in the /tmp directory. The name of the temporary file is stored in the dbx variable ID="04.cntrl57"$defaultin. You can display the temporary filename using the print command:(dbx) print $defaultinBecause the dbx temporary files are deleted at the end of the dbx session, use the temporary file to repeat previously executed dbx commands in the current debugging session only. If you need a command file for use in subsequent dbx sessions, you must specify the filename when you invoke record input. If the specified file exists, the new input is appended to the file.LBL="" HELPID=""ID="30241"Ending a Recording SessionTo end input or output recording sessions, use the ID="04.cntrl58"ID="04.cntrl59"unrecord command.unrecordID="04.cntrl60" session1 [, session2 ...]Turns off the specified recording session(s) and closes the file(s) involved.ID="04.cntrl61"unrecord allTurns off all recording sessions and closes all files involved.For example, to stop recording session 4, enter the dbx command:(dbx) unrecord 4To stop all recording sessions, enter:(dbx) unrecord allThe dbxID="04.cntrl62"status command does not report on recording sessions. To see whether or not any active recording sessions exist, use the record command described in IDREF="22428" TYPE="TITLE""Examining the Record State".LBL="" HELPID=""ID="38563"Playing Back InputUse ID="04.cntrl63"playback input to execute commands that you recorded with the ID="04.cntrl64"record input command. Two aliases exist for playback input: ID="04.cntrl65"pi and ID="04.cntrl66"source.) If you don't specify a filename, dbx uses the current temporary file that it created for the record input command. If you set the dbx variable ID="04.cntrl67"$pimode to nonzero, the commands are printed out as they are played back. By default, $pimode is set to zero.LBL="" HELPID=""Recording OutputUse the ID="04.cntrl68"ID="04.cntrl69"record output command to start output recording sessions within dbx. During an output recording session, dbx copies its screen output to a file. If the specified file already exists, dbx appends to the existing file. You can start and run as many simultaneous dbx output recording sessions as you need.By default, the commands you enter are not copied to the output file; however, if you set the dbx variable ID="04.cntrl70"$rimode to a nonzero value, dbx also copies the commands you enter.Each recording session is assigned a number when you begin it. Use this number to reference the recording session with the unrecord command described in IDREF="30241" TYPE="TITLE""Ending a Recording Session".The record output command is very useful when the screen output is too large for a single screen (for example, printing a large structure). Within dbx, you can use the playback output command (described in IDREF="95547" TYPE="TITLE""Playing Back Output") to look at the recorded information. After quitting dbx, you can review the output file using any IRIX system text viewing command (such as vi(1)).For example, to record the dbx output in a file called gaffa, enter:(dbx) record output gaffaTo record both the commands and the output, enter:(dbx) set $rimode=1
(dbx) record output gaffaIf you omit the filename, dbx saves the recorded output in a temporary file in /tmp. The temporary file is deleted at the end of the dbx session. To save output for use after the dbx session, you must specify the filename when giving the record output command. The name of the temporary file is stored in the dbx variable ID="04.cntrl71"$defaultout. To display the temporary filename, type:(dbx) print $defaultoutLBL="" HELPID=""ID="95547"Playing Back OutputThe playback output command displays output saved with the record output command. This command works the same as the cat(1) command. If you don't specify a filename, dbx uses the current temporary file created for the record output command.For example, to display the output stored in the file script, enter:(dbx) playback output scriptLBL="" HELPID=""ID="22428"Examining the Record StateThe ID="04.cntrl72"record command displays all ID="04.cntrl73"record input and record output sessions currently active. For example:(dbx) record
[4] record input /usr/demo/script (12 lines)
[5] record output /tmp/dbxoXa17992 (5 lines)LBL="" HELPID=""ID="60766"Executing dbx ScriptsYou can create ID="04.cntrl74"dbx command scripts using an external editor and then execute these scripts using the ID="04.cntrl75"pi or ID="04.cntrl76"playback input command. This is a convenient method for creating and executing automated test scripts.You can include comments in your command scripts by using a single pound sign (ID="04.cntrl77"#) to introduce a comment. To include a ID="04.cntrl78"ID="04.cntrl79"# operator (described in IDREF="90268" TYPE="TITLE""Operators") in a dbx script, use two pound signs (for example, ##27). When dbx sees a pound sign in a script file, it interprets all characters between the pound sign and the end of the current line as a comment.LBL="5"ID="80179"Examining and Changing DataThis chapter describes how to examine and change data in your program while running it under dbx. Topics covered include:IDREF="25993" TYPE="TITLE""Using Expressions"IDREF="17137" TYPE="TITLE""Printing Expressions"IDREF="18732" TYPE="TITLE""Using Data Types and Type Coercion (Casts)"IDREF="90553" TYPE="TITLE""Qualifying Names of Program Elements"IDREF="50911" TYPE="TITLE""Displaying and Changing Program Variables"IDREF="26262" TYPE="TITLE""Displaying and Changing Environment Variables Used by a Program"IDREF="58809" TYPE="TITLE""Using the High-Level Debugging Language duel"IDREF="18664" TYPE="TITLE""Determining Variable Scopes and Fully Qualified Names"IDREF="84723" TYPE="TITLE""Displaying Type Declarations"IDREF="50445" TYPE="TITLE""Examining the Stack"IDREF="81639" TYPE="TITLE""Using Interactive Function Calls"IDREF="14169" TYPE="TEXT"IDREF="14169" TYPE="TITLE""Obtaining Basic Blocks Counts"IDREF="19156" TYPE="TITLE""Accessing C++ Member Variables"LBL="" HELPID=""ID="25993"Using ExpressionsMany dbx commands accept one or more expressions as arguments. Expressions can consist of constants, ID="05.change1"dbx variables, program variables, and operators. This section discusses operators and constants. ID="05.change2"ID="05.change3"IDREF="88718" TYPE="TITLE""Creating and Removing dbx Variables" describes dbx variables, and IDREF="50911" TYPE="TITLE""Displaying and Changing Program Variables" describes program variables.LBL="" HELPID=""ID="90268"OperatorsIn general, dbx recognizes most expression operators from C, Fortran 77, and Pascal. dbx also provides some of its own operators. Operators follow the C language precedence. You can also use parentheses to explicitly determine the order of evaluation.ID="05.change4"IDREF="53353" TYPE="TABLE"Table 5-1 lists the operators provided by dbx.COLUMNS="2"LBL="5-1"Table 5-1  (continued)        ID="53353"dbx Language Independent Operators LEFT="0" WIDTH="54"OperatorLEFT="60" WIDTH="252"DescriptionLEFT="0" WIDTH="54"notLEFT="60" WIDTH="252"Unary operator returning false if the operand is trueLEFT="0" WIDTH="54"orLEFT="60" WIDTH="252"Binary logical operator returning true if either operand is 
nonzeroLEFT="0" WIDTH="54"xorLEFT="60" WIDTH="252"Binary operator returning the exclusive-OR of its operandsLEFT="0" WIDTH="54"/LEFT="60" WIDTH="252"Binary division operator ("//" also works for division)LEFT="0" WIDTH="54"divLEFT="60" WIDTH="252"Binary operator that coerces its operands to integers before 
dividingLEFT="0" WIDTH="54"modLEFT="60" WIDTH="252"Binary operator returning op1 modulo op2. This is equivalent 
to the C "%" operatorLEFT="0" WIDTH="54"#expLEFT="60" WIDTH="252"Unary operator returning the address of source line specified 
by expLEFT="0" WIDTH="54""file"#expLEFT="60" WIDTH="252"Unary operator returning the address of source line specified 
by exp in the file specified by fileLEFT="0" WIDTH="54"proc #expLEFT="60" WIDTH="252"Unary operator returning the address of source line specified 
by exp in the file containing the procedure procThe ID="05.change5"# operator takes the line number specified by the expression that follows it and returns the address of that source line. If you precede the # operator with a filename enclosed in quotation marks, the # operator returns the address of the line number in the file you specify. If you precede the # operator with the name of a procedure, dbx identifies the source file that contains the procedure and returns the address of the line number in that file.For example, to print the address of line 27 in the current source file, enter:(dbx) print #27To print the address of line 27 in the source file foo.c (assuming that foo.c contains source that was used to compile the current object file), enter:(dbx) print "foo.c" #27To print the address of line 27 in the source file containing the procedure bar (assuming that bar is a function in the current object file), enter:(dbx) print bar #27NoteA pound sign (ID="05.change6"#) introduces a comment in a ID="05.change7"dbx script file. When dbx sees a pound sign in a script file, it interprets all characters between the pound sign and the end of the current line as a comment. See IDREF="60766" TYPE="TITLE""Executing dbx Scripts" for more information on dbx script files. To include the ID="05.change8"# operator in a dbx script, use two pound signs (for example, ##27).IDREF="76162" TYPE="TABLE"Table 5-2 lists the C language operators recognized by dbx.COLUMNS="2"LBL="5-2"Table 5-2 ID="76162"C Language Operators Recognized by dbx LEFT="0" WIDTH="50"TypeLEFT="55" WIDTH="270"OperatorsLEFT="0" WIDTH="50"UnaryLEFT="55" WIDTH="270"!   &   +   -   *   sizeof()LEFT="0" WIDTH="50"BinaryLEFT="55" WIDTH="270"%   <<   >>   ==   <=   >=   !=   < >   &   &&   |   ||   +   -   * /   [ ]   ->   .NoteC does not allow you to use the sizeof operator on bit fields. However, dbx allows you to enter expressions using the sizeof operator on bit fields; in these cases, dbx returns the number of bytes in the data type of bit fields (such as int or unsigned int). The C language  "^" exclusive-OR operator is not supported. Use the dbx "xor" operator instead.IDREF="89237" TYPE="TABLE"Table 5-3 lists the Pascal operatorsID="05.change9"recognized by dbx.COLUMNS="2"LBL="5-3"Table 5-3 ID="89237"Pascal Operators Recognized by dbx LEFT="0" WIDTH="50"TypeLEFT="55" WIDTH="270"OperatorsLEFT="0" WIDTH="50"UnaryLEFT="55" WIDTH="270"not   ^    +    -LEFT="0" WIDTH="50"BinaryLEFT="55" WIDTH="270"mod   =    <=    >=    <>    <    >   and    or    +    -    *   /    div    [ ]IDREF="97740" TYPE="TABLE"Table 5-4 lists the Fortran 77 and Fortran 90 language operators recognized by ID="05.change10"dbx. Note that dbx does not recognize Fortran logical operators (such as .or. and .TRUE.).COLUMNS="2"LBL="5-4"Table 5-4 ID="97740"Fortran 77 and Fortran 90 Operators Recognized by dbx LEFT="0" WIDTH="50"TypeLEFT="55" WIDTH="171"OperatorsLEFT="0" WIDTH="50"UnaryLEFT="55" WIDTH="171"+    -LEFT="0" WIDTH="50"BinaryLEFT="55" WIDTH="171"+    -    *   /   %NoteFortran array subscripts may be in either square brackets, [ ],  or the standard parenthesis, ( ), and the Fortran 90 member selection operator (%) is allowed.ID="05.change11"LBL="" HELPID=""ConstantsYou can use both numeric and string constants under ID="05.change12"ID="05.change13"dbx.NoteExpressions cannot contain constants defined by ID="05.change14"#define declarations to the C preprocessor.ID="05.change15"LBL="" HELPID=""Numeric ConstantsIn numeric expressions, you can use any valid integer or floating point constants. By default, dbx assumes that numeric constants are in decimal. You can set the default input base to octal by setting the ID="05.change16"ID="05.change17"ID="05.change18"ID="05.change19"dbx variable ID="05.change20"$octin to a nonzero value. You can set the default input base to hexadecimal by setting the ID="05.change21"dbx variable ID="05.change22"$hexin to a nonzero value. If you set both $octin and $hexin to nonzero values, $hexin takes precedence.You can override the default input type by prefixing "0x" to indicate a hexadecimal constant, or "0t" to indicate a decimal constant. For example, "0t23" is decimal 23 (which equals hexadecimal 0x17), and "0x2A" is hexadecimal 2A (which equals decimal 42).By default, ID="05.change23"dbx prints the value of numeric expressions in decimal. You can set the default output base to octal by setting the ID="05.change24"ID="05.change25"dbx variable ID="05.change26"$octints to a nonzero value. You can set the default output base to hexadecimal by setting the ID="05.change27"dbx variable ID="05.change28"$hexints to a nonzero value. If you set both $octints and $hexints to nonzero values, $hexints takes precedence.LBL="" HELPID=""String ConstantsMost dbx expressions cannot include string constants. The ID="05.change29"print and printf commands are two of the dbx commands that accept string constants as arguments. You can also use the ID="05.change30"set command to assign a string value to a dbx variable.Otherwise, string constants are useful only as arguments to functions that you call interactively. See IDREF="81639" TYPE="TITLE""Using Interactive Function Calls" for information on interactive function calls.ID="05.change31"You can use either the double-quotation mark (") or the single-forward quotation mark (') to quote strings in dbx. In general, dbx recognizes the following escape sequences in quoted strings (following the standard C language usage):ID="05.change32"\\ \n \r \f \b \t \' \" \aEnclosing a character string  in back quotation marks (ID="05.change33"`) indicates that the whole string is the name of a program element, not a character-string constant.  This is useful, for example, when referring to C++ templates, which include in their names the greater-than (>) and less-than (<) characters. Without back quotation marks, dbx would attempt to interpret the characters as operators. For further discussion, see the sections IDREF="90553" TYPE="TITLE""Qualifying Names of Program Elements" in this chapter and IDREF="32416" TYPE="TITLE""Referring to C++ Functions" in Chapter 6.LBL="" HELPID=""ID="17137"Printing Expressionsdbx provides the following commands for printing values of expressions:ID="05.change34"printID="05.change35" [exp1 [, exp2, ...] ] Prints the value(s) of the specified expression(s).printd ID="05.change36"[exp1 [, exp2, ... ] ]Prints the value(s) of the specified expression(s) in decimal. (ID="05.change37"pd is an alias for printd. See IDREF="88718" TYPE="TITLE""Creating and Removing dbx Variables" for more information about dbx aliases.)printo ID="05.change38"[exp1 [, exp2, ... ] ]Prints the value(s) of the specified expression(s) in octal. (ID="05.change39"po is an alias for printo.) printx ID="05.change40"[exp1 [, exp2, ... ] ]Prints the value(s) of the specified expression(s) in hexadecimal. (ID="05.change41"px is an alias for printx.)For displaying information about variables, the duel command is a flexible alternative to the print command; see IDREF="58809" TYPE="TITLE""Using the High-Level Debugging Language duel".The variable types are listed in IDREF="60970" TYPE="TABLE"Table 5-5.COLUMNS="3"LBL="5-5"Table 5-5 ID="60970" (continued)        Variable TypesLEFT="0" WIDTH="113"TypeLEFT="120" WIDTH="113"Variable NameLEFT="240" WIDTH="113"ValueLEFT="0" WIDTH="113"signed charLEFT="120" WIDTH="113"scLEFT="240" WIDTH="113"0xffLEFT="0" WIDTH="113"unsigned charLEFT="120" WIDTH="113"uscLEFT="240" WIDTH="113"0xffLEFT="0" WIDTH="113"signed shortLEFT="120" WIDTH="113"sshLEFT="240" WIDTH="113"0xffffLEFT="0" WIDTH="113"unsigned shortLEFT="120" WIDTH="113"ushLEFT="240" WIDTH="113"0xffffExamples include:(dbx) pd sc
-1
(dbx) pd ssh 
-1
(dbx) px sc 
0xff 
(dbx) px ssh
0xffff
(dbx) pd usc
255
(dbx) pd ush
65535dbx always prints the bits in the appropriate type. pd is an exception; it expands signed types with sign extension so the decimal value looks correct. Another example:(dbx) print sc, usc
'\377' '\377'If $hexchars is set, this command displays `0xff' `0xff'. (This is a change from releases previous to IRIX 5.2. Previously, the px, po cases on signed char expanded to 32 bits, so px sc printed 0xffffffff.)If the printed data type is pointer, dbx uses the format specified in the $addrfmt or $addrfmt64 predefined dbx variable ($addrfmt64 is used on only 64-bit processes).printfID="05.change42" string [, exp1 [, exp2, ... ] ] Print the value(s) of the specified expression(s) in the format specified by the string, ID="05.change43"string. The printf command supports all formats of the IRIX printf command except "%s." For a list of formats, see the printf(3S) reference page.LBL="" HELPID=""ID="18732"Using Data Types and Type Coercion (Casts)You can use data types for type conversion (casting) by including the name of the data type in parentheses before the expression you want to cast. For example, to convert a character into an integer, use ID="05.change44"ID="05.change45"(int) to cast the value:(dbx) print (int) 'b'
98To convert an integer into a character, use (char) to cast the value:(dbx) print (char) 67
'C'This is standard C language type casting.LBL="" HELPID=""ID="90553"Qualifying Names of Program ElementsYou can use the same name for different program elements, such as variables, functions, statement labels, several times in a program. This is convenient and, during program execution, the potential ambiguity presents no problem. For example, you can use a temporary counter named "i" in many different functions. The scope of each variable is local; space is allocated for it when the function is called and freed when the function returns. However, in ID="05.change46"ID="05.change47"dbx you sometimes need to distinguish occurrences of identical names.dbx allows unambiguous reference to all program elements by using source file and routine names as qualifying information that makes otherwise indistinguishable names unique. To find the fully qualified name of the active version of a name, use the ID="05.change48"ID="05.change49"which command. To find the fully qualified names of all versions of a name, use the ID="05.change50"whereis command.  Note that if a variable, such as i, is used many times, whereis can generate many lines of output.The fully qualified name of a program element allows you not only to refer within a procedure to variables of the same name with different scopes, but to refer unambiguously to program elements outside your current frame or activation stack. dbx qualifies names with the file (also called module), the procedure, a block, or a structure. You can manually specify the full scope of a variable by separating scopes with periods. For example:mrx.main.iIn this expression, i is the variable name, main is a procedure in which it appears, and mrx is the source file (omitting the file extension) in which the procedure is defined.For languages without `modules,' such as C, C++, and Fortran, the base name of the source file, that is the file name up to the first dot in the name, is taken as a module name. For example, if b is a Fortran subroutine in  t.f, then t.b names the routine.To illustrate how names are qualified, consider a C program called test that contains a function compare. In this example, the variable i is declared in both the main procedure and the compare function:int compare ( int );

main( argc, argv )

int argc;
char **argv;
{
   int i;
...
}

int compare ( arg1, arg2 )
{
   int i;
...
}To trace the value of the i that appears in the function compare, enter:(dbx) trace test.compare.iTo print the value of the i that appears in the procedure main, enter:(dbx) print test.main.iIt is possible to have variable scopes in C and C++ that are in unnamed program blocks. ID="05.change51"dbx provides names for these scopes, starting with __$$blk1 and followed by __$$blk2, __$$blk3, etc, which it places in the fully qualified name of the variable as it would an explicit scope name. The ID="05.change52"whereis and ID="05.change53"which commands show the names assigned.dbx provides a special name __aout for your base executable. So for example, you can use __aout.main to refer to a global C function main in your executable. You can, of course, also refer to the function using the name of your executable; if your executable is named myaout, myaout.main also refers to the global C function main.If you wish to refer to a variable that occurs in a DSO, ID="05.change54"dbx uses a naming convention similar to that for variables in your executable. If, for example, strcpy is a function from the file stuff.c in the library libc.so.1, then both libc.stuff.strcpy and libc.strcpy refer to the function strcpy.In C, ID="05.change55"struct, union, and enum tags can conflict with other names. From the context, dbx usually interprets correctly a reference to one of these tags. However, if dbx does not, prefix the tag with the marker __$T_ to prevent confusion with variables or functions. For example; use __$T_foo if you wish to refer to:  struct foo { /* ... */ } In ANSI C, statement label names also can conflict with other names. The ambiguity is removed by applying a prefix ofID="05.change56" __$L_ to the label name. Thus, for example: int myfoo { int x;   x:  goto x; ++x} If you enter: (dbx) print &x The output is the address of the variable x. If you enter: (dbx) print &__$L_x The output is the address of label x. The ­32 compiler provides no debugging information on C labels.To refer to Fortran statement labels you must either use the __$L_  prefix or use back quotation marks to force ID="05.change57"dbx to recognize a numerical label as a name. For example, if you have:do 10  i = 1,10
10 continueBoth of the following commands lists the address of the label: (dbx) print &`10`
(dbx) print &__$L_10You may have multiple source files with the same name, for example myfile.c, that are in different directories. The `module' name myfile may refer to either source file. dbx resolves this ambiguity by prefixing the fully qualified file names with a unique, numeric label. The which and whereis commands show the label used. For example, suppose the main executable has two myfile.c source files, then __aout.myfile refers to either source file, __aout._$1_myfile refers to one of them, and __aout._$2_myfile refers to the other.A leading dot (a period at the beginning of the identifier) tells dbx that the first qualifier is not a module (file).The leading dot is useful when a file and a procedure have the same name. For instance, suppose mrx.c contains a function called mrx. Further, suppose that mrx.c contains a global variable called mi and a local variable, also called mi. To refer to the global variable, use the qualified form .mrx.mi, and to refer to the local variable, use the qualified form mrx.mrx.mi.LBL="" HELPID=""ID="50911"Displaying and Changing Program VariablesYou can use the value of program variables in ID="05.change58"dbx expressions. You can also change the value of program variables while running your program under dbx control.LBL="" HELPID=""Variable ScopeYou can access the value of a variable only while it is in scope. The variable is in scope only if the block or procedure with which it is associated is active.ID="05.change59"After you start your program, whenever your program executes a block or procedure that contains variables, your program allocates space for those variables and they "come into scope." You may access the values of those variables as long as the block or procedure is active. Once the block or procedure ends, the space for those variables is deallocated and you may no longer access their values.LBL="" HELPID=""ID="85784"Displaying the Value of a VariableYou can display the value of a program variable using the ID="05.change60"ID="05.change61"print, ID="05.change62"printd, ID="05.change63"printf, ID="05.change64"printo, and ID="05.change65"printx commands and the ID="05.change66"pd, ID="05.change67"po, and ID="05.change68"px aliases described in IDREF="17137" TYPE="TITLE""Printing Expressions". For example, to print the value of the program variable total, enter:(dbx) print total
235The print command also displays arrays, structures, and other complex data structures. For example, if message is a character array (a string), dbx prints the string:(dbx) print message
"Press <Return> to continue."As a more complex example, consider a simple linked list stored as an array of elements, each element consisting of a pointer to the next element and an integer value. If the array is named list, print the entire array by entering:(dbx) print arraydbx prints the value of each element in the array:{
    [0] struct list {
        next = (nil)
        value = 1034
    }
    [1] struct list {
        next = 0x10012258
        value = 1031
    }
    [2] struct list {
        next = 0x10012270
        value = 1028
    }
    [3] struct list {
        next = 0x10012288
        value = 1025
    }
    [4] struct list {
        next = 0x100122a0
        value = 1022
    }
    [5] struct list {
        next = 0x100122b8
        value = 1019
    }
...
}To print an individual element, enter a command such as:(dbx) print array[5]
struct list {
    next = 0x100122b8
    value = 1019
}If your array consists of simple elements such as integers or floating point values, you can directly examine the contents of memory using the /ID="05.change69" (examine forward) command described in IDREF="51451" TYPE="TITLE""Examining Memory and Disassembling Code".Suppose a single-precision floating point array is named float_vals. To see the six consecutive elements beginning with the fifth element, enter:(dbx) &float_vals[4] / 6f
10012018:  0.25000000000000000 0.20000000298023224 0.16666699945926666
0.14280000329017639
10012028:  0.12500000000000000 0.11111100018024445You can also print parts of arrays and complex structures with duel, a high-level debugging language. For more information, see IDREF="58809" TYPE="TITLE""Using the High-Level Debugging Language duel."LBL="" HELPID=""Changing the Value of a VariableThe ID="05.change70"ID="05.change71"assign command changes the value of existing program variables. You can also use the assign command to change the value of machine registers, as described in IDREF="34959" TYPE="TITLE""Changing Register Values".The syntax of the assign command is:assignID="05.change72" variable = expressionAssigns the value of expression to the program variable, variable.For example:(dbx) assign x = 27
27
(dbx) assign y = 37.5
37.5If you receive an incompatible types error when you try to assign a value to a pointer, use casts to make the assignment work. For example if next is a pointer to a structure of type "element," you can assign next a null pointer by entering:(dbx) assign *(int *) (&next) = 0
0
(dbx) assign next = 0
(nil)
(dbx) assign next = (struct list*) 0;
(nil)In this example, nil denotes that the value of the pointer is 0; nil is similar to NULL in the C language.LBL="" HELPID=""Conflicts Between Variable Names and KeywordsWhen naming variables in your program, avoid using any ID="05.change73"dbx keywords. If you have a variable with the same name as a dbx keyword and you attempt to use that variable in a dbx command, dbx reports a syntax error.If you do have a program variable with the same name as a dbx command, you can force dbx to treat it as a variable by enclosing the variable in parentheses. For example, if you try to print the value of a variable named in by entering the following command, dbx displays an error.(dbx) print inprint in
      ^ syntax error
Suggestion: in is a dbx keyword; a revised command is in history.
Type !16 or !! to execute: print (in)The correct way to display the value of input is to enter:(dbx) print (in)
34dbx keywords include:all    not
and    or
at     pgrp
div    pid
if     sizeof
in     to
mod    xorLBL="" HELPID=""Case Sensitivity in Variable NamesWhether or not ID="05.change74"dbx is case sensitive when it evaluates program variable names depends on the value of the dbx variable ID="05.change75"$casesense.If $casesense is 2 (the default), then the language in which the variable was defined is taken into account (for example, C and C++ are case sensitive while Pascal and Fortran are not). If $casesense is 1, case is always checked. If $casesense is 0, case is always ignored. Note that file (module) names are always case sensitive since they represent UNIX file names.LBL="" HELPID=""ID="26262"Displaying and Changing Environment Variables Used by a ProgramYou can control the values of environment variables used by a program without affecting the shell. The dbx commands printenv, setenv, and unsetenv control the debugging environment much like their csh counterparts control the shell environment. However, they only affect your program while it is being debugged. dbx passes the values shown by the printenv command to the shell as the environment to use while your program is run by the run or rerun commands. The following commands control your program's environment variables:    ID="05.change76"printenvPrints the list of environment variables affecting the program being debugged.ID="05.change77"setenvSame as printenv.setenv VARSets the environment variable VAR to an empty value.setenv VAR valueSets the environment variable VAR to value, where value is not a dbx variable.setenv VAR $varSets the environment variable VAR to $var, where $var is a dbx variable.setenv VAR "charstring"Sets the environment variable VAR to charstring. ID="05.change78"unsetenv VARRemoves the specified environment variable.If you attempt to change the environment variables PAGER or EDITOR, the effect on dbx is undefined; the new values may, or may not, affect how dbx runs.LBL="" HELPID=""ID="58809"Using the High-Level Debugging Language duel The ID="05.change79"duel language is a high-level debugging language that you can invoke from dbx. duel is an acronym for Debugging U (might) Even Like. The duel language provides the following commands for printing parts of arrays and complex structures:duelInvokes the duel debugging language.duel aliasShows all current duel aliases.duel clearDeletes all duel aliases. To invoke duel from within dbx, type:(dbx) duelFor example, to print the array elements x[1] to x[10] that are greater than 5, enter:(dbx) duel x[1..10] >? 5
x[3] = 14
x[8] = 6The output includes the values 14 and 6, as well as their symbolic representation x[3] and x[8].LBL="" HELPID=""Using duel Quick StartThe ID="05.change80"duel language is implemented by adding the duel command to dbx. All dbx commands work as before. The duel command, however, is interpreted by duel, and its concepts are not understood by other dbx commands.NoteThis version of duel does not understand or allow interactive function calls.duel is based on expressions that return multiple values. The x..y operator returns the integers from x to y; the x,y operator returns x and then y. For example:(dbx) duel (1,9,12..15,22)This command prints 1, 9, 12, 13, 14, 15, and 22. You can use such expressions wherever a single value is used. For example: (dbx) duel x[1,9,12..15,22] This command prints elements 1, 9, 12, 13, 14, 15, and 22 of the array x. duel incorporates C operators, and casts C statements as expressions.The semicolon (;) prevents duel output. duel aliases are defined with x:=y and provide an alternative to variable declaration. You can also return x[i] instead of using printf:(dbx) duel if(x[i:=0..99]<0) x[i]
x[i] = -4The symbolic output x[i] can be fixed by surrounding i with {}. For example:(dbx) duel if(x[i:=0..99]<0) x[{i}]
x[7] = -4The {} are like (), but force the symbolic evaluation to use i's value, instead of i. You can usually avoid this altogether with direct duel operators:(dbx) duel x[..100] <? 0
x[7] = -4The ..n operator is a shorthand for 0..n-1. For example, ..100 is the same as 0..99. The x<?y, x==?y, x>=?y, and so forth, operators compare their left side operand to their right side operand as in C, but return the left side value if the comparison result is true. Otherwise, they look for the next values to compare, without returning anything.duel's x.y and x->y allow an expression y, evaluated under x's scope:(dbx) duel emp[..100].(if(code>400) (code,name))
emp[46].code = 682
emp[46].name = "Ela"The if() expression is evaluated under the scope of each element of emp[], an array of structures. In C language terms, we have to write:for(i = 0; i < 100; i++ ) {
  if(emp[1].code > 400) {
    printf("%d %s\n",emp[i].cond,emp[i].name);A useful alternative to loops is the x=>y operator. It returns y for each value of x, setting the underbar (_) to reference x's value. For example: (dbx) ..100 => if(emp[_].code>400) emp[_].code,emp[_].name Using _ instead of i also avoids the need for {i}. Finally, the x-->y operator expands lists and other data structures. If head points to a linked list threaded through the next field, then:(dbx) duel head-->next->data 
head->data = 12
head->next->data = 14
head-->next[[2]]->data = 20
head-->next[[3]]->data = 26This produces the data field for each node in the list. x-->y returns x, x->y, x->y->y, x->y->y->y, ... until a NULL is found. The symbolic output x-->y[[n]] indicates that ->y was applied n times. x[[y]] is also the selection operator: (dbx) duel head-->next[[50..60]]->data This example returns the 50th through the 60th elements in the list. The #/x operator counts the number of values. For example: (dbx) duel #/( head-->next->data >? 50 ) This example counts the number of data elements over 50 on the list. Several other operators, including x@y, x#y, and active call stack access are described in the IDREF="21534" TYPE="TITLE""duel Operators."LBL="" HELPID=""duel Operator SummaryMost ID="05.change81"duel operators have the same precedence as their C counterparts. IDREF="24280" TYPE="TABLE"Table 5-6 lists duel operators in decreasing precedence. COLUMNS="3"LBL="5-6"Table 5-6 ID="24280" (continued)        duel Operator SummaryLEFT="0" WIDTH="61"AssociativityLEFT="70" WIDTH="110"OperatorsLEFT="185" WIDTH="168"DetailsLEFT="0" WIDTH="61"leftLEFT="70" WIDTH="110"{} () [] -> . f() -->LEFT="185" WIDTH="168"x-->y expands x->y x->y->y ...LEFT="0" WIDTH="61"LEFT="70" WIDTH="110"x[[y]] x#y x@yLEFT="185" WIDTH="168"generate x; select, index or stop-at yLEFT="0" WIDTH="61"rightLEFT="70" WIDTH="110"#/ - * & ! ~ ++ -- (cast)LEFT="185" WIDTH="168"#/x number of x valuesLEFT="0" WIDTH="61"LEFT="70" WIDTH="110"frame(n) sizeof(x)LEFT="185" WIDTH="168"reference to call stack activation level nLEFT="0" WIDTH="61"LEFT="70" WIDTH="110"=LEFT="185" WIDTH="168"simple assignmentLEFT="0" WIDTH="61"leftLEFT="70" WIDTH="110"x/y x*y x%yLEFT="185" WIDTH="168"multiply, divide, reminderLEFT="0" WIDTH="61"leftLEFT="70" WIDTH="110"x-y  x+yLEFT="185" WIDTH="168"add, subtractLEFT="0" WIDTH="61"leftLEFT="70" WIDTH="110"x<<y x>>yLEFT="185" WIDTH="168"shift left/rightLEFT="0" WIDTH="61"noneLEFT="70" WIDTH="110"x..y ..y x..LEFT="185" WIDTH="168"..y  0..y-1. x..y return x, x+1...yLEFT="0" WIDTH="61"leftLEFT="70" WIDTH="110"< > <= >= <? >? <=? >=?LEFT="185" WIDTH="168"x>?y return x if x>yLEFT="0" WIDTH="61"leftLEFT="70" WIDTH="110"== != ==? !=?LEFT="185" WIDTH="168"x==?y return x if x=yLEFT="0" WIDTH="61"leftLEFT="70" WIDTH="110"x&yLEFT="185" WIDTH="168"bit-andLEFT="0" WIDTH="61"leftLEFT="70" WIDTH="110"x^yLEFT="185" WIDTH="168"bit-xorLEFT="0" WIDTH="61"leftLEFT="70" WIDTH="110"x|yLEFT="185" WIDTH="168"bit-orLEFT="0" WIDTH="61"leftLEFT="70" WIDTH="110"x&&y &&/xLEFT="185" WIDTH="168"&&/x are all x values nonzero?LEFT="0" WIDTH="61"leftLEFT="70" WIDTH="110"x||y ||/xLEFT="185" WIDTH="168"||/x is any x value nonzero?LEFT="0" WIDTH="61"rightLEFT="70" WIDTH="110"x? y:zLEFT="185" WIDTH="168"for each x, if(x) y else zLEFT="0" WIDTH="61"rightLEFT="70" WIDTH="110"x:=y LEFT="185" WIDTH="168"x:=y set x as a duel alias to yLEFT="0" WIDTH="61"leftLEFT="70" WIDTH="110"x,yLEFT="185" WIDTH="168"return x, then yLEFT="0" WIDTH="61"rightLEFT="70" WIDTH="110"x=>yLEFT="185" WIDTH="168"for each x, evaluate y with x value `_'LEFT="0" WIDTH="61"rightLEFT="70" WIDTH="110"if() else while() for()LEFT="185" WIDTH="168"C statements cast as operatorsLEFT="0" WIDTH="61"leftLEFT="70" WIDTH="110"x;yLEFT="185" WIDTH="168"evaluate and ignore x, return yLEFT="0" WIDTH="61"right        LEFT="70" WIDTH="110",, LEFT="185" WIDTH="168"Fortran multi-dimensional array 
separator: x[7,,5]. Note the square 
brackets; x(7,,5) will not work in duel.LBL="" HELPID=""duel EXAMPLESID="05.change82"IDREF="17561" TYPE="TABLE"Table 5-7 lists and briefly explains duel examples. COLUMNS="2"LBL="5-7"Table 5-7 ID="17561" (continued)        duel ExamplesLEFT="0" WIDTH="166"ExampleLEFT="175" WIDTH="166"ExplanationLEFT="0" WIDTH="166"duel (0xff-0x12)*3LEFT="175" WIDTH="166"compute simple expressionLEFT="0" WIDTH="166"duel (1..10)*(1..10)LEFT="175" WIDTH="166"display multiplication tableLEFT="0" WIDTH="166"duel x[10..20,22,24,40..60]LEFT="175" WIDTH="166"display x[i] for the selected indexesLEFT="0" WIDTH="166"duel x[9..0]LEFT="175" WIDTH="166"display x[i] backwardsLEFT="0" WIDTH="166"duel x[..100] >? 5LEFT="175" WIDTH="166"display x[i] that are greater than 5LEFT="0" WIDTH="166"duel x[..100] >? 5 <? 10LEFT="175" WIDTH="166"display x[i] if 5<x[i]<10LEFT="0" WIDTH="166"duel x[..100] ==? (6..9)LEFT="175" WIDTH="166"same as aboveLEFT="0" WIDTH="166"duel x[0..99]=>if(_>5 && _<10) _LEFT="175" WIDTH="166"same as aboveLEFT="0" WIDTH="166"duel y[x[..100] !=? 0]LEFT="175" WIDTH="166"display y[x[i]] for each nonzero x[i]LEFT="0" WIDTH="166"duel emp[..50].codeLEFT="175" WIDTH="166"display emp[i].code for i=0 to 49LEFT="0" WIDTH="166"duel emp[..50].(code,name)LEFT="175" WIDTH="166"display emp[i].code & emp[i].nameLEFT="0" WIDTH="166"duel val[..50].(is_dbl? x:y)LEFT="175" WIDTH="166"display val[i].x or val[i].y depending on 
val[i].is_dbl.LEFT="0" WIDTH="166"duel val[..50].if(is_dbl) x else yLEFT="175" WIDTH="166"same as aboveLEFT="0" WIDTH="166"duel (hash[..1024]!=?0)->scopeLEFT="175" WIDTH="166"hash[i].scope for non-null hash[i]LEFT="0" WIDTH="166"duel x[i:=..100] >? x[i+1]LEFT="175" WIDTH="166"check if x[i] is not sortedLEFT="0" WIDTH="166"duel x[i:=..100] ==? x[j:=..100]=>  if(i<j) 
x[{i,j}]LEFT="175" WIDTH="166"check if x has nonunique elementsLEFT="0" WIDTH="166"duel if(x[i:=..99] ==  x[j:=i+1..99]) x[{i,j}]LEFT="175" WIDTH="166"same as aboveLEFT="0" WIDTH="166"duel (x[..100] >? 0)[[0]]LEFT="175" WIDTH="166"the 1st (0th element) positive x[i] LEFT="0" WIDTH="166"duel (x[..100] >? 0)[[2]]LEFT="175" WIDTH="166"return the 3rd positive x[i] LEFT="0" WIDTH="166"duel (x[..100] >? 0)[[..5]]LEFT="175" WIDTH="166"return the first 5 positive x[i]LEFT="0" WIDTH="166"duel (x[0..] >? 6)[[0]]LEFT="175" WIDTH="166"return the first x[i]>6, no limit on iLEFT="0" WIDTH="166"duel argv[0..]@0LEFT="175" WIDTH="166"argv[0] argv[1] .. until first nullLEFT="0" WIDTH="166"duel x[0..]@20 >? 9LEFT="175" WIDTH="166"x[0..n]>9 where n is first x[n]==20LEFT="0" WIDTH="166"duel emp[0..]@(code==0)LEFT="175" WIDTH="166"emp[0]..emp[n-1] where 
emp[n].code==0LEFT="0" WIDTH="166"duel head-->next->valLEFT="175" WIDTH="166"val of each element in a linked listLEFT="0" WIDTH="166"duel head-->next[[20]]LEFT="175" WIDTH="166"the 21st element of a linked listLEFT="0" WIDTH="166"duel *head-->next[[20]]LEFT="175" WIDTH="166"display above as a structLEFT="0" WIDTH="166"duel #/head-->nextLEFT="175" WIDTH="166"count elements on a linked listLEFT="0" WIDTH="166"duel x-->y[[#/x-->y - 1]]LEFT="175" WIDTH="166"last element of a linked listLEFT="0" WIDTH="166"duel x-->y[[#/x-->y - 10..1]]LEFT="175" WIDTH="166"last 10 elements of a linked listLEFT="0" WIDTH="166"duel head-->next->  if(next) val >? 
next->valLEFT="175" WIDTH="166"check if the list is sorted by valLEFT="0" WIDTH="166"duel head-->(next!=?head)LEFT="175" WIDTH="166"expand cyclic linked list (tail->head)LEFT="0" WIDTH="166"duel head-->(next!=?_)LEFT="175" WIDTH="166"handle termination with p->next==p LEFT="0" WIDTH="166"duel root-->(left,right)->keyLEFT="175" WIDTH="166"expand binary tree, show keysLEFT="0" WIDTH="166"duel root-->(left,right)->(  
(left!=?0)->key>=?key, (right !=?0 
)->key<=?key)LEFT="175" WIDTH="166"check bin tree sorted by keyLEFT="0" WIDTH="166"duel (T mytype) xLEFT="175" WIDTH="166"convert x to user defined type mytypeLEFT="0" WIDTH="166"duel (struct s*) xLEFT="175" WIDTH="166"convert x to struct s pointerLEFT="0" WIDTH="166"duel if(x) y; else z *ERR*LEFT="175" WIDTH="166"`;' must be followed by an expressionLEFT="0" WIDTH="166"duel {x} y *ERR*LEFT="175" WIDTH="166"`}' requires `;' if followed by expLEFT="0" WIDTH="166"fortarray[2..5,, 6,7] LEFT="175" WIDTH="166"print 2-dimensional Fortran array 
elementsLBL="" HELPID=""duel SEMANTICSThe ID="05.change83"duel semantics are modeled after the Icon programming language. The input consists of expressions that return sequences of values. C statements are cast as expressions, too. Expressions are parsed into abstract syntax trees, which are traversed during evaluation. The evaluation of most nodes (operators) recursively evaluates the next value for each operand, and then applies the operator to produce the next result. Only one value is produced each time, and duel's eval function keeps a state for each node (backtracking, co-routines, consumer-producer or threads are good metaphors for the evaluation mechanism).For example, in (5,3)+6..8, the evaluation of `+' first retrieves the operands 5 and 6, to compute and return 5+6. Then 7, the next right operand is retrieved and 5+7 is returned, followed by 5+8. Since no other right operand value exists, the next left operand, 3 is fetched. The right operand's computation is restarted returning 6, and 3+6 is returned. The final return values are 3+7 and 3+8.The computation for operators like x>?y is similar, but when x<=y, the next values are fetched instead of returning a value, forming the basis for an implicit search. Operators like .. return a sequence of values for each pair of operands.The duel values follow the C semantics. A value is either an lvalue (can be used as the left-hand side of assignment), or an rvalue. Therefor, objects like arrays can not be directly manipulated. However, operators like x..y can accomplish such tasks. The duel types also follow the C semantics, with some important differences. C types are checked statically; duel types are checked when operators are applied. For example, (1,1.0)/2 returns 0 (int) and 0.5 (double); (x,y).z returns x.z and y.z even if x and y are of different types, as long as they both have a field z.Values and types of symbols are looked up at run-time (using the dbx lookup rules).To avoid this ambiguity, the keyword T must precede a user-defined type. For example, if value is a typedef, C's (value (*)()) x is written in duel as (T value (*)()) x. Types that begin with a reserved keyword don't need T. For example, (struct value*) x and (long *[5]) y are accepted. As special cases, (type)x and (type*)x are accepted but discouraged (it causes (printf)("hi"), which is valid in C, to fail). A side effect is that sizeof x must be written as sizeof(x).LBL="" HELPID=""ID="21534"duel OperatorsThe ID="05.change84"duel operators are described below.x=y x+y x-y x*y x/y x%y x^y x|y x&y x<<y x>>yx>y x<y x>=y x<=y x==y x!=y  x[y] These binary operators follow their C semantics. For each value of x, they are evaluated for every value of y. For example, (5,2)>(4,1) evaluates as 5>4, 5>1, 2>4, 2>1 returning 1, 1, 0, 1.The y values are reevaluated for each new value of x. For example, i=4; (4,5)>i++ evaluates as 4>4 and 5>5. Beware of multiple y values in assignment. For example, x[..3]=(4,6,9) does not set x[0]=4, x[1]=6, and x[2]=9. It assigns 4, 6, and 9 to each element, which has the same effect as x[..3]=9. Use x[i:=..3]=(4,6,9)[[i]] to achieve the desired effect.-x ~x &x *x !x ++x --x x++ x-- sizeof(x) (type)x These unary operators follow their C semantics. They are applied to each value of x. The increment and decrement operators require an lvalue, so i:=0 ; i++ produces an error because i is a duel alias to 0, an rvalue. Parenthesis must be used with sizeof(x). Note that sizeof x is not allowed. Cast to user defined type requires generally requires T. For example, (T val(*)())x, but (val)x and (val*)x are accepted as special cases. x&&y   x||y These logical operators also follow their C semantics, but have nonintuitive results for multi-valued x and y. For example, (1,0,0) || (1,0) returns 1,1,0,1,0 ­ the right hand-side (1,0) is returned for each left-hand side 0. It is best to use these operators only in single value expressions. x? y:z   if(x)y   if(x)y else z These expressions return the values of y for each nonzero value returned by x, and the values of z for each zero value returned by x. For example, if(x[..100]==0) y returns y for every x[i]==0, not if all x[i] are zero (if(&&/(x[..100]==0)); y does that). Also, if(x) y; else z is illegal. duel's semicolon is an expression separator, not a terminator. while(x)y   for(w;x;y)z The while(x)y expression returns y as long as all values of x are nonzero. The for() expression is similar and both have the expected C semantics. For example, for(i=0 ; i<100 ; i++) x[i] is the same as x[..100]. Unlike the if() expression, while(x[..100]==0) continues to execute only if all elements of x are zero, that is, the condition is evaluated into a single value using an implicit &&/x. At present, assignments are not supported, so the for is of limited utility except to assign aliases. x,y   x..y   ..xx..These operators produce multiple values for single value operands. x,y returns x, then y. x..y returns the integers from x to y. When x>y, the sequence is returned in descending order, that is, 5..3 returns 5, 4, 3. The ..x operator is a shorthand for 0..x-1. For example, ..3 returns 0, 1, 2. The x.. operator is a shorthand for x..maxint. It returns increasing integer values starting at x indefinitely, and should be bounded by [[n]] or @n operators.A comma (,) retains its precedence level in C. The precedence of ..  is above < and below arithmetic operators, so 0..n-1 and x==1..9 work as expected.x,,yThe ,, operator is very low precedence, is only usable inside the [] array operators, and is used to separate the dimension expressions of Fortran multi-dimensional arrays. Note the deviation from Fortran and ID="05.change85"dbx command-line usage; array operators are square brackets, [ ], not parentheses, ( )x<?y x>?y x>=?y x<=?y x!=?y x==?y These operators work like their C counterparts but return x if the comparison is true. If the comparison is false, the next (x,y) value is tried, forming the basis of an implicit search.(x) {x} x;y x=>y Both () and {} act as C parenthesis. The {} set the returned symbolic value as the actual value. For example, if i=5 and x[5]=3, then x[i] produces the output x[i] = 3, x[{i}] produces x[5] = 3, and {x[i]} produces 3. The semicolon is an operator. x;y evaluates x, ignoring the results, then evaluates and returns y. For example, (i:=1..3 ; i+5) sets i to 3 and returns 8. The x=>y operator evaluates and returns y for each value of x. For example, (i:=1..3 => i+5) returns 6, 7, and 8. The value returned by x is also stored implicitly in _, which can be used in y. For example, 1..5 => z[_][_] produces z[1][1], z[2][2], and so forth. The symbolic value for _ is that of the left side value, hence {_} is not needed.Semicolon (;) has the lowest precedence, so it must be used inside () or {} for compound expressions. The precedence of => is just below comma (,).Be aware that if(a) x; else {y;} z is illegal; a semicolon is not allowed before } or else and must be inserted before z. x->y   x.y These expressions work as in C for a symbol y. If y is an expression, it is evaluated under the scope of x. For example, x.(a+b) is the same as x.a+x.b, if a and b are fields of x (if they are not, they are looked up as local or global variables). x may return multiple values of different types. For example, (u,v).a returns u.a and v.a, even if u and v are different structures.Also, the value of x is available as _ inside y. For example, x[..100].(if(a) _) produces x[i] for each x[i].a!=0. Nested x.y are allowed. For example, u.(v.(a+b)) looks up a and b first under v, then under u. x:=y The duel aliases store a reference to y in x. Any reference to x is then replaced by y. If y is a constant or an rvalue, its value is replaced for x. If y is an lvalue (e.g., a variable), a reference to same lvalue is returned. For example, x:=emp[5] ; x=9 assigns 9 to emp[5].Aliases retain their values across invocation of the duel command. A duel alias to a local variable references a stray address when the variable goes out of scope.The special command duel clear delete all the duel aliases; duel alias shows all current duel aliases. Symbols are looked up as duel aliases first, so a duel alias x will hide a local x. The duel aliases are separate from dbx aliases. Currently, duel aliases are shared across all processes.x-->y The expansion operator x-->y expands a data structure x following the y links.It returns x, x->y, x->y->y, until a null is found. If x is null, no values are produced. If y returns multiple values, they are stacked and each is further expanded in a depth-first notion. For example, if r is the root of a tree with children u->childs[..u->nchilds], then u-->(childs[..nchilds]) expands the whole tree. y is an arbitrary expression, evaluated exactly like x->y (this includes _).x@y The expression x@y produces the values of x until x.y is nonzero. For example, for(i=0 ; x[i].code!= -1 && i<100 ; i++) x[i] can be written as x[..100]@(code==-1). The evaluation of x is stopped as soon as y evaluates to true. x->y (or x=>y) is used to evaluate y when x is not a struct or a union. If y is a constant, (_==y) is used. For example, s[0..]@0 produces the characters in string s up to but not including the terminating null. #/x   &&/x   ||/x These operators return a single summary value for all the values returned by x. The #/x returns the number of values returned by x. For example, #/(x[..100]>?0) counts the number of positive x[i]. The &&/x returns 1 if all the values produced by x are nonzero, and ||/x returns 1 if any of x's values are nonzero. Like in C, the evaluation stops as soon as possible.For example, ||/(x[..100]==0) and &&/(x[..100]==0) check if one or all of x[i] are zero, respectively.x#y x[[y]] The operator x#y produces the values of x and arranges for y to be an alias for the index of each value in x. It is commonly used with x-->y to produce the element's index. For example, head-->next->val#i=i assigns each val field its element number in the list. The selection operator x[[y]] produces the yth result of x. If y returns multiple value, each select a value of x. For example, (5,7,11,13)[3,0,2] returns 13, 5, and 11 (13 is the third element, 5 is the 0th element).Don't use side effects in x, since its evaluation can be restarted depending on y. For example, after (x[0..i++])[[3,5]] the value of i is unpredictable. NoteWithin a duel command, the # operator does not have anything to do with line numbers or dbx comments.frame(n)   frames_no   func.x The frame(n) for an integer n returns a reference to the nth frame, or activation level, on the stack (0 is the inner most function and frame(frames_no-1) is main()). Frame values can be compared to function pointers. For example, frame(3)==myfunc is true if the fourth frame is a call to myfunc, and in scope resolution. For example, frame(3).x returns the local variable x of the fourth frame.The frames_no is the number of active frames on the stack. For example, (frames(..frames_no) ==? myfunc).x displays x for all active invocations of myfunc. As a special case, (frames(..frames_no)==?f)[[0]].x can be written as f.x (x can be an expression). LBL="" HELPID=""Differences from Other LanguagesThe following paragraphs describe the differences between ID="05.change86"duel, C, and Fortran languages.LBL="" HELPID=""Differences from CBoth ID="05.change87"{} and ; are operators, not statements or expression separators. For example, if(x) y; else {z;} u is illegal; use if(x) y else {z} ; u. Ambiguities require preceding user-defined types (typedef) with the keyword T. For example, if value is a user type, C's sizeof(value*) is written sizeof(T value*), except for the casts (t)x and (t*)x; sizeof(x) requires parenthesis for variable x. LBL="" HELPID=""Differences from FortranBecause the comma (ID="05.change88",) is used to separate a sequence of values, the usual dbx syntax for multi-dimensional array references of myarr[3,4] does not mean the same thing to duel as it does to dbx.In duel, refer to the dimensions of a multi-dimensional Fortran array using ,, as the dimension separator. In other words, if myarr is a two-dimensional array, myarr[3,,4] refers to the Fortran array element myarr(3,4).The base dbx syntax for this element remains unchanged. For example, to show that element of myarr, use one of the following:(dbx) print myarr[3,4] 
(dbx) duel  myarr[3,,4] LBL="" HELPID=""ID="18664"Determining Variable Scopes and Fully Qualified NamesThe ID="05.change89"ID="05.change90"which command allows you to determine the scope of a variable. This command is useful for programs that have multiple variables with the same name occurring in different scopes.The which command prints the fully qualified name of the active version of a specified variable. For example, to determine the scope of the variable i, enter:(dbx) which i
.foo.foo2.iIn the example above, the variable i that is currently active is local to the procedure foo2 that appears in the module foo (corresponding to the file foo.c in a C language program). The which command also determines the fully qualified name of other program elements, such as procedures or type descriptors, that are submitted as arguments for the command.The ID="05.change91"whereis command prints the fully qualified names of all versions of the name of any program element. dbx  searches (a possibly limited part of) your program for all occurrences of the name and returns the fully qualified names. The range of the search is determined by the dbx variable ID="05.change92"$whereisdsolimit. By default, $whereisdsolimit is 1 and only the main executable is checked by whereis. To search all objects, set $whereisdsolimit to 0. To check just the first n objects, set $whereisdsolimit to n.LBL="" HELPID=""ID="84723"Displaying Type DeclarationsThe ID="05.change93"ID="05.change94"whatis command displays the type declaration for a specified variable or procedure in your program. For example, to display the type declaration for the variable i, enter:(dbx) whatis i
int i;The following example illustrates the output of whatis for an array of structures:(dbx) whatis array
struct list {
    struct list* next;
    int value;
} array[12];When you provide a procedure name to whatis, dbx reports the type of the value returned by the procedure and the types of all arguments to the procedure:(dbx) whatis foo
int foo(i)
int i;
(dbx) whatis main
int main(argc, argv)
int argc;
char** argv;LBL="" HELPID=""ID="50445"Examining the StackEach time your program executes a procedure, the information about where in the program the call was made from is saved on a stack. The stack also contains arguments to the procedure and all of the procedure's local variables. Each procedure on the stack defines an ID="05.change95"ID="05.change96"activation level or ID="05.change97"frame. Activation levels can also consist of blocks that define local variables within procedures.The most recently called procedure or block is numbered 0. The next active procedure (the one that called the current procedure) is numbered 1. The last activation level is always the main program block.The stack determines the scope of many ID="05.change98"dbx commands and expressions. For example, unless you qualify a variable, as described in ID="05.change99"IDREF="90553" TYPE="TITLE""Qualifying Names of Program Elements"dbx assumes that variables you reference are local to the current activation level. If a variable does not appear in the current activation level, dbx successively examines previous activation levels in the stack until it finds the referenced variable. The maximum number of activation levels examined is determined by the dbx variable $stacktracelimit, which has a default value of 100. LBL="" HELPID=""Printing Stack TracesThe ID="05.change100"ID="05.change101"where command prints stack traces. Stack traces show the current activation levels (procedures) of a program. For example, consider the following stack trace for a program called test:(dbx) where
>  0 foo2(i = 5) ["/usr/var/tmp/dbx_examples/test.c":44, 0x1000109c]
   1 foo(i = 4) ["/usr/var/tmp/dbx_examples/test.c":38, 0x1000105c]
   2 main(argc = 1, argv = 0xffffffad78) ["/usr/var/tmp/dbx_examples/test.c":55, 0x10001104]
   3 __start() ["/shamu/lib/libc/libc_64/crt1text.s":137, 0x10000ee4]This program has four activation levels. The most recent, a call of the procedure foo2, is numbered 0. The currently selected activation level is 0, indicated by the ">" character.The stack trace also reports that foo2 was passed one argument: the value 5 was assigned to the local variable i. The trace indicates that the program was stopped at line 44 of the file test.c, which translates to machine address 0x1000109c.The stack trace reports similar information for the next two activation levels in this example. You can see that the function foo called foo2 from line 38 in test.c. In turn, foo was called by main at line 55 of the file test.c. Finally, the run-time start-up level was called at line 137 from the file ctrltext.s.If a program is highly recursive, stack traces can get quite long. The dbx variable ID="05.change102"$stacktracelimit controls the maximum number of activation levels that appear in a stack trace. In the example above, setting $stacktracelimit = 2 before issuing the where command reduces the set of reported frames to just levels 0 and 1.If you compile with ID="05.change103"­g0 or with no ­g option, limited symbols are reported. In cases such as this, where detailed symbolic information is not available, the four hexadecimal values returned represent dbx's guess that the function has four integer arguments. The following example illustrates such a case:(dbx) where
>  0 fooexample(0x300000000, 0x4000000ff, 0x5000000ff, 0x0) ["/usr/var/tmp/dbx_examples/test3.c":10, 0x10000cf8]
   1 main(0x3, 0x4, 0x5, 0x0) ["/usr/var/tmp/dbx_examples/test3.c":5, 0x10000cbc]
   2 __start() ["/shamu/lib/libc/libc_64/csu/crt1text.s":137, 0x10000c64]
(dbx) quit
Process 22582 terminated
int fooexample(int,int,int);
int main()
{
       fooexample(3,4,5);
       return 0;
}
int fooexample(int i, int j, int k)
{
       int x = i + j + 3*k;
       return x;
}The examples below show register values from code compiled without a ID="05.change104"­g option. MIPS1 or MIPS2 code using the 32-bit ABI (for example, on an Indy):(dbx) where
> 0 subr1(0x3, 0x7fffaf14, 0x7fffaf1c, 0x0) ["t.c":3, 0x4009ec]
  1 test(0x3, 0x7fffaf14, 0x7fffaf1c, 0x0) ["t.c":8, 0x400a10]
  2 main(0x1, 0x7fffaf14, 0x7fffaf1c, 0x0) ["t.c":13, 0x400a48]
  3 __start() ["crt1text.s":133, 0x40099c]There are four hexadecimal values displayed in most lines of the code above since the 32-bit MIPS ABI has four integer argument passing registers. No user-useful registers are passed to __start().MIPS3 or MIPS4 code using the 64-bit ABI (for example, on a Power Challenge):(dbx) where
> 0 subr1(0x3, 0xffffffaed8, 0xffffffaee8, 0x0, 0x2f, 0x10, 0x0, 0xfbd82a0) ["/usr/people/doc/debug/t.c":3, 0x10000c9c]
  1 test(0x3, 0xffffffaed8, 0xffffffaee8, 0x0, 0x2f, 0x10, 0x0, 0xfbd82a0) ["/usr/people/doc/debug/t.c":9, 0x10000ce8]
  2 main(0x1000000ff, 0xffffffaed8, 0xffffffaee8, 0x0, 0x2f, 0x10, 0x0, 0xfbd82a0) ["/usr/people/doc/debug/t.c":14, 0x10000d2c]
  3 __start() ["/shamu/redwood2/work/irix/lib/libc/libc_64/csu/crt1text.s":137, 0x10000c70]There are eight hexadecimal values displayed in most lines of the code above since the 64-bit MIPS ABI has eight integer argument passing registers. No user-useful registers are passed to __start().The values listed as arguments are the integer argument-passing register values. Typically, only the 0 entry of the stack has those argument values correct. Correctness is not guaranteed because the code generator can overwrite the values, using the registers as temporary variables.The debugger reports the integer argument-passing registers because this information may be of some value.For example, for the code samples above, the following code calls subr1():int test(void)
{
     subr1(3);
}This code displays 0x3 as the argument register value. The other registers listed for subr1 contain arbitrary data.LBL="" HELPID=""ID="88379"Moving Within the StackThe ID="05.change105"up and ID="05.change106"down commands move up and down the activation levels in the stack. These commands are useful when examining a call from one level to another. You can also move up and down the activation stack with the ID="05.change107"ID="05.change108"func command described in IDREF="82062" TYPE="TITLE""Moving to a Specified Procedure".The up and down commands have the following syntax:up [num] Moves up the specified number of activation levels in the stack. The default is one level.down [num] Moves down the specified number of activation levels in the stack. The default is one level.When you change activation levels, your scope changes. For example, unless you qualify a variable, as described in ID="05.change109"IDREF="90553" TYPE="TITLE""Qualifying Names of Program Elements", dbx assumes that variables you reference are local to the current activation level. Also, dbx changes the current source file to the file containing the procedure's source.ID="05.change110"Consider examining the stack trace for a program called test4 and moving up in the activation stack:(dbx) where
>  0 foo2(i = 5) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]
   1 foo(i = 4) ["/usr/var/tmp/dbx_examples/foo.c":40, 0x100011d4]
   2 main(argc = 1, argv = 0xffffffad78) ["/usr/var/tmp/dbx_examples/test4.c":25, 0x10000fa0]
   3 __start() ["/shamu/lib/libc/libc_64/csu/crt1text.s":137, 0x10000f34]
(dbx) print i
5
(dbx) up 
foo:  40  r = foo2(i+1);The current activation level is now the procedure foo. As indicated in the output, the variable i receives the argument passed to foo and is therefore local to foo. The variable i at this activation level is different from the variable i in the foo2 activation level. You can reference the currently active i as "i"; whereas you must qualify the reference to the i in foo2:(dbx) print i
4
(dbx) print foo2.i
<symbol not found>Moving up one more activation level brings you to the main procedure:(dbx) up
main:  25  j = foo(j);
(dbx) file
/usr/var/tmp/dbx_examples/test4.cIn this example, the source for main is in test4.c, whereas the source for foo and foo2 is in foo.c; therefore, dbx changes the current source file when you move up to the main activation level.dbx resets the source file when you return to the foo2 activation level:(dbx) down 2
foo2:  46  printf("foo2 arg is %d\n",i);
(dbx) file
/usr/var/tmp/dbx_examples/foo.cLBL="" HELPID=""ID="82062"Moving to a Specified ProcedureThe ID="05.change111"func command moves you up or down the activation stack. You can specify the new activation level by providing either a procedure name or an activation level number.ID="05.change112"The syntax for the func command is:funcID="05.change113" {activation_level | procedure} Changes the current activation level. If you specify an activation level by number, dbx changes to that activation level. If you specify a procedure, dbx changes to the activation level of that procedure. If you specify a procedure name and that procedure has called itself recursively, dbx changes to the most recently called instance of that procedure.funcID="05.change114" Displays the name of the procedure corresponding to the current activation level.When you change your activation level, your scope changes. For example, unless you qualify a variable as described in ID="05.change115"IDREF="90553" TYPE="TITLE""Qualifying Names of Program Elements", dbx assumes that variables you reference are local to the current activation level. Also, dbx changes the current source file to the one containing the procedure's source and the current line to the first line of the procedure.You can also give the func command the name of a procedure that is not on the activation stack, even when your program is not executing. In this case, dbx has no corresponding activation level to make current. However, dbx still changes the current source file to the one containing the procedure's source and the current line to the first line of the procedure.For example, consider the following activation stack:(dbx) where
>  0 foo2(i = 5) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]
   1 foo(i = 4) ["/usr/var/tmp/dbx_examples/foo.c":40, 0x100011d4]
   2 main(argc = 1, argv = 0xffffffad78) ["/usr/var/tmp/dbx_examples/test4.c":25, 0x10000fa0]
   3 __start() ["/shamu/lib/libc/libc_64/csu/crt1text.s":137, 0x10000f34]In this case, you can go to the main activation stack by entering:(dbx) func main
main:  25  j = foo(j);This command changes the current activation level to "2" and changes the current source file to test4.c.If you use the func command to go to a function that is not on the activation stack, dbx changes only the current source file to the one containing the procedure's source and the current line to the first line of the procedure:(dbx) func bar
   3  {
(dbx) file
/usr/var/tmp/dbx_examples/bar.cLBL="" HELPID=""Printing Activation Level InformationThe ID="05.change116"dump command prints information about the variables in an activation level:ID="05.change117"dumpID="05.change118" Prints information about the variables in the current procedure.dumpID="05.change119" procedure Prints information about the variables in the specified procedure. The procedure must be active. Starts searching for procedure at the current activation level as set by the up or down command. (See IDREF="88379" TYPE="TITLE""Moving Within the Stack" for more information about the up and down commands.)dump .ID="05.change120" Prints information about the variables in all procedures in all activation levels.For example, executing dump while in a function called foo2 appears as:(dbx) dump
foo2(i = 5) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]To examine the information for the procedure main, enter:(dbx) dump main
main(argc = 1, argv = 0xffffffad78) ["/usr/var/tmp/dbx_examples/test4.c":25,
0x10000fa0]
j = 4
i = 12
r = <expression or syntax error>
a = 0
total = 0To perform a complete dump of the program's active variables, enter:(dbx) dump .
>  0 foo2(i = 5) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]
   1 foo(i = 4) ["/usr/var/tmp/dbx_examples/foo.c":40, 0x100011d4]
r = 0
   2 main(argc = 1, argv = 0xffffffad78) ["/usr/var/tmp/dbx_examples/test4.c":25, 0x10000fa0]
j = 4
i = 12
r = <bad operand>
a = 0
total = 0LBL="" HELPID=""ID="81639"Using Interactive Function CallsYou can interactively call a function in your program from ID="05.change121"dbx.If the function returns a value, you can use that function in a normal dbx expression. For example, consider a function prime defined in your program that accepts an integer value as an argument, and returns 1 if the value is prime and 0 if it is not. You can call this function interactively and print the results by entering a command such as:(dbx) print prime(7)
1LBL="" HELPID=""Using ccallIf your function does not return a value, or if you want to execute a function primarily for its side effects, you can execute the function interactively with the dbx command ccall:ccallID="05.change122" func(arg1, arg2, ... , argn) This command calls a function with the given arguments. Regardless of the language the function was written in, the call is interpreted as if it were written in C, and normal C calling conventions are used.ID="05.change123"NoteStructure and union arguments to a function, and structure and union returns from a function, are not supported.Functions called interactively honor breakpoints. Thus you can debug a function by setting breakpoints and then calling it interactively. If you perform a stack trace using the where command while stopped in a routine executed interactively, dbx displays only those activation levels created by your interactive function call. The activation levels for your active program are effectively invisible. For example, a stack trace looks like this during an interactive function call:(dbx) where
>  0 foo2(i = 9) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]
   1 foo(i = 8) ["/usr/var/tmp/dbx_examples/foo.c":40, 0x100011d4]

===== interactive function call =====

   2 foo2(i = 5) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]
   3 foo(i = 4) ["/usr/var/tmp/dbx_examples/foo.c":40, 0x100011d4]
   4 main(argc = 1, argv = 0xffffffad78) ["/usr/var/tmp/dbx_examples/test4.c":25, 0x10000fa0]
   5 __start() ["/shamu/lib/libc/libc_64/csu/crt1text.s":137, 0x10000f34]If you stop execution of an interactively called function, you are responsible for eventually "unstacking" the call and returning from the function call. To unstack a call, you can complete the call using ID="05.change124"ID="05.change125"dbx commands such as cont, resume, next, or step as many times as necessary. If you run or rerun your program, dbx automatically unstacks all interactive function calls.LBL="" HELPID=""Using clearcallsAnother way to unstack an interactive function call is to execute the ID="05.change126"ID="05.change127"clearcalls command, which clears all stopped interactive calls. (dbx) clearcallsWhen stopped or faulted within one or more nested interactive calls, the clearcalls command removes these calls from the stack and returns the program to its regular callstack. This command is useful when a segmentation fault, infinite loop, or other fatal error is encountered within the interactive call.When stopped in an interactive call, the call stack displayed by where shows the following line at the end of each stack of interactive call instantiation. ==== interactive function call ====For example, if the procedure foo() is interactively called from main(), you see the following stack:>  0 foo2(i = 9) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]
   1 foo(i = 8) ["/usr/var/tmp/dbx_examples/foo.c":40, 0x100011d4]

===== interactive function call =====

   2 foo2(i = 5) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]
   3 foo(i = 4) ["/usr/var/tmp/dbx_examples/foo.c":40, 0x100011d4]
   4 main(argc = 1, argv = 0xffffffad78) ["/usr/var/tmp/dbx_examples/test4.c":25, 0x10000fa0]
   5 __start() ["/shamu/lib/libc/libc_64/csu/crt1text.s":137, 0x10000f34]LBL="" HELPID=""Nesting Interactive Function CallsYou can also nest interactive function calls. In other words, if you have one or more breakpoints in a function, and you call that function repeatedly, each interactive call is stacked on top of the previous call. Breakpoints in a function affect all nesting levels, so you cannot have different breakpoints at different nesting levels.ID="05.change128"ID="05.change129"The where command shows the entire stack trace from which you can determine the nesting depth. The following example has two nesting levels.(dbx) where
>  0 foo2(i = 17) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]
   1 foo(i = 16) ["/usr/var/tmp/src/dbx_examples/foo.c":40, 0x100011d4]

===== interactive function call =====

   2 foo2(i = 9) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]
   3 foo(i = 8) ["/usr/var/tmp/dbx_examples/foo.c":40, 0x100011d4]

===== interactive function call =====

   4 foo2(i = 5) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]
   5 foo(i = 4) ["/usr/var/tmp/dbx_examples/foo.c":40, 0x100011d4]
   6 main(argc = 1, argv = 0xffffffad78) ["/usr/var/tmp/src/dbx_examples/test4.c":25, 0x10000fa0]
   7 __start() ["/shamu/lib/libc/libc_64/csu/crt1text.s":137, 0x10000f34]To set a conditional breakpoint, for example, type:(dbx) stop in foo if j == 7
Process     0: [3] stop in foo if j==7If j is not within the scope of foo, then you will receive an error message if you attempt to call foo interactively. To prevent this, disable or delete any such breakpoints, conditional commands, or traces before executing the interactive function call.LBL="" HELPID=""ID="14169"Obtaining Basic Blocks CountsThe ID="05.change130"dbx command allows interactive control of a pixie instrumented binary.pixie clear Clear the basic block counts for the current execution.pixie write Write out the counts file with the current basic block counts. The counts reflect the execution of the program since the run command or since the last pixie clear command, whichever was more recent.When you debug a program that has been instrumented by pixie, it is often desirable to perform experiments over different code paths and do comparisons of the results. You can do this by capturing the pixie basic block counts at any point in the program's execution. Suppose you want to determine the basic block counts for the section of code between lines 10 and 15 of a given file. Just set breakpoints at the two lines of interest, zero the counts when the first breakpoint is encountered, and then write out the counts file when the second breakpoint is encountered. For example:(dbx) stop at "pix.c":15
Process 0: [3] stop at "pix.c":15
(dbx) stop at "pix.c":20
Process 0: [4] stop at "pix.c":20
(dbx) run
Process 997 (pix.pixie) started
[3] Process 997 (pix.pixie) stopped at [main:15 ,0x400a48  (pixie 0x404570)] 15 first = 12;
(dbx) pixie clear
(dbx) cont
[4] Process 997 (pix.pixie) stopped at [main:20 ,0x400aa8 (pixie 0x404684)] 20 total = multiply(total, 2);
(dbx) pixie write
(dbx) sh prof -pixie prog
--------------------------------------------------------------------------
Profile listing generated Tue Feb 14 11:08:46 1995
    with:       prof -pixie prog
--------------------------------------------------------------------------
Total cycles  Total Time  Instructions  Cycles/inst      Clock   Target
          53    5.3e-07s            27        1.963   100.0MHz    R4000

         10: Total number of Load Instructions executed.
         40: Total number of bytes loaded by the program.
          3: Total number of Store Instructions executed.
         12: Total number of bytes stored by the program.

          2: Total number nops executed in branch delay slot.
          0: Total number conditional branches executed.
          0: Total number conditional branches actually taken.
          0: Total number conditional branch likely executed.
          0: Total number conditional branch likely actually taken.

         18: Total cycles waiting for current instr to finish.
         26: Total cycles lost to satisfy scheduling constraints.
          5: Total cycles lost waiting for operands be available.
*---------------------------------------------------------------------*
-p[rocedures] using basic-block counts.                               *
 Sorted in descending order by the number of cycles executed in each  *
 procedure. Unexecuted procedures are not listed.                     *
*----------------------------------------------------------------------*
        cycles(%)  cum %     secs    instrns      calls procedure(file)

        27(50.94)  50.94     0.00         19      1 main(prog:prog.c)
        18(33.96)  84.91     0.00          4      1 multiply(prog:prog.c)
         8(15.09) 100.00     0.00          4      2 add(prog:prog.c)The above example uses the sh command to invoke prof directly from dbx.For an explanation of the above listing and information on the prof and pixie commands, see "Using the Performance Tools" in the Compiling and Performance Tuning Guide and the prof(1) and pixie(1) reference pages.LBL="" HELPID=""ID="19156"Accessing C++ Member VariablesDebugging a program written in C++ is somewhat different from debugging programs written in other languages. This section describes features that affect how you access variables. See also the section in the following chapter, ID="05.change131"IDREF="32416" TYPE="TITLE""Referring to C++ Functions."Typically you use standard C++ syntax to access member variables of objects. For example, if the string ID="05.change132"_name is a member variable of the object myWindow, you can print its value by entering:(dbx) print myWindow._name
0x1001dc1c = "MenuWindow" To display a static member variable for a C++ class, you must specify the variable with the class qualifier. For example, to print the value of the static member variable ID="05.change133"costPerShare of the class CoOp, enter:(dbx) print CoOp::costPerShare
25.0LBL="6"ID="91063"Controlling Program ExecutionA program typically runs until it exits or encounters an unrecoverable error. You can use dbx, however, to stop a program under various conditions, step through your program line by line, stop execution on receiving a signal, and execute conditional commands based on your program's status.This chapter covers:IDREF="23865" TYPE="TITLE""Setting Breakpoints"IDREF="31983" TYPE="TITLE""Continuing Execution After a Breakpoint"IDREF="19256" TYPE="TITLE""Tracing Program Execution"IDREF="89878" TYPE="TITLE""Writing Conditional Commands"IDREF="14485" TYPE="TITLE""Managing Breakpoints, Traces, and Conditional Commands"IDREF="25866" TYPE="TITLE""Using Signal Processing"IDREF="51268" TYPE="TITLE""Stopping on C++ Exceptions"IDREF="93296" TYPE="TITLE""Stopping at System Calls"IDREF="31135" TYPE="TITLE""Stepping Through Your Program"IDREF="28904" TYPE="TITLE""Starting at a Specified Line"IDREF="32416" TYPE="TITLE""Referring to C++ Functions"LBL="" HELPID=""ID="23865"Setting BreakpointsBreakpointsID="06.exec1" allow you to stop execution of your program. Breakpoints can be unconditionalID="06.exec2", in which case they always stop your program, or ID="06.exec3"conditional, in which case they stop your program only if a test condition that you specify is true.NoteAll breakpoints halt program execution before executing the line on which they are set. Therefore, if you want to examine the effects of a line of code, you should set the breakpoint on the line of code following the one whose effects you want to study.Each breakpoint is assigned a number when you create it. Use this number to reference a breakpoint in the various commands provided for manipulating breakpoints (for example, ID="06.exec4"disable, ID="06.exec5"enable, and ID="06.exec6"delete, all described in IDREF="14485" TYPE="TITLE""Managing Breakpoints, Traces, and Conditional Commands").LBL="" HELPID=""Setting Unconditional BreakpointsTo set an unconditional breakpoint, you simply specify the point at which you want to stop program execution, using one of the following forms of the ID="06.exec7"stop command:stop atID="06.exec8"Sets a breakpoint at the current source line.stop atID="06.exec9" lineSets a breakpoint at the specified source line in the current source file.stop inID="06.exec10" procedure Sets a breakpoint to stop execution upon entering the specified procedure. Execution will stop in all inlined or cloned instances of the procedure.ID="06.exec11"ID="06.exec12"stop at file:lineSets a breakpoint in the specified file at the specified line.CautionIf your program has multiple source files, be sure to set the breakpoint in the correct file. To do so, you can explicitly set the source file using dbx's file command (see IDREF="41684" TYPE="TITLE""Changing Source Files") or you can use the func command to go to a source file containing a specified function (see IDREF="82062" TYPE="TITLE""Moving to a Specified Procedure").LBL="" HELPID=""Setting Conditional BreakpointsAn unconditional breakpoint is the simplest type of breakpoint; your program stops every time it reaches a specified place. On the other hand, a ID="06.exec13"conditional breakpoint stops your program only if a condition that you specify is true. The two conditions that you can test are:Has the value of a variable or other memory location changed?Is a test expression true?LBL="" HELPID=""Stopping If a Variable or Memory Location Has ChangedBy including a ID="06.exec14"variable clause in your stop command, you can cause dbx to stop if the value of a variable or the contents of a memory location has changed.If you provide only a variable name in your variable clause, the breakpoint stops your program if the value of the variable has changed since the last time dbx checked it. If instead of a variable name, you provide an expression of type pointer, dbx checks the data pointed to. If the data pointed to is a structure, dbx checks that structure. If you provide an expression that's not of type pointer, dbx evaluates the expression and uses the result as an address in memory. The breakpoint stops your program if the contents of the memory location (32 bits) has changed since the last time dbx checked it.The points at which dbx checks the value of a variable or memory location depend on the command that you use to set the breakpoint:stopID="06.exec15" [expression|variable] Inspects the value before executing each source line. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address). For example, consider the command:ID="06.exec16"stop (struct s*) 0x12345678This command checks the contents of the structure located at 0x12345678.stop ID="06.exec17"[expression|variable] at line Inspects the value at the given source line. Stops if the value has changed. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).ID="06.exec18"stopID="06.exec19" [expression|variable] in procedure Inspects the value at every source line within a given procedure. Stops if the value has changed. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).ID="06.exec20"LBL="" HELPID=""Using Fast Data BreakpointsYou can use fast watchpoints, also known as data breakpoints, with the stop command. A fast watchpoint watches a specified variable or memory address without severely impacting the performance of the program being debugged. InIRIX 4 and earlier versions of dbx, the debugger had to single-step the process being debugged and check if the value of a variable had changed after each instruction. With fast watchpoints, the debugger uses a hardware virtual memory write protect mechanism to allow the program to run freely until the variable being watched changes. The program being debugged stops only when the virtual memory page containing the variable is written to. If the value of the variable being watched does not changed, dbx continues the execution of the process. If a write modifies a watched variable, dbx notifies you of the change.Consider a small program that contains a global variable called global:stop globalThis command causes the program to stop if the value of the variable global changes. The program runs virtually at full speed until global gets assigned a new value. Similarly, consider the command:stop 0x100100This command stops when the 32- bit integer residing at address 0x100100 is modified, and runs at nearly full speed until the value changes. This form of the stop command is useful for watching the contents of anonymous memory, such as the memory returned by malloc().dbx still needs to use the single-step approach if the stop command contains an expression to watch, such as in stop if global == 1. The performance of the debugged program can be greatly enhanced by including a variable to watch in the stop command. For example, the previous stop command can be expressed equivalently as stop global if global == 1. This instructs the debugger to check only the expression global == 1 if the value of global changes. For situations where the expression does not depend upon a particular variable getting modified such as stop if global == x * 3, the single-step approach is the only way to achieve the desired behavior.LBL="" HELPID=""ID="71997"Stopping If a Test Expression Is TrueBy including a test clause in your ID="06.exec21"stop command, you can cause dbx to stop if the value of an expression is true. You can use any valid numerical expression as a test. If the result of the expression is nonzero, the expression is true and the test is successful.The point at which dbx evaluates the test expression depends on the command that you use to set the breakpoint:stopID="06.exec22" if expressionEvaluates the expression before executing each source line. Note that execution is very slow if you choose this type of conditional breakpoint.ID="06.exec23"stop at line if expressionEvaluates the expression at the given line.stop in procedure if expressionEvaluates the expression at every source line within a given procedure.LBL="" HELPID=""Conditional Breakpoints Combining Variable and Test ClausesYou can create conditional breakpoints that combine both variable and test clauses. In these cases, the overall test evaluates to true only if both clauses are true.ID="06.exec24"ID="06.exec25"The following forms of the stop command combine both the variable and test clauses:stop [expression1|variable] if expression2 Tests both conditions before executing each source line. Stops if both conditions are true. If ID="06.exec26"expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stop [expression1|variable] at line if expression2 Tests both conditions at the given source line. Stops if both conditions are true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stop [expression1|variable] in procedure if expression2 Tests both conditions at every source line within a given procedure. Stops if both conditions are true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).LBL="" HELPID=""ID="31983"Continuing Execution After a BreakpointThe ID="06.exec27"cont command allows you to continue execution after any type of breakpoint. In its simplest form, program execution continues until the end of the program or until another breakpoint is reached. You can also tell ID="06.exec28"dbx to continue your program until it reaches a given line or procedure; this is similar to setting a temporary, "one-shot" breakpoint and then continuing.The syntax of the cont command is:contContinues execution with the current line.cont {at | to} lineSets a temporary breakpoint at the specified source line, then resumes execution with the current line. When your program reaches the breakpoint at line, dbx stops your program and deletes the temporary breakpoint. The keywords at and to are equivalent.cont in procedureSets a temporary breakpoint to stop execution upon entering the specified procedure, then resumes execution with the current line. When your program reaches the breakpoint in procedure, dbx stops your program and deletes the temporary breakpoint.If your program stopped because dbx caught a signal intended for your program, then dbx will send that signal to your program when you continue execution. You can also explicitly send a signal to your program when you continue execution. Sending signals to your program upon continuation is discussed in ID="06.exec29"IDREF="62814" TYPE="TITLE""Continuing After Catching a Signal".When you debug multiprocess programs, the ID="06.exec30"ID="06.exec31"resume command can be more helpful than the cont command. Refer to IDREF="87200" TYPE="TITLE""Resuming a Suspended Process" for more information about the resume command.LBL="" HELPID=""ID="19256"Tracing Program ExecutionThe trace command allows you to observe the progress of your program as it executes. With it, you can print:values of variables at specific points in your program or whenever variables change valueparameters passed to and values returned from functionsEach trace is assigned a number when you create it. Use this number to reference the trace in the various commands provided for manipulating traces (for example, ID="06.exec32"disable, ID="06.exec33"enable, and ID="06.exec34"delete, all described in IDREF="14485" TYPE="TITLE""Managing Breakpoints, Traces, and Conditional Commands").The syntax of the trace command is:traceID="06.exec35" variableWhenever the specified variable changes, ID="06.exec36"dbx prints the old and new values of that variable.traceID="06.exec37" procedurePrints the values of the parameters passed to the specified procedure whenever your program calls it. Upon return, ID="06.exec38"dbx prints the return value.traceID="06.exec39" [expression|variable] at lineWhenever your program reaches the specified line, dbx prints the value of the variable if its value has changed. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).ID="06.exec40"traceID="06.exec41" [expression|variable] in procedure Whenever the variable changes within the procedure, dbx prints the old and new values of that variable. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).trace [expression1|variable] at line if expression2 Prints the value of the variable (if changed) whenever your program reaches the specified line and the given expression is true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).trace [expression1|variable] in procedure if expression2 Whenever the variable changes within the procedure that you specify, dbx prints the old and new values of that variable, if the given expression is true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).To examine the parameters passed to and values returned from a function, you can trace that function. For example, if the function name is foo, set the trace by entering:(dbx) trace fooWhen you execute your program, dbx prints the values of the parameters passed to foo whenever your program calls it. Upon return from foo, dbx prints the return value:(dbx) run
[3] calling foo(text = 0x10000484 = "Processing...\n", i = 4) from function main
[4] foo returning -1 from fooIn the example shown above, foo receives two parameters: a character string variable named text containing the value "Processing...\n" and an integer variable named i containing the value 4. The trace also indicates that foo returns a value of -1.You can also examine a variable as it changes values. For example, you can monitor the value of a string variable named curarg as you use it to process an argument list. To set the trace, enter:(dbx) trace curarg
Process 2395: [6] trace .test.main.curarg in mainWhen you set a trace on a variable, examine the confirmation that dbx prints. If you use the same variable name in multiple functions in your program, dbx may not set the trace on the variable that you want. If dbx sets the trace on an incorrect variable, delete the trace and set a new trace using a qualified variable format as described in ID="06.exec42"IDREF="90553" TYPE="TITLE""Qualifying Names of Program Elements". For more information on deleting traces, see IDREF="99674" TYPE="TITLE""Deleting Breakpoints, Traces, and Conditional Commands".So, in this example, if you use the variable curarg in both main and a function called arg_process, and you want to trace the curarg in arg_process, first delete this trace and then set a new trace:(dbx) delete 6
(dbx) trace arg_process.curarg
Process 2395: [7] trace .test.arg_process.curarg in arg_processWhen you execute your program, whenever curarg changes, dbx prints its old and new values:(dbx) run
[7] curarg changed before [arg_process: line 53]:
                new value = (nil);
[7] curarg changed before [arg_process: line 86]:
                old value = 0;
                new value = 0x7fffc7e5 = "-i";
[7] curarg changed before [arg_process: line 86]:
                old value = 2147469285;
                new value = 0x7fffc7eb = "names.out";
[7] curarg changed before [arg_process: line 86]:
                old value = 2147469291;
                new value = 0x7fffc7f5 = "names.in";LBL="" HELPID=""ID="89878"Writing Conditional CommandsA conditional command created with the ID="06.exec43"when command is similar to a breakpoint set with the stop command, except that rather than stopping when certain conditions are met, dbx executes a list of commands. The command list can consist of any dbx commands, separated by semicolons if you include more than one command in the command list. Additionally, you can use the keyword ID="06.exec44"stop in the command list to stop execution, just like a breakpoint.Each conditional command is assigned a number when you create it. You use this number to reference the conditional command in the various commands provided for manipulating conditional commands (for example, disable, enable, and delete, all described in IDREF="14485" TYPE="TITLE""Managing Breakpoints, Traces, and Conditional Commands").The syntax of the when command is:whenID="06.exec45" [expression|variable] {command-list} Inspects the value before executing each source line. If it has changed, executes the command list. ID="06.exec46"If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).when [expression|variable] at line {command-list} Inspects the value at the given source line. If it has changed, executes the command list. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).when [expression|variable] in procedure {command-list} Inspects the value at every source line within a given procedure. If it has changed, executes the command list. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).when if expression {command-list}Evaluates the expression before executing each source line. If it is true, executes the command list. Note that execution is slow if you choose this type of conditional command execution.ID="06.exec47"when at line if expression {command-list}Evaluates the expression at the given line. If it is true, executes the command list.when in procedure if expression {command-list}Evaluates the expression at every source line within a given procedure. If it is true, executes the command list.when [expression1|variable] if expression2 {command-list} Checks if the value of the variable has changed. If it has changed and the expression is true, executes the command list.If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).when [expression1|variable] at line if expression2 {command-list} Checks if the value of the variable has changed each time the line is executed. If the value has changed and the expression is true, executes the command list. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).when [expression1|variable] in procedure if expression2 {command-list} Checks if the value of variable has changed at each source line of the given procedure. If the value has changed and the expression is true, executes the command list. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).LBL="" HELPID=""ID="14485"Managing Breakpoints, Traces, and Conditional Commandsdbx provides commands that allow you to disable, enable, delete, and examine the status of the breakpoints, traces, and conditional commands that you set in your programs.Each breakpoint, trace, and conditional command is assigned a number when you create it. Use these numbers as identifiers in the various commands provided for manipulating these debugging controls.LBL="" HELPID=""ID="58446"Listing Breakpoints, Traces, and Conditional CommandsThe ID="06.exec48"status command lists all of the breakpoints, traces, and conditional commands that you have set and indicates whether they are enabled or disabled.ID="06.exec49"ID="06.exec50"ID="06.exec51"For example, consider executing the following commands while debugging a program called test:(dbx) stop in foo
Process     0: [3] stop in foo
(dbx) r
Process 22631 (test) started
[3] Process 22631 (test) stopped at [foo:38 ,0x10001050]
  38  r = foo2(i+1);
(dbx) trace total
Process 22631: [4] trace total in foo
(dbx) when at 60 {print i,j }
Process 22631: [5] when at "/usr/var/tmp/dbx_examples/test.c":60 { print i, j }If you enter status, you see the following:(dbx) status
Process 22631: [3] stop in foo
Process 22631: [4] trace total in foo
Process 22631: [5] when at "/usr/var/tmp/dbx_examples/test.c":60 { print i, j }LBL="" HELPID=""ID="84268"Disabling Breakpoints, Traces, and Conditional CommandsThe ID="06.exec52"disable command allows you to temporarily disable a breakpoint, trace, or conditional command so that it is inoperative and has no effect on program execution. dbx remembers all information about a disabled breakpoint, trace, or conditional command, and you may enable it using the enable command described in IDREF="14318" TYPE="TITLE""Enabling Breakpoints, Traces, and Conditional Commands".The syntax of the disable command is:disable item [, item ... ]Disables the specified breakpoint(s), trace(s), or conditional command(s). This command has no effect if the item you specify is already disabled.ID="06.exec53"ID="06.exec54"ID="06.exec55"For example, to disable the conditional command set in IDREF="58446" TYPE="TITLE""Listing Breakpoints, Traces, and Conditional Commands" enter:(dbx) disable 4If you enter status, you see the following:(dbx) status
Process 22631: [3] stop in foo
Process 22631: [4] (disabled) trace total in foo
Process 22631: [5] when at "/usr/var/tmp/dbx_examples/test.c":60 { print i, jLBL="" HELPID=""ID="14318"Enabling Breakpoints, Traces, and Conditional CommandsThe enable command reverses the effects of a disable command: The breakpoint, trace, or conditional command that you specify is enabled and once again affects the execution of your program. The syntax of the enable command is:enableID="06.exec56" item [, item ...]Enables the specified breakpoint(s), trace(s), or conditional command(s).ID="06.exec57"ID="06.exec58"ID="06.exec59"For example, to enable the conditional command disabled in IDREF="84268" TYPE="TITLE""Disabling Breakpoints, Traces, and Conditional Commands" enter:(dbx) enable 4Executing the status command shows that the condition command is now enabled:(dbx) status
Process 22631: [3] stop in foo
Process 22631: [4] trace total in foo
Process 22631: [5] when at "/usr/var/tmp/dbx_examples/test.c":60 { print i, jLBL="" HELPID=""ID="99674"Deleting Breakpoints, Traces, and Conditional CommandsThe ID="06.exec60"delete command allows you to delete breakpoints, traces, and conditional commands:deleteID="06.exec61" {item [, item ...] | all}Deletes the item or items specified. If you use the keyword all instead of listing individual items, dbx deletes all breakpoints, traces, and conditional commands.ID="06.exec62"ID="06.exec63"ID="06.exec64"For example, to delete the breakpoint and trace set in IDREF="58446" TYPE="TITLE""Listing Breakpoints, Traces, and Conditional Commands" enter:(dbx) delete 3, 4If you enter status, you see the following:(dbx) status
Process 22631: [5] when at "/usr/var/tmp/dbx_examples/test.c":60 { print i, j }To delete all breakpoints, traces, and conditional commands, enter:(dbx) delete allLBL="" HELPID=""ID="25866"Using Signal Processingdbx can detect any signals sent to your program while it is running and, at your option, stop the program.LBL="" HELPID=""Catching and Ignoring SignalsWith the catch command, you can instruct dbx to stop your program when it receives any specified signal. The ID="06.exec65"ignore command undoes the effects of a catch command. The catch and ignore commands have the following syntax:catch {signal | all}Instructs ID="06.exec66"dbx to stop your program whenever it receives the specified signal. If you use the keyword all rather than giving a specific signal, dbx catches all signals.ignoreID="06.exec67" {signal | all}Instructs ID="06.exec68"dbx to ignore the specified signal. All ignored signals are passed to your program normally. If you use the keyword all rather than giving a specific signal, dbx ignores all signals.catchPrints a list of all signals caught.ID="06.exec69"ignoreID="06.exec70"Prints a list of all signals ignored.ID="06.exec71"You can use the signal names and numbers as listed in the signal(2) reference page. You can also abbreviate the signal names by omitting the "SIG" portion of the name. You can use uppercase or lowercase for the signal names.NoteBecause "int" (in lowercase) is a dbx keyword, you cannot use it as an abbreviation for the SIGINT signal. You must use uppercase ("INT"), the full signal name ("SIGINT" or "sigint"), or the signal number ("2"). SIGINT is the only signal name with such a restriction.If you instruct dbx to catch a signal, whenever that signal is directed to your program, dbx intercepts it and stops your program. Your program does not see this signal until you continue your program with the cont command. If your program has a handler for the signal, the signal is then passed to the program. If there is no handler for the signal, the program does not see the signal. You can suppress passing the signal to the program's signal handler by issuing a step or next command, rather than cont.If you issue a SIGINT signal at the keyboard (usually by pressing <Ctrl-C>) while you are running an application under dbx, what happens depends on the circumstances:If the process is in the same IRIX process group as dbx, the interrupt signal is sent to both dbx and the process. Both dbx and the process stop running. You are left at the dbx command line.If the process was added with addproc, dbx ­P, or dbx ­p, it is not in the same IRIX process group as dbx. In this case, the signal interrupt is sent to dbx but not to the process. dbx stops running, but the process continues to run. Use the showproc command to see whether the process is still running. Then use the suspend command to stop the process. LBL="" HELPID=""ID="62814"Continuing After Catching a SignalThe ID="06.exec72"cont command allows you to continue execution after catching a signal. You can also use the cont command to specify a different signal to send to your program than the one that dbx caught. Using the same syntax, you can also send a signal to your program when you continue, even if your program did not stop because of a caught signal.Use the following forms of the cont command when handling signals. In each case, if you do not provide a signal, but your program stopped because dbx caught a signal intended for your program, then dbx sends that signal to your program when you continue execution:cont [signal]Continues execution with the current line and sends the specified signal to your program.ID="06.exec73"cont [signal] {at | to} lineSets a temporary breakpoint at the specified source line, then resumes execution with the current line and sends the specified signal to your program.ID="06.exec74"cont [signal] in procedureSets a temporary breakpoint to stop execution upon entering the specified procedure, then resumes execution with the current line and sends the specified signal to your program.For example, if your program stopped because dbx caught a SIGINT signal, dbx will automatically send that signal to your program, if you enter:(dbx) contSuppose you have a procedure called alarm_handler to handle an alarm signal sent to your program. If you want to test this procedure by single-stepping through it, you can execute the following command:(dbx) cont SIGALRM in alarm_handlerThis sets a temporary breakpoint to stop your program upon entering alarm_handler, continues execution of your program, and sends a SIGALRM signal to your program. Your program then enters the alarm_handler procedure and stops. You can then single-step through the procedure and observe execution.LBL="" HELPID=""ID="51268"Stopping on C++ ExceptionsThe intercept command stops program execution on C++ exceptions. You can append a conditional expression to an ID="06.exec75"intercept command by using the if clause. However, the context of an intercept break is not that of the throw; the context is the exception handling code of the C++ runtime library. Hence, only global variables have unambiguous interpretation in the if clause. To refer to a variable whose scope is that of the throw, use the fully qualified name for the variable.The syntax of the intercept command is:ID="06.exec76"intercept {all | item}Stops on all C++ exceptions, or exceptions that throw the base type item. intercept unexpected {[all] | [item [, item] ]}Stops on all C++ exceptions that have either no handler or are caught by an "unexpected" handler. You may omit all. If you specify item, stops on exceptions that throw the base type item.intercept ... if expressionYou can append the if clause to all intercept commands. Your program stops only if expression is non-zero. Note that the context for evaluation of expression is the C++ runtime library, not that of the throw, so use global variables or fully qualified names in expression.bx is an alias for intercept and unx is an alias for unexpected.The following program example illustrates the if clause with the intercept command:int global = 1;

main (){
 int local = 2;
 try {
  throw -1;
 }
 catch (int key) {
  printf ("exception: %d.\n", key);
 }
}To set a break with a condition on the global variable, enter: (dbx) intercept int if global != 0Use a fully qualified name to set a break with a condition on the local variable:(dbx) intercept int if main.local != 0Do not include complex expressions involving operators such as * and & in your type specification for an intercept command. Note, however, that if you use the intercept command with a specific base type, you will also stop your program on throws of pointer, reference, const and volatile types. For example:(dbx) bx charYour program will stop on throws of type char, char *, char&, const char&, volatile char*, and so forth.Like all other break points, pgrp or a pid clause can be appended to an intercept command. For example:(dbx)intercept int pid 12345
(dbx)intercept char pgrpLBL="" HELPID=""ID="93296"Stopping at System CallsBecause system calls are part of the operating system and their source is generally not available for debugging purposes, you cannot set breakpoints in system calls using the same method that you use for your program's procedures. Instead, dbx provides the ID="06.exec77"syscall command to allow you to stop your program when it executes system calls. With the syscall command you can catch (breakpoint) system calls either at the entry to the system call or at the return from the system call.The syntax of the syscall command is:syscall catchID="06.exec78" {call | return} {system_call | all}Sets a breakpoint to stop execution upon entering (ID="06.exec79"call) or returning from (return) the specified system call. Note that you can set dbx to catch both the call and the return of a system call.If you use the keyword all rather than giving a specific system call, dbx catches all system calls.syscall ignoreID="06.exec80" {call | return} {system_call | all}Clears the breakpoint to stop execution upon entering (ID="06.exec81"call) or returning from (return) the specified system call.If you use the keyword all rather than giving a specific system call, dbx clears the breakpoints to stop execution upon entering (call) or returning from (return) all system calls.syscall catch [{call | return}]Prints a list of all system calls caught upon entry (ID="06.exec82"call) or return (return). If you provide neither the call nor return keyword, dbx lists all system calls that are caught.syscall ignore [{call | return}]Prints a list of all system calls not caught upon entry (ID="06.exec83"call) or return (return). If you provide neither the call nor return keyword, dbx lists all system calls that are ignored.syscallPrints a summary of the catch and ignore status of all system calls. The summary is divided into four sections: 1) caught at call, 2) caught at return, 3) ignored at call, and 4) ignored at return.The ID="06.exec84"fork and ID="06.exec85"sproc system calls are treated specially as they invoke new processes. The returns from these system calls are controlled by the dbx variables ID="06.exec86"$promptonfork and ID="06.exec87"$mp_program, not by syscall. This is discussed in IDREF="61470" TYPE="TITLE""Handling fork System Calls" and IDREF="59516" TYPE="TITLE""Handling sproc System Calls and Process Group Debugging".The ID="06.exec88"execv and ID="06.exec89"execve system calls are treated specially as they change a process into a new program. For more information, see IDREF="10836" TYPE="TITLE""Handling exec System Calls". The system calls are listed in /usr/include/sys.s. dbx ignores the case of the system call names in all syscall commands; therefore, you can use uppercase or lowercase in these commands.A particularly useful setting is:(dbx) syscall catch call exitThis stops your program upon entry to ID="06.exec90"exit. With your program stopped, you can do a stack trace before the termination to see why exit was called.LBL="" HELPID=""ID="31135"Stepping Through Your ProgramSteppingID="06.exec91" is a process of executing your program for a fixed number of lines and then automatically returning control to dbx. dbx provides two commands for stepping through lines of code: ID="06.exec92"step and ID="06.exec93"next.For both step and next, dbx counts only those source lines that actually contain code; for the purposes of stepping, dbx ignores blank lines and lines consisting solely of comments.The next and step commands differ in their treatment of procedure calls. When step encounters a procedure call, it usually "steps into" the procedure and continues stepping through the procedure (counting each line of source). On the other hand, when next encounters a procedure call, it "steps over" the procedurename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'executing it without stopping but not counting lines in the procedurename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'and continues stepping through the current procedure.The following code fragment illustrates the difference between step and next: 55  foo( arg1, arg2 )
 56  int arg1, arg2;
 57  {
 58        if ( arg1 < arg2 ) {
 ...       ...
 78        return( 0 );
 79  }
 ...
211  x = foo( i, j );
212  y = 2 * x;In this example, if at line 211 you execute a step command to advance one line, dbx allows the process to proceed to line 58 (the first code line of the foo procedure). However, if you execute a next command, dbx executes line 211name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'calling fooname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'and advances the process to line 212.LBL="" HELPID=""ID="33387"Stepping Using the step CommandThe format of the step command is:stepID="06.exec94" [integer]Executes the specified number of lines of source code, stepping into procedures. If you do not provide an argument, step executes one line. If step encounters any breakpoints, it immediately stops execution.By default, step steps into only those procedures that are compiled with the debugging options ID="06.exec95"-g, -g2, or -g3 for which line numbers are available in the symbol table. Note that this does not include standard library routines because they are not compiled using debugging options.ID="06.exec96"You can modify this behavior, even force dbx to step into procedures not compiled with full debugging information, by changing the value of the dbx variable $stepintoall.IDREF="66599" TYPE="TABLE"Table 6-1 summarizes how the value of ID="06.exec97"$stepintoall affects the step command.COLUMNS="2"LBL="6-1"Table 6-1 ID="66599"Effect of $stepintoall Variable on the step CommandLEFT="0" WIDTH="63"$stepintoall 
valueLEFT="70" WIDTH="261"Effect on step CommandLEFT="0" WIDTH="63"0 (default)LEFT="70" WIDTH="261"Steps into all procedures that are compiled with debugging 
options -g, -g2, or -g3 for which line numbers are available in the 
symbol table. LEFT="0" WIDTH="63"1 LEFT="70" WIDTH="261"In addition to the above procedures, steps into any procedures 
for which a source file can be found. Note that when you debug 
a source file compiled without symbols or compiled with 
optimization, the line numbers may jump erratically.LEFT="0" WIDTH="63"2LEFT="70" WIDTH="261"Steps into all procedures. Note that if dbx cannot locate a source 
file, then it cannot display source lines as you step through a 
procedure.If your program has DSOs, set the environment variable ID="06.exec98"ID="06.exec99"LD_BIND_NOW to 1 before you run your program. This will force complete run-time linking. Otherwise, you can accidentally step into the run-time-linker, rld(1), which becomes part of your program at run time. Useful stack traces are then impossible. To avoid this situation, enter the following before the run command:(dbx) setenv LD_BIND_NOW 1 LBL="" HELPID=""ID="24643"Stepping Using the next CommandThe format of the next command is:nextID="06.exec100" [integer]Executes the specified number of lines of source code, stepping over procedures. If you do not provide an argument, next executes one line. If next encounters any breakpoints, even in procedures that it steps over, it immediately stops execution.LBL="" HELPID=""Using the return CommandIf you step into a procedure and then decide you don't want to step through the rest of it, use ID="06.exec101"return to finish executing the procedure and return to the calling procedure.The format of the return command is:returnID="06.exec102"Continues execution until control returns to the procedure that invoked the return command. return procContinues execution until control returns to the named procedure. Execution continues, unless stopped by a breakpoint, until the latest invocation of the procedure named by proc at the time the command was issued is reached. Execution doesn't stop at subsequent invocations of the same procedure. The search for the frame to return to starts with the previous frame, because the current frame is skipped in looking for a frame whose name matches proc. If execution is stopped for any reason, this command is cancelled. LBL="" HELPID=""ID="28904"Starting at a Specified LineWhen you continue your program, you typically do so at the place where it stopped using the ID="06.exec103"cont command. However, you can also force your program to continue at a different address by using the goto command:gotoID="06.exec104" lineBegins execution at the specified line. You may not use the goto command to resume execution with a line outside of the current procedure.LBL="" HELPID=""ID="32416"Referring to C++ FunctionsAs discussed in the section IDREF="19156" TYPE="TITLE""Accessing C++ Member Variables" in Chapter 5, debugging a program written in C++ has some unique features. This section discusses setting breakpoints in C++ functions.ID="06.exec105"For the purpose of dbx debugging, functions in C++ programs fall into three general categories:Member functionsID="06.exec106"Refers to member functions using the syntax classname::functionname. For example, refers to the member function foo in the class Window as Window::foo.Global C++ functionsID="06.exec107"Refers to global functions using the syntax ::functionname. For example, refers to the global function foo as ::foo.Non-C++ functionsID="06.exec108"Refers to non-C++ functions using the syntax functionname. For example, refers to the function printf as printf.When using dbx with C++, you cannot distinguish between overloaded functions. For example, consider two functions:ID="06.exec109"print(int);
print(float);The following command sets a breakpoint in both functions:(dbx) stop in ::printThe following example illustrates various possibilities:#include <stdio.h> 
class foo {
   int n; 
   public:
   foo() {n = 0;}
   foo(int x);
   int bar();
   int bar(int); 
};

int foo:: bar() 
{
   return n; 
}

int foo:: bar(int x) 
{
   return n + x; 
}

foo::foo(int x) 
{
   n = x; 
}

int square(int x) 
{
   return x*x; 
}

main() 
{ 
   foo a; 
   foo b = 11; 
   int x = a.bar(); 
   int y = b.bar(x) + square(x);  
   printf("y = %d\n", y); 
} If you enter:(dbx) stop in foo::foodbx stops execution in the constructor for the variable b; dbx also stops in the constructor for the variable a.If you enter:(dbx) stop in foo::bardbx stops execution both when a.bar is called and when b.bar is called, because dbx is unable to distinguish between the overloaded functions.To stop in square, enter:(dbx) stop in ::squareTo stop in printf (a C function), enter:(dbx) stop in printfTo set breakpoints in a specific function from a C++ template, the name of the function must be in back quotation marks to force ID="06.exec110"dbx to interpret the entire character string as the name of the function. Otherwise the < and > characters in the template name are interpreted by dbx as operators.dbx sets breakpoints in all instantiations of the template if you do not use back quotation marks and simply leave out the template's type-argument list, that is leave out the two characters < and > and the characters included between them. The following code illustrates these points:template <class T>  myclass {myclass() { /*... */ }~myclass() { /*... */ }myfunc(T) { /* ... */ }};To set a breakpoint only in the <int> template function for myfunc enter:(dbx) stop in `myclass<int>::myfunc` To set breakpoints in all functions myfunc for all instantiations of the template class enter:(dbx) stop in  myclass::myfuncLBL="7"ID="33796"Debugging Machine Language CodeThis chapter explains how to debug machine language code by:IDREF="88998" TYPE="TITLE""Examining and Changing Register Values"IDREF="51451" TYPE="TITLE""Examining Memory and Disassembling Code"IDREF="64338" TYPE="TITLE""Setting Machine-Level Breakpoints"IDREF="37993" TYPE="TITLE""Continuing Execution After a Machine-Level Breakpoint"IDREF="81564" TYPE="TITLE""Tracing Execution at the Machine Level"IDREF="94164" TYPE="TITLE""Writing Conditional Commands at the Machine Level"IDREF="53669" TYPE="TITLE""Stepping Through Machine Code"LBL="" HELPID=""ID="88998"Examining and Changing Register ValuesUsing dbx, you can examine and change the hardware registers during execution of your program. ID="07.mach1"IDREF="39923" TYPE="TABLE"Table 7-1 lists the machine form of the register names and the alternate software names as defined in the include file ID="07.mach2"regdef.h.COLUMNS="3"LBL="7-1"Table 7-1  (continued)        ID="39923"Hardware Registers and AliasesLEFT="0" WIDTH="72"RegisterLEFT="80" WIDTH="72"Software NameLEFT="160" WIDTH="180"DescriptionLEFT="0" WIDTH="72"$r0LEFT="80" WIDTH="72"$zeroLEFT="160" WIDTH="180"Always 0LEFT="0" WIDTH="72"$r1LEFT="80" WIDTH="72"$atLEFT="160" WIDTH="180"Reserved for assemblerLEFT="0" WIDTH="72"$r2... $r3LEFT="80" WIDTH="72"$v0... $v1LEFT="160" WIDTH="180"Expression evaluations, function return 
values, static linksLEFT="0" WIDTH="72"$r4... $r7LEFT="80" WIDTH="72"$a0... $a3LEFT="160" WIDTH="180"ArgumentsLEFT="0" WIDTH="72"$r8... $r11LEFT="80" WIDTH="72"$t0... $t7$a4... $a7,$ta0... $ta3LEFT="160" WIDTH="180"Temporaries (32 bit)Arguments (64 bit)LEFT="0" WIDTH="72"$r12... $r15LEFT="80" WIDTH="72"$t4... $t7, $t0... $t3$ta0... $ta3LEFT="160" WIDTH="180"Temporaries (32 bit)Temporaries (64 bit)LEFT="0" WIDTH="72"$r16... $r23LEFT="80" WIDTH="72"$s0... $s7LEFT="160" WIDTH="180"Saved across procedure callsLEFT="0" WIDTH="72"$r24... $r25LEFT="80" WIDTH="72"$t8... $t9LEFT="160" WIDTH="180"TemporariesLEFT="0" WIDTH="72"$r26... $r27LEFT="80" WIDTH="72"$k0... $k1LEFT="160" WIDTH="180"Reserved for kernelLEFT="0" WIDTH="72"$r28LEFT="80" WIDTH="72"$gpLEFT="160" WIDTH="180"Global pointerLEFT="0" WIDTH="72"$r29LEFT="80" WIDTH="72"$spLEFT="160" WIDTH="180"Stack pointerLEFT="0" WIDTH="72"$r30LEFT="80" WIDTH="72"$s8LEFT="160" WIDTH="180"Saved across procedure callsLEFT="0" WIDTH="72"$r31LEFT="80" WIDTH="72"$raLEFT="160" WIDTH="180"Return addressLEFT="0" WIDTH="72"$mmhiLEFT="80" WIDTH="72"LEFT="160" WIDTH="180"Most significant multiply/divide result 
registerLEFT="0" WIDTH="72"$mmloLEFT="80" WIDTH="72"LEFT="160" WIDTH="180"Least significant multiply/divide result 
registerLEFT="0" WIDTH="72"$fcsrLEFT="80" WIDTH="72"LEFT="160" WIDTH="180"Floating point control and status registerLEFT="0" WIDTH="72"$feirLEFT="80" WIDTH="72"LEFT="160" WIDTH="180"Floating point exception instruction registerLEFT="0" WIDTH="72"$causeLEFT="80" WIDTH="72"LEFT="160" WIDTH="180"Exception cause registerLEFT="0" WIDTH="72"$d0, $d2, ... $d30$d0, $d2, ... $d31LEFT="80" WIDTH="72"LEFT="160" WIDTH="180"Double precision floating point registers(32 bit)(64 bit)LEFT="0" WIDTH="72"$f0, $f2, ... $f30$f0, $f1, ... $f31LEFT="80" WIDTH="72"LEFT="160" WIDTH="180"Single precision floating point registers(32 bit)(64 bit)For registers with alternate names, the dbx variable ID="07.mach3"$regstyle controls which name is displayed when you disassemble code (as described in ID="07.mach4"IDREF="51451" TYPE="TITLE""Examining Memory and Disassembling Code"). If $regstyle is set to 0, then dbx uses the alternate form of the register name (for example, "zero" instead of "r0," and "t1" instead of "r9"); if $regstyle is anything other than 0, the machine names are used ("r0" through "r31").LBL="" HELPID=""Printing Register ValuesUse the ID="07.mach5"printregs command to print the values stored in all registers.ID="07.mach6"The base in which the register values are displayed depends on the values of the dbx variables ID="07.mach7"$octints and ID="07.mach8"$hexints. By default, dbx prints the register values in decimal. You can set the output base to octal by setting the ID="07.mach9"dbx variable $octints to a nonzero value. You can set the output base to hexadecimal by setting the ID="07.mach10"dbx variable $hexints to a nonzero value. If you set both $octints and $hexints to nonzero values, $hexints takes precedence.To examine the register values in hexadecimal, enter the following:(dbx) set $hexints = 1
(dbx) printregs
r0/zero=0x0     r1/at=0x19050
r2/v0=0x8       r3/v1=0x100120e0
r4/a0=0x4       r5/a1=0xffffffad78
r6/a2=0xffffffad88      r7/a3=0x0
r8/a4=0x10      r9/a5=0x20
r10/a6=0x0      r11/a7=0xfbd5990
r12/t0=0x0      r13/t1=0x0
r14/t2=0x65     r15/t3=0x0
r16/s0=0x1      r17/s1=0xffffffad78
r18/s2=0xffffffad88     r19/s3=0xffffffaf70
r20/s4=0x0      r21/s5=0x0
r22/s6=0x0      r23/s7=0x0
r24/t8=0x0      r25/t9=0x10001034
r26/k0=0x0      r27/k1=0x20
r28/gp=0x1001a084       r29/sp=0xffffffaca0
r30/s8=0x0      r31/ra=0x1000110c
mdhi=0x0        mdlo=0xe0
cause=0x24      pc=0x10001050
fpcsr=0x0
f0=0.0000000e+00        f1=0.0000000e+00        f2=0.0000000e+00
f3=0.0000000e+00        f4=0.0000000e+00        f5=0.0000000e+00
f6=0.0000000e+00        f7=0.0000000e+00        f8=0.0000000e+00
f9=0.0000000e+00        f10=0.0000000e+00       f11=0.0000000e+00
f12=0.0000000e+00       f13=0.0000000e+00       f14=0.0000000e+00
f15=0.0000000e+00       f16=0.0000000e+00       f17=0.0000000e+00
f18=0.0000000e+00       f19=0.0000000e+00       f20=0.0000000e+00
f21=0.0000000e+00       f22=0.0000000e+00       f23=0.0000000e+00
f24=0.0000000e+00       f25=0.0000000e+00       f26=0.0000000e+00
f27=0.0000000e+00       f28=0.0000000e+00       f29=0.0000000e+00
f30=0.0000000e+00       f31=0.0000000e+00
d0=0.000000000000000e+00        d1=0.000000000000000e+00
d2=0.000000000000000e+00        d3=0.000000000000000e+00
d4=0.000000000000000e+00        d5=0.000000000000000e+00
d6=0.000000000000000e+00        d7=0.000000000000000e+00
d8=0.000000000000000e+00        d9=0.000000000000000e+00
d10=0.000000000000000e+00       d11=0.000000000000000e+00
d12=0.000000000000000e+00       d13=0.000000000000000e+00
d14=0.000000000000000e+00       d15=0.000000000000000e+00
d16=0.000000000000000e+00       d17=0.000000000000000e+00
d18=0.000000000000000e+00       d19=0.000000000000000e+00
d20=0.000000000000000e+00       d21=0.000000000000000e+00
d22=0.000000000000000e+00       d23=0.000000000000000e+00
d24=0.000000000000000e+00       d25=0.000000000000000e+00
d26=0.000000000000000e+00       d27=0.000000000000000e+00
d28=0.000000000000000e+00       d29=0.000000000000000e+00
d30=0.000000000000000e+00       d31=0.000000000000000e+00(Note that there are twice as many floating point registers with 64-bit programs.) You can also use the value of a single register in an expression by typing the name of the register preceded by a dollar sign ($). ID="07.mach11"For example, to print the current value of the program counter (the pc register), enter:(dbx) printx $pc
0x10001050LBL="" HELPID=""ID="34959"Changing Register ValuesIn the same way you change the values of program variables, you can use the ID="07.mach12"assign command to change the value of registers:assignID="07.mach13" register = expressionAssigns the value of ID="07.mach14"expression to register. You must precede the name of the register with a dollar sign ($).For example:(dbx) assign $f0 = 3.14159
3.1415899999999999
(dbx) assign $t3 = 0x5a
0x5aBy default, the ID="07.mach15"assignregister command changes the register value in the current activation level, which is a typical operation. To force the hardware register to be updated regardless of the current activation level, use the $ set $framereg command. ID="07.mach16"LBL="" HELPID=""ID="51451"Examining Memory and Disassembling CodeThe ID="07.mach17"listregions command shows all memory regions, along with their sizes, in use by your program. This overview can be particularly useful if you want to know to what piece of your program a given data address corresponds. Since listregions shows the sizes of the memory regions, it allows you to easily determine the sizes of the data and stack regions of your program.The forward slash (/) and question mark (?) commands allow you to examine the contents of memory. Depending on the format you specify, you can display the values as numbers, characters, or disassembled machine code. Note that all common forms of address are supported. Some unusual expressions may not be accepted unless enclosed in parentheses, as in (address)/count format.The commands for examining memory have the following syntax:address ID="07.mach18"/ count formatPrints the contents of the specified address, or disassembles the code for the instruction at the specified address. Repeat for a total of ID="07.mach19"ID="07.mach20"count addresses in increasing addressname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in other words, an "examine forward" command. The format codes are listed in IDREF="54646" TYPE="TABLE"Table 7-2.address ID="07.mach21"? count formatPrints the contents of the specified address or, disassembles the code for the instruction at the specified address. Repeat for a total of ID="07.mach22"ID="07.mach23"count addresses in decreasing addressname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in other words, an "examine backward" command. The format codes are listed in IDREF="54646" TYPE="TABLE"Table 7-2.address / count L value maskExamines ID="07.mach24"count 32-bit words in increasing addresses; prints those 32-bit words which, when ORed with mask, equals value. This command searches memory for specific patterns../Repeats the previous examine command with increasing address. .?Repeats the previous examine command with decreasing address.COLUMNS="2"LBL="7-2"Table 7-2  (continued)        ID="54646"Memory Display Format CodesLEFT="0" WIDTH="72"Format CodeLEFT="80" WIDTH="216"Displays Memory in the FormatLEFT="0" WIDTH="72"iLEFT="80" WIDTH="216"print machine instructions (disassemble)LEFT="0" WIDTH="72"dLEFT="80" WIDTH="216"print a 16-bit word in signed decimalID="07.mach25"LEFT="0" WIDTH="72"DLEFT="80" WIDTH="216"print a 32-bit word in signed decimalID="07.mach26"LEFT="0" WIDTH="72"ddLEFT="80" WIDTH="216"print a 64-bit word in signed decimalID="07.mach27"LEFT="0" WIDTH="72"oLEFT="80" WIDTH="216"print a 16-bit word in octalLEFT="0" WIDTH="72"OLEFT="80" WIDTH="216"print a 32-bit word in octalID="07.mach28"LEFT="0" WIDTH="72"ooLEFT="80" WIDTH="216"print a 64-bit word in octalLEFT="0" WIDTH="72"xLEFT="80" WIDTH="216"print a 16-bit word in hexadecimalLEFT="0" WIDTH="72"XLEFT="80" WIDTH="216"print a 32-bit word in hexadecimalID="07.mach29"LEFT="0" WIDTH="72"xxLEFT="80" WIDTH="216"print a 64-bit word in hexadecimalLEFT="0" WIDTH="72"vLEFT="80" WIDTH="216"print a 16-bit word in unsigned decimalLEFT="0" WIDTH="72"VLEFT="80" WIDTH="216"print a 32-bit word in unsigned decimalLEFT="0" WIDTH="72"vvLEFT="80" WIDTH="216"print a 64-bit word in unsigned decimalLEFT="0" WIDTH="72"LLEFT="80" WIDTH="216"like X but use with val mask LEFT="0" WIDTH="72"bLEFT="80" WIDTH="216"print a byte in octalID="07.mach30"LEFT="0" WIDTH="72"cLEFT="80" WIDTH="216"print a byte as character LEFT="0" WIDTH="72"sLEFT="80" WIDTH="216"print a string of characters that ends in a null byte LEFT="0" WIDTH="72"fLEFT="80" WIDTH="216"print a single-precision real number LEFT="0" WIDTH="72"gLEFT="80" WIDTH="216"print a double-precision real numberFor example, to display 10 disassembled machine instructions starting at the current address of the program counter, enter:(dbx) $pc/10i
*[main:26, 0x400290]    sw      zero,28(sp)
 [main:27, 0x400294]    sw      zero,24(sp)
 [main:29, 0x400298]    lw      t1,28(sp)
 [main:29, 0x40029c]    lw      t2,32(sp)
 [main:29, 0x4002a0]    nop
 [main:29, 0x4002a4]    slt     at,t1,t2
 [main:29, 0x4002a8]    beq     at,zero,0x4002ec
 [main:29, 0x4002ac]    nop
 [main:31, 0x4002b0]    lw      t3,28(sp)
 [main:31, 0x4002b4]    nopTo disassemble another 10 lines, enter:(dbx) ./
 [main:31, 0x4002b8]    addiu   t4,t3,1
 [main:31, 0x4002bc]    sw      t4,28(sp)
 [main:32, 0x4002c0]    lw      t5,24(sp)
 [main:32, 0x4002c4]    lw      t6,28(sp)
 [main:32, 0x4002c8]    nop
 [main:32, 0x4002cc]    addu    t7,t5,t6
 [main:32, 0x4002d0]    sw      t7,24(sp)
 [main:33, 0x4002d4]    lw      t8,28(sp)
 [main:33, 0x4002d8]    lw      t9,32(sp)
 [main:33, 0x4002dc]    nopTo examine ten 32-bit words starting at address 0x7fffc754, and print those whose least significant byte is hexadecimal 0x19, enter:(dbx) 0x7fffc754 / 10 L 0x19 0xff
7fffc758:  00000019Consider a single-precision floating point array named array. You can examine the six consecutive elements, beginning with the fifth element, by entering:(dbx) &array[4] / 6f
7fffc748:  0.2500000 0.2000000 0.1666667 0.1428571
7fffc758:  0.1250000 0.1111111LBL="" HELPID=""ID="64338"Setting Machine-Level Breakpointsdbx allows you to set breakpoints while debugging machine code just as you can while debugging source code. You set breakpoints at the machine code level using the ID="07.mach31"ID="07.mach32"stopi command.The conditional and unconditional versions of the stopi commands work in the same way as the stop command described in IDREF="23865" TYPE="TITLE""Setting Breakpoints" with these exceptions:The stopi command checks its breakpoint conditions on a machine-instruction level instead of a source-code level.The stopi at command requires an address rather than a line number.Each breakpoint is assigned a number when you create it. Use this number to reference the breakpoint in the various commands provided for manipulating breakpoints (for example, ID="07.mach33"disable, ID="07.mach34"enable, and ID="07.mach35"delete, all described in IDREF="14485" TYPE="TITLE""Managing Breakpoints, Traces, and Conditional Commands").LBL="" HELPID=""Syntax of the stopi CommandThe syntax of the stopi command is:stopi atID="07.mach36"Sets an unconditional breakpoint at the current instruction.ID="07.mach37"stopi atID="07.mach38" addressSets an unconditional breakpoint at the specified address.ID="07.mach39"stopi in procedureSets an unconditional breakpoint to stop execution upon entering the specified procedure.stopi [expression|variable] Inspects the value before executing each machine instruction and stops if the value has changed. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).ID="07.mach40"stopi [expression|variable] at address Inspects the value when the program is at the given address and stops if the value has changed (for machine-level debugging). If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).ID="07.mach41"stopi [expression|variable] in procedure Inspects the value at every machine instruction within a given procedure and stops if the value has changed. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stopi if expressionEvaluates the expression before executing each instruction and stops if the expression is true. Note that execution is very slow if you choose this type of conditional breakpoint.stopi at address if expressionEvaluates the expression at the given address and stops if the expression is true.stopi in procedure if expressionEvaluates the expression at every instruction within a given procedure and stops if the expression is true.stopi [expression1|variable] if expression2 Tests both conditions before executing each machine instruction. Stops if both conditions are true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stopi [expression1|variable] at address if expression2 Tests both conditions at the given address (for machine-level debugging). Stops if both conditions are true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stopi [expression1|variable] in procedure if expression2 Tests the expression each time that the given variable changes within the given procedure. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).NoteWhen you stop execution because of a machine-level breakpoint set by one of the stopi in commands, a ID="07.mach42"where command at the point of stop may yield an incorrect stack trace. This is because the stack for the function is not completely set up until several machine instructions have been executed. dbx attempts to account for this, but is sometimes unsuccessful.LBL="" HELPID=""ID="54393"Linking With DSOsIf you link with a DSO, be careful when you use the stopi at command. For example, suppose you enter:dbx()stopi at functionxThe breakpoint at functionx is hit only if the gp_prolog instruction is executed. (gp_prolog is a short sequence of instructions at the beginning of the routine.) To avoid this problem, use the stopi in command:dbx()stopi in functionxIf you really want to use stopi at, a safe alternative is to disassemble functionx and put the breakpoint after the gp_prolog. For more information on gp_prolog, see the MIPSpro Assembly Language Programmer's Guide.The tracei at, wheni at, and conti at commands described in the following sections also follow this pattern. Use their "in" versions to ensure that the function breakpoint is hit.LBL="" HELPID=""ID="37993"Continuing Execution After a Machine-Level BreakpointThe ID="07.mach43"conti command continues executing assembly code after a breakpoint. As with the ID="07.mach44"ID="07.mach45"cont command, if your program stops because dbx catches a signal intended for your program, then dbx sends that signal to your program when you continue execution. You can also explicitly send a signal to your program when you continue execution. Signal processing and sending signals to your program is discussed in ID="07.mach46"IDREF="25866" TYPE="TITLE""Using Signal Processing".The syntax of the conti command is:contiID="07.mach47" [signal]Continues execution with the current instruction.contiID="07.mach48" [signal] {at | to} addressSets a temporary breakpoint at the specified address, then resumes execution with the current instruction. When your program reaches the breakpoint at address, dbx stops your program and deletes the temporary breakpoint.contiID="07.mach49" [signal] in procedureSets a temporary breakpoint to stop execution upon entering the specified procedure, then resumes execution with the current instruction. When your program reaches the breakpoint in procedure, dbx stops your program and deletes the temporary breakpoint.See also IDREF="54393" TYPE="TITLE""Linking With DSOs" for a description on using the conti in and conti at commands with DSOs.LBL="" HELPID=""ID="81564"Tracing Execution at the Machine LevelThe ID="07.mach50"tracei command allows you to observe the progress of your program while debugging machine code, just as you can with the trace command while debugging source code. The tracei command traces in units of machine instructions instead of in lines of code.Each trace is assigned a number when you create it. Use this number to reference the breakpoint in the various commands provided for manipulating breakpoints (for example, ID="07.mach51"disable, ID="07.mach52"enable, and ID="07.mach53"delete, all described in IDREF="14485" TYPE="TITLE""Managing Breakpoints, Traces, and Conditional Commands").The syntax of the tracei command is:traceiID="07.mach54" [expression|variable] Whenever the specified variable changes, ID="07.mach55"dbx prints the old and new values of that variable. (For machine-level debugging.) Note that execution is very slow if you choose this type of trace.If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).traceiID="07.mach56" procedureThis command is equivalent to entering traceprocedure. dbx prints the values of the parameters passed to the specified procedure whenever your program calls it. Upon return, dbx prints the return value.traceiID="07.mach57" [expression|variable] at address Prints the value of the variable whenever your program reaches the specified address. (For machine-level debugging.) If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).ID="07.mach58"traceiID="07.mach59" [expression|variable] in procedure Whenever the variable changes within the procedure that you specify, ID="07.mach60"dbx prints the old and new values of that variable. (For machine-level debugging.) If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).traceiID="07.mach61" [expression1|variable] at address if expression2 Prints the value of the variable whenever your program reaches the specified address and the given expression is true. (For machine-level debugging.) If ID="07.mach62"expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).traceiID="07.mach63" [expression1|variable] in procedure if expression2 Whenever the variable changes within the procedure that you specify, ID="07.mach64"dbx prints the old and new values of that variable, if the given expression is true. (For machine-level debugging.) If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).See also IDREF="54393" TYPE="TITLE""Linking With DSOs" for a description on using the tracei in and tracei at commands with DSOs.LBL="" HELPID=""ID="94164"Writing Conditional Commands at the Machine LevelUse the ID="07.mach65"wheni command to write conditional commands for use in debugging machine code. The wheni command works in the same way as the when command described in IDREF="89878" TYPE="TITLE""Writing Conditional Commands". The command list is a list of dbx commands, separated by semicolons. When the specified conditions are met, the command list is executed. If one of the commands in the list is stop (with no operands), then the process stops when the command list is executed.wheni ifID="07.mach66" expression {command-list}Evaluates the expression before executing each machine instruction. If the expression is true, executes the command list.wheni at address if expression {command-list}Evaluates the expression at the given address. If the expression is true, executes the command list. wheni in procedure if expression {command-list}Evaluates the expression in the given procedure. If the expression is true, executes the command list. wheniID="07.mach67" variable at address if expression {command-list}Tests both conditions at the given address. If the conditions are true, executes the command list. (For machine-level debugging.) If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).wheni variable in procedure if expression {command-list}Tests both conditions at every machine instruction within a given procedure. If they are true, executes the command list.See also IDREF="54393" TYPE="TITLE""Linking With DSOs" for a description on using the wheni in and wheni at commands with DSOs.LBL="" HELPID=""ID="53669"Stepping Through Machine CodeThe ID="07.mach68"ID="07.mach69"stepi and ID="07.mach70"nexti commands allow you to step through machine code in much the same way you can with the step and next commands while debugging source code. The stepi and nexti commands step in units of machine instructions instead of in lines of code.The formats of the nexti and stepi commands are:nextiID="07.mach71" [integer]Executes the specified number of machine instructions, stepping over procedures. If you do not provide an argument, nexti executes one instruction. If nexti encounters any breakpoints, even in procedures that it steps over, it immediately stops execution.stepiID="07.mach72"Single steps one machine instruction, stepping into procedures (as called by jal and jalr). If stepi encounters any breakpoints, it immediately stops execution.stepiID="07.mach73" [n]Executes the specified number of machine instructions, stepping into procedures (as called by jal and jalr). The value of the dbx variable ID="07.mach74"$stepintoall affects the stepi and nexti commands just as it does the step and next commands. See the section IDREF="31135" TYPE="TITLE""Stepping Through Your Program" in Chapter 6 for a discussion.If your program has DSOs, set the environment variable ID="07.mach75"ID="07.mach76"LD_BIND_NOW to 1 before you run your program. This forces complete run-time linking when your program starts. Otherwise, you could accidentally step into the run-time linker, rld(1), which becomes part of your program at run time.LBL="8"ID="42908"Multiple Process DebuggingThis chapter explains multiprocess debugging procedures, including:ID="08.multiple1"IDREF="12529" TYPE="TITLE""Listing Available Processes"IDREF="45986" TYPE="TITLE""Adding a Process to the Process Pool"IDREF="89656" TYPE="TITLE""Deleting a Process From the Process Pool"IDREF="16095" TYPE="TITLE""Selecting a Process"IDREF="38426" TYPE="TITLE""Suspending a Process"IDREF="87200" TYPE="TITLE""Resuming a Suspended Process"IDREF="12702" TYPE="TITLE""Waiting for a Resumed Process"IDREF="82112" TYPE="TITLE""Waiting for Any Running Process"IDREF="68796" TYPE="TITLE""Killing a Process"IDREF="61470" TYPE="TITLE""Handling fork System Calls"IDREF="10836" TYPE="TITLE""Handling exec System Calls"IDREF="59516" TYPE="TITLE""Handling sproc System Calls and Process Group Debugging"LBL="" HELPID=""Processes and Threadsdbx supports debugging multiprocess applications, including processes spawned with either the ID="08.multiple2"fork(2) or ID="08.multiple3"sproc(2) system calls. You can attach child processes automatically to dbx. You also can perform process control operations on a single process or on all processes in a group.dbx provides commands specifically for seizing, stopping, and debugging currently running processes. When dbx seizes a process, it adds it to a pool of processes available for debugging. Once you select a process from the pool of available processes, you can use all the ID="08.multiple4"dbx commands normally available.Once you are finished with the process, you can terminate it, return it to the pool, or return it to the operating system.dbx also provides limited support for the IRIX pthreads library. You can obtain information about threads, but cannot specify threads in program-control commands.LBL="" HELPID=""Using the pid ClauseMany ID="08.multiple5"dbx commands allow you to append the clause ID="08.multiple6"pidpid (where pid is a numeric process ID or a debugger variable holding a process ID). Using the pidpid clause means you can apply a command to any process in the process pool even though it is not the active process.For example, to set a breakpoint at line 97 of the process whose ID is 12745, enter:(dbx) stop at 97 pid 12745
Process 12745: [3] stop at "/usr/demo/test.c":97Commands that accept the pidpid clause include:active        edit        resume         wait
addproc       file        return         whatis
assign        func        showpoc        when, when[i]
catch         goto        status         where
cont, cont[i] ignore      step, step[i}  whereis
delete        kill        stop, stop[i]  which
delproc       next        suspend
directory     print       trace, trace[i]
down          printf      up
dump          printregs   useLBL="" HELPID=""Using the pgrp ClauseMany dbx commands allow the pgrp clause as a way to apply a command to several processes. For information, see IDREF="59516" TYPE="TITLE""Handling sproc System Calls and Process Group Debugging".LBL="" HELPID=""Using the thread ClauseYou can append the clause ID="08.multiple7"threadtid (where tid is a numeric thread ID, a debugger variable holding a thread ID, or the qualifier all) to some dbx commands that provide program information. You cannot use the threadtid clause with program-control commands such as stop, trace, when or continue. Using the threadtid clause means you can apply a command to any thread even if it is not current or in the current process.The current thread is defined to be the thread that is running in the current process. Examples of the threadtid clause are:(dbx) where thread
(dbx) where thread $no
(dbx) print x thread all The outputs of these commands are respectively: a stack trace of the current thread, a stack trace of the thread whose ID is stored in $no, and the values of all instances of the program variable x in all threads.The showthread command provides status information about the threads in your program. In one dbx session, you cannot debug more than one program that uses threads.The syntax of the showthread command is:ID="08.multiple8"showthread [full]Prints brief status information about the current thread. If the full qualifier is included, prints full status information.showthread [full] [thread] {number | $no | all}Prints brief status information about the thread identified by number or the value of $no, or all threads associated with the debug session. If the full qualifier is included, prints full status information. The thread qualifier does not affect the output, but it is allowed so the syntax can be the same as that for other commands that use the thread clause.LBL="" HELPID=""Using ScriptsAdditionally, dbx provides two variables that you can use when writing scripts to debug multiprocess programs:ID="08.multiple9"$lastchild Always set to the process ID of the last child process created by a fork or sproc.ID="08.multiple10"$pid0 Always set to the process ID of the process started by the run command.See the dbx online help file section on hint_mp_debug for sample multiprocessing debugging scripts.LBL="" HELPID=""ID="12529"Listing Available ProcessesUse the showproc command to list the available processes:showprocID="08.multiple11"Shows processes already in the ID="08.multiple12"dbx process pool or processes that dbx can control. Without any arguments, dbx lists the processes it already controls. showproc allID="08.multiple13"Lists all the processes it controls as well as all those processes it could control but that are not yet added to the process pool.showprocID="08.multiple14" pidShows the status of the process ID.ID="08.multiple15"For example, to display all processes in the process pool, enter:(dbx) showproc
Process 12711 (test) Trace/BPT trap [main:14 ,0x40028c]
Process 12712 (test) Trace/BPT trap [main:18 ,0x4002b4]To display only process 12712, enter:(dbx) showproc 12712
Process 12712 (test) Trace/BPT trap [main:18 ,0x4002b4]To display all processes that dbx can control, enter:(dbx) showproc all
Process 12711 (test) Trace/BPT trap [main:14 ,0x40028c]
Process 12055 (tcsh)
Process 12006 (clock)
Process 12054 (tcsh)
Process 12673 (zipxgizmo)
Process 12672 (zip)
Process 11974 (4Dwm)
Process 12712 (test) Trace/BPT trap [main:18 ,0x4002b4]
Process 12708 (dbx)
Process 12034 (xlock)LBL="" HELPID=""ID="45986"Adding a Process to the Process PoolThe ID="08.multiple16"ID="08.multiple17"addproc command adds one or more specified processes to the dbx process pool. This allows you to debug a program that is already running. The syntax of the addproc command is:addprocpid [ ... ]addprocvarFor example:(dbx) addproc 12924
Reading symbolic information of Process 12924 . . .
Process 12924 (loop_test) added to pool
Process 12924 (loop_test) runningEquivalently, you can enter either of the following:(dbx) set $foo = 12924
(dbx) addproc $fooLBL="" HELPID=""ID="89656"Deleting a Process From the Process PoolThe ID="08.multiple18"ID="08.multiple19"delproc command removes a process or variable from the process pool, freeing it from dbx control. When you delete a process from the process pool, dbx automatically returns the process to normal operation. The syntax of the delproc command is:delprocpid [ ... ]delprocvarFor example:(dbx) delproc 12924
Process 12924 (loop_test) deleted from poolEquivalently, you can enter either of the following:(dbx) set $foo = 12924
(dbx) delproc $fooLBL="" HELPID=""ID="16095"Selecting a ProcessThe dbx command has the ability to control multiple processes. However, dbx commands (by default) apply to only one process at a time, the active process. To select a process from the process pool to be the active process, use the active command:activeID="08.multiple20" [pid]Selects a process, ID="08.multiple21"pid, from dbx process pool as the active process. If you do not provide a process ID, dbx prints the currently active process ID.ID="08.multiple22"For example, to determine which process is currently active, enter:(dbx) active
Process 12976 (test1) is activeTo then select process 12977 as the active process, enter:(dbx) active 12977
Process 12977 (test1) after fork [.fork.fork:15 +0x8,0x4005e8]LBL="" HELPID=""ID="38426"Suspending a ProcessThe suspend command allows you to stop a process in the dbx process pool:suspendID="08.multiple23" Suspends the active process if it is running. If it is not running, this command does nothing.ID="08.multiple24"suspend allID="08.multiple25"Suspends all the processes.ID="08.multiple26"suspend pid ID="08.multiple27"pid Suspends the process ID="08.multiple28"pid if it is in the dbx process pool. If it is not running, this command does nothing.suspend ID="08.multiple29"pgrp Suspends all the processes in the ID="08.multiple30"pgrp.For example, to stop the active process, enter:(dbx) suspend
Process 12987 (loop_test) requested stop [main:10 +0x8,0x400244]
  10  i = i % 10;Then to stop process 12988, enter:(dbx) suspend pid 12988
Process 12988 (test3) requested stop [main:29 +0x4,0x400424]
  10  j = k / 10.0;LBL="" HELPID=""ID="87200"Resuming a Suspended ProcessTo resume execution of a suspended dbx controlled process, you can use either the ID="08.multiple31"cont command or the resume command. If you use cont, you do not return to the dbx command interpreter until the program encounters an event (for example, a breakpoint). On the other hand, the resume command returns immediately to the dbx command interpreter.The syntax of the resume command is:resumeID="08.multiple32" Resumes execution of the program, and returns immediately to the ID="08.multiple33"dbx command interpreter.resumeID="08.multiple34" [signal]Resumes execution of the process, sending it the specified signal, and returns immediately to the ID="08.multiple35"ID="08.multiple36"dbx command interpreter.Because the resume command returns you to the dbx command interpreter after restarting the process, it is more useful than using the cont command when you're debugging multiple processes. With resume, you are free to select and debug a process while another process is running.If any resumed process modifies the terminal modes (for example if it uses curses(3X)), dbx can't correctly control the modes. Intercept programs using curses by typing dbx ­p (or dbx ­P).For example, if you are debugging multiple processes and want to resume the active process, enter:(dbx) resumedbx restarts the active process and returns the dbx prompt. You can then continue debugging, for example by switching to another process.To resume all the processes in pgrp 2 and send a SIGINT signal to the process when dbx resumes, enter:(dbx) resume SIGINT 2LBL="" HELPID=""ID="12702"Waiting for a Resumed ProcessTo wait for a process to stop for an event (such as a breakpoint), use the wait command. This is useful after a resume command. Also refer to the description of the ID="08.multiple37"waitall command, described in IDREF="82112" TYPE="TITLE""Waiting for Any Running Process".The syntax of the wait command is:waitID="08.multiple38" Waits for the active process to stop for an event.ID="08.multiple39"wait pid ID="08.multiple40"pid Waits for the process ID="08.multiple41"pid to stop for an event.For example, assume that you want to wait until process 14280 stops, perhaps at a breakpoint you have set. To do so, enter:(dbx) wait pid 14280After you enter this command, dbx waits until process 14280 stops, at which point it displays the dbx prompt.LBL="" HELPID=""ID="82112"Waiting for Any Running ProcessTo wait for any process currently running to breakpoint or stop for any reason, use the ID="08.multiple42"ID="08.multiple43"waitall command. It causes dbx to wait until a running process in the process list stops, at which point it returns you to the dbx command interpreter.NoteWhen you return to the dbx command interpreter after a waitall command, dbx does not make the process that stopped the active process. You must use the active command to change the active process.For example, to wait until one of your processes under dbx control stops, enter:(dbx) waitallAfter you enter this command, dbx waits until a process stops, at which point it indicates which process stopped and displays the dbx prompt. For example:Process 14281 (loop_test) Terminated [main:10 +0x8,0x400244]
  10  i = i % 10;
(dbx)LBL="" HELPID=""ID="68796"Killing a ProcessTo kill a process in the process pool while running dbx, use the kill command:killID="08.multiple44" Kills the active process. ID="08.multiple45"killID="08.multiple46" pid [ ... ]Kills the specified process(es).ID="08.multiple47"For example, to kill process 14257, enter:(dbx) kill 14257
Process 14257 (fork_test) terminated
Process 14257 (fork_test) deleted from poolLBL="" HELPID=""ID="61470"Handling fork System CallsWhen a program executes a ID="08.multiple48"fork system call and starts another process, dbx allows you to add that process to the process pool. (See also IDREF="93296" TYPE="TITLE""Stopping at System Calls".)The dbx variable ID="08.multiple49"$promptonfork determines how dbx treats forks. IDREF="43416" TYPE="TABLE"Table 8-1 summarizes its effects.COLUMNS="2"LBL="8-1"Table 8-1  (continued)        ID="43416"How the $promptonfork Variable Affects dbx's Treatment of ForksLEFT="0" WIDTH="72"ID="08.multiple50"$promptonfork 
ValueLEFT="80" WIDTH="261"Effect on dbx's Treatment of ForksLEFT="0" WIDTH="72"0 (default)LEFT="80" WIDTH="261"dbx does not add the child process to the process pool. Both the 
child process and the parent process continue to run.LEFT="0" WIDTH="72"1LEFT="80" WIDTH="261"dbx stops the parent process and asks if you want to add the child 
process to the process pool. If you answer yes, then dbx adds the 
child process to the pool and stops the child process; if you 
answer no, dbx allows the child process to run and does not place 
it in the process pool.LEFT="0" WIDTH="72"2LEFT="80" WIDTH="261"dbx automatically stops both the parent and child processes and 
adds the child process to the process pool.NoteIDREF="59516" TYPE="TITLE""Handling sproc System Calls and Process Group Debugging" provides additional information on debugging multiprocessing programs; some of the material in that section can apply also to programs that use the fork system call.Consider a program named fork that contains these lines:main(argc, argv)
int argc;
char *argv;
{
   int pid;
   if ((pid = fork()) == -1)
      perror("fork");
   else if (pid == 0)
      printf("child\n");
   else { printf("parent\n");
}If you set $promptonfork to 1 and run the program, dbx prompts you whether it should add the child process to the process pool:(dbx) set $promptonfork = 1
(dbx) run
Process 22661 (fork) started
Process 22662 (fork) has executed the "fork" system call

Add child to process pool (n if no)?y
Process 22662 (fork) added to pool
Process 22662 (fork) stopped on sysexit fork [_fork:28 ,0x40643a4]
Process 22661 (fork) stopped on sysexit fork [_fork:28 ,0x40643a4]
         Source (of /shamu/lib/libc/libc_64/proc/fork.s) not available for Process 22661LBL="" HELPID=""ID="10836"Handling exec System CallsThe ID="08.multiple51"exec system call executes another program. During an exec, the first program gives up its process number to the program it executes. When a program using DSOs executes an exec() call, dbx runs the new program to main. When a program linked with a non-shared library executes an exec() call, dbx reads the symbolic information for the new program and then stops program execution. In either case, you can continue by entering a cont or resume command.For example, consider the programs exec1.c and exec2.c:/* exec1.c */
main()
{
   printf("in exec1\n");
/* Invoke the "exec2" program */

   execl("exec2", "exec2", 0);

   /* We'll only get here if execl() fails */

   perror("execl");
}
/* exec2.c */
main()
{
   printf("in exec2\n");
}You can enter cont to continue executing exec2. For example:(dbx) cont
in exec2
Process 14409 (exec2) finishedLBL="" HELPID=""ID="59516"Handling sproc System Calls and Process Group DebuggingThe process group facility allows a group of processes to be operated on simultaneously by a single ID="08.multiple52"dbx command. This is more convenient to use when dealing with processes created with the ID="08.multiple53"sproc system call than issuing individual resume, suspend, or breakpoint setting commands. This facility was created to deal more conveniently with parallel programs created, for example, by the Power Fortran Accelerator (PFA).ID="08.multiple54"ID="08.multiple55"The dbx variable ID="08.multiple56"$mp_program determines how dbx treats ID="08.multiple57"sproc system calls. IDREF="92131" TYPE="TABLE"Table 8-2 summarizes its effects.COLUMNS="2"LBL="8-2"Table 8-2 ID="92131"How the $mp_program Variable Affects dbx's Treatment of sprocsLEFT="0" WIDTH="72"$mp_program 
ValueLEFT="80" WIDTH="261"Effect on dbx's Treatment of sprocLEFT="0" WIDTH="72"0 (default)LEFT="80" WIDTH="261"dbx treats calls to sproc in the same way as it treats calls to ID="08.multiple58"fork.LEFT="0" WIDTH="72"1LEFT="80" WIDTH="261"Child processes created by calls to sproc are allowed to run; they 
block on multiprocessor synchronization code emitted by mp 
Fortran or C code. When you set $mp_program to 1, multiprocess 
Fortran or C code is easier to debug.Whenever a process executes a sproc, if dbx adds the child to the process pool, dbx also adds the parent and child to the ID="08.multiple59"group list. The group list is simply a list of processes. If you set the dbx variable ID="08.multiple60"$groupforktoo to 1, then forked processes are added to the group list automatically just as sproced processes are. (By default, $groupforktoo is 0.)You can explicitly add one or more processes to the group list with the ID="08.multiple61"ID="08.multiple62"addpgrp command (you can add only processes in the process pool to the group list):addpgrppid [ ... ]You can remove processes from the group list with the ID="08.multiple63"ID="08.multiple64"delpgrp command:delpgrppid [ ... ]The ID="08.multiple65"ID="08.multiple66"showpgrp command displays information about the group list. The showpgrp command shows the process group numbers and all the stop, trace, or when events in each. These events are created by stop[i], when[i] ... pgrp (which create multiple stop, trace, or when events) and by deletepgrp commands, which delete them.The following example shows the output of the showpgrp command with two processes in the group list:(dbx) showpgrp
2 processes in group:
 14559 14558Once you add processes to the group list (by adding the keyword pgrpID="08.multiple67" to the end of certain dbx commands), you can apply that command to all processes in the group. The commands to which you can append pgrp are: delete, list, next[i], resume, status, stop[i], suspend, trace[i], and when.The breakpoints and traces set by the ID="08.multiple68"ID="08.multiple69"stop[i], trace[i], and when commands, when used with the pgrp keyword, are also added to the ID="08.multiple70"group history. This group history is displayed as a numbered list when you execute showpgrp. To delete breakpoints from multiple processes with a single command, use the group history number with the delete command. For example, to delete the history entry 7 for the process group, enter:(dbx) delete 7 pgrpThe dbx variable ID="08.multiple71"$newpgrpevent stores the group history number of the most recent pgrp event. This can be useful when writing a script, for example:set $myevent = $newpgrpevent
....
delete $myevent pgrpBreakpoints set on the process group are recorded both in the group and in each process. Deleting breakpoints individually (even if set by a group command) is allowed.For example, the following command sets a breakpoint at line 10 in all processes in the group list:(dbx) stop at 10 pgrpProcess 14558: [6] stop at "/usr/demo/pgrp_test.c":10
Process 14559: [7] stop at "/usr/demo/pgrp_test.c":10If you now enter a status command, only those breakpoints associated with the active process are displayed:(dbx) status
Process 14559: [7] {pgrp 269011340} stop at "/usr/demo/pgrp_test.c":10By appending the keyword pgrp, you can display the breakpoints for all processes in the group list:(dbx) status pgrp
Process 14558: [6] {pgrp 269011276} stop at "/usr/demo/pgrp_test.c":10
Process 14559: [7] {pgrp 269011340} stop at "/usr/demo/pgrp_test.c":10Use the showpgrp command to display the group history:(dbx) showpgrp
2 processes in group:
 14559 14558
Group history number: 10
        Process 14558 Process 14558: [6] stop at "/usr/demo/pgrp_test.c":10
        Process 14559 Process 14559: [7] stop at "/usr/demo/pgrp_test.c":10You can delete the breakpoints in both processes by deleting the associated group history entry. For example, enter:(dbx) delete 10 pgrp
(dbx) showpgrp
2 processes in group:
 14559 14558
LBL="A"ID="74957"dbx CommandsAll dbx commands are listed below along with a brief description. For more information about a command, refer to its description in the main text of this guide.;ID="apA.cmd1" Use the semicolon (;) as a separator to include multiple commands on the same command line.\ID="apA.cmd2" Use the backslash (\) at the end of a line of input to dbx to indicate that the command is continued on the next line../ID="apA.cmd3" Repeats the previous examine command by incrementing the address.ID="apA.cmd4"/[reg_exp] Searches forward through the current source file from the current line for the regular expression ID="apA.cmd5"ID="apA.cmd6"reg_exp. If dbx reaches the end of the file without finding the regular expression, it wraps around to the beginning of the file. dbx prints the first source line containing a match of the search expression.If you do not supply reg_exp, dbx searches forward, based on the last regular expression you searched for..?ID="apA.cmd7" Repeats the previous examine command by decrementing the address.ID="apA.cmd8"?[reg_exp] Searches backward through the current source file from the current line for the regular expression ID="apA.cmd9"ID="apA.cmd10"reg_exp. If dbx reaches the beginning of the file without finding the regular expression, it wraps around to the end of the file. dbx prints the first source line containing a match of the search expression.If you do not supply a regular expression, dbx searches backward, based on the last regular expression you searched for.!!ID="apA.cmd11" Repeats the previous command. If the value of the ID="apA.cmd12"dbx variable ID="apA.cmd13"$repeatmode is set to 1, then entering a carriage return at an empty line is equivalent to executing !!. By default, $repeatmode is set to 0.ID="apA.cmd14"!string Repeats the most recent command that starts with the specified ID="apA.cmd15"string.ID="apA.cmd16"!integer Repeats the command associated with the specified ID="apA.cmd17"integer in the history list.ID="apA.cmd18"!-integer Repeats the command that occurred ID="apA.cmd19"integer times before the most recent command. Entering !-1 executes the previous command, !-2 the command before that, and so forth.activeID="apA.cmd20" [pid] Selects a process, ID="apA.cmd21"pid, from dbx process pool as the active process. If you do not provide a process ID, dbx prints the currently active process ID.ID="apA.cmd22"addpgrpID="apA.cmd23" pid [ ... ]Adds the process IDs specified to the group list. Only processes in the process pool can be added to the group list.ID="apA.cmd24"addprocID="apA.cmd25" pid [ ... ]Adds the specified process(es) to the pool of ID="apA.cmd26"dbx controlled processes.ID="apA.cmd27"address ID="apA.cmd28"/ count format Prints the contents of the specified address or disassembles the code for the machine instruction at the specified address. Repeats for a total of ID="apA.cmd29"ID="apA.cmd30"count addresses in increasing addressname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in other words, an examine forward command. The format codes are listed in IDREF="54646" TYPE="TABLE"Table 7-2.address ID="apA.cmd31"? count format Prints the contents of the specified address or disassembles the code for the machine instruction at the specified address. Repeats for a total of ID="apA.cmd32"ID="apA.cmd33"count addresses in decreasing addressname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in other words, an "examine backward" command. The format codes are listed in IDREF="54646" TYPE="TABLE"Table 7-2.address ID="apA.cmd34"/ count L value mask Examines ID="apA.cmd35"count 32-bit words in increasing address and print those 32-bit words which, when ORed with mask, equal value. This command searches memory for specific patterns.alias Lists all existing aliases.ID="apA.cmd36"aliasID="apA.cmd37" name Lists the alias definition for ID="apA.cmd38"name.alias name command Defines ID="apA.cmd39"name as an alias for command.alias name "string" Defines ID="apA.cmd40"name as an alias for string. With this form of the alias command, you can provide command arguments in the alias definition.alias name(arg1 [, ... argN]) "string" Defines ID="apA.cmd41"name as an alias for string. arg1 through argN are arguments to the alias, appearing in the string definition. When you use the alias, you must provide values for the arguments, which dbx then substitutes in string.assignID="apA.cmd42" register = expression Assigns the value of ID="apA.cmd43"expression to register. You must precede the name of the register with a dollar sign ($).assignID="apA.cmd44" variable = expression Assigns the value of ID="apA.cmd45"expression to the program variable, variable.catchID="apA.cmd46" Prints a list of all signals caught.ID="apA.cmd47"catchID="apA.cmd48" {signal | all} Instructs ID="apA.cmd49"dbx to stop your program whenever it receives the specified signal. If you use the keyword all rather than giving a specific signal, dbx catches all signals.ccallID="apA.cmd50" func(arg1, arg2, ... , argn) Calls a function with the given arguments.ID="apA.cmd51"clearcallsID="apA.cmd52" Clears all stopped interactive calls.ID="apA.cmd53"contID="apA.cmd54" Continues execution with the current line.cont {at | to} line Sets a temporary breakpoint at the specified source line, then resumes execution with the current line. When your program reaches the breakpoint at line, dbx stops your program and deletes the temporary breakpoint. The keywords at and to are equivalent.cont in procedure Sets a temporary breakpoint to stop execution upon entering the specified procedure, then resumes execution with the current line. When your program reaches the breakpoint in procedure, dbx stops your program and deletes the temporary breakpoint.cont [signal] Continues execution with the current line and sends the specified signal to your program. If you do not provide a signal, but your program stopped because dbx caught a signal intended for your program, then dbx sends that signal to your program when you continue execution.cont [signal] {at | to} line Sets a temporary breakpoint at the specified source line, then resumes execution with the current line and sends the specified signal to your program. If you do not provide a signal, but your program stopped because dbx caught a signal intended for your program, then dbx sends that signal to your program when you continue execution.cont [signal] in procedure Sets a temporary breakpoint to stop execution upon entering the specified procedure, then resumes execution with the current line and sends the specified signal to your program. If you do not provide a signal, but your program stopped because dbx caught a signal intended for your program, then dbx sends that signal to your program when you continue execution.contiID="apA.cmd55" [signal] Continues execution with the current machine instruction. If you specify a signal, dbx sends the signal to your program. If you do not provide a signal, but your program stopped because dbx caught a signal intended for your program, then dbx sends that signal to your program when you continue execution.conti [signal] {at | to} address Sets a temporary breakpoint at the specified address, then resumes execution with the current machine instruction. When your program reaches the breakpoint at address, dbx stops your program and deletes the temporary breakpoint.If you specify a signal, then dbx sends the signal to your program. If you do not provide a signal, but your program stopped because dbx caught a signal intended for your program, then dbx sends that signal to your program when you continue execution.conti [signal] in procedure Sets a temporary breakpoint to stop execution upon entering the specified procedure, then resumes execution with the current machine instruction. When your program reaches the breakpoint in procedure, dbx stops your program and deletes the temporary breakpoint.If you specify a signal, then dbx sends the signal to your program. If you do not provide a signal, but your program stopped because dbx caught a signal intended for your program, then dbx sends that signal to your program when you continue execution.corefileID="apA.cmd56" [file]If you provide a filename, ID="apA.cmd57"dbx uses the program data stored in the core dump file.If you do not provide a filename, dbx displays the name of the current core file.deleteID="apA.cmd58" {item [, item ...] | all} Deletes the item(s) specified. If you use the keyword all instead of listing individual items, dbx deletes all breakpoints, traces, and conditional commands.ID="apA.cmd59"ID="apA.cmd60"ID="apA.cmd61"delpgrpID="apA.cmd62" pid [ ... ]Deletes the process IDs specified from the group list.ID="apA.cmd63"delprocID="apA.cmd64" pid [ ... ]Deletes the specified process(es) from the pool of ID="apA.cmd65"dbx controlled processes.dirID="apA.cmd66" [dir ...] If you provide one or more directories, ID="apA.cmd67"dbx adds those directories to the end of the source directory list.If you do not provide any directories, dbx displays the current source directory list.disableID="apA.cmd68" item [, item ... ] Disables the item(s) listed. The specified breakpoint(s), trace(s), or conditional command(s) no longer affect program execution. This command has no effect if the item you specify is already disabled.ID="apA.cmd69"ID="apA.cmd70"ID="apA.cmd71"downID="apA.cmd72" [num] Moves down the specified number of activation levels in the stack. The default is one level.ID="apA.cmd73"duelID="apA.cmd74" Invokes duel, the high-level debugging tool. duel alias Shows are current duel aliases. duel clear Deletes all duel aliases.dumpID="apA.cmd75" Prints information about the variables in the current procedure. dump procedure Prints information about the variables in the specified procedure. The procedure must be active.ID="apA.cmd76"dump . Prints information about the variables in all procedures currently active.ID="apA.cmd77"editID="apA.cmd78" [file | procedure] Edits a file. If you set the ID="apA.cmd79"dbx variable ID="apA.cmd80"$editor to the name of an editor, the edit command invokes that editor on the source file. If you do not set the dbx variable $editor, dbx checks whether you have set the environment variable ID="apA.cmd81"EDITOR and, if so, invokes that editor. If you do not set either the dbx variable or the environment variable, dbx invokes the vi editor. When you exit the editor, you return to the dbx prompt.If you supply a filename, edit invokes the editor on that file. If you supply the name of a procedure, edit invokes the editor on the file that contains the source for that procedure. If you do not supply a filename or a procedure name, edit invokes the editor on the current source file.editID="apA.cmd82"pid pid Edits the process ID ID="apA.cmd83"pid clause.enableID="apA.cmd84" item [, item ... ] Enables the item(s) specified. This command activates the specified breakpoint(s), trace(s), or conditional command(s), reversing the effects of a ID="apA.cmd85"ID="apA.cmd86"ID="apA.cmd87"disable command, so that they affect program execution.fileID="apA.cmd88" [file] Changes the current source file to ID="apA.cmd89"ID="apA.cmd90"file. The new file becomes the current source file, on which you can search, list, and perform other operations.funcID="apA.cmd91" Displays the name of the procedure corresponding to the current activation level.func {activation_level | procedure} Changes the current activation level. If you specify an activation level by number, ID="apA.cmd92"dbx changes to that activation level. If you specify procedure, dbx changes to the activation level of that procedure. If you specify a procedure name and that procedure has called itself recursively, dbx changes to the most recently called instance of that procedure. If you specify procedure, dbx changes the current source file to be that procedure, even if the procedure is not active.givenfileID="apA.cmd93" [file] If you provide a filename, ID="apA.cmd94"dbx kills the currently running processes and loads the executable code and debugging information found in file.If you do not provide a filename, dbx displays the name of the program that it is currently debugging.hedID="apA.cmd95"ID="apA.cmd96" Edits only the last line of the history list (the last command executed).ID="apA.cmd97"hedID="apA.cmd98" num1 Edits line ID="apA.cmd99"num1 in the history list.hed num1,num2 Edits the lines in the history list from ID="apA.cmd100"num1 to num2.hed all Edits the entire history list.ID="apA.cmd101"helpID="apA.cmd102" Shows the list of available help sections.ID="apA.cmd103"help allDisplays the entire dbx help file. dbx displays the file using the command name given by the dbxID="apA.cmd104"$pager variable. The dbx help file is large and can be difficult to use if you use a simple paging program like more(1). A useful technique is to set the $pager variable to a text editor like vi(1).help helpExplains how to display the help file in your favorite editor.help sectionShows this help section. dbx displays the file using the command name given by the dbxID="apA.cmd105"$pager variable. (By default, it uses more.) A useful technique is to set the $pager variable to a text editor like vi(1).historyID="apA.cmd106" Prints the commands in the history list.ignoreID="apA.cmd107" Prints a list of all signals ignored.ID="apA.cmd108"ID="apA.cmd109"intercept {all | item}Stops on all C++ exceptions, or exceptions that throw the base type item. intercept unexpected {[all] | [item [, item] ]}Stops on all C++ exceptions that have either no handler or are caught by an "unexpected" handler. You may omit all. If you specify item, stops on exceptions that throw the base type item.intercept ... if expressionYou can append the if clause to all intercept commands. Your program stops only if expression is non-zero. Note that the context for evaluation of expression is the C++ runtime library, not that of the throw, so use global variables or fully qualified names in expression.ignore {signal | all} Instructs ID="apA.cmd110"dbx to ignore the specified signal. All ignored signals are passed to your program normally. If you use the keyword all rather than giving a specific signal, dbx ignores all signals.ID="apA.cmd111"kill Kills the active process. ID="apA.cmd112"kill pid ... Kills the active process(es) whose PIDs are specified.ID="apA.cmd113"listID="apA.cmd114"ID="apA.cmd115" exp Lists ID="apA.cmd116"$listwindow lines starting with the line number given by the expression exp. The expression may be any valid expression that evaluates to an integer value.list exp1:exp2 Lists exp2 lines, beginning at line exp1.list exp1,exp2 Lists all source between line exp1 and line exp2 inclusive.list func Lists ID="apA.cmd117"$listwindow lines starting at procedure func.list func:exp Lists exp2 lines, beginning at func.list func,exp Lists all source between func and exp, inclusive.ID="apA.cmd118"listclones Lists all the root functions and their derived clones. listclones funcLists the root and all derived clones for func.listinlinesLists all of the inlined routines with their start and end addresses.listinlines funcLists all of the inlined versions of func with their start and end addresses.listobjID="apA.cmd119"Lists dynamic shared objects being used. The base application is first in the list.ID="apA.cmd120"listregionsLists all the memory regions being used by the application. Any object region with debugging information is marked with a "Y."nextID="apA.cmd121" [n] Executes the specified number of lines of source code, stepping over procedures. If you do not provide an argument, ID="apA.cmd122"next executes one line. If next encounters any breakpoints, even in procedures that it steps over, it immediately stops execution.nextiID="apA.cmd123" [n] Executes the specified number of machine instructions, stepping over procedures. If you do not provide an argument, nexti executes one line. If nexti encounters any breakpoints, even in procedures which it steps over, it immediately stops execution.pixie clearID="apA.cmd124" Clears the basic block counts for the current execution.pixie write Writes the counts file with the current basic block counts. The counts reflect the exectuion of the program since the run command or since the last pixie clear command, whichever is more recent.playback inputID="apA.cmd125" [file] Executes the commands from ID="apA.cmd126"file. The default file is the current temporary file created for the record input command. If the dbx variable ID="apA.cmd127"$pimode is nonzero, the commands are printed out as they are played back.playback outputID="apA.cmd128" [file] Prints the commands from ID="apA.cmd129"file. The default file is the current temporary file created for the record output command.printID="apA.cmd130" [exp1 [, exp2, ... ] ] Prints the value(s) of the specified expression(s).ID="apA.cmd131"printd ID="apA.cmd132"[exp1 [, exp2, ... ] ]Prints the value(s) of the specified expression(s) in decimal.ID="apA.cmd133"printenvPrints the list of environment variables affecting the program being debugged.printfID="apA.cmd134" string [, exp1 [, exp2, ... ] ] Prints the value(s) of the specified expression(s) in the format specified by the string, ID="apA.cmd135"string. The printf command supports all formats except "%s". For a list of formats, see the printf(3S) reference page.printo ID="apA.cmd136"[exp1 [, exp2, ... ] ]Prints the value(s) of the specified expression(s) in octal.printregsID="apA.cmd137" Prints all register values.ID="apA.cmd138"printx ID="apA.cmd139"[exp1 [, exp2, ... ] ]Prints the value(s) of the specified expression(s) in hexadecimal. quitID="apA.cmd140" Quits ID="apA.cmd141"dbx.recordID="apA.cmd142" Displays the current input and output recording sessions.ID="apA.cmd143"record inputID="apA.cmd144" [file] Records everything you type to ID="apA.cmd145"dbx in file. The default file is a temporary dbx file in the /tmp directory. The name of the temporary file is stored in the dbx variable ID="apA.cmd146"$defaultin.record outputID="apA.cmd147" [file] Records all ID="apA.cmd148"dbx output in file. The default file is a temporary dbx file in the /tmp directory. The name of the temporary file is stored in the dbx variable ID="apA.cmd149"$defaultout. If the dbx variable ID="apA.cmd150"$rimode is nonzero, dbx also records the commands you enter.rerunID="apA.cmd151" run-argumentsWithout any arguments, repeats the last ID="apA.cmd152"run command, if applicable. Otherwise, rerun is equivalent to the run command without any arguments.resumeID="apA.cmd153" Resumes execution of the program, and returns immediately to the ID="apA.cmd154"dbx command interpreter.resume [signal]Resumes execution of the process, sending it the specified signal, and returns immediately to the ID="apA.cmd155"ID="apA.cmd156"dbx command interpreter.returnID="apA.cmd157"Continues execution until control returns to the next procedure on the stack.return proc Continues execution until control returns to the named procedure.runID="apA.cmd158" run-arguments Starts your program and passes to it any arguments that you provide. All shell processing is accepted, such as unglobbing of * and ? in filenames. Redirection of the program's standard input and standard output, and/or standard error is also done by the shell. In other words, the ID="apA.cmd159"ID="apA.cmd160"ID="apA.cmd161"ID="apA.cmd162"run command does exactly what typing target run-arguments does. You can specify a target, either on dbx invocation or in a prior givenfile command. dbx passes ./target as argv[0] to target when you specify it as a relative pathname. You can specify target either on dbx invocation or in a prior givenfile command. dbx passes ./target as argv[0] to target when you specify it as a relative pathname.A run command must appear on a line by itself and cannot be followed by another dbx command. Terminate the command line with a return (new-line). Note that you cannot include a run command in the command list of a when command.setID="apA.cmd163" Displays a list of predefined and user defined variables.ID="apA.cmd164"set var = exp Defines (or redefines) the specified ID="apA.cmd165"dbx variable, setting its value to that of the expression you provide.ID="apA.cmd166"setenvPrints the list of environment variables for the program being debugged.setenv VARSets the environment variable VAR to an empty value.setenv VAR valueSets the environment variable VAR to value, where value is not a dbx variable.setenv VAR $varSets the environment variable VAR to $var, where $var is a dbx variable.setenv VAR "charstring"Sets the environment variable VAR to charstring.shID="apA.cmd167" Invokes a subshell. To return to ID="apA.cmd168"dbx from the subshell, enter exit at the command line, or otherwise terminate the subshell.sh com Executes the specified shell command. ID="apA.cmd169"dbx interprets the remainder of the line as a command to pass to the spawned shell process, unless you enclose the command in double-quotes or you terminate your shell command with a semicolon (;).showpgrpID="apA.cmd170" Shows the group process list and the group history.ID="apA.cmd171"showprocID="apA.cmd172" [pid | all] Shows processes already in the ID="apA.cmd173"dbx process pool or processes that dbx can control. If you provide no arguments, dbx lists the processes it already controls. If you provide a pid, dbx displays the status of the specified process. If you use argument "all," dbx lists all the processes it controls as well as all those processes it could control but that are not yet added to the process pool.ID="apA.cmd174"showthread [full]Prints brief status information about the current thread. If the full qualifier is included, prints full status information.showthread [full] [thread] {number | $no | all}Prints brief status information about the thread identified by number or the value of $no, or all threads associated with the debug session. If the full qualifier is included, prints full status information. The thread qualifier does not affect the output, but it is allowed so the syntax can be the same as that for other commands that use the thread clause.ID="apA.cmd175"source [file] Executes dbx commands from file.statusID="apA.cmd176" Displays all breakpoints, traces, and conditional commands.ID="apA.cmd177"ID="apA.cmd178"ID="apA.cmd179"stepID="apA.cmd180" [n] Executes the specified number of lines of source code, stepping into procedures. If you do not provide an argument, ID="apA.cmd181"step executes one line. If step encounters any breakpoints, it immediately stops execution.stepiID="apA.cmd182"Single steps one machine instruction, stepping into procedures (as called by jal and jalr). If stepi encounters any breakpoints, it immediately stops execution.stepi [n]Executes the specified number of machine instructions, stepping into procedures (as called by jal and jalr). stop atID="apA.cmd183" Set a breakpoint at the current source line.ID="apA.cmd184"stop at line Sets a breakpoint at the specified source line.stop expression Inspects the expression. If the expression is type pointer, checks the data being pointed at. Otherwise, checks the 32 bits at the address given by the expression.stop in procedure Sets a breakpoint to stop execution upon entering the specified procedure. Execution will stop in all inlined or cloned instances of the procedure.ID="apA.cmd185"stop [expression|variable] Inspects the value before executing each source line. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).ID="apA.cmd186"stop [expression|variable] at line Inspects the value at the given source line. Stops if the value has changed. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stop [expression|variable] in procedure Inspects the value at every source line within a given procedure. Stops if the value has changed. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stop if expression Evaluates the expression before executing each source line. Stops if the expression is true.stop at line if expression Evaluates the expression at the given source line. Stops if the expression is true.stop in procedure if expression Evaluates the expression at every source line within a given procedure. Stops if the expression is true.stop [expression1|variable] if expression2 Tests both conditions before executing each source line. Stops if both conditions are true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stop [expression1|variable] at line if expression2 Tests both conditions at the given source line. Stops if both conditions are true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stop [expression1|variable] in procedure if expression2 Tests both conditions at every source line within a given procedure. Stops if both conditions are true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stopi atID="apA.cmd187" Sets an unconditional breakpoint at the current machine instruction.ID="apA.cmd188"stopi at address Sets an unconditional breakpoint at the specified address (for machine-level debugging).ID="apA.cmd189"stopi in procedure Sets an unconditional breakpoint to stop execution upon entering the specified procedure (for machine-level debugging).stopi [expression|variable] Inspects the value before executing each machine instruction and stops if the value has changed. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stopi [expression|variable] at address Inspects the value when the program is at the given address and stops if the value has changed (for machine-level debugging). If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stopi [expression|variable] in procedure Inspects the value at every machine instruction within a given procedure and stops if the value has changed. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stopi if expression Evaluates the expression before executing each machine instruction and stops if the expression is true.stopi at address if expression Evaluates the expression at the given address and stops if the expression is true (for machine-level debugging).stopi in procedure if expression Evaluates the expression at every machine instruction within a given procedure and stops if the expression is true.stopi [expression1|variable] if expression2 Tests both conditions before executing each machine instruction. Stops if both conditions are true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stopi [expression1|variable] at address if expression2 Tests both conditions at the given address (for machine-level debugging). Stops if both conditions are true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stopi [expression1|variable] in procedure if expression2 Tests the expression each time that the given variable changes within the given procedure. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).suspendID="apA.cmd190" Suspends the active process if it is running. If it is not running, this command does nothing. If you use the keyword all, suspends all active processes.suspend pgrp Suspends all the processes in ID="apA.cmd191"pgrp.suspend pid ID="apA.cmd192"pid Suspends the process pid if it is in the dbx process pool. If it is not running, this command does nothing.syscallID="apA.cmd193" Prints a summary of the catch and ignore status of all system calls. The summary is divided into four sections: 1) caught at call, 2) caught at return, 3) ignored at call, and 4) ignored at return.syscall catch [{call | return}] Prints a list of all system calls caught upon entry (ID="apA.cmd194"call) or return (return). If you provide neither the call nor return keyword, dbx lists all system calls that are caught.syscall ignore [{call | return}]Prints a list of all system calls not caught upon entry (ID="apA.cmd195"call) or return (return). If you provide neither the call nor return keyword, dbx lists all system calls that are ignored.syscall catch {call | return} {system_call | all}Sets a breakpoint to stop execution upon entering (ID="apA.cmd196"call) or returning from (return) the specified system call. Note that you can set dbx to catch both the call and the return of a system call.If you use the keyword all rather than giving a specific system call, dbx catches all system calls.syscall ignore {call | return} {system_call | all} Clears the breakpoint to stop execution upon entering (ID="apA.cmd197"call) or returning from (return) the specified system call.If you use the keyword all rather than giving a specific system call, dbx clears the breakpoints to stop execution upon entering (call) or returning from (return) all system calls.ID="apA.cmd198"tag procedureSearches the tag file for the given procedure.traceID="apA.cmd199" variable Whenever the specified variable changes, ID="apA.cmd200"dbx prints the old and new values of that variable.traceID="apA.cmd201" procedurePrints the values of the parameters passed to the specified procedure whenever your program calls it. Upon return, ID="apA.cmd202"dbx prints the return value.trace [expression|variable] at lineWhenever your program reaches the specified line, dbx prints the value of the variable if its value has changed. ID="apA.cmd203"If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).trace [expression|variable] in procedure Whenever the variable changes within the procedure, ID="apA.cmd204"dbx prints the old and new values of that variable. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).trace [expression1|variable] at line if expression2 Prints the value of the variable (if changed) whenever your program reaches the specified line and the given expression is true. ID="apA.cmd205"If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).trace [expression1|variable] in procedure if expression2 Whenever the variable changes within the procedure that you specify, ID="apA.cmd206"dbx prints the old and new values of that variable, if the given expression is true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).traceiID="apA.cmd207" [expression|variable] Whenever the specified variable changes, ID="apA.cmd208"dbx prints the old and new values of that variable. (For machine-level debugging.) If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).tracei procedure This command is equivalent to entering ID="apA.cmd209"traceprocedure. (For machine-level debugging.)tracei [expression|variable] at address Prints the value of the variable whenever your program reaches the specified address. (For machine-level debugging.) ID="apA.cmd210"If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).tracei [expression|variable] in procedure Whenever the variable changes within the procedure that you specify, ID="apA.cmd211"dbx prints the old and new values of that variable. (For machine-level debugging.) If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).tracei [expression1|variable] at address if expression2 Prints the value of the variable whenever your program reaches the specified address and the given expression is true. (For machine-level debugging.) ID="apA.cmd212"If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).tracei [expression1|variable] in procedure if expression2 Whenever the variable changes within the procedure that you specify, ID="apA.cmd213"dbx prints the old and new values of that variable, if the given expression is true. (For machine-level debugging.) If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).unaliasID="apA.cmd214" alias Removes the specified alias.ID="apA.cmd215"unrecordID="apA.cmd216" session1 [, session2 ... ] Turns off the specified recording session(s) and closes the file(s) involved.ID="apA.cmd217"unrecord allID="apA.cmd218" Turns off all recording sessions and closes all files involved.ID="apA.cmd219"unsetID="apA.cmd220" var Removes the specified ID="apA.cmd221"dbx variable.ID="apA.cmd222"unsetenv VARRemoves the specified environment variable.upID="apA.cmd223" [num] Moves up the specified number of activation levels in the stack. The default is one level.ID="apA.cmd224"useID="apA.cmd225" [dir ...]If you provide one or more directories, ID="apA.cmd226"dbx replaces the source directory list with the directories that you provide.If you do not provide any directories, dbx displays the current source directory list.waitID="apA.cmd227" Waits for the active process to stop for an event.ID="apA.cmd228"wait pid pid Waits for the process ID="apA.cmd229"pid to stop for an event.waitallID="apA.cmd230" Waits for any process currently running to breakpoint or stop for any reason.ID="apA.cmd231"whatisID="apA.cmd232" namePrints the type declaration for ID="apA.cmd233"name.whenID="apA.cmd234" [expression|variable] {command-list} Inspects the value before executing each source line. If it has changed, executes the command list. ID="apA.cmd235"If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).when [expression|variable] at line {command-list} Inspects the value at the given source line. If it has changed, executes the command list. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).when [expression|variable] in procedure {command-list} Inspects the value at every source line within a given procedure. If it has changed, executes the command list. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).when if expression {command-list} Evaluates the expression before executing each source line. If it is true, executes the command list.when at line if expression {command-list} Evaluates the expression at the given source line. If it is true, executes the command list.ID="apA.cmd236"when in procedure if expression {command-list} Evaluates the expression at every source line within a given procedure. If it is true, executes the command list.when [expression1|variable] if expression2 {command-list} Checks if the value of the variable has changed. If it has changed and the expression is true, executes the command list. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).when [expression1|variable] at line if expression2 {command-list} Checks if the value of the variable has changed each time the line is executed. If the value has changed and the expression is true, executes the command list. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).when [expression1|variable] in procedure if expression2 {command-list} Checks if the value of variable has changed at each source line of the given procedure. If the value has changed and the expression is true, executes the command list. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).wheni ifID="apA.cmd237" expression {command-list}Evaluates the expression before executing each machine instruction. If the expression is true, executes the command list.wheni at address if expression {command-list}Evaluates the expression at the given address. If the expression is true, executes the command list. (For machine-level debugging.)wheni in procedure if expression {command-list}Evaluates the expression in the given procedure. If the expression is true, executes the command list. (For machine-level debugging.)wheni variable at address if expression {command-list}Tests both conditions at the given address. If the conditions are true, executes the command list. (For machine-level debugging.) If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).wheni variable in procedure if expression {command-list}Tests both conditions at every machine instruction within a given procedure. If they are true, executes the command list.whereID="apA.cmd238" Print a stack trace. ID="apA.cmd239"t is an alias for the where command.ID="apA.cmd240"whereis namePrints the fully qualified names of all versions of ID="apA.cmd241"name. The range of objects examined is determined by $whereisdsolimit.ID="apA.cmd242"which namePrints the fully qualified name of the active version of ID="apA.cmd243"name.whichobjID="apA.cmd244" variableLists the dynamic shared objects that contain variable.LBL="B"ID="56444"Predefined AliasesIDREF="69697" TYPE="TABLE"Table B-1 lists all predefined ID="apB.alias1"dbx aliases. You can override any predefined alias by redefining it with theID="apB.alias2"alias command or by removing it with the ID="apB.alias3"unalias command.COLUMNS="3"LBL="B-1"Table B-1 ID="69697" (continued)        Predefined AliasesLEFT="0" WIDTH="54"AliasLEFT="60" WIDTH="99"DefinitionLEFT="165" WIDTH="189"DescriptionLEFT="0" WIDTH="54"aID="apB.alias4"LEFT="60" WIDTH="99"assignLEFT="165" WIDTH="189"Assigns the specified expression to the 
specified program variable or register.LEFT="0" WIDTH="54"bID="apB.alias5"LEFT="60" WIDTH="99"stop atLEFT="165" WIDTH="189"Sets a breakpoint at the specified line.LEFT="0" WIDTH="54"bpID="apB.alias6"LEFT="60" WIDTH="99"stop inLEFT="165" WIDTH="189"Sets a breakpoint in the specified procedure.LEFT="0" WIDTH="54"cID="apB.alias7"LEFT="60" WIDTH="99"contLEFT="165" WIDTH="189"Continues program execution after a 
breakpoint.LEFT="0" WIDTH="54"dID="apB.alias8"LEFT="60" WIDTH="99"deleteLEFT="165" WIDTH="189"Deletes the specified item from the status list.LEFT="0" WIDTH="54"dirID="apB.alias9"LEFT="60" WIDTH="99"directoryLEFT="165" WIDTH="189"Displays the current source directory list. If 
you specify one or more directories, those 
directories are added to the end of the source 
directory list.LEFT="0" WIDTH="54"eID="apB.alias10"LEFT="60" WIDTH="99"fileLEFT="165" WIDTH="189"Displays the name of the currently selected 
source file. If you specify a file, this command 
makes the specified file the currently selected 
source file.LEFT="0" WIDTH="54"fID="apB.alias11"LEFT="60" WIDTH="99"funcLEFT="165" WIDTH="189"Moves to the specified procedure (activation 
level) on the stack. If you specify no procedure 
or expression, dbx prints the current activation 
level.LEFT="0" WIDTH="54"gID="apB.alias12"LEFT="60" WIDTH="99"gotoLEFT="165" WIDTH="189"Goes to the specified source line.LEFT="0" WIDTH="54"hID="apB.alias13"LEFT="60" WIDTH="99"historyLEFT="165" WIDTH="189"Lists all the items currently in the history list.LEFT="0" WIDTH="54"jID="apB.alias14"LEFT="60" WIDTH="99"statusLEFT="165" WIDTH="189"Lists all the currently set stop,trace, and when 
commands.LEFT="0" WIDTH="54"lID="apB.alias15"LEFT="60" WIDTH="99"listLEFT="165" WIDTH="189"Lists the next $listwindow lines of source code 
beginning at the current line.LEFT="0" WIDTH="54"liID="apB.alias16"LEFT="60" WIDTH="99"$curpc/10i; \set $curpc=$curpc+40LEFT="165" WIDTH="189"Lists the next 40 bytes of machine instructions 
(approximately 10 instructions).LEFT="0" WIDTH="54"nID="apB.alias17"LEFT="60" WIDTH="99"nextLEFT="165" WIDTH="189"Executes the specified number of lines of 
source code, stepping over procedures. If you 
do not provide an argument, dbx executes only 
one line.LEFT="0" WIDTH="54"niID="apB.alias18"LEFT="60" WIDTH="99"nextiLEFT="165" WIDTH="189"Executes the specified number of lines of 
machine code, stepping over procedures. If 
you do not provide an argument, dbx executes 
only one instruction.LEFT="0" WIDTH="54"pID="apB.alias19"LEFT="60" WIDTH="99"printLEFT="165" WIDTH="189"Prints the value of the specified variable or 
expression.LEFT="0" WIDTH="54"pdID="apB.alias20"LEFT="60" WIDTH="99"printdLEFT="165" WIDTH="189"Prints the value of the specified variable in 
decimal.LEFT="0" WIDTH="54"piID="apB.alias21"LEFT="60" WIDTH="99"playback inputLEFT="165" WIDTH="189"Replays dbx commands saved in the specified 
file. If you do not specify a file, dbx uses the 
temporary file specified by $defaultin.LEFT="0" WIDTH="54"poID="apB.alias22"LEFT="60" WIDTH="99"printoLEFT="165" WIDTH="189"Prints the value of the specified variable or 
expression in octal.LEFT="0" WIDTH="54"prID="apB.alias23"LEFT="60" WIDTH="99"printregsLEFT="165" WIDTH="189"Prints values contained in all registers.LEFT="0" WIDTH="54"pxID="apB.alias24"LEFT="60" WIDTH="99"printxLEFT="165" WIDTH="189"Prints the value of the specified variable or 
expression in hexadecimal.LEFT="0" WIDTH="54"qID="apB.alias25"LEFT="60" WIDTH="99"quitLEFT="165" WIDTH="189"Quits dbx.LEFT="0" WIDTH="54"rID="apB.alias26"LEFT="60" WIDTH="99"rerunLEFT="165" WIDTH="189"Runs the program again using the arguments 
specified for the last run command executed.LEFT="0" WIDTH="54"riID="apB.alias27"LEFT="60" WIDTH="99"record inputLEFT="165" WIDTH="189"Records to the specified file all the input you 
give to dbx. If you do not specify a file, dbx 
creates a temporary file. The name of the file is 
specified by $defaultin.LEFT="0" WIDTH="54"roID="apB.alias28"LEFT="60" WIDTH="99"record outputLEFT="165" WIDTH="189"Records all dbx output to the specified file. If 
no file is specified, records output to a 
temporary file. The name of the file is specified 
by $defaultout.LEFT="0" WIDTH="54"sID="apB.alias29"LEFT="60" WIDTH="99"stepLEFT="165" WIDTH="189"Executes the specified number of lines of 
source code, stepping into procedures. If you 
do not provide an argument, dbx executes only 
one line.LEFT="0" WIDTH="54"SID="apB.alias30"LEFT="60" WIDTH="99"nextLEFT="165" WIDTH="189"Executes the specified number of lines of 
source code, stepping over procedures. If you 
do not provide an argument, dbx executes only 
one line.LEFT="0" WIDTH="54"siID="apB.alias31"LEFT="60" WIDTH="99"stepiLEFT="165" WIDTH="189"Executes the specified number of lines of 
machine code, stepping into procedures. If 
you do not provide an argument, dbx executes 
only one instruction.LEFT="0" WIDTH="54"SiID="apB.alias32"LEFT="60" WIDTH="99"nextiLEFT="165" WIDTH="189"Executes the specified number of lines of 
machine code, stepping over procedures. If 
you do not provide an argument, dbx executes 
only one instruction.LEFT="0" WIDTH="54"sourceID="apB.alias33"LEFT="60" WIDTH="99"playback input (pi)LEFT="165" WIDTH="189"Replays dbx commands saved in the specified 
file. If no file is specified, dbx uses the 
temporary file specified by $defaultin.LEFT="0" WIDTH="54"tID="apB.alias34"LEFT="60" WIDTH="99"whereLEFT="165" WIDTH="189"Does a stack trace to show the current 
activation levels.LEFT="0" WIDTH="54"uID="apB.alias35"LEFT="60" WIDTH="99"list $curline-9:10LEFT="165" WIDTH="189"Lists a window of source code showing the 
nine lines before the current code line and the 
current code line. This command does not 
change the current code line.LEFT="0" WIDTH="54"wID="apB.alias36"LEFT="60" WIDTH="99"list $curline-5:10LEFT="165" WIDTH="189"Lists a window of source code around the 
current line. This command shows the four 
lines before the current code line, the current 
code line, and five lines after the current code 
line. This command does not change the 
current code line.LEFT="0" WIDTH="54"WID="apB.alias37"LEFT="60" WIDTH="99"list $curline-10:20LEFT="165" WIDTH="189"Lists a window of source code around the 
current line. This command shows the nine 
lines before the current code line, the current 
code line, and 10 lines after the current code 
line. This command does not change the 
current code line.LEFT="0" WIDTH="54"wiID="apB.alias38"LEFT="60" WIDTH="99"$curpc-20/10iLEFT="165" WIDTH="189"Lists a window of assembly code around the 
program counter.LBL="C"ID="80540"Predefined dbx VariablesID="apC.vars1"ID="apC.vars2"ID="apC.vars3"ID="apC.vars4"ID="apC.vars5"ID="apC.vars6"ID="apC.vars7"ID="apC.vars8"ID="apC.vars9"ID="apC.vars10"ID="apC.vars11"Predefined dbx variables are listed in ID="apC.vars12"IDREF="59961" TYPE="TABLE"Table C-1. The predefined variable names begin with "$" so that they do not conflict with variable, command, or alias names.COLUMNS="3"LBL="C-1"Table C-1 ID="59961" (continued)        Predefined dbx VariablesLEFT="0" WIDTH="100"VariableLEFT="105" WIDTH="46"DefaultLEFT="160" WIDTH="187"DescriptionLEFT="0" WIDTH="100"ID="apC.vars13"$addrfmtLEFT="105" WIDTH="46""0x%x"LEFT="160" WIDTH="187"Specifies the format for addresses. This can be 
set to any format valid for the C language 
printf(3S) function.LEFT="0" WIDTH="100"ID="apC.vars14"$addrfmt64LEFT="105" WIDTH="46""0x%llx"LEFT="160" WIDTH="187"Specifies the format for 64-bit addresses. This 
can be set to any format valid for the C 
language printf(3S) function.LEFT="0" WIDTH="100"ID="apC.vars15"$assignverifyLEFT="105" WIDTH="46"1LEFT="160" WIDTH="187"If nonzero, the new value of a program 
variable will be displayed after the assign command.LEFT="0" WIDTH="100"ID="apC.vars16"$casesenseLEFT="105" WIDTH="46"2LEFT="160" WIDTH="187"If 0, symbol names are case sensitive. If 1, 
symbol names are not case sensitive. If 2, the 
case sensitivity of symbol names depends on 
the case sensitivity of the language in which 
the symbol was defined.ID="apC.vars17"LEFT="0" WIDTH="100"ID="apC.vars18"$ctypenamesLEFT="105" WIDTH="46"1LEFT="160" WIDTH="187"If 1, the words "unsigned," "short," "long," 
"int," "char," "struct," "union," and "enum" 
are keywords usable only in type casts. If 0, 
"struct," "union," and "enum" are ordinary 
words with no predefined meaning (in C 
modules, the others are still known as C 
types).ID="apC.vars19"LEFT="0" WIDTH="100"ID="apC.vars20"$cureventLEFT="105" WIDTH="46"LEFT="160" WIDTH="187"The last event number as seen by the status 
command.LEFT="0" WIDTH="100"ID="apC.vars21"$curlineLEFT="105" WIDTH="46"LEFT="160" WIDTH="187"The current line in the source code being 
executed.LEFT="0" WIDTH="100"ID="apC.vars22"$curpcLEFT="105" WIDTH="46"LEFT="160" WIDTH="187"The current program counter.LEFT="0" WIDTH="100"ID="apC.vars23"$cursrclineLEFT="105" WIDTH="46"LEFT="160" WIDTH="187"The current source listing line plus one.LEFT="0" WIDTH="100"ID="apC.vars24"$defaultinLEFT="105" WIDTH="46"LEFT="160" WIDTH="187"The name of the file that dbx uses when the 
ID="apC.vars25"record input or the playback input command is 
executed with no argument.LEFT="0" WIDTH="100"ID="apC.vars26"$defaultoutLEFT="105" WIDTH="46"LEFT="160" WIDTH="187"The name of the file that dbx uses when the 
record output or the playback output command 
is executed with no argument.LEFT="0" WIDTH="100"ID="apC.vars27"$editorLEFT="105" WIDTH="46"viLEFT="160" WIDTH="187"The name of the editor to invoke (with the ID="apC.vars28"edit 
command). Default value is set to the value of 
the EDITOR environment variable. If EDITOR 
missing, it defaults to vi.LEFT="0" WIDTH="100"ID="apC.vars29"$fp_preciseLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"When nonzero, dbx runs programs on R8000 
processors in floating point precise mode, 
allowing accurate floating point exceptions. 
By default, R8000 floating point interrupts are 
asynchronous and reported program counter 
values are useless for debugging. For more 
information about floating point precise 
mode, see the syssgi(2) reference page section 
on SGI_SET_FP_PRECISE.LEFT="0" WIDTH="100"ID="apC.vars30"$frameregLEFT="105" WIDTH="46"1LEFT="160" WIDTH="187"If 1, all references to registers are to the 
registers of the current activation level. If 0, all 
references are to the hardware registers (the 
registers of activation level 0).LEFT="0" WIDTH="100"ID="apC.vars31"$groupforktooLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If 0, adds only processes created with the 
sproc(2) system call to the process group list 
automatically. If 1, then adds processes 
created with either the fork(2) or sproc system 
calls to process group list.LEFT="0" WIDTH="100"ID="apC.vars32"$hexcharsLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If nonzero, outputs characters in hexadecimal, 
using C format "%x". This affects char type 
variables, including those in structures. It 
does not affect arrays of characters, which are 
printed using the "%.*s" format.LEFT="0" WIDTH="100"ID="apC.vars33"$hexdoublesLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If nonzero, dbx displays floating point and 
double-precision variables both as literals and 
as hexadecimal representations of the bit 
pattern.LEFT="0" WIDTH="100"ID="apC.vars34"$hexinLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If nonzero, input constants are assumed to be 
in hexadecimal. This overrides $octin.LEFT="0" WIDTH="100"ID="apC.vars35"$hexintsLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If nonzero, outputs integers in hexadecimal 
format. This overrides $octints.LEFT="0" WIDTH="100"ID="apC.vars36"$hexstringsLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If nonzero, outputs strings and arrays in 
hexadecimal. For character arrays, if nonzero, 
the null byte is not taken as a terminator. 
Instead, prints the entire array (or $maxlen 
values, whichever is less). If 0, then a null byte 
in a C or C++ character array is taken as the 
end of the array (the length of the array and 
$maxstrlen can terminate the array printing 
before a null byte is found). LEFT="0" WIDTH="100"ID="apC.vars37"$historyeventLEFT="105" WIDTH="46"LEFT="160" WIDTH="187"The current history line number.LEFT="0" WIDTH="100"ID="apC.vars38"$lastchildLEFT="105" WIDTH="46"LEFT="160" WIDTH="187"The process ID of the last child process created 
by a fork or sproc system call.LEFT="0" WIDTH="100"ID="apC.vars39"$linesLEFT="105" WIDTH="46"100LEFT="160" WIDTH="187"The number of lines in the history list.LEFT="0" WIDTH="100"ID="apC.vars40"$listwindowLEFT="105" WIDTH="46"10LEFT="160" WIDTH="187"Specifies how many lines the list command 
lists.LEFT="0" WIDTH="100"ID="apC.vars41"$maxstrlenLEFT="105" WIDTH="46"128LEFT="160" WIDTH="187"Maximum length printed for zero-terminated 
char strings and arrays. Prints char arrays for 
array-length, $maxstrlen bytes, or up to a null 
byte, whichever comes first (see $hexstrings).LEFT="0" WIDTH="100"ID="apC.vars42"$mp_programLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If 0, dbx treats calls to sproc in the same way as 
it treats calls to fork. If 1, child processes 
created by calls to sproc are allowed to run; 
they block on multiprocessor synchronization 
code emitted by mp Fortran code. When you 
set $mp_program to 1, mp Fortran code is 
easier to debug.LEFT="0" WIDTH="100"ID="apC.vars43"$neweventLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"After every command creating an event, this 
variable is set to the event's number. The 
$newevent variable is useful in writing scripts 
that do not use hard-coded event numbers.LEFT="0" WIDTH="100"ID="apC.vars44"$newpgrpeventLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"Stores the number of the latest pgrp event 
created by stop[i], trace[i], and when[i]... pgrp. 
Useful when writing scripts .LEFT="0" WIDTH="100"ID="apC.vars45"$nonstopLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"Only used with addproc or with dbx options -pand-P. If 0, the process that is the argument 
of the command is stopped; if 1, the process is 
not stopped. In either case the process state is 
not changed. If the you start dbx with the ­Noption, then $nonstop = 1.LEFT="0" WIDTH="100"ID="apC.vars46"$octinLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If nonzero, assumes input constants are in 
octal (ID="apC.vars47"ID="apC.vars48"$hexin overrides $octin). LEFT="0" WIDTH="100"ID="apC.vars49"$octintsLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If nonzero, outputs integers in octal format 
(ID="apC.vars50"ID="apC.vars51"$hexints takes precedence).LEFT="0" WIDTH="100"ID="apC.vars52"$pageLEFT="105" WIDTH="46"1LEFT="160" WIDTH="187"Specifies whether or not to page when dbx 
output scrolls information off the current 
screen. A nonzero value turns on paging; a 0 
turns it off.LEFT="0" WIDTH="100"ID="apC.vars53"$pagerLEFT="105" WIDTH="46"moreLEFT="160" WIDTH="187"The name of the program used to display output from ID="apC.vars54"dbx.LEFT="0" WIDTH="100"ID="apC.vars55"$pagewidthLEFT="105" WIDTH="46"80LEFT="160" WIDTH="187"The width of the window in characters 
(assumes a fixed-width font). Used by dbx to 
calculate how many screen lines are output. 
dbx never inserts newlines; the window 
software wraps the lines.LEFT="0" WIDTH="100"ID="apC.vars56"$pagewindowLEFT="105" WIDTH="46"23LEFT="160" WIDTH="187"Specifies how many lines print when 
information is longer than one screen. This 
can be changed to match the number of lines 
on any terminal. If set to 0, 1 is used.LEFT="0" WIDTH="100"ID="apC.vars57"$pendingtrapsLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If nonzero, allows traps that cannot be 
satisfied immediately to wait until they can be 
satisfied. This is useful for debugging 
programs that use DSOs, as it allows setting 
breakpoints before the dlopen() call. When set 
to nonzero, mistyped procedure names are 
not flagged and cause a pending trap to be set. LEFT="0" WIDTH="100"ID="apC.vars58"$piaddtohistLEFT="105" WIDTH="46"1LEFT="160" WIDTH="187"If 1, adds commands read from files using the 
ID="apC.vars59"playback input command to the command 
history. If 0, does not add the commands to the 
history.LEFT="0" WIDTH="100"ID="apC.vars60"$pidLEFT="105" WIDTH="46"LEFT="160" WIDTH="187"The current process for kernel debugging 
(-k).LEFT="0" WIDTH="100"ID="apC.vars61"$pid0LEFT="105" WIDTH="46"LEFT="160" WIDTH="187"Set by dbx to the process ID of the running 
process (also called the object file).LEFT="0" WIDTH="100"ID="apC.vars62"$pimodeLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If 1, dbx prints the commands read from files 
using theID="apC.vars63"playback input command. If 0, dbx 
does not print the commands. In either case, 
dbx prints the output resulting from such 
commands.LEFT="0" WIDTH="100"ID="apC.vars64"$printdataLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"Used when disassembling. If 1, prints register 
contents alongside disassembled instructions. 
If 0, just prints disassembled instructions.LEFT="0" WIDTH="100"ID="apC.vars65"$print_exception_frameLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If nonzero, the display of a kernel exception 
frame by the dumporwhere commands 
includes information that you can use to find 
the contents of the kernel registers at the time 
of the fault.LEFT="0" WIDTH="100"ID="apC.vars66"$printwhilestepLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If 0, prints only the next line to be executed. If 
nonzero, prints each line that is executed 
while it single steps.LEFT="0" WIDTH="100"ID="apC.vars67"$printwideLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If 0, prints arrays, unions, structures and 
classes one element per line. If nonzero, prints 
arrays compactly (wide).LEFT="0" WIDTH="100"ID="apC.vars68"$procaddrLEFT="105" WIDTH="46"LEFT="160" WIDTH="187"This variable applies only if you invoke dbx 
with the -k option (that is, it is not available 
unless you are doing kernel debugging). 
Whenever ID="apC.vars69"$pid is set, dbx sets $procaddr to the 
address of the process table entry for that 
process.LEFT="0" WIDTH="100"ID="apC.vars70"$promptLEFT="105" WIDTH="46"dbxLEFT="160" WIDTH="187"The prompt for ID="apC.vars71"dbx.LEFT="0" WIDTH="100"ID="apC.vars72"$promptonforkLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If 0, dbx does not add the child process to the 
process pool. Both the child process and the 
parent process continue to run.If 1, dbx stops the parent process and asks if 
you want to add the child process to the 
process pool. If you answer yes, then dbx adds 
the child process to the pool and stops the 
child process; if you answer no, dbx allows the 
child process to run and does not place it in 
the process pool.If 2, dbx automatically stops both the parent 
and child processes and adds the child 
process to the process pool.LEFT="0" WIDTH="100"ID="apC.vars73"$regstyleLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If 0, dbx uses the alternate form of the register 
name (for example, "zero" instead of "r0" and 
"t1" instead of "r9"). If nonzero, ID="apC.vars74"dbx uses the 
machine name ("r0" through "r31").LEFT="0" WIDTH="100"ID="apC.vars75"$repeatmodeLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If nonzero, entering a null line (entering a 
newline on an empty line) repeats the last 
command. If 0, ID="apC.vars76"dbx performs no action.LEFT="0" WIDTH="100"ID="apC.vars77"$rimodeLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If 1, dbx records commands you enter in 
addition to output when using the recordoutput command. If 0, dbx does not copy the 
commands.LEFT="0" WIDTH="100"ID="apC.vars78"$shellparametersLEFT="105" WIDTH="46"" "LEFT="160" WIDTH="187"A string that is added by run to the command 
line it passes to the command interpreter, 
SHELL. Use $shellparameters to disable 
spawning of subshells by the initialization file 
of a non-standard shell.LEFT="0" WIDTH="100"ID="apC.vars79"$showbreakaddrsLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If nonzero, show the address of each 
breakpoint placed in the code each time it is 
placed. Removal of the breakpoints is not 
shown. If multiple breakpoints are placed at 
one location, only one of the placements is 
shown. Since breakpoints are frequently 
placed and removed by dbx, the volume of 
output can be annoying when tracing.LEFT="0" WIDTH="100"ID="apC.vars80"$showfilenameLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If 0, step, next, and so on. do not show the 
source file name in the dbx message describing 
the stopped state.If 1, prints just the base file name.If 2, prints the full path.If $stopformat is 1, $showfilename = 0 is treated 
as if $showfilename were 2.LEFT="0" WIDTH="100"$ID="apC.vars81"sourcepathruleLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If 0, search for a source file by: a) using the pathname in the object file's 
debugging information;if the file is not found, then b) examine pathnames remapped by the dir or 
use command; if the file is still not found, thenc) reduce full pathnames to base file names 
and search the list of directories created by the 
dir or use command.If 1, permute the default source-file search 
sequence to: step b, step c, then step a.If 2, use only steps b and c of the default 
source-file search sequence.LEFT="0" WIDTH="100"ID="apC.vars82"$stacktracelimitLEFT="105" WIDTH="46"100LEFT="160" WIDTH="187"Sets the maximum number of frames that will 
be examined by the dump, func, and where 
commands. LEFT="0" WIDTH="100"ID="apC.vars83"$stdcLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If nonzero, attempts in dbx expressions to 
model exactly the promotion rules of ANSI C 
and ISO/IEC 9899 C (even to the point of 
matching float to float rather than converting 
all floating points to doubles).If 0, promotes variables more like traditional 
pcc C (but promotions of 16-bit and 8-bit 
unsigned is to int, not unsigned int).LEFT="0" WIDTH="100"$stepintoallID="apC.vars84"LEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If 0, step steps into all procedures that are 
compiled with debugging options­g,­ g2, or­g3for which line numbers are available in 
the symbol table. Note that standard library 
routines are excluded.If 1, in addition to the procedures above, steps 
into any procedures for which a source file can 
be found. Note that when you debug a source 
file compiled without symbols or compiled 
with optimization, the line numbers may 
jump erratically.If 2, steps into all procedures. Note that if dbx 
cannot locate a source file, then it cannot 
display source lines as you step through a 
procedure.LEFT="0" WIDTH="100"ID="apC.vars85"$stopformatLEFT="105" WIDTH="46"0LEFT="160" WIDTH="187"If 0, stopping messages appear in the 
traditional IRIX dbx format, for example: stopped at [main:32 , 0x400000 
main.c]If 1, messages appear in a more standard BSD 
dbx format:stopped in main at line 32 in file 
"main.c"See affect on $showfilename also.LEFT="0" WIDTH="100"ID="apC.vars86"$tagfileLEFT="105" WIDTH="46"tagsLEFT="160" WIDTH="187"The name of a file of tags, as created by 
ctags(1). Used by the tag command.LEFT="0" WIDTH="100"ID="apC.vars87"$whereisdsolimitLEFT="105" WIDTH="46"1LEFT="160" WIDTH="187"If 1, whereis looks only in main object.If 0, whereis checks all objects.If n, whereis checks first n objects.!! commandIDREF="apA.cmd11"dbx CommandsIDREF="04.cntrl19"Repeating Commands!-integer commandIDREF="04.cntrl23"Repeating CommandsIDREF="apA.cmd18"dbx Commands!integer commandIDREF="04.cntrl22"Repeating CommandsIDREF="apA.cmd16"dbx Commands!string commandIDREF="04.cntrl21"Repeating CommandsIDREF="apA.cmd14"dbx Commands# charactersIDREF="05.change6"OperatorsIDREF="04.cntrl77"Executing dbx ScriptsIDREF="02.run13"dbx Options#define declarationsIDREF="05.change14"Constants// (division) operatorIDREF="05.change10"OperatorsIDREF="05.change9"Operators-c flagIDREF="02.run7"dbx Options-d flagIDREF="02.run9"dbx Options-e flagIDREF="02.run10"dbx Options-g flagIDREF="01.start7"Examining Core Dumps to Determine Cause of FailureIDREF="01.start33"Avoiding Common PitfallsIDREF="05.change103"Printing Stack TracesIDREF="02.run2"Compiling a Program for Debugging Under dbxIDREF="06.exec95"Stepping Using the step CommandIDREF="06.exec96"Stepping Using the step CommandIDREF="03.examin3"Specifying Source Directories-I flagIDREF="02.run14"dbx OptionsIDREF="02.run12"dbx OptionsIDREF="03.examin6"Specifying Source Directories With Arguments-k flagIDREF="02.run18"dbx Options-N flagIDREF="02.run20"dbx Options-P flagIDREF="02.run21"dbx OptionsIDREF="02.run23"dbx Options-R flagIDREF="02.run24"dbx OptionsIDREF="02.run25"dbx Options16-bit wordIDREF="07.mach25"Examining Memory and Disassembling Code32-bit wordIDREF="07.mach26"Examining Memory and Disassembling Code64-bit wordIDREF="07.mach27"Examining Memory and Disassembling Code; (command separator)IDREF="apA.cmd1"dbx CommandsIDREF="02.run53"Entering Multiple Commands on a Single Line? commandIDREF="03.examin30"Searching Through Source CodeIDREF="apA.cmd31"dbx CommandsIDREF="apA.cmd7"dbx CommandsIDREF="07.mach21"Examining Memory and Disassembling CodeIDREF="apA.cmd8"dbx CommandsIDREF="03.examin32"Searching Through Source Code\\ (command continuation)IDREF="02.run54"Spanning a Command Across Multiple LinesIDREF="apA.cmd2"dbx Commandsactivation levelsIDREF="05.change96"Examining the StackchangingIDREF="apA.cmd92"dbx CommandsIDREF="05.change112"Moving to a Specified ProcedurecurrentIDREF="07.mach15"Changing Register Values framesIDREF="05.change96"Examining the Stackmoving downIDREF="apA.cmd73"dbx CommandsIDREF="05.change108"Moving Within the Stackmoving upIDREF="05.change107"Moving Within the StackIDREF="apA.cmd224"dbx Commandsprinting informationIDREF="apA.cmd76"dbx CommandsIDREF="apA.cmd77"dbx CommandsIDREF="05.change117"Printing Activation Level Informationregisters andIDREF="07.mach15"Changing Register Valuesactive commandIDREF="08.multiple20"Selecting a ProcessIDREF="apA.cmd20"dbx Commandsactive processwait forIDREF="08.multiple39"Waiting for a Resumed ProcessIDREF="apA.cmd228"dbx Commandsadd processes to process poolIDREF="08.multiple16"Adding a Process to the Process PoolIDREF="apA.cmd26"dbx Commandsadding processes to the process group listIDREF="apA.cmd24"dbx CommandsIDREF="08.multiple61"Handling sproc System Calls and Process Group DebuggingIDREF="08.multiple59"Handling sproc System Calls and Process Group Debuggingaddpgrp commandIDREF="08.multiple62"Handling sproc System Calls and Process Group DebuggingIDREF="apA.cmd23"dbx Commandsaddproc commandIDREF="apA.cmd25"dbx CommandsIDREF="08.multiple17"Adding a Process to the Process Pooladdress of line numbersIDREF="05.change8"OperatorsIDREF="04.cntrl79"Executing dbx ScriptsIDREF="05.change5"Operators$addrfmtIDREF="apC.vars13"Predefined dbx Variables    $addrfmt64IDREF="apC.vars14"Predefined dbx Variables    alias commandIDREF="apA.cmd27"dbx CommandsIDREF="apA.cmd37"dbx CommandsIDREF="04.cntrl36"Listing AliasesIDREF="apB.alias2"Predefined AliasesIDREF="04.cntrl45"Creating Command AliasesIDREF="04.cntrl38"Listing AliasesIDREF="04.cntrl40"Creating Command AliasesIDREF="04.cntrl43"Creating Command AliasesIDREF="04.cntrl37"Listing AliasesIDREF="04.cntrl41"Creating Command AliasesaliasesIDREF="04.cntrl33"Creating and Removing dbx AliasescreatingIDREF="04.cntrl42"Creating Command AliasesIDREF="apA.cmd40"dbx CommandsIDREF="04.cntrl46"Creating Command AliasesIDREF="apA.cmd41"dbx CommandsIDREF="04.cntrl44"Creating Command AliasesIDREF="04.cntrl39"Creating Command AliasesIDREF="apA.cmd39"dbx CommandsdeletingIDREF="apA.cmd215"dbx CommandsIDREF="04.cntrl47"Removing Command AliasesdisplayingIDREF="apA.cmd36"dbx CommandsIDREF="apA.cmd38"dbx CommandsIDREF="04.cntrl35"Listing Aliasespredefined. See predefined dbx aliasesIDREF="apB.alias1"Predefined AliasesIDREF="04.cntrl34"Creating and Removing dbx Aliasesassign commandIDREF="07.mach13"Changing Register ValuesIDREF="05.change71"Changing the Value of a VariableIDREF="apA.cmd44"dbx CommandsIDREF="07.mach12"Changing Register ValuesIDREF="05.change72"Changing the Value of a VariableIDREF="apA.cmd42"dbx Commandsassign to register commandIDREF="07.mach15"Changing Register Values$assignverifyIDREF="apC.vars15"Predefined dbx Variables    back quotation marks (`)IDREF="05.change57"Qualifying Names of Program ElementsIDREF="06.exec110"Referring to C++ FunctionsIDREF="05.change33"String Constantsbasic block counts, obtainingIDREF="05.change130"Obtaining Basic Blocks Countsblocks, countingIDREF="05.change130"Obtaining Basic Blocks CountsbreakpointsIDREF="06.exec1"Setting BreakpointsIDREF="01.start10"Debugging Your Programsand interactive function callsIDREF="05.change129"Nesting Interactive Function CallsconditionalIDREF="01.start12"Debugging Your ProgramsIDREF="06.exec3"Setting Breakpointscontinuing afterIDREF="06.exec28"Continuing Execution After a BreakpointIDREF="07.mach44"Continuing Execution After a Machine-Level BreakpointIDREF="01.start19"Debugging Your ProgramsdisablingIDREF="06.exec53"Disabling Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd69"dbx CommandsenablingIDREF="06.exec57"Enabling Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd85"dbx Commandsmachine-levelIDREF="07.mach37"Syntax of the stopi CommandIDREF="07.mach31"Setting Machine-Level BreakpointsIDREF="apA.cmd188"dbx CommandsIDREF="07.mach39"Syntax of the stopi CommandIDREF="apA.cmd189"dbx Commandsprocess groupsIDREF="08.multiple68"Handling sproc System Calls and Process Group DebuggingsettingIDREF="06.exec7"Setting Unconditional BreakpointsIDREF="06.exec13"Setting Conditional BreakpointsIDREF="apA.cmd185"dbx CommandsIDREF="01.start14"Debugging Your ProgramsIDREF="apA.cmd184"dbx CommandsstatusIDREF="apA.cmd177"dbx CommandsIDREF="06.exec49"Listing Breakpoints, Traces, and Conditional Commandstest clauseIDREF="06.exec25"Conditional Breakpoints Combining Variable and Test ClausesIDREF="06.exec23"Stopping If a Test Expression Is TrueIDREF="06.exec21"Stopping If a Test Expression Is TrueunconditionalIDREF="06.exec2"Setting BreakpointsIDREF="01.start11"Debugging Your Programsvariable clauseIDREF="06.exec16"Stopping If a Variable or Memory Location Has ChangedIDREF="07.mach41"Syntax of the stopi CommandIDREF="06.exec24"Conditional Breakpoints Combining Variable and Test ClausesIDREF="06.exec14"Stopping If a Variable or Memory Location Has ChangedIDREF="06.exec18"Stopping If a Variable or Memory Location Has ChangedIDREF="06.exec26"Conditional Breakpoints Combining Variable and Test ClausesIDREF="06.exec20"Stopping If a Variable or Memory Location Has ChangedIDREF="apA.cmd186"dbx CommandsIDREF="07.mach40"Syntax of the stopi CommandC keyword conflictsIDREF="apC.vars19"Predefined dbx Variables    C preprocessorIDREF="05.change15"ConstantsC++considerationsIDREF="06.exec105"Referring to C++ FunctionsIDREF="05.change131"Accessing C++ Member Variables exceptionsIDREF="06.exec75"Stopping on C++ Exceptionsglobal functionsIDREF="06.exec107"Referring to C++ Functionsmember functionsIDREF="06.exec106"Referring to C++ Functionsmember variablesIDREF="05.change132"Accessing C++ Member Variablesnon-C++ functionsIDREF="06.exec108"Referring to C++ Functionsoverloaded functionsIDREF="06.exec109"Referring to C++ Functionsstatic member variablesIDREF="05.change133"Accessing C++ Member Variablescase sensitivity of program variable namesIDREF="apC.vars17"Predefined dbx Variables    IDREF="05.change74"Case Sensitivity in Variable Names$casesenseIDREF="05.change75"Case Sensitivity in Variable NamesIDREF="apC.vars16"Predefined dbx Variables    castsIDREF="04.cntrl49"Alias Examplecatch commandIDREF="apA.cmd48"dbx CommandsIDREF="apA.cmd46"dbx Commandscatching signalsIDREF="apA.cmd49"dbx CommandsIDREF="06.exec66"Catching and Ignoring Signalscatching system callsIDREF="06.exec79"Stopping at System CallsIDREF="apA.cmd196"dbx Commandsccall commandIDREF="05.change122"Using ccallIDREF="apA.cmd50"dbx Commandschanging program variable valuesIDREF="apA.cmd45"dbx CommandsIDREF="05.change70"Changing the Value of a Variableclearcalls commandIDREF="05.change127"Using clearcallsIDREF="apA.cmd52"dbx CommandsclonesIDREF="03.examin25"Listing Inlines and Clonesstopping inIDREF="06.exec12"Setting Unconditional Breakpointscode missingIDREF="01.start39"Avoiding Common Pitfalls/ commandIDREF="apA.cmd3"dbx CommandsIDREF="apA.cmd34"dbx CommandsIDREF="03.examin29"Searching Through Source CodeIDREF="apA.cmd4"dbx CommandsIDREF="05.change69"Displaying the Value of a VariableIDREF="07.mach18"Examining Memory and Disassembling CodeIDREF="03.examin31"Searching Through Source CodeIDREF="apA.cmd28"dbx Commands commands/IDREF="03.examin29"Searching Through Source CodeIDREF="apA.cmd28"dbx CommandsIDREF="apA.cmd34"dbx CommandsIDREF="03.examin31"Searching Through Source CodeIDREF="07.mach18"Examining Memory and Disassembling CodeIDREF="apA.cmd3"dbx CommandsIDREF="apA.cmd4"dbx CommandsIDREF="05.change69"Displaying the Value of a Variable!!IDREF="apA.cmd11"dbx CommandsIDREF="04.cntrl19"Repeating Commands!-integerIDREF="apA.cmd18"dbx CommandsIDREF="04.cntrl23"Repeating Commands!integerIDREF="04.cntrl22"Repeating CommandsIDREF="apA.cmd16"dbx Commands!stringIDREF="apA.cmd14"dbx CommandsIDREF="04.cntrl21"Repeating Commands?IDREF="03.examin32"Searching Through Source CodeIDREF="07.mach21"Examining Memory and Disassembling CodeIDREF="apA.cmd7"dbx CommandsIDREF="apA.cmd31"dbx CommandsIDREF="apA.cmd8"dbx CommandsIDREF="03.examin30"Searching Through Source CodenextIDREF="01.start22"Studying a New ProgramprintIDREF="01.start24"Studying a New ProgramIDREF="01.start21"Studying a New ProgramrerunIDREF="01.start16"Debugging Your ProgramsrunIDREF="01.start15"Debugging Your ProgramsstepIDREF="01.start23"Studying a New ProgramstopIDREF="01.start13"Debugging Your ProgramstraceIDREF="01.start27"Studying a New ProgramwhereIDREF="01.start6"Examining Core Dumps to Determine Cause of Failurecommand continuationIDREF="02.run54"Spanning a Command Across Multiple LinesIDREF="apA.cmd2"dbx Commandscommand scriptscommentsIDREF="04.cntrl78"Executing dbx ScriptsIDREF="05.change7"Operatorscommand separator (;)IDREF="02.run53"Entering Multiple Commands on a Single LineIDREF="apA.cmd1"dbx CommandscommandsactiveIDREF="apA.cmd20"dbx CommandsIDREF="08.multiple20"Selecting a ProcessaddpgrpIDREF="08.multiple62"Handling sproc System Calls and Process Group DebuggingIDREF="apA.cmd23"dbx CommandsaddprocIDREF="08.multiple17"Adding a Process to the Process PoolIDREF="apA.cmd25"dbx CommandsaliasIDREF="04.cntrl43"Creating Command AliasesIDREF="04.cntrl38"Listing AliasesIDREF="apA.cmd27"dbx CommandsIDREF="04.cntrl45"Creating Command AliasesIDREF="apA.cmd37"dbx CommandsIDREF="04.cntrl36"Listing AliasesIDREF="04.cntrl40"Creating Command AliasesIDREF="04.cntrl41"Creating Command AliasesIDREF="04.cntrl37"Listing AliasesIDREF="apB.alias2"Predefined AliasesassignIDREF="07.mach13"Changing Register ValuesIDREF="05.change71"Changing the Value of a VariableIDREF="05.change72"Changing the Value of a VariableIDREF="apA.cmd42"dbx CommandsIDREF="07.mach12"Changing Register ValuesIDREF="apA.cmd44"dbx Commandsassign registerIDREF="07.mach16"Changing Register ValuescatchIDREF="apA.cmd46"dbx CommandsIDREF="apA.cmd48"dbx CommandsccallIDREF="05.change122"Using ccallIDREF="apA.cmd50"dbx CommandsclearcallsIDREF="apA.cmd52"dbx CommandsIDREF="05.change127"Using clearcallscontIDREF="apA.cmd54"dbx CommandsIDREF="07.mach45"Continuing Execution After a Machine-Level BreakpointIDREF="08.multiple31"Resuming a Suspended ProcessIDREF="06.exec72"Continuing After Catching a SignalIDREF="06.exec103"Starting at a Specified LineIDREF="06.exec27"Continuing Execution After a BreakpointcontiIDREF="07.mach43"Continuing Execution After a Machine-Level BreakpointIDREF="07.mach48"Continuing Execution After a Machine-Level BreakpointIDREF="07.mach47"Continuing Execution After a Machine-Level BreakpointIDREF="apA.cmd55"dbx CommandsIDREF="07.mach49"Continuing Execution After a Machine-Level BreakpointcorefileIDREF="02.run36"Specifying Files with dbx CommandsIDREF="02.run34"Specifying Files with dbx CommandsIDREF="apA.cmd56"dbx CommandsdeleteIDREF="apA.cmd58"dbx CommandsIDREF="07.mach35"Setting Machine-Level BreakpointsIDREF="07.mach53"Tracing Execution at the Machine LevelIDREF="06.exec6"Setting BreakpointsIDREF="06.exec61"Deleting Breakpoints, Traces, and Conditional CommandsIDREF="06.exec34"Tracing Program ExecutionIDREF="06.exec60"Deleting Breakpoints, Traces, and Conditional CommandsdelpgrpIDREF="apA.cmd62"dbx CommandsIDREF="08.multiple64"Handling sproc System Calls and Process Group DebuggingdelprocIDREF="apA.cmd64"dbx CommandsIDREF="08.multiple19"Deleting a Process From the Process PooldirIDREF="apA.cmd66"dbx CommandsIDREF="03.examin14"Path RemappingIDREF="03.examin9"Specifying Source Directories With dbx CommandsIDREF="03.examin7"Specifying Source Directories With dbx CommandsIDREF="02.run17"dbx OptionsdisableIDREF="07.mach33"Setting Machine-Level BreakpointsIDREF="07.mach51"Tracing Execution at the Machine LevelIDREF="06.exec52"Disabling Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd68"dbx CommandsIDREF="06.exec32"Tracing Program ExecutionIDREF="06.exec4"Setting BreakpointsdownIDREF="apA.cmd72"dbx CommandsIDREF="05.change106"Moving Within the StackduelIDREF="apA.cmd74"dbx CommandsIDREF="05.change79"Using the High-Level Debugging Language duel dumpIDREF="apA.cmd75"dbx CommandsIDREF="05.change120"Printing Activation Level InformationIDREF="05.change116"Printing Activation Level InformationIDREF="05.change119"Printing Activation Level InformationIDREF="05.change118"Printing Activation Level InformationeditIDREF="03.examin35"Calling an EditorIDREF="apC.vars28"Predefined dbx Variables    IDREF="apA.cmd82"dbx CommandsIDREF="03.examin33"Calling an EditorIDREF="apA.cmd78"dbx CommandsenableIDREF="07.mach34"Setting Machine-Level BreakpointsIDREF="06.exec56"Enabling Breakpoints, Traces, and Conditional CommandsIDREF="06.exec33"Tracing Program ExecutionIDREF="apA.cmd84"dbx CommandsIDREF="06.exec5"Setting BreakpointsIDREF="07.mach52"Tracing Execution at the Machine LevelfileIDREF="apA.cmd88"dbx CommandsIDREF="03.examin17"Changing Source FilesfuncIDREF="apA.cmd91"dbx CommandsIDREF="05.change114"Moving to a Specified ProcedureIDREF="05.change113"Moving to a Specified ProcedureIDREF="05.change111"Moving to a Specified ProceduregivenfileIDREF="02.run35"Specifying Files with dbx CommandsIDREF="apA.cmd93"dbx CommandsIDREF="02.run33"Specifying Files with dbx CommandsgotoIDREF="apA.cmd95"dbx CommandsIDREF="06.exec104"Starting at a Specified LinehedIDREF="04.cntrl29"The History EditorIDREF="04.cntrl31"The History EditorIDREF="apA.cmd98"dbx CommandsIDREF="04.cntrl25"The History EditorIDREF="apA.cmd96"dbx CommandsIDREF="04.cntrl30"The History EditorhelpIDREF="apA.cmd102"dbx CommandsIDREF="02.run51"Using Online HelphistoryIDREF="apA.cmd106"dbx CommandsIDREF="04.cntrl16"Examining the History ListignoreIDREF="06.exec65"Catching and Ignoring SignalsIDREF="06.exec70"Catching and Ignoring SignalsIDREF="apA.cmd107"dbx CommandsIDREF="06.exec67"Catching and Ignoring SignalsinterceptIDREF="apA.cmd109"dbx CommandsIDREF="06.exec76"Stopping on C++ ExceptionskillIDREF="apA.cmd111"dbx CommandsIDREF="08.multiple44"Killing a ProcessIDREF="08.multiple46"Killing a ProcesslistIDREF="03.examin21"Listing Source CodeIDREF="apA.cmd114"dbx CommandslistclonesIDREF="03.examin27"Listing Inlines and ClonesIDREF="apA.cmd118"dbx CommandslistinlinesIDREF="03.examin26"Listing Inlines and CloneslistobjIDREF="apA.cmd119"dbx CommandsIDREF="02.run4"Compiling and Linking Programs With Dynamic Shared ObjectslistregionsIDREF="apA.cmd120"dbx CommandsIDREF="07.mach17"Examining Memory and Disassembling CodenextIDREF="06.exec100"Stepping Using the next CommandIDREF="06.exec93"Stepping Through Your ProgramIDREF="apA.cmd121"dbx CommandsnextiIDREF="07.mach70"Stepping Through Machine CodeIDREF="07.mach71"Stepping Through Machine CodeIDREF="apA.cmd123"dbx CommandspixieIDREF="05.change130"Obtaining Basic Blocks CountsIDREF="apA.cmd124"dbx Commandsplayback inputIDREF="04.cntrl76"Executing dbx ScriptsIDREF="apC.vars63"Predefined dbx Variables    IDREF="apC.vars7"Predefined dbx Variables    IDREF="04.cntrl56"Recording InputIDREF="apC.vars59"Predefined dbx Variables    IDREF="apA.cmd125"dbx Commandsplayback outputIDREF="apC.vars6"Predefined dbx Variables    IDREF="apA.cmd128"dbx CommandsprintIDREF="04.cntrl7"Setting dbx VariablesIDREF="apA.cmd130"dbx CommandsIDREF="05.change61"Displaying the Value of a VariableIDREF="05.change35"Printing ExpressionsprintdIDREF="05.change36"Printing ExpressionsIDREF="apA.cmd132"dbx CommandsIDREF="05.change62"Displaying the Value of a VariableprintenvIDREF="apA.cmd133"dbx CommandsIDREF="05.change76"Displaying and Changing Environment Variables Used by a ProgramprintfIDREF="apA.cmd134"dbx CommandsIDREF="05.change42"Printing ExpressionsIDREF="05.change63"Displaying the Value of a VariableprintoIDREF="05.change38"Printing ExpressionsIDREF="apA.cmd136"dbx CommandsIDREF="05.change64"Displaying the Value of a VariableprintregsIDREF="apA.cmd137"dbx CommandsIDREF="07.mach5"Printing Register ValuesprintxIDREF="05.change40"Printing ExpressionsIDREF="apA.cmd139"dbx CommandsIDREF="05.change65"Displaying the Value of a VariablequitIDREF="apA.cmd140"dbx CommandsIDREF="02.run59"Quitting dbxrecordIDREF="apA.cmd142"dbx CommandsIDREF="04.cntrl72"Examining the Record Staterecord inputIDREF="apC.vars25"Predefined dbx Variables    IDREF="apA.cmd144"dbx CommandsIDREF="04.cntrl64"Playing Back InputIDREF="04.cntrl55"Recording Inputrecord outputIDREF="apC.vars1"Predefined dbx Variables    IDREF="apA.cmd147"dbx CommandsIDREF="04.cntrl69"Recording OutputrerunIDREF="02.run39"Running Your ProgramIDREF="apA.cmd151"dbx CommandsIDREF="02.run46"Running Your ProgramresumeIDREF="08.multiple32"Resuming a Suspended ProcessIDREF="apA.cmd153"dbx CommandsIDREF="06.exec31"Continuing Execution After a BreakpointIDREF="08.multiple34"Resuming a Suspended ProcessreturnIDREF="06.exec102"Using the return CommandIDREF="06.exec101"Using the return CommandIDREF="apA.cmd157"dbx CommandsrunIDREF="02.run40"Running Your ProgramIDREF="apA.cmd158"dbx CommandsIDREF="02.run38"Running Your Programsearch backward (?)IDREF="apA.cmd8"dbx CommandsIDREF="03.examin32"Searching Through Source CodeIDREF="03.examin30"Searching Through Source Codesearch forward (/)IDREF="03.examin31"Searching Through Source CodeIDREF="03.examin29"Searching Through Source CodeIDREF="apA.cmd4"dbx CommandssetIDREF="apA.cmd163"dbx CommandsIDREF="04.cntrl4"Setting dbx VariablesIDREF="04.cntrl5"Setting dbx VariablesIDREF="05.change30"String ConstantsIDREF="04.cntrl9"Listing dbx VariablessetenvIDREF="05.change77"Displaying and Changing Environment Variables Used by a ProgramIDREF="02.run45"Running Your ProgramIDREF="apA.cmd166"dbx CommandsshIDREF="02.run56"Invoking a ShellIDREF="apA.cmd167"dbx CommandsshowpgrpIDREF="08.multiple66"Handling sproc System Calls and Process Group DebuggingIDREF="apA.cmd170"dbx CommandsshowprocIDREF="08.multiple14"Listing Available ProcessesIDREF="08.multiple13"Listing Available ProcessesIDREF="08.multiple11"Listing Available ProcessesIDREF="apA.cmd172"dbx CommandsshowthreadIDREF="08.multiple8"Using the thread ClauseIDREF="apA.cmd174"dbx CommandsstatusIDREF="apA.cmd176"dbx CommandsIDREF="06.exec48"Listing Breakpoints, Traces, and Conditional CommandsIDREF="04.cntrl62"Ending a Recording SessionstepIDREF="06.exec92"Stepping Through Your ProgramIDREF="apA.cmd180"dbx CommandsIDREF="06.exec94"Stepping Using the step CommandstepiIDREF="07.mach72"Stepping Through Machine CodeIDREF="07.mach69"Stepping Through Machine CodeIDREF="apA.cmd182"dbx CommandsIDREF="07.mach73"Stepping Through Machine CodestopIDREF="06.exec8"Setting Unconditional BreakpointsIDREF="06.exec15"Stopping If a Variable or Memory Location Has ChangedIDREF="06.exec19"Stopping If a Variable or Memory Location Has ChangedIDREF="06.exec10"Setting Unconditional BreakpointsIDREF="apA.cmd183"dbx CommandsIDREF="06.exec9"Setting Unconditional BreakpointsIDREF="06.exec17"Stopping If a Variable or Memory Location Has ChangedIDREF="06.exec22"Stopping If a Test Expression Is TruestopiIDREF="07.mach32"Setting Machine-Level BreakpointsIDREF="07.mach36"Syntax of the stopi CommandIDREF="07.mach38"Syntax of the stopi CommandIDREF="apA.cmd187"dbx CommandssuspendIDREF="08.multiple29"Suspending a ProcessIDREF="apA.cmd190"dbx CommandsIDREF="08.multiple25"Suspending a ProcessIDREF="08.multiple23"Suspending a ProcessIDREF="08.multiple27"Suspending a ProcessIDREF="apA.cmd192"dbx CommandssyscallIDREF="06.exec78"Stopping at System CallsIDREF="06.exec80"Stopping at System CallsIDREF="06.exec77"Stopping at System CallsIDREF="apA.cmd193"dbx CommandstagIDREF="apA.cmd198"dbx CommandstraceIDREF="06.exec37"Tracing Program ExecutionIDREF="apA.cmd199"dbx CommandsIDREF="06.exec41"Tracing Program ExecutionIDREF="06.exec39"Tracing Program ExecutionIDREF="apA.cmd201"dbx CommandsIDREF="06.exec35"Tracing Program ExecutiontraceiIDREF="07.mach59"Tracing Execution at the Machine LevelIDREF="07.mach50"Tracing Execution at the Machine LevelIDREF="07.mach57"Tracing Execution at the Machine LevelIDREF="07.mach61"Tracing Execution at the Machine LevelIDREF="07.mach54"Tracing Execution at the Machine LevelIDREF="apA.cmd207"dbx CommandsIDREF="07.mach56"Tracing Execution at the Machine LevelIDREF="07.mach63"Tracing Execution at the Machine LevelunaliasIDREF="apB.alias3"Predefined AliasesIDREF="apA.cmd214"dbx CommandsIDREF="04.cntrl48"Removing Command AliasesunrecordIDREF="04.cntrl60"Ending a Recording SessionIDREF="apA.cmd216"dbx CommandsIDREF="apA.cmd218"dbx CommandsIDREF="04.cntrl59"Ending a Recording SessionunsetIDREF="apA.cmd220"dbx CommandsIDREF="04.cntrl11"Removing VariablesunsetenvIDREF="apA.cmd222"dbx CommandsIDREF="05.change78"Displaying and Changing Environment Variables Used by a ProgramupIDREF="apA.cmd223"dbx CommandsIDREF="05.change105"Moving Within the StackuseIDREF="apA.cmd225"dbx CommandsIDREF="02.run16"dbx OptionsIDREF="03.examin8"Specifying Source Directories With dbx CommandsIDREF="03.examin11"Specifying Source Directories With dbx CommandswaitIDREF="apA.cmd227"dbx CommandsIDREF="08.multiple40"Waiting for a Resumed ProcessIDREF="08.multiple38"Waiting for a Resumed ProcesswaitallIDREF="apA.cmd230"dbx CommandsIDREF="08.multiple43"Waiting for Any Running ProcessIDREF="08.multiple37"Waiting for a Resumed ProcesswhatisIDREF="05.change94"Displaying Type DeclarationsIDREF="apA.cmd232"dbx CommandswhenIDREF="06.exec45"Writing Conditional CommandsIDREF="apA.cmd234"dbx CommandswheniIDREF="07.mach66"Writing Conditional Commands at the Machine LevelIDREF="apA.cmd237"dbx CommandsIDREF="07.mach65"Writing Conditional Commands at the Machine LevelIDREF="07.mach67"Writing Conditional Commands at the Machine LevelwhereIDREF="07.mach42"Syntax of the stopi CommandIDREF="apA.cmd238"dbx CommandsIDREF="05.change101"Printing Stack TraceswhereisIDREF="05.change91"Determining Variable Scopes and Fully Qualified NamesIDREF="05.change52"Qualifying Names of Program ElementsIDREF="05.change50"Qualifying Names of Program ElementsIDREF="apA.cmd240"dbx CommandswhichIDREF="05.change53"Qualifying Names of Program ElementsIDREF="05.change49"Qualifying Names of Program ElementsIDREF="05.change90"Determining Variable Scopes and Fully Qualified NamesIDREF="apA.cmd242"dbx CommandswhichobjIDREF="02.run5"Compiling and Linking Programs With Dynamic Shared ObjectsIDREF="apA.cmd244"dbx Commandscomments, command scriptsIDREF="05.change7"OperatorsIDREF="04.cntrl78"Executing dbx Scriptscommon pitfallsIDREF="01.start31"Avoiding Common Pitfallscompiling a program for dbx debuggingIDREF="02.run1"Compiling a Program for Debugging Under dbxconditional breakpointsIDREF="01.start12"Debugging Your ProgramsIDREF="06.exec3"Setting BreakpointssettingIDREF="06.exec13"Setting Conditional Breakpointstest clauseIDREF="06.exec23"Stopping If a Test Expression Is TrueIDREF="06.exec21"Stopping If a Test Expression Is TrueIDREF="06.exec25"Conditional Breakpoints Combining Variable and Test Clausesvariable clauseIDREF="06.exec18"Stopping If a Variable or Memory Location Has ChangedIDREF="apA.cmd186"dbx CommandsIDREF="07.mach40"Syntax of the stopi CommandIDREF="07.mach41"Syntax of the stopi CommandIDREF="06.exec16"Stopping If a Variable or Memory Location Has ChangedIDREF="06.exec20"Stopping If a Variable or Memory Location Has ChangedIDREF="06.exec14"Stopping If a Variable or Memory Location Has ChangedIDREF="06.exec24"Conditional Breakpoints Combining Variable and Test ClausesIDREF="06.exec26"Conditional Breakpoints Combining Variable and Test Clausesconditional commandsdeletingIDREF="apA.cmd59"dbx CommandsIDREF="apA.cmd61"dbx CommandsIDREF="06.exec62"Deleting Breakpoints, Traces, and Conditional CommandsIDREF="06.exec64"Deleting Breakpoints, Traces, and Conditional CommandsdisablingIDREF="apA.cmd71"dbx CommandsIDREF="06.exec55"Disabling Breakpoints, Traces, and Conditional CommandsenablingIDREF="06.exec59"Enabling Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd87"dbx CommandssettingIDREF="06.exec43"Writing Conditional CommandsstatusIDREF="06.exec51"Listing Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd179"dbx Commandsstop keywordIDREF="06.exec44"Writing Conditional Commandstest clauseIDREF="apA.cmd236"dbx CommandsIDREF="06.exec47"Writing Conditional Commandsvariable clauseIDREF="apA.cmd235"dbx CommandsIDREF="06.exec46"Writing Conditional Commandsconflicts between program variable names and C keywordsIDREF="apC.vars19"Predefined dbx Variables    conflicts between program variable names and keywordsIDREF="05.change73"Conflicts Between Variable Names and KeywordsconstantsnumericIDREF="05.change16"Numeric ConstantsIDREF="05.change12"ConstantsstringIDREF="05.change29"String ConstantsIDREF="05.change13"Constantscont commandIDREF="06.exec27"Continuing Execution After a BreakpointIDREF="07.mach45"Continuing Execution After a Machine-Level BreakpointIDREF="06.exec103"Starting at a Specified LineIDREF="08.multiple31"Resuming a Suspended ProcessIDREF="apA.cmd54"dbx CommandsIDREF="06.exec72"Continuing After Catching a Signalconti commandIDREF="apA.cmd55"dbx CommandsIDREF="07.mach47"Continuing Execution After a Machine-Level BreakpointIDREF="07.mach48"Continuing Execution After a Machine-Level BreakpointIDREF="07.mach49"Continuing Execution After a Machine-Level BreakpointIDREF="07.mach43"Continuing Execution After a Machine-Level Breakpointcontinuing after a breakpointIDREF="01.start19"Debugging Your ProgramsIDREF="07.mach44"Continuing Execution After a Machine-Level BreakpointIDREF="06.exec28"Continuing Execution After a Breakpointcontinuing after catching signalsIDREF="06.exec73"Continuing After Catching a SignalIDREF="06.exec74"Continuing After Catching a Signalcore dumpIDREF="02.run28"Specifying Object and Core FilesIDREF="01.start2"Examining Core Dumps to Determine Cause of Failurecore filesIDREF="01.start3"Examining Core Dumps to Determine Cause of FailurespecifyingIDREF="apA.cmd57"dbx CommandsIDREF="02.run30"Specifying Object and Core Filescorefile commandIDREF="02.run36"Specifying Files with dbx CommandsIDREF="apA.cmd56"dbx CommandsIDREF="02.run34"Specifying Files with dbx Commandscrashes, diagnosingIDREF="01.start2"Examining Core Dumps to Determine Cause of Failurecreating aliasesIDREF="apA.cmd39"dbx CommandsIDREF="apA.cmd40"dbx CommandsIDREF="apA.cmd41"dbx CommandsIDREF="04.cntrl39"Creating Command AliasesIDREF="04.cntrl42"Creating Command AliasesIDREF="04.cntrl44"Creating Command AliasesIDREF="04.cntrl46"Creating Command Aliases$ctypenamesIDREF="apC.vars18"Predefined dbx Variables    $cureventIDREF="apC.vars20"Predefined dbx Variables    $curlineIDREF="apC.vars21"Predefined dbx Variables    $curpcIDREF="apC.vars22"Predefined dbx Variables    current directoryIDREF="03.examin4"Specifying Source Directoriescurrent source fileIDREF="apA.cmd90"dbx CommandsIDREF="apA.cmd6"dbx CommandsIDREF="apA.cmd10"dbx CommandsIDREF="05.change110"Moving Within the StackIDREF="03.examin19"Changing Source Files$cursrclineIDREF="apC.vars23"Predefined dbx Variables    dbx-c flagIDREF="02.run7"dbx Options-d flagIDREF="02.run9"dbx Options-e flagIDREF="02.run10"dbx Options-i flagIDREF="02.run12"dbx OptionsIDREF="03.examin6"Specifying Source Directories With ArgumentsIDREF="02.run14"dbx Options-k flagIDREF="02.run18"dbx Options-N flagIDREF="02.run20"dbx Options-P flagIDREF="02.run21"dbx OptionsIDREF="02.run23"dbx Options-r flagIDREF="02.run25"dbx Options-R flagIDREF="02.run24"dbx Options command scriptsIDREF="04.cntrl74"Executing dbx Scripts invokingIDREF="02.run6"Invoking dbxinvokingIDREF="01.start4"Examining Core Dumps to Determine Cause of Failure quittingIDREF="apA.cmd141"dbx CommandsIDREF="02.run58"Quitting dbxdbx aliases. See aliasesIDREF="04.cntrl33"Creating and Removing dbx Aliasesdbx variablesIDREF="05.change1"Using ExpressionsIDREF="04.cntrl1"Creating and Removing dbx VariableslistingIDREF="04.cntrl8"Listing dbx VariablesIDREF="apA.cmd164"dbx Commandspredefined. See predefined dbx variablesIDREF="04.cntrl2"Creating and Removing dbx VariablesremovingIDREF="04.cntrl10"Removing VariablesIDREF="apA.cmd221"dbx CommandssettingIDREF="04.cntrl6"Setting dbx VariablesIDREF="04.cntrl3"Setting dbx VariablesIDREF="apA.cmd165"dbx Commands.dbxinit fileIDREF="02.run48"Automatically Executing Commands on StartupIDREF="02.run8"dbx Optionsdebugging a programIDREF="01.start9"Debugging Your Programs Fortran multiprocess programsIDREF="08.multiple55"Handling sproc System Calls and Process Group Debugginghigh levelIDREF="05.change79"Using the High-Level Debugging Language duel multiprocess application. See multiprocess debuggingIDREF="08.multiple1"Multiple Process Debuggingdebugging C++ programsIDREF="05.change131"Accessing C++ Member VariablesIDREF="06.exec105"Referring to C++ Functionsrunning processesIDREF="02.run22"dbx Optionsdecimal inputIDREF="05.change17"Numeric Constantsdecimal outputIDREF="05.change24"Numeric Constantsdefault input baseIDREF="05.change18"Numeric Constantsdefault output baseIDREF="05.change23"Numeric Constants$defaultinIDREF="04.cntrl57"Recording InputIDREF="apC.vars24"Predefined dbx Variables    IDREF="apA.cmd146"dbx Commands$defaultoutIDREF="apA.cmd149"dbx CommandsIDREF="apC.vars26"Predefined dbx Variables    IDREF="04.cntrl71"Recording Outputdelete commandIDREF="06.exec6"Setting BreakpointsIDREF="06.exec34"Tracing Program ExecutionIDREF="06.exec60"Deleting Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd58"dbx CommandsIDREF="07.mach35"Setting Machine-Level BreakpointsIDREF="07.mach53"Tracing Execution at the Machine LevelIDREF="06.exec61"Deleting Breakpoints, Traces, and Conditional Commandsdelete processes from process poolIDREF="08.multiple18"Deleting a Process From the Process PoolIDREF="apA.cmd65"dbx Commandsdeleting aliasesIDREF="04.cntrl47"Removing Command AliasesIDREF="apA.cmd215"dbx Commandsconditional commandsIDREF="06.exec64"Deleting Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd61"dbx CommandsIDREF="apA.cmd59"dbx CommandsIDREF="06.exec62"Deleting Breakpoints, Traces, and Conditional Commands processes from the process group listIDREF="apA.cmd63"dbx Commandsprocesses from the process group listIDREF="08.multiple63"Handling sproc System Calls and Process Group DebuggingtracingIDREF="apA.cmd60"dbx CommandsIDREF="06.exec63"Deleting Breakpoints, Traces, and Conditional Commandsdelpgrp commandIDREF="08.multiple64"Handling sproc System Calls and Process Group DebuggingIDREF="apA.cmd62"dbx Commandsdelproc commandIDREF="08.multiple19"Deleting a Process From the Process PoolIDREF="apA.cmd64"dbx Commandsdetermining scope of program variablesIDREF="05.change89"Determining Variable Scopes and Fully Qualified NamesIDREF="apA.cmd241"dbx CommandsIDREF="apA.cmd243"dbx CommandsdiraliasIDREF="apB.alias9"Predefined Aliasespath remappingIDREF="03.examin13"Path Remappingdir commandIDREF="apA.cmd66"dbx CommandsIDREF="03.examin14"Path RemappingIDREF="03.examin9"Specifying Source Directories With dbx CommandsIDREF="03.examin7"Specifying Source Directories With dbx CommandsIDREF="02.run17"dbx Optionsdisable commandIDREF="07.mach33"Setting Machine-Level BreakpointsIDREF="apA.cmd68"dbx CommandsIDREF="06.exec52"Disabling Breakpoints, Traces, and Conditional CommandsIDREF="07.mach51"Tracing Execution at the Machine LevelIDREF="06.exec32"Tracing Program ExecutionIDREF="06.exec4"Setting BreakpointsdisablingbreakpointsIDREF="apA.cmd69"dbx CommandsIDREF="06.exec53"Disabling Breakpoints, Traces, and Conditional Commandsconditional commandsIDREF="06.exec55"Disabling Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd71"dbx CommandstracingIDREF="06.exec54"Disabling Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd70"dbx Commandsdisassemble codeIDREF="07.mach23"Examining Memory and Disassembling CodeIDREF="apA.cmd33"dbx CommandsIDREF="07.mach4"Examining and Changing Register ValuesIDREF="apA.cmd30"dbx CommandsIDREF="07.mach20"Examining Memory and Disassembling Codedisplayactive process in process poolIDREF="08.multiple22"Selecting a ProcessIDREF="apA.cmd22"dbx Commandsprocesses in process poolIDREF="08.multiple15"Listing Available ProcessesIDREF="apA.cmd173"dbx CommandsIDREF="08.multiple12"Listing Available Processesdisplaying aliasesIDREF="04.cntrl35"Listing AliasesIDREF="apA.cmd36"dbx CommandsIDREF="apA.cmd38"dbx Commandsdisplaying caught signalsIDREF="06.exec69"Catching and Ignoring SignalsIDREF="apA.cmd47"dbx Commandsdisplaying caught system callsIDREF="apA.cmd194"dbx CommandsIDREF="06.exec82"Stopping at System Callsdisplaying ignored signalsIDREF="apA.cmd108"dbx CommandsIDREF="06.exec71"Catching and Ignoring Signalsdisplaying ignored system callsIDREF="apA.cmd195"dbx CommandsIDREF="06.exec83"Stopping at System Callsdisplaying recording sessionsIDREF="apA.cmd143"dbx CommandsIDREF="04.cntrl73"Examining the Record Statedisplaying register valuesIDREF="05.change104"Printing Stack Tracesdown commandIDREF="05.change106"Moving Within the StackIDREF="apA.cmd72"dbx CommandsDSOsIDREF="05.change54"Qualifying Names of Program ElementsIDREF="02.run3"Compiling and Linking Programs With Dynamic Shared Objectsstepping intoIDREF="07.mach75"Stepping Through Machine CodeIDREF="06.exec98"Stepping Using the step CommandduelC languageIDREF="05.change87"Differences from CdebuggingIDREF="05.change79"Using the High-Level Debugging Language duel examplesIDREF="05.change82"duel EXAMPLESFortran array subscriptsIDREF="05.change85"duel OperatorsFortran languageIDREF="05.change88"Differences from Fortranlanguage differencesIDREF="05.change86"Differences from Other LanguagesoperatorsIDREF="05.change84"duel OperatorsIDREF="05.change81"duel Operator Summaryquick startIDREF="05.change80"Using duel Quick StartsemanticsIDREF="05.change83"duel SEMANTICSduel commandIDREF="apA.cmd74"dbx Commandsdump commandIDREF="05.change118"Printing Activation Level InformationIDREF="05.change119"Printing Activation Level InformationIDREF="apA.cmd75"dbx CommandsIDREF="05.change120"Printing Activation Level InformationIDREF="05.change116"Printing Activation Level Informationedit commandIDREF="03.examin33"Calling an EditorIDREF="apC.vars28"Predefined dbx Variables    IDREF="apA.cmd78"dbx CommandsIDREF="apA.cmd82"dbx CommandsIDREF="03.examin35"Calling an Editoredit history listIDREF="apA.cmd99"dbx CommandsIDREF="04.cntrl26"The History EditorIDREF="apA.cmd100"dbx CommandsIDREF="apA.cmd97"dbx CommandsIDREF="apA.cmd101"dbx Commandsediting filesIDREF="03.examin34"Calling an EditorIDREF="apA.cmd83"dbx CommandsIDREF="apA.cmd79"dbx Commands$editorIDREF="apA.cmd80"dbx CommandsIDREF="03.examin36"Calling an EditorIDREF="04.cntrl27"The History EditorIDREF="apC.vars27"Predefined dbx Variables    EDITOR environment variableIDREF="apC.vars3"Predefined dbx Variables    IDREF="apA.cmd81"dbx CommandsIDREF="04.cntrl28"The History EditorIDREF="03.examin37"Calling an Editorenable commandIDREF="apA.cmd84"dbx CommandsIDREF="06.exec33"Tracing Program ExecutionIDREF="07.mach34"Setting Machine-Level BreakpointsIDREF="07.mach52"Tracing Execution at the Machine LevelIDREF="06.exec5"Setting BreakpointsIDREF="06.exec56"Enabling Breakpoints, Traces, and Conditional CommandsenablingbreakpointsIDREF="06.exec57"Enabling Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd85"dbx Commandsconditional commandsIDREF="apA.cmd87"dbx CommandsIDREF="06.exec59"Enabling Breakpoints, Traces, and Conditional CommandstracingIDREF="apA.cmd86"dbx CommandsIDREF="06.exec58"Enabling Breakpoints, Traces, and Conditional Commandsending recordingIDREF="04.cntrl61"Ending a Recording SessionIDREF="apA.cmd219"dbx CommandsIDREF="apA.cmd217"dbx CommandsIDREF="04.cntrl58"Ending a Recording Sessionenvironment variablesEDITORIDREF="03.examin37"Calling an EditorIDREF="apC.vars3"Predefined dbx Variables    IDREF="04.cntrl28"The History EditorIDREF="apA.cmd81"dbx CommandsHOMEIDREF="02.run49"Automatically Executing Commands on StartupLD_BIND_NOWIDREF="07.mach76"Stepping Through Machine CodeIDREF="06.exec99"Stepping Using the step Commandevaluation stack, increasingIDREF="02.run11"dbx Optionsexamining a new programIDREF="01.start20"Studying a New Programexamining core dumpsIDREF="01.start2"Examining Core Dumps to Determine Cause of Failureexamining program variablesIDREF="01.start17"Debugging Your ProgramsIDREF="01.start25"Studying a New Programexamining stackIDREF="01.start18"Debugging Your ProgramsexecIDREF="08.multiple51"Handling exec System Callsexecuting a shell commandIDREF="apA.cmd169"dbx CommandsIDREF="02.run57"Invoking a ShellexecvIDREF="06.exec88"Stopping at System CallsexecveIDREF="06.exec89"Stopping at System CallsexitIDREF="06.exec90"Stopping at System CallsexpressionsprintingIDREF="05.change34"Printing ExpressionsIDREF="apA.cmd131"dbx Commandsprinting formattedIDREF="apA.cmd135"dbx CommandsIDREF="05.change43"Printing Expressionsfile commandIDREF="apA.cmd88"dbx CommandsIDREF="03.examin17"Changing Source FilesforkIDREF="08.multiple2"Processes and ThreadsIDREF="06.exec84"Stopping at System CallsIDREF="apC.vars10"Predefined dbx Variables    IDREF="08.multiple48"Handling fork System CallsIDREF="apC.vars8"Predefined dbx Variables    IDREF="08.multiple58"Handling sproc System Calls and Process Group DebuggingFortrandbx array subscriptsIDREF="05.change11"Operatorsduel array subscriptsIDREF="05.change85"duel Operatorsmultiprocess debuggingIDREF="08.multiple55"Handling sproc System Calls and Process Group Debugging$fp_preciseIDREF="apC.vars29"Predefined dbx Variables    $frameregIDREF="apC.vars30"Predefined dbx Variables    framesIDREF="05.change97"Examining the Stackfully qualified namesIDREF="05.change48"Qualifying Names of Program Elementsfunc commandIDREF="05.change113"Moving to a Specified ProcedureIDREF="apA.cmd91"dbx CommandsIDREF="05.change114"Moving to a Specified ProcedureIDREF="05.change111"Moving to a Specified Procedurefunction calls, interactiveIDREF="apA.cmd51"dbx CommandsIDREF="05.change121"Using Interactive Function CallsIDREF="apA.cmd53"dbx CommandsIDREF="05.change124"Using ccallIDREF="05.change126"Using clearcallsIDREF="05.change123"Using ccallgivenfile commandIDREF="02.run35"Specifying Files with dbx CommandsIDREF="02.run33"Specifying Files with dbx CommandsIDREF="apA.cmd93"dbx Commandsgoto commandIDREF="06.exec104"Starting at a Specified LineIDREF="apA.cmd95"dbx Commandsgroup historyIDREF="08.multiple70"Handling sproc System Calls and Process Group Debugging$groupforktooIDREF="08.multiple60"Handling sproc System Calls and Process Group DebuggingIDREF="apC.vars31"Predefined dbx Variables    hed commandIDREF="apA.cmd98"dbx CommandsIDREF="04.cntrl31"The History EditorIDREF="04.cntrl25"The History EditorIDREF="04.cntrl29"The History EditorIDREF="apA.cmd96"dbx CommandsIDREF="04.cntrl30"The History EditorhelpIDREF="apC.vars54"Predefined dbx Variables    IDREF="02.run50"Using Online HelpIDREF="apA.cmd103"dbx Commandshelp commandIDREF="02.run51"Using Online HelpIDREF="apA.cmd102"dbx Commandshexadecimal inputIDREF="05.change21"Numeric ConstantsIDREF="apC.vars2"Predefined dbx Variables    hexadecimal outputIDREF="07.mach10"Printing Register ValuesIDREF="apC.vars5"Predefined dbx Variables    IDREF="05.change27"Numeric Constants$hexcharsIDREF="apC.vars32"Predefined dbx Variables    $hexdoublesIDREF="apC.vars33"Predefined dbx Variables    $hexinIDREF="apC.vars34"Predefined dbx Variables    IDREF="05.change22"Numeric ConstantsIDREF="apC.vars48"Predefined dbx Variables    $hexintsIDREF="apC.vars35"Predefined dbx Variables    IDREF="apC.vars51"Predefined dbx Variables    IDREF="07.mach8"Printing Register ValuesIDREF="05.change28"Numeric Constants$hexstringsIDREF="apC.vars36"Predefined dbx Variables    history commandIDREF="04.cntrl16"Examining the History ListIDREF="apA.cmd106"dbx Commandshistory editorIDREF="04.cntrl24"The History Editorhistory featureIDREF="04.cntrl12"Using the History Feature and the History Editorhistory listIDREF="04.cntrl18"Repeating CommandsIDREF="04.cntrl14"Examining the History ListeditingIDREF="apA.cmd101"dbx CommandsIDREF="04.cntrl26"The History EditorIDREF="apA.cmd97"dbx CommandsIDREF="apA.cmd99"dbx CommandsIDREF="apA.cmd100"dbx CommandsprintIDREF="04.cntrl15"Examining the History List$historyeventIDREF="apC.vars37"Predefined dbx Variables    HOME environment variableIDREF="02.run49"Automatically Executing Commands on Startupignore commandIDREF="06.exec67"Catching and Ignoring SignalsIDREF="apA.cmd107"dbx CommandsIDREF="06.exec65"Catching and Ignoring SignalsIDREF="06.exec70"Catching and Ignoring Signalsignoring signalsIDREF="apA.cmd110"dbx CommandsIDREF="06.exec68"Catching and Ignoring Signalsignoring system callsIDREF="06.exec81"Stopping at System CallsIDREF="apA.cmd197"dbx Commandsinclude filesIDREF="01.start36"Avoiding Common PitfallsinlinesIDREF="03.examin24"Listing Inlines and Clones stopping inIDREF="06.exec11"Setting Unconditional Breakpointsinputplaying backIDREF="04.cntrl51"Recording and Playing Back dbx Input and OutputIDREF="04.cntrl63"Playing Back InputIDREF="apA.cmd126"dbx CommandsrecordingIDREF="apA.cmd145"dbx CommandsIDREF="04.cntrl52"Recording and Playing Back dbx Input and Outputinput basedecimalIDREF="05.change17"Numeric ConstantshexadecimalIDREF="05.change21"Numeric ConstantsIDREF="apC.vars2"Predefined dbx Variables    octalIDREF="05.change19"Numeric ConstantsIDREF="apC.vars47"Predefined dbx Variables    instrumented binaryIDREF="05.change130"Obtaining Basic Blocks Countsinteractive function callsIDREF="05.change31"String ConstantsIDREF="05.change121"Using Interactive Function CallsbreakpointsIDREF="05.change129"Nesting Interactive Function CallscallingIDREF="apA.cmd51"dbx CommandsIDREF="05.change123"Using ccallclearingIDREF="05.change126"Using clearcallsIDREF="05.change124"Using ccallIDREF="apA.cmd53"dbx CommandsnestingIDREF="05.change128"Nesting Interactive Function CallsunstackingIDREF="05.change125"Using ccallintercept  commandIDREF="06.exec76"Stopping on C++ ExceptionsIDREF="apA.cmd109"dbx Commandsinvoking a shellIDREF="apA.cmd168"dbx CommandsIDREF="02.run55"Invoking a Shellinvoking dbxIDREF="02.run6"Invoking dbxIDREF="01.start4"Examining Core Dumps to Determine Cause of Failurekernel debuggingIDREF="02.run19"dbx Optionskill active processIDREF="08.multiple45"Killing a ProcessIDREF="apA.cmd112"dbx Commandskill commandIDREF="08.multiple46"Killing a ProcessIDREF="08.multiple44"Killing a ProcessIDREF="apA.cmd111"dbx Commandskill process in process poolIDREF="apA.cmd113"dbx CommandsIDREF="08.multiple47"Killing a Process$lastchildIDREF="08.multiple9"Using ScriptsIDREF="apC.vars38"Predefined dbx Variables    LD_BIND_NOW environment variableIDREF="06.exec99"Stepping Using the step CommandIDREF="07.mach76"Stepping Through Machine Code$linesIDREF="apC.vars39"Predefined dbx Variables    line numbers, addressIDREF="05.change5"OperatorsIDREF="04.cntrl79"Executing dbx ScriptsIDREF="05.change8"Operatorslinked listIDREF="04.cntrl50"Alias Examplelist commandIDREF="apA.cmd114"dbx CommandsIDREF="03.examin21"Listing Source Codelistclones  commandIDREF="03.examin27"Listing Inlines and ClonesIDREF="apA.cmd118"dbx Commandslisting dbx variablesIDREF="apA.cmd164"dbx CommandsIDREF="04.cntrl8"Listing dbx Variableslistinlines  commandIDREF="03.examin26"Listing Inlines and Cloneslistobj commandIDREF="apA.cmd119"dbx CommandsIDREF="02.run4"Compiling and Linking Programs With Dynamic Shared Objectslistregions commandIDREF="07.mach17"Examining Memory and Disassembling CodeIDREF="apA.cmd120"dbx Commands$listwindowIDREF="03.examin20"Listing Source CodeIDREF="apC.vars40"Predefined dbx Variables    IDREF="apA.cmd116"dbx CommandsIDREF="03.examin23"Listing Source CodeIDREF="apA.cmd117"dbx CommandsIDREF="03.examin22"Listing Source CodeIDREF="apA.cmd115"dbx Commandsmachine-level breakpointsIDREF="apA.cmd188"dbx CommandsIDREF="apA.cmd189"dbx CommandsIDREF="07.mach39"Syntax of the stopi CommandIDREF="07.mach37"Syntax of the stopi CommandIDREF="07.mach31"Setting Machine-Level Breakpointsmachine-level debuggingIDREF="01.start1"Getting Started With dbxmachine-level single-steppingIDREF="07.mach68"Stepping Through Machine CodemacrosIDREF="01.start38"Avoiding Common Pitfallsmapping pathnamesIDREF="03.examin13"Path Remapping$maxstrlenIDREF="apC.vars41"Predefined dbx Variables    memoryprint contentsIDREF="apA.cmd29"dbx CommandsIDREF="07.mach19"Examining Memory and Disassembling Codememory, print contentsIDREF="apA.cmd35"dbx CommandsIDREF="07.mach24"Examining Memory and Disassembling CodeIDREF="apA.cmd32"dbx CommandsIDREF="07.mach22"Examining Memory and Disassembling Codemissing codeIDREF="01.start40"Avoiding Common PitfallsIDREF="01.start37"Avoiding Common Pitfallsmp FortranIDREF="08.multiple54"Handling sproc System Calls and Process Group DebuggingIDREF="apC.vars4"Predefined dbx Variables    $mp_programIDREF="06.exec87"Stopping at System CallsIDREF="apC.vars42"Predefined dbx Variables    IDREF="08.multiple56"Handling sproc System Calls and Process Group Debuggingmultiprocess debuggingIDREF="08.multiple1"Multiple Process Debuggingmultiprocess programsIDREF="06.exec30"Continuing Execution After a Breakpointnames fully qualifiedIDREF="05.change48"Qualifying Names of Program Elementsfully qualifiedIDREF="06.exec42"Tracing Program ExecutionIDREF="05.change99"Examining the Stackstatement labels ( __$L_ marker )IDREF="05.change56"Qualifying Names of Program Elementsstruct, union, and enum tags  ( __$T_ marker )IDREF="05.change55"Qualifying Names of Program Elementsunnamed program blocks ( __$$blk1 marker)IDREF="05.change51"Qualifying Names of Program Elementsnesting interactive function callsIDREF="05.change128"Nesting Interactive Function Calls$neweventIDREF="apC.vars43"Predefined dbx Variables    $newpgrpeventIDREF="08.multiple71"Handling sproc System Calls and Process Group DebuggingIDREF="apC.vars44"Predefined dbx Variables    next commandIDREF="01.start22"Studying a New ProgramIDREF="06.exec100"Stepping Using the next CommandIDREF="apA.cmd121"dbx CommandsIDREF="06.exec93"Stepping Through Your Programnexti commandIDREF="apA.cmd123"dbx CommandsIDREF="07.mach71"Stepping Through Machine CodeIDREF="07.mach70"Stepping Through Machine Code$nonstopIDREF="apC.vars45"Predefined dbx Variables    numeric constantsIDREF="05.change12"ConstantsIDREF="05.change16"Numeric Constantsobject filesIDREF="03.examin2"Specifying Source DirectoriesspecifyingIDREF="02.run29"Specifying Object and Core FilesIDREF="02.run27"Specifying Object and Core FilesIDREF="apA.cmd94"dbx Commandsoctal inputIDREF="apC.vars47"Predefined dbx Variables    IDREF="05.change19"Numeric Constantsoctal outputIDREF="07.mach9"Printing Register ValuesIDREF="apC.vars50"Predefined dbx Variables    IDREF="05.change25"Numeric Constants$octinIDREF="apC.vars46"Predefined dbx Variables    IDREF="05.change20"Numeric Constants$octintsIDREF="07.mach7"Printing Register ValuesIDREF="05.change26"Numeric ConstantsIDREF="apC.vars49"Predefined dbx Variables    on-line helpIDREF="apC.vars54"Predefined dbx Variables    IDREF="apA.cmd103"dbx CommandsIDREF="02.run50"Using Online HelpoperatorsIDREF="05.change3"Using Expressions# operatorIDREF="05.change8"OperatorsIDREF="04.cntrl79"Executing dbx ScriptsIDREF="05.change5"Operators// (division)IDREF="05.change10"OperatorsIDREF="05.change9"OperatorsprecedenceIDREF="05.change4"Operatorsoutputplaying backIDREF="apA.cmd129"dbx CommandsIDREF="04.cntrl54"Recording and Playing Back dbx Input and OutputrecordingIDREF="04.cntrl53"Recording and Playing Back dbx Input and OutputIDREF="04.cntrl68"Recording OutputIDREF="apA.cmd148"dbx Commandsoutput basedecimalIDREF="05.change24"Numeric ConstantshexadecimalIDREF="07.mach10"Printing Register ValuesIDREF="05.change27"Numeric ConstantsIDREF="apC.vars5"Predefined dbx Variables    octalIDREF="apC.vars50"Predefined dbx Variables    IDREF="05.change25"Numeric ConstantsIDREF="07.mach9"Printing Register Valuesoverloaded C++ functionsIDREF="06.exec109"Referring to C++ Functions$pageIDREF="apC.vars52"Predefined dbx Variables    $pagerIDREF="02.run52"Using Online HelpIDREF="apA.cmd105"dbx CommandsIDREF="apA.cmd104"dbx CommandsIDREF="apC.vars53"Predefined dbx Variables    $pagewidthIDREF="apC.vars55"Predefined dbx Variables    $pagewindowIDREF="apC.vars56"Predefined dbx Variables    path remappingIDREF="03.examin13"Path RemappingpathnamesIDREF="03.examin13"Path RemappingpdIDREF="05.change66"Displaying the Value of a VariableIDREF="05.change37"Printing Expressions$pendingtrapsIDREF="apC.vars57"Predefined dbx Variables    pgrp clauseIDREF="08.multiple67"Handling sproc System Calls and Process Group Debugging$pidIDREF="apC.vars60"Predefined dbx Variables    IDREF="apC.vars69"Predefined dbx Variables    pi commandIDREF="04.cntrl65"Playing Back Input$piaddtohistIDREF="apC.vars58"Predefined dbx Variables    $pid0IDREF="08.multiple10"Using ScriptsIDREF="apC.vars61"Predefined dbx Variables    pid clauseIDREF="08.multiple6"Using the pid Clause$pimodeIDREF="apC.vars62"Predefined dbx Variables    IDREF="apA.cmd127"dbx CommandsIDREF="04.cntrl32"The History EditorIDREF="04.cntrl67"Playing Back Inputpixiecounting basic blocksIDREF="05.change130"Obtaining Basic Blocks Countspixie commandIDREF="apA.cmd124"dbx Commandsplayback input commandIDREF="04.cntrl76"Executing dbx ScriptsIDREF="apC.vars63"Predefined dbx Variables    IDREF="04.cntrl56"Recording InputIDREF="apC.vars59"Predefined dbx Variables    IDREF="apA.cmd125"dbx CommandsIDREF="apC.vars7"Predefined dbx Variables    playback output commandIDREF="apC.vars6"Predefined dbx Variables    IDREF="apA.cmd128"dbx Commandsplaying back inputIDREF="apA.cmd126"dbx CommandsIDREF="04.cntrl51"Recording and Playing Back dbx Input and OutputIDREF="04.cntrl63"Playing Back Inputplaying back outputIDREF="04.cntrl54"Recording and Playing Back dbx Input and OutputIDREF="apA.cmd129"dbx CommandspoIDREF="05.change67"Displaying the Value of a VariableIDREF="05.change39"Printing Expressionsprecedence, operatorsIDREF="05.change4"Operatorspredefined dbx aliasesIDREF="04.cntrl34"Creating and Removing dbx AliasesIDREF="apB.alias1"Predefined AliasesaIDREF="apB.alias4"Predefined AliasesbIDREF="apB.alias5"Predefined AliasesbpIDREF="apB.alias6"Predefined AliasescIDREF="apB.alias7"Predefined AliasesdIDREF="apB.alias8"Predefined AliasesdirIDREF="apB.alias9"Predefined AliaseseIDREF="apB.alias10"Predefined AliasesfIDREF="apB.alias11"Predefined AliasesgIDREF="apB.alias12"Predefined AliaseshIDREF="apB.alias13"Predefined AliasesjIDREF="apB.alias14"Predefined AliaseslIDREF="apB.alias15"Predefined AliasesliIDREF="apB.alias16"Predefined AliasesnIDREF="apB.alias17"Predefined AliasesniIDREF="apB.alias18"Predefined AliasespIDREF="apB.alias19"Predefined AliasespdIDREF="05.change37"Printing ExpressionsIDREF="apB.alias20"Predefined AliasesIDREF="05.change66"Displaying the Value of a VariablepiIDREF="04.cntrl65"Playing Back InputIDREF="04.cntrl75"Executing dbx ScriptsIDREF="apB.alias21"Predefined AliasespoIDREF="apB.alias22"Predefined AliasesIDREF="05.change39"Printing ExpressionsIDREF="05.change67"Displaying the Value of a VariableprIDREF="apB.alias23"Predefined AliasespxIDREF="05.change41"Printing ExpressionsIDREF="apB.alias24"Predefined AliasesIDREF="05.change68"Displaying the Value of a VariableqIDREF="apB.alias25"Predefined AliasesrIDREF="apB.alias26"Predefined AliasesriIDREF="apB.alias27"Predefined AliasesroIDREF="apB.alias28"Predefined AliasesSIDREF="apB.alias30"Predefined AliasesIDREF="apB.alias29"Predefined AliasesSiIDREF="apB.alias32"Predefined AliasesIDREF="apB.alias31"Predefined AliasessourceIDREF="apA.cmd175"dbx CommandsIDREF="apB.alias33"Predefined AliasestIDREF="apB.alias34"Predefined AliasesuIDREF="apB.alias35"Predefined AliasesWIDREF="apB.alias37"Predefined AliasesIDREF="apB.alias36"Predefined AliaseswiIDREF="apB.alias38"Predefined Aliasespredefined dbx variablesIDREF="04.cntrl2"Creating and Removing dbx VariablesIDREF="apC.vars12"Predefined dbx Variables    $addrfmtIDREF="apC.vars13"Predefined dbx Variables    $addrfmt64IDREF="apC.vars14"Predefined dbx Variables    $assignverifyIDREF="apC.vars15"Predefined dbx Variables    $casesenseIDREF="05.change75"Case Sensitivity in Variable NamesIDREF="apC.vars16"Predefined dbx Variables    $ctypenamesIDREF="apC.vars18"Predefined dbx Variables    $cureventIDREF="apC.vars20"Predefined dbx Variables    $curlineIDREF="apC.vars21"Predefined dbx Variables    $curpcIDREF="apC.vars22"Predefined dbx Variables    $cursrclineIDREF="apC.vars23"Predefined dbx Variables    $defaultinIDREF="apA.cmd146"dbx CommandsIDREF="04.cntrl57"Recording InputIDREF="apC.vars24"Predefined dbx Variables    $defaultoutIDREF="04.cntrl71"Recording OutputIDREF="apC.vars26"Predefined dbx Variables    IDREF="apA.cmd149"dbx Commands$editorIDREF="04.cntrl27"The History EditorIDREF="apC.vars27"Predefined dbx Variables    IDREF="03.examin36"Calling an EditorIDREF="apA.cmd80"dbx Commands$fp_preciseIDREF="apC.vars29"Predefined dbx Variables    $frameregIDREF="apC.vars30"Predefined dbx Variables    IDREF="07.mach15"Changing Register Values$groupforktooIDREF="08.multiple60"Handling sproc System Calls and Process Group DebuggingIDREF="apC.vars31"Predefined dbx Variables    $hexcharsIDREF="apC.vars32"Predefined dbx Variables    $hexdoublesIDREF="apC.vars33"Predefined dbx Variables    $hexinIDREF="apC.vars34"Predefined dbx Variables    IDREF="apC.vars48"Predefined dbx Variables    IDREF="05.change22"Numeric Constants$hexintsIDREF="apC.vars51"Predefined dbx Variables    IDREF="05.change28"Numeric ConstantsIDREF="07.mach8"Printing Register ValuesIDREF="apC.vars35"Predefined dbx Variables    $hexstringsIDREF="apC.vars36"Predefined dbx Variables    $historyeventIDREF="apC.vars37"Predefined dbx Variables    $lastchildIDREF="08.multiple9"Using ScriptsIDREF="apC.vars38"Predefined dbx Variables    $linesIDREF="apC.vars39"Predefined dbx Variables    $listwindowIDREF="apA.cmd115"dbx CommandsIDREF="apA.cmd116"dbx CommandsIDREF="apA.cmd117"dbx CommandsIDREF="03.examin23"Listing Source CodeIDREF="apC.vars40"Predefined dbx Variables    IDREF="03.examin20"Listing Source CodeIDREF="03.examin22"Listing Source Code$maxstrlenIDREF="apC.vars41"Predefined dbx Variables    $mp_programIDREF="08.multiple56"Handling sproc System Calls and Process Group DebuggingIDREF="06.exec87"Stopping at System CallsIDREF="apC.vars42"Predefined dbx Variables    $neweventIDREF="apC.vars43"Predefined dbx Variables    $newpgrpeventIDREF="apC.vars44"Predefined dbx Variables    IDREF="08.multiple71"Handling sproc System Calls and Process Group Debugging$nonstopIDREF="apC.vars45"Predefined dbx Variables    $octinIDREF="05.change20"Numeric ConstantsIDREF="apC.vars46"Predefined dbx Variables    $octintsIDREF="07.mach7"Printing Register ValuesIDREF="apC.vars49"Predefined dbx Variables    IDREF="05.change26"Numeric Constants$pageIDREF="apC.vars52"Predefined dbx Variables    $pagerIDREF="apC.vars53"Predefined dbx Variables    IDREF="apA.cmd105"dbx CommandsIDREF="02.run52"Using Online HelpIDREF="apA.cmd104"dbx Commands$pagewidthIDREF="apC.vars55"Predefined dbx Variables    $pagewindowIDREF="apC.vars56"Predefined dbx Variables    $pendingtrapsIDREF="apC.vars57"Predefined dbx Variables    $pidIDREF="apC.vars60"Predefined dbx Variables    IDREF="apC.vars69"Predefined dbx Variables    $piaddtohistIDREF="apC.vars58"Predefined dbx Variables    $pid0IDREF="08.multiple10"Using ScriptsIDREF="apC.vars61"Predefined dbx Variables    $pimodeIDREF="apC.vars62"Predefined dbx Variables    IDREF="apA.cmd127"dbx CommandsIDREF="04.cntrl67"Playing Back InputIDREF="04.cntrl32"The History Editor$print_exception_frameIDREF="apC.vars65"Predefined dbx Variables    $printdataIDREF="apC.vars64"Predefined dbx Variables    $printwhilestepIDREF="apC.vars66"Predefined dbx Variables    $printwideIDREF="apC.vars67"Predefined dbx Variables    $procaddrIDREF="apC.vars68"Predefined dbx Variables    $promptIDREF="apC.vars70"Predefined dbx Variables    IDREF="02.run32"The dbx Prompt$promptonforkIDREF="08.multiple49"Handling fork System CallsIDREF="06.exec86"Stopping at System CallsIDREF="08.multiple50"Handling fork System CallsIDREF="apC.vars72"Predefined dbx Variables    $regstyleIDREF="07.mach3"Examining and Changing Register ValuesIDREF="apC.vars73"Predefined dbx Variables    $repeatmodeIDREF="apC.vars75"Predefined dbx Variables    IDREF="04.cntrl20"Repeating CommandsIDREF="apA.cmd13"dbx Commands$rimodeIDREF="apC.vars77"Predefined dbx Variables    IDREF="04.cntrl70"Recording OutputIDREF="apA.cmd150"dbx Commands$shellparametersIDREF="apC.vars78"Predefined dbx Variables    IDREF="02.run44"Running Your Program$showbreakaddrsIDREF="apC.vars79"Predefined dbx Variables    $showfilenameIDREF="apC.vars80"Predefined dbx Variables    $sourcepathruleIDREF="apC.vars81"Predefined dbx Variables    IDREF="03.examin16"Controlling use of Path Remappings and Your Source-Directory List$stacktracelimitIDREF="apC.vars82"Predefined dbx Variables    IDREF="05.change102"Printing Stack Traces$stdcIDREF="apC.vars83"Predefined dbx Variables    $stepintoallIDREF="06.exec97"Stepping Using the step CommandIDREF="07.mach74"Stepping Through Machine CodeIDREF="apC.vars84"Predefined dbx Variables    $stopformatIDREF="apC.vars85"Predefined dbx Variables    $tagfileIDREF="apC.vars86"Predefined dbx Variables    $whereisdsolimitIDREF="apC.vars87"Predefined dbx Variables    IDREF="05.change92"Determining Variable Scopes and Fully Qualified Namesprintbyte in octalIDREF="07.mach30"Examining Memory and Disassembling Codeword in decimalIDREF="07.mach26"Examining Memory and Disassembling Codeword in hexadecimalIDREF="07.mach29"Examining Memory and Disassembling Codeword in octalIDREF="07.mach28"Examining Memory and Disassembling Codeprint commandIDREF="01.start24"Studying a New ProgramIDREF="05.change61"Displaying the Value of a VariableIDREF="apA.cmd130"dbx CommandsIDREF="04.cntrl7"Setting dbx VariablesIDREF="05.change35"Printing ExpressionsIDREF="01.start21"Studying a New Programprint history listIDREF="04.cntrl15"Examining the History Listprint memory contentsIDREF="apA.cmd35"dbx CommandsIDREF="07.mach22"Examining Memory and Disassembling CodeIDREF="07.mach24"Examining Memory and Disassembling CodeIDREF="07.mach19"Examining Memory and Disassembling CodeIDREF="apA.cmd29"dbx CommandsIDREF="apA.cmd32"dbx Commands$print_exception_frameIDREF="apC.vars65"Predefined dbx Variables    printd commandIDREF="apA.cmd132"dbx CommandsIDREF="05.change36"Printing ExpressionsIDREF="05.change62"Displaying the Value of a Variable$printdataIDREF="apC.vars64"Predefined dbx Variables    printenv  commandIDREF="05.change76"Displaying and Changing Environment Variables Used by a ProgramIDREF="apA.cmd133"dbx Commandsprintf commandIDREF="apA.cmd134"dbx CommandsIDREF="05.change42"Printing ExpressionsIDREF="05.change63"Displaying the Value of a Variableprinting expressionsIDREF="05.change34"Printing ExpressionsIDREF="apA.cmd131"dbx Commandsprinting formatted expressionsIDREF="apA.cmd135"dbx CommandsIDREF="05.change43"Printing Expressionsprinting program variablesIDREF="05.change60"Displaying the Value of a Variableprinting register valuesIDREF="05.change104"Printing Stack Tracesprinto commandIDREF="05.change64"Displaying the Value of a VariableIDREF="05.change38"Printing ExpressionsIDREF="apA.cmd136"dbx Commandsprintregs commandIDREF="07.mach5"Printing Register ValuesIDREF="apA.cmd137"dbx Commands$printwhilestepIDREF="apC.vars66"Predefined dbx Variables    $printwideIDREF="apC.vars67"Predefined dbx Variables    printx commandIDREF="apA.cmd139"dbx CommandsIDREF="05.change40"Printing ExpressionsIDREF="05.change65"Displaying the Value of a Variableproblemsconfused listingIDREF="01.start34"Avoiding Common Pitfallsinclude filesIDREF="01.start36"Avoiding Common PitfallsmacrosIDREF="01.start38"Avoiding Common Pitfallssource and code do not matchIDREF="01.start35"Avoiding Common Pitfallsvariables do not displayIDREF="01.start32"Avoiding Common Pitfalls$procaddrIDREF="apC.vars68"Predefined dbx Variables    procedures, tracingIDREF="01.start29"Studying a New Programprocess group listadding processesIDREF="apA.cmd24"dbx CommandsIDREF="08.multiple59"Handling sproc System Calls and Process Group DebuggingIDREF="08.multiple61"Handling sproc System Calls and Process Group Debuggingdeleting processesIDREF="08.multiple63"Handling sproc System Calls and Process Group DebuggingIDREF="apA.cmd63"dbx Commandsshowing processesIDREF="08.multiple65"Handling sproc System Calls and Process Group DebuggingIDREF="apA.cmd171"dbx Commandsprocess groupsIDREF="08.multiple52"Handling sproc System Calls and Process Group DebuggingbreakpointsIDREF="08.multiple68"Handling sproc System Calls and Process Group Debugginggroup historyIDREF="08.multiple70"Handling sproc System Calls and Process Group DebuggingtracingIDREF="08.multiple69"Handling sproc System Calls and Process Group Debuggingprocess identification number (PID)IDREF="08.multiple5"Using the pid Clauseprocess poolIDREF="08.multiple4"Processes and Threadsadd processesIDREF="08.multiple16"Adding a Process to the Process PoolIDREF="apA.cmd26"dbx Commandsdelete processesIDREF="08.multiple18"Deleting a Process From the Process PoolIDREF="apA.cmd65"dbx Commandsdisplay active processIDREF="apA.cmd22"dbx CommandsIDREF="08.multiple22"Selecting a Processdisplay processesIDREF="08.multiple12"Listing Available ProcessesIDREF="apA.cmd173"dbx CommandsIDREF="08.multiple15"Listing Available Processeskill active processIDREF="08.multiple45"Killing a ProcessIDREF="apA.cmd112"dbx Commandskill processesIDREF="apA.cmd113"dbx CommandsIDREF="08.multiple47"Killing a Processresume active processIDREF="08.multiple33"Resuming a Suspended ProcessIDREF="apA.cmd154"dbx CommandsIDREF="08.multiple35"Resuming a Suspended ProcessIDREF="apA.cmd155"dbx Commandsselect active processIDREF="08.multiple21"Selecting a ProcessIDREF="apA.cmd21"dbx Commandssuspend active processIDREF="08.multiple24"Suspending a Processsuspend processesIDREF="08.multiple26"Suspending a ProcessIDREF="apA.cmd191"dbx CommandsIDREF="08.multiple28"Suspending a ProcessIDREF="08.multiple30"Suspending a Processprocesseswait forIDREF="08.multiple41"Waiting for a Resumed ProcessIDREF="apA.cmd231"dbx CommandsIDREF="apA.cmd228"dbx CommandsIDREF="08.multiple39"Waiting for a Resumed ProcessIDREF="apA.cmd229"dbx CommandsIDREF="08.multiple42"Waiting for Any Running Processprogram stack. See stackIDREF="05.change95"Examining the Stack program variables. See variables, programIDREF="05.change2"Using ExpressionsIDREF="05.change58"Displaying and Changing Program Variablesprogram variables. See variables, programIDREF="01.start17"Debugging Your Programs$promptIDREF="apC.vars70"Predefined dbx Variables    IDREF="02.run32"The dbx PromptpromptIDREF="02.run31"The dbx PromptIDREF="apC.vars71"Predefined dbx Variables    $promptonforkIDREF="apC.vars72"Predefined dbx Variables    IDREF="08.multiple50"Handling fork System CallsIDREF="06.exec86"Stopping at System CallsIDREF="08.multiple49"Handling fork System CallspxIDREF="05.change68"Displaying the Value of a VariableIDREF="05.change41"Printing Expressionsqualifying program variable namesIDREF="06.exec42"Tracing Program ExecutionIDREF="05.change99"Examining the StackIDREF="05.change46"Qualifying Names of Program Elementsquick start duelIDREF="05.change80"Using duel Quick Startquit commandIDREF="02.run59"Quitting dbxIDREF="apA.cmd140"dbx Commandsquitting dbxIDREF="apA.cmd141"dbx CommandsIDREF="02.run58"Quitting dbxquotation marksIDREF="06.exec110"Referring to C++ FunctionsIDREF="05.change57"Qualifying Names of Program ElementsIDREF="05.change33"String Constantsrecord commandIDREF="apA.cmd142"dbx CommandsIDREF="04.cntrl72"Examining the Record Staterecord input commandIDREF="04.cntrl64"Playing Back InputIDREF="apC.vars25"Predefined dbx Variables    IDREF="04.cntrl55"Recording InputIDREF="apA.cmd144"dbx Commandsrecord output commandIDREF="apA.cmd147"dbx CommandsIDREF="apC.vars1"Predefined dbx Variables    IDREF="04.cntrl69"Recording Outputrecording inputIDREF="04.cntrl52"Recording and Playing Back dbx Input and OutputIDREF="apA.cmd145"dbx Commandsrecording outputIDREF="04.cntrl53"Recording and Playing Back dbx Input and OutputIDREF="04.cntrl68"Recording OutputIDREF="apA.cmd148"dbx Commandsrecording, displaying sessionsIDREF="04.cntrl73"Examining the Record StateIDREF="apA.cmd143"dbx Commandsrecording, endingIDREF="apA.cmd217"dbx CommandsIDREF="04.cntrl58"Ending a Recording SessionIDREF="apA.cmd219"dbx CommandsIDREF="04.cntrl61"Ending a Recording Sessionregister namesIDREF="07.mach2"Examining and Changing Register ValuesIDREF="apC.vars74"Predefined dbx Variables    registersIDREF="07.mach1"Examining and Changing Register Valueschanging valuesIDREF="apA.cmd43"dbx CommandsIDREF="07.mach14"Changing Register Valuesdisplaying valuesIDREF="05.change104"Printing Stack Tracesprinting valuesIDREF="05.change104"Printing Stack TracesIDREF="07.mach6"Printing Register ValuesIDREF="apA.cmd138"dbx Commandsusing values in expressionsIDREF="07.mach11"Printing Register Values$regstyleIDREF="07.mach3"Examining and Changing Register ValuesIDREF="apC.vars73"Predefined dbx Variables    removing dbx variablesIDREF="apA.cmd221"dbx CommandsIDREF="04.cntrl10"Removing Variablesrepeating commandsIDREF="apA.cmd15"dbx CommandsIDREF="apA.cmd17"dbx CommandsIDREF="apA.cmd19"dbx CommandsIDREF="04.cntrl17"Repeating CommandsIDREF="apC.vars76"Predefined dbx Variables    IDREF="apA.cmd12"dbx CommandsIDREF="04.cntrl13"Using the History Feature and the History Editor$repeatmodeIDREF="apC.vars75"Predefined dbx Variables    IDREF="04.cntrl20"Repeating CommandsIDREF="apA.cmd13"dbx Commandsrerun commandIDREF="02.run46"Running Your ProgramIDREF="01.start16"Debugging Your ProgramsIDREF="apA.cmd151"dbx CommandsIDREF="02.run39"Running Your Programresume active processIDREF="08.multiple35"Resuming a Suspended ProcessIDREF="apA.cmd154"dbx CommandsIDREF="apA.cmd155"dbx CommandsIDREF="08.multiple33"Resuming a Suspended Processresume commandIDREF="08.multiple34"Resuming a Suspended ProcessIDREF="06.exec31"Continuing Execution After a BreakpointIDREF="apA.cmd153"dbx CommandsIDREF="08.multiple32"Resuming a Suspended Processreturn commandIDREF="apA.cmd157"dbx CommandsIDREF="06.exec101"Using the return CommandIDREF="06.exec102"Using the return Command$rimodeIDREF="04.cntrl70"Recording OutputIDREF="apC.vars77"Predefined dbx Variables    IDREF="apA.cmd150"dbx Commandsrun commandIDREF="02.run40"Running Your ProgramIDREF="apA.cmd158"dbx CommandsIDREF="01.start15"Debugging Your ProgramsIDREF="02.run38"Running Your Programrunning process, wait forIDREF="08.multiple42"Waiting for Any Running ProcessIDREF="apA.cmd231"dbx Commandsrunning programsIDREF="02.run47"Running Your ProgramIDREF="02.run37"Running Your ProgramIDREF="apA.cmd159"dbx CommandsIDREF="02.run26"dbx OptionsIDREF="apA.cmd152"dbx Commandsscope of program variablesIDREF="05.change98"Examining the StackIDREF="05.change109"Moving Within the StackIDREF="05.change59"Variable ScopeIDREF="05.change115"Moving to a Specified ProcedurescriptsIDREF="04.cntrl74"Executing dbx Scriptssearch backward (?) commandIDREF="03.examin30"Searching Through Source CodeIDREF="03.examin32"Searching Through Source CodeIDREF="apA.cmd8"dbx Commandssearch forward (/) commandIDREF="apA.cmd4"dbx CommandsIDREF="03.examin31"Searching Through Source CodeIDREF="03.examin29"Searching Through Source Codesearching source codeIDREF="apA.cmd9"dbx CommandsIDREF="apA.cmd5"dbx CommandsIDREF="03.examin28"Searching Through Source Codeselect active process from process poolIDREF="apA.cmd21"dbx CommandsIDREF="08.multiple21"Selecting a Processsending signalsIDREF="06.exec29"Continuing Execution After a BreakpointIDREF="08.multiple36"Resuming a Suspended ProcessIDREF="07.mach46"Continuing Execution After a Machine-Level BreakpointIDREF="apA.cmd156"dbx Commandsset commandIDREF="04.cntrl4"Setting dbx VariablesIDREF="apA.cmd163"dbx CommandsIDREF="04.cntrl9"Listing dbx VariablesIDREF="04.cntrl5"Setting dbx VariablesIDREF="05.change30"String Constantssetenv commandIDREF="05.change77"Displaying and Changing Environment Variables Used by a ProgramIDREF="apA.cmd166"dbx CommandsIDREF="02.run45"Running Your Programsetting breakpointsIDREF="01.start14"Debugging Your Programssetting conditional breakpointsIDREF="06.exec13"Setting Conditional Breakpointssetting conditional commandsIDREF="06.exec43"Writing Conditional Commandssetting dbx variablesIDREF="04.cntrl6"Setting dbx VariablesIDREF="apA.cmd165"dbx CommandsIDREF="04.cntrl3"Setting dbx Variablessetting unconditional breakpointsIDREF="06.exec7"Setting Unconditional BreakpointsIDREF="apA.cmd185"dbx CommandsIDREF="apA.cmd184"dbx Commandssh commandIDREF="apA.cmd167"dbx CommandsIDREF="02.run56"Invoking a Shellshell command, executingIDREF="apA.cmd169"dbx CommandsIDREF="02.run57"Invoking a Shellshell, invoking from dbxIDREF="apA.cmd168"dbx CommandsIDREF="02.run55"Invoking a Shell$shellparametersIDREF="02.run44"Running Your ProgramIDREF="apC.vars78"Predefined dbx Variables    $showbreakaddrsIDREF="apC.vars79"Predefined dbx Variables    $showfilenameIDREF="apC.vars80"Predefined dbx Variables    showing processes in the process group listIDREF="08.multiple65"Handling sproc System Calls and Process Group DebuggingIDREF="apA.cmd171"dbx Commandsshowpgrp commandIDREF="08.multiple66"Handling sproc System Calls and Process Group DebuggingIDREF="apA.cmd170"dbx Commandsshowproc commandIDREF="08.multiple11"Listing Available ProcessesIDREF="08.multiple13"Listing Available ProcessesIDREF="apA.cmd172"dbx CommandsIDREF="08.multiple14"Listing Available Processesshowthread commandIDREF="08.multiple8"Using the thread ClauseIDREF="apA.cmd174"dbx CommandssignalscatchingIDREF="apA.cmd49"dbx CommandsIDREF="06.exec66"Catching and Ignoring Signalscontinuing after catchingIDREF="06.exec74"Continuing After Catching a SignalIDREF="06.exec73"Continuing After Catching a Signaldisplaying caughtIDREF="apA.cmd47"dbx CommandsIDREF="06.exec69"Catching and Ignoring Signalsdisplaying ignoredIDREF="06.exec71"Catching and Ignoring SignalsIDREF="apA.cmd108"dbx CommandsignoringIDREF="apA.cmd110"dbx CommandsIDREF="06.exec68"Catching and Ignoring SignalssendingIDREF="apA.cmd156"dbx CommandsIDREF="06.exec29"Continuing Execution After a BreakpointIDREF="07.mach46"Continuing Execution After a Machine-Level BreakpointIDREF="08.multiple36"Resuming a Suspended Processsingle-steppingIDREF="apA.cmd181"dbx CommandsIDREF="01.start26"Studying a New ProgramIDREF="apA.cmd122"dbx CommandsIDREF="06.exec91"Stepping Through Your Programsingle-stepping at the machine-code levelIDREF="07.mach68"Stepping Through Machine CodesourceIDREF="apB.alias33"Predefined AliasesIDREF="apA.cmd175"dbx Commandssource codesearchingIDREF="03.examin28"Searching Through Source CodeIDREF="apA.cmd5"dbx CommandsIDREF="apA.cmd9"dbx Commandssource commandIDREF="04.cntrl66"Playing Back Inputsource directoriesspecifyingIDREF="apA.cmd226"dbx CommandsIDREF="03.examin15"Path RemappingIDREF="apA.cmd67"dbx CommandsIDREF="03.examin10"Specifying Source Directories With dbx CommandsIDREF="03.examin12"Specifying Source Directories With dbx CommandsIDREF="03.examin5"Specifying Source Directories With Argumentssource filesIDREF="03.examin1"Specifying Source DirectoriesdbxIDREF="03.examin13"Path RemappingeditingIDREF="apA.cmd79"dbx CommandsIDREF="apA.cmd83"dbx CommandsIDREF="03.examin34"Calling an EditorlocatingIDREF="03.examin13"Path RemappingspecifyingIDREF="apA.cmd67"dbx CommandsIDREF="03.examin10"Specifying Source Directories With dbx CommandsIDREF="03.examin18"Changing Source FilesIDREF="apA.cmd89"dbx CommandsIDREF="03.examin5"Specifying Source Directories With ArgumentsIDREF="03.examin12"Specifying Source Directories With dbx CommandsIDREF="apA.cmd226"dbx CommandsIDREF="02.run15"dbx OptionsIDREF="03.examin15"Path Remappingsource lines, tracingIDREF="01.start30"Studying a New Program$sourcepathruleIDREF="03.examin16"Controlling use of Path Remappings and Your Source-Directory ListIDREF="apC.vars81"Predefined dbx Variables    sprocIDREF="08.multiple3"Processes and ThreadsIDREF="apC.vars11"Predefined dbx Variables    IDREF="08.multiple57"Handling sproc System Calls and Process Group DebuggingIDREF="06.exec85"Stopping at System CallsIDREF="apC.vars9"Predefined dbx Variables    IDREF="08.multiple53"Handling sproc System Calls and Process Group DebuggingstackexaminingIDREF="05.change95"Examining the StackIDREF="01.start18"Debugging Your ProgramsIDREF="05.change104"Printing Stack TracesprintingIDREF="05.change104"Printing Stack TracestraceIDREF="01.start5"Examining Core Dumps to Determine Cause of FailureIDREF="05.change100"Printing Stack TracesIDREF="apA.cmd239"dbx Commands$stacktracelimitIDREF="05.change102"Printing Stack TracesIDREF="apC.vars82"Predefined dbx Variables    standard errorIDREF="02.run43"Running Your ProgramIDREF="apA.cmd162"dbx Commandsstandard inputIDREF="apA.cmd160"dbx CommandsIDREF="02.run41"Running Your Programstandard outputIDREF="02.run42"Running Your ProgramIDREF="apA.cmd161"dbx Commandsstatus commandIDREF="apA.cmd176"dbx CommandsIDREF="04.cntrl62"Ending a Recording SessionIDREF="06.exec48"Listing Breakpoints, Traces, and Conditional Commands$stdcIDREF="apC.vars83"Predefined dbx Variables    step commandIDREF="06.exec92"Stepping Through Your ProgramIDREF="apA.cmd180"dbx CommandsIDREF="06.exec94"Stepping Using the step CommandIDREF="01.start23"Studying a New Programstepi commandIDREF="07.mach72"Stepping Through Machine CodeIDREF="07.mach73"Stepping Through Machine CodeIDREF="apA.cmd182"dbx CommandsIDREF="07.mach69"Stepping Through Machine Code$stepintoallIDREF="07.mach74"Stepping Through Machine CodeIDREF="06.exec97"Stepping Using the step CommandIDREF="apC.vars84"Predefined dbx Variables    stop commandIDREF="06.exec19"Stopping If a Variable or Memory Location Has ChangedIDREF="06.exec22"Stopping If a Test Expression Is TrueIDREF="01.start13"Debugging Your ProgramsIDREF="apA.cmd183"dbx CommandsIDREF="06.exec8"Setting Unconditional BreakpointsIDREF="06.exec9"Setting Unconditional BreakpointsIDREF="06.exec10"Setting Unconditional BreakpointsIDREF="06.exec15"Stopping If a Variable or Memory Location Has ChangedIDREF="06.exec17"Stopping If a Variable or Memory Location Has Changed$stopformatIDREF="apC.vars85"Predefined dbx Variables    stopi commandIDREF="07.mach38"Syntax of the stopi CommandIDREF="07.mach32"Setting Machine-Level BreakpointsIDREF="07.mach36"Syntax of the stopi CommandIDREF="apA.cmd187"dbx Commandsstring constantsIDREF="05.change13"ConstantsIDREF="05.change29"String Constantsescape sequencesIDREF="05.change32"String Constantsstripped symbol tableIDREF="01.start8"Examining Core Dumps to Determine Cause of Failuresuspend active processIDREF="08.multiple24"Suspending a Processsuspend commandIDREF="08.multiple23"Suspending a ProcessIDREF="apA.cmd190"dbx CommandsIDREF="08.multiple27"Suspending a ProcessIDREF="apA.cmd192"dbx CommandsIDREF="08.multiple25"Suspending a ProcessIDREF="08.multiple29"Suspending a Processsuspend process in process poolIDREF="08.multiple30"Suspending a ProcessIDREF="08.multiple26"Suspending a ProcessIDREF="08.multiple28"Suspending a ProcessIDREF="apA.cmd191"dbx Commandssymbol tablestrippedIDREF="01.start8"Examining Core Dumps to Determine Cause of Failuresyscall commandIDREF="06.exec80"Stopping at System CallsIDREF="06.exec78"Stopping at System CallsIDREF="06.exec77"Stopping at System CallsIDREF="apA.cmd193"dbx Commandssystem callscatchingIDREF="apA.cmd196"dbx CommandsIDREF="06.exec79"Stopping at System Callsdisplaying caughtIDREF="06.exec82"Stopping at System CallsIDREF="apA.cmd194"dbx Commandsdisplaying ignoredIDREF="apA.cmd195"dbx CommandsIDREF="06.exec83"Stopping at System CallsexecIDREF="08.multiple51"Handling exec System CallsexecvIDREF="06.exec88"Stopping at System CallsexecveIDREF="06.exec89"Stopping at System CallsexitIDREF="06.exec90"Stopping at System CallsforkIDREF="08.multiple2"Processes and ThreadsIDREF="apC.vars8"Predefined dbx Variables    IDREF="06.exec84"Stopping at System CallsIDREF="apC.vars10"Predefined dbx Variables    IDREF="08.multiple58"Handling sproc System Calls and Process Group DebuggingIDREF="08.multiple48"Handling fork System CallsignoringIDREF="06.exec81"Stopping at System CallsIDREF="apA.cmd197"dbx CommandssprocIDREF="06.exec85"Stopping at System CallsIDREF="apC.vars9"Predefined dbx Variables    IDREF="apC.vars11"Predefined dbx Variables    IDREF="08.multiple3"Processes and ThreadsIDREF="08.multiple53"Handling sproc System Calls and Process Group DebuggingIDREF="08.multiple57"Handling sproc System Calls and Process Group Debuggingtag commandIDREF="apA.cmd198"dbx Commands$tagfileIDREF="apC.vars86"Predefined dbx Variables    thread clauseIDREF="08.multiple7"Using the thread Clausetrace commandIDREF="06.exec41"Tracing Program ExecutionIDREF="06.exec37"Tracing Program ExecutionIDREF="06.exec35"Tracing Program ExecutionIDREF="apA.cmd199"dbx CommandsIDREF="06.exec39"Tracing Program ExecutionIDREF="apA.cmd201"dbx CommandsIDREF="01.start27"Studying a New Programtracei commandIDREF="07.mach57"Tracing Execution at the Machine LevelIDREF="07.mach54"Tracing Execution at the Machine LevelIDREF="07.mach59"Tracing Execution at the Machine LevelIDREF="07.mach50"Tracing Execution at the Machine LevelIDREF="apA.cmd207"dbx CommandsIDREF="07.mach61"Tracing Execution at the Machine LevelIDREF="07.mach56"Tracing Execution at the Machine LevelIDREF="07.mach63"Tracing Execution at the Machine LeveltracingdeletingIDREF="06.exec63"Deleting Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd60"dbx CommandsdisablingIDREF="apA.cmd70"dbx CommandsIDREF="06.exec54"Disabling Breakpoints, Traces, and Conditional CommandsenablingIDREF="06.exec58"Enabling Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd86"dbx CommandsproceduresIDREF="apA.cmd209"dbx CommandsIDREF="apA.cmd202"dbx CommandsIDREF="01.start29"Studying a New ProgramIDREF="06.exec38"Tracing Program Executionprocess groupsIDREF="08.multiple69"Handling sproc System Calls and Process Group Debuggingsource linesIDREF="01.start30"Studying a New ProgramstatusIDREF="apA.cmd178"dbx CommandsIDREF="06.exec50"Listing Breakpoints, Traces, and Conditional CommandsvariablesIDREF="apA.cmd213"dbx CommandsIDREF="07.mach60"Tracing Execution at the Machine LevelIDREF="07.mach62"Tracing Execution at the Machine LevelIDREF="07.mach64"Tracing Execution at the Machine LevelIDREF="01.start28"Studying a New ProgramIDREF="06.exec36"Tracing Program ExecutionIDREF="06.exec40"Tracing Program ExecutionIDREF="07.mach55"Tracing Execution at the Machine LevelIDREF="07.mach58"Tracing Execution at the Machine LevelIDREF="apA.cmd200"dbx CommandsIDREF="apA.cmd203"dbx CommandsIDREF="apA.cmd204"dbx CommandsIDREF="apA.cmd205"dbx CommandsIDREF="apA.cmd206"dbx CommandsIDREF="apA.cmd208"dbx CommandsIDREF="apA.cmd210"dbx CommandsIDREF="apA.cmd211"dbx CommandsIDREF="apA.cmd212"dbx CommandstroubleshootingIDREF="01.start31"Avoiding Common Pitfallstype castingIDREF="05.change45"Using Data Types and Type Coercion (Casts)type conversionIDREF="05.change44"Using Data Types and Type Coercion (Casts)type declarations of program variable namesIDREF="apA.cmd233"dbx CommandsIDREF="05.change93"Displaying Type Declarationsunalias commandIDREF="04.cntrl48"Removing Command AliasesIDREF="apB.alias3"Predefined AliasesIDREF="apA.cmd214"dbx Commandsunconditional breakpointsIDREF="06.exec2"Setting BreakpointsIDREF="01.start11"Debugging Your ProgramssettingIDREF="06.exec7"Setting Unconditional BreakpointsIDREF="apA.cmd184"dbx CommandsIDREF="apA.cmd185"dbx Commandsunrecord commandIDREF="04.cntrl60"Ending a Recording SessionIDREF="apA.cmd216"dbx CommandsIDREF="apA.cmd218"dbx CommandsIDREF="04.cntrl59"Ending a Recording Sessionunset commandIDREF="04.cntrl11"Removing VariablesIDREF="apA.cmd220"dbx Commandsunsetenv  commandIDREF="apA.cmd222"dbx CommandsIDREF="05.change78"Displaying and Changing Environment Variables Used by a Programunstacking interactive function callsIDREF="05.change125"Using ccallup commandIDREF="apA.cmd223"dbx CommandsIDREF="05.change105"Moving Within the Stackusepath remappingIDREF="03.examin13"Path Remappinguse commandIDREF="03.examin11"Specifying Source Directories With dbx CommandsIDREF="02.run16"dbx OptionsIDREF="apA.cmd225"dbx CommandsIDREF="03.examin8"Specifying Source Directories With dbx Commandsvariablesdbx. See dbx variablesIDREF="05.change1"Using ExpressionsIDREF="04.cntrl1"Creating and Removing dbx Variablesdo not displayIDREF="01.start32"Avoiding Common Pitfallsvariables, predefined dbx. See predefined dbx variablesIDREF="apC.vars12"Predefined dbx Variables    variables, programIDREF="05.change2"Using ExpressionsIDREF="05.change58"Displaying and Changing Program Variablescase sensitivityIDREF="apC.vars17"Predefined dbx Variables    IDREF="05.change74"Case Sensitivity in Variable Nameschanging valuesIDREF="apA.cmd45"dbx CommandsIDREF="05.change70"Changing the Value of a Variabledetermining scopeIDREF="05.change89"Determining Variable Scopes and Fully Qualified NamesIDREF="apA.cmd243"dbx CommandsIDREF="apA.cmd241"dbx CommandsexaminingIDREF="01.start17"Debugging Your ProgramsIDREF="01.start25"Studying a New Programnames and C keyword conflictsIDREF="apC.vars19"Predefined dbx Variables    names and keyword conflictsIDREF="05.change73"Conflicts Between Variable Names and KeywordsprintingIDREF="05.change60"Displaying the Value of a Variablequalifying variable namesIDREF="06.exec42"Tracing Program ExecutionIDREF="05.change99"Examining the StackIDREF="05.change46"Qualifying Names of Program ElementsscopeIDREF="05.change59"Variable ScopeIDREF="05.change109"Moving Within the StackIDREF="05.change115"Moving to a Specified ProcedureIDREF="05.change47"Qualifying Names of Program ElementsIDREF="05.change98"Examining the StacktracingIDREF="01.start28"Studying a New Programtype declarationsIDREF="05.change93"Displaying Type DeclarationsIDREF="apA.cmd233"dbx CommandsWIDREF="apB.alias37"Predefined Aliaseswait commandIDREF="apA.cmd227"dbx CommandsIDREF="08.multiple40"Waiting for a Resumed ProcessIDREF="08.multiple38"Waiting for a Resumed Processwait for active processIDREF="apA.cmd228"dbx CommandsIDREF="08.multiple39"Waiting for a Resumed Processwait for processIDREF="08.multiple41"Waiting for a Resumed ProcessIDREF="apA.cmd229"dbx Commandswait for running processIDREF="08.multiple42"Waiting for Any Running ProcessIDREF="apA.cmd231"dbx Commandswaitall commandIDREF="08.multiple43"Waiting for Any Running ProcessIDREF="apA.cmd230"dbx CommandsIDREF="08.multiple37"Waiting for a Resumed Processwhatis commandIDREF="05.change94"Displaying Type DeclarationsIDREF="apA.cmd232"dbx Commandswhen commandIDREF="apA.cmd234"dbx CommandsIDREF="06.exec45"Writing Conditional Commandswheni commandIDREF="07.mach65"Writing Conditional Commands at the Machine LevelIDREF="07.mach66"Writing Conditional Commands at the Machine LevelIDREF="07.mach67"Writing Conditional Commands at the Machine LevelIDREF="apA.cmd237"dbx Commandswhere commandIDREF="apA.cmd238"dbx CommandsIDREF="01.start6"Examining Core Dumps to Determine Cause of FailureIDREF="05.change101"Printing Stack TracesIDREF="07.mach42"Syntax of the stopi Commandwhereis  commandIDREF="05.change50"Qualifying Names of Program ElementsIDREF="apA.cmd240"dbx CommandsIDREF="05.change52"Qualifying Names of Program ElementsIDREF="05.change91"Determining Variable Scopes and Fully Qualified Names$whereisdsolimitIDREF="apC.vars87"Predefined dbx Variables    IDREF="05.change92"Determining Variable Scopes and Fully Qualified Nameswhich  commandIDREF="05.change90"Determining Variable Scopes and Fully Qualified NamesIDREF="apA.cmd242"dbx CommandsIDREF="05.change49"Qualifying Names of Program ElementsIDREF="05.change53"Qualifying Names of Program Elementswhichobj commandIDREF="apA.cmd244"dbx CommandsIDREF="02.run5"Compiling and Linking Programs With Dynamic Shared Objects