/*
 * Files:         simplem2v.c
 *
 * Usage:         simplem2v <filename>
 *
 * Description:   Simplem2v sends a frame of image data from memory 
 *                to the video output. The image data must be in YUV422
 *		  format. Images in this format may be generated by
 *             	  running the vidtomem application with the -r option
 *                on an Indy Video board. 
 *                Simplem2v only runs on video hardware that has a 
 *		  video output port. It will not run on a VINO video 
 *                board.
 *  		  
 *
 * Functions:     SGI Video Library functions used
 *
 *                vlOpenVideo()
 *                vlGetNode()
 *                vlCreatePath()
 *                vlSetupPaths()
 *                vlRegisterBuffer()
 *		  vlCreateBuffer()
 *                vlGetTransferSize()
 *		  vlGetNextFree()
 *		  vlGetActiveRegion()
 *                vlBufferDone()
 *                vlBeginTransfer()
 *                vlEndTransfer()
 *                vlDeregisterBuffer()
 *		  vlDestroyBuffer()
 *                vlDestroyPath()
 *                vlCloseVideo()
 *		  vlGetErrno()
 *                vlPerror()
 *                vlStrError()
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/errno.h>
#include <dmedia/vl.h>

#define MIN(x,y) ((x>y)?y:x)

extern int errno;

main(int argc, char **argv)
{
    VLServer svr;
    VLPath MEMtoVIDPath;
    VLNode src, drn;
    VLBuffer buf;
    VLInfoPtr info;
    struct stat status_buffer;
    char *dataPtr;
    ulong transferSize;
    int ret, fd;
    int c;
    char *_progName;
    char *fileName;

    _progName = argv[0];
    
    if (argc != 2)
    {
	fprintf(stderr,"%s <filename>\n", _progName);
	exit(1);
    }
    
    fileName = argv[1];

    /* Connect to the daemon */
    if (!(svr = vlOpenVideo(""))) 
    {
	fprintf(stderr,"%s: can't open video: %s\n", _progName, vlStrError(vlGetErrno()));
	exit(1);
    }

    /* Set up a source node in memory */
    src = vlGetNode(svr, VL_SRC, VL_MEM, VL_ANY);
    
    /* Set up a video drain node on the first device that has one */
    drn = vlGetNode(svr, VL_DRN, VL_VIDEO, VL_ANY); 
    
    /* Create a path using the selected devices */
    MEMtoVIDPath = vlCreatePath(svr, VL_ANY, src, drn);

    /* Set up the hardware for and define the usage of the path */
    if (vlSetupPaths(svr, (VLPathList)&MEMtoVIDPath, 1, VL_SHARE, VL_SHARE)<0)
    {
	fprintf(stderr,"%s: can't setup path: %s\n", _progName, vlStrError(vlGetErrno()));
	exit(1);
    }

    /* Find out what size this path supports */
    transferSize = vlGetTransferSize(svr,MEMtoVIDPath);

    /* Create a ring buffer for the data transfers */
    buf = vlCreateBuffer(svr, MEMtoVIDPath, src, 1);

    /* Associate the ring buffer with the path */
    vlRegisterBuffer(svr, MEMtoVIDPath, src, buf);
   
    /* Get the next free frame in the buffer, reserve it for the data */
    do
    {
	info = vlGetNextFree(svr, buf, transferSize);
    } while (!info && !vlBufferDone(buf)); 

    /* Get a pointer to where the data will go */
    dataPtr = vlGetActiveRegion(svr, buf, info);

    /*  Open raw YUV data file */
    fd = open(fileName, O_RDONLY);
    if (!fd)
    {
	fprintf(stderr,"%s: cannot open file %s.\n", _progName, fileName);
	exit(1);
    }
    
    /* Get the file's size (image size of this data)*/
    if (fstat(fd,&status_buffer) == -1) 
    {
	perror(fileName);
	exit(1);
    }

    /* Make sure the hardware supports this image size */
    if (status_buffer.st_size != transferSize) 
    {
	fprintf(stderr,"%s: The image is not the right size for this device\n",
	   _progName);
	exit(1);
    }
    
    /* Read in the data */
    ret = read(fd, dataPtr, transferSize);
    close(fd);
    
    /* Check the size of the data read in */
    if (ret != transferSize) 
    {
	fprintf(stderr, "%s: Unable to read the image data\n", _progName);
	exit(1);
    }

    /* Put the data into the ring buffer  */
    vlPutValid(svr, buf);

    /* Begin the data transfer */
    vlBeginTransfer(svr, MEMtoVIDPath, 0, NULL);
    
    /* Wait until user presses a key */
    printf("Hit return to exit.\n");
    c = getc(stdin);
    
    /* End the data transfer */
    vlEndTransfer(svr, MEMtoVIDPath);
    
    /* Clean up and exit */
    vlDeregisterBuffer(svr, MEMtoVIDPath, src, buf);
    vlDestroyPath(svr, MEMtoVIDPath);
    vlDestroyBuffer(svr, buf);
    vlCloseVideo(svr);
}
