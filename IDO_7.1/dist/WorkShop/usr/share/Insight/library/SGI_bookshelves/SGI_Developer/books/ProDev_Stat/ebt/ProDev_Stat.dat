#EDIR DATA#
LANG=CDeveloper Magic‘: Static Analyzer User's GuideDocument Number 007-2580-002CONTRIBUTORSWritten and Illustrated by John C. Stearns Edited by Christina CaryProduction by Laura CooperEngineering contributions by Lia Adams, Jim Ambras, Trevor Bechtel, Alan Foster, Christine Hanna, David Henke, Marty Itzkowitz, Mahadevan Iyer, Lisa Kvarda, Allan McNaughton, Ashok Mouli, Sudhir Mohan, Anil Pal, Andrew Palay, Kim Rachmeler, Jack Repenning, Paul Sanville, Ravi Shankar, Shankar Unni, Mike Yang, Jun Yu, and Doug Young.© 1991-1995 Silicon Graphics, Inc.name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' All Rights ReservedThis document contains proprietary and confidential information of Silicon Graphics, Inc. The contents of this document may not be disclosed to third parties, copied, or duplicated in any form, in whole or in part, without the prior written permission of Silicon Graphics, Inc.RESTRICTED RIGHTS LEGENDUse, duplication, or disclosure of the technical data contained in this document by the Government is subject to restrictions as set forth in subdivision (c) (1) (ii) of the Rights in Technical Data and Computer Software clause at DFARS 52.227-7013 and/or in similar or successor clauses in the FAR, or in the DOD or NASA FAR Supplement. Unpublished rights reserved under the Copyright Laws of the United States. Contractor/manufacturer is Silicon Graphics, Inc., 2011 N. Shoreline Blvd., Mountain View, CA 94039-7311.Silicon Graphics is a registered trademark, and Graphics Library are trademarks of Silicon Graphics, Inc. ClearCase is a trademark of Atria Software, Inc. UNIX is a registered trademark of UNIX System Laboratories. X Window System is a trademark of the Massachusetts Institute of Technology. OSF/Motif is a trademark of the Open Software Foundation.About This GuideThis manual is a user's guide for the ProDev WorkShop Static Analyzer and Browser, Release 2.5.1. NoteThe features described in this manual that apply to Ada are only available if you have purchased the ProDev Ada package.This manual contains the following chapters:IDREF="69413" TYPE="TITLE"Chapter 1, "Introduction to the WorkShop Static Analyzer," describes the Static Analyzer, the WorkShop tool for examining the structure of a program's source code and the relationships between its parts, such as files, functions, and variables.IDREF="70671" TYPE="TITLE"Chapter 2, "A Sample Session With the Static Analyzer," provides a tutorial to introduce you to some major features in the Static Analyzer. IDREF="32461" TYPE="TITLE"Chapter 3, "Static Analyzer: Creating a Fileset and Generating a Database," describes the fileset concept. A fileset is a file that contains files you specify for inclusion in the analysis. You also specify whether a file is to be analyzed by the faster scanner mode or the slower, more thorough parser mode.IDREF="24882" TYPE="TITLE"Chapter 4, "Static Analyzer: Queries," describes how you perform queries using the Static Analyzer. IDREF="25986" TYPE="TITLE"Chapter 5, "Static Analyzer: Views," describes the text and graphical views that the Static Analyzer uses to present its data. IDREF="27911" TYPE="TITLE"Chapter 6, "Static Analyzer: Working on Large Programming Projects," presents techniques for applying the Static Analyzer to large projects. IDREF="13468" TYPE="TITLE"Chapter 7, "Getting Started With the Browser," tells you how to start the Browser and describes some of the features common to both the C++ and Ada versions of Browser View.IDREF="89909" TYPE="TITLE"Chapter 8, "Using the Browser for C++: A Sample Session," provides a short tutorial highlighting the C++ features of Browser View.IDREF="65958" TYPE="TITLE"Chapter 9, "Using the Browser for Ada: A Sample Session,"provides a short tutorial highlighting the Ada features of Browser View.IDREF="41721" TYPE="TITLE"Chapter 10, "The Browser Reference," describes all of the Browser windows, menus, and other features in detail.LBL="1"ID="69413"Introduction to the WorkShop Static AnalyzerToo many software projects today contain massive amounts of code that may or may not compile, have few or no comments, and are teamed by programmers unfamiliar with the original code. The ProDev WorkShop Static Analyzer helps solve problems like these. With the Static Analyzer, you can analyze source code written in C, C++, Fortran, or Ada (with ProDev Ada package ID="ch011"only). It shows you the code's structure, including how functions within programs call each other, where and how variables are defined, how files depend on each other, where you can find macros, and other structural details to help you understand the code.The Static Analyzer provides the answers in text or easily understood graphic form. Because the Static Analyzer is interactive, you can quickly zero in on the part of the code structure that interests you, or you can step back for an overview. And because the Static Analyzer recognizes the connections between elements of the source code, you can readily trace how a proposed change to one element will affect related elements.The following is covered in this chapter:IDREF="23362" TYPE="TITLE""How the Static Analyzer Works"IDREF="17247" TYPE="TITLE""How You Use the Static Analyzer"NoteThe features described in this chapter that apply to Ada are only available if you have purchased the ProDev Ada package.LBL="" HELPID=""ID="23362"How the Static Analyzer WorksThe Static Analyzer is in essence a database program that reads through one or more source code files and creates a database that includes functions, macros, variables, files, and object-oriented elements for C++ and Ada. The database also includes the interconnections between the elementsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'which functions call which other functions, which files include which other files, and so on.ID="ch012"The Static Analyzer provides two modes for extracting static analysis data from your source files:scanner modename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'a fast, general-purpose scanner that looks through code with minimal sensitivity to the programming language parser modename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'a language-sensitive scanner that can be run at compile time by setting a switchThe trade-off between the modes is speed versus accuracy. A very effective technique is to perform preliminary analysis in scanner mode when you need to see the overall structure of a large group of files and then focus on a smaller subset using parser mode to derive detailed relationship information. Note also that if a program cannot compile, parser mode will not work and you must use scanner mode.The Static Analyzer can perform selective searches (called ID="ch013"queries) through the database. The Static Analyzer displays the results of the query in the query results area (the interior of its main window). If you've used the UNIX grep command, you'll find that the Static Analyzer can perform the same kinds of simple searches through the text of your source code, finding strings of text as well as regular expressions. The Static Analyzer also performs much more sophisticated queries that follow connections between elements of the source code: function calls, file includes, class parenthood, and other similar relationships. Be careful not to request too much data! Overly general queries often return extensive results that are difficult to comprehend (consider, for example, a query that asks for all of the functions defined in millions of lines of source code). The Static Analyzer can restrict the scope of your queries so you can break down large projects into pieces of a manageable size. For example, you can see the connections to and from a single function or take a look at all the classes defined within a single file.ID="ch014"By default, the Static Analyzer displays the results of your query in text form. You can scroll through the results, and you can immediately call up the file that contains any element you see in the results. The file appears in the Source View window, which shows you the exact source code line where that element occurs. You can also ask the Static Analyzer to display the results of the query in a graphic view that shows not only the elements found but alsoname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'using tree formname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the relationships between elements. To help you see the structure more clearly, you can set the scale and orientation of the tree, or you can call for a full overview that shows all elements in the structure and helps you scroll to the particular elements you want.ID="ch015"ID="ch016"LBL="" HELPID=""ID="17247"How You Use the Static AnalyzerTypically, in performing static analysis, you create an overview showing basic relationships and then zero in on the source code requiring further work or analysis. There are five general steps in the static analysis process:ID="ch017"Decide which files to include in your static analysis.It is good practice to narrow down the set of files to be analyzed as much as possible. Large static analysis databases are not only difficult to navigate through, but are time-consuming to build. You specify the files to be used in a special file called a fileset (see IDREF="32461" TYPE="TITLE"Chapter 3, "Static Analyzer: Creating a Fileset and Generating a Database" for more information).Choose how the files will be analyzed: parser mode, scanner mode, a combination, or differently in multiple passes.Scanner mode is good for determining the general structure of a program. It is most appropriate when you are working on uncompilable code, analyzing large filesets, or performing preliminary analysis. Parser mode is better when you need detailed relationship information. You should apply parser mode to smaller filesets, because it takes longer to extract data.In some situations, it is desirable to use a combination of modes. For example, if you need detail but are having compilation problems, you can apply the scanner to the problem files and the parser to everything else. A different example would be applying the parser to a few files where you need detail and the scanner to the rest of the fileset.An example of a multiple-pass scenario is to analyze a large fileset in scanner mode, zero in on a subset of the files, and then run that subset through parser mode to get a detailed analysis. Build the static analysis database.Both scanner mode and parser mode can be invoked within the Static Analyzer. After you have defined your fileset, the database will be built when you make your first query or when you select "Rescan" or "Force Scan."Parser mode can also be invoked through the compiler. A particularly convenient method for using the Static Analyzer parser is to modify an existing makefile so that it analyzes the files as part of the build process. This can be done with or without producing object code. You use the flags: -sa,<directory> and -nocode. For more information on this approach, see IDREF="22770" TYPE="TITLE""Tutorial 3: Using the Compiler to Create a Static Analysis Database".Perform static analysis queries and view the results.The queries can give you a good idea of the structure and the relationship of components in your program. You can review the results in text form, as a list of items and their source lines or graphically (a tree showing relationships between items).If you're programming in C++ or Ada, you can make object-oriented queries by bringing up the Browser, a facility within the Static Analyzer for viewing structural and relationship information in C++ or Ada programs.Bring up Source View to edit or view a selected component.Once you have isolated an area for analysis, you can readily edit the source code from the Static Analyzer. Double-clicking an element brings up the corresponding source code in Source View.LBL="2"ID="70671"A Sample Session With the Static AnalyzerThis chapter shows how you might use the Static Analyzer in a typical session. It doesn't go into full detail, but it does explain the fundamental concepts you'll need to use the Static Analyzer. It lists related commands and controls after each tutorial so you can experiment on your own. You'll find more specific details about Static Analyzer features in Chapters 3 - 6.This chapter discusses the following topics:IDREF="90197" TYPE="TITLE""Tutorial 1: Applying the Static Analyzer to Scanned Files"IDREF="48858" TYPE="TITLE""Tutorial 2: Applying the Static Analyzer to Parsed C++ Files"IDREF="22770" TYPE="TITLE""Tutorial 3: Using the Compiler to Create a Static Analysis Database"IDREF="19691" TYPE="TITLE""Other Static Analyzer Features"LBL="" HELPID=""ID="17247"ID="90197"Tutorial 1: Applying the Static Analyzer to Scanned FilesIn this tutorial, you will create a fileset for the demo program bounce using scanner mode and perform some basic queries in text mode.Move to the /usr/demos/WorkShop/bounce directory by entering the following:cd /usr/demos/WorkShop/bounceThis directory contains the source code files (C++) for the demo program bounce.List the directory's contents to see if the file cvstatic.fileset exists (in case someone worked through a tutorial and forgot to remove the file). If it does exist, remove it along with any other files the Static Analyzer may have left:rm cvstatic.* cvdb* vista.tafWhenever you run the Static Analyzer, it checks the directory where you invoked it for cvstatic.fileset and uses the file's contents as its fileset. If it doesn't find ID="ch021"cvstatic.fileset, it creates and saves its own fileset containing the expression ID="ch022"*.[cCfF] so that all possible C files (.c), Fortran files(.f or .F), and C++ files (.C) in the current directory are included. When you quit the Static Analyzer, any fileset you or the Static Analyzer created remains in the directory for use in your next Static Analyzer session.If you don't care to use the default fileset, you can create your own or modify the default fileset using the "Edit Fileset..." selection in the Admin menu. You can also create your own ID="ch023"cvstatic.fileset file by hand; you'll find instructions in IDREF="10605" TYPE="TITLE""Creating a Fileset Manually".Start the Static Analyzer by entering the following:cvstatic &The Static Analyzer window appears (as shown in IDREF="91378" TYPE="GRAPHIC"Figure 2-1).FILE="ch02.gif" POSITION="INLINE" SCALE="FALSE"LBL="2-1"Figure 2-1 ID="91378"The Static Analyzer WindowChoose "Edit Fileset..." from the Admin menu to open the Fileset Editor window (shown in IDREF="15611" TYPE="GRAPHIC"Figure 2-2).FILE="ch022.gif" POSITION="INLINE" SCALE="FALSE"LBL="2-2"Figure 2-2 ID="15611"The Fileset Editor WindowThe current working directory appears in the Browsing Directory field at the top left. Subdirectories (if any) appear in the Directories list field. The files in the current working directory appear in the Files list field. You select the files you wish to include in the fileset from these two lists. For parser mode files, you click the associated Parser button; for scanning mode, the Scanner button. There are two sets of Parser and Scanner mode buttons: the upper set moves whole directories and the lower set individual files. The two fileset list fields Parser Fileset and Scanner Fileset are at the right of the window.Select the expression *.[cCfF] in both the Parser Fileset and Scanner Fileset list fields (if it appears), and click the Remove button.This removes any default expressions from the fileset.Click the C++ language filter button.This filters the Files list to include only those files with the .C extension (signifying C++ source files) and selects them all.Now add these source code files to the fileset by clicking the Move Files:Scanner button. The ScannerFileset list now displays the files selected from the Files list. These files will be scanned into the static analysis database when it is created. Click the OK button at the bottom of the Fileset Editor window.Once you've created the fileset, you can query it for useful information. Your first query prompts the Static Analyzer to extract static analysis data from the files in the fileset and create a cross-reference database (using scannner mode). This occurs prior to returning the results of your query. The database includes the relationships between functions, files, classes, and other elements of the code in the fileset, and is saved in a database file along with two accompanying index files. The database file is named cvstatic.xreID="ch024"ID="ch025"ID="ch026"f; the accompanying files are named ID="ch027"cvstatic.index and cvstatic.posting.ID="ch028" These files are stored in the same directory as the fileset with which they're associated, and remain there after the Static Analyzer quits.Subsequent queries use the same database until you ask the Static Analyzer to rescan the fileset, which creates an updated database. When you quit the Static Analyzer and return to it later, it automatically updates the database, going through any files in the fileset that have changed since the last session. If you use appropriate wild card expressions in the fileset, the fileset will automatically accommodate new files added to specified directories.From a shell, list the contents of the cvstatic.fileset file.All files and their paths to be included in the fileset should display. If you had selected files for parsing, they would have compiler flags following their paths.Click the Queries menu to open it.To query the database, you choose a command from the Queries menu. You'll find the commands grouped in submenus according to types of query (see IDREF="49794" TYPE="GRAPHIC"Figure 2-3).FILE="ch023.gif" POSITION="INLINE" SCALE="FALSE"LBL="2-3"Figure 2-3 ID="49794"Static Analyzer Queries Menu and Query Target FieldThe query submenus let you perform different searches:ID="ch029""General" searches for text strings, regular expressions, and symbols."Macros" searches for locations of macro definitions and places where macros are used."Variables" searches for global and local variables and shows where they're defined and who references and sets the variables."Functions" searches for functions, shows where they're defined, and shows who calls them and whom they in turn call."Files" searches for files in the fileset (including headers and libraries) and shows which files are included by which other files."Classes" searches C++ files for classes and shows where they're defined. It also shows subclass and superclass relationships, and lists the methods defined within classes."Methods" searches C++ files for methods and shows where they're defined and declared."Common Blocks" searches Fortran files for common blocks."Types" searches C and C++ files for type information."Directories" lets you list directories or the files in a directory."Packages" lets you look for Ada packages."Tagged Types" lets you look for Ada tagged types."Task Types" lets you look for Ada task types.To start a query, you choose the query you want from the Queries menu. The Static Analyzer then searches through its database or through the original source code to find what you asked for.ID="ch0210" If you want to look for a specific function, file, string, or other element, you enter the target text in the ID="ch0211"ID="ch0212"Query Target field above the query results area (shown in IDREF="91378" TYPE="GRAPHIC"Figure 2-1).Queries that require text in the Query Target field (such as "Find String" in the General submenu and "Who Is Called By?" in the Functions submenu) are grayed in the Queries menu if there is no text present. More general queries that require no search text (such as "List All Functions" and "List Global Symbols") are always available.Choose "List All Functions" from the "Functions" submenu of the Queries menu.The Static Analyzer builds its cross-reference database and notifies you that it's doing so. When it's finished, it displays a list of all functions found in the fileset (as shown in IDREF="95397" TYPE="GRAPHIC"Figure 2-4), their file, the line number at which they are first defined or declared, with the actual source line.NoteDuring this process, you may get a warning dialog box about multiple function occurrences. This is due to the inaccuracy of scanner mode; it has problems with #ifdef statements. You may also get an error message about missing files. This can happen if your include paths are not set correctly. The missing files are not necessary for this tutorial. Usually you can tell by looking at the files if you need to include them in the fileset.FILE="ch024.gif" POSITION="INLINE" SCALE="FALSE"LBL="2-4"Figure 2-4 ID="95397"The Results of a "List Functions" QueryThe Static Analyzer returns the results of all queries in its query results area (below the ID="ch0213"Query Target field). It presents this information in text form (and by the previous type of view if applicable for subsequent queries). You can scroll through a text list to find specific data that interests you. Clicking any part of an element listed (a filename, a function name, a line number, and so on) pastes it into the Query Target field so you can use it as the base of your next search. For example, if you'd like to find out what functions a particular function calls, you can click its name to put it into the Query Target field and then choose "Who Is Called By" from the "Functions" submenu of the Queries menu.Text View allows you to sort the element lines alphanumerically by any one of the fields in a line. For example, you can sort a list of functions alphabetically by function name or numerically by line number where they occur. To sort, click within an element line in the field by which you want to sort, and then choose "Sort" from the Admin menu. The Static Analyzer sorts the results of a query according to the field selected.ID="ch0214"Click the function name Actor in the query results area.The Static Analyzer pastes the name into the Query Target field.Choose "Who Is Called By" from the "Functions" submenu of the Queries menu.The Static Analyzer displays a list of all functions called by Actor.Clear the Query Target field and then type buffer in it.We are now going to look for any occurrences of the text string "buffer" that might lead us to information in the code concerning z-buffering or data buffering. Choose "Find String" from the "General" submenu of the Queries menu.The Static Analyzer returns all the lines of code that contain the text string "buffer," even if it only appears in a comment.Click the History menu to open it.It displays the queries you've made so far, as shown in IDREF="51547" TYPE="GRAPHIC"Figure 2-5.FILE="f13histy.gif" POSITION="INLINE" SCALE="FALSE"LBL="2-5"Figure 2-5 ID="51547"Static Analyzer History MenuChoose "List All Functions" from the History menu to see a list of all functions once again.This brings back your previous query results.Double-click the Actor function.Source View now appears, displaying the source code for Actor. You can examine it, check it out (if you have a versioning system), or edit it.Select "Close" from the Source View File menu to close it.Select "Exit" from the Static Analyzer Admin menu to end this tutorial.LBL="" HELPID=""ID="48858"Tutorial 2: Applying the Static Analyzer to Parsed C++ FilesIn this tutorial, you will create a fileset for bounce using parser mode and perform some detailed static analysis in both text mode and graphic mode.Move to the /usr/demos/WorkShop/bounce directory by entering the following:cd /usr/demos/WorkShop/bounceType rm cvstatic.* cvdb* vista.tafWe need to remove these files to avoid using the previous fileset.Start the Static Analyzer by entering the following:cvstatic -mode PARSER &The Static Analyzer window appears. The -mode PARSER option causes the Static Analyzer to use parser files only when queries are performed.Select "Edit Fileset..." from the Admin menu.We are going to apply parser mode through the Fileset Editor.Remove the wild card defaults (*.[cCfF]) if they appear in the fileset lists.Select the file called BouncingBall.C in the File list at the lower left and click the Move Files: Parser button to transfer the file to the Parser Fileset list.This enters the file BouncingBall.C into the fileset and sets it for parsing mode.Click OK to save the new fileset and from a shell, type cat cvstatic.filesetThe contents of cvstatic.fileset display:/usr/demos/WorkShop/bounce/BouncingBall.C NCC Notice that the BouncingBall.C file has a compiler flag indicator as part of the entry. This is how parser mode files are indicated.Select "List All Functions" from the Queries Menu.The Static Analyzer builds a new database using parser mode. Since BouncingBall.C has a number of include files, this process may take a few minutes. During the process, a small window called Build Shell appears that displays any compiler errors or warnings. At the conclusion of the process, the functions in BouncingBall.C and its include files are listed in text form in the query results area. Select "Call Tree View" from the Views menu.The query results area now changes to graphical form. The functions are depicted as rectangles. In addition to listing functions, the Static Analyzer now provides us with relationship information, that is, who calls which functions. The function calls are shown as arrows (or arcs) pointing to the functions that were called.Besides "Call Tree View," there are two other types of graphical views: "Class Tree View," which displays C++ classes and their hierarchy, and "File Dependency View," which displays the files in the fileset and their dependency on each other.ID="ch0215"ID="ch0216" Whenever you use a tree view, the view interprets the results of your query according to the type of tree displayed. For example, if you perform a "Functions" query while you're in file dependency view, the view changes to show you which files contain the functions returned by the query. Some views don't make sense for displaying the results of a query, in which case the Static Analyzer switches to the view it thinks is most reasonable for the query.ID="ch0217"Click the Graph Overview button (the fourth button from the left at the bottom of the Static Analyzer window).This displays the Call Tree Overview window, a feature to help users navigate through a graph. It displays the full call tree in overview, with a small rectangular outline (called the 
viewport) in the upper-left corner. The viewport shows which portion of the tree currently appears in the query results area of the Static Analyzer window and can be dragged by the mouse to expose other portions of the graph. See ID="ch0218"IDREF="78166" TYPE="GRAPHIC"Figure 2-6.FILE="ch025.gif" POSITION="INLINE" SCALE="FALSE"LBL="2-6"Figure 2-6 ID="78166"Typical Static Analyzer Call TreeClick in the center of the Call Tree Overview window.The viewport jumps so that its upper-left corner matches the pointer location. The query results area in the Static Analyzer window shifts to display the part of the tree outlined by the viewport in the Call Tree Overview window.Drag the viewport around in the Call Tree Overview window by holding down the left mouse button and moving the mouse. Finish by dragging the viewport to the upper-left corner of the call tree.As the viewport moves over the call tree overview, the call tree shown in the Static Analyzer query results area scrolls to match.Select "Close" from the Admin menu in the Call Tree Overview window to close it.Enter colorSelected in the Query Target field and select "Who Calls?" from the "Functions" submenu in the Queries Menu.This reduces the graph to three nodes: colorSelectedCallback and cancelCallback, which call colorSelected, and colorSelected itself.Hold the right mouse button down over the node labeled colorSelected to open its popup menu.This displays the individual node menu, which provides the selections: "Hide Node," "Collapse Subgraph," "Show Immediate Children," and "Show Parents." The triangular arrow at the right of the colorSelected node indicates that it has undisplayed child nodes: accordingly the "Show Immediate Children" is enabled. Since the parents of colorSelected are already displayed, the "Show Parents" selection is disabled.If you hold the right mouse button down over a portion of the query results area where there are no nodes, the selected nodes menu displays, which provides the selections: "Hide Selected Nodes," "Collapse Selected Nodes," and "Expand Selected Nodes." Choose "Show Immediate Children" from the popup menu.The Static Analyzer displays the functions called by colorSelected.For more information on the standard graph controls and node manipulation, see IDREF="95481" BOOK="007-2582-002" FILE="appa.doc" HDG=""Appendix A, "Using Graphical Views," in the DeveloperMagic: ProDev WorkShop Overview. Note that the view options menu is unique to the Static Analyzer. It offers options that extend the range of the nodes you see in the tree to include nodes not included in the original query.Open the History menu to review the commands you have selected.Choose "Exit" from the Admin menu to exit the Static Analyzer.Remove all the files generated by the Static Analyzer from the directory:rm cvstatic.* cvdb* vista.tafLBL="" HELPID=""ID="22770"Tutorial 3: Using the Compiler to Create a Static Analysis DatabaseThis tutorial takes you through the steps of creating a static analysis database, using parser mode.Type cd /usr/demos/WorkShop/bounce to go to the bounce demonstration directory.We will once again analyze the bounce demonstration program. Type mkdir staticdirThis creates the subdirectory in which we will store the static analysis database. If a directory named staticdir already exists, remove it or use a different name.Type cd staticdir to change directories and then initcvdb.sh.The initcvdb.sh script creates the initial files cvdb*.* necessary for producing the database.Change /usr/demos/WorkShop/bounce/Makefile as follows:The most convenient method for applying the Static Analyzer parser to a large group of files is to modify the existing makefile so that it analyzes the files without producing object code. Change the following line:CC=CCtoCC=NCC -sa,staticdir -nocodeChanging to NCC causes the C++ compiler to be used. The flag -sa tells the compiler to perform static analysis. Following -sa with ,staticdir tells the compiler to store the results in the staticdir subdirectory; otherwise, the current directory is assumed. The flag -nocode saves you time by telling the compiler not to create object code.Make sure you are in the /usr/demos/WorkShop/bounce directory and typemake -kThis runs the compiler as you've specified in the makefile. This may take a while. Running parser mode performs the major operations of compiling, short of creating the object code.Go to the staticdir subdirectory and type cvstatic -mode PARSER -readonlyThis invokes the Static Analyzer set for parsed files. The other mode options are SCANNER for scanned files and BOTH if you mix scanned and parsed files. The -readonly safeguard flag protects against inadvertent changes. You can now perform any valid Static Analyzer operations, as in the previous tutorials.LBL="" HELPID=""ID="19691"Other Static Analyzer FeaturesYou'll find more detailed information about querying in Chapter 5. To explore on your own, try these commands in the Admin menu, which also affect queries:ID="ch0219""Rescan"ID="ch0220"asks the Static Analyzer to update the cross-reference database by rescanning any source code files in the fileset that have changed since the last database update."Force Scan"ID="ch0221"asks the Static Analyzer to update the cross-reference database by rescanning all source code files in the fileset, whether they have changed or not."General Options..."ID="ch0222"offers options that determine how a query treats the text string entered in the Query Target field and how filenames are displayed."Set Include Path..."ID="ch0223"allows you to set a search path of directories where the Static Analyzer looks for include files that are mentioned in the code contained in the fileset."Save Query..."ID="ch0224"saves the text or graphics results of a query to a file. If the query results are displayed graphically, this command allows you to select a file to save the PostScript representation.CautionAs you experiment with queries in tree views, you may be tempted to look at a coding project that includes millions of lines of code. If so, be sure to use restricted queries or to use the Results Filter to greatly filter the results of the query. If you use a very comprehensive query such as "List All Functions," the Static Analyzer may be locked into creating a tree view that consists of hundreds of thousands of nodes and even more arcs, something akin to drawing a map of the United States with detail enough to show every driveway of every house in the country! Not only will you have to wait hours for your results, but the results will probably be so complicated that they'll be meaningless to you.ID="ch0225"And with that warning, you're left to your own experimentation. For more details on individual Static Analyzer features, see IDREF="22684" TYPE="TITLE"Chapter 3 through IDREF="98379" TYPE="TITLE"Chapter 6.LBL="3"ID="32461"Static Analyzer: Creating a Fileset and GeID="71197"nerating a DatabaseID="ch031"Before you can perform any static analysis queries, you need to specify the source code files to be analyzed in a file called a fileset and then generate a database containing the static analysis information. This chapter covers these topics:IDREF="34371" TYPE="TITLE""Fileset Specifications"IDREF="89415" TYPE="TITLE""Using the Fileset Editor"IDREF="10605" TYPE="TITLE""Creating a Fileset Manually"IDREF="46873" TYPE="TITLE""Using Command-Line Options to Create and Use a Fileset"IDREF="34073" TYPE="TITLE""Generating a Static Analyzer Database"IDREF="41450" TYPE="TITLE""Rescanning the Fileset"IDREF="12658" TYPE="TITLE""Search Path for Included Files"IDREF="14993" TYPE="TITLE""Changing to a New Fileset and Working Directory"NoteThe features described in this chapter that apply to Ada are only available if you have purchased the ProDev Ada package.LBL="" HELPID=""ID="34371"Fileset SpecificationsID="ch032"A Static Analyzer 
fileset is a single file used to specify the source code files to be analyzed. There are five methods for creating a fileset:using the Fileset Editorcreating a file manuallyletting cvstatic do it automatically at startup by defaulting to those files in the current directory that match the expression *.[cCfF] letting cvstatic do it automatically at startup by designating an executableusing the compiler to create a fileset (and database) by adding the -sa,<dbdirectory> option to your makefileA fileset is a regular ASCII file with a format of one entry per line, each line separated from the next by a carriage return. The first line of a fileset is always-cvstaticThe other entries can beregular expressionsfilenamesincluded directories preceded by the designator -INoteIn parser mode only, an entry can be followed by the name of the compile driver, compilation options such as -ansi, and other user-specified options such as -D for defining macros (see IDREF="60270" TYPE="TITLE""Parser Mode").LBL="" HELPID=""Using Regular ExpressionsEach line in the fileset can use shell expansion characters, a wild card system in standard use for specifying filenames in UNIX shells. If you enter a standard pathname (either absolute or relative), the Static Analyzer reads the line literally and looks for the file. If you use metacharacters such as brackets ([]) and asterisks (*), you can specify a number of files with a single line of text. For example, the default fileset contains the single line:ID="ch033"ID="ch034"*.[cCfF]The asterisk specifies any number of characters (zero or greater) before a period, and the bracketed set of characters specifies any of four single charactersname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'c, C, f, or Fname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'after the period. The result is that the line specifies any filenames in the current directory that use a .c, .C, .f, or .F extension.If you are analyzing Ada files, then the default expression *.[cCfF] is not appropriate. You may wish to substitute an expression like *.adb.NoteDon't confuse the shell expansion characters used here with the regular expressions used in the Fileset Selection Browser; they're completely different systems. If you want full information about shell expansion characters, you'll find them described in the reference (man) pages for ID="ch035"csh.LBL="" HELPID=""Specifying PathnamesThe Static Analyzer resolves absolute pathnames in the fileset from the root; it resolves relative pathnames from the directory in which you invoke the Static Analyzer, referred to as the
 browsing directory. Anytime you change to a fileset in another directory, however, the Static Analyzer changes the working directory to match so that any relative filenames in the fileset are resolved from the fileset's own directory.ID="ch036"LBL="" HELPID=""Specifying Included FilesBesides specifying filenames, the fileset also can also specify directories to search for included files. The default search files are the current directory and ID="ch037"/usr/include. Any additional search paths are specified with the prefix -I followed immediately (without space) by the pathname. For example, the pathname-I/usr/include/gllisted in a fileset asks the Static Analyzer to search through /usr/include/gl for include files. Filesets created by the Static Analyzer are named ID="ch038"cvstatic.fileset by default. If you create your own filesets, you can give them any name you wish, but by convention you should use the .fileset extension.LBL="" HELPID=""ID="82331"Defining Symbols in the FilesetThe Static Analyzer lets you define macros to be included in the database. When you compile with the -sa flag, the fileset is built with one file per line; lines may also contain a -I flag for including files, -D for defining macros, or -U for undefining macros. The Static Analyzer doesn't normally preprocess source code files before creating a cross-reference database. Some source code, however, requires preprocessing to resolve ifdef statements before you can successfully analyze the code. The way to perform preprocessing is to specify these symbol names and values in the file cvstatic.fileset and then run cvstatic from the command line with the -preprocess flag. The macros are specified at the end of the fileset by appending a line of the form-D<symbolname> or-D<symbolname>=<value>for each preprocessor symbol you want to define. For example, to set the macros DEBUG and BUFFERSIZE, you would append two lines like this to the end of the fileset:-DDEBUG
-DBUFFERSIZE=8 In like manner, -U undefines macros. These symbol definitions are used for processing all of the files in the fileset.NoteUsing the -preprocess option increases the scanning time tremendously (scanner mode only). Use it only when absolutely necessary, and consider analyzing the code as is, including all the ifdefed sections.LBL="" HELPID=""Using the Default FilesetID="ch039"When you start the Static Analyzer in a directory that doesn't contain a file named cvstatic.fileset, the Static Analyzer creates a default fileset and saves it as ID="ch0310"cvstatic.fileset. The contents of the fileset are:*.[cCfF]This line specifies any C, C++, or Fortran files in the working directory. Note that the line assumes that C++ files have a ID="ch0311".C extension, which may not be the case for all C++ files because there isn't yet a pervasive extension standard. If your C++ files use .c++, .cc, or other extensions and you want to use the default fileset, you should edit it to include the extensions you want.LBL="" HELPID="FilesetEditor"ID="89415"Using the Fileset EditorThe Fileset Editor window (see ID="ch0312"IDREF="15611" TYPE="GRAPHIC"Figure 3-1) lets you edit the contents of a fileset. You invoke it by choosing "Edit Fileset..." from the Admin menu. The contents of the current fileset appear in the two file lists on the right side of the window; directories and files that you can add to the fileset appear in the ID="ch0313"Directories and Files lists on the left.The Current FilesetID="ch0314" field at the top right of the window is a read-only display that shows the full pathname of the current fileset. The directory displayed here is the Static Analyzer's current working directory. You can't change either the fileset or the working directory here; to do so, use the "Change Fileset..." selection in the Admin menu.ID="ch0315"ID="ch0316"Below the Current Fileset field, there are two list areas. A fileset can contain two kinds of files: those that are scanned into and those that are parsed into the database. (For a complete discussion of scanner and parser mode, see IDREF="34073" TYPE="TITLE""Generating a Static Analyzer Database.") The top list area shows the files in the fileset to be parsed, and the lower one shows the files to be scanned. Both list areas have vertical scroll bars to scroll through long lists and horizontal scroll bars to move left and right through long filenames.To see an example of the Fileset Editor, refer to IDREF="90197" TYPE="TITLE""Tutorial 1: Applying the Static Analyzer to Scanned Files."FILE="ch033.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-1"Figure 3-1 ID="15611"The Fileset Editor WindowLBL="" HELPID="FilesetEditorDirectEntry"Adding Lines to the Fileset Contents ListBoth fileset list areas have direct entry fields immediately below them that allow you to enter lines in the fileset. You put the pointer in the line entry field and type. When you press 
<Enter>, the Fileset Editor enters your line in the fileset.The line entry field interprets each typed line as soon as you press 
<Enter>. If you enter a literal filename such as jello.c or ../bounce/bounce.C, that filename appears in the fileset list when you press 
<Enter>. If you enter a wild card entry such as ID="ch0317"*.*, the Fileset Editor interprets it, resolving from the working directory, and places those filenames that match (not the wild card entry itself) in the fileset list.If you want to enter a wild card entry in the fileset without having it immediately interpreted and replaced with actual filenames, turn on the ID="ch0318"Literal Input toggle button just below the line entry area. When this button is on, the Fileset Editor treats any strings you enter literally; it does not interpret them as shell expansion characters, which allows you to place wild card lines directly into the fileset. The Static Analyzer interprets these strings later when you query the fileset.LBL="" HELPID="FilesetEditorLineRemoval"Removing Lines From the Fileset ListsID="ch0319"To remove a line from a fileset list, click to select it and then click the Remove button below the lists. The Fileset Editor removes the line from the list. To remove more than one line at a time, drag the cursor over a range of files or hold down the 
<Control> while clicking, then click the Remove button.LBL="" HELPID=""Browsing for Fileset ContentsID="ch0320"You can use the lists and buttons on the left side of the Fileset Editor window to browse through available directories for files to add to the fileset. LBL="" HELPID="FilesetEditorDirList"Directories ListThe DirectoriesID="ch0321" list shows the subdirectories available in the current directory; double-click a subdirectory to move to that directory and see its subdirectories in the Directories list. The ".." entry is the parent directory of the current directory; double-click it to move up a directory.LBL="" HELPID="FilesetEditorBrowseDir"Browsing DirectoryThe ID="ch0322"Browsing Directory field just above the Directories list shows the current directory in which you're browsing. You can use it to type an absolute pathname to a new directoryname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'put the pointer in the area to type. When you press 
<Enter>, the contents of the Directories list change to show the subdirectories of the directory you entered.LBL="" HELPID="FilesetEditorLangFilters"Language FiltersThe FilesID="ch0323" list below the Directories list shows the files contained in the current directory. You can filter the contents you see there by turning on any or all of the three filter buttons below the list: the ID="ch0324"C button, the C++ button, or the Fortran button. If none of these buttons is turned on, the Files list shows all files in the current directory. Turning on any single button restricts files listed to Ada, C, C++, or Fortran files:The C button restricts files shown to those with .c extensions.The C++ button restricts files shown to those with .C, .cc, or .cxx extensions.The Fortran button restricts files shown to those with .f or .F extensions.The Ada button restricts files shown to those with .adb, .ali, .atb, .ads, and .ats extensions (with ProDev Ada package only).You can set combinations of these buttons to see different source code file types.LBL="" HELPID="FilesetEditorMoveFiles"Adding Filenames From ListsIf you wish to add one or more filenames from the Files list to one of the fileset lists, select the filename and click the ID="ch0325"Move FilesParser button or Scanner button to the right of the Files list depending on how you want information extracted from the file. The Fileset Editor puts the absolute pathname of each file in the fileset list.To add all the files in a directory to the Fileset Contents list, click the directory name (or directory names if you want more than one) in the Directories list, then click either the Parser button or Scanner button to the right of the Directories list. The Fileset Editor (in its default state) adds only the files contained in that directory, and not files contained within any of its subdirectories.To add files contained within a directory's subdirectories, turn on the Include Subdirectories button. When you click the Add Directories button with this button turned on, the Fileset Editor adds all files in directories, subdirectories, and so on, to the fileset lists.You can specify the kinds of files the Fileset Editor puts in the Parser Fileset and Scanner Fileset lists when you click the Add Directories button. To do so, turn on any of the filter buttons below the Files list.LBL="" HELPID="FilesetEditorXferFiles"Transferring Files in the Fileset Between ModesThe Fileset Editor lets you change the method of data extraction (parser or scanner) for files in the fileset. You do this by transferring them from one fileset list to the other using the two Transfer Files arrows. This is particularly useful when you discover that a file cannot be parsed, as first thought; you then transfer it to the scanner mode, which is not sensitive to programming languages.LBL="" HELPID="FilesetEditorControls"Leaving the Fileset Editor WindowYou can close the Fileset Editor window by clicking the OK button or the Cancel button. Click OK to put all the fileset changes you made into effect. Click Cancel to close the window and return the fileset to the state it was in when you first opened the Fileset Editor. Your editing changes are ignored.LBL="" HELPID=""ID="10605"Creating a Fileset Manually ID="ch0326"You can create a fileset by hand if you wish, either by using a text editor that saves text in a text-only format (vi, for example), or by using the output of UNIX commands that return filenames. You may find the UNIX ID="ch0327"find command particularly useful for returning all specified filenames within a directory tree. For example, the commandfind . -name "*.f" -print > cvstatic.filesetcreates a fileset of all Fortran files (those with a .f extension) found within the current directory and all of its subdirectories. Note that all the pathnames in the fileset are relative, determined from the current directory.You can pipe the output of the find command through filtering commands such as sed to further modify the fileset created. For example, the commandfind . -name "*.c" -print | sed'/\.\.c/d > cvstatic.filesetfinds C files within a directory tree and strips out any .c files left by the C++ compiler.LBL="" HELPID=""ID="46873"Using Command-Line Options to Create and Use a FilesetID="ch0328"The Static Analyzer provides three special options when you invoke ID="ch0329"cvstatic from the command line:ID="ch0330"The -executableID="ch0331" option followed by the filename of an executable file asks the Static Analyzer to create a fileset that contains the absolute pathname of every file used to compile that executable. For example, enteringID="ch0332"cvstatic -executable jellowhile in the /usr/demos/CASEVision/jello directory starts the Static Analyzer and creates a fileset that includes all the files used to compile jello.Note that the executable must not be stripped; stripped files do not contain the names of their source files. When using the -executable option, it's a good idea to use the fileset editor to exclude files with "incomplete" names (which can occur with files compiled into lib using compilers prior to 4.0.1 or non-supported languages like assembler or Pascal). The -executable option requires that the executable be built on the same system performing the static analysis. Note also that this command-line option works only if you have the C, C++, or Fortran compiler that's shipped with IRIX‘ version 4.0.1 or greater.TheID="ch0333" -ID="ch0334"filesetoption followed by the filename of a fileset asks the Static Analyzer to start using a fileset other than cvstatic.fileset.The -mode flag takes the options SCANNER or COMPILER to indicate the type(s) of files in the fileset to be used in queries. If you do not use the -mode flag, then scanner will be assumed for those files in the fileset without compiler driver specifications (see IDREF="17673" TYPE="TITLE""Preparing the Fileset for Parser Mode"). LBL="" HELPID=""ID="34073"Generating a Static Analyzer DatabaseThe most time-consuming part of the static analysis process is creating the database, which is a collection of symbols and their relationships. There are two methods for extracting static analysis data from a fileset:scanner mode, which is fast but not sensitive to the characteristics of specific programming languagesparser mode, which is language-specific and thus more thoroughIf you need a mix of accuracy and speed, you can combine the two modes by flagging the files in the fileset according to mode and building the database with the -mode BOTH flag. You might use this approach if some files cannot be compiled or if scanner mode is misinterpreting necessary symbols.LBL="" HELPID="ScannerMode"ID="89873"Scanner ModeThe quickest way to build a database is to use scanner mode. Since scanner mode is not sensitive to the characteristics of specific programming languages, it may miss or incorrectly parse certain symbols (especially in Fortran). If you are analyzing a large quantity of source code, do not care about minor inaccuracies, and do not need the language-specific relationships (such as C types) available in parser mode, then use scanner mode. ID="ch0335"Scanner mode is the default method for building a static analysis database. It is run automatically whenever you create a new fileset or perform a rescan, unless you explicitly specify parser mode.Scanner mode creates files named cvstatic.fileset, cvstatic.index, cvstatic.posting, and cvstatic.xref in the directory in which it is started. These files comprise the Static Analyzer database for the program.If the Static Analyzer finds cross-reference files to accompany a fileset, it determines when they were last updated. It then scans the fileset to see which files which have been modified or added since that date. The Static Analyzer updates the cross-reference files with cross-references found in modified or added files.ID="ch0336"Scanner mode is based on a sophisticated pattern matcher. It works by searching for and identifying common patterns that occur in programs. Both philosophically, and in terms of the actual implementation, cvstatic is most closely related to the program grep. If you expect cvstatic to produce the type of results that can be accomplished only with a full-compilation type of analysis, you should use the compiler-based parser mode. If you approach scanner mode as a "super-grep," using it as most programmers currently use grep (or various "tags" packages) to explore a new program, you can quickly get a quick high-level look at your code.LBL="" HELPID="ParserMode"ID="60270"Parser ModeParser mode is language-specific and slower as a result. Use parser mode when you need to stress accuracy over speed. Parser mode provides relationship data specific to the programming languages C, Fortran, and C++, such as querying on types, directories, and Fortran common blocks. Parser mode uses the compiler to identify entities in the source code, so you must be able to compile a file in order for it to be parsed. If a source file cannot compile, then you need to flag that file for scanning and run it through scanner mode. ID="ch0337"NoteThe database generated by parser mode can also be used by the C++ Browser (it must be purchased separately).LBL="" HELPID=""ID="17673"Preparing the Fileset for Parser ModeFile entries for parser mode take the general form/fullpath/sourcefile drivername optionswheredrivernamerefers to the compiler driver and can be "f77" for Fortran, "ncc" for the Edison C compiler, "NCC" for the standard C++ compiler, or "DCC" for the Delta C++ compiler.optionslets you choose language level (-ansi, -cckr, -xansi, or -ansiposix) and user-specified options such as -I for including files, -D for defining macros, -nostd, and +p. See the man page for cc for more information.The Static Analyzer recognizes the type of language by the file extension. ".c" extension is considered to be C. ".C" and ".cxx" are considered to be C++ files. Parser mode assumes that C files are ANSI unless otherwise specified in the makefile.Before processing the files, the Static Analyzer must know where to look for include files. If you are using parser mode, you need to set the include paths before the Static Analyzer scans the files, so do this before performing any queries or selecting "Force Scan."LBL="" HELPID=""Invoking the ParserThere are three methods for creating a fileset with parser mode files:Enter the files in the parser mode fileset list in the Fileset Editor.Edit the cvstatic.fileset file directly, specifying the compiler and other options after the file entry.Use the compiler to generate the fileset by specifying the flag -sa[,databasedirectory] and -nocode. Without arguments, the -sa flag stores the static analysis database in the current directory. If you enter a comma (,) and a directory, the static analysis database will be stored in the specified directory. If you specify the flag -nocode, then the database will be built without creating new object files.While the database is being built, a window appears, displaying any messages from the parsing process. This helps you find problems if there is code that cannot compile.Parser mode creates a cvstatic.fileset file and some new files named cvdb*.dat, cvdb*.key, vista.taf, and cvdb.dbd in the current directory. In parser mode, "Force Scan" rebuilds the database. "Rescan" looks at the time stamps of files in the database and rebuilds pieces only when they are out of date. For more information on creating a database in parser mode, see IDREF="22770" TYPE="TITLE""Tutorial 3: Using the Compiler to Create a Static Analysis Database."LBL="" HELPID=""Parser Mode ShortcutsIf you want to use parser mode but wish to avoid waiting for the process to finish, there are two ways to speed things up:You can use the compiler with the -nocode flag to skip creating object files.You can build the Static Analyzer database using the compiler and bring up the graphic user interface later to read this database.LBL="" HELPID=""Size LimitationsThe limitations and shortcomings mentioned here are largely a consequence of the grep-like model supported by scanner mode. Still, cvstatic does provide a more powerful way to approach understanding a set of source files than using grep.When you use the Fileset Editor to add entire directories of files, you cannot enter more than 10,000 files. This limit exists to prevent someone from inadvertently starting at the root of a file system and trying to add all files. Note that there is no limitation on the number of files that can be added to the fileset when the fileset file is constructed in other ways, such as compiling source files with the -sa flag, or emitting a fileset from a Makefile rule.cvstatic displays at most 20,000 lines of unfiltered results from a query in the Text View. Larger results can, however, be saved to a file or reduced to a more manageable size using the Results Filter.cvstatic displays no more than 5,000 functions in the Call Tree View, 10,000 files in the File Dependency View, or 10,000 classes in the Class Tree View. These are absolute maximum limits, and the actual limits may be much lower depending on characteristics of the graph being displayed. In particular, all graph views in cvstatic are displayed in a scrolled X window, which is sized to accommodate the graph. X imposes a maximum size on windows that graphs cannot exceed. To get around this limitation, you canuse more specific queries to focus on the part of the program that is of the most interestreduce the scale used to view the graphuse the Results Filter to prune the results of queriesuse the Incremental Mode setting in graph views or the pop-up menus on nodes of the graph to follow a specific path through a large tree.LBL="" HELPID=""ID="41450"Rescanning the FilesetID="ch0338"After you have generated a database, you can always go back and rescan the fileset. The Admin menu provides two selections for this purpose:"Rescan"ID="ch0339" asks the Static Analyzer to check for new or modified files since the last scan and to store any cross-references found in new and modified files in the database. Use this command anytime you've modified source code files during a Static Analyzer session and you want to ensure that the Static Analyzer reflects those changes in the cross-reference files."Force Scan"ID="ch0340" asks the Static Analyzer to completely rebuild the cross-reference files, creating a cross-reference database of all files specified in the fileset, whether or not they've been modified since the last scan. "Force Scan" also returns the Static Analyzer to its initial startup state with no query results in the main window and no past queries stored in the History menu. Use this command to restart the Static Analyzer and to verify the integrity of its cross-reference files.There are also two command-line options involved with rescanning the fileset:-batchID="ch0341"asks the Static Analyzer to perform the equivalent of the "Rescan" selection; it updates the cross-reference files to accommodate new and modified files in the fileset. It doesn't open the Static Analyzer's main window, however, and it quits the Static Analyzer once the scan is finished. You can use the -batch option to update cross-reference files for a large set of source code files, using the Static Analyzer as a background process. Note that you must have a fileset in the directory where you start the Static Analyzer or that you must specify a fileset when you start the Static Analyzer, or this option won't work.-noindex ID="ch0342"asks the Static Analyzer not to create an inverted index for the cross-reference database, so it doesn't create the ID="ch0343".index and .posting files. This makes creating a cross-reference database faster than it would be without the option, but the lack of an index makes queries to the database much slower. Use this option with caution.NoteThis works in scanner mode only.ID="12658"ID="ch0344"LBL="" HELPID="FilesetEditorScanOptions"Search Path for Included FilesID="ch0345"Whenever the Static Analyzer scans a fileset and finds an included file in source code, it searches by default for the file in the current directory and then in /usr/include. If it doesn't find the included file in either of these directories, it posts a Not Found dialog box that shows the names of those included files listed but not found in its search path.To add directories to the search path for included files, choose "Set Include Path and Flags" from the Admin menu to open the Scanning Options dialog box shown in ID="ch0346"IDREF="36585" TYPE="GRAPHIC"Figure 3-2.The Include Directories list at the top of the box lists all directories that the Static Analyzer searches in addition to the default search path. To add a directory to the list, move the pointer to the Directory field below the list, type in a directory name, then press 
<Enter> (or click the Add Directory button). The path should be relative to the directory in which cvstatic is running. To delete a directory, click its name in the Include Directories list (this puts it in the Directories field), then click the Remove Directory button. You can also add flags such as -I for including files, -D for defining macros, or -U for undefining macros, as described in IDREF="82331" TYPE="TITLE""Defining Symbols in the Fileset".FILE="f14incld.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-2"Figure 3-2 ID="36585"The Scanning Options Dialog BoxTo exclude /usr/include from the Static Analyzer's search path, click the No Standard Includes button to turn on the option. Turn on this option whenever you don't want to scan standard libraries and headers into a .xref file. By eliminating these files from a scan, you can greatly reduce the amount of data the Static Analyzer handles, increase its speed, and concentrate query results on your custom code. (Note, however, that you won't be able to find data in the header files normally found in /usr/include.)To close the Scanning Options dialog box, click the Close button. Note that any directories you added to the search path are stored as part of the fileset. You won't see the directories listed if you open the Fileset Editor, but you will see them if you examine the fileset file directly; each added search directory appears in a separate line with a -I prefix.LBL="" HELPID="FilesetBrowser"Changing to a New Fileset and Working ID="14993"DirectoryThe Static Analyzer uses only one fileset at a time, and resolves each relative pathname and general line from its current working directory. To change to a new fileset or a new working directory, use the Fileset Selection Browser window shown in ID="ch0347"IDREF="48076" TYPE="GRAPHIC"Figure 3-3 by choosing "Change Fileset..." from the Admin menu.ID="ch0348"FILE="f14fselc.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-3"Figure 3-3 ID="48076"The Fileset Selection Browser WindowTo load a new fileset, change to the directory in which it's located using the File Selection field (either by dragging a folder icon into it or by typing directly), then select the fileset in the Files list. Once you change to a new fileset, the directory where it's located becomes the new working directory.You can use the File Selection field of the Fileset Selection Browser window to create a new fileset from within the Static Analyzer. If you enter a new filename such as custom.fileset in the File Selection field (as part of a full pathname) and then click OK to accept your new fileset, the Static Analyzer creates a file by that name and saves any fileset edits you make to that file.LBL="4"ID="24882"Static Analyzer: QueriesThis chapter covers queries, which ask the Static Analyzer for specific information about the source code files included in the fileset. You'll find these topics here:ID="ch041"ID="ch042"IDREF="15412" TYPE="TITLE""Defining the Scope of a Query"IDREF="32019" TYPE="TITLE""Making a Query"IDREF="41313" TYPE="TITLE""Viewing Source Code"IDREF="29547" TYPE="TITLE""Repeating Recent Queries"IDREF="42333" TYPE="TITLE""Saving Query Results"For examples of using queries, refer to IDREF="90197" TYPE="TITLE""Tutorial 1: Applying the Static Analyzer to Scanned Files" and IDREF="48858" TYPE="TITLE""Tutorial 2: Applying the Static Analyzer to Parsed C++ Files."LBL="" HELPID=""ID="15412"Defining the Scope of a QueryID="ch043"The Static Analyzer has two types of queries: comprehensive queries, such as "List All Functions" and "List Global Symbols," that don't require a query target; and specific queries, such as "Who Is Called By?" and "List Methods In Class," that require a query target. Specific queries are grayed in the Queries menu unless you supply target text in the ID="ch044"Query Target field.To enter text in the Query Target field, put the pointer in the text area and type. You can also click an element in the query results area; the Static Analyzer pastes it into the text area. For example, you can click a function name displayed in the query results area to enter the function name in the Query Target field.To make a query based on target text, choose a query from the Queries menu. The Static Analyzer returns all elements that match the parameters of the query and the target text. You can also make a query by pressing ID="ch045"<Enter> while the pointer is in the Query Target field; the Static Analyzer repeats the last type of query you made, using the contents of the Query Target field as target text. Use this convenient keyboard shortcut to repeat a query with a new target text each timename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for example, if you're following a thread of function calls.LBL="" HELPID=""Target Text as a Regular ExpressionThe Static Analyzer reads target text in the Query Target field as a regular expression, which is a system of string constructions used by the UNIX ed command to construct literal strings or wild card strings. Regular expression syntax is described in the reference (man) pages for ed; you'll also find the same description on the Static Analyzer's Help screen for regular expressions.If you enter target text without using any regular expression special characters (which are \, ., *, (, ), [, ^, $, and +), the Static Analyzer reads the text as a literal string (without wild cards) and searches only for that text. If you use special characters to create a wild card expression, the Static Analyzer searches for a variety of target text in a single query, a useful tool for expanding the scope of a specific query.ID="ch046"ID="ch047"NoteDon't confuse regular expressions with the shell expressions you use to create a fileset. They're completely different systems. For example, the regular expression "q.*" matches strings that begin with "q," while the shell expression "q.*" matches strings that begin with "q."LBL="" HELPID="GenlOptions"Case SensitivityID="ch048"The Static Analyzer normally recognizes the difference between uppercase and lowercase characters in target text during queries. If you want to ignore case in target text during a query (useful for Fortran code, which is case-insensitive), choose "General Options" from the Admin menu to open the General Options dialog box shown in ID="ch049"ID="ch0410"IDREF="32490" TYPE="GRAPHIC"Figure 4-1. Click the "Ignore Case In Searches" button to turn it on, then click the Close button to close the dialog box. You can return to the dialog box to turn off the option when you want to recognize case in queries.FILE="f15gnopt.gif" POSITION="INLINE" SCALE="FALSE"LBL="4-1"Figure 4-1 ID="32490"The General Options Dialog BoxLBL="" HELPID=""ID="32019"Making a QueryID="ch0411"To make a query, choose a query type from the Queries menu, which organizes queries in submenus of related queries (see IDREF="73484" TYPE="GRAPHIC"Figure 4-2). The Static Analyzer shows the results in the query results area of its main window, using the view that is turned on. If the view isn't appropriate for the query (file dependency view for a function query, for example), the Static Analyzer informs you; no elements are listed in the query results area.FILE="ch0424.gif" POSITION="INLINE" SCALE="FALSE"LBL="4-2"Figure 4-2 ID="73484"Static Analyzer Queries Menu with SubmenusLBL="" HELPID="GenlQueries"General QueriesID="ch0412"FILE="f15qsub3.gif" POSITION="MARGIN" SCALE="FALSE"LBL="4-3"Figure 4-3 ID="20630"Queries Submenu: "General"The "General" submenu (see ID="ch0413"IDREF="20630" TYPE="GRAPHIC"Figure 4-3) contains a variety of general-purpose queries designed to find strings or nonspecific program elements. Several of these queries find symbols, which are programmatic tokens sent to the compilername='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'macro names, functions, variables, and other source code elements. The general queries are:"List Global Symbols"ID="ch0414"returns all global symbols it finds in the files defined by the fileset. It ignores any target text. (Global symbols are standard elements of code: functions, macros, variables, classes, and so forth.)"List All Constants"ID="ch0415"returns all constants in the source code (includes enums, named constants, and Fortran 77 parameters)."Where Symbol Used?"ID="ch0416"expects a symbol name in the Query Target field. It returns the source code locations of all references to the symbol."Where Defined?"ID="ch0417"expects a symbol name in the Query Target field. It finds all symbols that match the target text and returns the source code locations where those symbols are defined."Find String"ID="ch0418"expects a literal string in the Query Target field. It returns the source code locations of all strings that match the target text. When you use this query, you ask the Static Analyzer not to interpret the target text as a regular expression, which allows you to use regular expression special characters as part of a literal text string."Find Regular Expression"ID="ch0419"expects a general expression in the Query Target field. It returns the source code locations of all strings that match the target text.LBL="" HELPID="MacroQueries"Macro QueriesID="ch0420"FILE="f15qsub4.gif" POSITION="MARGIN" SCALE="FALSE"LBL="4-4"Figure 4-4 ID="76184"Queries Submenu: "Macros"The "Macros" submenu (see IDREF="76184" TYPE="GRAPHIC"Figure 4-4) contains queries that deal with macros:"List All Macros"ID="ch0421"returns all macros it finds in the files defined by the fileset. It ignores any target text."Where Defined?"ID="ch0422"expects a macro name in the Query Target field. It finds all the macros that match the target text and returns the source code locations where those macros are defined."Where Undefined?"ID="ch0423"expects a macro name in the Query Target field. It finds all the macros that match the target text and returns the source code locations where those macros are undefined (using #undef)."Where Used?"ID="ch0424"finds all locations where the macro entered in the Query Target field is used."List Unused Macros"ID="ch0425"lists macros defined but never used.LBL="" HELPID="VarQueries"Variable QueriesID="ch0426"The "Variables" submenu contains queries that deal with variables. In performing a variable query, you typically list variables first and then select an individual variable for further information. IDREF="36297" TYPE="GRAPHIC"Figure 4-5 shows the results of the "List All Global Variables" selection with the _lastCmd variable selected. Notice that the variable list has five columns: Name, Function, File, Line, and Source. These identify the variable, its function or <global> if no function, the file in which it is defined or declared, the line number at which it is first defined or declared, and the actual source line. FILE="f15lsvar.gif" POSITION="INLINE" SCALE="FALSE"LBL="4-5"Figure 4-5 ID="36297""List All Global Variables" Results with Variable SelectedFrom a list resulting from "List All Global Variables", you can select individual variables for specific queries. You do this by clicking the variable name. IDREF="21888" TYPE="GRAPHIC"Figure 4-6 shows the results of a "Who References?" query. FILE="ch0425.gif" POSITION="INLINE" SCALE="FALSE"LBL="4-6"Figure 4-6 ID="21888""Who References?" ResultsThe column headings are the same as for the "List All Global Variables" query results. In this case, the Line and Source fields refer to the line where the reference took place.FILE="f15qsub5.gif" POSITION="MARGIN" SCALE="FALSE"LBL="4-7"Figure 4-7 ID="65525"Queries Submenu: "Variables"The "Variables submenu" appears in IDREF="65525" TYPE="GRAPHIC"Figure 4-7 and offers these selections:"List All Global Variables"ID="ch0427"returns the global variables it finds in files defined by the fileset. It ignores any target text."Where Declared?"ID="ch0428"finds the location where the selected variable was declared."Where Defined?"ID="ch0429"finds the location(s) where the variable was defined."Who References?"ID="ch0430"expects a variable name in the Query Target field. It finds all variables that match the target text and returns all references to those variables."Who Sets?"ID="ch0431"expects a variable name in the Query Target field. It finds all variables that match the target text and returns all source code locations where the values of those variables are set."Where Address Taken"ID="ch0432"finds all locations where the address of the variable is taken."List Unused Variables"ID="ch0433"lists all variables that have been defined or declared but not otherwise used in the source code."Where Allocated"ID="ch0434"lists all locations where memory was allocated for the selected variable."Where Deallocated"ID="ch0435"lists all locations where memory was deallocated for the selected variable.LBL="" HELPID="FunctionQueries"Function QueriesID="ch0436"FILE="f15qsub6.gif" POSITION="MARGIN" SCALE="FALSE"LBL="4-8"Figure 4-8 ID="47646"Queries Submenu: "Functions"The "Functions" submenu (see IDREF="47646" TYPE="GRAPHIC"Figure 4-8)contains queries that deal with functions. It operates in similar fashion to the variable queriesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'you create a list of functions and select individual functions for detailed queries. The selections are:"List All Functions"ID="ch0437"returns all functions it finds implemented in the fileset. It ignores any target text."Where Function Declared"ID="ch0438"returns the location where the function was declared."Where Defined?"ID="ch0439"returns all source code locations where those functions are defined."Where Function Used"ID="ch0440"returns all source code locations where the function appears."Who Calls?"ID="ch0441"returns all source code locations where the function is called."Who Is Called By?"ID="ch0442"returns the names of all functions called by the selected (or entered) function, including the line number and source code where the call is made."List Undefined"ID="ch0443"returns all functions called but not implemented in the fileset (usually library functions). "List Unused Function"ID="ch0444"returns functions that were declared or defined but not otherwise used in the source code."List Local Declarations"ID="ch0445"returns all local variables and arguments in the source code and the line and source code in which the declaration is made.LBL="" HELPID="FilesQueries"Files QueriesID="ch0446"FILE="f15qsub7.gif" POSITION="MARGIN" SCALE="FALSE"LBL="4-9"Figure 4-9 ID="91295"Queries Submenu: "Files"The "Files" submenu (see IDREF="91295" TYPE="GRAPHIC"Figure 4-10) contains queries that deal with files."List All Files"ID="ch0447"returns all files included in the fileset as well as any included files specified by files within the fileset (such as header files). It ignores any target text."List All Header Files"ID="ch0448"returns all header (<filename>.h) files in the fileset."List Matching Files"ID="ch0449"expects either a filename in the Query Target field or no target text at all. If it finds target text, it returns all filenames that match the regular expression. If it finds no target text, it returns the same results as the "List All Files" query."Who Includes?"ID="ch0450"expects a filename in the Query Target field or a selected filename. It returns the names of all files that include the file(s) specified by the target text."Who is Included By?"ID="ch0451"expects a filename in the Query Target field or a selected filename. It returns the names of all files that are included by the specified file(s).LBL="" HELPID="ClassQueries"Class QueriesID="ch0452"FILE="f15qsub8.gif" POSITION="MARGIN" SCALE="FALSE"LBL="4-10"Figure 4-10 ID="92248"Queries Submenu: "Classes"The "Classes" submenu (see IDREF="92248" TYPE="GRAPHIC"Figure 4-11) contains queries that deal with C++ classes:"List All Classes" ID="ch0453"returns all classes it finds in the files defined by the fileset. It ignores any target text."Where Defined?"ID="ch0454"expects a class name in the Query Target field. It finds all classes that match the target text and returns the source code locations where those classes are defined."List Subclasses"ID="ch0455"expects a class name in the Query Target field. It returns the immediate subclasses of the classes matching the target text."List Superclasses"ID="ch0456"expects a class name in the Query Target field. It returns the immediate superclasses of the classes that match the target text."List Methods In Class"ID="ch0457"expects a class name in the Query Target field. It returns those methods defined within the classes that match the target text.LBL="" HELPID="MethodQueries"Method QueriesID="ch0458"FILE="f15qsub9.gif" POSITION="MARGIN" SCALE="FALSE"LBL="4-11"Figure 4-11 ID="66587"Queries Submenu: "Methods"The "Methods" submenu (see IDREF="66587" TYPE="GRAPHIC"Figure 4-12) contains queries that deal with C++ member functions, also called methods:"List All Methods"ID="ch0459"returns all methods in the fileset. It ignores any target text."Where Defined?"ID="ch0460"expects a method name in the Query Target field. It finds all methods that match the target text and returns all source code locations where those methods are defined."Where Declared?"ID="ch0461"expects a method in the Query Target field. It returns source code locations of all class declarations that include methods that match the target text.LBL="" HELPID="CommonBlocksQueries"Common Blocks QueriesID="ch0462"FILE="f15qsubA.gif" POSITION="MARGIN" SCALE="FALSE"LBL="4-12"Figure 4-12 ID="77361"Queries Submenu: "Common Blocks"The "Common Blocks" submenu (see IDREF="77361" TYPE="GRAPHIC"Figure 4-13) applies to Fortran source code only. It contains these selections:"List All Common Blocks"ID="ch0463"lists all common blocks in the fileset."List All Symbols in Common Block"ID="ch0464"lists all symbols used in common blocks in the fileset."Where Common Block Defined"ID="ch0465"expects a common block in the Query Target field. It finds all common blocks that match the target text and returns the source code locations where the common blocks are defined."Where Common Block Referenced"ID="ch0466"returns all source code locations where the common block appears.LBL="" HELPID="TypesQueries"Types QueriesID="ch0467"FILE="f15qsubB.gif" POSITION="MARGIN" SCALE="FALSE"LBL="4-13"Figure 4-13 ID="89579"Queries Submenu: "Types"The "Types" submenu (see IDREF="89579" TYPE="GRAPHIC"Figure 4-14) helps you get type information. It contains the following choices:"List All Types"ID="ch0468"returns all types used in the source code."Where Type Defined"ID="ch0469"expects a type in the Query Target field. It finds all types that match the target text and returns the source code locations where the types are defined."List Functions of Type"ID="ch0470"returns all functions of the given type and the source code locations where they are declared or defined."List Data of Type"ID="ch0471"returns all data declarations and definitions using the given type and the source code locations where they are declared or defined."Where Type Used"ID="ch0472"returns all source code locations where the type and functions and data items using the type appear.LBL="" HELPID="DirectoriesQueries"Directories QueriesID="ch0473"FILE="f15qsubC.gif" POSITION="MARGIN" SCALE="FALSE"LBL="4-14"Figure 4-14 ID="17386"Queries Submenu: "Directories"The "Directories" submenu (see IDREF="17386" TYPE="GRAPHIC"Figure 4-15) helps you determine the organization of the current fileset. It contains these selections:"List Directories"ID="ch0474"lists all directories in the fileset."List Files"ID="ch0475"lists all files in the fileset.LBL="" HELPID="PackagesQueries"Packages QueriesNoteThe "Packages" submenu is only available if you have purchased the ProDev Ada package.FILE="f15qsubD.gif" POSITION="INLINE" SCALE="FALSE"LBL="4-15"Figure 4-15 Queries Submenu: "Packages"The "Packages" submenu helps you get package information when you are analyzing programs written in Ada. It contains"List All Packages"lists all packages in the fileset"Which Package Defines"expects a package name in the Query Target field. It finds all package that match the target text and returns all source code locations where those packages are defined."List Functions"expects a package name in the Query Target field and returns all functions declared in the package spec and the body."List Data"expects a package name in the Query Target field and returns data declared in the package spec and body."Where Withed"expects a package name in the Query Target field and returns all packages that with the given package.LBL="" HELPID="TaggedTypesQueries"Tagged Types QueriesNoteThe "Tagged Types" submenu is only available if you have purchased the ProDev Ada package.FILE="f15qsubE.gif" POSITION="INLINE" SCALE="FALSE"LBL="4-16"Figure 4-16 Queries Submenu: "Tagged Types"The "Tagged Types" submenu"List All Tagged Types"lists all tagged types in the fileset."Where Tagged Types Defined"expects a tagged type name in the Query Target field and returns all tagged types that match the target text and returns all source code locations where those tagged types are defined."List Parent Types"lists the parent types for the tagged type entered in the Query Target field."List Derived Types"lists the derived types for the tagged type entered in the Query Target field."List Primitive Operations"lists the primitive operations for the tagged type entered in the Query Target field."List Components"lists the parent types for the tagged type entered in the Query Target field."Where Type Used"returns all declarations of functions and data of this type. as well as sites where other types derive from this one or refer to it.LBL="" HELPID="TaskTypesQueries"Task Types QueriesNoteThe "Task Types" submenu is only available if you have purchased the ProDev Ada package.FILE="f15qsubF.gif" POSITION="INLINE" SCALE="FALSE"LBL="4-17"Figure 4-17 Queries Submenu: "Directories"The "Task Types" submenu"List All Task Types"lists all task types in the fileset."Where Task Type Defined"expects a task type name in the Query Target field and returns all task types that match the target text and returns all source code locations where those task types are defined."List Entries""List Body Data"lists the data local to the body for the given task type."List Body Functions"lists all non-entry functions local to the task body."List Body Types"lists all types declared that are local to the task body."Where Type Used"lists all tasks of this type, as well as other types that derive from this type or refer to it.LBL="" HELPID=""ID="41313"Viewing Source CodeID="ch0476"When the Static Analyzer returns query results, you can look at each element's source code. To do this, double-click an element in the query results area, or single-click an element and then choose "Edit" from the Admin menu. Either of these actions opens up the Source View window as shown in ID="ch0477"IDREF="39564" TYPE="GRAPHIC"Figure 4-18.The Source View window opens the file containing the element and highlights the source line. Although the Source View window is set by default to be read only, you can edit text if you wish. If you have a configuration management tool installed, you can use the "Versioning" selection from the File menu to check out the file for editing. ID="ch0478"FILE="ch0426.gif" POSITION="INLINE" SCALE="FALSE"LBL="4-18"Figure 4-18  ID="39564"The Source View Window With Highlighted Source CodeLBL="" HELPID=""Alternate Text EditorsID="ch0479"If you prefer to view source code in a text editor other than Source View, you can choose "General Options" from the Admin menu to open the General Options dialog box, which offers the option ID="ch0480"ID="ch0481"Use Source View. Turn this option off to use the default alternate text editor, vi, whenever you double-click to see source code. To set a different alternate text editor, add the line*editorCommand: <editor>to your .XdefaultsID="ch0482" file, where <editor> is the command for the editor you wish to use. The next time you use the Static Analyzer with the Source View option turned off, the editor you specified will appear when you view source code.LBL="" HELPID="HistoryMenu"ID="29547"Repeating Recent QueriesID="ch0483"The Static Analyzer retains a list of your 15 most recent queries and presents them in the History menu. You can choose any of the queries listed in this menu to repeat the query. The Static Analyzer remembers the query type and the target text it used; it doesn't remember any view settings, such as the view type, view options, or Scope Manager settings. If you change view settings and then choose a query from the History menu to repeat the query, the Static Analyzer will return the same query results but will display them differently.ID="ch0484"LBL="" HELPID="SaveQuery"ID="42333"Saving Query ResultsID="ch0485"You can save query results by choosing "Save Query..." from the Admin menu to open the Save Query File Browser window shown in ID="ch0486"ID="ch0487"IDREF="47536" TYPE="GRAPHIC"Figure 4-19. This is the standard Save File Browser.FILE="ch0415.gif" POSITION="INLINE" SCALE="FALSE"LBL="4-19"Figure 4-19 ID="47536"The Save Query File Browser WindowTo save query results, move to a directory in which you want to make the save. To specify a directory, you can use the path navigation bar, enter a path in the text field, or drag a folder into the drop pocket. Then click the OK button to save the query results and close the Save Query File Browser window.The Static Analyzer saves the contents of the query results area to the file you named in the Browser. If you're in Text View, the Static Analyzer saves the results in text format; if you're looking at a graphical view, the graph is saved in PostScript format. It adds a heading to the text that lists query type and the target text that specified the query. It also includes field headings (such as Function, File, and so on) to match those at the top of the query results area in the main window.LBL="5"ID="25986"Static Analyzer: ViewsThis chapter discusses the different views available in the Static Analyzer to view your query results. The selections "Text View," "Call Tree View," "Class Tree View," and "File Dependency View" are available in the Static Analyzer Views menu. The "Results Filter..." selection can be accessed from the Static Analyzer Admin menu. You'll find these topics:ID="ch051"IDREF="24734" TYPE="TITLE""Text View"IDREF="36448" TYPE="TITLE""Call Tree View"IDREF="29370" TYPE="TITLE""Class Tree View"IDREF="30622" TYPE="TITLE""The Results Filter"LBL="" HELPID="TextView"ID="24734"Text ViewID="ch052"Text View is the Static Analyzer's default view. It displays the results of any query and, because it's limited to text, displays query results faster than any of the tree views.ID="ch053"Text View provides labels at the top of the query results area (as shown in ID="ch054"IDREF="60400" TYPE="GRAPHIC"Figure 5-1) that identify the query type, show the extent of Results Filter reductions (called Scoping field, discussed later in this chapter), and label the columns in the query results area. Below the labels, the Static Analyzer lists the elements returned by a query, one element per line.FILE="ch057.gif" POSITION="INLINE" SCALE="FALSE"LBL="5-1"Figure 5-1 ID="60400"Text View LabelsText View's arrangement of information within each element line depends on the query type. The left field always lists the type of element you searched for; fields to its right show the location of that element and, if applicable, the contents of the source code line where it's located. For example, Text View shows the results of a function query with the function name in the first field, the filename where the function is located in the second field, the line number of the source code line where the function is defined in the next field, and the text of the line in the last field. For class queries, Text View shows any superclasses of returned classes, and for method queries, it shows the class where each method is defined.ID="ch055"Use the horizontal and vertical scroll bars to scroll left and right to see the full contents of long lines or up and down to work through long lists of elements respectively. To see more information at one time, you can enlarge the Static Analyzer window by dragging a corner.To see the source code listing where an element occurs, you can double-click any element line to open the Source View window. It displays the selected element in the middle of the window, surrounded by adjacent code.ID="ch056"LBL="" HELPID=""Viewing Full Pathnames for FilesID="ch057"Text View normally shows filenames in the query results area as short base names. If you want to see the directory as well as the filename (or at least as full a pathname as the Static Analyzer can find), turn on the Full Pathnames option: Choose "General Options" from the Admin menu to open the General Options dialog box shown in ID="ch058"ID="ch059"IDREF="47648" TYPE="GRAPHIC"Figure 5-2, then click the Full Pathnames button to turn on the option. Click the Close button to close the dialog box.FILE="ch053.gif" POSITION="INLINE" SCALE="FALSE"LBL="5-2"Figure 5-2 ID="47648"The General Options Dialog BoxTo return to base filenames, reopen the General Options dialog box and turn off the Full Pathnames option.LBL="" HELPID=""Sorting Elements in Text ViewID="ch0510"The Static Analyzer normally presents elements in the order in which they appear within each file of the fileset. To sort the elements in alphanumerical order by a single field, click the field you want within any element line, then choose "Sort" from the Admin menu. The Static Analyzer sorts the elements in ascending order by that field.ID="ch0511"LBL="" HELPID="CallTreeView"ID="36448"Call Tree ViewID="ch0512"Call Tree View is designed to display functions and the static calls between them in a graphic tree form. Because it's intended for functions, it shows results only for function queries, not for other types of queries such as file and class queries. A line of text above the query results area identifies the last type of query made and shows the extent of Scope Manager reductions.To use Call Tree View (shown in ID="ch0513"IDREF="96241" TYPE="GRAPHIC"Figure 5-3), choose "Call Tree View" from the Views menu. It presents each function in the query results area as a node, a small movable box labeled with the function name, and each function call as an arc, an arrow drawn from the calling function to the called function. Because the function relationships are presented in a tree structure, higher-level functions normally appear on the left side of the window. They call lower-level functions located farther to the right.ID="ch0514"ID="ch0515"ID="ch0516"FILE="ch058.gif" POSITION="INLINE" SCALE="FALSE"LBL="5-3"Figure 5-3 ID="96241"Call Tree View Displaying Functions and Function Calls as Nodes and Connecting ArcsLBL="" HELPID="GraphControlPanel"The Static Analyzer Graph Control PanelID="ch0517"The Static Analyzer graph view control panel (shown in IDREF="98420" TYPE="GRAPHIC"Figure 5-4) below the query results area offers a set of controls that you can use to change the view. They help you see query results in the form most useful to you. FILE="ch059.gif" POSITION="INLINE" SCALE="FALSE"LBL="5-4"Figure 5-4 ID="98420"The View Control PanelTo change the scale of the call tree in the query results area to see more or less of the tree at one time, use the zoom controls: the ID="ch0518"Zoom menu and the ID="ch0519"Zoom In and Zoom OutID="ch0520" buttons. If the tree you're viewing doesn't fit entirely within the boundaries of the query results area, you can view other parts of the tree by using the scroll bars or clicking the OverviewID="ch0521" button and navigating in the Overview window. By default, Call Tree View shows only a single arc between two functions, even if the calling function calls more than once. To see multiple calls between functions in the call tree, click the ID="ch0522"Multiple Arcs button. After maneuvering nodes, you can return them to their default positions by clicking the ID="ch0523"Realign button. The Static Analyzer's default tree orientation is horizontal; the tree grows from left to right. To see vertical tree orientation, that is, top-down (or to toggle back to horizontal), click the RotateID="ch0524" button.Call Tree View allows you to directly manipulate nodes and arcs in the query results area. You can hide, reveal, and rearrange nodes, and you can select a node or an arc to view either a function or a function call in the Source View window.For more information on the graph controls and node/arc manipulation, see IDREF="95481" BOOK="007-2582-002" FILE="appa.doc" HDG=""Appendix A, "Using Graphical Views," in the ProDev WorkShop Overview.LBL="" HELPID="ViewOptionsMenu"Setting View OptionsID="ch0525"FILE="f16optmn.gif" POSITION="MARGIN" SCALE="FALSE"LBL="5-5"Figure 5-5 ID="48297"View Options MenuThe View Options menu (at the lower right of the Call Tree View window) has four view selections that change the number of nodes you see in the query results area and change the way query results are cleared between queries (see ID="ch0526"ID="ch0527"IDREF="48297" TYPE="GRAPHIC"Figure 5-5). To open the menu, move the pointer over it and hold the left mouse button down. Drag up or down to the selection you want, then release the button. The selections are:"Query Only"ID="ch0528"is the default selection. Only the target and results of each query appear in the query results area. Each time you make a new query, the results of the old query are cleared before the new results appear."Incremental Mode"ID="ch0529"is useful for following a chain of function calls. In incremental mode, the Static Analyzer doesn't erase the results of the previous query from the query results area. It adds the results of the latest query to the nodes and arcs already on the screen, so you can incrementally build a tree as you follow function calls. The Static Analyzer shows the target and the results of the latest query in target and result colors. It shows all other nodes in the non-query color so that you can see which nodes were returned by the query and which nodes were there before the query.ID="ch0530""All Defined"ID="ch0531"shows at all times a complete tree of all functions defined (that is, implemented) within the fileset. When you make a function query, the Static Analyzer shows the query target and result nodes in target and result colors. All other nodes appear in the non-query color, so that the query results stand out as a subtree within the overall function tree."Complete Tree"ID="ch0532"shows a complete tree at all times of all the functions known within the fileset, whether they're defined or not. This includes all the defined functions shown in "All Defined" and adds any functions called but not defined. Because these include calls to external libraries, even a small program can generate a huge complete tree. The "Complete Tree" selection, like the "All Defined" option, shows the results of any queries you make by highlighting in target and result colors, leaving all other nodes in non-query colors.CautionThe Complete Tree selection can easily create unmanageably large trees for even small programs, so use it with care.LBL="" HELPID=""Viewing Function Definitions and Calls in Source ViewID="ch0533"To view a function definition in Call Tree View, either select the function's node and choose "Edit Selected Item" from the Admin menu, or double-click the function's node. The Source View window opens with the beginning of the function definition highlighted amid surrounding code.ID="ch0534"Call Tree View offers a Source View function not available in Text View: You can view a function call by double-clicking an arc that connects two functions. The Source View window shows the line of code (listed within the calling function) that calls the called function. You can get the same results by selecting an arc and then choosing "Edit Selected Item" from the Admin menu.LBL="" HELPID=""Tutorial: Working in Call Tree ViewID="ch0535"This tutorial traces function calls in Call Tree View using the "Incremental Mode" and "All Defined" viewing options. It first goes from higher- to lower-level functions using queries, and then returns to higher-level functions by showing parent nodes using the Node menu.Move to the demo directory jello:cd /usr/demos/WorkShop/jelloMake sure that no fileset and cross-reference files exist in the directory, so that the Static Analyzer will create its own standard default files:rm cvstatic.*Start the Static Analyzer:cvstatic &Select "Edit Fileset" from the Admin menu and move the jello.c file into the Scanner Fileset field using the Move Files Scanner button. Click OK.This creates the fileset for this tutorial.Choose "Call Tree View" from the Views menu to put the Static Analyzer in Call Tree View.Choose "Incremental Mode" from the View Options menu on the bottom right side of the control panel to turn on the "Incremental Mode" view option.Move the pointer into the Query Target field and type main.Choose "Who Is Called By" from the "Functions" submenu of the Query menu to find the functions that main() calls.The Static Analyzer displays a node named main on the left side of the query results area, which displays in the target color for this scheme. It's connected by arcs to a set of lower-order function nodes to the right, all in the result color.Drag the vertical scroll bar of the query results area down until you see the draw_everything node, then click on it to select it.draw_everything appears in the Query Target field.Move the pointer into the Query Target field, then press 
<Enter>.The Static Analyzer repeats its last query using the new target and returns draw_everything as a target node with several result nodes to its right. The nodes from the previous queryname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'main and its other childrenname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'still appear in the query results area in non-query color.Select the result node draw_jello, move the pointer into the Query Target field, and press 
<Enter> to search for all functions called by draw_jello().The Static Analyzer returns draw_jello as a target node with result nodes to its right as shown in IDREF="57913" TYPE="GRAPHIC"Figure 5-6. The nodes from the two previous queries are still in the query results area.FILE="ch055.gif" POSITION="INLINE" SCALE="FALSE"LBL="5-6"Figure 5-6 ID="57913"Incremental Mode ExampleChoose "15%" from the Zoom menu to set scaling to 15%.The call tree reduces in size so that you can see all of the full call tree, although the function names are too small to be readable.Hold down the right mouse button over any node in the tree. The corresponding node menu displays, and the name of the function appears at the top of the menu. Using this method, you can see a large part of a tree and orient yourself by displaying the node menus (see IDREF="78695" TYPE="GRAPHIC"Figure 5-7).FILE="ch054.gif" POSITION="INLINE" SCALE="FALSE"LBL="5-7"Figure 5-7 ID="78695"Displaying Node Information at Reduced ScaleClick a node towards the top of the call tree and choose 100% from the Zoom menu.This returns you to viewing at 100% and demonstrates one technique for navigating around a large call tree. LBL="" HELPID="ClassTreeView"ID="29370"Class Tree ViewID="ch0536"Class Tree View, which you set by choosing "Class Tree View" from the Views menu, displays a class inheritance tree containing the classes found in C++ files in the fileset. It's not intended for nonclass elements, and it won't show the results of function, file, and method queries, for example.ID="ch0537"Class Tree View looks almost identical to Call Tree View. It includes a line of text above the query results area that lists the last query and the extent of Results Filter reductions; it shows elements in the query results area using nodes and arcs; it offers a control panel to change the view in the query results area. The main difference is that each node in Class Tree View represents a class instead of a function, and each arc shows inheritance instead of a function call. Class trees in horizontal orientation move from superclasses on the left to subclasses on the right.When you make class queries in Class Tree View, the Static Analyzer uses colors in the same way that it does in Call Tree View: target color to mark target nodes, results color to mark result nodes, and non-query color to mark nodes not returned by the last query. The view controls also work the same way, with one minor variation. The ID="ch0538"Multiple Arcs button has no effect because no multiple inheritances exist in a class tree.The selections in the Node and the Selected Node menus work the same way they do in Call Tree View, working through parents and children of existing nodes, but they follow class inheritance instead of a chain of function calls. Using the Source View window in Class Tree View has one minor difference: you can double-click a node to view source code for a class, but you can't double-click an arc to see an inheritance.NoteThe Browser lets you gather additional information on the structure, hierarchy, and method interactions of each C++ class in your application or library.File Dependency View, which you set by choosing "File Dependency View" from the Views menu, displays the include relationships between files in the fileset. File Dependency View is similar to Class Tree View and offers the same controls, colors, and menus. The main difference is that each node in this view represents a file in the fileset instead of a function, and each arc shows the inclusion of one file by another. An arc leads from the including file to the included file.ID="ch0539"Although File Dependency View displays only files, it can provide useful information when used in conjunction with other types of queries. For example, if File Dependency View is displayed and you select "Where Used" from the "Function" submenu, those files containing the specified function will be highlighted.File Dependency View is particularly useful when you are analyzing Ada source files; it shows you the dependency between packages. If you double-click arcs in this view, you can see where packages are imported using the with command and also definitions where packages are brought in.An include tree in horizontal orientation places including files on the left and included files on the right. If you use selections from the Node and Selected Node menus to work through parents and children of existing nodes, you follow include relationships. A child of a node is a file included by that node; a parent of the node is a file that includes that node.LBL="" HELPID="ResultsFilter"ID="30622"The Results FilterID="ch0540"The Results Filter is a view tool that works in all of the Static Analyzer's views; it filters the view to show you a subset of all the results returned by a query. The Results Filter filters only the view of query results, not the results themselves. For example, if a function query returns 18 functions and the Results Filter is set to filter out 5 of them, the query results area shows only 13 functions. The Static Analyzer, however, retains the full 18 functions returned by the query; it simply hides the 5 functions filtered by the Results Filter. If you turn off all filters in the Results Filter, you then see the full 18 functions in the query results area.ID="ch0541"When the Results Filter is set to filter, its filters remain turned on to affect the view of any future queries you make. For example, if the Results Filter is set to filter out all elements contained in header files, it does so for all queries that follow. It removes variables found in header files from a "List All Global Variables" query, and it removes header files from a "List All Files" query. You must turn off the filters if you want to see the full results of a query.ID="ch0542"The Scoping line, located just above the right corner of the query results area, tells the extent of any filtering performed by the Results Filter. It lists two numbers separated by a colon: the first is the number of elements returned after filtering, the second is the full number of elements returned by the query. For example,ID="ch0543"ID="ch0544"Scoping: 78:154tells you that 154 elements were returned by the current query, and after filtering, the Results Filter shows 78 of them in the query results area.LBL="" HELPID="ScopeFilters"Setting Results FiltersTo open the Results Filter window shown in IDREF="24700" TYPE="GRAPHIC"Figure 5-8, choose "Results Filter" from the Admin menu.ID="ch0545"FILE="f16rsflt.gif" POSITION="INLINE" SCALE="FALSE"LBL="5-8"Figure 5-8 ID="24700"The Results Filter WindowThe Results Filter has seven different scope filters. The first five filters provide fields in which you can enter regular expressions, which allow you to specify a literal string of characters or a wild card expression that matches a set of strings. The last two filters require specific files and functions. The filters are:ID="ch0546"ID="ch0547"NameID="ch0548"filters by the Name field in Text View. The Name field can list variables for a variable query, target functions for a function query, or other parts of elements, depending on the query type.FunctionID="ch0549"filters by the Function field in Text View. This field can list functions called by a target function, functions that define local variables, and other types of functions, depending on the query type. FileID="ch0550"filters by the File field in Text View. This field can exclude elements contained in specified files or show only elements contained in specified files.SourceID="ch0551"filters by the Source field in Text View. This field can exclude or constrain elements according to strings contained in lines of source code.DirectoryID="ch0552" filters by the Directory field in Text View. This field can exclude elements contained in specified directories or show only elements contained in specified directories.HeadersID="ch0553"filters according to whether elements are contained in a header file or not.External FunctionsID="ch0554"filters according to whether elements are contained in externally defined functions or not.Although the first five scope filters work using fields in Text View, their results are the same in tree views such as Call Tree View. They sort by invisible criteria in these views. For example, you can sort with the Source scope filter in Call Tree View, even though Call Tree View doesn't show the Source field for each function it displays.LBL="" HELPID=""Filtering by Name, Function, File, and SourceID="ch0555"To filter using the first five scope filters, enter a regular expression in the appropriate text area, and then click on either the ID="ch0556"Constrain or ExcludeID="ch0557" button following the text area. Constrain filters elements so that only those that match the regular expression in the appropriate field are displayed in the query results area. Exclude filters elements so that elements that match the regular expression in the appropriate field aren't displayed in the query results. For example, if you enter jello.c in the File scope filter and click the Constrain button, the Static Analyzer displays only elements found in the file jello.c.To turn off filtering by any one of these five filters, delete all text from its text area.LBL="" HELPID="HeaderFilesandExternalFunctionsFilters"Filtering by Header Files and External FunctionsThe Headers scope filter allows three ID="ch0558"options:Includedisplays elements found in header files in addition to elements found in other files.Constraindisplays only elements found in header files.Excludedisplays only elements not found in header files.The External Functions scope filter also allows three options:Includedisplays elements found in externally defined functions (functions defined in files outside of the fileset) in addition to elements found in internally defined files.Constraindisplays only elements found in externally defined functions.Excludedisplays only elements not found in externally defined functions.To turn off filtering by either of these two filters, click their Include button.LBL="" HELPID=""Combining Results FiltersID="ch0559"You can use results filters singly or in combination to limit the elements you see to a very specific subset of the query results. For example, you can set the File filter to show only elements found in the file jello.c. You can then further refine the filtering by setting the Function filter to show only elements found in the function draw_everything(). The Static Analyzer combines these two filters to show only elements found in the function draw_everything(), which is contained in the file jello.c.LBL="" HELPID="ResultsFilterControls"Using the Results Filter ButtonsThe Results Filter window displays a row of four buttons across the bottom of the window:Applyapplies current scope settings to the query results area to filter out elements. The Static Analyzer automatically applies scope settings whenever you click an Include, Exclude, or Constrain button, so you don't usually need to click the Apply button.Clearclears text from all text fields and returns the bottom two filters to the Include setting. Click on Clear whenever you want to turn off filtering by the Results Filter.Closecloses the Results Filter window.Helpopens the Help window, where you can find information about the Results Filter window.LBL="" HELPID=""Tutorial: Using the Results FilterID="ch0560"This tutorial uses the Results Filter to view, in Text View, selected methods in a fileset of C++ files. It first filters the methods by file and then filters them further by a string found within each method's source code line.Move to the demo directory bounce:cd /usr/demos/WorkShop/bounceMake sure that no fileset and cross-reference files exist in the directory so that the Static Analyzer will create its own standard default files:rm cvstatic.*Start the Static Analyzer:cvstatic &Use the Fileset Editor to create a fileset for bounce. If you need help, refer to IDREF="90197" TYPE="TITLE""Tutorial 1: Applying the Static Analyzer to Scanned Files"Choose "List All Methods" from the Methods submenu of the Queries menu.The Static Analyzer displays all methods found in the fileset. It uses Text View. The Scoping field reads 196:196, which means that all 196 elements returned by the query are displayed in the query results area. Your version of bounce may be slightly different. Choose "Results Filter" from the Admin menu to open the Results Filter window. When it appears, drag it from on top of the Static Analyzer window so that you can see the query results area.Move the pointer to the File field in the Results Filter window, type Application.h and click the Apply button.The Static Analyzer shows only the methods found in the file Application.h. The Scoping field shows 16:196, which means that you see only 16 elements of the 196 returned by the current query.Move the pointer to the Source field, type virtual, and click the Apply button.The Static Analyzer further filters the view as shown in IDREF="36706" TYPE="GRAPHIC"Figure 5-9, showing only the methods found in the file Application.h, which include the string "virtual" in their source code line. The Scoping field shows 5:196.Click the Clear button.The Static Analyzer clears all text fields and turns off all Results Filter filtering. All elements of the recent query return to the query results area, and the Scoping field shows 196:196.Click the Close button to close the Results Filter window.FILE="f16rsfl2.gif" POSITION="INLINE" SCALE="FALSE"LBL="5-9"Figure 5-9 ID="36706"The Results Filter Query ResultsID="98379"LBL="6"ID="27911"Static AID="84250"nalyzer: Working on Large Programming ProjectsThe Static Analyzer is a flexible tool. It works on uncompilable code, analyzes filesets containing files from completely different programs, and presents query results in a graphic form that's easy to browse through. This same flexibility can bring unproductive results, however, if you use the Static Analyzer carelessly on hundreds of thousands (or millions) of lines of code that are typical of a large programming project. You must narrow your analysis to a meaningful portion of your project, or you may commit the Static Analyzer to spend hours to return results so extensive that they have little meaning.ID="ch061"This chapter recommends techniques to help you get the best results when using the Static Analyzer for large programming projects. It covers these topics:IDREF="34664" TYPE="TITLE""Creating a Fileset Using a Shell Script" to find files in separate directoriesIDREF="30536" TYPE="TITLE""Customizing the Fileset for Individual Code Modules"IDREF="40463" TYPE="TITLE""Using the Results Filter to Focus Queries"IDREF="16182" TYPE="TITLE""Applying Group Analysis Techniques"LBL="" HELPID=""ID="34664"Creating a Fileset Using a Shell ScriptID="ch062"Creating a fileset for a large programming project can be difficult to do by hand because the source code files may be scattered throughout many different directories. If so, you can use a shell script to create a fileset for you.LBL="" HELPID=""A Fileset Shell ScriptThe shell script in IDREF="11782" TYPE="TEXT"Example 6-1 is an example that you can modify that searches through a list of directories for filenames with extensions that indicate source code filesLBL="6-1"Example 6-1 ID="11782"Script for Creating Filesetsrm -f cvstatic.fileset
DIRS="/usr/local/src /usr/src "
EXTENSIONS="*.c++ *.c *.f"
for DIR in $DIRS
   for EXT in $EXTENSIONS
         do
         find ${DIRS} -name "$EXT" -print >> cvstatic.fileset
   done
doneThe first line removes the old fileset. The DIRS second line sets the search pattern; it assigns a list of directories you want searched to the variable DIRS. Put the pathname of any directory you want searched in between the quotes following DIRS, and put a space between pathnames.The third line creates a list of the file extensions for which you want to search. Use shell metacharacters to create list entries. In this example, the script looks for any filenames that end in .c++, .c, or .f. To create an extension list that looks for different extensions, use shell metacharacters to spell out the extensions you want, and put the entries between the two quotes following EXTENSIONS. Be sure to put a space between each entry.The six-line nested loop at the end of the script looks through each directory in the DIRS search path and returns any files that match the list of file extensions in EXTENSIONS. It puts the names of all returned files into the file cvstatic.fileset in a form that the Static Analyzer reads as a fileset.Once you create a fileset with a shell script, you should look at the fileset before you make any queries. If you find libraries included in the fileset, you may want to remove them so that you don't have to analyze the internal workings of each library function. You may also want to remove all files that don't apply to your specific area of the project.LBL="" HELPID=""ID="30536"Customizing the Fileset for Individual Code ModulesID="ch063"Most programming projects are organized so that the source code is organized in modules, with individual programmers taking responsibility for different sets of modules. The Static Analyzer allows you to analyze each module separately, even if the module won't compile without other parts of the system, so it's wise to bring the Static Analyzer to bear only on the modules you're working on. You can then see your own code in detail and see calls into other modules without having to view the contents of those modules. You also reduce the size of the cross-reference database with which you work, which speeds up the time the Static Analyzer takes to refresh the database and to complete queries of the database.LBL="" HELPID=""ID="40463"Using the Results Filter to Focus QueriesID="ch064"Once you create a reduced fileset, you can further improve the efficiency of your analysis by setting the Static Analyzer's Results Filter (shown in IDREF="63555" TYPE="GRAPHIC"Figure 6-1).Two settings are particularly useful for large programming projects: "Headers" and "External Functions." If you set "Headers" to ID="ch065"ID="ch066"Exclude, you prevent the Static Analyzer from taking the time to display query results that come from header files. And if you set "External Functions" to Exclude, you ensure that the Static Analyzer doesn't display query results from libraries and other non-fileset files.For example, consider the function foo(), which calls bar(), a function in the fileset. It also calls XtCreateWidget(), a library function that isn't in the fileset. If you set "External Functions" to Exclude and then make the query "Who Is Called By foo?", the Static Analyzer will display only bar().FILE="f17rsflt.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-1"Figure 6-1 ID="63555"Results FilterAlthough the Results Filter doesn't reduce the time the Static Analyzer takes to make a query, it does reduce the time it takes to display the results, a substantial gain if you're using a tree view to display the results of comprehensive queries.LBL="" HELPID=""ID="16182"Applying Group Analysis TechniquesID="ch067"Although it's good practice for individual programmers to limit the amount of source code they analyze with the Static Analyzer to just the modules for which they're responsible, sometimes it's useful to analyze all the files in the programming project. For example, library programmers may want to know every function that calls a specific library function; that way, they know what software is affected by changes they make to the library function.For this and similar cases, you should create a comprehensive cross-reference database on a project workstation as shown in ID="ch068"IDREF="17940" TYPE="GRAPHIC"Figure 6-2. This arrangement allows users on personal workstations to query the extensive project database without actually creating the database.FILE="Fig6-2snap.gif" POSITION="INLINE" SCALE="FALSE"ID="ch069"LBL="6-2"Figure 6-2 ID="17940"A Project Cross-reference DatabaseLBL="" HELPID=""Setting Up a Project DatabaseID="ch0610"To create a project cross-reference database, you first need a comprehensive fileset for the programming project. To maintain consistency, the programmer in charge of checking in files for builds should make and maintain the fileset. If the source tree uses a consistent set of directories, the build programmer can use a shell script like the example earlier in this chapter to update the fileset automatically.Once the fileset is up to date, the build programmer creates a cross-reference database. Because it can take a long time to create a cross-reference database for a large programming project, you can save time by using the ≠batch ID="ch0611"command-line option when you start the Static Analyzer. It runs the Static Analyzer in the background, keeps the Static Analyzer window from opening, and reduces the time necessary to create a cross-reference database.It may be useful to run the Static Analyzer in batch mode on the server once a night. This provides a fresh database for programmers who wish to query it from their own workstations. To protect the shared database from automatic modification by outside users, be sure that read and write permissions for all four Static Analyzer files on the servername='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'ID="ch0612"cvstatic.fileset, cvstatic.xref, cvstatic.index, ID="ch0613"ID="ch0614"and cvstatic.postingID="ch0615"ID="ch0616"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'deny write access to outside users.LBL="" HELPID=""Querying a Project DatabaseID="ch0617"To query a project database from a personal workstation, you must first mount the project database in a local directory using NFS (the Network File System). You then start the Static Analyzer using command line options to specify the project fileset and to set the Static Analyzer to read only so that it won't try to modify the project database. For example, this command starts the Static Analyzer, sets it to read-only, and directs it to the project fileset, which is NFS-mounted in the directory /project:cvstatic ID="ch0618"-readonly -fileset /project/cvstatic.filesetID="ch0619"The first command-line option, -readonly, sets the Static Analyzer so that it won't try to rebuild the project database at any time. The second command-line option, -fileset, sets the fileset to cvstatic.fileset, which is NFS-mounted in the directory /project.When you make queries on a large project database, use caution and common sense. Comprehensive queries such as "List All Functions" won't yield useful resultsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'few people find it truly useful to see every function in millions of lines of code displayed at one time. Comprehensive queries like this may also take a good deal of time to complete. You'll find it much more productive to take a task-oriented approach when querying. Ask what you really need to know in the project, then make the most specific query that answers your questions. For example, if you get a bug report on a function, you might use specific queries such as "Where Defined", "Who Calls", or "Who Is Called By" to get the information you need about that function.LBL="" HELPID=""Viewing SuggestionsID="ch0620"If you do need to make comprehensive queries on a large database, consider using Text View for your queries. Because Text View doesn't require the Static Analyzer to build a tree containing thousands of elements, it's much faster at displaying the results of a comprehensive query than any of the tree views.ID="ch0621"Text View doesn't show connections between calling and called functions in the query results area, but you can easily follow a chain of functions. First, click a function name you want, then press 
<Alt-B> to see which functions it calls, or press 
<Alt-C> to see which functions call it.Tree views show relationships between query elements more clearly than text view, so you may want to use tree views to display the results of some queries. If so, you can reduce the time the Static Analyzer needs to display tree view results by observing a few limitations.ID="ch0622"First, don't use either the "All Defined" or the "Complete Tree" view options, which display a huge set of elements in the query results area no matter how limited a query you make. Use the "Query Only" and "Incremental Mode" view options to restrict the number of elements displayed for each query.ID="ch0623"ID="ch0624"ID="ch0625"ID="ch0626"In Incremental Mode, you can build a tree from scratch by making very specific queries that identify and then follow only the branch of the tree in which you're interested. For example, you may want to follow a chain of function calls starting with ID="ch0627"main(). If so, start with the query "Who Is Called By main?". Find a function among those called that you want to follow, then query the Static Analyzer for the functions called by that function. As you continue through the call chain, the Static Analyzer displays only the branch of the call tree that applies, not the entire tree.You should also consider viewing query results in a tree view that offers coarser resolution than you normally use. For example, File Dependency View displays file elements, each of which may contain many functions. This is a much coarser view of the database than that offered by Call Tree View, which displays functions individually in function elements. If you make a query such as "Who Calls", while in File Dependency View, the Static Analyzer shows you each file that contains called functions. You can then open the Source View window for one of those files; it highlights each called function in its display area. The same query in Call Tree View would show you each called function in tree form, but would probably require many more elements to show query results and would take much longer to return results.ID="ch0628"LBL="7"ID="13468"Getting Started With the BrowserThis chapter is designed to introduce you to the Browser, a facility accessed from the Static Analyzer for performing object-oriented queries. It tells you what you need to run the Browser, shows you how to start it, and presents a brief overview of its main window and menus. To see examples of the Browser, see IDREF="89909" TYPE="TITLE"Chapter 8, "Using the Browser for C++: A Sample Session," and IDREF="65958" TYPE="TITLE"Chapter 9, "Using the Browser for Ada: A Sample Session." If you need specific reference information on any part of the Browser's user interface, see IDREF="41721" TYPE="TITLE"Chapter 10, "The Browser Reference."This chapter contains the following sections:IDREF="41492" TYPE="TITLE""Starting Browser View"IDREF="71473" TYPE="TITLE""General Characteristics of the Browser"LBL="" HELPID=""ID="41492"Starting Browser ViewAfter you have created a fileset and built a static analysis database, you are ready to make object-oriented queries using the Browser. To access the Browser, open the Admin menu in the Static Analyzer and select "Browser." The Browser View window appears, along with a chooser window called Browsing Choices, as shown in ID="ch071"IDREF="55000" TYPE="GRAPHIC"Figure 7-1. FILE="f07choos.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-1"Figure 7-1 ID="55000"Browsing Choices Dialog BoxThe Browsing Choices window lets you select an item from the fileset to be displayed in Browser View: either a class if you are using C++; or a package, task, or tagged type, if you are using Ada. The Browser View then displays detailed information on that item.LBL="" HELPID=""ID="71473"General Characteristics of the BrowserThe Browser View window shows you the internal structure and relations of the item you select in a textual, outline format. You can also select components of the item and perform queries on them. The results to queries are highlighted in Browser View and can also be displayed in the Static Analyzer. Browser View can display the contents of C++ and Ada entities. This section describes the features of the Browser common to both languages. For the language-specific characteristics, see IDREF="89909" TYPE="TITLE"Chapter 8, "Using the Browser for C++: A Sample Session," and IDREF="65958" TYPE="TITLE"Chapter 9, "Using the Browser for Ada: A Sample Session."Some features of the Browser are common to both the C++ and Ada versions. See IDREF="91891" TYPE="GRAPHIC"Figure 7-2.FILE="ch072.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-2"Figure 7-2 ID="91891"Browser View FeaturesLBL="" HELPID=""Browser View Outline ListsThe Browser displays its data in outline lists in two side-by-side panes in the Browser View window. The lists are in a hierarchical, expandable outline format organized by category. The left pane displays an individual entity and its internals; the right pane displays other items to which that entity is related. When you are looking at C++ code, Browser View displays individual classes and their members in the left pane, and related classes and members in the right pane. The Ada version displays individual packages and their components on the left, and related packages and components on the right. LBL="" HELPID=""Outline IconsAn outline icon is a diamond-shaped, concave icon. It appears to the left of component categories in the lists displayed in the Browser. An outline icon is used to expand or collapse a category. The icon contains an arrow pointing downward if the category is expanded (all items displayed) or to the right if the category is collapsed (all items hidden). Clicking the arrow switches back and forth between collapsing and expanding the category. A right-pointing outline icon that appears filled indicates that one or more of the hidden items satisfy the current query. IDREF="46184" TYPE="GRAPHIC"Figure 7-3 illustrates these conditions.FILE="ch073.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-3"Figure 7-3 ID="46184"Outline Icon ExamplesLBL="" HELPID=""Browser View MenusBrowser View provides these menus:Admin menuname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for general housekeepingViews menuname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for displaying relationships in a graphical format. You can request four variations of class graphs available based on these relationships: inheritance, which describes the relationship of parent classes to derived classes (C++), and parent tagged types to derived tagged types (Ada). containment, which describes the relationship of container classes to the classes they contain.interaction, which describes the relationship of classes using methods of other classes.friends, which describes the relationship of classes declaring other classes as friends.You can also request a call graph to view the relationships of selected methods or functions. History menuname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for going back to a previous Browser activityQueries menuname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for performing queries on the current item. (Note that you can also perform queries on a selected element in either pane by holding down the right mouse button. These popup queries menus have different selections depending on the type of element.)Preference menuname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for changing the appearance of the display and the behavior enacted by double-clicking with the mouseLBL="" HELPID=""Other Browser Window FeaturesThe Current Subject field displays the name of the item you have selected. Its label indicates the kind of item being displayed. Note that the Current Subject field provides a form of file completion; if you enter the partial name of an item and then press the space bar, the name will be completed up to the point that a unique string can be found. The Show in Static Analyzer toggle lets you display the results of any queries in the Static Analyzer window. the Static Analyzer shows more detail, including source information, than the Browser View does. The Last Query button lets you display the result of the previous query to the Static Analyzer.The Browser has annotated scroll bars. This means that when you perform a query, tick marks will appear in the scroll bars (if there are any) to indicate matching elements.LBL="8"ID="89909"Using the Browser for C++: A Sample SessionThis chapter guides you through an interactive sample session that demonstrates the main features in the C++ Browser. The session outlines common tasks you can perform with the Browser, using sample C++ source code to illustrate the use of each function. For complete reference information on the Browser user interface, see ID="ch081"ID="ch082"IDREF="41721" TYPE="TITLE"Chapter 10, "The Browser Reference."This chapter contains the following sections:IDREF="41398" TYPE="TITLE""Setting Up the Sample Session"IDREF="15427" TYPE="TITLE""Understanding the Browser Window"IDREF="44574" TYPE="TITLE""Expanding and Collapsing Categories"IDREF="59198" TYPE="TITLE""Making Queries"IDREF="45215" TYPE="TITLE""Using the Browser Graphical Views"IDREF="17992" TYPE="TITLE""Shortcuts for Entering Subjects"IDREF="56673" TYPE="TITLE""Generating Man Pages"IDREF="13051" TYPE="TITLE""Generating Web Pages"LBL="" HELPID=""ID="41398"Setting Up the Sample SessionThe demonstration directory, /usr/demos/WorkShop/bounce, contains the complete source code for the C++ application bounce. To prepare for the session, you must create the fileset and static analysis database, then launch the browser from the Static Analyzer.ID="ch083"ID="ch084"Prepare for the session by following these steps:Open a shell window, change to the /usr/demos/WorkShop/bounce directory, and start the Static Analyzer by entering cvstatic.The Static Analyzer window opens.Select "Browser" from the Static Analyzer Admin menu.ID="ch085"This starts the Browser if a parser mode static analysis database has already been built. If none is available, an error message appears, and you must specify a parser mode fileset as shown in IDREF="88098" TYPE="GRAPHIC"Figure 8-1. Then you need to select "Browser" from the Admin menu again. This causes a new database to be built using parser mode, and takes several minutes to complete.FILE="ch083.gif" POSITION="INLINE" SCALE="FALSE"LBL="8-1"Figure 8-1 ID="88098"Steps in Specifying a Parser FilesetThe Browsing Choices chooser window opens at the same time as the Browser View window so that you can select the first class. The Browsing Choices chooser window contains the complete list of C++ classes included in the current fileset. Locate the Actor class in the chooser window. See IDREF="16979" TYPE="GRAPHIC"Figure 8-2.FILE="ch085.gif" POSITION="INLINE" SCALE="FALSE"LBL="8-2"Figure 8-2 ID="16979"Initial Browser Display With Item SelectedID="15427"Understanding the Browser WindowDouble-click the Actor class in the chooser window.The Browsing Choices window closes, and the data for Actor now appears in the Browser View window. The class name Actor is displayed in the Current Subject text field. Information about the class appears in the outline list views in the side-by-side panes (see IDREF="25929" TYPE="GRAPHIC"Figure 8-3). Actor is now the current subject (class).FILE="ch08.gif" POSITION="INLINE" SCALE="FALSE"LBL="8-3"Figure 8-3 ID="25929"Browser View With C++ DataLook at the Browser window.The ID="ch086"member list in Browser View is on the left. It displays members according to their accessibility: PUBLIC, INSTANCE, or PRIVATE.Each kind of member can be STATIC or INSTANCE (non-static). Static objects of a given class contain the same value for a given member. INSTANCE members can contain different data values in different instances of that class.The member pane displays four kinds of class members: TYPES, DATA, METHODS,and VIRTUAL METHODS.The relations list displays information on related classes and methods, based on the point of view of the current class: BASE CLASSES, DERIVED CLASSES, USES (classes that the current class uses), USED BY (classes that the current class is used by), FRIENDS, FRIEND FUNCTIONS, and FRIEND OF relationships. The layout of the both list displays are customizable.ID="44574"Expanding and Collapsing CategoriesClick the outline icon to the left of the Protected category (see IDREF="25929" TYPE="GRAPHIC"Figure 8-3).This displays the elements in the Protected category and causes the arrow in the outline icon to point downward.Click the outline icon to the left of the Protected category again.This hides the elements and causes the arrow in the outline icon to point to the right again.ID="59198"Making QueriesClick the Queries menu and examine it.To learn details about the structure of your C++ code, you make ID="ch087"queriesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'predefined questionsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'about the current class's members and related classes. A query provides a focused view of a large, complicated class structure from the viewpoint of any class or member. Queries search the static analysis database for specific information about classes and their members, including class hierarchy, class and member declarations and definitions, and the interactions among members and classes (for example, which members call which members, where a definition overrides another, where an instance is created or destroyed, and so on).The C++ Browser provides two types of Queries menus: Queries menuname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'accessed from the menu bar, its queries apply to the current classElement-specific popup menusname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Accessed by holding down the right mouse button while the pointer is over the selected element you wish to queryThe Browser provides answers to queries by highlighting items in the member and related class lists that match the query. Optionally, you can display more detailed query results in the Static Analyzer window from which you launched the Browser.ID="ch088"Click the Show in Static Analyzer toggle button shown in IDREF="25929" TYPE="GRAPHIC"Figure 8-3.This button lets you view the results of queries in the Static Analyzer window along with the Browser window. The Static Analyzer window has the advantage of showing source lines for your queries.Select "What Uses" from the Queries menu and "To Contain" from its submenu, as shown in the top part of IDREF="25415" TYPE="GRAPHIC"Figure 8-4.The Queries menu in the menu bar lets you request relationship information for the current class. In addition to highlighting the matching elements in the list, the Browser displays indicator marks in the scroll bar showing the relative locations of matching elements. Also, the query is identified in the field over the outline list area. If you click on an indicator mark, you'll scroll directly to the matching element. See the lower part of IDREF="25415" TYPE="GRAPHIC"Figure 8-4. Since you turned on the Static Analyzer toggle, the results are shown there as well, including the file, line number, and source line for the classes containing Actor. See IDREF="64095" TYPE="GRAPHIC"Figure 8-5.FILE="ch086.gif" POSITION="INLINE" SCALE="FALSE"LBL="8-4"Figure 8-4 ID="25415"Performing a Query on Current ClassFILE="f08stat1.gif" POSITION="INLINE" SCALE="FALSE"LBL="8-5"Figure 8-5 ID="64095"Static Analyzer After Browser QuerySelect the constructor method in the Methods category, hold down the right mouse button, and select "Show Source Where Declared." See IDREF="69653" TYPE="GRAPHIC"Figure 8-6.This displays the Queries menu specific to methods. In this case, the query lets us see the source code where it is declared. Source View now displays with the matching code highlighted. For practice, try a few random queries.Click the Last Query button in Browser View.Clicking this button displays the results of the most recent query in the WorkShop Static Analyzer window from which the Browser was launched.FILE="ch087.gif" POSITION="INLINE" SCALE="FALSE"LBL="8-6"Figure 8-6 ID="69653"Performing a Query on an Element in a ListID="45215"Using the Browser Graphical ViewsNow look at the graphical views supplied by the Browser.Select "Show Containment Graph" from the Views menu in the Browser window.The Graph Views window is displayed, set to Containment as shown in IDREF="41247" TYPE="GRAPHIC"Figure 8-7. You can switch to other relationship modes through the relation mode menu.FILE="ch088.gif" POSITION="INLINE" SCALE="FALSE"LBL="8-7"Figure 8-7 ID="41247"Graph Views Window in Containment ModePull down the Views menu, select "Show Butterfly," and resize the Graph Views Window to be smaller.This eliminates extraneous classes from the graph, displaying only those classes that Actor contains or is contained by. Now compare the graph with the query results shown in the Browser. FILE="ch089.gif" POSITION="INLINE" SCALE="FALSE"LBL="8-8"Figure 8-8 Comparison of Data Displayed in Browser With Data Displayed in Containment GraphSelect "Inheritance" from the relation mode menu (see IDREF="41247" TYPE="GRAPHIC"Figure 8-7).This shows the inheritance relationships; in this case, the derived classes BouncingBall and Engine inherit from Actor, as shown in IDREF="15626" TYPE="GRAPHIC"Figure 8-9.FILE="f08igrf2.gif" POSITION="INLINE" SCALE="FALSE"LBL="8-9"Figure 8-9 ID="15626"Graph Views Window in Inheritance ModeSelect "Interaction" from the relation mode menu.This displays the classes that directly interact with Actor. Those that use Actor appear on the left, and those that are used by Actor appear on the right.FILE="f08igrf3.gif" POSITION="INLINE" SCALE="FALSE"LBL="8-10"Figure 8-10 Graph Views Window in Interaction ModeID="17992"Shortcuts for Entering SubjectsGo back to the Browser window, clear the Current Subject field, and type a question mark (?), followed by <Enter>.This is a shortcut for displaying the Browsing Choices window. Instead of selecting through the Browsing Choices window, we're going to demonstrate how name completion works.Type Main and press the space bar.The Browser fills in the rest of the name, MainWindow in this example, and its data.ID="56673"Generating Man PagesThe Browser generates reference page templates from your classes so that all you have to do is fill in the descriptions and provide comments. To create reference pages for classes in the fileset, follow these steps:ID="ch089"ID="ch0810" From the Browser View Admin menu, select "Generate Man Pages." The Man Page Generator window opens, as shown in IDREF="64490" TYPE="GRAPHIC"Figure 8-13.FILE="ch0812.gif" POSITION="INLINE" SCALE="FALSE"LBL="8-11"Figure 8-11 ID="64490"Man Page Generator WindowYou can specify the target directory in the area at the top of the window, either directly in the Man Page Directory field, or by browsing in the dialog box displayed by clicking the Set Directory button. The control area lets you receive warnings if a man page already exists, select or unselect all classes, generate new man pages, and display shells showing the new man pages.Click the Select All button in the control area.This selects all the classes in the class list. If you need only a subset of the list, simply click the desired classes. If you change your mind, you can remove any current selections by clicking the Unselect All button.Click Generate. Wait for a few seconds while your files are generated. Click View to view the output files. A winout window containing the man page text opens, as shown in IDREF="91627" TYPE="GRAPHIC"Figure 8-12. You can edit this file using a text editor, such as vi. FILE="manPage.gif" POSITION="INLINE" SCALE="FALSE"LBL="8-12"Figure 8-12 ID="91627"Man Page TemplateClose the winout window using the window menu in the upper left corner.ID="13051"Generating Web PagesThe Browser also lets you generate web pages, that is, documentation in HTML format compatible with World Wide Web readers. From the Browser View Admin menu, select "Generate Web Pages." The Web Page Generator window opens, as shown in IDREF="64490" TYPE="GRAPHIC"Figure 8-13. FILE="ch082.gif" POSITION="INLINE" SCALE="FALSE"LBL="8-13"Figure 8-13 ID="64490"Web Page Generator WindowThis window operates analogously to the Man Page Generator window. You specify the target directory by typing directly in the Web Page Directory field, or by browsing in the dialog box that comes up when you click the Set Directory button. The control area lets you receive warnings if a web page already exists, select or unselect all classes, generate new web pages, and display a shell showing the new web pages.Click the Select All button in the control area.This selects all the classes in the class list. If you need only a subset of the list, simply click the desired classes. If you change your mind, you can remove any current selections by clicking the Unselect All button.Click Generate. Wait for a few seconds while your files are generated. Click View to view the output files. You've reached the end of the sample session. You can exit both the Static Analyzer and the C++ Browser by pulling down the Static Analyzer Admin menu and choosing "Exit." LBL="9"ID="65958"Using the Browser for Ada: A Sample SessionThis chapter guides you through an interactive sample session that demonstrates the main features in the Ada Browser. The session outlines common tasks you can perform with the Browser, using example Ada application source to illustrate the use of each function. For complete reference information on the browser's user interface, see ID="ch091"ID="ch092"IDREF="41721" TYPE="TITLE"Chapter 10, "The Browser Reference."This chapter contains the following sections:IDREF="41398" TYPE="TITLE""Setting Up the Sample Session"IDREF="42361" TYPE="TITLE""Starting the Browser"IDREF="29117" TYPE="TITLE""Understanding the Browser Window"IDREF="99168" TYPE="TITLE""Making Queries"IDREF="20425" TYPE="TITLE""Using the Browser Graphical Views"IDREF="36788" TYPE="TITLE""Shortcuts for Entering Subjects"NoteThe features described in this chapter are available only if you have purchased the ProDev Ada package.LBL="" HELPID=""ID="41398"Setting Up the Sample SessionThe demonstration directory, /usr/demos/Ada/WorkShop/tagged_example, contains the complete source code for a simple Ada application called tagged_example. To prepare for the session, you first need to create the fileset and static analysis database.ID="ch093"ID="ch094"Prepare for the session by following these steps:Open a shell window, and change to the /usr/demos/Ada/WorkShop/tagged_example directory. Start the Static Analyzer by entering cvstatic.The Static Analyzer window opens. You need to create a new fileset using parser mode. Pull down the Admin menu and select "Edit Fileset...".To create a parser mode fileset for this example, follow the instructions shown in IDREF="88098" TYPE="GRAPHIC"Figure 9-1. It takes several minutes to build the database from the fileset.FILE="ch095.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-1"Figure 9-1 ID="88098"Steps in Specifying a Parser FilesetWhen the fileset is built, select "List All Packages" from the "Packages" submenu in the Queries menu.This displays all the packages in the fileset.Select "List All Tagged Types" from the "Types" submenu in the Queries menu.This displays all the tagged types in the fileset.Select "List All Files" from the "Files" submenu in the Queries menu.This displays all the source code files in the fileset.Pull down the Views menu and select "File Dependency View."File Dependency shows you the dependency between packages (packages are defined one to a file). If you double-click arcs in this view, you can see where packages are imported using the with clause and also definitions where packages are brought in.FILE="f09fildp.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-2"Figure 9-2 File Dependency View ExampleID="42361"Starting the BrowserPull down the Static Analyzer Admin menu and select "Browser." ID="ch095"This displays the Browser View window and the Browsing Choices chooser window, which is used to select subjects for browsing. The Browsing Choices chooser window contains the complete list of Ada entities (packages, tagged types, and task types) included in the current fileset. See IDREF="16979" TYPE="GRAPHIC"Figure 9-3. FILE="ch096.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-3"Figure 9-3 ID="16979"Initial Browser Display With Item SelectedID="29117"Understanding the Browser WindowDouble-click the parent package in the chooser window.The Browsing Choices window is lowered, and the data for parent now appears in the Browser View window (see IDREF="25929" TYPE="GRAPHIC"Figure 9-4). The subject parent is now displayed in the Current Subject text field and is identified as an Ada package. Information about Ada entities appears in the outline list views in the side-by-side panes.FILE="ch092.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-4"Figure 9-4 ID="25929"Browser View With Ada DataObserve the Browser window.The ID="ch096"member pane in Browser View is on the left. It displays "members" according to their accessibility: SPEC PUBLIC, SPEC PRIVATE, or BODY.The member pane displays these kinds of Ada members: DATA, TYPE, FUNCTIONS, ENTRIES,and PRIMITIVE OPERATIONS.The relations pane displays information on related Ada entities, based on the point of view of the current subject: PARENTS and DERIVED. You can customize the layout of both list displays.Click the outline icon to the left of the FUNCTIONS category (see IDREF="25929" TYPE="GRAPHIC"Figure 9-4).This collapses the category, hiding the items. Outline icons with right-pointing arrows indicate that a category in the list is expandable, that is, that elements in the category are hidden from view. Click the outline icon again to display the items.ID="99168"Making QueriesClick the Queries menu and observe it.To learn the details about the structure of your Ada code, you make ID="ch097"queriesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'predefined questionsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'about the current subject's members and related entities. Queries are a focused view of a large, complicated structure from the viewpoint of any Ada entity. Queries search the static analysis database for specific information about subjects and their members. The Browser provides two types of Queries menus: a menu for the current subject that you access from the menu bar, and element-specific menus that you access by holding down the right mouse button while the pointer is over the selected element you wish to query. The Browser answers queries by highlighting items in the member and related class lists that match the query. Optionally, you can display more detailed query results in the Static Analyzer window from which you launched the Browser.ID="ch098"Select "What Is Declared" from the Queries menu.The Queries menu in the menu bar lets you request relationship information for the current subject. In addition to highlighting the matching elements in the list, the Browser displays indicator marks in the scroll bar showing the relative locations of matching elements. Also, the query is identified in the field over the outline list area. If you click on an indicator mark, you'll scroll directly to the matching element. See IDREF="25415" TYPE="GRAPHIC"Figure 9-5. FILE="ch097.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-5"Figure 9-5 ID="25415"Performing a Query on Current ClassAccessing Source CodeSelect the new_to_parent function, hold down the right mouse button over it, and choose "Show Source Where Declared."This displays Source View containing the source code where new_to_parent is declared. See IDREF="79093" TYPE="GRAPHIC"Figure 9-6.FILE="ch094.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-6"Figure 9-6 ID="79093"Accessing Source Code From Browser ViewID="20425"Using the Browser Graphical ViewsPull down the Views menu in the Browser window and select "Show Inheritance Graph." The Inheritance Graph window is displayed, as shown in IDREF="34993" TYPE="GRAPHIC"Figure 9-7. You can switch to other relationship modes through the relation mode menu.FILE="ch093.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-7"Figure 9-7 ID="34993"Inheritance Graph ExampleID="36788"Shortcuts for Entering SubjectsGo back to the Browser window, clear the Current Subject field, type a question mark (?), and press <Enter>.This is a shortcut for displaying the Browsing Choices window. Instead of selecting through the Browsing Choices window, however, follow this tutorial to see how name completion works.Type grand and press the space bar.The Browser fills in the rest of the name (grandparent in this example) and its data.This is the end of the sample session. You can exit both the Static Analyzer and the Ada Browser by choosing "Exit" from the Static Analyzer Admin menu.LBL="10"ID="41721"The Browser ReferenceThis chapter describes all of the windows and features associated with the Browser. For tutorials demonstrating how the Browser is used, refer to IDREF="89909" TYPE="TITLE"Chapter 8, "Using the Browser for C++: A Sample Session," and IDREF="65958" TYPE="TITLE"Chapter 9, "Using the Browser for Ada: A Sample Session."This chapter contains the following sections:IDREF="17490" TYPE="TITLE""Browsing Choices Window"IDREF="14051" TYPE="TITLE""Browser View Window"IDREF="20193" TYPE="TITLE""Graph Views Window"IDREF="52924" TYPE="TITLE""Call Graph Window"LBL="" HELPID="BrowsingChoicesWindow"ID="17490"Browsing Choices WindowThe Browsing Choices window lets you select items to be browsed from a list derived from the fileset in the Browser View window. Double-clicking an item in the selection list causes the Browser View window to be raised (moved to the front) with the chosen item as the current subject for analysis.FILE="ch1035.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-1"Figure 10-1 ID="88593"Browsing Choices WindowLBL="" HELPID=""Browsing Choices Window for C++With C++ code, the Browsing Choices window displays one column to indicate the kind of item, a column to identify the item, and three columns indicating properties, as follows:Kindname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'classes, template definitions, and template instancesNamename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the name of the itemAbstractname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'abstract property: concrete (blank), abstract by declaration, or abstract by inheritanceDeltaname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'delta property: dynamic, internal dynamic, or non-dynamic (blank)Templatename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'template property: specific definition, partial instantiation, or normal (blank)The Browsing Choices window provides a facility for sorting items by column. To do this, click in the column you wish to sort on and select "Sort" from the Admin menu.LBL="" HELPID=""Browsing Choices Window for AdaIf you're using Ada, the Browsing Choices window displays packages, tasks, and tagged types in the Kinds column. The properties columns are not used in Ada and appear blank. You can sort the items by kind or name by clicking in the appropriate column and selecting "Sort" from the Admin menu.NoteThese features are available only if you have purchased the ProDev Ada package.LBL="" HELPID="BrowserViewWindow"ID="14051"Browser View WindowBrowser View is the primary Browser window (see ID="ch101"IDREF="74392" TYPE="GRAPHIC"Figure 10-2). It opens when you select "Browser" from the Admin menu of the WorkShop Static Analyzer, but does not display data until you select an item from the list in the Browsing Choices window. Browser View displays internal and related information for elements in Ada and C++ programs. The information is presented in hierarchical lists shown in outline format. Browser View lets you perform a variety of static analysis database queries, depending on your current work context. Queries concerning the current subject are accessed from the Queries menu in the menu bar. You can also make queries specific to the selected elements in the list area by holding down the right mouse button to display a popup Queries menu specific to that type of element. The results of queries are indicated by highlighting matching elements in the Browser View window. Matching results are also highlighted in Source View, if it is displayed; and in the Static Analyzer, if the Show in Static Analyzer toggle is turned on (see IDREF="45301" TYPE="TITLE""Show in Static Analyzer Toggle"). You can also launch graphical views showing hierarchies and call graphs from the Browser View window. In addition, you can generate reference pages and web pages from Browser View.FILE="ch10.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-2"Figure 10-2 ID="74392"Browser View Window ElementsLBL="" HELPID="CurrentSubjectField"Current Subject FieldThe Current Subject field indicates the kind and name of the element to be analyzed. It is directly below the menu bar (see ID="ch102"IDREF="74392" TYPE="GRAPHIC"Figure 10-2). The label on this field is initially Current Subject. To analyze an element, you can type directly into this field (or select from the Browsing Choices window). The label changes according to the kind of element you select. You can enter the following kinds of elements:C++ classC++ template definitionC++ template instanceAda package (with ProDev Ada only)Ada task (with ProDev Ada only)Ada tagged type (with ProDev Ada only)LBL="" HELPID=""Name CompletionIf you type a partial string and then press the <space bar>, the Browser attempts to complete the element name by searching the fileset. A beep indicates that more than one matching name exists. If a match is made, press the <Enter> key to make the change effective.LBL="" HELPID=""Changing Subject Using "?"If you type a question mark (?) into the ID="ch103"Current Subject field, the Browsing Choices window opens. You can select a new item by double-clicking a name in the selection list.LBL="" HELPID="ShowinStaticAnalyzerToggle"ID="45301"Show in Static Analyzer ToggleThe Show in Static Analyzer toggle is directly to the right of the ID="ch104"Current Subject field (see IDREF="74392" TYPE="GRAPHIC"Figure 10-2). When the toggle is set (a check mark and the label Yes appear), the results of all queries are displayed in the WorkShop Static Analyzer window from which the Browser was launched, including the file, line number, and source line for the matching items. If no results are found and the Static Analyzer window is open, it comes to the front with an error message. ID="ch105"LBL="" HELPID="LastQueryButton"Last Query ButtonThe Last Query button is at the top right of the window, directly beneath the Help menu (see ID="ch106"IDREF="74392" TYPE="GRAPHIC"Figure 10-2). Clicking this button displays the results of the most recent query in the WorkShop Static Analyzer window from which the Browser was launched. LBL="" HELPID="BrowserViewQueryIdentificationArea"Browser View Query Identification AreaThe Browser View query identification area is directly above the list area (see ID="ch107"IDREF="74392" TYPE="GRAPHIC"Figure 10-2). This area displays the most recent query as a sentence containing both the query question and the name of the object of the query. The number of elements matching the query is displayed at the right end of the line.ID="ch108"LBL="" HELPID="BrowserListAreas"Browser View List AreasThe lower two-thirds of the Browser View window consists of two lists displayed in side-by-side panes (see ID="ch109"IDREF="74392" TYPE="GRAPHIC"Figure 10-2). The lists contain information about the currently selected subject and are organized by category in an outline format. The lists are:member listname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'a detailed view of the internals of the current subject.relation listname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'items related to the current subject.You can change the relative widths of the panes by moving the sash that separates the panes. The categories in the lists are different depending on whether you are using C++ or Ada code (with ProDev Ada only). IDREF="29319" TYPE="TABLE"Table 10-1 summarizes the contents of each list by programming language. For more information on the lists, see IDREF="52089" TYPE="TITLE""C++ Member List", IDREF="74451" TYPE="TITLE""C++ Relation List", IDREF="54961" TYPE="TITLE""Ada Member List", and IDREF="20799" TYPE="TITLE""Ada Relation List". COLUMNS="3"LBL="10-1"Table 10-1 ID="29319"Browser View List SummaryLEFT="0" WIDTH="57"LanguageLEFT="65" WIDTH="138"Member List ContentsLEFT="210" WIDTH="138"Relations List ContentsLEFT="0" WIDTH="57"C++LEFT="65" WIDTH="138"PUBLIC/INSTANCE/PRIVATE   INSTANCE/STATIC       TYPES/DATA/METHODS/      VIRTUAL METHODSLEFT="210" WIDTH="138"BASE CLASSES (including the 
current class)/ DERIVED 
CLASSES/USES/ USED BY/
FRIEND FUNCTIONS/
FRIENDS/FRIEND OFLEFT="0" WIDTH="57"AdaLEFT="65" WIDTH="138"SPEC PUBLIC/SPEC PRIVATE/
BODY   CONTAINS/DATA/TYPE/   FUNCTIONS/ENTRIES/   PRIMITIVE OPERATIONSLEFT="210" WIDTH="138"PARENTS (including the current 
subject)/ DERIVEDLBL="" HELPID=""Outline IconsEach category name appears with an outline icon to its left, that is, a diamond-shaped icon that can be used to collapse (hide) or expand (make visible) the items under that category. Inside the icon there is an arrow that indicates whether the category is in the expanded or collapsed state. If the arrow points downward, the list is in its expanded state; all items are displayed. If the icon points to the right, the category is in its collapsed state; all items in that category are hidden. Clicking the arrow toggles the state of the category, displaying or hiding the category's contents. Another function of the outline icon is to indicate when a collapsed list contains items matching the current query. This is shown with a filled outline icon. See ID="ch1010"IDREF="78252" TYPE="GRAPHIC"Figure 10-3.FILE="ch103.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-3"Figure 10-3 ID="78252"Outline List Icons and Indicator MarksLBL="" HELPID=""Annotated Scroll Bars and Highlighted EntriesThe lists use annotated scroll bars as another way to locate highlighted list entries. When you make a query on an item in a list, the Browser displays indicator marks in the scroll bars in both panes corresponding to the relative positions of matching items. This informs you about all matches even if they are in collapsed categories or in a portion of the list that is not currently in view. If you click an indicator with the middle mouse button, you scroll directly to the matching item in the list. When the thumb of the scroll bar overlaps a given tick mark, the corresponding entry is visible in the list window. See ID="ch1011"ID="ch1012"IDREF="78252" TYPE="GRAPHIC"Figure 10-3.LBL="" HELPID=""ID="52089"C++ Member ListThe Browser View member list displays the types, data members, methods, and virtual methods internal to the current class, template definition, or template instance when you are analyzing C++ code. It labels constructor methods as ID="ch1013"ID="ch1014"-constructor-> and destructors as --destructor->.LBL="" HELPID=""Display HierarchyThe members of the current class are sorted recursively into three nested lists according to the access specification (PUBLIC, PROTECTED, or PRIVATE) of each member. Within each of the access categories, the members are sorted by ID="ch1015"scope into two categories (INSTANCE and STATIC). Finally, within each category, members are displayed by member category type in this order: TYPE, DATA, METHODS (member functions), and VIRTUAL METHODS. ID="ch1016"Here is a schematic of the outline format for each nested list:Access (PUBLIC, PROTECTED, or PRIVATE)
    Scope (INSoTANCE or STATIC)
       TYPES
       DATA
       METHODS
       VIRTUAL METHODSLBL="" HELPID=""Access CategoriesThe accessibility categories are:public membersname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'accessible by any method or C-style functionID="ch1017"protected membersname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'accessible only by methods in derived classes, friend classes, or friend functions ID="ch1018"private membersname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'accessible only by methods in the class in which they are defined, friend classes, or friend functionsID="ch1019"LBL="" HELPID=""Scope CategoriesThe scope categories are:static membersname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'all objects of a given class contain the same value for a given memberinstance (non-static) membersname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'members in different instances of that class can contain different data valuesLBL="" HELPID=""Class Member CategoriesClass members fall into these categories:typesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'definitions of data types declared within a classdataname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'variables that contain state information for a classmethods (or member functions)name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'definitions of how a class interacts with other classes and structuresvirtual methodsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'methods for an object that ensure that the method invoked is defined by the class from which the object was instantiated, regardless of type castingThe list organization is customizable. For more information, refer to Appendix A.LBL="" HELPID=""Displaying a Member's Source CodeDouble-clicking any member in the member list opens a Source View window containing that member's code with the declaration highlighted. See ID="ch1020"ID="ch1021"ID="ch1022"IDREF="78391" TYPE="GRAPHIC"Figure 10-4.FILE="ch1021.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-4"Figure 10-4 ID="78391"Source View of Class Data MemberLBL="" HELPID=""ID="74451"C++ Relation ListThe C++ relations list displays the current class and its related classes in the related class listID="ch1023". The categories in the list are:BASE CLASSESname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'contains the current class and its ancestors, listed hierarchicallyDERIVED CLASSESname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'contains descendants of the current class, listed hierarchicallyUSESname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'contains classes that the current class uses (that is, instantiates, destroys, interacts with, or contains)USED BYname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'contains classes that the current class is used byFRIEND FUNCTIONSname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'contains global functions declared as friends by the current classFRIENDSname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'contains classes that are declared as friends by the current class.FRIEND OFname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'contains classes that declare the current class as a friend.Within this list, the current class is displayed as follows:ID="ch1024"<- Thiswhich refers to the class in the Current Class field.LBL="" HELPID=""C++ Relations List Mouse ShortcutsDouble-clicking any class listed in the related class list makes it the new current class. Double-clicking a friend function brings up a Source View window highlighting the function's definition.ID="ch1025"LBL="" HELPID=""Base Classes Category HierarchyThe Base Classes category shows the ancestors of the current class, if any. Each indented class is an ancestor of the class listed above it. The Base Classes category indicates a multiple inheritance relationship by indenting parent classes to the same level. If a given class has ancestors, it is accompanied by an outline icon, which works in a similar manner to the outline icons in the member list. Each ancestor name is followed by its inheritance access type (public, protected or private) listed in parentheses.ID="ch1026"ID="ch1027"This schematic gives an example of a Base Classes category:ID="ch1028"BASE CLASSES
   <-This
              first_parent_of_This (access type)
                                parent_of_first_parent_class (access type)
               second_parent_of_This (access type)
                               parent_of_second_parent_class (access type)LBL="" HELPID=""Derived Classes Category HierarchyThe Derived Classes category shows the descendants of the current class, if any. Each indented class is a descendant of the class listed above it. If a given class has descendants, it is accompanied by an outline icon, which works in a similar manner to the outline icons in the base classes category and member list. This schematic gives an example of a possible Derived Classes category:ID="ch1029"DERIVED CLASSES
    first_child_of_This
       child_of_first_child_class
    second_child_of_This
       child_of_second_child_class
FILE="ch106.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-5"Figure 10-5 ID="67052"C++ Relations List Derived Classes CategoryLBL="" HELPID=""ID="54961"Ada Member ListNoteThe features described in this section are available only if you have purchased the ProDev Ada package.The Ada version of the Browser View member list displays packages, task types, and tagged types as its current subjects. Packages have functions as their internal "members." The internal members for task types are entries (under Public) and functions. Tagged types have primitive operations as their internal members.LBL="" HELPID=""Display HierarchyThe members of the current subject are sorted recursively into three nested lists according to the access specification (SPEC PUBLIC, SPEC PRIVATE, or BODY) of each member. Under each of the access categories lies the INSTANCE subcategory. Finally, the members are displayed by member category type in this order: TYPES, DATA. ID="ch1030"Here is a schematic of the outline format for each nested list:Access (SPEC PUBLIC, SPEC PRIVATE, or BODY)
   Scope (INSTANCE)
      TYPES
      DATALBL="" HELPID=""Access CategoriesThe accessibility categories are different depending on the type of Ada entity.The accessibility categories for packages are:spec publicname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'includes declarations of data, functions, and types made in the public part of the package specspec privatename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'includes declarations of data, functions, and types made in the private part of the package specbodyname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'includes declarations and definitions of data, functions, and types made in the implementation of the package. These symbols are usable only within the package body.The accessibility categories for tagged types are:spec publicname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'includes data lists components of the tagged type. Functions list primitive operations of the tagged type.NoteThere is no spec private or body section for a tagged type.The accessibility categories for task types are:spec publicname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'includes functions listed here are entries to the task. Types and data listed here are public (ie usable by a client of the task).bodyname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'includes types, data, and functions used in the implementation of the task. These symbols are usable only within the task body.NoteThere is no spec private section for tagged typesLBL="" HELPID=""Type and Data Member CategoriesThe other categories are:typesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'definitions of data types declared by a package, task, or tagged typedataname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'variables that contain state information for a package, task, or tagged typeThe list organization is customizable. For more information, refer to IDREF="90006" TYPE="TITLE"Appendix A, "Customizing the C++ Browser."LBL="" HELPID=""Displaying a Member's Source CodeDouble-clicking any member in the member list opens a Source View window containing that member's code, with the declaration highlighted. See ID="ch1031"ID="ch1032"ID="ch1033"IDREF="78391" TYPE="GRAPHIC"Figure 10-4.LBL="" HELPID=""ID="20799"Ada Relation ListThe Ada relations list shows parent-derived relationships between tagged types (with ProDev Ada only).LBL="" HELPID=""ID="46225"Browser View Menu BarThis section describes the menus, found in the Browser View menu bar (see ID="ch1034"IDREF="84676" TYPE="GRAPHIC"Figure 10-6).FILE="ch1013.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-6"Figure 10-6 ID="84676"Browser View Menu Bar With Menus DisplayedLBL="" HELPID="BrowserAdminMenu"ID="72020"Admin MenuFILE="f10admin.gif" POSITION="MARGIN" SCALE="FALSE"LBL="10-7"Figure 10-7 ID="48485"Browser View Admin MenuCurrent Class Pop-Up MenuThe Admin menu contains commands for selecting new subjects, manipulating Browser View windows, generating reference and web pages, and exiting the Browser View.ID="ch1035""Change Current Subject"Lets you select a new current a new subject without manually typing it into the ID="ch1036"Current Subject field. Choosing this command opens the Browsing Choices window (see ID="ch1037"IDREF="88593" TYPE="GRAPHIC"Figure 10-1), which contains a scrolling list of all the classes or packages available from the current fileset. Double-clicking an item selects it for display in the Browser View window and closes the Browsing Choices window."Another Browser View"Creates an identical copy of the Browser View window. All current information displayed within the initial window appears in the copy, but connections to the graphical view windows are not carried over to the new Browser View window.ID="ch1038""Close Browser View"Shuts the Browser View window and any associated windows, such as Graph or List of Classes.ID="ch1039"LBL="" HELPID=""ID="45100"Man Page Generation"Generate Man Pages..."Opens the Man Page Generator window, which lets you create reference page templates for classes (C++), packages (Ada), tasks (Ada), and tagged types (Ada). See ID="ch1040"ID="ch1041"IDREF="52367" TYPE="GRAPHIC"Figure 10-8. Select individual subjects by clicking them. If you want a reference page for every subject in the list, click Select All. To remove selections you've made, click Unselect All. Clicking the Generate button creates a reference page template for each selected subject. If reference pages exist for any selected subjects, the Browser warns you, unless you set the Warn Overwrite toggle to No.Output files go in the directory shown in the Man Page Directory field, if it exists. To specify a different output directory, click the Set Directory button in the Man Page Generator window and enter your choice.FILE="ch102.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-8"Figure 10-8 ID="52367"Man Page Generator and Typical Man Page TemplateLBL="" HELPID=""ID="12080"Web Page Generation"Generate Web Pages ..."Opens the Web Page Generator window (see IDREF="45499" TYPE="GRAPHIC"Figure 10-9), which lets you create web page templates for classes (C++), packages (Ada), tasks (Ada), and tagged types (Ada). See IDREF="60102" TYPE="GRAPHIC"Figure 10-10. These templates are in HTML format and can be read by viewers compatible with the World Wide Web.Select individual subjects by clicking them. If you want a reference page for every subject in the list, click Select All. To remove selections you've made, click Unselect All. Clicking the Generate button creates a reference page template for each selected subject. If reference pages exist for any selected subjects, the Browser warns you, unless you set the Warn Overwrite toggle to No.Output files go in the directory shown in the Web Page Directory field, if it exists. To specify a different output directory, click the Set Directory button in the Web Page Generator window and enter your choice.FILE="ch105.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-9"Figure 10-9 ID="45499"Web Page Generator WindowFILE="f10wbtmp.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-10"Figure 10-10 ID="60102"Typical Web Page Template"Exit Browser"Quits the C++ Browser, closing all windows launched from it (except Source View). The Static Analyzer window from which the browser was launched is not affected.ID="ch1042"LBL="" HELPID="BrowserViewsMenu"ID="40544"Views MenuFILE="f10views.gif" POSITION="MARGIN" SCALE="FALSE"LBL="10-11"Figure 10-11 ID="81962"Views MenuThe Views menu contains commands for opening graphical views (see ID="ch1043"ID="ch1044"IDREF="81962" TYPE="GRAPHIC"Figure 10-11). For descriptions of the display and controls, refer to IDREF="95481" BOOK="WrkShp_OV" FILE="appa.doc" HDG=""Appendix A, "Using Graphical Views."  Each of the first four selections opens a Graph Views window for the current class, with a specific relationship; refer to IDREF="20193" TYPE="TITLE""Graph Views Window". The last selection opens a Call Graph window; refer to IDREF="52924" TYPE="TITLE""Call Graph Window"."Show Inheritance Graph"Describes the relationship between base classes and derived classes.ID="ch1045""Show Containment Graph"Describes the relationship of container classes to the classes they use as components.ID="ch1046""Show Interaction Graph" Describes the relationship of used classes to the classes that are their users.ID="ch1047""Show Friend Graph"Describes the relationship of classes declaring friends to the classes they declare.ID="ch1048""Show Call Graph"Opens a Call Graph window. To perform operations in it, select a method from the member list display, press the right mouse button to display the Methods popup menu, and select "Add," "Remove," or "Replace" from the "Call Graph" submenu. ID="ch1049"ID="ch1050"LBL="" HELPID="BrowserHistoryMenu"ID="98538"History MenuFILE="f10histo.gif" POSITION="MARGIN" SCALE="FALSE"LBL="10-12"Figure 10-12 ID="72280"History MenuThe History menu contains commands that let you quickly select previously chosen subjects for display in the Browser View window (see ID="ch1051"ID="ch1052"IDREF="72280" TYPE="GRAPHIC"Figure 10-12). If no class was selected previously, a message appears."Show Previous Subject"Sets the current subject to the previously displayed class, and the information in the Browser View window changes to reflect this. ID="ch1053""Show History"Opens a "List of Subjects Shown" chooser window for selecting previously viewed subjects (see ID="ch1054"IDREF="98920" TYPE="GRAPHIC"Figure 10-13). The window presents the previous subjects in reverse chronological order, that is, the most recent subject appears at the bottom of the list.FILE="f10lsshn.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-13"Figure 10-13 ID="98920"List of Classes ShownTo select a subject, click it and press Apply or OK. Double-clicking a subject has the same effect as OK; it makes the selection and closes the window. The selected class then becomes the current subject in the Browser View window.LBL="" HELPID="BrowserMainQueriesMenu"ID="17626"Main Queries MenuFILE="f10mainq.gif" POSITION="MARGIN" SCALE="FALSE"LBL="10-14"Figure 10-14 ID="69057"Queries MenuThe main Queries menu is accessed from the menu bar and applies to the current subject (see IDREF="69057" TYPE="GRAPHIC"Figure 10-14). The selections are:ID="ch1055"ID="37517""What Is Declared"Displays all methods declared by the current class.ID="ch1056""What Is Defined" Displays all members defined by the current class.ID="ch1057""What Is Overridden By"Displays all inherited methods that the current class overrides.ID="ch1058"ID="ch1059""What is Pure Virtual"Displays all pure virtual functions in the current subject."What Instantiates"Displays classes that instantiate the current class by invoking its constructors or by using its new methods.ID="ch1060"ID="ch1061""What Destroys"Displays classes that destroy the current class by invoking its destructors or by using its delete methods.ID="ch1062"ID="ch1063""What Uses" submenu (see IDREF="60180" TYPE="GRAPHIC"Figure 10-15)FILE="f10quses.gif" POSITION="MARGIN" SCALE="FALSE"LBL="10-15"Figure 10-15 ID="60180""What Uses" Submenu of Queries Menu
Displays the classes that use the current class in these contexts: ID="ch1064""To Contain" displays classes that use the current class as either an embedded or linked component.ID="ch1065""As Friend" displays classes that use the current class as a friend class.ID="ch1066"ID="ch1067""Methods" displays classes that use the methods defined by the current class.ID="ch1068""Data Members" displays classes that use (by modifying, reading, or taking the address) data members defined by the current class.ID="ch1069""What Is Instantiated"Displays classes that the current class instantiates by invoking its constructors.ID="ch1070""What Is Destroyed"Displays classes that the current class destroys by invoking its destructors.ID="ch1071"ID="ch1072""What Is Used" submenu (see ID="ch1073"IDREF="27084" TYPE="GRAPHIC"Figure 10-16)FILE="f10qused.gif" POSITION="MARGIN" SCALE="FALSE"LBL="10-16"Figure 10-16 ID="27084""What Is Used" Submenu of Queries Menu
Displays those classes used by the current class in these contexts:"To Contain" highlights classes that the current class uses as either embedded or linked components.ID="ch1074""As Friend" highlights classes that the current class uses as friend classes.ID="ch1075"ID="ch1076""By Methods" highlights classes whose methods are used by the current class.ID="ch1077"ID="ch1078""By Data Access" highlights classes whose data members are assigned, read, or have their address taken by the current class.ID="ch1079"ID="ch1080"Additional queries on subjects, data members, and methods are accessible from popup menus described in IDREF="52089" TYPE="TITLE""C++ Member List" and IDREF="74451" TYPE="TITLE""C++ Relation List".LBL="" HELPID="BrowserPreferenceMenu"Preference MenuThe Preference menu allows you to control how the class information is displayed in the window (see ID="ch1081"IDREF="68081" TYPE="GRAPHIC"Figure 10-17). FILE="ch1016.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-17"Figure 10-17 ID="68081"Preferences MenuThe selections are:"Relation Display" submenu ID="ch1082"ID="ch1083"Allows you to control how the class relations are displayed:"Declaration Order" displays the related classes in order of their declaration or the detection of their relation.ID="ch1084""End To End Sort" displays a sorted list of related classes. "Member Display" submenu ID="ch1085"Allows you to control how the class members are displayed:"Declaration Order" displays the members in order of their declaration.ID="ch1086""End To End Sort" performs an end-to-end sort of the member display strings and displays the result.ID="ch1087""Name Sort" performs a sort based on the name of the members and displays the result.ID="ch1088""Member Alignment" submenuAllows you to control how members line up:"Align Names" aligns the member names in the display. A radio button indicates if this feature is enabled or disabled.ID="ch1089""Align Arglists" aligns the member function argument lists in the display. A radio button indicates if this feature is enabled or disabled.ID="ch1090""Member Double Click" submenuLets you select which related source code is displayed in Source View when you double-click an item in the member list:"Show Definition" displays the source code where the item is defined."Show Declaration" displays the source code where the item is declared."Show Decl if no Defn" displays the code where the item is defined; if there is no definition, then the source code containing the declaration is displayed instead.LBL="" HELPID=""Browser View Popup MenusThe Browser View popup queries menus provide queries for currently selected items in the outline list areas. These menu are accessed by selecting an item and then holding down the right mouse button. IDREF="90090" TYPE="GRAPHIC"Figure 10-18 shows all of the popup menus available in Browser View.This section describes:IDREF="61820" TYPE="TITLE""Data Members Popup Menu"IDREF="50653" TYPE="TITLE""Methods Popup Menu"IDREF="95578" TYPE="TITLE""Class Popup Menus"Many of the same queries in the class popup menus appear in more than one menu. To eliminate this redundancy, each query is described once and presented in a single list rather than by menu.FILE="ch1032.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-18"Figure 10-18 ID="90090"Queries Popup Menus in the C++ Browser ViewLBL="" HELPID="DataMembersPopupMenus"ID="61820"Data Members Popup MenuThe Data Members popup menu performs these queries on data members selected in the member display list:ID="ch1091"ID="ch1092"FILE="f10dataq.gif" POSITION="MARGIN" SCALE="FALSE"LBL="10-19"Figure 10-19 ID="60180"Data Members Popup Menu"What Modifies"Highlights all methods and classes in which the selected data member is assigned a value.ID="ch1093""What Reads"Highlights all methods and classes in which the selected data member is read.ID="ch1094""What Accesses"Highlights all classes where the selected data member is assigned a value, read, or its address is taken.ID="ch1095""What Defines"Highlights the class that defines the selected data member.ID="ch1096""Show Source Where Defined"ID="ch1097"Displays the source code where the data is defined in a Source View window.LBL="" HELPID="MethodsPopupMenus"ID="50653"Methods Popup MenuThe Methods popup menu lets you perform the following queries on methods shown in IDREF="72422" TYPE="GRAPHIC"Figure 10-20.FILE="ch1025.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-20"Figure 10-20 ID="72422"Queries on Methods Popup MenuThe Methods popup menu provides these queries:"What Uses"Highlights all methods and classes that use the currently selected method.ID="ch1098""What Is Used" submenuID="ch1099"Contains these menu items:"All (method and data access)" highlights all data members, methods, and classes the currently selected method uses.ID="ch10100""Method Calls" highlights all methods called by the currently selected method.ID="ch10101""Data Access" highlights all data members that have been assigned, read, or had their address taken by the currently selected method.ID="ch10102""Data Modification" highlights all data members assigned by the currently selected method.ID="ch10103""Data Read" highlights all data members read by the currently selected method.ID="ch10104"ID="86775""Call Graph" submenuID="ch10105"Contains these menu items:"Add" adds the currently selected method and its calling structure to the Call Graph window, if one is open. If not, "Add" opens a Call Graph window before adding the method.ID="ch10106""Replace" replaces all methods in the display with the selected method and its calling structure in the Call Graph window.ID="ch10107""Remove" removes the currently selected method and its calling structure from the Call Graph window.ID="ch10108""What Declares"Highlights the class that declares the currently selected method.ID="ch10109""What Currently Defines"Highlights the class that provides the current definition for the method.ID="ch10110""What Else Defines"Highlights all classes that define the currently selected method."What Overloads"Highlights all methods and classes that overload the currently selected method.ID="ch10111"LBL="" HELPID="ClassPopupMenus"ID="95578"Class Popup MenusThis section describes the popup menus available in the related class list display. These menus are shown in IDREF="90090" TYPE="GRAPHIC"Figure 10-18. (Note that the queries menu that displays when you select <-This is not shown here; it's exactly the same as the main Queries menu shown in IDREF="69057" TYPE="GRAPHIC"Figure 10-14.) Many of the items in the class popup menus are common to more than one menu. To eliminate the redundancy of describing them in each menu, this section presents all the queries in a single list in alphabetical order. The menus they belong to are shown in parentheses. Here are the menu items:"New Browser View" (all menus except Friend Functions)Opens a new Browser View window displaying the selected class.ID="ch10112""Show Source" (all menus)Opens a Source View window on a file containing the declaration of the selected item. The first line of the declaration is highlighted in the source.ID="ch10113""What Destroys" (Uses and Used By)Highlights all members of the current class that destroy the selected class. ID="ch10114"ID="ch10115""What Instantiates" (Uses and Used By) Highlights all members of the current class that instantiate the selected class.ID="ch10116""What Is Declared" (Base Classes)Highlights all methods declared by the selected base class.ID="ch10117""What Is Defined" (Base Classes)Highlights all members defined by the selected base class.ID="ch10118""What Is Overloaded" (Derived Classes)Highlights all members of the current class that are overloaded by the selected class.ID="ch10119""What Is Overridden" (Base Classes)Highlights all the methods of the selected base class that are overridden by the current class."What Is Overridden" (Derived Classes)Highlights all the methods of the current class that are overridden by the selected derived class."What Is Used" (Friends)Highlights all members of the current class that the selected friend class uses.ID="ch10120""What Is Used" (Derived Classes and Used By Classes)ID="ch10121"FILE="f10cused.gif" POSITION="MARGIN" SCALE="FALSE"LBL="10-21"Figure 10-21 ID="48485""What Is Used" SubmenuCurrent Class Pop-Up Menu
Contains these queries in the submenu (see IDREF="48485" TYPE="GRAPHIC"Figure 10-7):"by Accessing Any Member" highlights all members (of the current class) that the selected class uses.ID="ch10122""by Calling Methods" highlights all methods (of the current class) that the selected class uses.ID="ch10123""by Accessing Data Members" highlights all data members (of the current class) that the selected class modifies, reads, or takes the address of.ID="ch10124""by Modifying Data Members" highlights all data members (of the current class) to which the selected class assigns a value.ID="ch10125""by Reading Data Members" highlights all data members (of the current class) from which the selected class reads a value.ID="ch10126""What It Uses" (Friend Function)Highlights all members of the current class that the selected friend function uses.ID="ch10127""What Uses" (Friend of Class)Highlights all members of the current class that use the friend class.ID="ch10128""What Uses" submenu (Uses Classes)ID="ch10129"Contains these queries in the submenu (see IDREF="48485" TYPE="GRAPHIC"Figure 10-7):FILE="f10cuses.gif" POSITION="MARGIN" SCALE="FALSE"LBL="10-22"Figure 10-22 ID="48485""What Uses" SubmenuCurrent Class Pop-Up Menu"by Accessing Any Member" highlights all members (of the current class) that use the selected class.ID="ch10130""by Calling Methods" highlights all methods (of the current class) that use the methods of the selected class.ID="ch10131""by Accessing Data" highlights all data members (of the current class) that modify, read, or take the address of data members of the selected class.ID="ch10132""by Modifying Data" highlights all data members (of the current class) that assign a value to data members of the selected class.ID="ch10133""by Reading Data" highlights all data members (of the current class) that read a value from data members of the selected class.LBL="" HELPID="GraphViewsWindow"ID="20193"Graph Views WindowThe Browser provides the Graph Views window, a graphical view for showing relationships between classes in the fileset (see ID="ch10134"IDREF="36592" TYPE="GRAPHIC"Figure 10-23). It depicts classes as nodes and relationships as arcs. The Graph Views window can show four types of class relationships:InheritanceContainmentInteractionFriendsFILE="ch1010.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-23"Figure 10-23 ID="36592"Graph Views Window Showing Inheritance RelationshipsLBL="" HELPID=""Setting Graph Views RelationshipsYou can display the graphical views by selecting any of the following items from the Views menu of the Browser View window:"Show Inheritance Graph""Show Containment Graph""Show Interaction Graph""Show Friends Graph"Once the Graph Views window is displayed, you can switch to any of the other relationships by using the Relationship menu at the bottom right of the Graph Views window (see IDREF="36592" TYPE="GRAPHIC"Figure 10-23).LBL="" HELPID="GraphViewsAdminMenu"Graph Views Admin MenuFILE="savegr.gif" POSITION="MARGIN" SCALE="FALSE"LBL="10-24"Figure 10-24 ID="65007""Save Graph" Submenu of Admin Menu
The Graph Views Admin menu contains two commands: "Save Graph"Allows you to save the graph to a file. It brings up the file selection dialog shown in IDREF="65007" TYPE="GRAPHIC"Figure 10-24. When you select your file and click OK, you save the graph as a PostScript“ file with the name specified in "Selection.""Close" Closes the Graph Views window.LBL="" HELPID="GraphViewsWindowViewsMenu"Graph Views Window Views MenuThe Graph Views window Views menu (see IDREF="36592" TYPE="GRAPHIC"Figure 10-23) commands control which classes included in the current fileset are displayed in the Graph Views window. The choices are:"Show All"Displays all classes included in the fileset as nodes, and their relations as arcs, as chosen from the relationship option menu.ID="ch10135""Show All Related"Displays only those classes included in the chain of relations, which includes the current class.ID="ch10136""Show Butterfly"Displays only those classes that are the immediate relatives (for example, parents and children for an inheritance relation of the current class).ID="ch10137"LBL="" HELPID=""Mouse ManipulationsDouble-clicking any subject in the Graph Views window causes it to become the new current subject in both the Browser View and Graph Views windows.LBL="" HELPID="CallGraphWindow"ID="52924"Call Graph WindowThe Call Graph window shows all calls made from selected methods in the member list, including calls made from its target methods. You can invoke it by ID="ch10138"selecting "Call Graph" from the Views menu in Browser Viewselecting a method in the member list, displaying the Methods popup menu, and selecting "Call Graph:Add." This displays the Call Graph window the first time and adds new methods to the graph each time you select "Call Graph:Add."IDREF="37535" TYPE="GRAPHIC"Figure 10-25 illustrates the second method for displaying Call Graph. The user has selected the initialize method in the Browser window and then selected "CallGraph:Add" from the Methods popup menu. The initialize method now appears in the Call Graph window with the methods that it calls.FILE="ch107.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-25"Figure 10-25 ID="37535"Displaying a Selected Method in Call GraphLBL="" HELPID="CallGraphControls"Using the Call Graph WindowYou add, replace, or remove methods in the Call Graph by choosing from the Call Graph submenu in the Methods popup menu in the Browser View member list (see ID="ch10139"IDREF="37535" TYPE="GRAPHIC"Figure 10-25), as follows:"Add" adds the currently selected method and its calling structure to the Call Graph window, if one is open. If not, "Add" opens a Call Graph window and then adds the method.ID="ch10140""Replace" replaces all methods in the display with the selected method and its calling structure in the Call Graph window.ID="ch10141""Remove" removes the currently selected method and its calling structure from the Call Graph window.ID="ch10142"The action you request is displayed in the message area in Browser View. In the Call Graph window, there is also a message area that identifies the method and its arguments. ID="ch10143"In the Call Graph window, double-clicking any method node opens a Source View window displaying the code that defines the method. The definition is highlighted in the source.ID="ch10144"ID="ch10145"ID="ch10146"For information on manipulating graphs, see IDREF="95481" BOOK="WrkShp_OV" FILE="appa.doc" HDG=""Appendix A, "Using Graphical Views," in the ProDev WorkShop Overview.LBL="" HELPID="CallGraphAdminMenu"Call Graph Admin MenuThe Call Graph window's Admin menu contains the following selections:"Show Arglist" toggleLets you display or hide the argument list for each method, as shown in ID="ch10147"IDREF="37535" TYPE="GRAPHIC"Figure 10-25. "Clear"Removes all methods from the Call Graph window.ID="ch10148""Save Graph"Displays a file selection dialog for saving the graph to a PostScript file. "Close"Closes the Call Graph window.LBL="A"ID="90006"Customizing the C++ BrowserThe C++ Browser lets you customize your display and the way you work with reference pages (man pages). These formats are implemented as X application resources that you can redefine in your local ID="appa1"ID="appa2"ID="appa3".Xdefaults file. After editing it, runID="appa4" xrdb .Xdefaults and then reopen the Static Analyzer.This appendix covers these topics:IDREF="42084" TYPE="TITLE""Customizing the Browser View Lists"IDREF="94559" TYPE="TITLE""Customizing Reference Page Generation"LBL="" HELPID=""ID="42084"Customizing the Browser View ListsThis section shows you how to customize the outline formats of Browser View lists by applying your own keyword headers and rearranging the features of each list.ID="appa5"LBL="" HELPID=""Member List ResourceThe layout of the Browser View member list is controlled by this resource:ID="appa6"Cvstatic*memberOrderThe general format of this resource is as follows:Level-1-keyword: HEADING [keyword], HEADING [keyword],..; Level-2-keyword: HEADING [keyword], HEADING [keyword],...; Level-3-keyword: HEADING [keyword], HEADING [keyword],...;The three level keywords are Protection, Scope, and Member. The order in which these are used determines the level of nesting in the outline list used for protection, scope, and member headings, respectively. Headings may consist of any string you choose to describe the heading category. The headings listed with the level-1 keyword become top-level headings in the outline list, the level-2 headings appear indented under each of the level-1 headings, and the level-3 headings appear indented beneath each of the level-2 headings. Each heading in a level has an associated keyword that determines the sort of items that appear under the heading. The allowable keywords are as follows for each associated level keyword:Protection:[public], [protected], [private]Scope:[instance], [static]Member:[type], [data], [method], [virtualmethod]It is also possible to combine the types associated with two or more keywords under one heading by using the construction for any given heading:HEADING [keyword1+keyword2+...]You can also control whether a heading is expanded or collapsed when the browser starts up. Placing an asterisk (*) at the end of the heading string causes that heading to be collapsed by default:HEADING* [keyword]The default assignment for the outline resource of the member list can be found in /usr/lib/X11/app-defaults/Cvstatic. The contents of the file appear below:Cvstatic*memberOrder:  Protection: PUBLIC [public], PROTECTED* [protected], PRIVATE* [private]; Scope: INSTANCE [instance], STATIC [static]; Member: TYPE* [type], DATA [data], METHODS [method], VIRTUAL_METHODS [virtualmethod];NoteThe sample above is a single line.You can override this definition by placing your own definition in your local .Xdefaults file. For example, to make the display look like the sample in IDREF="16809" TYPE="GRAPHIC"Figure A-1, add this line:Cvstatic*memberOrder: Member: IS (Type) [type], Data Members--------------------- [data],Methods----------------------------- [method], VirtualMethods-------------------- [virtualmethod]; Scope:Non-Static [instance], Static [static]; Protection: Private[private], Protected [protected], Public [public];LBL="" HELPID=""Related Class List ResourceThe layout of the Browser View related class list is controlled by this resource:ID="appa7"Cvstatic*relationOrderThe construction of this resource is similar to the member list, but simpler:HEADING [keyword], HEADING [keyword],...The headings and keywords work as described for the member list, but there is no concept of level keywords in the related class list.The allowable keywords for the related class list are as follows:[base], [derived], [uses], [usedby], [friendfunction], [friend], [friendof]NoteIn the related class list, headings cannot contain multiple keywords, as they can in the member list. As in the member list, you can control whether a heading in the related class list is expanded or collapsed when the browser starts up. Placing an asterisk (*) at the end of the heading string causes that heading to be collapsed by default:HEADING* [keyword]The default assignment for the related class list outline resource can be found in /usr/lib/X11/app-defaults/Cvstatic, and is listed below for your convenience:Cvstatic*relationOrder: BASE CLASSES [base], DERIVED CLASSES [derived], USES [uses], USED BY [usedby], FRIEND FUNCTIONS [friendfunction], FRIENDS [friend], FRIEND OF [friendof]You can override this definition by placing your own definition in your local .Xdefaults file. For example, for the display shown in IDREF="16809" TYPE="GRAPHIC"Figure A-1, try this:Cvstatic*relationOrder: Parent Classes [base], Child Classes [derived], Used Classes [uses], User Classes [usedby], Friend Functions [friendfunction], Friend Classes [friend], Friend Of [friendof]LBL="" HELPID=""Other Browser View List ResourcesXWindows resources listed in this section, found in /usr/lib/X11/app-defaults/Cvstatic, can be modified in your local .Xdefaults file. The default values are listed with each resource. You can set any true value to false.Cvstatic*completeClassName: trueenables ClassName completion; by typing a space in the current class field, you complete a class name from the list of classes in the fileset (if set to true, as it is by default).Cvstatic*showMessageArea: trueenables the message area in the Browser View window (if set to true, as it is by default).Cvstatic*scream: trueenables warning beeps when there are 0 results for a query, or when a class name has more than one completion in the current class field (if set to true, as it is by default).Cvstatic*indentationWidth: 15sets the indentation in the outline lists in pixels. IDREF="16809" TYPE="GRAPHIC"Figure A-1 shows the making the following change to the resource:Cvstatic*indentationWidth: 10Cvstatic*nameAlign: truealigns names of the members under the same parent so that the type declarations and member (variable and function) names form left-justified columns (if set to true, as it is by default).Cvstatic*arglistAlign: truealigns the argument lists of member functions under the same parent so they form a left-justified column (if set to true, as it is by default).Cvstatic*sort: true sorts items in the outline lists based on the value of the entire string denoting an item (if set to true, as it is by default). For example, given two members, void f and int k, the C++ Browser lists int k before void f in the list.Cvstatic*nameSort: truesorts items in the outline lists based on the string value of the name of a member (if set to true, as it is by default). For example, void f would be listed before int k).Using both of the previous resources in conjunction sorts first by type and then by name, as shown in IDREF="75361" TYPE="TABLE"Table A-1.COLUMNS="3"LBL="A-1"Table A-1 ID="75361" Sort Resources for Outline ListsLEFT="0" WIDTH="43"sortLEFT="50" WIDTH="45"nameLEFT="100" WIDTH="240"Sort effectLEFT="0" WIDTH="43"falseLEFT="50" WIDTH="45"falseLEFT="100" WIDTH="240"Members are in declaration orderLEFT="0" WIDTH="43"falseLEFT="50" WIDTH="45"trueLEFT="100" WIDTH="240"Members are sorted based on the name and not on type or 
return type. This behavior is shown in IDREF="16809" TYPE="GRAPHIC"Figure A-1.LEFT="0" WIDTH="43"trueLEFT="50" WIDTH="45"falseLEFT="100" WIDTH="240"Members are sorted based on the their return type or type. 
Within the same return type, members appear in 
declaration order.LEFT="0" WIDTH="43"trueLEFT="50" WIDTH="45"trueLEFT="100" WIDTH="240"Members are sorted both on their type or return type and 
their name. This is the default behavior.IDREF="16809" TYPE="GRAPHIC"Figure A-1 shows the Browser View display using the sample resources set in .Xdefaults.FILE="appa.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-1"Figure A-1 ID="16809"Customized Browser View DisplayLBL="" HELPID=""ID="94559"Customizing Reference Page GenerationThe resources in this section are associated with the Man Pages for Classes window, available from the Browser View Admin menu item "Generate Man Pages."ID="appa8"Cvstatic*manPageDirPath: <default manpage directory path> The default is the current directory (.). To place generated reference pages in the windTunnel directory (that you have created) use this:Cvstatic*manPageDirPath: ./manpage/windTunnelCvstatic*manPageSuffix: .<suffix> The default <suffix> is 3. The name of a reference page is <class_name>.3. To change the suffix to 4, use this:Cvstatic*manPageSuffix: .4Cvstatic*manPageViewCommand: <commands>Pressing the View button in the Man Pages for Classes window executes the command specified by this resource. The argument given is the set of reference pages for the classes that are selected. By default, View displays the most recently generated reference page in a read-only window. The default commands are:Cvstatic*manPageViewCommand: winterm -H -c man -dCvstatic*manPageCopyRightMessage: <string> The default string is "Copyright 1994 by Silicon Graphics." A customized example is:Cvstatic*manPageCopyRightMessage: Copyright 1994 by Fred Smythe"Class Tree View" selection in Static Analyzer Views menuIDREF="ch0537"Class Tree View"File Dependency View" selection in Static Analyzer Views menuIDREF="ch0539"Class Tree View"Find Regular Expression" selection in the QueriesGeneral submenuIDREF="ch0419"General Queries"Find String" selection in the QueriesGeneral submenuIDREF="ch0418"General Queries"Force Scan" selection in Queries menuIDREF="ch0221"Other Static Analyzer Features"General Options" selection in Static Analyzer Admin menuIDREF="ch058"Viewing Full Pathnames for Files"General Options..." selection in Queries menuIDREF="ch0222"Other Static Analyzer Features"List All Classes" selection in the QueriesClasses submenuIDREF="ch0453"Class Queries"List All Common Blocks" selection in the QueriesCommon Blocks submenuIDREF="ch0463"Common Blocks Queries"List All Constants" selection in the QueriesGeneral submenuIDREF="ch0415"General Queries"List All Files" selection in the QueriesFiles submenuIDREF="ch0447"Files Queries"List All Functions" selection in the QueriesFunction submenuIDREF="ch0437"Function Queries"List All Global Variables" selection in the QueriesVariables submenuIDREF="ch0427"Variable Queries"List All Header Files" selection in the QueriesFiles submenuIDREF="ch0448"Files Queries"List All Macros" selection in the QueriesMacro submenuIDREF="ch0421"Macro Queries"List All Methods" selection in the QueriesMethods submenuIDREF="ch0459"Method Queries"List All Symbols in Common Block" selection in the QueriesCommon Blocks submenuIDREF="ch0464"Common Blocks Queries"List All Types" selection in the QueriesTypes submenuIDREF="ch0468"Types Queries"List Data of Type" selection in the QueriesTypes submenuIDREF="ch0471"Types Queries"List Directories" selection in the QueriesDirectories submenuIDREF="ch0474"Directories Queries"List Files" selection in the QueriesDirectories submenuIDREF="ch0475"Directories Queries"List Functions of Type" selection in the QueriesTypes submenuIDREF="ch0470"Types Queries"List Global Symbols" selection in the QueriesGeneral submenuIDREF="ch0414"General Queries"List Local Declarations" selection in the QueriesFunction submenuIDREF="ch0445"Function Queries"List Matching Files" selection in the QueriesFiles submenuIDREF="ch0449"Files Queries"List Methods In Class" selection in the QueriesClasses submenuIDREF="ch0457"Class Queries"List Subclasses" selection in the QueriesClasses submenuIDREF="ch0455"Class Queries"List Superclasses" selection in the QueriesClasses submenuIDREF="ch0456"Class Queries"List Undefined" selection in the QueriesFunction submenuIDREF="ch0443"Function Queries"List Unused Function" selection in the QueriesFunction submenuIDREF="ch0444"Function Queries"List Unused Macros" selection in the QueriesMacro submenuIDREF="ch0425"Macro Queries"List Unused Variables" selection in the QueriesVariables submenuIDREF="ch0433"Variable Queries"Member Display" submenu"Name Sort"IDREF="ch1088"Preference Menu"Rescan" selection in Queries menuIDREF="ch0220"Other Static Analyzer Features"Results Filter" selection in Static Analyzer Admin menuIDREF="ch0545"Setting Results Filters"Save Query..." selection in Queries menuIDREF="ch0224"Other Static Analyzer Features"Save Query..." selection Static Analyzer Admin menuIDREF="ch0486"Saving Query Results"Set Include Path..." selection in Queries menuIDREF="ch0223"Other Static Analyzer Features"Show Inheritance Graph" selection in Class View Views menuIDREF="ch1045"Views Menu"Sort" selection in Static Analyzer Admin menuIDREF="ch0511"Sorting Elements in Text View"To Contain""What Is Used" submenuIDREF="ch1074"Main Queries Menu"What Is Used" submenuin Class View Queries menuIDREF="ch1073"Main Queries Menu"Where Address Taken" selection in the QueriesVariables submenuIDREF="ch0432"Variable Queries"Where Allocated" selection in the QueriesVariables submenuIDREF="ch0434"Variable Queries"Where Common Block Defined" selection in the QueriesCommon Blocks submenuIDREF="ch0465"Common Blocks Queries"Where Common Block Used" selection in the QueriesCommon Blocks submenuIDREF="ch0466"Common Blocks Queries"Where Deallocated" selection in the QueriesVariables submenuIDREF="ch0435"Variable Queries"Where Declared?" selection in the QueriesMethods submenuIDREF="ch0461"Method QueriesVariables submenuIDREF="ch0428"Variable Queries"Where Defined?" selection in the QueriesClasses submenuIDREF="ch0454"Class QueriesFunction submenuIDREF="ch0439"Function QueriesGeneral submenuIDREF="ch0417"General QueriesMacro submenuIDREF="ch0422"Macro QueriesMethods submenuIDREF="ch0460"Method QueriesVariables submenuIDREF="ch0429"Variable Queries"Where Function Declared" selection in the QueriesFunction submenuIDREF="ch0438"Function Queries"Where Function Used" selection in the QueriesFunction submenuIDREF="ch0440"Function Queries"Where Symbol Used?" selection in the QueriesGeneral submenuIDREF="ch0416"General Queries"Where Type Defined" selection in the QueriesTypes submenuIDREF="ch0469"Types Queries"Where Type Used" selection in the QueriesTypes submenuIDREF="ch0472"Types Queries"Where Undefined?" selection in the QueriesMacro submenuIDREF="ch0423"Macro Queries"Where Used?" selection in the QueriesMacro submenuIDREF="ch0424"Macro Queries"Who Calls?" selection in the QueriesFunction submenuIDREF="ch0441"Function Queries"Who Includes?" selection in the QueriesFiles submenuIDREF="ch0450"Files Queries"Who Is Called By?" selection in the QueriesFunction submenuIDREF="ch0442"Function Queries"Who is Included By?" selection in the QueriesFiles submenuIDREF="ch0451"Files Queries"Who References?" selection in the QueriesVariables submenuIDREF="ch0430"Variable Queries"Who Sets?" selection in the QueriesVariables submenuIDREF="ch0431"Variable Queries"Add" to Call GraphIDREF="ch10140"Using the Call Graph WindowIDREF="ch10106"Methods Popup Menu"Align Arglists"IDREF="ch1090"Preference Menu"Align Names"IDREF="ch1089"Preference Menu"All (method and data access)" used by methodIDREF="ch10100"Methods Popup Menu"Another Class View" selection in Class View Admin menuIDREF="ch1038"Admin Menu"As Friend"IDREF="ch1066"Main Queries Menu"As Friends"IDREF="ch1075"Main Queries Menu"by Accessing Any Member" of classIDREF="ch10130"Class Popup Menus"by Accessing Any Member" used by derived classIDREF="ch10122"Class Popup Menus"by Accessing Data Members" used by derived classIDREF="ch10124"Class Popup Menus"by Accessing Data" of classIDREF="ch10132"Class Popup Menus"by Calling Methods" of classIDREF="ch10131"Class Popup Menus"by Calling Methods" used by derived classIDREF="ch10123"Class Popup Menus"By Data Access"IDREF="ch1079"Main Queries Menu"By Method Calls"IDREF="ch1077"Main Queries Menu"by Modifying Data Members" by derived classIDREF="ch10125"Class Popup Menus"by Modifying Data" of classIDREF="ch10133"Class Popup Menus"by Reading Data Members" by derived classIDREF="ch10126"Class Popup Menus"Call Graph" submenuIDREF="ch10105"Methods Popup MenuCall Graph window andIDREF="ch1050"Views Menu"Change Current Class" selection in Class View Admin menuIDREF="ch1036"Admin Menu"Clear" selection in Call Graph Admin menuIDREF="ch10148"Call Graph Admin Menu"Close Class View" selection in Class View Admin menuIDREF="ch1039"Admin Menu"Data Access" by methodIDREF="ch10102"Methods Popup Menu"Data Members"IDREF="ch1069"Main Queries Menu"Data Modification" by methodIDREF="ch10103"Methods Popup Menu"Data Read" by methodIDREF="ch10104"Methods Popup Menu"Edit Fileset" selection in Static Analyzer Admin menuIDREF="ch095"Setting Up the Sample SessionIDREF="ch085"Setting Up the Sample Session"Exit Browser" selection in Class View Admin menuIDREF="ch1042"Web Page Generation"Generate Man Pages" selection in Class View Admin menuIDREF="ch1041"Man Page Generation"Member Display" submenuIDREF="ch1085"Preference Menu"Declaration Order"IDREF="ch1086"Preference Menu"End To End Sort"IDREF="ch1087"Preference Menu"Method Calls" by methodIDREF="ch10101"Methods Popup Menu"Methods"IDREF="ch1068"Main Queries Menu"New Class View"IDREF="ch10112"Class Popup Menus"Relation Display" submenuIDREF="ch1083"Preference Menu"Declaration Order"IDREF="ch1084"Preference Menu"End To End Sort"IDREF="ch1082"Preference Menu"Remove" method in Call GraphIDREF="ch10142"Using the Call Graph WindowIDREF="ch10108"Methods Popup Menu"Replace" method in Call GraphIDREF="ch10141"Using the Call Graph WindowIDREF="ch10107"Methods Popup Menu"Show All Related" selection of Class Graph Views menuIDREF="ch10136"Graph Views Window Views Menu"Show All" selection of Class Graph Views menuIDREF="ch10135"Graph Views Window Views Menu"Show Arg List" toggle in Call Graph Admin menuIDREF="ch10147"Call Graph Admin Menu"Show Butterfly" selection of Class Graph Views menuIDREF="ch10137"Graph Views Window Views Menu"Show Call Graph" selection in Class View Views menuIDREF="ch1049"Views Menu"Show Containment Graph" selection in Class View Views menuIDREF="ch1046"Views Menu"Show Friend Graph" selection in Class View Views menuIDREF="ch1048"Views Menu"Show Interaction Graph" selection in Class View Views menuIDREF="ch1047"Views Menu"Show Previous Class" selection in Class View History menuIDREF="ch1053"History Menu"Show Source"IDREF="ch10113"Class Popup Menus"To Contain""What Uses" submenuIDREF="ch1065"Main Queries Menu"What Accesses" data membersIDREF="ch1095"Data Members Popup Menu"What Currently Defines" methodIDREF="ch10110"Methods Popup Menu"What Declares" methodIDREF="ch10109"Methods Popup Menu"What Defines" data membersIDREF="ch1096"Data Members Popup Menu"What Destroys" classIDREF="ch10114"Class Popup Menus"What Destroys" selection in Class View Queries menuIDREF="ch1062"Main Queries Menu"What Instantiates" classIDREF="ch10116"Class Popup Menus"What Instantiates" selection in Class View Queries menuIDREF="ch1060"Main Queries Menu"What Is Declared" by base classIDREF="ch10117"Class Popup Menus"What is Declared" selection in Class View Queries menuIDREF="ch1056"Main Queries Menu"What Is Defined" by base classIDREF="ch10118"Class Popup Menus"What Is Defined" selection in Class View Queries menuIDREF="ch1057"Main Queries Menu"What Is Destroyed" selection in Class View Queries menuIDREF="ch1071"Main Queries Menu"What Is Instantiated" selection in Class View Queries menuIDREF="ch1070"Main Queries Menu"What Is Overloaded" by derived classIDREF="ch10119"Class Popup Menus"What is Overridden By"IDREF="ch1058"Main Queries Menu"What Is Used" by friend classIDREF="ch10120"Class Popup Menus"What Is Used" submenuIDREF="ch10121"Class Popup MenusQueries on Methods pop-up IDREF="ch1099"Methods Popup Menu"What It Uses"IDREF="ch10127"Class Popup Menus"What Modifies" data membersIDREF="ch1093"Data Members Popup Menu"What Overloads" methodIDREF="ch10111"Methods Popup Menu"What Reads" data membersIDREF="ch1094"Data Members Popup Menu"What Uses" friend classIDREF="ch10128"Class Popup Menus"What Uses" methodsIDREF="ch1098"Methods Popup Menu"What Uses" submenu in Class View Queries menuIDREF="ch1064"Main Queries Menu? in Current Class fieldIDREF="ch103"Changing Subject Using "?"access specificationIDREF="ch1030"Display HierarchyIDREF="ch1015"Display HierarchyAll Defined view optionIDREF="ch0531"Setting View OptionsIDREF="ch0623"Viewing Suggestionsannotated scroll barsIDREF="ch1011"Annotated Scroll Bars and Highlighted EntriesarcsIDREF="ch0516"Call Tree Viewargument listIDREF="ch10143"Using the Call Graph Windowbase classessublistIDREF="ch1028"Base Classes Category Hierarchybatch command-line optionIDREF="ch0341"Rescanning the FilesetIDREF="ch0611"Setting Up a Project Databasebrowsing directoryIDREF="ch036"Specifying PathnamesC++ BrowsercustomizingIDREF="appa1"Customizing the C++ BrowserCall Graph windowIDREF="ch10138"Call Graph Windowcall tree viewIDREF="ch0512"Call Tree ViewtutorialIDREF="ch0535"Tutorial: Working in Call Tree ViewCall Tree View selection in Static Analyzer Views menuIDREF="ch0514"Call Tree ViewChange Fileset commandIDREF="ch0348"Changing to a New Fileset and Working DirectoryIDREF="ch0316"Using the Fileset Editorchooser windowList of ClassesIDREF="ch071"Starting Browser ViewIDREF="ch1037"Admin MenuClass Graph windowIDREF="ch10134"Graph Views Windowclass queriesIDREF="ch0452"Class Queriesclass tree viewIDREF="ch0215"Tutorial 2: Applying the Static Analyzer to Parsed C++ FilesIDREF="ch0536"Class Tree ViewClass ViewIDREF="ch101"Browser View WindowAdmin menuIDREF="ch1035"Admin MenuHistory menuIDREF="ch1051"History Menumember listIDREF="ch1013"C++ Member Listmessage areaIDREF="ch107"Browser View Query Identification Areaoutline listsIDREF="ch109"Browser View List AreasPreference menuIDREF="ch1081"Preference MenuViews menuIDREF="ch1043"Views Menucommon block queriesIDREF="ch0462"Common Blocks QueriesComplete Tree view optionIDREF="ch0532"Setting View OptionsIDREF="ch0624"Viewing SuggestionsConstrain buttonIDREF="ch0556"Filtering by Name, Function, File, and Sourcecross-reference databaseIDREF="ch025"Tutorial 1: Applying the Static Analyzer to Scanned FilesIDREF="ch012"How the Static Analyzer Workscreating a project databaseIDREF="ch0610"Setting Up a Project DatabaseindexIDREF="ch0343"Rescanning the Filesetquerying a project databaseIDREF="ch0617"Querying a Project Databaseshared for projectIDREF="ch068"Applying Group Analysis Techniquescurrent class<-ThisIDREF="ch1024"C++ Relation ListCurrent Class fieldIDREF="ch102"Current Subject FieldcustomizingC++ Browser resourcesIDREF="appa2"Customizing the C++ Browsercvstatic.filesetIDREF="ch038"Specifying Included FilesIDREF="ch0612"Setting Up a Project DatabaseIDREF="ch0310"Using the Default Filesetcvstatic.indexIDREF="ch0614"Setting Up a Project DatabaseIDREF="ch027"Tutorial 1: Applying the Static Analyzer to Scanned Filescvstatic.postingIDREF="ch0616"Setting Up a Project DatabaseIDREF="ch028"Tutorial 1: Applying the Static Analyzer to Scanned FilesIDREF="ch0615"Setting Up a Project Databasecvstatic.xrefIDREF="ch026"Tutorial 1: Applying the Static Analyzer to Scanned FilesIDREF="ch0613"Setting Up a Project Databasedata membersqueriesIDREF="ch1092"Data Members Popup Menu used by current classIDREF="ch1080"Main Queries Menudatabasecreating for sample sessionIDREF="ch084"Setting Up the Sample SessionIDREF="ch094"Setting Up the Sample Sessiondatabase, see cross-reference databaseIDREF="ch012"How the Static Analyzer Worksderived classessublistIDREF="ch1029"Derived Classes Category HierarchydestroyclassIDREF="ch10115"Class Popup MenusclassesIDREF="ch1072"Main Queries Menucurrent classIDREF="ch1063"Main Queries MenuDirectory filterIDREF="ch0552"Setting Results Filtersdirectory queriesIDREF="ch0473"Directories Queriesdouble-clickingCall Graph nodeIDREF="ch10144"Using the Call Graph Windowopening Source ViewIDREF="ch1031"Displaying a Member's Source CodeIDREF="ch1020"Displaying a Member's Source Coderelated class list entriesIDREF="ch1025"C++ Relations List Mouse ShortcutsEdit Fileset commandIDREF="ch0313"Using the Fileset EditorExclude buttonIDREF="ch0557"Filtering by Name, Function, File, and SourceExternal Functions filterIDREF="ch066"Using the Results Filter to Focus QueriesIDREF="ch0554"Setting Results FiltersFile Dependency ViewIDREF="ch0216"Tutorial 2: Applying the Static Analyzer to Parsed C++ Filesusing to view function callsIDREF="ch0628"Viewing SuggestionsFile filterIDREF="ch0550"Setting Results Filtersfile queriesIDREF="ch0446"Files QueriesfilesetIDREF="ch031"Static Analyzer: Creating a Fileset and Generating a DatabasechangingIDREF="ch0347"Changing to a New Fileset and Working DirectorycreatingIDREF="ch0312"Using the Fileset Editorby handIDREF="ch0326"Creating a Fileset Manually for sample sessionIDREF="ch093"Setting Up the Sample SessionIDREF="ch083"Setting Up the Sample Sessionfrom executableIDREF="ch0332"Using Command-Line Options to Create and Use a Filesetwith a shell scriptIDREF="ch062"Creating a Fileset Using a Shell Scriptwith command-line optionIDREF="ch0328"Using Command-Line Options to Create and Use a Filesetwith UNIX find commandIDREF="ch0327"Creating a Fileset Manually customIDREF="ch023"Tutorial 1: Applying the Static Analyzer to Scanned Filescustomizing for code modulesIDREF="ch063"Customizing the Fileset for Individual Code ModulesdefaultIDREF="ch039"Using the Default FilesetIDREF="ch022"Tutorial 1: Applying the Static Analyzer to Scanned Filesfilename extensionsIDREF="ch0311"Using the Default Filesetfilenames inIDREF="ch021"Tutorial 1: Applying the Static Analyzer to Scanned Filesparser modeIDREF="ch0337"Parser Modepathnames inIDREF="ch034"Using Regular Expressionspersonal and projectIDREF="ch069"Applying Group Analysis Techniquesscanner modeIDREF="ch0335"Scanner ModescanningIDREF="ch024"Tutorial 1: Applying the Static Analyzer to Scanned FilesIDREF="ch0338"Rescanning the FilesetspecificationsIDREF="ch032"Fileset Specificationsspecifying with command-line optionIDREF="ch0333"Using Command-Line Options to Create and Use a FilesetupdatingIDREF="ch0336"Scanner Modeusing shell expansion charactersIDREF="ch034"Using Regular Expressionsfileset command-line optionIDREF="ch0619"Querying a Project DatabaseFileset EditorIDREF="ch0312"Using the Fileset EditorAdd Files buttonIDREF="ch0325"Adding Filenames From ListsBrowsing Directory text areaIDREF="ch0322"Browsing Directorybrowsing for contentsIDREF="ch0320"Browsing for Fileset ContentsCurrent Fileset text areaIDREF="ch0314"Using the Fileset EditorDirectories listIDREF="ch0321"Directories ListFiles listIDREF="ch0323"Language Filtersfilter buttonsIDREF="ch0324"Language Filtersliteral entryIDREF="ch0318"Adding Lines to the Fileset Contents Listremoving entriesIDREF="ch0319"Removing Lines From the Fileset Listswild card entryIDREF="ch0317"Adding Lines to the Fileset Contents ListForce Scan commandIDREF="ch0340"Rescanning the FilesetfriendclassesIDREF="ch1076"Main Queries Menucurrent classIDREF="ch1067"Main Queries MenuFunction filterIDREF="ch0549"Setting Results Filtersfunction queriesIDREF="ch0436"Function QueriesGeneral OptionscommandIDREF="ch0480"Alternate Text EditorsIDREF="ch049"Case Sensitivitydialog boxIDREF="ch0410"Case SensitivityIDREF="ch059"Viewing Full Pathnames for Filesgeneral queriesIDREF="ch0413"General Queriesgenerating man pages for C++ classesIDREF="ch089"Setting Up the Sample SessionGraph OverviewIDREF="ch0521"The Static Analyzer Graph Control PanelHeaders filterIDREF="ch065"Using the Results Filter to Focus QueriesIDREF="ch0553"Setting Results Filtershighlighted member declarationIDREF="ch1022"Displaying a Member's Source CodeIDREF="ch1033"Displaying a Member's Source Codemethod definitionIDREF="ch10146"Using the Call Graph Windowquery resultsIDREF="ch088"Setting Up the Sample SessionIDREF="ch098"Setting Up the Sample SessionHistory menuIDREF="ch0484"Repeating Recent QueriesHistory menu, Class ViewIDREF="ch1052"History MenuInclude buttonIDREF="ch0558"Filtering by Header Files and External Functionsincluded files, searching forIDREF="ch037"Specifying Included FilesIDREF="ch0345"Search Path for Included FilesIncremental Mode view optionIDREF="ch0529"Setting View OptionsIDREF="ch0626"Viewing Suggestionsbuilding a treeIDREF="ch0627"Viewing Suggestionsinherited methodsIDREF="ch1059"Main Queries Menuinstantiatecurrent classIDREF="ch1061"Main Queries MenuLast Query buttonIDREF="ch106"Last Query ButtonList of Classes Shown windowIDREF="ch1054"History Menumacro queriesIDREF="ch0420"Macro QueriesMan Page Generator windowIDREF="ch1040"Man Page Generationman pagescustomizing generationIDREF="appa8"Customizing Reference Page Generationgenerating for C++ classesIDREF="ch0810"Setting Up the Sample Sessionmember listIDREF="ch1014"C++ Member ListresourceIDREF="appa6"Member List Resourcememberstypes displayedIDREF="ch086"Setting Up the Sample SessionIDREF="ch096"Setting Up the Sample Sessionmenu barClass ViewIDREF="ch1034"Browser View Menu Barmessage areaClass ViewIDREF="ch108"Browser View Query Identification Areamethod queriesIDREF="ch0458"Method Queriesmethodsused by current classIDREF="ch1078"Main Queries MenuMultiple Arcs buttonIDREF="ch0522"The Static Analyzer Graph Control Panelmultiple inheritanceIDREF="ch1026"Base Classes Category HierarchyName filterIDREF="ch0548"Setting Results FiltersnodesIDREF="ch0515"Call Tree ViewcolorsIDREF="ch0530"Setting View OptionsIDREF="ch0538"Class Tree Viewhiding and revealingIDREF="ch0526"Setting View Optionsnoindex command-line optionIDREF="ch0342"Rescanning the Filesetoutlinecustomizing displayIDREF="appa5"Customizing the Browser View ListsiconsIDREF="ch1010"Outline Iconsparent classesmultiple inheritanceIDREF="ch1027"Base Classes Category Hierarchyparser modeIDREF="ch0337"Parser Modepop-up menus"What Uses" submenuIDREF="ch10129"Class Popup MenusQueries on Data MembersIDREF="ch1091"Data Members Popup MenuQueries on MethodsCall Graph submenuIDREF="ch10139"Using the Call Graph WindowPreference menuIDREF="ch1081"Preference Menu"Align Arglists"IDREF="ch1090"Preference Menu"Align Names"IDREF="ch1089"Preference Menu"Member Display" submenuIDREF="ch1085"Preference Menu"Relation Display" submenuIDREF="ch1083"Preference Menuprivate membersaccessIDREF="ch1019"Access Categoriesprotected membersaccessIDREF="ch1018"Access Categoriespublic membersaccessIDREF="ch1017"Access CategoriesqueriesIDREF="ch013"How the Static Analyzer WorksIDREF="ch042"Static Analyzer: Queriescase sensitivityIDREF="ch048"Case SensitivitycommandsIDREF="ch0219"Other Static Analyzer FeaturesdefiningIDREF="ch043"Defining the Scope of a QuerymakingIDREF="ch0411"Making a Queryregular expressions, use ofIDREF="ch046"Target Text as a Regular Expressionrelationship to viewsIDREF="ch0217"Tutorial 2: Applying the Static Analyzer to Parsed C++ FilesrepeatingIDREF="ch0483"Repeating Recent Queriessaving the results ofIDREF="ch0485"Saving Query Resultsscope ofIDREF="ch014"How the Static Analyzer Workssearch textIDREF="ch0211"Tutorial 1: Applying the Static Analyzer to Scanned FilesstartingIDREF="ch0210"Tutorial 1: Applying the Static Analyzer to Scanned Filestarget textIDREF="ch045"Defining the Scope of a Querytypes ofIDREF="ch0412"General QueriesIDREF="ch029"Tutorial 1: Applying the Static Analyzer to Scanned FilesqueryC++ code andIDREF="ch087"Setting Up the Sample SessionIDREF="ch097"Setting Up the Sample SessionQueries menu selectionsIDREF="ch1055"Main Queries Menuresult in Static AnalyzerIDREF="ch105"Show in Static Analyzer ToggleQuery Only view optionIDREF="ch0528"Setting View OptionsIDREF="ch0625"Viewing Suggestionsquery results areaIDREF="ch0213"Tutorial 1: Applying the Static Analyzer to Scanned FilesQuery Target text areaIDREF="ch0212"Tutorial 1: Applying the Static Analyzer to Scanned FilesIDREF="ch044"Defining the Scope of a Queryreadonly command-line optionIDREF="ch0618"Querying a Project DatabaseRealign buttonIDREF="ch0523"The Static Analyzer Graph Control Panelregular expressionsIDREF="ch046"Target Text as a Regular ExpressionIDREF="ch047"Target Text as a Regular ExpressionIDREF="ch0547"Setting Results FiltersIDREF="ch035"Using Regular Expressionsrelated class listIDREF="ch1023"C++ Relation ListresourceIDREF="appa7"Related Class List ResourceRescan commandIDREF="ch0339"Rescanning the Filesetresourcescustomizing C++ BrowserIDREF="appa3"Customizing the C++ BrowserResults FilterIDREF="ch0540"The Results Filtercombining filtersIDREF="ch0559"Combining Results Filtersfilter typesIDREF="ch0546"Setting Results FiltersfilteringIDREF="ch0542"The Results Filterseeing scope reduction numbersIDREF="ch0543"The Results Filtersetting filtersIDREF="ch0555"Filtering by Name, Function, File, and SourcetutorialIDREF="ch0560"Tutorial: Using the Results Filterusing with large projectsIDREF="ch064"Using the Results Filter to Focus QueriesRotate buttonIDREF="ch0524"The Static Analyzer Graph Control Panelsample sessionC++ BrowserIDREF="ch092"Using the Browser for Ada: A Sample SessionIDREF="ch082"Using the Browser for C++: A Sample SessionSave Query File BrowserIDREF="ch0487"Saving Query Resultsscanner modeIDREF="ch0335"Scanner ModescopeIDREF="ch1016"Display HierarchyScoping lineIDREF="ch0544"The Results Filterscroll bars, annotatedIDREF="ch1012"Annotated Scroll Bars and Highlighted Entriessearch pathIDREF="ch0344"Rescanning the FilesetSet Include Path and Flags commandIDREF="ch0346"Search Path for Included Filesshell expansion charactersIDREF="ch033"Using Regular ExpressionsShow in Static Analyzer buttonIDREF="ch104"Show in Static Analyzer Toggle"Show Source Where Defined" data queryIDREF="ch1097"Data Members Popup MenuSource filterIDREF="ch0551"Setting Results FiltersSource ViewIDREF="ch016"How the Static Analyzer WorksCall Graph method mode andIDREF="ch10145"Using the Call Graph WindowClass View memberIDREF="ch1032"Displaying a Member's Source CodeIDREF="ch1021"Displaying a Member's Source CodestartingIDREF="ch0534"Viewing Function Definitions and Calls in Source ViewIDREF="ch056"Text ViewIDREF="ch0477"Viewing Source CodeStatic Analyzer highlightsIDREF="ch0478"Viewing Source CodeStatic Analyzerbatch modeIDREF="ch0341"Rescanning the Filesetcommand-line optionsIDREF="ch0330"Using Command-Line Options to Create and Use a Filesetexecutable optionIDREF="ch0331"Using Command-Line Options to Create and Use a Filesetfileset optionIDREF="ch0334"Using Command-Line Options to Create and Use a Filesetgroup analysis techniquesIDREF="ch067"Applying Group Analysis Techniquesorder of activitiesIDREF="ch017"How You Use the Static AnalyzeroverviewIDREF="ch011"Introduction to the WorkShop Static AnalyzerqueriesIDREF="ch041"Static Analyzer: Queriesstarting commandIDREF="ch0329"Using Command-Line Options to Create and Use a Filesetuseswith large programming projectsIDREF="ch061"Static Analyzer: Working on Large Programming Projectsusing alternate text editors withIDREF="ch0479"Alternate Text Editorstext viewIDREF="ch0621"Viewing SuggestionsIDREF="ch052"Text ViewelementsIDREF="ch055"Text ViewfieldsIDREF="ch055"Text Viewfull and short pathnamesIDREF="ch057"Viewing Full Pathnames for FileslabelsIDREF="ch054"Text ViewsortingIDREF="ch0214"Tutorial 1: Applying the Static Analyzer to Scanned Filessorting elementsIDREF="ch0510"Sorting Elements in Text Viewspeed ofIDREF="ch053"Text Viewtree viewsIDREF="ch0622"Viewing Suggestionsnodes and arcsIDREF="ch0513"Call Tree ViewoptionsIDREF="ch0525"Setting View Optionsstarting Source ViewIDREF="ch0533"Viewing Function Definitions and Calls in Source ViewstructureIDREF="ch0513"Call Tree ViewtutorialIDREF="ch0535"Tutorial: Working in Call Tree Viewtype queriesIDREF="ch0467"Types QueriesUse Source View optionIDREF="ch0481"Alternate Text EditorsusingC++ BrowserIDREF="ch091"Using the Browser for Ada: A Sample SessionIDREF="ch081"Using the Browser for C++: A Sample Sessionvariable queriesIDREF="ch0426"Variable Queriesview controlsIDREF="ch0517"The Static Analyzer Graph Control PanelView Options menuIDREF="ch0527"Setting View Optionsviewing source codeIDREF="ch0476"Viewing Source CodeviewportIDREF="ch0218"Tutorial 2: Applying the Static Analyzer to Parsed C++ FilesviewsIDREF="ch051"Static Analyzer: ViewsIDREF="ch015"How the Static Analyzer Workscaution in usingIDREF="ch0225"Other Static Analyzer Featuresrelationship to queriesIDREF="ch0217"Tutorial 2: Applying the Static Analyzer to Parsed C++ Filessetting scopeIDREF="ch0541"The Results Filtersuggestions for large projectsIDREF="ch0620"Viewing SuggestionsViews menu, Class ViewIDREF="ch1044"Views Menuworking directoryIDREF="ch0315"Using the Fileset EditorchangingIDREF="ch0347"Changing to a New Fileset and Working Directory.Xdefaults fileIDREF="appa4"Customizing the C++ BrowserXdefaults fileIDREF="ch0482"Alternate Text EditorsZoom In buttonIDREF="ch0519"The Static Analyzer Graph Control PanelZoom menuIDREF="ch0518"The Static Analyzer Graph Control PanelZoom Out buttonIDREF="ch0520"The Static Analyzer Graph Control Panel