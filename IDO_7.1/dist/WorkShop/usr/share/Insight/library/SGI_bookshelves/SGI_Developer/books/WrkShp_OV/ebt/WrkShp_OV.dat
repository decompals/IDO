#EDIR DATA#
LANG=CDeveloper Magic‘:ProDev‘ WorkShop OverviewDocument Number 007-2582-003CONTRIBUTORSWritten and illustrated by John C. Stearns Production by Laura CooperEngineering contributions by Lia Adams, Jim Ambras, Trevor Bechtel, Wes Embry, Alan Foster, Christine Hanna, David Henke, Marty Itzkowitz, Mahadevan Iyer, Lisa Kvarda, Stuart Liroff, Song Liang, Allan McNaughton, Michey Mehta, Sudhir Mohan, Ashok Mouli, Anil Pal, Andrew Palay, Tom Quiggle, Kim Rachmeler, Jack Repenning, Paul Sanville, Ravi Shankar, John Templeton, Michele Chambers Turner, Shankar Unni, Mike Yang, Jun Yu, and Doug Young.© Copyright 1995 Silicon Graphics, Inc.name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' All Rights ReservedThis document contains proprietary and confidential information of Silicon Graphics, Inc. The contents of this document may not be disclosed to third parties, copied, or duplicated in any form, in whole or in part, without the prior written permission of Silicon Graphics, Inc.RESTRICTED RIGHTS LEGENDUse, duplication, or disclosure of the technical data contained in this document by the Government is subject to restrictions as set forth in subdivision (c) (1) (ii) of the Rights in Technical Data and Computer Software clause at DFARS 52.227-7013 and/or in similar or successor clauses in the FAR, or in the DOD or NASA FAR Supplement. Unpublished rights reserved under the Copyright Laws of the United States. Contractor/manufacturer is Silicon Graphics, Inc., 2011 N. Shoreline Blvd., Mountain View, CA 94043-1389.Silicon Graphics is a registered trademark, and Developer Magic, IRIX IM, Indy, POWER Onyx, IRIS ViewKit, Power Fortran Accelerator, OpenGL, Open Inventor, ShowCase, IRIS Inventor, and Graphics Library are trademarks of Silicon Graphics, Inc. ClearCase is a trademark of Atria Software, Inc. UNIX is a registered trademark in the United States and other countries, licensed exclusively through X/Open Company, Ltd. X Window System is a trademark of the Massachusetts Institute of Technology. OSF/Motif is a trademark of the Open Software Foundation. PostScript is a registered trademark of Adobe Systems, Inc. About This GuideThis manual is an introduction and overview of ProDev WorkShop, Release 2.5.1 It contains the following:The body of the manualIDREF="53784" TYPE="TITLE", "ProDev WorkShop Overview," describes the major tools in the ProDev WorkShop toolkit. It provides a user model for each tool, highlights some major features, and provides pointers to the user guides where you can get detailed information on the tools.IDREF="95481" TYPE="TITLE"Appendix A, "Using Graphical Views," describes the features and operation of graphical views in the ProDev WorkShop toolkit.IDREF="65152" TYPE="TITLE"Appendix B, "Customizing ProDev WorkShop Tools," describes features and resources available for customizing the look and operation of ProDev WorkShop tools.A glossary of commonly used terms in the ProDev WorkShop toolkit.ID="53784"ProDev WorkShop OverviewWelcome to ProDev WorkShop, a major part of the Developer Magic‘ software development environment. ProDev WorkShop is a software toolset for the development of C, C++, Ada, and Fortran applications. These powerful, highly visual tools help you understand your program's structure and operation so that you can diagnose very difficult, traditionally time-consuming problems in a short amount of time. With them, you can develop applications for the entire Silicon Graphics“ product line, from Indy‘ to POWER Onyx‘ workstations. NoteIn the past, the software development environment was called CASEVision‘; that name has been replaced by Developer Magic. In addition to ProDev WorkShop, the Developer Magic environment includes ProMPFname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'a special module for multi-process Fortran programmingname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'and IDO (IRIX Development Option)name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the base compiler and libraries. Some of the documentation may still use the CASEVision name; those documents will be updated soon.The ProDev WorkShop toolset provides:Comprehensive control over the debugging processname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'You can set simple breakpoints with the click of a mouse button or define complex conditions for your traps. ProDev WorkShop's fast data watch points with kernel support are especially adept at tracking memory corruption problems.Visual debugging environment for examining data in your active programname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'ProDev WorkShop provides convenient, graphical views of variables, expressions, large arrays, and data structures. If you prefer a tty-style interface, you can always dump values directly using WorkShop's Debugger command line.Powerful static analysis for understanding your programname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'You can view the structure of your program and relationships such as call trees, function lists, class hierarchies, and file dependencies. And you can get this information whether or not the program can be compiled.The ability to collect performance and coverage information during test runsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'ProDev WorkShop's Performance Analyzer lets you see where your program spends its time and pinpoint performance bugs, including those due to memory problems. The Tester tool shows you which source lines and basic blocks are covered in your tests.Convenient recompiling from within the ProDev WorkShop environmentname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'WorkShop's standard build tools let you view file dependencies and compiler requirements and fix compile errors conveniently. Quick recompiles for simple changesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'The Fix and Continue tool lets you make simple changes without having to go through a major recompile and relinking, dramatically reducing the number of edit-compile-debug cycles. Ability to analyze structures and relationships in C++ and Ada codename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'The Browser provides global graphical and textual views of relationships between language-specific entities, including inheritance, containment, and interactions.Specialized debugging for X/Motif“ applicationsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'The X/Motif Analyzer lets you solve the special problems in X/Motif application development. You can look at object data, set breakpoints at the object or X protocol level, trace X and widget events, and tune performance.Rapid application developmentname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'The RapidApp tool lets you create graphical interfaces for C++ applications quickly and easily. RapidApp lets you build graphical interfaces by dragging and dropping interface elements (based on IRIX IM (X/Motif) widgets and IRIS ViewKit‘-style components) onto a template window. This overview gives you a broad exposure to the ProDev WorkShop toolset as well as pointers to the documentation for getting detailed information. The overview is organized as follows:IDREF="49841" TYPE="TITLE""Using the ProDev WorkShop Debugger"IDREF="48925" TYPE="TITLE""Navigating Through Code With the Static Analyzer and Browser"IDREF="84734" TYPE="TITLE""Pinpointing Performance Problems With the Performance Analyzer"IDREF="71333" TYPE="TITLE""Determining the Thoroughness of Test Coverage With Tester"IDREF="99638" TYPE="TITLE""Recompiling Within the ProDev WorkShop Environment With Build Manager"IDREF="90607" TYPE="TITLE""Making Quick Changes With Fix and Continue"IDREF="68245" TYPE="TITLE""Debugging X/Motif Programs"IDREF="43033" TYPE="TITLE""Building Application Interfaces With RapidApp"In addition to the ProDev WorkShop tools, you can separately purchase:Developer Magic Pro MPFname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'a visual code parallelization tool used with the Power Fortran Accelerator‘ to help balance parallel loops in Fortran applicationsDeveloper Magic ClearCase‘name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'a toolset for version control, configuration management, and process control for software organizationsNoteIf you use ClearCase, SCCS, or RCS, you can check source files directly into or out of ProDev WorkShop and MegaDev.Developer Magic Trackername='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'an application builder for creating change control and change tracking systems. It can be integrated with ClearCase.LBL="" HELPID=""ID="49841"Using the ProDev WorkShop DebuggerThe Debugger is a UNIX“ source-level debugging tool that provides special windows (views) for displaying program data and execution state as the program executes. The Debugger lets you set various types of breakpoints and watch points where you can conveniently view data such as variables, expressions, structures, large arrays, call stacks, and machine-level values. The WorkShop Debugger goes far beyond the capabilities of dbx. It includes fast data watchpoints and other types of traps; graphical views for displaying local variables, source-level expressions, array variables, and data structures; and debugging at the machine level. LBL="" HELPID=""ID="54245"Debugger User ModelAll WorkShop activities can be accessed from the Main View window, which is illustrated in IDREF="62188" TYPE="GRAPHIC"Figure 1. FILE="ch110.gif" POSITION="INLINE" SCALE="FALSE"LBL="1"Figure 1 ID="62188"Major Areas of the Main View WindowThe basic model for using the Debugger is to:Invoke the Debugger by typing:cvd [-pid pid] [-host host] [executable [corefile]] [&]The -pid option lets you attach the Debugger to a running process. You can use this to determine why a live process is in an infinite loop or is otherwise hung.The argument executable is the name of the executable file for the process you want to run. It is optional; you can invoke the Debugger first and specify the executable later.The corefile option lets you invoke the Debugger and specify a core file (with its executable) to try to determine why a program crashed.The -host option lets you specify a remote host on which the target executable will be run; the Debugger runs locally. This option is useful if:you don't want the Debugger windows to interfere with the application you are debugging.you are supporting an application remotely.you don't want to use the Debugger on the target system for another reason.Set stop traps, that is, breakpoints, in the source code. Simple traps are set by clicking the left mouse button in the annotation column to the left of the source code display or by using the Traps menu. More complex traps, including watch points, can be set and managed from the Trap Manager, Signal Panel, and Syscall Panel, which can be accessed from the Views menu. You can also set traps by typing them at the Debugger command line in Main View. You can stop a process at any time by clicking the Stop button in the Main View control area.Start the program by clicking the Run button in Main View.When the process stops at a trap or other stopping point of interest, you can examine the data in the Debugger view windows (accessed from the Views menu). You can display view windows at any time; they update automatically each time the program stops. IDREF="26275" TYPE="GRAPHIC"Figure 2 shows four typical Debugger views and indicates how you access them from the Views menu.FILE="ch112.gif" POSITION="INLINE" SCALE="FALSE"LBL="2"Figure 2 ID="26275"Typical Debugger Views Accessible at a BreakpointIDREF="91266" TYPE="GRAPHIC"Figure 3 shows the Array Visualizer, a powerful view for examining data in arrays of up to 100 x 100 elements. You can look for problem areas in a 3D rendering of the array, click on the area of interest, and view the numerical values in a spreadsheet format. In IDREF="91266" TYPE="GRAPHIC"Figure 3, the hue option has been set so that the values appear in a color spectrum from blue (lowest) to red (highest) with out-of-range anomalies appearing in gray. Note the high point coming out of the 3D image; it demonstrates how anomalies in large arrays stand out. If you need to debug your program at the machine level, you can use Register View, Disassembly View, and Memory View, as shown in IDREF="11589" TYPE="GRAPHIC"Figure 4. These are accessed from the Views menu in the Debugger Main View as well.Use the control panel options in Main View to continue execution (see IDREF="62188" TYPE="GRAPHIC"Figure 1).From any breakpoint, you have these options:The Continue button runs the program until the next breakpoint.The "Continue To" selection in the PC menu proceeds to a specified source line. Placing the cursor in a line specifies it.The "Jump To" selection in the PC menu goes to a specified line (by the cursor), skipping over any intermediate code.The Step Into button continues execution by one step or a number specified by holding down the right mouse button over the Step Into button and selecting the number from the dialog box. The process then continues the specified number of source lines and enters any called functions.The StepOver button similarly proceeds a specified number of lines but executes intermediate functions without stepping into them.The Return button executes the remaining instructions in a function and stops on return from that function.Check out the source code that needs to be fixed.If you find a bug and are using an integrated source control program such as ClearCase, RCS, or SCCS, you can check out the source code from Main View (or Source View, an alternate editing window). Choose "Check Out" from the Versioning submenu in the Source menu.FILE="ch113.gif" POSITION="INLINE" SCALE="FALSE"LBL="3"Figure 3 ID="91266"Array VisualizerFILE="ch114.gif" POSITION="INLINE" SCALE="FALSE"LBL="4"Figure 4 ID="11589"Machine-Level Debugger ViewsFix any problems in your code using the source code display area in Main View, Source View, or the editor of your choice.Both Main View and Source View let you do simple editing and annotate the code with trap indicators. Source View also lets you display test data from the Performance Analyzer and Tester in the annotation column. If you prefer to view source code in a text editor other than Source View, add the line*editorCommand: editorto your .Xdefaults file, where editor is the command for the editor you wish to use. Recompile using Build Manager.Build Manager has two windows: Build View and Build Analyzer. Build View lets you compile, view compile error lists, and access the offending code in Source View or an editor of your choice. Build Analyzer lets you view build dependencies and recompilation requirements, and access source files. Build View uses the UNIX make facility as its default build software. Although Build Analyzer determines dependencies using make, you can substitute the build software of your choice, any make that runs on Silicon Graphics platforms.LBL="" HELPID=""Where to Find Debugger InformationTo find out more about the Debugger, refer to IDREF="47527" TYPE="TABLE"Table 1.COLUMNS="2"LBL="1"Table 1 ID="47527"Where to Find Debugger Information in the Developer Magic: 
Debugger User's GuideLEFT="0" WIDTH="252"TopicLEFT="260" WIDTH="252"See ...LEFT="0" WIDTH="252"General Debugger informationLEFT="260" WIDTH="252"IDREF="40971" BOOK="Debugger_UG" FILE="1GStartDebug.doc" HDG=""Chapter 1, "Getting Started with the WorkShop Debugger"LEFT="0" WIDTH="252"Debugger tutorialLEFT="260" WIDTH="252"IDREF="21883" BOOK="Debugger_UG" FILE="3TutGen.doc" HDG=""Chapter 3, "A Short Debugger Tutorial"LEFT="0" WIDTH="252"Debugger interaction with source filesLEFT="260" WIDTH="252"IDREF="34853" BOOK="Debugger_UG" FILE="2MngSrc.doc" HDG=""Chapter 2, "Managing Source Files"LEFT="0" WIDTH="252"Managing windows while performing multiple tasksLEFT="260" WIDTH="252"IDREF="71783" BOOK="Debugger_UG" FILE="AReference.doc" HDG="""Project Session Management Windows"LEFT="0" WIDTH="252"Comprehensive trap informationLEFT="260" WIDTH="252"IDREF="25908" BOOK="Debugger_UG" FILE="4Traps.doc" HDG=""Chapter 4, "Setting Traps"LEFT="0" WIDTH="252"Controlling execution in a process (stepping, jumping, etc.)LEFT="260" WIDTH="252"IDREF="25765" BOOK="Debugger_UG" FILE="5ProcCon.doc" HDG=""Chapter 5, "Controlling Process Execution"LEFT="0" WIDTH="252"Examining Debugger data in general at the source levelLEFT="260" WIDTH="252"IDREF="24462" BOOK="Debugger_UG" FILE="6ExmnData.doc" HDG=""Chapter 6, "Examining Debugger Data"LEFT="0" WIDTH="252"Tracing through the call stackLEFT="260" WIDTH="252"IDREF="55087" BOOK="Debugger_UG" FILE="6ExmnData.doc" HDG="""Tracing Through Call Stack View"LEFT="0" WIDTH="252"Entering expressions to be evaluated at stopping pointsLEFT="260" WIDTH="252"IDREF="38851" BOOK="Debugger_UG" FILE="6ExmnData.doc" HDG="""Evaluating Expressions"LEFT="0" WIDTH="252"Viewing or changing the values of variablesLEFT="260" WIDTH="252"IDREF="40944" BOOK="Debugger_UG" FILE="AReference.doc" HDG="""Variable Browser"LEFT="0" WIDTH="252"Examining data in arrays using the 3D or spreadsheet formatLEFT="260" WIDTH="252"IDREF="84807" BOOK="Debugger_UG" FILE="AReference.doc" HDG="""Array Browser"LEFT="0" WIDTH="252"Determining the data structures of variablesLEFT="260" WIDTH="252"IDREF="64311" BOOK="Debugger_UG" FILE="AReference.doc" HDG="""Structure Browser"LEFT="0" WIDTH="252"Using the Debugger command lineLEFT="260" WIDTH="252"IDREF="76970" BOOK="Debugger_UG" FILE="AReference.doc" HDG="""Debugger Command Line"LEFT="0" WIDTH="252"Examining debugger data at the machine levelLEFT="260" WIDTH="252"IDREF="49277" BOOK="Debugger_UG" FILE="AReference.doc" HDG="""Machine-level Debugging Windows"LEFT="0" WIDTH="252"Using the debugger to trap memory allocation problemsLEFT="260" WIDTH="252"IDREF="12096" BOOK="Debugger_UG" FILE="8Heaps.doc" HDG=""Chapter 8, "Detecting Heap Corruption"LEFT="0" WIDTH="252"Debugging multiprocess programsLEFT="260" WIDTH="252"IDREF="69417" BOOK="Debugger_UG" FILE="AReference.doc" HDG="""Multiple Process Debugging Windows"LBL="" HELPID=""ID="48925"Navigating Through Code With the Static Analyzer and BrowserThe ProDev WorkShop Static Analyzer is a source code analysis and navigation tool for analyzing source code written in C, C++, Fortran, or Ada (with purchase of ProDev Ada only). (The Browser has additional features for Ada and C++ and is described in IDREF="30448" TYPE="TITLE""Browser User Model".) The Static Analyzer shows you the code's structure (graphically or in text format) including function calls, definitions of variables, file dependencies, macro locations, class hierarchies, file dependencies, and other structural details for understanding your code. You can also make specific queries, such as showing where a function is used. You can even analyze programs that don't compile, a particularly nice feature for those porting code.The Static Analyzer works by reading through source code files that you specify and creating a database of program elements such as functions, files, classes, methods, packages, and their relationships. The main Static Analyzer window with a typical call graph is illustrated in IDREF="19895" TYPE="GRAPHIC"Figure 5. FILE="ch115.gif" POSITION="INLINE" SCALE="FALSE"LBL="5"Figure 5 ID="19895"Main Static Analyzer WindowLBL="" HELPID=""Static Analyzer User ModelFollow these steps for using the Static Analyzer:Invoke the Static Analyzer, either by typing cvstatic or by selecting "Static Analyzer" from the Launch submenu in any ProDev WorkShop Admin menu (preferably from the directory where your source is located).Decide which files are to be analyzed.You designate which files are to be analyzed in a special file called a 
fileset. A fileset is a regular ASCII file with a format of one entry per line, each line separated from the next by a carriage return. The entries can be regular expressions, filenames, or included directories preceded by the designator -I. To specify a fileset, you cancreate the fileset manually using a text editoruse the Fileset Editor, which is accessed from the Admin menu in the Static Analyzer windowlet the Static Analyzer create the fileset automatically at startup by defaulting to the files in the current directory that match the expression *.[cCfF] let the Static Analyzer create the fileset automatically at startup from the command line by typing cvstatic with the -executable flag and designating an executableuse the compiler to create a fileset (and database) by adding the -sa,<dbdirectory> option to your makefileNoteMany programs are so big that a query covering the entire scope is useless due to its size and complexity. There are two ways to keep the scope of your analysis at a manageable size: (1) Limit the number of files to be analyzed or (2) avoid queries that begin with "List All ...". Decide how you are going to build the database.Before you can specify a fileset, you must decide how you are going to build the database. You can choose to create the database in scanner mode (the default), which is fast but not sensitive to any specific programming language, or in parser mode, which uses the compiler and is slower but more thorough. Use scanner mode for large programs or for programs that do not compile. Scanner mode is particularly suited to porting situations. Parser mode is better when you have code that compiles and you need to determine language-specific relationships, particularly in Fortran, Ada, and C++. Build the database.Perform your queries.Queries are selected from the Queries menu in the Static Analyzer. They fall into 13 categories, as shown in IDREF="73484" TYPE="GRAPHIC"Figure 6. Remember that the "List All ..." queries can produce overwhelming results for large programs.View (and save) the results.The Static Analyzer has four ways of presenting data, which are selected from the Views menu:"Text View" displays query results in a text format. In addition to listing the queried items, it indicates the source filename and line number, and includes the actual source line. "Call Tree View" applies to function queries. It presents the data in a graphical format with nodes (rectangles) representing functions and arcs (arrows) representing calls to functions. "Class Tree View" applies to C++ class queries. It presents a class inheritance tree with nodes representing classes and arcs representing parent-child class relationships."File Dependency View" applies to file queries. It presents a graph, with nodes representing files and arcs representing include relationships.If you want to save a query in a graphical view, you can save a PostScript“ version by selecting "Save Query..." from the Admin menu and print it out at your leisure.Access the source code.Double-clicking any node in a graph or item in Text View brings up the Source View window containing the corresponding source code. Double-clicking any arc (arrow) displays Source View with the corresponding call site or file inclusion.FILE="ch111.gif" POSITION="INLINE" SCALE="FALSE"LBL="6"Figure 6 ID="73484"Static Analyzer Queries Menu with SubmenusLBL="" HELPID=""Where to Find Static Analyzer InformationTo find out more about the Static Analyzer, refer to IDREF="48661" TYPE="TABLE"Table 2.COLUMNS="2"LBL="2"Table 2 ID="48661"Where to Find Static Analyzer Information in the Developer Magic: 
Static Analyzer and Browser User's GuideLEFT="0" WIDTH="166"TopicLEFT="175" WIDTH="166"See ...LEFT="0" WIDTH="166"General Static Analyzer descriptionLEFT="175" WIDTH="166"IDREF="69413" BOOK="007-2580-001" FILE="ch01.doc" HDG=""Chapter 1, "Introduction to the 
WorkShop Static Analyzer"LEFT="0" WIDTH="166"Static Analyzer tutorialLEFT="175" WIDTH="166"IDREF="70671" BOOK="007-2580-001" FILE="ch02.doc" HDG=""Chapter 2, "A Sample Session With the 
Static Analyzer"LEFT="0" WIDTH="166"Specifying a filesetLEFT="175" WIDTH="166"IDREF="34371" BOOK="007-2580-001" FILE="ch03.doc" HDG="""Fileset Specifications"LEFT="0" WIDTH="166"Building a database using scanner modeLEFT="175" WIDTH="166"IDREF="89873" BOOK="007-2580-001" FILE="ch03.doc" HDG="""Scanner Mode"LEFT="0" WIDTH="166"Building a database using parser modeLEFT="175" WIDTH="166"IDREF="60270" BOOK="007-2580-001" FILE="ch03.doc" HDG="""Parser Mode"LEFT="0" WIDTH="166"Performing queriesLEFT="175" WIDTH="166"IDREF="24882" BOOK="007-2580-001" FILE="ch04.doc" HDG=""Chapter 4, "Static Analyzer: Queries"LEFT="0" WIDTH="166"Static Analyzer viewing formatsLEFT="175" WIDTH="166"IDREF="25986" BOOK="007-2580-001" FILE="ch05.doc" HDG=""Chapter 5, "Static Analyzer: Views"LEFT="0" WIDTH="166"Strategies for analyzing large programsLEFT="175" WIDTH="166"IDREF="27911" BOOK="007-2580-001" FILE="ch06.doc" HDG=""Chapter 6, "Static Analyzer: Working on 
Large Programming Projects"LBL="" HELPID=""ID="30448"Browser User ModelThe Browser user model is similar to the Static Analyzer user model. After you build the database (which must be done in parser mode), you access the Browser by selecting "Browser" from the Static Analyzer Admin menu.The Browser lets you display different sets of information including relationships about C++ classes and members, Ada packages, tagged types, tasks, and their members through these three views:Browser Viewname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'displays member and related information in an expandable, hierarchical outline format with the members of the current class, package, tagged type, or task in the left pane and related elements on the right (see IDREF="87170" TYPE="GRAPHIC"Figure 7). Clicking the diamond-shaped icons next to the headings in the list hides or displays the associated information. Like the Static Analyzer, you have numerous queries available through the Query menu. In addition, if you select an item in either of the Browser View lists and hold down the right mouse button, you can access the Queries menu specific to that type of item, that is, methods, data members, classes, and so on.FILE="ch13.gif" POSITION="INLINE" SCALE="FALSE"LBL="7"Figure 7 ID="87170"Browser View Window and Query Menus with C++ DataYou can create man page templates for classes, packages, tasks, or tagged types by selecting "Generate man pages..." from the Browser View Admin menu. You simply specify one or more elements, click the Generate button, and the Browser fills in the man page template for you. Similarly you can create web pages by selecting "Generate web pages..." from the Browser View Admin menu. See IDREF="25629" TYPE="GRAPHIC"Figure 8.Class Graphname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'displays the hierarchy for the current subject in the Browser View window with nodes as subjects and arcs as relationships. Class Graph can show four types of relationships: inheritance, containment, interaction, and friends. You can display all subjects, limit the scope to those derived from the current subject, or get a butterfly view showing the immediate base and derived subjects of the current one.Call Graphname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'displays the calling relationships of methods, virtual methods, or functions selected from Browser View with options for customizing the display of the graph.To find out more about the Browser, refer to Table 3.COLUMNS="2"LBL="3"Table 3 ID="47527"Where to Find Browser Information in the Developer Magic: Static 
Analyzer and Browser User's GuideLEFT="0" WIDTH="166"TopicLEFT="175" WIDTH="166"See ...LEFT="0" WIDTH="166"General Browser descriptionLEFT="175" WIDTH="166"IDREF="13468" BOOK="007-2580-001" FILE="ch07.doc" HDG=""Chapter 7, "Getting Started with the 
Browser"LEFT="0" WIDTH="166"C++ Browser tutorialLEFT="175" WIDTH="166"IDREF="39823" BOOK="007-2580-001" FILE="ch08.doc" HDG=""Chapter 8, "Using the Browser for C++: 
A Sample Session"LEFT="0" WIDTH="166"Ada Browser tutorialLEFT="175" WIDTH="166"IDREF="39823" BOOK="007-2580-001" FILE="ch09.doc" HDG=""Chapter 9, "Using the Browser for Ada: 
A Sample Session"LEFT="0" WIDTH="166"Detailed reference informationLEFT="175" WIDTH="166"IDREF="41721" BOOK="007-2580-001" FILE="ch10.doc" HDG=""Chapter 10, "The Browser Reference"LEFT="0" WIDTH="166"Browser View windowLEFT="175" WIDTH="166"IDREF="14051" BOOK="007-2580-001" FILE="ch10.doc" HDG="""Browser View Window"LEFT="0" WIDTH="166"Class Graph windowLEFT="175" WIDTH="166"IDREF="20193" BOOK="007-2580-001" FILE="ch10.doc" HDG="""Class Graph Window"LEFT="0" WIDTH="166"Call Graph windowLEFT="175" WIDTH="166"IDREF="52924" BOOK="007-2580-001" FILE="ch10.doc" HDG="""Call Graph Window"LEFT="0" WIDTH="166"Generating man pages LEFT="175" WIDTH="166"IDREF="45100" BOOK="ProDev_Stat" FILE="ch10.doc" HDG="""Man Page Generation"LEFT="0" WIDTH="166"Generating web pagesLEFT="175" WIDTH="166"IDREF="12080" BOOK="ProDev_Stat" FILE="ch10.doc" HDG="""Web Page Generation"FILE="ch12.gif" POSITION="INLINE" SCALE="FALSE"LBL="8"Figure 8 ID="25629"Generated Man and Web Page TemplatesLBL="" HELPID=""ID="84734"Pinpointing Performance Problems With the Performance AnalyzerThe ProDev WorkShop Performance Analyzer helps you understand how your program performs so that you can correct any problems. In performance analysis, you run experiments to capture performance data and see how long each phase or part of your program takes to run. You can then determine if the performance of the phase is slowed down by the CPU, I/O activity, memory, or a bug and attempt to speed it up. A menu of predefined tasks is provided to help you set up your experiments. With the Performance Analyzer views, you can conveniently analyze the data. These views show CPU utilization and process resource usage (such as context switches, page faults, and working set size), I/O activity, and memory usage (to capture such problems as memory leaks, bad allocations, and heap corruption). The Performance Analyzer has three general techniques for collecting performance data:Countingname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'It can count the exact number of times each function and/or basic block has been executed. This requires 
instrumenting the program, that is, inserting code into the executable to collect counts.Profilingname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'It can periodically examine and record the program's PC (program counter), call stack, and resource consumption. Tracingname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'It can trace events that affect performance, such as reads and writes, system calls, page faults, floating point exceptions, and mallocs, reallocs, and frees. LBL="" HELPID=""Performance Analyzer User ModelSet up a general experiment to determine areas for improvement in your program.To set up a performance experiment, select a task from the Select Task submenu in the Perf menu in the Debugger Main View. The task menu lets you select predefined experiment tasks (see IDREF="10062" TYPE="GRAPHIC"Figure 9). At this point, you probably haven't formed a hypothesis yet about where the performance problems lie. If this is the case, select the "Determine bottlenecks, identify phases" task. This is useful for determining the general problem areas within the program.FILE="ch116.gif" POSITION="INLINE" SCALE="FALSE"LBL="9"Figure 9 ID="10062"Debugger Main View With Perf Task Menu DisplayedStart the program by clicking the Run button in Main View.This runs the experiment and collects the performance data, which is written to a directory test0000 (or a name of your choice); test0000 is the identification for your experiment.Analyze the results in the Performance Analyzer window and the Usage View (Graphs) window.After the experiment has finished, you can display the results in the Performance Analyzer window by selecting "Performance Analyzer" from the Launch submenu in any ProDev WorkShop Admin menu or by typing cvperf -exp experimentname. The results from a typical performance analysis experiment appear in IDREF="76072" TYPE="GRAPHIC"Figure 10, the main Performance Analyzer window, and IDREF="95839" TYPE="GRAPHIC"Figure 11, which shows a subset of the graphs in the Usage Views (Graphs) window. You should be able to determine where the phases of execution occur so that you can set sample traps between them. Sample traps collect performance data at specified times and events in the experiment.FILE="ch117.gif" POSITION="INLINE" SCALE="FALSE"LBL="10"Figure 10 ID="76072"Performance Analyzer Main WindowFILE="ch118.gif" POSITION="INLINE" SCALE="FALSE"LBL="11"Figure 11 ID="95839"Usage View (Graphs) Window: Lower GraphsSet sample traps at the start and end of each phase.Setting sample traps between phases isolates the data to be analyzed on a phase-by-phase basis. Sample traps are set by selecting "Sample", "Sample at Function Entry", or "Sample at Function Exit" from the Set Trap submenu in the Traps menu in the Debugger Main View or through the Traps Manager.Select your next experiment from the Task Menu in the Performance Panel and run it by clicking the Run button in the Main View window.You need to form a hypothesis about the performance problem and select an appropriate task (see IDREF="10062" TYPE="GRAPHIC"Figure 9) for your next experiment. There are trade-offs in selecting tasksname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'experiments can collect huge amounts of data and may perturb the results in some cases.Analyze the results using the Performance Analyzer main window, its views, or Source View with performance data annotations displayed. A typical Performance Analyzer view, Malloc Error View, is shown in IDREF="99708" TYPE="GRAPHIC"Figure 12. The Performance Analyzer provides results in the windows listed in IDREF="79612" TYPE="TABLE"Table 4.FILE="ch119.gif" POSITION="INLINE" SCALE="FALSE"LBL="12"Figure 12 ID="99708"Malloc Error ViewCOLUMNS="2"LBL="4"Table 4 ID="79612"Performance Analyzer Views and DataLEFT="0" WIDTH="166"Performance Analyzer WindowLEFT="175" WIDTH="338"Data ProvidedLEFT="0" WIDTH="166"Performance Analyzer main windowLEFT="175" WIDTH="338"Function list with performance data, usage chart showing general resource usage 
over time, and time line for setting scope on dataLEFT="0" WIDTH="166"Call Stack ViewLEFT="175" WIDTH="338"Call stack recorded when selected event occurredLEFT="0" WIDTH="166"Usage View (Graphs)LEFT="175" WIDTH="338"Specific resource usage over time, shown as graphsLEFT="0" WIDTH="166"Usage View (Numerical)LEFT="175" WIDTH="338"Specific resource usage for selected (by caliper) time interval, shown as numerical 
valuesLEFT="0" WIDTH="166"Call Graph ViewLEFT="175" WIDTH="338"A graph showing functions that were called during the time interval, annotated by 
the performance data collectedLEFT="0" WIDTH="166"I/O ViewLEFT="175" WIDTH="338"A graph showing I/O activity over time during the time intervalLEFT="0" WIDTH="166"Malloc ViewLEFT="175" WIDTH="338"A list of all mallocs, their sizes and number of occurrences, and, if selected, their 
corresponding call stack within the selected time intervalLEFT="0" WIDTH="166"Malloc Error ViewLEFT="175" WIDTH="338"A list of malloc errors, their number of occurrences, and if selected, their 
corresponding call stack within the time intervalLEFT="0" WIDTH="166"Leak ViewLEFT="175" WIDTH="338"A list of specific leaks, their sizes and number of occurrences, and if selected, their 
corresponding call stack within the time intervalLEFT="0" WIDTH="166"Heap ViewLEFT="175" WIDTH="338"A generalized view of heap memory within the time intervalLEFT="0" WIDTH="166"Source ViewLEFT="175" WIDTH="338"The ProDev WorkShop text editor window showing source code annotated by 
performance data collectedLEFT="0" WIDTH="166"Working Set ViewLEFT="175" WIDTH="338"The instruction coverage of dynamic shared objects (DSOs) that make up the 
executable, showing instructions, functions, and pages that were not used within the 
time intervalLEFT="0" WIDTH="166"Cord AnalyzerLEFT="175" WIDTH="338"The Cord Analyzer is not actually part of the Performance Analyzer, but it works 
with data from Performance Analyzer experiments. It lets you try out different 
ordering of functions to see the effect on performance.LBL="" HELPID=""Where to Find Performance Analyzer InformationTo find out more about the Performance Analyzer, refer to Table 5.COLUMNS="2"LBL="5"Table 5 ID="47527"Where to Find Performance Analyzer Information in the Developer 
Magic: Performance Analyzer and Tester User's GuideLEFT="0" WIDTH="252"TopicLEFT="260" WIDTH="252"See ...LEFT="0" WIDTH="252"General Performance Analyzer informationLEFT="260" WIDTH="252"IDREF="40590" BOOK="007-2581-001" FILE="ch01.doc" HDG=""Chapter 1, "Introduction to the Performance Analyzer"LEFT="0" WIDTH="252"Performance analysis theoryLEFT="260" WIDTH="252"IDREF="10636" BOOK="007-2581-001" FILE="ch01.doc" HDG="""Sources of Performance Problems"LEFT="0" WIDTH="252"General Performance Analyzer tutorialLEFT="260" WIDTH="252"IDREF="11628" BOOK="007-2581-001" FILE="ch02.doc" HDG=""Chapter 2, "Performance Analyzer Tutorial"LEFT="0" WIDTH="252"Memory leak tutorial LEFT="260" WIDTH="252"IDREF="64332" BOOK="007-2581-001" FILE="ch04.doc" HDG="""Memory Experiment Tutorial"LEFT="0" WIDTH="252"Setting up performance analysis experiments including task 
selectionLEFT="260" WIDTH="252"IDREF="27257" BOOK="007-2581-001" FILE="ch03.doc" HDG=""Chapter 3, "Setting Up Performance Analysis Experiments" 
for details and IDREF="24567" BOOK="007-2581-001" FILE="ch04.doc" HDG="""Selecting Performance Tasks" for a 
summaryLEFT="0" WIDTH="252"Setting sample trapsLEFT="260" WIDTH="252"IDREF="25908" BOOK="Debugger_UG" FILE="4Traps.doc" HDG=""Chapter 4, "Setting Traps" in the ProDev WorkShop Debugger 
User's GuideLEFT="0" WIDTH="252"Performance Analyzer main windowLEFT="260" WIDTH="252"IDREF="13068" BOOK="007-2581-001" FILE="ch04.doc" HDG="""The Performance Analyzer Main Window"LEFT="0" WIDTH="252"Usage View (Graphs) windowLEFT="260" WIDTH="252"IDREF="21919" BOOK="007-2581-001" FILE="ch04.doc" HDG="""Usage View (Graphs)"LEFT="0" WIDTH="252"Watching an experiment without collecting data in the Process 
MeterLEFT="260" WIDTH="252"IDREF="96732" BOOK="007-2581-001" FILE="ch04.doc" HDG="""Process Meter"LEFT="0" WIDTH="252"Usage View (Numerical) windowLEFT="260" WIDTH="252"IDREF="95321" BOOK="007-2581-001" FILE="ch04.doc" HDG="""Usage View (Numerical)"LEFT="0" WIDTH="252"Tracing I/O calls using the I/O View windowLEFT="260" WIDTH="252"IDREF="41945" BOOK="007-2581-001" FILE="ch04.doc" HDG="""I/O View"LEFT="0" WIDTH="252"Call Graph View windowLEFT="260" WIDTH="252"IDREF="53051" BOOK="007-2581-001" FILE="ch04.doc" HDG="""Call Graph View"LEFT="0" WIDTH="252"Finding memory problemsLEFT="260" WIDTH="252"IDREF="28886" BOOK="007-2581-001" FILE="ch04.doc" HDG="""Analyzing Memory Problems"LEFT="0" WIDTH="252"Specifying performance annotations for Source View and Call 
Graph ViewLEFT="260" WIDTH="252"IDREF="54221" BOOK="007-2581-001" FILE="ch04.doc" HDG="""Config Menu"LEFT="0" WIDTH="252"Call Stack View windowLEFT="260" WIDTH="252"IDREF="74395" BOOK="007-2581-001" FILE="ch04.doc" HDG="""Call Stack"LEFT="0" WIDTH="252"Improving working set behaviorLEFT="260" WIDTH="252"IDREF="52948" BOOK="007-2581-001" FILE="ch04.doc" HDG="""Analyzing Working Sets"LBL="" HELPID=""ID="71333"Determining the Thoroughness of Test Coverage With TesterTester is a software quality assurance toolset for measuring dynamic coverage over a set of tests. It tracks the execution of functions, individual source lines, arcs, blocks, and branches. LBL="" HELPID=""Tester User ModelThis section describes the user model for designing a single test. After you have your instrumentation file and test directories set up, you can automate your testing and create larger test sets. Tester has both a command line interface (see IDREF="50161" TYPE="TABLE"Table 6) and a graphical user interface (see IDREF="18827" TYPE="GRAPHIC"Figure 13).Plan your test.Create (or reuse) an instrumentation file.The instrumentation file defines the coverage data you wish to collect in this test. Apply the instrument file to the target executable(s).This creates a special executable for testing purposes that collects data as it runs.Create a test directory to collect the data files.Run the instrumented version of the executable to collect the coverage data.Analyze the results.Tester produces a wide variety of column-based reports. Most are available in both interfaces: command line and graphical. The reports can show source and assembly line coverage; coverage of functions; arc coverage, that is, coverage of function calls; call graphs indicating caller and callee functions and their counts; basic block counts; count information for assembly language branches; summaries of overall coverage; and argument tracing. COLUMNS="3"LBL="6"Table 6 ID="50161"Tester Command Line Interface SummaryLEFT="0" WIDTH="90"Command CategoryLEFT="95" WIDTH="72"Command NameLEFT="175" WIDTH="342"DescriptionLEFT="0" WIDTH="90"generalLEFT="95" WIDTH="72"cvcov cattestLEFT="175" WIDTH="342"Describes the test details for a test, test set, or test group LEFT="0" WIDTH="90"LEFT="95" WIDTH="72"cvcov lsinstrLEFT="175" WIDTH="342"Displays the instrumentation information for a particular test LEFT="0" WIDTH="90"LEFT="95" WIDTH="72"cvcov lstestLEFT="175" WIDTH="342"Lists the test directories in the current working directory LEFT="0" WIDTH="90"LEFT="95" WIDTH="72"cvcov mktestLEFT="175" WIDTH="342"Creates a test directory LEFT="0" WIDTH="90"LEFT="95" WIDTH="72"cvcov rmtestLEFT="175" WIDTH="342"Removes tests and test sets LEFT="0" WIDTH="90"LEFT="95" WIDTH="72"cvcov runinstrLEFT="175" WIDTH="342"Adds code to the target executable to enable you to capture coverage data, according 
to the criteria you specify LEFT="0" WIDTH="90"LEFT="95" WIDTH="72"cvcov runtestLEFT="175" WIDTH="342"Runs a test or a set of tests LEFT="0" WIDTH="90"coverage analysisLEFT="95" WIDTH="72"cvcov lssumLEFT="175" WIDTH="342"Shows the overall coverage based on the user-defined weighted average over 
function, line, block, branch, and arc coverage LEFT="0" WIDTH="90"LEFT="95" WIDTH="72"cvcov lsfunLEFT="175" WIDTH="342"Lists coverage information for the specified functions in the program that was tested LEFT="0" WIDTH="90"LEFT="95" WIDTH="72"cvcov lsblockLEFT="175" WIDTH="342"Displays a list of blocks for one or more functions and the count information 
associated with each block LEFT="0" WIDTH="90"LEFT="95" WIDTH="72"cvcov lsbranchLEFT="175" WIDTH="342"Lists coverage information for branches in the program, including the line number at 
which the branch occurs LEFT="0" WIDTH="90"LEFT="95" WIDTH="72"cvcov lsarcLEFT="175" WIDTH="342"Shows arc coverage, that is, the number of arcs taken out of the total possible arcs LEFT="0" WIDTH="90"LEFT="95" WIDTH="72"cvcov lscallLEFT="175" WIDTH="342"Lists the call graph for the executable with counts for each function LEFT="0" WIDTH="90"LEFT="95" WIDTH="72"cvcov lslineLEFT="175" WIDTH="342"Lists the coverage for native source lines LEFT="0" WIDTH="90"LEFT="95" WIDTH="72"cvcov lssourceLEFT="175" WIDTH="342"Displays the source annotated with line counts LEFT="0" WIDTH="90"LEFT="95" WIDTH="72"cvcov lstraceLEFT="175" WIDTH="342"Shows the argument tracing information LEFT="0" WIDTH="90"LEFT="95" WIDTH="72"cvcov diffLEFT="175" WIDTH="342"Shows the difference in coverage for different versions of the same program LEFT="0" WIDTH="90"test set LEFT="95" WIDTH="72"cvcov mktsetLEFT="175" WIDTH="342"Makes a test set LEFT="0" WIDTH="90"LEFT="95" WIDTH="72"cvcov addtestLEFT="175" WIDTH="342"Adds a test or test set to a test set or test groupLEFT="0" WIDTH="90"LEFT="95" WIDTH="72"cvcov deltestLEFT="175" WIDTH="342"Removes a test or test set from a test set or test groupLEFT="0" WIDTH="90"LEFT="95" WIDTH="72"cvcov optimizeLEFT="175" WIDTH="342"Selects the minimum set of tests that give the same coverage or meet the given 
coverage criteria as the given set LEFT="0" WIDTH="90"test groupLEFT="95" WIDTH="72"cvcov mktgroupLEFT="175" WIDTH="342"Creates a test group that can contain other tests or test groups; targets are either the 
target libraries or DSOsFILE="ch120.gif" POSITION="INLINE" SCALE="FALSE"LBL="13"Figure 13 ID="18827"Major Areas of the Main Tester WindowLBL="" HELPID=""Where to Finder Tester InformationTo find out more information about Tester, refer to IDREF="93900" TYPE="TABLE"Table 7.COLUMNS="2"LBL="7"Table 7 ID="93900"Where to Find Tester Information in the Developer Magic: Performance 
Analyzer and Tester User's GuideLEFT="0" WIDTH="166"TopicLEFT="175" WIDTH="166"See ...LEFT="0" WIDTH="166"General Tester informationLEFT="175" WIDTH="166"IDREF="93914" BOOK="WrkShp_UG" FILE="ch22.doc" HDG="""Tester Overview"LEFT="0" WIDTH="166"Automated testingLEFT="175" WIDTH="166"IDREF="23612" BOOK="WrkShp_UG" FILE="ch22.doc" HDG="""Automated Testing"LEFT="0" WIDTH="166"Command line interface tutorialLEFT="175" WIDTH="166"IDREF="40637" BOOK="WrkShp_UG" FILE="ch23.doc" HDG=""Chapter 23, "Tester Command Line 
Interface Tutorial"LEFT="0" WIDTH="166"Graphical user interface tutorialLEFT="175" WIDTH="166"IDREF="47213" BOOK="WrkShp_UG" FILE="ch25.doc" HDG=""Chapter 25, "Tester Graphical User 
Interface Tutorial"LEFT="0" WIDTH="166"Command line interface detailsLEFT="175" WIDTH="166"IDREF="37824" BOOK="WrkShp_UG" FILE="ch24.doc" HDG=""Chapter 24, "Tester Command Line 
Reference"LEFT="0" WIDTH="166"Graphical user interface detailsLEFT="175" WIDTH="166"IDREF="24089" BOOK="WrkShp_UG" FILE="ch26.doc" HDG=""Chapter 26, "Tester Graphical User 
Interface Reference"LBL="" HELPID=""ID="99638"Recompiling Within the ProDev WorkShop Environment With Build ManagerThe Build Manager lets you view file dependencies and compiler requirements, fix compile errors conveniently, and compile software without leaving the WorkShop environment. It provides two views: Build Viewname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for compiling, viewing compile error lists, and accessing the code containing the errors in Source View (the ProDev WorkShop editor) or an editor of your choice.Build Analyzername='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for viewing build dependencies and recompilation requirements and accessing source files. For more information on Build Manager, see IDREF="50420" BOOK="Debugger_UG" FILE="BBuild.doc" HDG=""Appendix B, "Using the Build Manager," in the Developer Magic:Debugger User's Guide.LBL="" HELPID=""ID="90607"Making Quick Changes With Fix and ContinueFix and Continue is part of the Developer Magic MegaDev module. The Fix and Continue feature lets you make minor changes to your code from within WorkShop without having to recompile and link the entire system. You issue Fix and Continue commands in the Debugger Main View window, either by selecting them from the Fix+Continue menu or typing them in directly in the Debugger command line area. With Fix and Continue, you can edit a function, parse the new function, and continue execution of the program being debugged. Fix and Continue enables you to speed up your development cycle significantly. For example, a program that takes 5 minutes to rebuild through a conventional compile might take 45 seconds using Fix and Continue.Fix and Continue lets you:Redefine existing function definitionsDisable, reenable, save, and delete redefinitionsSet breakpoints in and single-step within redefined codeView the status of changesExamine differences between original and redefined functionsIDREF="37013" TYPE="GRAPHIC"Figure 14 shows you the WorkShop Main View during a Fix and Continue session and explains how to use the Fix and Continue menu.LBL="" HELPID=""Fix and Continue User ModelInvoke the Debugger as you normally would by typing:cvd [-pid pid] [-host host] [executable [corefile]] [&]See IDREF="54245" TYPE="TITLE""Debugger User Model".Navigate to the function to be changed.You can get to the function numerous ways, by selecting "Search..." from the Source menu, typing func functionname at the Debugger command line, or simply scrolling to the location. If you did not use func functionname, you need to place the cursor inside the function.FILE="ch19.gif" POSITION="INLINE" SCALE="FALSE"LBL="14"Figure 14 ID="37013"Using Fix+ContinueSelect "Edit" from the Fix+Continue menu.This turns on edit mode, highlighting the function source code. If line numbers are displayed, those in the selected function appear with a two-part number separated by a decimal point. The left part represents the starting line number of the function in the source file before selecting "Edit". The right part renumbers the source within the function to make it easier to keep track of added new lines.Make your changes to the source code.You can do this directly in Main View or you can use a preferred editor by selecting "External Edit" from the Fix+Continue menu.Try out your changes.Selecting "Parse And Load" adds your changes to the executable you are debugging. The changed function will get executed the next time it is invoked. If you stopped in the edited function, the Debugger will let you continue from the corresponding line in the new function, barring certain restrictions.If the changes are satisfactory, save them for later compiling."Save File+Fixes As..." saves the fixes in your current file. "Update All Files..." saves all fixes in your current session.At any point, you can make comparisons with your old code. "Show Difference" displays the old and new source code in a side-by-side format. "Edited<-->Compiled" lets you toggle between the old and new executables making it easy to verify or demonstrate your bug fix.LBL="" HELPID=""Where to Find Fix and Continue InformationTo find out more information about Fix and Continue, refer to IDREF="59082" TYPE="TABLE"Table 8.COLUMNS="2"LBL="8"Table 8 ID="59082"Where to Find Fix and Continue Information in the Developer Magic: 
Debugger User's GuideLEFT="0" WIDTH="166"Topic LEFT="175" WIDTH="166"See ...LEFT="0" WIDTH="166"General information and tutorialLEFT="175" WIDTH="166"IDREF="39823" BOOK="Debugger_UG" FILE="7TutF+C.doc" HDG=""Chapter 7, "Debugging with 
Fix+Continue: A Tutorial"LEFT="0" WIDTH="166"Detailed command information LEFT="175" WIDTH="166"IDREF="12535" BOOK="Debugger_UG" FILE="AReference.doc" HDG="""Fix+Continue Windows"LBL="" HELPID=""ID="68245"Debugging X/Motif ProgramsThe X/Motif Analyzer provides special debugging support for X/Motif applications and is available from the WorkShop Views menu. The X/Motif Analyzer operates in a number of modes (referred to as examiners) for examining different types of X/Motif objects. The X/Motif Analyzer provides information unavailable through conventional debuggers. It also lets you set widget-level breakpoints and collect X event history.When you first invoke the X/Motif Analyzer, it comes up in its Widget Examiner mode. You can switch to the other examiners through the Examiner menu or by clicking the tabs at the bottom of the window (See IDREF="73887" TYPE="GRAPHIC"Figure 15).FILE="ch15.gif" POSITION="INLINE" SCALE="FALSE"LBL="15"Figure 15 ID="73887"The X/Motif Analyzer WindowLBL="" HELPID=""Features of the X/Motif AnalyzerThe X/Motif Analyzer provides the following types of examiners:Widget examinername='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'identifies a widget's ID, name, class, and parent, and displays its definitions. Widget tree examinername='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'displays the widget hierarchy (see IDREF="76511" TYPE="GRAPHIC"Figure 16). The widgets can be displayed by name, class, or ID by selecting from the widget display menu. Double-clicking a widget node switches to the widget examiner and displays the data for the selected widget.FILE="ch16.gif" POSITION="INLINE" SCALE="FALSE"LBL="16"Figure 16 ID="76511"X/Motif Analyzer Widget Tree ExaminerBreakpoints examinername='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'lets you set breakpoints at the widget and widget class level. You can set breakpoints atcallback functionswidget eventsresource changes causedtimeout callback functionsinput callback functionswidget state changesX eventsX requestsTrace examinername='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'lets you trace the execution of your application and collect the following types of data:X Server EventsX Server Requestswidget event dispatch informationwidget resource changeswidget state changesXt callbacksIDREF="62195" TYPE="GRAPHIC"Figure 17 is a typical example of the trace examiner. The events appear in a list. Double-clicking an event displays its details.Callback examinername='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'comes up automatically when the process stops in a callback. It displays the callstack frame for the callback functionwidget informationthe callback data structure Window examinername='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'identifies the window, its parent and any children, and displays window attribute informationEvent examinername='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'displays the event structure for a given XEvent pointerGraphics context (GC) examinername='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'displays the X graphics context attributes for a given GC pointerPixmap examinername='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'displays the basic attributes of an X pixmap, including size and depth, and can provide an ASCII display of small pixmaps, using the units digit of the pixel valueswidget class examinername='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'displays the widget class attributes for a given widget class pointer FILE="ch17.gif" POSITION="INLINE" SCALE="FALSE"LBL="17"Figure 17 ID="62195"X/Motif Analyzer Trace ExaminerLBL="" HELPID=""Where to Find X/Motif Analyzer InformationTo find out more information about the X/Motif Analyzer, refer to IDREF="48216" TYPE="TABLE"Table 9.COLUMNS="2"LBL="9"Table 9 ID="48216"Where to Find X/Motif Analyzer information in the Developer Magic: 
Debugger User's GuideLEFT="0" WIDTH="166"Topic LEFT="175" WIDTH="166"See ...LEFT="0" WIDTH="166"General information and tutorialLEFT="175" WIDTH="166"IDREF="97409" BOOK="Debugger_UG" FILE="10TutCvmotif.doc" HDG=""Chapter 10, "Using the X/Motif 
Analyzer: A Tutorial"LEFT="0" WIDTH="166"Detailed reference informationLEFT="175" WIDTH="166"IDREF="17727" BOOK="Debugger_UG" FILE="AReference.doc" HDG="""X/Motif Analyzer Windows"LEFT="0" WIDTH="166"Setting breakpoints to capture 
widget-level informationLEFT="175" WIDTH="166"IDREF="37518" BOOK="Debugger_UG" FILE="AReference.doc" HDG="""Breakpoints Examiner"LEFT="0" WIDTH="166"Tracing widget-level data through the 
execution of a programLEFT="175" WIDTH="166"IDREF="22611" BOOK="Debugger_UG" FILE="AReference.doc" HDG="""Trace Examiner"LEFT="0" WIDTH="166"Getting information on a specified 
widget LEFT="175" WIDTH="166"IDREF="67883" BOOK="Debugger_UG" FILE="AReference.doc" HDG="""Widget Examiner"LEFT="0" WIDTH="166"Displaying a graph of the widget 
hierarchyLEFT="175" WIDTH="166"IDREF="21251" BOOK="Debugger_UG" FILE="AReference.doc" HDG="""Tree Examiner"LEFT="0" WIDTH="166"Getting information on a specified 
callbackLEFT="175" WIDTH="166"IDREF="31463" BOOK="Debugger_UG" FILE="AReference.doc" HDG="""Callback Examiner"LEFT="0" WIDTH="166"Getting information on a specified 
windowLEFT="175" WIDTH="166"IDREF="91799" BOOK="Debugger_UG" FILE="AReference.doc" HDG="""Window Examiner"LEFT="0" WIDTH="166"Getting information on a specified X 
eventLEFT="175" WIDTH="166"IDREF="14627" BOOK="Debugger_UG" FILE="AReference.doc" HDG="""Event Examiner"LEFT="0" WIDTH="166"Getting information on a specified 
graphics context LEFT="175" WIDTH="166"IDREF="67664" BOOK="Debugger_UG" FILE="AReference.doc" HDG="""Graphics Context Examiner"LEFT="0" WIDTH="166"Getting information on a specified 
pixmapLEFT="175" WIDTH="166"IDREF="86505" BOOK="Debugger_UG" FILE="AReference.doc" HDG="""Pixmap Examiner"LBL="" HELPID=""ID="43033"Building Application Interfaces With RapidAppRapidApp is a simple, interactive tool for creating application interfaces. It's integrated with the other WorkShop tools to provide a complete environment for developing object-oriented applications quickly and easily. RapidApp generates C++ code, with interface classes based on the IRIS ViewKit toolkit and IRIS IM (the Silicon Graphics version of X/Motif). RapidApp also includes predefined interface components that allow you to conveniently use other Developer Magic libraries such as OpenGL‘ and Open Inventor‘. Applications produced by RapidApp are automatically integrated into the Indigo Magic Desktop environment, letting you take advantage of Silicon Graphics' interface and desktop technology. Working with RapidApp is similar to using a drawing tool such as Showcase‘. A typical RapidApp window is shown in IDREF="70312" TYPE="GRAPHIC"Figure 18. RapidApp lets you create interface elements by clicking icons representing widgets or components in the palette area, positioning them in a template window, and setting their resources in the editing area.FILE="ch18.gif" POSITION="INLINE" SCALE="FALSE"LBL="18"Figure 18 ID="70312"RapidApp Window Displaying Container PaletteLBL="" HELPID=""RapidApp User ModelRapidApp users should be familiar with IRIX IM, IRIS ViewKit, and C++ programming. Here's the basic user model:Invoke RapidApp by typing rapidapp in the directory in which you wish to build your application.The RapidApp window is displayed as shown in IDREF="70312" TYPE="GRAPHIC"Figure 18. There are six palettes of icon widgets available. The number of palettes and icons available will increase over time as new, useful widgets are developed. The palettes and icons are:Container palettename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'provides container widgets, that is, widgets that can hold other widgetsControls palettename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'provides miscellaneous widgets, typically for controls, fields, and so on. Windows palettename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'provides simple or special-purpose windows and window-oriented controls, such as menu bars and pulldown menusViewKit palettename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'provides ViewKit components, that is, prepackaged assemblies of widgets from the ViewKit librariesInventor palettename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'provides viewers, editors, and drawing areas compatible with IRIS Inventor‘The process is then one of selecting containers, populating them with widgets, and assembling them into elements of your user interface. Select a container widget.A rubber-band box appears, representing the initial default size of the widget. Use the mouse to drag it to a working area on your desktop (or inside another container). After you've positioned the new container widget, you can adjust its size by dragging the corners.Edit the widget's resources.Customize the widget for your application. RapidApp changes the resource editing area according to the type of widget you are working with. It displays text fields for string resources, radio buttons for Booleans, and menus for resources with multiple values. IDREF="56493" TYPE="GRAPHIC"Figure 19 illustrates the creation of a drawing area container widget. The drawing area icon has been selected from the container palette, the new widget has been placed, and the resource editing area has changed accordingly.FILE="ch14.gif" POSITION="INLINE" SCALE="FALSE"LBL="19"Figure 19 ID="56493"Creating a WidgetSelect "Play Mode" from the View menu.This lets you try out the interface design. When you are through trying it out, go back to working on the interface by selecting "Build Mode" from the View menu.Perform any further edits on the widget.Repeat steps 2-5 until your window (or application) is complete.Select "Generate C++" from the Project menu.This produces the source code (including Makefile) necessary to implement the interface you have designed. It also displays the Builder information window, a shell that displays RapidApp status messages. Select "Edit File ..." from the Project menu to make any necessary adjustments to the source code.A file selection dialog box displays showing the contents of the directory containing the generated source files. When you choose a file, it will appear in your default editor. Select "Build Application" from the Project menu to compile the new program.The WorkShop Build View displays and starts a compile going and lets you view any compile errors (see IDREF="99638" TYPE="TITLE""Recompiling Within the ProDev WorkShop Environment With Build Manager").Use the other ProDev WorkShop and MegaDev tools, if necessary, to fix any coding problems.RapidApp is fully integrated with the rest of the Developer Magic environment so that the full range of tools and libraries are at your disposal for completing your application.LBL="" HELPID=""Where to Find RapidApp InformationTo find out more information about RapidApp, refer to Table 10.COLUMNS="2"LBL="10"Table 10 ID="48216"Where to Find RapidApp Information in the Developer Magic: 
Application Builder User's GuideLEFT="0" WIDTH="166"Topic LEFT="175" WIDTH="166"See ...LEFT="0" WIDTH="166"Understanding the RapidApp windowLEFT="175" WIDTH="166"IDREF="24446" BOOK="BuilderUG" FILE="01.doc" HDG="""The RapidApp Interface" in Chapter 1LEFT="0" WIDTH="166"Using RapidApp LEFT="175" WIDTH="166"IDREF="15713" BOOK="BuilderUG" FILE="01.doc" HDG="""Basic Interaction Techniques" in 
Chapter 1 and IDREF="96510" BOOK="BuilderUG" FILE="03.doc" HDG=""Chapter 3, "Building 
Interfaces With RapidApp"LEFT="0" WIDTH="166"General tutorialLEFT="175" WIDTH="166"IDREF="43093" BOOK="BuilderUG" FILE="01.doc" HDG="""Example: A Calculator" in Chapter 1LEFT="0" WIDTH="166"Inventor tutorialLEFT="175" WIDTH="166"IDREF="90687" BOOK="BuilderUG" FILE="04.doc" HDG=""Chapter 4, "Example Programs"LEFT="0" WIDTH="166"WindowsLEFT="175" WIDTH="166"IDREF="59704" BOOK="BuilderUG" FILE="03.doc" HDG="""Choosing and Using Windows" in 
Chapter 3LEFT="0" WIDTH="166"ContainersLEFT="175" WIDTH="166"IDREF="77158" BOOK="BuilderUG" FILE="03.doc" HDG="""Using Containers" in Chapter 3LEFT="0" WIDTH="166"Generating software code LEFT="175" WIDTH="166"IDREF="77424" BOOK="BuilderUG" FILE="02.doc" HDG=""Chapter 2, "Creating Applications With 
RapidApp"LEFT="0" WIDTH="166"Applying the other ProDev tools to 
RapidApp applicationsLEFT="175" WIDTH="166"IDREF="12521" BOOK="BuilderUG" FILE="02.doc" HDG="""Debugging and Interactively Adding 
Functionality" in Chapter 2LEFT="0" WIDTH="166"Detailed reference information LEFT="175" WIDTH="166"IDREF="11027" BOOK="BuilderUG" FILE="B.doc" HDG=""Appendix B, "RapidApp Reference"LBL="A"ID="95481"Using Graphical ViewsMany tools in ProDev WorkShop and related products provide graphical views. The graphical view is a useful device for depicting relationships. This appendix covers these topics:ID="appa1"IDREF="27423" TYPE="TITLE""General Graphical View Characteristics"IDREF="20457" TYPE="TITLE""Manipulating the Display"IDREF="35807" TYPE="TITLE""Filtering Nodes and Arcs"LBL="" HELPID=""ID="27423"General Graphical View CharacteristicsThe purpose of a graphical view is to provide an overview that shows relationships between entities and a means of accessing the detail information. In a graphical view, entities are shown as rectangles (or 
nodes) and relationships as connecting arrows (or 
arcs). When entities represent source code, double-clicking a node will bring up Source View with the corresponding code available for editing.A typical graphical view appears in IDREF="30258" TYPE="GRAPHIC"Figure A-1. Graphical views have a display area with a row of controls underneath it. If the graph is larger than the viewing area, scroll bars will be enabled. FILE="appa6.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-1"Figure A-1 ID="30258"Typical Graphical ViewSince an overwhelming amount of information can be displayed in a graphical view, a number of methods are provided for simplifying the display. They fall into two categories: those that manipulate the display without changing the current contents and those that let you filter nodes and arcs from the display.LBL="" HELPID=""ID="20457"Manipulating the DisplayThis section covers those methods that change the display without altering the contents.LBL="" HELPID=""Graph Control AreaAll graphical views have a control area containing a row of graph controls as shown in ID="appa2"IDREF="38166" TYPE="GRAPHIC"Figure A-2. FILE="appa4.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-2"Figure A-2 ID="38166"Graph Display ControlsNoteIn some cases, the Multiple Arcs button may be disabled. This is appropriate where there can only be one arc between nodes.These graphical view controls are:ID="appa3"


Zoom menu shows the current scale of the graph. If clicked on, a pop-up menu appears displaying other available scales. The scaling range is between 15% and 300% of the normal (100%) size.ID="appa4"


Zoom Out buttonresets the scale of the graph to the next available smaller size in the range.ID="appa5"


Zoom In buttonresets the scale of the graph to the next available larger size in the range.NoteIf you reposition the nodes by dragging and then use one of the Zoom buttons, the configuration will return to the initial position.ID="appa6"


Overview buttoninvokes the overview pop-up display, which shows a scaled-down representation of the graph. The nodes appear in the analogous places on the overview pop-up, and a white outline may be used to position the main graph relative to the pop-up. Alternatively, the main graph may be repositioned with its scroll bars. See the following section.ID="appa7"Multiple Arcs buttontoggles between single and multiple arc mode. Multiple arc mode is extremely useful for the "List Arcs" query, because it indicates graphically how many of the paths between two functions were actually used. ID="appa8"


Realign buttonredraws the graph, restoring the positions of any nodes that were repositioned.ID="appa9"


Rotate buttonflips the orientation of the graph between horizontal (calling nodes at the left) and vertical (calling nodes at the top).NoteIf you reposition the nodes by dragging and then change orientation, the nodes will return to the initial positioning relative to each other.LBL="" HELPID=""Overview WindowThe Overview window lets you view the entire graph at a reduced scale. To display the Overview window, you click the ID="appa10"overview button (see IDREF="98994" TYPE="GRAPHIC"Figure A-3). IDREF="48208" TYPE="GRAPHIC"Figure A-4 shows a typical Overview window with the resulting graph. The Overview window has a movable viewport that lets you select the portion of the graph displayed in the main window. Special nodes and arcs are highlighted for easy detection. FILE="fAadmmn.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-3"Figure A-3 ID="98994"Admin Menu in the Overview WindowThe Overview window has an Admin menu (see IDREF="98994" TYPE="GRAPHIC"Figure A-3) with these three selections:"Scale to Fit"ID="appa11"scales the graph to match the aspect ratio of the overview window."Show Arcs"ID="appa12"displays or hides the arcs between the nodes. "Close"ID="appa13"closes the Overview window.FILE="fA4ovrvu.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-4"Figure A-4 ID="48208"Overview Window with Resulting GraphLBL="" HELPID=""Using the Mouse in a GraphYou can move an individual node in a graph by dragging it with the middle mouse button. This can help reveal obscured arc annotations.ID="appa14"You can select multiple nodes by dragging a selection rectangle around them. You can Ctrl-click to add a single node to the group. Shift-clicking a node adds it to the group along with all the nodes that it calls. Once you have selected a group of nodes, you can move them as a group with the middle mouse button or perform other operations on them.LBL="" HELPID=""Selecting Nodes from outside the GraphOften you can specify a node from a text view, search field, or dialog box and it will be highlighted in the graph.LBL="" HELPID=""ID="35807"Filtering Nodes and ArcsAnother approach to simplifying a graph is to reduce the number of nodes and arcs. Different tools have different filtering options. All graphs have two types of node menus (accessed by holding the right mouse button) for filtering nodes: the Node menu and the Selected Nodes menu. Both menus are shown in ID="appa15"IDREF="36789" TYPE="GRAPHIC"Figure A-5.FILE="appa.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-5"Figure A-5 ID="36789"Node Pop-up MenusLBL="" HELPID=""ID="87672"Node MenuThe Node menu lets you filter a single node. It is displayed by holding the right mouse button down while the cursor is over the node. The name of the selected node appears at the top of the menu. The Node menu selections are:ID="appa16""Hide Node"ID="appa17"removes the selected node from the graph display."Collapse Subgraph"ID="appa18"removes the nodes called by the selected node (and subsequently called nodes) from the graph display."Show Immediate Children"ID="appa19"displays the functions called by the selected node."Show Parents"ID="appa20"displays all the functions that call the selected node."Show All Children"ID="appa21"displays all the functions (descendants) called by the selected node.LBL="" HELPID=""Selected Nodes MenuThe Selected Nodes menu lets you filter multiple nodes. You can select multiple nodes by dragging a selection rectangle around them. You can also Shift-click a node and it will be selected along with all the nodes that it calls. Holding down the right mouse button anywhere in the graph displays the Selected Nodes menu. The Selected Nodes menu items are:ID="appa22""Hide"ID="appa23"removes the selected nodes from the graph display."Collapse"ID="appa24"removes the nodes called by the selected nodes (and descendant nodes) from the graph display."Expand"ID="appa25"displays all the functions (descendants) called by the selected node.LBL="B"ID="13867"Customizing ProDev ID="65152"WorkShop ToolsIf the configuration of a window or view does not meet your particular needs, you may be able to adjust the graphical user interface accordingly. This appendix discusses how to make such changes.ID="appb1"IDREF="92470" TYPE="TITLE""Customizing Within ProDev WorkShop"IDREF="25087" TYPE="TITLE""Changing X Resources"LBL="" HELPID=""ID="92470"Customizing Within ProDev WorkShopIf you want to change the appearance of the ProDev WorkShop windows, we recommend that you start with the menus provided for that purpose:ID="appb2"WorkShop Main View: Display menuArray Browser: Color, Scale, Format, and Spreadsheet menusCall Stack View: Config and Display menusDisassembly View: Config, Disassemble, and Display menusExpression View: Config, Display, Language popup, and Format popup menusMemory View: Mode menuProcess Meter: Charts and Scale menuRegister View: Config menuSource View: Display menuStructure Browser: Config, Display, Node, and Format popup menusTrap Manager: Config and Display menusVariable Browser: Language popup, and Format popup menusBuild Analyzer: Filter, Selected Node popup and Node popup menus and graphic controlsBuild View: Admin menuname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'"Preferences..." and "Build Options..."Performance Analyzer: Config menus in all views, and Selected Node popup and Node popup menus and graphic controls in graphical viewsStatic Analyzer: Views menu, and Selected Node popup and Node popup menus and graphic controls in graphical viewsTester: Views menu, and Selected Node popup and Node popup menus and graphic controls in graphical viewsLBL="" HELPID=""ID="25087"Changing X ResourcesWhile there are hundreds of X resources that can be changed, we recommend that you avoid modifying recources if at all possible. However, in some cases, there may be no way within WorkShop to make the desired change. Here are some X resources for the Debugger and its views that you may find useful: ID="appb3"*autoStringFormatif true, sets default format for *char results as strings in Expression View, the Variable Browser, and the Structure Browser; otherwise the default format will be the hex address. *varBrowser*maxSymSizelets you set the maximum number of variables that can be displayed by the Variable Browser. The current default is 25. *expressionView*maxNumOfExprlets you set the maximum number of expressions that can be read from a file by Expression View. The current default is 25.cvmain*sourceView*nameText.columnssets the length of the File field in the WorkShop Main View window. The default is 30 characters.Cvmain*disableLicenseWarnings and *disableLicenseWarningsdisable the license warning messagse that display when you start cvd and the other tools.The following resources apply to Source View:*tabWidthsets the number of spaces for tabs in Source View. *sourceView*textEdit.scrollHorizontalif true, displays a horizontal scroll bar in Source View. *sourceView*nameText.columnssets the length of the File field in Source View. The default is 30 characters.*svComponent*lineNumbersVisibledisplays source line numbers by default.The following resource applies to the Build Analyzer:*buildCommandis used by the Build Analyzer to determine which program to use to build with (make, smake, clearmake, etc.). The default value is make.To change these resources, you need to set the desired value in your .Xdefaults file, re-run xrdb if you use it, and then restart your application so that the resource gets picked up. Glossaryanti-leakSee bad free.arcA relation between two entities in a program depicted graphically as lines between rectangles (nodes). For example, arcs can represent function calls, file dependency, or inheritance.Array BrowserA Debugger view that displays the values of an array in a spreadsheet format and can also depict them graphically in a 3D rendering.bad freeA problem that occurs when a program frees a malloced piece of memory that it had already freed (also referred to as an anti-leak condition or double free).Bar Graph ViewA display mode of Tester that shows a summary of coverage information in a bar graph.basic blockA block of machine-level instructions used as a metric in Performance Analyzer and Tester experiments. A basic block is the largest set of consecutive machine instructions that can be formed with no branches into or out of them. boundary overrunA problem that occurs when a program writes beyond a specified region, for example overwriting the end of an array or a malloced structure.boundary underrunA problem that occurs when a program writes in front of a specified region, for example writing ahead of the first element in an array or a malloced structure.breakpointSee trapBrowser (Static Analyzer)A facility within the Static Analyzer for viewing structural and relationship information in C++ or Ada programs. It provides three views: Browser View for displaying member and class information; Class Graph for displaying inheritance, containment, interaction, and friend relationships in the hierarchy; and Call Graph for displaying the calling relationships of methods, virtual methods, and functions.Build AnalyzerA view that displays a graph of program files (source and object) indicating build dependencies and provides access to the source files.Build ManagerA tool for recompiling programs within WorkShop. The Build Manager has two windows: Build Analyzer and Build View.Build ViewA view that lets you run compiles. In addition, Build View displays compile errors and provides access to the code containing the errors.calipersSee time linecall graphA generic term for views used in several tools (Static Analyzer, C++ Browser, Performance Analyzer, and Tester) that display a graph of the calling hierarchy of functions. Double-clicking a function in a call graph causes the Source View window to be displayed showing the function's source code.Call GraphA display mode of the C++ Browser that shows methods and their calls. See also call graph and C++ Browser.Call Graph ViewA display mode of the Performance Analyzer that shows functions, their calls, and associated performance data. See also call graph and C++ Browser.Call StackA view that displays the call stack at the current context. In the Debugger this means where the process is stopped; in the Performance Analyzer this means sample traps and other events where data was written out to disk. Each frame in the Call Stack window can show the function; argument names, values, and types; the function's source file and line number; and the PC (program counter). Double-clicking a frame in the Call Stack causes the Source View window to be displayed showing the corresponding source code.Call Tree View (Static Analyzer version)A display mode of the Static Analyzer that displays the results of function queries as a call graph. See also call graph and Static AnalyzerCall Tree View (Tester version)A display mode of Tester that displays function coverage information in a call graph. See also TesterCall ViewA display mode of the C++ Browser for displaying member and class information. See also C++ BrowserClass GraphA display mode of the C++ Browser for displaying inheritance, containment, interaction, and friend relationships in the class hierarchy.Class Tree ViewA display mode of the Static Analyzer that displays the results of class queries as a class hierarchy. See also Static AnalyzerClearCaseA tool in the Developer Magic‘ environment for performing configuration management and version control. command line (Debugger)A field in the Debugger Main View that lets you enter a set of commands similar to dbx commands.cordA system command used to rearrange procedures in an executable to reduce paging and achieve better instruction cache mapping. The Cord Analyzer and Working Set View let you analyze the effectiveness of an arrangement and try out new arrangements to improve efficiency.Cord AnalyzerA tool that lets you analyze the paging efficiency of your executable's working sets, that is, the executable code brought into memory during a particular phase or operation. It also calculates an optimized ordering and lets you try out different working set configurations to reduce paging problems. The Cord Analyzer works with the Working Set View, a part of the Performance Analyzer. See also cord, working set, and Working Set View countsThe number of times a piece of code (function, line, instruction, or basic block) was executed as listed by Tester or the Performance Analyzer.coverageA term used in Tester. Coverage means a test has exercised a particular unit of source code, such as functions, individual source lines, arcs, blocks, or branches. In the case of branches, coverage means the branch has been executed under both true and false conditions.CPU-boundA performance analysis term for a condition in which a process spends its time in the CPU and is limited by CPU speed and availability.CPU timeA performance analysis metric approximating the time spent in the CPU. CPU time is calculated by multiplying the number of times a PC appears in the profile of a function, source line, or instruction by 10 ms.cvcordThe name of the Cord Analyzer executable. See also Cord AnalyzercvcovThe name of the Tester command line interface executable. See also TestercvdThe name of the Debugger executable. cvd has options for attaching the Debugger to a running process (-pid), examining core files (executable), and running from a remote host (-host). See also DebuggercvperfThe name of the executable that calls the Performance Analyzer. cvperf has an option (-exp) for designating the name of the experiment directory. See also Performance AnalyzercvspeedThe name of the executable that brings up the Performance Panel, a window for setting up Performance Analyzer experiments. See also Performance Panel cvstaticThe name of the executable that calls the Static Analyzer. See also Static AnalyzercvxcovThe name of the executable that calls the graphical interface of Tester. See also Testercycle countThe specified number of times to hit a breakpoint before stopping the process, it defaults to 1. The cycle count for any trap can be set through the Trap Manager view in the Debugger.DCCA native C++ compiler that allows you to use dynamic classes (also known as Delta C++). See also the DCC(1) reference page for more informationDebuggerA tool in ProDev WorkShop for analyzing general software problems using a live process. The Debugger lets you stop the process at specific locations in the code by setting breakpoints (referred to as traps) or by clicking the Stop button. At each trap, you can display special windows called views, for examining data. See alsocvdDisassembly ViewA view that lets you see the program's machine-level code. The Debugger version shows you the code; the Performance Analyzer version additionally displays performance data for each line.double freeSee bad freeDSO (dynamic shared object)An ELF (Executable and Linking Format) format object file, similar in structure to an executable program but with no main. It has a shared component, consisting of shared text and read-only data; a private component, consisting of data and the GOT (Global Offset Table); several sections that hold information necessary to load and link the object; and a liblist, the list of other shared objects referenced by this object. Most of the libraries supplied by SGI are available as dynamic shared objects.erroneous freeA problem that occurs when a program calls free() on addresses that were not returned by malloc, such as static, global, or automatic variables, or other invalid expressions.eventAn action that takes place during a process, such as a function call, signal, or a form of user interaction. The Performance Analyzer uses event tracing in experiments to help you correlate measurements to points in the process where events occurred.exclusive performance dataPerformance Analyzer data collected for a function without including the data for any functions it calls. See also inclusive performance dataExecution ViewA Debugger view that serves as a simple shell to provide access outside of WorkShop. It's typically used to set environment variables, inspect error messages, and conduct I/O with the program being debugged.experimentThe model for using the Performance Analyzer and Tester. The steps in creating an experiment are (1) creating a directory to hold the results, (2) instrumenting the executable (instrumentation is recompiling with special libraries for collecting data), (3) running the instrumented executable as a test, and (4) analyzing the results using the views in the tools. The first two steps are done automatically when you use the Performance Panel and select a performance task (performance experiments only). The term experiment can also refer to the actual data itself that was saved.Expression ViewA Debugger view that lets you specify one or more expressions to be evaluated whenever the process stops or the callstack context is changed. Expression View lets you save sets of expressions for subsequent reuse, specify the language of the expression (Ada, Fortran, C, or C++), and specify the format for the resulting values.File Dependency ViewA display mode of the Static Analyzer that displays the results of queries in a graph indicating file dependency relationships. See also Static AnalyzerFileset EditorA window for specifying a fileset, that is, the set of files to be used in creating a database for Static Analyzer queries. The Fileset Editor also lets you specify whether a file is to be analyzed using scanner mode or parser mode. See also parser mode, scanner mode, and Static Analyzerfine-grained usageA technique in performance analysis that captures resource usage data between sample traps.Fix + ContinueA feature in the Debugger that lets you make source level changes and continue debugging without having to perform a full compile and relinking.floating point exceptionA problem that occurs when a program cannot complete a numerical calculation due to division by zero, overflow, underflow, inexact result, or invalid operand. Floating point exceptions can be captured by the Performance Analyzer and can also be identified in the Array Browser.freed memoryFreed memory is memory that was originally malloced and has been returned for general use by calling free(). Accessing freed memory is a problem that occurs when a program attempts to read or write this memory, possibly corrupting the free list maintained by malloc. function listA generic type of view used in several tools (Static Analyzer, Performance Analyzer, Tester, and Cord Analyzer) to list functions and related information, such as location, experiment data, and executable code size. Double-clicking a function displays its source code in Source View.GLDebugA graphical software tool for debugging application programs that use the IRIS Graphics Library (GL). GLdebug locates programming errors in executables when GL calls are used incorrectly. GLDebug is not part of WorkShop but is accessible from the Admin menu in Main View.heap corruptionA memory problem that may be due to boundary overrun or underrun, accessing uninitialized memory, accessing freed memory, freeing a memory location twice, or attempting to free a memory location erroneously. See also malloc debugging libraryHeap ViewA Performance Analyzer view that displays a map of memory indicating how blocks of memory were used in the time interval set by the time line calipers.ideal timeA performance analysis metric that assumes that each instruction takes one cycle of the particular machine's time. It's then useful to compare the ideal time with the actual time in an experiment.inclusive performance dataPerformance Analyzer data collected for a function where the total includes data for all of the called functions. See also exclusive performance datainstrumentationSee experimentI/O-boundA performance analysis term for a condition in which a process has to wait for I/O to complete and may be limited by disk access speeds or memory caching.I/O ViewA Performance Analyzer view that displays a chart devoted to I/O system calls. I/O View can identify up to 10 files involved in I/O.IRIS IM‘A user interface toolkit on Silicon Graphics“ systems based on X/Motif“.IRIS IM AnalyzerA Debugger view for debugging X/Motif applications. The IRIS IM Analyzer lets you look at object data, set breakpoints at the object or X protocol level, trace X and widget events, and tune performance.IRIS ViewKit‘A Developer Magic toolkit that provides predefined widgets and classes for building applications.Leak ViewA Performance Analyzer view that displays each memory leak that occurred in your experiment, its size, the number of times the leak occurred at that location during the experiment, and the call stack corresponding to the selected leak. library search pathA path you may need to specify when debugging executables or core files to indicate which DSOs (dynamic shared objects) are required for debugging. See also DSOMain ViewThe main window of the Debugger. The MainView provides access to other tools and views, process controls, a source code display, and a command line for entering a set of commands similar to dbx. You can also add custom buttons to Main View using the command line.Malloc Error ViewA Performance Analyzer view that displays each malloc error (leaks and bad frees) that occurred in an experiment, the number of times the malloc occurred (a count is kept of mallocs with identical call stacks), and the call stack corresponding to the selected malloc error. malloc debugging libraryA special library (libmalloc_cv.a) for detecting heap corruption problems. Relinking your executable with the malloc library sets up mechanisms for trapping memory problems.Malloc ViewA Performance Analyzer view that displays each malloc (whether or not it caused a problem) that occurred in your experiment, its size, the number of times the malloc occurred (a count is kept of mallocs with identical call stacks), and the call stack corresponding to the selected malloc.MegaDevThe package name for a set of advanced Developer Magic tools for the development of C and C++ applications.Memory-boundA performance analysis term for a condition in which a process continuously needs to swap out pages of memory.memory leakA problem when a program dynamically allocates memory and fails to deallocate that memory when it is through with the space.Memory ViewA Debugger view that lets you see or change the contents of memory locations.Multiprocess ViewA Debugger view that lets you manage the debugging of a multiprocess executable. For example, you can set traps in individual processes or across groups of processes.NCCA native C++ compiler that uses the same compiler as DCC, but doesn't allow you to use dynamic classes.nodeThe rectangles in graphical views. A node may represent a function, class, or file depending on the type of graph.Overview windowA window in graphical views that displays the current graph at a reduced scale and lets you navigate to different parts of the graph.paletteThe portion of the RapidApp window that provides user interface elements for creating graphical interfaces. See also RapidAppparser modeA method of extracting Static Analyzer data from source files. Parser mode uses the compiler to build the Static Analyzer database. It is language-specific and very thorough; as a result, it is slower than scanner mode. See also scanner mode and Static AnalyzerPath RemappingA dialog box that lets you set mappings to redirect filenames used in building your executable to their actual locations in the filesystem.PC (program counter)The current line in a stopped process, indicated by a right-pointing arrow with a highlight in the source code display areas and by a highlighted frame in the Call Stack views.Performance AnalyzerA tool in ProDev WorkShop for measuring the performance of an application. To use the tool, you select one of the predefined analysis tasks, run an experiment, and examine the results in one of the Performance Analyzer views. See alsocvperfPerformance PanelA window for setting up Performance Analyzer experiments. The panel displays toggles and fields for specifying data to be captured. As a convenience, you can select performance tasks (such as "Determine bottlenecks..." or "Find memory leaks") from a menu that specifies the data automatically. See alsocvspeedperformance taskSee Performance PanelphaseA performance analysis term for a period in an experiment covering a single activity. In a phase, there is one limiting resource that controls the speed of execution.pollpoint samplingA technique in performance analysis that captures performance data, such as resource usage or event tracing, at regular intervals.Process MeterA view that monitors the resource usage of a running process without saving the data. See also Performance Analyzer and Performance PanelProDev WorkShop The package name for the core WorkShop tools.profileA record of a program's PC (program counter), call stack, and resource consumption over time, used in performance analysis.Project ViewA Debugger view for managing ProDev WorkShop and MegaDev tools operating on a common target.queryThe term for a search through a Static Analyzer database to locate elements in your program. Queries are similar to the IRIX grep command but provide a more specific search. For example, you can perform a query to find where a method is defined. See also Static AnalyzerRapidAppA tool in the Developer Magic environment for creating graphical interfaces quickly and easily. RapidApp lets you drag and drop user interface elements (for example, IRIS IM widgets, IRIS ViewKit components, Inventor components, and so on) onto a template window to create the interface.Register ViewA Debugger view that lets you see or change the contents of the machine registers.Results FilterA dialog box that lets you limit the scope of Static Analyzer queries. See also query and Static Analyzersample trapSimilar to a stop trap except that instead of stopping the process, performance data is written out to disk and the process continues running. See also trapsamplingIn performance analysis, the capture of performance data, such as resource usage or event tracing, at points in an experiment so that a graph of usage over time can be created.scanner modeA method of extracting Static Analyzer data from source files. Scanner mode is fast but not language-specific so that the source code need not be compilable. Results may have minor inaccuracies. See also parser mode and Static AnalyzerSignal PanelA dialog box for specifying signals to trap.Smart BuildAn option to the compiler where only those files that must be recompiled are recompiled. Source ViewA window for viewing or editing source code. Source View is an alternative editing window to Main View. If you have conducted Performance Analyzer or Tester experiments, you can view the results in the column to the left of the source code display area.stackSee Call StackStatic AnalyzerA tool in ProDev WorkShop for viewing the structure of a program at different levels and locating where elements of the program are used or defined. The Static Analyzer works by extracting structure and location information from files that you specify and storing the information in a database for subsequent analysis. You can view the analysis as a text list or graphically. See alsocvstatic, Call Tree View, Class Tree View, File Dependency View, and Text Viewstop trapA breakpoint. See also trapStructure BrowserA Debugger view that graphically displays data structures including data values and pointer relationships.Syscall PanelA dialog box for specifying system calls to trap. You can designate whether to trap the system calls at the entry or exit from the call.test groupA grouping of experiments in Tester used to test a common DSO (dynamic shared object).test setA group of experiments in Tester used to test a common executable.TesterA tool in ProDev WorkShop for measuring dynamic coverage over a set of tests. It tracks the execution of functions, individual source lines, arcs, blocks, and branches. Tester has both a command line and a graphical interface.Text View (Static Analyzer version)A display mode of the Static Analyzer that displays the results of queries as a scrollable text list. See also Static AnalyzerText View (Tester version)A display mode of Tester that displays function coverage information in a report form. See also Testertime lineA feature in the main Performance Analyzer window that shows where events occurred in an experiment and provides calipers for controlling the scope of analysis for the Performance Analyzer views.tracingA record of a specified type of event (such as reads and writes, system calls, page faults, floating point exceptions, and mallocs, reallocs, and frees) over time, used in performance analysis.trapA mechanism for trapping data at specified points and conditions in a live process. Also referred to as a breakpoint. There are two types of traps: stop traps are used in debugging to halt a process, and sample traps are used in performance analysis to collect data without halting the process. See also watchpoint Trap ManagerA window for managing traps. It lets you set simple or conditional traps, browse (or modify) a list of traps, and save or load a set of traps.uninitialized memoryMemory that is allocated but not assigned any specific contents. Accessing uninitialized memory is a problem that occurs when a program attempts to read memory that has not yet been initialized with valid information.Usage View (Graphical)A Performance Analyzer view that contains charts indicating resource usage and the occurrence of events, corresponding to time intervals set by the time line calipers.Usage View (Textual)A Performance Analyzer view that displays the actual resource usage values corresponding to time intervals set by the time line calipers.Variable BrowserA Debugger view that displays the local variables valid in the current context and their values (or addresses). The Variable Browser also lets you view the previous value at the breakpoint. You can enter a new value directly if you wish.viewA window that lets you analyze data.ViewKitSee IRIS ViewKitwatchpointA trap that fires when a specified variable or address is read, written, or executed.working setThe set of executable pages, functions, and instructions brought into memory during a particular phase or operation. See also Working Set ViewWorking Set ViewA Performance Analyzer view that lets you measure the coverage of the dynamic shared objects (DSOs) that make up your executable. It indicates instructions, functions, and pages that were not used in a particular phase or operation in an experiment. Working Set View works with the Cord Analyzer. See also working set and Cord Analyzer"Close" selection in Overview Admin menuIDREF="appa13"Overview Window"Collapse Subgraph" selection in Node menuIDREF="appa18"Node Menu"Collapse" selection in Selected Nodes menuIDREF="appa24"Selected Nodes Menu"Expand" selection in Selected Nodes menuIDREF="appa25"Selected Nodes Menu"Hide Node" selection in Node menuIDREF="appa17"Node Menu"Hide" selection in Selected Nodes menuIDREF="appa23"Selected Nodes Menu"Scale to Fit" selection in Overview Admin menuIDREF="appa11"Overview Window"Show All Children" selection in Node menuIDREF="appa21"Node Menu"Show Arcs" selection in Overview Admin menuIDREF="appa12"Overview Window"Show Immediate Children" selection in Node menuIDREF="appa19"Node Menu"Show Parents" selection in Node menuIDREF="appa20"Node Menucustomizing workshopIDREF="appb1"Customizing ProDev WorkShop Toolsthrough menusIDREF="appb2"Customizing Within ProDev WorkShopthrough X resourcesIDREF="appb3"Changing X Resourcesgraph controlsIDREF="appa2"Graph Control Areagraphical viewsIDREF="appa1"Using Graphical Viewsfiltering techniquesIDREF="appa15"Filtering Nodes and Arcsmouse manipulationsIDREF="appa14"Using the Mouse in a GraphNode menuIDREF="appa16"Node Menumouse manipulationsgraphical viewsIDREF="appa14"Using the Mouse in a GraphMultiple Arcs buttonIDREF="appa7"Graph Control AreaNode menuIDREF="appa16"Node MenuOverview buttonIDREF="appa6"Graph Control AreaOverview windowgraphical viewsIDREF="appa10"Overview WindowRealign buttonIDREF="appa8"Graph Control AreaRotate buttonIDREF="appa9"Graph Control AreaSelected Nodes menuIDREF="appa22"Selected Nodes MenuZoom In buttonIDREF="appa5"Graph Control AreaZoom menuIDREF="appa3"Graph Control AreaZoom Out buttonIDREF="appa4"Graph Control Area