#EDIR DATA#
LANG=CLANG=CIndigo Magic User Interface Guidelines Document Number 007-2167-001TECHNICAL PUBLICATIONSWritten by Jackie Neider, Deb Galdes, John C. Stearns, and Arthur EvansIllustrated by John C. Stearns, Arthur Evans, Delle Maxwell, and Doug O'MorainEdited by Christina CaryStyle Card designed and illustrated by Kay MaitzPrincipal architects of the Silicon Graphics Style: Deb Galdes, Mike Mohageg, Michael Portuesi, Rob Myers, and Betsy ZellerSpecial thanks to Donna Davilla, Debbie Myers, Dave Ciemiewicz, Steve Yohanan, and Kim RachmelerOther contributions by Dave Story, Eva Manolis, Susan Dahlberg, Doug Young, Josie Wernecke, Susan Angebranndt, Roger Powell, Dave Mott, Tom Davis, David Curley, Ken Jones, Richard Wright, Ron Edmark, Victor Riley, Ashmeet Sidana, Ken Kershner, Joel Tesler, Bob Brown, Dan Miley, Greg Ferguson, Jerry Granucci, Ed Immenschuh, Grace Pariante, Delle Maxwell, Rebecca Underwood, James Raby, Pete Sullivan, Mike Chow, Tony Wong, Jamie Schein, Mike Keeler, Anna Wichansky, Beth Fryer, Robert Reimann© Copyright 1994, Silicon Graphics, Inc.name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' All Rights ReservedThis document contains proprietary and confidential information of Silicon Graphics, Inc. The contents of this document may not be disclosed to third parties, copied, or duplicated in any form, in whole or in part, without the prior written permission of Silicon Graphics, Inc.RESTRICTED RIGHTS LEGENDUse, duplication, or disclosure of the technical data contained in this document by the Government is subject to restrictions as set forth in subdivision (c) (1) (ii) of the Rights in Technical Data and Computer Software clause at DFARS 52.227-7013 and/or in similar or successor clauses in the FAR, or in the DOD or NASA FAR Supplement. Unpublished rights reserved under the Copyright Laws of the United States. Contractor/manufacturer is Silicon Graphics, Inc., 2011 N. Shoreline Blvd., Mountain View, CA 94043-1389.Silicon Graphics and IRIS are registered trademarks of Silicon Graphics, Inc. IRIX, Indigo Magic, InPerson, IRIS IM, IRIS InSight, and IRIS Showcase are trademarks of Silicon Graphics, Inc. UNIX is a registered trademark in the United States and other countries, licensed exclusively through X/Open Company, Ltd. Motif and OSF/Motif are trademarks of the Open Systems Foundation. MediaMail is a trademark of Z-Code Software Corp. PostScript is a registered trademark of Adobe Systems, Inc.ID="30361"About This GuideThis guide is written for developers of software products used on Silicon GraphicsÆ workstations, including software engineers, graphical user interface designers,  human factors specialists, and others involved in the design process. It contains recommended guidelines to help you design products that are consistent with other applications and that integrate seamlessly into the Indigo Magic‘ Desktop. The result of this consistency and integration is that your products work the way end users expect them to work; consequently, end users find your products easier to learn and use. This guide provides information on how to design user interfaces for Silicon Graphics applications, along with specific examples of what is and isn't appropriate and why. Note that the guidelines discussed in this book are just thatname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'guidelines, not rules; they're designed to apply to the majority of applications, but there will certainly be anomalous applications for which these guidelines don't make sense.This guide assumes you're programming with the IRIS IM‘ user interface toolkit. IRIS IM is the Silicon Graphics port of the industry-standard OSF/Motif‘ user interface toolkit for use on Silicon Graphics computers. The Indigo Magic guidelines encourage compliance with the OSF/Motif guidelines described in OSF/Motif Style Guide, Release 1.2, so you should be familiar with the OSF/Motif manual before reading this one. In addition, the Indigo Magic guidelines clarify and elaborate on many OSF/Motif style issues; they recommend many value-added extensions and improvements to the OSF/Motif style that don't conflict with the basic OSF/Motif interface. Following the recommendations in this book will help ensure that your software product provides all of the functionality and ease of use designed into the Indigo Magic Desktop.This guide also focuses on how your application should look and feel on the Indigo Magic Desktop when you're finished creating itname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'that is, how users will expect to be able to interact with your application. The implementation details of how to achieve this look and feel are covered in the OSF/Motif Programmer's Guide and the Indigo Magic Desktop Integration Guide. LBL="" HELPID=""What This Guide ContainsThis guide contains two parts, which are described in the following sections. For your convenience, this guide is available online so that you can search it using the IRIS InSight‘ Viewer; also, the online version contains many links to the Indigo Magic Desktop Integration Guide so that you can rapidly reach the necessary implementation information. Also available is the full-color Indigo Magic Style Card, which provides a quick overview of the important concepts presented in this guide.LBL="" HELPID=""Part One: Integrating With the Indigo Magic DesktopThis part describes how users will expect to be able to interact with your application from the Indigo Magic Desktop; it contains the following chapters: IDREF="73752" TYPE="TITLE"Chapter 1, "Overview of the Indigo Magic Desktop," sets the context for Part One; it gives you an overview of the desktop environment in which users will encounter your application and describes the mouse and keyboard hardware provided with Silicon Graphics systems.IDREF="94988" TYPE="TITLE"Chapter 2, "Icons," describes how to design your application and file icons so that they're meaningful, they properly reflect their state (such as selected or open), and they behave appropriately for user actions such as double-click and drag-and-drop. It also describes how to make your application icon accessible so that users can interact with your application through the desktop tools, such as the Icon Catalog and the Find an Icon tool. IDREF="42750" TYPE="TITLE"Chapter 3, "Windows in the Indigo Magic Environment," defines the various categories of windows and describes the Indigo Magic look for your application's windows. This look is an enhanced version of IRIS IM and includes pre-packaged color and font schemes. This chapter also covers the expected behaviors that your application's windows should supportname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'such as sizing, moving, and minimizing windows, managing the keyboard focus across windows, interacting with desks, and responding to session management.IDREF="43344" TYPE="TITLE"Chapter 4, "Indigo Magic Desktop Services," explains how your application can take advantage of several services provided by the Indigo Magic Desktop, such as Software Manager, SGIHelp, the IRIS InSight online documentation viewer, global desktop settings, and the File Alteration Monitor (FAM). IDREF="43344" TYPE="TITLE"Chapter 5, "Data Exchange on the Indigo Magic Desktop," describes the data transfer models that your application should support. It also lists the data types supported for data exchange in the Indigo Magic environment.LBL="" HELPID=""Part Two: Interface ComponentsThe second part of this guide describes the individual components of an application, such as windows, menus, controls, and dialogs. Part Two contains the following chapters:IDREF="71076" TYPE="TITLE"Chapter 6, "Application Windows" discusses the different types of windows, how your application should combine them, what elements are appropriate for primary and support windows, and how these elements should be arranged. IDREF="63208" TYPE="TITLE"Chapter 7, "Focus, Selection, and Drag and Drop" discusses three general mechanisms by which users interact with your application: keyboard focus (within a window), selection, and drag and drop.IDREF="98597" TYPE="TITLE"Chapter 8, "Menus" describes the kinds of menus your application can use (pull-down, popup, and option menus), how users display, traverse, activate, and close these menus, and how to design menus and menu items for your application.IDREF="95140" TYPE="TITLE"Chapter 9, "Controls" describes controls that are supported in the standard OSF/Motif environment (such as push buttons, lists, and scrollbars) and those that are unique to the Indigo Magic environment (such as thumbwheels and dials). Each description consists of a general description of the control, and guidelines for when to use the control, how to label the control, and how the control should behave. IDREF="30192" TYPE="TITLE"Chapter 10, "Dialogs" defines the standard types of dialogs and discusses when to use them. It also covers how to design application-specific dialogs.IDREF="58675" TYPE="TITLE"Chapter 11, "User Feedback" describes various types of feedback users expect your application to provide. It also tells you when to use each of the standard pointer shapes and provides guidelines for designing your own pointer shapes.LBL="" HELPID=""AppendixIDREF="12454" TYPE="TITLE"Appendix A, "Summary of Guidelines," provides a checklist that you can use to determine whether your product follows the Indigo Magic user interface guidelines. This checklist contains all of the individual guidelines that appear throughout the book. LBL="" HELPID=""What You Should Know Before Reading This GuideThis guide assumes that you understand the concepts and terminology used with computers whose user interface is based on the X Window System‘ and OSF/Motif. It also assumes that you're familiar with the OSF/Motif Style Guide, Release 1.2; the material presented in this guide represents enhancements to and clarification of information presented in that manual. LBL="" HELPID=""Suggestions for Further ReadingThe programming details of how to implement the style guidelines described here are contained in the following books, all of which are available online through IRIS InSight:Indigo Magic Desktop Integration GuideSoftware Packager User's GuideTopics in IRIX ProgrammingOSF/Motif Programmer's GuideOSF/Motif Reference ManualThe X Window System, Volume 1: Xlib Programming ManualThe X Window System, Volume 4: X Toolkit Intrinsics Programming ManualIn addition, you might want to take a look at IRIS Essentials (also an online manual), which explains how users interact with the Indigo Magic Desktop. Finally, here are some references for further reading in the area of user interface design:Brown, C. Marlin "Lin." Human-Computer Interface Design Guidelines. Norwood, New Jersey: Ablex Publishing Corporation, 1989. (This book presents general user interface guidelines.)Laurel, Brenda, ed. The Art of Human-Computer Interface Design. Reading, Massachusetts: Addison-Wesley Publishing Co., 1990. (This book addresses future directions in user inteface design.)Mayhew, Deborah J. Principles and Guidelines in Software User Interface Design Englewood Cliffs, New Jersey: Prentice-Hall, Inc., 1992. (This book covers the overall design process and presents general user interface guidelines.)Norman, Donald A. The Design of Everyday Things. Reading, Massachusetts: Addison-Wesley Publishing Co., 1991. (This book uses examples of commonly used products to illustrate why good design is necessary.)Shneiderman, Ben (1992) Designing the User Interface: Strategies for Effective Human-Computer Interaction, second ed. Reading, Massachusetts: Addison-Wesley Publishing Co., 1992. (This book presents general user interface guidelines.)LBL="" HELPID=""Conventions Used in This GuideIn this book you'll find the following conventions that act as visual cues for different types of information.LBL="" HELPID=""Style GuidelinesThis icon indicates a guideline that summarizes the preceding discussion. The guidelines appear at the end of each main section, and a complete list is provided in IDREF="12454" TYPE="TITLE"Appendix A, "Summary of Guidelines."LBL="" HELPID=""Font ConventionsThese are the typographical conventions used in this book: Bold text indicates that a term is a data type, a keyword, an X or IRIS IM widget name, a function, or an X resource.Italics indicates that a term is a file name, a button name, a variable, an IRIX‘ command, or a document title."Quoted text" indicates menu items.Angle brackets indicate special keys, as in <Ctrl>.Regular text is used for menu and window names.LBL="I"Integrating With the Indigo Magic DesktopLBL="1"ID="73752"Overview of the Indigo Magic DesktopThe Indigo Magic Desktop environment allows users to interact with applications by using a graphical, point-and-click interface based on icons and windows. It offers an easy, powerful alternative to typing commands in the traditional UNIXÆ style. ID="ch01.deskoverview1"This chapter provides a brief overview of the Indigo Magic Desktop environment from the user's perspective. It describes how users expect to interact with their graphical environment and with your application. The specific implications for your application are discussed in the remainder of Part One, "Integrating With the Indigo Magic Desktop." For details on how users interact with the Indigo Magic Desktop, see the online IRIS Essentials manual. This chapter covers the following topics:IDREF="81108" TYPE="TITLE""Overview of the Desktop" briefly describes the major elements of the Indigo Magic Desktop including the various types of desktop icons.IDREF="37385" TYPE="TITLE""How Users Interact With Desktop Icons" describes how users interact with icons and how icons appear on the desktop during these interactions.IDREF="39080" TYPE="TITLE""Mouse and Keyboard Hardware" describes the mouse and keyboard hardware provided for use with Silicon Graphics systems.LBL="" HELPID=""ID="81108"Overview of the DesktopThe Indigo Magic Desktop appears in IDREF="63460" TYPE="GRAPHIC"Figure 1-1 along with the major desktop tools and examples of icons and minimized windows. The important elements in the Indigo Magic Desktop environment are:ID="ch01.deskoverview2"ID="ch01.deskoverview3"ID="ch01.deskoverview4"4Dwmname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the window manager application underlying the Indigo Magic Desktop. (4Dwm is the only sanctioned window manager for the Indigo Magic environment.) It is an X Window System client based on the Motif Window Manager (MWM). 4Dwm provides window management, desks (defined below), and session management. It provides facilities for controlling window placement, window size, keyboard focus ownership, and minimized windows. Toolchestname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'a menu bar that provides general system commands not specific to any application. This menu bar is displayed horizontally or vertically, depending on the user's preference, and is positioned by default in the upper left corner of the desktop.ID="ch01.deskoverview5"Directory Viewsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'windows that display the contents of a UNIX file directory (folder icon) in various formats involving icons. The Directory View has an optional ID="ch01.deskoverview6"shelf pane where users can store frequently used icons. Note the thumbwheel on the lower left side of the windowname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'it lets users adjust the viewing size of icons in the display area of the Directory View window.Icons on the screen backgroundname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'symbols that represent entities, such as applications, files, directories, people, printers, the Indy Cam‘ camera, removable media devices (for example, CDROM, floppy, and DAT drives), and other devices. Users can place icons in any portion of the desktop to have them readily accessible. ID="ch01.deskoverview7"ID="ch01.deskoverview8"Icon Catalogname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'a window that allows users to access application icons directly. It uses a page-oriented metaphor with six default pages: Applications, Collaboration, Demos, Desktop Tools, Media Tools, and Control Panels. Users can also create their own pages. ID="ch01.deskoverview9"Find an Icon toolname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'a tool for either retrieving a file's icon, given the name, or obtaining the full path and filename given the icon. ID="ch01.deskoverview10"FILE="ch01.deskoverview.ras" POSITION="INLINE" SCALE="FALSE"LBL="1-1"Figure 1-1 ID="63460"Major Elements of the Indigo Magic DesktopSearch toolname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'a tool that lets users search for files, printers, hosts, drives, and people.ID="ch01.deskoverview11"Customize control panelsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'windows that let users specify various types of preferences, such as screen background and language. ID="ch01.deskoverview12"Desks OverviewID="ch01.deskoverview13" Due to a software patent dispute instituted by Xerox Corporation, the Desks and Desks Overview features of this version of the IRIX operating system are now optional and may or may not be available to you after May 15, 1995. On this date, these features will be disabled unless you have entered a license code obtained from Silicon Graphics. When the Desks Overview feature is initiated, a dialog box will periodically warn you of the May 15, 1995 expiration date. Depending on how this patent dispute is resolved, prior to May 15, 1995, Silicon Graphics will attempt to inform you that the license code for these features will: (1) not be available; (2) only be available at an additional price; or (3) be available free of charge. Silicon Graphics apologizes for this inconvenience and appreciates your understanding. For updates, see comp.sys.sgi.admin, or call 1-415-390-4334. Please do not send email, or call other SGI numbers.name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'a tool for creating and managing multiple virtual screens (desks). It lets users set up and switch desks, typically for organizing their work. 4Dwm allows these desks to display different backgrounds.These tools affect the design of your application. Specific design implications are discussed in detail in the remainder of Part One. For more information on the tools themselves, see the IRIS Essentials manual.LBL="" HELPID=""ID="37385"How Users Interact With Desktop IconsUsers interact with icons on the Indigo Magic Desktop using a point-and-click graphical user interface. For example, the following techniques represent some of the ways a user can launch an application using icons:ID="ch01.deskoverview14"ID="ch01.deskoverview15"double-clicking the application icon, which launches the application and opens a new filedouble-clicking a file icon, which launches the application opened to that specific fileselecting the application icon (by single-clicking or dragging a rectangle that encloses it) and then choosing "Open Icon" from the Selected menu (in the Toolchest for icons on the screen background or in the specific tool window for other icons)dragging a compatible file icon and dropping it on top of the application icon, which launches the application and opens that specific fileThe six states that are used to represent icon manipulations are indicated primarily by painting specific portions of the icon with a predefined "icon color." As the state changes, the areas painted with the ID="ch01.deskoverview16"icon color change color. For the specific implications on the design of your application's icons, see IDREF="19353" TYPE="TITLE""General Icon Design: Components, Size, and Colors" in Chapter 2. The icon states of the IRIS Showcase application icon are illustrated in IDREF="33876" TYPE="GRAPHIC"Figure 1-2. (Note that the magic carpet under the magician's hat is the generic executable symbol used in the Indigo Magic environment to identify the icon as an application icon.) In the figure, the hat brim, the light shading on the hat, and the carpet are in the predefined icon color and thus change color as the state changes. The states are:ID="ch01.deskoverview17"neutralname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the icon isn't involved in any operations. The icon appears in the base colors you've chosen. The portions containing the icon color appear in light gray.ID="ch01.deskoverview18"locate highlightname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the pointer is resting on the icon and the icon isn't currently selected (see the following description of the selected state). The icon color portions change from the neutral state color light gray to white. The locate highlight feature lets the user know that the highlighted icon will be selected if the user single-clicks or opened if the user double-clicks. (The locate highlight feature also applies to components in windows to provide feedback as to which objects are true components and which are passive graphics, as described in IDREF="47013" TYPE="TITLE""Enhanced Graphics in the Indigo Magic Look" in Chapter 3.) ID="ch01.deskoverview19"selectedname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the icon has been chosen potentially for some operation. Users select an icon by single-clicking on it with the left mouse button or dragging a rectangle around it using the left mouse button. When an icon is selected, the icon color portions turn yellow. Note that the icon color is bright yellow when the window containing the icon (or the screen background) has the keyboard focus; otherwise, the icon color is a dim yellow. Users can choose entries from the Selected menu (from the Toolchest if the icon is on the screen background or from a window's menu bar if contained in a tool window) to perform various operations on the object represented by the icon. ID="ch01.deskoverview20"openname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'applies to application icons but not to data file icons. For application icons, the open state indicates that the application is running. Application icons indicate their open state by moving the magic carpet from a horizontal to a vertical position and by changing their application icon symbol. This is discussed in more detail in IDREF="96073" TYPE="TITLE""Application Icon Design" in Chapter 2. Note that application icons don't indicate their open state with colors. ID="ch01.deskoverview21"dragname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'an icon is in the process of being moved on the screen. Users drag icons by pressing and holding down the left mouse button while the pointer is positioned over the icon and then moving the mouse. The icon moves around the desktop with the pointer. As an icon is dragged, the portions colored with the icon color display in yellow since it's in the selected state, and a ghost image of the icon with the icon color portions displaying in dark gray remains in the original position. The ghost image remains until the user drops or places the icon or cancels the drag operation.ID="ch01.deskoverview22"drop-acceptingname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'an icon has another icon moved on top of it to perform some operation. For example, users can move a file from one directory to another by dragging the icon representing the file and dropping it onto the icon representing the new directory. When an icon has another icon positioned over it, the icon color portions of the destination icon turn royal blue if the destination icon can accept dropped icons or remain in their current color if the destination icon doesn't accept them.FILE="ch01.deskoverview.ras2" POSITION="INLINE" SCALE="FALSE"LBL="1-2"Figure 1-2 ID="33876"Icon States: User Actions and EffectsLBL="" HELPID=""ID="39080"Mouse and Keyboard HardwareSilicon Graphics systems come with a three-button mouse that supports the mouse actions defined in the ID="ch01.deskoverview23"ID="ch01.deskoverview24"OSF/Motif Style Guide (such as press, release, click, motion, multiclick, multipress, and multimotion). IDREF="73735" TYPE="TABLE"Table 1-1 lists these buttons and their functions. If a mouse action is mentioned in this guide without reference to a specific mouse button, assume that the button being used is the left mouse button. For example, "when the user clicks on the OK button. . ." means "when the user positions the pointer over the OK button and clicks the left mouse button. . . ." Note that users can switch the mouse to a left-handed mouse via the Mouse Settings control panel available from the Desktop->Customize menu in the Toolchest. COLUMNS="4"LBL="1-1"Table 1-1 ID="73735"Mouse Button Names and FunctionsLEFT="0" WIDTH="87"ButtonIDREF="ch01.deskoverviewTF0a"aLEFT="95" WIDTH="44"OSF/Motif
 NameLEFT="145" WIDTH="71"Silicon Graphics 
NameLEFT="225" WIDTH="129"FunctionLEFT="0" WIDTH="87"Leftmost button LEFT="95" WIDTH="44"BSelectID="ch01.deskoverview25"LEFT="145" WIDTH="71"Left mouse 
buttonID="ch01.deskoverview26"LEFT="225" WIDTH="129"Used for all primary 
interactions, including 
selection, activation, and 
setting the location cursor.LEFT="0" WIDTH="87"Middle button LEFT="95" WIDTH="44"BTransferID="ch01.deskoverview27"LEFT="145" WIDTH="71"Middle mouse 
buttonID="ch01.deskoverview28"LEFT="225" WIDTH="129"Used for moving and copying 
elements. Can be used for 
advanced user shortcuts that 
are also included in a more 
obvious interface.LEFT="0" WIDTH="87"Rightmost button LEFT="95" WIDTH="44"BMenuID="ch01.deskoverview29"LEFT="145" WIDTH="71"Right mouse 
buttonID="ch01.deskoverview30"LEFT="225" WIDTH="129"Exclusively used for popping 
up menus.LBL="a" ID="ch01.deskoverviewTF0a"This table assumes a right-handed mouse.Silicon Graphics keyboards support the following special keys that are used to interact with Motif-compliant applications: ID="ch01.deskoverview31"ID="ch01.deskoverview32"COLUMNS="1"LEFT="0" WIDTH="313"<Tab>LEFT="0" WIDTH="313"<Space>LEFT="0" WIDTH="313"<Back Space>LEFT="0" WIDTH="313"<Escape>LEFT="0" WIDTH="313"<Insert>LEFT="0" WIDTH="313"<Delete>LEFT="0" WIDTH="313"<Home>LEFT="0" WIDTH="313"<End>LEFT="0" WIDTH="313"<Page Up>LEFT="0" WIDTH="313"<Page Down>LEFT="0" WIDTH="313"Modifier keys: <Ctrl>, <Alt>, <Shift>LEFT="0" WIDTH="313"Ten function keys: <F1> through <F10>LEFT="0" WIDTH="313"Special printing characters: </>, <\>, <!>LEFT="0" WIDTH="313"Arrow keys: <down arrow>, <left arrow>, <right arrow>, <up arrow>In addition to these keys, Silicon Graphics keyboards also support the function keys <F11> and <F12>, which aren't included in the OSF/Motif Style Guide. If your application uses these keys, limit them to application-specific functionality rather than the general functionality described in this guide. ID="ch01.deskoverview33"IDREF="99510" TYPE="TABLE"Table 1-2 lists the keys that the OSF/Motif Style Guide defines but that don't appear on Silicon Graphics keyboards; it also lists the corresponding Motif-compliant substitutions for Silicon Graphics keyboards. COLUMNS="2"LBL="1-2"Table 1-2 ID="99510" Keyboard Substitutes LEFT="0" WIDTH="166"OSF/Motif KeyLEFT="175" WIDTH="166"Silicon Graphics SubstituteLEFT="0" WIDTH="166"<Return>ID="ch01.deskoverview34"LEFT="175" WIDTH="166"<Enter>ID="ch01.deskoverview35"LEFT="0" WIDTH="166"<Cancel>ID="ch01.deskoverview36"LEFT="175" WIDTH="166"<Escape>ID="ch01.deskoverview37"LEFT="0" WIDTH="166"<Help>ID="ch01.deskoverview38"LEFT="175" WIDTH="166"<F1>ID="ch01.deskoverview39"LEFT="0" WIDTH="166"<Menu>ID="ch01.deskoverview40"LEFT="175" WIDTH="166"<Shift><F10>ID="ch01.deskoverview41"LEFT="0" WIDTH="166"<Begin>ID="ch01.deskoverview42"LEFT="175" WIDTH="166"<Home>ID="ch01.deskoverview43"LBL="2"ID="94988"IconsThe Indigo Magic Desktop uses icons to represent entities such as applications, files, directories, people, printers, the Indy Cam camera, removable media devices (for example, CDROM, floptical, and DAT drives), and other devices. Users can manipulate these icons through a point-and-click graphical user interface to initiate certain actions, such as launching an application or sending a data file to the printer, instead of entering UNIX commands in a shell window. This chapter covers the following topics:ID="ch02.icons1"ID="ch02.icons2"ID="ch02.icons3"ID="ch02.icons4"IDREF="18888" TYPE="TITLE""Designing the Appearance of Icons" tells you how to design an application icon to represent your application's executable file and a file icon to represent your data files.IDREF="25444" TYPE="TITLE""Defining the Behavior of Icons With FTRs" explains which File Typing Rules (FTRs) you need to define for your application and file icons so that they will respond to user actions such as double-click and drag-and-drop. IDREF="38425" TYPE="TITLE""Making Application Icons Accessible" discusses adding your application icon to the Icon Catalog and naming and locating your executable file in the file system so that users can easily find your application icon.NoteIn this guide, the term icon refers to Indigo Magic Desktop icons and not to minimized windows, as in the OSF/Motif Style Guide. Minimized windows are described inIDREF="87201" TYPE="TITLE""Minimized Windows" in Chapter 3.LBL="" HELPID=""ID="18888"Designing the Appearance of IconsYour application's desktop icons can appear in any of several places on the Indigo Magic Desktop, along with icons from other applications. For example, your icons can appear on the desktop background, in Directory View windows, and in the Icon Catalog. ID="ch02.icons5"IDREF="68489" TYPE="GRAPHIC"Figure 2-1 shows the Icon Catalog, which displays several application icons representing executable files, and IDREF="68653" TYPE="GRAPHIC"Figure 2-2 is a snapshot of various data file icons that might appear on a user's desktop. You'll need to create an application icon. If your application saves its data in a unique format, you'll also need to create a data file icon. (If your application saves its data in a standard data format, your application's data files will automatically appear on the desktop using the appropriate standard data icon.)FILE="fig.iconcatalog2.bw" POSITION="INLINE" SCALE="FALSE"LBL="2-1"Figure 2-1 ID="68489"Application IconsFILE="ch02.icons.ras2" POSITION="INLINE" SCALE="FALSE"LBL="2-2"Figure 2-2 ID="68653"File IconsTo make your application and file icons stand out in a group of icons, you need to create meaningful symbols that are distinctive and represent your product. Your icon designs should also follow the guidelines detailed in the remainder of this section so that users recognize your icons as desktop icons and know that they can interact with these icons in expected ways. LBL="" HELPID=""ID="19353"General Icon Design: Components, Size, and ColorsYou should design your application and file icons so that theyconvey your product identityhave the right components and thus are recognizable as desktop iconsare identifiable when zoomed to the minimum and maximum sizes allowed by the Indigo Magic Desktopuse an effective color scheme, which allows the icon to reflect its stateID="64864"Keep in mind that your primary goal is to differentiate your icons from those of other products and that your design should be fairly simple because desktop icons can be displayed at a relatively small size. LBL="" HELPID=""Icon ComponentsAs shown in ID="ch02.icons6"IDREF="37550" TYPE="GRAPHIC"Figure 2-3, application and file icons consist of several components: a symbol identifying the application or type of data file, an outline around the edge of the symbol, a drop shadow that helps give the icons a 3D appearance, and a label identifying the executable or data file. Application icons also include a ID="ch02.icons7"magic carpet, the generic executable symbol, which differentiates them from file icons and shows whether or not the application is running (by moving from the horizontal, at-rest position into a vertical, up-and-running position). File icons for document-based applications incorporate the generic data file symbol (three rectangles representing sheets of paper) into the file icon design.FILE="ch02.icons.ras3" POSITION="INLINE" SCALE="FALSE"LBL="2-3"Figure 2-3 ID="37550"Application and File Icon ComponentsYou need to create the symbols for your application icon and for any unique file types your application creates. You create symbols with the IconSmith‘ drawing tool, which is described in IDREF="17843" BOOK="IndigoMagic_IG" FILE="12.IconSmith.doc" HDG=""Chapter 12, "Using IconSmith," in the Indigo Magic Desktop Integration Guide. IconSmith provides a drawing grid with tools for creating 3D graphics. It also supplies predefined templates for the magic carpet in both the running and not running states and the data file format symbol, complete with drop shadows. You create your unique icon symbols in the drawing area and can readily add the predefined templates to your design. IDREF="71791" TYPE="GRAPHIC"Figure 2-4 shows four examples of IconSmith. The drawing area in the example in the upper left corner contains the IRIS Showcase application symbol for its not-running state. The other three examples contain the three predefined templates. The icon labels are supplied automatically when the icons are displayed on the desktop. This label is the name of the executable for application icons and the name of the data file for file icons.FILE="ch02.icons.ras4" POSITION="INLINE" SCALE="FALSE"LBL="2-4"Figure 2-4 ID="71791"IconSmith ExamplesLBL="" HELPID=""Icon SizeYou need to draw your icon within the 100name='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]'100-pixel boundary box defined by IconSmith. Keep in mind that your symbol designs should allow any generic icon components, such as the magic carpet and stack of papers, to be at least partially visible. This is described in more detail in ID="ch02.icons8"IDREF="96073" TYPE="TITLE""Application Icon Design" and IDREF="46804" TYPE="TITLE""File Icon Design" later in this chapter.By default, icons are reduced to fit within a 50x50 pixel area when they're displayed on the desktop. Because users can adjust the viewing scale for icons making the icons either larger or smaller than this default, your icon drawings should look good across the range of available sizes. You can use the IconSmith preview box to see what your icon looks like when scaled to various sizes.LBL="" HELPID=""ID="36254"Icon ColorsIconSmith provides the color palette shown in ID="ch02.icons9"IDREF="30364" TYPE="GRAPHIC"Figure 2-5 for specifying the colors in your icon. The following two buttons are of particular importance for applying color to icons:Specificname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'lets you apply a color from the color selection area to the selected part of the graphic. The specific color remains constant as an icon goes through its states.ID="ch02.icons10"Iconname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'lets you apply the predefined icon color to the selected part of the graphic. Portions painted with the icon color change color as the icon changes its state.When choosing colors for your icons, consider that the ID="ch02.icons11"icon color changes to indicate state and that icons appear against a variety of differently colored backgrounds. To accommodate these issues, you need to enable your icon to show its state and make sure your icon stands out from the most likely backgrounds, as explained in the following paragraphs. (See IDREF="73752" TYPE="TITLE"Chapter 1, "Overview of the Indigo Magic Desktop," for explanations of icon states from the user's point of view.) FILE="ch02.icons.ras5" POSITION="INLINE" SCALE="FALSE"LBL="2-5"Figure 2-5 ID="30364"IconSmith Color PaletteTo enable your icon to reflect what state it's in, you need to paint portions of it with the predefined 
icon color supplied by IconSmith. Those portions of your icon are changed automatically by the Indigo Magic Desktop to indicate the icon's state. In the example shown in IDREF="33876" TYPE="GRAPHIC"Figure 2-6, the hat brim, the light shading on the hat, and the carpet of the IRIS Showcase application icon use the predefined icon color (which is a light gray in the neutral state). In addition, to make the state color changes easier for users to detect in your icons, avoid (or use sparingly) intense, strongly saturated colors and the specific colors used by the Indigo Magic Desktop to indicate statename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'bright yellow, dim yellow, royal blue, pure white, and light gray.FILE="ch02.icons.ras6" POSITION="INLINE" SCALE="FALSE"LBL="2-6"Figure 2-6 ID="33876"Icon States and Effects on ColorThere are several things you can do to increase your icon's chances of standing out on user-customized desktops. (Remember that users can customize the desktop background to be any color and pattern, as described in IDREF="73752" TYPE="TITLE"Chapter 1, "Overview of the Indigo Magic Desktop.") Use the icon color defined by IconSmith to color most of your icon.Use two or more areas of accent colors to help your icon stand out against user-customized background colors.Avoid using only very small color areas (2-4 pixels) because these small areas may be difficult to see against a patterned background.Use the ID="ch02.icons12"outline color (which is black) supplied by IconSmith to define the outline of your icon. Since your icons can display in certain Indigo Magic tools as shown in IDREF="11788" TYPE="GRAPHIC"Figure 2-7, avoid (or use sparingly) the following background colors used by these tools: light gray-greenname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'used in Directory View windowscadet bluename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'used in read/write panes such as drop pockets, shelves in Directory View windows, and the Icon Catalog pagesNavajo whitename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'used in read-only panes such as the results area of the Search toolNoteThe color descriptions "light gray-green" and "cadet blue" are approximate since hardware and gamma values vary. Look at these colors on your system in Directory View windows and read/write panes, and avoid using these colors in your icon or use them sparingly.LBL="" HELPID=""Icon OrientationIcons on the Indigo Magic Desktop should display at a three-quarter view and face the lower right of the screen to make them appear 3D. When designing your application and data file format symbols, draw them using this perspective. This is the same perspective that is used for the generic executable symbol (the magic carpet) and the generic data file symbol (stack of papers). Icons that don't follow this convention appear to be facing the wrong way.ID="ch02.icons13"FILE="ch02.icons.ras7" POSITION="INLINE" SCALE="FALSE"LBL="2-7"Figure 2-7 ID="11788"Potential Icon Background Areas and ColorsLBL="" HELPID=""ID="96073"Application Icon DesignIn addition to adhering to the guidelines discussed in the previous section, ID="ch02.icons14"IDREF="19353" TYPE="TITLE""General Icon Design: Components, Size, and Colors," the application icon that represents your application's executable needs to convey to usersthat it's an application icon (as opposed to a file icon)what its current state is (whether or not the application is running)The magic carpet is the generic executable symbol; it differentiates application icons from file icons. As mentioned in the previous section, the magic carpet and its drop shadow are predefined components that can easily be incorporated into your icon design when using IconSmith. For details of having them appear with your application symbol, see ID="ch02.icons15"IDREF="48028" BOOK="IndigoMagic_IG" FILE="11.Overview.Icons.doc" HDG=""Chapter 11, "Creating Desktop Icons: An Overview," in the Indigo Magic Desktop Integration Guide.As shown in ID="ch02.icons16"IDREF="89242" TYPE="GRAPHIC"Figure 2-8, your application icon should use both of the following techniques to indicate its statename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'that is, whether or not the application is running:The 3D application symbol changes (in this example, items pop out of the hat in the running state). The magic carpet moves from a horizontal, at-rest position to a vertical, up-and-running one, and the drop shadow changes shape appropriately. Since the magic carpet must be recognizable in both states, make sure that your application symbol doesn't completely obscure it in either position.FILE="ch02.icons.ras8" POSITION="INLINE" SCALE="FALSE"LBL="2-8"Figure 2-8 ID="89242"Application Icon in Running and Not Running StatesTo have your application icon change to reflect its running state, create two different symbols using IconSmith and associate them with your application. See IDREF="48028" BOOK="IndigoMagic_IG" FILE="11.Overview.Icons.doc" HDG=""Chapter 11, "Creating Desktop Icons: An Overview," in the Indigo Magic Desktop Integration Guide for details on how to do this. The specific design of the two symbols is up to you, but keep in mind that you're trying to convey an inactive state and an active, running one. Also, when viewed in succession, the two symbols should look like a progressive animation rather than two unrelated icons.The IRIS Showcase application icon shown in IDREF="89242" TYPE="GRAPHIC"Figure 2-8 is an example of a well-designed icon: it animates in a clever way to show which state the application is in, and the carpet is always visible. IDREF="29855" TYPE="GRAPHIC"Figure 2-9 shows three examples of application icon designs that can be improved: The first example is an application icon for a point-and-click ASCII text editor. Its carpet is clearly visible and functions properly. The application symbol doesn't change, however, to reflect that the application is running. To improve the design, the existing symbol could be used to show the running state and the pencil could be aligned at the bottom or side of a blank version of the pad when the application isn't running. The application icon in the second example represents an online book viewer. The application symbol changes nicely to indicate its running state. The carpet, however, is almost totally obscured when the application isn't running and doesn't appear at all when the application is running. The third application icon represents a database application for tracking software bugs. The application symbol is visually appealing but completely obscures the carpet. In addition, there's no change in the application symbol to reflect its running state, and the symbol is oriented toward the lower left instead of the lower right. The design could be improved by adding a second symbol for the not-running state (perhaps showing the file drawer closed with the bug's antennae sticking out), making the application symbol smaller so that the magic carpet is visible, and redrawing the symbol so that it faces the lower right.FILE="ch02.icons.ras9" POSITION="INLINE" SCALE="FALSE"LBL="2-9"Figure 2-9 ID="29855"Examples of Application Icons That Could be ImprovedLBL="" HELPID=""ID="46804"File Icon DesignIf your application creates files, those files need to be associated with ID="ch02.icons17"file icons. Silicon Graphics defines a set of standard data formats and provides associated file icons, some of which are shown in IDREF="17142" TYPE="GRAPHIC"Figure 2-10. (For information on these file formats, see IDREF="30180" BOOK="IndigoMagic_IG" FILE="E.Predefined.Types.doc" HDG=""Appendix E, "Predefined File Types," in the Indigo Magic Desktop Integration Guide.) If your application saves its data in any of these standard formats, it will automatically use the appropriate file icon for those files.If your application saves its data in a unique format, however, you need to design a distinctive file icon that relates graphically to the theme of your application icon. It should also indicate, if possible, how the data is used. Your file icon should follow the guidelines discussed in this section and in the earlier section IDREF="19353" TYPE="TITLE""General Icon Design: Components, Size, and Colors."FILE="ch02.icons.ras10" POSITION="INLINE" SCALE="FALSE"LBL="2-10"Figure 2-10 ID="17142"Examples of Standard File IconsThe standard file icons shown in ID="ch02.icons18"IDREF="17142" TYPE="GRAPHIC"Figure 2-10 that symbolize documents all contain the generic data file symbol (stack of papers). If your application creates data files, your file icon should include this generic symbol. Both the generic symbol and its drop shadow are predefined components available in IconSmith. If you're creating a unique icon that does not use the generic data file symbol, create an appropriately shaped drop shadow for your design and paint it with the shadow color predefined in IconSmith.ID="ch02.icons19"IDREF="18807" TYPE="GRAPHIC"Figure 2-11 shows some file icons for application-specific file formats. For example, the IRIS Showcase file icon includes the generic data file symbol (a stack of papers) to indicate that it represents a document, and the data file format symbol is similar to that found in the IRIS Showcase application symbol for the running state.FILE="ch02.icons.ras11" POSITION="INLINE" SCALE="FALSE"LBL="2-11"Figure 2-11 ID="18807"Examples of File Icons for Application-Specific File FormatsLBL="" HELPID=""ID="14297"Icon Appearance Design GuidelinesFor any icon you create . . . Provide a meaningful, distinctive symbol that gives your product an identity and that allows users to readily identify your application and its corresponding custom data files, if any. Keep your design fairly simple because desktop icons can be displayed at very small sizes.Make sure that your icon can be identified across the range of viewing sizes.Color most of your icon using the icon color predefined by IconSmith so that your icon's state is easy to detect.Use two or more areas of accent colors to help your icon stand out against user-customized background colors.Avoid small areas of color (2-4 pixels) because they're difficult to see against patterned backgrounds.Include an outline around your custom symbol, and use the outline color supplied by IconSmith.Avoid or use sparingly intense, strongly saturated colors and the specific colors used by the Indigo Magic Desktopname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'bright yellow, dim yellow, royal blue, light gray-green, cadet blue, and Navajo white. These colors make it difficult to distinguish between certain icon states and to find your icon against the background colors of many desktop tools.Orient your icon so that it displays a three-quarter view that faces the lower right corner of the screen.When designing an application icon . . . Include the magic carpet, the generic executable symbol, with your application's symbol.Indicate the state of the application (not running vs. running) by providing two different application symbols and by moving the magic carpet from a horizontal (not running) to vertical (running) position. Remember that your application symbols should resemble a progressive animation when viewed in succession.Make sure that your application symbols do not obscure the magic carpet in either its horizontal or vertical position.If your application saves data in a custom file format . . . Design a unique data file format symbol that is readily associated with your application icon design and also indicates how the data is used.If your application is document-based, include the generic data file symbol (stack of papers) in your design.If your data file icon does not use the generic data file symbol, create an appropriately shaped shadow for your file icon and use the predefined shadow color supplied by IconSmith.LBL="" HELPID=""ID="25444"Defining the Behavior of Icons With FTRsYou define the behavior of icons on the Indigo Magic Desktop by creating a File Typing Rule (FTR) file for each icon. This behavior includes such things as what happens when the user double-clicks on an icon and what happens when the user drags and drops one type of icon onto another type of icon. This section describes how users can interact with icons, how an FTR supports these interactions (in brief), and the minimal set of standard behaviors your application and file icons should support. ID="ch02.icons20"ID="ch02.icons21"IDREF="43521" TYPE="TABLE"Table 2-1 shows the behavior users expect for given interactions with application and file icons. The last column lists the rules for each type of interaction. For information on implementing these behaviors, see IDREF="48028" BOOK="IndigoMagic_IG" FILE="11.Overview.Icons.doc" HDG=""Chapter 11, "Creating Desktop Icons: An Overview," in the Indigo Magic Desktop Integration Guide.COLUMNS="4"LBL="2-1"Table 2-1 ID="43521"User/Icon Interactions and Expected BehaviorLEFT="0" WIDTH="90"User GoalLEFT="95" WIDTH="162"User ActionLEFT="265" WIDTH="157"Expected BehaviorLEFT="430" WIDTH="93"Implementation HintsLEFT="0" WIDTH="90"Launch applicationLEFT="95" WIDTH="162"Selects application icon and chooses 
"Open" from the corresponding 
Selected menu-or-Double-clicks application iconLEFT="265" WIDTH="157"The magic carpet and the application 
symbol change from the not-running 
to the running state. The application 
launches, set to a new file.LEFT="430" WIDTH="93"Add a CMD OPEN 
rule for the 
application iconLEFT="0" WIDTH="90"Launch application 
with a particular file 
by directly opening 
fileLEFT="95" WIDTH="162"Selects file icon and chooses "Open" 
from the corresponding Selected menu-or-Double-clicks file iconLEFT="265" WIDTH="157"The magic carpet and the application 
symbol change from the not-running 
to the running state. The application 
launches, set to the specified file.LEFT="430" WIDTH="93"Add a CMD OPEN 
rule for the file icon 
that specifies its 
applicationIDREF="ch02.iconsTF0a"aLEFT="0" WIDTH="90"Launch application 
with a particular file 
by dragging and 
droppingLEFT="95" WIDTH="162"Drops file icon onto application iconLEFT="265" WIDTH="157"If file is compatible, application 
launches, set to specified fileIf file is incompatible, application 
posts an appropriate error message 
and doesn't launch.In both cases, the magic carpet and the 
application symbol change from the 
not running to the running state.LEFT="430" WIDTH="93"Add a CMD DROP 
rule for the 
application iconLEFT="0" WIDTH="90"Launch application 
with command-line 
argumentsLEFT="95" WIDTH="162"Double-clicks application icon while 
holding down the <Alt> keyLEFT="265" WIDTH="157"The Launch dialog box opens, 
displaying the path to your executable 
(see IDREF="39600" TYPE="GRAPHIC"Figure 2-12). Users can add 
arguments if desired. Clicking OK 
executes the text input as specified. 
The magic carpet and the application 
symbol then change from the 
not-running to the running state.LEFT="430" WIDTH="93"Add a CMD 
ALTOPEN rule for the 
application iconaLEFT="0" WIDTH="90"Print fileID="ch02.icons22"LEFT="95" WIDTH="162"Selects file icon and chooses "Print" 
from the corresponding Selected menu-or-Drops file icon onto printer iconLEFT="265" WIDTH="157"Specified file prints on default printer 
if activated by a menu selection or 
prints on specified printer if activated 
by a drag and drop action.LEFT="430" WIDTH="93"Add a PRINT rule for 
the file iconaLBL="a" ID="ch02.iconsTF0a"Design the application so it can accept specific data (for example, a filename) as a command-line argument. FILE="fig.launch.bw" POSITION="INLINE" SCALE="FALSE"LBL="2-12"Figure 2-12 ID="39600"Launch Dialog BoxLBL="" HELPID=""ID="14297"Icon Behavior GuidelinesWhen creating an FTR to define your application icon's behavior . . . Provide a CMD OPEN rule that launches the application. This allows the user to open your application either by selecting your application icon and then choosing "Open" from the corresponding Selected menu, or by double-clicking your application icon.Provide a CMD ALTOPEN rule that opens the Launch dialog box shown in IDREF="39600" TYPE="GRAPHIC"Figure 2-12 with the path to your executable displayed in the text field of this window. This allows the user to open the Launch dialog box by double-clicking your application icon while holding down the <Alt> key. Provide a CMD DROP rule that launches your application with the file specified by the dropped icon. If your application doesn't understand the type of file represented by the icon dropped on it, your application should provide an appropriate error message to the user rather than launching. This allows the user to launch your application with a specific file by dragging the file icon and dropping it on your application icon.When creating an FTR for your file icon . . . Provide a CMD OPEN rule that launches your application and automatically opens the file represented by the file icon. This allows the user to open a file created by your application either by selecting the file icon and then choosing "Open" from the corresponding Selected menu, or by double-clicking the file icon.Provide a CMD PRINT rule that sends the file represented by the file icon to the specified printer. This allows the user to send your application's data files to the default printer by selecting the file icon and then choosing "Print" from the corresponding Selected menu. It also allows the user to send your application's data files to any printer by dragging the file icon and dropping it on an icon that represents the specific printer.LBL="" HELPID=""ID="38425"Making Application Icons AccessibleIn addition to designing the appearance and defining the behavior of your application icon, you need to make it accessible to users byID="ch02.icons23"putting it into the Icon Catalog naming and locating your executable file appropriately so that users can find it with the Find an Icon toolLBL="" HELPID=""ID="74160"Putting Icons Into the Icon CatalogAfter users install an application, they expect to find its icon in the Icon Catalog (described in IDREF="81108" TYPE="TITLE""Overview of the Desktop" in Chapter 1), so you need to add your application icon to the Catalog as part of the installation process. Also, decide on which page of the Catalog your icon should appear or, if necessary, create a new page. Once you've chosen an appropriate page for your application icon, refer to IDREF="86065" BOOK="IndigoMagic_IG" FILE="15.Icon.Catalog.doc" HDG=""Chapter 15, "Adding Your Application's Icon to the Icon Catalog," in the Indigo Magic Desktop Integration Guide for details on making your application icon appear on the chosen page. As shown in IDREF="83339" TYPE="GRAPHIC"Figure 2-13, the Icon Catalog lets users access applications visually without having to search through the file hierarchy. The Catalog contains six pages by default, which are listed below along with typical applications that appear on them:Application pagename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'multimedia presentation application (showcase), text editor (jot), electronic mail program (MediaMail)Collaboration pagename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'desktop conferencing application (inperson)Demos pagename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'xlogo and buttonflyDesktop Tools pagename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'calculator program (xcalc), clock program (xclock), select fonts (xfontsel), mail notifier utility (mailbox), calendar display (ical), and screen magnifier (mag)Media Tools pagename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'compact disc player (cdman), digital audio tape player (datman), image file format conversion utility (imgcopy), movie creation/editing application (moviemaker), audio editing application (soundeditor)Control Panels pagename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'audio control panel (apanel), background setting control panel (background), desktop settings control panel (desktop)In most cases your application icon should appear on the Applications page, since that's where users will expect to find it. If you're developing a suite of applications, however, you may want to create a new page for your icons and let users know (in your product's documentation) that you've done this.FILE="fig.iconcatalog.bw" POSITION="INLINE" SCALE="FALSE"LBL="2-13"Figure 2-13 ID="83339"Icon CatalogLBL="" HELPID=""ID="22021"Naming and Locating Executables for the Find an Icon ToolThe Find an Icon tool, shown in ID="ch02.icons24"ID="ch02.icons25"IDREF="49376" TYPE="GRAPHIC"Figure 2-14, allows users to find applications by typing the name of the executable. If they type the correct name and if the executable is located in a directory on the user's search path or under the user's home directory, the corresponding icon appears in the drop pocket. The user can then drag the icon to another location such as the desktop, or open it directly from the Find an Icon tool by double-clicking. FILE="ch02.icons.ras14" POSITION="INLINE" SCALE="FALSE"LBL="2-14"Figure 2-14 ID="49376"The Find an Icon Tool Since users may be guessing at the most likely name for the application's executable, you should adhere to the following naming conventions: Choose a name that matches the product name or is strongly associated with the product. For example, the name of the IRIS Showcase executable is showcase, and the name of the online book application, IRIS InSight, is insight.Use only lowercase letters for the name. For example, the name for the SoundEditor executable is soundeditor.Don't include spaces in the name since UNIX doesn't handle spaces elegantly.Don't use numbers in the name to represent versions of a product. For example, the executables for IRIS InSight 2.2.1 and its earlier versions are all named insight.Don't use any special characters in the name, such as underlines or periods. Simply remove any spaces when converting your product's name to an appropriate name for your executable.Since the Find an Icon tool searches only directories on the user's search path and under the user's home directory, your executablename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'or a link to it, which is preferablename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'should reside in one of the directories on the user's default path. The directories included in the default path are: ID="ch02.icons26"COLUMNS="3"LEFT="0" WIDTH="84"/usr/sbinLEFT="90" WIDTH="83"/usr/bsdLEFT="180" WIDTH="91"/sbinLEFT="0" WIDTH="84"/usr/binLEFT="90" WIDTH="83"/binLEFT="180" WIDTH="91"/usr/bin/X11The most appropriate place to put a link to your executablename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'and the one that will result in users finding your application the fastestname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'is /usr/sbin.LBL="" HELPID=""Application Icon Accessibility GuidelinesWhen making your application icons accessible to users . . .Place your application icon on the Applications page in the Icon Catalog. If you produce a suite of software applications, consider creating your own page.In your documentation, refer users to the appropriate page in the Icon Catalog after they've installed your application.When naming your executable, use the product name or choose a name that's strongly associated with the product.When naming your executable, use only lowercase letters. Don't use numbers, spaces, or special characters such as underlines or periods.Make sure that a link to your executable (preferred method) or the executable itself resides in a directory in the user's default search path. Ideally, place a link to your executable in the /usr/sbin directory. This helps ensure that users can quickly find your application icon using the Find an Icon tool.LBL="3"ID="42750"Windows in the Indigo Magic EnvironmentWhen users run your application on the Indigo Magic Desktop, they interact with its windows through 4Dwm, the IRIS Extended Motif Window Manager. This chapter describes the look, interactions, and behaviors that your application's windows should support. (For information on individual window components, see IDREF="71076" TYPE="TITLE"Chapter 6, "Application Windows," and IDREF="95140" TYPE="TITLE"Chapter 9, "Controls.") This chapter covers the following topics:IDREF="24763" TYPE="TITLE""The Indigo Magic Look: Graphic Features and Schemes" discusses general characteristics of windows, including the Indigo Magic enhanced look provided by the IRIS IM toolkit and its advantages, and color and font schemes.IDREF="38970" TYPE="TITLE""Application Window Categories and Characteristics" defines the categories of windows in the Indigo Magic Desktop environment and presents several models of applications using the various window types. It also lists the required window decorations and Window menu for each window category, prescribes how to choose labels for title bars, and discusses window size and placement issues.IDREF="59672" TYPE="TITLE""Keyboard Focus Across Windows" establishes the 4Dwm default keyboard focus policy across windows as implicit, and describes the behavior for applications that need to maintain control of the pointer while it's outside of the application's windows.IDREF="90668" TYPE="TITLE""Minimized Windows" provides ideas for designing minimized window images, describes how to choose labels for minimized windows, and discusses application behavior while minimized.IDREF="53752" TYPE="TITLE""Desks" describes the tool that provides users with multiple virtual screens or desks. It covers the design implications for your application windows, which can be distributed over these multiple desks.IDREF="17063" TYPE="TITLE""Session Management" describes the 4Dwm session manager and the implications of allowing users to log out while your application is running and return automatically to the same state upon subsequent login.LBL="" HELPID=""ID="24763"ID="87629"The Indigo Magic Look: Graphic Features and SchemesWhen using the IRIS IM user interface toolkit, you can choose one of two different appearances for your application: either the basic OSF/Motif look, or the Indigo Magic look. The Indigo Magic look provides both an attractive, 3D look for your application and the default colors and fonts used by the Indigo Magic Desktop. There are two components to the Indigo Magic look: the graphic features and the color and font schemes.LBL="" HELPID=""ID="47013"Enhanced Graphics in the Indigo Magic LookThe Indigo Magic look contains a number of graphic modifications made to the standard IRIS IM interface. These modification improve the appearance and ease of use of applications with no impact on the component layout and minimal work on the part of the developer. Some of the differences between the Indigo Magic look and the standard IRIS IM look are illustrated in IDREF="15859" TYPE="GRAPHIC"Figure 3-1. In comparison, the Indigo Magic look:Uses smooth shading with a rounded dimensional look to create a high-quality visual appearance. Numerous sharp bevels, such as those found in standard Motif components, detract from rather than add to the visual presentation of an application. (See IDREF="15859" TYPE="GRAPHIC"Figure 3-1A.)Establishes the common aesthetic of burnished aluminum, giving a visually appealing look.Renders black outlines around stand-alone widgets to improve the readability and perception of adjoining color areas (see IDREF="15859" TYPE="GRAPHIC"Figure 3-1B and C). For example, the black outline around buttons and scrollbars make them stand out from a window's background. Uses decals instead of stacked, 3D elements to make it easier for users to see the components (see IDREF="15859" TYPE="GRAPHIC"Figure 3-1B). There is no gratuitous use of 3D such as the raised arrows and rectangular option buttons in standard Motif.Provides a more consolidated treatment for composite objects. For example, the Indigo Magic look visually integrates the arrow stepper buttons in scrollbars with the scrollbars themselves to give a less cluttered look. In addition, the scrollbars are visually integrated with the client pane as much as possible to make the whole assembly appear as a single, integrated unit (see IDREF="15859" TYPE="GRAPHIC"Figure 3-1C). Enhances scrollbars by providing a grip on the slider used in scrollbars and a temporararily indented impression to indicate the original location of the slider during the scrolling process (see IDREF="15859" TYPE="GRAPHIC"Figure 3-1C). The grip makes it easier for users to recognize the slider as something to be dragged rather than a button to be pressed. Adds additional visual feedback for selected checkboxes and radio buttons. A distinct red arrow and a blue triangle clearly indicate a selected checkbox and radio button, respectively (see IDREF="15859" TYPE="GRAPHIC"Figure 3-1A).Adds locate highlight (the object brightens as the pointer passes over it) so that users can tell which components are live functional objects and which are passive graphics or are disabled. Locate highlight also gives users feedback as to whether or not the application is listening.Uses a stroked underline to indicate mnemonics in menus simply to give the look of an application some pizazz (see IDREF="15859" TYPE="GRAPHIC"Figure 3-1D).For details on how to obtain the graphic enhancements of the Indigo Magic look, see IDREF="77833" BOOK="IndigoMagic_IG" FILE="02.IM.Look.doc" HDG=""Chapter 2, "Getting the Indigo Magic Look," in the Indigo Magic Desktop Integration Guide. For guidance on designing other aspects of your application windows, such as general layout principles and use of controls, see IDREF="71076" TYPE="TITLE"Chapter 6, "Application Windows" and IDREF="95140" TYPE="TITLE"Chapter 9, "Controls."FILE="ch03.windows.ras" POSITION="INLINE" SCALE="FALSE"LBL="3-1"Figure 3-1 ID="15859"Examples of Graphic Modifications in the Indigo Magic LookLBL="" HELPID=""ID="78166"Schemes for Colors and FontsIn addition to the graphic modifications described in the previous section, IDREF="47013" TYPE="TITLE""Enhanced Graphics in the Indigo Magic Look," the Indigo Magic look includes schemes. A 
scheme is a pre-packaged collection of colors and fonts that users can apply to application windows.FILE="fig.schemebrowser.bw" POSITION="INLINE" SCALE="FALSE"LBL="3-2"Figure 3-2 ID="36463"Scheme Setting Control PanelSchemes deliver several benefits to users. When all applications on a workstation use schemes, users can conveniently customize their environment. The schemes are designed with an eye to effective use of color, taking into account both usability and aesthetic considerations. Multiple schemes are provided to address such problems as red/green color-blindness, monochrome X-terminals, and user preference for light or dark text. A user changes the scheme for the desktop by selecting the new scheme from the control panel shown in IDREF="36463" TYPE="GRAPHIC"Figure 3-3. (This control panel is accessed from the Desktop->Customize cascading menu in the Toolchest.)Using schemes also benefits you as a developer by leveraging the work that has already been done on appropriate color and font choices. Using schemes eliminates worrying about different display resolutions, gamma values, user preferences, or most style guide color and font issues.The model for using schemes as a developer is to specify color and font choices as abstract names from the predefined scheme color and font palettes instead of hard-coding specific color and font values. Then, when the user specifies a scheme, the palette entries are mapped to specific RGB color and font values. By default, the Indigo Magic Desktop comes up in the Indigo Magic scheme. This scheme is organized around a neutral gray palette with the typographically neutral Helvetica font. Using neutral colors for standard user interface elements preserves the use of color for the application's content areas. Schemes are meant to apply to any region of an application window built with the standard toolkit components. Schemes should not be used for application client areas which are content specificname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for example, a rendering window, a movie player, or a molecular modeler. The colors in such client areas will be application-specific and not subject to change when a user selects a new scheme.For information on supplying schemes in your application, see IDREF="74067" BOOK="IndigoMagic_IG" FILE="03.Schemes.doc" HDG=""Chapter 3, "Using Schemes," in the Indigo Magic Desktop Integration Guide.LBL="" HELPID=""ID="95618"Indigo Magic Look GuidelinesWhen designing the look for your application . . .Use the Indigo Magic look rather than the standard IRIS IM look.Use the pre-packaged color and font schemes supplied by Silicon Graphics rather than designing your own colors and fonts.LBL="" HELPID=""ID="38970"Application Window Categories and CharacteristicsThis section defines the four categories of windows in the Indigo Magic Desktop environment; presents four models of applications using these window types; and lists the decorations, Window menus, and behavior required for each window type.LBL="" HELPID=""ID="82170"Application Window CategoriesThe OSF/Motif Style Guide refers to two categories of windows: primary windows and secondary windows. The Indigo Magic environment subdivides each of these categories to yield two additional categories useful in many applications. There are two types of primary windows:A main primary window serves as the application's main controlling window. It's used to view or manipulate data, get access to other windows within the application, and kill the process when users quit. There's only one main primary window per application (and sometimes it isn't visible to users). A co-primary window is used for major data manipulation or viewing of data outside of the main window. There are two types of secondary windows:A support window is a persistent special-purpose window. It typically contains a control panel or tool palette that operates directly on data in a primary window. It is used repeatedly. A dialog is a transient window, typically used for short, quick, user input, such as an action confirmation, or system output, as in a warning message. It may be user-requested or application-generated. LBL="" HELPID=""ID="67450"Application ModelsAlthough there can be many combinations in an application of the four window types discussed in the previous section (main, co-primary, support, and dialog windows), most applications can be classified as fitting one of four basic models. The distinguishing factors between the models are: whether they can have one or multiple documents (files) open at a time their use of primary windowsNoteThe term document means a grouping of data and shouldn't be thought of as simply a text-oriented file. It covers such data types as film clips, audio segments, and Inventor scenes. These models are illustrated and discussed in more detail in IDREF="67644" TYPE="TITLE""Application Models" in Chapter 6. For information about how to implement the various models, see IDREF="14513" BOOK="IndigoMagic_IG" FILE="05.Window.Management.doc" HDG="""Implementing an Application Model" in Chapter 5 in the Indigo Magic Desktop Integration Guide. LBL="" HELPID="""Single Document, One Primary" Application Model"Single document, one primary" is the most basic modelname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'it accomplishes all of its tasks within the main window and uses as many support windows and dialogs as needed. Users can work on only one document at a time. Thus, when a user has one document open and opens a second document, the second document replaces the first. IRIS Showcase operates in this manner.LBL="" HELPID="""Single Document, Multiple Primaries" Application ModelThe "single document, multiple primaries" model uses both main and co-primary windows to accomplish major tasks. In this model, the co-primary windows perform different functions. MediaMail is an example of this model. Its main window lets users select electronic mail messages from a folder and perform actions on them such as viewing, printing, deleting, and sorting. Its Compose and Message windows are typical of co-primary windows with different functions designed to support the functionality of the main window. In this model, each primary window has its own menu bar tailored specifically to the functions in that window.LBL="" HELPID="""Multiple Document, Visible Main" Application ModelThe "multiple document, visible main" model has a main window that is mostly used to launch co-primary windows. These co-primary windows are identical to each other and perform the same functions on different files or documents. Each co-primary window has its own menu bar. IRIS InSight is an example of this model. Its main window lets users launch co-primary viewing windows, browse available files, and conduct global searches through these files. The co-primary windows are used for viewing online books.LBL="" HELPID="""Multiple Document, No Visible Main" Application ModelThe "multiple document, no visible main" model is identical to the "multiple document, visible main" model except that the main window is invisible to the user and new co-primary windows are launched from co-primary windows that are already open. Users open one document and leave it open while opening others. When the last open document is closed, the process is killed.LBL="" HELPID=""ID="85826"Window Decorations and the Window MenuUsers primarily interact with windows on the Indigo Magic Desktop through the window decorations and Window menu, which 4Dwm, the IRIS window manager, places on each window. The decorations and Window menu entries vary according to the category of the window (see IDREF="82170" TYPE="TITLE""Application Window Categories" earlier in this chapter) and whether any of the components in the window are resizable. IDREF="44435" TYPE="GRAPHIC"Figure 3-3 shows the decorations for a typical main window. For complete details of the behavior of each of the window decorations, see Section 7.3, "Window Decorations," in the OSF/Motif Style Guide.FILE="ch03.windows.ras3" POSITION="INLINE" SCALE="FALSE"LBL="3-3"Figure 3-3 ID="44435"Features of a Typical Main Primary WindowThe recommended decorations and Window menu entries for each category of window are shown in IDREF="68452" TYPE="TABLE"Table 3-1. To meet these requirements, you may have to modify both the default window decorations and Window menu entries for at least some of your application windows. For information on modifying the default window decorations and Window menu entries, see IDREF="19937" BOOK="IndigoMagic_IG" FILE="05.Window.Management.doc" HDG=""Chapter 5, "Window, Session, and Desk Management," in the Indigo Magic Desktop Integration Guide. IDREF="68452" TYPE="TABLE"Table 3-1 also lists the keyboard accelerators and mnemonics provided by 4Dwm for each Window menu item. These keyboard accelerators are reserved and thus should not be assigned to other functions in your application.The behavior of the window decorations and Window menu entries is consistent with the definitions in Section 7.3 of the OSF/Motif Style Guide, with two notable differences:4Dwm Window menus include the entry "Raise." "Raise" allows the user to move the window to the top of the window hierarchy, making it completely visible (in contrast to "Lower"). "Exit" lets users quit the application completely from a primary window. Your application must do all the appropriate cleanup work for an exit from the Window menu, such as prompting the user whether to save changes to a file. The behavior of "Exit" in the Window menu is the same as that of "Exit" in the File menu. See IDREF="38726" TYPE="TITLE""File Menu" in Chapter 8 for information on the File menu. (Note that the "Close" entry on a co-primary window closes that window and any associated support windows and dialogs. It doesn't quit the application.)The Window menu entries are based on the functionality available for that type of window. For example, users can't exit the application from support or dialog windows, so these window types don't include an "Exit" entry. If a window can't be resized, it doesn't need the "Size" entry or the "Maximize" entry in its Window menu. (To eliminate the ability of a window to be resized, set the maximum and minimum window sizes equal to the default window size. See IDREF="32339" TYPE="TITLE""Window Size" later in this chapter.) Dialogs can't be minimized independently of their parent windows and thus don't have a "Minimize" entry. COLUMNS="5"LBL="3-1"Table 3-1 ID="68452"Window Decorations and Window Menu Entries by Window Category LEFT="0" WIDTH="108"Window Decorations and 
Window Menu EntriesLEFT="115" WIDTH="99"Main WindowsLEFT="220" WIDTH="99"Co-Primary WindowsLEFT="325" WIDTH="99"Support WindowsLEFT="430" WIDTH="99"DialogsLEFT="0" WIDTH="108"Window menu buttonLEFT="115" WIDTH="99"RequiredLEFT="220" WIDTH="99"RequiredLEFT="325" WIDTH="99"RequiredLEFT="430" WIDTH="99"RequiredLEFT="0" WIDTH="108""Restore  Alt+F5"IDREF="ch03.windowsTF0a"aLEFT="115" WIDTH="99"RequiredLEFT="220" WIDTH="99"RequiredLEFT="325" WIDTH="99"RequiredaLEFT="430" WIDTH="99"RequiredaLEFT="0" WIDTH="108""Move  Alt+F7"LEFT="115" WIDTH="99"RequiredLEFT="220" WIDTH="99"RequiredLEFT="325" WIDTH="99"RequiredLEFT="430" WIDTH="99"RequiredLEFT="0" WIDTH="108""Size  Alt+F8" / 
Resize handlesLEFT="115" WIDTH="99"Optional; use if user 
may need to expand 
work area or other 
components. If 
resizable, set minimum 
and maximum size 
limits.LEFT="220" WIDTH="99"Optional; use if user 
may need to expand 
work area or other 
components. If 
resizable, set minimum 
and maximum size 
limits.LEFT="325" WIDTH="99"Optional; use if user 
may need to expand 
any components, such 
as text input fields or 
scrolling lists. If 
resizable, set minimum 
and maximum size 
limits.LEFT="430" WIDTH="99"Optional; use if user 
may need to expand 
any components, such 
as text input fields or 
scrolling lists. If 
resizable, set minimum 
and maximum size 
limits.LEFT="0" WIDTH="108""Minimize  Alt+F9" / 
Minimize buttonLEFT="115" WIDTH="99"Required LEFT="220" WIDTH="99"RequiredLEFT="325" WIDTH="99"Don't useLEFT="430" WIDTH="99"Don't useLEFT="0" WIDTH="108""Maximize  Alt+F10" / 
Maximize buttonLEFT="115" WIDTH="99"Use only if there's a 
"Size" entry.LEFT="220" WIDTH="99"Use only if there's a 
"Size" entry.LEFT="325" WIDTH="99"Use only if there's a 
"Size" entry.LEFT="430" WIDTH="99"Use only if there's a 
"Size" entry.LEFT="0" WIDTH="108""Raise  Alt+F2"LEFT="115" WIDTH="99"RequiredLEFT="220" WIDTH="99"RequiredLEFT="325" WIDTH="99"RequiredLEFT="430" WIDTH="99"RequiredLEFT="0" WIDTH="108""Lower  Alt+F3"LEFT="115" WIDTH="99"RequiredLEFT="220" WIDTH="99"RequiredLEFT="325" WIDTH="99"RequiredLEFT="430" WIDTH="99"Required LEFT="0" WIDTH="108""Close  Alt+F4"LEFT="115" WIDTH="99"Don't use; not relevant 
for main windows.LEFT="220" WIDTH="99"RequiredLEFT="325" WIDTH="99"RequiredLEFT="430" WIDTH="99"RequiredLEFT="0" WIDTH="108""Exit  Alt+F12"LEFT="115" WIDTH="99"Required; closes all 
windows for this 
application and quits. LEFT="220" WIDTH="99"Optional; use if users 
can quit application 
from this window.LEFT="325" WIDTH="99"Don't useLEFT="430" WIDTH="99"Don't useLBL="a" ID="ch03.windowsTF0a"This entry always appears in the Window menu, and it's automatically disabled if there's no "Maximize" entry; this default behavior can't be 
changed.LBL="" HELPID=""ID="56252"Window Title BarBy default, all windows on the Indigo Magic Desktop have a title bar that contains a label for the window. The default label used in the title bar (the application name) rarely provides enough information for users to be able to distinguish one window from another. You should label your title bars according to the rules shown below to help your users distinguish among windows belonging to the same application as well as instances of the same application. (For information on how to set the label in the title bar, see IDREF="96868" BOOK="IndigoMagic_IG" FILE="05.Window.Management.doc" HDG="""Interacting With the Window and Session Manager" in Chapter 5 of the Indigo Magic Desktop Integration Guide.) In general, use the title bar label to identify the window; don't use it to display general status (such as current page number or viewing mode) or application-critical information. Using the title bar to display information can cause problems. For example:The title bar may be covered by another window or off the screen. Users aren't accustomed to looking for status information in the title bar, so they`re likely to overlook it if your application displays it there.It's expensive for the application to update the title bar continuously.For more information on where to place status information or application-critical information in your application window's title bars, see IDREF="30855" TYPE="TITLE""Status Areas in Primary Windows" in Chapter 6.The label you put in the title bar is also used in the Desks Overview window (see IDREF="55393" TYPE="TITLE""Desks" later in this chapter). By default, as a user moves the pointer over the thumbnail window sketches in the Desks Overview, the thumbnail window's title bar label displays as shown in IDREF="81978" TYPE="GRAPHIC"Figure 3-4. (Note that users can specify that the minimized window label be shown in the thumbnail sketches instead of the title bar label.) This further emphasizes the need for users to be able to distinguish windows using only the title bar information.FILE="ch03.windows.ras4" POSITION="INLINE" SCALE="FALSE"LBL="3-4"Figure 3-4 ID="81978"Title Bar Label Appearing in Desks OverviewLBL="" HELPID=""Rules for Labeling the Title Bar in Main Primary WindowsThe rules for labeling title bars in main windows are illustrated in IDREF="12998" TYPE="GRAPHIC"Figure 3-5. First determine if your application accesses document files. If not, use just the application name. If your application is document-based, use the application name followed by a colon (:) and the filename (or "Untitled" if it's a new file) as the label in the title bar. Note that if you include a filename in the label, you need to update the label whenever the file changes. Unless you have a real need and enough room, don't include the full pathname in the title bar. If your application is displaying remotely, use the host name followed by a colon as a prefix to the title bar label determined above. Be sure to leave spaces between strings and colons in the label. Don't use the version number in the title bar; that information should be available from the "Product Information" entry in the Help menu (see IDREF="35470" TYPE="TITLE""Types of Online Help" in Chapter 4 for more information). FILE="ch03.windows.cgm5" POSITION="INLINE" SCALE="FALSE"LBL="3-5"Figure 3-5 ID="12998"Labels for Main Window Title BarsLBL="" HELPID=""ID="15724"Rules for Labeling the Title Bar in Windows Other Than MainFor those co-primary windows that are used to supplement the main window's functionality as in the "single document, multiple primaries" application model, use the application name and function in the format AppName : Function. Make sure that the function closely matches the entry in the menu or the label on the button that invokes it. If the co-primary window follows a multiple document model such as the "multiple document, visible main" application model or the "multiple document, no visible main" application model, use the format AppName : Filename (or AppName : Untitled if it's a new file).Support windows use the application name and the function in the format AppName : Function. Make sure that the function closely matches the entry in the menu or the label on the button that invokes it.For dialog windows, use the application name, followed by the type of dialog in the format AppName : DialogType, where DialogType can be "Prompt," "Error," "Warning," "Question," "Information," "Working," or "File Selection." (For information on dialogs, see IDREF="30192" TYPE="TITLE"Chapter 10, "Dialogs.")LBL="" HELPID=""ID="32339"Window SizeThe 4Dwm window manager provides users with complete control over the size of application windows unless the application sets limits. Without a minimum window limit, users can shrink your windows to the point where they're unusable. With no maximum limit, users can expand a window to cover the full screen, potentially wasting valuable screen real estate. These extreme cases, along with a window at its default size, are illustrated in IDREF="55167" TYPE="GRAPHIC"Figure 3-6. Set appropriate maximum and minimum window sizes for all of your application windows. See IDREF="96868" BOOK="IndigoMagic_IG" FILE="05.Window.Management.doc" HDG="""Interacting With the Window and Session Manager" in Chapter 5 of the Indigo Magic Desktop Integration Guide.In general, windows should be resizable only if they contain areas or components that a user might wish to resize, for example, a primary window with a resizable work area or a support window with a scrolling list or text input field. If a window does not contain resizable areas or components, then it shouldn't be resizable and you should set both the maximum and minimum size equal to the default size. Remember also to remove the Size and Maximize entries from the Window menu as described in IDREF="85826" TYPE="TITLE""Window Decorations and the Window Menu" earlier in this chapter. For more information on specific window components, see IDREF="95140" TYPE="TITLE"Chapter 9, "Controls."FILE="ch03.windows.ras6" POSITION="INLINE" SCALE="FALSE"LBL="3-6"Figure 3-6 ID="55167"Default Maximum and Minimum Window Size ExamplesLBL="" HELPID=""ID="11715"Window PlacementUsers expect the placement of all primary windows to respond to the value of the Auto Window Placement option in the Window Settings control panel, as shown in IDREF="23895" TYPE="GRAPHIC"Figure 3-9. (Users access this control panel from the Desktop->Customize cascading menu in the Toolchest.) Support windows and dialogs are always placed automatically.FILE="ch03.windows.ras7" POSITION="INLINE" SCALE="FALSE"LBL="3-7"Figure 3-7 ID="23895"Setting Auto Window PlacementWhen auto window placement is on (the default), 4Dwm automatically places an application's primary windows. If a primary window does not supply any position information, 4Dwm by default places it in the upper left corner of the screen. When auto window placement is off, users expect to be able to interactively place all primary windows. In this case, a window displays initially as a red outline attached to the pointer at its upper left corner, allowing the user to place the window manually. The user places the window by moving the outline to the desired location on the screen and clicking the left mouse button. To take advantage of the Auto Window Placement setting, you must supply 4Dwm with a preferred window position for each primary window rather than a required window position. With a preferred window position, when Auto Window Placement is on, 4Dwm places the window at its preferred position. When Auto Window Placement is off, 4Dwm ignores the preferred position, allowing the user to place the window interactively. If the window has a required position, however, 4Dwm always tries to place the window at this preferred position even when users want to place windows themselves.Furthermore, users expect complete control when moving windows and should be able to move any of your application's windows anywhere on the desktop. Some applications try to "help" the user by repositioning the window programmatically; this strategy is never successful and instead ends up frustrating the user. For details on how to set a preferred window placement, see IDREF="96868" BOOK="IndigoMagic_IG" FILE="05.Window.Management.doc" HDG="""Interacting With the Window and Session Manager" in Chapter 5 of the Indigo Magic Desktop Integration Guide.LBL="" HELPID=""ID="57875"Application Window Characteristic GuidelinesIn general, when deciding on the characteristics for your application windows . . .Determine which category (main, co-primary, support, or dialog) each application window belongs to and assign characteristics appropriately.When setting up your window decorations . . .Include a Window menu button for all windows.Include resize handles only if the window contains resizable components such as work areas, scrolling lists, and text input fields.Include a Minimize button for all primary windows. Do not include this button on support windows or dialogs.Include a Maximize button only if the window contains resizable components.(To see the above window decoration requirements arranged according to window type, see IDREF="68452" TYPE="TABLE"Table 3-1.)When designing the Window menus for your application windows . . .Include "Restore  Alt+F5" for all primary windows. Include it for support windows and dialogs only if the menu contains a "Maximize" entry.Include "Move  Alt+F7" for all windows.Include "Size  Alt+F8" and resize handles for windows that contain resizable components such as works areas, scrolling lists, and text input fields.Include "Minimize  Alt+F9" and the Minimize button for all primary windows. Do not include the Minimize entry for support windows or dialogs.Include "Maximize  Alt+F10" for windows that are resizable, that is, they have a "Size  Alt+F8" entry.Include "Raise  Alt+F2" for all windows.Include "Lower  Alt+F3" for all windows.Include "Close  Alt+F4" for all windows except the main primary window.Include "Exit  Alt+F12" for the main primary window. Include "Exit  Alt+F12" for those co-primary windows from which users can quit the application. "Exit" always has the same behavior, that is, it quits the application, no matter how it's activated. Don't include "Exit" for support windows or dialogs.(To see the above Window menu requirements arranged according to window type, see IDREF="68452" TYPE="TABLE"Table 3-1.)Always use the default behaviors for the Window menu entries except for "Exit." Don't add functionality to these commands. When users choose "Exit," your application must perform any necessary clean up, such as prompting the user to save unsaved changes before quitting.Don't add application-specific entries to this menu. Users don't expect application-specific entries in the Window menu.Don't add a title to the Window menu.Don't use the keyboard accelerators <Alt-F2>, <Alt-F3>, <Alt-F4>, <Alt-F5>, <Alt-F7>, <Alt-F8>, <Alt-F9>, <Alt-F10>, or <Alt-F12> for other functions in your application. They are reserved for the 4Dwm Window menu entries.When specifying the label in the title bar . . .For all categories of windows, limit the length of each title bar label such that the entire label displays when the window is viewed at its default size.Don't include application-critical information or general status information in the title bar such as the current page number or whether a file is in view-only mode. For main windows, first determine if your application uses document files. If it is not document-based, use the application name only. If it is document-based, use the application name followed by a colon and the filename (or Untitled if new file) in the format AppName : filename and update the label whenever the filename changes. Don't use the full pathname unless that information is required for users to distinguish one window from another. If your application is displaying remotely, add the host name followed by a colon at the beginning of the title bar label in the format Host : AppName ... .For co-primary windows used in multiple document models, use the format AppName : Filename (or AppName : Untitled if a new file). For co-primary windows used in the "single document, multiple primaries" model, use the format AppName : Function. Make sure that the function matches the menu entry or the label on the button that invokes it. For support windows, use the application name and function in the format: AppName : Function. Make sure that the function closely matches the menu entry or the label on the button that invokes it. For dialog windows, use the application name, followed by the type of dialog in the format: AppName : DialogType, where DialogType is "Prompt," "Error," "Warning," "Question," "Information," "Working," or "File Selection."Leave spaces between strings and colons in a label.When determining the default, minimum, and maximum sizes for your windows . . .Specify a default size for each window.If the window is resizable, specify a minimum size at which all controls and work areas will be visible and large enough to be usable. If the window is not resizable, set the minimum size equal to the default size.If the window is resizable, specify a maximum size such that your application window doesn't expand to fill screen space unnecessarily. If the window is not resizable, set the maximum size equal to the default size.When considering window placement . . .Set a preferred window position for all primary windows. Don't set a required window position for primary windows. Try to anticipate other application windows that may be displayed with your application and set your preferred default position appropriately.LBL="" HELPID=""ID="59672"Keyboard Focus Across WindowsAs defined in the OSF/Motif Style Guide, there are two types of keyboard focus (also referred to as input focus): implicit, in which the keyboard focus tracks the pointerexplicit, which requires the user to explicitly select (by clicking with the left mouse button) which window or component receives the keyboard focusThe Indigo Magic Desktop uses implicit focus when moving the keyboard focus across windows. Your application should work well under implicit focus and shouldn't require users to change the default keyboard focus policy to explicit. (Note that within windows, applications should use explicit focus to move the keyboard focus between components in the window. Guidelines for using explicit focus within windows are discussed in IDREF="50040" TYPE="TITLE""Keyboard Focus and Navigation" in Chapter 7.)Certain applications need to 
grab the keyboard focus, that is, use the pointer while it is outside of the application windowname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for example, applications performing screen captures. This is called
 pointer grab mode. There are two recommended interaction models for pointer grab mode:
 single-action, which permits the user only one action to capture the data before returning to implicit focus; and 
multiple-action, which lets the user perform multiple actions while in pointer grab mode. In the multiple-action model, the user turns on a toggle to maintain keyboard focus while specifying the data to capture. In both the single- and multiple-action models, the application should change the pointer shape to indicate that the pointer belongs to a specific window and no longer adheres to implicit focus. (For a list of standard pointers, see IDREF="15568" TYPE="TITLE""Pointer Shapes and Colors" in Chapter 11.)LBL="" HELPID=""ID="17496"Single-Action Pointer Grab ModelThe InPerson desktop conferencing application is a good example of the single-action pointer grab model. The sequence in IDREF="69430" TYPE="GRAPHIC"Figure 3-8 illustrates the single-action pointer grab where the action is to sweep out an area of the screen to be captured as an image. The user chooses the "Snap Screen Area" entry from the screen capture menu in the whiteboard's tool bar. The pointer changes to a sighting pointer (a camera with a cross hair) and the user can then drag a rectangle around the area of the screen that the user wants to capture as an image. When the user completes the single action of dragging, InPerson releases the pointer and it is no longer in pointer grab mode. Note that in pointer grab mode, the active window is the window that has grabbed the keyboard focus, regardless of where the pointer is positioned on the screen. FILE="ch03.windows.ras8" POSITION="INLINE" SCALE="FALSE"LBL="3-8"Figure 3-8 ID="69430"Single-Action Pointer Grab Example: Capture by SweepingLBL="" HELPID=""Multiple-Action Pointer Grab ModelThe IRIS Showcase Image Gizmo, used for doing screen captures, is an example of the multiple-action pointer grab model. The IRIS Showcase Image Gizmo lets users capture an area of the screen as an image, then place that image in a IRIS Showcase document. The major difference between the Image Gizmo screen capture and the InPerson screen capture described in the previous section (IDREF="17496" TYPE="TITLE""Single-Action Pointer Grab Model") is that the Image Gizmo allows a user to perform multiple actions when defining the screen capture region and not just a single action like InPerson. This allows users to grab the pointer, sweep out an area to capture, and make any adjustments to the capture area before releasing the pointer and returning to implicit focus mode.The IRIS Showcase Image Gizmo provides an example of entering pointer grab mode. Here's the process:The user clicks the Sweep Area button in the Image Gizmo. This changes the pointer to a camera with a cross hair, which is used as the sighting pointer. At this point, the sighting pointer is limited to the Image Gizmo window, that is, the user hasn't initiated pointer grab mode yet.The user enters pointer grab mode by clicking the Grab Selection Focus button. Once in pointer grab mode, the sighting pointer is no longer limited to the Image Gizmo window. Now when the user moves the pointer out of the Image Gizmo window, the Image Gizmo retains the keyboard focus and the sighting pointer continues to display.NoteA better design would be to eliminate the step of requiring the user to click the Grab Selection Focus button and to instead have the Image Gizmo grab the keyboard focus when the user clicks the Sweep Area button.The user drags a rectangle around the area of interest on the screen. At this point, the user is still in pointer grab mode and can redefine the area by dragging the boundaries of the current rectangle or sweeping out a completely new area.The user clicks the Grab Image button, which releases the pointer, completes the screen capture, and returns the user to implicit focus mode.IDREF="63084" TYPE="GRAPHIC"Figure 3-9 shows this example during pointer grab mode. FILE="ch03.windows.ras9" POSITION="INLINE" SCALE="FALSE"LBL="3-9"Figure 3-9 ID="63084"Multiple-Action Pointer Grab ExampleLBL="" HELPID=""Guidelines for Keyboard Focus Across WindowsWhen designing your application windows . . .Make sure that your application works well under implicit focus across windows.Don't have your application move the pointer to another location on the screen. Always allow the user to control the position of the pointer on the screen.When incorporating a "pointer grab" function into your application . . .If the user is always going to specify the data to capture with a single action such as a single mouse click or a single mouse drag, use the single-action pointer grab model; otherwise use the multiple-action pointer grab model.Display a standard or modified sighting pointer whenever your application window grabs keyboard focus. This indicates that the keyboard focus belongs to your application's window and that the pointer isn't currently following implicit focus across windows.LBL="" HELPID=""ID="87201"ID="90668"Minimized WindowsMinimizing windows frees up screen real estate for other uses. On the Indigo Magic Desktop, users minimize windows by clicking the Minimize button in the window's title bar or choosing the "Minimize" entry from the Window menu. When a window is minimized, it's replaced by an 85x67-pixel representation with an identifying label of twelve characters or fewer. The 4Dwm window manager determines the placement of all minimized windows.Note that primary windows can be minimized independently of each other. Note also that dialogs and support windows become unmapped when their associated primary windows are minimized. LBL="" HELPID=""ID="80365"Choosing an Image for Your Minimized WindowIt's important for users to be able to identify application windows readily when minimized. You need to define a specific image for your main window and any co-primary windows in your application. A good example in which users can easily associate the minimized window with the application appears in IDREF="90304" TYPE="GRAPHIC"Figure 3-10. In the example, the IRIS InSight viewer window uses an open book as its minimized window image with the name of the book as the label.FILE="fig.minim.insight.viewer.bw" POSITION="INLINE" SCALE="FALSE"LBL="3-10"Figure 3-10 ID="90304"Minimized Window Example: Good User Association With ApplicationIf your application fits either of the single document application models discussed in IDREF="67450" TYPE="TITLE""Application Models" earlier in this chapter, it should have separate images for all primary windows. If your application fits one of the multiple document models, then it should have one image for the main window and a second image for the co-primary windows.FILE="ch03.windows.ras11" POSITION="MARGIN" SCALE="FALSE"LBL="3-11"Figure 3-11 ID="40246"Minimized Window ExamplesID="ch03.windows1"Here are some approaches for choosing a minimized window image (see examples in IDREF="40246" TYPE="GRAPHIC"Figure 3-11):Marketing themename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'If your application has a symbol used in packaging or marketing your product, you can use some or all of it to create an image. The IRIS Showcase minimized window is an example of this approach.Window snapshotsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'If your application's main primary window layout is distinctive, you can use a snapshot of a recognizable portion of it, as in the Icon Catalog and Directory View window examples. Symbolic themename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'You can use a symbol that reflects the nature of your application. For example, the text editor Jot uses an image of a writing hand. The IRIS Insight online book viewer uses an image of a stack of books to represent the main library window.Evocative imagename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'You can use an image that's evocative of the function your application performs. For example, the minimized window image for the mouse control panel is an image of a mouse. The minimized window image for the background control panel is an image that uses a combination of the various background patterns available for users via this tool.Although it is desirable to keep some family resemblance between the minimized window and other elements of an application, it's a bad idea to use a snapshot of a desktop icon as an image for a minimized window. The problem is that users could mistake the minimized window for the real desktop icon. IDREF="67613" TYPE="GRAPHIC"Figure 3-12 demonstrates this problem. The minimized window at the left (faked for this example) uses a snapshot of the application icon in its open state as its image. Users could confuse the minimized window with the application icon itself. The actual minimized window appears at the right of the figure, demonstrating good design. It reuses the magician's hat theme, showing the family resemblance, but uses a different rendition of the hat to avoid confusion.FILE="ch03.windows.ras13" POSITION="INLINE" SCALE="FALSE"LBL="3-12"Figure 3-12 ID="67613"Minimized Window Example: Incorrect DesignFILE="fig.min.bad.bw" POSITION="MARGIN" SCALE="FALSE"LBL="3-13"Figure 3-13 ID="76720"Minimized Window Example:Design That's Too LiteralWhichever theme you choose, make sure that the significance of your image will be grasped in foreign countries and will not offend international users. Images that are too literal will not be understood by an international audience. For example, the minimized window in IDREF="76720" TYPE="GRAPHIC"Figure 3-13 is for a debugging application and uses an image representing dead bugs. This may not be readily apparent to some non-English speaking users.For information on creating and implementing minimized window images, see IDREF="86930" BOOK="IndigoMagic_IG" FILE="06.Minimized.doc" HDG=""Chapter 6, "Customizing Your Application's Minimized Windows," in the Indigo Magic Desktop Integration Guide.LBL="" HELPID=""ID="46466"Labeling a Minimized WindowBy default, the 4Dwm window manager reuses the title bar label for the minimized window label. (The guidelines for specifying title bar labels are discussed in IDREF="56252" TYPE="TITLE""Window Title Bar" earlier in this chapter.) This doesn't usually work due to the space limit (approximately twelve characters) on the minimized window label. Thus, you will need to specify a label for each of your minimized windows. Those applications that aren't document-based should use the application name as the minimized window label for the main window. Any minimized co-primary windows for these applications should use the label Function, where Function is the same function as in the co-primary window's title bar.Applications that are document-based and follow the single-document models (see IDREF="67450" TYPE="TITLE""Application Models" earlier in this chapter) should use Filename (or "Untitled" for new files) for the minimized main window label. Any co-primary windows for these applications should use Function for the minimized window label, where Function is the same function as in the co-primary window's title bar.Applications that are document-based and follow the multiple-document models (see IDREF="67450" TYPE="TITLE""Application Models" earlier in this chapter), should use the application name as the label for the main window (if this main window is visible). The co-primary windows in these models represent the multiple documents and should have the minimized window label Filename (or "Untitled" for new files).The minimized window label is also used in the Desks Overview window (see IDREF="55393" TYPE="TITLE""Desks" later in this chapter). The user can customize the Desks Overview so that moving the pointer over the thumbnail window sketches in the Desks Overview displays the minimized window labels for those windows. This further emphasizes the need for users to be able to distinguish windows using only the minimized window label.For more information on specifying a label for a minimized window image, see IDREF="86930" BOOK="IndigoMagic_IG" FILE="06.Minimized.doc" HDG=""Chapter 6, "Customizing Your Application's Minimized Windows," in the Indigo Magic Desktop Integration Guide.LBL="" HELPID=""ID="67243"Processing While MinimizedUsers generally expect an application to continue processing while its windows are minimized; when re-opened, the window's contents should have changed appropriately. Of course, it doesn't make sense for all types of functions to continue processing while the window is minimized. For example, you needn't keep moving a clock application's hands while it is minimized. It's up to you to determine which functions are appropriate for continued processing and which are inappropriate. Be sure to stop those functions that don't need to process as they can be a drain on CPU resources.LBL="" HELPID=""ID="54212"Using the Minimized Window to Show StatusIf it is typical for users to minimize your application's windows while processing continues, you may wish to use your minimized application window to indicate status. IDREF="19815" TYPE="GRAPHIC"Figure 3-14 shows how the minimized window label can be used to indicate status in an electronic mail application by showing the number of messages in a mail folder.FILE="fig.minim.msgs.bw" POSITION="INLINE" SCALE="FALSE"LBL="3-14"Figure 3-14 ID="19815"Minimized Window Example: Indicating Status With the LabelIt is also possible to change the minimized window image to show status, however this is quite difficult. For more information on changing minimized window labels and images to show status, see IDREF="86930" BOOK="IndigoMagic_IG" FILE="06.Minimized.doc" HDG=""Chapter 6, "Customizing Your Application's Minimized Windows," in the Indigo Magic Desktop Integration Guide.LBL="" HELPID=""Minimized Window GuidelinesWhen designing images for your minimized primary windows . . .Use a color image rather than a two-color bitmap.Design your images to look best at the default size of 85x67 pixels.If your application is based on a single document model, create separate images for each of the primary windows. If your application is based on a multiple document model, create one image for the main window and a second image to use for all co-primary windows. Choose images that clearly identify the window that is minimized. If you have multiple images, make sure that the separate images work well together. Make sure that the images you use for minimized windows will be understood by an international audience.Don't use a snapshot of the desktop icon for the image. This could be confused with the real icon.When choosing labels for your minimized primary windows . . .Limit the label to approximately twelve characters. If you need a few more characters than this, check that your label will fit with the default size and font for minimized windows.If your application is not document-based, use the application name as the minimized window label for the minimized main window. Use the label Function for minimized co-primary windows where Function is the same function as in the co-primary window's title bar.If your application is document-based and follows one of the single-document models, use Filename (or "Untitled" for new files) for the minimized main window label. Use Function for minimized co-primary window labels where Function is the same function as in the co-primary window's title bar.If your application is document-based and follows one of the multiple-document models, use the application name as the label for the main window (if it is visible). The co-primary windows in these models represent the multiple documents and should have the minimized window label Filename (or "Untitled" for new files).When determining the behavior for a window that the user has chosen to minimize . . .Decide which operations should and should not continue to be processed while the window is minimized. Indicate status with the minimized window label if your application is typically minimized during long processes.Use the default screen locations supplied by 4Dwm for the minimized window. Don't specify your own screen location.LBL="" HELPID=""ID="55393"ID="53752"DesksThe Indigo Magic Desktop provides users with a handy tool called Desks Overview Due to a software patent dispute instituted by Xerox Corporation, the Desks and Desks Overview features of this version of the IRIX operating system are now optional and may or may not be available to you after May 15, 1995. On this date, these features will be disabled unless you have entered a license code obtained from Silicon Graphics. When the Desks Overview feature is initiated, a dialog box will periodically warn you of the May 15, 1995 expiration date. Depending on how this patent dispute is resolved, prior to May 15, 1995, Silicon Graphics will attempt to inform you that the license code for these features will: (1) not be available; (2) only be available at an additional price; or (3) be available free of charge. Silicon Graphics apologizes for this inconvenience and appreciates your understanding. For updates, see comp.sys.sgi.admin, or call 1-415-390-4334. Please do not send email, or call other SGI numbers.
 for organizing their work (see IDREF="94809" TYPE="GRAPHIC"Figure 3-15). The Desks Overview application allows users to create multiple virtual screens (desks). The user can place any primary window (main or co-primary) on any desk. The window appears in the thumbnail sketch in the Desks Overview window. Support windows and dialogs don't appear in these thumbnail sketches. FILE="fig.deskoverview.bw" POSITION="INLINE" SCALE="FALSE"LBL="3-15"Figure 3-15 ID="94809"Desks Overview WindowThere are several things you need to know about desks and the corresponding effects on the design of your application.4Dwm treats application windows on desks other than the current one as if they are minimized. The windows are no longer mapped to the screen display and the application is informed that it's unmapped. This emphasizes how important it is for you to decide which operations continue processing when the application is in an unmapped (minimized) state. (See IDREF="67243" TYPE="TITLE""Processing While Minimized" earlier in this chapter.)As users move the pointer over the miniaturized window representations in the thumbnail sketches, the title bar labels display by default. If the user prefers, the minimized window labels can be displayed instead. This further emphasizes the need to pick title bar labels and minimized window labels so that a user can distinguish windows using only this information. (For information on defining these labels, see IDREF="56252" TYPE="TITLE""Window Title Bar" and IDREF="46466" TYPE="TITLE""Labeling a Minimized Window" earlier in this chapter.)Support windows and dialogs will appear on all desks if their associated parent window is not mapped to the screen. Since support windows and dialogs should only appear on the desk where their parent appears, make sure that all parent windows are visible and mapped to the screen.Your application should not create a screen background. Screen backgrounds are managed by 4Dwm by default or by the user through the Background control panel. Users typically employ different screen backgrounds on different desks as an aid in orienting themselves. LBL="" HELPID=""Desks GuidelinesWhen designing your application . . .Make sure that all windows with associated support or dialogs are visible and mapped to the screen so that the support windows and dialogs appear only on the desk where their parent window displays.Don't design your application to manage the screen background.LBL="" HELPID=""ID="17063"Session ManagementSession management allows users to log out of their accounts and have any running applications automatically restart when they log back in, thus eliminating the need for users to restart applications manually when they log back in. In 4Dwm, users have the option of turning session management on (the default) or off by using the Window Settings control panel (which is available from the Desktop->Customize cascading menu in the Toolchest), as shown in IDREF="40246" TYPE="GRAPHIC"Figure 3-16IDREF="23895" TYPE="GRAPHIC"Figure 3-19.FILE="ch03.windows.ras18" POSITION="INLINE" SCALE="FALSE"LBL="3-16"Figure 3-16 ID="23895"Setting Session ManagementFor your application to be restarted via the 4Dwm session manager, your application needs to create a command line that will launch the application and restore its current state. Your application needs to update this command line as the application state changes. For details of specifying this command line and keeping it up to date, see IDREF="96868" BOOK="IndigoMagic_IG" FILE="05.Window.Management.doc" HDG="""Interacting With the Window and Session Manager" in Chapter 5 of the Indigo Magic Desktop Integration Guide. The following scenario outlines the process. FILE="ch03.windows.ras19" POSITION="INLINE" SCALE="FALSE"LBL="3-17"Figure 3-17 ID="23895"Setting Auto Window PlacementWhen a user launches an application, that application registers itself with the 4Dwm session manager by creating a command line that will launch the application and restore its current state. For example, if your application is used to edit a specific file, the command line should contain the information necessary to launch your application and open this specific file. There is only one command line per application. As the state changes over time, your application needs to update this command line. So, to continue the example, suppose the user opens a different file to edit under your application. In such a case, your application needs to create a new command line that will launch the application and open this new file.If the user opens co-primary windows or support windows (see IDREF="38970" TYPE="TITLE""Application Window Categories and Characteristics" earlier in this chapter for window definitions), these windows should also redisplay when the user logs out and back in again. (Dialogs typically don't redisplay.) One method for obtaining this behavior is to allow your application to take command line arguments to redisplay these windows so that you can include these arguments on the stored command line when appropriate. When the user logs out, 4Dwm saves the command lines for all applications that are currently running on the user's desktop. When the user logs back in, 4Dwm attempts to execute the commands that it saved and restore the user's desktop to what it was when the user logged out.Applications can also request to have 4Dwm inform them when a user chooses "Log Out." When applications receive this notification, they should not post any dialogs such as "Save unsaved changes before quitting?" Instead, if 4Dwm notifies your application that the user is logging out and there are unsaved changes for the current file, your application should use one of the following strategies:Save these changes into another file and name it something logical such as original_file_name.save. When the application is restarted at login, post a dialog that tells the user that this file with unsaved changes exists and query the user whether to open the original file or the file with the unsaved changes. This is the preferred strategy.Ignore the user's unsaved changes, and simply restart the application using the most recent saved version of the file. This strategy is okay, but it is not preferred.Don't automatically save the user's changes by default. This may cause the user to lose as much data as throwing away all unsaved changes. Let the user control when changes are saved. For details on how to request log-out notification from 4Dwm, see IDREF="96868" BOOK="IndigoMagic_IG" FILE="05.Window.Management.doc" HDG="""Interacting With the Window and Session Manager" in Chapter 5 of the Indigo Magic Desktop Integration Guide.LBL="" HELPID=""Session Management GuidelinesWhen designing your application . . .Have your application create a command line that will launch the application and restore its current state. This current state should minimally include reopening any files that are currently open under the application and opening any primary or support windows that are currently open.Update this command line as the state of the application changes.If your application allows users to create and edit data files, have 4Dwm notify your application when the user chooses "Log Out."If your application is running when the user chooses "Log Out" and there are unsaved changes for a specific file . . .Save these changes into another file and name it something logical such as original_file_name.save. When the application is restarted at login, post a dialog that tells the user that this file with unsaved changes exists and query the user to determine whether to open the original file or the file with the unsaved changes.If you cannot implement the preferred strategy described above, ignore the user's unsaved changes. Do not automatically save the user's changes by default.LBL="4"ID="43344"Indigo Magic Desktop ServicesIndigo Magic provides desktop services you can take advantage of in your applications. These services save you time by providing common functionality that you don't have to develop on your own. Using the services can also help ensure that your application is consistent with other applications in the Indigo Magic environment. This chapter covers the following topics:ID="ch04.services1"IDREF="83542" TYPE="TITLE""Software Installation" describes how users install, remove, and upgrade applications using Software Manager, an Indigo Magic Desktop utility.IDREF="81967" TYPE="TITLE""Online Help" describes SGIHelp, the standard online help system on all Silicon Graphics platforms.IDREF="14953" TYPE="TITLE""Online Documentation" discusses IRIS InSight, an online documentation delivery system available on all Silicon Graphics platforms. IDREF="62219" TYPE="TITLE""Desktop Variables" describes certain customization settings that users can choose and their implications for your application.IDREF="17476" TYPE="TITLE""File Alteration Monitor (FAM)" describes the FAM service, which informs your application about ongoing changes to the file system, eliminating the need for your application to do its own polling.LBL="" HELPID=""ID="83542"Software InstallationUsers install software on Silicon Graphics workstations using the Software Manager, a graphical tool for installing, removing, and tracking software (see ID="ch04.services2"ID="ch04.services3"ID="ch04.services4"ID="ch04.services5"ID="ch04.services6"ID="ch04.services7"IDREF="37171" TYPE="GRAPHIC"Figure 4-1). For your application to work with the Software Manager, you must package your files into software images that it will understand. This packaging process is simplified by the Software Packager tool, which is described in the Software Packager User's Guide.FILE="fig.swmgr.bw" POSITION="INLINE" SCALE="FALSE"LBL="4-1"Figure 4-1 ID="37171"The Indigo Magic Software ManagerAlthough you can create installation and removal scripts independently of the Software Manager, it's strongly recommended that you package your application to use the Software Manager format. The advantages of the Software Manager are:It gives users a single, graphical tool to install all of their applications, upgrades, and maintenance releases. Users won't have to learn how to use additional tools, read lengthy installation instructions, or enter commands in a UNIX shell.It allows users to remove their applications cleanly. Users can remove your application and all supporting directories and files using Software Manager. They don't have to rely on specialized removal instructions or guess which directories and files they should remove.It helps users upgrade applications cleanly. When the user installs an upgrade, the Software Manager automatically removes previous versions of that application.It provides installation status information. Users can query the Software Manager database to quickly obtain information such as whether the application is installed, when it was installed, how much disk space it uses, and whether any upgrades or maintenance releases have been installed. The Software Manager doesn't track this information for applications that were installed using specialized scripts.LBL="" HELPID=""Software Installation GuidelineMake sure that users can install and remove your application through the Software Manager, an Indigo Magic Desktop utility. LBL="" HELPID=""ID="81967"Online HelpYour application should provide online help. In the Indigo Magic environment, users are accustomed to specific kinds of online help information, including context-sensitive help (letting users click on window areas and components to get specific help) and task-oriented help (presenting help information for specific tasks that can be performed using the application). ID="ch04.services8"ID="ch04.services9"ID="ch04.services10"LBL="" HELPID=""ID="66672"Providing Help Using SGIHelpSGIHelp is the online help system available on all Silicon Graphics platforms. It provides an easy method for delivering help information to users. Although you can supply your own help system, it's strongly recommended that you use SGIHelp. The advantages of supplying SGIHelp with your application are:Users like itname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'it's easy to use and convenient. SGIHelp provides context-sensitive help and task-oriented help. It also allows users to get help information by browsing and searching an index of available help topics and by following cross-references (links) to related topics.Silicon Graphics users are already familiar with it. They may get frustrated if they have to learn a different help system for your application, particularly when they're looking for help.It eliminates the need for creating and maintaining your own help system. Many of the help capabilities that your application should support (which are discussed in the next section, IDREF="35470" TYPE="TITLE""Types of Online Help") are provided automatically when you use SGIHelp.SGIHelp is a full-featured system that provides users with: fast, direct access to any help topic, the ability to navigate forward and backward through cross-referenced help topics, an index of help topics, search capabilities, and convenient printing of help information. SGIHelp is also a multimedia toolname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'you can include inline images, 3D objects, and audio clips, and you can launch applications from it. For details on how to include SGIHelp in your application, see IDREF="60030" BOOK="IndigoMagic_IG" FILE="09.SGIHelp.doc" HDG=""Chapter 9, "Providing Online Help With SGIHelp," in the Indigo Magic Desktop Integration Guide.LBL="" HELPID=""ID="35470"Types of Online HelpThe keys to supplying useful online help are to anticipate users' questions and to provide them with easy access to the answers to those questions. Each window in your application should include a Help menu if the window has a menu bar or a Help button if the window doesn't have a menu bar.IDREF="92392" TYPE="GRAPHIC"Figure 4-2 demonstrates how users access online help from a Help menu. A typical Help menu showing the various types of information appears in the upper left of the figure. The SGIHelp windows available from the "Overview," "Index," and "Keys & Shortcuts" menu entries are shown in clockwise order around the Help menu.Online help falls into six general categories:context-sensitive informationoverview informationtask-oriented informationindex of help topicskeyboard shortcut informationproduct informationThese categories are defined and discussed in the following paragraphs.FILE="ch04.services.ras2" POSITION="INLINE" SCALE="FALSE"LBL="4-2"Figure 4-2 ID="92392"Typical Help Menu and Related WindowsLBL="" HELPID=""Context-Sensitive InformationID="ch04.services11"ID="ch04.services12"ID="ch04.services13"Context-sensitive information answers the question "What is the purpose of this area or component in this window?" It should be available for all primary and support windows. Context-sensitive help mode should be enabled when the user either chooses the "Click for Help" entry in a Help menu (if the window has a menu bar) or presses <Shift>-<F1> (whether or not the window has a menu bar).Once the user has enabled context-sensitive help mode for a particular window, the pointer should change to a question mark and the user should be able to click in any area of the window to get specific help information (see IDREF="75713" TYPE="GRAPHIC"Figure 4-3). At a minimum, your application should provide separate context-sensitive help for each control area, work area, status area, and menu in the window. This help should describe the purpose of the corresponding area and should include cross-references to task-oriented help topics which describe tasks which use this area.FILE="ch04.services.ras3" POSITION="INLINE" SCALE="FALSE"LBL="4-3"Figure 4-3 ID="75713"Context-Sensitive Help Example LBL="" HELPID=""Overview InformationID="ch04.services14"ID="ch04.services15"ID="ch04.services16"Overview information answers the question "What does this application or window do?" All main windows should provide overview help information regardless of whether help is provided from a menu or a button. Co-primary and support windows with menu bars should also provide this information. If the window has a menu bar, the overview information should be accessible from an "Overview" entry in the Help menu. For main windows that don't have a menu bar, this overview information should be contained in the help that's displayed when the user clicks on the Help button in the window.For main windows, the overview information should briefly describe the functionality of the entire application. For co-primary and support windows, the overview should describe the functionality of the current window. It can also provide cross-references to task-oriented information. An example Overview help topic is shown in IDREF="92392" TYPE="GRAPHIC"Figure 4-2. LBL="" HELPID=""Task-Oriented InformationID="ch04.services17"ID="ch04.services18"Task-oriented information answers the question "How do I accomplish a specific task?" It also serves to give users a quick overview of your application; users often scan a new application's menusname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'especially the Help menuname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'to get an idea of the application's functionality. All windows should provide task-oriented help. Windows with a menu bar should provide Help menu entries for each of the most important tasks that users can accomplish in that particular window. When a user chooses any of these entries, the resulting help topic should present task-oriented information that describes step-by-step instructions for accomplishing the given task. A typical list of tasks is shown in the Help menu for IDREF="92392" TYPE="GRAPHIC"Figure 4-2. For windows without a menu bar, the task-oriented information should be displayed when the user clicks on the Help button in that window. This help information should include step-by-step instructions for accomplishing all of the tasks in that specific window. LBL="" HELPID=""Index of Help TopicsThe ID="ch04.services19"ID="ch04.services20"indexof help topics answers the question "What help topics are available for this application?" This index should be available from all windows with a menu bar and should be displayed when the user chooses the "Index" entry from the Help menu. It should list all available help topics for the application, including those that are generated using the context-sensitive help mode and those that are available directly from the Help menu. Users should be able to browse the index and select individual help topics as an alternative to the other methods of accessing help. See IDREF="92392" TYPE="GRAPHIC"Figure 4-2 for an example index.LBL="" HELPID=""Keyboard Shortcut InformationID="ch04.services21"Keyboard shortcut information answers the question "How can I use the keyboard as a shortcut for performing specific actions?" This information should include all mnemonics, keyboard accelerators, and function keys available for the entire application (not just those for a specific window). An example keyboard shortcuts help topic is shown in IDREF="92392" TYPE="GRAPHIC"Figure 4-2.All main windows should provide information on keyboard shortcuts. Co-primary and support windows with menu bars should also provide access to this information. If the window has a menu bar, the keyboard shortcut information should be accessible from a "Keys & Shortcuts" entry in the Help menu. For main windows that don't have a menu bar, this shortcut information should be contained in the help that's displayed when the user clicks on the Help button in the window. ID="ch04.services22"LBL="" HELPID=""ID="33310"Product InformationID="ch04.services23"Product information answers generic questions about the application. At a minimum, it should identify the application and version number, but it can also include general product information such as copyright and trademarking, licensing, and customer support access. All main windows should provide access to this information. Co-primary and support windows with menu bars should also provide access to this information.If the window has a menu bar, the product information should be accessible from a "Product Information" entry in the Help menu. For main windows that don't have a menu bar, this product information should be contained in the help that is displayed when the user clicks on the Help button in the window.ID="ch04.services24"Note that product information should always be provided using an Information dialog rather than through the SGIHelp system. Some users don't install online help to save disk space, so using a dialog for this information allows more users to access the application's version number and customer support contact information. See IDREF="16318" TYPE="TITLE""Other Situations for Invoking Dialogs" in Chapter 10 for information about how to design an appropriate product information dialog. LBL="" HELPID=""ID="31568"Providing Help through a Help MenuAll windows that have a menu bar should provide a Help menu. (See ID="ch04.services25"IDREF="12088" TYPE="TITLE""Standard Menus" in Chapter 8 for more information on standard menus.) Help menus have the general layout, mnemonics, and keyboard accelerators shown in IDREF="40246" TYPE="GRAPHIC"Figure 4-4. The entries are divided into four groups. The list of tasks appears between the "Overview" and "Index" entries and is specific to the application.FILE="ch04.services.ras4" POSITION="INLINE" SCALE="FALSE"LBL="4-4"Figure 4-4 ID="40246"Typical Help MenuHelp menus should contain these elements, in the order presented:"Click for Help" provides context-sensitive information for the current window. It uses <Shift+F1> as the keyboard accelerator. (Note that this differs from the ID="ch04.services26"ID="ch04.services27"ID="ch04.services28"ID="ch04.services29"OSF/Motif Style Guide which recommends using the label "Context-Sensitive Help" for this entry.) "Overview" provides an overview of the entire application when it appears in the Help menu for the main window. Otherwise, it provides an overview of the functionality of the current window and should be labeled "Overview for <ID="ch04.services30"ID="ch04.services31"window name>". The list of tasks provides menu entries for those tasks that can be performed in the current window. This task-oriented information should include step-by-step instructions for how to accomplish the specific task. If you have more than ten or twelve or task entries, consider using a cascading menu such as the "Arranging Icons" entry in ID="ch04.services32"IDREF="40246" TYPE="GRAPHIC"Figure 4-4. Cascading menus are described in IDREF="53348" TYPE="TITLE""Using Cascading Menus" in Chapter 8. These entries shouldn't have mnemonics or keyboard accelerators."Index" displays a list of all help topics available for the application and allows users to choose topics from this list for viewing. ID="ch04.services33"ID="ch04.services34""Keys & Shortcuts" displays all mnemonics, keyboard accelerators, and function keys available for the entire application and not just those for a specific window. (Note that this differs from the ID="ch04.services35"ID="ch04.services36"OSF/Motif Style Guide which recommends using the label "Keyboard" for this entry.)"Product Information" identifies the application and version number. Additionally, this entry can provide general product information such as copyright and trademarking, licensing, and customer support access. ID="ch04.services37"ID="ch04.services38"LBL="" HELPID=""ID="94472"Providing Help Through a Help ButtonIf an application window doesn't have a menu bar, it should provide a ID="ch04.services39"ID="ch04.services40"Help button for accessing online help. When users click this button on a main window, they should get information that includes an overview of the functionality of the application (overview), step-by-step instructions for how to perform all of the tasks in this main window (task-oriented), a list of all keyboard shortcuts for the application, and the version number, copyright, licensing, and customer support access information for the application (product information).When users activate the ID="ch04.services41"ID="ch04.services42"ID="ch04.services43"Help button in a co-primary or support window, they should get information that describes the function of the specific window (overview), and step-by-step instructions for how to perform all of the tasks in this window (task-oriented). For dialogs, activating the Help button should provide help that focuses on the main purpose of the dialog, describes how to use the dialog, and might also provide pointers to additional information, especially in the case of error dialogs. Both primary and support windows with Help buttons should also provide context-sensitive help when the user presses <Shift>-<F1>. Dialogs typically don't support context-sensitive help mode.  A typical window with a Help button appears in IDREF="18553" TYPE="GRAPHIC"Figure 4-5. For specific information on laying out pushbuttons in windows, see IDREF="93963" TYPE="TITLE""Control Areas in Primary Windows" in Chapter 6 and IDREF="95730" TYPE="TITLE""Decorations, Initial State, and Layout of Dialogs" in Chapter 10. FILE="ch04.services.ras5" POSITION="MARGIN" SCALE="FALSE"LBL="4-5"Figure 4-5 ID="18553"Help Button Example LBL="" HELPID=""Guidelines for Designing Online HelpWhen designing access to online help for your application . . .Provide access in each window of your application from either a Help menu if the window has a menu bar or a Help button if the window doesn't have a menu bar. Use SGIHelp. This provides users with a familiar viewer and familiar navigation techniques when reading the online help for your application.When defining the types of online help for your application . . .Provide context-sensitive help, overview information, task-oriented help, a list of keyboard shortcuts, product information, and an index of help topics.Provide context-sensitive help for all primary and support windows.Enable context-sensitive help mode when the user either chooses the "Click for Help" entry in a Help menu (if the window has a menu bar) or presses <Shift>-<F1> (whether or not the window has a menu bar). Change the pointer to a question mark when context-sensitive help mode is enabled.At a minimum, provide separate context-sensitive help for each control area, work area, status area, and menu in the window. This help should describe the purpose of the corresponding area and should include cross-references to task-oriented help topics which describe tasks which use this area.Provide overview information for all main windows whether help is provided from a menu or a button. This overview should briefly describe the functionality of the entire application.For co-primary and support windows that include a menu bar, provide overview information that describes the functionality of that specific window.Provide task-oriented information for all windows. This information should include step-by-step instructions for how to accomplish all of the tasks available in the current window.For windows with a menu bar, provide access to an index of help topics. This index should list all available help topics for the application including those that are generated using the context-sensitive help mode and those that are available directly from the Help menu. In addition, users should be able to browse the index and select topics for reading. Provide keyboard shortcut information for all main windows (whether help is provided from a menu or a button) and for co-primary and support windows that include a menu bar. This information should include the mnemonics, accelerators, and function keys available for the entire application and not just for the current window.Provide product information for all main windows (whether help is provided from a menu or a button) and for co-primary and support windows that include a menu bar. This information should minimally include the product name and version number. It might also include other general product information such as copyright and trademarking, licensing, and customer support access.Display product information using an Information dialog so that users who don't install an application's online help can still access version number and customer support information.When providing a Help menu in an application window . . .Include a "Click for Help" entry to enable context-sensitive help mode with the keyboard accelerator <Shift>-<F1>.Include an "Overview" entry for main windows. For co-primary and support windows, include an entry labeled "Overview for <window name>". Include entries that represent a list of tasks that users can accomplish in the current window. If this list of tasks is more than ten or twelve entries, use cascading menus. These entries shouldn't have mnemonics or keyboard accelerators.Include an "Index" entry that allows the user to access the help index.Include a "Keys & Shortcuts" entry to display all keyboard shortcuts for the application.Include a "Product Information" entry. When providing a Help button in an application window . . .Provide a Help button for all windows that don't have a menu bar.For main windows, provide overview, task-oriented, keyboard shortcuts, and product information when the user clicks this button.For co-primary and support windows, provide overview and task-oriented information when the user clicks this button.For dialogs, provide help that focuses on the main purpose of the dialog and describes how to use the dialog.For primary and support windows that include a Help button, also provide access to context-sensitive help when the user presses <Shift>-<F1>. Dialogs typically don't support context-sensitive help mode.LBL="" HELPID=""ID="26928"Writing Online Help Content for SGIHelpThis section discusses the actual writing of the online help content. It might be of interest to both application designers and online help documentation writers.ID="ch04.services44"LBL="" HELPID=""Learning About SGIHelpThe basic unit of help information in SGIHelp is the ID="ch04.services45"help card (see IDREF="92392" TYPE="GRAPHIC"Figure 4-2, IDREF="75713" TYPE="GRAPHIC"Figure 4-3, and IDREF="18553" TYPE="GRAPHIC"Figure 4-5). Help cards typically cover one topic although they may be divided into subtopics. They can have cross-references (links) to other help cards for the application. These links appear as blue text in the help card viewer window. Before writing online help content for SGIHelp, read through the help information for some Indigo Magic applications to get a feel for content, functionality, and presentation. Some good examples of help in applications with a Help menu are the Directory View windows and the Icon Catalog application. Take a look at the User Manager (accessed from the System menu in the Toolchest) as an example of a utility that provides help through a Help button. Also try out the Help button in dialogs in the desktop applications.As you experiment with SGIHelp, follow some (blue) hypertext links to other help topics. Trace these cross-reference links both forward and backward. Look at the presentation of inline figures. Print some of the help information. Bring up the help index and search this index for specific keywords and phrases. Be sure to try out the "Click for Help" facility to get a feel for how specific the information is when you click on an area of the window.LBL="" HELPID=""Creating Help CardsOnline help is designed to be presented in short chunks of information that answer specific questions. (See IDREF="35470" TYPE="TITLE""Types of Online Help" earlier in this chapter for a list of the types of questions users ask and the types of information that should be available in your online help to answer these questions.) Each help topic consists of one card of information that answers a specific question. The SGIHelp viewer is designed to take up no more than one quarter of the screen. If a help card has more information than will fit in the viewer window at one time, the user can use the scroll bar to scroll through the information. Each help card should span no more than three viewer windows of information so that users can keep scrolling to a minimum. Sometimes a help card may depend on another help card. It's better to provide a link to the supplementary card than to repeat the information.All help cards have titles. Each title should tell the reader what's contained in the specific help card, and it shouldn't be written so that it assumes users have read other help topics. The titles should be as descriptive as possible since they also appear in an index of help topics. Users can display the list of help topics in the index by choosing "Index" from the Help menu. Note that the topics listed in the index should match the titles of the help cards as closely as possible.As in any form of documentation, use familiar terminology and natural, friendly, real-world language. Remember that when users access online help, they're often searching for a quick answer to a specific question. This isn't the time to teach them new technical terms. LBL="" HELPID=""Writing Context-Sensitive HelpBefore the writing process begins for context-sensitive help, list all appropriate window components that users might need help on. Describe components in terms of the user tasks they support. That is, don't just say what the component isname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'tell users when they would find this component useful. Be careful not to mix specific step-by-step instructions with the context-sensitive information; instead, you might include links to the appropriate task-oriented information. ID="ch04.services46"IDREF="75713" TYPE="GRAPHIC"Figure 4-3 shows the help card for context-sensitive help on the shelf area in a Directory View window. LBL="" HELPID=""Writing Overview InformationOverview information should be a one or two paragraph overview of either the application's functionality (main windows) or the functionality of a specific application window (co-primary and support windows). It should answer the question, "What does this application (or application window) do?" ID="ch04.services47"IDREF="92392" TYPE="GRAPHIC"Figure 4-2 shows the overview card for Directory View windows. Notice how it provides an overview of the entire application and limits the information to the application's functionality.LBL="" HELPID=""Writing Task InformationStart by compiling a list of major tasks that users will want to perform using the application. For each task, supply the step-by-step instructions necessary to accomplish that task. If the instructions span more than three or four viewer windows of information, try to divide this topic into several smaller help topics. In addition to the step-by-step information, provide a brief summary paragraph at the beginning of the help card. Some readers take the time to read only the first few sentences of a help card.ID="ch04.services48"IDREF="99134" TYPE="GRAPHIC"Figure 4-6 is an example of a task-oriented help card taken from a Directory View window. Note that it displays the summary paragraph and the initial steps in the in the first viewer window of information. Remember that when displayed in a Help menu, the list of tasks gives users a quick overview of what the application can do, before they've even had to look at a help card. Make sure that you have descriptive titles for your task-oriented help cards and review them as a group. See IDREF="92392" TYPE="GRAPHIC"Figure 4-2. FILE="ch04.services.ras6" POSITION="INLINE" SCALE="FALSE"LBL="4-6"Figure 4-6 ID="99134"Task-Oriented Help Example LBL="" HELPID=""Writing Index InformationUsers access the help index to browse or to search for specific topics, so it's important to have descriptive titles for your help cards. The help index presents topics roughly in the order in which they appear in the Help menu: overview, list of tasks, context-sensitive topics, and keyboard shortcuts. If the application has more than one window with a Help menu, the help topics are grouped by windows. See ID="ch04.services49"IDREF="92392" TYPE="GRAPHIC"Figure 4-2. LBL="" HELPID=""Writing Keyboard Shortcut InformationEvery Help menu should have a "Keys & Shortcuts" entry containing all the mnemonics, keyboard accelerators, and function keys for the entire application. Typically, this help card contains an introductory description and a three-column table containing columns for the menu entry label, keyboard accelerator, and mnemonic. You should also include information on function keys and other shortcuts that can be used in your application. See ID="ch04.services50"IDREF="92392" TYPE="GRAPHIC"Figure 4-2. LBL="" HELPID=""Writing for Windows With Help ButtonsIf your main application window has a ID="ch04.services51"Help button rather than a Help menu, the initial help card should contain an overview of your application, task-oriented information, a list of all keyboard shortcuts, and product information. To make it easier for users to navigate through this amount of information, after the overview information at the beginning of the help card, place links which take users directly to the other chunks of help information contained in the card. This strategy greatly reduces the amount of scrolling and searching necessary. See IDREF="18553" TYPE="GRAPHIC"Figure 4-5 for an example help card with links to additional information.On other windows with a Help button, present only the help information for the specific window. If this information is longer than three or four viewer windows of information, use the above strategy of presenting brief overview or summary information followed by a list of links to the individual chunks for the task-oriented information. LBL="" HELPID=""Guidelines for Creating SGIHelp ContentWhen writing any online help for your product . . .Create separate help "cards" for each help topic.Limit each help card to no more than three viewer windows full of information. Write a descriptive heading for each help card. If a particular help topic needs supplemental information, provide links to that information rather than repeating it in the current card.Use language your users will understand.Use figures when appropriate. SGIHelp allows users to view graphics inline with the help text.When writing the "Click for Help" context-sensitive information for your application . . .Begin by listing the individual controls and areas of your application windows that you need to describe. At a minimum, provide separate help cards for each group of controls and areas in that window. Provide descriptions in terms of the user tasks the components support. Don't include procedural, task-oriented information with the context-sensitive informationname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'include links to the appropriate task-oriented topics instead. When writing the overview help cards for your application . . .Restrict the content to information about what the product does, not how to use it.Limit the text to one or two viewer windows of information.Use the heading "Overview" for the main window's overview help card and "Overview of <window name>" for co-primary and support windows with overview help cards.When writing the task-oriented information for your application . . .Begin by listing the tasks that users will want to accomplish with your application. For each task, list the step-by-step instructions users will need to accomplish that task. If these instructions span more than three or four viewer windows, try to divide this topic into several smaller help topics. Provide a brief summary paragraph at the beginning of the help card, followed by the step-by-step information. When writing the keyboard shortcuts information for your application . . .Include all shortcuts for your application in a single cardname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'mnemonics, keyboard accelerators, and function keys.When creating the index for your help topics . . . Match the titles in the index as closely as possible to the titles of the help cards.Place the topics in the index in the following ordername='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'overview, list of tasks, context-sensitive topics, and keyboard shortcuts.When writing help information that will be available from a Help button rather than from a Help menu . . .For the main application window, the help card should contain an overview of your application, task-oriented information, a list of all keyboard shortcuts, and product information.For Help buttons not on the main application window of your application, present only the help information for the specific window. If the amount of information on this one help card spans more than three or four viewer windows of information, after the overview or summary information at the beginning of the help card, place links which take users directly to the other chunks of help information contained in that card.After writing your online help . . .Have reviewers examine your help content online rather than reviewing a printed copy. Help topics will "read" differently depending on which paths readers (reviewers) traveled to get there.Have reviewers check the titles of the help topics to make sure they are descriptive and appropriate.Have reviewers test out all links to make sure they are appropriate.LBL="" HELPID=""ID="14953"Online DocumentationSilicon Graphics now ships almost all manuals in online form using IRIS InSight. IRIS InSight is an online documentation delivery system based on SGML (Standard Generalized Markup Language), a portable, platform-independent document description language. ID="ch04.services52"InSight offers users a convenient means of viewing manuals. It can save money for organizations that ship a high volume of manuals, that have frequent releases, and whose users can get by without hardcopy versions of the manual. If your organization fits this description and uses a process based on a standardized approach to document management, consider using IRIS InSight. To contact Silicon Graphics for more information, send email to techpubs@sgi.com. LBL="" HELPID=""ID="62219"Desktop VariablesThe Indigo Magic Desktop allows users to set a variety of variables that can affect the way an application behaves on the desktop. These variables are set using the graphical control panels selected from the Desktop->Customize cascading menu in the Toolchest. Users expect all applications to adhere to the values set in these graphical control panels. Your application should support this expectation by using the values that users have set for these variables.Your application needs to be concerned only with those variables listed in this section. For details on having your application respond to the settings of these variables, see IDREF="74067" BOOK="IndigoMagic_IG" FILE="03.Schemes.doc" HDG=""Chapter 3, "Using Schemes," and IDREF="19937" BOOK="IndigoMagic_IG" FILE="05.Window.Management.doc" HDG=""Chapter 5, "Window, Session, and Desk Management," both in the Indigo Magic Desktop Integration Guide. The other variables that users can set using the graphical control panels either don't affect your application or automatically apply to your application. These variables include things such as whether the mouse is set for right-handed or left-handed users and the default permissions for new files.LBL="" HELPID=""Scheme SettingThe Scheme variable allows users to change the color and font scheme used by applications that are currently running on the desktop. This variable is discussed in the section ID="ch04.services53"IDREF="78166" TYPE="TITLE""Schemes for Colors and Fonts" in Chapter 3.LBL="" HELPID=""Auto Window Placement SettingThe Auto Window Placement setting allows users to specify whether newly opened windows should be placed automatically by the ID="ch04.services54"4Dwm window manager or should be placed interactively by the user. This variable is discussed in the section IDREF="11715" TYPE="TITLE""Window Placement" in Chapter 3.LBL="" HELPID=""Language SettingFILE="fig.set.lang.bw" POSITION="MARGIN" SCALE="FALSE"LBL="4-7"Figure 4-7 ID="33427"Language Control PanelWhen users launch an application, they expect the application to appear in the language set in the Language Control panel (see ID="ch04.services55"IDREF="33427" TYPE="GRAPHIC"Figure 4-7). The default setting is U.S. English. For guidelines on designing an internationalized application, see the online manual Topics in IRIX Programming.LBL="" HELPID=""Mouse Double-Click Speed SettingUsers expect applications to respond to the mouse double-click speed set in the Mouse Settings control panel (see ID="ch04.services56"IDREF="87735" TYPE="GRAPHIC"Figure 4-8).FILE="ch04.services.ras9" POSITION="INLINE" SCALE="FALSE"LBL="4-8"Figure 4-8 ID="87735"Mouse Settings Control PanelLBL="" HELPID=""Editor Preference SettingWhen users open ASCII text files on the Indigo Magic Desktop, the default editor is ID="ch04.services57"ID="ch04.services58"jot, a point-and-click graphical editor. Users can change the default editor using the Desktop control panel (see IDREF="50319" TYPE="GRAPHIC"Figure 4-9). Applications that let users modify ASCII text files should default to the text editor specified in the Desktop control panel. FILE="ch04.services.ras10" POSITION="INLINE" SCALE="FALSE"LBL="4-9"Figure 4-9 ID="50319"Desktop Settings Control PanelFor example, the Compose window in the MediaMail application, shown in IDREF="26718" TYPE="GRAPHIC"Figure 4-10, gives users a simple editor for composing electronic mail messages. In addition, users can also elect to use their preferred editor by selecting the "Editor" entry in the Edit menu for this window. This launches the editor set in the Desktop control panel, which in this example is jot.FILE="ch04.services.ras11" POSITION="INLINE" SCALE="FALSE"LBL="4-10"Figure 4-10 ID="26718"Selecting Preferred Editor in MediaMail LBL="" HELPID=""Desktop Variables GuidelinesIn general . . .Always honor the user's desktop customization settings. Never override or ignore them.When considering color and font schemes for your application. . .Use the pre-packaged color and font schemes supplied by Silicon Graphics rather than designing your own.When considering window placement . . .Set a preferred window position for all primary windows. Don't set a required window position for primary windows.Try to anticipate other application and tool windows that may be displayed with your application and set your preferred default position appropriately.To allow users to control the language for your application . . .Check the value of the default language each time your application is launched. Don't reset this value while the application is running.To allow users to control the mouse double-click speed for your application . . .Check the value of the double-click speed each time your application is launched. Don't reset this value while the application is running.If users will be editing and/or browsing ASCII text files in your application . . .Make their preferred editor (specified in the Desktop control panel) available for use on text files. Check the value for the preferred editor each time your application is launched, but don't reset this value while your application is running. If users can only browse the ASCII text files, launch the editor in read-only mode.LBL="" HELPID=""ID="17476"File Alteration Monitor (FAM)The File Alteration Monitor (FAM) is a service that monitors changes to files and directories in the file system and notifies interested applications of these changes. If your application needs to stay in sync with the state of any part of the file system, you should use FAM. This process is considerably more efficient than having an application poll the file system itself to detect changes. (See ID="ch04.services59"ID="ch04.services60"IDREF="11012" BOOK="IndigoMagic_IG" FILE="08.FAM.doc" HDG=""Chapter 8, "Monitoring Changes to Files and Directories," in the Indigo Magic Desktop Integration Guide for details on using FAM in your application.)Here are two examples of Indigo Magic applications that use FAM:The File Manager relies on FAM to track any changes to directories and/or files that are visible on the user's desktop or in any open Directory View windows. When FAM notifies the File Manager of any changes, the File Manager updates the views. This guarantees that the user always sees an accurate view of the file system, both on the desktop and in the Directory View windows.MediaMail uses FAM to monitor the arrival of new mail by tracking changes to the /usr/mail directory. If a user is running MediaMail and new mail arrives, the user is immediately notified.LBL="" HELPID=""File Monitoring GuidelineIf your application needs to stay in sync with the state of any part of the file system, use FAM. Don't have your application directly poll the file system to detect changes.LBL="5"ID="43344"Data Exchange on the Indigo Magic DesktopThe Indigo Magic Desktop enables users to transfer data between applications. There are two types of transfers from the user's point of view. ID="ch05.xchange1"ID="ch05.xchange2"Copy takes data specified in the source application and creates a duplicate in the destination application. 
Move removes the data specified in the source application and places it in the destination application. The source and destination applications can be the same application.This chapter covers the following topics:IDREF="27430" TYPE="TITLE""Supporting the Clipboard Transfer Model" explains what users expect when performing operations using the "Cut," "Copy," and "Paste" entries in the Edit menu.IDREF="61999" TYPE="TITLE""Supporting the Primary Transfer Model" describes the expected behavior when users select data and copy it using the left and middle mouse buttons.IDREF="80633" TYPE="TITLE""Data Types Supported for Inter-Application Transfer" lists those data types that users can transfer between applications.LBL="" HELPID=""ID="27430"Supporting the Clipboard Transfer ModelIn the clipboard transfer model, users move or copy a selection using the "Cut," "Copy," and "Paste" entries from the Edit menu. If your application contains data that users will want to transfer to other applications or across separate instantiations of your application, your application should support the clipboard transfer model described in this section. Note that this model is a subset of the clipboard transfer model described in Section 4.3 of the ID="ch05.xchange3"ID="ch05.xchange4"ID="ch05.xchange5"ID="ch05.xchange6"ID="ch05.xchange7"ID="ch05.xchange8"ID="ch05.xchange9"OSF/Motif Style Guide. For information on implementing clipboard transfer, see IDREF="56716" BOOK="IndigoMagic_IG" FILE="07.Data.Exchange.doc" HDG="""Implementing the Clipboard Transfer Model" in Chapter 7 of the Indigo Magic Desktop Integration Guide. For more information on the layout of the Edit menu, the behaviors of each entry, and keyboard accelerators, see IDREF="94339" TYPE="TITLE""Edit Menu" in Chapter 8.In a typical clipboard transfer, the user selects data in an application window and initiates a move or copy transfer operation by choosing "Cut" or "Copy" from the window's Edit menu. The source application then takes ownership of the clipboard atom replacing the prior owner (if there was one). The user completes the transfer by choosing "Paste" from the Edit menu in the destination application. The destination application then moves or copies the data associated with the clipboard to this destination. When the transfer is complete, the newly pasted data is not selected or highlighted. For more information on selection techniques, see IDREF="59818" TYPE="TITLE""Selection" in Chapter 7. Note that clipboard data is nonpersistent. If a user quits the application that currently owns the clipboard, the data associated with the clipboard atom is lost. Only one application can own the clipboard atom at any given time.ID="ch05.xchange10"IDREF="54884" TYPE="GRAPHIC"Figure 5-1 illustrates clipboard transfer using the SoundEditor application. In the figure, there are two instantiations of the application; the window on the left is the source and the one on the right is the destination. Note that the clipboard atom in the figure is only a representation and doesn't actually appear. In this example, the user selects a region of sound in the source window and chooses "Copy" from the Edit menu in that window. The source instantiation of SoundEditor takes ownership of the clipboard atom. When the user chooses "Paste" from the Edit menu in the destination window, the data associated with the clipboard is inserted into the destination sound file at the insertion cursor (the vertical black line). Note that after the "Paste" operation, the SoundEditor application doesn't select or highlight the newly pasted data.FILE="ch05.xchange.ras" POSITION="INLINE" SCALE="FALSE"LBL="5-1"Figure 5-1 ID="54884"Clipboard Transfer ExampleThe clipboard operates independently of the primary selection described in the next section, ID="ch05.xchange11"ID="ch05.xchange12"IDREF="61999" TYPE="TITLE""Supporting the Primary Transfer Model." When a user chooses "Cut" or "Copy" from an Edit menu, that application takes ownership of the clipboard but the primary selection remains unchanged. LBL="" HELPID=""ID="61999"Supporting the Primary Transfer ModelIn the primary transfer model, users select the data for transfer using the left mouse button and copy the data to the destination application using the middle mouse button. If your application contains data that users will want to transfer to other applications or across separate instantiations of your application, your application should support the primary transfer model described in this section. Note that this model is a subset of the primary transfer model described in Section 4.3 of the ID="ch05.xchange13"ID="ch05.xchange14"ID="ch05.xchange15"ID="ch05.xchange16"OSF/Motif Style Guide. For information on implementing primary transfer, see IDREF="35778" BOOK="IndigoMagic_IG" FILE="07.Data.Exchange.doc" HDG="""Implementing the Primary Transfer Model" in Chapter 7 of the Indigo Magic Desktop Integration Guide. In the ID="ch05.xchange17"ID="ch05.xchange18"primary transfer model, when a user begins a selection in an application, that application takes ownership of the primary selection atom, replacing the previous owner if there was one. This selection is referred to as the primary selection. The user can then copy the primary selection to a destination application by moving the pointer to the destination window (making it the active window) and clicking the middle mouse button. At this point, the destination application copies the primary selection data to this destination. Note that the data is pasted at the position of the pointer, not at the insertion cursor. Also note that when the copy is complete, the newly pasted data isn't selected or highlighted. For more information on selection techniques, see IDREF="59818" TYPE="TITLE""Selection" in Chapter 7. IDREF="30841" TYPE="GRAPHIC"Figure 5-2 through IDREF="68897" TYPE="GRAPHIC"Figure 5-3 illustrate primary selection and transfer using the SoundEditor application. IDREF="30841" TYPE="GRAPHIC"Figure 5-2 illustrates making a primary selection. The user creates a selection by dragging with the left mouse button across a range of sound data. As soon as the user begins this selection, SoundEditor takes ownership of the primary selection atom. This selection is then referred to as the primary selection.FILE="ch05.xchange.ras2" POSITION="INLINE" SCALE="FALSE"LBL="5-2"Figure 5-2 ID="30841"Primary Selection ExampleIDREF="68897" TYPE="GRAPHIC"Figure 5-3 shows the source and destination windows just prior to a primary transfer. IDREF="68897" TYPE="GRAPHIC"Figure 5-3 shows the source and destination windows after the transfer. Note that when the user clicks the middle mouse button, the primary selection is inserted at the pointer location rather than at the insertion cursor. Also note that after the transfer operation, the SoundEditor application doesn't select or highlight the newly pasted data and the primary selection doesn't change.FILE="ch05.xchange.ras3" POSITION="INLINE" SCALE="FALSE"LBL="5-3"Figure 5-3 ID="68897"Primary Transfer Example: Before TransferFILE="ch05.xchange.ras4" POSITION="INLINE" SCALE="FALSE"LBL="5-4"Figure 5-4 ID="68897"Primary Transfer Example: After TransferIn general, when your application loses the primary selection, it should keep its current selection highlighted. When a user has selections highlighted in more than one window at a time, the most recent selection is always the primary selection. This is consistent with the ID="ch05.xchange19"ID="ch05.xchange20"persistent always selection model discussed in Section 4.2 in the OSF/Motif Style Guide. Exceptions to this guideline are those applications that use selection only for primary transfername='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for example, the winterm Unix shell window. The only reason for users to select text in a shell window is to transfer that text using the primary transfer mechanism. In this case, when the winterm window loses the primary selection, the highlighting is removed. This is referred to as nonpersistent selection in Section 4.2 in the OSF/Motif Style Guide. For guidelines on selection in general, see IDREF="59818" TYPE="TITLE""Selection" in Chapter 7.If the user returns the keyboard focus to a window with a highlighted, superseded primary selection, the application should allow the user to reinstate the highlighted selection as the primary selection by pressing <Alt-Insert>. In addition to supporting this key combination, you can also add the entry "Promote" to the Edit menu for the application window. The "Promote" menu entry should be active only when your application has a selection which is not the primary selection. (For details of placing this item in the Edit menu, see ID="ch05.xchange21"ID="ch05.xchange22"ID="ch05.xchange23"IDREF="94339" TYPE="TITLE""Edit Menu" in Chapter 8.) Note that when a user begins to modify a selection, such as adding elements to it, it's considered to be a new selection. In this case, your application needs to reassert ownership of the primary selection if your application doesn't currently own it.The primary selection operates independently of the clipboard, as described in the previous section, ID="ch05.xchange24"ID="ch05.xchange25"IDREF="27430" TYPE="TITLE""Supporting the Clipboard Transfer Model." When the user makes a selection, that selection becomes the primary selectionname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'there's no effect on the contents of the clipboard. LBL="" HELPID=""ID="80633"Data Types Supported for Inter-Application TransferApplications can use the atom names listed in ID="ch05.xchange26"IDREF="75072" TYPE="TABLE"Table 5-1 for both clipboard and primary transfer of the corresponding types of data. If you want users to be able to transfer data from your application to other applications, you need to be able to export data in one of the formats listed in IDREF="75072" TYPE="TABLE"Table 5-1. If your application is to receive data from other applications, see IDREF="75072" TYPE="TABLE"Table 5-1 for what's required. For complete details of implementing both clipboard and primary data transfer, see IDREF="12625" BOOK="IndigoMagic_IG" FILE="07.Data.Exchange.doc" HDG=""Chapter 7, "Interapplication Data Exchange," in the Indigo Magic Desktop Integration Guide.COLUMNS="4"LBL="5-1"Table 5-1 ID="75072"Data Types Supported for Inter-Application TransferLEFT="0" WIDTH="144"Target Format Atom NameLEFT="150" WIDTH="108"Nature of DataLEFT="265" WIDTH="108"What Target ReceivesLEFT="380" WIDTH="144"Receiving Application 
RequirementsLEFT="0" WIDTH="144"INVENTORLEFT="150" WIDTH="108"3D, generated by 
InventorLEFT="265" WIDTH="108"Inventor data (Scene 
Graph)LEFT="380" WIDTH="144"Ability to read Inventor dataLEFT="0" WIDTH="144"_SGI_RGB_IMAGE_FILENAMELEFT="150" WIDTH="108"color image in rgb formatLEFT="265" WIDTH="108"rgb file nameLEFT="380" WIDTH="144"Ability to use rgb filesLEFT="0" WIDTH="144"_SGI_RGB_IMAGELEFT="150" WIDTH="108"color image in rgb formatLEFT="265" WIDTH="108"stream of rgb dataLEFT="380" WIDTH="144"Ability to use rgb filesLEFT="0" WIDTH="144"_SGI_AUDIO_FILENAMELEFT="150" WIDTH="108"sound dataLEFT="265" WIDTH="108"audio file nameLEFT="380" WIDTH="144"SGI audio file library libaudiofileLEFT="0" WIDTH="144"_SGI_AUDIOLEFT="150" WIDTH="108"sound dataLEFT="265" WIDTH="108"stream of audio dataLEFT="380" WIDTH="144"SGI audio file library libaudiofileLEFT="0" WIDTH="144"_SGI_MOVIE_FILENAMELEFT="150" WIDTH="108"movie dataLEFT="265" WIDTH="108"movie file nameLEFT="380" WIDTH="144"SGI Movie library libmovieLEFT="0" WIDTH="144"_SGI_MOVIELEFT="150" WIDTH="108"movie dataLEFT="265" WIDTH="108"stream of movie dataLEFT="380" WIDTH="144"SGI Movie library libmovieLEFT="0" WIDTH="144"STRINGLEFT="150" WIDTH="108"text encoded as ISO Latin 1LEFT="265" WIDTH="108"textual dataLEFT="380" WIDTH="144"Ability to read text encoded as ISO 
Latin 1LEFT="0" WIDTH="144"COMPOUND_TEXTLEFT="150" WIDTH="108"compound textLEFT="265" WIDTH="108"textual data formatted as 
compound textLEFT="380" WIDTH="144"Ability to read compound textLBL="" HELPID=""Data Exchange GuidelinesIf your application contains data that users may wish to transfer to other applications or across separate instantiations of your application . . .Support the Clipboard Transfer Model using the "Cut," "Copy," and "Paste" entries in the Edit menu. In this model, the clipboard is a global entity that's shared by all applications. Your application shouldn't use these entries to refer to a clipboard that's private to your application.When supporting the Clipboard Transfer Model, don't select or highlight newly pasted data after a "Paste" operation.Support the Primary Transfer Model. Assert ownership of the primary selection when the user begins to make a selection. Insert data at the location of the pointer when the user clicks the middle mouse button (which isn't necessarily at the insertion cursor).When supporting the Primary Transfer Model, don't select or highlight newly transferred data after a transfer operation.Use persistent always selection highlighting (keep the current selection highlighted even when your application loses the primary selection), unless the only action that can be performed on the selection is to copy the data using primary data transfer. In this case, use nonpersistent selection highlightingname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'that is, remove the selection highlight when the selection is no longer the primary selection.When supporting the Primary Transfer Model, if the current active window has a selection that isn't the primary selection, reinstate this selection as the primary selection if the user presses <Alt-Insert>. Additionally, you can include a "Promote" entry in the Edit menu to perform the same function.When supporting the Primary Transfer Model, when the user begins to modify a selection, such as adding elements to it, reassert ownership of the primary selection if your application does not currently own it.When supporting both Clipboard Transfer and Primary Transfer, keep the primary selection independent from the clipboard. When the user begins to make a selection in your application, assert ownership of the primary selection but do not change the ownership of the clipboard. When the user chooses "Cut" or "Copy" from an Edit menu in your application, assert ownership of the clipboard but do not change the ownership of the primary selection.LBL="II"Interface ComponentsLBL="6"ID="71076"Application WindowsThis chapter discusses the role of different types of windows in the Indigo Magic environment. It includes information on how your application should combine the different types of windows, as well as guidelines on what elements are appropriate for primary and support windows, and how these elements should be arranged. (Dialog windows are discussed in detail in IDREF="30192" TYPE="TITLE"Chapter 10, "Dialogs.")This chapter covers the following topics:IDREF="67644" TYPE="TITLE""Application Models" discusses different models for applications. Which model is appropriate for your application depends upon whether your application needs multiple primary windows, and whether it can have multiple documents open at the same time.IDREF="67665" TYPE="TITLE""Main and Co-Primary Windows" discusses the design of primary windows.IDREF="30905" TYPE="TITLE""Support Windows" discusses the design of support windows.IDREF="69885" TYPE="TITLE""Pointer Behavior in a Window" discusses the limits of what your application should do with the mouse pointer.Note that by default, 4Dwm, the window manager for the Indigo Magic Desktop, provides window decorations and a Window menu for all application windows. The specific window decorations and contents of the Window menu depend on the type of window and whether any of the components in the window are resizable. For guidelines on window decorations, Window menu entries, and related issues, see IDREF="38970" TYPE="TITLE""Application Window Categories and Characteristics" in Chapter 3. LBL="" HELPID=""ID="67644"Application ModelsThis section describes how the different types of windows used in the Indigo Magic environment can be used together in applications.LBL="" HELPID=""ID="91745"Window TypesAs discussed in IDREF="82170" TYPE="TITLE""Application Window Categories" in Chapter 3, windows in the Indigo Magic environment are divided into four types, which are subdivisions of Motif's two types: primary and secondary. Primary windows are divided into main primary windows and co-primary windows, and secondary windows are divided into support windows and dialogs. The definitions are repeated here for your convenience:A main primary window serves as the application's main controlling window. It's used to view or manipulate data, get access to other windows within the application, and kill the process when users quit. There's only one main primary window per application (and sometimes it isn't visible to users). A co-primary window is used for major data manipulation or viewing of data outside of the main window A support window is a persistent special-purpose window. It typically contains a control panel or tool palette that operates directly on data in a primary window. A support window can be used repeatedly. A dialog is a transient window, typically used for short, quick user input, such as an action confirmation, or system output, as in a warning message. A dialog may be user-requested or application-generated. It is usually dismissed as soon as it has served its purpose. Dialogs are discussed in detail in IDREF="30192" TYPE="TITLE"Chapter 10, "Dialogs."The next section (IDREF="27980" TYPE="TITLE""Standard Application Models") describes several standard models for combining these types of windows in a real application. Whichever model you choose, try to keep the window hierarchy shallow so that users can form a relatively simple conceptual model of how your application's windows are related. IDREF="71136" TYPE="GRAPHIC"Figure 6-1 shows the allowable parent and child relationships within an application's window hierarchy. For example, all co-primary windows should be children of the main window, so primary windows should never be more than two levels deep; dialogs can be children of any type of window.FILE="ch06.windows.ras" POSITION="INLINE" SCALE="FALSE"LBL="6-1"Figure 6-1 ID="71136"Allowable Parent-Child Window RelationshipsLBL="" HELPID=""ID="27980"Standard Application ModelsApplications can combine the basic window types in many ways, but most applications fall into one of four basic models. These models differ with respect to whether they can have one or multiple documents (files) open at a time and their use of primary windows. (For information about how to implement the various models, see IDREF="14513" BOOK="IndigoMagic_IG" FILE="05.Window.Management.doc" HDG="""Implementing an Application Model" in Chapter 5 in the Indigo Magic Desktop Integration Guide.)NoteThe term document means a grouping of data and shouldn't be thought of as referring exclusively to text-oriented files. A document can include such data types as film clips, audio segments, and 3D scenes. LBL="" HELPID="""Single Document, One Primary" Application Model"Single Document, One Primary" (see IDREF="93978" TYPE="GRAPHIC"Figure 6-2) is the most basic model. It accomplishes all of its tasks within the main window and uses as many support windows and dialogs as needed. Users can work on only one document at a time. Thus, when a user has one document open and opens a second document, the second document replaces the first. IRIS Showcase operates in this manner. FILE="ch06.windows.ras2" POSITION="INLINE" SCALE="FALSE"LBL="6-2"Figure 6-2 ID="93978""Single Document, One Primary" Application ModelLBL="" HELPID="""Single Document, Multiple Primaries" Application ModelThe "Single Document, Multiple Primaries" model (see IDREF="20959" TYPE="GRAPHIC"Figure 6-3) uses both main and co-primary windows to accomplish major tasks. In this model, each co-primary window performs a different function; these functions supplement the functionality of the main window. MediaMail is an example of this model. Its main window lets users select electronic mail messages from a folder and perform actions on them such as viewing, printing, deleting, and sorting. Its Compose and Message windows are typical of co-primary windows with different functions designed to support the functionality of the main window. Also in this model, each primary window has its own menu bar tailored specifically to the functions in that window. Each co-primary window is opened from the main window. Each support and dialog window is associated with a specific primary window.FILE="ch06.windows.cgm3" POSITION="INLINE" SCALE="FALSE"LBL="6-3"Figure 6-3 ID="20959""Single Document, Multiple Primaries" Application ModelThe single-document application with multiple primary windows is useful for dealing with data that the user needs to view in a number of different ways at the same time. For example, the WorkShop debugger operates on a single executable at a time. However, at a given time WorkShop might have several primary windows displaying source code, with other primary windows displaying call graphs and output from running the executable. In the case of WorkShop, the nature of the application demands multiple-primary windows.LBL="" HELPID="""Multiple Document, Visible Main" Application ModelThe "Multiple Document, Visible Main" model (see IDREF="91934" TYPE="GRAPHIC"Figure 6-4) has a main window that's used primarily to launch co-primary windows. These co-primary windows are identical to each other and perform the same functions on different files or documents. All co-primary windows have identical entries in the menu bar and identical sets of dialogs and support windows. Each set of dialogs and support windows acts on a single document, the one represented by the co-primary window from which the dialog or support window was invoked. Co-primary windows are opened either from the main window or from a co-primary window that's already open. IRIS InSight is an example of this model. Its main window lets users launch co-primary viewing windows, browse available files, and conduct global searches through these files. The co-primary windows are used for viewing online books.A multi-document application should have a visible main window only if the main window offers functionality that can't be provided from the co-primary windows. For example, the IRIS InSight main window allows users to browse a list of books and to search a collection of books for specific words or phrases. A multi-document application should not have a visible main window if the only thing in the main window would be a menu bar. In this case, the "multiple documents, no visible main" model should be used, and the menu entries from the main window should instead be made available from the pull-down menus in each of the co-primary windows, as described in the next section.FILE="ch06.windows.cgm4" POSITION="INLINE" SCALE="FALSE"LBL="6-4"Figure 6-4 ID="91934""Multiple Document, Visible Main" Application ModelLBL="" HELPID=""ID="96208""Multiple Document, No Visible Main" Application ModelThe "Multiple Document, No Visible Main" model (see IDREF="37659" TYPE="GRAPHIC"Figure 6-5) is identical to the "Multiple Document, Visible Main" model described in the previous section except that the main window is invisible to the user (that is, unmapped) and new co-primary windows are launched from co-primary windows that are already open. Users open one document and leave it open while opening others. When the user has closed all of the documents, the process is killed.FILE="ch06.windows.cgm5" POSITION="INLINE" SCALE="FALSE"LBL="6-5"Figure 6-5 ID="37659""Multiple Document, No Visible Main" Application ModelLBL="" HELPID=""Application Model GuidelinesFor all applications . . .Choose an appropriate application model for combining the different types of windows in your application.Use only the allowable parent-child window relationships and keep your application window hierarchy shallow.LBL="" HELPID=""ID="67665"Main and Co-Primary WindowsEvery application has at least one primary window, which serves as the application's main controlling window. In fact, the majority of a user's interactions should occur in the main and co-primary windows (these window types are defined in IDREF="91745" TYPE="TITLE""Window Types" earlier in this chapter). Several typical layouts for primary windows are shown in Figures IDREF="82225" TYPE="TEXT"6-6 through IDREF="95489" TYPE="TEXT"6-8. These layouts are discussed in the following sections.FILE="ch06.windows.ras6" POSITION="INLINE" SCALE="FALSE"LBL="6-6"Figure 6-6 ID="82225"Basic Primary WindowFILE="ch06.windows.ras7" POSITION="INLINE" SCALE="FALSE"LBL="6-7"Figure 6-7 ID="17433"Primary Windows With Tool PalettesFILE="primarytwopanes.bw" POSITION="INLINE" SCALE="FALSE"LBL="6-8"Figure 6-8 ID="95489"Primary Window With Two PanesLBL="" HELPID=""ID="93559"Menu Bars in Primary WindowsPrimary windows typically have a menu bar, which is part of the window as shown in Figures IDREF="82225" TYPE="TEXT"6-6 through IDREF="95489" TYPE="TEXT"6-8. It shouldn't be a detached menu bar contained in a separate window. For details on designing the menu bar and its contents for a primary window, see IDREF="42408" TYPE="TITLE""The Menu Bar and Pull-Down Menus" in Chapter 8.If the primary window doesn't have a menu bar and all of its functionality is available using buttons, the window should still respond to the keyboard accelerators for Close (Ctrl+W) and Exit (Ctrl+Q) when appropriate. That is, the window should respond to these accelerators according to the guidelines for when to use just Exit, when to use just Close, and when to use both Close and Exit for a window, as described in the section IDREF="38726" TYPE="TITLE""File Menu" in Chapter 8.LBL="" HELPID=""Scrollable Work Areas in Primary WindowsThe most prominent area of the window is typically a scrollable work area, as shown in Figures IDREF="82225" TYPE="TEXT"6-6 through IDREF="95489" TYPE="TEXT"6-8. Use scrollbars for the work area of a window when the window can be resized such that some of the available data may be hidden in the work area. Note that the scrollbars scroll only the work area and don't scroll the menu bar, buttons in a command area, or the status message area.Each scrollbar should span the entire width or height of the scrollable region. Don't put controls or status information in the areas reserved for the scroll bars. Controls should be put in the control area, as described later in IDREF="93963" TYPE="TITLE""Control Areas in Primary Windows." Status information should be put in the status area, as described later in IDREF="30855" TYPE="TITLE""Status Areas in Primary Windows."Use a vertical scrollbar on the right of the work area if the window or pane that contains the work area can be resized such that the data being displayed in the work area won't fit in a vertical direction. Similarly, use a horizontal scrollbar directly below the work area if the window or pane can be resized such that the data being displayed in the work area won't fit in a horizontal direction. Disable (rather than remove) the appropriate scrollbar when all of the data is being displayed in a given direction. For more information on using scrollbars, see IDREF="33826" TYPE="TITLE""Scrollbars" in Chapter 9.LBL="" HELPID=""ID="93963"Control Areas in Primary WindowsControls in primary windows, which are typically pushbuttons, are generally placed directly beneath the horizontal scrollbar and on the left side of the window (see Figures IDREF="82225" TYPE="TEXT"6-6 through IDREF="95489" TYPE="TEXT"6-8). (Note that this is different than the OSF/MotifStyle Guide, which states that controls can be arranged along the top, bottom, or side of the work area.) As stated in the previous section, controls shouldn't be placed directly below or on the right side of the work area in the scroll bar areaname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'scrollbars should span the entire width and height of the work area. (See IDREF="95140" TYPE="TITLE"Chapter 9, "Controls," for more information about how to use controls in your application.)Control areas sometimes contain pushbuttons that are grouped into tool palettes. Figures IDREF="82225" TYPE="TEXT"6-6 through IDREF="95489" TYPE="TEXT"6-8 show primary windows with pushbuttons in the control areas, and IDREF="17433" TYPE="GRAPHIC"Figure 6-7 shows primary windows with both tool palettes and pushbuttons that aren't part of a palette. Buttons that are part of a tool palette don't need to have corresponding menu entries. These "tools" typically allow a user to launch support and co-primary windows, or put the work area in a different mode (for example, edit mode or draw mode).In contrast, pushbuttons used in control areas that do not represent tool palettes should represent the most frequently accessed application-specific menu entries which provide users a more convenient way of accessing these actions. There are two advantages to having these buttons repeat functionality from the menus:Having the functions in a menu allows you to assign keyboard accelerators to those common functions and allows users to choose between using point-and-click on the button or using a keyboard accelerator to access the functionality.Having the functions in a menu means that users can skim one place (the menu entries) to get an idea of the overall functionality of the product, and can skim another place (the control area) to see the frequently used functionality.These non-palette buttons generally don't include actions from the standard File, Edit, or Help menus because these entries typically aren't the most frequently accessed when compared to the functionality that's specific to your application. For example, these buttons don't include the actions "Exit" or "Close" because these functions are used only once each time the window is opened, and they don't include "Help" because help is easily accessible from the Help menu. (For more information on buttons, see IDREF="18668" TYPE="TITLE""Pushbuttons" in Chapter 9; also see IDREF="12088" TYPE="TITLE""Standard Menus" in Chapter 8.)The control area can also include an area to enter command line input. This command line area should be in addition to the buttons. Note that this differs from the OSF/MotifStyle Guide, which states that the command area can contain only command line input. For an example window with an command line input area, see Section 6.2.1 in the OSF/Motif Style Guide.LBL="" HELPID=""ID="30855"Status Areas in Primary WindowsPrimary windows can also include a single status message area at the bottom of the window if the application needs to post frequent messages to the user about the status of the application or the status of specific user actions  (see Figures IDREF="82225" TYPE="TEXT"6-6 through IDREF="95489" TYPE="TEXT"6-8). For example, messages in this area might confirm that a file has been saved or that an option has been turned on or off. You should provide vertical scrollbars for this area so that users can view previously displayed messages.This area shouldn't be used for warnings, errors, or other kinds of messages requiring the user to respond. Instead, dialogs should be used to display these types of messages. (See IDREF="30192" TYPE="TITLE"Chapter 10, "Dialogs," for guidelines on designing dialogs.) It also shouldn't be used to display help information.LBL="" HELPID=""ID="69664"Splitting Primary Windows Into PanesWindows can be split into various panes of information (see IDREF="95489" TYPE="GRAPHIC"Figure 6-8). Panes are separated from each other by separator lines. Each separator line may or may not include a sash control, which allows users to resize the panes. (See the Sash reference page in Chapter 9 of the OSF/Motif Style Guide.) Windows can include panes that are stacked vertically (IDREF="95489" TYPE="GRAPHIC"Figure 6-8) or that are next to each other in a side-by-side horizontal layout (IDREF="92383" TYPE="GRAPHIC"Figure 6-9). Note that control areas can be associated either with a specific pane or with the entire window. Don't overuse panesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'each application window typically should have no more than four separate panes and no more than three sash controls. If certain panes are optional to performing the task, provide menu entries that show or hide specific panes of information (see IDREF="26586" TYPE="TITLE""View Menu" in Chapter 8). LBL="" HELPID=""Popup Menus in Primary WindowsPopup menus (which aren't shown in the figures in this chapter) can provide quick access to frequently used functions in primary windows. For information on when and how to use popup menus, see IDREF="62260" TYPE="TITLE""Popup Menus" in Chapter 8.LBL="" HELPID=""Primary Window GuidelinesWhen designing a primary window . . .Use a menu bar unless all of the window's functionality is available through pushbuttons. Don't use a "floating" menu bar in a separate window.Support keyboard accelerators for Close (Ctrl-W) and Exit (Ctrl-Q) as appropriate, even if the window doesn't have a menu bar.When designing a scrollable work area in a primary window . . .Use a vertical scrollbar on the right side of the work area when the data being displayed in the work area may not fit in a vertical direction. Use a horizontal scrollbar directly below the work area when the data may not fit in a horizontal direction. Don't use scrollbars if you're certain the data will fit.Disable the appropriate scrollbar when all the data is visible in a given direction. Don't remove the scrollbar.Make each scrollbar span the entire height or width of the work area. Don't include controls or status information in the scrollbar region.When designing control areas in a primary window . . .Place controls below horizontal scrollbars or to the left of work areas.Provide pushbuttons for the most frequently accessed application-specific functions from the pull-down menus. Don't use pushbuttons for standard menu entries such as Open, Save, Close, Exit, Cut, Copy, Paste, and Help.Use pushbuttons only for functions that appear in menus, unless the pushbuttons are part of a tool palette.Provide an area for command-line input, if appropriate, in addition to (not in place of) pushbuttons.To display status information . . .Use a status area along the bottom of a primary window if your application needs to post frequent messages about its status. Provide vertical scrollbars for this area so that users can view previously displayed messages.Use a status area to display messages that the user doesn't have to respond to rather than posting this noncritical information in dialogs. However, don't put critical warning or error messages in the status area (use a dialog instead).Don't use the status area to display help information.When dividing a primary window into panes . . .Divide panes using separator lines. If users might need to resize the pane, also include a sash control.Try to limit the number of panes in a single window to four with no more than three sash controls.If certain panes are optional, allow users to hide or show these individual panes using entries in the "View" menu.LBL="" HELPID=""ID="30905"Support WindowsAs defined in IDREF="91745" TYPE="TITLE""Window Types" earlier in this chapter, support windows are persistent secondary windows that allow users convenient, constant access to sets of important controls that directly manipulate data in the associated primary window. The next two sections discuss the general design of support windows and a specific standard support window, the Indigo Magic color chooser.LBL="" HELPID=""General Support Window DesignEach support window should be associated with a specific primary window (its parent), which should be visible and mapped to the screen. (Support windows with invisible, unmapped parents don't work properly with desks, as described in IDREF="55393" TYPE="TITLE""Desks" in Chapter 3.) Support windows shouldn't have other support windows or dialogs as parent windows. Note that this differs from the OSF/MotifStyle Guide, which states that secondary windows can have other secondary windows as parents. Support windows typically don't have menu bars like primary windows, but they should still respond to the keyboard accelerator for closing a window ("Ctrl+W"). Support windows should be launched from items in the Tools menu of the associated primary window's menu bar (see IDREF="70020" TYPE="TITLE""Tools menu" in Chapter 8) or from a tool palette in the primary window (see IDREF="93963" TYPE="TITLE""Control Areas in Primary Windows"). Users can show or hide support windows as they wish, and rearrange where they're displayed with respect to the primary window. This makes support windows more versatile than control areas in a primary window. When bringing up support windows, don't overlap the work area of the associated primary window if you can avoid it. Note that 4Dwm constrains support windows to always appear on top of the parent window in the window hierarchy. A support window should be smaller and less complex than its associated primary window, so that you don't need to split the support window's contents into separate panes. Support windows typically include a related set of controls that are associated with the parent primary window.  Each related set of functions or input fields should be given its own support window. The controls (which can include buttons, text fields, and scrolling lists) typically either operate directly on selected data or change the mode of the primary window. For example, they might allow the user to choose a texture that will be applied to the selected objects in the primary window, or they might allow the user to choose a specific drawing tool that changes what's drawn in the parent window. For example, the IRIS Showcase Align Gizmo shown in IDREF="27066" TYPE="GRAPHIC"Figure 6-9 aligns the objects that are currently selected in IRIS Showcase's main window. You shouldn't add or remove controls from a support window depending on the current contextname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the layout and contents of a support window should be static.FILE="06.supportwindow.bw" POSITION="INLINE" SCALE="FALSE"LBL="6-9"Figure 6-9 ID="27066"The IRIS Showcase Align GizmoSupport windows also typically contain a response area that includes standard actions for the window: "Apply," "Cancel/Close," and "Help." See IDREF="32754" TYPE="TITLE""Standard Dialog Actions" in Chapter 10 for more information about these actions. In addition, support windows may contain secondary work areas for manipulating data that will eventually be integrated into the work area of the associated primary window. Texture, pattern, icon, and geometry editors are examples of support windows that might contain secondary work areas. The Align Gizmo in IDREF="27066" TYPE="GRAPHIC"Figure 6-9 contains a small display area showing a circle, a square, and a triangle, which shows the effects of the user's changes before they're applied to the main window. Support windows should be modelessname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'that is, they shouldn't prevent the user from interacting with any of the application's other windows. If your application requires a secondary window that the user must dismiss before interacting with the rest of the application, you should use a modal dialog (see IDREF="54825" TYPE="TITLE""Dialog Modes" in Chapter 10).LBL="" HELPID=""ID="84245"A Specific Standard Support Window: The Indigo Magic Color ChooserThe Indigo Magic color chooser is a standard support window that allows users to edit colors. You should use the color chooser in your application whenever you want to offer the user an unrestricted choice of colors. For a restricted choice of colors, you can offer the user a palette of colors to choose from, a list, an option button, or a set of radio buttons, depending on the number of choices available. IDREF="84728" TYPE="GRAPHIC"Figure 6-10 shows the color chooser in its default configuration. FILE="ch06.windows.ras10" POSITION="INLINE" SCALE="FALSE"LBL="6-10"Figure 6-10 ID="84728"The Indigo Magic Color ChooserYou can allow users to access the Indigo Magic color chooser from your application in one of two ways: by having them click on a button that displays its (editable) color, or having them click on an object for which the color should be changed. The first method is used by the Background control panel (which is available from the Desktop->Customize menu in the Toolchest). With this panel, the user clicks on one of the color buttons to open the color chooser. If the color chooser is already open, clicking on a color button selects that color for the color chooser to edit. The colors of the buttons represent the current colors being used by the desktop background. With the second method, the user selects an object and then chooses the "Color Editor" entry from the Edit menu, as described in the section IDREF="94339" TYPE="TITLE""Edit Menu" in Chapter 8. This menu entry opens the color chooser. For details on how to include the Indigo Magic color chooser in your application, see IDREF="69317" BOOK="IndigoMagic_IG" FILE="04.Widgets.doc" HDG="""The New Widgets" in Chapter 4 of the Indigo Magic Desktop Integration Guide.As noted in IDREF="84728" TYPE="GRAPHIC"Figure 6-10, the color chooser includes the following components:Two color swatches: one for showing the current selected color and one for enabling the user to store a second color for reference.A color hexagon that provides visual selection of the hue and saturation components of a color in an HSV color space. The user changes the hue and saturation by moving the selector (which appears as a small circle) in the color hexagon.Color sliders for controlling various color components. Text fields that show the exact values for hue, saturation, and value color components and allow users to set these values numerically. (There are also text fields indicating the values of the red, green and blue color components when the red, green, and blue sliders are visible.)Menus for Options (which allows users to easily find the color white) and Sliders (which provides various combinations of sliders for setting hue, saturation, value, red, green, blue input values).Pushbuttons that allow users to apply the current values, cancel a pending change, or get help on this window. NoteBecause of drawing-speed considerations, the color hexagon and color sliders are available only if running under GL. For X-only configurations, the Color Chooser uses a Scale widget instead of the color sliders, and there is no color hexagon. The user can apply the new color to the selected object by pressing either the OK or Apply buttons. If the user presses OK, the color chooser should be dismissed after the new color is applied. If the user selects a new object in the parent primary window while the color chooser is open, the color chooser should update its current color to the color of the selected object. Thus, a single color chooser window can be used to change the color of a number of different objects. LBL="" HELPID=""Support Window GuidelinesWhen designing support windows . . .Use them to provide access to sets of related controls.Allow users to access them either through entries in the Tools menu or through pushbuttons in a tool palette in the parent primary window.Be sure that each support window has a visible parent primary window that's mapped to the screen.When designing the layout of a support window . . .Make the layout simple and static. Don't include multiple panes of information.Include a response area for standard actions that's similar to the one dialogs have.Don't include a menu bar in most cases, but do support the keyboard accelerator for Close (Ctrl-W).When opening support windows . . .Avoid overlapping the work area of the parent window.Bring them up as modeless secondary windows. When allowing the user to make color choices . . .Use the Indigo Magic color chooser whenever you want to offer the user an unrestricted choice of colors. For a restricted choice of colors, use a palette of colors to choose from, a list, an option button, or a set of radio buttons, depending on the number of choices available. LBL="" HELPID=""ID="41181"ID="69885"Pointer Behavior in a WindowThe user should retain control over the location of the pointer at all times. Your application shouldn't change the location of the pointer. (This is sometimes referred to as "warping" the pointer.) Similarly, your application shouldn't change the gain and acceleration characteristics of mouse movement. Users set these on a global basis using the Mouse Settings control panel available from the Desktop->Customize cascading menu in the Toolchest. If your application requires finer motion control than what's provided by the default gain settings, provide a zoom feature in the View menu that allows users to change the relative size of an area of your application. (See IDREF="26586" TYPE="TITLE""View Menu" in Chapter 8 for more information about this menu.) Although users control the location of the pointer, your application needs to control the shape of the pointer. This shape gives the user feedback about the current state of the application (for example, whether it's waiting for user input or whether it's busy processing). Pointer shapes are discussed in IDREF="15568" TYPE="TITLE""Pointer Shapes and Colors" in Chapter 11.LBL="" HELPID=""Pointer Behavior GuidelinesWhen designing your application . . .Always allow the user to control the location of the pointer; your application shouldn't change the position of the pointer.Don't change the gain or acceleration characteristics of the pointer. If your application requires fine manipulation, provide a zoom feature in the View menu.LBL="7"ID="63208"Focus, Selection, and Drag and DropUsers can interact with your application through three general mechanisms, which are discussed in the following sections:IDREF="50040" TYPE="TITLE""Keyboard Focus and Navigation" discusses how your application should allow users to direct keyboard input to specific components. It also discusses how certain components should be controlled from the keyboard. IDREF="59818" TYPE="TITLE""Selection" discusses various models for allowing users to select data in your application.IDREF="83927" TYPE="TITLE""Drag and Drop" discusses how users expect to directly manipulate text and other objects in your application by dragging them with the mouse.LBL="" HELPID=""ID="50040"Keyboard Focus and NavigationKeyboard input allows users to enter data into text fields and to control other components in your application. The keyboard focus policy determines which component in which window receives the keyboard input. Only one component in one window receives input from the keyboard at any given time; this component has the keyboard focus (also called input focus). For example, if a button has the keyboard focus and the user presses the Space bar on the keyboard, the button is activated. The process of moving the keyboard focus is called navigation. Keyboard navigation allows the user to navigate among components in a window using only the keyboard rather than having to manipulate the mouse (or other pointing device). As described in IDREF="59672" TYPE="TITLE""Keyboard Focus Across Windows" in Chapter 3, the Indigo Magic environment uses one policy for moving the keyboard focus among components within a window and a different policy for moving the keyboard focus between windows. When moving the keyboard focus among components within a window, your application should use an explicit focus policy. In other words, the user clicks a mouse button or presses a key to move the keyboard focus to a new component in the active window. In contrast, 4Dwm, the window manager for the Indigo Magic Desktop, uses implicit focus across windows: the window directly underneath the pointer receives keyboard input (that is, it's the active window). Note that users can't navigate among windows using the keyboard when using 4Dwm in its default configuration.This section discusses keyboard focus and navigation among components in the active window.LBL="" HELPID=""ID="86870"Keyboard Focus Policy and Navigation Within a WindowOnly one component in the active window has the keyboard focus at any given time. Your application should use explicit focus (as opposed to implicit focus) within a window; in other words, the user must explicitly select the component that receives the keyboard input. Your application should support the models described in this section for navigating to specific components in a window and for using the keyboard to activate these components.Within the active window, the component with the keyboard focus is visually identified by the location cursor. The location cursor isn't necessarily a cursor in the traditional sense of a text cursor. It gives the user visual feedback as to which component receives the keyboard input. Each standard component described in IDREF="95140" TYPE="TITLE"Chapter 9, "Controls," has its own method for displaying a location cursor when the component has keyboard focus. For example, the location cursor used to indicate that a specific radio button has the keyboard focus is a simple box, as shown in IDREF="15861" TYPE="GRAPHIC"Figure 7-1. FILE="ch07.focus.ras" POSITION="INLINE" SCALE="FALSE"LBL="7-1"Figure 7-1 ID="15861"Location Cursor ExampleKeyboard activation and keyboard navigation are strongly linked: if a user can activate or control a component from the keyboard, the user should also be able to navigate to that component from within the window using the keyboard. This enables the user to perform the task without having to frequently switch between using the mouse and keyboard.Section 2.2 in the OSF/Motif Style Guide states that "all application functionality must be available from the keyboard alone." This includes navigating among windows, navigating among components in a window, and activating components. By default, users will be able to navigate to and control all components in a window except for those that aren't traversable or don't accept input (for example, labels and separators). Since all Silicon Graphics systems come with a mouse, it isn't as critical to provide access to all functionality from the keyboard alone when programming for Silicon Graphics systems. Just keep in mind that some users use alternate input devices that rely on having functions available from the keyboard. At a minimum, your application should let users do the following from the keyboard:navigate between editable text fields in a windowenter data into editable text fieldsselect data in a text field (see IDREF="59818" TYPE="TITLE""Selection" later in this chapter and IDREF="36229" TYPE="TITLE""Text Fields" in Chapter 9)navigate to a list component (see IDREF="72866" TYPE="TITLE""Lists" in Chapter 9)select data in a list (see IDREF="59818" TYPE="TITLE""Selection" later in this chapter and IDREF="72866" TYPE="TITLE""Lists" in Chapter 9)navigate among all types of menus (pull-down, popup, and option menus) and their entries (see IDREF="19797" TYPE="TITLE""Menu Traversal and Activation" in Chapter 8)activate menu entries (see IDREF="19797" TYPE="TITLE""Menu Traversal and Activation" in Chapter 8)scroll any scrollable component (see IDREF="33826" TYPE="TITLE""Scrollbars" in Chapter 9)activate the default button in a dialog if there is one (see IDREF="32754" TYPE="TITLE""Standard Dialog Actions" in Chapter 10)use mnemonics for all menu titles and menu entries in the pull-down menus (see IDREF="62421" TYPE="TITLE""Choosing Mnemonics" in Chapter 8)use keyboard accelerators for frequently used entries in the pull-down menus, such as "Cut," "Copy," and "Paste" in the Edit menu (see IDREF="75819" TYPE="TITLE""Choosing Keyboard Accelerators" in Chapter 8)LBL="" HELPID=""ID="74637"Keyboard NavigationThis section discusses guidelines for moving the focus to a different component in the window using the keyboard. (The OSF/Motif Style Guide refers to this as component navigation.) Each window is divided into fields, where a field can be an individual control (for example, a text input field) or a group of controls (such as a group of radio buttons). By default, the fields that can accept the keyboard focus are ordered, in general, from upper left to lower right. If a window has multiple panes, the focus moves by default through the fields in the topmost (or leftmost) pane, then the fields in the next pane, and so on, until it wraps back to the beginning. In some cases, you may have to modify the default order in which components are navigated from the keyboard. For example, when a window first becomes active, the component that should have the keyboard focus is the one that the user is most likely to want to interact with using the keyboard. This isn't necessarily the component in the upper left-hand corner. Also, when a user returns the keyboard focus to a window that was previously the active window, the keyboard focus should return to where it was when the user moved the focus out of that window.By default, users can cycle through the fields in order using the <Tab> key; in addition, they can use the arrow keys to move the keyboard focus among the individual components in the current field. For example, in the Add Printer window, shown in IDREF="44860" TYPE="GRAPHIC"Figure 7-2, a user could use <Tab> to move keyboard focus from the first field ("New Printer Name") to the second field ("Connection Type"). Once in the second field, the user can move keyboard focus between the radio buttons using the directional arrow keys. .FILE="ch07.focus.ras2" POSITION="INLINE" SCALE="FALSE"LBL="7-2"Figure 7-2 ID="44860"Components and FieldsBy default, the following keyboard commands are used for navigating within a window. In addition, as discussed in IDREF="19797" TYPE="TITLE""Menu Traversal and Activation" in Chapter 8, <Shift>-<F10> should move the location cursor to a popup menu if one is available for the current context. <Tab>Moves the location cursor to the next field that can accept the keyboard focus, unless the current field is a multi-line editable text field. In this case it simply inserts a tab character.<Ctrl>-<Tab>Always moves the location cursor to the next field that can accept the keyboard focus.<Shift>-<Tab>Moves the location cursor to the previous field that can accept the keyboard focus.<Ctrl>-<Shift>-<Tab>Always moves the location cursor to the previous field that can accept the keyboard focus.<down arrow>Moves the location cursor within a field forward (or down) to the next component that can receive the keyboard focus, eventually wrapping back to the first component. If the components are in a matrix, <down arrow> moves down through a column and then proceeds to the top of the next column to the right. <up arrow>Moves the location cursor within a field opposite to the direction of the <down arrow> to the next component that can receive the keyboard focus. Eventually it wraps back to the last component.<right arrow>Moves the location cursor within a field to the next component to the right that can receive the keyboard focus, eventually wrapping back to the first component. If the components are in a matrix, <right arrow> moves across an entire row and then proceeds to the row below. <left arrow>Moves the location cursor within a field opposite to the direction of the <right arrow> to the next component that can receive the keyboard focus. Eventually it wraps back to the last component.<F10>Moves the location cursor to the leftmost menu in the menu bar if there is one. If a menu is already displayed, <F10> closes the menu and returns the location cursor to where it was previously. (See IDREF="19797" TYPE="TITLE""Menu Traversal and Activation" in Chapter 8.)Because the keys listed above are used for navigating among components, don't use them for other purposes. However, there's an exception to this rule: the arrow keys can be used to control a component that's the only component in its field. For this reason, each editable text field, list, scrollbar or sash is by default placed in its own field. LBL="" HELPID=""Mouse NavigationTo move the keyboard focus in the current active window using the mouse, users position the pointer over a specific component and click the left mouse button. This moves the keyboard focus to the selected component, if you've allowed that component to accept keyboard focus. This also typically performs some action or selects some data. For example, clicking the left mouse button on a pushbutton activates the pushbutton, as well as moves keyboard focus to the pushbutton. Clicking the left mouse button in an editable text field moves keyboard focus to the text field and places the insertion point in the text field at the pointer location. If users want to move the keyboard focus to a component using the mouse without activating that component, they can position the pointer over the component, then hold down the <Ctrl> key while clicking the left mouse button.By default, there are certain components that don't grab the keyboard focus when activated using the mouse. These include scrollbars, sashes, any other component that's used only to change the size or location of other elements, and any components that you've designated as being unable to accept keyboard focus. If the user uses the mouse to activate any of these components, it's activated and the keyboard focus stays where it was. LBL="" HELPID=""Keyboard Focus and Navigation GuidelinesWhen designing keyboard focus and navigation for your application windows . . . Use explicit focus for navigating among components within a window.Support at least the minimum required functionality from the keyboard, such as navigating to and entering data into editable text fields, using mnemonics and keyboard accelerators to access menu entries, and scrolling any scrollable component. Keep in mind that some users use alternate input devices that rely on having functions available from the keyboard.When the window becomes active for the first time, give focus to the component that the user is most likely to want to interact with using the keyboard. When a user returns the keyboard focus to a window that was previously the active window, return the keyboard focus to where it was when the user moved the focus out of that window.Put each component that requires the use of arrow keys to control it in its own field. The following components are by default put in fields of their own: editable text fields, lists, scrollbars, and sashes.Don't use the default keyboard navigation keys for other purposes. These keys are <Tab>, <Ctrl>-<Tab>, <Shift>-<Tab>, <Ctrl>-<Shift>-<Tab>, the arrow keys, <F10>, <Shift>-<F10>, and <Ctrl> in combination with a left mouse button click.LBL="" HELPID=""ID="59818"SelectionIRIS IM is based on the object-action model of direct manipulation. This means that a user must first select an object or group of objects, then choose an action to perform on that data. Users typically select data by clicking the left mouse button (to select a single object) or by dragging with the left mouse button (to select a range of objects). The selection is completed when the mouse button is released. Making a selection shouldn't automatically perform any operation on that selection. When users select data in an application window, that data should be highlighted in some way so that when they pick an action, they'll know which chunk of data that action is being applied to. At any time, there's one selection that's the primary selection. This is the last selection explicitly started by the user and is used to copy data between applications. For details on supporting the primary transfer model in your application, see IDREF="61999" TYPE="TITLE""Supporting the Primary Transfer Model" in Chapter 5.LBL="" HELPID=""Selection Modelsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'What Can Be Selected and How To Select ItThe data in an application window is divided into collections. A collection is a group of related elements that share a selection model. There are four basic selection models described in the OSF/Motif Style Guide:In the single selection model, only one element in the collection can be selected at any given time. For example, a color palette usually allows you to pick only one color at a time. The browse selection model is essentially the same as the single selection model, except that it allows users to browse through the available elements by dragging with the left mouse button. The list of available schemes in the Schemes control panel is an example of this model.In the range selection model, more than one element in the collection can be selected at any given time, but these elements must be next to each other. Text is usually selected in this fashionname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'a user can select any number of contiguous characters in a piece of text.In the discontiguous selection model, more than one element in the collection can be selected at any given time, and these elements don't have to be next to each other. An example of this model is a list of files that allows a user to select multiple files.Note that the OSF/Motif Style Guide also describes a fifth selection model, multiple selection. Your application shouldn't use this model because it uses mouse actions for adding and removing selected elements that are different from other mouse actions. Eliminating these inconsistent mouse actions for selection makes it much easier for users to learn how to select data.Each collection of data in your application should support the mouse and keyboard actions for selecting and deselecting data listed in IDREF="65350" TYPE="TABLE"Table 7-1, depending on which of the above models it supports. By default, the IRIS IM list component supports the browse selection model, and the IRIS IM text component supports the range selection model. COLUMNS="3"LBL="7-1"Table 7-1 ID="65350"Selection Actions and ResultsLEFT="0" WIDTH="147"ActionLEFT="155" WIDTH="70"ModelLEFT="230" WIDTH="285"ResultLEFT="0" WIDTH="147"Click on an element in the 
collectionLEFT="155" WIDTH="70"AllLEFT="230" WIDTH="285"The element is selected, and any elements in the collection that were 
previously selected are deselected. The location cursor is moved to the 
selected element.LEFT="0" WIDTH="147"Drag through a range of data in 
the collectionLEFT="155" WIDTH="70"BrowseLEFT="230" WIDTH="285"As the user moves the pointer over each element in the collection, that 
element becomes selected and all other elements in the collection are 
deselected. When the user releases the left mouse button, the element 
currently under the pointer remains the selected item, and the 
location cursor is moved to this element.LEFT="0" WIDTH="147"Drag through a range of data in 
the collectionLEFT="155" WIDTH="70"Range and 
discontiguousLEFT="230" WIDTH="285"Any elements in the collection that were previously selected are 
deselected, and an anchor is set on the element or at the location where 
the left mouse button was pressed. While the user continues to drag 
the mouse, all elements between the anchor and the current location 
of the pointer are selected. When the user releases the mouse button, 
the current selection is set to all the elements between the anchor and 
the location of the pointer when the mouse button was released.LEFT="0" WIDTH="147"<Shift>-click on an element or 
<Shift>-drag through a range of 
elements in a collectionLEFT="155" WIDTH="70"Range or 
discontiguousLEFT="230" WIDTH="285"The anchor is left in place, and the current selection is modified using 
one of three models for extending a range described in Section 4.1.4 of 
the OSF/Motif Style Guide. The preferred model is the balance beam 
model, which is also the default for the IRIS IM text component.LEFT="0" WIDTH="147"<Ctrl>-click on an element in the 
collectionLEFT="155" WIDTH="70"DiscontiguousLEFT="230" WIDTH="285"The selection state of the element is toggled, and the anchor and 
location cursor are moved to that element.LEFT="0" WIDTH="147"<Ctrl> drag through a range of 
data in the collectionLEFT="155" WIDTH="70"DiscontiguousLEFT="230" WIDTH="285"The selection state of the range of elements is toggled based on the 
anchor toggle model described in the OSF/Motif Style Guide, section4.1.5. That is, you pick the element in the range that is closest to the 
anchor and set all of the elements in the range to the inverse of the 
selection state of this element.LEFT="0" WIDTH="147"Click outside of the selection (but 
not on any element in a collection 
that requires at least one element 
to be selected at any given time)LEFT="155" WIDTH="70"All LEFT="230" WIDTH="285"All elements are deselected.LEFT="0" WIDTH="147"When all of the data in a collection 
is selected, click anywhere inside 
the collectionLEFT="155" WIDTH="70"Range and 
discontiguousLEFT="230" WIDTH="285"All elements are deselected.LEFT="0" WIDTH="147"<Esc> while in the process of 
making a selection in any 
collection of data.LEFT="155" WIDTH="70"AllLEFT="230" WIDTH="285"The current selection action is cancelled, and all user input is ignored 
until the user has released all keys and buttons. The selection state is 
returned to its previous state.LEFT="0" WIDTH="147"<Ctrl>-</> when the collection 
has keyboard focusLEFT="155" WIDTH="70"Range and 
discontiguousLEFT="230" WIDTH="285"All elements in the collection are selected. The anchor is placed at the 
beginning of the collection. The location cursor remains unchanged.LEFT="0" WIDTH="147"<Ctrl><\> when the collection has 
keyboard focusLEFT="155" WIDTH="70"Range and 
discontiguousLEFT="230" WIDTH="285"All elements in the collection are deselected. The location cursor 
remains at its current position, and the anchor is moved to where the 
location cursor is.When users select data in a component that can be scrolled, the component should support automatic scrollingname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'that is, if the data being selected is in a scrollable component and the user drags the pointer out of the data display region while still holding down the mouse button, the data should scroll in the direction of the pointer and should continue to be selected. Note that this behavior is automatically supported in the IRIS IM list and text components.The mouse and keyboard actions described above represent a subset of those defined in the OSF/MotifStyle Guide, which requires that all functionality be available from the keyboard. The OSF/MotifStyle Guide describes specific keyboard actions to select individual elements, select a range of data, and modify the data selected. If you determine that users will want to access any of this functionality in your application using the keyboard, see Section 4.1.6 of the OSF/MotifStyle Guide for details on supporting keyboard selection. Note that keyboard selection is automatically supported in IRIS IM list and text components.LBL="" HELPID=""ID="93501"Highlighting a SelectionWhen the user initiates and continues to add to a selection, your application should visually highlight the currently selected data. In addition, while the data in the collection is being adjusted, the currently selected data should always be highlighted to show users what would be selected if they were to release the mouse button immediately. Selections should remain highlighted, even when the window containing that selection is no longer the active window. The OSF/Motif Style Guide refers to this as persistent always highlighting. This is the best type of selection highlighting to use when implicit focus is used for moving the keyboard focus across windows (implicit focus is the default for 4Dwm, as explained in IDREF="59672" TYPE="TITLE""Keyboard Focus Across Windows" in Chapter 3).Use persistent always highlighting except when the only reason a user can make a selection is to transfer that data using the primary transfer model and the user cannot perform any other actions on this data. (The primary transfer model is discussed in IDREF="61999" TYPE="TITLE""Supporting the Primary Transfer Model" in Chapter 5.) For this type of data, your application should use nonpersistent highlighting, which means that the selection is highlighted only when it's the primary selection. When this data is no longer the primary selection, the currently selected data is no longer highlighted and the current selection is set to empty.LBL="" HELPID=""Multiple Collections in One Application WindowThis section describes some common ways that multiple collections of data might interact in a single application window. There are three basic scenarios for using multiple collections in the same window:The user can select data in only one collection at a time.The user can select data in more than one collection at a time, and any given mouse, keyboard, or menu command applies to only one of the collections.The user can select data in more than one collection at a time, and some mouse, keyboard, or menu commands can be applied to more than one of the collections.If the user can select data in only one collection at a time, deselect the previous selection whenever the user makes a new selection in any of the collections. If the user can select data in more than one collection at a time, and any given mouse, keyboard, or menu command applies to only one of the collections, don't do anything special. Since each action can be applied only to one collection, it's obvious which collection to apply it to. For mouse, keyboard, or menu commands that can be applied to more than one of the collections, apply the operation to the collection that most recently had a selection made in it. (See IDREF="50040" TYPE="TITLE""Keyboard Focus and Navigation" earlier in this chapter.)LBL="" HELPID=""Selection GuidelinesFor each collection of data . . . Use one of the four recommended selection modelsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'single selection, browse selection, range selection, or discontiguous selection. Don't use the multiple selection model.Automatically scroll the data as the user drags the pointer out of the scrollable data display region.Determine if your users will need to create or modify a selection using the keyboard. If so, then support the keyboard actions defined in Section 4.1.6 of the OSF/Motif Style Guide. (These actions are automatically supported if you use the IRIS IM list or text components.)When highlighting a selection . . . Update the highlighting continuously as the user initiates and extends the selection.Use persistent always highlighting, unless the only reason a user can select this data is to transfer it using the primary transfer model. In this case, use nonpersistent highlighting.When managing multiple collections of data in a single window . . .Deselect the previous selection whenever the user makes a new selection in any of the collections for cases where the user can select data in only one collection at a time. Apply the operation to the collection that most recently had a selection made in it when the user can select data in more than one collection at a time and there are mouse, keyboard, or menu commands that can be applied to more than one of the collections.LBL="" HELPID=""ID="83927"Drag and DropDirect manipulation, or drag and drop, describes an interface in which the user moves icons on the desktop or in application windows in order to perform various actions on the objects represented by the icons. Some typical uses for drag and drop include the following:Moving an object from one place to another by dragging the object with the mouse and dropping it on a target. For example, to move a file from one directory to another, the user drags the icon representing the file and drops it on the folder icon representing the new directory location.Making a reference to the object in the new location. For example, to add an online book to the personal bookshelf in IRIS Insight, the user drags an icon representing an online book from the main bookshelf to the personal bookshelf. This creates a reference to that book on the personal bookshelf in addition to the reference on the main bookshelf.Performing some operation on the item being dragged. For example, a user can print a file by dragging the icon that represents the file onto a printer icon.If the user presses <Esc> during a drag and drop operation, the operation should be cancelled, and both the object and the target should be left as they were before the operation was initiated.LBL="" HELPID=""Two Models of Drag and DropThere are two models for drag and drop, one recommended for use with text, and the other recommended for use with other objects.LBL="" HELPID=""Drag and Drop for Non-Text ObjectsThe most common model for drag and drop found in applications requires the user to select and drag the object using the left mouse button. This is the preferred model for implementing drag and drop of non-text objects; it reinforces the direct manipulation model of controlling objects directly using the left mouse button. The two most common scenarios for this are the following:The user initiates dragging the object by positioning the cursor over the object, pressing with the left mouse button and dragging the mouse. Pressing the left mouse button in this case selects the object. Dragging the mouse drags the object. (Note that if the pointer is over two different elements that can be dragged, the topmost element should be the one selected and dragged.) Releasing the mouse button drops the object on the target below the pointer location. The user selects one or more objects in a collection using the left mouse button. The user then positions the pointer anywhere over the selection, presses the left mouse button, and drags the mouse to drag the object(s). As with the above scenario, when the user releases the mouse button, the object is dropped on the target below the pointer location. Note that in this case, if users positions the pointer outside of the selection and begins dragging with the left mouse button, they're indicating that they want to make a new selection. See IDREF="59818" TYPE="TITLE""Selection" earlier in this chapter.For either of the above scenarios, after a drop the target should determine both the format of the data and whether the user meant to perform a move or a copy operation. In some cases, dropping the object might simply mean that the object should be moved to a new location in the same component. In the case where the drop is in the same component, after the drop the data should remain selected. For example, the user can move files around in a Directory View window using drag and drop. In other cases, dragging an object onto a target means that the object should be copied to the target so that the target can perform some operation on it. For example, when the user drags a file onto a printer icon, the file is translated into an appropriate format and sent to the printer.To make drag and drop of file objects easy to include in your application, Indigo Magic includes a file finder component, which provides a drop pocket (see IDREF="45317" TYPE="GRAPHIC"Figure 7-3). If the user drops a file icon in the drop pocket, the text field updates to show the pathname of the file represented by the icon. If the user types in the field, the icon in the drop pocket changes to show the new choice. For guidelines on when to use this type of control in your application, see IDREF="43846" TYPE="TITLE""File Finder" in Chapter 9.FILE="ch07.focus.ras3" POSITION="INLINE" SCALE="FALSE"LBL="7-3"Figure 7-3 ID="45317"File Finder ComponentLBL="" HELPID=""Drag and Drop for TextDrag and drop can also be implemented using the middle mouse button. Use this model of drag and drop for transferring text rather than the model described in the previous section because the left mouse button is so heavily used for selection in text.In this case, the user selects a region of text to be dragged using the selection techniques described in IDREF="59818" TYPE="TITLE""Selection," earlier in this chapter. Then the user positions the pointer over the selected text region and drags the text with the middle mouse button. When the user releases the middle mouse button, the text is dropped on the target under the pointer. By default, all text (including labels) can be dragged using the middle mouse button. You may want to turn off drag and drop for some of the text in your application if users will never need to drag it (for example, labels).For additional details of implementing drag and drop of text, see Sections 4.3.4 and 6.2.5 in the OSF/MotifStyle Guide.LBL="" HELPID=""Pointers for Drag OperationsWhen selecting and dragging are integrated into the left mouse button, use the standard arrow cursor for simplicity. When drag and drop is implemented using the middle mouse button (typically for dragging text), replace the standard pointer with a drag icon. This reinforces to users that they're using the middle mouse button to perform a drag and drop operation. The design of drag icons is discussed in Section 6.2.5.1 of the OSF/MotifStyle Guide. LBL="" HELPID=""Drag and Drop GuidelinesWhen designing drag and drop for your application . . . Cancel a drag and drop operation if the user presses <Esc>, and leave both the object and the target as they were before the operation was initiated.Use the left mouse button for both selecting and dragging non-text objects. Use the standard cursor in this case.Use the middle mouse button for dragging text, and replace the cursor with a drag icon when the text is being dragged.LBL="8"ID="98597"MenusMenus allow users to browse through options, settings, and commands available in your application. A well-organized set of menus shows users what your application can do and makes it easy to locate particular functions. This chapter describes the kinds of menus your application should use and how menus and menu items should be organized, in these sections:IDREF="56383" TYPE="TITLE""Types of Menus" defines the three types of menus that your application can use: pull-down, popup, and option menus.IDREF="19797" TYPE="TITLE""Menu Traversal and Activation" describes the default IRIS IM model for accessing menus with the mouse and the keyboard, with two additions that your application should support.IDREF="42408" TYPE="TITLE""The Menu Bar and Pull-Down Menus" discusses how to design pull-down menus (which include cascading, or nested, menus). IDREF="62260" TYPE="TITLE""Popup Menus" discusses how to design popup menus.Option menus are discussed only briefly in this chapter; they're covered in detail in IDREF="68004" TYPE="TITLE""Option Buttons" in Chapter 9.LBL="" HELPID=""ID="56383"Types of MenusIndigo Magic supports three types of menus, all of which are defined in the OSF/Motif Style Guide: pull-down menus, popup menus, and option menus. Of the three types, pull-down menus are probably the most frequently used. Most applications have a menu bar, which is a collection of pull-down menus. IDREF="49505" TYPE="GRAPHIC"Figure 8-1 shows a typical menu bar.FILE="08.menubar.bw" POSITION="INLINE" SCALE="FALSE"LBL="8-1"Figure 8-1 ID="49505"Menu BarEach pull-down menu is represented in the menu bar by its title. A user can display a menu by pressing the left mouse button on the menu title. IDREF="30057" TYPE="GRAPHIC"Figure 8-2 shows a typical pull-down menu. FILE="08.filemenu.bw" POSITION="INLINE" SCALE="FALSE"LBL="8-2"Figure 8-2 ID="30057"Pull-Down MenuPull-down menus can include submenus, or 
cascading menus. A menu entry for a cascading menu is indicated by an arrowhead next to the entry, as shown in IDREF="68665" TYPE="TEXT"IDREF="68665" TYPE="GRAPHIC"Figure 8-3. Pull-down menus are discussed in detail in IDREF="42408" TYPE="TITLE""The Menu Bar and Pull-Down Menus" later in this chapter. FILE="ch08.menus.ras3" POSITION="INLINE" SCALE="FALSE"LBL="8-3"Figure 8-3 ID="68665"Cascading MenuUnlike pull-down menus, popup menus are not represented by a title on the screen. A user displays a popup menu by pressing the right mouse button. The contents of the popup menu depend on where the mouse pointer is located when the button is pushed. IDREF="73864" TYPE="GRAPHIC"Figure 8-4 shows a popup menu. Popup menus are discussed in detail in IDREF="62260" TYPE="TITLE""Popup Menus" later in this chapter.FILE="08.popup.bw" POSITION="INLINE" SCALE="FALSE"LBL="8-4"Figure 8-4 ID="73864"Popup MenuOption menus allow the user to select a single option from a list of options. An option menu appears as a button marked with a horizontal bar, as shown in IDREF="33895" TYPE="GRAPHIC"Figure 8-5. FILE="optionbutton.bw" POSITION="INLINE" SCALE="FALSE"LBL="8-5"Figure 8-5 ID="33895"Option Menu ButtonThe option button is labelled with the currently selected option. When a user presses the left mouse button over the option button, the option menu is displayed, as shown in IDREF="45752" TYPE="GRAPHIC"Figure 8-6. If the user selects a different option from this menu, the label on the button updates to reflect this new value.FILE="ch08.menus.ras6" POSITION="INLINE" SCALE="FALSE"LBL="8-6"Figure 8-6 ID="45752"An Open Option MenuEntries in an option menu represent mutually exclusive values of a parameter. They shouldn't be used for actions. Guidelines for using option buttons and option menus are discussed in IDREF="68004" TYPE="TITLE""Option Buttons" in Chapter 9.LBL="" HELPID=""ID="19797"Menu Traversal and ActivationPull-down, popup, and option menus should use the default IRIS IM model for menu traversal and activation, with two additions. This model is defined in the OSF/Motif Style Guide, Chapter 3, and summarized below. The two additional guidelines are also described in the following paragraphs. Furthermore, pull-down menus use mnemonics and keyboard accelerators for traversal and activation; these techniques are described in the next section, IDREF="42408" TYPE="TITLE""The Menu Bar and Pull-Down Menus."With the default model, users can use either the mouse or the keyboard to display, traverse, activate, and close menus. With the mouse, users have the additional choice of manipulating menus in either a 
spring-loaded or a 
posted manner:To display a pull-down or option menu in a spring-loaded manner, the user positions the pointer over the menu and presses the left mouse button. To display a popup menu in a spring-loaded manner, the user positions the pointer in an area of the window that has a popup menu associated with it and presses the right mouse button. The user traverses any of these menus by moving the pointer over the menu entries while continuing to hold the mouse button. If the pointer is over a menu entry when the user releases the mouse button, that entry is activated and the menu is removed. To display a menu in a posted manner, the user positions the mouse pointer over the menu or over the appropriate area of the window and clicks the appropriate mouse button (left for pull-down and option menus, right for popup). The menu is then displayed with the location cursor on the first available menu entry (that is, the first non-disabled entry). To activate one of the menu entries, the user positions the pointer over the appropriate entry and clicks the left mouse button. To remove the menu, the user clicks the left mouse button anywhere outside the menu. For popup menus, the user can click either the left or right mouse buttons to select an entry or remove the menu.In addition to supporting this default model for manipulating spring-loaded and posted menus with the mouse, your application should handle the mouse click that closes a posted menu as follows: Even though this click is passed on to the underlying application window, your application should ignore this click so that users don't lose selections they've made in the window just because they display and close menus. By default, in IRIS IM, users can also display, traverse, activate, and close menus using the keyboard:To display pull-down menus, users first press <F10> to move the keyboard focus to the leftmost menu in the menu bar and then press the down arrow key. To display an option menu, users first move keyboard focus to the option menu button and then press the space bar. Once a menu is displayed, the user can use the up arrow and down arrow keys to traverse a menu. Similarly, the user can use the left arrow and right arrow keys to move from menu to menu across the menu bar. Once a menu is displayed, pressing <Enter> or the space bar activates the item under the location cursor, closes the menu, and returns the keyboard focus to where it was before the menu was displayed.Pressing <Esc> while a menu is displayed closes the menu and returns the keyboard focus to where it was before the menu was displayed. Pull-down menus can also be closed by pressing <F10>.In addition to supporting this default model for manipulating menus with the keyboard, your application should allow <Shift><F10> to display a popup menu if one is available and move the keyboard focus to the first available entry in the menu. Pressing <Shift><F10> again should close the popup menu and return the keyboard focus to where it was before <Shift><F10> was pressed originally. This behavior is recommended in the OSF/Motif Style Guide (where <Shift><F10> is described as the substitute for the <Menu> key), but it isn't supported by default in IRIS IM.LBL="" HELPID=""Menu Traversal and Activation GuidelinesIn general, when designing traversal and activation for your menus . . . Allow users to activate and traverse the menus using the default IRIS IM behaviors for mouse and keyboard actions.If a user closes a menu by clicking somewhere outside of the menu, the application should ignore this click so that users don't lose selections they've made in the window just because they display and close menus.Allow users to display and close popup menus using the key combination <Shift><F10>. When <Shift><F10> displays a popup menu, the location cursor should be on the first available menu entry. When <Shift><F10> closes the menu, the keyboard focus should be returned to where it was before the menu was displayed.LBL="" HELPID=""ID="42408"The Menu Bar and Pull-Down MenusIn most cases, each of an application's primary windows has a menu bar as described in IDREF="93559" TYPE="TITLE""Menu Bars in Primary Windows" in Chapter 6. Users should be able to access most of an application's functions through its menu bars. This makes it easy for users to see what functions are available to them.Each menu bar contains several pull-down menus. Each pull-down menu is represented in the menu bar by its title and contains entries that are either an action, a label for a cascading menu, or a separator, as shown in IDREF="42142" TYPE="GRAPHIC"Figure 8-7. Also as shown, the cascading menus contain additional actions. See IDREF="67010" TYPE="TITLE""What to Put in the Pull-Down Menus" for more information about the content of pull-down menus. FILE="ch08.menus.ras7" POSITION="INLINE" SCALE="FALSE"LBL="8-7"Figure 8-7 ID="42142"Elements of a Pull-Down MenuUsers interact with pull-down menus according to the model described in the previous section, IDREF="19797" TYPE="TITLE""Menu Traversal and Activation." In addition, users can access menu entries using mnemonics, which are the underlined characters in the menu titles and on menu entries (see IDREF="42142" TYPE="GRAPHIC"Figure 8-7). To access a menu using a mnemonic, a user moves the pointer into the application window, then holds down the <Alt> key while pressing the character key that matches the underlined character in the menu title. For example, to display the Catapult menu shown in IDREF="42142" TYPE="GRAPHIC"Figure 8-7, the user holds down the <Alt> key and presses the "c" key. Then, to select a projectile from the Projectiles cascading menu, the user presses the "p" key to display the Projectiles cascading menu, and then presses "p" again to select "Piano." Note that mnemonics are always activated without the <Shift> key, even if the underlined character happens to be uppercase. Choosing appropriate mnemonics is discussed in more detail in IDREF="62421" TYPE="TITLE""Choosing Mnemonics" later in this chapter.Menu entries that represent frequently used actions can have keyboard accelerators, as shown in IDREF="42142" TYPE="GRAPHIC"Figure 8-7. These keyboard accelerators are displayed in the menu next to the action and are typically a combination of the <Ctrl> key and one other key. To initiate a menu action using a keyboard accelerator, a user moves the pointer over the window to make it the active window and then presses the key combination shown in the menu entry. For example, instead of selecting "Fire catapult" from the Catapult menu in IDREF="42142" TYPE="GRAPHIC"Figure 8-7, a user could fire the catapult by holding down the <Ctrl> key and pressing the "f" key. When to use keyboard accelerators and how to choose ones which are appropriate are discussed in more detail in the IDREF="75819" TYPE="TITLE""Choosing Keyboard Accelerators" section later in this chapter.A menu entry that's followed by an ellipsis (such as the "Select target..." entry shown in IDREF="42142" TYPE="GRAPHIC"Figure 8-7) brings up a dialog that requests more information from the user before any action is performed. When to use an ellipsis in a menu entry is discussed in more detail later in this chapter in IDREF="87916" TYPE="TITLE""Naming Menu Entries in the Pull-Down Menus." Menu entries that aren't currently available are disabled. This is usually shown by graying out the menu entry, as discussed in IDREF="19592" TYPE="TITLE""Disabling Menu Entries."When designing the menu bar and its pull-down menus for your application, you should start with the standard menus described in the next section, IDREF="12088" TYPE="TEXT"IDREF="12088" TYPE="TITLE""Standard Menus." Then, modify these standard menus to fit your specific application, using the guidelines in the section IDREF="67010" TYPE="TITLE""What to Put in the Pull-Down Menus."LBL="" HELPID=""ID="12088"Standard MenusYour application needs its own customized set of menus and menu entries, but you should use the standard set as the starting point for the overall menu structure. All of the menu entries discussed in this chapter are optional; many of them are appropriate for most applications (but there are always exceptions), and some entries are generally less common than others. For example, "Print" is a fairly common entry for the "File" menu, but printing doesn't generally make sense for audio applications. "Import" is another entry for the "File" menu, but it's less common than "Print." IDREF="78135" TYPE="GRAPHIC"Figure 8-8 shows a menu bar with all of the standard menus (in the correct order) and their mnemonics. This menu bar includes all of the menus defined in the MenuBar reference page of Chapter 9 in the OSF/Motif Style Guide, plus an additional menu, Tools, which is defined in the Indigo Magic environment. The standard menus are described in the following sections. FILE="08.complete.menubar.bw" POSITION="INLINE" SCALE="FALSE"LBL="8-8"Figure 8-8 ID="78135"Standard Menus for Menu BarsNote that for each of the standard menu entries described in the following sections, mnemonics are represented by the underlined character in the entry label. This label also includes an ellipsis if the entry should include them. The entries are listed in the order in which they should appear in menus, and entries that are likely to be less common are indicated. Keyboard accelerators, if they exist, are listed in the description of the specific menu entry. Appropriate places for separators are shown in the figures depicting the standard menus. Situations where a menu entry should be disabled are included in the description of the menu entry if applicable. Also, the keyboard shortcuts are shown as they should be displayed in the menus (for example, <Ctrl>-s is shown as "Ctrl+S").LBL="" HELPID=""ID="38726"File MenuThe File menu contains entries for actions that are performed on files, such as "Open," "Save," and "Print," and on the application as a whole, such as "Exit." IDREF="20202" TYPE="GRAPHIC"Figure 8-9 shows the standard File menu with the most common entries; note that its mnemonic is "F." These standard entries, as well as a few other less common ones ("Reopen," "Import," and "Revert"), are described in IDREF="43365" TYPE="TABLE"Table 8-1 in the order in which they should appear in the menu. All of these entries should behave as defined by the File Menu reference page in the OSF/Motif Style Guide, Chapter 9, except as noted in the table. Note that "New," "Open," "Close," and "Exit" should display a dialog as described in IDREF="91359" TYPE="TITLE""Invoking Dialogs" in Chapter 10 if there are unsaved changes to the current document.FILE="08.filemenu.bw" POSITION="INLINE" SCALE="FALSE"LBL="8-9"Figure 8-9 ID="20202"The Standard File Menu COLUMNS="4"LBL="8-1"Table 8-1 ID="43365"File Menu EntriesLEFT="0" WIDTH="61"Menu Entry 
and MnemonicLEFT="70" WIDTH="102"OSF/Motif BehaviorLEFT="180" WIDTH="289"Indigo Magic Additions and ExceptionsLEFT="475" WIDTH="50"Keyboard 
AcceleratorLEFT="0" WIDTH="61"NewLEFT="70" WIDTH="102"Creates a new, empty 
file.LEFT="180" WIDTH="289"If your application allows more than one document window to be open 
at a time, it should create a new, empty document window; if the current 
document window is already empty, the action should have no effect. 
For more information on designing applications that support multiple 
open documents, see IDREF="27980" TYPE="TITLE""Standard Application Models" in Chapter 6. If 
your application requires more information before creating a new 
document (for example, the user must select a template), this action may 
bring up a dialog to request the information. In this case, the entry label 
should be followed by an ellipsis.LEFT="475" WIDTH="50"Ctrl+NLEFT="0" WIDTH="61"OpenLEFT="70" WIDTH="102"Brings up a dialog, 
allowing the user to 
choose an existing file to 
open.LEFT="180" WIDTH="289"If your application allows more than one document window to be open 
at a time, it should create a new document window to display the 
specified file; however, if the current document window is already 
empty, the file should be displayed in the current document window. 
This new document window shouldn't be a separate instantiation of the 
application.LEFT="475" WIDTH="50"Ctrl+OLEFT="0" WIDTH="61"ReopenIDREF="ch08.menusTF0a"aLEFT="70" WIDTH="102"Not defined.LEFT="180" WIDTH="289""Reopen" allows a user to return to a file that had been previously 
opened by the application. Choosing "Reopen" should display a 
cascading menu of previously opened files; you might choose to limit 
the length of this list to a maximum of 10 entries. (You should disable 
this entry if there are no previously opened filesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for example, if this is 
the first time the user has launched the application.) If there are unsaved 
changes to the current file, your application should display a dialog that 
asks the user whether to save or discard the changes (see IDREF="61823" TYPE="TITLE""Invoking 
Dialogs When Manipulating Files" in Chapter 10).LEFT="475" WIDTH="50"LEFT="0" WIDTH="61"ImportaLEFT="70" WIDTH="102"Not defined.LEFT="180" WIDTH="289""Import" allows a user to read an existing data file into the current 
application. This entry can bring up the Indigo Magic file selection 
dialog (in which case it should be displayed with an ellipsis), and the 
application should automatically determine the type of the file after it's 
selected. (See IDREF="52846" TYPE="TITLE""Types and Modes of Dialogs" in Chapter 10 for details on 
the Indigo Magic file selection dialog.) Alternatively, this entry can use 
a cascading menu to display the types of data that your application 
allows users to import. Each of these entries should be followed by an 
ellipsis and should bring up the file selection dialog to allow the user to 
specify the specific file to import. Follow this entry with a separator.LEFT="475" WIDTH="50"LEFT="0" WIDTH="61"SaveLEFT="70" WIDTH="102"Saves the current file.LEFT="180" WIDTH="289"Although some applications disable this entry when there are no 
changes to be saved, your application should never disable this entry (as 
described in IDREF="19592" TYPE="TITLE""Disabling Menu Entries").LEFT="475" WIDTH="50"Ctrl+SLEFT="0" WIDTH="61"Save As...LEFT="70" WIDTH="102"Brings up a dialog and 
saves the current file 
with a new name. Also 
closes the previous file 
and opens the new one.LEFT="180" WIDTH="289"If the current document already has a filename, that filename should be 
the default value in the file selection dialog. LEFT="475" WIDTH="50"LEFT="0" WIDTH="61"RevertaLEFT="70" WIDTH="102"Not defined.LEFT="180" WIDTH="289""Revert" allows a user to undo all changes made to the current file since 
the last time the user saved it. (This entry should be disabled if there are 
no unsaved changes.) Your application should display a warning dialog 
before executing this action, as described in IDREF="61823" TYPE="TITLE""Invoking Dialogs When 
Manipulating Files" in Chapter 10. LEFT="475" WIDTH="50"LEFT="0" WIDTH="61"PrintLEFT="70" WIDTH="102"Prints the current file.LEFT="180" WIDTH="289"If choosing "Print" brings up a dialog to allow the user to select from a 
list of all available printers, it should be followed by an ellipsis. If the 
keyboard accelerator is used to activate this entry, the print job should 
be sent to the default printer.LEFT="475" WIDTH="50"Ctrl+PLEFT="0" WIDTH="61"CloseLEFT="70" WIDTH="102"Closes a window and its 
associated support 
windows and dialogs, 
without quitting the 
current application.LEFT="180" WIDTH="289""Close" should be provided on co-primary windows and on support 
windows if they have menu bars. It shouldn't be provided on the main 
primary window. (See IDREF="91745" TYPE="TITLE""Window Types" in Chapter 6 for definitions of 
these window types and IDREF="85826" TYPE="TITLE""Window Decorations and the Window Menu" 
in Chapter 3 for details on the "Close" entry.) Applications that follow 
the "Multiple Document, No Visible Main" model should exit the 
application when the last co-primary window is closed. (See IDREF="96208" TYPE="TITLE"""Multiple 
Document, No Visible Main" Application Model" in Chapter 6.)LEFT="475" WIDTH="50"Ctrl+WLEFT="0" WIDTH="61"ExitLEFT="70" WIDTH="102"Closes all windows for 
the application and 
quits the application.LEFT="180" WIDTH="289""Exit" should always be provided in the main primary window. If users 
are likely to want to exit your application from a specific co-primary 
window in the application, that window should include an "Exit" entry 
in the leftmost menu, in addition to a "Close" entry. (See IDREF="85826" TYPE="TITLE""Window 
Decorations and the Window Menu" in Chapter 3 for details on when to 
use "Exit" and "Close.")LEFT="475" WIDTH="50"Ctrl+QLBL="a" ID="ch08.menusTF0a"These entries are probably less common than the others. LBL="" HELPID=""Selected MenuThe Selected menu contains application-specific actions that are performed on the currently selected objects. For example, Directory View windows on the Indigo Magic Desktop display icons representing files. Each Directory View window has a Selected menu that allows users to perform actions on the selected files, such as "Open," "Print," and "Remove." (Note that since actions in the Selected menu act on the selected data while actions in the File menu act on the entire file of data, the same entryname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'"Print," for examplename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'can mean something different in the two menus.) The Selected menu shouldn't contain editing actions such as "Cut" since these should be in the Edit menu. The mnemonic for the Selected menu should be "S." LBL="" HELPID=""ID="94339"Edit MenuThe Edit menu contains actions that transfer data to or from the clipboard, actions that modify the current selection, and "Undo." It contains actions for both the clipboard data exchange model ("Cut," "Copy," and "Paste") and for the primary data exchange model ("Promote"). Both of these data exchange models are described in IDREF="43344" TYPE="TITLE"Chapter 5, "Data Exchange on the Indigo Magic Desktop."IDREF="26733" TYPE="GRAPHIC"Figure 8-10 shows the most common entries in the standard Edit menu; note that its mnemonic should be "E." FILE="ch08.menus.ras10" POSITION="INLINE" SCALE="FALSE"LBL="8-10"Figure 8-10 ID="26733"The Standard Edit MenuThese standard entries, as well as a few other less common ones ("Clear," "Promote," and "Color Editor"), are described in IDREF="84101" TYPE="TABLE"Table 8-2 in the order in which they should appear in the menu. All of these entries should behave as defined in the Edit Menu reference page in Chapter 9 of the OSF/Motif Style Guide, except as noted in the table. COLUMNS="4"LBL="8-2"Table 8-2 ID="84101" Standard Edit Menu EntriesLEFT="0" WIDTH="65"Menu Entry and 
MnemonicLEFT="70" WIDTH="160"OSF/Motif BehaviorLEFT="235" WIDTH="226"Indigo Magic Additions and ExceptionsLEFT="470" WIDTH="50"Keyboard 
AcceleratorLEFT="0" WIDTH="65"Undo [action]LEFT="70" WIDTH="160"Reverses the effect of a previous action. 
The "Undo" action may apply to 
actions that the user accomplishes 
without using the menusname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'typing text, 
for example.LEFT="235" WIDTH="226"At a minimum, your application should be able to undo 
all of the actions in the Edit menu. If an undo action will 
change the data significantly and can't be undone, you 
should display a warning dialog explaining that the 
change can't be undone and ask for confirmation. See 
IDREF="52846" TYPE="TITLE""Types and Modes of Dialogs" in Chapter 10 for 
information on warning dialogs. The "Undo" entry 
should be disabled if the last change cannot be undone 
or if there are no changes.If your application has only a single-level undo (that is, 
it can undo only the most recent action), after the user 
selects "Undo," the "Undo" entry should be changed to 
"Redo [action]." If the user selects "Redo" the 
application should reverse the effects of the previous 
"Undo," and toggle the menu entry back to "Undo 
[action]." If your application has multiple-level undo 
(that is, it can undo a series of actions), you should 
provide a separate "Redo" menu entry. Typically, 
applications don't allow users to undo beyond the saved 
version of the file; if your application does, you should 
bring up a warning dialog.LEFT="470" WIDTH="50"Ctrl+ZLEFT="0" WIDTH="65"Redo [action]LEFT="70" WIDTH="160"Not defined.LEFT="235" WIDTH="226""Redo" reverses the effect of a previous "Undo" action. 
It is useful to have a separate "Redo" entry if your 
application has multiple-level undo. Like "Undo," the 
"Redo" entry should indicate the action that will be 
redone (for example, "Redo Cut," "Redo Paste"). If you 
provide a "Redo" command, place it after the Undo 
entry and follow it with a separator. LEFT="470" WIDTH="50"Shift+Ctrl
+ZLEFT="0" WIDTH="65"CutLEFT="70" WIDTH="160"Removes the selected data from the 
application window to the clipboard.LEFT="235" WIDTH="226"The "Cut" entry should be disabled if there's nothing 
currently selected in the window. LEFT="470" WIDTH="50"Ctrl+XLEFT="0" WIDTH="65"CopyLEFT="70" WIDTH="160"Copies the selected data to the 
clipboard without removing it from the application window.LEFT="235" WIDTH="226"The "Copy" entry should be disabled if there's nothing 
currently selected in the window. LEFT="470" WIDTH="50"Ctrl+CLEFT="0" WIDTH="65"PasteLEFT="70" WIDTH="160"Copies the contents of the clipboard 
into the application window.LEFT="235" WIDTH="226"If there's nothing currently on the clipboard available to 
be pasted, bring up a dialog saying there's nothing 
available. See IDREF="91359" TYPE="TITLE""Invoking Dialogs" in Chapter 10.LEFT="470" WIDTH="50"Ctrl+VLEFT="0" WIDTH="65"ClearIDREF="ch08.menusTF1a"aLEFT="70" WIDTH="160"Same as "Delete," except that the 
remaining data isn't reorganized to fill 
in the space left by the cleared data.LEFT="235" WIDTH="226"If you provide a "Clear" command, place it before the 
"Delete" entry. The "Clear" entry should be disabled if 
there's nothing currently selected in the window.LEFT="470" WIDTH="50"LEFT="0" WIDTH="65"DeleteLEFT="70" WIDTH="160"Removes the selected data from the 
application window.LEFT="235" WIDTH="226"The "Delete" entry should be disabled if there's nothing 
currently selected in the window.LEFT="470" WIDTH="50"LEFT="0" WIDTH="65"Select AllLEFT="70" WIDTH="160"Selects all of the elements in a 
component of the application window.LEFT="235" WIDTH="226"The mnemonic for "Select All" should be "A."LEFT="470" WIDTH="50"Ctrl+/LEFT="0" WIDTH="65"Deselect AllLEFT="70" WIDTH="160"Deselects all of the elements in a 
component of the application window.LEFT="235" WIDTH="226"The "Deselect All" entry should be disabled if there's 
nothing currently selected in the window. The 
mnemonic for "Deselect All" should be "l."LEFT="470" WIDTH="50"Ctrl+\LEFT="0" WIDTH="65"PromoteaLEFT="70" WIDTH="160"Promotes the current selection to the 
primary selection.LEFT="235" WIDTH="226""Promote" should be included if it can be difficult or 
time-consuming to recreate a selection in your 
application, and if your application supports the 
primary transfer model described in IDREF="61999" TYPE="TITLE""Supporting the 
Primary Transfer Model" in Chapter 5. Disable this 
entry when there's no current selection or when the 
current selection is already the primary selection; it 
should be enabled only when the application window 
has a selection that isn't currently the primary selection. 
See IDREF="59818" TYPE="TITLE""Selection" in Chapter 7 for information on 
selections. The mnemonic for "Promote" should be "m."LEFT="470" WIDTH="50"<Alt>- 
<Insert>LEFT="0" WIDTH="65"Color Editor...aLEFT="70" WIDTH="160"Not defined.LEFT="235" WIDTH="226"Choosing "Color Editor" invokes the Indigo Magic color 
chooser, which allows the user to select colors. (See IDREF="84245" TYPE="TITLE""A 
Specific Standard Support Window: The Indigo Magic 
Color Chooser" in Chapter 6.)LEFT="470" WIDTH="50"LBL="a" ID="ch08.menusTF1a"These entries are probably less common than the others. LBL="" HELPID=""ID="26586"View MenuThe View menu contains entries for application-specific actions that change the user's view of the current data but that don't change the actual data. For example, if your application window has several panes of information, the View menu could provide the user with a way to turn each individual pane on or off. The entries representing the individual panes should be grouped together, and there should be a checkbox in front of each one indicating whether the pane is currently being displayed or not. (See IDREF="69664" TYPE="TITLE""Splitting Primary Windows Into Panes" in Chapter 6 for information on multiple-pane windows. Using checkboxes in menus is discussed in more detail in the section on IDREF="67896" TYPE="TITLE""Using Radio Buttons and Checkboxes in Pull-Down Menus.") Other entries in the View menu might adjust the scale of the view (zoom in and zoom out), display support elements (such as rulers and grid lines), and hide or display certain parts of the data. The mnemonic for the View menu should be "V."LBL="" HELPID=""ID="70020"Tools menuThe Tools menu contains application-specific entries that allow the user to open support windows for manipulating the data in the parent primary window. For example, a desktop publishing package might have separate support windows that provide special controls for editing graphics, tables, and mathematical equations; access to these support windows would be placed in the Tools menu. See IDREF="30905" TYPE="TITLE""Support Windows" in Chapter 6 for a discussion of support windows. The mnemonic for the Tools menu should be "T."LBL="" HELPID=""Options menuThe Options menu contains application-specific entries that allow the user to customize the application. For example, a multi-window application might have entries in the Options menu to allow the user to set preferences such as which windows should come up by default when the application is started, and whether window sizes and positions should be saved between sessions. The mnemonic for the Options menu should be "O."LBL="" HELPID=""Help menuThe Help menu contains entries for actions that provide several different kinds of help information to the user. All application windows that have a menu bar should contain a Help menu. Its mnemonic is "H." The standard entries for the Help menu are discussed in IDREF="31568" TYPE="TITLE""Providing Help through a Help Menu" in Chapter 4. LBL="" HELPID=""ID="67010"What to Put in the Pull-Down MenusYour application's pull-down menus should include whatever standard menu entries are relevant for your application, plus whatever application-specific entries you need to represent your application's core functionality. The previous section, IDREF="12088" TYPE="TITLE""Standard Menus," describes when and how to use the standard entries; this section presents guidelines for application-specific modifications and additions to the standard menus. As you decide which of the standard entries to include in your application, consider each of these entries on a case-by-case basis. For example, you almost certainly need an "Exit" entry, but it's possible that none of the other standard File menu entries make sense for your application, including the "File" menu title itself. Users often learn the functionality of a new application by scanning the menus to see what actions are available and by browsing the online help. Also, when users want to perform some action, they usually look first for that action in the pull-down menus. Thus, all simple, frequently accessed actions should be accessible from the pull-down menus. Be sure to include actions for performing basic operations (such as "Cut," "Paste," or "Save"), for setting the value of an attribute (for example, make selected text bold, or turn grid lines on or off), for online help, and for "Undo" (particularly if users can perform actions that destroy or significantly change their data)\xd7 . If this important functionality is hidden in a dialog, users won't easily discover it. (See IDREF="30192" TYPE="TITLE"Chapter 10, "Dialogs" for details on when to use dialogs.) Also, don't include more than 10-12 entries in a menu or users will have trouble scanning it; all of your entries should be able to fit on the screen at one time because IRIS IM doesn't support scrolling menus.Actions that are accomplished using buttons in primary windows should be repeated in the pull-down menus because they're probably the most frequently accessed actions. Including them in the menus gives users one place to look for all actions and allows you to assign keyboard accelerators and mnemonics that are clearly shown in the menu entries. Users should have the option of using the keyboard for frequently used actions rather than being restricted to pointing-and-clicking on buttons. In addition, all simple actions should have an associated menu command even if there's a direct manipulation method or mouse double-click shortcut available for accomplishing the task. Providing menu commands avoids hidden functionality, and helps those users who have difficulty performing double-clicks. If you think that your users need constant access to a group of actions, your application should make these actions available in a support window. As a second choice, you can use a tear-off menu as described in the OSF/Motif Style Guide, section 6.2.3. Support windows are designed to include groups of controls that the user might want to use continuously. Support windows allow for a more flexible layout of controls than tear-off menus do, and support windows can contain all kinds of components, such as labels and text input fields, not just push buttons. (See IDREF="30905" TYPE="TITLE""Support Windows" in Chapter 6 for information on designing support windows.) Users should be able to access such support windows as well as co-primary windows from the menu bar of their parent window. LBL="" HELPID=""ID="90029"Naming Menus in the Menu BarAll menus in the menu bar should have one-word (capitalized) titles since users may interpret a second word as a separate menu title; don't use bitmaps as menu titles. Use the standard titles for menus (for example, File and Edit) if they're applicable to your application, but don't use a standard title if you're changing the standard definition. (See IDREF="12088" TYPE="TITLE""Standard Menus" for standard menu titles and their definitions.) The leftmost menu contains actions that operate on a logical unit of data for the application; it's generally titled "File" because most applications read and write data files. However, if your application doesn't manipulate data files, the leftmost menu should reflect the unit of data that the user expects to operate on. For example, the Search tool's leftmost menu is called Page because the application doesn't manipulate data files, but it does offer several different pages that define search categories. If your application does read and write data files but the word "File" might be confusing to users, choose a more appropriate title for the leftmost menu. For example, in MediaMail, a group of documents (mail messages) are stored in a single file referred to as a mail folder. The leftmost menu in the main window is named "Folder" to make it clear that it contains actions that apply to the entire folder of messages rather than to individual messages. If the menu were named "File," it  might not be clear whether the "Open" entry opened a message or a mail folder. Similarly, you can change the names of other standard menus to make them more meaningful. The second menu in the main window of MediaMail is named "Message" because all operations in that menu are performed on the selected messages. This menu could have been called the Selected menu, but "Message" makes it clear what the menu entries act on.LBL="" HELPID=""ID="87916"Naming Menu Entries in the Pull-Down MenusAs with menu names in the menu bar, use the standard names for menu entries within pull-down menus if they're applicable to your application; don't use a standard name if you're changing the standard definition. (See IDREF="12088" TYPE="TITLE""Standard Menus.") Menu entries should be capitalized using the same rules for capitalizing book titles: capitalize the first word and other non-articles, but don't capitalize articles unless they're the first word.  Generally, a menu entry should be one of the following:A verbname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'such as "Cut," "Copy," or "Delete." A value for a parameter, when the action is to set the parameter to that specific value. For instance, IRIS Showcase has a "Grids" cascading menu with entries corresponding to grid sizes such as "1/8 inch" and "1/4 inch."An attribute name, when the action is to assign some entity that attributename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'such as whether shapes should be drawn filled or unfilled.A window name, if the menu entry brings up a co-primary, support, or dialog window. For example, a Directory View window has a menu entry for setting permissions. This entry brings up a dialog named "Permissions," so the menu entry is also named "Permissions," rather than "Set Permissions."The name of a cascading menu (see IDREF="53348" TYPE="TITLE""Using Cascading Menus" later in this chapter).If none of these categories applies, choose a one- or two-word phrase that indicates clearly what action will be taken. Include the name of the object that will be acted on if it's needed for clarity. For example, "New," generally indicates that a new data file will be created. If your application doesn't create data files, the menu entry for creating a new entity should be "New object" such as "New Folder" (Directory View windows) or "New Page" (Icon Catalog).You can use graphic labels for menus entries, but keep in mind that graphic labels are often unclear. They work best when used along with a text label, and typically there's not enough room for both graphic and text labels in a menu entry. For those cases where graphics are better descriptions than text (for example, when showing bitmaps or textures), you should probably include these options in a tool palette either as individual buttons or as entries in an option menu. See IDREF="18668" TYPE="TITLE""Pushbuttons" and IDREF="68004" TYPE="TITLE""Option Buttons" in Chapter 9 for more information about these alternatives.If the entry is something that toggles its state, use one of the following alternatives: Toggle the menu entry name to indicate the action that will be taken if the user selects this entry. For example, a menu entry "Show Grid" indicates that the grid isn't currently shown and that choosing this item will display it. If the user chooses this item, the grid is displayed and the entry should toggle to "Hide Grid."Choose a menu entry name that clearly indicates what action will be taken, place a checkbox indicator next to the menu entry, and use the checkbox to indicate whether or not the action has been taken. For example, the menu entry "Italics" with a checkmark next to it indicates that the current font is an Italic one; the same entry with no checkmark indicates that the current font isn't Italic. (For more details on the use of checkboxes in menus, see IDREF="67896" TYPE="TITLE""Using Radio Buttons and Checkboxes in Pull-Down Menus" later in this chapter.) If the entry belongs to a group of related entries, all of which toggle their states, place checkbox indicators next to each of them. The entry names should be nouns or attributes that clearly imply their actions (and these names should remain constant rather than toggling), and the entire group should be separated from other menu items by separator lines. (See IDREF="67896" TYPE="TITLE""Using Radio Buttons and Checkboxes in Pull-Down Menus.")A menu entry should be followed by an ellipsis if it brings up a dialog for the purpose of requesting more information from the user before performing the action. The ellipsis does not simply mean that the menu entry displays a dialog. For example, the "Save As..." menu entry brings up a dialog that asks the user to enter additional necessary information before the action can be performed. "Help," on the other hand, brings up a dialog that contains the information that the user requested.LBL="" HELPID=""Ordering Menus and Menu Entries in the Pull-Down MenusUse the order described in IDREF="89217" TYPE="TEXT"IDREF="12088" TYPE="TITLE""Standard Menus" for standard menus in the menu bar and their entries. If you need to create additional menus for your application, place them between the View and Tools menus. If you need to change the name of one of the standard menus (as discussed earlier in IDREF="90029" TYPE="TITLE""Naming Menus in the Menu Bar"), leave this menu in the same order as if it had the standard name. For example, in MediaMail the File menu is renamed Folder and the Selected menu is renamed Message, but Folder is still the leftmost menu and Message is still next to the Folder menu.Within menus, organize entries into logical groups. If one of your application-specific menu entries is logically related to one of the standard menu entries, place it near that standard entry. If this isn't a good fit, create new menus that group the entries according to function. For example, the Directory View window has an Arrange menu that contains different options for arranging the file icons displayed in the window. Within the logical groups, first place entries in the order in which they need to be used. For example, in the Edit menu, "Copy" is before "Paste" because the user must do a "Copy" operation before doing a "Paste." Secondarily, order them by frequency of use, placing the more frequently used entries closer to the top of the menu. In any case, be sure that when you use "Close" and "Exit," they're always at the end of the leftmost menu, whether or not this menu is named File.When creating logical groups of entries, use separators to define the groups, but avoid overusing separators because they can make it difficult to scan the entries. Two situations where separators are especially useful are for groups where only one of the entries can be selected at any one time, and groups whose entries represent multiple attributes that can be applied to a single object. As described later in IDREF="67896" TYPE="TITLE""Using Radio Buttons and Checkboxes in Pull-Down Menus," you should also use radio buttons in the first case and checkboxes in the second.If the menu contains entries that can be determined only when the user launches the application (for example, a menu listing plug-in modules), alphabetize the entries. If this alphabetized group appears in a menu that contains other entries, place the group at the end of a menu and use a separator between it and the preceding entries.LBL="" HELPID=""ID="53348"Using Cascading MenusAs you're organizing your menus, you can use cascading menus, but don't use more than a single level. If you think you need more than one level of cascading menus, try adding a new menu instead, especially if you have numerous items in the cascading menus. If you have only a few items, consider creating groups of items by using separators, rather than putting them in separate cascading menus. In general, try to limit your use of cascading menus since users tend to scan only the top-level menus when they're looking for a specific function or trying to learn the functionality of the application. When naming a cascading menu, use a name that suggests what it contains so that users know what functions they're likely to find. For example, in an early version of IRIS Showcase, the grid was under a cascading menu named "Editing Options" in the Edit menu, and users often weren't able to find it. Now, the different grid sizes are under a cascading menu named "Grids" in the View menu.LBL="" HELPID=""ID="67896"Using Radio Buttons and Checkboxes in Pull-Down MenusIf only one of a group of menu items can be selected at any one time, each item in the group should have a radio button next to it, and only one radio button should be active at any given time. For example, the radio buttons in IDREF="86773" TYPE="GRAPHIC"Figure 8-15 allow the user to choose exactly one type of tea at a timename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'which is as it should be, because if you ordered two cups of tea at a time the second one would get cold before you could drink it. A set of radio buttons should be separated from other entries in the menu by separator lines.FILE="07.radiobuttons.bw" POSITION="INLINE" SCALE="FALSE"LBL="8-11"Figure 8-11 ID="86773"Radio buttonsIf several of a group of related menu items can be selected at any one time, each item in the group should have a checkbox next to it, and the active entries should be shown with checkmarks. These items typically represent attributes of an object, more than one of which can be applied to the object. For example, the checkboxes in IDREF="26995" TYPE="GRAPHIC"Figure 8-13 allow the user to select milk or sugar, or both, or neither. A set of checkboxes should be separated from other entries in the menu by separator lines. LBL="" HELPID=""ID="62421"Choosing MnemonicsYou need to choose single-character mnemonics for any menus or menu entries you create. Each of the menus in the menu bar should have a unique mnemonic, as should each of the entries within any specific menu. Use the standard mnemonics for standard menu titles and entries, as described earlier in IDREF="12088" TYPE="TITLE""Standard Menus." You can use a standard mnemonic for a different entry if you're not using that standard entry.If possible, use the first character in the label for the mnemonic. If two menu titlesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'or two entries in the same menuname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'have the same first character, use the first character for the mnemonic of the menu title or entry that will be used most frequently. For example, "Save" is used more frequently than "Save As...", so "Save" has the mnemonic "S" and "Save As..." has the mnemonic "A." When the first character can't be used as the mnemonic, try to pick a consonant in the name that's strongly associated with the word (such as "x" for Maximize in the Window menu). If no such consonant exists, choose the first available vowel (such as "a" for Raise in the Window menu). Note that the mnemonic chosen can be an uppercase or lowercase character in the label, but it must be case insensitive for activation (that is, users don't need to hold down the <Shift> key). LBL="" HELPID=""ID="75819"Choosing Keyboard AcceleratorsUse the keyboard accelerators for the standard menu entries as described in IDREF="12088" TYPE="TITLE""Standard Menus"; don't use any of the standard accelerators for application-specific entries, even if you're not using those standard entries. For menu entries you create, provide keyboard accelerators only for the most commonly used actions, not for every menu entry in every pull-down menu. In most cases, use the <Ctrl> key and a character for a keyboard accelerator. (In order to avoid conflicts with mnemonics, don't use the <Alt> key rather than <Ctrl>.) To make accelerators easier to remember, choose a character that's associated with the menu entry. For example, the standard keyboard accelerators include <Ctrl-c> for "Copy" and <Ctrl-s> for "Save," and the Directory View window uses <Ctrl-i> for "Get Info." If you have a pair of menu entries that both require keyboard accelerators, and one entry reverses the results of the other, their keyboard accelerators should be related. Choose a character that's associated with the more frequently used entry (so that its accelerator is <Ctrl-character>), and add <Shift> to create the other accelerator (so that its accelerator is <Shift-Ctrl-character>, where character is the same for both accelerators). For example, the keyboard accelerator for Undo is <Ctrl-z>, and the keyboard accelerator for Redo is <Shift-Ctrl-z>. In general, avoid using multiple modifier keys such as <Shift-Ctrl-character>, except for this situation.Note that any keyboard accelerator that involves a lowercase character should be shown in the menu as "Ctrl+uppercase_character" (for example, <Ctrl-s> should be displayed as "Ctrl+S"). This is because uppercase characters are easier to read in the menus. If the accelerator involves an uppercase character, display it as "Shift+Ctrl+uppercase_character" (for example, <Ctrl-S> should be displayed as "Shift+Ctrl+S").LBL="" HELPID=""ID="19592"Disabling Menu EntriesAs discussed in IDREF="12088" TYPE="TITLE""Standard Menus," menu entries that aren't currently available should be disabled (grayed out). (See the next section, IDREF="23392" TYPE="TITLE""Dynamic Menu Entries," for discussion of the rare cases in which menu entries can be removed from the menu when they're unavailable.) In general, disabling entries when selecting them would give the user an error message. For example, if a menu entry works on a selection (such as "Cut" and "Copy"), it should be disabled if there's no current selection. If selecting the menu entry would result in no action at all (not even an error message), the menu entry shouldn't be disabled. As an example, choosing "Save" from the File menu saves the current document; if the document hasn't been edited, selecting "Save" has no real effect, but there's no need to display an error message, so this menu entry should never be disabled.Menu entries that launch modeless dialogs should never be disabled. If the dialog isn't applicable when it's launched, the OK and Apply buttons on the dialog should be disabled rather than disabling the menu entry that launches the dialog. Suppose the user launches the dialog and the current context of the application is such that the dialog isn't applicable. Because the dialog is modeless, the user should be able to change the state of the application after the dialog has been launched to put the application in a state where the dialog is now applicable. In contrast, menu entries that launch modal dialogs should be disabled if the dialog isn't currently applicable because the user must dismiss the modal dialog before changing the state of the application. So, if the modal dialog isn't applicable when it's launched, the user has no way to change the state of the application to get it in a state where the dialog would be applicable. See IDREF="54825" TYPE="TITLE""Dialog Modes" in Chapter 10 for a discussion of modal and modeless dialogs.Don't include always-disabled menu entries whose action isn't available in the current version of your application, so that users don't waste time looking for a way to enable the entry. For example, if your application doesn't provide a tutorial, don't include a disabled menu entry for "Tutorial" in the Help menu. Instead, just leave this entry out of the Help menu. If a feature requires certain hardware configurations, don't disable its menu entry; instead, have it display an information dialog stating why the feature isn't available.LBL="" HELPID=""ID="23392"Dynamic Menu EntriesDynamic menu entries are strongly discouraged, especially when there are fewer than four such entries. If you have only a few entries that aren't always available, put them in the menu and disable them when they aren't available. You can use dynamic menu entries in those rare cases when almost everything in a menu can change. For example, the grelnotes program has a Chapter menu that has entries for each chapter in the current set of release notes. When the user loads a new set of release notes, the entries in the Chapter menu are changed to reflect the new chapter titles. Unless a more obvious ordering is suggested by the content of the entries (for example, the order of chapters), alphabetize the entries in a dynamic menu.Dynamic menu entries are discouraged because they make it hard for users to learn what entries are in each of the menus since they're visible only when the application is in a specific state. Users are likely to assume that certain functions aren't available when they don't see menu entries for them as they're scanning your application's menus for the first time. They might not realize that they must first get the application in a particular state before they can even see the action. Even when they've been working with your application for a while, they may not look for certain actions in the menus because they think they've already seen the full contents of the menus, which never included the action that they now want. Also, users become accustomed to the spatial positions of items in menusname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for example, "Cut" is always the second item in the Edit menuname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'and will be frustrated if these positions change.LBL="" HELPID=""Pull-Down Menu GuidelinesIn general, when designing pull-down menus in a menu bar . . . Be sure that users can access most of your application's functionality from the menu entries. At a minimum, make sure that the core functionality can be accessed from the menus.Don't include more than a 10-12 entries in a menu and make sure that all of your entries can fit on the screen at one time.Provide mnemonics for all menus and menu entries. In most cases, the mnemonic should be either the first character of the name or, if there's a conflict, a character that's strongly associated with and included in the name. Use standard mnemonics for standard menus and entries.Limit the use of tear-off menus. Instead, use support windows for groups of controls that users might want to use continuously.When selecting specific menus and entries for an application window . . .Use the standard menus and menu entries as the basis for the overall design of the menu structure. Include all standard menus and entries that are applicable to your application.Include a Help menu as the rightmost menu.Include an "Undo" menu entry, particularly if users can perform actions that destroy or significantly change their data\xd7 .Include an "Exit" menu entry for all main windows and for co-primary windows if users will want to completely exit the application from that co-primary window.Include a "Close" menu entry for all co-primary windows and support windows that have menu bars. Don't provide a "Close" entry for main windows.Include menu entries that repeat the functionality of any pushbuttons on the primary window.Include menu entries for actions that are accomplished using a direct manipulation method or a mouse shortcut such as double-clicking.Include menu entries for accessing all primary and support windows that are children of the current window.Don't include entries for functions that aren't available for the current version of your application.When naming menus . . .Use one-word titles for menus.Use the standard titles for menus (for example, File and Edit) if they're applicable, but change the standard title if this will make the function more clear. Don't use a standard menu title if you're changing the standard definition.When naming menu entries . . .Use the standard names for standard menu entries, but don't use a standard name for a menu entry that doesn't support the standard behavior.Each entry name should be an action word, the value of a parameter, an attribute name, the name of a cascading menu, or the name of a co-primary, support, or dialog window. Don't use more than two words (except for task-oriented Help menu entries), and avoid using graphic labels for menus entries unless the graphics make the functionality more clear.Choose descriptive names that help users learn the functionality of the application. For cascading menus, choose a name that clearly implies the contents of the menu.Add a word if necessary to be sure the entry clearly indicates what entity will be acted upon. For example, you might use "New object" such as "New Folder" or "New Page" rather than just "New."If a menu entry toggles its state, use a checkbox and leave the menu entry name the same for the different states ("Italics"). If this won't be clear, toggle the name so that it indicates what action will be taken if the menu entry is selected ("Show Grid," "Hide Grid").Capitalize the menu entry using the same rules as capitalizing book titles.Display an ellipsis (...) after menu entries that bring up a dialog that requests more information from the user. Don't use ellipses if the dialog simply brings up information that the user requested (for example, a Help dialog).When ordering menus and menu entries . . .Place the standard menus in the standard order (File, Selected, Edit, View, Tools, Options, Help), even if you have renamed any of these menus. Place any new menus between the View and Tools menus.Place standard menu entries in the standard order. "Close" and "Exit" are always at the end of the leftmost menu whether or not this menu is named File.Group menu entries logically. If a new menu entry is related to one of the standard menu entries, place it near that standard menu entry.Place items in the menu first according to the order they will be used, and second according to their frequency of use (with more frequently used items closer to the top of the menu).Alphabetize entries that can be determined only when the user launches the application. If this alphabetized group appears in a menu that contains other entries, place the group at the end of a menu and use a separator between it and the preceding entries.Use radio buttons for mutually exclusive menu entries, and checkboxes for a group of related menu entries, any number of which can be selected at any one time.Use separators when necessary to group itemsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for example, to set off a group of related entries that use radio buttons or checkboxes.Limit the use of cascading menus. Never use more than one level of cascading menus.When selecting keyboard accelerators for menu entries . . .Use standard keyboard accelerators for standard menu entries; don't use any of the standard accelerators for your own entries, even if you're not using those standard entries. Provide keyboard accelerators for the most frequently used menu entries. Don't provide accelerators for all menu entries.Use the key combination <Ctrl>character. Don't use the key combination <Alt>character because this conflicts with mnemonics.For pairs of menu entries where one entry reverses the results of the other entry ("Undo" and "Redo"), use <Ctrl>character for the most frequently used entry and <Shift><Ctrl>character for the other entry where character is the same for both accelerators.Display all characters in keyboard accelerators as uppercase (for example, display <Ctrl>s as "Ctrl+S"). For keyboard accelerators that involve uppercase characters, show the <Shift> key as part of the keyboard accelerator (for example, display <Ctrl>S as "Shift+Ctrl+S").When deciding when to disable menu entries . . .If selecting the menu entry in the current context would give the user an error message, show the menu entry as disabled (dimmed). Avoid using dynamic entries. Rather than removing an entry when it's temporarily unavailable, include it and disable it as appropriate.LBL="" HELPID=""ID="62260"Popup MenusUse popup menus to provide a quick way for users to access the most commonly used functions in the associated work are. For example, you might provide a popup menu containing "Cut," "Copy," "Paste," and "Delete" in a text application. Popup menus should never be the sole access to functions because these menus are hidden. Instead, popup entries typically represent the most commonly used actions from the application window's pull-down menus. (See IDREF="19797" TYPE="TITLE""Menu Traversal and Activation" for a description of how users interact with popup menus.)At most, your application should provide a different popup menu for each main area of the window (that is, for each main field or pane). Note that this differs from the OSF/Motif Style Guide, which allows the availability and content of popup menus to vary depending on the element under the pointer or the selection state of the element. Instead of following this model, you should have one set of entries in the popup menu, and enable and disable each of them as appropriate. With one set of entries, users will become familiar with the popup entries more quickly and won't be confused when entries are sometimes unavailable (see IDREF="23392" TYPE="TITLE""Dynamic Menu Entries" for discussion of how dynamic entries can be confusing to users). LBL="" HELPID=""What to Put in Popup MenusA popup menu should contain a title, followed by a separator and the individual menu entries, as shown in IDREF="25877" TYPE="GRAPHIC"Figure 8-13. The title should be the name of the application or, if the application has more than one popup menu, it should describe the purpose of the menu. Since the entries typically repeat entries found in the pull-down menus, they should be displayed similarly: in the same order, and with the same or very similar names as in the pull-down menu. Ellipses and keyboard accelerators should be included if they're included in the corresponding entry in the pull-down menu, but don't show mnemonics in popup menus.FILE="08.popup.bw" POSITION="INLINE" SCALE="FALSE"LBL="8-12"Figure 8-12 ID="25877"Popup MenuPopup menus generally don't have entries that require radio buttons or checkboxes since these are rarely common enough actions to be included in a popup menu. If you do need to include these kinds of entries in a popup menu, separate them from the rest of the entries with separators and include the radio buttons or checkboxes. See IDREF="67896" TYPE="TITLE""Using Radio Buttons and Checkboxes in Pull-Down Menus" for more information. Popup menus shouldn't contain cascading menus, nor should they be tear-off menus. LBL="" HELPID=""Disabling Popup Menu EntriesAs with pull-down menu entries, if one of the entries in a popup menu is unavailable for selection in the current context, that menu entry should be disabled. It shouldn't be removed from the menu.LBL="" HELPID=""Popup Menu GuidelinesWhen choosing when a popup menu should appear . . .At most, provide a different popup menu for each main area (that is main field or main pane) of the window. Don't change the availability of a popup menu based on what graphical element the pointer is over or based on the selection state of any of the graphical elements.When deciding what to include in a popup menu . . .Include entries for the most commonly used functions from the pull-down menus, and use the same names in the same order as they're displayed in the pull-down menus.Avoid entries that require checkboxes or radio buttons. These are typically not the most commonly used menu functions.Don't make menu entries the sole access to these functions.Don't change the content of the menu based on what graphical element the pointer is over, or based on the selection state or contents of this element. Instead, put all entries in the popup menu for the main area of the window, then enable and disable entries as appropriate. Don't include cascading menus and don't use tear-off menus.When displaying the contents of the popup menu . . .Include a title that's either the name of the application, or if the application has more than one popup menu, that describes the purpose of the menu. Use only one separator, which goes between the title and the individual menu entries.Show ellipses and keyboard accelerators if these are shown in the corresponding pull-down menu entry, but don't show mnemonics.If selecting the menu entry in the current context would give the user an error message, show the menu entry as disabled (dimmed). Don't remove the menu entry when it's temporarily unavailable.LBL="9"ID="95140"ControlsTwo types of controls are described in this chaptername='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'those supported in the standard OSF/Motif environment (such as pushbuttons, lists, and scrollbars), and those unique to the Indigo Magic environment (such as enhanced scales, thumbwheels, and dials). These controls can be used in any window of an application. Each description consists of a general description of the control and guidelines for when to use it, how to label it, and how it should behave.Note that some of the standard controls have been enhanced in the Indigo Magic environment as described in IDREF="47013" TYPE="TITLE""Enhanced Graphics in the Indigo Magic Look" in Chapter 3. To use these enhanced controls in your application, see IDREF="77041" BOOK="IndigoMagic_IG" FILE="04.Widgets.doc" HDG="""Using the New and Enhanced Widgets" in Chapter 4 of the Indigo Magic Desktop Integration Guide. The reference pages in Chapter 9 of the OSF/Motif Style Guide provide details on the behavior of the OSF/Motif controls discussed in this chapter. This chapter covers the following controls:IDREF="18668" TYPE="TITLE""Pushbuttons"IDREF="68004" TYPE="TITLE""Option Buttons"IDREF="22792" TYPE="TITLE""Checkboxes"IDREF="71369" TYPE="TITLE""Radio Buttons"IDREF="72866" TYPE="TITLE""Lists"IDREF="36229" TYPE="TITLE""Text Fields"IDREF="33826" TYPE="TITLE""Scrollbars"IDREF="85716" TYPE="TITLE""Indigo Magic Scales"IDREF="92572" TYPE="TITLE""Labels"IDREF="43846" TYPE="TITLE""File Finder"IDREF="20150" TYPE="TITLE""Thumbwheels"IDREF="97285" TYPE="TITLE""Dials"LBL="" HELPID=""ID="18668"PushbuttonsA pushbutton is a button that invokes an operation. Pushbuttons are rectangular and can be labelled with either text or icons, as shown in IDREF="55921" TYPE="GRAPHIC"Figure 9-1. The basic operations for pushbuttons are described in the section "Other Operations," in the reference page for PushButton in the OSF/MotifStyle Guide, Chapter 9. See IDREF="93963" TYPE="TITLE""Control Areas in Primary Windows" in Chapter 6 for guidelines on using pushbuttons in control areas and tool palettes, and see IDREF="32754" TYPE="TITLE""Standard Dialog Actions" in Chapter 10 for guidelines on using pushbuttons in dialogs.FILE="09.buttons.bw" POSITION="INLINE" SCALE="FALSE"LBL="9-1"Figure 9-1 ID="55921"PushbuttonsLBL="" HELPID=""Pushbutton GuidelinesWhen using pushbuttons . . . In windows with menu bars, use pushbuttons to provide easy access to the most frequently used application-specific functions in the pulldown menus. For primary windows, these pushbuttons appear in the control area of the window.In windows without menu bars, use pushbuttons to access help and to close the window.Use pushbuttons to create tool palettes, either in support windows or in primary windows. Use pushbuttons in the response area of a dialog for the standard actions for that dialog. Always have the pushbutton perform the same operation (although the input to that operation may vary based on what data is currently selected). Don't use the same pushbutton to perform different tasks based on some mode of the application.Use pushbuttons to perform an action; don't use them merely to set state, such as a parameter value in a dialog box. Use checkboxes, radio buttons, or option menus for this purpose.When labelling a pushbutton . . . Use either a text or graphic label that describes the action associated with the button. With text labels, use an active verb describing the operation the button performs. Each text label should be a single, capitalized word.Center the label on the button.If the pushbutton opens a dialog to collect more information from the user before the action represented by the pushbutton can be completed, place an ellipsis after the button label. Don't use an ellipsis if the button opens a dialog simply to display some information to the user as an end result of the operation. This use of ellipses is the same as that described for menu entries in the section IDREF="87916" TYPE="TITLE""Naming Menu Entries in the Pull-Down Menus" in Chapter 8.When displaying pushbuttons . . . If the action associated with a button is temporarily unavailable, disable the button rather than remove it.Don't resize pushbuttons when the window is resized.Don't use dynamic buttons whose labels change to indicate different functionality depending on the current context. Instead, use multiple buttons and disable buttons that represent functionality that's currently unavailable. With multiple buttons, the functionality is obvious even if some of the buttons aren't currently active. With dynamic buttons, the user has to put the application intothe proper context to discover some of the functionality. The one exception to this guideline is the Cancel/Close button used in Dialogs with the Apply button. See IDREF="32754" TYPE="TITLE""Standard Dialog Actions" in Chapter 10 for information on this special case.LBL="" HELPID=""ID="68004"Option ButtonsAn option button is a button that displays an option menu. It allows the user to choose one of the options listed in the menu, and its label changes to reflect the currently selected menu entry. Entries in the option menu represent mutually exclusive values of a parameter. Users interact with option menus according to the model described in IDREF="19797" TYPE="TITLE""Menu Traversal and Activation" in Chapter 8. IDREF="36248" TYPE="GRAPHIC"Figure 9-2 shows an option button and its option menu. Note that the button has a special graphic on it to distinguish it from regular pushbuttons. The basic operations for option buttons are described in the section "Other Operations," in the reference page for OptionButton in the OSF/Motif Style Guide, Chapter 9.FILE="ch09.controls.ras2" POSITION="INLINE" SCALE="FALSE"LBL="9-2"Figure 9-2 ID="36248"Option Button and Option MenuLBL="" HELPID=""Option Button GuidelinesWhen using option buttons . . . Use an option button when you want to offer the user about 5-12 mutually exclusive options; use a list for more than 12 choices. If there's enough space, use radio buttons for fewer than 5 choices. Don't put radio buttons or checkboxes in an option menu.Don't use an option button if the user can select several options at the same timename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'use a list or a set of checkboxes instead.Don't put actions (such as zoom or rotate) in the option menuname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'use pulldown menus or pushbuttons instead.Don't add or delete the choices in the option menu. If the choices must change, use a list.Don't use cascading menus in the option menu. If there are so many items that they don't fit conveniently into an option menu, use a scrolling list instead.Don't use a tear-off entry in an option menu.When labelling an option button . . . Use the default label for the option button itself, which is the current value of the parameter.Use a second label that describes the parameter that the option button controls. This parameter label should be to the left of the option button and should be followed by a colon (:) and a space (see IDREF="36248" TYPE="GRAPHIC"Figure 9-2). This label is typically a noun.When labelling the entries in an option menu . . .Use nouns that indicate the possible values of the parameter being set.When displaying option menus . . . If one of the entries in an option menu is unavailable for selection in the current context, disable the menu entry. Don't remove the entry from the menu. Note that the user should always be able to display the contents of an option menu even if all of the menu entries are currently disabled.Don't include a title in option menus.LBL="" HELPID=""ID="22792"CheckboxesA checkbox is a button with two statesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'on and off. In a group of checkboxes, each can be turned on or off independently. The on state is indicated in the Indigo Magic look by a red check mark, as shown in IDREF="67843" TYPE="GRAPHIC"Figure 9-3. The basic operations for checkboxes are described in the section "Other Operations," in the reference page for CheckButton in the OSF/Motif Style Guide, Chapter 9.FILE="09.checkboxes.bw" POSITION="INLINE" SCALE="FALSE"LBL="9-3"Figure 9-3 ID="67843"CheckboxesLBL="" HELPID=""Checkbox GuidelinesWhen using checkboxes . . . Use checkboxes for single attributes or states that can be turned on and off, or for groups of items where multiple items in the group can be selected independently. (Also see IDREF="67896" TYPE="TITLE""Using Radio Buttons and Checkboxes in Pull-Down Menus" in Chapter 8.)Use checkboxes for groups of less than about six items. When dealing with more than a handful of items, use a list that allows multiple elements to be selected at the same time.Don't use checkboxes for mutually exclusive options. If only one item in a group of items can be selected at a time, use radio buttons instead.Don't use checkboxes for actions; use pushbuttons instead.Don't change the choices in the group based on the current context. If you want to offer a dynamic set of choices, use a list.When labelling checkboxes . . . Give each checkbox a label that describes the attribute, state, or option it controls.Create a group label for each group of checkboxes, and indent the checkboxes below the label. This group label should be a noun that describes the function of the group. When displaying checkboxes . . . Keep checkboxes updated to reflect the current state of the application and the settings of the current selection (if the settings of the checkboxes relate to the current selection). For example, if you have a checkbox for turning underlining on and off and the user selects some text, the checkbox should be updated to reflect whether or not the selection is underlined.Disable checkboxes representing choices that aren't currently available. Don't remove the checkboxes.LBL="" HELPID=""ID="71369"Radio ButtonsA radio button is a button with two statesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'on and off. Unlike checkboxes, radio buttons are always used in groups. Only one of a group of radio buttons can be turned on at any given time. The on state is indicated in the Indigo Magic look by a blue triangle, as shown in IDREF="89261" TYPE="GRAPHIC"Figure 9-4. The basic operations for radio buttons are described in the section "Other Operations," in the reference page for RadioButton in the OSF/Motif Style Guide, Chapter 9.FILE="09.radiobuttons.bw" POSITION="INLINE" SCALE="FALSE"LBL="9-4"Figure 9-4 ID="89261"Radio ButtonsLBL="" HELPID=""Radio Button GuidelinesWhen using radio buttons . . . Use radio buttons in groups, never as single buttons. If you need to use a single button that shows an on/off state, use a checkbox instead.  (Also see IDREF="67896" TYPE="TITLE""Using Radio Buttons and Checkboxes in Pull-Down Menus" in Chapter 8.)Use radio buttons for mutually exclusive options. If more than one item in the group can be selected at a time, use checkboxes or a list instead. Use radio buttons when you want to offer the user fewer than six options. If you have more than six options, or if screen space is extremely limited, use an option button instead. (See the section IDREF="68004" TYPE="TITLE""Option Buttons" earlier in this chapter.) If you have more than 12 options, you should consider using a list where only a single element can be selected at a time. (See the section IDREF="72866" TYPE="TITLE""Lists" later in this chapter.)Don't use radio buttons for actions; use pushbuttons instead.Don't change the choices in a group of radio buttons based on the current context. If you want to offer a dynamic set of choices, use a list because users expect the elements of a list to change occasionally, but they don't expect radio buttons to change.When labelling radio buttons . . . Give each radio button a label that describes the attribute or option it controls.Create a group label for each group of radio buttons, and indent the radio buttons below the label. This group label should be a noun that describes the function of the group.When displaying radio buttons . . . Keep radio buttons updated. If the settings of the radio buttons depend on the current selection, they should be updated when the user makes a new selection so that they reflect the settings of the new selection.Disable radio buttons representing options that aren't currently available. Don't remove the radio buttons.LBL="" HELPID=""ID="72866"ListsA list allows the user to choose from a series of elements. It can allow the user to choose a single element at a time or choose multiple elements at once. Lists should have vertical and horizontal scrollbars when necessary. (See IDREF="33826" TYPE="TITLE""Scrollbars" later in this chapter.) When allowing users to select elements in the list, you should follow the selection guidelines described in IDREF="59818" TYPE="TITLE""Selection" in Chapter 7. IDREF="83859" TYPE="GRAPHIC"Figure 9-5 shows a list with vertical and horizontal scrollbars. The basic operation of lists is described in the section "Other Operations," in the reference page for List in the OSF/Motif Style Guide, Chapter 9.FILE="09.list.bw" POSITION="INLINE" SCALE="FALSE"LBL="9-5"Figure 9-5 ID="83859"ListLBL="" HELPID=""List GuidelinesWhen using lists . . . Use a list when you want to allow the user to choose a single option from a large list (that is, more than 15 options). If you have fewer than 15 options, use either an option button (best for 5-15 options; see IDREF="68004" TYPE="TITLE""Option Buttons" earlier in this chapter) or a set of radio buttons (best for 2-5 options; see IDREF="71369" TYPE="TITLE""Radio Buttons" earlier in this chapter).Use a list when you want to allow the user to choose several options from a list of six or more elements. If you have fewer options, use checkboxes (see IDREF="22792" TYPE="TITLE""Checkboxes" earlier in this chapter).If you want to allow the user to choose elements from a dynamic list of options, use a list regardless of the number of options. (Option menus and groups of checkboxes or radio buttons should represent static lists of options.)When labelling a list . . . Label the list with a noun that indicates the function of the elements in the list.Place the label directly above and either left-aligned with or slightly to the left of the first element of the list.When labelling the list entries . . .If the elements in the list represent operations to perform, they should be active verbs. Otherwise, they should be nouns. When displaying lists . . . When a window using a list is first opened, the currently selected list elements should be highlighted and the list should be scrolled to display these. If multiple elements are selected, scroll the list so that the first selected one appears at the top of the viewing area. See IDREF="59818" TYPE="TITLE""Selection" in Chapter 7.Allow users to select elements in the list according to the selection guideline discussed in IDREF="59818" TYPE="TITLE""Selection" in Chapter 7.Disable list elements that aren't currently available.Allow the list to autoscroll (the default behavior) if the user is making a selection and the selection goes outside the range of the displayed elements. See IDREF="59818" TYPE="TITLE""Selection" in Chapter 7.LBL="" HELPID=""ID="36229"Text FieldsText fields can be single-line or multi-line. Single-line text fields don't have scrollbars, even if all of the text can't be displayed horizontally in the field. Multi-line text fields should have vertical and horizontal scrollbars when necessary. (See IDREF="33826" TYPE="TITLE""Scrollbars" later in this chapter.) Text fields can be either editable or noneditable. Editable and noneditable text fields have different colored backgrounds to indicate to the user whether the information can be changed. These background colors vary depending on what scheme the user has selected (see IDREF="78166" TYPE="TITLE""Schemes for Colors and Fonts" in Chapter 3 for information on schemes).Indigo Magic offers an enhanced text field; it allows the application to select a section of text and flag it with an error status. The error selection shows up with a special background color to distinguish it from an ordinary text selection. For example, a debugger might use the error selection to indicate to the user which section of code was causing an error. In addition, the enhanced text field control allows you to specify the following:both the foreground and background colors of the selected text (See IDREF="59818" TYPE="TITLE""Selection" in Chapter 7 for information on selection.)the background color for text that's marked with an error statuswhether to show the text cursor only when the text component currently has keyboard focus (See IDREF="50040" TYPE="TITLE""Keyboard Focus and Navigation" in Chapter 7 for information on keyboard focus.)The basic operations for text fields are described in the section "Other Operations" in the reference page for Text in the OSF/Motif Style Guide, Chapter 9.LBL="" HELPID=""Text Field GuidelinesWhen using text fields . . . Use single-line, editable text fields to display values of parameters that users can edit.Use single-line, noneditable text fields to display values of parameters that users can't edit, whenever these values either change over time or might need to be selected by the user. If the value doesn't change and the user doesn't need to select it, use a label.Don't use a text field if you need to display and edit pathnames; use the Indigo Magic File Finder instead.Use text fields for values that change over time; don't use labels.When labelling text fields . . . Label each editable or noneditable text field, unless the field represents the bulk of a window and the field's function is clear.For single-line text fields, place the label to the left of the text field, and follow the label with a colon (:) and a space. The label should be vertically centered within the text field.When displaying text fields . . . Use the default selection and highlighting discussed in IDREF="59818" TYPE="TITLE""Selection" in Chapter 7.Allow the user to cancel a text edit in progress by pressing <Esc>. That is, once the user has selected text and started to replace it with new text, <Esc> should cancel any changes that the user has made. Keep text fields updated. When a window using a text field is first opened, the default or current setting (if either exists) for the text field should be shown.Make the text automatically scroll if the user is making a selection and the selection goes outside the range of the displayed elements.When an editable text field can't be edited in the current context but the information is still useful to the user, change it to a noneditable text field. If the information isn't useful to the user (that is, the user doesn't need to know the value and won't need to select it), disable the text field.LBL="" HELPID=""ID="33826"ScrollbarsA scrollbar "scrolls" the data in a viewing region to change the portion of the data that's visible. Scrollbars can be either horizontal or vertical. ("Enhanced Graphics in the Indigo Magic Look" in Chapter 3 describes enhancements to the scrollbar's appearance.) IDREF="11538" TYPE="GRAPHIC"Figure 9-6 shows a scrollbar.FILE="ch09.controls.ras6" POSITION="INLINE" SCALE="FALSE"LBL="9-6"Figure 9-6 ID="11538"ScrollbarA scrollbar includes the scroll region (shown as a trough), which represents the size of the entire scrollable element with arrow buttons at each end. If there's data that can be scrolled, the scrollbar also includes a slider that indicates the relative position and portion of the data currently being displayed. As the user moves the slider, a temporarily indented impression of the slider indicates the position of the slider before the user began moving it. This indented impression disappears when the user releases the mouse button to complete the scroll action. The basic operations for scrollbars are described in the section "Other Operations," in the reference page for ScrollBar in the OSF/Motif Style Guide, Chapter 9.LBL="" HELPID=""Scrollbar GuidelinesWhen using scrollbars . . . Use scrollbars to pan an associated view.Use scrollbars with components that can be resized such that all of the available information contained in the component can't be displayed at one time. Typical scrollable components include work areas in primary windows, lists, multiple line text fields, and data display areas in primary or support windows.Use scrollbars with a list when the number of elements in the list doesn't fit in the viewing region (vertical scrollbar), when the elements are too wide to fit in the viewing region (horizontal scrollbar), or when the window containing the list can be resized such that either of these situations can occur. See IDREF="72866" TYPE="TITLE""Lists" earlier in this chapter for information.Use scrollbars with multi-line text regions when the data can't all be displayed vertically or horizontally or when the window can be resized such that this is true. See IDREF="36229" TYPE="TITLE""Text Fields" earlier in this chapter for information.Don't use scrollbars with single-line text fields. See IDREF="36229" TYPE="TITLE""Text Fields" earlier in this chapter for information.Don't use scrollbars for zooming or for rotation. Use an Indigo Magic thumbwheel instead. See IDREF="20150" TYPE="TITLE""Thumbwheels" later in this chapter.Don't use scrollbars to choose a value in a range; use the Indigo Magic scale instead.When displaying scrollbars . . . Place vertical scrollbars along the right of the element being scrolled, and place horizontal scrollbars along the bottom of the element being scrolled. Keep scrollbars updated. When a window using a scrollbar is first opened, the scrollbar should reflect the current area being displayed in the scrolled region.Update the data in the scrolled area continuously as the user drags the slider along the scroll region. This gives the feeling of direct, continuous control. Don't wait until the user has released the slider to update the data, because users often use the current view of the data to determine when to stop dragging the slider.When a component is being scrolled, don't scroll it beyond the first or last elements. That is, there should be no extra white space before the first element or after the last element. The exception to this rule is scrolling text elements that represent physical pages (for example, in a desktop publishing application).Make all components that use scrollbars automatically scroll when the user makes a selection that goes outside of the data currently being displayed. Also, make the component automatically scroll if the user performs an operation that moves the cursor outside of the current view (for example, if the user inserts or deletes text that moves the cursor outside of the current view). In this case, the view should be automatically scrolled so that the cursor is shown when the operation is finished.When using the <Page Up>, <Page Down>, <Ctrl>-<Page Up>, or <Ctrl>-<Page Down> key sequences to scroll a page at a time, leave one unit of overlap from the previous page to make it easier for the user to preserve the current context. This unit is application-specific; it might be a line of text, an item in a list, a row of icons, or a specfic number of pixels (for example, in a drawing region). By default, this behavior is automatic for IRIS IM list and text components.Remove the slider from the scrollbar when all of the data is currently being displayed. Don't remove the scrollbar or disable it in some other fashion.Allow the user to cancel scroll actions by pressing <Esc>. By default, if the user presses the <Esc> key while dragging the slider along the scroll region, the scroll action is canceled, and both the data and the slider are returned to the position they had before the user initiated the scroll action. LBL="" HELPID=""ID="85716"Indigo Magic ScalesScales can be used either to allow users to change a value in a given range or to display a value in a range. The size of the control shows the size of the range. When the scale is being used to allow users to specify or change a value, the slider indicates the current value in the range and can be dragged by the user. When the scale is being used for display only, there's no slider for the user to control. IDREF="64619" TYPE="GRAPHIC"Figure 9-7 shows the Indigo Magic scale in both modes. The basic operations for scales are described in the section "Other Operations" in the reference page for Scale in the OSF/Motif Style Guide, Chapter 9. For specific details on using the Indigo Magic scale in your application, see the SgScale(SGI) reference page.FILE="ch09.controls.ras7" POSITION="INLINE" SCALE="FALSE"LBL="9-7"Figure 9-7 ID="64619"Indigo Magic ScaleLBL="" HELPID=""Indigo Magic Scale GuidelinesWhen using the Indigo Magic scale . . . Use scales to allow users to change a value in a given range. Use scales in display-only mode to display values that the user can't control. For example, use a display-only scale as a percent-done indicator to show progress in a Working dialog. (See IDREF="17857" TYPE="TITLE""Working Dialogs" in Chapter 10.)Don't use scales for scrolling.When labelling a scale . . . Label it with the current value for the scale.If the function of the scale isn't immediately apparent, give the scale an additional label that indicates its purpose.When displaying scales . . .Keep scales updated. When a window using a scale is first opened, the slider of the scale should show the current setting for the scale control.For sliders where the user can change the value, update the value being manipulated as the user moves the slider. It should give the impression of direct, continuous manipulation. For sliders that also manipulate an object, update the object continuously as well. For sliders that are used only to display values, the slider should be immediately updated to reflect the new value as the value changes. Allow the user to cancel a scale operation by pressing <Esc>. If the user presses the <Esc> key while manipulating the scale, the action should be canceled, and the scale should return to the position it had before the user initiated the action. LBL="" HELPID=""ID="92572"LabelsLabels are noneditable text or graphical objects. They aren't selectable.LBL="" HELPID=""Label GuidelinesWhen using labels . . . Use labels for displaying text information that the user won't need to edit or select.Use labels for labeling controls as described under the individual controls in this chapter.Use labels for labeling groups of controls. When used to label a group of controls, the label should be followed by a colon (:) and a space, and should be placed either to the left of the item in the upper left corner of the group or above and slightly to the left of the item in the upper left corner of the group.Use labels for simple instructions when necessary. Before adding instructions to any of your application windows, however, first try to design some alternatives that might make the instructions unnecessary. For example, if these instructions are necessary because the user interface works in a nonstandard way, redesigning the interface to be more standard is likely to make the instructions unnecessary.Place labels on the background of the window (that is, the part of the window that isn't recessed). When displaying labels . . . Don't change the text or graphic on a label. If this information will change, consider putting it in a noneditable text field instead; users don't expect label text to change.Disable labels when the controls they represent are disabled. Don't disable group labels.LBL="" HELPID=""ID="43846"File FinderThe File Finder is an Indigo Magic control. It allows users to navigate the file hierarchy quickly and to specify directories and files easily, using drag and drop of desktop icons. The File Finder is pictured in IDREF="70546" TYPE="GRAPHIC"Figure 9-8.FILE="ch09.controls.ras8" POSITION="INLINE" SCALE="FALSE"LBL="9-8"Figure 9-8 ID="70546"The File FinderThe File Finder includes several pieces:text fieldname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'allows the user to enter the pathname for a file or directory.drop pocketname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'displays the desktop icon representing the current file or directory whose name is displayed in the text field. A user can also drop a desktop icon into this drop pocket and have the text field automatically update with the pathname of the icon.path navigation barname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'each button represents the directory being displayed below it in the text field. A user can quickly navigate to ancestor directories by clicking on any of these buttons.history buttonname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'similar to an option menu button; maintains a list of directories that the user already visited while using this control. The user can select any of these previously visited directories to return immediately to that directory.For specific details on using the file finder in your application, see the SgFinder(3X) reference page.LBL="" HELPID=""File Finder GuidelinesWhen using the File Finder . . . Use the File Finder when the user needs to enter the pathname of a directory or file. This allows the user to drag and drop desktop icons to specify the file and to navigate the file hierarchy.When a window using a file finder is first opened, the text field in the file finder should show the default or current value of the pathname, if any. This value should also be placed in the history list under the history button.LBL="" HELPID=""ID="20150"ThumbwheelsThe thumbwheel is an Indigo Magic control that allows users to specify or change a value, either in a given range (for instance, when zooming) or in an infinite range (for instance, when rotating a 3D object). Users change the current value by direct manipulation of the wheel (that is, by clicking and dragging). The thumbwheel can also include a "home button" that returns the thumbwheel to a default value. Thumbwheels can be oriented either horizontally or vertically. IDREF="17825" TYPE="GRAPHIC"Figure 9-9 shows a thumbwheel. For specific details on using the thumbwheel in your application, see the SgThumbWheel(3X) reference page.FILE="ch09.controls.ras9" POSITION="INLINE" SCALE="FALSE"LBL="9-9"Figure 9-9 ID="17825"ThumbwheelLBL="" HELPID=""Thumbwheel GuidelinesWhen using thumbwheels . . . Use thumbwheels to change the values of continuous variables (that is, variables that don't have discrete values). For discrete values, consider a scale or dial instead.Use thumbwheels with finite ranges for zooming operations and thumbwheels with infinite range for rotating objects.When a thumbwheel is used to change a value that has a clear default, provide a home button. For example, a Directory View window has a thumbwheel that allows the user to set the size of the desktop icons. Pressing the home button on this thumbwheel sets the icons to their default size.Use thumbwheels when screen real estate is extremely limited.Don't use a thumbwheel for panning; use a scrollbar instead. A scrollbar gives the user much more information about the object being scrolled than a thumbwheel could.When displaying a thumbwheel . . . Update the object or value being manipulated as the user moves the thumbwheel. The thumbwheel should give the impression of direct, continuous manipulation.LBL="" HELPID=""ID="97285"DialsThe dial is an Indigo Magic control that allows users to specify or change a value in a given range. Users change the current value by direct manipulation of the dialname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'by dragging or by clicking on the appropriate tic mark that represents the desired value. The appearance and the behavior of the dial can be modified. For example, the angular range in degrees through which the dial is allowed to rotate and the color of the dial and tic marks can be changed. IDREF="21965" TYPE="GRAPHIC"Figure 9-10 shows two dials with different appearance options. For a complete list of options for dials, and other specific details on using dials in your application, see the SgDial(3X) reference page. FILE="ch09.controls.ras10" POSITION="INLINE" SCALE="FALSE"LBL="9-10"Figure 9-10 ID="21965"DialsLBL="" HELPID=""Dial GuidelinesWhen using dials . . . Use dials as an alternative to scales for setting parameters. Dials are best for numeric parameters where the range of allowable values is small and the values are discrete.When labelling dials . . . Place a label either directly below or directly above the dial, specifying the parameter that the dial controls. When you have a group of dials, place each dial label in the same position relative to its dial (that is, either all the labels should be below the dials or all the labels should be above the dials).When displaying dials . . . When a window using a dial is first opened, the dial should show the current setting.As a dial is rotated, update the value being manipulated to reflect the new value on the dial. The dial should give the impression of direct, continuous manipulation. Also, if the dial is controlling an object, continuously update the object as the dial is manipulated.LBL="10"ID="30192"DialogsDialogs are transient windows that your application uses either to communicate something important to the user (for example, that a pending action could cause some data to be lost), or to obtain a specific piece of information from the user (for example, which file should be opened). Users interact quickly with dialogs and then dismiss them. This chapter covers dialogs in the following sections:IDREF="52846" TYPE="TITLE""Types and Modes of Dialogs" discusses the standard types of dialogs, when to use them, and whether they should be modal or not (that is, whether they should prevent the user from doing anything else until the dialog is dismissed).IDREF="27264" TYPE="TITLE""Designing Dialogs" discusses general dialog design issuesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'such as what window decorations dialogs should have, how the information in dialogs should be laid out, and what the standard actions are (in the form of push buttons). It also covers specific design and content issues for the various types of dialogs listed in the previous section.IDREF="91359" TYPE="TITLE""Invoking Dialogs" describes the most common situations that require dialogs and which types of dialogs to use in them. LBL="" HELPID=""ID="52846"Types and Modes of DialogsDialogs are used to give information to the user or to get information from the user; once they've served their purpose, they go away. Dialogs that give information to the user are instigated by the application; these application-generated dialogs present important messages for the user's immediate attention. Dialogs whose purpose is to get information from the user are displayed as the result of a user action (such as pushing a button or selecting a menu entry). An example of such a user-requested dialog occurs when the user selects "Open..." from the File menu; the application should bring up the Indigo Magic File Selection dialog so that the user can specify which file should be opened.The OSF/Motif Style Guide defines several types of application-generated and user-requested dialogs. The most common of these are listed in IDREF="43029" TYPE="TABLE"Table 10-1, along with a brief description of when each might be used in an application and whether they should be modal or not. IDREF="40008" TYPE="GRAPHIC"Figure 10-1 shows each of the standard OSF/Motif dialogs with the Indigo Magic look, and IDREF="64835" TYPE="GRAPHIC"Figure 10-2 shows the Indigo Magic File Selection dialog. Each of these standard dialogs are discussed in more detail in the rest of this chapter and in their reference pages in Chapter 9 of the OSF/Motif Style Guide. Dialog modes are defined and discussed in the next section (IDREF="54825" TYPE="TITLE""Dialog Modes"). COLUMNS="3"LBL="10-1"Table 10-1 ID="43029"Types of Dialogs, Their Modality, and When to Use ThemLEFT="0" WIDTH="60"Type of DialogLEFT="65" WIDTH="351"When to Use ItLEFT="425" WIDTH="91"ModalityLEFT="0" WIDTH="60"PromptLEFT="65" WIDTH="351"To ask users for specific information.LEFT="425" WIDTH="91"Modeless or modalLEFT="0" WIDTH="60"Error LEFT="65" WIDTH="351"To tell users about an error they've made in interacting with your application.LEFT="425" WIDTH="91"Application-modalLEFT="0" WIDTH="60"Warning LEFT="65" WIDTH="351"When there's an action pending that will cause users to lose data.LEFT="425" WIDTH="91"Application-modalLEFT="0" WIDTH="60"Question LEFT="65" WIDTH="351"To ask users a specific question that they must respond to before continuing to interact 
with the application. Note that although Warning dialogs can also ask users a question, 
that question relates to a pending action that's destructive.LEFT="425" WIDTH="91"Application-modalLEFT="0" WIDTH="60"Working LEFT="65" WIDTH="351"When an operation takes more than 5 seconds to complete. This dialog gives users the 
chance to cancel or stop the operation. Note that you might have to choose one of several 
different platforms as your standard for estimating times of operations. Also note that 
the pointer shape might need to change to the watch if the Working dialog is modal; see 
IDREF="74495" TYPE="TITLE""Standard Pointer Shapes and Colors" in Chapter 11.LEFT="425" WIDTH="91"Modeless or modalLEFT="0" WIDTH="60"Information LEFT="65" WIDTH="351"To give users information that's of immediate importance. This type of dialog should be 
used sparingly; use a status area in one of your primary application windows for the less 
important messages (see IDREF="30855" TYPE="TITLE""Status Areas in Primary Windows" in Chapter 6).LEFT="425" WIDTH="91"ModelessLEFT="0" WIDTH="60"File SelectionLEFT="65" WIDTH="351"To allow users to navigate the file hierarchy and choose a file. Note that the Indigo Magic 
File Selection dialog, which is shown in IDREF="64835" TYPE="GRAPHIC"Figure 10-2, is slightly different from the 
standard OSF/Motif File Selection dialog.LEFT="425" WIDTH="91"ModelessFILE="ch10.dialogs.ras" POSITION="INLINE" SCALE="FALSE"LBL="10-1"Figure 10-1 ID="40008"Sample Prompt, Error, Warning, Question, Working, and Information DialogsFILE="ch10.dialogs.ras2" POSITION="INLINE" SCALE="FALSE"LBL="10-2"Figure 10-2 ID="64835"The Indigo Magic File Selection DialogBoth the Indigo Magic and IRIS IM File Selection dialogs provide lists of the contents of the current directory and a text input field; the Indigo Magic list contains both the files and the subdirectories of the current directory, while the IRIS IM list presents these in two separate lists. The Indigo Magic File Selection dialog also allows users to navigate through the file hierarchy using the drop pocket, path navigation bar, and history button. As discussed in detail in IDREF="43846" TYPE="TITLE""File Finder" in Chapter 9, these components allow users to drop file or directory icons in the drop pocket, traverse to ancestors of the current directory, or return to any directory visited previously. In addition, the Indigo Magic dialog presents a Filter button (rather than the IRIS IM text input field), which brings up a dialog that allows the user to enter the filter string.LBL="" HELPID=""ID="54825"Dialog ModesAs listed in IDREF="43029" TYPE="TABLE"Table 10-1, dialogs can have different modes whereby the application can require the user to respond to the dialog before continuing with other actions in the application. The following are the most commonly used modes defined by OSF/Motif:ModelessModeless dialogs, such as the Indigo Magic File Selection dialog, don't require the user to respond before continuing. The user can interact with any other window associated with the application and with any other application.Primary-modalPrimary-modal dialogs require the user to respond to the dialog before continuing to interact with the dialog's parent window or any other ancestor window. Note that these ancestor windows can't receive mouse or keyboard input until the user has responded to the dialog. Application-modalApplication-modal dialogs require the user to respond to the dialog before continuing to interact with the application. Note that none of the application's windows (except the dialog) can receive mouse or keyboard input until the user has responded to the dialog. An example of this type is a dialog that asks the user for a root password.In addition to these modes, OSF/Motif defines a system-modal dialog that requires the user to interact with the dialog before doing anything else on the system. You shouldn't use system-modal dialogs because your application should never need to restrict users' activities to this degree.Modal dialogs typically show static information, but modeless dialogs should display dynamically updated information as the current state changes. Otherwise, the dialog will become useless. For example, the Indigo Magic File Selection dialog dynamically updates itself if a user changes the file hierarchy while it's displayed; if it didn't, the user could select a file that no longer exists, for example.As listed in IDREF="43029" TYPE="TABLE"Table 10-1, File Selection and Information dialogs should be modeless. Error, Warning, and Question dialogs should be application-modal. Working and Prompt dialogs can be modeless or modal, depending on what they are being used for in the application. For example, the desktop displays a Working dialog when you're copying a large directory from a remote system using a directory view, but you can still do other things in the Directory View while the copy is in progress. In other situations, you might not want to allow user input until your application has completed a particular operation. For example, when a user opens a large folder in MediaMail, no other actions can be performed in that window until the folder has been read in completely.  See IDREF="17857" TYPE="TITLE""Working Dialogs" for details on the design of Working dialogs.LBL="" HELPID=""Guidelines for Using the Various Types and Modes of DialogsWhen choosing the type and mode of a dialog . . .Use a Prompt dialog to ask users for specific information. This dialog can be modeless or modal.Use an application-modal Error dialog to tell users about an error they've made in interacting with your application.Use an application-modal Warning dialog when there's an action pending that will cause users to lose data.Use an application-modal Question dialog to ask users a specific question that they must respond to before continuing to interact with the application. Use a Working dialog when an operation takes more than 5 seconds to complete. This dialog can be modeless or modal.Use a modeless Information dialog to give users information that's of immediate importance. Use this type of dialog sparingly.Use the modeless Indigo Magic File Selection dialog to allow users to navigate the file hierarchy and choose a file. Don't use system-modal dialogs.Use modal dialogs to show static information, and update modeless dialogs dynamically as the current state changes. LBL="" HELPID=""ID="27264"Designing DialogsThis section discusses general guidelines that apply to the design of all dialogsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for example, what window decorations dialogs should have, what size they should be, what information they should display when they first come up, and generally how their information should be laid out. It also describes the standard actions (in the form of pushbuttons) that dialogs should contain. Finally, this section covers guidelines for the content of the specific types of dialogs.Keep in mind that as discussed in IDREF="71076" TYPE="TITLE"Chapter 6, "Application Windows," every dialog is associated with a specific primary or support window (its parent). The parent window should be visible and mapped to the screen so that dialogs work properly across Desks, as noted in IDREF="55393" TYPE="TITLE""Desks" in Chapter 3.LBL="" HELPID=""ID="95730"Decorations, Initial State, and Layout of DialogsAll dialogs should have the window decorations and Window menu entries listed in IDREF="68452" TYPE="TABLE"Table 3-1 and described in IDREF="85826" TYPE="TITLE""Window Decorations and the Window Menu" in Chapter 3. These decorations and menu entries allow the user to:Move a dialog using the title bar. Since 4Dwm doesn't guarantee that a dialog will be placed in a specific location, a user may need to move the dialog to access information in order to figure out the appropriate response to the dialog. Note that a dialog's title bar should follow the guidelines discussed in IDREF="15724" TYPE="TITLE""Rules for Labeling the Title Bar in Windows Other Than Main" in Chapter 3. A proper label allows users to quickly identify the type of dialog and the application to which it belongs.Resize a dialog that contains resizable components such as text input fields and scrolling lists. See IDREF="85826" TYPE="TITLE""Window Decorations and the Window Menu" and IDREF="32339" TYPE="TITLE""Window Size" in IDREF="32339" TYPE="TITLE"Chapter 3 for specific guidelines on when a dialog should be resizable.Note that these window decorations and menu entries don't include operations either for minimizing a dialog (since dialogs can't be minimized independently of their parent window) or for exiting an application from a dialog. When a dialog is opened, its size, placement, keyboard focus, and information displayed should follow these guidelines:The default size should allow all of the components and information to be displayed in their entirety. Users shouldn't have to resize a dialog to see its contents. The dialog should be placed automatically on the screenname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'either near (but not overlapping) any related information in the parent window, or in the center of the parent window (if the contents of the dialog aren't related to the contents of the parent window). For more information on choosing a screen location, see IDREF="11715" TYPE="TITLE""Window Placement" in Chapter 3. The keyboard focus should be in the field with which the user is most likely to want to interact. For example, if there are text input fields, the focus should probably be in one of those fields. In general, dialogs should follow the keyboard focus and keyboard navigation guidelines discussed in IDREF="86870" TYPE="TITLE""Keyboard Focus Policy and Navigation Within a Window" in Chapter 7. The information being displayed in the dialog should always match the current state of the application. If the dialog is modeless, this information should be dynamically updated, as described in IDREF="54825" TYPE="TITLE""Dialog Modes". All dialogs you create should include a response area that contains standard dialog actions (pushbuttons) tailored to the type and purpose of the dialog. The next section (IDREF="32754" TYPE="TITLE""Standard Dialog Actions") discusses what the appropriate buttons are for this area. In addition to the response area, Prompt dialogs should include in their layout an input area that consists of whatever controls are necessary for selecting objects or setting application parameters. Instead of this input area, Error, Warning, Question, Working, and Information dialogs should include a message area, as shown in IDREF="44320" TYPE="GRAPHIC"Figure 10-3. The message area consists of an icon and text region that displays the dialog's message. FILE="ch10.dialogs.ras3" POSITION="INLINE" SCALE="FALSE"LBL="10-3"Figure 10-3 ID="44320"Warning Dialog LayoutNote that dialogs shouldn't have menu bars; they're intended for short, quick user input rather than for accessing lots of functionality. Also, dialogs don't contain secondary work areas; if you need additional work areas, use a support window instead. (See IDREF="30905" TYPE="TITLE""Support Windows" in Chapter 6 for information.) Also note that the pre-designed Indigo Magic File Selection dialog has a somewhat different set of elements and layout than the other types of dialogs. LBL="" HELPID=""ID="32754"Standard Dialog ActionsAll dialogs include a response area that contains a horizontal row of pushbuttons across the bottom of the dialog. The standard dialog pushbuttons (or actions) are Yes, No, OK, Close, Apply, Retry, Stop, Pause, Resume, Clear, Reset, Cancel, and Help, and they should appear in that order. Your dialogs will typically contain some subset of these buttons and possibly additional ones; the additional buttons should appear after the OK and Apply buttons but before the Cancel and Help buttons. All of these standard actions except Clear are defined in the reference page for DialogBox in the OSF/Motif Style Guide. Clear, which is used in Indigo Magic applications, should clear all of the text input fields in the dialog. Note that this differs from the "Reset" action, which resets all controls in a dialog (not just the text fields) to default values.LBL="" HELPID=""ID="59772"Choosing Specific Actions for Your DialogsWhen choosing which of the standard actions to include in your specific dialog, use the guidelines listed in the OSF/Motif Style Guide, Sections 6.2.1.7 and 6.2.4.2, with the following additions and exceptions:Most dialogs should have a Help button. If the situation is stated clearly, you might not need a Help button.Avoid using both OK and Apply on the same dialog because it often confuses users. The only time you should consider using both is when the number of users who will want to make one set of changes, apply them, and close the dialog is equal to the number of users who will want to make and apply multiple sets of changes before closing the dialog.To decide between OK and Apply, determine whether users are more likely to use the dialog to make one set of changes at a time (if so, use OK) or whether they're more likely to want to make and apply changes repeatedly before closing the dialog (in this case, use Apply).If you can't decide which of these scenarios best describes your users, use Apply rather than OK. With Apply, users who want to make a single set of changes must press an extra button (Apply, then Close, instead of just OK), which is at most a minor annoyance. On the other hand, using OK by itself forces users who want to make several sets of changes to re-launch the dialog for each set of changes, which can be annoying. Any dialog that has an Apply button should also include a Cancel/Close button. When the dialog is opened, the button is labelled "Cancel." After the user applies some irreversible change, the label on the button changes to "Close" to inform users that the action is irreversible. This button doesn't indicate whether or not there are pending changes to be applied.Working dialogs should have a Cancel button that allows users to cancel an operation and return the application to the state it was in before the operation began. If you can't return your application to the pre-operation state, you should still allow users to stop the operation at the current point in the processing. It's even better to allow the user a choice of actionsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for example, Pause (with the option of later resuming) and Cancel. By default, pressing the <Esc> key within a dialog is equivalent to clicking a Cancel button. This is true even if the dialog doesn't have an explicit Cancel button.LBL="" HELPID=""Choosing Default ActionsFor many dialogs, you should choose one of the actions in the response area to be the default action. By default, the default pushbutton is visually distinguished from the other buttons (for example, the OK button in IDREF="44320" TYPE="GRAPHIC"Figure 10-3), and it's activated when the user presses the <Enter> key while the dialog is the active window. If other buttons in the response area can accept keyboard focus, they become the default button when they have the focusname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'that is, they're visually distinct from the other buttons, and pressing <Enter> causes them to be activated. When none of these other buttons has the keyboard focus, the default button status returns to the original default button. The following bullets describe common default actions for certain types of dialogs:The default action for Information dialogs, which typically have buttons only for OK and Help, should be OK.The default action for Question, Warning, Error, and any other dialogs that contain buttons but no text fields should be the response that users are most likely to select. For example, a Warning dialog that asks, "Do you really want to do this destructive action?" should have the affirmative response as the default action. Note that as discussed in the next section, IDREF="98282" TYPE="TITLE""Labeling Dialog Buttons," each button name should clearly indicate the specific action that will occur if that button is clicked.The default action for dialogs that have only one text field and no other controls than the buttons in the response area (such as the File Selection and Prompt dialogs) should be the action that the user is most likely to select after entering a text string.Dialogs that contain multiple text fields should not have a default action since many applications require users to press <Enter> after entering data in a text field. Users tend to press <Enter> regardless of whether they have to, and they expect that action to ensure that their data is entered; they don't expect that action to invoke the dialog's default action. LBL="" HELPID=""ID="98282"Labeling Dialog ButtonsWhen labeling dialog buttons, use the OSF/Motif standard names except in the following cases:Replace the "Yes" and "No" labels in Warning and Question dialogs with button names that clearly indicate the specific action that will occur if the button is clicked. The buttons replacing Yes and No perform the action and close the dialog. As an example, consider the Warning dialog shown in IDREF="52310" TYPE="GRAPHIC"Figure 10-4. FILE="warning.save.bw" POSITION="INLINE" SCALE="FALSE"LBL="10-4"Figure 10-4 ID="52310"Warning Dialog With Save, Discard, and Cancel ButtonsReplace the "OK" or "Apply" labels in Prompt or Warning dialogs with button names that clearly indicate the specific action that will occur if the button is clicked (for example, Open, Save, Print). You shouldn't replace these names when the button is used for more than one purposename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for example, when the file browser is used to specify a name for a new file, the OK button can be used to both name the file and display the contents of a directory.You also shouldn't replace either of these names on those rare instances when OK and Apply are used together in a Prompt dialog.LBL="" HELPID=""Content of Specific Types of DialogsIn addition to the general guidelines discussed in the two previous sections (IDREF="95730" TYPE="TITLE""Decorations, Initial State, and Layout of Dialogs" and IDREF="32754" TYPE="TITLE""Standard Dialog Actions"), you should follow the more specific guidelines for the different types of dialogs presented in this section. (The dialog types are defined in IDREF="43029" TYPE="TABLE"Table 10-1.)LBL="" HELPID=""Prompt DialogsPrompt dialogs use a variety of controls to collect information from the user, including text input fields, a list of all possible choices, radio buttons, checkboxes, and option menus. Try to collect this information in related chunksname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'that is, avoid collecting unrelated pieces of information in the same dialog, and don't launch multiple dialog boxes one right after the other to collect several pieces of information if these pieces are frequently collected at the same time.LBL="" HELPID=""Error DialogsAll Error dialogs should include a description of the error, step-by-step instructions for how to recover from it (or a pointer to information on how to recover from it if the instructions are long), and a pointer to more information about why the error might have occurred. If the error involves a specific entity (for instance, a file, user, or host), name the entity in the error message, as shown in IDREF="17440" TYPE="GRAPHIC"Figure 10-5. Invoke Error dialogs only when they're directly relevant to the user; for example, don't tell the user that the printer is out of paper until the user has a job in the queue. FILE="error.host.bw" POSITION="INLINE" SCALE="FALSE"LBL="10-5"Figure 10-5 ID="17440"Error Dialog With Specific EntityLBL="" HELPID=""Warning DialogsWarning dialogs should clearly state what data is likely to be lost and why, and they should give the user a chance to cancel the action.LBL="" HELPID=""Question DialogsLimit your use of Question dialogs to those situations where the user couldn't have provided the information in advance. Also, don't use Question dialogs for questions that relate to a pending destructive actionname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for these cases, use Warning dialogs instead.LBL="" HELPID=""ID="17857"Working DialogsFor Working dialogs, you should dynamically indicate how much of the operation is complete with the Indigo Magic scale used as a percent-done indicator, as shown in IDREF="82759" TYPE="GRAPHIC"Figure 10-6.  (See IDREF="85716" TYPE="TITLE""Indigo Magic Scales" in Chapter 9 for more information about these indicators.) FILE="ch10.dialogs.ras6" POSITION="INLINE" SCALE="FALSE"LBL="10-6"Figure 10-6 ID="82759"Working Dialog with Indigo Magic ScaleAs described earlier in this chapter in IDREF="59772" TYPE="TITLE""Choosing Specific Actions for Your Dialogs," Working dialogs should include at least one way to interrupt the task in progress. If the dialog is modal, you should also switch from the general-purpose pointer to the watch pointer in the dialog's parent window. If for some reason you're unable to include any buttons in the Working dialog (such as Cancel, Pause, Resume, or Help), you should switch to the watch pointer in the Working dialog to indicate that user input will be ignored while the operation is in progress. See IDREF="74495" TYPE="TITLE""Standard Pointer Shapes and Colors" in Chapter 11 for more information about the watch pointer.LBL="" HELPID=""Guidelines for Designing DialogsWhen choosing the window decorations, initial state, and layout of dialogs . . .Associate every dialog with a primary or support window (its parent) that's mapped to the screen.Use the window decorations and Window menu entries listed in IDREF="68452" TYPE="TABLE"Table 3-1 and described in IDREF="85826" TYPE="TITLE""Window Decorations and the Window Menu" and IDREF="15724" TYPE="TITLE""Rules for Labeling the Title Bar in Windows Other Than Main" in Chapter 3. Have the default size large enough to allow all of the components and information to be displayed in their entirety. Place the dialog on the screen either near (but not overlapping) any related information in the parent window, or in the center of the parent window if the contents of the dialog aren't related to the contents of the parent window. Locate the initial keyboard focus in the field with which the user is most likely to want to interact. Be sure the information being displayed in the dialog matches the current state of the application. If the dialog is modeless, update this information dynamically. Include a response area that contains standard dialog actions (pushbuttons) tailored to the type and purpose of the dialog. Also include an input area that consists of whatever controls are necessary for selecting objects or setting application parameters in Prompt dialogs. Include a message area in Error, Warning, Question, Working, and Information dialogs.Don't include secondary work areas; if you need additional work areas, use a support window instead.Don't include menus. If the dialog includes so much functionality that menus are necessary, you should probably use a support window.When choosing pushbutton actions for dialogs . . .Use a subset of the standard dialog actions (Yes, No, OK, Close, Apply, Retry, Stop, Pause, Resume, Clear, Reset, Cancel, and Help), and have them appear in that order. If you include additional buttons, they should appear after the OK and Apply buttons but before the Cancel and Help buttons. Include a Help button unless the situation is explained thoroughly in the dialog.Avoid using both OK and Apply on the same dialog.To decide between OK and Apply, determine whether users are more likely to use the dialog to make one set of changes at a time (if so, use OK), or whether they're more likely to want to make and apply changes repeatedly before closing the dialog (in this case, use Apply).Include a Cancel/Close button on any dialog that has an Apply button. Include a Cancel button on Working dialogs and, if possible, a Pause button (with the option of later resuming). When choosing and creating default actions . . .Whenever appropriate, choose one of the actions to be the default action. Have OK be the default action for Information dialogs (which typically have buttons only for OK and Help).Have the response that users are most likely to select be the default action for Question, Warning, Error, and any other dialogs that contain buttons but no text fields. Have the response that users are most likely to select after entering a text string be the default action for dialogs that have only one text field. Use no other controls than the buttons in the response area (such as the File Selection and Prompt dialogs).Don't have a default action for dialogs that contain multiple text fields.When labeling dialog buttons . . .Replace the "Yes" and "No" labels in Warning and Question dialogs with button names that clearly indicate the specific action that will occur if the button is clicked. Replace the "OK" or "Apply" labels in Prompt or Warning dialogs with button names that clearly indicate the specific action that will occur if the button is clicked, unless the button is used for more than one purpose, or in the rare instance that "OK" and "Apply" are used together in a Prompt dialog.In all other cases, use the OSF/Motif standard names.When deciding what content to include in specific types of dialogs . . .Use Prompt dialogs to collect information in related chunksname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'that is, avoid collecting unrelated pieces of information in the same dialog, and don't launch multiple dialog boxes sequentially to collect several pieces of information if these pieces are frequently collected at the same time.Include a description of the error, step-by-step instructions for how to recover from it, and a pointer to more information in Error dialogs. If the error involves a specific entity (for instance, a file, user, or host), name the entity in the error message. Invoke Error dialogs only when they're directly relevant to the user; for example, don't tell the user that the printer is out of paper until the user has a job in the queue. State what data is likely to be lost and why, and give the user a chance to cancel the action in Warning dialogs.Limit your use of Question dialogs to those situations where the user couldn't have provided the information in advance.  Don't use Question dialogs for questions that relate to a pending destructive actionname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for these cases, use Warning dialogs instead.Dynamically indicate how much of the operation is complete with the Indigo Magic scale used as a percent-done indicator in Working dialogs.Switch from the general-purpose pointer to the watch pointer in the parent window of a modal Working dialog. LBL="" HELPID=""ID="91359"Invoking DialogsUsers expect to encounter dialogs in certain situations. This section describes the most common such situations and gives an example of the dialog your application should provide if users can encounter this situation when interacting with your application. (For more information about the standard menu entries referred to in this section, see IDREF="12088" TYPE="TITLE""Standard Menus" in Chapter 8.)Since dialogs are designed to get the user's attention, overuse of them will be distracting to the user. Similarly, application-generated dialogs shouldn't be used to provide general status information; you should use a status area in the associated primary or support window instead (see IDREF="30855" TYPE="TITLE""Status Areas in Primary Windows" in Chapter 6). LBL="" HELPID=""ID="61823"Invoking Dialogs When Manipulating FilesUsers expect to be prompted with a dialog whenever they choose a menu entry that includes an ellipsis. These dialogs prompt the user for information that's necessary before the action can be completed, as described in the following common examples."Open..." from the File (or leftmost) menu should display the Indigo Magic File Selection dialog shown in IDREF="64835" TYPE="GRAPHIC"Figure 10-2. The first time this dialog is opened for an application, it should show the current working directory and no specific file. Subsequently, it should come up in the state it was last in when the user dismissed itname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'that is, it should show the last directory the user traversed to, and the file that the user opened the last time should be selected. (See IDREF="43029" TYPE="TABLE"Table 10-1 and IDREF="64835" TYPE="GRAPHIC"Figure 10-2 earlier in this chapter for more information about the Indigo Magic File Selection dialog.)"Save As..." from the File (or leftmost) menu should display the Indigo Magic File Selection dialog. If the file being saved doesn't exist yet, the dialog should show the current working directory and no specific file. If the file exists, the dialog should show that file's directory, and the current name of the file should be selected. If the user uses "Save As..." to change the name of an existing file, your application should create a copy of the existing file with the new name, close the previous file, and open the new file. (See IDREF="38726" TYPE="TITLE""File Menu" in Chapter 8.)When users open, close, or save changes to files, they should be prompted with the Warning dialog shown in IDREF="52310" TYPE="GRAPHIC"Figure 10-4 whenever these actions will cause data to be lost. The standard situations in which this can arise include the following (see IDREF="67644" TYPE="TITLE""Application Models" in Chapter 6 for a discussion of the single- and multiple-document application models described in the following paragraphs):In an application that allows only one document to be open at a time, when the user chooses to open another (new or existing) document and there are unsaved changes in the currently opened document. The user can open another document by selecting "New" from the File menu, by selecting "Open..." from the File menu and using the File Selection dialog, or by choosing a file from the "Reopen" cascading menu in the File menu.When the user chooses "Close" from the File menu in a co-primary window, and the co-primary window contains data that will be lost if the window is closed. This situation is especially common in applications that support multiple open documents because for these applications, closing a co-primary window is equivalent to closing a file.When the user chooses "Exit" from the File menu, and at least one open co-primary window contains data that will be lost if the application is exited. For applications that support multiple open documents, the user should be prompted with a separate dialog box for each file that's currently open and has unsaved changes.Other common file-related situations that require dialogs include:When the user chooses "Save" from the File menu, and the current file is untitled. In this situation, the user should be prompted with the Indigo Magic File Selection dialog, as described above for "Save As...."When the user is interacting with the File Selection dialog and chooses a filename that already exists. In this situation, the user should be prompted with the Warning dialog shown in IDREF="53895" TYPE="GRAPHIC"Figure 10-7. FILE="warning.overwrite.bw" POSITION="INLINE" SCALE="FALSE"LBL="10-7"Figure 10-7 ID="53895"Warning Dialog for Overwriting a FileWhen the user chooses "Revert" from the File menu, and the file currently has unsaved changes. In this situation, the user should be prompted with the Warning dialog shown in IDREF="53895" TYPE="GRAPHIC"Figure 10-7. FILE="warning.revert.bw" POSITION="INLINE" SCALE="FALSE"LBL="10-8"Figure 10-8 ID="53895"Warning Dialog for Reverting to Previous VersionLBL="" HELPID=""ID="16318"Other Situations for Invoking DialogsWhen the user chooses "Product Information" from the Help menu, you should display an Information dialog like the one shown in IDREF="16543" TYPE="GRAPHIC"Figure 10-9. (See IDREF="33310" TYPE="TITLE""Product Information" in Chapter 4 for some suggestions about what to include in Product Information dialogs.)FILE="10.product.info.bw" POSITION="INLINE" SCALE="FALSE"LBL="10-9"Figure 10-9 ID="16543"Product Information DialogWhen users initiate an operation that takes more than five seconds to complete, your application should display a Working dialog. In this situation, the user should be prompted with the Working dialog shown in IDREF="82759" TYPE="GRAPHIC"Figure 10-6. Note that you might have to choose one of several different platforms as your standard for estimating times of operations. See IDREF="17857" TYPE="TITLE""Working Dialogs" earlier in this chapter for more information about the content of these dialogs.When the user chooses "Paste" from the Edit menu and there's nothing currently on the clipboard to be pasted, bring up an Information dialog that says "The clipboard is empty" and that contains the single button "OK." (See IDREF="94339" TYPE="TITLE""Edit Menu" in Chapter 8.)LBL="" HELPID=""Guidelines for Invoking DialogsWhen determining when to display a dialog and which dialog to display . . .Limit the use of dialogs to those cases when they're absolutely necessary. Don't use dialogs to provide general status informationname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'use a status area in the associated primary or support window instead. Invoke a dialog whenever users choose a menu entry that includes an ellipsis.Display the Indigo Magic File Selection dialog when the user chooses "Open..." from the File menu. The first time this dialog is opened, it should show the current working directory and no specific file. Subsequently, it should come up in the state it was last in when the user dismissed it.Display the Indigo Magic File Selection dialog when the user chooses "Save As..." from the File menu. If the file being saved doesn't exist yet, the dialog should show the current working directory and no specific file. If the file exists, the dialog should show that file's directory, and the current name of the file should be selected. When users open, close, or save changes to files, prompt them with a Warning dialog whenever these actions will cause data to be lost:In an application that allows only one document to be open at a time, when the user chooses to open another (new or existing) document and there are unsaved changes in the currently opened document. (For example, the user chooses "New," "Open," or "Reopen" from the File menu.)When the user chooses "Close" from the File menu in a co-primary window, and the co-primary window contains data that will be lost if the window is closed.When the user chooses "Exit" from the File menu, and at least one open co-primary window contains data that will be lost if the application is exited. For applications that support multiple open documents, prompt the user with a separate dialog box for each file that's currently open and has unsaved changes.Prompt users with the File Selection dialog when they choose Save from the File menu and the current file is untitled. The behavior is the same as the "Save As..." entry in this situation.Prompt users with a Warning dialog when they're interacting with the File Selection dialog and they choose a filename that already exists. Prompt users with a Warning dialog when they choose "Revert" from the File menu and the file currently has unsaved changes. Display an Information dialog when a user chooses the "Product Information" entry from the Help menu.Display the Working dialog when users initiate an operation that takes more than five seconds to complete. Note that you might have to choose one of several different platforms as your standard for estimating times of operations.LBL="11"ID="58675"User FeedbacklYour application should supply feedback to users so that they know it's working and what it's doing. This chapter covers the following topics:ID="ch11.feedback1"ID="ch11.feedback2"IDREF="60318" TYPE="TITLE""Types of Feedback" briefly describes various types of feedback users expect your application to provide; it also tells you where to look in this guide for more information about each type of feedback.IDREF="15568" TYPE="TITLE""Pointer Shapes and Colors" discusses when to use each of the standard pointer shapes and provides guidelines for designing your own pointer shapes.LBL="" HELPID=""ID="60318"Types of FeedbackYour application should provide feedback to users using the techniques described in this section. Note that most of these techniques are covered in other chapters of this guide, as indicated; these other chapters also include the explicit checklist guidelines you should follow, so they're not repeated here.LBL="" HELPID=""Provide Graphic FeedbackAppropriate desktop icons for your application's executable and data files allow users to readily identify your application, files that were created using your application, and the current state of the application (that is, running or not running). You should design executable and data file icons to provide this sort of graphic feedback, as discussed in ID="ch11.feedback3"ID="ch11.feedback4"IDREF="94988" TYPE="TITLE"Chapter 2, "Icons."The Indigo Magic look includes graphic modifications that were made to standard IRIS IM in order to improve the level of user feedback. For instance, locate highlight visually indicates which components are live functional objects and which are passive graphics. In addition, scrollbars were redesigned to keep track of their initial positions, and radio buttons and checkboxes show their state more emphatically. Your application should use the Indigo Magic look, which is discussed in ID="ch11.feedback5"ID="ch11.feedback6"ID="ch11.feedback7"ID="ch11.feedback8"ID="ch11.feedback9"IDREF="24763" TYPE="TITLE""The Indigo Magic Look: Graphic Features and Schemes" in Chapter 3.Users expect the pointer to change shape to reflect the current state of the windowname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for example, when the application is busy processing and can't accept keyboard or mouse input, the pointer should change to a watch. Guidelines for pointer shapes are discussed later in this chapter, in ID="ch11.feedback10"IDREF="15568" TYPE="TITLE""Pointer Shapes and Colors."As users select data in a window, that data should be highlighted to show what's included in the current selection. The data should remain highlighted even when the window isn't the currently active window. See ID="ch11.feedback11"IDREF="93501" TYPE="TITLE""Highlighting a Selection" in Chapter 7 for more information about highlighting selections. LBL="" HELPID=""Keep Information Up to DateAs users set particular values in components such as radio buttons, check boxes, lists, and option menus, your application should always indicate the current values so that the user knows what they are. For example, the Language control panel highlights the current values for "Locations" and "Keyboards" in the two corresponding lists. Radio buttons, checkboxes, lists, and option menus are discussed in more detail in ID="ch11.feedback12"IDREF="95140" TYPE="TITLE"Chapter 9, "Controls."Even if users can change values or data without using an explicitly provided component, your application should still endeavor to display the current information. For instance, users can change the file hierarchy using the shell; if your application displays information affected by such a change (such as a directory view), the display should update dynamically as the user makes the change. (See IDREF="17476" TYPE="TITLE""File Alteration Monitor (FAM)" in Chapter 4 for more information about using the Indigo Magic FAM service to monitor changes to the file system.) If it's impossible or if it would have a significantly adverse effect on your application's performance to make the display dynamic, choose a design that looks static. For example, you might use label text, which looks like it's a permanent part of the background, rather than text fields, which look like they should be updated constantly. The desktop uses this strategy for the "business cards" that are displayed when a user double-clicks a person icon.When component settings apply to a specific object, the displayed components should reflect the values for the currently selected object (if there is one). For example, if you select some text in an IRIS Showcase file, the "Font Family," "Font Size," Bold/Italic/Underline, and color options in the Master Gizmo are updated to display the characteristics of the selected text. LBL="" HELPID=""ID="21977"Provide Messages to the UserIn addition to providing immediate graphic feedback through your application's icons, components, and pointers, you should give users textual messages that describe your application's status. Keep in mind that by default the window manager for the Indigo Magic Desktop, ID="ch11.feedback13"ID="ch11.feedback14"ID="ch11.feedback15"4Dwm, sends stdout and stderr messages to the Console window, which users typically keep minimized. (Users can choose to have stderr messages appear in a dialog box by using the Desktop Settings control panel available from the Desktop->Customize cacading menu in the Toolchest, and they can of course un-minimize the Console window.) Because of these default settings, you can't be sure that users will notice messages sent to stdout and stderr, so you should use dialogs or status areas in your application instead. In particular, you should use dialogs to provide warning messages, error messages, and work-in-progress feedback, as discussed in ID="ch11.feedback16"ID="ch11.feedback17"ID="ch11.feedback18"IDREF="30192" TYPE="TITLE"Chapter 10, "Dialogs." You should also define an area on primary windows for status messages in the cases discussed in IDREF="30855" TYPE="TITLE""Status Areas in Primary Windows" in Chapter 6. Finally, you should change the label (or possibly the image) of your application's minimized window when appropriate to provide feedback; IDREF="87201" TYPE="TITLE""Minimized Windows" in Chapter 3 discusses when to use this technique. LBL="" HELPID=""General User Feedback GuidelinesProvide graphic feedback with appropriate desktop icon designs, by using the Indigo Magic look, by changing pointer shapes appropriately, and by highlighting selected text.Be sure your application displays up-to-date informationname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in controls and components (display the settings that correspond to the currently selected object or the current values), and in information displays (such as directory views). If the information being displayed can't be dynamically updated, choose a design that looks static.Provide textual message to the user through dialogs, through status areas on your primary windows, and by changing the label of your minimized window when appropriate.LBL="" HELPID=""ID="15568"Pointer Shapes and ColorsYour application should use different pointer shapes to indicate when it's busy or in a particular mode, or when one of its windows isn't accepting input. This section discusses when to use the standard pointer shapes and when and how to design new pointer shapes.ID="ch11.feedback19"LBL="" HELPID=""ID="74495"Standard Pointer Shapes and ColorsThe OSF/Motif Style Guide defines several standard pointer shapes. Your application should use these standard shapes for the purposes described in IDREF="55346" TYPE="TABLE"Table 11-1; the table also notes any additions and exceptions to the OSF/Motif policies for using these pointers. If your application requires functionality beyond what's described below, you should design your own new pointers, as described in IDREF="29040" TYPE="TITLE""Designing New Pointer Shapes," rather than extend the functionality of these standard ones. COLUMNS="4"LBL="11-1"Table 11-1 ID="55346"Standard Pointer Shapes and ColorsLEFT="0" WIDTH="33"PointerLEFT="40" WIDTH="58"NameLEFT="105" WIDTH="148"PurposeLEFT="260" WIDTH="262"Additions and Exceptions to OSF/Motif StyleLEFT="0" WIDTH="33"FILE="arrowleft.bw" POSITION="TBLCELL" SCALE="FALSE"LEFT="40" WIDTH="58"upper-left 
arrowID="ch11.feedback20"LEFT="105" WIDTH="148"General-purpose pointer, used for 
selecting data, setting the values of 
controls, and initiating actions (for 
example, by clicking on a button).LEFT="260" WIDTH="262"In the Indigo Magic environment, this pointer should be red with 
a white outline (rather than black with a white outline) so that it's 
easier to see against most typical user-customized background 
colors and patterns.LEFT="0" WIDTH="33"FILE="arrowright.bw" POSITION="TBLCELL" SCALE="FALSE"LEFT="40" WIDTH="58"upper-right 
arrowID="ch11.feedback21"LEFT="105" WIDTH="148"Indicates that a menu is being 
displayed and that the application is 
waiting for the user to select a menu 
item or remove the menu.LEFT="260" WIDTH="262"This is the default pointer when a menu is pulled down from a 
menu bar, popped up from the right mouse button, or displayed 
from an option menu button. (See IDREF="98597" TYPE="TITLE"Chapter 8, "Menus," for details 
on the various types of menus.) LEFT="0" WIDTH="33"FILE="watch.bw" POSITION="TBLCELL" SCALE="FALSE"LEFT="40" WIDTH="58"watchID="ch11.feedback22"LEFT="105" WIDTH="148"Indicates that an operation is in 
progress in the area, and that all 
mouse-button and keyboard events 
are ignored in the area. LEFT="260" WIDTH="262"Use this pointer instead of the hourglass because the watch is a 
more universally recognized symbol for time. Also, use this 
pointer if you estimate that the operation generally takes more 
than 3 seconds. (Note that you might have to choose one of 
several different platforms as your standard for estimating times 
of operations.) For less than 3 seconds, maintain the current 
pointer shape to avoid distracting users. For more than 5 seconds, 
use a work-in-progress dialog in addition to the watch pointer. 
(See IDREF="30192" TYPE="TITLE"Chapter 10, "Dialogs.")LEFT="0" WIDTH="33"FILE="ibeam.bw" POSITION="TBLCELL" SCALE="FALSE"LEFT="40" WIDTH="58"I-beam 
pointerID="ch11.feedback23"LEFT="105" WIDTH="148"Indicates that your application is in 
text-editing mode. (Note that this I-beam pointer is different from the 
I-beam text insertion cursor.)LEFT="260" WIDTH="262"OSF/Motif allows this pointer to be used for indicating that the 
pointer is over an editable text component in a window that uses 
implicit focus. Since you should use explicit focus when moving 
within a window, you don't need the I-beam pointer for this 
purpose. However, you can use it to indicate that your 
application is in text-editing mode; this might be useful if your 
application can edit both text and graphics, for example.LEFT="0" WIDTH="33"FILE="question.bw" POSITION="TBLCELL" SCALE="FALSE"LEFT="40" WIDTH="58"question 
markID="ch11.feedback24"LEFT="105" WIDTH="148"Indicates that the user is in context-
sensitive help mode and needs to 
click on an area of the screen to 
specify the exact help information 
requested.LEFT="260" WIDTH="262"noneLEFT="0" WIDTH="33"FILE="crosshair.bw" POSITION="TBLCELL" SCALE="FALSE"LEFT="40" WIDTH="58"cross hairID="ch11.feedback25"LEFT="105" WIDTH="148"Used to make fine position 
selections; for example, to indicate a 
pixel to fill in a drawing program, or 
to select the endpoint of a line.LEFT="260" WIDTH="262"noneLEFT="0" WIDTH="33"FILE="resize.bw" POSITION="TBLCELL" SCALE="FALSE"LEFT="40" WIDTH="58"resizeID="ch11.feedback26"LEFT="105" WIDTH="148"Indicates positions when resizing an 
area.LEFT="260" WIDTH="262"noneLEFT="0" WIDTH="33"FILE="fourdirection.bw" POSITION="TBLCELL" SCALE="FALSE"LEFT="40" WIDTH="58"4-directional 
arrowID="ch11.feedback27"LEFT="105" WIDTH="148"Indicates that either a move 
operation or a resize operation 
(before the resize direction has been 
determined) is in progress.LEFT="260" WIDTH="262"noneThe OSF/Motif Style Guide defines a few pointers that you shouldn't need to use: Hourglassname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Use the watch instead of the hourglass because the watch is a more universally recognized symbol for time.ID="ch11.feedback28"Xname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Reserved for use by the window manager.ID="ch11.feedback29"OSF/Motif also defines a caution pointer to be used for indicating that all mouse and keyboard events are ignored in the area until the user performs an expected action in a primary modal or application modal dialog. You can use this pointer in your application if you want; note that many Indigo Magic applications don't use it because at this time there's no automatic support for it in IRIS IM. (See IDREF="54825" TYPE="TITLE""Dialog Modes" in Chapter 10 for more information on primary and application modal dialogs.)LBL="" HELPID=""ID="29040"Designing New Pointer ShapesYou might find it necessary to design new pointer shapes that represent functionality specific to your application, particularly if your application has modes. In these cases, the pointer shape can be used to indicate the current mode. For example, a paint program typically has different tools or modes that the user can select; the pointer shape might resemble a specific brush style, spray paint can, eraser, or I-beam pointer, depending on the tool selected. When you design new pointer shapes, follow the guidelines listed in the reference page on Pointer Shapes in the ID="ch11.feedback30"OSF/Motif Style Guide: create a pointer shape that gives a hint about its purpose and is easy to see, avoid shapes that create visual clutter, and make its hotspot easy to locate. (The hotspot identifies where mouse actions occur.) LBL="" HELPID=""Pointer Shapes and Colors GuidelinesWhen deciding which pointers to use in your application . . . Use the standard pointers when possible.Use the upper-left pointing arrow as a general-purpose pointer; this pointer should be red with a white outline.Use the upper-right pointing arrow when a menu is pulled down from a menu bar, popped up from the right mouse button, or displayed from an option menu button. Use the watch pointer for operations that take more than 3 seconds. (For less than 3 seconds, maintain the current pointer; for more than 5 seconds, also use a work-in-progress dialog.)Use the I-beam pointer to indicate that your application is in a text-editing mode, but don't use it to indicate implicit focus over a text object within a window.Use the question mark to indicate that the user is in context-sensitive help mode.Use the sighting pointer (crosshair) to make fine position selections.Use resize pointers to indicate positions when resizing an area.Use the 4-directional arrow to indicate that either a move operation or a resize operation is in progress.Don't use the hourglass pointer; use the watch pointer instead.Don't use the X pointer (it's reserved for the window manager).Don't assign new functionality to the standard pointer shapes; instead, design your own new pointer shape.When designing new pointer shapes . . . Create a pointer shape that gives a hint about its purpose.Make the shape easy to see.Make the hotspot easy to locate.Avoid shapes that would create visual clutter.LBL="A"ID="12454"Summary of GuidelinesThis appendix contains an all-inclusive list of the guidelines for designing applications for the Indigo Magic Desktop Environment. Its purpose is to serve as a master checklist and summary; to understand the rationale for these guidelines, refer back to the chapters of this manual where they are discussed in detail. The guidelines are grouped as follows: IDREF="69686" TYPE="TITLE""Icon Appearance Design Guidelines"IDREF="34925" TYPE="TITLE""Icon Behavior Guidelines"IDREF="96551" TYPE="TITLE""Application Icon Accessibility Guidelines"IDREF="26903" TYPE="TITLE""Indigo Magic Look Guidelines"IDREF="57728" TYPE="TITLE""Application Window Characteristic Guidelines"IDREF="26715" TYPE="TITLE""Guidelines for Keyboard Focus Across Windows"IDREF="88857" TYPE="TITLE""Minimized Window Guidelines"IDREF="54822" TYPE="TITLE""Desks Guidelines"IDREF="44643" TYPE="TITLE""Session Management Guidelines"IDREF="19019" TYPE="TITLE""Software Installation Guideline"IDREF="27292" TYPE="TITLE""Guidelines for Designing Online Help"IDREF="42669" TYPE="TITLE""Guidelines for Creating SGIHelp Content"IDREF="86960" TYPE="TITLE""Desktop Variables Guidelines"IDREF="27457" TYPE="TITLE""File Monitoring Guideline"IDREF="74743" TYPE="TITLE""Data Exchange Guidelines"IDREF="70148" TYPE="TITLE""Application Model Guidelines"IDREF="97354" TYPE="TITLE""Primary Window Guidelines"IDREF="45614" TYPE="TITLE""Support Window Guidelines"IDREF="93758" TYPE="TITLE""Pointer Behavior Guidelines"IDREF="31057" TYPE="TITLE""Keyboard Focus and Navigation Guidelines"IDREF="38775" TYPE="TITLE""Selection Guidelines"IDREF="99534" TYPE="TITLE""Drag and Drop Guidelines"IDREF="10519" TYPE="TITLE""Menu Traversal and Activation Guidelines"IDREF="78525" TYPE="TITLE""Pull-Down Menu Guidelines"IDREF="54082" TYPE="TITLE""Popup Menu Guidelines"IDREF="11036" TYPE="TITLE""Pushbutton Guidelines"IDREF="13450" TYPE="TITLE""Option Button Guidelines"IDREF="50633" TYPE="TITLE""Checkbox Guidelines"IDREF="61178" TYPE="TITLE""Radio Button Guidelines"IDREF="73700" TYPE="TITLE""List Guidelines"IDREF="23148" TYPE="TITLE""Text Field Guidelines"IDREF="22352" TYPE="TITLE""Scrollbar Guidelines"IDREF="94829" TYPE="TITLE""Indigo Magic Scale Guidelines"IDREF="57791" TYPE="TITLE""Label Guidelines"IDREF="28474" TYPE="TITLE""File Finder Guidelines"IDREF="37723" TYPE="TITLE""Thumbwheel Guidelines"IDREF="96812" TYPE="TITLE""Dial Guidelines"IDREF="30622" TYPE="TITLE""Guidelines for Using the Various Types and Modes of Dialogs"IDREF="31035" TYPE="TITLE""Guidelines for Designing Dialogs"IDREF="95778" TYPE="TITLE""Guidelines for Invoking Dialogs"IDREF="97122" TYPE="TITLE""General User Feedback Guidelines"IDREF="76388" TYPE="TITLE""Pointer Shapes and Colors Guidelines"LBL="" HELPID=""ID="69686"Icon Appearance Design GuidelinesFor any icon you create . . . Provide a meaningful, distinctive symbol that gives your product an identity and that allows users to readily identify your application and its corresponding custom data files, if any. Keep your design fairly simple because desktop icons can be displayed at very small sizes.Make sure that your icon can be identified across the range of viewing sizes.Color most of your icon using the icon color predefined by IconSmith so that your icon's state is easy to detect.Use two or more areas of accent colors to help your icon stand out against user-customized background colors.Avoid small areas of color (2-4 pixels) because they're difficult to see against patterned backgrounds.Include an outline around your custom symbol, and use the outline color supplied by IconSmith.Avoid or use sparingly intense, strongly saturated colors and the specific colors used by the Indigo Magic Desktopname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'bright yellow, dim yellow, royal blue, light gray-green, cadet blue, and Navajo white. These colors make it difficult to distinguish between certain icon states and to find your icon against the background colors of many desktop tools.Orient your icon so that it displays a three-quarter view that faces the lower right corner of the screen.When designing an application icon . . . Include the magic carpet, the generic executable symbol, with your application's symbol.Indicate the state of the application (not running vs. running) by providing two different application symbols and by moving the magic carpet from a horizontal (not running) to vertical (running) position. Remember that your application symbols should resemble a progressive animation when viewed in succession.Make sure that your application symbols do not obscure the magic carpet in either its horizontal or vertical position.If your application saves data in a custom file format . . . Design a unique data file format symbol that is readily associated with your application icon design and also indicates how the data is used.If your application is document-based, include the generic data file symbol (stack of papers) in your design.If your data file icon does not use the generic data file symbol, create an appropriately shaped shadow for your file icon and use the predefined shadow color supplied by IconSmith.LBL="" HELPID=""ID="34925"Icon Behavior GuidelinesWhen creating an FTR to define your application icon's behavior . . . Provide a CMD OPEN rule that launches the application. This allows the user to open your application either by selecting your application icon and then choosing "Open" from the corresponding Selected menu, or by double-clicking your application icon.Provide a CMD ALTOPEN rule that opens the Launch dialog box shown in IDREF="39600" TYPE="GRAPHIC"Figure 2-12 with the path to your executable displayed in the text field of this window. This allows the user to open the Launch dialog box by double-clicking your application icon while holding down the 
Alt key. Provide a CMD DROP rule that launches your application with the file specified by the dropped icon. If your application doesn't understand the type of file represented by the icon dropped on it, your application should provide an appropriate error message to the user rather than launching. This allows the user to launch your application with a specific file by dragging the file icon and dropping it on your application icon.When creating an FTR for your file icon . . . Provide a CMD OPEN rule that launches your application and automatically opens the file represented by the file icon. This allows the user to open a file created by your application either by selecting the file icon and then choosing "Open" from the corresponding Selected menu, or by double-clicking the file icon.Provide a CMD PRINT rule that sends the file represented by the file icon to the specified printer. This allows the user to send your application's data files to the default printer by selecting the file icon and then choosing "Print" from the corresponding Selected menu. It also allows the user to send your application's data files to any printer by dragging the file icon and dropping it on an icon that represents the specific printer. LBL="" HELPID=""ID="96551"Application Icon Accessibility GuidelinesWhen making your application icons accessible to users . . .Place your application icon on the Applications page in the Icon Catalog. If you produce a suite of software applications, consider creating your own page.In your documentation, refer users to the appropriate page in the Icon Catalog after they've installed your application.When naming your executable, use the product name or choose a name that's strongly associated with the product.When naming your executable, use only lowercase letters. Don't use numbers, spaces, or special characters such as underlines or periods.Make sure that a link to your executable (preferred method) or the executable itself resides in a directory in the user's default search path. Ideally, place a link to your executable in the /usr/sbin directory. This helps ensure that users can quickly find your application icon using the Find an Icon tool.LBL="" HELPID=""ID="26903"Indigo Magic Look GuidelinesWhen designing the look for your application . . .Use the Indigo Magic look rather than the standard IRIS IM look.Use the pre-packaged color and font schemes supplied by Silicon Graphics rather than designing your own colors and fonts.LBL="" HELPID=""ID="57728"Application Window Characteristic GuidelinesIn general, when deciding on the characteristics for your application windows . . .Determine which category (main, co-primary, support, or dialog) each application window belongs to and assign characteristics appropriately.When setting up your window decorations . . .Include a Window menu button for all windows.Include resize handles only if the window contains resizable components such as work areas, scrolling lists, and text input fields.Include a Minimize button for all primary windows. Do not include this button on support windows or dialogs.Include a Maximize button only if the window contains resizable components.(To see the above window decoration requirements arranged according to window type, see IDREF="68452" TYPE="TABLE"Table 3-1.)When designing the Window menus for your application windows . . .Include "Restore  Alt+F5" for all primary windows. Include it for support windows and dialogs only if the menu contains a "Maximize" entry.Include "Move  Alt+F7" for all windows.Include "Size  Alt+F8" and resize handles for windows that contain resizable components such as works areas, scrolling lists, and text input fields.Include "Minimize  Alt+F9" and the Minimize button for all primary windows. Do not include the Minimize entry for support windows or dialogs.Include "Maximize  Alt+F10" for windows that are resizable, that is, they have a "Size  Alt+F8" entry.Include "Raise  Alt+F2" for all windows.Include "Lower  Alt+F3" for all windows.Include "Close  Alt+F4" for all windows except the main primary window.Include "Exit  Alt+F12" for the main primary window. Include "Exit  Alt+F12" for those co-primary windows from which users can quit the application. "Exit" always has the same behavior, that is, it quits the application, no matter how it's activated. Don't include "Exit" for support windows or dialogs.(To see the above Window menu requirements arranged according to window type, see IDREF="68452" TYPE="TABLE"Table 3-1.)Always use the default behaviors for the Window menu entries except for "Exit." Don't add functionality to these commands. When users choose "Exit," your application must perform any necessary clean up, such as prompting the user to save unsaved changes before quitting.Don't add application-specific entries to this menu. Users don't expect application-specific entries in the Window menu.Don't add a title to the Window menu.Don't use the keyboard accelerators <Alt-F2>, <Alt-F3>, <Alt-F4>, <Alt-F5>, <Alt-F7>, <Alt-F8>, <Alt-F9>, <Alt-F10>, or <Alt-F12> for other functions in your application. They are reserved for the 4Dwm Window menu entries.When specifying the label in the title bar . . .For all categories of windows, limit the length of each title bar label such that the entire label displays when the window is viewed at its default size.Don't include application-critical information or general status information in the title bar such as the current page number or whether a file is in view-only mode. For main windows, first determine if your application uses document files. If it is not document-based, use the application name only. If it is document-based, use the application name followed by a colon and the filename (or Untitled if new file) in the format AppName : filename and update the label whenever the filename changes. Don't use the full pathname unless that information is required for users to distinguish one window from another. If your application is displaying remotely, add the host name followed by a colon at the beginning of the title bar label in the format Host : AppName ... .For co-primary windows used in multiple document models, use the format AppName : Filename (or AppName : Untitled if a new file). For co-primary windows used in the "single document, multiple primaries" model, use the format AppName : Function. Make sure that the function matches the menu entry or the label on the button that invokes it. For support windows, use the application name and function in the format: AppName : Function. Make sure that the function closely matches the menu entry or the label on the button that invokes it. For dialog windows, use the application name, followed by the type of dialog in the format: AppName : DialogType, where DialogType is "Prompt," "Error," "Warning," "Question," "Information," "Working," or "File Selection."Leave spaces between strings and colons in a label.When determining the default, minimum, and maximum sizes for your windows . . .Specify a default size for each window.If the window is resizable, specify a minimum size at which all controls and work areas will be visible and large enough to be usable. If the window is not resizable, set the minimum size equal to the default size.If the window is resizable, specify a maximum size such that your application window doesn't expand to fill screen space unnecessarily. If the window is not resizable, set the maximum size equal to the default size.When considering window placement . . .Set a preferred window position for all primary windows. Don't set a required window position for primary windows. Try to anticipate other application windows that may be displayed with your application and set your preferred default position appropriately.LBL="" HELPID=""ID="26715"Guidelines for Keyboard Focus Across WindowsWhen designing your application windows . . .Make sure that your application works well under implicit focus across windows.Don't have your application move the pointer to another location on the screen. Always allow the user to control the position of the pointer on the screen.When incorporating a "pointer grab" function into your application . . .If the user is always going to specify the data to capture with a single action such as a single mouse click or a single mouse drag, use the single-action pointer grab model; otherwise use the multiple-action pointer grab model.Display a standard or modified sighting pointer whenever your application window grabs keyboard focus. This indicates that the keyboard focus belongs to your application's window and that the pointer isn't currently following implicit focus across windows.LBL="" HELPID=""ID="88857"Minimized Window GuidelinesWhen designing images for your minimized primary windows . . .Use a color image rather than a two-color bitmap.Design your images to look best at the default size of 85x67 pixels.If your application is based on a single document model, create separate images for each of the primary windows. If your application is based on a multiple document model, create one image for the main window and a second image to use for all co-primary windows. Choose images that clearly identify the window that is minimized. If you have multiple images, make sure that the separate images work well together. Make sure that the images you use for minimized windows will be understood by an international audience.Don't use a snapshot of the desktop icon for the image. This could be confused with the real icon.When choosing labels for your minimized primary windows . . .Limit the label to approximately twelve characters. If you need a few more characters than this, check that your label will fit with the default size and font for minimized windows.If your application is not document-based, use the application name as the minimized window label for the minimized main window. Use the label Function for minimized co-primary windows where Function is the same function as in the co-primary window's title bar.If your application is document-based and follows one of the single-document models, use Filename (or "Untitled" for new files) for the minimized main window label. Use Function for minimized co-primary window labels where Function is the same function as in the co-primary window's title bar.If your application is document-based and follows one of the multiple-document models, use the application name as the label for the main window (if it is visible). The co-primary windows in these models represent the multiple documents and should have the minimized window label Filename (or "Untitled" for new files).When determining the behavior for a window that the user has chosen to minimize . . .Decide which operations should and should not continue to be processed while the window is minimized. Indicate status with the minimized window label if your application is typically minimized during long processes.Use the default screen locations supplied by 4Dwm for the minimized window. Don't specify your own screen location.LBL="" HELPID=""ID="54822"Desks GuidelinesWhen designing your application . . .Make sure that all windows with associated support or dialogs are visible and mapped to the screen so that the support windows and dialogs appear only on the desk where their parent window displays.Don't design your application to manage the screen background.LBL="" HELPID=""ID="44643"Session Management GuidelinesWhen designing your application . . .Have your application create a command line that will launch the application and restore its current state. This current state should minimally include reopening any files that are currently open under the application and opening any primary or support windows that are currently open.Update this command line as the state of the application changes.If your application allows users to create and edit data files, have 4Dwm notify your application when the user chooses "Log Out."If your application is running when the user chooses "Log Out" and there are unsaved changes for a specific file . . .Save these changes into another file and name it something logical such as original_file_name.save. When the application is restarted at login, post a dialog that tells the user that this file with unsaved changes exists and query the user to determine whether to open the original file or the file with the unsaved changes.If you cannot implement the preferred strategy described above, ignore the user's unsaved changes. Do not automatically save the user's changes by default.LBL="" HELPID=""ID="19019"Software Installation GuidelineMake sure that users can install and remove your application through the Software Manager, an Indigo Magic Desktop utility.LBL="" HELPID=""ID="27292"Guidelines for Designing Online HelpWhen designing access to online help for your application . . .Provide access in each window of your application from either a Help menu if the window has a menu bar or a Help button if the window doesn't have a menu bar. Use SGIHelp. This provides users with a familiar viewer and familiar navigation techniques when reading the online help for your application.When defining the types of online help for your application . . .Provide context-sensitive help, overview information, task-oriented help, a list of keyboard shortcuts, product information, and an index of help topics.Provide context-sensitive help for all primary and support windows.Enable context-sensitive help mode when the user either chooses the "Click for Help" entry in a Help menu (if the window has a menu bar) or presses <Shift>-<F1> (whether or not the window has a menu bar). Change the pointer to a question mark when context-sensitive help mode is enabled.At a minimum, provide separate context-sensitive help for each control area, work area, status area, and menu in the window. This help should describe the purpose of the corresponding area and should include cross-references to task-oriented help topics which describe tasks which use this area.Provide overview information for all main windows whether help is provided from a menu or a button. This overview should briefly describe the functionality of the entire application.For co-primary and support windows that include a menu bar, provide overview information that describes the functionality of that specific window.Provide task-oriented information for all windows. This information should include step-by-step instructions for how to accomplish all of the tasks available in the current window.For windows with a menu bar, provide access to an index of help topics. This index should list all available help topics for the application including those that are generated using the context-sensitive help mode and those that are available directly from the Help menu. In addition, users should be able to browse the index and select topics for reading. Provide keyboard shortcut information for all main windows (whether help is provided from a menu or a button) and for co-primary and support windows that include a menu bar. This information should include the mnemonics, accelerators, and function keys available for the entire application and not just for the current window.Provide product information for all main windows (whether help is provided from a menu or a button) and for co-primary and support windows that include a menu bar. This information should minimally include the product name and version number. It might also include other general product information such as copyright and trademarking, licensing, and customer support access.Display product information using an Information dialog so that users who don't install an application's online help can still access version number and customer support information.When providing a Help menu in an application window . . .Include a "Click for Help" entry to enable context-sensitive help mode with the keyboard accelerator <Shift>-<F1>.Include an "Overview" entry for main windows. For co-primary and support windows, include an entry labeled "Overview for <window name>". Include entries that represent a list of tasks that users can accomplish in the current window. If this list of tasks is more than ten or twelve entries, use cascading menus. These entries shouldn't have mnemonics or keyboard accelerators.Include an "Index" entry that allows the user to access the help index.Include a "Keys & Shortcuts" entry to display all keyboard shortcuts for the application.Include a "Product Information" entry. When providing a Help button in an application window . . .Provide a Help button for all windows that don't have a menu bar.For main windows, provide overview, task-oriented, keyboard shortcuts, and product information when the user clicks this button.For co-primary and support windows, provide overview and task-oriented information when the user clicks this button.For dialogs, provide help that focuses on the main purpose of the dialog and describes how to use the dialog.For primary and support windows that include a Help button, also provide access to context-sensitive help when the user presses <Shift>-<F1>. Dialogs typically don't support context-sensitive help mode.LBL="" HELPID=""ID="42669"Guidelines for Creating SGIHelp ContentWhen writing any online help for your product . . .Create separate help "cards" for each help topic.Limit each help card to no more than three viewer windows full of information. Write a descriptive heading for each help card. If a particular help topic needs supplemental information, provide links to that information rather than repeating it in the current card.Use language your users will understand.Use figures when appropriate. SGIHelp allows users to view graphics inline with the help text.When writing the "Click for Help" context-sensitive information for your application . . .Begin by listing the individual controls and areas of your application windows that you need to describe. At a minimum, provide separate help cards for each group of controls and areas in that window. Provide descriptions in terms of the user tasks the components support. Don't include procedural, task-oriented information with the context-sensitive informationname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'include links to the appropriate task-oriented topics instead. When writing the overview help cards for your application . . .Restrict the content to information about what the product does, not how to use it.Limit the text to one or two viewer windows of information.Use the heading "Overview" for the main window's overview help card and "Overview of <window name>" for co-primary and support windows with overview help cards.When writing the task-oriented information for your application . . .Begin by listing the tasks that users will want to accomplish with your application. For each task, list the step-by-step instructions users will need to accomplish that task. If these instructions span more than three or four viewer windows, try to divide this topic into several smaller help topics. Provide a brief summary paragraph at the beginning of the help card, followed by the step-by-step information. When writing the keyboard shortcuts information for your application . . .Include all shortcuts for your application in a single cardname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'mnemonics, keyboard accelerators, and function keys.When creating the index for your help topics . . . Match the titles in the index as closely as possible to the titles of the help cards.Place the topics in the index in the following ordername='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'overview, list of tasks, context-sensitive topics, and keyboard shortcuts.When writing help information that will be available from a Help button rather than from a Help menu . . .For the main application window, the help card should contain an overview of your application, task-oriented information, a list of all keyboard shortcuts, and product information.For Help buttons not on the main application window of your application, present only the help information for the specific window. If the amount of information on this one help card spans more than three or four viewer windows of information, after the overview or summary information at the beginning of the help card, place links which take users directly to the other chunks of help information contained in that card.After writing your online help . . .Have reviewers examine your help content online rather than reviewing a printed copy. Help topics will "read" differently depending on which paths readers (reviewers) traveled to get there.Have reviewers check the titles of the help topics to make sure they are descriptive and appropriate.Have reviewers test out all links to make sure they are appropriate. LBL="" HELPID=""ID="86960"Desktop Variables GuidelinesIn general . . .Always honor the user's desktop customization settings. Never override or ignore them.When considering color and font schemes for your application. . .Use the pre-packaged color and font schemes supplied by Silicon Graphics rather than designing your own.When considering window placement . . .Set a preferred window position for all primary windows. Don't set a required window position for primary windows.Try to anticipate other application and tool windows that may be displayed with your application and set your preferred default position appropriately.To allow users to control the language for your application . . .Check the value of the default language each time your application is launched. Don't reset this value while the application is running.To allow users to control the mouse double-click speed for your application . . .Check the value of the double-click speed each time your application is launched. Don't reset this value while the application is running.If users will be editing and/or browsing ASCII text files in your application . . .Make their preferred editor (specified in the Desktop control panel) available for use on text files. Check the value for the preferred editor each time your application is launched, but don't reset this value while your application is running. If users can only browse the ASCII text files, launch the editor in read-only mode.LBL="" HELPID=""ID="27457"File Monitoring GuidelineIf your application needs to stay in sync with the state of any part of the file system, use FAM. Don't have your application directly poll the file system to detect changes.LBL="" HELPID=""ID="74743"Data Exchange GuidelinesIf your application contains data that users may wish to transfer to other applications or across separate instantiations of your application . . .Support the Clipboard Transfer Model using the "Cut," "Copy," and "Paste" entries in the Edit menu. In this model, the clipboard is a global entity that's shared by all applications. Your application shouldn't use these entries to refer to a clipboard that's private to your application.When supporting the Clipboard Transfer Model, don't select or highlight newly pasted data after a "Paste" operation.Support the Primary Transfer Model. Assert ownership of the primary selection when the user begins to make a selection. Insert data at the location of the pointer when the user clicks the middle mouse button (which isn't necessarily at the insertion cursor).When supporting the Primary Transfer Model, don't select or highlight newly transferred data after a transfer operation.Use persistent always selection highlighting (keep the current selection highlighted even when your application loses the primary selection), unless the only action that can be performed on the selection is to copy the data using primary data transfer. In this case, use nonpersistent selection highlightingname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'that is, remove the selection highlight when the selection is no longer the primary selection.When supporting the Primary Transfer Model, if the current active window has a selection that isn't the primary selection, reinstate this selection as the primary selection if the user presses <Alt-Insert>. Additionally, you can include a "Promote" entry in the Edit menu to perform the same function.When supporting the Primary Transfer Model, when the user begins to modify a selection, such as adding elements to it, reassert ownership of the primary selection if your application does not currently own it.When supporting both Clipboard Transfer and Primary Transfer, keep the primary selection independent from the clipboard. When the user begins to make a selection in your application, assert ownership of the primary selection but do not change the ownership of the clipboard. When the user chooses "Cut" or "Copy" from an Edit menu in your application, assert ownership of the clipboard but do not change the ownership of the primary selection.LBL="" HELPID=""ID="70148"Application Model GuidelinesFor all applications . . .Choose an appropriate application model for combining the different types of windows in your application.Use only the allowable parent-child window relationships and keep your application window hierarchy shallow.LBL="" HELPID=""ID="97354"Primary Window GuidelinesWhen designing a primary window . . .Use a menu bar unless all of the window's functionality is available through pushbuttons. Don't use a "floating" menu bar in a separate window.Support keyboard accelerators for Close (Ctrl-W) and Exit (Ctrl-Q) as appropriate, even if the window doesn't have a menu bar.When designing a scrollable work area in a primary window . . .Use a vertical scrollbar on the right side of the work area when the data being displayed in the work area may not fit in a vertical direction. Use a horizontal scrollbar directly below the work area when the data may not fit in a horizontal direction. Don't use scrollbars if you're certain the data will fit.Disable the appropriate scrollbar when all the data is visible in a given direction. Don't remove the scrollbar.Make each scrollbar span the entire height or width of the work area. Don't include controls or status information in the scrollbar region.When designing control areas in a primary window . . .Place controls below horizontal scrollbars or to the left of work areas.Provide pushbuttons for the most frequently accessed application-specific functions from the pull-down menus. Don't use pushbuttons for standard menu entries such as Open, Save, Close, Exit, Cut, Copy, Paste, and Help.Use pushbuttons only for functions that appear in menus, unless the pushbuttons are part of a tool palette.Provide an area for command-line input, if appropriate, in addition to (not in place of) pushbuttons.To display status information . . .Use a status area along the bottom of a primary window if your application needs to post frequent messages about its status. Provide vertical scrollbars for this area so that users can view previously displayed messages.Use a status area to display messages that the user doesn't have to respond to rather than posting this noncritical information in dialogs. However, don't put critical warning or error messages in the status area (use a dialog instead).Don't use the status area to display help information.When dividing a primary window into panes . . .Divide panes using separator lines. If users might need to resize the pane, also include a sash control.Try to limit the number of panes in a single window to four with no more than three sash controls.If certain panes are optional, allow users to hide or show these individual panes using entries in the "View" menu.LBL="" HELPID=""ID="45614"Support Window GuidelinesWhen designing support windows . . .Use them to provide access to sets of related controls.Allow users to access them either through entries in the Tools menu or through pushbuttons in a tool palette in the parent primary window.Be sure that each support window has a visible parent primary window that's mapped to the screen.When designing the layout of a support window . . .Make the layout simple and static. Don't include multiple panes of information.Include a response area for standard actions that's similar to the one dialogs have.Don't include a menu bar in most cases, but do support the keyboard accelerator for Close (Ctrl-W).When opening support windows . . .Avoid overlapping the work area of the parent window.Bring them up as modeless secondary windows. When allowing the user to make color choices . . .Use the Indigo Magic color chooser whenever you want to offer the user an unrestricted choice of colors. For a restricted choice of colors, use a palette of colors to choose from, a list, an option button, or a set of radio buttons, depending on the number of choices available. LBL="" HELPID=""ID="93758"Pointer Behavior GuidelinesWhen designing your application . . .Always allow the user to control the location of the pointer; your application shouldn't change the position of the pointer.Don't change the gain or acceleration characteristics of the pointer. If your application requires fine manipulation, provide a zoom feature in the View menu.LBL="" HELPID=""ID="31057"Keyboard Focus and Navigation GuidelinesWhen designing keyboard focus and navigation for your application windows . . . Use explicit focus for navigating among components within a window.Support at least the minimum required functionality from the keyboard, such as navigating to and entering data into editable text fields, using mnemonics and keyboard accelerators to access menu entries, and scrolling any scrollable component. Keep in mind that some users use alternate input devices that rely on having functions available from the keyboard.When the window becomes active for the first time, give focus to the component that the user is most likely to want to interact with using the keyboard. When a user returns the keyboard focus to a window that was previously the active window, return the keyboard focus to where it was when the user moved the focus out of that window.Put each component that requires the use of arrow keys to control it in its own field. The following components are by default put in fields of their own: editable text fields, lists, scrollbars, and sashes.Don't use the default keyboard navigation keys for other purposes. These keys are <Tab>, <Ctrl>-<Tab>, <Shift>-<Tab>, <Ctrl>-<Shift>-<Tab>, the arrow keys, <F10>, <Shift>-<F10>, and <Ctrl> in combination with a left mouse button click.LBL="" HELPID=""ID="38775"Selection GuidelinesFor each collection of data . . . Use one of the four recommended selection modelsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'single selection, browse selection, range selection, or discontiguous selection. Don't use the multiple selection model.Automatically scroll the data as the user drags the pointer out of the scrollable data display region.Determine if your users will need to create or modify a selection using the keyboard. If so, then support the keyboard actions defined in Section 4.1.6 of the OSF/Motif Style Guide. (These actions are automatically supported if you use the IRIS IM list or text components.)When highlighting a selection . . . Update the highlighting continuously as the user initiates and extends the selection.Use persistent always highlighting, unless the only reason a user can select this data is to transfer it using the primary transfer model. In this case, use nonpersistent highlighting.When managing multiple collections of data in a single window . . .Deselect the previous selection whenever the user makes a new selection in any of the collections for cases where the user can select data in only one collection at a time. Apply the operation to the collection that most recently had a selection made in it when the user can select data in more than one collection at a time and there are mouse, keyboard, or menu commands that can be applied to more than one of the collections.LBL="" HELPID=""ID="99534"Drag and Drop GuidelinesWhen designing drag and drop for your application . . . Cancel a drag and drop operation if the user presses <Esc>, and leave both the object and the target as they were before the operation was initiated.Use the left mouse button for both selecting and dragging non-text objects. Use the standard cursor in this case.Use the middle mouse button for dragging text, and replace the cursor with a drag icon when the text is being dragged.LBL="" HELPID=""ID="10519"Menu Traversal and Activation GuidelinesIn general, when designing traversal and activation for your menus . . . Allow users to activate and traverse the menus using the default IRIS IM behaviors for mouse and keyboard actions.If a user closes a menu by clicking somewhere outside of the menu, the application should ignore this click so that users don't lose selections they've made in the window just because they display and close menus.Allow users to display and close popup menus using the key combination <Shift><F10>. When <Shift><F10> displays a popup menu, the location cursor should be on the first available menu entry. When <Shift><F10> closes the menu, the keyboard focus should be returned to where it was before the menu was displayed.LBL="" HELPID=""ID="78525"Pull-Down Menu GuidelinesIn general, when designing pull-down menus in a menu bar . . . Be sure that users can access most of your application's functionality from the menu entries. At a minimum, make sure that the core functionality can be accessed from the menus.Don't include more than a 10-12 entries in a menu and make sure that all of your entries can fit on the screen at one time.Provide mnemonics for all menus and menu entries. In most cases, the mnemonic should be either the first character of the name or, if there's a conflict, a character that's strongly associated with and included in the name. Use standard mnemonics for standard menus and entries.Limit the use of tear-off menus. Instead, use support windows for groups of controls that users might want to use continuously.When selecting specific menus and entries for an application window . . .Use the standard menus and menu entries as the basis for the overall design of the menu structure. Include all standard menus and entries that are applicable to your application.Include a Help menu as the rightmost menu.Include an "Undo" menu entry, particularly if users can perform actions that destroy or significantly change their data\xd7 .Include an "Exit" menu entry for all main windows and for co-primary windows if users will want to completely exit the application from that co-primary window.Include a "Close" menu entry for all co-primary windows and support windows that have menu bars. Don't provide a "Close" entry for main windows.Include menu entries that repeat the functionality of any pushbuttons on the primary window.Include menu entries for actions that are accomplished using a direct manipulation method or a mouse shortcut such as double-clicking.Include menu entries for accessing all primary and support windows that are children of the current window.Don't include entries for functions that aren't available for the current version of your application.When naming menus . . .Use one-word titles for menus.Use the standard titles for menus (for example, File and Edit) if they're applicable, but change the standard title if this will make the function more clear. Don't use a standard menu title if you're changing the standard definition.When naming menu entries . . .Use the standard names for standard menu entries, but don't use a standard name for a menu entry that doesn't support the standard behavior.Each entry name should be an action word, the value of a parameter, an attribute name, the name of a cascading menu, or the name of a co-primary, support, or dialog window. Don't use more than two words (except for task-oriented Help menu entries), and avoid using graphic labels for menus entries unless the graphics make the functionality more clear.Choose descriptive names that help users learn the functionality of the application. For cascading menus, choose a name that clearly implies the contents of the menu.Add a word if necessary to be sure the entry clearly indicates what entity will be acted upon. For example, you might use "New object" such as "New Folder" or "New Page" rather than just "New."If a menu entry toggles its state, use a checkbox and leave the menu entry name the same for the different states ("Italics"). If this won't be clear, toggle the name so that it indicates what action will be taken if the menu entry is selected ("Show Grid," "Hide Grid").Capitalize the menu entry using the same rules as capitalizing book titles.Display an ellipsis (...) after menu entries that bring up a dialog that requests more information from the user. Don't use ellipses if the dialog simply brings up information that the user requested (for example, a Help dialog).When ordering menus and menu entries . . .Place the standard menus in the standard order (File, Selected, Edit, View, Tools, Options, Help), even if you have renamed any of these menus. Place any new menus between the View and Tools menus.Place standard menu entries in the standard order. "Close" and "Exit" are always at the end of the leftmost menu whether or not this menu is named File.Group menu entries logically. If a new menu entry is related to one of the standard menu entries, place it near that standard menu entry.Place items in the menu first according to the order they will be used, and second according to their frequency of use (with more frequently used items closer to the top of the menu).Alphabetize entries that can be determined only when the user launches the application. If this alphabetized group appears in a menu that contains other entries, place the group at the end of a menu and use a separator between it and the preceding entries.Use radio buttons for mutually exclusive menu entries, and checkboxes for a group of related menu entries, any number of which can be selected at any one time.Use separators when necessary to group itemsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for example, to set off a group of related entries that use radio buttons or checkboxes.Limit the use of cascading menus. Never use more than one level of cascading menus.When selecting keyboard accelerators for menu entries . . .Use standard keyboard accelerators for standard menu entries; don't use any of the standard accelerators for your own entries, even if you're not using those standard entries. Provide keyboard accelerators for the most frequently used menu entries. Don't provide accelerators for all menu entries.Use the key combination <Ctrl>character. Don't use the key combination <Alt>character because this conflicts with mnemonics.For pairs of menu entries where one entry reverses the results of the other entry ("Undo" and "Redo"), use <Ctrl>character for the most frequently used entry and <Shift><Ctrl>character for the other entry where character is the same for both accelerators.Display all characters in keyboard accelerators as uppercase (for example, display <Ctrl>s as "Ctrl+S"). For keyboard accelerators that involve uppercase characters, show the <Shift> key as part of the keyboard accelerator (for example, display <Ctrl>S as "Shift+Ctrl+S").When deciding when to disable menu entries . . .If selecting the menu entry in the current context would give the user an error message, show the menu entry as disabled (dimmed). Avoid using dynamic entries. Rather than removing an entry when it's temporarily unavailable, include it and disable it as appropriate.LBL="" HELPID=""ID="54082"Popup Menu GuidelinesWhen choosing when a popup menu should appear . . .At most, provide a different popup menu for each main area (that is main field or main pane) of the window. Don't change the availability of a popup menu based on what graphical element the pointer is over or based on the selection state of any of the graphical elements.When deciding what to include in a popup menu . . .Include entries for the most commonly used functions from the pull-down menus, and use the same names in the same order as they're displayed in the pull-down menus.Avoid entries that require checkboxes or radio buttons. These are typically not the most commonly used menu functions.Don't make menu entries the sole access to these functions.Don't change the content of the menu based on what graphical element the pointer is over, or based on the selection state or contents of this element. Instead, put all entries in the popup menu for the main area of the window, then enable and disable entries as appropriate. Don't include cascading menus and don't use tear-off menus.When displaying the contents of the popup menu . . .Include a title that's either the name of the application, or if the application has more than one popup menu, that describes the purpose of the menu. Use only one separator, which goes between the title and the individual menu entries.Show ellipses and keyboard accelerators if these are shown in the corresponding pull-down menu entry, but don't show mnemonics.If selecting the menu entry in the current context would give the user an error message, show the menu entry as disabled (dimmed). Don't remove the menu entry when it's temporarily unavailable.LBL="" HELPID=""ID="11036"Pushbutton GuidelinesWhen using pushbuttons . . . In windows with menu bars, use pushbuttons to provide easy access to the most frequently used application-specific functions in the pulldown menus. For primary windows, these pushbuttons appear in the control area of the window.In windows without menu bars, use pushbuttons to access help and to close the window.Use pushbuttons to create tool palettes, either in support windows or in primary windows. Use pushbuttons in the response area of a dialog for the standard actions for that dialog. Always have the pushbutton perform the same operation (although the input to that operation may vary based on what data is currently selected). Don't use the same pushbutton to perform different tasks based on some mode of the application.Use pushbuttons to perform an action; don't use them merely to set state, such as a parameter value in a dialog box. Use checkboxes, radio buttons, or option menus for this purpose.When labelling a pushbutton . . . Use either a text or graphic label that describes the action associated with the button. With text labels, use an active verb describing the operation the button performs. Each text label should be a single, capitalized word.Center the label on the button.If the pushbutton opens a dialog to collect more information from the user before the action represented by the pushbutton can be completed, place an ellipsis after the button label. Don't use an ellipsis if the button opens a dialog simply to display some information to the user as an end result of the operation. This use of ellipses is the same as that described for menu entries in the section IDREF="87916" TYPE="TITLE""Naming Menu Entries in the Pull-Down Menus" in Chapter 8.When displaying pushbuttons . . . If the action associated with a button is temporarily unavailable, disable the button rather than remove it.Don't resize pushbuttons when the window is resized.Don't use dynamic buttons whose labels change to indicate different functionality depending on the current context. Instead, use multiple buttons and disable buttons that represent functionality that's currently unavailable. With multiple buttons, the functionality is obvious even if some of the buttons aren't currently active. With dynamic buttons, the user has to put the application intothe proper context to discover some of the functionality. The one exception to this guideline is the Cancel/Close button used in Dialogs with the Apply button. See IDREF="32754" TYPE="TITLE""Standard Dialog Actions" in Chapter 10 for information on this special case.LBL="" HELPID=""ID="13450"Option Button GuidelinesWhen using option buttons . . . Use an option button when you want to offer the user about 5-12 mutually exclusive options; use a list for more than 12 choices. If there's enough space, use radio buttons for fewer than 5 choices. Don't put radio buttons or checkboxes in an option menu.Don't use an option button if the user can select several options at the same timename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'use a list or a set of checkboxes instead.Don't put actions (such as zoom or rotate) in the option menuname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'use pulldown menus or pushbuttons instead.Don't add or delete the choices in the option menu. If the choices must change, use a list.Don't use cascading menus in the option menu. If there are so many items that they don't fit conveniently into an option menu, use a scrolling list instead.Don't use a tear-off entry in an option menu.When labelling an option button . . . Use the default label for the option button itself, which is the current value of the parameter.Use a second label that describes the parameter that the option button controls. This parameter label should be to the left of the option button and should be followed by a colon (:) and a space (see IDREF="36248" TYPE="GRAPHIC"Figure 9-2). This label is typically a noun.When labelling the entries in an option menu . . .Use nouns that indicate the possible values of the parameter being set.When displaying option menus . . . If one of the entries in an option menu is unavailable for selection in the current context, disable the menu entry. Don't remove the entry from the menu. Note that the user should always be able to display the contents of an option menu even if all of the menu entries are currently disabled.Don't include a title in option menus.LBL="" HELPID=""ID="50633"Checkbox GuidelinesWhen using checkboxes . . . Use checkboxes for single attributes or states that can be turned on and off, or for groups of items where multiple items in the group can be selected independently. (Also see IDREF="67896" TYPE="TITLE""Using Radio Buttons and Checkboxes in Pull-Down Menus" in Chapter 8.)Use checkboxes for groups of less than about six items. When dealing with more than a handful of items, use a list that allows multiple elements to be selected at the same time.Don't use checkboxes for mutually exclusive options. If only one item in a group of items can be selected at a time, use radio buttons instead.Don't use checkboxes for actions; use pushbuttons instead.Don't change the choices in the group based on the current context. If you want to offer a dynamic set of choices, use a list.When labelling checkboxes . . . Give each checkbox a label that describes the attribute, state, or option it controls.Create a group label for each group of checkboxes, and indent the checkboxes below the label. This group label should be a noun that describes the function of the group. When displaying checkboxes . . . Keep checkboxes updated to reflect the current state of the application and the settings of the current selection (if the settings of the checkboxes relate to the current selection). For example, if you have a checkbox for turning underlining on and off and the user selects some text, the checkbox should be updated to reflect whether or not the selection is underlined.Disable checkboxes representing choices that aren't currently available. Don't remove the checkboxes.LBL="" HELPID=""ID="61178"Radio Button GuidelinesWhen using radio buttons . . . Use radio buttons in groups, never as single buttons. If you need to use a single button that shows an on/off state, use a checkbox instead.  (Also see IDREF="67896" TYPE="TITLE""Using Radio Buttons and Checkboxes in Pull-Down Menus" in Chapter 8.)Use radio buttons for mutually exclusive options. If more than one item in the group can be selected at a time, use checkboxes or a list instead. Use radio buttons when you want to offer the user fewer than six options. If you have more than six options, or if screen space is extremely limited, use an option button instead. (See the section IDREF="68004" TYPE="TITLE""Option Buttons" earlier in this chapter.) If you have more than 12 options, you should consider using a list where only a single element can be selected at a time. (See the section IDREF="72866" TYPE="TITLE""Lists" later in this chapter.)Don't use radio buttons for actions; use pushbuttons instead.Don't change the choices in a group of radio buttons based on the current context. If you want to offer a dynamic set of choices, use a list because users expect the elements of a list to change occasionally, but they don't expect radio buttons to change.When labelling radio buttons . . . Give each radio button a label that describes the attribute or option it controls.Create a group label for each group of radio buttons, and indent the radio buttons below the label. This group label should be a noun that describes the function of the group.When displaying radio buttons . . . Keep radio buttons updated. If the settings of the radio buttons depend on the current selection, they should be updated when the user makes a new selection so that they reflect the settings of the new selection.Disable radio buttons representing options that aren't currently available. Don't remove the radio buttons.LBL="" HELPID=""ID="73700"List GuidelinesWhen using lists . . . Use a list when you want to allow the user to choose a single option from a large list (that is, more than 15 options). If you have fewer than 15 options, use either an option button (best for 5-15 options; see IDREF="68004" TYPE="TITLE""Option Buttons" earlier in this chapter) or a set of radio buttons (best for 2-5 options; see IDREF="71369" TYPE="TITLE""Radio Buttons" earlier in this chapter).Use a list when you want to allow the user to choose several options from a list of six or more elements. If you have fewer options, use checkboxes (see IDREF="22792" TYPE="TITLE""Checkboxes" earlier in this chapter).If you want to allow the user to choose elements from a dynamic list of options, use a list regardless of the number of options. (Option menus and groups of checkboxes or radio buttons should represent static lists of options.)When labelling a list . . . Label the list with a noun that indicates the function of the elements in the list.Place the label directly above and either left-aligned with or slightly to the left of the first element of the list.When labelling the list entries . . .If the elements in the list represent operations to perform, they should be active verbs. Otherwise, they should be nouns. When displaying lists . . . When a window using a list is first opened, the currently selected list elements should be highlighted and the list should be scrolled to display these. If multiple elements are selected, scroll the list so that the first selected one appears at the top of the viewing area. See IDREF="59818" TYPE="TITLE""Selection" in Chapter 7.Allow users to select elements in the list according to the selection guideline discussed in IDREF="59818" TYPE="TITLE""Selection" in Chapter 7.Disable list elements that aren't currently available.Allow the list to autoscroll (the default behavior) if the user is making a selection and the selection goes outside the range of the displayed elements. See IDREF="59818" TYPE="TITLE""Selection" in Chapter 7.LBL="" HELPID=""ID="23148"Text Field GuidelinesWhen using text fields . . . Use single-line, editable text fields to display values of parameters that users can edit.Use single-line, noneditable text fields to display values of parameters that users can't edit, whenever these values either change over time or might need to be selected by the user. If the value doesn't change and the user doesn't need to select it, use a label.Don't use a text field if you need to display and edit pathnames; use the Indigo Magic File Finder instead.Use text fields for values that change over time; don't use labels.When labelling text fields . . . Label each editable or noneditable text field, unless the field represents the bulk of a window and the field's function is clear.For single-line text fields, place the label to the left of the text field, and follow the label with a colon (:) and a space. The label should be vertically centered within the text field.When displaying text fields . . . Use the default selection and highlighting discussed in IDREF="59818" TYPE="TITLE""Selection" in Chapter 7.Allow the user to cancel a text edit in progress by pressing <Esc>. That is, once the user has selected text and started to replace it with new text, <Esc> should cancel any changes that the user has made. Keep text fields updated. When a window using a text field is first opened, the default or current setting (if either exists) for the text field should be shown.Make the text automatically scroll if the user is making a selection and the selection goes outside the range of the displayed elements.When an editable text field can't be edited in the current context but the information is still useful to the user, change it to a noneditable text field. If the information isn't useful to the user (that is, the user doesn't need to know the value and won't need to select it), disable the text field.LBL="" HELPID=""ID="22352"Scrollbar GuidelinesWhen using scrollbars . . . Use scrollbars to pan an associated view.Use scrollbars with components that can be resized such that all of the available information contained in the component can't be displayed at one time. Typical scrollable components include work areas in primary windows, lists, multiple line text fields, and data display areas in primary or support windows.Use scrollbars with a list when the number of elements in the list doesn't fit in the viewing region (vertical scrollbar), when the elements are too wide to fit in the viewing region (horizontal scrollbar), or when the window containing the list can be resized such that either of these situations can occur. See IDREF="72866" TYPE="TITLE""Lists" earlier in this chapter for information.Use scrollbars with multi-line text regions when the data can't all be displayed vertically or horizontally or when the window can be resized such that this is true. See IDREF="36229" TYPE="TITLE""Text Fields" earlier in this chapter for information.Don't use scrollbars with single-line text fields. See IDREF="36229" TYPE="TITLE""Text Fields" earlier in this chapter for information.Don't use scrollbars for zooming or for rotation. Use an Indigo Magic thumbwheel instead. See IDREF="20150" TYPE="TITLE""Thumbwheels" later in this chapter.Don't use scrollbars to choose a value in a range; use the Indigo Magic scale instead.When displaying scrollbars . . . Place vertical scrollbars along the right of the element being scrolled, and place horizontal scrollbars along the bottom of the element being scrolled. Keep scrollbars updated. When a window using a scrollbar is first opened, the scrollbar should reflect the current area being displayed in the scrolled region.Update the data in the scrolled area continuously as the user drags the slider along the scroll region. This gives the feeling of direct, continuous control. Don't wait until the user has released the slider to update the data, because users often use the current view of the data to determine when to stop dragging the slider.When a component is being scrolled, don't scroll it beyond the first or last elements. That is, there should be no extra white space before the first element or after the last element. The exception to this rule is scrolling text elements that represent physical pages (for example, in a desktop publishing application).Make all components that use scrollbars automatically scroll when the user makes a selection that goes outside of the data currently being displayed. Also, make the component automatically scroll if the user performs an operation that moves the cursor outside of the current view (for example, if the user inserts or deletes text that moves the cursor outside of the current view). In this case, the view should be automatically scrolled so that the cursor is shown when the operation is finished.When using the <Page Up>, <Page Down>, <Ctrl>-<Page Up>, or <Ctrl>-<Page Down> key sequences to scroll a page at a time, leave one unit of overlap from the previous page to make it easier for the user to preserve the current context. This unit is application-specific; it might be a line of text, an item in a list, a row of icons, or a specfic number of pixels (for example, in a drawing region). By default, this behavior is automatic for IRIS IM list and text components.Remove the slider from the scrollbar when all of the data is currently being displayed. Don't remove the scrollbar or disable it in some other fashion.Allow the user to cancel scroll actions by pressing <Esc>. By default, if the user presses the <Esc> key while dragging the slider along the scroll region, the scroll action is canceled, and both the data and the slider are returned to the position they had before the user initiated the scroll action. LBL="" HELPID=""ID="94829"Indigo Magic Scale GuidelinesWhen using the Indigo Magic scale . . . Use scales to allow users to change a value in a given range. Use scales in display-only mode to display values that the user can't control. For example, use a display-only scale as a percent-done indicator to show progress in a Working dialog. (See IDREF="17857" TYPE="TITLE""Working Dialogs" in Chapter 10.)Don't use scales for scrolling.When labelling a scale . . . Label it with the current value for the scale.If the function of the scale isn't immediately apparent, give the scale an additional label that indicates its purpose.When displaying scales . . .Keep scales updated. When a window using a scale is first opened, the slider of the scale should show the current setting for the scale control.For sliders where the user can change the value, update the value being manipulated as the user moves the slider. It should give the impression of direct, continuous manipulation. For sliders that also manipulate an object, update the object continuously as well. For sliders that are used only to display values, the slider should be immediately updated to reflect the new value as the value changes. Allow the user to cancel a scale operation by pressing <Esc>. If the user presses the <Esc> key while manipulating the scale, the action should be canceled, and the scale should return to the position it had before the user initiated the action. LBL="" HELPID=""ID="57791"Label GuidelinesWhen using labels . . . Use labels for displaying text information that the user won't need to edit or select.Use labels for labeling controls as described under the individual controls in this chapter.Use labels for labeling groups of controls. When used to label a group of controls, the label should be followed by a colon (:) and a space, and should be placed either to the left of the item in the upper left corner of the group or above and slightly to the left of the item in the upper left corner of the group.Use labels for simple instructions when necessary. Before adding instructions to any of your application windows, however, first try to design some alternatives that might make the instructions unnecessary. For example, if these instructions are necessary because the user interface works in a nonstandard way, redesigning the interface to be more standard is likely to make the instructions unnecessary.Place labels on the background of the window (that is, the part of the window that isn't recessed). When displaying labels . . . Don't change the text or graphic on a label. If this information will change, consider putting it in a noneditable text field instead; users don't expect label text to change.Disable labels when the controls they represent are disabled. Don't disable group labels.LBL="" HELPID=""ID="28474"File Finder GuidelinesWhen using the File Finder . . . Use the File Finder when the user needs to enter the pathname of a directory or file. This allows the user to drag and drop desktop icons to specify the file and to navigate the file hierarchy.When a window using a file finder is first opened, the text field in the file finder should show the default or current value of the pathname, if any. This value should also be placed in the history list under the history button.LBL="" HELPID=""ID="37723"Thumbwheel GuidelinesWhen using thumbwheels . . . Use thumbwheels to change the values of continuous variables (that is, variables that don't have discrete values). For discrete values, consider a scale or dial instead.Use thumbwheels with finite ranges for zooming operations and thumbwheels with infinite range for rotating objects.When a thumbwheel is used to change a value that has a clear default, provide a home button. For example, a Directory View window has a thumbwheel that allows the user to set the size of the desktop icons. Pressing the home button on this thumbwheel sets the icons to their default size.Use thumbwheels when screen real estate is extremely limited.Don't use a thumbwheel for panning; use a scrollbar instead. A scrollbar gives the user much more information about the object being scrolled than a thumbwheel could.When displaying a thumbwheel . . . Update the object or value being manipulated as the user moves the thumbwheel. The thumbwheel should give the impression of direct, continuous manipulation.LBL="" HELPID=""ID="96812"Dial GuidelinesWhen using dials . . . Use dials as an alternative to scales for setting parameters. Dials are best for numeric parameters where the range of allowable values is small and the values are discrete.When labelling dials . . . Place a label either directly below or directly above the dial, specifying the parameter that the dial controls. When you have a group of dials, place each dial label in the same position relative to its dial (that is, either all the labels should be below the dials or all the labels should be above the dials).When displaying dials . . . When a window using a dial is first opened, the dial should show the current setting.As a dial is rotated, update the value being manipulated to reflect the new value on the dial. The dial should give the impression of direct, continuous manipulation. Also, if the dial is controlling an object, continuously update the object as the dial is manipulated.LBL="" HELPID=""ID="30622"Guidelines for Using the Various Types and Modes of DialogsWhen choosing the type and mode of a dialog . . .Use a Prompt dialog to ask users for specific information. This dialog can be modeless or modal.Use an application-modal Error dialog to tell users about an error they've made in interacting with your application.Use an application-modal Warning dialog when there's an action pending that will cause users to lose data.Use an application-modal Question dialog to ask users a specific question that they must respond to before continuing to interact with the application. Use a Working dialog when an operation takes more than 5 seconds to complete. This dialog can be modeless or modal.Use a modeless Information dialog to give users information that's of immediate importance. Use this type of dialog sparingly.Use the modeless Indigo Magic File Selection dialog to allow users to navigate the file hierarchy and choose a file. Don't use system-modal dialogs.Use modal dialogs to show static information, and update modeless dialogs dynamically as the current state changes. LBL="" HELPID=""ID="31035"Guidelines for Designing DialogsWhen choosing the window decorations, initial state, and layout of dialogs . . .Associate every dialog with a primary or support window (its parent) that's mapped to the screen.Use the window decorations and Window menu entries listed in IDREF="68452" TYPE="TABLE"Table 3-1 and described in IDREF="85826" TYPE="TITLE""Window Decorations and the Window Menu" and IDREF="15724" TYPE="TITLE""Rules for Labeling the Title Bar in Windows Other Than Main" in Chapter 3. Have the default size large enough to allow all of the components and information to be displayed in their entirety. Place the dialog on the screen either near (but not overlapping) any related information in the parent window, or in the center of the parent window if the contents of the dialog aren't related to the contents of the parent window. Locate the initial keyboard focus in the field with which the user is most likely to want to interact. Be sure the information being displayed in the dialog matches the current state of the application. If the dialog is modeless, update this information dynamically. Include a response area that contains standard dialog actions (pushbuttons) tailored to the type and purpose of the dialog. Also include an input area that consists of whatever controls are necessary for selecting objects or setting application parameters in Prompt dialogs. Include a message area in Error, Warning, Question, Working, and Information dialogs.Don't include secondary work areas; if you need additional work areas, use a support window instead.Don't include menus. If the dialog includes so much functionality that menus are necessary, you should probably use a support window.When choosing pushbutton actions for dialogs . . .Use a subset of the standard dialog actions (Yes, No, OK, Close, Apply, Retry, Stop, Pause, Resume, Clear, Reset, Cancel, and Help), and have them appear in that order. If you include additional buttons, they should appear after the OK and Apply buttons but before the Cancel and Help buttons. Include a Help button unless the situation is explained thoroughly in the dialog.Avoid using both OK and Apply on the same dialog.To decide between OK and Apply, determine whether users are more likely to use the dialog to make one set of changes at a time (if so, use OK), or whether they're more likely to want to make and apply changes repeatedly before closing the dialog (in this case, use Apply).Include a Cancel/Close button on any dialog that has an Apply button. Include a Cancel button on Working dialogs and, if possible, a Pause button (with the option of later resuming). When choosing and creating default actions . . .Whenever appropriate, choose one of the actions to be the default action. Have OK be the default action for Information dialogs (which typically have buttons only for OK and Help).Have the response that users are most likely to select be the default action for Question, Warning, Error, and any other dialogs that contain buttons but no text fields. Have the response that users are most likely to select after entering a text string be the default action for dialogs that have only one text field. Use no other controls than the buttons in the response area (such as the File Selection and Prompt dialogs).Don't have a default action for dialogs that contain multiple text fields.When labeling dialog buttons . . .Replace the "Yes" and "No" labels in Warning and Question dialogs with button names that clearly indicate the specific action that will occur if the button is clicked. Replace the "OK" or "Apply" labels in Prompt or Warning dialogs with button names that clearly indicate the specific action that will occur if the button is clicked, unless the button is used for more than one purpose, or in the rare instance that "OK" and "Apply" are used together in a Prompt dialog.In all other cases, use the OSF/Motif standard names.When deciding what content to include in specific types of dialogs . . .Use Prompt dialogs to collect information in related chunksname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'that is, avoid collecting unrelated pieces of information in the same dialog, and don't launch multiple dialog boxes sequentially to collect several pieces of information if these pieces are frequently collected at the same time.Include a description of the error, step-by-step instructions for how to recover from it, and a pointer to more information in Error dialogs. If the error involves a specific entity (for instance, a file, user, or host), name the entity in the error message. Invoke Error dialogs only when they're directly relevant to the user; for example, don't tell the user that the printer is out of paper until the user has a job in the queue. State what data is likely to be lost and why, and give the user a chance to cancel the action in Warning dialogs.Limit your use of Question dialogs to those situations where the user couldn't have provided the information in advance.  Don't use Question dialogs for questions that relate to a pending destructive actionname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for these cases, use Warning dialogs instead.Dynamically indicate how much of the operation is complete with the Indigo Magic scale used as a percent-done indicator in Working dialogs.Switch from the general-purpose pointer to the watch pointer in the parent window of a modal Working dialog. LBL="" HELPID=""ID="95778"Guidelines for Invoking DialogsWhen determining when to display a dialog and which dialog to display . . .Limit the use of dialogs to those cases when they're absolutely necessary. Don't use dialogs to provide general status informationname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'use a status area in the associated primary or support window instead. Invoke a dialog whenever users choose a menu entry that includes an ellipsis.Display the Indigo Magic File Selection dialog when the user chooses "Open..." from the File menu. The first time this dialog is opened, it should show the current working directory and no specific file. Subsequently, it should come up in the state it was last in when the user dismissed it.Display the Indigo Magic File Selection dialog when the user chooses "Save As..." from the File menu. If the file being saved doesn't exist yet, the dialog should show the current working directory and no specific file. If the file exists, the dialog should show that file's directory, and the current name of the file should be selected. When users open, close, or save changes to files, prompt them with a Warning dialog whenever these actions will cause data to be lost:In an application that allows only one document to be open at a time, when the user chooses to open another (new or existing) document and there are unsaved changes in the currently opened document. (For example, the user chooses "New," "Open," or "Reopen" from the File menu.)When the user chooses "Close" from the File menu in a co-primary window, and the co-primary window contains data that will be lost if the window is closed.When the user chooses "Exit" from the File menu, and at least one open co-primary window contains data that will be lost if the application is exited. For applications that support multiple open documents, prompt the user with a separate dialog box for each file that's currently open and has unsaved changes.Prompt users with the File Selection dialog when they choose Save from the File menu and the current file is untitled. The behavior is the same as the "Save As..." entry in this situation.Prompt users with a Warning dialog when they're interacting with the File Selection dialog and they choose a filename that already exists. Prompt users with a Warning dialog when they choose "Revert" from the File menu and the file currently has unsaved changes. Display an Information dialog when a user chooses the "Product Information" entry from the Help menu.Display the Working dialog when users initiate an operation that takes more than five seconds to complete. Note that you might have to choose one of several different platforms as your standard for estimating times of operations.LBL="" HELPID=""ID="97122"General User Feedback GuidelinesProvide graphic feedback with appropriate desktop icon designs, by using the Indigo Magic look, by changing pointer shapes appropriately, and by highlighting selected text.Be sure your application displays up-to-date informationname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in controls and components (display the settings that correspond to the currently selected object or the current values), and in information displays (such as directory views). If the information being displayed can't be dynamically updated, choose a design that looks static.Provide textual message to the user through dialogs, through status areas on your primary windows, and by changing the label of your minimized window when appropriate.LBL="" HELPID=""ID="76388"Pointer Shapes and Colors GuidelinesWhen deciding which pointers to use in your application . . . Use the standard pointers when possible.Use the upper-left pointing arrow as a general-purpose pointer; this pointer should be red with a white outline.Use the upper-right pointing arrow when a menu is pulled down from a menu bar, popped up from the right mouse button, or displayed from an option menu button. Use the watch pointer for operations that take more than 3 seconds. (For less than 3 seconds, maintain the current pointer; for more than 5 seconds, also use a work-in-progress dialog.)Use the I-beam pointer to indicate that your application is in a text-editing mode, but don't use it to indicate implicit focus over a text object within a window.Use the question mark to indicate that the user is in context-sensitive help mode.Use the sighting pointer (crosshair) to make fine position selections.Use resize pointers to indicate positions when resizing an area.Use the 4-directional arrow to indicate that either a move operation or a resize operation is in progress.Don't use the hourglass pointer; use the watch pointer instead.Don't use the X pointer (it's reserved for the window manager).Don't assign new functionality to the standard pointer shapes; instead, design your own new pointer shape.When designing new pointer shapes . . . Create a pointer shape that gives a hint about its purpose.Make the shape easy to see.Make the hotspot easy to locate.Avoid shapes that would create visual clutter."Click for Help" option (in Help menu)IDREF="ch04.services12"Context-Sensitive InformationIDREF="ch04.services26"Providing Help through a Help Menu"Context-Sensitive Help" option (in Help menu)IDREF="ch04.services27"Providing Help through a Help Menu"Copy" option (in Edit menu)IDREF="ch05.xchange5"Supporting the Clipboard Transfer Model"Cut" option (in Edit menu)IDREF="ch05.xchange4"Supporting the Clipboard Transfer Model"Index" option (in Help menu)IDREF="ch04.services33"Providing Help through a Help MenuIDREF="ch04.services20"Index of Help Topics"Keys & Shortcuts" option (in Help menu)IDREF="ch04.services35"Providing Help through a Help MenuIDREF="ch04.services22"Keyboard Shortcut Information"Overview" option (in Help menu)IDREF="ch04.services15"Overview InformationIDREF="ch04.services30"Providing Help through a Help Menu"Paste" option (in Edit menu)IDREF="ch05.xchange6"Supporting the Clipboard Transfer Model"Product Information" option (in Help menu)IDREF="ch04.services37"Providing Help through a Help MenuIDREF="ch04.services24"Product Information"Promote" option (in Edit menu)IDREF="ch05.xchange23"Supporting the Primary Transfer Model<Alt-Insert\>IDREF="ch05.xchange21"Supporting the Primary Transfer Model<Begin\> keyIDREF="ch01.deskoverview42"Mouse and Keyboard Hardware<Cancel\> keyIDREF="ch01.deskoverview36"Mouse and Keyboard Hardware<Enter\> keyIDREF="ch01.deskoverview35"Mouse and Keyboard Hardware<Escape\> keyIDREF="ch01.deskoverview37"Mouse and Keyboard Hardware<F1\> keyIDREF="ch01.deskoverview39"Mouse and Keyboard Hardware<Help\> keyIDREF="ch01.deskoverview38"Mouse and Keyboard Hardware<Home\> keyIDREF="ch01.deskoverview43"Mouse and Keyboard Hardware<Menu\> keyIDREF="ch01.deskoverview40"Mouse and Keyboard Hardware<Return\> keyIDREF="ch01.deskoverview34"Mouse and Keyboard Hardware<Shft\><F10\> keyIDREF="ch01.deskoverview41"Mouse and Keyboard Hardware<Shft\><F1\> keyIDREF="ch04.services28"Providing Help through a Help MenuIDREF="ch04.services13"Context-Sensitive Information4-directional arrow pointerIDREF="ch11.feedback27"Standard Pointer Shapes and Colorsapplication icons (Desktop icons)IDREF="ch02.icons14"Application Icon Designapplicationsdata exchangeIDREF="ch05.xchange2"Data Exchange on the Indigo Magic Desktopediting textIDREF="ch04.services58"Editor Preference SettinglocationsIDREF="ch02.icons26"Naming and Locating Executables for the Find an Icon ToolnamingIDREF="ch02.icons24"Naming and Locating Executables for the Find an Icon ToolAuto Window PlacementIDREF="ch04.services54"Auto Window Placement SettingBMenuIDREF="ch01.deskoverview29"Mouse and Keyboard HardwareBSelectIDREF="ch01.deskoverview25"Mouse and Keyboard HardwareBTransferIDREF="ch01.deskoverview27"Mouse and Keyboard HardwarecheckboxesIndigo Magic lookIDREF="ch11.feedback9"Provide Graphic Feedbackclipboard data, nonpersistentIDREF="ch05.xchange10"Supporting the Clipboard Transfer Modelclipboard transfer modelIDREF="ch05.xchange3"Supporting the Clipboard Transfer Modelprimary transfer model, independenceIDREF="ch05.xchange24"Supporting the Primary Transfer ModelIDREF="ch05.xchange11"Supporting the Clipboard Transfer Modelco-primary windowsHelp buttonIDREF="ch04.services41"Providing Help Through a Help ButtoncolorsDesktop iconsIDREF="ch02.icons9"Icon Colors4Dwmwindow manager:See also window managersIDREF="ch01.deskoverview2"Overview of the Desktop4Dwmwindow managerIDREF="ch01.deskoverview4"Overview of the Desktopcontext-sensitive helpIDREF="ch04.services11"Context-Sensitive InformationIDREF="ch04.services29"Providing Help through a Help Menuwriting help contentIDREF="ch04.services46"Writing Context-Sensitive Helpcontrol panelsDesktopIDREF="ch04.services57"Editor Preference SettingIDREF="ch11.feedback15"Provide Messages to the UserLanguageIDREF="ch04.services55"Language SettingMouse SettingsIDREF="ch04.services56"Mouse Double-Click Speed Settingcopying dataIDREF="ch05.xchange14"Supporting the Primary Transfer ModelIDREF="ch05.xchange8"Supporting the Clipboard Transfer Modelcross hair pointerIDREF="ch11.feedback25"Standard Pointer Shapes and ColorsCustomize control panelsIDREF="ch01.deskoverview12"Overview of the Desktopcut and paste. See data exchangeIDREF="ch05.xchange1"Data Exchange on the Indigo Magic Desktopcutting dataIDREF="ch05.xchange7"Supporting the Clipboard Transfer Modeldata exchangeIDREF="ch05.xchange2"Data Exchange on the Indigo Magic Desktop<Alt-Insert\>IDREF="ch05.xchange21"Supporting the Primary Transfer Modelclipboard data, nonpersistentIDREF="ch05.xchange10"Supporting the Clipboard Transfer Modelclipboard transfer modelIDREF="ch05.xchange3"Supporting the Clipboard Transfer Modelprimary transfer model, independenceIDREF="ch05.xchange24"Supporting the Primary Transfer ModelIDREF="ch05.xchange11"Supporting the Clipboard Transfer Modelcopying dataIDREF="ch05.xchange14"Supporting the Primary Transfer ModelIDREF="ch05.xchange8"Supporting the Clipboard Transfer Modelcutting dataIDREF="ch05.xchange7"Supporting the Clipboard Transfer Modeldata types supportedIDREF="ch05.xchange26"Data Types Supported for Inter-Application Transferhighlighting selected dataIDREF="ch11.feedback11"Provide Graphic FeedbackIDREF="ch05.xchange18"Supporting the Primary Transfer Modelnonpersistent selection modelIDREF="ch05.xchange20"Supporting the Primary Transfer Modelpasting dataIDREF="ch05.xchange9"Supporting the Clipboard Transfer ModelIDREF="ch05.xchange15"Supporting the Primary Transfer Modelpersistent always selection modelIDREF="ch05.xchange19"Supporting the Primary Transfer Modelprimary selectionIDREF="ch05.xchange17"Supporting the Primary Transfer ModelreinstatingIDREF="ch05.xchange22"Supporting the Primary Transfer Modelprimary transfer modelIDREF="ch05.xchange13"Supporting the Primary Transfer Modelclipboard transfer model, independenceIDREF="ch05.xchange12"Supporting the Clipboard Transfer ModelIDREF="ch05.xchange25"Supporting the Primary Transfer Modeldata typesdata exchange, supportedIDREF="ch05.xchange26"Data Types Supported for Inter-Application TransferDesksDesks OverviewIDREF="ch01.deskoverview13"Overview of the DesktopDesks OverviewIDREF="ch01.deskoverview13"Overview of the DesktopDesktopicons. See Desktop iconsIDREF="ch01.deskoverview7"Overview of the DesktopoverviewIDREF="ch01.deskoverview1"Overview of the Indigo Magic DesktopDesktop control panelIDREF="ch04.services57"Editor Preference Settingstderr messagesIDREF="ch11.feedback15"Provide Messages to the UserDesktop iconsIDREF="ch11.feedback4"Provide Graphic FeedbackIDREF="ch02.icons4"IconsIDREF="ch01.deskoverview8"Overview of the Desktop0IDREF="ch02.icons2"Iconsapplication iconsIDREF="ch02.icons14"Application Icon Designbehavior, programmingIDREF="ch02.icons20"Defining the Behavior of Icons With FTRscolorsIDREF="ch02.icons19"File Icon DesignIDREF="ch02.icons9"Icon ColorscomponentsIDREF="ch02.icons6"Icon Componentsdesigning appearanceIDREF="ch02.icons5"Designing the Appearance of Iconsfile iconsIDREF="ch02.icons17"File Icon Designgeneric data file symbolIDREF="ch02.icons18"File Icon Designgeneric executable symbol (magic carpet)IDREF="ch02.icons7"Icon ComponentsIDREF="ch02.icons15"Application Icon DesignIcon CatalogIDREF="ch02.icons23"Making Application Icons AccessibleIDREF="ch01.deskoverview9"Overview of the Desktopicon colorIDREF="ch02.icons10"Icon Colorslaunching applicationsIDREF="ch02.icons21"Defining the Behavior of Icons With FTRsIDREF="ch01.deskoverview15"How Users Interact With Desktop IconsorientationIDREF="ch02.icons13"Icon Orientationoutline colorIDREF="ch02.icons12"Icon Colorsprinting filesIDREF="ch02.icons22"Defining the Behavior of Icons With FTRsshadow colorIDREF="ch02.icons19"File Icon DesignsizeIDREF="ch02.icons8"Icon SizestatesIDREF="ch02.icons16"Application Icon DesignIDREF="ch01.deskoverview16"How Users Interact With Desktop IconsIDREF="ch11.feedback4"Provide Graphic FeedbackIDREF="ch02.icons11"Icon Colorsuser interactionIDREF="ch01.deskoverview14"How Users Interact With Desktop IconsDesktop servicesIDREF="ch04.services1"Indigo Magic Desktop ServicesAuto Window PlacementIDREF="ch04.services54"Auto Window Placement Settingeditor, preferredIDREF="ch04.services57"Editor Preference SettingFile Alteration Monitor (FAM)IDREF="ch04.services59"File Alteration Monitor (FAM)Language control panelIDREF="ch04.services55"Language Settingmousedouble-click speedIDREF="ch04.services56"Mouse Double-Click Speed Settingonline documentationIDREF="ch04.services52"Online Documentationonline helpIDREF="ch04.services8"Online Helpcontext-sensitiveIDREF="ch04.services29"Providing Help through a Help MenuIDREF="ch04.services11"Context-Sensitive InformationHelp buttonIDREF="ch04.services16"Overview InformationIDREF="ch04.services39"Providing Help Through a Help ButtonHelp menuIDREF="ch04.services25"Providing Help through a Help MenuindexIDREF="ch04.services34"Providing Help through a Help MenuIDREF="ch04.services19"Index of Help Topicskeyboard shortcutsIDREF="ch04.services21"Keyboard Shortcut InformationIDREF="ch04.services36"Providing Help through a Help MenuoverviewIDREF="ch04.services31"Providing Help through a Help MenuIDREF="ch04.services14"Overview Informationproduct informationIDREF="ch04.services38"Providing Help through a Help MenuIDREF="ch04.services23"Product Informationtask-orientedIDREF="ch04.services32"Providing Help through a Help MenuIDREF="ch04.services17"Task-Oriented Informationwriting help contentIDREF="ch04.services44"Writing Online Help Content for SGIHelpschemesIDREF="ch04.services53"Scheme Settingsoftware installationIDREF="ch04.services2"Software InstallationdialogsHelp buttonIDREF="ch04.services43"Providing Help Through a Help Buttonuser feedbackIDREF="ch11.feedback16"Provide Messages to the Userdirectoriesmonitoring changesIDREF="ch04.services60"File Alteration Monitor (FAM)Directory ViewsIDREF="ch01.deskoverview6"Overview of the Desktopdisplays, updatingIDREF="ch11.feedback12"Keep Information Up to Datedocumenation, onlineIDREF="ch04.services52"Online Documentationdouble-click speed, mouseIDREF="ch04.services56"Mouse Double-Click Speed Settingdrag state, Desktop iconsIDREF="ch01.deskoverview21"How Users Interact With Desktop Iconsdrop-accepting state, Desktop iconsIDREF="ch01.deskoverview22"How Users Interact With Desktop IconsEdit menu"Copy" optionIDREF="ch05.xchange5"Supporting the Clipboard Transfer Model"Cut" optionIDREF="ch05.xchange4"Supporting the Clipboard Transfer Model"Paste" optionIDREF="ch05.xchange6"Supporting the Clipboard Transfer Model"Promote" optionIDREF="ch05.xchange23"Supporting the Primary Transfer Modeleditor, preferredIDREF="ch04.services57"Editor Preference SettingFAM (File Alteration Monitor)IDREF="ch04.services59"File Alteration Monitor (FAM)feedback. See user feedbackIDREF="ch11.feedback1"User FeedbackFile Alteration Monitor (FAM)IDREF="ch04.services59"File Alteration Monitor (FAM)file icons (Desktop icons)IDREF="ch02.icons17"File Icon DesignFile Typing Rules (FTRs)IDREF="ch02.icons20"Defining the Behavior of Icons With FTRsfilesmonitoring changesIDREF="ch04.services60"File Alteration Monitor (FAM)Find an Icon toolIDREF="ch01.deskoverview10"Overview of the DesktopIDREF="ch02.icons25"Naming and Locating Executables for the Find an Icon ToolFTRs (File Typing Rules)IDREF="ch02.icons20"Defining the Behavior of Icons With FTRsgeneric data file symbol (Desktop icons)IDREF="ch02.icons18"File Icon Designgeneric executable symbol (Desktop Icons)IDREF="ch02.icons7"Icon ComponentsIDREF="ch02.icons15"Application Icon Designgraphic feedbackIDREF="ch11.feedback3"Provide Graphic Feedbackhardware descriptionIDREF="ch01.deskoverview23"Mouse and Keyboard HardwareHelp buttonIDREF="ch04.services16"Overview InformationIDREF="ch04.services39"Providing Help Through a Help Buttonwriting help contentIDREF="ch04.services51"Writing for Windows With Help Buttonshelp cardsIDREF="ch04.services45"Learning About SGIHelpHelp menuIDREF="ch04.services25"Providing Help through a Help Menu"Click for Help" optionIDREF="ch04.services12"Context-Sensitive Information"Index" optionIDREF="ch04.services20"Index of Help Topics"Keys & Shortcuts" optionIDREF="ch04.services22"Keyboard Shortcut Information"Overview" optionIDREF="ch04.services15"Overview Information"Product Information" optionIDREF="ch04.services24"Product Informationtask optionsIDREF="ch04.services18"Task-Oriented Informationhelp. See online helpIDREF="ch04.services9"Online Helphighlighting selected dataIDREF="ch05.xchange18"Supporting the Primary Transfer ModelIDREF="ch11.feedback11"Provide Graphic Feedbackhourglass pointerIDREF="ch11.feedback28"Standard Pointer Shapes and ColorsI-beam pointerIDREF="ch11.feedback23"Standard Pointer Shapes and ColorsIcon CatalogIDREF="ch01.deskoverview9"Overview of the DesktopIDREF="ch02.icons23"Making Application Icons Accessibleicon color, Desktop iconsIDREF="ch02.icons10"Icon Colorsicons. See Desktop icons, minimized windowsIDREF="ch02.icons3"Iconsindex, help topicsIDREF="ch04.services34"Providing Help through a Help MenuIDREF="ch04.services19"Index of Help Topicswriting help contentIDREF="ch04.services49"Writing Index InformationIndigo Magic lookcheckboxesIDREF="ch11.feedback9"Provide Graphic Feedbacklocate highlightIDREF="ch11.feedback6"Provide Graphic Feedbackradio buttonsIDREF="ch11.feedback8"Provide Graphic FeedbackscrollbarsIDREF="ch11.feedback7"Provide Graphic Feedbackuser feedbackIDREF="ch11.feedback5"Provide Graphic Feedbackinstalling softwareIDREF="ch04.services4"Software InstallationinternationalizationIDREF="ch04.services55"Language SettingFigTitleMarginIDREF="ch03.windows1"Choosing an Image for Your Minimized Windowkeyboard descriptionIDREF="ch01.deskoverview31"Mouse and Keyboard Hardwarekeyboard shortcutshelpIDREF="ch04.services21"Keyboard Shortcut InformationIDREF="ch04.services36"Providing Help through a Help Menuwriting help contentIDREF="ch04.services50"Writing Keyboard Shortcut InformationkeysspecialIDREF="ch04.services13"Context-Sensitive InformationIDREF="ch04.services28"Providing Help through a Help MenuIDREF="ch01.deskoverview32"Mouse and Keyboard Hardwaresubstitutes to Motif-compliant keysIDREF="ch01.deskoverview33"Mouse and Keyboard HardwareLanguage control panelIDREF="ch04.services55"Language Settinglaunching applicationsDesktop iconsIDREF="ch01.deskoverview15"How Users Interact With Desktop IconsIDREF="ch02.icons21"Defining the Behavior of Icons With FTRsleft mouse buttonIDREF="ch01.deskoverview26"Mouse and Keyboard Hardwaredata exchangeIDREF="ch05.xchange16"Supporting the Primary Transfer Modellocate highlightIDREF="ch11.feedback6"Provide Graphic Feedbacklocated state, Desktop iconsIDREF="ch01.deskoverview18"How Users Interact With Desktop IconslocationsapplicationsIDREF="ch02.icons26"Naming and Locating Executables for the Find an Icon Toolmagic carpet, icon componentIDREF="ch02.icons7"Icon ComponentsIDREF="ch02.icons15"Application Icon Designmain windowsHelp buttonIDREF="ch04.services40"Providing Help Through a Help Buttonmessages, userIDREF="ch11.feedback13"Provide Messages to the Usermiddle mouse buttonIDREF="ch01.deskoverview28"Mouse and Keyboard Hardwaredata exchangeIDREF="ch05.xchange16"Supporting the Primary Transfer Modelminimized windows:See also Desktop iconsIDREF="ch02.icons1"IconslabelsIDREF="ch11.feedback18"Provide Messages to the Usermonitoring, files and directoriesIDREF="ch04.services60"File Alteration Monitor (FAM)mousebuttonsIDREF="ch01.deskoverview24"Mouse and Keyboard Hardwaredata exchangeIDREF="ch05.xchange16"Supporting the Primary Transfer ModeldescriptionIDREF="ch01.deskoverview24"Mouse and Keyboard Hardwaredouble-click speedIDREF="ch04.services56"Mouse Double-Click Speed SettingMouse Settings control panelIDREF="ch04.services56"Mouse Double-Click Speed SettingnamingapplicationsIDREF="ch02.icons24"Naming and Locating Executables for the Find an Icon Toolneutral state, Desktop iconsIDREF="ch01.deskoverview17"How Users Interact With Desktop Iconsnonpersistent selection modelIDREF="ch05.xchange20"Supporting the Primary Transfer Modelonline documentationIDREF="ch04.services52"Online Documentationonline helpIDREF="ch04.services8"Online Helpcontext-sensitiveIDREF="ch04.services11"Context-Sensitive InformationIDREF="ch04.services29"Providing Help through a Help Menuwriting help contentIDREF="ch04.services46"Writing Context-Sensitive HelpHelp buttonIDREF="ch04.services39"Providing Help Through a Help ButtonIDREF="ch04.services16"Overview Informationwriting help contentIDREF="ch04.services51"Writing for Windows With Help ButtonsHelp menuIDREF="ch04.services25"Providing Help through a Help MenuindexIDREF="ch04.services34"Providing Help through a Help MenuIDREF="ch04.services19"Index of Help Topicswriting help contentIDREF="ch04.services49"Writing Index Informationkeyboard shortcutsIDREF="ch04.services21"Keyboard Shortcut InformationIDREF="ch04.services36"Providing Help through a Help Menuwriting help contentIDREF="ch04.services50"Writing Keyboard Shortcut InformationoverviewIDREF="ch04.services31"Providing Help through a Help MenuIDREF="ch04.services14"Overview Informationwriting help contentIDREF="ch04.services47"Writing Overview Informationproduct informationIDREF="ch04.services38"Providing Help through a Help MenuIDREF="ch04.services23"Product Informationtask-orientedIDREF="ch04.services17"Task-Oriented InformationIDREF="ch04.services32"Providing Help through a Help Menuwriting help contentIDREF="ch04.services48"Writing Task Informationwriting help contentIDREF="ch04.services44"Writing Online Help Content for SGIHelpopen state, Desktop iconsIDREF="ch01.deskoverview20"How Users Interact With Desktop Iconsoutline color, Desktop iconsIDREF="ch02.icons12"Icon Colorsoverview helpIDREF="ch04.services14"Overview InformationIDREF="ch04.services31"Providing Help through a Help Menuwriting help contentIDREF="ch04.services47"Writing Overview Informationpackaging software for installationIDREF="ch04.services7"Software Installationparagraph TagsFigTitleMarginIDREF="ch03.windows1"Choosing an Image for Your Minimized Windowpasting dataIDREF="ch05.xchange9"Supporting the Clipboard Transfer ModelIDREF="ch05.xchange15"Supporting the Primary Transfer Modelpersistent always selection modelIDREF="ch05.xchange19"Supporting the Primary Transfer ModelpointerdesigningIDREF="ch11.feedback30"Designing New Pointer Shapesshapes, state andIDREF="ch11.feedback10"Provide Graphic FeedbackIDREF="ch11.feedback19"Pointer Shapes and Colorspreferred editorIDREF="ch04.services57"Editor Preference Settingprimary selectionIDREF="ch05.xchange17"Supporting the Primary Transfer ModelreinstatingIDREF="ch05.xchange22"Supporting the Primary Transfer Modelprimary transfer modelIDREF="ch05.xchange13"Supporting the Primary Transfer Modelclipboard transfer model, independenceIDREF="ch05.xchange25"Supporting the Primary Transfer ModelIDREF="ch05.xchange12"Supporting the Clipboard Transfer Modelprint filesDesktop iconsIDREF="ch02.icons22"Defining the Behavior of Icons With FTRsproduct informationIDREF="ch04.services38"Providing Help through a Help MenuIDREF="ch04.services23"Product Informationquestion mark pointerIDREF="ch11.feedback24"Standard Pointer Shapes and Colorsradio buttonsIndigo Magic lookIDREF="ch11.feedback8"Provide Graphic Feedbackresize pointerIDREF="ch11.feedback26"Standard Pointer Shapes and Colorsright mouse buttonIDREF="ch01.deskoverview30"Mouse and Keyboard HardwareschemesIDREF="ch04.services53"Scheme SettingscrollbarsIndigo Magic lookIDREF="ch11.feedback7"Provide Graphic FeedbackSearch toolIDREF="ch01.deskoverview11"Overview of the Desktopselected state, Desktop iconsIDREF="ch01.deskoverview19"How Users Interact With Desktop IconsSGIHelp system. See online helpIDREF="ch04.services10"Online Helpshadow color, Desktop iconsIDREF="ch02.icons19"File Icon Designsoftware installationIDREF="ch04.services3"Software InstallationSoftware ManagerIDREF="ch04.services5"Software InstallationSoftware PackagerIDREF="ch04.services6"Software InstallationstatesDesktop iconsIDREF="ch02.icons16"Application Icon DesignIDREF="ch11.feedback4"Provide Graphic FeedbackIDREF="ch01.deskoverview16"How Users Interact With Desktop IconsIDREF="ch02.icons11"Icon Colorspointers, shapes andIDREF="ch11.feedback19"Pointer Shapes and ColorsIDREF="ch11.feedback10"Provide Graphic Feedbackstatus areasIDREF="ch11.feedback17"Provide Messages to the Usersupport windowsHelp buttonIDREF="ch04.services42"Providing Help Through a Help Buttontask-oriented helpIDREF="ch04.services17"Task-Oriented InformationIDREF="ch04.services32"Providing Help through a Help Menuwriting help contentIDREF="ch04.services48"Writing Task InformationToolchestIDREF="ch01.deskoverview5"Overview of the Desktopupdating displaysIDREF="ch11.feedback12"Keep Information Up to Dateupper-left arrow pointerIDREF="ch11.feedback20"Standard Pointer Shapes and Colorsupper-right arrow pointerIDREF="ch11.feedback21"Standard Pointer Shapes and Colorsuser feedbackIDREF="ch11.feedback2"User FeedbackgraphicIDREF="ch11.feedback3"Provide Graphic FeedbackmessagesIDREF="ch11.feedback13"Provide Messages to the Userupdating displaysIDREF="ch11.feedback12"Keep Information Up to Dateuser messagesIDREF="ch11.feedback13"Provide Messages to the UserstderrIDREF="ch11.feedback14"Provide Messages to the UserstdoutIDREF="ch11.feedback14"Provide Messages to the Userwatch pointerIDREF="ch11.feedback22"Standard Pointer Shapes and Colorswindow managers:See also4Dwm window managerIDREF="ch01.deskoverview3"Overview of the Desktop4DwmIDREF="ch01.deskoverview4"Overview of the DesktopX pointerIDREF="ch11.feedback29"Standard Pointer Shapes and Colors