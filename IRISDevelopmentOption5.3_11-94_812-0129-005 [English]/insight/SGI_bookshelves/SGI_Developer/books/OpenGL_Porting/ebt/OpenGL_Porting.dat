#EDIR DATA#
LANG=CThe OpenGL Porting GuideDocument Number 007-1797-020CONTRIBUTORSWritten by C J Silverio, Beth Fryer, and Jed HartmanEdited by Nancy SchweigerCover design and illustration by Rob Aguilar, Rikk Carey, Dean Hodgkinson, Erik Lindholm, and Kay MaitzProduction by Lorrie WilliamsEngineering contributions by Kurt Akeley, Allen Akin, Gavin Bell, Derrick Burns, Dave Ciemiewicz, Tom Davis, Chris Frazier, Phil Karlton, Reuel Nash, Mark Segal, Dave Shreiner, Rolf van Widenfelt, and Mason Woo© Copyright 1994, Silicon Graphics, Inc.name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' All Rights ReservedThis document contains proprietary and confidential information of Silicon Graphics, Inc. The contents of this document may not be disclosed to third parties, copied, or duplicated in any form, in whole or in part, without the prior written permission of Silicon Graphics, Inc.RESTRICTED RIGHTS LEGENDUse, duplication, or disclosure of the technical data contained in this document by the Government is subject to restrictions as set forth in subdivision (c) (1) (ii) of the Rights in Technical Data and Computer Software clause at DFARS 52.227-7013 and/or in similar or successor clauses in the FAR, or in the DOD or NASA FAR Supplement. Unpublished rights reserved under the Copyright Laws of the United States. Contractor/manufacturer is Silicon Graphics, Inc., 2011 N. Shoreline Blvd., Mountain View, CA 94039-7311.Silicon Graphics and IRIS are registered trademarks and GL, Graphics Library, IRIS GL, IRIS IM, IRIS Indigo, IRIX, OpenGL, Open Inventor, Personal IRIS, and RealityEngine are trademarks of Silicon Graphics, Inc. X Window System is a trademark of Massachusetts Institute of Technology. OSF/Motif is a trademark of the Open Software Foundation, Inc.ID="37200"About This GuideThis guide tells you how to port your existing IRIS GL‘ code to OpenGL‘. It describes how to use the automatic translation script (called toogl), lists OpenGL equivalents for IRIS GL calls, describes how to reimplement IRIS GL windowing code with X and IRIS IM‘ (IRIS IM is Silicon Graphics' port of the industry-standard OSF/Motif‘ software), and gives you the basics of what you need to know about X.This book is intended for developers who have been using IRIS GL. It is not an introduction to graphics programming and it is not comprehensive OpenGL documentation. For more complete OpenGL documentation, refer to the OpenGL Programming Guide, available from Addison-Wesley.NoteThis book is written for programmers who are working in C. The Fortran and Ada wrappers for OpenGL have not yet been determined, but will be available sometime in the future. LBL="" HELPID=""How to Use This GuideAs you use this guide, you'll probably need to refer often to the OpenGL reference pages, as well as the IRIS GL reference pages and programming guide. You can read all the reference pages online using the man command, or you can buy the printed OpenGL reference pages. These are published in the OpenGL Reference Manual, available in bookstores or from Silicon Graphics.LBL="" HELPID=""What This Guide ContainsThis guide includes the following chapters:IDREF="80988" TYPE="TITLE"Chapter 1, "Introduction to Porting from IRIS GL to OpenGL," describes some of the major differences between IRIS GL and OpenGL, lists the tools Silicon GraphicsÆ provides to help you with the translation, and provides some general porting instructions.IDREF="16996" TYPE="TITLE"Chapter 2, "Using toogl," describes how to use the automatic translation tool, which can do much of the porting work for you.IDREF="17509" TYPE="TITLE"Chapter 3, "After toogl: How to Finish Porting to OpenGL," discusses IRIS GL commands that might need some extra porting attention, giving command equivalents and providing porting tips for each.IDREF="45274" TYPE="TITLE"Chapter 4, "Using the Auxiliary Library to Replace Windowing and Event Handling Calls," explains how to use the auxiliary library to replace simple windowing and event handling commands (rather than using Xt or Xlib).IDREF="37274" TYPE="TITLE"Chapter 5, "Mixed-Model Programming," describes two methods for using the X Window System‘ to manage windows and events with OpenGL: using Xt and the Silicon Graphics mixed-model programming widget or using Xlib. IRIS IM is also discussed in this chapter.IDREF="39727" TYPE="TITLE"Appendix A, "OpenGL Commands and Their IRIS GL Equivalents," is a complete alphabetical list of IRIS GL calls and their OpenGL equivalents (if an equivalent exists) along with cross-references to documentation, where available.IDREF="71689" TYPE="TITLE"Appendix B, "Differences Between OpenGL and IRIS GL," provides a more complete list of the differences between OpenGL and IRIS GL than is offered in IDREF="80988" TYPE="TITLE"Chapter 1.IDREF="18405" TYPE="TITLE"Appendix C, "Some Important OpenGL Basics," explains the OpenGL naming conventions, lists OpenGL defined types, and describes error handling in OpenGL.IDREF="13844" TYPE="TITLE"Appendix D, "Example OpenGL Program with the Auxiliary Library," provides an example OpenGL program that uses the auxiliary library for windowing and event handling.IDREF="77823" TYPE="TITLE"Appendix E, "Example Mixed-Model Program with WorkProc," provides an example OpenGL mixed-model program using Xt, IRIS IM, and the Silicon Graphics widget. The program demonstrates the use of WorkProc for animation.IDREF="77823" TYPE="TITLE"Appendix F, "Example Mixed-Model Programs With Xlib," provides two example mixed-model programs using Xlib. Each program is shown in both IRIS GL and OpenGL form.LBL="" HELPID=""Where To Get More InformationID="intro1"For more information on programming in OpenGL, refer to these manuals:OpenGL Reference Manual, from the OpenGL Architecture Review Board, published by Addison-Wesley Publishing Company, Reading, Massachusetts, 1992. ISBN 0-201-63276-4. OpenGL Programming Guide, written by Jackie Neider, Tom Davis, and Mason Woo, published by Addison-Wesley Publishing Company, Reading, Massachusetts. ISBN 0-201-63274-8For more information on programming with IRIS GL, refer to these Silicon Graphics manuals:Graphics Library Programming GuideGraphics Library Programming Tools and TechniquesFor comprehensive information on the X Window System, Xlib, Xt, and X protocol, see the Digital Press X Series:X Window System: The Complete Reference to Xlib, X Protocol, ICCCM, XLFD, Third Edition, X Version 11, Release 5, Scheifler, Robert W., and James Gettys, et al., Digital Pressname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Digital Equipment Corporation, Burlington Massachusetts, 1992. ISBN 1-55558-088-2.X Window System Toolkit: The Complete Programmer's Guide and Specification, Asente, Paul J., and Ralph R. Swick, Digital Pressname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Digital Equipment Corporation, Burlington MA, 1992. ISBN 1-55558-051-3.Or refer to the O'Reilly X Window System Series, Volumes 1, 4, and 5:Volume One: Xlib Programming Manual, by Adrian Nye, published by O'Reilly & Associates, Inc., Sebastopol, California.Volume Four: X Toolkit Intrinsics Programming Manual, by Adrian Nye and Tim O'Reilly, published by O'Reilly & Associates, Inc., Sebastopol, California.Volume Five: X Toolkit Intrinsics Reference Manual, published by O'Reilly & Associates, Inc., Sebastopol, California.For information on OSF/Motif, see the Prentice-Hall OSF/Motif series:OSF/Motif Programmer's Guide, Open Software Foundation, PTR Prentice-Hall, Inc., Englewood Cliffs, NJ.OSF/Motif Programmer's Reference, Open Software Foundation, PTR Prentice-Hall, Inc., Englewood Cliffs, NJ. OSF/Motif Style Guide, Open Software Foundation, PTR Prentice-Hall, Inc., Englewood Cliffs, NJ.LBL="" HELPID=""Style ConventionsThese style conventions are used in this guide:Boldname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Function names.Italicsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'IRIX command names, variables, arguments, parameter names, and spatial dimensions.Code examples are set off from the text in a fixed-width typeface. All code examples are in C.A family of functions whose names all start out the same way are referred to collectively using the common name-beginning and an asterisk. For instance, glColor*() refers collectively to glColor3b(), glColor4usv(), and all the other functions whose names begin with the string "glColor."LBL="1"Introduction to ID="80988"Porting from IRIS GL to OpenGLThis chapter provides an overview to porting from IRIS GL to OpenGL. It lists the most important differences between OpenGL and IRIS GL, describes some tools and libraries provided by Silicon Graphics that might help you port your code, and lists the basic steps for porting code from IRIS GL to OpenGL. It also provides some advice for programmers who do not plan to port to OpenGL immediately.LBL="" HELPID=""ID="64796"What's Different?ID="01.begin1"Due in part to OpenGL's focus on portability, OpenGL and IRIS GL differ in several major areas. This section lists a few very important ways in which OpenGL is different from IRIS GL. A more complete list of the differences between the two is provided in IDREF="71689" TYPE="TITLE"Appendix B, "Differences Between OpenGL and IRIS GL."Here are some key differences between OpenGL and IRIS GL:Since OpenGL is window-system independent, it contains no windowing, pop-up menus, event handling, color-map loading, buffer allocation/management, font file formats, or cursor handling. These functions are delegated to the window or operating system. Silicon Graphics provides a small, auxiliary library that you can use to replace simple windowing, event handling, and color-map loading calls. See IDREF="45274" TYPE="TITLE"Chapter 4, "Using the Auxiliary Library to Replace Windowing and Event Handling Calls," for more information. If you need more sophisticated windowing and event handling calls, you'll probably need to turn your program into a mixed-model program (a program that mixes X and GL calls). Silicon Graphics provides some special OpenGL/X calls and a OpenGL/X widget to help you replace your IRIS GL windowing, event, and color-map handling calls. See IDREF="37274" TYPE="TITLE"Chapter 5, "Mixed-Model Programming," for details.OpenGL establishes and adheres to a standard "name space." OpenGL commands begin with the gl prefix (glEnable(), glTranslatef(), and so on). This prevents conflict with commands from other libraries. IDREF="63238" TYPE="TITLE""OpenGL Command Names" explains the OpenGL naming conventions, and IDREF="68221" TYPE="TITLE""OpenGL Defined Types" lists the OpenGL defined types with their C data type equivalents.Like IRIS GL, OpenGL maintains many state variables (for color, fog, texture, lighting, viewport, and so on). But OpenGL manages state variables more directly and consistently than does IRIS GL. With OpenGL there are no tablesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'you just load values directly. Since OpenGL doesn't keep tables of lights and materials that you've predefined, it has no equivalent for "binds," although you can use display lists to get a similar effect. IDREF="21145" TYPE="TITLE""Porting defs, binds, and sets: Replacing `Tables' of Stored Definitions" explains how to do this. You might also refer to IDREF="20887" TYPE="TITLE""Porting Lighting and Materials Calls" and IDREF="43929" TYPE="TITLE""Porting Texture Calls" for more discussion and some examples.OpenGL display lists are not editable. In OpenGL, the sole purpose of display lists is to efficiently cache OpenGL commands. This means that IRIS GL calls for editing display lists have no OpenGL equivalentsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'if your IRIS GL code edits display lists, you'll need to reimplement to some extent. IDREF="58056" TYPE="TITLE""Porting Display Lists" lists the relevant IRIS GL calls, and IDREF="91726" TYPE="TITLE""Edited Display Lists" provides some suggestions for porting code that edits display lists. IRIS GL provides calls to handle fonts and text strings. Although OpenGL can render text, it doesn't provide a file format for fonts. For fonts and text strings, you can use the GLX call glXUseXFont() in conjunction with the OpenGL calls glCallLists() and glListBase(). IDREF="89603" TYPE="TITLE""Fonts and Strings" provides suggestions for porting fonts and strings.OpenGL provides a utility library, called the GL Utility Library (GLU), that contains additional routines (such as NURBS and quadric surfaces rendering routines). This library is discussed in the OpenGL Programming Guide. Reference pages for all the routines comprising the GLU are included in the OpenGL Reference Manual. These routines all begin with the glu prefix (gluDisk(), gluErrorString(), and so on).LBL="" HELPID=""ID="83315"Tools and Libraries to Help Port Your CodeSilicon Graphics provides some tools and libraries to help you port your code:ID="01.begin2"The toogl tool translates your program's IRIS GL calls to OpenGL calls. toogl can't translate everything (in particular, it can't translate windowing and event calls), so you have to edit the outputname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'but it does do a lot of the translation work for you. IDREF="16996" TYPE="TITLE"Chapter 2, "Using toogl," explains how to use this tool.The OpenGL extension to X (GLX) provides a variety of routines to help you replace your old IRIS GL windowing, event, and font calls. IDREF="37274" TYPE="TITLE"Chapter 5 explains how to do this. Reference pages for the GLX routines are included in the OpenGL Reference Manual. You might want to look at the glXIntro reference page first.The GLwDrawingArea and GLwMDrawingArea widgets help you port your code to mixed-model mode. (In the context of this book, a mixed-model program is a mixture of X and OpenGL, in which OpenGL is used for rendering and X is used for windowing, event handling, fonts, and so on.) These widgets provide a window with the appropriate visual and color maps needed for OpenGL, based on supplied parameters. They also provide callbacks for redraw, resize, input, and initialization. For information on how to use these widgets, see IDREF="37274" TYPE="TITLE"Chapter 5.The auxiliary library was designed to support the code examples in the OpenGL Programming Guide. It is intentionally very simple, but it does provide some simple routines that you can use to open windows, detect input, load the color map, render 3-D objects, and so on. For information on how to use the auxiliary library, see the OpenGL Programming Guide and IDREF="45274" TYPE="TITLE"Chapter 4 of this book.LBL="" HELPID=""ID="93927"How to Port Your Code to OpenGLID="01.begin3"This section lists three casesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'select the one that best matches your situation and complete the porting tasks listed (you don't need to do them in any particular order).Case 1:Your IRIS GL code is already in mixed-model mode. (A mixed-model program uses GL for rendering and X for all window system calls, including windowing and event handling.)This means it'll be much easier to port to OpenGL. Here's what you'll need to do:Run your program through a C beautifier (such as cb), then run the toogl filter script on your code. Spend some time editing its output. See IDREF="16996" TYPE="TITLE"Chapter 2 for a list of known trouble spots where hand-porting is required. You'll probably need to hand-port some of the trickier commandsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'see IDREF="17509" TYPE="TITLE"Chapter 3, "After toogl: How to Finish Porting to OpenGL," for specific suggestions.Convert your IRIS GL/X calls to OpenGL/X calls. If you used one of the mixed-model widgets, GlxDraw or GlxMDraw, switch to the OpenGL version: GLwDrawingArea or GLwMDrawingArea. The OpenGL Reference Manual contains an overview of the OpenGL Extension to the X Window System. It also includes a glXIntro reference page and reference pages for all the OpenGL/X routines. IDREF="37274" TYPE="TITLE"Chapter 5 discusses mixed-model programming in OpenGL and provides information about the OpenGL version of the Silicon Graphics mixed-model widget.Case 2:Your IRIS GL code is not in mixed-model mode, but your windowing, color map, and event handling code is reasonably simple, conforms to Silicon Graphics recommendations, and does not use unsupported calls. You can use the OpenGL Programming Guide auxiliary library to replace your IRIS GL windowing, color map, and event handling calls. Here's what you'll need to do:Replace windowing and event handling calls with auxiliary library calls. See IDREF="45274" TYPE="TITLE"Chapter 4 for porting instructions and refer to the OpenGL Programming Guide for more information on the auxiliary library.Run your program through a C beautifier (such as cb), then run the toogl filter script on your code. Spend some time editing its output. See IDREF="16996" TYPE="TITLE"Chapter 2 for a list of known trouble spots where hand-porting is required. You'll probably need to hand-port some of the trickier commandsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'see IDREF="17509" TYPE="TITLE"Chapter 3 for specific suggestions.Case 3:Your IRIS GL code is not in mixed-model mode and your windowing and event handling code uses unsupported calls, does not conform to Silicon Graphics recommendations, or is especially complicated or unusual in scope. In this case, you're probably better off porting to mixed-model mode. Here's what you'll need to do:Run your program through a C beautifier (such as cb), then run the toogl filter script on your code. Spend some time editing its output. See IDREF="16996" TYPE="TITLE"Chapter 2 for a list of known trouble spots where hand-porting is required. You'll probably need to hand-port some of the trickier commandsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'see IDREF="17509" TYPE="TITLE"Chapter 3 for specific suggestions.Port your program to the mixed-model mode (mixing OpenGL and X). You can do this either by using Xlib and directly replacing calls like winopen() and qread() with their GLX equivalents, or by using Xt along with a widget set and the OpenGL widget GLwDrawingArea. See IDREF="37274" TYPE="TITLE"Chapter 5 for more information.In all cases, after you've finished the porting tasks listed, you'll probably need to iteratively compile, run, and debug your program. If necessary, run the toogl script again to catch any IRIS GL commands that you missed. You might find it useful to refer to IDREF="99378" TYPE="TITLE""Error Handling" which gives some basic information on error handling in OpenGL.LBL="" HELPID=""ID="56142"If You're Not Porting Your Code to OpenGL YetID="01.begin4"If you're not porting to OpenGL now, but know that you will be porting in the future, it's a very good idea to switch to mixed-model mode now. Replace all GL windowing calls with GLX and X calls. Replace GL event handling with X event handling. Refer the Graphics Library Programming Tools and Techniques manual for detailed instructions. Another thing you can do now is to learn what IRIS GL features have no OpenGL equivalents. Avoid using them in new code, and reimplement code that does use them. (IDREF="39727" TYPE="TITLE"Appendix A, "OpenGL Commands and Their IRIS GL Equivalents," lists IRIS GL commands and indicates which commands are not supported in OpenGL.)Finally, replace any obsolete or unsupported calls with newer IRIS GL equivalents as soon as possible.NoteYou might also consider switching now from IRIS GL to Open Inventor‘, a powerful toolkit based on OpenGL. You can order Open Inventor from your Silicon Graphics sales representative or through Silicon Graphics Software Express.LBL="2"ID="16996"Using tooglThis chapter documents how to use and get the most from toogl. It explains where to find a copy of toogl and how to use toogl most effectively. It also mentions some areas of your IRIS GL code that might give you problems.LBL="" HELPID=""ID="10561"How to Get and Call tooglID="02.toogl1"toogl (which stands for To OpenGL and is pronounced TOO-guhl) is a script that takes IRIS GL code as input and produces commented, nearly equivalent OpenGL code as output. You can use toogl to do much of the work of translating your IRIS GL code to OpenGL code. While toogl can't do everything, it can do all the tedious work of changing command names, and it can call your attention to code you will need to port by hand. You can get a copy of toogl from /usr/people/4Dgifts/bin. If you want to look at the source (it's in C++), you can get a copy from the OpenGL directory in /usr/people/4Dgifts. (If you have any problems finding something in 4Dgifts, refer to the /usr/people/4Dgifts/README file, which explains the structure and contents of 4Dgifts.)toogl syntax:toogl [-cwq] < infile > outfileYou can use any of these options with ID="02.toogl2"toogl:-cdon't clutter up the output with comments-wdon't remove window manager calls, like winopen(), mapcolor()-qdon't remove event queue calls, like qread(), setvaluator()Notetoogl doesn't attempt to translate event queue and windowing callsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' it simply removes them, replacing them with warning comments. The -w and -q flags merely suppress the comments.Keep your original source! Accidents happen.To process a directory full of source files automatically, you could use a shell script like this one:ID="02.toogl3"#!/bin/sh
mkdir OpenGL
for i in *.c
   do
      echo "Converting " $i " ..."
      toogl < $i > OpenGL/$i
   doneLBL="" HELPID=""ID="34013"Using gdiff to Compare FilesID="02.toogl4"You'll probably find the gdiff command very helpful when editing toogl output. gdiff allows you to easily see differences between the toogl output and your original programname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'or any other version of the program. To use gdiff, type:gdiff -b file1 file2where file1 and file2 are the names of the files you want to compare. The -b option tells gdiff to ignore trailing blanks on lines when comparing files. You might also want to use the -w option, which tells gdiff to ignore white space.See the gdiff reference page for more information.LBL="" HELPID=""ID="22881"What ID="02.toogl5"toogl Will and Won't Do for Youtoogl is a filter that scans each line of an input file, looking for IRIS GL calls. When it finds an IRIS GL function, it replaces the function with the corresponding OpenGL function(s). Since toogl can't translate everything, you need to edit its output. Any time toogl translates code that you might need to look at, check, or change, it marks the potential problem with a comment starting with "OGLXXX". (You can use the -c option to suppress the comments.) LBL="" HELPID=""ID="88166"Hints for Using toogl EffectivelyID="02.toogl6"ID="02.toogl7"ID="02.toogl8"Here are a few suggestions for getting the most out of toogl:For best results, use a C beautifier (such as cb) on your code before running toogl on it.Use gdiff to browse through your source and the translation simultaneously.toogl expects to find the matching parentheses or quotes on the same line as the IRIS GL function.toogl expects to find only spaces and tabs between a function name and the opening parenthesis. For example, this code:v3f
(foo);will be left unchanged, as will:v3f /* comment */ (foo);(Running a C beautifier on your program before using toogl can prevent this sort of problem.)C comments inside the argument list of a function shouldn't contain parentheses or quote characters. Faced with the following code, ID="02.toogl9"ID="02.toogl10"toogl will generate a warning and do no translation:v3f ( foo /* I really mean bar "-) */ );LBL="" HELPID=""ID="13398"Editing toogl Output: Areas that Need Special AttentionID="02.toogl11"After you've run toogl on your code, you need to edit the output. Some areas are more problematic than othersname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' for example, v() calls usually translate quite neatly into glVertex() calls, but texture calls often don't translate well at all. This section lists some of the general areas that are likely to need special attention. IDREF="17509" TYPE="TITLE"Chapter 3, "After toogl: How to Finish Porting to OpenGL," provides more detailed information on problem areas.LBL="" HELPID=""ID="34561"Windowing, Device, and Event CallsID="02.toogl12"toogl can't translate sections of code where you make window manager, window configuration, device, or event calls, or where you load a color map. You'll need to rewrite these yourself. You can use the -w and -q options to make toogl leave this code alone, so you can still read it to translate it manually. If your windowing and event handling calls are very simple and straightforward, you can replace them with calls from the auxiliary library. IDREF="45274" TYPE="TITLE"Chapter 4, "Using the Auxiliary Library to Replace Windowing and Event Handling Calls," explains how to do this. If your windowing and event handling calls are fairly sophisticated, you'll need to switch to mixed-model programmingname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'this is explained in IDREF="37274" TYPE="TITLE"Chapter 5, "Mixed-Model Programming."LBL="" HELPID=""Parentheses and QuotesID="02.toogl13"toogl understands a little about matching parentheses and quotes. It translates:v3f( v[strlen(strcat(foo, "foo("))] );into:glVertex3fv( v[strlen(strcat(foo, "foo("))] );LBL="" HELPID=""Defined Color ConstantsID="02.toogl14"IRIS GL provides defined color constants: BLACK, BLUE, RED, GREEN, MAGENTA, CYAN, YELLOW, and WHITE. OpenGL does not provide these constants and toogl does not translate them, so you'll need to port them by hand.LBL="" HELPID=""clear() CallsID="02.toogl15"Check to make sure clear() calls are correctly translated. For example, you might have code that clears the window this way:color(BLACK);
clear();toogl translates those two lines into:glIndex(BLACK);
glClear(GL_COLOR_BUFFER_BIT);This code is incorrect, unfortunately, because OpenGL maintains a clear color, distinct from its drawing colorname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'also, OpenGL does not provide the color constant, BLACK. A better translation would be:glIndex(0);
glClearIndex(0);
glClear(GL_COLOR_BUFFER_BIT);LBL="" HELPID=""Get CallsID="02.toogl16"toogl doesn't always translate IRIS GL "get" calls (such as getdepth(), getcolor(), and so on) correctly. toogl translates:i = getcolor();
getdepth(&near, &far);into:/* OGLXXX replace value with your variable */
i = glGetIntegerv(GL_CURRENT_INDEX, &value);

/* OGLXXX You can probably do better than this. */
{
  int get_depth_tmp[2];
  glGetIntegerv(GL_DEPTH_RANGE, get_depth_tmp);
  *(&near)=get_depth_tmp[0];
  *( &far)=get_depth_tmp[1];
};This guide lists the get calls related to a particular topic in the section on that topic. For general information on replacing get calls, see IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' Commands".LBL="" HELPID=""rotate()The OpenGL rotation call, glRotate(), is somewhat different from rotate(). You'll probably need to massage the code a bit after translating with toogl. See IDREF="91369" TYPE="TITLE""Porting Matrix and Transformation Calls" for details.LBL="" HELPID=""swaptmesh()OpenGL has no equivalent for swaptmesh(); toogl merely flags occurrences of the function and leaves it up to you to restructure your triangles.LBL="" HELPID=""Texturingtoogl correctly translates texture coordinate calls, but that's about it. You'll need to do some additional work by hand. IDREF="43929" TYPE="TITLE""Porting Texture Calls" explains how. LBL="" HELPID=""defs/bindsOpenGL doesn't keep tables of lights and materials that you've predefined, so it has no equivalent for "binds." You can mimic this behavior by using display lists. See IDREF="21145" TYPE="TITLE""Porting defs, binds, and sets: Replacing `Tables' of Stored Definitions" for more information. You might also look at IDREF="20887" TYPE="TITLE""Porting Lighting and Materials Calls" and IDREF="43929" TYPE="TITLE""Porting Texture Calls" for more discussion and some examples.LBL="" HELPID=""Calls without Direct Equivalentstoogl can't directly translate some IRIS GL calls into OpenGL calls. arcf() is one example of such a call. You'll need to port such calls by hand. IDREF="84596" TYPE="TITLE""Editing toogl Output: An Example" gives an example of how you might hand-port a call like arcf().LBL="" HELPID=""Finding OpenGL Replacements for IRIS GL CallsIDREF="39727" TYPE="TITLE"Appendix A, "OpenGL Commands and Their IRIS GL Equivalents," contains a table listing IRIS GL commands and the corresponding OpenGL commands, and tells you where to go for more information. This table also indicates which IRIS GL calls are unsupported in OpenGL.LBL="" HELPID=""ID="78929"PerformanceID="02.toogl17"toogl doesn't necessarily produce fast OpenGL code; in fact, there are several aspects to an automatic port of this kind which are known to result in loss of performance. Details of improving OpenGL performance are beyond the scope of the current edition of this guide; however, you can find some specific tips in IDREF="28727" TYPE="TITLE""Porting Screen and Buffer Clearing Commands" and IDREF="20887" TYPE="TITLE""Porting Lighting and Materials Calls" in Chapter 3.Two features of OpenGL which can drastically improve performance are display lists and direct rendering. Use these features whenever possible in OpenGL programs. For information on display lists, see ID="02.toogl18"ID="02.toogl19"IDREF="58056" TYPE="TITLE""Porting Display Lists" in Chapter 3. For information on direct rendering, see the glXCreateContext() reference page. Note that if you aren't careful, it's possible to set up indirect rendering without noticing that it's indirect; specify direct rendering explicitly where possible.A few more tips:If you're drawing independent triangles, there's no need to put glBegin() and glEnd() around each set of three vertices; simply call glBegin(GL_TRIANGLES) and then list as many separate triangles as you need before the glEnd(). This optimization alone can improve performance tremendously.If you aren't using the z-buffer, be sure to disable it. This is particularly important when you call glDrawPixels() or other non-3D drawing functions.Be sure to disable texturing when calling glDrawPixels() or any other function that shouldn't use textures. (Otherwise, the texture overhead slows down drawing even if you're only drawing a bitmap.)LBL="" HELPID=""ID="84596"Editing toogl Output: An ExampleID="02.toogl20"Here's an example of how you might handle a call like arcf(). toogl translates this call:arcf(1.0, 1.0, 0.9, 1200, 2200);as:/* OGLXXX see gluPartialDisk man page */
gluPartialDisk( *gobj, innerRad, outerRad, slices, loops, startAng, endAng);The IRIS GL call arcf() can't be directly translated into an OpenGL call. The GL Utility Library call gluPartialDisk() is the nearest equivalent, but you need to fill in its arguments by hand. Compare the reference pages for the two commands, or refer to the section in this guide that discusses porting that command (in this case, IDREF="44954" TYPE="TITLE""Arcs and Circles"). Perusal of that material will tell you that you have to account for the following changes:Arcs are now quadrics and are drawn using quadric objects.Angles are now measured in degrees instead of tenths of degrees.Instead of specifying a center for your arc in the call, you now do a translation first.Angles are now measured on different coordinate axes, and the second angle is a sweep angle instead of an end angle.Your completed arcf() translation might look like this:gluQuadricObj *arcObj;
arcObj = gluNewQuadric(void);
glTranslatef( 1.0, 1.0, 0.0 );
gluPartialDisk( *arcObj, 0.0, 0.9, 100, 2, -30, -100);LBL="3"ID="17509"After toogl: How to Finish Porting to OpenGLAfter you run your IRIS GL program through toogl, you can use this chapter to find out how to replace IRIS GL calls that toogl didn't manage to translate fully. To get the most out of this discussion, refer to the reference pages as necessary. (If you want a printed version of the reference pages, buy the OpenGL Reference Manual, described in the introductory section IDREF="37200" TYPE="TITLE""About This Guide" at the beginning of this guide.) LBL="" HELPID=""ID="21136"Header FilesID="03.finish1"toogl doesn't replace header files for you, so you'll need to replace them yourself. This section lists the files your IRIS GL program probably used and which OpenGL files to replace them with.Your IRIS GL program probably uses these include lines:#include <gl/gl.h>
#include <gl/device.h>
#include <gl/get.h>In your OpenGL program, you'll need to replace these with:#include <GL/gl.h>
#include <GL/glu.h>

#include <Xm/Xm.h>          /* (These are X header files-- */
#include <Xm/Frame.h>       /* you don't need them if */
#include <Xm/Form.h>        /* you're using the auxiliary */
#include <X11/StringDefs.h> /* library instead of */
#include <X11/keysym.h>     /* mixed-model.) */If you use the auxiliary library, you'll also need to include:#include "aux.h"If your IRIS GL program uses the mixed-model widget, it uses one of these include lines:For the IRIS IM version of the widget:#include <X11/Xirisw/GlxMDraw.h>For the generic version of the widget:#include <X11/Xirisw/GLxDraw.h>For the OpenGL version, substitute these include lines:For the IRIS IM version of the widget:#include <GL/GLwMDrawA.h>For the generic version of the widget:#include <GL/GLwDrawA.h>If you're using Xlib and OpenGL/X calls, add:#include <GL/glx.h>LBL="" HELPID=""ID="62214"Porting greset()ID="03.finish2"OpenGL replaces the functionality of greset() with the commands ID="03.finish3"glPushAttrib() and ID="03.finish4"glPopAttrib(). Use these commands to save and restore groups of state variables. The command:void glPushAttrib( GLbitfield mask );takes a bitwise OR of symbolic constants, indicating which groups of state variables to push onto an attribute stack. Each constant refers to a group of state variables. IDREF="52610" TYPE="TABLE"Table 3-1 shows the attribute groups with their corresponding symbolic constant names. For a complete list of the OpenGL state variables associated with each constant, see the reference page for ID="03.finish5"glPushAttrib().COLUMNS="2"LBL="3-1"Table 3-1 ID="52610"State Attribute GroupsLEFT="0" WIDTH="189"AttributeLEFT="195" WIDTH="144"ConstantLEFT="0" WIDTH="189"accumulation buffer clear valueLEFT="195" WIDTH="144"GL_ACCUM_BUFFER_BITLEFT="0" WIDTH="189"color bufferLEFT="195" WIDTH="144"GL_COLOR_BUFFER_BITLEFT="0" WIDTH="189"currentLEFT="195" WIDTH="144"GL_CURRENT_BITLEFT="0" WIDTH="189"depth bufferLEFT="195" WIDTH="144"GL_DEPTH_BUFFER_BITLEFT="0" WIDTH="189"enableLEFT="195" WIDTH="144"GL_ENABLE_BITLEFT="0" WIDTH="189"evaluatorsLEFT="195" WIDTH="144"EGL_VAL_BITLEFT="0" WIDTH="189"fogLEFT="195" WIDTH="144"GL_FOG_BITLEFT="0" WIDTH="189"GL_LIST_BASE settingLEFT="195" WIDTH="144"GL_LIST_BITLEFT="0" WIDTH="189"hint variablesLEFT="195" WIDTH="144"GL_HINT_BITLEFT="0" WIDTH="189"lighting variablesLEFT="195" WIDTH="144"GL_LIGHTING_BITLEFT="0" WIDTH="189"line drawing modeLEFT="195" WIDTH="144"GL_LINE_BITLEFT="0" WIDTH="189"pixel mode variablesLEFT="195" WIDTH="144"GL_PIXEL_MODE_BITLEFT="0" WIDTH="189"point variablesLEFT="195" WIDTH="144"GL_POINT_BITLEFT="0" WIDTH="189"polygonLEFT="195" WIDTH="144"GL_POLYGON_BITLEFT="0" WIDTH="189"polygon stippleLEFT="195" WIDTH="144"GL_POLYGON_STIPPLE_BITLEFT="0" WIDTH="189"scissorLEFT="195" WIDTH="144"GL_SCISSOR_BITLEFT="0" WIDTH="189"stencil bufferLEFT="195" WIDTH="144"GL_STENCIL_BUFFER_BITLEFT="0" WIDTH="189"textureLEFT="195" WIDTH="144"GL_TEXTURE_BITLEFT="0" WIDTH="189"transformLEFT="195" WIDTH="144"GL_TRANSFORM_BITLEFT="0" WIDTH="189"viewportLEFT="195" WIDTH="144"GL_VIEWPORT_BITLEFT="0" WIDTH="189"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="195" WIDTH="144"GL_ALL_ATTRIB_BITSTo restore the values of the state variables to those saved with the last glPushAttrib(), simply call glPopAttrib(). The variables you didn't save will remain unchanged. The attribute stack has a finite depth of at least 16.LBL="" HELPID=""ID="66224"Porting IRIS GL `Get' CommandsID="03.finish6""Get" calls in IRIS GL were of the form:int getthing();
int getthings( int *a, int *b);Your IRIS GL code probably includes calls that look something like:thing = getthing();
if(getthing() == THING) { /* stuff */ }
getthings (&a, &b);Gets in OpenGL use glGet*() commands and look something like this:void glGetIntegerfv(NAME_OF_THING, &thing);IDREF="56942" TYPE="TABLE"Table A-1 lists the IRIS GL get commands with their OpenGL equivalents. In general, this guide lists various parameters for glGet*() functions in the sections that discuss topics related to those parameters. To see the parameter values related to matrices, for example, see IDREF="91369" TYPE="TITLE""Porting Matrix and Transformation Calls".There are other commands to query the OpenGL state, such as glGetClipPlane() and glGetLight(). These commands are discussed in the sections on related calls, as well as in the reference pages.LBL="" HELPID=""About glGet*()There are four types of glGet*() commands:glGetBooleanv()glGetIntegerv()glGetFloatv()glGetDoublev()The commands have the syntax:glGet<Datatype>v( value, *data )where value is of type GLenum and data of type GLdatatype. If you issue a glGet*() command that returns types different from the type expected, the type is converted appropriately. For a complete list of glGet*() parameters, see the reference page. LBL="" HELPID=""glGet() Conventions Used in This BookThis guide, for the sake of brevity, usually shortens the reference to the form glGet(GL_GET_TYPE). For example, glGetIntegerv(GL_VIEWPORT, *params);will be abbreviated as:glGet(GL_VIEWPORT);in tables and text (though not in code examples).LBL="" HELPID=""ID="67471"Porting Commands that Required Current Graphics PositionID="03.finish7"ID="03.finish8"OpenGL does not maintain a current graphics position. IRIS GL commands that depend on the current graphics position, such as move(), draw(), and rmv(), have no equivalents in OpenGL.ID="03.finish9"Older versions of IRIS GL included drawing commands that relied upon the current graphics position, though their use has been discouraged. You will need to reimplement if you relied on the current graphics position in any way, or used any of the following routines:draw() and move()pmv(), pdr(), and pclos()rdr(), rmv(), rpdr(), and rpmv()getgpos()OpenGL has a concept of raster position that corresponds to IRIS GL's current character position. See IDREF="92008" TYPE="TITLE""Porting Pixel Operations" for more information.LBL="" HELPID=""ID="28727"Porting Screen and Buffer Clearing CommandsOpenGL replaces a variety of IRIS GL clear() calls (such as zclear(), aclear(), sclear(), and so on) with one: glClear(). Specify exactly what you want to clear by passing masks to glClear().Porting notes:OpenGL maintains clear colors separately from drawing colors, with calls like glClearColor() and glClearIndex(). Be sure to set the clear color for each buffer before doing a clear.Since toogl has no concept of context, it will not correctly translate color calls immediately preceding clears into glClearColor() calls. You will have to do this by hand. For example, you might have cleared your viewport with code like this:color(BLACK);
clear();toogl will translate those two lines into:glIndex(BLACK);
glClear(GL_COLOR_BUFFER_BIT);That fragment might correctly read: glClearIndex(0);
glClear(GL_COLOR_BUFFER_BIT);(Remember that IRIS GL color constants, such as BLACK, are not defined in OpenGL.)Instead of using one of several differently named clear calls, you now clear several buffers with one call, glClear(), by ORing together buffer masks. For example czclear() is replaced by: glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT )IRIS GL respects the polygon stipple and the color write mask. OpenGL ignores the polygon stipple but respects the write mask. (czclear() ignored both the polygon stipple and the write mask.)IDREF="92580" TYPE="TABLE"Table 3-2 lists the various clear calls with their IRIS GL equivalents. ID="03.finish10"COLUMNS="3"LBL="3-2"Table 3-2 ID="92580"Calls for Clearing the ScreenLEFT="0" WIDTH="82"IRIS GL CallLEFT="90" WIDTH="159"OpenGL CallLEFT="255" WIDTH="91"MeaningLEFT="0" WIDTH="82"acbuf(AC_CLEAR)LEFT="90" WIDTH="159"glClear(GL_ACCUM_BUFFER_BIT)LEFT="255" WIDTH="91"clear the 
accumulation bufferLEFT="0" WIDTH="82"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="159"glClearColor()LEFT="255" WIDTH="91"set the RGBA clear 
colorLEFT="0" WIDTH="82"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="159"glClearIndex()LEFT="255" WIDTH="91"set the clear color 
indexLEFT="0" WIDTH="82"clear()LEFT="90" WIDTH="159"glClear(GL_COLOR_BUFFER_BIT)LEFT="255" WIDTH="91"clear the color bufferLEFT="0" WIDTH="82"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="159"glClearDepth()LEFT="255" WIDTH="91"specify the clear 
value for the depth 
bufferLEFT="0" WIDTH="82"zclear()LEFT="90" WIDTH="159"glClear(GL_DEPTH_BUFFER_BIT)LEFT="255" WIDTH="91"clear the depth bufferLEFT="0" WIDTH="82"czclear()LEFT="90" WIDTH="159"glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)LEFT="255" WIDTH="91"clear the color buffer 
and the depth bufferLEFT="0" WIDTH="82"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="159"glClearAccum()LEFT="255" WIDTH="91"specify clear values 
for the accumulation 
bufferLEFT="0" WIDTH="82"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="159"glClearStencil()LEFT="255" WIDTH="91"specify the clear 
value for the stencil 
bufferLEFT="0" WIDTH="82"sclear()LEFT="90" WIDTH="159"glClear(GL_STENCIL_BUFFER_BIT)LEFT="255" WIDTH="91"clear the stencil 
bufferIf your IRIS GL code used both gclear() and sclear(), you can combine them into a single glClear() callname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'this might improve your program's performance.LBL="" HELPID=""Porting ID="91369"Matrix and Transformation CallsID="03.finish11"ID="03.finish12"Porting notes:There is no single-matrix mode. You are always in double-matrix mode in OpenGL.Angles are now measured in degrees, instead of tenths of degrees.Projection matrix calls, like glFrustum() and glOrtho(), now multiply onto the current matrix, instead of being loaded onto the current matrix.The OpenGL call glRotate() is very different from rotate(). You can now rotate around any arbitrary axis, instead of being confined to the x, y, and z axes. But you will probably have to port rotate() calls by hand, since toogl often has trouble translating them. For example, toogl might translate:rotate(200*(i+1), 'z');into:glRotate(.1*(200*(i+1)), ( 'z')=='x', ( 'z')=='y', 
                         ( 'z')=='z');toogl correctly switched to degrees from tenths of degrees, but didn't correctly handle the replacement of `z' with a vector for the z-axis. A better translation would be:glRotate(.1*(200*(i+1), 0.0, 0.0, 1.0);OpenGL documentation presents matrices in a manner more consistent with standard usage in linear algebra than did IRIS GL documentation. Specifically, in IRIS GL documentation, vectors are treated as rows, and a matrix is applied to a vector on the right of the vector. ID="03.finish13"multmatrix() replaces the current matrix C with C' = MC. In OpenGL documentation, vectors are treated as columns, and a matrix applies to a vector on the left of the vector. glMultMatrix() computes C' = CM.A generic IRIS GL translation is shown in the equation in IDREF="29746" TYPE="GRAPHIC"Figure 3-1.FILE="equation_1.bw" POSITION="INLINE" SCALE="FALSE"LBL="3-1"Figure 3-1 ID="29746"A Generic IRIS GL TranslationA generic OpenGL translation is shown in the equation in IDREF="36379" TYPE="GRAPHIC"Figure 3-2.FILE="equation_2.bw" POSITION="INLINE" SCALE="FALSE"LBL="3-2"Figure 3-2 ID="36379"A Generic OpenGL TranslationThe important thing is that this is a change in documentation onlyname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'OpenGL matrices are completely compatible to the ones in IRIS GL except that they are stored in column-major order. So, if you want the matrix shown in the equation in IDREF="33798" TYPE="GRAPHIC"Figure 3-3 in your OpenGL application, you would declare it like this:float mat[16] = {a, e, i, m, b, f, j, n, c, g, 
                 k, o, d, h, l, p}FILE="equation_3.bw" POSITION="INLINE" SCALE="FALSE"LBL="3-3"Figure 3-3 ID="33798"An OpenGL Matrix ExampleOpenGL has no equivalent to the ID="03.finish14"polarview() call. You can replace such a call easily, however, with a translation and three rotations:polarview(distance, azimuth, incidence, twist);translates to:glTranslatef( 0.0, 0.0, -distance);
glRotatef( -twist * 10.0, 0.0, 0.0, 1.0);
glRotatef( -incidence * 10.0, 1.0, 0.0, 0.0);
glRotatef( -azimuth * 10.0, 0.0, 0.0, 1.0);The replacement for the ID="03.finish15"lookat() call, ID="03.finish16"gluLookAt(), takes an up vector instead of a twist angle. toogl does not translate this call correctly, so you will have to port by hand. See the reference page for gluLookAt() for more information.IDREF="62790" TYPE="TABLE"Table 3-3 lists the OpenGL matrix calls and their IRIS GL equivalents.COLUMNS="3"LBL="3-3"Table 3-3 ID="62790"Matrix OperationsLEFT="0" WIDTH="83"IRIS GL CallLEFT="90" WIDTH="86"OpenGL CallLEFT="185" WIDTH="162"MeaningLEFT="0" WIDTH="83"mmode()ID="03.finish17"LEFT="90" WIDTH="86"glMatrixMode()ID="03.finish18"LEFT="185" WIDTH="162"set current matrix modeID="03.finish19"ID="03.finish20"LEFT="0" WIDTH="83"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="86"glLoadIdentity()ID="03.finish21"LEFT="185" WIDTH="162"replace current matrix with the identity 
matrixLEFT="0" WIDTH="83"loadmatrix()ID="03.finish22"LEFT="90" WIDTH="86"glLoadMatrixf(),ID="03.finish23"glLoadMatrixd()ID="03.finish24"LEFT="185" WIDTH="162"replace current matrix with the 
specified matrixLEFT="0" WIDTH="83"multmatrix()ID="03.finish25"LEFT="90" WIDTH="86"glMultMatrixf(),ID="03.finish26"glMultMatrixd()ID="03.finish27"LEFT="185" WIDTH="162"post-multiply current matrix with the 
specified matrix (note that multmatrix() 
pre-multiplied)LEFT="0" WIDTH="83"mapw(), mapw2()ID="03.finish28"ID="03.finish29"LEFT="90" WIDTH="86"gluUnProject()ID="03.finish30"LEFT="185" WIDTH="162"project world space coordinates to 
object space (see also gluProject())ID="03.finish31"LEFT="0" WIDTH="83"ortho()ID="03.finish32"LEFT="90" WIDTH="86"glOrtho()ID="03.finish33"LEFT="185" WIDTH="162"multiply current matrix by an 
orthographic projection matrixLEFT="0" WIDTH="83"ortho2()ID="03.finish34"LEFT="90" WIDTH="86"gluOrtho2D()ID="03.finish35"LEFT="185" WIDTH="162"define a 2-dimensional orthographic 
projection matrixLEFT="0" WIDTH="83"perspective()ID="03.finish36"LEFT="90" WIDTH="86"gluPerspective()ID="03.finish37"LEFT="185" WIDTH="162"define a perspective projection matrixLEFT="0" WIDTH="83"picksize()ID="03.finish38"LEFT="90" WIDTH="86"gluPickMatrix()ID="03.finish39"LEFT="185" WIDTH="162"define a picking regionLEFT="0" WIDTH="83"popmatrix()ID="03.finish40"LEFT="90" WIDTH="86"glPopMatrix()ID="03.finish41"LEFT="185" WIDTH="162"pop current matrix stack, replacing the 
current matrix with the one below itLEFT="0" WIDTH="83"pushmatrix()ID="03.finish42"LEFT="90" WIDTH="86"glPushMatrix()ID="03.finish43"LEFT="185" WIDTH="162"push current matrix stack down by one, 
duplicating the current matrixLEFT="0" WIDTH="83"rotate(),ID="03.finish44"rot()ID="03.finish45"LEFT="90" WIDTH="86"glRotated(),ID="03.finish46"glRotatef()ID="03.finish47"LEFT="185" WIDTH="162"rotate current coordinate system by the 
given angle about the vector from the 
origin through the given point. Note 
that rotate() rotated only about the x, y, 
and z axesLEFT="0" WIDTH="83"scale()ID="03.finish48"LEFT="90" WIDTH="86"glScaled(),ID="03.finish49"glScalef()ID="03.finish50"LEFT="185" WIDTH="162"multiply current matrix by a scaling 
matrixLEFT="0" WIDTH="83"translate()ID="03.finish51"LEFT="90" WIDTH="86"glTranslatef(),ID="03.finish52" glTranslated()ID="03.finish53"LEFT="185" WIDTH="162"move coordinate system origin to the 
point specified, by multiplying the 
current matrix by a translation matrixLEFT="0" WIDTH="83"window()ID="03.finish54"LEFT="90" WIDTH="86"glFrustum()ID="03.finish55"LEFT="185" WIDTH="162"given coordinates for clipping planes, 
multiply the current matrix by a 
perspective matrixOpenGL has three matrix modes, which are set with ID="03.finish56"ID="03.finish57"glMatrixMode(). IDREF="22064" TYPE="TABLE"Table 3-4 lists the mode types available for arguments to glMatrixMode(). The corresponding mmode() arguments are listed in the second column.COLUMNS="4"LBL="3-4"Table 3-4 ID="22064"Matrix ModesLEFT="0" WIDTH="85"IRIS GL Matrix ModeLEFT="90" WIDTH="79"OpenGL ModeLEFT="175" WIDTH="95"MeaningLEFT="275" WIDTH="73"Min Stack DepthLEFT="0" WIDTH="85"MTEXTUREID="03.finish58"LEFT="90" WIDTH="79"GL_TEXTUREID="03.finish59"LEFT="175" WIDTH="95"operate on the texture 
matrix stackLEFT="275" WIDTH="73"2LEFT="0" WIDTH="85"MVIEWINGID="03.finish60"LEFT="90" WIDTH="79"GL_MODELVIEWID="03.finish61"LEFT="175" WIDTH="95"operate on the 
modelview matrix 
stackLEFT="275" WIDTH="73"32LEFT="0" WIDTH="85"MPROJECTIONID="03.finish62"LEFT="90" WIDTH="79"GL_PROJECTIONID="03.finish63"LEFT="175" WIDTH="95"operate on the 
projection matrix stackLEFT="275" WIDTH="73"2LBL="" HELPID=""ID="90887"Porting MSINGLE Mode CodeNote that OpenGL has no equivalent for MSINGLE, single-matrix mode. Though use of this mode has been discouraged, it was the default for IRIS GL and your code might have used it. If it did, you will need to reimplement. OpenGL is always in double-matrix mode, and is initially in GL_MODELVIEW mode.Most IRIS GL code in MSINGLE mode looks like this:...
projectionmatrix();
...where projectionmatrix() is one of: ortho(), ortho2(), perspective(), window(). To port to OpenGL, replace the MSINGLE mode projectionmatrix() call by:...
glMatrixMode( GL_PROJECTION );
glLoadMatrix( identity matrix );
[one of these calls: glFrustrum(), glOrtho(), glOrtho2(), gluPerspective()};
glMatrixMode( GL_MODELVIEW );
glLoadMatrix( identity matrix );LBL="" HELPID=""Porting "Get" Calls For Matrices and TransformationsIDREF="11654" TYPE="TABLE"Table 3-5 lists related gets.COLUMNS="3"LBL="3-5"Table 3-5 ID="11654"Arguments for Transformation Matrix QueriesLEFT="0" WIDTH="81"IRIS GL Matrix 
QueryLEFT="90" WIDTH="180"OpenGL glGet() Matrix QueryLEFT="275" WIDTH="72"MeaningLEFT="0" WIDTH="81"getmmode()ID="03.finish64"LEFT="90" WIDTH="180"GL_MATRIX_MODEID="03.finish65"LEFT="275" WIDTH="72"return the 
current matrix 
modeLEFT="0" WIDTH="81"getmatrix() in 
MVIEWING modeID="03.finish66"LEFT="90" WIDTH="180"GL_MODELVIEW_MATRIXID="03.finish67"LEFT="275" WIDTH="72"return a copy of 
the current 
modelview 
matrixLEFT="0" WIDTH="81"getmatrix() in 
MPROJECTION 
modeLEFT="90" WIDTH="180"GL_PROJECTION_MATRIXID="03.finish68"LEFT="275" WIDTH="72"return a copy of 
the current 
projection 
matrixLEFT="0" WIDTH="81"getmatrix() in 
MTEXTURE modeLEFT="90" WIDTH="180"GL_TEXTURE_MATRIXID="03.finish69"LEFT="275" WIDTH="72"return a copy of 
the current 
texture matrixLEFT="0" WIDTH="81"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="180"GL_MAX_MODELVIEW_STACK_DEPTHLEFT="275" WIDTH="72"return 
maximum 
supported 
depth of the 
modelview 
matrix stackLEFT="0" WIDTH="81"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="180"GL_MAX_PROJECTION_STACK_DEPTHLEFT="275" WIDTH="72"return 
maximum 
supported 
depth of the 
projection 
matrix stackLEFT="0" WIDTH="81"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="180"GL_MAX_TEXTURE_STACK_DEPTHLEFT="275" WIDTH="72"return 
maximum 
supported 
depth of the 
texture matrix 
stackLEFT="0" WIDTH="81"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="180"GL_MODELVIEW_STACK_DEPTHLEFT="275" WIDTH="72"returns number 
of matrices on 
the modelview 
stackLEFT="0" WIDTH="81"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="180"GL_PROJECTION_STACK_DEPTHLEFT="275" WIDTH="72"returns number 
of matrices on 
the projection 
stackLEFT="0" WIDTH="81"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="180"GL_TEXTURE_STACK_DEPTHLEFT="275" WIDTH="72"returns number 
of matrices on 
the texture stackLBL="" HELPID=""ID="73299"Viewports, Screenmasks, and ScrboxesThe following IRIS GL calls have no OpenGL equivalent:reshapeviewport()ID="03.finish70" (see IDREF="91085" TYPE="TITLE""Handling Redraw Events" for information on how to replace this with auxiliary library calls)ID="03.finish71"scrbox(), ID="03.finish72"getscrbox()Porting notes: With viewport(), you specified the x coordinates (in pixels) for the left and right of the viewport rectangle and the y coordinates for the top and bottom. With ID="03.finish73"glViewport(), however, you specify the x and y coordinates (in pixels) of the lower left corner of the viewport rectangle along with its width and height.IDREF="36584" TYPE="TABLE"Table 3-6 lists the OpenGL equivalents for viewport commands.COLUMNS="3"LBL="3-6"Table 3-6 ID="36584"Viewport CallsLEFT="0" WIDTH="99"IRIS GL CallLEFT="105" WIDTH="146"OpenGL CallLEFT="260" WIDTH="87"MeaningLEFT="0" WIDTH="99"viewport(left, right, 
bottom, top)ID="03.finish74"LEFT="105" WIDTH="146"glViewport(x, y, width, height)LEFT="260" WIDTH="87"set the viewportLEFT="0" WIDTH="99"popviewport()ID="03.finish75"pushviewport()ID="03.finish76"LEFT="105" WIDTH="146"glPopAttrib()glPushAttrib(GL_VIEWPORT_BIT)LEFT="260" WIDTH="87"push and pop the 
stackLEFT="0" WIDTH="99"getviewport()ID="03.finish77"LEFT="105" WIDTH="146"glGet(GL_VIEWPORT)LEFT="260" WIDTH="87"returns viewport 
dimensionsLBL="" HELPID=""ID="26684"Clipping PlanesOpenGL implements clipping planes the way IRIS GL did, though you can now also query clipping planes. IDREF="25826" TYPE="TABLE"Table 3-7 lists the OpenGL equivalents to IRIS GL calls.COLUMNS="3"LBL="3-7"Table 3-7 ID="25826"Clipping Plane CallsLEFT="0" WIDTH="135"IRIS GL CallLEFT="140" WIDTH="126"OpenGL CallLEFT="275" WIDTH="72"MeaningLEFT="0" WIDTH="135"clipplane(ID="03.finish78"i, CP_ON, params)LEFT="140" WIDTH="126"glEnable(GL_CLIP_PLANEi)LEFT="275" WIDTH="72"enable clipping 
on plane iLEFT="0" WIDTH="135"clipplane(i, CP_DEFINE, plane)LEFT="140" WIDTH="126"glClipPlane( 
GL_CLIP_PLANEID="03.finish79"i, plane)LEFT="275" WIDTH="72"define clipping 
planeLEFT="0" WIDTH="135"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="140" WIDTH="126"glGetClipPlane()ID="03.finish80"LEFT="275" WIDTH="72"returns clipping 
plane equationLEFT="0" WIDTH="135"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="140" WIDTH="126"glIsEnabled( 
GL_CLIP_PLANEi)LEFT="275" WIDTH="72"returns true if 
clip plane i is 
enabledLEFT="0" WIDTH="135"scrmask()ID="03.finish81"LEFT="140" WIDTH="126"glScissor()ID="03.finish82"LEFT="275" WIDTH="72"defines the 
scissor boxLEFT="0" WIDTH="135"getscrmask()ID="03.finish83"LEFT="140" WIDTH="126"glGet(GL_SCISSOR_BOX)LEFT="275" WIDTH="72"return the 
current scissor 
boxTo turn on the scissor test, call glEnable() with GL_SCISSOR_BOX as the parameter.LBL="" HELPID=""Porting ID="98356"Drawing CommandsID="03.finish84"The following sections discuss how to port IRIS GL drawing primitives.LBL="" HELPID=""TheID="11089" IRIS GL Sphere LibraryID="03.finish85"The sphere library that worked with IRIS GL isn't yet available for OpenGL. Look for it in a later release of OpenGL. In the meantime, you can replace your sphere library calls with quadrics routines from the GLU library. Refer to the OpenGL Programming Guide and the GLU reference pages in the OpenGL Reference Manual for details on using the GLU library. ID="03.finish86"IDREF="74711" TYPE="TABLE"Table 3-8 summarizes OpenGL quadrics calls.ID="03.finish87"COLUMNS="2"LBL="3-8"Table 3-8 ID="74711"Calls for Drawing QuadricsLEFT="0" WIDTH="108"OpenGL CallLEFT="115" WIDTH="225"MeaningLEFT="0" WIDTH="108"gluNewQuadric()ID="03.finish88"LEFT="115" WIDTH="225"create a new quadric objectLEFT="0" WIDTH="108"gluDeleteQuadric()ID="03.finish89"LEFT="115" WIDTH="225"delete a quadric objectLEFT="0" WIDTH="108"gluQuadricCallback()ID="03.finish90"LEFT="115" WIDTH="225"associate a callback with a quadric object, for error 
handlingLEFT="0" WIDTH="108"gluQuadricNormals()ID="03.finish91"LEFT="115" WIDTH="225"specify normals: no normals, one per face, or one per 
vertexLEFT="0" WIDTH="108"gluQuadricOrientation()ID="03.finish92"LEFT="115" WIDTH="225"specify direction of normals: outward or inwardLEFT="0" WIDTH="108"gluQuadricTexture()ID="03.finish93"LEFT="115" WIDTH="225"turn texture coordinate generation on or offLEFT="0" WIDTH="108"gluQuadricDrawstyle()ID="03.finish94"LEFT="115" WIDTH="225"specify drawing style: polygons, lines, points, and so onLEFT="0" WIDTH="108"gluSphere()ID="03.finish95"LEFT="115" WIDTH="225"draw a sphereLEFT="0" WIDTH="108"gluCylinder()ID="03.finish96"LEFT="115" WIDTH="225"draw a cylinder or coneLEFT="0" WIDTH="108"gluPartialDisk()ID="03.finish97"LEFT="115" WIDTH="225"draw an arcLEFT="0" WIDTH="108"gluDisk()ID="03.finish98"LEFT="115" WIDTH="225"draw a circle or diskYou can use one quadric object for all quadrics you'd like to render in similar ways. The following code fragment uses two quadrics objects to draw four quadrics, two of them textured.GLUquadricObj    *texturedQuad, *plainQuad;

texturedQuad = gluNewQuadric(void);
gluQuadricTexture(texturedQuad, GL_TRUE);
gluQuadricOrientation(texturedQuad, GLU_OUTSIDE);
gluQuadricDrawStyle(texturedQuad, GLU_FILL);

plainQuad = gluNewQuadric(void);
gluQuadricDrawStyle(plainQuad, GLU_LINE);

glColor3f (1.0, 1.0, 1.0);

gluSphere(texturedQuad, 5.0, 20, 20);
glTranslatef(10.0, 10.0, 0.0);
gluCylinder(texturedQuad, 2.5, 5, 5, 10, 10);
glTranslatef(10.0, 10.0, 0.0);
gluDisk(plainQuad, 2.0, 5.0, 10, 10);
glTranslatef(10.0, 10.0, 0.0);
gluSphere(plainQuad, 5.0, 20, 20);LBL="" HELPID=""ID="37304"The v() CommandsID="03.finish99"In IRIS GL, you use variations on the v() call to specify vertices. This call has a direct successor in OpenGL, glVertex():glVertex2[d|f|i|s][v]( x, y );glVertex3[d|f|i|s][v]( x, y, z);
glVertex4[d|f|i|s][v]( x, y, z, w);glVertex() takes suffixes the same way other OpenGL calls do. The vector versions of the call take arrays of the proper size as arguments. In the 2D version, z=0 and w=1. In the 3D version, w=1.LBL="" HELPID=""ID="49018"bgn/end CommandsID="03.finish100"IRIS GL uses the begin/end paradigm but has a different call for each graphics primitive. For example, you probably used bgnpolygon() and endpolygon() to draw polygons, and bgnline() and endline() to draw lines. With the OpenGL, you use the ID="03.finish101"glBegin()/ID="03.finish102"glEnd() structure for both. (The OpenGL draws most geometric objects by enclosing a series of calls that specify vertices, normals, textures, and colors between pairs of glBegin() and glEnd() calls.) void glBegin( GLenum mode) ;
   /* vertex list, colors, normals, textures, materials */
void glEnd( void );glBegin() takes a single argument that specifies the drawing mode, and thus the primitive. Here's an OpenGL code fragment that draws a polygon and then a line:glBegin( GL_POLYGON) ;
   glVertex2f(20.0, 10.0);
   glVertex2f(10.0, 30.0);
   glVertex2f(20.0, 50.0);
   glVertex2f(40.0, 50.0);
   glVertex2f(50.0, 30.0);
   glVertex2f(40.0, 10.0);
glEnd();
glBegin( GL_LINES ) ;
   glVertex2i(100,100);
   glVertex2i(500,500);
glEnd();In OpenGL, you draw different geometric objects by specifying different arguments to glBegin(). These arguments are listed in IDREF="16389" TYPE="TABLE"Table 3-9 below, along with the IRIS GL calls they replace (if any).COLUMNS="3"LBL="3-9"Table 3-9 ID="16389"Calls for Drawing PrimitivesLEFT="0" WIDTH="108"IRIS GL CallLEFT="115" WIDTH="108"Value of glBegin() ModeLEFT="230" WIDTH="117"MeaningLEFT="0" WIDTH="108"bgnpoint()LEFT="115" WIDTH="108"GL_POINTSLEFT="230" WIDTH="117"individual pointsLEFT="0" WIDTH="108"bgnline()LEFT="115" WIDTH="108"GL_LINE_STRIPLEFT="230" WIDTH="117"series of connected line 
segmentsLEFT="0" WIDTH="108"bgnclosedline()LEFT="115" WIDTH="108"GL_LINE_LOOPLEFT="230" WIDTH="117"series of connected line 
segments, with a segment 
added between first and last 
verticesLEFT="0" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="115" WIDTH="108"GL_LINESLEFT="230" WIDTH="117"pairs of vertices interpreted 
as individual line segmentsLEFT="0" WIDTH="108"bgnpolygon()LEFT="115" WIDTH="108"GL_POLYGONLEFT="230" WIDTH="117"boundary of a simple 
convex polygonLEFT="0" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="115" WIDTH="108"GL_TRIANGLESLEFT="230" WIDTH="117"triples of vertices 
interpreted as trianglesLEFT="0" WIDTH="108"bgntmesh()LEFT="115" WIDTH="108"GL_TRIANGLE_STRIPLEFT="230" WIDTH="117"linked strips of trianglesLEFT="0" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="115" WIDTH="108"GL_TRIANGLE_FANLEFT="230" WIDTH="117"linked fans of trianglesLEFT="0" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="115" WIDTH="108"GL_QUADSLEFT="230" WIDTH="117"quadruples of vertices 
interpreted as 
quadrilateralsLEFT="0" WIDTH="108"bgnqstrip()LEFT="115" WIDTH="108"GL_QUAD_STRIPLEFT="230" WIDTH="117"linked strips of 
quadrilateralsFor a detailed discussion of the differences between triangle meshes, strips, and fans, see IDREF="65584" TYPE="TITLE""Triangles".There is no limit to the number of vertices you can specify between a glBegin()/glEnd() pair.In addition to specifying vertices inside a glBegin()/glEnd() pair, you can also specify a current normal, current texture coordinates, and a current color. IDREF="87386" TYPE="TABLE"Table 3-10 lists the commands valid inside a glBegin()/glEnd() pair.COLUMNS="3"LBL="3-10"Table 3-10 ID="87386"Valid Commands inside a Begin/End StructureLEFT="0" WIDTH="108"IRIS GL CallID="03.finish103"LEFT="115" WIDTH="108"OpenGL EquivalentLEFT="230" WIDTH="117"MeaningLEFT="0" WIDTH="108"v2*(), v3*(), v4*()LEFT="115" WIDTH="108"glVertex*()LEFT="230" WIDTH="117"set vertex coordinatesLEFT="0" WIDTH="108"RGBcolor(), cpack()LEFT="115" WIDTH="108"glColor*()LEFT="230" WIDTH="117"set current colorLEFT="0" WIDTH="108"color(), colorf()LEFT="115" WIDTH="108"glIndex*()LEFT="230" WIDTH="117"set current color indexLEFT="0" WIDTH="108"n3f()LEFT="115" WIDTH="108"glNormal*()LEFT="230" WIDTH="117"set normal vector 
coordinatesLEFT="0" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="115" WIDTH="108"glEvalCoord()LEFT="230" WIDTH="117"evaluate enabled one- and 
two-dimensional mapsLEFT="0" WIDTH="108"callobj()LEFT="115" WIDTH="108"glCallList(), glCallLists()LEFT="230" WIDTH="117"execute display list(s)LEFT="0" WIDTH="108"t2()LEFT="115" WIDTH="108"glTexCoord()LEFT="230" WIDTH="117"set texture coordinatesLEFT="0" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="115" WIDTH="108"glEdgeFlag()LEFT="230" WIDTH="117"control drawing edgesLEFT="0" WIDTH="108"lmbind()LEFT="115" WIDTH="108"glMaterial()LEFT="230" WIDTH="117"set material propertiesIf you use any other OpenGL command inside a glBegin()/glEnd() pair, you'll get unpredictable results, or possibly an error.LBL="" HELPID=""ID="89248"PointsID="03.finish104"OpenGL has no command to draw a single point. Otherwise, porting point calls is straightforward. IDREF="16149" TYPE="TABLE"Table 3-11 lists commands for drawing points.COLUMNS="3"LBL="3-11"Table 3-11 ID="16149"Calls for Drawing PointsLEFT="0" WIDTH="72"IRIS GL CallLEFT="80" WIDTH="144"OpenGL EquivalentLEFT="230" WIDTH="117"MeaningLEFT="0" WIDTH="72"pnt()ID="03.finish105"LEFT="80" WIDTH="144"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="230" WIDTH="117"draw a single pointLEFT="0" WIDTH="72"bgnpoint(),ID="03.finish106"endpoint()ID="03.finish107"LEFT="80" WIDTH="144"glBegin(GL_POINTS), ID="03.finish108"glEnd()ID="03.finish109"LEFT="230" WIDTH="117"interpret vertices as pointsLEFT="0" WIDTH="72"pntsize()ID="03.finish110"LEFT="80" WIDTH="144"glPointSize()ID="03.finish111"LEFT="230" WIDTH="117"set point size in pixelsID="03.finish112"LEFT="0" WIDTH="72"pntsmooth()ID="03.finish113"LEFT="80" WIDTH="144"glEnable(GL_POINT_SMOOTH)ID="03.finish114"LEFT="230" WIDTH="117"turn on point antialiasing 
(see IDREF="91804" TYPE="TITLE""Porting Antialiasing 
Calls")See the glPointSize() reference page for information about related get commands.LBL="" HELPID=""ID="68126"LinesID="03.finish115"Porting code that draws lines is fairly straightforward, though you should note the differences in the way OpenGL does stipples.COLUMNS="3"LBL="3-12"Table 3-12 Calls for Drawing LinesLEFT="0" WIDTH="72"IRIS GL CallLEFT="80" WIDTH="162"OpenGL CallLEFT="250" WIDTH="99"MeaningLEFT="0" WIDTH="72"bgnclosedline(),ID="03.finish116"endclosedline()ID="03.finish117"LEFT="80" WIDTH="162"glBegin(GL_LINE_LOOP)ID="03.finish118"glEnd()ID="03.finish119"LEFT="250" WIDTH="99" draw a closed lineLEFT="0" WIDTH="72"bgnline()ID="03.finish120"LEFT="80" WIDTH="162"glBegin(GL_LINE_STRIP)LEFT="250" WIDTH="99"draw line segmentsLEFT="0" WIDTH="72"linewidth()ID="03.finish121"LEFT="80" WIDTH="162"glLineWidth()ID="03.finish122"LEFT="250" WIDTH="99"set line widthLEFT="0" WIDTH="72"getlwidth()ID="03.finish123"LEFT="80" WIDTH="162"glGet(GL_LINE_WIDTH)ID="03.finish124"LEFT="250" WIDTH="99"return current line 
widthLEFT="0" WIDTH="72"deflinestyle()ID="03.finish125"setlinestyle()ID="03.finish126"LEFT="80" WIDTH="162"glLineStipple(ID="03.finish127"factor, pattern)LEFT="250" WIDTH="99"specify a line stipple 
patternLEFT="0" WIDTH="72"lsrepeat()ID="03.finish128"LEFT="80" WIDTH="162"factor argument of glLineStipple()LEFT="250" WIDTH="99"set a repeat factor for 
the line styleLEFT="0" WIDTH="72"getlstyle()ID="03.finish129"LEFT="80" WIDTH="162"glGet(GL_LINE_STIPPLE_PATTERN)LEFT="250" WIDTH="99"return line stipple 
patternLEFT="0" WIDTH="72"getlsrepeat()ID="03.finish130"LEFT="80" WIDTH="162"glGet(GL_LINE_STIPPLE_REPEAT)LEFT="250" WIDTH="99"return repeat factorLEFT="0" WIDTH="72"linesmooth(), ID="03.finish131"smoothline()ID="03.finish132"LEFT="80" WIDTH="162"glEnable(GL_LINE_SMOOTH)LEFT="250" WIDTH="99"turn on line 
antialiasing (see 
IDREF="91804" TYPE="TITLE""Porting Antialiasing 
Calls")Note that there are no tables for line stipples. OpenGL maintains only one line stipple pattern. You can use glPushAttrib() and glPopAttrib() to switch between different stipple patterns. Old-style line style routines are not supported by OpenGL. You might have used these calls: draw(), ID="03.finish133"lsbackup(), ID="03.finish134"getlsbackup(), ID="03.finish135"resetls(), ID="03.finish136"getresetls(). If so, you will have to reimplement.For information on drawing antialiased lines, see IDREF="91804" TYPE="TITLE""Porting Antialiasing Calls".LBL="" HELPID=""ID="83655"Polygons and QuadrilateralsID="03.finish137"Porting notes:There is no direct equivalent for ID="03.finish138"concave(TRUE). You might want to use the tessellation routines in the GLU, described in IDREF="26633" TYPE="TITLE""Tessellated Polygons".Polygon modes are now set differently.ID="03.finish139"These older polygon drawing calls have no direct equivalents in OpenGL:the ID="03.finish140"poly() family of routinesthe ID="03.finish141"polf() family of routinesID="03.finish142"pmv(), ID="03.finish143"pdr(), and ID="03.finish144"pclos()ID="03.finish145"rpmv() and ID="03.finish146"rpdr()ID="03.finish147"splf()ID="03.finish148"spclos()If you used them, you'll have to reimplement using glBegin(GL_POLYGON). IDREF="16389" TYPE="TABLE"Table 3-9 lists the OpenGL equivalents to IRIS GL polygon drawing calls.COLUMNS="3"LBL="3-13"Table 3-13 ID="16389"Calls for Drawing PolygonsLEFT="0" WIDTH="81"IRIS GL CallLEFT="90" WIDTH="135"OpenGL EquivalentLEFT="230" WIDTH="117"MeaningLEFT="0" WIDTH="81"bgnpolygon(), 
endpolygon()ID="03.finish149"ID="03.finish150"LEFT="90" WIDTH="135"glBegin(GL_POLYGON),ID="03.finish151"glEnd()ID="03.finish152"LEFT="230" WIDTH="117"vertices define boundary of 
a simple convex polygonLEFT="0" WIDTH="81"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="135"glBegin(GL_QUADS),glEnd()LEFT="230" WIDTH="117"interpret quadruples of 
vertices as quadrilateralsLEFT="0" WIDTH="81"bgnqstrip(), 
endqstrip()ID="03.finish153"ID="03.finish154"LEFT="90" WIDTH="135"glBegin(GL_QUAD_STRIP),glEnd()LEFT="230" WIDTH="117"interpret vertices as linked 
strips of quadrilateralsLEFT="0" WIDTH="81"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="135"glEdgeFlag()ID="03.finish155"LEFT="230" WIDTH="117"LEFT="0" WIDTH="81"polymode()ID="03.finish156"LEFT="90" WIDTH="135"glPolygonMode()ID="03.finish157"LEFT="230" WIDTH="117"set polygon drawing modeLEFT="0" WIDTH="81"rect(), ID="03.finish158"rectf(),ID="03.finish159"LEFT="90" WIDTH="135"glRect()ID="03.finish160"ID="03.finish161"LEFT="230" WIDTH="117"draw a rectangleLEFT="0" WIDTH="81"sbox(), ID="03.finish162"sboxf()ID="03.finish163"LEFT="90" WIDTH="135"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="230" WIDTH="117"draw a screen-aligned 
rectangleLBL="" HELPID=""Polygon ModesID="03.finish164"The call for setting the polygon mode has changed slightly. The OpenGL call glPolygonMode()ID="03.finish165" allows you to specify which side of a polygon (the back or the front) that the mode applies to. Its syntax is:void glPolygonMode( GLenum face, GLenum mode )where face is one of:GL_FRONTmode applies to front-facing polygonsGL_BACKmode applies to back-facing polygonsGL_FRONT_AND_BACKmode applies to both front- and back-facing polygonsThe equivalents to IRIS GL ID="03.finish166"polymode() calls would use GL_FRONT_AND_BACK. IDREF="29723" TYPE="TABLE"Table 3-14 lists IRIS GL polygon modes and the corresponding OpenGL modes.COLUMNS="3"LBL="3-14"Table 3-14 ID="29723"Polygon ModesLEFT="0" WIDTH="108"IRIS GL ModeLEFT="115" WIDTH="108"OpenGL ModeLEFT="230" WIDTH="117"MeaningLEFT="0" WIDTH="108"PYM_POINTLEFT="115" WIDTH="108"GL_POINTLEFT="230" WIDTH="117"draw vertices as pointsLEFT="0" WIDTH="108"PYM_LINELEFT="115" WIDTH="108"GL_LINELEFT="230" WIDTH="117"draw boundary edges as 
line segmentsLEFT="0" WIDTH="108"PYM_FILLLEFT="115" WIDTH="108"GL_FILLLEFT="230" WIDTH="117"draw polygon interior filledLEFT="0" WIDTH="108"PYM_HOLLOWLEFT="115" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="230" WIDTH="117"fill only interior pixels at the 
boundariesLBL="" HELPID=""Polygon StipplesID="03.finish167"Porting notes:There are no tables for polygon stipples. OpenGL keeps only one stipple pattern. You can use display lists to store different stipple patterns.The polygon stipple bitmap size is always a 32x32 bit pattern.Stipple encoding is affected by ID="03.finish168"glPixelStore(). See IDREF="92008" TYPE="TITLE""Porting Pixel Operations" for more information.IDREF="26272" TYPE="TABLE"Table 3-15 lists polygon stipple calls.COLUMNS="3"LBL="3-15"Table 3-15 ID="26272"Polygon Stipple CallsLEFT="0" WIDTH="108"IRIS GL CallLEFT="115" WIDTH="108"OpenGL CallLEFT="230" WIDTH="117"MeaningLEFT="0" WIDTH="108"defpattern()ID="03.finish169"LEFT="115" WIDTH="108"glPolygonStipple()ID="03.finish170"LEFT="230" WIDTH="117"set the stipple patternLEFT="0" WIDTH="108"setpattern()ID="03.finish171"LEFT="115" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="230" WIDTH="117"OpenGL keeps only one 
polygon stipple patternLEFT="0" WIDTH="108"getpattern()ID="03.finish172"LEFT="115" WIDTH="108"glGetPolygonStipple()ID="03.finish173"LEFT="230" WIDTH="117"return the stipple bitmap 
(used to return an index)Enable and disable polygon stippling by passing GL_POLYGON_STIPPLE as an argument to ID="03.finish174"glEnable() and ID="03.finish175"glDisable().Here's an example OpenGL code fragment that demonstrates polygon stippling:/*  polys.c  */
#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"

void display(void)
{
    GLubyte fly[] = {
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x03, 0x80, 0x01, 0xC0, 0x06, 0xC0, 0x03, 0x60,
      0x04, 0x60, 0x06, 0x20, 0x04, 0x30, 0x0C, 0x20,
      0x04, 0x18, 0x18, 0x20, 0x04, 0x0C, 0x30, 0x20,
      0x04, 0x06, 0x60, 0x20, 0x44, 0x03, 0xC0, 0x22,
      0x44, 0x01, 0x80, 0x22, 0x44, 0x01, 0x80, 0x22,
      0x44, 0x01, 0x80, 0x22, 0x44, 0x01, 0x80, 0x22,
      0x44, 0x01, 0x80, 0x22, 0x44, 0x01, 0x80, 0x22,
      0x66, 0x01, 0x80, 0x66, 0x33, 0x01, 0x80, 0xCC,
      0x19, 0x81, 0x81, 0x98, 0x0C, 0xC1, 0x83, 0x30,
      0x07, 0xe1, 0x87, 0xe0, 0x03, 0x3f, 0xfc, 0xc0,
      0x03, 0x31, 0x8c, 0xc0, 0x03, 0x33, 0xcc, 0xc0,
      0x06, 0x64, 0x26, 0x60, 0x0c, 0xcc, 0x33, 0x30,
      0x18, 0xcc, 0x33, 0x18, 0x10, 0xc4, 0x23, 0x08,
      0x10, 0x63, 0xC6, 0x08, 0x10, 0x30, 0x0c, 0x08,
      0x10, 0x18, 0x18, 0x08, 0x10, 0x00, 0x00, 0x08
    };
    GLubyte halftone[] = {
      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
      0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55
    };

    glClear (GL_COLOR_BUFFER_BIT);
    glColor3f (1.0, 1.0, 1.0); /* draw all polys in white */

/*  draw 1 solid unstippled rectangle, then 2 stippled ones*/
    glRectf (25.0, 25.0, 125.0, 125.0);
    glEnable (GL_POLYGON_STIPPLE);
    glPolygonStipple (fly);
    glRectf (125.0, 25.0, 225.0, 125.0);
    glPolygonStipple (halftone);
    glRectf (225.0, 25.0, 325.0, 125.0);
    glDisable (GL_POLYGON_STIPPLE);
    glFlush ();
}LBL="" HELPID=""ID="26633"Tessellated PolygonsID="03.finish176"The GLU has routines you can use to draw concave polygons. You no longer just use concave(TRUE) and then bgnpolygon().To draw a concave polygon with OpenGL, follow these steps:Create a tesselation object.Define callbacks that will be used to process the triangles generated by the tessellator.ID="03.finish177"Specify the concave polygon to be tessellated.IDREF="71609" TYPE="TABLE"Table 3-16 lists the calls for drawing tessellated polygons.COLUMNS="2"LBL="3-16"Table 3-16 ID="71609"Tessellated Polygon CallsLEFT="0" WIDTH="99"GLU CallLEFT="105" WIDTH="234"MeaningLEFT="0" WIDTH="99"gluNewTess()ID="03.finish178"LEFT="105" WIDTH="234"create a new tessellation objectLEFT="0" WIDTH="99"gluDeleteTess()ID="03.finish179"LEFT="105" WIDTH="234"delete a tessellation objectLEFT="0" WIDTH="99"gluTessCallback()ID="03.finish180"LEFT="105" WIDTH="234"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="99"gluBeginPolygon()ID="03.finish181"LEFT="105" WIDTH="234"begin the polygon specificationLEFT="0" WIDTH="99"gluTessVertex()ID="03.finish182"LEFT="105" WIDTH="234"specify a polygon vertex in a contoursLEFT="0" WIDTH="99"gluNextContour()ID="03.finish183"LEFT="105" WIDTH="234"indicate that the next series of vertices describe a new 
contourLEFT="0" WIDTH="99"gluEndPolygon()ID="03.finish184"LEFT="105" WIDTH="234"end the polygon specificationFor complete details, see the reference pages for the commands in IDREF="71609" TYPE="TABLE"Table 3-16.LBL="" HELPID=""ID="65584"TrianglesID="03.finish185"OpenGL provides three ways to draw triangles: separate triangles, triangle strips, and triangle fans.Porting notes:There's no equivalent for ID="03.finish186"swaptmesh(). Instead, use a combination of triangles, triangle strips, and triangle fans.If you drew individual triangles by surrounding each triangle with a bgntmesh() / endtmesh() pair, be sure to surround the entire group of individual triangles with just one glBegin(GL_TRIANGLES) / glEnd() pair in your OpenGL program, for a drastic performance increase.IDREF="61828" TYPE="TABLE"Table 3-17 lists the commands for drawing triangles.COLUMNS="3"LBL="3-17"Table 3-17 ID="61828"Calls for Drawing TrianglesLEFT="0" WIDTH="72"IRIS GL CallLEFT="80" WIDTH="144"Equivalent glBegin() ArgumentLEFT="230" WIDTH="117"MeaningLEFT="0" WIDTH="72"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="80" WIDTH="144"GL_TRIANGLESLEFT="230" WIDTH="117"triples of vertices 
interpreted as trianglesLEFT="0" WIDTH="72"bgntmesh(), 
endtmesh()ID="03.finish187"ID="03.finish188"LEFT="80" WIDTH="144"GL_TRIANGLE_STRIPLEFT="230" WIDTH="117"linked strips of trianglesLEFT="0" WIDTH="72"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="80" WIDTH="144"GL_TRIANGLE_FANLEFT="230" WIDTH="117"linked fans of trianglesLBL="" HELPID=""ID="44954"Arcs and CirclesID="03.finish189"In OpenGL, filled arcs and circles are drawn with the same calls as unfilled arcs and circles. See the reference pages for specifics. IDREF="50683" TYPE="TABLE"Table 3-18 lists the IRIS GL arc and circle commands with the corresponding OpenGL (GLU) commands.COLUMNS="3"LBL="3-18"Table 3-18 ID="50683"Calls for Drawing Arcs and Circles LEFT="0" WIDTH="54"IRIS GL CallLEFT="60" WIDTH="69"OpenGL CallLEFT="135" WIDTH="86"MeaningLEFT="0" WIDTH="54"arc(),ID="03.finish190"arcf()ID="03.finish191"LEFT="60" WIDTH="69"gluPartialDisk()ID="03.finish192"LEFT="135" WIDTH="86"draw an arcLEFT="0" WIDTH="54"circ(),ID="03.finish193"circf()ID="03.finish194"LEFT="60" WIDTH="69"gluDisk()ID="03.finish195"LEFT="135" WIDTH="86"draw a circle or diskThe gluPartialDisk() call is very different from the arc() call. Refer to the gluPartialDisk() reference page for complete information.You can do some things with OpenGL arcs and circles that you can't do with IRIS GL. Refer to the OpenGL Programming Guide and the reference pages in the OpenGL Reference Manual for detailed information on OpenGL arcs and circles (which are called disks and partial disks in OpenGL).Porting notes:ID="03.finish196"Angles are no longer measured in tenths of degrees, but simply in degrees.The start angle is measured from the positive y-axis, and not from the x.The sweep angle is now clockwise instead of counterclockwise, as shown in IDREF="71639" TYPE="GRAPHIC"Figure 3-4..FILE="03.finish.cgm4" POSITION="INLINE" SCALE="FALSE"LBL="3-4"Figure 3-4 ID="71639"Drawing Angles: IRIS GL vs. OpenGLLBL="" HELPID=""SpheresID="03.finish197"Porting notes:You can no longer control the type of primitives used to draw the sphere. You have control of drawing precision in another way: you can use the slices and stacks parameters. Slices are longitudinal; stacks are latitudinal.Spheres are now drawn centered at the origin. Instead of specifying the location, as you used to in ID="03.finish198"sphdraw() calls, precede a ID="03.finish199"gluSphere() call with a translation.The sphere library isn't yet available for OpenGLname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'see IDREF="11089" TYPE="TITLE""The IRIS GL Sphere Library" for more information about replacing sphere library calls.IDREF="69155" TYPE="TABLE"Table 3-19 lists the IRIS GL calls for drawing spheres along with the corresponding GLU calls where available. COLUMNS="3"LBL="3-19"Table 3-19 ID="69155"Calls for Drawing SpheresLEFT="0" WIDTH="81"IRIS GL CallLEFT="90" WIDTH="90"GLU CallLEFT="185" WIDTH="162"NotesLEFT="0" WIDTH="81"sphobj()ID="03.finish200"LEFT="90" WIDTH="90"gluNewQuadric()ID="03.finish201"LEFT="185" WIDTH="162"create a new sphere objectLEFT="0" WIDTH="81"sphfree()ID="03.finish202"LEFT="90" WIDTH="90"gluDeleteQuadric()ID="03.finish203"LEFT="185" WIDTH="162"delete sphere object and free memory 
usedLEFT="0" WIDTH="81"sphdraw()ID="03.finish204"LEFT="90" WIDTH="90"gluSphere()ID="03.finish205"LEFT="185" WIDTH="162"draw a sphereLEFT="0" WIDTH="81"sphmode()ID="03.finish206"LEFT="90" WIDTH="90"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="185" WIDTH="162"set sphere attributesLEFT="0" WIDTH="81"sphrotmatrix()ID="03.finish207"LEFT="90" WIDTH="90"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="185" WIDTH="162"control sphere orientationLEFT="0" WIDTH="81"sphgnpolys()ID="03.finish208"LEFT="90" WIDTH="90"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="185" WIDTH="162"return number of polygons in current 
sphereLBL="" HELPID=""ID="31702"Porting Color, Shading, and Writemask CommandsID="03.finish209"The major change you'll have to watch out for is the change in how color maps are implemented.Porting notes:Though you can set color map indices with the OpenGL ID="03.finish210"glIndex() call, OpenGL does not provide a routine for loading color map indices. If you're using the auxiliary library, see IDREF="54935" TYPE="TITLE""Using Color-Index Mode" for instructions on loading color maps. If you're using X, see IDREF="23967" TYPE="TITLE""X Color Maps" for an example code fragment that sets up a color map.Color values are normalized to their data type. See the ID="03.finish211"glColor() reference page for details.There is no simple equivalent for ID="03.finish212"cpack(). You can use glColor() instead, but you'll need to port by hand.Some calls to c() or ID="03.finish213"color() might need to be translated to glClearColor() or glClearIndex() and not glColor() or glIndex(). See IDREF="28727" TYPE="TITLE""Porting Screen and Buffer Clearing Commands" for details.The RGBA writemask is not for each bit, just each component.IRIS GL provided defined color constants: BLACK, BLUE, RED, GREEN, MAGENTA, CYAN, YELLOW, and WHITE. OpenGL does not provide these constants and ID="03.finish214"toogl does not translate them, so you'll need to port them by hand.LBL="" HELPID=""Color CallsIDREF="12951" TYPE="TABLE"Table 3-20 lists equivalent color calls.COLUMNS="3"LBL="3-20"Table 3-20 ID="12951"Color CallsLEFT="0" WIDTH="81"IRIS GL CallLEFT="90" WIDTH="144"OpenGL CallLEFT="240" WIDTH="108"MeaningLEFT="0" WIDTH="81"c3*(), c4*()ID="03.finish215"LEFT="90" WIDTH="144"glColor*()LEFT="240" WIDTH="108"sets RGB colorLEFT="0" WIDTH="81"color(), colorf()LEFT="90" WIDTH="144"glIndex*()LEFT="240" WIDTH="108"sets the color indexLEFT="0" WIDTH="81"getcolor()ID="03.finish216"LEFT="90" WIDTH="144"glGet(GL_CURRENT_INDEX)ID="03.finish217"LEFT="240" WIDTH="108"returns the current color 
indexLEFT="0" WIDTH="81"getmcolor()ID="03.finish218"LEFT="90" WIDTH="144"XQueryColor()LEFT="240" WIDTH="108"gets a copy of a colormap 
entry's RGB valuesLEFT="0" WIDTH="81"gRGBcolor()ID="03.finish219"LEFT="90" WIDTH="144"glGet(GL_CURRENT_COLOR)ID="03.finish220"LEFT="240" WIDTH="108"gets the current RGB 
color valuesLEFT="0" WIDTH="81"mapcolor()ID="03.finish221"LEFT="90" WIDTH="144"auxSetOneColor() or XStoreColor()ID="03.finish222"ID="03.finish223"LEFT="240" WIDTH="108"see IDREF="54935" TYPE="TITLE""Using Color-Index 
Mode" or IDREF="23967" TYPE="TITLE""X 
Color Maps"LEFT="0" WIDTH="81"RGBcolor()ID="03.finish224"LEFT="90" WIDTH="144"glColor()LEFT="240" WIDTH="108"sets RGB colorLEFT="0" WIDTH="81"writemask()ID="03.finish225"LEFT="90" WIDTH="144"glIndexMask()ID="03.finish226"LEFT="240" WIDTH="108"sets the color index mode 
color maskLEFT="0" WIDTH="81"wmpack()ID="03.finish227"RGBwritemask()ID="03.finish228"LEFT="90" WIDTH="144"glColorMask()ID="03.finish229"LEFT="240" WIDTH="108"sets the RGB color mode 
maskLEFT="0" WIDTH="81"getwritemask()ID="03.finish230"LEFT="90" WIDTH="144"glGet(GL_COLOR_WRITEMASK)ID="03.finish231"glGet(GL_INDEX_WRITEMASK)LEFT="240" WIDTH="108"gets the color maskLEFT="0" WIDTH="81"gRGBmask()ID="03.finish232"LEFT="90" WIDTH="144"glGet(GL_COLOR_WRITEMASK)LEFT="240" WIDTH="108"gets the color maskLEFT="0" WIDTH="81"zwritemask()ID="03.finish233"LEFT="90" WIDTH="144"glDepthMask()ID="03.finish234"LEFT="240" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'NoteBe careful when replacing zwritemask() with glDepthMask(): glDepthMask() takes a boolean argument; zwritemask() takes a bitfield.If you want to use multiple color maps, you'll need to implement them using X's colormap facilities. Therefore, ID="03.finish235"multimap(), ID="03.finish236"onemap(), ID="03.finish237"getcmmode(), setmap()ID="03.finish238", and ID="03.finish239"getmap() have no OpenGL equivalents.LBL="" HELPID=""Shading ModelsAs with IRIS GL, you can switch between smooth (Gouraud) shading and flat shading. IDREF="86023" TYPE="TABLE"Table 3-21 lists the calls.ID="03.finish240"COLUMNS="3"LBL="3-21"Table 3-21 ID="86023"Shading and DitheringLEFT="0" WIDTH="117"IRIS GL CallLEFT="125" WIDTH="131"OpenGL CallLEFT="265" WIDTH="82"MeaningLEFT="0" WIDTH="117"shademodel(FLAT)ID="03.finish241"LEFT="125" WIDTH="131"glShadeModel(GL_FLAT) ID="03.finish242"LEFT="265" WIDTH="82"do flat shadingLEFT="0" WIDTH="117"shademodel(GOURAUD)LEFT="125" WIDTH="131"glShadeModel(GL_SMOOTH)LEFT="265" WIDTH="82"do smooth shadingLEFT="0" WIDTH="117"getsm()ID="03.finish243"LEFT="125" WIDTH="131"glGet(GL_SHADE_MODEL)ID="03.finish244"LEFT="265" WIDTH="82"return current 
shade modelLEFT="0" WIDTH="117"dither(DT_ON)ID="03.finish245"dither(DT_OFF)LEFT="125" WIDTH="131"glEnable(GL_DITHER)ID="03.finish246"glDisable(GL_DITHER)ID="03.finish247"ID="03.finish248"LEFT="265" WIDTH="82"turn on dithering 
on/offSmooth shading and dithering are on by default, as in IRIS GL.LBL="" HELPID=""Porting ID="92008"Pixel OperationsID="03.finish249"Porting notes:Logical pixel operations are not applied to RGBA color buffers. See the glLogicOp() reference page for more information.In general, IRIS GL used the ABGR format for pixels (that is, with color components in the order Alpha, Blue, Green, Red), while OpenGL uses the RGBA format. Note that although glPixelStore() can reverse the order of bytes within a color component, it can't reverse the order of the components within a pixel; thus, it can't be used to convert IRIS GL pixels to OpenGL pixels. Instead, you must reverse the order of the components yourself.When porting lrectwrite() calls, be careful to note where lrectwrite() is writing (for instance, it could be writing to the depth buffer).If you wanted to read from the z-buffer in IRIS GL, you specified that buffer with readsource() and then used lrectread() or rectread() to do the reading. If you want to read from the z-buffer in OpenGL, you simply specify that buffer as a parameter to glReadPixels().OpenGL gives you some additional flexibility in pixel operations. IDREF="59087" TYPE="TABLE"Table 3-22 lists calls for pixel operations.COLUMNS="3"LBL="3-22"Table 3-22 ID="59087"Pixel OperationsLEFT="0" WIDTH="99"IRIS GL CallLEFT="105" WIDTH="117"OpenGL CallLEFT="230" WIDTH="117"MeaningLEFT="0" WIDTH="99"lrectread(), rectread(),ID="03.finish250"ID="03.finish251"readRGB()ID="03.finish252"LEFT="105" WIDTH="117"glReadPixels()ID="03.finish253"LEFT="230" WIDTH="117"read a block of pixels from 
the frame bufferLEFT="0" WIDTH="99"lrectwrite(), rectwrite()ID="03.finish254"ID="03.finish255"LEFT="105" WIDTH="117"glDrawPixels()ID="03.finish256"LEFT="230" WIDTH="117"write a block of pixels to the 
frame bufferLEFT="0" WIDTH="99"rectcopy()ID="03.finish257"LEFT="105" WIDTH="117"glCopyPixels()ID="03.finish258"LEFT="230" WIDTH="117"copy pixels in the frame 
bufferLEFT="0" WIDTH="99"rectzoom()ID="03.finish259"LEFT="105" WIDTH="117"glPixelZoom()ID="03.finish260"LEFT="230" WIDTH="117"specify pixel zoom factors 
for glDrawPixels() and 
glCopyPixels()LEFT="0" WIDTH="99"cmov()ID="03.finish261"LEFT="105" WIDTH="117"glRasterPos()ID="03.finish262"LEFT="230" WIDTH="117"specify raster position for 
pixel operationsLEFT="0" WIDTH="99"readsource()ID="03.finish263"LEFT="105" WIDTH="117"glReadBuffer()ID="03.finish264"LEFT="230" WIDTH="117"select a color buffer source 
for pixelsLEFT="0" WIDTH="99"pixmode()ID="03.finish265"LEFT="105" WIDTH="117"glPixelStore()ID="03.finish266"LEFT="230" WIDTH="117"set pixel storage modesLEFT="0" WIDTH="99"pixmode()ID="03.finish267"LEFT="105" WIDTH="117"glPixelTransfer()ID="03.finish268"LEFT="230" WIDTH="117"set pixel transfer modesLEFT="0" WIDTH="99"logicop()ID="03.finish269"LEFT="105" WIDTH="117"glLogicOp()ID="03.finish270"LEFT="230" WIDTH="117"specify a logical operation 
for pixel writesLEFT="0" WIDTH="99"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="105" WIDTH="117"glEnable(GL_LOGIC_OP)ID="03.finish271"LEFT="230" WIDTH="117"turn on pixel logic 
operationsSee the reference page for glLogicOp() for a list of possible logical operations.Here's a code fragment that shows a typical pixel write:unsigned long *packedRaster;
...
packedRaster[k] = 0x00000000;
...
lrectwrite(0, 0, xSize, ySize, packedRaster);Here is how toogl translates the call to lrectwrite():/* OGLXXX lrectwrite: see man page for glDrawPixels */
glRasterPos2i(0,  0);
glDrawPixels(( xSize)-(0)+1, ( ySize)-( 0)+1, GL_RGBA,             GL_UNSIGNED_BYTE, packedRaster);After some tweaking, the finished code might look like this:glRasterPos2i(0, 0);
glDrawPixels(xSize + 1, ySize + 1, GL_RGBA,
             GL_UNSIGNED_BYTE, packedRaster);LBL="" HELPID=""Porting ID="77276"Depth Cueing and Fog CommandsID="03.finish272"Porting notes:The fog calls have been restructured, so you might have to rewrite them by hand. The IRIS GL call fogvertex() set a mode and parameters affecting that mode. In OpenGL, you call glFog() once to set the mode, then again twice or more to set various parameters.Depth cueing is no longer a separate feature. Use linear fog instead of depth cueing. (This section provides an example of how to do this.) The following calls therefore have no direct OpenGL equivalent:ID="03.finish273"depthcue()ID="03.finish274"lRGBrange()ID="03.finish275"lshaderange()ID="03.finish276"getdcm()To adjust fog quality, use glHint(GL_FOG_HINT).IDREF="46633" TYPE="TABLE"Table 3-23 lists the IRIS GL calls for managing fog along with the corresponding OpenGL calls.COLUMNS="3"LBL="3-23"Table 3-23 ID="46633"Calls for Managing FogLEFT="0" WIDTH="108"IRIS GL CallLEFT="115" WIDTH="108"OpenGL CallLEFT="230" WIDTH="117"MeaningLEFT="0" WIDTH="108"fogvertex()ID="03.finish277"LEFT="115" WIDTH="108"glFog()ID="03.finish278"LEFT="230" WIDTH="117"set various fog parametersLEFT="0" WIDTH="108"fogvertex(FG_ON)LEFT="115" WIDTH="108"glEnable(GL_FOG)ID="03.finish279"LEFT="230" WIDTH="117"turn fog onLEFT="0" WIDTH="108"fogvertex(FG_OFF)LEFT="115" WIDTH="108"glDisable(GL_FOG)ID="03.finish280"LEFT="230" WIDTH="117"turn fog offLEFT="0" WIDTH="108"depthcue()LEFT="115" WIDTH="108"glFog(GL_FOG_MODE, 
GL_LINEAR)LEFT="230" WIDTH="117"use linear fog for depth 
cueingIDREF="75617" TYPE="TABLE"Table 3-24 lists the arguments you can pass to ID="03.finish281"glFog().COLUMNS="3"LBL="3-24"Table 3-24 ID="75617"Fog ParametersLEFT="0" WIDTH="99"Fog ParameterLEFT="105" WIDTH="117"MeaningLEFT="230" WIDTH="117"DefaultLEFT="0" WIDTH="99"GL_FOG_DENSITYLEFT="105" WIDTH="117"fog densityLEFT="230" WIDTH="117"1.0LEFT="0" WIDTH="99"GL_FOG_STARTLEFT="105" WIDTH="117"near distance for linear fogLEFT="230" WIDTH="117"0.0LEFT="0" WIDTH="99"GL_FOG_ENDLEFT="105" WIDTH="117"far distance for linear fogLEFT="230" WIDTH="117"1.0LEFT="0" WIDTH="99"GL_FOG_INDEXLEFT="105" WIDTH="117"fog color indexLEFT="230" WIDTH="117"0.0LEFT="0" WIDTH="99"GL_FOG_COLORLEFT="105" WIDTH="117"fog RGBA colorLEFT="230" WIDTH="117"(0, 0, 0, 0)LEFT="0" WIDTH="99"GL_FOG_MODELEFT="105" WIDTH="117"fog modeLEFT="230" WIDTH="117"see IDREF="91254" TYPE="TABLE"Table 3-25The fog density argument of OpenGL is different than the fog density argument of IRIS GL. They are related as follows:if fogMode is EXP2:openGLfogDensity = (IRISGLfogDensity)  (sqrt( - log( 1 / 255 ) ))if fogMode is EXP:openGLfogDensity = (IRISGLfogDensity)  (- log( 1 / 255 ) )where sqrt is the square root operation, log is the natural logarithm, IRISGLfogDensity is the IRIS GL fog density, and openGLfogDensity is the OpenGL fog density.To switch between calculating fog in per-pixel mode and per-vertex mode, use glHint(GL_FOG_HINT, hintMode). Two hint modes are available:GL_NICESTID="03.finish282"per-pixel fog calculationGL_FASTESTID="03.finish283"per-vertex fog calculationIDREF="91254" TYPE="TABLE"Table 3-25 lists the OpenGL equivalents for IRIS GL fog modes.ID="03.finish284"ID="03.finish285"COLUMNS="4"LBL="3-25"Table 3-25 ID="91254"Fog ModesLEFT="0" WIDTH="81"IRIS GL Fog ModeLEFT="90" WIDTH="81"OpenGL Fog ModeLEFT="180" WIDTH="81"Hint ModeLEFT="270" WIDTH="90"MeaningLEFT="0" WIDTH="81"FG_VTX_EXP, FG_PIX_EXPLEFT="90" WIDTH="81"GL_EXPLEFT="180" WIDTH="81"GL_FASTEST,GL_NICESTLEFT="270" WIDTH="90"heavy fog mode 
(default)LEFT="0" WIDTH="81"FG_VTX_EXP2, FG_PIX_EXP2LEFT="90" WIDTH="81"GL_EXP2LEFT="180" WIDTH="81"GL_FASTEST,GL_NICESTLEFT="270" WIDTH="90"haze modeLEFT="0" WIDTH="81"FG_VTX_LIN, FG_PIX_LINLEFT="90" WIDTH="81"GL_LINEARLEFT="180" WIDTH="81"GL_FASTEST,GL_NICESTLEFT="270" WIDTH="90"linear fog mode (use 
for depthcueing)Here's an example program that demonstrates depth cueing in OpenGL:/*  depthcue.c
 *  This program draws a wireframe model, which uses
 *  intensity (brightness) to give clues to distance.
 *  Fog is used to achieve this effect.
 */
#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"

/*  Initialize linear fog for depth cueing. */
void myinit(void)
{
    GLfloat fogColor[4] = {0.0, 0.0, 0.0, 1.0};

    glEnable(GL_FOG);
    glFogi (GL_FOG_MODE, GL_LINEAR);
    glHint (GL_FOG_HINT, GL_NICEST);  /*  per pixel   */
    glFogf (GL_FOG_START, 3.0);
    glFogf (GL_FOG_END, 5.0);
    glFogfv (GL_FOG_COLOR, fogColor);
    glClearColor(0.0, 0.0, 0.0, 1.0);
    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);
    glShadeModel(GL_FLAT);
}

/*  display() draws an icosahedron. */
void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glColor3f (1.0, 1.0, 1.0);
    auxWireIcosahedron(1.0);
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective (45.0, (GLfloat) w/(GLfloat) h,
                    3.0, 5.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity ();
    glTranslatef (0.0, 0.0, -4.0); /*move obj. into view*/
}
/*  Main Loop */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGBA |
                        AUX_DEPTH);
    auxInitPosition (0, 0, 400, 400);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}LBL="" HELPID=""Porting ID="41945"Curve and Surface CommandsID="03.finish286"OpenGL does not support equivalents to the old-style curves and surface patches. You'll need to reimplement if your code uses any of these calls:ID="03.finish287"defbasis()ID="03.finish288"curvebasis(), ID="03.finish289"curveprecision(), ID="03.finish290"crv(), ID="03.finish291"crvn(), ID="03.finish292"rcrv(), ID="03.finish293"rcrvn(), and ID="03.finish294"curveit()ID="03.finish295"patchbasis(), ID="03.finish296"patchcurves(), ID="03.finish297"patchprecision(), ID="03.finish298"patch(), and ID="03.finish299"rpatch()(Silicon Graphics recommends that you reimplement these calls using evaluators, rather than trying to replace them with NURBS. Refer to the OpenGL Reference Manual and the OpenGL Programming Guide for more information on using evaluators.)LBL="" HELPID=""NURBS ObjectsID="03.finish300"OpenGL treats NURBS as objects, similar to the way it treats quadrics: you create a NURBS object and then specify how it should be rendered. IDREF="54158" TYPE="TABLE"Table 3-26 lists the NURBS object commands. COLUMNS="2"LBL="3-26"Table 3-26 ID="54158"Calls for Managing NURBS ObjectsLEFT="0" WIDTH="117"OpenGL CallLEFT="125" WIDTH="216"MeaningLEFT="0" WIDTH="117"gluNewNurbsRenderer()ID="03.finish301"LEFT="125" WIDTH="216"create a new NURBS objectLEFT="0" WIDTH="117"gluDeleteNurbsRenderer()ID="03.finish302"LEFT="125" WIDTH="216"delete a NURBS objectLEFT="0" WIDTH="117"gluNurbsCallback()ID="03.finish303"LEFT="125" WIDTH="216"associate a callback with a NURBS object, for error 
handlingPorting notes:ID="03.finish304"ID="03.finish305"NURBS control points are now floats, not doubles.The stride parameter is now counted in floats, not bytes.If you're using lighting and you're not specifying normals, call glEnable()ID="03.finish306" with GL_AUTO_NORMAL as the parameter to generate normals automatically.LBL="" HELPID=""ID="41356"NURBS CurvesThe OpenGL calls for drawing NURBS are very similar to the IRIS GL calls. You specify knot sequences and control points using a gluNurbsCurve() call, which must be contained within a glBeginCurve()/glEndCurve() pair.IDREF="80167" TYPE="TABLE"Table 3-27 summarizes the calls for drawing NURBS curves.COLUMNS="3"LBL="3-27"Table 3-27 ID="80167"Calls for Drawing NURBS CurvesLEFT="0" WIDTH="108"IRIS GL CallLEFT="115" WIDTH="108"OpenGL CallLEFT="230" WIDTH="117"MeaningLEFT="0" WIDTH="108"bgncurve()ID="03.finish307"LEFT="115" WIDTH="108"gluBeginCurve()ID="03.finish308"LEFT="230" WIDTH="117"begin a curve definitionLEFT="0" WIDTH="108"nurbscurve()ID="03.finish309"LEFT="115" WIDTH="108"gluNurbsCurve()ID="03.finish310"LEFT="230" WIDTH="117"specify curve attributesLEFT="0" WIDTH="108"endcurve()ID="03.finish311"LEFT="115" WIDTH="108"gluEndCurve()ID="03.finish312"LEFT="230" WIDTH="117"end a curve definitionPosition, texture, and color coordinates are associated by presenting each as a separate gluNurbsCurve() inside the begin/end pair. You can make no more than one call to gluNurbsCurve() for each piece of color, position, and texture data within a single gluBeginCurve()/gluEndCurve() pair. You must make exactly one call to describe the position of the curve (a GL_MAP1_VERTEX_3 or GL_MAP1_VERTEX_4 description). When you call gluEndCurve(), the curve will be tessellated into line segments and then rendered.IDREF="65325" TYPE="TABLE"Table 3-28 lists NURBS curve types.ID="03.finish313"COLUMNS="3"LBL="3-28"Table 3-28 ID="65325"NURBS Curve TypesLEFT="0" WIDTH="72"IRIS GL TypeLEFT="80" WIDTH="144"OpenGL TypeLEFT="230" WIDTH="117"MeaningLEFT="0" WIDTH="72"N_V3DLEFT="80" WIDTH="144"GL_MAP1_VERTEX_3LEFT="230" WIDTH="117"polynomial curveID="03.finish314"LEFT="0" WIDTH="72"N_V3DRLEFT="80" WIDTH="144"GL_MAP1_VERTEX_4LEFT="230" WIDTH="117"rational curveID="03.finish315"LEFT="0" WIDTH="72"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="80" WIDTH="144"GL_MAP1_TEXTURE_COORD_*LEFT="230" WIDTH="117"control points are texture 
coordinatesLEFT="0" WIDTH="72"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="80" WIDTH="144"GL_MAP1_NORMALLEFT="230" WIDTH="117"control points are normalsFor more information on available evaluator types, see the reference page for glMap1()ID="03.finish316".LBL="" HELPID=""ID="88446"Trimming CurvesID="03.finish317"OpenGL trimming curves are very similar to IRIS GL trimming curves. IDREF="86587" TYPE="TABLE"Table 3-29 lists the calls for defining trimming curves.ID="03.finish318"COLUMNS="3"LBL="3-29"Table 3-29 ID="86587"Calls for Drawing NURBS Trimming CurvesLEFT="0" WIDTH="81"IRIS GL CallLEFT="90" WIDTH="81"OpenGL CallLEFT="180" WIDTH="171"MeaningLEFT="0" WIDTH="81"bgntrim()ID="03.finish319"LEFT="90" WIDTH="81"gluBeginTrim()ID="03.finish320"LEFT="180" WIDTH="171"begin trimming curve definitionLEFT="0" WIDTH="81"pwlcurve()ID="03.finish321"LEFT="90" WIDTH="81"gluPwlCurve()ID="03.finish322"LEFT="180" WIDTH="171"define a piecewise linear curveLEFT="0" WIDTH="81"nurbscurve()ID="03.finish323"LEFT="90" WIDTH="81"gluNurbsCurve()ID="03.finish324"LEFT="180" WIDTH="171"specify trimming curve attributesLEFT="0" WIDTH="81"endtrim()ID="03.finish325"LEFT="90" WIDTH="81"gluEndTrim()ID="03.finish326"LEFT="180" WIDTH="171"end trimming curve definitionLBL="" HELPID=""ID="12666"NURBS SurfacesID="03.finish327"IDREF="78966" TYPE="TABLE"Table 3-30 summarizes the calls for drawing NURBS surfaces.COLUMNS="3"LBL="3-30"Table 3-30 ID="78966"Calls for Drawing NURBS SurfacesLEFT="0" WIDTH="99"IRIS GL CallLEFT="105" WIDTH="108"OpenGL CallLEFT="220" WIDTH="126"MeaningLEFT="0" WIDTH="99"bgnsurface()ID="03.finish328"LEFT="105" WIDTH="108"gluBeginSurface()ID="03.finish329"LEFT="220" WIDTH="126"begin a surface definitionLEFT="0" WIDTH="99"nurbssurface()ID="03.finish330"LEFT="105" WIDTH="108"gluNurbsSurface()ID="03.finish331"LEFT="220" WIDTH="126"specify surface attributesLEFT="0" WIDTH="99"endsurface()ID="03.finish332"LEFT="105" WIDTH="108"gluEndSurface()ID="03.finish333"LEFT="220" WIDTH="126"end a surface definitionIDREF="67597" TYPE="TABLE"Table 3-31 lists parameters for surface types.ID="03.finish334"COLUMNS="3"LBL="3-31"Table 3-31 ID="67597"NURBS Surface TypesLEFT="0" WIDTH="63"IRIS GL TypeLEFT="70" WIDTH="144"OpenGL TypeLEFT="220" WIDTH="126"MeaningLEFT="0" WIDTH="63"N_V3DLEFT="70" WIDTH="144"GL_MAP2_VERTEX_3LEFT="220" WIDTH="126"polynomial curveID="03.finish335"LEFT="0" WIDTH="63"N_V3DRLEFT="70" WIDTH="144"GL_MAP2_VERTEX_4LEFT="220" WIDTH="126"rational curveID="03.finish336"LEFT="0" WIDTH="63"N_C4DLEFT="70" WIDTH="144"GL_MAP2_COLOR_4LEFT="220" WIDTH="126"control points define color 
surface in (R,G,B,A) formLEFT="0" WIDTH="63"N_C4DRLEFT="70" WIDTH="144"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="220" WIDTH="126"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="63"N_T2DLEFT="70" WIDTH="144"GL_MAP2_TEXTURE_COORD_2LEFT="220" WIDTH="126"control points are texture 
coordinatesLEFT="0" WIDTH="63"N_T2DRLEFT="70" WIDTH="144"GL_MAP2_TEXTURE_COORD_3LEFT="220" WIDTH="126"control points are texture 
coordinatesLEFT="0" WIDTH="63"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="70" WIDTH="144"GL_MAP2_NORMALLEFT="220" WIDTH="126"control points are normalsFor more information on available evaluator types, see the reference page for glMap2()ID="03.finish337".Here's an example program that draws a trimmed NURBS surface:/*
 *  trim.c
 *  This program draws a NURBS surface in the shape of a
 *  symmetrical hill, using both a NURBS curve and pwl
 *  (piecewise linear) curve to trim part of the surface.
 */
#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"

GLfloat ctlpoints[4][4][3];

GLUnurbsObj *theNurb;

/*  Initializes the control points of the surface to a
 *  small hill. The control points range from -3 to +3
 *  in x, y, and z
 */
void init_surface(void)
{
    int u, v;
    for (u = 0; u < 4; u++) {
        for (v = 0; v < 4; v++) {
            ctlpoints[u][v][0] = 2.0*((GLfloat)u - 1.5);
            ctlpoints[u][v][1] = 2.0*((GLfloat)v - 1.5);

            if ( (u == 1 || u == 2) && (v == 1 || v == 2))
                ctlpoints[u][v][2] = 3.0;
            else
                ctlpoints[u][v][2] = -3.0;
        }
    }
}

/*  Initialize material property and depth buffer.
 */
void myinit(void)
{
    GLfloat mat_diffuse[] = { 0.6, 0.6, 0.6, 1.0 };
    GLfloat mat_specular[] = { 0.9, 0.9, 0.9, 1.0 };
    GLfloat mat_shininess[] = { 128.0 };

    glClearColor (0.0, 0.0, 0.0, 1.0);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_AUTO_NORMAL);
    glEnable(GL_NORMALIZE);

    init_surface();

    theNurb = gluNewNurbsRenderer();
    gluNurbsProperty(theNurb, GLU_SAMPLING_TOLERANCE,
                     50.0);
    gluNurbsProperty(theNurb, GLU_DISPLAY_MODE, GLU_FILL);
}

void display(void)
{
    GLfloat knots[8] = {0.0, 0.0, 0.0, 0.0, 1.0, 1.0,
                        1.0, 1.0};
    GLfloat edgePt[5][2] = /* counterclockwise */
    {{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}, {0.0, 1.0},
     {0.0, 0.0}};
    GLfloat curvePt[4][2] = /* clockwise */
    {{0.25, 0.5}, {0.25, 0.75}, {0.75, 0.75},
     {0.75, 0.5}};
    GLfloat curveKnots[8] =
        {0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0};
    GLfloat pwlPt[4][2] = /* clockwise */
        {{0.75, 0.5}, {0.5, 0.25}, {0.25, 0.5}};

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glPushMatrix();
    glRotatef(330.0, 1.,0.,0.);
    glScalef (0.5, 0.5, 0.5);
    gluBeginSurface(theNurb);
    gluNurbsSurface(theNurb,
            8, knots,
            8, knots,
            4 * 3,
            3,
            &ctlpoints[0][0][0],
            4, 4,
            GL_MAP2_VERTEX_3);
    gluBeginTrim (theNurb);
        gluPwlCurve (theNurb, 5, &edgePt[0][0], 2,
                     GLU_MAP1_TRIM_2);
    gluEndTrim (theNurb);
    gluBeginTrim (theNurb);
        gluNurbsCurve (theNurb, 8, curveKnots, 2,
                &curvePt[0][0], 4, GLU_MAP1_TRIM_2);
        gluPwlCurve (theNurb, 3, &pwlPt[0][0], 2,
                     GLU_MAP1_TRIM_2);
    gluEndTrim (theNurb);
    gluEndSurface(theNurb);

    glPopMatrix();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective (45.0, (GLdouble)w/(GLdouble)h,
                    3.0, 8.0);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef (0.0, 0.0, -5.0);
}

/*  Main Loop */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGBA |
                        AUX_DEPTH);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}LBL="" HELPID=""Porting ID="91804"Antialiasing CallsID="03.finish338"Subpixel mode is always on, so the IRIS GL call subpixel(TRUE) is not necessary and has no OpenGL equivalent.LBL="" HELPID=""ID="87998"BlendingID="03.finish339"ID="03.finish340"Blending is off by default. If you use _DA or _MDA blend functions, you'll need to allocate destination alpha bits when you choose a visualname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'you need to use X for this, so refer to ID="03.finish341"ID="03.finish342"IDREF="37274" TYPE="TITLE"Chapter 5.Porting Tip: In IRIS GL, when drawing to both front and back buffers, blending is done by reading one of the buffers, blending with that color, and then writing the result to both buffers. In OpenGL, however, each buffer is read in turn, blended, and then written.IDREF="73474" TYPE="TABLE"Table 3-32 lists IRIS GL and OpenGL blending calls.COLUMNS="3"LBL="3-32"Table 3-32 ID="73474"Blending CallsLEFT="0" WIDTH="108"IRIS GLLEFT="115" WIDTH="108"OpenGLLEFT="230" WIDTH="117"MeaningLEFT="0" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="115" WIDTH="108"glEnable(GL_BLEND)ID="03.finish343"LEFT="230" WIDTH="117"turn on blendingLEFT="0" WIDTH="108"blendfunction()ID="03.finish344"LEFT="115" WIDTH="108"glBlendFunc()ID="03.finish345"LEFT="230" WIDTH="117"specify a blend functionThe calls glBlendFunc() and blendfunction() are almost identical. IDREF="19817" TYPE="TABLE"Table 3-33 lists the OpenGL equivalents to the IRIS GL blend factors.ID="03.finish346"COLUMNS="3"LBL="3-33"Table 3-33 ID="19817"Blending FactorsLEFT="0" WIDTH="90"IRIS GL LEFT="95" WIDTH="144"OpenGLLEFT="245" WIDTH="99"NotesLEFT="0" WIDTH="90"BF_ZEROLEFT="95" WIDTH="144"GL_ZEROLEFT="245" WIDTH="99"LEFT="0" WIDTH="90"BF_ONELEFT="95" WIDTH="144"GL_ONELEFT="245" WIDTH="99"LEFT="0" WIDTH="90"BF_SALEFT="95" WIDTH="144"GL_SRC_ALPHALEFT="245" WIDTH="99"LEFT="0" WIDTH="90"BF_MSALEFT="95" WIDTH="144"GL_ONE_MINUS_SRC_ALPHALEFT="245" WIDTH="99"LEFT="0" WIDTH="90"BF_DALEFT="95" WIDTH="144"GL_DST_ALPHALEFT="245" WIDTH="99"LEFT="0" WIDTH="90"BF_MDALEFT="95" WIDTH="144"GL_ONE_MINUS_DST_ALPHALEFT="245" WIDTH="99"LEFT="0" WIDTH="90"BF_SCLEFT="95" WIDTH="144"GL_SRC_COLORLEFT="245" WIDTH="99"LEFT="0" WIDTH="90"BF_MSCLEFT="95" WIDTH="144"GL_ONE_MINUS_SRC_COLORLEFT="245" WIDTH="99"destination onlyLEFT="0" WIDTH="90"BF_DCLEFT="95" WIDTH="144"GL_DST_COLORLEFT="245" WIDTH="99"source onlyLEFT="0" WIDTH="90"BF_MDCLEFT="95" WIDTH="144"GL_ONE_MINUS_DST_COLORLEFT="245" WIDTH="99"source onlyLEFT="0" WIDTH="90"BF_MIN_SA_MDALEFT="95" WIDTH="144"GL_SRC_ALPHA_SATURATELEFT="245" WIDTH="99"LBL="" HELPID=""ID="93903"afunction() Test FunctionsID="03.finish347"IDREF="11057" TYPE="TABLE"Table 3-34 lists the available alpha test functions.COLUMNS="2"LBL="3-34"Table 3-34 ID="11057"Alpha Test FunctionsLEFT="0" WIDTH="113"afunction()LEFT="120" WIDTH="113"glAlphaFunc()LEFT="0" WIDTH="113"AF_NOTEQUALID="03.finish348"LEFT="120" WIDTH="113"GL_NOTEQUALID="03.finish349"LEFT="0" WIDTH="113"AF_ALWAYSID="03.finish350"LEFT="120" WIDTH="113"GL_ALWAYSID="03.finish351"LEFT="0" WIDTH="113"AF_NEVERID="03.finish352"LEFT="120" WIDTH="113"GL_NEVERID="03.finish353"LEFT="0" WIDTH="113"AF_LESSID="03.finish354"LEFT="120" WIDTH="113"GL_LESSID="03.finish355"LEFT="0" WIDTH="113"AF_EQUALID="03.finish356"LEFT="120" WIDTH="113"GL_EQUALID="03.finish357"LEFT="0" WIDTH="113"AF_LEQUALID="03.finish358"LEFT="120" WIDTH="113"GL_LEQUALID="03.finish359"LEFT="0" WIDTH="113"AF_GREATERID="03.finish360"LEFT="120" WIDTH="113"GL_GREATERID="03.finish361"LEFT="0" WIDTH="113"AF_GEQUALID="03.finish362"LEFT="120" WIDTH="113"GL_GEQUALID="03.finish363"LBL="" HELPID=""ID="65073"Antialiasing CallsID="03.finish364"OpenGL has direct equivalents to IRIS GL's antialiasing calls. IDREF="51190" TYPE="TABLE"Table 3-35 lists them.COLUMNS="3"LBL="3-35"Table 3-35 ID="51190"Calls to Draw Antialiased PrimitivesLEFT="0" WIDTH="63"IRIS GL CallLEFT="70" WIDTH="153"OpenGL CallLEFT="230" WIDTH="117"MeaningLEFT="0" WIDTH="63"pntsmooth()ID="03.finish365"LEFT="70" WIDTH="153"glEnable(GL_POINT_SMOOTH)ID="03.finish366"LEFT="230" WIDTH="117"enable antialiasing of pointsLEFT="0" WIDTH="63"linesmooth()ID="03.finish367"LEFT="70" WIDTH="153"glEnable(GL_LINE_SMOOTH)LEFT="230" WIDTH="117"enable antialiasing of linesLEFT="0" WIDTH="63"polysmooth()ID="03.finish368"LEFT="70" WIDTH="153"glEnable(GL_POLYGON_SMOOTH)LEFT="230" WIDTH="117"enable antialiasing of 
polygonsUse the corresponding ID="03.finish369"glDisable() calls to turn off antialiasing.With IRIS GL, you can control the quality of the antialiasing, by callinglinesmooth(SML_ON + SML_SMOOTHER);OpenGL provides similar controlname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'use ID="03.finish370"glHint():glHint(GL_POINT_SMOOTH_HINT, hintMode);
glHint(GL_LINE_SMOOTH_HINT, hintMode);
glHint(GL_POLYGON_SMOOTH_HINT, hintMode);where hintMode is one of the following:GL_NICESTID="03.finish371"Use the highest quality smoothing.GL_FASTESTID="03.finish372"Use the most efficient smoothing.GL_DONT_CAREID="03.finish373"You don't care which smoothing method is used.IRIS GL also allowed end correction by calling:ID="03.finish374"linesmooth(SML_ON + SML_END_CORRECT);OpenGL doesn't have an equivalent for this call.LBL="" HELPID=""ID="19353"Accumulation Buffer CallsID="03.finish375"You must allocate your accumulation buffer by requesting the appropriate visual with auxInitDisplayMode() or glXChooseVisual(). (To learn how to use auxInitDisplayMode(), see IDREF="64084" TYPE="TITLE""Porting Display Mode Initialization Calls with auxInitDisplayMode()". For information on glXChooseVisual(), see the glXIntro and glXChooseVisual() reference pages and refer to IDREF="37274" TYPE="TITLE"Chapter 5.)IRIS GL allows you to draw colors in the depth buffer, so acbuf() can use that buffer as a color source for accumulation. Some developers have used this depth-buffer reading capability to put depth data into accumulation buffers as well. OpenGL, on the other hand, doesn't put color information in the depth buffer; glAccum() thus can't read any information from the depth buffer. To emulate accumulation from the depth buffer (using a configuration that supports auxiliary buffers), use glReadPixels() to read from the depth buffer, massage the results as necessary, and then draw the resulting data to an auxiliary buffer. Select this auxiliary buffer with glReadBuffer(), and use glAccum() to accumulate from that buffer. (Note that this procedure requires caution in converting among data types.)Except as noted above, porting accumulation buffer calls should be straightforward. IDREF="42317" TYPE="TABLE"Table 3-36 lists calls that affect the accumulation buffer.COLUMNS="3"LBL="3-36"Table 3-36 ID="42317"Accumulation Buffer CallsLEFT="0" WIDTH="108"IRIS GL CallLEFT="115" WIDTH="108"OpenGL CallLEFT="230" WIDTH="117"MeaningLEFT="0" WIDTH="108"acbuf()ID="03.finish376"LEFT="115" WIDTH="108"glAccum()ID="03.finish377"LEFT="230" WIDTH="117"operate on the 
accumulation bufferLEFT="0" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="115" WIDTH="108"glClearAccum()ID="03.finish378"LEFT="230" WIDTH="117"set clear values for 
accumulation bufferLEFT="0" WIDTH="108"acbuf(AC_CLEAR)LEFT="115" WIDTH="108"glClear(GL_ACCUM_ID="03.finish379"ID="03.finish380"BUFFER_BIT)LEFT="230" WIDTH="117"clear the accumulation 
bufferLEFT="0" WIDTH="108"acsize()ID="03.finish381"LEFT="115" WIDTH="108"auxInitDisplayMode() orID="03.finish382"glXChooseVisual() ID="03.finish383"LEFT="230" WIDTH="117"specify number of bitplanes 
per color component in the 
accumulation bufferIDREF="79183" TYPE="TABLE"Table 3-37 lists IRIS GL's acbuf() arguments along with the corresponding arguments to OpenGL's glAccum().COLUMNS="2"LBL="3-37"Table 3-37 ID="79183"Accumulation Buffer OperationsLEFT="0" WIDTH="162"IRIS GL ArgumentLEFT="170" WIDTH="171"OpenGL ArgumentLEFT="0" WIDTH="162"AC_ACCUMULATEID="03.finish384"LEFT="170" WIDTH="171"GL_ACCUMID="03.finish385"LEFT="0" WIDTH="162"AC_CLEAR_ACCUMULATEID="03.finish386"LEFT="170" WIDTH="171"GL_LOADID="03.finish387"LEFT="0" WIDTH="162"AC_RETURNID="03.finish388"LEFT="170" WIDTH="171"GL_RETURNID="03.finish389"LEFT="0" WIDTH="162"AC_MULTID="03.finish390"LEFT="170" WIDTH="171"GL_MULTID="03.finish391"LEFT="0" WIDTH="162"AC_ADDID="03.finish392"LEFT="170" WIDTH="171"GL_ADDID="03.finish393"LBL="" HELPID=""ID="80759"Stencil Plane CallsID="03.finish394"In OpenGL, you allocate stencil planes by requesting the appropriate visual with ID="03.finish395"auxInitDisplayMode() or glXChooseVisual(). (To learn how to use auxInitDisplayMode(), see IDREF="64084" TYPE="TITLE""Porting Display Mode Initialization Calls with auxInitDisplayMode()". For information on glXChooseVisual(), see the glXIntro and glXChooseVisual() reference pages and refer to IDREF="37274" TYPE="TITLE"Chapter 5.) Otherwise, porting should be straightforward. IDREF="74240" TYPE="TABLE"Table 3-38 lists calls that affect the stencil planes.COLUMNS="3"LBL="3-38"Table 3-38 ID="74240"Stencil OperationsLEFT="0" WIDTH="75"IRIS GL CallLEFT="80" WIDTH="158"OpenGL CallLEFT="245" WIDTH="99"MeaningLEFT="0" WIDTH="75"stensize()ID="03.finish396"LEFT="80" WIDTH="158"glXChooseVisual()LEFT="245" WIDTH="99"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="75"stencil(TRUE, ...)ID="03.finish397"LEFT="80" WIDTH="158"glEnable(GL_STENCIL_TEST)ID="03.finish398"LEFT="245" WIDTH="99"enable stencil testsLEFT="0" WIDTH="75"stencil()LEFT="80" WIDTH="158"glStencilOp()ID="03.finish399"LEFT="245" WIDTH="99"set stencil test actionsLEFT="0" WIDTH="75"stencil(... func, ...)LEFT="80" WIDTH="158"glStencilFunc()ID="03.finish400"LEFT="245" WIDTH="99"set function & reference 
value for stencil testingLEFT="0" WIDTH="75"swritemask()ID="03.finish401"LEFT="80" WIDTH="158"glStencilMask()ID="03.finish402"LEFT="245" WIDTH="99"specify which stencil 
bits can be writtenLEFT="0" WIDTH="75"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="80" WIDTH="158"glClearStencil()ID="03.finish403"LEFT="245" WIDTH="99"specify the clear value 
for the stencil bufferLEFT="0" WIDTH="75"sclear()ID="03.finish404"LEFT="80" WIDTH="158"glClear(GL_STENCIL_BUFFER_BIT)ID="03.finish405"ID="03.finish406"ID="03.finish407"ID="03.finish408"LEFT="245" WIDTH="99"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Stencil comparison functions and stencil pass/fail operations are nearly equivalent in OpenGL and IRIS GL. The IRIS GL stencil function flags are prefaced with SF, the OpenGL flags with GL. IRIS GL pass/fail operation flags are prefaced with ST, the OpenGL flags with GL. Compare the reference pages for further details.LBL="" HELPID=""Porting ID="58056"Display ListsID="03.finish409"The OpenGL implementation of display lists is similar to the IRIS GL implementation, with two exceptions: you can't edit display lists once you've created them and you can't call functions from within display lists. Since you can't edit or call functions from within display lists, these IRIS GL commands have no equivalents in OpenGL:ID="03.finish410"editobj()ID="03.finish411"objdelete(), ID="03.finish412"objinsert(), and ID="03.finish413"objreplace()ID="03.finish414"maketag(), ID="03.finish415"gentag(), ID="03.finish416"istag(), and ID="03.finish417"deltag()ID="03.finish418"callfunc()With IRIS GL, you used the commands ID="03.finish419"makeobj() and ID="03.finish420"closeobj() to create display lists. With OpenGL, you use ID="03.finish421"glNewList() and ID="03.finish422"glEndList(). For details on using glNewList() (including a description of the two list modes and a list of commands that are not compiled into the display list but are executed immediately), see the glNewList() reference page and the OpenGL Programming Guide.IDREF="14056" TYPE="TABLE"Table 3-39 lists the IRIS GL display list commands with the corresponding OpenGL commands.COLUMNS="3"LBL="3-39"Table 3-39 ID="14056"Display List CommandsLEFT="0" WIDTH="108"IRIS GL CallLEFT="115" WIDTH="108"OpenGL CallLEFT="230" WIDTH="117"MeaningLEFT="0" WIDTH="108"makeobj()LEFT="115" WIDTH="108"glNewList()LEFT="230" WIDTH="117"create a new display listLEFT="0" WIDTH="108"closeobj()LEFT="115" WIDTH="108"glEndList()LEFT="230" WIDTH="117"signal end of display listLEFT="0" WIDTH="108"callobj()ID="03.finish423"LEFT="115" WIDTH="108"glCallList(), glCallLists()ID="03.finish424"ID="03.finish425"LEFT="230" WIDTH="117"execute display list(s)LEFT="0" WIDTH="108"isobj()ID="03.finish426"LEFT="115" WIDTH="108"glIsList()ID="03.finish427"LEFT="230" WIDTH="117"test for display list existenceLEFT="0" WIDTH="108"delobj()ID="03.finish428"LEFT="115" WIDTH="108"glDeleteLists()ID="03.finish429"LEFT="230" WIDTH="117"delete contiguous group of 
display listsLEFT="0" WIDTH="108"genobj()ID="03.finish430"LEFT="115" WIDTH="108"glGenLists()ID="03.finish431"LEFT="230" WIDTH="117"generate the given number 
of contiguous empty 
display listsLBL="" HELPID=""ID="14029"Porting bbox2() CallsThe command bbox2() has no OpenGL equivalent. To port bbox2() calls, first create a new (OpenGL) display list that has everything that was in the corresponding IRIS GL display list except the bbox2() call. Then, in feedback mode, draw a rectangle the same size as the IRIS GL bounding box: if nothing comes back, the box was completely clipped and you shouldn't draw the display list.LBL="" HELPID=""ID="91726"Edited Display ListsID="03.finish432"ID="03.finish433"Although you can't actually edit OpenGL display lists, you can get a similar result by nesting display lists, then destroying and creating new versions of the sublists.This OpenGL code fragment shows how:glNewList (1, GL_COMPILE);
    glIndexi (MY_RED);
glEndList ();
    glNewList (2, GL_COMPILE);
    glScalef (1.2, 1.2, 1.0);
glEndList ();

glNewList (3, GL_COMPILE);
    glCallList (1);
    glCallList (2);
glEndList ();
     .
     .
glDeleteLists (1, 2);
glNewList (1, GL_COMPILE);
    glIndexi (MY_CYAN);
glEndList ();
glNewList (2, GL_COMPILE);
    glScalef (0.5, 0.5, 1.0);
glEndList ();LBL="" HELPID=""A Sample Implementation of a Display ListID="03.finish434"An IRIS GL display list might look like this:makeobj (10);   /* 10 object   */
   cpack (0x0000FF);
   recti (164, 33, 364, 600);  /* hollow rectangle */
closeobj ();

makeobj (20);     /* 20 object -- various things   */
   cpack (0xFFFF00);
   circi(0,0,25); /* draw an unfilled circle   */
   rectfi (100, 100, 200, 200); /* draw filled rect */
closeobj ();
   
makeobj (30);      /* 30 -- THE MAIN OBJECT */
   callobj (10);
   cpack (0xFFFFFF);      
   rectfi (400, 100, 500, 300); /* draw filled rect */
   callobj (20);
closeobj ();
/* now draw by calling the lists */
callobj(30);The example above defines three display lists, one of which refers to the others in its definition. Translated to OpenGL, that code might look like this:glNewList( 10, GL_COMPILE );
   glColor3f( 1, 0, 0 );
   glRecti( 164, 33, 364, 600 );
glEndList();

glNewList( 20, GL_COMPILE );
   glColor3f( 1, 1, 0 ); /* set color to YELLOW  */
   glPolygonMode(GL_BOTH, GL_LINE); /* unfilled mode */
   glBegin(GL_POLYGON); /* use polygon to approximate circle */
      for(i=0;i<100;i++) {
         cosine = 25 * cos(i*2*PI/100.0);
         sine =   25 * sin(i*2*PI/100.0);
        glVertex2f(cosine,sine);
      }
   glEnd();

   glBegin(GL_QUADS);
      glColorf( 0, 1, 1 ); /* set color to CYAN  */
      glVertex2i(100,100);
      glVertex2i(100,200);
      glVertex2i(200,200);
      glVertex2i(100,200);
   glEnd();
glEndList();

glNewList(30, GL_COMPILE); /* List #30 */
   glCallList( 10 );
      glColorf( 1, 1, 1 ); /* set color to WHITE */   
      glRecti(400, 100, 500, 300);
   glCallList( 20 );
glEndList();

/* execute the display lists */
glCallList( 30 );LBL="" HELPID=""ID="21145"Porting defs, binds, and sets: Replacing `Tables' of Stored DefinitionsID="03.finish435"OpenGL does not have tables of stored definitionsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'you can't define lighting models, materials, textures, line styles, or patterns as separate objects as you could in IRIS GL. Thus, there are no direct equivalents to these IRIS GL calls:ID="03.finish436"lmdef() and ID="03.finish437"lmbind()tevdef()ID="03.finish438" and ID="03.finish439"tevbind()texdef()ID="03.finish440" and ID="03.finish441"texbind()deflinestyle()ID="03.finish442" and ID="03.finish443"setlinestyle()defpattern()ID="03.finish444" and ID="03.finish445"setpattern()However, you can use display lists to mimic the def/bind behavior. (It's often best to optimize by writing display lists that contain just a single material definition.)For example, here is a material definition in IRIS GL:float mat[] = {
    AMBIENT, .1, .1, .1,
    DIFFUSE, 0, .369, .165,
    SPECULAR, .5, .5, .5,
    SHININESS, 10,
    LMNULL
};
lmdef(DEFMATERIAL, 1, 0, mat);
lmbind(MATERIAL, 1);In the following code fragment, the same material is defined in a display list, referred to by the list number in MYMATERIAL.#define MYMATERIAL 10
/* you would probably use glGenLists() to get list numbers */
GLfloat   mat_amb[] = {.1, .1, .1, 1.0}; 
GLfloat   mat_dif[] = {0, .369, .165, 1.0};
GLfloat   mat_spec[] = { .5, .5, .5, 1.0};

glNewList( MYMATERIAL, GL_COMPILE );
    glMaterialfv( GL_FRONT, GL_AMBIENT, mat_amb);
    glMaterialfv( GL_FRONT, GL_DIFFUSE, mat_dif);
    glMaterialfv( GL_FRONT, GL_SPECULAR, mat_spec);
    glMateriali(  GL_FRONT, GL_SHININESS, 10);
glEndList();

glCallList( MYMATERIAL );LBL="" HELPID=""ID="20887"Porting Lighting and Materials CallsID="03.finish446"ID="03.finish447"ID="03.finish448"ID="03.finish449"You'll probably need to port lighting and materials code by hand, since the OpenGL calls differ substantially from the IRIS GL calls. The OpenGL API is much cleaner, however; it has separate calls for setting lights, light models, and materials.Porting notes:OpenGL has no table of stored definitions. It has no separate ID="03.finish450"lmdef() and lmbind()ID="03.finish451" calls. You can use display lists to mimic the def/bind behavior. See IDREF="21145" TYPE="TITLE""Porting defs, binds, and sets: Replacing `Tables' of Stored Definitions" for an example. This might have the added benefit of improving your program's performance.Attenuation is now associated with each light source, rather than with the overall lighting model.Diffuse and specular components are separated out in OpenGL light sources.OpenGL light sources have an alpha component. When porting your code, it's best to set this alpha component to 1.0, indicating 100% fully opaque. That way, alpha values will be determined solely by the alpha component of your materials and the objects in your scene will look the same as they did in IRIS GL.In IRIS GL, you could call lmcolor() between a call to bgnprimitive() and the corresponding endprimitive() call. In OpenGL, you can't call glColorMaterial() between a glBegin() and its corresponding glEnd().IDREF="24918" TYPE="TABLE"Table 3-40 lists IRIS GL lighting and materials commands and the corresponding OpenGL commands.COLUMNS="3"LBL="3-40"Table 3-40 ID="24918"Lighting and Materials CommandsLEFT="0" WIDTH="113"IRIS GL CallLEFT="120" WIDTH="113"OpenGL CallLEFT="240" WIDTH="104"MeaningLEFT="0" WIDTH="113"lmdef(DEFLIGHT,...)LEFT="120" WIDTH="113"glLight()ID="03.finish452"LEFT="240" WIDTH="104"define a light sourceLEFT="0" WIDTH="113"lmdef(DEFLMODEL, ...)LEFT="120" WIDTH="113"glLightModel()ID="03.finish453"LEFT="240" WIDTH="104"define a lighting modelLEFT="0" WIDTH="113"lmbind()LEFT="120" WIDTH="113"glEnable(GL_LIGHTID="03.finish454"i)LEFT="240" WIDTH="104"enable light iLEFT="0" WIDTH="113"lmbind()LEFT="120" WIDTH="113"glEnable(GL_LIGHTING)LEFT="240" WIDTH="104"enable lightingLEFT="0" WIDTH="113"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="120" WIDTH="113"glGetLight()ID="03.finish455"LEFT="240" WIDTH="104"get light source 
parametersLEFT="0" WIDTH="113"lmdef(DEFMATERIAL, ...)LEFT="120" WIDTH="113"glMaterial()ID="03.finish456"LEFT="240" WIDTH="104"define a materialLEFT="0" WIDTH="113"lmcolor()ID="03.finish457"LEFT="120" WIDTH="113"glColorMaterial()ID="03.finish458"LEFT="240" WIDTH="104"change effect of color 
commands while 
lighting is activeLEFT="0" WIDTH="113"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="120" WIDTH="113"glGetMaterial()ID="03.finish459"LEFT="240" WIDTH="104"get material parametersWhen the first argument for lmbind() is DEFMATERIAL, the equivalent command is ID="03.finish460"ID="03.finish461"glMaterial(). IDREF="12769" TYPE="TABLE"Table 3-41 lists the various materials parameters you can set.COLUMNS="4"LBL="3-41"Table 3-41 ID="12769"Material Definition ParametersLEFT="0" WIDTH="77"lmdef() indexLEFT="85" WIDTH="99"glMaterial() parameterLEFT="190" WIDTH="72"DefaultLEFT="270" WIDTH="84"MeaningLEFT="0" WIDTH="77"ALPHALEFT="85" WIDTH="99"GL_DIFFUSEIDREF="03.finishTF40a"aLEFT="190" WIDTH="72"LEFT="270" WIDTH="84"LEFT="0" WIDTH="77"AMBIENTID="03.finish462"LEFT="85" WIDTH="99"GL_AMBIENTID="03.finish463"LEFT="190" WIDTH="72"(0.2, 0.2, 0.2, 1.0)LEFT="270" WIDTH="84"ambient colorLEFT="0" WIDTH="77"DIFFUSEID="03.finish464"LEFT="85" WIDTH="99"GL_DIFFUSEID="03.finish465"LEFT="190" WIDTH="72"(0.8, 0.8, 0.8, 1.0)LEFT="270" WIDTH="84"diffuse colorLEFT="0" WIDTH="77"SPECULARID="03.finish466"LEFT="85" WIDTH="99"GL_SPECULARID="03.finish467"IDREF="03.finishTF40b"bLEFT="190" WIDTH="72"(0.0, 0.0, 0.0, 1.0)LEFT="270" WIDTH="84"specular colorLEFT="0" WIDTH="77"EMISSIONID="03.finish468"LEFT="85" WIDTH="99"GL_EMISSIONID="03.finish469"LEFT="190" WIDTH="72"(0.0, 0.0, 0.0, 1.0)LEFT="270" WIDTH="84"emissive colorLEFT="0" WIDTH="77"SHININESSID="03.finish470"LEFT="85" WIDTH="99"GL_SHININESSID="03.finish471"LEFT="190" WIDTH="72"0.0LEFT="270" WIDTH="84"specular exponentLEFT="0" WIDTH="77"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="85" WIDTH="99"GL_AMBIENT_AND_
DIFFUSEID="03.finish472"LEFT="190" WIDTH="72"(see above)LEFT="270" WIDTH="84"equivalent to 
calling glMaterial() 
twice with same 
valuesLEFT="0" WIDTH="77"COLORINDEXESID="03.finish473"LEFT="85" WIDTH="99"GL_COLOR_INDEXESID="03.finish474"LEFT="190" WIDTH="72"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="270" WIDTH="84"color indices for 
ambient, diffuse, 
and specular 
lightingLBL="a" ID="03.finishTF40a"(The fourth value in the GL_DIFFUSE parameter specifies the alpha value.)LBL="b" ID="03.finishTF40b"In IRIS GL, if the specular exponent (i.e. SHININESS) is zero, then the specular component 
of the light is not added in. In OpenGL, the specular component is added in anyway.When the first argument of lmdef() is DEFLMODEL, the equivalent OpenGL call is glLightModel(). The exception is the case when the first argument of lmdef() is DEFLMODEL, ATTENUATIONname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in this case, you'll need to replace lmdef() with several glLight() calls. IDREF="65825" TYPE="TABLE"Table 3-42 lists equivalent lighting model parameters.COLUMNS="4"LBL="3-42"Table 3-42 ID="65825"Lighting Model ParametersLEFT="0" WIDTH="72"lmdef() indexLEFT="80" WIDTH="107"glLightModel() ParameterLEFT="195" WIDTH="70"DefaultLEFT="270" WIDTH="82"MeaningLEFT="0" WIDTH="72"AMBIENTLEFT="80" WIDTH="107"GL_LIGHT_MODEL_A
MBIENTID="03.finish475"LEFT="195" WIDTH="70"(0.2, 0.2, 0.2, 1.0)LEFT="270" WIDTH="82"ambient color of 
sceneLEFT="0" WIDTH="72"ATTENUATIONLEFT="80" WIDTH="107"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="195" WIDTH="70"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="270" WIDTH="82"see glLight()LEFT="0" WIDTH="72"LOCALVIEWERLEFT="80" WIDTH="107"GL_LIGHT_MODEL_LO
CAL_VIEWERID="03.finish476"LEFT="195" WIDTH="70"GL_FALSELEFT="270" WIDTH="82"viewer local 
(TRUE) or infinite 
(FALSE)LEFT="0" WIDTH="72"TWOSIDELEFT="80" WIDTH="107"GL_LIGHT_MODEL_T
WO_SIDEID="03.finish477"LEFT="195" WIDTH="70"GL_FALSELEFT="270" WIDTH="82"use two-sided 
lighting when 
TRUEWhen the first argument of lmdef() is DEFLIGHT, the equivalent OpenGL call is glLight(). IDREF="13070" TYPE="TABLE"Table 3-43 lists equivalent lighting parameters.COLUMNS="4"LBL="3-43"Table 3-43 ID="13070"Light ParametersLEFT="0" WIDTH="80"lmdef() indexLEFT="85" WIDTH="101"glLight() ParameterLEFT="195" WIDTH="72"DefaultLEFT="275" WIDTH="81"MeaningLEFT="0" WIDTH="80"AMBIENTLEFT="85" WIDTH="101"GL_AMBIENTLEFT="195" WIDTH="72"(0.0, 0.0, 0.0, 1.0)LEFT="275" WIDTH="81"ambient intensityLEFT="0" WIDTH="80"LEFT="85" WIDTH="101"GL_DIFFUSELEFT="195" WIDTH="72"(1.0, 1.0, 1.0, 1.0)LEFT="275" WIDTH="81"diffuse intensityLEFT="0" WIDTH="80"LEFT="85" WIDTH="101"GL_SPECULARLEFT="195" WIDTH="72"(1.0, 1.0, 1.0, 1.0)LEFT="275" WIDTH="81"specular intensityLEFT="0" WIDTH="80"LCOLORID="03.finish478"LEFT="85" WIDTH="101"LEFT="195" WIDTH="72"LEFT="275" WIDTH="81"LEFT="0" WIDTH="80"POSITIONID="03.finish479"LEFT="85" WIDTH="101"GL_POSITIONID="03.finish480"LEFT="195" WIDTH="72"(0.0, 0.0, 1.0, 0.0)LEFT="275" WIDTH="81"position of lightLEFT="0" WIDTH="80"SPOTDIRECTIONID="03.finish481"LEFT="85" WIDTH="101"GL_SPOT_DIRECTIONID="03.finish482"LEFT="195" WIDTH="72"(0, 0, -1)LEFT="275" WIDTH="81"spot directionLEFT="0" WIDTH="80"SPOTLIGHTID="03.finish483"LEFT="85" WIDTH="101"LEFT="195" WIDTH="72"LEFT="275" WIDTH="81"LEFT="0" WIDTH="80"LEFT="85" WIDTH="101"GL_SPOT_EXPONENTID="03.finish484"LEFT="195" WIDTH="72"0LEFT="275" WIDTH="81"intensity 
distributionLEFT="0" WIDTH="80"LEFT="85" WIDTH="101"GL_SPOT_CUTOFFID="03.finish485"LEFT="195" WIDTH="72"180LEFT="275" WIDTH="81"maximum spread 
angle of light 
sourceLEFT="0" WIDTH="80"DEFLMODEL, 
ATTENUATION, 
...LEFT="85" WIDTH="101"GL_CONSTANT_ID="03.finish486"ID="03.finish487"ATTENUATIONGL_LINEAR_ID="03.finish488"ATTENUATIONGL_QUADRATIC_ID="03.finish489"ATTENUATIONLEFT="195" WIDTH="72"(1,0,0)LEFT="275" WIDTH="81"attenuation factorsHere's an OpenGL code fragment that demonstrates some OpenGL lighting and material calls, including two-sided lighting:ID="03.finish490"ID="03.finish491"/* Initialize lighting */
void myinit(void)
{
    GLfloat light_ambient[] = { 0.0, 0.0, 0.0, 1.0 };
    GLfloat light_diffuse[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat light_specular[] = { 1.0, 1.0, 1.0, 1.0 };
/*      light_position is NOT default value     */
    GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };

    glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);

    glFrontFace (GL_CW);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_AUTO_NORMAL);
    glEnable(GL_NORMALIZE);
    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);
}

void display(void)
{
    GLdouble eqn[4] = {1.0, 0.0, -1.0, 1.0};
    GLfloat mat_diffuse[] = { 0.8, 0.8, 0.8, 1.0 };
    GLfloat back_diffuse[] = { 0.8, 0.2, 0.8, 1.0 };

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glPushMatrix ();
    glClipPlane (GL_CLIP_PLANE0, eqn);  /*  slice objects   */
    glEnable (GL_CLIP_PLANE0);

    glPushMatrix ();
    glTranslatef (0.0, 2.0, 0.0);
    auxSolidTeapot(1.0);        /*  one-sided lighting  */
    glPopMatrix ();

        /*  two-sided lighting, but same material       */
    glLightModelf (GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
    glMaterialfv (GL_FRONT_AND_BACK, GL_DIFFUSE,
                  mat_diffuse);
    glPushMatrix ();
    glTranslatef (0.0, 0.0, 0.0);
    auxSolidTeapot(1.0);
    glPopMatrix ();

        /*  two-sided lighting, two different materials */
    glMaterialfv (GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv (GL_BACK, GL_DIFFUSE, back_diffuse);
    glPushMatrix ();
    glTranslatef (0.0, -2.0, 0.0);
    auxSolidTeapot(1.0);
    glPopMatrix ();

    glLightModelf (GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE);
    glDisable (GL_CLIP_PLANE0);
    glPopMatrix ();
    glFlush();
}LBL="" HELPID=""Porting ID="43929"Texture CallsID="03.finish492"A single IRIS GL call might be replaced with two or more OpenGL calls, so you'll definitely need to edit the ID="03.finish493"toogl output for these calls. You might need to restructure your code, or use more variables than you did before. Porting notes:OpenGL keeps no tables of textures, just a single 1D texture and a single 2D texture. If you want to reuse your textures, put them in a display list, as described in IDREF="21145" TYPE="TITLE""Porting defs, binds, and sets: Replacing `Tables' of Stored Definitions".OpenGL doesn't automatically generate mipmaps for youname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'if you're using mipmaps, you'll need to call ID="03.finish494"gluBuild2DMipmaps() first.You need to use ID="03.finish495"glEnable() and ID="03.finish496"glDisable() to turn texturing capabilities on and off. See the reference page for details.Texture size in OpenGL is more strictly regulated than in IRIS GL. An OpenGL texture must be2n + 2bwhere n is an integer and b is:0, if there's no border1, if there's a border pixel (textures in OpenGL can have 1 pixel borders)IDREF="76828" TYPE="TABLE"Table 3-44 lists the general OpenGL equivalents to IRIS GL texture calls.COLUMNS="3"LBL="3-44"Table 3-44 ID="76828"Texture CommandsLEFT="0" WIDTH="99"IRIS GL CallLEFT="105" WIDTH="99"OpenGL CallLEFT="210" WIDTH="135"MeaningLEFT="0" WIDTH="99"texdef2d() ID="03.finish497"LEFT="105" WIDTH="99"glTexImage2D()ID="03.finish498"glTexParameter()ID="03.finish499"gluBuild2DMipmaps()ID="03.finish500"LEFT="210" WIDTH="135"specify a 2D texture imageLEFT="0" WIDTH="99"texbind()ID="03.finish501"LEFT="105" WIDTH="99"glTexParameter()ID="03.finish502"glTexImage2D()ID="03.finish503"gluBuild2DMipmaps()ID="03.finish504"LEFT="210" WIDTH="135"select a texture functionLEFT="0" WIDTH="99"tevdef()ID="03.finish505"LEFT="105" WIDTH="99"glTexEnv()ID="03.finish506"LEFT="210" WIDTH="135"define a texture mapping 
environmentLEFT="0" WIDTH="99"tevbind()ID="03.finish507"LEFT="105" WIDTH="99"glTexEnv()ID="03.finish508"LEFT="210" WIDTH="135"select a texture environmentLEFT="0" WIDTH="99"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="105" WIDTH="99"glTexImage1D()ID="03.finish509"LEFT="210" WIDTH="135"LEFT="0" WIDTH="99"t2*(), t3*(), t4*()ID="03.finish510"LEFT="105" WIDTH="99"glTexCoord*()ID="03.finish511"LEFT="210" WIDTH="135"set the current texture 
coordinatesID="03.finish512"LEFT="0" WIDTH="99"texgen()ID="03.finish513"LEFT="105" WIDTH="99"glTexGen()ID="03.finish514"LEFT="210" WIDTH="135"control generation of texture 
coordinatesLEFT="0" WIDTH="99"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="105" WIDTH="99"glGetTexParameter()ID="03.finish515"LEFT="210" WIDTH="135"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="99"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="105" WIDTH="99"gluBuild1DMipmaps()ID="03.finish516"LEFT="210" WIDTH="135"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="99"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="105" WIDTH="99"gluBuild2DMipmaps()ID="03.finish517"LEFT="210" WIDTH="135"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="99"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="105" WIDTH="99"gluScaleImage()ID="03.finish518"ID="03.finish519"LEFT="210" WIDTH="135"scale an image to arbitrary sizeYou'll probably want to look at the OpenGL Programming Guide to get details on how textures work in OpenGL, but here are a few brief, general tips:remember to call gluBuild2DMipmaps() or gluBuild1DMipmaps() before trying to use mipmapsuse glTexParameter() to specify wrapping and filtersuse glTexEnv() to set up texturing environmentuse glTexImage2D() or glTexImage1D() to load each imageuse glEnable() and glDisable() to turn texturing capabilities on and offSee the reference pages for detailed information.LBL="" HELPID=""ID="91980"Translating tevdef()ID="03.finish520"Here's an example of an IRIS GL texture environment definition that specifies the TV_DECAL texture environment option:float tevprops[] = {TV_DECAL, TV_NULL};tevdef(1, 0, tevprops);Here's how you could translate that code to OpenGL:glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);IDREF="21691" TYPE="TABLE"Table 3-45 lists the IRIS GL texture environment options and their OpenGL equivalents.COLUMNS="2"LBL="3-45"Table 3-45 ID="21691"Texture Environment OptionsLEFT="0" WIDTH="171"IRIS GL OptionLEFT="180" WIDTH="162"OpenGL OptionLEFT="0" WIDTH="171"TV_MODULATEID="03.finish521"LEFT="180" WIDTH="162"GL_MODULATEID="03.finish522"LEFT="0" WIDTH="171"TV_DECALID="03.finish523"LEFT="180" WIDTH="162"GL_DECALID="03.finish524"LEFT="0" WIDTH="171"TV_BLENDID="03.finish525"LEFT="180" WIDTH="162"GL_BLENDID="03.finish526"LEFT="0" WIDTH="171"TV_COLORID="03.finish527"LEFT="180" WIDTH="162"GL_TEXTURE_ENV_COLORID="03.finish528"LEFT="0" WIDTH="171"TV_ALPHAID="03.finish529"LEFT="180" WIDTH="162"no direct OpenGL equivalentLEFT="0" WIDTH="171"TV_COMPONENT_SELECTID="03.finish530"LEFT="180" WIDTH="162"no direct OpenGL equivalentFor more detailed information on how to use these options, see the glTexEnv() reference page. LBL="" HELPID=""ID="43009"Translating texdef()ID="03.finish531"Here's an example of an IRIS GL texture definition:float texprops[] = { TX_MINFILTER, TX_POINT,
                     TX_MAGFILTER, TX_POINT,
                     TX_WRAP_S, TX_REPEAT,
                     TX_WRAP_T, TX_REPEAT,
                     TX_NULL };
texdef2d(1, 1, 6, 6, granite_texture, 7, texprops)In the above code example, texdef() specifies the TX_POINT filter as both the magnification and the minification filter, and TX_REPEAT as the wrapping behavior. It also specifies the texture image, in this case an image called granite_texture.In OpenGL, the image specification is handled by the glTexImage*() functions and property-setting is handled by glTexParameter(). So to translate to OpenGL, you'd replace a texdef() call with a call to a glTexImage*() routine and one or more calls to glTexParameter().Here's an example of one way you could translate the IRIS GL code fragment above:GLfloat nearest [] = {GL_NEAREST};
GLfloat repeat [] = {GL_REPEAT};
glTexParameterfv( GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER,
                  nearest);
glTexParameterfv( GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER,
                  nearest);
glTexParameterfv( GL_TEXTURE_1D, GL_TEXTURE_WRAP_S,
                  repeat);
glTexParameterfv( GL_TEXTURE_1D, GL_TEXTURE_WRAP_T,
                  repeat);
glTexImage1D(GL_TEXTURE_1D, 0, 1, 6, 0, GL_RGB,
                  GL_UNSIGNED_SHORT,granite_tex); IDREF="31508" TYPE="TABLE"Table 3-46 lists the IRIS GL texture parameters with their OpenGL equivalents. For more detailed information on OpenGL texture parameters, refer to the glTexParameter() reference page.COLUMNS="2"LBL="3-46"Table 3-46 ID="31508"IRIS GL and OpenGL Texture ParametersLEFT="0" WIDTH="162"texdef(... np, ...) OptionLEFT="170" WIDTH="171"glTexParameter() Parameter NameLEFT="0" WIDTH="162"TX_MINFILTERID="03.finish532"LEFT="170" WIDTH="171"GL_TEXTURE_MIN_FILTERID="03.finish533"LEFT="0" WIDTH="162"TX_MAGFILTERID="03.finish534"LEFT="170" WIDTH="171"GL_TEXTURE_MAG_FILTERID="03.finish535"LEFT="0" WIDTH="162"TX_WRAP, TX_WRAP_SID="03.finish536"ID="03.finish537"LEFT="170" WIDTH="171"GL_TEXTURE_WRAP_SID="03.finish538"LEFT="0" WIDTH="162"TX_WRAP, TX_WRAP_TID="03.finish539"ID="03.finish540"LEFT="170" WIDTH="171"GL_TEXTURE_WRAP_TID="03.finish541"LEFT="0" WIDTH="162"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="170" WIDTH="171"GL_TEXTURE_BORDER_COLORID="03.finish542"IDREF="71837" TYPE="TABLE"Table 3-47 lists the possible values of the IRIS GL texture parameters along with their OpenGL equivalents. If you used special values available only on systems with RealityEngine‘ graphics, you might need to wait for RealityEngine extensions to the OpenGL before you can translate these values exactly (see IDREF="47009" TYPE="TITLE""Porting RealityEngine Graphics Features" for further discussion). For more information on possible values of OpenGL texture parameters, see the glTexParameter() reference page.COLUMNS="2"LBL="3-47"Table 3-47 ID="71837"Values for IRIS GL and OpenGL Texture ParametersLEFT="0" WIDTH="162"IRIS GLLEFT="170" WIDTH="171"OpenGLLEFT="0" WIDTH="162"TX_POINTID="03.finish543"LEFT="170" WIDTH="171"GL_NEARESTID="03.finish544"LEFT="0" WIDTH="162"TX_BILINEARID="03.finish545"LEFT="170" WIDTH="171"GL_LINEARID="03.finish546"LEFT="0" WIDTH="162"TX_MIPMAP_POINTID="03.finish547"LEFT="170" WIDTH="171"GL_NEAREST_MIPMAP_NEARESTID="03.finish548"LEFT="0" WIDTH="162"TX_MIPMAP_BILINEARID="03.finish549"LEFT="170" WIDTH="171"GL_LINEAR_MIPMAP_NEARESTID="03.finish550"LEFT="0" WIDTH="162"TX_MIPMAP_LINEARID="03.finish551"LEFT="170" WIDTH="171"GL_NEAREST_MIPMAP_LINEARID="03.finish552"LEFT="0" WIDTH="162"TX_TRILINEARID="03.finish553"LEFT="170" WIDTH="171"GL_LINEAR_MIPMAP_LINEARID="03.finish554"LBL="" HELPID=""ID="31165"Translating texgen()ID="03.finish555"The functionality of texgen() is replaced by ID="03.finish556"glTexGen() almost entirely, though you need to call glEnable() and glDisable() to turn coordinate generation on and off. IDREF="14951" TYPE="TABLE"Table 3-48 lists the equivalents for texture coordinate names.COLUMNS="3"LBL="3-48"Table 3-48 ID="14951"Texture Coordinate NamesLEFT="0" WIDTH="110"IRIS GL Texture CoordinateLEFT="115" WIDTH="112"OpenGL Texture CoordinateLEFT="235" WIDTH="108"glEnable() ArgumentLEFT="0" WIDTH="110"TX_SID="03.finish557"LEFT="115" WIDTH="112"GL_SID="03.finish558"LEFT="235" WIDTH="108"GL_TEXTURE_GEN_SLEFT="0" WIDTH="110"TX_TID="03.finish559"LEFT="115" WIDTH="112"GL_TID="03.finish560"LEFT="235" WIDTH="108"GL_TEXTURE_GEN_TLEFT="0" WIDTH="110"TX_RID="03.finish561"LEFT="115" WIDTH="112"GL_RID="03.finish562"LEFT="235" WIDTH="108"GL_TEXTURE_GEN_RLEFT="0" WIDTH="110"TX_QID="03.finish563"LEFT="115" WIDTH="112"GL_QID="03.finish564"LEFT="235" WIDTH="108"GL_TEXTURE_GEN_QIDREF="80835" TYPE="TABLE"Table 3-49 lists texture generation mode and plane names.COLUMNS="3"LBL="3-49"Table 3-49 ID="80835"Texture Generation Modes and PlanesLEFT="0" WIDTH="99"IRIS GL Texture ModeLEFT="105" WIDTH="108"OpenGL Texture ModeLEFT="220" WIDTH="126"Corresponding Plane NameLEFT="0" WIDTH="99"TG_LINEARID="03.finish565"LEFT="105" WIDTH="108"GL_OBJECT_LINEARID="03.finish566"LEFT="220" WIDTH="126"GL_OBJECT_PLANEID="03.finish567"LEFT="0" WIDTH="99"TG_CONTOURID="03.finish568"LEFT="105" WIDTH="108"GL_EYE_LINEARID="03.finish569"LEFT="220" WIDTH="126"GL_EYE_PLANEID="03.finish570"LEFT="0" WIDTH="99"TG_SPHEREMAPID="03.finish571"LEFT="105" WIDTH="108"GL_SPHERE_MAPID="03.finish572"LEFT="220" WIDTH="126"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'With IRIS GL, you call texgen() twice: once to simultaneously set the mode and a plane equation, and once more to enable texture coordinate generation. In OpenGL, you make three calls: two to glTexGen() (once to set the mode, and again to set the plane equation), and one to glEnable(). For example, if you called texgen() like this:texgen(TX_S, TG_LINEAR, planeParams);
texgen(TX_S, TG_ON, NULL);the equivalent OpenGL code is:glTexGen(GL_S, GL_TEXTURE_GEN_MODE, modeName);
glTexGen(GL_S, GL_OBJECT_PLANE, planeParams);
glEnable(GL_TEXTURE_GEN_S);LBL="" HELPID=""Texturing in OpenGL: An ExampleHere's an example of a complete OpenGL program demonstrating texture mapping:/*  checker2.c
 *  This program texture maps a checkerboard image onto
 *  two rectangles.  This program repeats the texture, if
 *  the texture coordinates fall outside 0.0 and 1.0.
 */
#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"

/*      Create checkerboard texture     */
#define checkImageWidth 64
#define checkImageHeight 64
GLubyte checkImage[checkImageWidth][checkImageHeight][3];

void makeCheckImage(void)
{
    int i, j, r, c;

    for (i = 0; i < checkImageWidth; i++) {
        for (j = 0; j < checkImageHeight; j++) {
            c = ((((i&0x8)==0)^((j&0x8))==0))*255;
            checkImage[i][j][0] = (GLubyte) c;
            checkImage[i][j][1] = (GLubyte) c;
            checkImage[i][j][2] = (GLubyte) c;
        }
    }
}

void myinit(void)
{
    glClearColor (0.0, 0.0, 0.0, 0.0);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);

    makeCheckImage();
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glTexImage2D(GL_TEXTURE_2D, 0, 3, checkImageWidth,
        checkImageHeight, 0, GL_RGB, GL_UNSIGNED_BYTE,
        &checkImage[0][0][0]);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
                    GL_REPEAT);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,
                    GL_REPEAT);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
                    GL_NEAREST);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
                    GL_NEAREST);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
    glEnable(GL_TEXTURE_2D);
    glShadeModel(GL_FLAT);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glBegin(GL_QUADS);
    glTexCoord2f(0.0, 0.0); glVertex3f(-2.0, -1.0, 0.0);
    glTexCoord2f(0.0, 3.0); glVertex3f(-2.0, 1.0, 0.0);
    glTexCoord2f(3.0, 3.0); glVertex3f(0.0, 1.0, 0.0);
    glTexCoord2f(3.0, 0.0); glVertex3f(0.0, -1.0, 0.0);

    glTexCoord2f(0.0, 0.0); glVertex3f(1.0, -1.0, 0.0);
    glTexCoord2f(0.0, 3.0); glVertex3f(1.0, 1.0, 0.0);
    glTexCoord2f(3.0, 3.0); glVertex3f(2.41421, 1.0,
                                       -1.41421);
    glTexCoord2f(3.0, 0.0); glVertex3f(2.41421, -1.0,
                                       -1.41421);
    glEnd();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(60.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0,
                   30.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef(0.0, 0.0, -3.6);
}

int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGBA | AUX_DEPTH);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}LBL="" HELPID=""Porting ID="20349"Picking CallsID="03.finish573"All the IRIS GL picking calls have OpenGL equivalents, with the exception of clearhitcode(). IDREF="44504" TYPE="TABLE"Table 3-50 lists the IRIS GL picking calls and their OpenGL counterparts.COLUMNS="3"LBL="3-50"Table 3-50 ID="44504"Calls for PickingLEFT="0" WIDTH="108"IRIS GL CallLEFT="115" WIDTH="125"OpenGL CallLEFT="245" WIDTH="100"NotesLEFT="0" WIDTH="108"clearhitcode()LEFT="115" WIDTH="125"not supportedLEFT="245" WIDTH="100"clears global variable, 
hitcodeLEFT="0" WIDTH="108"pick(),ID="03.finish574" select()ID="03.finish575"LEFT="115" WIDTH="125"glRenderMode(GL_SELECT)ID="03.finish576"LEFT="245" WIDTH="100"switch to selection/
picking modeLEFT="0" WIDTH="108"endpick(),ID="03.finish577"endselect()ID="03.finish578"LEFT="115" WIDTH="125"glRenderMode(GL_RENDER)ID="03.finish579"LEFT="245" WIDTH="100"switch back to 
rendering modeLEFT="0" WIDTH="108"picksize()ID="03.finish580"LEFT="115" WIDTH="125"gluPickMatrix()ID="03.finish581"LEFT="245" WIDTH="100"LEFT="0" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="115" WIDTH="125"glSelectBuffer()ID="03.finish582"LEFT="245" WIDTH="100"set the return arrayLEFT="0" WIDTH="108"initnames()ID="03.finish583"LEFT="115" WIDTH="125"glInitNames()ID="03.finish584"LEFT="245" WIDTH="100"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="108"pushname(),ID="03.finish585"popname()ID="03.finish586"LEFT="115" WIDTH="125"glPushName(), glPopName()ID="03.finish587"ID="03.finish588"LEFT="245" WIDTH="100"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="108"loadname()ID="03.finish589"LEFT="115" WIDTH="125"glLoadName()ID="03.finish590"LEFT="245" WIDTH="100"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'For more information on picking, refer to the gluPickMatrix() reference page and the OpenGL Programming Guide.Here's an example of an OpenGL program that demonstrates picking:#include <stdio.h>
#include <gl/gl.h>
#include <gl/device.h>

#define SELECT 1
#define RENDER 2

void drawLine(int mode)
{
    float vec1[3] = {30.0, 30.0, 0.0};
    float vec2[3] = {50.0, 60.0, 0.0};
    float vec3[3] = {70.0, 40.0, 0.0};

    if (mode == SELECT)
      loadname(1);
    else
      cpack (0xFFFFFF);
    bgnline ();
      v3f (vec1);
      v3f (vec2);
    endline ();    

    if (mode == SELECT)
      loadname(2);
    else
      cpack (0xFFFFFF);
    bgnline ();
      v3f (vec2);
      v3f (vec3);
    endline ();    
}

#define BUFSIZE 50

void printhits(short buffer[], long hits)
{
    int indx, items, h, i;
    char str[20];

    printf("%ld hit", hits);

    if (hits != 1)
      printf("s");
    if (hits > 0)
      printf(": ");
    indx = 0;
    for (h = 0; h < hits; h++) {
      items = buffer[indx++];
      printf("(");
      for (i = 0; i < items; i++) {
          if (i != 0)
            printf(" ");
          printf("%d", buffer[indx++]);
       }
      printf(") ");
    }
    printf("\n");
}

main()
{
    Device dev;
    short val;
    long hits;
    long xsize, ysize;
    short buffer[BUFSIZE];
    Boolean run;

    prefsize (100, 100);
    winopen ("pickline");
    RGBmode ();
    gconfig ();
    getsize(&xsize, &ysize);
    mmode(MVIEWING);
    ortho2(0.0, 100.0, 0.0, 100.0);

    cpack(0);
    clear();
    qdevice(LEFTMOUSE);
    qdevice(ESCKEY);
        
    drawLine(RENDER);
    run = TRUE;

    picksize (5,5);
    while (run) {
      dev = qread(&val);
      if (val == 0) {                /* on upstroke */
        switch (dev) {
        case LEFTMOUSE:
          pushmatrix ();
            pick(buffer, BUFSIZE);
            ortho2(0.0, 100.0, 0.0, 100.0);
            drawLine(SELECT);/* no actual drawing happens */
            hits = endpick(buffer);
          popmatrix ();
          printhits(buffer, hits);
          break;
        
        case ESCKEY:
          run = FALSE;
          break;
        }
    }
    }
    gexit();
    return 0;
}Here's how you could handle picking in OpenGL. This example uses auxiliary library calls for windowing and event handling./*
 *  pickline.c
 *  This code demonstrates picking.  Press the left mouse
 *  button to enter picking mode.  You get two hits if you
 *  click the intersection of the lines.
 */
#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"

void drawLine(GLenum mode)
{
    if (mode == GL_SELECT)
      glLoadName (1);
    glBegin (GL_LINES);
      glColor3f (1.0, 1.0, 1.0);
      glVertex3f (30.0, 30.0, 0.0);
      glVertex3f (50.0, 60.0, 0.0);
    glEnd (); 

    if (mode == GL_SELECT)
      glLoadName (2);
    glBegin (GL_LINES);
      glColor3f (1.0, 1.0, 1.0);
      glVertex3f (50.0, 60.0, 0.0);
      glVertex3f (70.0, 40.0, 0.0);
    glEnd (); 
}

void printHits (GLint hits, GLuint buffer[])
{
    unsigned int i, j, names, ii, jj;
    unsigned int *ptr;

    printf ("hits = %d\n", hits);
    ptr = (unsigned int *) buffer;
    for (i = 0; i < hits; i++) {    /*  for each hit  */
      names = *ptr;
      printf (" number of names for this hit = %d\n", names);
      ptr++;
      printf ("  z1 is %u;", *ptr); ptr++;
      printf (" z2 is %u\n", *ptr); ptr++;
      printf ("   names are ");
      for (j = 0; j < names; j++) {    /*  for each name */
        printf ("%d ", *ptr);
        ptr++;
      }
      printf ("\n");
    }
}

#define BUFSIZE 512

void pickLine(AUX_EVENTREC *event)
{
    GLuint selectBuf[BUFSIZE];
    GLint hits;
    GLint viewport[4];
    int x, y;

    x = event->data[AUX_MOUSEX];
    y = event->data[AUX_MOUSEY];
    glGetIntegerv (GL_VIEWPORT, viewport);

    glSelectBuffer (BUFSIZE, selectBuf);
    (void) glRenderMode (GL_SELECT);

    glInitNames();
    glPushName(-1);

    glPushMatrix ();
    glMatrixMode (GL_PROJECTION);
    glLoadIdentity ();
    gluPickMatrix (x, 100-y, 5, 5, viewport);
    gluOrtho2D (0.0, 100.0, 0.0, 100.0);
    drawLine (GL_SELECT);
    glPopMatrix ();
    glFlush ();

    hits = glRenderMode (GL_RENDER);
    printHits (hits, selectBuf);
} 

void display(void)
{
    glMatrixMode (GL_PROJECTION);
    glLoadIdentity ();
    gluOrtho2D (0.0, 100.0, 0.0, 100.0);

    glClearColor (0.0, 0.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT);
    drawLine (GL_RENDER);
    glEnd ();
    glFlush();
}

void main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);
    auxInitPosition (0, 0, 100, 100);
    auxInitWindow (argv[0]);
    auxMouseFunc (AUX_LEFTBUTTON, AUX_MOUSEDOWN, pickLine);
    auxMainLoop(display);
}LBL="" HELPID=""Porting ID="43211"Feedback CallsFeedback under IRIS GL differed from machine to machine. OpenGL standardizes feedback, so you can now rely on consistent feedback from machine to machine, implementation to implementation. IDREF="91748" TYPE="TABLE"Table 3-51 lists IRIS GL and OpenGL feedback calls.COLUMNS="3"LBL="3-51"Table 3-51 ID="91748"Feedback CallsLEFT="0" WIDTH="63"IRIS GL CallLEFT="70" WIDTH="144"OpenGL CallLEFT="220" WIDTH="126"NotesLEFT="0" WIDTH="63"feedback()ID="03.finish591"LEFT="70" WIDTH="144"glRenderMode(GL_FEEDBACK)ID="03.finish592"LEFT="220" WIDTH="126"switch to feedback modeLEFT="0" WIDTH="63"endfeedback()ID="03.finish593"LEFT="70" WIDTH="144"glRenderMode(GL_RENDER)LEFT="220" WIDTH="126"switch back to rendering 
modeLEFT="0" WIDTH="63"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="70" WIDTH="144"glFeedbackBuffer()ID="03.finish594"LEFT="220" WIDTH="126"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="63"passthrough()ID="03.finish595"LEFT="70" WIDTH="144"glPassThrough()ID="03.finish596"LEFT="220" WIDTH="126"place a token marker in the 
feedback bufferFor more information, see the reference pages or the OpenGL Programming Guide.Here's an example demonstrating OpenGL feedback:/*
 * feedback.c
 * This program demonstrates use of OpenGL feedback. First,
 * a lighting environment is set up and a few lines are
 * drawn. Then feedback mode is entered, and the same lines
 * are drawn. The results in the feedback buffer are printed.
 */
#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"

/*    Initialize lighting.
 */
void myinit(void)
{
 glEnable(GL_LIGHTING);
 glEnable(GL_LIGHT0);
}

/*    Draw a few lines and two points, one of which will 
 *    be clipped. If in feedback mode, a passthrough token 
 *    is issued between the primitives.
 */
void drawGeometry (long mode)
{
 glBegin (GL_LINE_STRIP);
 glNormal3f (0.0, 0.0, 1.0);
 glVertex3f (30.0, 30.0, 0.0);
 glVertex3f (50.0, 60.0, 0.0);
 glVertex3f (70.0, 40.0, 0.0);
 glEnd ();
 if (mode == GL_FEEDBACK)
    glPassThrough (1.0);
 glBegin (GL_POINTS);
 glVertex3f (-100.0, -100.0, -100.0);   /* will be clipped */
 glEnd ();
 if (mode == GL_FEEDBACK)
    glPassThrough (2.0);
 glBegin (GL_POINTS);
 glNormal3f (0.0, 0.0, 1.0);
 glVertex3f (50.0, 50.0, 0.0);
 glEnd ();
}

void print3DcolorVertex(GLint size, GLint *count,
                        GLfloat *buffer)
{
 int i;

 printf (" ");
 for (i = 0; i < 7; i++) {
    printf ("%4.2f ", buffer[size-(*count)]);
    *count = *count - 1;
 }
 printf ("\n");
}

void printBuffer(GLint size, GLfloat *buffer)
{
 GLint count;
 GLfloat token;

 count = size;
 while (count) {
    token = buffer[size-count]; count--;
    if (token == GL_PASS_THROUGH_TOKEN) {
     printf ("GL_PASS_THROUGH_TOKEN\n");
     printf (" %4.2f\n", buffer[size-count]);
     count--;
    }
    else if (token == GL_POINT_TOKEN) {
     printf ("GL_POINT_TOKEN\n");
     print3DcolorVertex (size, &count, buffer);
    }
    else if (token == GL_LINE_TOKEN) {
     printf ("GL_LINE_TOKEN\n");
     print3DcolorVertex (size, &count, buffer);
     print3DcolorVertex (size, &count, buffer);
    }
    else if (token == GL_LINE_RESET_TOKEN) {
     printf ("GL_LINE_RESET_TOKEN\n");
     print3DcolorVertex (size, &count, buffer);
     print3DcolorVertex (size, &count, buffer);
    }
 }
}

void display(void)
{
 GLfloat feedBuffer[1024];
 GLint size;

 glMatrixMode (GL_PROJECTION);
 glLoadIdentity ();
 glOrtho (0.0, 100.0, 0.0, 100.0, 0.0, 1.0);

 glClearColor (0.0, 0.0, 0.0, 0.0);
 glClear(GL_COLOR_BUFFER_BIT);
 drawGeometry (GL_RENDER);

 glFeedbackBuffer (1024, GL_3D_COLOR, feedBuffer);
 (void) glRenderMode (GL_FEEDBACK);
 drawGeometry (GL_FEEDBACK);

 size = glRenderMode (GL_RENDER);
 printBuffer (size, feedBuffer);
}

void main(int argc, char** argv)
{
 auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);
 auxInitPosition (0, 0, 100, 100);
 auxInitWindow (argv[0]);
 myinit ();
 auxMainLoop(display);
}LBL="" HELPID=""ID="47009"Porting RealityEngine Graphics FeaturesUnfortunately, some IRIS GL features that were available only on systems with RealityEngine graphics are unavailable in OpenGL.ID="03.finish597"IDREF="59631" TYPE="TABLE"Table 3-52 lists the IRIS GL RealityEngine calls and their OpenGL counterparts.COLUMNS="3"LBL="3-52"Table 3-52 ID="59631"RealityEngine CallsLEFT="0" WIDTH="81"IRIS GL CallLEFT="90" WIDTH="180"OpenGL CallLEFT="275" WIDTH="72"NotesLEFT="0" WIDTH="81"blendcolor()LEFT="90" WIDTH="180"glBlendColorEXT()LEFT="275" WIDTH="72"specify a color to 
blendLEFT="0" WIDTH="81"convolve()LEFT="90" WIDTH="180"glConvolutionFilter2DEXT(), 
glSeparableFilter2DEXT(), 
glConvolutionParameterEXT(), 
glPixelTransfer()LEFT="275" WIDTH="72"convolve an 
input image 
with a kernel 
imageLEFT="0" WIDTH="81"displacepolygon()LEFT="90" WIDTH="180"glPolygonOffsetEXT()LEFT="275" WIDTH="72"specify z 
displacement 
for rendered 
polygonsLEFT="0" WIDTH="81"fbsubtexload()LEFT="90" WIDTH="180"not supportedLEFT="275" WIDTH="72"load part or all 
of a textureLEFT="0" WIDTH="81"gethgram()LEFT="90" WIDTH="180"glGetHistogramEXT()LEFT="275" WIDTH="72"get histogram 
dataLEFT="0" WIDTH="81"getminmax()LEFT="90" WIDTH="180"glGetMinmaxEXT()LEFT="275" WIDTH="72"get minimum 
and maximum 
graphics valuesLEFT="0" WIDTH="81"hgram()LEFT="90" WIDTH="180"glHistogramEXT(), glResetHistogramEXT()LEFT="275" WIDTH="72"compute 
histogram of 
pixel-transfer 
informationLEFT="0" WIDTH="81"ilbuffer()LEFT="90" WIDTH="180"not supportedLEFT="275" WIDTH="72"allocate space 
for temporary 
image-
processing 
resultsLEFT="0" WIDTH="81"ildraw()LEFT="90" WIDTH="180"not supportedLEFT="275" WIDTH="72"select an ilbuffer 
to draw intoLEFT="0" WIDTH="81"istexloaded()LEFT="90" WIDTH="180"not supportedLEFT="275" WIDTH="72"find out whether 
a given texture 
is resident in 
texture memoryLEFT="0" WIDTH="81"leftbuffer()LEFT="90" WIDTH="180"glDrawBuffer(GL_LEFT)LEFT="275" WIDTH="72"enable left-
buffer drawingLEFT="0" WIDTH="81"minmax()LEFT="90" WIDTH="180"glMinmaxEXT()LEFT="275" WIDTH="72"compute 
minimum and 
maximum pixel 
valuesLEFT="0" WIDTH="81"monobuffer()LEFT="90" WIDTH="180"superseded by selection of an appropriate 
GLX visualLEFT="275" WIDTH="72"select 
monoscopic 
viewingLEFT="0" WIDTH="81"msalpha()LEFT="90" WIDTH="180"glEnable( 
GL_SAMPLE_ALPHA_TO_MASK_SGIS), 
glEnable( 
GL_SAMPLE_ALPHA_TO_ONE_SGIS)LEFT="275" WIDTH="72"specify 
treatment of 
alpha values 
during 
multisamplingLEFT="0" WIDTH="81"msmask()LEFT="90" WIDTH="180"glSampleMaskSGIS()LEFT="275" WIDTH="72"specify a 
multisample 
maskLEFT="0" WIDTH="81"mspattern()LEFT="90" WIDTH="180"glSamplePatternSGIS()LEFT="275" WIDTH="72"specify a sample 
pattern for 
multisamplingLEFT="0" WIDTH="81"mssize()LEFT="90" WIDTH="180"glXChooseVisual() with attribute 
GLX_SAMPLE_BUFFERS_SGISLEFT="275" WIDTH="72"configure 
multisample 
bufferLEFT="0" WIDTH="81"multisample()LEFT="90" WIDTH="180"glEnable(GL_MULTISAMPLE_SGIS)LEFT="275" WIDTH="72"enable or 
disable 
multisamplingLEFT="0" WIDTH="81"pixelmap()LEFT="90" WIDTH="180"glPixelMap()LEFT="275" WIDTH="72"define pixel 
transfer lookup 
tablesLEFT="0" WIDTH="81"pixeltransfer()LEFT="90" WIDTH="180"glPixelTransfer()LEFT="275" WIDTH="72"set transfer 
modesLEFT="0" WIDTH="81"readcomponent()LEFT="90" WIDTH="180"glReadPixels() gives partial support; some 
readcomponent() features aren't yet 
supportedLEFT="275" WIDTH="72"choose a 
component 
sourceLEFT="0" WIDTH="81"rightbuffer()LEFT="90" WIDTH="180"glDrawBuffer(GL_RIGHT)LEFT="275" WIDTH="72"enable drawing 
in right bufferLEFT="0" WIDTH="81"stereobuffer()LEFT="90" WIDTH="180"superseded by selection of an appropriate 
GLX visualLEFT="275" WIDTH="72"select 
stereoscopic 
viewingLEFT="0" WIDTH="81"subtexload()LEFT="90" WIDTH="180"glTexSubImage2DEXT() gives partial 
support (the flags parameter to subtexload() 
isn't supported)LEFT="275" WIDTH="72"load part or all 
of a textureLEFT="0" WIDTH="81"texdef3d()LEFT="90" WIDTH="180"glTexImage3DEXT()LEFT="275" WIDTH="72"convert 3D 
image into a 
textureLEFT="0" WIDTH="81"tlutbind()LEFT="90" WIDTH="180"not supportedLEFT="275" WIDTH="72"select a texture 
lookup tableLEFT="0" WIDTH="81"tlutdef()LEFT="90" WIDTH="180"not supportedLEFT="275" WIDTH="72"define a texture 
lookup tableLEFT="0" WIDTH="81"zbsize()LEFT="90" WIDTH="180"superseded by selection of an appropriate 
GLX visualLEFT="275" WIDTH="72"specify number 
of bitplanes to 
use for the depth 
bufferSome RealityEngine features (mostly involving texturing) don't correspond to specific IRIS GL functions, and thus don't fit nicely into IDREF="59631" TYPE="TABLE"Table 3-52. Some such features are supported by extensions to OpenGL; you should check at runtime to see if the relevant extension is supported by calling glGetString(GL_EXTENSIONS) (see the glGetString() reference page for more information). Some other non-function-specific IRIS GL RealityEngine features aren't supported at all.Each of the following features is supported on a given machine if the corresponding OpenGL extension is supported:The internal texture storage format (TX_INTERNAL_FORMAT in IRIS GL) is supported by the texture extension (GL_EXT_texture). OpenGL without extensions supports a superset of the formats previously specified by TX_EXTERNAL_FORMAT; see the glTexImage2D() reference page for more information.Sharpen texture is supported by the GL_SGIS_sharpen_texture extension. This was done in IRIS GL by passing TX_SHARPEN to texdef().Detail texture is supported by the GL_SGIS_detail_texture extension. This was done in IRIS GL by using the tokens TX_DETAIL, TX_ADD_DETAIL, and TX_MODULATE_DETAIL in texdef() calls.The detail texture and sharpen texture extension both support control points (pairs of level-of-detail and scale values) to control the rate at which the relevant filters are applied (see TX_CONTROL_CLAMP and TX_CONTROL_POINT in the texdef() reference page). However, unlike IRIS GL, OpenGL uses a separate set of control points for each of the two filters.IRIS GL's ABGR pixel format is supported by the GL_EXT_abgr extension.Texture and texture environment definition and binding (formerly done by using texdef(), texbind(), tevdef(), and tevbind()) are currently handled in OpenGL by creating a display list containing a glTexImage2D() call. (No OpenGL extension is required.)These features are not supported in OpenGL or its extensions:automatic mipmap generation is supported (in the GLU library, by gluBuild2DMipmaps()), but you can't change the default filtering used to generate mipmap levels (see TX_MIPMAP_FILTER_KERNEL in the texdef() reference page)bicubic texture filtering (see the descriptions of TX_BICUBIC and TX_BICUBIC_FILTER in the texdef() reference page)shadows (see the descriptions of TX_BILINEAR_LEQUAL and TX_BILINEAR_GEQUAL in the texdef() reference page, and of TV_ALPHA in the tevdef() reference page)component selection (see TV_COMPONENT_SELECT in the tevdef() reference page)texture definition from a live video stream (available in IRIS GL using the flags argument to subtexload())fast texture definition, as performed in IRIS GL with TX_FAST_DEFINEquadlinear mipmap filtering (see TX_MIPMAP_QUADLINEAR in the texdef() reference page)specifying separate alpha and non-alpha functions for texture magnification filtering (see TX_MAGFILTER_COLOR and TX_MAGFILTER_ALPHA in the texdef() reference page)LBL="" HELPID=""OpenGL ExtensionsFor information on extensions to OpenGL, see the glintro and glxintro reference pages, as well as the reference pages for individual functions. (For a partial list of extension-related functions, see ID="03.finish598"IDREF="47009" TYPE="TITLE""Porting RealityEngine Graphics Features.")LBL="4"ID="45274"Using the Auxiliary Library to Replace Windowing and Event Handling CallsID="04.auxlib1"The auxiliary library provides several simple routines for windowing, event handling, loading the color map, and drawing several three-dimensional objects.If your program uses only simple window and event handling calls, you can probably replace them with auxiliary library calls, rather than converting immediately to a mixed model program using Xlib or X. Remember that the auxiliary library is limited in functionalityname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'more complicated applications will almost certainly require you to switch to mixed model instead of the auxiliary library.For more information on the auxiliary library or on the auxiliary library calls, refer to the OpenGL Programming Guide. (At the time of this writing, reference pages are not available for auxiliary library routines.)When using the auxiliary library, remember to include the auxiliary library header file:ID="04.auxlib2"#include "aux.h"LBL="" HELPID=""Running a Program That Uses the Auxiliary LibraryID="04.auxlib3"To run a program using the auxiliary library, you need to call ID="04.auxlib4"auxMainLoop() from within your main() routine, passing it the name of the routine that redraws the objects in your scene. The example programs in IDREF="26599" TYPE="TITLE""Windowing with the Auxiliary Library: Example Program" and IDREF="19802" TYPE="TITLE""Input Handling with the Auxiliary Library: Example Program" demonstrate how to do this.NoteauxMainLoop() never exits, so calls that are placed after auxMainLoop() in your program are never executed. LBL="" HELPID=""ID="88614"WindowingID="04.auxlib5"The auxiliary library provides three windowing routines: auxInitWindow(), auxInitDisplayMode(), and auxInitPosition(). With these routines, you can open and initialize a window.Note that if you want to do more complex windowing, you'll need to use X calls. See IDREF="37274" TYPE="TITLE"Chapter 5, "Mixed-Model Programming," for more information. Also note that some IRIS GL window-related functions, notably mswapbuffers() and swapinterval(), have no real equivalents in OpenGL; these will probably be implemented in future OpenGL extensions.LBL="" HELPID=""ID="45155"Replacing prefposition() with auxInitPosition()You can replace ID="04.auxlib6"prefposition() with ID="04.auxlib7"auxInitPosition(). The arguments don't correspond exactly, however. With prefposition() you specified the coordinates of opposite corners of the window. With auxInitPosition() you specify the screen coordinates (in pixels) of the upper left corner of the window, as well as the width and height of the window. The C specification for auxInitPosition() is:void auxInitPosition( GLint x, GLint y, GLsizei width,
                      GLsizei height );The default size for auxInitPosition() is a 100 x 100 pixel square. The default window position is at the upper left corner of the screen.LBL="" HELPID=""ID="64084"Porting Display Mode Initialization Calls with auxInitDisplayMode()ID="04.auxlib8"ID="04.auxlib9"ID="04.auxlib10"You can set the display mode of a window by selecting arguments to auxInitDisplayMode(). The C specification for auxInitDisplayMode() is:void auxInitDisplayMode(GLbitfield mask)The mask argument is a bitwise OR-ed combination of:AUX_RGBA or AUX_INDEXID="04.auxlib11"ID="04.auxlib12"AUX_SINGLE or AUX_DOUBLEID="04.auxlib13"ID="04.auxlib14"and any of these buffer enabling flags:AUX_DEPTH, AUX_STENCIL, and AUX_ACCUMID="04.auxlib15"ID="04.auxlib16"ID="04.auxlib17"So, for example, for a double-buffered, RGBA-mode window with a depth buffer, you would use:auxInitDisplayMode( AUX_DOUBLE | AUX_RGBA | AUX_DEPTH );The default setting for auxInitDisplayMode() is a single-buffered, color index window.IDREF="23684" TYPE="TABLE"Table 4-1 IRIS GL lists display mode calls that can be either fully or partially replaced by auxInitDisplayMode(). COLUMNS="3"LBL="4-1"Table 4-1 ID="23684"auxInitDisplayMode() Arguments and IRIS GL Command EquivalentsLEFT="0" WIDTH="108"IRIS GL CallLEFT="115" WIDTH="108"Corresponding 
auxInitDisplayMode() 
ArgumentLEFT="230" WIDTH="117"Specifies:LEFT="0" WIDTH="108"acsize()ID="04.auxlib18"LEFT="115" WIDTH="108"AUX_ACCUMLEFT="230" WIDTH="117"accumulation-buffer modeLEFT="0" WIDTH="108"cmode()ID="04.auxlib19"LEFT="115" WIDTH="108"AUX_INDEXLEFT="230" WIDTH="117"color-map modeLEFT="0" WIDTH="108"doublebuffer()ID="04.auxlib20"LEFT="115" WIDTH="108"AUX_DOUBLELEFT="230" WIDTH="117"double-buffer modeLEFT="0" WIDTH="108"RGBmode()ID="04.auxlib21"LEFT="115" WIDTH="108"AUX_RGBALEFT="230" WIDTH="117"RGBA modeLEFT="0" WIDTH="108"singlebuffer()ID="04.auxlib22"LEFT="115" WIDTH="108"AUX_SINGLELEFT="230" WIDTH="117"single-buffer modeLEFT="0" WIDTH="108"stensize()ID="04.auxlib23"LEFT="115" WIDTH="108"AUX_STENCILIDREF="04.auxlibTF0a"aLEFT="230" WIDTH="117"stencil-buffer modeLEFT="0" WIDTH="108"zbuffer(TRUE)ID="04.auxlib24"LEFT="115" WIDTH="108"AUX_DEPTHLEFT="230" WIDTH="117"z-buffer modeLBL="a" ID="04.auxlibTF0a"note that stencil() does more than specify stencil-buffer mode,name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'use glStencilFunc() to re
place the rest of the stencil() functionalityNoteThe auxiliary library doesn't providename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'and you won't needname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'an equivalent for ID="04.auxlib25"gconfig(). auxInitDisplayMode() must be called before auxInitWindow().LBL="" HELPID=""ID="49158"Replacing winopen() with auxInitWindow()ID="04.auxlib26"Use ID="04.auxlib27"auxInitWindow() to replace ID="04.auxlib28"winopen(). The C specification for auxInitWindow() is:void auxInitWindow (GLbyte *titleString);The specified string appears in the title bar of the window, and the escape key is bound to an exiting function that kills the window and exits the program. The default color for the background window is set to black for an RGBA window and to color index 0 for a color-index window.ID="04.auxlib29"ID="04.auxlib30"NoteRemember that auxInitDisplayMode() must be called before auxInitWindow(). LBL="" HELPID=""ID="26599"Windowing with the Auxiliary Library: Example ProgramHere's a simple program that uses the auxiliary library to initialize and open a window:/*
 *  simple.c
 *  This program draws a white rectangle on a black background.
 */
#include <GL/gl.h>
#include "aux.h"

int main(int argc, char** argv)
{
        auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);
        auxInitPosition (0, 0, 500, 500);
        auxInitWindow (argv[0]);

        glClearColor (0.0, 0.0, 0.0, 0.0);
        glClear(GL_COLOR_BUFFER_BIT);
        glColor3f(1.0, 1.0, 1.0);
        glMatrixMode (GL_PROJECTION);
        glLoadIdentity ();
        glOrtho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0);
        glBegin(GL_POLYGON);
                glVertex2f(-0.5, -0.5);
                glVertex2f(-0.5, 0.5);
                glVertex2f(0.5, 0.5);
                glVertex2f(0.5, -0.5);
        glEnd();
        glFlush();
        sleep (10);
}LBL="" HELPID=""ID="43633"Event Handling: Replacing qdevice(), qtest(), and qread()ID="04.auxlib31"If you used the queuing method of event handling, you can use the auxiliary library to replace simple IRIS GL event handling calls. If you used polling calls, such as ID="04.auxlib32"getvaluator() and ID="04.auxlib33"getbutton(), you can't exactly replace that functionality with the auxiliary library. And, in general, for anything particularly complicated, you should probably invest the extra effort and translate your program to mixed model.The auxiliary library's method of event handling is somewhat different from what you're used to in IRIS GL. With the auxiliary library, you structure your application's event handling to use callback functions. In general, you first open a window and register callback routines for specific events. Then you create a main loop without an exit. In the main loop, if an event occurs, its registered callback functions are executed. Upon completion of the callback functions, flow of control is returned to the main loop.After a window is created, but before you enter the main loop, register callback functions using these three auxiliary library event handling routines: auxReshapeFunc()ID="04.auxlib34", auxKeyFunc(), and auxMouseFunc().Each of these three routines takes over some part of what you used to do with qdevice(), qtest(), and qread(), so read each section for details.LBL="" HELPID=""ID="91085"Handling Redraw EventsThis section explains how to use ID="04.auxlib35"ID="04.auxlib36"auxReshapeFunc() to specify a function to be called whenever the window is resized, moved, or exposed. In IRIS GL, you might have done something like this:gid = winopen("MyProgram"); /*initialization*/
qenter(REDRAW,gid); 
dev = qread (&value);
if ( dev == REDRAW ) {
       reshapeviewport();
       MySceneRedraw();
}Using the auxiliary library, you specify a function that will be called automatically whenever you get a redraw event. Here's an example of a redraw function:void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective (45.0, (GLfloat) w/(GLfloat) h, 3.0, 5.0);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity ();
    glTranslatef (0.0, 0.0, -4.0);/*move object into view*/}Once you've written your redraw function, like the myReshape() in the example above, you have auxReshapeFunc() call it from the main loop. In this example, the main loop might look something like this:int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGBA | AUX_DEPTH);
    auxInitPosition (0, 0, 400, 400);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}Here's the C specification for auxReshapeFunc():void auxReshapeFunc( void (*function) (GLsizei, GLsizei));The argument function is a pointer to a function that expects two arguments: the new width and height of the window. Typically, the function calls ID="04.auxlib37"glViewport() so that the display is clipped to the new size, and it redefines the projection matrix so that the aspect ratio of the projected image matches the viewport, avoiding aspect ratio distortion. If you don't call ID="04.auxlib38"auxReshapeFunc(), a default reshape function is called, which assumes a two-dimensional orthographic projection. With the auxiliary library, the window is automatically redrawn after every reshaping event.LBL="" HELPID=""Handling Keyboard InputID="04.auxlib39"With IRIS GL, you might do something like this:qdevice (AKEY); /*initialization*/ 
dev = qread (&value);
if ((device == AKEY) && (val == 1))
    /* toggle autopilot mode */
    autopilot = ! autopilot;In the auxiliary library, you use ID="04.auxlib40"auxKeyFunc() to specify a function that will be called automatically whenever the A key is pressed. So, for this example, before entering the main loop of your program, you could define a function called MyAutopilot() to toggle the autopilot mode for you, then in the main loop of your program, you could call:auxKeyFunc(AUX_a, MyAutopilot);Then the auxiliary library will call MyAutopilot whenever the A key is pressed. The C specification for auxKeyFunc() is:void auxKeyFunc(GLint key, void (*function) (void) );Specifies the function that is called when the key indicated by key is pressed. Use one of the auxiliary library constants for key:AUX_A through AUX_Z for the upper case alphabetID="04.auxlib41"ID="04.auxlib42"AUX_a through AUX_z for the lower case alphabetID="04.auxlib43"ID="04.auxlib44"AUX_0 through AUX_9 for the digitsID="04.auxlib45"ID="04.auxlib46"AUX_LEFT, AUX_RIGHT, AUX_UP, and AUX_DOWN for the arrow keysID="04.auxlib47"ID="04.auxlib48"ID="04.auxlib49"ID="04.auxlib50"AUX_ESCAPE, AUX_SPACE, and AUX_RETURN for the escape key, the spacebar, and the return key, respectivelyID="04.auxlib51"ID="04.auxlib52"ID="04.auxlib53"With the auxiliary library, the window is automatically redrawn after every processed key event, although in a more sophisticated application, you might want to wait for several events to be completed before drawing. LBL="" HELPID=""Handling Mouse EventsID="04.auxlib54"The C specification for ID="04.auxlib55"auxMouseFunc() is:void auxMouseFunc(GLint button, GLint mode,                  void(*function)(AUX_EVENTREC *) );auxMouseFunc() specifies the function that is called when the mouse button indicated by button enters the mode defined by mode. Here are the possible button arguments:AUX_LEFTBUTTONID="04.auxlib56"AUX_RIGHTBUTTONID="04.auxlib57"AUX_MIDDLEBUTTONID="04.auxlib58"Here are the possible mode arguments:AUX_MOUSEDOWNID="04.auxlib59"AUX_MOUSEUPID="04.auxlib60"AUX_MOUSELOCID="04.auxlib61"The function argument must take one argument that is a pointer to a structure of type AUX_EVENTREC. The ID="04.auxlib62"ID="04.auxlib63"auxMouseFunc() routine allocates memory for the structure. IDREF="19802" TYPE="TITLE""Input Handling with the Auxiliary Library: Example Program" contains a complete program using auxMouseFunc().With IRIS GL, you might do something like this:qdevice (LEFTMOUSE); /*initialization*/
tie(LEFTMOUSE, MOUSEX, MOUSEY);
...
dev = qread (&value);

if (dev == LEFTMOUSE)
    {
        if (value)
        {
            qread(&x);
            qread(&y);
            qdevice(MOUSEX);
            qdevice(MOUSEY);
        }
        elseIn the auxiliary library, you use auxMouseFunc() to specify functions that will be called automatically whenever the left mouse button is pressed or released. To replace the IRIS GL code above, you might define a function like this:void MyFunction (AUX_EVENTREC *event ) {
    GLint x, y;
    x = event -> data[AUX_MOUSEX];
    y = event -> data[AUX_MOUSEY];
    ...
}Then in your main loop you would call auxMouseFunc() like this:auxMouseFunc(AUX_LEFTMOUSE, AUX_MOUSEDOWN, MyFunction);For more information on auxMouseFunc(), see the OpenGL Programming Guide. You might also want to look at the aux.h include file for more information on defined constants, structure types, and so on. LBL="" HELPID=""ID="19802"Input Handling with the Auxiliary Library: Example ProgramID="04.auxlib64"This program uses the auxiliary library for simple windowing and event handling. For another program example using the auxiliary library, see IDREF="13844" TYPE="TITLE"Appendix D, "Example OpenGL Program with the Auxiliary Library."/*  movelight.c
 *  This program demonstrates when to issue lighting and
 *  transformation commands to render a model with a light
 *  that is moved by a modeling transformation (rotate or
 *  translate).  The light position is reset after the
 *  modeling transformation is called.  The eye position
 *  does not change.
 
 *  A sphere is drawn using a gray material characteristic.
 *  A single light source illuminates the object.
 *
 *  Interaction:  pressing the left or middle mouse button
 *  alters the modeling transformation (x rotation) by 30
 *  degrees.
 *  The scene is then redrawn with the light in a new
 *  position.
 */

#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"

static int spin = 0;

void movelight (AUX_EVENTREC *event)
{
    spin = (spin + 30) % 360;
}

void myinit (void)
{
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);
}

/*  Here is where the light position is reset
 *  after the modeling transformation (glRotated) 
 *  is called. This places the light at a new position
 *  in world coordinates. The cube represents the 
 *  position of the light.
 */
void display(void)
{
    GLfloat position[] = { 0.0, 0.0, 1.5, 1.0 };

    glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glPushMatrix ();
    glTranslatef (0.0, 0.0, -5.0);

    glPushMatrix ();
    glRotated ((GLdouble) spin, 1.0, 0.0, 0.0);
    glLightfv (GL_LIGHT0, GL_POSITION, position);

    glTranslated (0.0, 0.0, 1.5);
    glDisable (GL_LIGHTING);
    glColor3f (0.0, 1.0, 1.0);
    auxWireCube (0.1);
    glEnable (GL_LIGHTING);
    glPopMatrix ();

    auxSolidTorus (0.275, 0.85);
    glPopMatrix ();
    glFlush ();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(40.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar,
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGBA | AUX_DEPTH);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxMouseFunc (AUX_LEFTBUTTON, AUX_MOUSEDOWN, movelight);
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}LBL="" HELPID=""Managing Background EventsID="04.auxlib65"You can specify a function to be executed if no other events are pending with ID="04.auxlib66"auxIdleFunc(). Here's the C specification:void auxIdleFunc(void (*func(void));This routine takes a pointer to a function as its only argument. Pass in zero to disable the execution of the function.LBL="" HELPID=""ID="54935"Using Color-Index ModeID="04.auxlib67"ID="04.auxlib68"Loading a color map depends completely on the windowing system, so OpenGL doesn't provide any routines for this task. You can use the auxiliary library routine, ID="04.auxlib69"auxSetOneColor(), instead of ID="04.auxlib70"mapcolor(). Like mapcolor(), auxSetOneColor() takes four arguments: an index into the color map, and red, green, and blue values for intensity values of each of those colors. The main thing to remember when you're switching from mapcolor() to auxSetOneColor() is that the red, green, and blue values are now normalized to lie in the range [0.0, 1.0]. So, for color values, mapcolor() took (short) integers between 0 and 255 and auxSetOneColor() takes floats between 0.0 and 1.0. Here's an example of how you could use auxSetOneColor() to load values into the colormap:    for (i = 0; i < 32; i++) {
        auxSetOneColor (16 + i, 1.0 * (i/32.0), 
                        0.0, 1.0 *(i/32.0));
        auxSetOneColor (48 + i, 1.0, 1.0 * (i/32.0), 1.0);
    }For a more complete example, see the program in IDREF="19802" TYPE="TITLE""Input Handling with the Auxiliary Library: Example Program"Here's the C specification for auxSetOneColor():auxSetOneColor (GLint index, GLfloat red, GLfloat green,
                GLfloat blue );NoteAs explained in IDREF="64084" TYPE="TITLE""Porting Display Mode Initialization Calls with auxInitDisplayMode()" you replace the initialization calls to ID="04.auxlib71"cmode() and ID="04.auxlib72"gconfig() by calling auxInitDisplayMode() with the argument AUX_INDEX. LBL="" HELPID=""Other Auxiliary Library RoutinesID="04.auxlib73"ID="04.auxlib74"The auxiliary library provides routines for drawing 3-D objects, such as cylinders, spheres, cubes, teapots, and more. The OpenGL Programming Guide discusses these routines in detail.LBL="5"ID="37274"ID="61628"Mixed-Model ProgrammingID="05.mixed1"ID="05.mixed2"ID="05.mixed3"This chapter provides some preliminary information about OpenGL programming in the X environment. This chapter focuses specifically on information relevant to translating IRIS GL programs into mixed-model OpenGL/X programsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'it does not provide a tutorial on Xt and IRIS IM. For more information on the relevant features of Xt and IRIS IM, consult the OSF/Motif series, and Digital's X Window System Toolkit: The Complete Programmer's Guide and Specification, or O'Reilly's Vols. 4 & 5 on X Toolkit Intrinsics.LBL="" HELPID=""What Is a Mixed-Model Program?ID="05.mixed4"ID="05.mixed5"ID="05.mixed6"ID="05.mixed7"A mixed-model program, in the context of this manual, is an X program that creates one or more subwindows that use OpenGL for rendering. A mixed-model program allows full access to the capabilities of X by completely removing OpenGL from any feature governed by the X server, giving the programmer direct control of all the areas governed by the X server. In a mixed-model program, the X part of the code manages all of the event handling, window control, and menus. You also use X to handle color maps and fonts.ID="05.mixed8"ID="05.mixed9"NoteYou can't create mixed-model programs that go only halfway. Your mixed-model program must use X for all window-system-related services.  You can find examples of many mixed-model programsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'both OpenGL and IRIS GLname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in the 4Dgifts directories. If you have trouble finding the relevant directories, refer to the README file in /usr/people/4Dgifts. This file explains the contents and organization of the 4Dgifts directories. With IRIS GL, instead of creating a mixed-model program, you could use IRIS GL event and window management routines, such as ID="05.mixed10"winopen() or qread()ID="05.mixed11"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'these routines would access the X Window System for you. Silicon Graphics does provide a very limited Auxiliary Library, which provides some windowing and event handling routines, but if these are not sufficient for your purposes, you'll need to translate your IRIS GL code to a mixed-model program.LBL="" HELPID=""ID="16719"Porting IRIS GL Mixed-Model ProgramsIRIS GL provided some mixed-model support, allowing IRIS GL programs to draw in X11 windows, with routines such as GLXgetconfig(), GLXlink(), GLXunlink(), and GLXwinset().  These functions don't have exact equivalents in OpenGL, but see IDREF="39727" TYPE="TITLE"Appendix A for approximate equivalents.The naming conventions for X-related functions may be somewhat confusing, as they depend largely on capitalization to differentiate between groups of functions:GLX*()IRIS GL mixed-model supportGlx*()IRIS GL support for IRIS IMglX*()OpenGL support for XGLw*()OpenGL support for IRIS IMNote that the glX*() routines are, confusingly, collectively referred to as "GLX." Note, too, that GLXgetconfig() (an IRIS GL mixed-model routine) is not at all the same function as glXGetConfig() (an OpenGL mixed-model routine). The commandIRIS% man glxgetconfigon a system with both IRIS GL and OpenGL lists both reference pages, one following the other.LBL="" HELPID=""Two Choices For Mixed-Model ProgrammingID="05.mixed12"When writing a mixed-model program, you have two choices: you can use the Xt toolkit and a widget set, such as IRIS IM, or you can write your program in Xlib and GL using special GLX commands.The first method, using Xt and a widget set, is much easier and is more commonly used by mixed-model developers. This is the method recommended by Silicon Graphicsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'particularly for programmers with little or no previous experience with X.Whichever method you choose, you'll find more information on programming with Xlib and Xt in the X Window System series from O'Reilly & Associates. The material in this chapter is intended as a supplement to the O'Reilly guides, detailing X development features available on Silicon Graphics workstations. LBL="" HELPID=""Using Xt and a Widget SetID="05.mixed13"Silicon Graphics provides a widget library that simplifies mixed-model programming with Xt. IDREF="47893" TYPE="TITLE""Porting to Mixed-Model Using Xt and a Widget Set" explains how to convert your IRIS GL program to an OpenGL/X mixed-model program using Xt, the IRIS Widget Library, and the GL widget, GLwDrawingArea (Silicon Graphics also provides an IRIS IM version of GLwDrawingArea, called GLwMDrawingArea). Sample programs demonstrate these concepts.ID="05.mixed14"ID="05.mixed15"LBL="" HELPID=""Using XlibIf you prefer to create a mixed-model program in Xlib, without using Xt, refer to the recommended references on X programming, and use the GLX routines described in the ID="05.mixed16"ID="05.mixed17"OpenGL Reference Manual (start with the glXIntro reference page). IDREF="34451" TYPE="TITLE""Mixed-Model Programming Using Xlib and OpenGL GLX Commands" provides more information on this mixed-model programming method and contains some code examples. Several complete programs using this method are included in IDREF="77823" TYPE="TITLE"Appendix F, "Example Mixed-Model Programs With Xlib," along with IRIS GL versions of the same programs.LBL="" HELPID=""Some General Hints on Mixed-Model Programming This section contains a few brief hints for OpenGL/X mixed-model programmers. This list is not comprehensivename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'it just describes a few important things to watch out for.LBL="" HELPID=""You Can't Change Window Depth and Display ModeID="05.mixed18"In mixed-model programs, window depth and display mode are window attributes that are defined when the window is created, and they cannot be changed. To change these attributes, you must create a new window. If you need multiple display modes in your application, you can create multiple windows, then map and unmap them, or raise one above the others.LBL="" HELPID=""ID="22249"Installing Color MapsID="05.mixed19"ID="05.mixed20"ID="05.mixed21"ID="05.mixed22"It's a good idea to call ID="05.mixed23"XSetWMColormapWindows() in your mixed-model programname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'this ensures that its color maps are installed. If you don't call XSetWMColormapWindows(), the default X color map is used. Even if your program uses RGB mode, you should still call XSetWMColormapWindows() because some hardware (such as IRIS Indigo) simulates RGB with a color map.ID="05.mixed24"LBL="" HELPID=""ID="89603"Fonts and StringsID="05.mixed25"ID="05.mixed26"The OpenGL contains no equivalents for the IRIS GL text-handling calls and Font Manager calls. To obtain full text- and font-handling facilities, use the OpenGL/X call ID="05.mixed27"glXUseXFont() with display lists to get some text-display capabilities. This section gives you an example.To use display lists to do X bitmap fonts, your code should do the following:ID="05.mixed28"ID="05.mixed29"Use X calls to load information about the font you want to use.Using glXUseXFont(), generate a series of display lists, one for each character in the font.Put the bitmap for one character into each display list, in the order the characters appear in the font.To print out a string, use ID="05.mixed30"glListBase() to set the display list base to the base for your character series. Then pass the string as an argument to glCallLists()ID="05.mixed31".The following code fragment gives you an example, using Helvetica Medium to print out the string "The quick brown fox jumps over a lazy dog." It also prints out the entire character set, from ASCII 32 to 127.#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glx.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include "aux.h"

GLuint base;

void makeRasterFont(void)
{
    XFontStruct *fontInfo;
    Font id;
    unsigned int first, last;
    Display *xdisplay;

    xdisplay = auxIdentifyXDisplay ();
    fontInfo = XLoadQueryFont(xdisplay, 
             "-adobe-helvetica-medium-r-normal--17-120-100-100-p-88-iso8859-1");
    if (fontInfo == NULL) {
        printf ("no font found\n");
        exit (0);
    }

    id = fontInfo->fid;
    first = fontInfo->min_char_or_byte2;
    last = fontInfo->max_char_or_byte2;

    base = glGenLists(last+1);
    if (base == 0) {
        printf ("out of display lists\n");
    exit (0);
    }
    glXUseXFont(id, first, last-first+1, base+first);
}

void printString(char *s)
{
    glPushAttrib (GL_LIST_BIT);
    glListBase(base);
    glCallLists(strlen(s), GL_UNSIGNED_BYTE, 
                (unsigned char *)s);
    glPopAttrib ();
}

void display(void)
{
    GLfloat white[3] = { 1.0, 1.0, 1.0 };
    long i, j;
    char teststring[33];

    glClear(GL_COLOR_BUFFER_BIT);
    glColor3fv(white);
    for (i = 32; i < 127; i += 32) {
        glRasterPos2i(20, 200 - 18*i/32);
        for (j = 0; j < 32; j++)
            teststring[j] = i+j;
        teststring[32] = 0;
        printString(teststring);
    }
    glRasterPos2i(20, 100);
    printString("The quick brown fox jumps");
    glRasterPos2i(20, 82);
    printString("over a lazy dog.");
    glFlush ();
}LBL="" HELPID=""ID="47893"Porting to Mixed-Model Using Xt and a Widget SetID="05.mixed32"The addition of direct control over X features makes mixed-model programs more complex than pure GL programs. In general, you can bypass many of the complexities of X and of mixed-model programming by using the Xt toolkit and a widget set such as IRIS IM. When mixing the GL with Xt, IRIS IM, or Athena widgets, you can use the Silicon Graphics mixed-model GLwDrawingArea widget, which simplifies mixed-model programming with IRIS IM or any other widget set. The GLwDrawingArea widget is also compatible with User Interface Language (UIL). This section explains how to use the GLwMDrawingArea widget for embedding GL in an Xt or IRIS IM program.ID="05.mixed33"ID="05.mixed34"ID="05.mixed35"LBL="" HELPID=""What You Need to Know About Xt and IRIS IMID="05.mixed36"ID="05.mixed37"ID="05.mixed38"ID="05.mixed39"The examples shown in this chapter use Xt and IRIS IM. Although knowledge of Xt and IRIS IM is not required to read this chapter, understanding the details of the examples does require some Xt and IRIS IM knowledge. This chapter points out areas of the Xt and IRIS IM toolkits that are of special interest to mixed-model programmersname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'it does not provide a tutorial on Xt and IRIS IM. For more information on the relevant features of Xt and IRIS IM, consult the OSF/Motif series, and Digital's X Window System Toolkit: The Complete Programmer's Guide and Specification, or O'Reilly's Vols. 4 & 5 on the X Toolkit Intrinsics.LBL="" HELPID=""What is Xt?Xt, also known as the X Toolkit Intrinsics, is a C library that provides routines for creating and using user interface componentsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'widgets. It's much easier to convert your IRIS GL program to mixed-model using Xt than it is to use the low-level programming library Xlib.ID="05.mixed40"Since Xt doesn't dictate the "look and feel" of the GUI, you must use it in conjunction with a widget set (a library of pre-built widgets), such as the Athena widget set or IRIS IM.ID="05.mixed41"LBL="" HELPID=""What Is IRIS IM?ID="05.mixed42"IRIS IM is Silicon Graphics' port of OSF/Motif. Motif is an extensible widget set of user interface objects, such as buttons, scroll bars, menu systems, and dialog boxes. These widgets are accessible via a library of C routines. These widgets are supported by the Xt. Ultimately, the X Window System is the foundation for both the Motif and Athena widget sets.Motif is also a style guide, which describes the "look and feel" of a Motif-compliant user interface. LBL="" HELPID=""You Don't Have to Use IRIS IMID="05.mixed43"ID="05.mixed44"ID="05.mixed45"This section refers frequently to IRIS IM because it is commonly used in mixed-model programs; however, unless otherwise specified, you can use the features discussed here with other widget sets, such as the Athena widget set, because the features discussed in this chapter exist either within the widget itself or are based on the X toolkit. If you do use IRIS IM, you should use GLwMDrawingArea, the IRIS IM version of the GLwDrawingArea widget.LBL="" HELPID=""About the GLwDrawingArea WidgetCombining OpenGL and Motif is made easier by a specially supplied OpenGL drawing area widget, GLwDrawingArea. Use the GLwDrawingArea widget when creating a mixed-model program using Xt. The GLwDrawingArea widget is similar to a normal widget, but it sets up a configuration for GL drawing, as well as providing resources and callbacks that are useful to the GL programmer. The GLwDrawingArea widget also provides support for overlays. ID="05.mixed46"There are actually two GLwDrawingArea widgets. The widget known as GLwDrawingArea is a generic widget, suitable with any widget set that is based on the Xt intrinsics. There is also a version known as GLwMDrawingArea (note the M) for use with IRIS IM programs.ID="05.mixed47"ID="05.mixed48"The two widgets are very similar, but they do have these differences:ID="05.mixed49"ID="05.mixed50"GLwMDrawingArea is a subclass of the IRIS IM XmPrimitive widget, rather than being a subclass of the Xt Core widget and, therefore, has various defaults such as background color.GLwMDrawingArea understands IRIS IM traversal, although traversal is turned off by default. ID="05.mixed51"ID="05.mixed52"ID="05.mixed53"GLwMDrawingArea has an IRIS IM style creation function, ID="05.mixed54"GlxCreateMDrawingArea(), in addition to allowing creation of the widget directly through Xt.ID="05.mixed55"In all other respects, the two widgets are identical. The remainder of this chapter refers to the GlxMDraw widget, but unless otherwise specified, everything stated refers to both.LBL="" HELPID=""What You Need to Replace with XYou need to replace any GL code that handled anything controlled by the X Window Systemname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'this will mainly include your windowing and event handling code. One way to do this is to run toogl and then search through the output for the toogl warnings, which it marks "OGLXXX." It should be reasonably straightforward to determine which warnings relate to X.LBL="" HELPID=""Using the OpenGL WidgetID="05.mixed56"ID="05.mixed57"This section shows a simple example of a program that uses the IRIS IM version of the OpenGL widget and explains how the code worksname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the generic version of the widget can be used in the same way. To compile this example, use this command line:% cc -O -o mixed mixed.c -lXm -lGL -lGLw -lGLUWhen the OpenGL widget is initially opened, its visual must be set. In other words, you must first declare the display mode of the visual: single or double buffer, color index or RGBA mode. You may also specify how many bits will be used by the components of the frame buffer: for example, depth, stencil, and accumulation bits.In the program below, the function init_window(), which is registered with the GlxNginitCallback callback, calls ID="05.mixed58"glXCreateContext() to set the visual of the OpenGL widget. In this case, the resources for the widget are set to support RGBA and double buffer mode. (See the fallback_resources[] array in the main() procedure.)/* mixed.c
 */

#include <Xm/Xm.h>
#include <Xm/Form.h>
#include <X11/keysym.h>
#include <X11/StringDefs.h>
#include "GL/GLwMDrawA.h"

#include <GL/gl.h>
#include <GL/glu.h>
#include <stdio.h>
#include <stdlib.h>

static void input(Widget, XtPointer, XtPointer);
static void draw_scene_callback (Widget, XtPointer,
                                 XtPointer);
static void do_resize(Widget, XtPointer, XtPointer);
static void init_window(Widget, XtPointer, XtPointer);

static GLXContext glx_context;

void main(int argc, char** argv)
{
    Arg args[20];
    int n;
    Widget glw, toplevel, form;
    static XtAppContext app_context;
    static String fallback_resources[] = {
        "*glwidget*width: 300",
        "*glwidget*height: 300",
        "*glwidget*rgba: TRUE",
        "*glwidget*doublebuffer: TRUE",
        "*glwidget*allocateBackground: TRUE",
        NULL
    };

    toplevel = XtAppInitialize(&app_context, "Mixed", NULL,
                               0, &argc, argv,
                               fallback_resources, NULL, 0);
    n = 0;
    form = XmCreateForm(toplevel, "form", args, n);
    XtManageChild(form);

    n = 0;
    XtSetArg(args[n], XmNbottomAttachment, XmATTACH_FORM);
    n++;
    XtSetArg(args[n], XmNtopAttachment, XmATTACH_FORM);
    n++;
    XtSetArg(args[n], XmNleftAttachment, XmATTACH_FORM);
    n++;
    XtSetArg(args[n], XmNrightAttachment, XmATTACH_FORM);
    n++;
    glw = GLwCreateMDrawingArea(form, "glwidget", args, n);
    XtManageChild (glw);
    XtAddCallback(glw, GLwNexposeCallback,
                  draw_scene_callback, (XtPointer) NULL);
    XtAddCallback(glw, GLwNresizeCallback, do_resize,
                  (XtPointer) NULL);
    XtAddCallback(glw, GLwNginitCallback, init_window,
                  (XtPointer) NULL);
    XtAddCallback(glw, GLwNinputCallback, input,
                  (XtPointer) NULL);

    XtRealizeWidget(toplevel);
    XtAppMainLoop(app_context);
}

static int rotation = 0;

void spin (void)
{
    rotation = (rotation + 5) % 360;
}

static void draw_scene (Widget w)
{
    GLUquadricObj *quadObj;

    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f (1.0, 1.0, 1.0);
    glPushMatrix();
    glTranslatef (0.0, 0.0, -5.0);
    glRotatef ((GLfloat) rotation, 1.0, 0.0, 0.0);

    glPushMatrix ();
    glRotatef (90.0, 1.0, 0.0, 0.0);
    glTranslatef (0.0, 0.0, -1.0);
    quadObj = gluNewQuadric ();
    gluQuadricDrawStyle (quadObj, GLU_LINE);
    gluCylinder (quadObj, 1.0, 1.0, 2.0, 12, 2);
    glPopMatrix ();

    glPopMatrix();
    glFlush();
    glXSwapBuffers (XtDisplay(w), XtWindow(w));
}

/* Process all Input callbacks*/
static void input(Widget w, XtPointer client_data,
                  XtPointer call)
{
    char buffer[1];
    KeySym keysym;
    GLwDrawingAreaCallbackStruct *call_data;

    call_data = (GLwDrawingAreaCallbackStruct *) call;

    switch(call_data->event->type)
    {
    case KeyRelease:
         /* It is necessary to convert the keycode to a
          * keysym before it is possible to check if it is
          * an escape.
          */
         if (XLookupString( (XKeyEvent *) call_data->event,
                            buffer, 1, &keysym,
                            (XComposeStatus *) NULL ) == 1
             && keysym == (KeySym) XK_Escape)
             exit(0);
    break;

    case ButtonPress:
        switch (call_data->event->xbutton.button)
        {
        case Button1:
            spin();
            draw_scene(w);
        break;
        }
    break;

    default:
    break;
    }
}

static void draw_scene_callback(Widget w, XtPointer client_data, XtPointer call)
{
    static char firstTime = 0x1;
    GLwDrawingAreaCallbackStruct *call_data;

    call_data = (GLwDrawingAreaCallbackStruct *) call;
    GLwDrawingAreaMakeCurrent(w, glx_context);

    if (firstTime) {
        glViewport(0, 0, call_data->width,call_data->height);
        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        gluPerspective(65.0, (float) call_data->width /
                       (float)call_data->height, 1.0, 20.0);
        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();
        firstTime = 0;
    }
    draw_scene (w);
}

static void do_resize(Widget w, XtPointer client_data,
                      XtPointer call)
{
    GLwDrawingAreaCallbackStruct *call_data;

    call_data = (GLwDrawingAreaCallbackStruct *) call;

    GLwDrawingAreaMakeCurrent(w, glx_context);
    glViewport(0, 0, call_data->width, call_data->height);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(65.0, (GLfloat) call_data->width /
                   (GLfloat)call_data->height, 1.0, 20.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

static void init_window(Widget w, XtPointer client_data,
                        XtPointer call_data)
{
    Arg args[1];
    XVisualInfo *vi;
    GLUquadricObj *quadObj;

    XtSetArg(args[0], GLwNvisualInfo, &vi);
    XtGetValues(w, args, 1);
    glx_context = glXCreateContext(XtDisplay(w), vi, 0,
                                   GL_FALSE);
}It is a good idea to always call ID="05.mixed59"GlxDrawingAreaMakeCurrent() to set the current widget. In the previous program, ID="05.mixed60"GlxDrawingAreaMakeCurrent() is called from the callback functions.In the program example shown above, a wire frame cylinder is drawn using OpenGL. The GlxNinputCallback calls ID="05.mixed61"input(), which handles mouse and keyboard input. Pressing the escape key causes the program to exit. Pressing Button1 (usually the left mouse button) calls spin(), which changes the rotation of the cylinder. Then the scene is completely redrawn. The mixed.c program has absolutely basic placement of widgets. The OpenGL drawing area widget is attached to all sides of its parent, an IRIS IM XmForm widget. This is a minimal arrangementname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'you can add additional IRIS IM widgets for a more sophisticated interface.ID="05.mixed62"You might also want to add a WorkProc (or idle) function, which executes when no other events are occurring. A WorkProc is useful for rendering continuous motion, which does not require steady input events. ID="05.mixed63"IDREF="77823" TYPE="TITLE"Appendix E, "Example Mixed-Model Program with WorkProc," contains an example mixed-model program using Xt and WorkProc.LBL="" HELPID=""Other Information Sources for Mixed-Model ProgrammingFor more information on mixed-model programming in general, you can refer to the ID="05.mixed64"OpenGL Reference Manual, which contains reference pages for the OpenGL GLX command, as well as an introductory reference page, glXIntro.For more detailed information on programming with Xt, refer to Volume IV of the X Window System Series, "X Toolkit Intrinsics Programming Manual," by Adrian Nye and Tim O'Reilly, published by O'Reilly & Associates, Inc. (If you're also using IRIS IM, you'll probably want the Motif version of Volume IV.)For more information on IRIS IM, refer to documentation on Motif, such as the OSF/Motif Series published by Prentice Hall.ID="05.mixed65"LBL="" HELPID=""ID="34451"Mixed-Model Programming Using Xlib and OpenGL GLX CommandsID="05.mixed66"This method of mixed-model programming is more difficult than using Xt and a widget set, and Silicon Graphics doesn't recommend it unless you're already familiar with Xlib programming. This section provides an overview of the necessary steps for mixed-model programming using Xlib and GLX. It also provides some simple code examples.You'll almost certainly need to refer to more substantial Xlib documentation (such as the O'Reilly volumes), as well as the OpenGL Reference Manual. The glXIntro reference page is a good starting point.In brief, to port your OpenGL code to a mixed-model program using Xlib and GLX calls, follow these steps:Add the necessary include files to your program. (See IDREF="21136" TYPE="TITLE""Header Files" for information on what files to include.)Open a connection to a display: ID="05.mixed67"XOpenDisplay().Choose an X visual: ID="05.mixed68"glXChooseVisual().Create a GLX context: ID="05.mixed69"glXCreateContext().Create an X window or pixmap: ID="05.mixed70"XCreateWindow().Connect the GLX context to the X window: ID="05.mixed71"glXMakeCurrent().LBL="" HELPID=""Code Example: Opening a Window with OpenGL GLXThe following example is a simple way of following those steps.You can find a version of this code in the glXIntro reference page. This sample is more heavily commented and contains some additional examples:ID="05.mixed72"#include <X11/Xlib.h>
#include <GL/glx.h>
#include <GL/gl.h>
#include <stdio.h>

static int attributeList[] = { GLX_RGBA, None };

static Bool WaitForNotify(Display *d, XEvent *e, char *arg)
    { return(e->type == MapNotify) && (e->xmap.window == (Window)arg); }

int main(int argc, char**argv)
{
    Display *dpy;
    XVisualInfo *vi;
    Colormap cmap;
    XSetWindowAttributes swa;
    Window win;
    GLXContext cx;
    XEvent event;

/* get a connection   */
    dpy   = XOpenDisplay(0);
    if (!dpy) {
        fprintf(stderr, "Cannot open display.\n");
        exit(-1);
    }

/* get an appropriate visual */
    vi = glXChooseVisual(dpy, DefaultScreen(dpy),
         attributeList);
    if (!vi) {
        fprintf(stderr, "Cannot find visual with desired attributes.\n");
        exit(-1);
    }

/* create a GLX context */
    cx = glXCreateContext(dpy, vi, 0, GL_FALSE);
    if (!cx) {
        fprintf(stderr, "Cannot create context.\n");
        exit(-1);
    }

/* create a colormap -- AllocAll for color index mode */
    cmap = XCreateColormap(dpy, RootWindow(dpy, vi->screen),
           vi->visual, AllocNone);
    if (!cmap) {
        fprintf(stderr, "Cannot allocate colormap.\n");
        exit(-1);
    }

    /* create a   window */
    swa.colormap = cmap;
    swa.border_pixel = 0;
    /* connect the context to the window */
    glXMakeCurrent(dpy, win, cx);

/* clear the buffer */
    glClearColor(1,1,0,1);
    glClear(GL_COLOR_BUFFER_BIT);
    glFlush();

/wait for a while */
    sleep(10);
/* exit cleanly */
    XCloseDisplay(dpy);
    exit(0);
}LBL="" HELPID=""ID="23967"X Color MapsID="05.mixed73"Here's a brief example of OpenGL GLX code that demonstrates the use of color maps:XColor xc;

display = XOpenDisplay(0);

visual = glXChooseVisual(display,     

    DefaultScreen(display), attributeList);

context = glXCreateContext (display,visual,0,GL_FALSE);

colorMap = XCreateColormap (display,RootWindow(display, 

    visual->screen), visual->visual, AllocAll);

/* Note: if you don't say AllocAll, you can't load */
/* the color maps! */
    ...

if (index < visual->colormap_size) {

    xc.pixel = index;

    xc.red = (unsigned short)(red * 65535.0 + 0.5);

    xc.green = (unsigned short)(green * 65535.0 + 0.5);

    xc.blue = (unsigned short)(blue * 65535.0 + 0.5);

    xc.flags = DoRed | DoGreen | DoBlue;

    XStoreColor (display, colorMap, &xc);

}
LBL="" HELPID=""A Sample X Event LoopID="05.mixed74"Here's a simple example of a mixed-model program that uses Xlib and OpenGL GLX calls for event handling:swa.event_mask = ExposureMask | StructureNotifyMask 
                 | KeyPressMask | KeyReleaseMask;
do {
    XNextEvent(dpy, &event);
    switch (event.type) {
        case Expose:
            doRedraw = GL_TRUE;
            break;
        case ConfigureNotify:
            width = event.xconfigure.width;
            height = event.xconfigure.height;
            doRedraw = GL_TRUE;
            break;
        case KeyPress:
        {
            char buf[100];
            int rv;
            KeySym ks;

            rv = XLookupString(&event.xkey, buf, sizeof(buf), &ks, 0);
            switch (ks) {
                case XK_s:
                case XK_S:
                    doSave = GL_TRUE;
                    break;
                case XK_Escape:
                    return 0;
                    break;
            }
        }
    }
} while (XPending(dpy));LBL="A"ID="39727"OpenGL Commands and Their IRIS GL EquivalentsIDREF="56942" TYPE="TABLE"Table A-1 contains a list of equivalent calls that you might find useful while porting. The first column is an alphabetical list of IRIS GL calls, the second column contains the corresponding calls to use with OpenGL, and the third column contains pointers to any relevant discussion in the text.NoteIn many cases the OpenGL commands listed will function somewhat differently from the IRIS GL commands, and the parameters may be different as well.Be sure to refer to the OpenGL reference pages in the OpenGL Reference Manual for detailed descriptions of the functions of the these commands and the parameters they take.You might also need to refer to X or IRIS IM documentation; some appropriate X and IRIS IM manuals are listed in the introductory section of this guideIDREF="37200" TYPE="TITLE", "About This Guide."COLUMNS="3"LBL="A-1"Table A-1 ID="56942"IRIS GL Commands and Their OpenGL EquivalentsLEFT="0" WIDTH="90"IRIS GL CallLEFT="95" WIDTH="135"OpenGL/glu/glX/aux EquivalentLEFT="235" WIDTH="108"Where DiscussedLEFT="0" WIDTH="90"acbuf()LEFT="95" WIDTH="135"glAccum()LEFT="235" WIDTH="108"IDREF="19353" TYPE="TITLE""Accumulation Buffer 
Calls"LEFT="0" WIDTH="90"acsize()LEFT="95" WIDTH="135"glXChooseVisual()LEFT="235" WIDTH="108"IDREF="19353" TYPE="TITLE""Accumulation Buffer 
Calls"LEFT="0" WIDTH="90"addtopup()LEFT="95" WIDTH="135"use X or IRIS IM for menusLEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5, glXIntro 
reference page, 
X documentation, 
IRIS IM documentationLEFT="0" WIDTH="90"afunction()LEFT="95" WIDTH="135"glAlphaFunc()LEFT="235" WIDTH="108"IDREF="93903" TYPE="TITLE""afunction() Test 
Functions"LEFT="0" WIDTH="90"arc(), arcf()LEFT="95" WIDTH="135"gluPartialDisk()IDREF="A.equivsTF0a"aLEFT="235" WIDTH="108"IDREF="84596" TYPE="TITLE""Editing toogl Output: 
An Example" 
and IDREF="44954" TYPE="TITLE""Arcs and Circles"LEFT="0" WIDTH="90"backbuffer()LEFT="95" WIDTH="135"glDrawBuffer(GL_BACK)LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"backface()LEFT="95" WIDTH="135"glCullFace(GL_BACK)LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"bbox2()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="14029" TYPE="TITLE""Porting bbox2() Calls"LEFT="0" WIDTH="90"bgnclosedline()LEFT="95" WIDTH="135"glBegin(GL_LINE_LOOP)LEFT="235" WIDTH="108"IDREF="49018" TYPE="TITLE""bgn/end Commands" and IDREF="68126" TYPE="TITLE""Lines"LEFT="0" WIDTH="90"bgncurve()LEFT="95" WIDTH="135"gluBeginCurve()LEFT="235" WIDTH="108"IDREF="41356" TYPE="TITLE""NURBS Curves"LEFT="0" WIDTH="90"bgnline()LEFT="95" WIDTH="135"glBegin(GL_LINE_STRIP)LEFT="235" WIDTH="108"IDREF="49018" TYPE="TITLE""bgn/end Commands" and IDREF="68126" TYPE="TITLE""Lines"LEFT="0" WIDTH="90"bgnpoint()LEFT="95" WIDTH="135"glBegin(GL_POINTS)LEFT="235" WIDTH="108"IDREF="49018" TYPE="TITLE""bgn/end Commands" and IDREF="89248" TYPE="TITLE""Points"LEFT="0" WIDTH="90"bgnpolygon()LEFT="95" WIDTH="135"glBegin(GL_POLYGON)LEFT="235" WIDTH="108"IDREF="49018" TYPE="TITLE""bgn/end Commands", IDREF="83655" TYPE="TITLE""Polygons 
and Quadrilaterals" and IDREF="26633" TYPE="TITLE""Tessellated 
Polygons"LEFT="0" WIDTH="90"bgnqstrip()LEFT="95" WIDTH="135"glBegin(GL_QUAD_STRIP)LEFT="235" WIDTH="108"IDREF="49018" TYPE="TITLE""bgn/end Commands" and 
IDREF="83655" TYPE="TITLE""Polygons and 
Quadrilaterals"LEFT="0" WIDTH="90"bgnsurface()LEFT="95" WIDTH="135"gluBeginSurface()LEFT="235" WIDTH="108"IDREF="12666" TYPE="TITLE""NURBS Surfaces"LEFT="0" WIDTH="90"bgntmesh()LEFT="95" WIDTH="135"glBegin( 
GL_TRIANGLE_STRIP)LEFT="235" WIDTH="108"IDREF="49018" TYPE="TITLE""bgn/end Commands" and 
IDREF="65584" TYPE="TITLE""Triangles"LEFT="0" WIDTH="90"bgntrim()LEFT="95" WIDTH="135"gluBeginTrim()LEFT="235" WIDTH="108"IDREF="88446" TYPE="TITLE""Trimming Curves"LEFT="0" WIDTH="90"blankscreen()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"blanktime()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"blendcolor()LEFT="95" WIDTH="135"glBlendColorEXT()LEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"blendfunction()LEFT="95" WIDTH="135"glBlendFunc()LEFT="235" WIDTH="108"IDREF="87998" TYPE="TITLE""Blending"LEFT="0" WIDTH="90"blink()LEFT="95" WIDTH="135"use auxiliary library or X for 
color mapsLEFT="235" WIDTH="108"IDREF="54935" TYPE="TITLE""Using Color-Index 
Mode" or 
IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"blkqread()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="108"IDREF="43633" TYPE="TITLE""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" or IDREF="37274" TYPE="TITLE"Chapter 5 and 
glXIntro reference pageLEFT="0" WIDTH="90"c3*(), c4*()LEFT="95" WIDTH="135"glColor*()LEFT="235" WIDTH="108"IDREF="31702" TYPE="TITLE""Porting Color, Shading, 
and Writemask 
Commands"LEFT="0" WIDTH="90"callfunc()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="58056" TYPE="TITLE""Porting Display Lists"LEFT="0" WIDTH="90"callobj() LEFT="95" WIDTH="135"glCallList()LEFT="235" WIDTH="108"IDREF="49018" TYPE="TITLE""bgn/end Commands" and IDREF="58056" TYPE="TITLE""Porting 
Display Lists"LEFT="0" WIDTH="90"charstr()LEFT="95" WIDTH="135"glCallLists()aLEFT="235" WIDTH="108"IDREF="89603" TYPE="TITLE""Fonts and Strings"LEFT="0" WIDTH="90"chunksize()LEFT="95" WIDTH="135"not neededLEFT="235" WIDTH="108"IDREF="58056" TYPE="TITLE""Porting Display Lists"LEFT="0" WIDTH="90"circ(), circf()LEFT="95" WIDTH="135"gluDisk()LEFT="235" WIDTH="108"IDREF="44954" TYPE="TITLE""Arcs and Circles"LEFT="0" WIDTH="90"clear()LEFT="95" WIDTH="135"glClear( 
GL_COLOR_BUFFER_BIT)LEFT="235" WIDTH="108"IDREF="34561" TYPE="TITLE""Windowing, Device, and 
Event Calls" 
and IDREF="28727" TYPE="TITLE""Porting Screen and 
Buffer Clearing 
Commands"LEFT="0" WIDTH="90"clearhitcode()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="20349" TYPE="TITLE""Porting Picking Calls"LEFT="0" WIDTH="90"clipplane() LEFT="95" WIDTH="135"glClipPlane()LEFT="235" WIDTH="108"IDREF="26684" TYPE="TITLE""Clipping Planes"LEFT="0" WIDTH="90"clkon()LEFT="95" WIDTH="135"XChangeKeyboardControl()LEFT="235" WIDTH="108"see X documentationLEFT="0" WIDTH="90"clkoff()LEFT="95" WIDTH="135"XChangeKeyboardControl()LEFT="235" WIDTH="108"see X documentationLEFT="0" WIDTH="90"closeobj()LEFT="95" WIDTH="135"glEndList()LEFT="235" WIDTH="108"IDREF="58056" TYPE="TITLE""Porting Display Lists"LEFT="0" WIDTH="90"cmode()LEFT="95" WIDTH="135"auxInitDisplayMode() or 
glXChooseVisual()LEFT="235" WIDTH="108"IDREF="54935" TYPE="TITLE""Using Color-Index 
Mode" or 
IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
and glXChooseVisual() 
reference pagesLEFT="0" WIDTH="90"cmov(),cmov2()LEFT="95" WIDTH="135"glRasterPos3()a,glRasterPos2()aLEFT="235" WIDTH="108"IDREF="92008" TYPE="TITLE""Porting Pixel 
Operations"LEFT="0" WIDTH="90"color(), colorf()LEFT="95" WIDTH="135"glIndex*()LEFT="235" WIDTH="108"IDREF="49018" TYPE="TITLE""bgn/end Commands" and IDREF="31702" TYPE="TITLE""Porting 
Color, Shading, and 
Writemask Commands"LEFT="0" WIDTH="90"compactify()LEFT="95" WIDTH="135"not neededLEFT="235" WIDTH="108"IDREF="31702" TYPE="TITLE""Porting Color, Shading, 
and Writemask 
Commands"LEFT="0" WIDTH="90"concave()LEFT="95" WIDTH="135"gluBeginPolygon()aLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"convolve()LEFT="95" WIDTH="135"glConvolutionFilter2DEXT(), 
glSeparableFilter2DEXT(), 
glConvolutionParameterEXT(), 
glPixelTransfer()LEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"cpack()LEFT="95" WIDTH="135"glColor*()aLEFT="235" WIDTH="108"IDREF="49018" TYPE="TITLE""bgn/end Commands" and IDREF="31702" TYPE="TITLE""Porting 
Color, Shading, and 
Writemask Commands"LEFT="0" WIDTH="90"crv()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="41945" TYPE="TITLE""Porting Curve and 
Surface Commands"LEFT="0" WIDTH="90"crvn()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="41945" TYPE="TITLE""Porting Curve and 
Surface Commands"LEFT="0" WIDTH="90"curorigin()LEFT="95" WIDTH="135"use X for cursorsLEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5, glXIntro 
reference page, 
X documentationLEFT="0" WIDTH="90"cursoff()LEFT="95" WIDTH="135"use X for cursorsLEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5, glXIntro 
reference page, 
X documentationLEFT="0" WIDTH="90"curson()LEFT="95" WIDTH="135"use X for cursorsLEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5, glXIntro 
reference page, 
X documentationLEFT="0" WIDTH="90"curstype()LEFT="95" WIDTH="135"use X for cursorsLEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5, glXIntro 
reference page, 
X documentationLEFT="0" WIDTH="90"curvebasis()LEFT="95" WIDTH="135"glMap1()LEFT="235" WIDTH="108"IDREF="41945" TYPE="TITLE""Porting Curve and 
Surface Commands"LEFT="0" WIDTH="90"curveit()LEFT="95" WIDTH="135"glEvalMesh1()LEFT="235" WIDTH="108"IDREF="41945" TYPE="TITLE""Porting Curve and 
Surface Commands"LEFT="0" WIDTH="90"curveprecision()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="41945" TYPE="TITLE""Porting Curve and 
Surface Commands"LEFT="0" WIDTH="90"cyclemap()LEFT="95" WIDTH="135"use auxiliary library or X for 
color mapsLEFT="235" WIDTH="108"IDREF="54935" TYPE="TITLE""Using Color-Index 
Mode" or 
IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"czclear()LEFT="95" WIDTH="135"glClear( 
GL_COLOR_BUFFER_BIT | 
GL_DEPTH_BUFFER_BIT)LEFT="235" WIDTH="108"IDREF="28727" TYPE="TITLE""Porting Screen and 
Buffer Clearing 
Commands"LEFT="0" WIDTH="90"dbtext()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"Dial and Button Box 
documentationLEFT="0" WIDTH="90"defbasis()LEFT="95" WIDTH="135"glMap1()LEFT="235" WIDTH="108"IDREF="41945" TYPE="TITLE""Porting Curve and 
Surface Commands"LEFT="0" WIDTH="90"defcursor()LEFT="95" WIDTH="135"use X for cursorsLEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5, glXIntro 
reference page, 
X documentationLEFT="0" WIDTH="90"deflinestyle()LEFT="95" WIDTH="135"glLineStipple()LEFT="235" WIDTH="108"IDREF="68126" TYPE="TITLE""Lines" and 
IDREF="21145" TYPE="TITLE""Porting defs, binds, and 
sets: Replacing `Tables' of 
Stored Definitions"LEFT="0" WIDTH="90"defpattern() LEFT="95" WIDTH="135"glPolygonStipple()LEFT="235" WIDTH="108"IDREF="83655" TYPE="TITLE""Polygons and 
Quadrilaterals" and IDREF="21145" TYPE="TITLE""Porting 
defs, binds, and sets: 
Replacing `Tables' of 
Stored Definitions"LEFT="0" WIDTH="90"defpup()LEFT="95" WIDTH="135"use X for menusLEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5, glXIntro 
reference page, 
X documentationLEFT="0" WIDTH="90"defrasterfont() LEFT="95" WIDTH="135"glXUseXFont()aLEFT="235" WIDTH="108"IDREF="89603" TYPE="TITLE""Fonts and Strings"LEFT="0" WIDTH="90"delobj() LEFT="95" WIDTH="135"glDeleteLists()LEFT="235" WIDTH="108"IDREF="58056" TYPE="TITLE""Porting Display Lists"LEFT="0" WIDTH="90"deltag()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="58056" TYPE="TITLE""Porting Display Lists"LEFT="0" WIDTH="90"depthcue()LEFT="95" WIDTH="135"glFog()aLEFT="235" WIDTH="108"IDREF="77276" TYPE="TITLE""Porting Depth Cueing 
and Fog Commands"LEFT="0" WIDTH="90"dglclose()LEFT="95" WIDTH="135"not neededname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'OpenGL is 
network transparentLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"dglopen()LEFT="95" WIDTH="135"not neededname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'OpenGL is 
network transparentLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"displacepolygon()LEFT="95" WIDTH="135"glPolygonOffsetEXT()LEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"dither()LEFT="95" WIDTH="135"glEnable(GL_DITHER)LEFT="235" WIDTH="108"IDREF="31702" TYPE="TITLE""Porting Color, Shading, 
and Writemask 
Commands"LEFT="0" WIDTH="90"dopup()LEFT="95" WIDTH="135"use X for menusLEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5, glXIntro 
reference page, 
X documentationLEFT="0" WIDTH="90"doublebuffer()LEFT="95" WIDTH="135"auxInitDisplayMode() or 
glXChooseVisual()LEFT="235" WIDTH="108"IDREF="64084" TYPE="TITLE""Porting Display Mode 
Initialization Calls with 
auxInitDisplayMode()" or IDREF="37274" TYPE="TITLE"Chapter 5 
and glXIntro reference 
pageLEFT="0" WIDTH="90"draw()LEFT="95" WIDTH="135"glBegin(GL_LINES)aLEFT="235" WIDTH="108"IDREF="67471" TYPE="TITLE""Porting Commands that 
Required Current 
Graphics Position" and IDREF="68126" TYPE="TITLE""Lines"LEFT="0" WIDTH="90"drawmode()LEFT="95" WIDTH="135"glXMakeCurrent()aLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"editobj()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="58056" TYPE="TITLE""Porting Display Lists"LEFT="0" WIDTH="90"endclosedline()LEFT="95" WIDTH="135"glEnd()LEFT="235" WIDTH="108"IDREF="49018" TYPE="TITLE""bgn/end Commands" and IDREF="68126" TYPE="TITLE""Lines"LEFT="0" WIDTH="90"endcurve()LEFT="95" WIDTH="135"gluEndCurve()LEFT="235" WIDTH="108"IDREF="41945" TYPE="TITLE""Porting Curve and 
Surface Commands"LEFT="0" WIDTH="90"endfeedback()LEFT="95" WIDTH="135"glRenderMode(GL_RENDER)LEFT="235" WIDTH="108"IDREF="43211" TYPE="TITLE""Porting Feedback Calls"LEFT="0" WIDTH="90"endfullscreen()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"endline()LEFT="95" WIDTH="135"glEnd()LEFT="235" WIDTH="108"IDREF="49018" TYPE="TITLE""bgn/end Commands"LEFT="0" WIDTH="90"endpick()LEFT="95" WIDTH="135"glRenderMode(GL_RENDER)LEFT="235" WIDTH="108"IDREF="20349" TYPE="TITLE""Porting Picking Calls"LEFT="0" WIDTH="90"endpoint()LEFT="95" WIDTH="135"glEnd()LEFT="235" WIDTH="108"IDREF="49018" TYPE="TITLE""bgn/end Commands" and IDREF="89248" TYPE="TITLE""Points"LEFT="0" WIDTH="90"endpolygon()LEFT="95" WIDTH="135"glEnd()LEFT="235" WIDTH="108"IDREF="49018" TYPE="TITLE""bgn/end Commands" and 
IDREF="83655" TYPE="TITLE""Polygons and 
Quadrilaterals"LEFT="0" WIDTH="90"endpupmode()LEFT="95" WIDTH="135"use X for menusLEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5, glXIntro 
reference page, 
X documentationLEFT="0" WIDTH="90"endqstrip()LEFT="95" WIDTH="135"glEnd()LEFT="235" WIDTH="108"IDREF="49018" TYPE="TITLE""bgn/end Commands" and 
IDREF="83655" TYPE="TITLE""Polygons and 
Quadrilaterals"LEFT="0" WIDTH="90"endselect()LEFT="95" WIDTH="135"glRenderMode(GL_RENDER)LEFT="235" WIDTH="108"IDREF="20349" TYPE="TITLE""Porting Picking Calls"LEFT="0" WIDTH="90"endsurface()LEFT="95" WIDTH="135"gluEndSurface()LEFT="235" WIDTH="108"IDREF="12666" TYPE="TITLE""NURBS Surfaces"LEFT="0" WIDTH="90"endtmesh()LEFT="95" WIDTH="135"glEnd()LEFT="235" WIDTH="108"IDREF="49018" TYPE="TITLE""bgn/end Commands" and 
IDREF="65584" TYPE="TITLE""Triangles"LEFT="0" WIDTH="90"endtrim()LEFT="95" WIDTH="135"gluEndTrim()LEFT="235" WIDTH="108"IDREF="88446" TYPE="TITLE""Trimming Curves"LEFT="0" WIDTH="90"fbsubtexload()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"feedback()LEFT="95" WIDTH="135"glFeedbackBuffer()LEFT="235" WIDTH="108"IDREF="43211" TYPE="TITLE""Porting Feedback Calls"LEFT="0" WIDTH="90"finish()LEFT="95" WIDTH="135"glFinish()LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"fogvertex() LEFT="95" WIDTH="135"glFog()LEFT="235" WIDTH="108"IDREF="77276" TYPE="TITLE""Porting Depth Cueing 
and Fog Commands"LEFT="0" WIDTH="90"font()LEFT="95" WIDTH="135"see glListBase()LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"foreground()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"freepup()LEFT="95" WIDTH="135"use X for menusLEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5, glXIntro 
reference page, 
X documentationLEFT="0" WIDTH="90"frontbuffer()LEFT="95" WIDTH="135"glDrawBuffer(GL_FRONT)LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"frontface()LEFT="95" WIDTH="135"see glCullFace()LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"fudge()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"fullscrn()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"gammaramp()LEFT="95" WIDTH="135"use auxiliary library or X for 
color mapsLEFT="235" WIDTH="108"IDREF="54935" TYPE="TITLE""Using Color-Index 
Mode" or 
IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"gbegin()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"gconfig()LEFT="95" WIDTH="135"no equivalent (not needed)LEFT="235" WIDTH="108"IDREF="64084" TYPE="TITLE""Porting Display Mode 
Initialization Calls with 
auxInitDisplayMode()" or IDREF="37274" TYPE="TITLE"Chapter 5 
and glXIntro reference 
pageLEFT="0" WIDTH="90"genobj()LEFT="95" WIDTH="135"glGenLists()LEFT="235" WIDTH="108"IDREF="58056" TYPE="TITLE""Porting Display Lists"LEFT="0" WIDTH="90"gentag()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="80759" TYPE="TITLE""Stencil Plane Calls"LEFT="0" WIDTH="90"getbackface()LEFT="95" WIDTH="135"glGet()LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"getbuffer()LEFT="95" WIDTH="135"glGet()LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"getbutton()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands", 
IDREF="43633" TYPE="TITLE""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" or IDREF="37274" TYPE="TITLE"Chapter 5, and 
glXIntro reference pageLEFT="0" WIDTH="90"getcmmode()LEFT="95" WIDTH="135"glXGetCurrentContext()LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands", 
IDREF="37274" TYPE="TITLE"Chapter 5 and IDREF="31702" TYPE="TITLE""Porting 
Color, Shading, and 
Writemask Commands"LEFT="0" WIDTH="90"getcolor()LEFT="95" WIDTH="135"glGet()LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"getcpos()LEFT="95" WIDTH="135"glGet()LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"getcursor()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"getdcm()LEFT="95" WIDTH="135"glIsEnabled()LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands" 
and IDREF="77276" TYPE="TITLE""Porting Depth 
Cueing and Fog 
Commands"LEFT="0" WIDTH="90"getdepth()LEFT="95" WIDTH="135"glGet()LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"getdescender()LEFT="95" WIDTH="135"use X for fontsLEFT="235" WIDTH="108"IDREF="89603" TYPE="TITLE""Fonts and Strings" and IDREF="66224" TYPE="TITLE""Porting 
IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"getdev()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"getdisplaymode()LEFT="95" WIDTH="135"glGet()LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"getdrawmode()LEFT="95" WIDTH="135"glXGetCurrentContext()LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"getfont()LEFT="95" WIDTH="135"use X for fontsLEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands" 
and IDREF="89603" TYPE="TITLE""Fonts and Strings"LEFT="0" WIDTH="90"getgdesc()LEFT="95" WIDTH="135"glGet(),glXGetConfig(),glXGetCurrentContext(),glXGetCurrentDrawable()LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"getgpos() LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="67471" TYPE="TITLE""Porting Commands that 
Required Current 
Graphics Position" and IDREF="66224" TYPE="TITLE""Porting IRIS 
GL `Get' Commands"LEFT="0" WIDTH="90"getheight()LEFT="95" WIDTH="135"use X for fontsLEFT="235" WIDTH="108"IDREF="89603" TYPE="TITLE""Fonts and Strings" and IDREF="66224" TYPE="TITLE""Porting 
IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"gethgram()LEFT="95" WIDTH="135"glGetHistogramEXT()LEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"gethitcode()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="20349" TYPE="TITLE""Porting Picking Calls" and IDREF="66224" TYPE="TITLE""Porting 
IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"getlsbackup()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="68126" TYPE="TITLE""Lines" and 
IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"getlsrepeat()LEFT="95" WIDTH="135"glGet()LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands" 
and IDREF="68126" TYPE="TITLE""Lines"LEFT="0" WIDTH="90"getlstyle()LEFT="95" WIDTH="135"glGet()LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands" 
and IDREF="68126" TYPE="TITLE""Lines"LEFT="0" WIDTH="90"getlwidth()LEFT="95" WIDTH="135"glGet()LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands" 
and IDREF="68126" TYPE="TITLE""Lines"LEFT="0" WIDTH="90"getmap(void)LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands", 
IDREF="37274" TYPE="TITLE"Chapter 5 and IDREF="31702" TYPE="TITLE""Porting 
Color, Shading, and 
Writemask Commands"LEFT="0" WIDTH="90"getmatrix()LEFT="95" WIDTH="135"glGet(GL_MODELVIEW_           MATRIX),glGet(GL_PROJECTION_           MATRIX)LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands" 
and IDREF="91369" TYPE="TITLE""Porting Matrix and 
Transformation Calls"LEFT="0" WIDTH="90"getmcolor()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands", 
IDREF="31702" TYPE="TITLE""Porting Color, Shading, 
and Writemask 
Commands", 
IDREF="54935" TYPE="TITLE""Using Color-Index 
Mode", or 
IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"getminmax()LEFT="95" WIDTH="135"glGetMinmaxEXT()LEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"getmmode()LEFT="95" WIDTH="135"glGet(GL_MATRIX_MODE)LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands" 
and IDREF="91369" TYPE="TITLE""Porting Matrix and 
Transformation Calls"LEFT="0" WIDTH="90"getmonitor()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"getnurbsproperty()LEFT="95" WIDTH="135"gluGetNurbsProperty()LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"getopenobj()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="58056" TYPE="TITLE""Porting Display Lists" and IDREF="66224" TYPE="TITLE""Porting 
IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"getorigin()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands" 
and IDREF="88614" TYPE="TITLE""Windowing", or IDREF="37274" TYPE="TITLE"Chapter 5 and 
glXIntro reference pageLEFT="0" WIDTH="90"getpattern()LEFT="95" WIDTH="135"glGetPolygonStipple()LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands" 
and IDREF="83655" TYPE="TITLE""Polygons and 
Quadrilaterals"LEFT="0" WIDTH="90"getplanes()LEFT="95" WIDTH="135"glGet(GL_RED_BITS),glGet(GL_GREEN_BITS),glGet(GL_BLUE_BITS)LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"getport()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands", 
IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"getresetls()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="68126" TYPE="TITLE""Lines" and 
IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"getscrbox()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands" 
and IDREF="73299" TYPE="TITLE""Viewports, 
Screenmasks, and 
Scrboxes"LEFT="0" WIDTH="90"getscrmask() LEFT="95" WIDTH="135"glGet(GL_SCISSOR_BOX)LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands" 
and IDREF="73299" TYPE="TITLE""Viewports, 
Screenmasks, and 
Scrboxes"LEFT="0" WIDTH="90"getshade()LEFT="95" WIDTH="135" glGet( GL_CURRENT_INDEX)LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"getsize()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands", 
IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"getsm()LEFT="95" WIDTH="135"glGet(GL_SHADE_MODEL)LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands" 
and IDREF="31702" TYPE="TITLE""Porting Color, 
Shading, and Writemask 
Commands"LEFT="0" WIDTH="90"getvaluator()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands", 
IDREF="43633" TYPE="TITLE""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" or IDREF="37274" TYPE="TITLE"Chapter 5 and 
glXIntro reference pageLEFT="0" WIDTH="90"getvideo()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"getviewport()LEFT="95" WIDTH="135"glGet(GL_VIEWPORT)LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands" 
and IDREF="73299" TYPE="TITLE""Viewports, 
Screenmasks, and 
Scrboxes"LEFT="0" WIDTH="90"getwritemask()LEFT="95" WIDTH="135"glGet( 
GL_INDEX_WRITEMASK)LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands" 
and IDREF="31702" TYPE="TITLE""Porting Color, 
Shading, and Writemask 
Commands"LEFT="0" WIDTH="90"getwscrn()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands" 
and IDREF="88614" TYPE="TITLE""Windowing" or IDREF="37274" TYPE="TITLE"Chapter 5 and 
glXIntro reference pageLEFT="0" WIDTH="90"getzbuffer()LEFT="95" WIDTH="135"glIsEnabled( GL_DEPTH_TEST)LEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"gexit()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"gflush()LEFT="95" WIDTH="135"glFlush()LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"ginit()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"glcompat()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"GLXgetconfig()LEFT="95" WIDTH="135"roughly, glXChooseVisual()LEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"GLXlink()LEFT="95" WIDTH="135"combination of 
glXCreateContext() and 
glXMakeCurrent()LEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"GLXunlink()LEFT="95" WIDTH="135"glXMakeCurrent(display_name,
 None, NULL)LEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"GLXwinset()LEFT="95" WIDTH="135"roughly, glXMakeCurrent()LEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"greset()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="62214" TYPE="TITLE""Porting greset()"LEFT="0" WIDTH="90"gRGBcolor()LEFT="95" WIDTH="135"glGet(GL_CURRENT_           RASTER_COLOR)LEFT="235" WIDTH="108"IDREF="31702" TYPE="TITLE""Porting Color, Shading, 
and Writemask 
Commands"LEFT="0" WIDTH="90"gRGBcursor()LEFT="95" WIDTH="135"use X for cursorsLEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5, glXIntro 
reference page, 
X documentationLEFT="0" WIDTH="90"gRGBmask()LEFT="95" WIDTH="135"glGet( 
GL_COLOR_WRITEMASK)LEFT="235" WIDTH="108"IDREF="31702" TYPE="TITLE""Porting Color, Shading, 
and Writemask 
Commands"LEFT="0" WIDTH="90"gselect() LEFT="95" WIDTH="135"glSelectBuffer()LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"gsync()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"gversion()LEFT="95" WIDTH="135"glGetString( GL_RENDERER)aLEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"hgram()LEFT="95" WIDTH="135"glHistogramEXT(), 
glResetHistogramEXT()LEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"iconsize()LEFT="95" WIDTH="135"use X LEFT="235" WIDTH="108"see X documentation for 
XIconSize()LEFT="0" WIDTH="90"icontitle()LEFT="95" WIDTH="135"use XLEFT="235" WIDTH="108"see X documentation for 
XSetIconName()LEFT="0" WIDTH="90"ilbuffer()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"ildraw()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"imakebackground()LEFT="95" WIDTH="135"use the auxiliary library or X for 
event handlingLEFT="235" WIDTH="108"IDREF="43633" TYPE="TITLE""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" or IDREF="37274" TYPE="TITLE"Chapter 5 and 
glXIntro reference pageLEFT="0" WIDTH="90"initnames()LEFT="95" WIDTH="135"glInitNames()LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"ismex()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' 
Commands"LEFT="0" WIDTH="90"isobj()LEFT="95" WIDTH="135"glIsList()LEFT="235" WIDTH="108"IDREF="58056" TYPE="TITLE""Porting Display Lists"LEFT="0" WIDTH="90"isqueued()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="108"IDREF="43633" TYPE="TITLE""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" or IDREF="37274" TYPE="TITLE"Chapter 5 and 
glXIntro reference pageLEFT="0" WIDTH="90"istag()LEFT="95" WIDTH="135"not supported LEFT="235" WIDTH="108"IDREF="80759" TYPE="TITLE""Stencil Plane Calls"LEFT="0" WIDTH="90"istexloaded()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"keepaspect()LEFT="95" WIDTH="135"use the auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"lampoff()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"see X documentation for 
XChangeKeyboardContr
ol()LEFT="0" WIDTH="90"lampon()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"see X documentation for 
XChangeKeyboardContr
ol()LEFT="0" WIDTH="90"leftbuffer()LEFT="95" WIDTH="135"glDrawBuffer(GL_LEFT)LEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"linesmooth()LEFT="95" WIDTH="135"glEnable( GL_LINE_SMOOTH)LEFT="235" WIDTH="108"IDREF="68126" TYPE="TITLE""Lines" and 
IDREF="65073" TYPE="TITLE""Antialiasing Calls"LEFT="0" WIDTH="90"linewidth()LEFT="95" WIDTH="135"glLineWidth()LEFT="235" WIDTH="108"IDREF="68126" TYPE="TITLE""Lines"LEFT="0" WIDTH="90"linewidthf()LEFT="95" WIDTH="135"glLineWidth()LEFT="235" WIDTH="108"IDREF="68126" TYPE="TITLE""Lines"LEFT="0" WIDTH="90"lmbind()LEFT="95" WIDTH="135"glEnable(GL_LIGHTING)glEnable(GL_LIGHTi)LEFT="235" WIDTH="108"IDREF="49018" TYPE="TITLE""bgn/end Commands", IDREF="21145" TYPE="TITLE""Porting defs, 
binds, and sets: Replacing 
`Tables' of Stored 
Definitions", 
and IDREF="20887" TYPE="TITLE""Porting Lighting 
and Materials Calls"LEFT="0" WIDTH="90"lmcolor()LEFT="95" WIDTH="135"glColorMaterial()LEFT="235" WIDTH="108"IDREF="20887" TYPE="TITLE""Porting Lighting and 
Materials Calls"LEFT="0" WIDTH="90"lmdef()LEFT="95" WIDTH="135"glMaterial()glLight()glLightModel()LEFT="235" WIDTH="108"IDREF="21145" TYPE="TITLE""Porting defs, binds, and 
sets: Replacing `Tables' of 
Stored Definitions" and IDREF="20887" TYPE="TITLE""Porting 
Lighting and Materials 
Calls"LEFT="0" WIDTH="90"loadmatrix()LEFT="95" WIDTH="135"glLoadMatrix()LEFT="235" WIDTH="108"IDREF="91369" TYPE="TITLE""Porting Matrix and 
Transformation Calls"LEFT="0" WIDTH="90"loadname()LEFT="95" WIDTH="135"glLoadName()LEFT="235" WIDTH="108"IDREF="20349" TYPE="TITLE""Porting Picking Calls"LEFT="0" WIDTH="90"logicop()LEFT="95" WIDTH="135"glLogicOp()LEFT="235" WIDTH="108"IDREF="92008" TYPE="TITLE""Porting Pixel 
Operations"LEFT="0" WIDTH="90"lookat() LEFT="95" WIDTH="135"gluLookAt()aLEFT="235" WIDTH="108"IDREF="91369" TYPE="TITLE""Porting Matrix and 
Transformation Calls"LEFT="0" WIDTH="90"lrectread() LEFT="95" WIDTH="135"glReadPixels()LEFT="235" WIDTH="108"IDREF="92008" TYPE="TITLE""Porting Pixel 
Operations"LEFT="0" WIDTH="90"lrectwrite(])LEFT="95" WIDTH="135"glDrawPixels()LEFT="235" WIDTH="108"IDREF="92008" TYPE="TITLE""Porting Pixel 
Operations"LEFT="0" WIDTH="90"lRGBrange()LEFT="95" WIDTH="135"not supported; see glFog()LEFT="235" WIDTH="108"IDREF="77276" TYPE="TITLE""Porting Depth Cueing 
and Fog Commands"LEFT="0" WIDTH="90"lsbackup()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="68126" TYPE="TITLE""Lines"LEFT="0" WIDTH="90"lsetdepth()LEFT="95" WIDTH="135"glDepthRange()LEFT="235" WIDTH="108"IDREF="77276" TYPE="TITLE""Porting Depth Cueing 
and Fog Commands"LEFT="0" WIDTH="90"lshaderange()LEFT="95" WIDTH="135"not supported; see glFog()LEFT="235" WIDTH="108"IDREF="77276" TYPE="TITLE""Porting Depth Cueing 
and Fog Commands"LEFT="0" WIDTH="90"lsrepeat()LEFT="95" WIDTH="135"glLineStipple()LEFT="235" WIDTH="108"IDREF="68126" TYPE="TITLE""Lines"LEFT="0" WIDTH="90"makeobj()LEFT="95" WIDTH="135"glNewList()LEFT="235" WIDTH="108"IDREF="58056" TYPE="TITLE""Porting Display Lists"LEFT="0" WIDTH="90"maketag()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="80759" TYPE="TITLE""Stencil Plane Calls"LEFT="0" WIDTH="90"mapcolor()LEFT="95" WIDTH="135"auxSetOneColor() or 
XStoreColor()LEFT="235" WIDTH="108"IDREF="54935" TYPE="TITLE""Using Color-Index 
Mode" and 
IDREF="37274" TYPE="TITLE"Chapter 5LEFT="0" WIDTH="90"mapw()LEFT="95" WIDTH="135"gluProject()LEFT="235" WIDTH="108"IDREF="91369" TYPE="TITLE""Porting Matrix and 
Transformation Calls"LEFT="0" WIDTH="90"maxsize()LEFT="95" WIDTH="135"use the auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"minmax()LEFT="95" WIDTH="135"glMinmaxEXT()LEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"minsize()LEFT="95" WIDTH="135"use the auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"mmode()LEFT="95" WIDTH="135"glMatrixMode()LEFT="235" WIDTH="108"IDREF="91369" TYPE="TITLE""Porting Matrix and 
Transformation Calls"LEFT="0" WIDTH="90"monobuffer()LEFT="95" WIDTH="135"superseded by selection of an 
appropriate GLX visualLEFT="235" WIDTH="108"glXChooseVisual() 
reference page and 
IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"move()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="67471" TYPE="TITLE""Porting Commands that 
Required Current 
Graphics Position"LEFT="0" WIDTH="90"msalpha()LEFT="95" WIDTH="135"glEnable(GL_SAMPLE_ALPHA
_TO_MASK_SGIS), 
glEnable(GL_SAMPLE_ALPHA
_TO_ONE_SGIS)LEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"msmask()LEFT="95" WIDTH="135"glSampleMaskSGIS()LEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"mspattern()LEFT="95" WIDTH="135"glSamplePatternSGIS()LEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"mssize()LEFT="95" WIDTH="135"glXChooseVisual with attribute 
GLX_SAMPLE_BUFFERS_SGISLEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"mswapbuffers()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing"LEFT="0" WIDTH="90"multimap()LEFT="95" WIDTH="135"use the auxiliary library or X for 
color mapsLEFT="235" WIDTH="108"IDREF="31702" TYPE="TITLE""Porting Color, Shading, 
and Writemask 
Commands", 
also IDREF="54935" TYPE="TITLE""Using Color-Index 
Mode" or 
IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"multisample()LEFT="95" WIDTH="135"glEnable( 
GL_MULTISAMPLE_SGIS)LEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"multmatrix()LEFT="95" WIDTH="135"glMultMatrix()LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"n3f()LEFT="95" WIDTH="135"glNormal3fv()LEFT="235" WIDTH="108"IDREF="49018" TYPE="TITLE""bgn/end Commands"LEFT="0" WIDTH="90"newpup()LEFT="95" WIDTH="135"use X for menusLEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5, glXIntro 
reference page, 
X documentationLEFT="0" WIDTH="90"newtag()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="58056" TYPE="TITLE""Porting Display Lists"LEFT="0" WIDTH="90"nmode()LEFT="95" WIDTH="135"glEnable(GL_NORMALIZE)LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"noborder()LEFT="95" WIDTH="135"use the auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"noise()LEFT="95" WIDTH="135"use the auxiliary library or X for 
event handlingLEFT="235" WIDTH="108"IDREF="43633" TYPE="TITLE""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" or IDREF="37274" TYPE="TITLE"Chapter 5 and 
glXIntro reference pageLEFT="0" WIDTH="90"noport()LEFT="95" WIDTH="135"use X for windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"normal()LEFT="95" WIDTH="135"glNormal3fv()LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"nurbscurve()LEFT="95" WIDTH="135"gluNurbsCurve()aLEFT="235" WIDTH="108"IDREF="41356" TYPE="TITLE""NURBS Curves" and IDREF="88446" TYPE="TITLE""Trimming 
Curves"LEFT="0" WIDTH="90"nurbssurface()LEFT="95" WIDTH="135"gluNurbsSurface()aLEFT="235" WIDTH="108"IDREF="12666" TYPE="TITLE""NURBS Surfaces"LEFT="0" WIDTH="90"objdelete()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="80759" TYPE="TITLE""Stencil Plane Calls"LEFT="0" WIDTH="90"objinsert()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="80759" TYPE="TITLE""Stencil Plane Calls"LEFT="0" WIDTH="90"objreplace()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="58056" TYPE="TITLE""Porting Display Lists"LEFT="0" WIDTH="90"onemap()LEFT="95" WIDTH="135"use the auxiliary library or X for 
color mapsLEFT="235" WIDTH="108"IDREF="31702" TYPE="TITLE""Porting Color, Shading, 
and Writemask 
Commands" 
and IDREF="54935" TYPE="TITLE""Using Color-Index 
Mode" or 
IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"ortho()LEFT="95" WIDTH="135"glOrtho()LEFT="235" WIDTH="108"IDREF="91369" TYPE="TITLE""Porting Matrix and 
Transformation Calls"LEFT="0" WIDTH="90"ortho2()LEFT="95" WIDTH="135"gluOrtho2D()LEFT="235" WIDTH="108"IDREF="91369" TYPE="TITLE""Porting Matrix and 
Transformation Calls"LEFT="0" WIDTH="90"overlay()LEFT="95" WIDTH="135"use XLEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference page, also 
glXChooseVisual()LEFT="0" WIDTH="90"pagecolor()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"passthrough()LEFT="95" WIDTH="135"glPassThrough() LEFT="235" WIDTH="108"IDREF="43211" TYPE="TITLE""Porting Feedback Calls"LEFT="0" WIDTH="90"patch()LEFT="95" WIDTH="135"glEvalMesh2()aLEFT="235" WIDTH="108"IDREF="41945" TYPE="TITLE""Porting Curve and 
Surface Commands"LEFT="0" WIDTH="90"patchbasis()LEFT="95" WIDTH="135"glMap2()aLEFT="235" WIDTH="108"IDREF="41945" TYPE="TITLE""Porting Curve and 
Surface Commands"LEFT="0" WIDTH="90"patchcurves()LEFT="95" WIDTH="135"glMap2()aLEFT="235" WIDTH="108"IDREF="41945" TYPE="TITLE""Porting Curve and 
Surface Commands"LEFT="0" WIDTH="90"patchprecision()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="41945" TYPE="TITLE""Porting Curve and 
Surface Commands"LEFT="0" WIDTH="90"pclos()LEFT="95" WIDTH="135"not supported; see glEnd()LEFT="235" WIDTH="108"IDREF="67471" TYPE="TITLE""Porting Commands that 
Required Current 
Graphics Position" and IDREF="83655" TYPE="TITLE""Polygons 
and Quadrilaterals"LEFT="0" WIDTH="90"pdr()LEFT="95" WIDTH="135"not supported; see glVertex()LEFT="235" WIDTH="108"IDREF="67471" TYPE="TITLE""Porting Commands that 
Required Current 
Graphics Position" and IDREF="83655" TYPE="TITLE""Polygons 
and Quadrilaterals"LEFT="0" WIDTH="90"perspective()LEFT="95" WIDTH="135"gluPerspective()LEFT="235" WIDTH="108"IDREF="91369" TYPE="TITLE""Porting Matrix and 
Transformation Calls"LEFT="0" WIDTH="90"pick()LEFT="95" WIDTH="135"gluPickMatrix()a andglRenderMode(GL_SELECT)LEFT="235" WIDTH="108"IDREF="20349" TYPE="TITLE""Porting Picking Calls"LEFT="0" WIDTH="90"picksize() LEFT="95" WIDTH="135"gluPickMatrix()LEFT="235" WIDTH="108"IDREF="91369" TYPE="TITLE""Porting Matrix and 
Transformation Calls" and IDREF="20349" TYPE="TITLE""Porting 
Picking Calls"LEFT="0" WIDTH="90"pixelmap()LEFT="95" WIDTH="135"glPixelMap()LEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"pixeltransfer()LEFT="95" WIDTH="135"glPixelTransfer()LEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"pixmode()LEFT="95" WIDTH="135"glPixelTransfer() and 
glPixelStore()LEFT="235" WIDTH="108"IDREF="92008" TYPE="TITLE""Porting Pixel 
Operations"LEFT="0" WIDTH="90"pmv()LEFT="95" WIDTH="135"not supported; see glBegin() and 
glVertex()LEFT="235" WIDTH="108"IDREF="67471" TYPE="TITLE""Porting Commands that 
Required Current 
Graphics Position" and IDREF="83655" TYPE="TITLE""Polygons 
and Quadrilaterals"LEFT="0" WIDTH="90"pnt*()LEFT="95" WIDTH="135"glBegin(GL_POINTS)aLEFT="235" WIDTH="108"IDREF="89248" TYPE="TITLE""Points"LEFT="0" WIDTH="90"pntsize(), pntsizef()LEFT="95" WIDTH="135"glPointSize()LEFT="235" WIDTH="108"IDREF="89248" TYPE="TITLE""Points"LEFT="0" WIDTH="90"pntsmooth()LEFT="95" WIDTH="135"glEnable( 
GL_POINT_SMOOTH)LEFT="235" WIDTH="108"IDREF="89248" TYPE="TITLE""Points" and 
IDREF="65073" TYPE="TITLE""Antialiasing Calls"LEFT="0" WIDTH="90"polarview()LEFT="95" WIDTH="135"not supported; see glRotate() 
and glTranslate()LEFT="235" WIDTH="108"IDREF="91369" TYPE="TITLE""Porting Matrix and 
Transformation Calls"LEFT="0" WIDTH="90"polf()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="83655" TYPE="TITLE""Polygons and 
Quadrilaterals"LEFT="0" WIDTH="90"poly()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="83655" TYPE="TITLE""Polygons and 
Quadrilaterals"LEFT="0" WIDTH="90"polymode()LEFT="95" WIDTH="135"glPolygonMode()LEFT="235" WIDTH="108"IDREF="83655" TYPE="TITLE""Polygons and 
Quadrilaterals"LEFT="0" WIDTH="90"polysmooth()LEFT="95" WIDTH="135"glEnable( 
GL_POLYGON_SMOOTH)LEFT="235" WIDTH="108"IDREF="65073" TYPE="TITLE""Antialiasing Calls"LEFT="0" WIDTH="90"popattributes()LEFT="95" WIDTH="135"glPopAttrib()LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"popmatrix()LEFT="95" WIDTH="135"glPopMatrix()LEFT="235" WIDTH="108"IDREF="91369" TYPE="TITLE""Porting Matrix and 
Transformation Calls"LEFT="0" WIDTH="90"popname()LEFT="95" WIDTH="135"glPopName()LEFT="235" WIDTH="108"IDREF="20349" TYPE="TITLE""Porting Picking Calls"LEFT="0" WIDTH="90"popviewport()LEFT="95" WIDTH="135"glPopAttrib()LEFT="235" WIDTH="108"IDREF="73299" TYPE="TITLE""Viewports, 
Screenmasks, and 
Scrboxes"LEFT="0" WIDTH="90"prefposition()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="45155" TYPE="TITLE""Replacing 
prefposition() with 
auxInitPosition()" or IDREF="37274" TYPE="TITLE"Chapter 5 and 
glXIntro reference pageLEFT="0" WIDTH="90"prefsize()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"pupmode()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"pushattributes()LEFT="95" WIDTH="135"glPushAttrib() LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"pushmatrix()LEFT="95" WIDTH="135"glPushMatrix()LEFT="235" WIDTH="108"IDREF="91369" TYPE="TITLE""Porting Matrix and 
Transformation Calls"LEFT="0" WIDTH="90"pushname()LEFT="95" WIDTH="135"glPushName()LEFT="235" WIDTH="108"IDREF="20349" TYPE="TITLE""Porting Picking Calls"LEFT="0" WIDTH="90"pushviewport()LEFT="95" WIDTH="135"glPushAttrib(GL_VIEWPORT)LEFT="235" WIDTH="108"IDREF="73299" TYPE="TITLE""Viewports, 
Screenmasks, and 
Scrboxes"LEFT="0" WIDTH="90"pwlcurve()LEFT="95" WIDTH="135"gluPWLCurve()LEFT="235" WIDTH="108"IDREF="88446" TYPE="TITLE""Trimming Curves"LEFT="0" WIDTH="90"qcontrol()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="108"IDREF="43633" TYPE="TITLE""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" or IDREF="37274" TYPE="TITLE"Chapter 5 and 
glXIntro reference pageLEFT="0" WIDTH="90"qdevice()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="108"IDREF="43633" TYPE="TITLE""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" or IDREF="37274" TYPE="TITLE"Chapter 5 and 
glXIntro reference pageLEFT="0" WIDTH="90"qenter()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="108"IDREF="43633" TYPE="TITLE""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" or IDREF="37274" TYPE="TITLE"Chapter 5 and 
glXIntro reference pageLEFT="0" WIDTH="90"qgetfd()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="108"IDREF="43633" TYPE="TITLE""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" or IDREF="37274" TYPE="TITLE"Chapter 5 and 
glXIntro reference pageLEFT="0" WIDTH="90"qread()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="108"IDREF="43633" TYPE="TITLE""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" or IDREF="37274" TYPE="TITLE"Chapter 5 and 
glXIntro reference pageLEFT="0" WIDTH="90"qreset()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="108"IDREF="43633" TYPE="TITLE""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" or IDREF="37274" TYPE="TITLE"Chapter 5 and 
glXIntro reference pageLEFT="0" WIDTH="90"qtest()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="108"IDREF="43633" TYPE="TITLE""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" or IDREF="37274" TYPE="TITLE"Chapter 5 and 
glXIntro reference pageLEFT="0" WIDTH="90"rcrv()LEFT="95" WIDTH="135"not supported LEFT="235" WIDTH="108"IDREF="41945" TYPE="TITLE""Porting Curve and 
Surface Commands"LEFT="0" WIDTH="90"rcrvn()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="41945" TYPE="TITLE""Porting Curve and 
Surface Commands"LEFT="0" WIDTH="90"rdr()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="67471" TYPE="TITLE""Porting Commands that 
Required Current 
Graphics Position"LEFT="0" WIDTH="90"readcomponent()LEFT="95" WIDTH="135"glReadPixels() gives partial 
support; some readcomponent() 
features aren't supportedLEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"readdisplay()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"readpixels()LEFT="95" WIDTH="135"glReadPixels()LEFT="235" WIDTH="108"IDREF="92008" TYPE="TITLE""Porting Pixel 
Operations"LEFT="0" WIDTH="90"readRGB()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="92008" TYPE="TITLE""Porting Pixel 
Operations"LEFT="0" WIDTH="90"readsource()LEFT="95" WIDTH="135"glReadBuffer()LEFT="235" WIDTH="108"IDREF="92008" TYPE="TITLE""Porting Pixel 
Operations"LEFT="0" WIDTH="90"rect(), rectf()LEFT="95" WIDTH="135"see glRect() and 
glPolygonMode()LEFT="235" WIDTH="108"IDREF="83655" TYPE="TITLE""Polygons and 
Quadrilaterals"LEFT="0" WIDTH="90"rectcopy() LEFT="95" WIDTH="135"glCopyPixels()LEFT="235" WIDTH="108"IDREF="92008" TYPE="TITLE""Porting Pixel 
Operations"LEFT="0" WIDTH="90"rectread()LEFT="95" WIDTH="135"glReadPixels()LEFT="235" WIDTH="108"IDREF="92008" TYPE="TITLE""Porting Pixel 
Operations"LEFT="0" WIDTH="90"rectwrite()LEFT="95" WIDTH="135"glDrawPixels()LEFT="235" WIDTH="108"IDREF="92008" TYPE="TITLE""Porting Pixel 
Operations"LEFT="0" WIDTH="90"rectzoom()LEFT="95" WIDTH="135"glPixelZoom()LEFT="235" WIDTH="108"IDREF="92008" TYPE="TITLE""Porting Pixel 
Operations"LEFT="0" WIDTH="90"resetls()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="68126" TYPE="TITLE""Lines"LEFT="0" WIDTH="90"reshapeviewport()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="91085" TYPE="TITLE""Handling Redraw 
Events" or 
IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"RGBcolor()LEFT="95" WIDTH="135"glColor()LEFT="235" WIDTH="108"IDREF="49018" TYPE="TITLE""bgn/end Commands" and IDREF="31702" TYPE="TITLE""Porting 
Color, Shading, and 
Writemask Commands"LEFT="0" WIDTH="90"RGBcursor()LEFT="95" WIDTH="135"use X for cursorsLEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5, glXIntro 
reference page, 
X documentationLEFT="0" WIDTH="90"RGBmode()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="64084" TYPE="TITLE""Porting Display Mode 
Initialization Calls with 
auxInitDisplayMode()" or IDREF="37274" TYPE="TITLE"Chapter 5 
and glXIntro reference 
pageLEFT="0" WIDTH="90"RGBrange()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"RGBsize()LEFT="95" WIDTH="135"not supported, but the 
glXChooseVisual() function 
does some similar thingsLEFT="235" WIDTH="108"glXChooseVisual() 
reference pageLEFT="0" WIDTH="90"RGBwritemask()LEFT="95" WIDTH="135"glColorMask()LEFT="235" WIDTH="108"IDREF="31702" TYPE="TITLE""Porting Color, Shading, 
and Writemask 
Commands"LEFT="0" WIDTH="90"rightbuffer()LEFT="95" WIDTH="135"glDrawBuffer(GL_RIGHT)LEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"ringbell()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"see X documentation for 
XBell()LEFT="0" WIDTH="90"rmv()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="67471" TYPE="TITLE""Porting Commands that 
Required Current 
Graphics Position"LEFT="0" WIDTH="90"rot()LEFT="95" WIDTH="135"glRotate()LEFT="235" WIDTH="108"IDREF="91369" TYPE="TITLE""Porting Matrix and 
Transformation Calls"LEFT="0" WIDTH="90"rotate()LEFT="95" WIDTH="135"glRotate()LEFT="235" WIDTH="108"IDREF="91369" TYPE="TITLE""Porting Matrix and 
Transformation Calls"LEFT="0" WIDTH="90"rpatch()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="41945" TYPE="TITLE""Porting Curve and 
Surface Commands"LEFT="0" WIDTH="90"rpdr()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="67471" TYPE="TITLE""Porting Commands that 
Required Current 
Graphics Position" and IDREF="83655" TYPE="TITLE""Polygons 
and Quadrilaterals"LEFT="0" WIDTH="90"rpmv()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="67471" TYPE="TITLE""Porting Commands that 
Required Current 
Graphics Position" and IDREF="83655" TYPE="TITLE""Polygons 
and Quadrilaterals"LEFT="0" WIDTH="90"sbox(), sboxf()LEFT="95" WIDTH="135"glRect()aLEFT="235" WIDTH="108"IDREF="83655" TYPE="TITLE""Polygons and 
Quadrilaterals"LEFT="0" WIDTH="90"scale()LEFT="95" WIDTH="135"glScale()LEFT="235" WIDTH="108"IDREF="91369" TYPE="TITLE""Porting Matrix and 
Transformation Calls"LEFT="0" WIDTH="90"sclear()LEFT="95" WIDTH="135"glClear( 
GL_STENCIL_BUFFER_BIT)LEFT="235" WIDTH="108"IDREF="28727" TYPE="TITLE""Porting Screen and 
Buffer Clearing 
Commands" 
and IDREF="80759" TYPE="TITLE""Stencil Plane Calls"LEFT="0" WIDTH="90"scrbox()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="73299" TYPE="TITLE""Viewports, 
Screenmasks, and 
Scrboxes"LEFT="0" WIDTH="90"screenspace()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="91369" TYPE="TITLE""Porting Matrix and 
Transformation Calls"LEFT="0" WIDTH="90"scrmask() LEFT="95" WIDTH="135"glScissor()LEFT="235" WIDTH="108"IDREF="73299" TYPE="TITLE""Viewports, 
Screenmasks, and 
Scrboxes"LEFT="0" WIDTH="90"scrnattach()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"scrnselect()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"scrsubdivide()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"select()LEFT="95" WIDTH="135"glRenderMode()LEFT="235" WIDTH="108"IDREF="20349" TYPE="TITLE""Porting Picking Calls"LEFT="0" WIDTH="90"setbell()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"see X documentation for 
XChangeKeyboardContr
ol()LEFT="0" WIDTH="90"setcursor() LEFT="95" WIDTH="135"use X for cursorsLEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5, glXIntro 
reference page and 
X documentationLEFT="0" WIDTH="90"setdblights()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"dial and button box 
documentationLEFT="0" WIDTH="90"setdepth()LEFT="95" WIDTH="135"glDepthRange()aLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"setlinestyle()LEFT="95" WIDTH="135"glLineStipple()LEFT="235" WIDTH="108"IDREF="68126" TYPE="TITLE""Lines" and 
IDREF="21145" TYPE="TITLE""Porting defs, binds, and 
sets: Replacing `Tables' of 
Stored Definitions"LEFT="0" WIDTH="90"setmap()LEFT="95" WIDTH="135"use auxiliary library or X for 
color mapsLEFT="235" WIDTH="108"IDREF="31702" TYPE="TITLE""Porting Color, Shading, 
and Writemask 
Commands" 
and IDREF="54935" TYPE="TITLE""Using Color-Index 
Mode" or 
IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"setmonitor()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"setnurbsproperty()LEFT="95" WIDTH="135"gluNurbsProperty()LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"setpattern()LEFT="95" WIDTH="135"glPolygonStipple() LEFT="235" WIDTH="108"IDREF="83655" TYPE="TITLE""Polygons and 
Quadrilaterals" and IDREF="21145" TYPE="TITLE""Porting 
defs, binds, and sets: 
Replacing `Tables' of 
Stored Definitions"LEFT="0" WIDTH="90"setpup()LEFT="95" WIDTH="135"use X for menusLEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5, glXIntro 
reference page, 
X documentationLEFT="0" WIDTH="90"setvaluator()LEFT="95" WIDTH="135"use X for devicesLEFT="235" WIDTH="108"IDREF="37274" TYPE="TITLE"Chapter 5, glXIntro 
reference page, 
X documentationLEFT="0" WIDTH="90"setvideo()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"shademodel()LEFT="95" WIDTH="135"glShadeModel()LEFT="235" WIDTH="108"IDREF="31702" TYPE="TITLE""Porting Color, Shading, 
and Writemask 
Commands"LEFT="0" WIDTH="90"shaderange()LEFT="95" WIDTH="135"glFog()LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"singlebuffer()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="64084" TYPE="TITLE""Porting Display Mode 
Initialization Calls with 
auxInitDisplayMode()" or IDREF="37274" TYPE="TITLE"Chapter 5 
and glXIntro reference 
pageLEFT="0" WIDTH="90"smoothline()LEFT="95" WIDTH="135"glEnable( GL_LINE_SMOOTH)LEFT="235" WIDTH="108"IDREF="68126" TYPE="TITLE""Lines"LEFT="0" WIDTH="90"spclos()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="83655" TYPE="TITLE""Polygons and 
Quadrilaterals"LEFT="0" WIDTH="90"splf()LEFT="95" WIDTH="135"not supportedsee glBegin()LEFT="235" WIDTH="108"IDREF="83655" TYPE="TITLE""Polygons and 
Quadrilaterals"LEFT="0" WIDTH="90"stencil()LEFT="95" WIDTH="135"glStencilFunc(),glStencilOp()LEFT="235" WIDTH="108"IDREF="80759" TYPE="TITLE""Stencil Plane Calls"LEFT="0" WIDTH="90"stensize()LEFT="95" WIDTH="135"glStencilMask()LEFT="235" WIDTH="108"IDREF="80759" TYPE="TITLE""Stencil Plane Calls"LEFT="0" WIDTH="90"stepunit()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"stereobuffer()LEFT="95" WIDTH="135"superseded by selection of an 
appropriate GLX visualLEFT="235" WIDTH="108"glXChooseVisual() 
reference page and 
IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"strwidth()LEFT="95" WIDTH="135"use X for fonts and stringsLEFT="235" WIDTH="108"IDREF="89603" TYPE="TITLE""Fonts and Strings"LEFT="0" WIDTH="90"subpixel()LEFT="95" WIDTH="135"not neededLEFT="235" WIDTH="108"IDREF="91804" TYPE="TITLE""Porting Antialiasing 
Calls"LEFT="0" WIDTH="90"subtexload()LEFT="95" WIDTH="135"glTexSubImage2DEXT()LEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"swapbuffers()LEFT="95" WIDTH="135"glXSwapBuffers()LEFT="235" WIDTH="108"glXIntro and 
glXSwapBuffers() 
reference pagesLEFT="0" WIDTH="90"swapinterval()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing"LEFT="0" WIDTH="90"swaptmesh()LEFT="95" WIDTH="135"not supported; see glBegin(GL_TRIANGLE_FAN)LEFT="235" WIDTH="108"IDREF="65584" TYPE="TITLE""Triangles"LEFT="0" WIDTH="90"swinopen()LEFT="95" WIDTH="135"use the auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"swritemask()LEFT="95" WIDTH="135"glStencilMask()LEFT="235" WIDTH="108"IDREF="80759" TYPE="TITLE""Stencil Plane Calls"LEFT="0" WIDTH="90"t2*(), t3*(), t4*()LEFT="95" WIDTH="135"glTexCoord*()LEFT="235" WIDTH="108"IDREF="43929" TYPE="TITLE""Porting Texture Calls"LEFT="0" WIDTH="90"tevbind() LEFT="95" WIDTH="135"glTexEnv()LEFT="235" WIDTH="108"IDREF="21145" TYPE="TITLE""Porting defs, binds, and 
sets: Replacing `Tables' of 
Stored Definitions" and IDREF="20887" TYPE="TITLE""Porting 
Lighting and Materials 
Calls"LEFT="0" WIDTH="90"tevdef() LEFT="95" WIDTH="135"glTexEnv()LEFT="235" WIDTH="108"IDREF="21145" TYPE="TITLE""Porting defs, binds, and 
sets: Replacing `Tables' of 
Stored Definitions", IDREF="20887" TYPE="TITLE""Porting 
Lighting and Materials 
Calls", and 
IDREF="91980" TYPE="TITLE""Translating tevdef()"LEFT="0" WIDTH="90"texbind()LEFT="95" WIDTH="135"glTexImage2D(),glTexParameter(),gluBuild2DMipmaps(),LEFT="235" WIDTH="108"IDREF="21145" TYPE="TITLE""Porting defs, binds, and 
sets: Replacing `Tables' of 
Stored Definitions" and IDREF="43929" TYPE="TITLE""Porting 
Texture Calls"LEFT="0" WIDTH="90"texdef2d()LEFT="95" WIDTH="135"glTexImage2D(),glTexParameter(),gluBuild2DMipmaps()LEFT="235" WIDTH="108"IDREF="21145" TYPE="TITLE""Porting defs, binds, and 
sets: Replacing `Tables' of 
Stored Definitions", IDREF="20887" TYPE="TITLE""Porting 
Lighting and Materials 
Calls", and 
IDREF="43009" TYPE="TITLE""Translating texdef()"LEFT="0" WIDTH="90"texdef3d()LEFT="95" WIDTH="135"glTexImage3DEXT()LEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"texgen()LEFT="95" WIDTH="135"glTexGen()LEFT="235" WIDTH="108"IDREF="20887" TYPE="TITLE""Porting Lighting and 
Materials Calls" and IDREF="31165" TYPE="TITLE""Translating 
texgen()"LEFT="0" WIDTH="90"textcolor()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"textinit()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"textport()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"tie()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="108"IDREF="43633" TYPE="TITLE""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" or IDREF="37274" TYPE="TITLE"Chapter 5 and 
glXIntro reference pageLEFT="0" WIDTH="90"tlutbind()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"tlutdef()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"tpoff()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"tpon()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"translate()LEFT="95" WIDTH="135"glTranslate()LEFT="235" WIDTH="108"IDREF="91369" TYPE="TITLE""Porting Matrix and 
Transformation Calls"LEFT="0" WIDTH="90"underlay()LEFT="95" WIDTH="135"glXChooseVisual()LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"unqdevice()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="108"IDREF="43633" TYPE="TITLE""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" or IDREF="37274" TYPE="TITLE"Chapter 5 and 
glXIntro reference pageLEFT="0" WIDTH="90"v2*(), v3*(), v4*()LEFT="95" WIDTH="135"glVertex*()LEFT="235" WIDTH="108"IDREF="37304" TYPE="TITLE""The v() Commands"LEFT="0" WIDTH="90"videocmd()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"viewport()LEFT="95" WIDTH="135"glViewport()LEFT="235" WIDTH="108"IDREF="73299" TYPE="TITLE""Viewports, 
Screenmasks, and 
Scrboxes"LEFT="0" WIDTH="90"winattach()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowing LEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"winclose()LEFT="95" WIDTH="135"glXDestroyContext(), 
XCloseDisplay()LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"winconstraints()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"windepth()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"window() LEFT="95" WIDTH="135"glFrustum()LEFT="235" WIDTH="108"IDREF="91369" TYPE="TITLE""Porting Matrix and 
Transformation Calls"LEFT="0" WIDTH="90"winget()LEFT="95" WIDTH="135"glXGetCurrentContext()LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"winmove()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"winopen()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="49158" TYPE="TITLE""Replacing winopen() 
with auxInitWindow()" or IDREF="37274" TYPE="TITLE"Chapter 5 
and glXIntro reference 
pageLEFT="0" WIDTH="90"winpop()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"winposition() LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"winpush()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"winset()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
and glXMakeCurrent() 
reference pagesLEFT="0" WIDTH="90"wintitle()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="108"IDREF="88614" TYPE="TITLE""Windowing" 
or IDREF="37274" TYPE="TITLE"Chapter 5 and glXIntro 
reference pageLEFT="0" WIDTH="90"wmpack()LEFT="95" WIDTH="135"glColorMask()LEFT="235" WIDTH="108"IDREF="31702" TYPE="TITLE""Porting Color, Shading, 
and Writemask 
Commands"LEFT="0" WIDTH="90"writemask()LEFT="95" WIDTH="135"glIndexMask()LEFT="235" WIDTH="108"IDREF="31702" TYPE="TITLE""Porting Color, Shading, 
and Writemask 
Commands"LEFT="0" WIDTH="90"writepixels()LEFT="95" WIDTH="135"glDrawPixels()LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"writeRGB()LEFT="95" WIDTH="135"glDrawPixels()LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"xfpt*()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"IDREF="20349" TYPE="TITLE""Porting Picking Calls" and IDREF="43211" TYPE="TITLE""Porting 
Feedback Calls"LEFT="0" WIDTH="90"zbsize()LEFT="95" WIDTH="135"superseded by selection of an 
appropriate GLX visualLEFT="235" WIDTH="108"glXChooseVisual() 
reference page and 
IDREF="47009" TYPE="TITLE""Porting RealityEngine 
Graphics Features"LEFT="0" WIDTH="90"zbuffer()LEFT="95" WIDTH="135"glEnable(GL_DEPTH_TEST)LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"zclear()LEFT="95" WIDTH="135"glClear( 
GL_DEPTH_BUFFER_BIT)LEFT="235" WIDTH="108"IDREF="28727" TYPE="TITLE""Porting Screen and 
Buffer Clearing 
Commands"LEFT="0" WIDTH="90"zdraw()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"zfunction()LEFT="95" WIDTH="135"glDepthFunc()LEFT="235" WIDTH="108"LEFT="0" WIDTH="90"zsource()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="108"LEFT="0" WIDTH="90"zwritemask()LEFT="95" WIDTH="135"glDepthMask()LEFT="235" WIDTH="108"IDREF="31702" TYPE="TITLE""Porting Color, Shading, 
and Writemask 
Commands"LBL="a" ID="A.equivsTF0a"note that this is not a direct equivalent of IRIS GL functionalityname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'be careful when portingLBL="B"ID="71689"Differences Between OpenGL and IRIS GLThis appendix contains a list of differences between OpenGL and IRIS GL. Each difference is given a simple name, followed by a description.accumulation from the z-bufferReading from and writing to the z-buffer from the accumulation buffer isn't supported in OpenGL.accumulation wrappingOpenGL accumulation buffer operation is not defined when component values exceed 1.0 or go below -1.0.antialiased linesOpenGL stipples antialiased lines. IRIS GL does not.arcOpenGL supports arcs in its utility library. attribute listsThe attributes pushed by IRIS GL pushattributes() differ from any of the attribute sets that are pushed by OpenGL glPushAttrib(). Because all OpenGL states can be read back, however, it is possible to implement any desired push/pop semantics using the OpenGL API.bbox OpenGL does not support conditional execution of display lists.buffers, multipleAnything involving multiple buffers or windowing must be done in X or with the OpenGL Programming Guide auxiliary library.callfuncOpenGL does not support callback from display lists. Note that IRIS GL also did not support this functionality when client and server were on different platforms.circleOpenGL supports circles in the GLU. In OpenGL both circles and arcs (disks and partial disks) can have holes. Also, subdivision of the primitives can be changed in OpenGL and the primitives' surface normals are available for lighting.clear optionsOpenGL really clears buffers. It does not apply most currently-specified pixel operations, such as blending and logicop, regardless of their modes, though there are some options that are applied. To clear using such features, you must render a window-size polygon.closed linesOpenGL renders all single-width aliased lines such that abutting lines share no pixels. This means that the "last" pixel of an independent line is not drawn.color mapsChanging the color map under OpenGL must be done using the X color map.color/normal flagOpenGL lighting is explicitly enabled or disabled. When enabled, it is effective regardless of the order in which colors and normals are specified.Lighting cannot be enabled or disabled between OpenGL glBegin() and glEnd() commands. If you need to disable lighting between glBegin() and glEnd(), you must do it by specifying zero ambient, diffuse, and specular material reflectance. Then set the material emission to the desired color.color packingOpenGL has no need for cpack(); you can use 4-item vectors to specify colors instead.color range with c3i()The OpenGL glColor*() routines that appear to correspond directly to IRIS GL c3*() and c4*() routines are not actually equivalent. For instance, IRIS GL's c3i() function took arguments in the range [0, 255] for each color; but in OpenGL, glColor3i() allows signed arguments with values up to over two billion. Check the OpenGL Programming Guide for details on argument value ranges, and use glColor3ub() as a replacement for c3i().concave polygonsThe core OpenGL API does not handle concave polygons, but the GLU does provide support for decomposing concave, non-self-intersecting contours into triangles. These triangles can either be draw immediately or returned.current computed colorOpenGL has no notion of a current computed color. If you're using OpenGL as a lighting engine, you can use feedback to obtain colors generated by lighting calculations. current graphics positionOpenGL does not maintain a current graphics position. IRIS GL commands that depended on current graphics position, such as relative lines and polygons, are not included in OpenGL.curvesOpenGL does not support IRIS GL curves. Use of NURBS curves is recommended.defs/bindsOpenGL does not have the concept of a material, light, or texture objects, only of material, light, and texture properties. OpenGL programmers can use display lists to create their own objects, however. depthcueOpenGL provides no direct support for depth cueing. However, its fog support is a more general capability that you can easily use to emulate IRIS GL depthcue().display list editingOpenGL display lists cannot be edited, only created and destroyed. Because display list names are specified by the programmer, however, it is possible to redefine individual display lists in a hierarchy.OpenGL display lists are designed for data caching, not for data base management. They are guaranteed to be stored on the server in client/server environments, so they are not limited by network bandwidth during execution.OpenGL display lists can be called between glBegin() and glEnd() commands, so the display list hierarchy can be made fine enough that it can, in effect, be edited.error checkingOpenGL checks for errors more carefully than IRIS GL. For example, all OpenGL commands that are not accepted between glBegin() and glEnd() are detected as errors, and have no other effect.error return valuesWhen an OpenGL command that returns a value detects an error, it always returns zero. OpenGL commands that return data through passed pointers make no change to the array contents if an error is detected.error side effectsWhen an OpenGL command results in an error, its only side effect is to update the error flag to the appropriate value. No other state changes are made. (Exception is the OUT_OF_MEMORY error, which is fatal.)evaluatorsInput and output that was done with such functions as getbutton(), qread(), and qdevice() in IRIS GL must be done using X calls with OpenGL, as must cursor-manipulation functions.feedbackIn OpenGL, feedback is standardized so that it doesn't change from machine to machine. IDREF="43211" TYPE="TITLE""Porting Feedback Calls" explains how to port your IRIS GL feedback calls.fogIn OpenGL, you can't use depth-cueing and fog at the same time, because fog is used to emulate depth-cueing. IRIS GL allows more options to fog; some OpenGL implementations may compute fog per-vertex instead of per-fragment.fonts and stringsOpenGL expects character glyphs to be manipulated as individual display lists. It provides a display list calling function that accepts a list of display list names, each name represented as 1, 2, or 4 bytes. glCallLists() adds a separately specified offset to each display list name before the call, allowing lists of display list names to be treated as strings. This mechanism provides all the functionality of IRIS GL fonts, and considerably more. For example, characters comprised of triangles can be easily manipulated. frontbufferIRIS GL had complex rules for defeating rendering to the front buffer in singlebuffer mode. OpenGL does as it is asked in this regard.hollow polygonsOpenGL does not support hollow polygons. However, you can use the OpenGL stencil capability to render hollow polygons.index clampingWhere possible, OpenGL treats color and stencil indexes as bitfields rather than numbers. Thus indexes are masked, rather than clamped, to the supported range of the framebuffer.input and outputI/O in OpenGL is mostly handled via X calls. See IDREF="37274" TYPE="TITLE"Chapter 5 for more information.integer colorsSigned integer color components (red, green, blue, or alpha) are linearly mapped to floating point such that the most negative integer maps to -1.0 and the most positive integer maps to 1.0. This mapping occurs when the color is specified, before it replaces the current color.Unsigned integer color components are linearly mapped to floating point such that 0 maps to 0.0 and the largest representable integer maps to 1.0. This mapping occurs when the color is specified, before it replaces the current color.integer normalsInteger normal components are mapped just like signed color components, such that the most negative integer maps to -1.0, and the most positive integer maps to 1.0.invarianceOpenGL guarantees certain invariances that IRIS GL does not. For example, OpenGL guarantees that identical code sequences sent to the same system, differing only in the blending function specified, will generate the same pixel fragments. (The fragments may be different if blending is enabled and disabled, however.)lighting equationThe OpenGL lighting equation differs slightly from the IRIS GL equation. OpenGL supports separate attenuation for each light source, rather than a single attenuation for all the light sources as in IRIS GL, and OpenGL regularizes the equation so that ambient, diffuse, and specular lighting contributions are all attenuated. Also, OpenGL allows separate colors to be specified for the ambient, diffuse, and specular intensities of light sources, as well as for the ambient, diffuse, and specular reflectance of materials. All OpenGL light and material colors must include an alpha value, though only the diffuse material-color alpha value is actually used for lighting.Setting the specular exponent to zero does NOT defeat specular lighting in OpenGL.mapw()OpenGL utilities don't directly support mapping between object and window coordinates. If you specify the right projection matrix and viewport, you might be able to achieve the same effect using gluProject().material colorIn IRIS GL, you could call lmcolor() between a call to bgnprimitive() and the corresponding endprimitive() call. In OpenGL, you can't call glColorMaterial() between a glBegin() and its corresponding glEnd().Also, material coloring behaves differently: in IRIS GL it was connected with lighting models, while it's part of OpenGL's state.matrix modeAll OpenGL matrix operations operate on the current matrix, rather than on a particular matrix, as do the IRIS GL ortho(), ortho2(), perspective(), and window() commands. All OpenGL matrix operations except glLoadIdentity() and glLoadMatrix() multiply the current matrix rather than replacing it (as do ortho(), ortho2(), perspective(), and window() in IRIS GL).mipmaps, automatic generationThe OpenGL texture interface does not support automatic generation of mipmap images. GLU does support automatic generation of mipmap images for both 1D and 2D textures; however, GLU mipmap generation isn't as flexible as that of IRIS GL. (For instance, GLU doesn't currently allow you to set weights for the texels when you average texels to generate a small mipmap from a larger one.)mixed-modelFor an extensive discussion of this topic, see IDREF="37274" TYPE="TITLE"Chapter 5, "Mixed-Model Programming." Note in particular that IRIS GL mixed-model routines had, in some cases, names confusingly similar to unrelated OpenGL routines; see IDREF="16719" TYPE="TITLE""Porting IRIS GL Mixed-Model Programs" in Chapter 5 for details.move/draw/pmove/pdraw/pclosOpenGL supports only Begin/End style graphics, because it does not maintain a current graphics position. The scalar parameter specification of the old move/draw commands is accepted by OpenGL for all vertex related commands, however.MSINGLE modeSee the entry for "single matrix mode" in this appendix.multi-buffer drawingOpenGL renders to each color buffer individually, rather than computing a single new color value based on the contents of one color buffer and writing it to all the enabled color buffers, as IRIS GL did.multisamplingMultisampling is supported only in an extension to OpenGL.NURBS OpenGL supports NURBS with a combination of core capability (evaluators) and GLU support. GLU currently supports only Berstein polynomials, not all splines; in the future, GLU may support changing the basis matrix to handle all splines.old polygon modeAliased OpenGL polygons are always point sampled. The old polygon compatibility mode of the IRIS GL, where pixels outside the polygon perimeter were included in its rasterization, is not supported. If your code uses old polygon mode, it's probably for rectangles. Old polygon mode rectangles appear one pixel wider and higher. packed color formatsOpenGL accepts colors as 8-bit components, but these components are treated as an array of bytes rather than as bytes packed into larger words. By encouraging array indexing rather than shifting, OpenGL promotes endian-invariant programming.Just as IRIS GL accepted packed colors both for geometric and pixel rendering, OpenGL accepts arrays of color components for geometric and pixel rendering.patchesOpenGL does not support IRIS GL patches. Use of evaluators is recommended.per-bit color writemaskOpenGL writemasks for color components enable or disable changes to the entire component (red, green, blue, or alpha), not to individual bits of components. Note that per-bit writemasks are supported for both color indexes and stencil indexes, however.per-bit depth writemaskOpenGL writemasks for depth components enable or disable changes to the entire component, not to individual bits of the depth component.performanceThe performance of an OpenGL program depends in part on whether certain OpenGL features are used. A straightforward port of an IRIS GL program will probably require tuning to achieve maximum performance in OpenGL. For some tips on maximizing OpenGL performance, see IDREF="78929" TYPE="TITLE""Performance" in Chapter 2.pickThe OpenGL utility library includes support for generating a pick matrix.pixel coordinatesOpenGL and IRIS GL agree that the origin of a window's coordinate system is at its lower left corner. OpenGL places the origin at the lower left corner of this pixel, however, while IRIS GL placed it at the center of the lower left pixel.pixel fragmentsPixels drawn by glDrawPixels() or glCopyPixels() are always rasterized and converted to fragments. The resulting fragments are textured, fogged, depth buffered, blended, and so on, just as if they had been generated from geometric points. Fragment data that are not provided by the source pixels are augmented from the current raster position. For example, RGBA pixels take the raster position Z and texture coordinates. Depth pixels take the raster position color and texture coordinates.pixel zoomOpenGL negative zoom factors reflect about the current graphics position. IRIS GL doesn't define the operation of negative zoom factors, and instead provides RIGHT_TO_LEFT and TOP_TO_BOTTOM reflection pixmodes. These reflection modes reflect in place, rather than about the current raster position. OpenGL doesn't define reflection modes. Also, OpenGL allows fractional zoom factors.pixmodeOpenGL pixel transfers operate on individual color components, rather than on packed groups of 4 8-bit components as does IRIS GL. While OpenGL provides substantially more pixel capability than IRIS GL, it does not support packed color constructs, and it does not allow color components to be reassigned (red to green, red to blue, etc.) during pixel copy operations.polf()/poly()OpenGL provides no direct support for vertex lists other than display lists. Functions like polf() and poly() can easily be implemented using the OpenGL API, however.polygon provoking vertexFlat shaded IRIS GL polygons took the color of the last vertex specified, while OpenGL polygons take the color of the first vertex specified. (Note that this is only true for the GL_POLYGON primitive, not for triangles, triangle strips, and other primitive types, each of which take their colors from different vertices. See the reference page for glShadeModel() for details.)polygon stippleIn IRIS GL the polygon stipple pattern was screen-relative. In OpenGL it is window-relative.polygon vertex countThere is no limit to the number of vertexes between glBegin() and glEnd() in OpenGL, even for glBegin(POLYGON). In IRIS GL polygons are limited to no more than 255 vertexes.readdisplayReading pixels outside window boundaries is properly a window system capability, rather than a renderer capability. The IRIS GL readdisplay() command may eventually be replaced by an extension to X.RealityEngine graphics featuresMany of the special RealityEngine graphics features of IRIS GL (including multisampling and some texture-mapping features) have been implemented as extensions to OpenGL.relative move/draw/pmove/pdraw/pclosOpenGL does not maintain a current graphics position, and therefore is unable to support relative vertex operations. reset linestyleIRIS GL resetls() has not been supported for some time, and is not supported by OpenGL.RGBA logicop()OpenGL does not support logical operations on RGBA buffers.sbox()sbox() is an IRIS GL rectangle primitive that is well defined only if transformed without rotation, and is designed to be faster than standard rectangles. While OpenGL does not support such a primitive, it can be tuned to render rectangles very quickly when the matrixes and other modes are in states that simplify calculations.scalar argumentsAll OpenGL commands that are accepted between glBegin() and glEnd() have entry points that accept scalar arguments. For example, glColor4f(red,green,blue,alpha).scissorOpenGL glScissor() does not track the viewport. The IRIS GL viewport() command automatically updates the scrmask.scrbox()OpenGL doesn't support bounding box computation.scrsubdivide()OpenGL doesn't support explicit screen subdivision. scrsubdivide() was used in IRIS GL to handle perspective properly when interpolating colors and textures. Most Silicon Graphics platforms now handle texture interpolation correctly, but not all platforms do perspective-corrected color interpolation.If you notice a perspective problem in interpolation, try specifying this hint:glHint(GL_PERSPECTIVE_CORRECTION_HINT,
       GL_NICEST);Under some circumstances, that may improve the interpolation. GL_NICEST specifies quality at the expense of speed, though, so if speed is a high priority you may be forced to settle for linear interpolation.single matrix modeOpenGL always maintains two matrices: the modelview matrix and the projection matrix. While an OpenGL implementation may consolidate these into a single matrix for performance reasons, it must always present the 2≠matrix model to the programmer. See IDREF="90887" TYPE="TITLE""Porting MSINGLE Mode Code" in Chapter 3 for more information.specular exponent, setting to zeroSee the entry for "lighting equation" in this appendix.stereoStereo rendering on RealityEngine graphics systems under OpenGL is accomplished by choosing an appropriate X visual.subpixel modeAll OpenGL rendering is subpixel positionedname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'subpixel mode is always on.swapbuffers()Anything involving multiple buffers or windowing must be done in X or with the OpenGL Programming Guide auxiliary library.swaptmesh()OpenGL does not support the swaptmesh() capability. It does offer two types of triangle meshes, however: one that corresponds to the default "strip" behavior of the IRIS GL, and another that corresponds to calling swaptmesh() prior to the third and all subsequent vertexes when using IRIS GL.texture lookup tablesTexture lookup tables aren't yet supported in OpenGL.texture scaling, automaticThe OpenGL texture interface does not support automatic scaling of images to power-of-two dimensions. However, the GLU supports image scaling.texturing, 3DThree-dimensional texturing is provided as part of an extension to OpenGL.uniform scalingIf you use only unit-length normals in IRIS GL, and if the modelview matrix is the product only of rotations and uniform scales, you don't need to enable normalization of the normal vectors.In OpenGL, however, uniform scaling does affect the length of normal vectors, even unit-length normals.vector argumentsAll OpenGL commands that are accepted between glBegin() and glEnd() have entry points that accept vector arguments. For example, glColor4fv(v).window managementOpenGL includes no window system commands. It is always supported as an extension to a window or operating system that includes capability for device and window control. Each extension provides a system-specific mechanism for creating, destroying, and manipulating OpenGL rendering contexts. For example, the OpenGL extension to the X window system (GLX) includes roughly 10 commands for this purpose.IRIS GL commands such as gconfig() and drawmode() are not implemented by OpenGL.window offsetIRIS GL returned viewport and character position in screen, rather than window, coordinates. OpenGL always deals with window coordinates.z-buffer, reading fromIf you wanted to read from the z-buffer in IRIS GL, you specified that buffer with readsource() and then used lrectread() or rectread() to do the reading. If you want to read from the z-buffer in OpenGL, you simply specify that buffer as a parameter to glReadPixels().z-buffer sizingChanging the depth of the z-buffer can be done by selecting an appropriate visual.z renderingOpenGL does not support rendering colors to the depth buffer. It does allow for additional color buffers, which can be implemented using the same memory that is used for depth buffers in other window configurationsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'but these additional color buffers cannot share memory with the depth buffer in any single configuration.LBL="C"ID="18405"Some Important OpenGL BasicsThis appendix provides a bit of background information on OpenGL command names, OpenGL defined types, and OpenGL error handling. It is intended mainly as a brief, quick reference. For more detailed information, refer to the OpenGL Programming Guide.LBL="" HELPID=""ID="63238"OpenGL Command NamesThis section describes the naming convention for OpenGL calls. For a complete list of OpenGL equivalents to IRIS GL routines, see IDREF="39727" TYPE="TITLE"Appendix A, "OpenGL Commands and Their IRIS GL Equivalents."OpenGL commands begin with the gl prefix (glEnable(), glTranslatef(), and so on). OpenGL Utility Library (GLU) commands all begin with the glu prefix (gluDisk(), gluErrorString(), and so on). The commands that comprise the OpenGL extension to X (GLX) all begin with the glX prefix (glXChooseVisual(), glXCopyContext(), and so on). The commands that comprise the OpenGL auxiliary library begin with the aux prefix (auxWireCone(), auxSolidTeapot(), and so on).OpenGL commands are formed by a root name followed by up to four characters. The first character indicates the number of arguments. The second character, or pair or characters, specifies the type of the arguments. IDREF="30548" TYPE="TABLE"Table C-1 lists the character suffixes and the corresponding argument types (some of these values might be different on a 64-bit architecture).COLUMNS="3"LBL="C-1"Table C-1 ID="30548"Command Suffixes and Corresponding Argument TypesLEFT="0" WIDTH="72"LetterLEFT="80" WIDTH="135"TypeLEFT="220" WIDTH="126"C TypeLEFT="0" WIDTH="72"bLEFT="80" WIDTH="135"8-bit integerLEFT="220" WIDTH="126"charLEFT="0" WIDTH="72"sLEFT="80" WIDTH="135"16-bit integerLEFT="220" WIDTH="126"shortLEFT="0" WIDTH="72"iLEFT="80" WIDTH="135"32-bit integerLEFT="220" WIDTH="126"longLEFT="0" WIDTH="72"fLEFT="80" WIDTH="135"32-bit floating pointLEFT="220" WIDTH="126"floatLEFT="0" WIDTH="72"dLEFT="80" WIDTH="135"64-bit floating pointLEFT="220" WIDTH="126"doubleLEFT="0" WIDTH="72"ubLEFT="80" WIDTH="135"8-bit unsigned integerLEFT="220" WIDTH="126"unsigned charLEFT="0" WIDTH="72"usLEFT="80" WIDTH="135"16-bit unsigned integerLEFT="220" WIDTH="126"unsigned shortLEFT="0" WIDTH="72"uiLEFT="80" WIDTH="135"32-bit unsigned integerLEFT="220" WIDTH="126"unsigned longThe final character, if present, is v. The v indicates that the command takes a pointer to an array of valuesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'a vectorname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'rather than a series of individual arguments. The IRIS GL used a similar mechanism for some commands. The predecessor to glVertex(), for example, was v(), which also used a suffix to specify the number and type of its arguments.Here are some examples of OpenGL command naming:void glVertex2i( GLint x, GLint y) ;void glVertex3f( GLfloat x, GLfloat y, GLfloat z);
void glVertex3dv( const GLdouble *v) ;The first version of the vertex call, glVertex2i(), takes two integer arguments. The second, glVertex3f(), is a three-dimensional version, which expects three floats. The third version, glVertex3dv() expects an argument in the form of a vector, which is a pointer to an array. In this case, the array should have three elements.LBL="" HELPID=""ID="68221"OpenGL Defined TypesIDREF="39486" TYPE="TABLE"Table C-2 lists C data types and their equivalent OpenGL defined types.COLUMNS="2"LBL="C-2"Table C-2 ID="39486"OpenGL Equivalents to C Data TypesLEFT="0" WIDTH="171"C TypeLEFT="180" WIDTH="162"Equivalent OpenGL TypeLEFT="0" WIDTH="171"bitmask valueLEFT="180" WIDTH="162"GLbitfieldLEFT="0" WIDTH="171"boolean valueLEFT="180" WIDTH="162"GLbooleanLEFT="0" WIDTH="171"doubleLEFT="180" WIDTH="162"GLdoubleLEFT="0" WIDTH="171"double value clamped to [ 0.0, 1.0 ]LEFT="180" WIDTH="162"GLclampdLEFT="0" WIDTH="171"enumerated typeLEFT="180" WIDTH="162"GLenumLEFT="0" WIDTH="171"floatLEFT="180" WIDTH="162"GLfloatLEFT="0" WIDTH="171"float value clamped to [ 0.0, 1.0 ]LEFT="180" WIDTH="162"GLclampfLEFT="0" WIDTH="171"longLEFT="180" WIDTH="162"GLintLEFT="0" WIDTH="171"shortLEFT="180" WIDTH="162"GLshortLEFT="0" WIDTH="171"signed charLEFT="180" WIDTH="162"GLbyteLEFT="0" WIDTH="171"unsigned charLEFT="180" WIDTH="162"GLubyteLEFT="0" WIDTH="171"unsigned intLEFT="180" WIDTH="162"GLuintLEFT="0" WIDTH="171"unsigned shortLEFT="180" WIDTH="162"GLushortLEFT="0" WIDTH="171"voidLEFT="180" WIDTH="162"GLvoidLBL="" HELPID=""ID="99378"Error HandlingWhen an error occurs, OpenGL sets an error flag to the appropriate error value. You can test error conditions using the glGetError() call, which returns the error number. IDREF="21378" TYPE="TABLE"Table C-3 lists possible error values. For details, see the reference page for glGetError().COLUMNS="3"LBL="C-3"Table C-3 ID="21378" glGetError() Return ValuesLEFT="0" WIDTH="113"ErrorLEFT="120" WIDTH="113"DescriptionLEFT="240" WIDTH="104"Command Ignored?LEFT="0" WIDTH="113"NO_ERRORLEFT="120" WIDTH="113"No errorLEFT="240" WIDTH="104"NoLEFT="0" WIDTH="113"INVALID_ENUMLEFT="120" WIDTH="113"enumerated argument out 
of rangeLEFT="240" WIDTH="104"YesLEFT="0" WIDTH="113"INVALID_VALUELEFT="120" WIDTH="113"Numeric argument out of 
rangeLEFT="240" WIDTH="104"YesLEFT="0" WIDTH="113"INVALID_OPERATIONLEFT="120" WIDTH="113"Operation illegal in current 
stateLEFT="240" WIDTH="104"YesLEFT="0" WIDTH="113"STACK_OVERFLOWLEFT="120" WIDTH="113"Command would cause a 
stack overflowLEFT="240" WIDTH="104"YesLEFT="0" WIDTH="113"STACK_UNDERFLOWLEFT="120" WIDTH="113"Command would cause a 
stack underflowLEFT="240" WIDTH="104"YesLEFT="0" WIDTH="113"OUT_OF_MEMORYLEFT="120" WIDTH="113"Not enough memory left to 
execute commandLEFT="240" WIDTH="104"UnknownLBL="D"ID="13844"Example OpenGL Program with the Auxiliary LibraryThis program uses OpenGL and the auxiliary library to display a planet rotating around the sun. It demonstrates how to composite modeling transformations to draw translated and rotated models. Pressing the left, right, up, and down arrow keys alters the rotation of the planet around the sun./*
 *  planet.c
 */

#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"

static int year = 0, day = 0;

void dayAdd (void)
{
    day = (day + 10) % 360;
}

void daySubtract (void)
{
    day = (day - 10) % 360;
}

void yearAdd (void)
{
    year = (year + 5) % 360;
}
void yearSubtract (void)
{
    year = (year - 5) % 360;
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT);

    glColor3f (1.0, 1.0, 1.0);
    glPushMatrix();
/*      draw sun        */
    auxWireSphere(1.0);
/*      draw smaller planet     */
    glRotatef ((GLfloat) year, 0.0, 1.0, 0.0);
    glTranslatef (2.0, 0.0, 0.0);
    glRotatef ((GLfloat) day, 0.0, 1.0, 0.0);
    auxWireSphere(0.2);
    glPopMatrix();
    glFlush();
}

void myinit (void) {
    glShadeModel (GL_FLAT);
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(60.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef (0.0, 0.0, -5.0);
}
/*  Main Loop
 *  Open window with initial window size, title bar,
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit ();
    auxKeyFunc (AUX_LEFT, yearSubtract);
    auxKeyFunc (AUX_RIGHT, yearAdd);
    auxKeyFunc (AUX_UP, dayAdd);
    auxKeyFunc (AUX_DOWN, daySubtract);
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
LBL="E"ID="77823"Example Mixed-Model Program with WorkProcThis appendix contains an example mixed model program that uses Xt, IRIS IM, and the IRIS IM version of the Silicon Graphics widget. The program displays a planet with a moon, orbiting a sun, and uses WorkProc for the animation./* opensolar.c
 * opensolar displays a planet with a moon, orbiting a sun.
 * To compile:
 * cc -O -o opensolar opensolar.c -lXm -lGLw -lm -lGLU -lGL
 */

#include <Xm/Xm.h>
#include <Xm/Frame.h>
#include <Xm/Form.h>
#include <X11/keysym.h>
#include <X11/StringDefs.h>
#include <GL/GLwMDrawA.h>

#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glx.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "malloc.h"

typedef struct _spin {
  short year;
} SPINDATA, *SPINPTR;

/* function prototypes */
void main(int argc, char **argv);
void initCB (Widget w, XtPointer client_data,
             XtPointer call_data);
void exposeCB (Widget w, XtPointer spin,
               XtPointer call_data);
void resizeCB (Widget w, XtPointer spin,
               XtPointer call_data);
void inputCB (Widget w, XtPointer client_data,
              XtPointer call_data);
Boolean drawWP (XtPointer spin);
void drawscene(SPINPTR spin);
void setbeachball(int stripes);
void beachball(unsigned long color1, unsigned long color2);

XtAppContext app_context;
XtWorkProcId workprocid = NULL;

GLXContext glx_context;
Display * global_display;
Window global_window;


/* main
 * This program shows a solar system, with a sun, planet, and
 * moon (in OpenGL). The user can exit with the ESCape key
 * or through the window manager menu.
 */
void main(int argc, char **argv)
{
  Arg wargs[15];
  int n;
  Widget glw, toplevel, frame, form;
  SPINPTR spin;
  static String fallback_resources[] = {
    "*frame*shadowType: SHADOW_IN", "*glwidget*width: 750",
    "*glwidget*height: 600", "*glwidget*rgba: TRUE",
    "*glwidget*doublebuffer: TRUE",
    "*glwidget*allocateBackground: TRUE", NULL
  };

  /* create main data structure, spin pointer */
  spin = (SPINPTR) malloc (sizeof (SPINDATA));
  spin->year = 0;
  toplevel = XtAppInitialize(
     &app_context, /* Application context */
     "Opensolar", /* Application class */
     NULL, 0, /* command line option list */
     &argc, argv, /* command line args */
     fallback_resources,
     NULL, /* argument list */
     0); /* number of arguments */

  n = 0;
  form = XmCreateForm(toplevel, "form", wargs, n);
  XtManageChild(form);

  n = 0;
  XtSetArg(wargs[n], XtNx, 30); 
  n++;
  XtSetArg(wargs[n], XtNy, 30); 
  n++;
  XtSetArg(wargs[n], XmNbottomAttachment, XmATTACH_FORM); 
  n++;
  XtSetArg(wargs[n], XmNleftAttachment, XmATTACH_FORM); 
  n++;
  XtSetArg(wargs[n], XmNrightAttachment, XmATTACH_FORM); 
  n++;
  XtSetArg(wargs[n], XmNtopAttachment, XmATTACH_FORM); 
  n++;
  XtSetArg(wargs[n], XmNleftOffset, 30); 
  n++;
  XtSetArg(wargs[n], XmNbottomOffset, 30); 
  n++;
  XtSetArg(wargs[n], XmNrightOffset, 30); 
  n++;
  XtSetArg(wargs[n], XmNtopOffset, 30); 
  n++;
  frame = XmCreateFrame (form, "frame", wargs, n);
  XtManageChild (frame);

  n = 0;
  glw = GLwCreateMDrawingArea(frame, "glwidget", wargs, n);
  XtManageChild (glw);
  XtAddCallback(glw, GLwNginitCallback, initCB,
                (XtPointer) NULL);
  XtAddCallback(glw, GLwNexposeCallback, exposeCB,
                (XtPointer) spin);
  XtAddCallback(glw, GLwNresizeCallback, resizeCB,
                (XtPointer) spin);
  XtAddCallback(glw, GLwNinputCallback, inputCB,
                (XtPointer) NULL);

  XtRealizeWidget(toplevel); /* instantiate it now */
  XtAppMainLoop(app_context); /* loop for events */
} /* end main() */


/* initCB 
 * The initCB subroutine initializes graphics modes and
 * transformation matrices.
 */
void initCB (Widget w, XtPointer client_data,
             XtPointer call_data)
{
  Arg args[1];
  XVisualInfo *vi;

  XtSetArg(args[0], GLwNvisualInfo, &vi);
  XtGetValues(w, args, 1);

  global_display = XtDisplay(w);
  global_window = XtWindow(w);
  glx_context = glXCreateContext(global_display, vi, 0,
                                 GL_FALSE);
} /* end initCB() */


/* exposeCB() and resizeCB() are called when the window
 * is uncovered, moved, or resized.
 */
void exposeCB (Widget w, XtPointer ptr, XtPointer call_data)
{
  SPINPTR spin;
  static char firstTime = 0x1;
  GLwDrawingAreaCallbackStruct *call_ptr;

  call_ptr = (GLwDrawingAreaCallbackStruct *) call_data;
  GLwDrawingAreaMakeCurrent(w, glx_context);
  if (firstTime) {
    glClearColor(0.0, 0.0, 0.0, 0.0);
    glShadeModel (GL_FLAT);
    glEnable(GL_DEPTH_TEST);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity ();
    gluPerspective(45.0, (GLfloat)(call_ptr->width)
                   /(GLfloat)(call_ptr->height), 1.0, 25.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity ();
    glTranslatef(0.0, 0.0, -12.0);
    workprocid = XtAppAddWorkProc(app_context, drawWP, ptr);
      /* ptr is spin */
    firstTime = 0;
  }
  spin = (SPINPTR) ptr;
  drawscene(spin);
}

void resizeCB (Widget w, XtPointer ptr, XtPointer call_data)
{
  GLwDrawingAreaCallbackStruct *call_ptr;
  SPINPTR spin;

  spin = (SPINPTR) ptr;
  call_ptr = (GLwDrawingAreaCallbackStruct *) call_data;
  GLwDrawingAreaMakeCurrent(w, glx_context);
  glViewport (0, 0, (GLsizei) (call_ptr->width-1),
              (GLsizei) (call_ptr->height-1));
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity ();
  gluPerspective(45.0, (GLfloat)(call_ptr->width) /
                 (GLfloat)(call_ptr->height), 1.0, 25.0);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity ();
  glTranslatef(0.0, 0.0, -12.0);
  drawscene(spin);
}


/* inputCB() handles all types of input from the GL widget.
 * The KeyRelease handles the ESCape key, so that it exits
 * the program. 
 */
void inputCB (Widget w, XtPointer client_data,
              XtPointer call_data)
{
  char buffer[1];
  KeySym keysym;
  GLwDrawingAreaCallbackStruct *call_ptr;
  XKeyEvent *kevent;

  call_ptr = (GLwDrawingAreaCallbackStruct *) call_data;
  kevent = (XKeyEvent *) (call_ptr->event);
  switch(call_ptr->event->type) {
  case KeyRelease:
    /* Must convert the keycode to a keysym before
     * checking if it is an escape
     */
    if (XLookupString(kevent,buffer,1,&keysym,NULL) == 1 
                      && keysym == (KeySym)XK_Escape)
      exit(0);
    break;
  default:
    break;
  }
}


/* drawWP() is called by the WorkProc. When the scene
 * is in automatic motion, the WorkProc calls this routine,
 * which adds 1 degree (10 tenths) to the cumulative amount
 * of rotation. drawscene() is called, so the image is
 * redrawn. It returns(FALSE) so the WorkProc does not
 * discontinue operation.
 */
Boolean drawWP (XtPointer ptr)
{
  SPINPTR spin;

  spin = (SPINPTR) ptr;
  spin->year = (spin->year + 10) % 3600;
  drawscene (spin);
  return (FALSE);
}

/* drawscene
 * drawscene calculates angles relative to the spin->year
 * and then draws sun, planet, and moon.
 */
void drawscene(SPINPTR spin)
{
  short sunangle;
  /* actual dist is 1.5e8 km; mult by 3.0e-8 fudgefactor */
  float earthdist = 4.5;
  short dayangle;
  float earthscale = 0.5;
  short monthangle;
  float moondist = 0.9;
  float moonscale = 0.2;

  glClear(GL_DEPTH_BUFFER_BIT|GL_COLOR_BUFFER_BIT);

  glPushMatrix();
  glRotatef(10.0, 1.0, 0.0, 0.0); /* tilt entire scene */
  glPushMatrix();
  sunangle = (spin->year*365/25) % 3600;
  /* sun rotates on axis every 25 days */
  glRotatef(.1*(sunangle), 0.0, 1.0, 0.0);
  /* cpack format color1, color2 */
  /* swapped by hand: was beachball(0x20C0FF, 0x200FFFF); */
  beachball(0xFFC02000, 0xFFFF0020);
  glPopMatrix();
  glPushMatrix();
  glRotatef(.1*(spin->year), 0.0, 1.0, 0.0);
  glTranslatef(earthdist, 0.0, 0.0);
  glPushMatrix();
  dayangle = (spin->year*50) % 3600;
  /* dayangle fudged so earth rotation can be seen */
  glRotatef(.1*(dayangle), 0.0, 1.0, 0.0);
  glScalef(earthscale, earthscale, earthscale);
  glColor3f(0.0, 0.0, 1.0);
  /* swap by hand; was beachball(0xFF0000, 0xC02000);*/
  beachball(0x0000FF00, 0x0020C000); /* earth */
  glPopMatrix();
  monthangle = (spin->year*365/28) % 3600;
  glRotatef(.1*(monthangle), 0.0, 1.0, 0.0);
  glTranslatef(moondist, 0.0, 0.0);
  glScalef(moonscale, moonscale, moonscale);
  glColor3f(1.0, 1.0, 1.0);
  /* swap by hand; was beachball(0xFFFFFF, 0xC0C0C0); */
  beachball(0xFFFFFF00, 0xC0C0C000); /* moon */
  glPopMatrix();
  glPopMatrix();
  glXSwapBuffers(global_display, global_window);
} /* end drawscene() */


/*
 * BEACHBALL
 */

/* three dimensional vector */
typedef float vector[3];
vector front =  { 0.0, 0.0, 1.0 };
vector back =   { 0.0, 0.0, -1.0 };
vector top =    { 0.0, 1.0, 0.0 };
vector bottom = { 0.0, -1.0, 0.0 };
vector right =  { 1.0, 0.0, 0.0 };
vector left =   { -1.0, 0.0, 0.0 };
vector center = { 0.0, 0.0, 0.0 };

/* Number of colored stripes. Should be even to look right */
#define BEACHBALL_STRIPES 12
/* Default number of polygons making up a stripe. Should */
/* be even */
#define BEACHBALL_POLYS 16

/* array of vertices making up a stripe */
vector stripe_point[BEACHBALL_POLYS + 3];

/* has the beachball been initialized */
Boolean beachball_initialized = FALSE;

/* Number of polygons making up a stripe */
int beachball_stripes;

/* Number of vertices making up a stripe */
int stripe_vertices;

/* Initializes beachball_point array to a stripe of unit */
/* radius. */
void setbeachball(int stripes)
{
  int i,j;
  float x,y,z; /* vertex points */
  float theta,delta_theta; /* angle from top pole to bottom*/
  float offset; /* offset from center of stripe to vertex */
  /* radius of cross-section at current latitude */
  float cross_radius;
  float cross_theta; /* angle occupied by a stripe */

  beachball_stripes = stripes;

  /* polys distributed by even angles from top to bottom */
  delta_theta = M_PI/((float)BEACHBALL_POLYS/2.0);
  theta = delta_theta;
  cross_theta = 2.0*M_PI/(float)beachball_stripes;

  j = 0;
  stripe_point[j][0] = top[0];
  stripe_point[j][1] = top[1];
  stripe_point[j][2] = top[2];
  j++;

  for (i = 0; i < BEACHBALL_POLYS; i += 2) {
    cross_radius = fsin(theta);
    offset = cross_radius * ftan(cross_theta/2.0);

    stripe_point[j][0] = - offset;
    stripe_point[j][1] = fcos(theta);
    stripe_point[j][2] = cross_radius;
    j++;

    stripe_point[j][0] = offset;
    stripe_point[j][1] = stripe_point[j-1][1];
    stripe_point[j][2] = stripe_point[j-1][2];
    j++;

    theta += delta_theta;
  } /* end for */

  stripe_point[j][0] = bottom[0];
  stripe_point[j][1] = bottom[1];
  stripe_point[j][2] = bottom[2];

  stripe_vertices = j + 1;

  beachball_initialized = TRUE;
}


/* Draws a canonical beachball. The colors are cpack values
 * when in RGBmode.
 */
void beachball(unsigned long c1, unsigned long c2)
{
  float angle, delta_angle;
  int i, j;

  if (! beachball_initialized)
    setbeachball(BEACHBALL_STRIPES);

  angle = 0.0;
  delta_angle = 360.0/(float)beachball_stripes;

  for (i = 0; i < beachball_stripes; i++) {
    if ( i%2 == 0)
      glColor4ubv((GLubyte *)(&c1));
    else
      glColor4ubv((GLubyte *)(&c2));
    glPushMatrix();
    glRotatef(angle, 0.0, 1.0, 0.0);
    angle += delta_angle;

    glBegin(GL_TRIANGLE_STRIP);
    for (j = 0; j < stripe_vertices; j++)
      glVertex3fv(stripe_point[j]);
    glEnd();
    glPopMatrix();
  }
}
LBL="F"ID="77823"Example Mixed-Model Programs With XlibThis appendix contains two example mixed-model programs that use Xlib. Each example program is shown first in IRIS GL, then in OpenGL. LBL="" HELPID=""Example One: iobounce.ciobounce.c is a simple interactive program that bounces a ball around a 2D surface. Users can use the mouse buttons to change the velocity of the ball. The IRIS GL version of the program is presented first, then the OpenGL version.LBL="" HELPID=""IRIS GL VersionHere's the IRIS GL version of iobounce.c. This is a "pure" IRIS GL program, meaning that it does not contain X calls./*                    iobounce.c:
 *   "pool" ball that "bounces" around a 2-d "surface". 
 *                RIGHTMOUSE stops ball
 *                MIDDLEMOUSE increases y velocity
 *                LEFTMOUSE increases x velocity
 */

#include <stdio.h>
#include <gl/gl.h>
#include <gl/device.h>

long xmaxscrn, ymaxscrn;  /* maximum size of screen in x and y */

#define XMIN 100
#define YMIN 100
#define XMAX 900
#define YMAX 700

long xvelocity = 0, yvelocity = 0;

main()
{
    Device dev;
    short val;
    long sizex, sizey;

    initialize();

    while (TRUE) {
       while (qtest()) {
          dev = qread(&val);
          switch (dev) {
                case REDRAW:  /* redraw window re: move/resize/push/pop */
                    reshapeviewport();
                    ortho2(XMIN - 0.5, XMAX + 0.5, YMIN - 0.5,
                           YMAX + 0.5);
                    drawball();
                    break;
                case LEFTMOUSE:     /* increase xvelocity */
                    if (xvelocity >= 0)
                        xvelocity++;
                    else
                        xvelocity--;
                    break;
                case MIDDLEMOUSE:   /* increase yvelocity */
                    if (yvelocity >= 0)
                        yvelocity++;
                    else
                        yvelocity--;
                    break;
                case RIGHTMOUSE:     /* stop ball */
                    xvelocity = yvelocity = 0;
                    break;
                case ESCKEY:
                    gexit();
                    exit(0);
            }
        }
        drawball();
    }
}

initialize() {

    xmaxscrn = getgdesc(GD_XPMAX)-1;
    ymaxscrn = getgdesc(GD_YPMAX)-1;
    prefposition(xmaxscrn/4,xmaxscrn*3/4,ymaxscrn/4,ymaxscrn*3/4);
    winopen("iobounce");
    winconstraints();

    doublebuffer();
    gconfig();
    shademodel(FLAT);

    ortho2(XMIN - 0.5, XMAX + 0.5, YMIN - 0.5, YMAX + 0.5);

    qdevice(ESCKEY);
    qdevice(LEFTMOUSE);
    qdevice(MIDDLEMOUSE);
    qdevice(RIGHTMOUSE);
}

drawball() {
    static xpos = 500,ypos = 500;
    long radius = 10;

    color(BLACK);
    clear();
    xpos += xvelocity;
    ypos += yvelocity;
    if (xpos > XMAX - radius ||
        xpos < XMIN + radius) {
        xpos -= xvelocity;
        xvelocity = -xvelocity;
    }
    if (ypos > YMAX - radius ||
        ypos < YMIN + radius) {
        ypos -= yvelocity;
        yvelocity = -yvelocity;
    }
    color(YELLOW);
    circfi(xpos, ypos, radius);
    swapbuffers();
}LBL="" HELPID=""OpenGL Version of iobounce.cHere's the OpenGL version of iobounce.c. Windowing and event handling are now controlled with Xlib, rather than IRIS GL calls./*                   iobounce.c:
 *
 *   "pool ball" that "bounces" around a 2-d "surface". 
 *            RIGHTMOUSE stops ball
 *            MIDDLEMOUSE increases y velocity
 *            LEFTMOUSE increases x velocity
 *
 *           (ported from ~4Dgifts/example/grafix/iobounce.c)
 */

#include <GL/glx.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <stdio.h>
#include <stdlib.h>
#include <X11/keysym.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>

#define XMIN 100
#define YMIN 100
#define XMAX 900
#define YMAX 700

#define BLACK           0
#define YELLOW          3

#define LEFTMOUSE       3
#define MIDDLEMOUSE     2
#define RIGHTMOUSE      1

#define TRUE            1
#define FALSE           0

long xmaxscrn, ymaxscrn; /* maximum size of screen /*
                         /* in x and y */

Display *dpy;            /* The X server connection */
Atom del_atom;           /* WM_DELETE_WINDOW atom   */
Window glwin;            /* handle to the GL window */
XEvent event;

static void openwindow(char *);
static void drawball(void);
static void clean_exit(void);

long xvelocity = 0, yvelocity = 0;

main(int argc, char *argv[])
{
    int myExpose, myConfigure,
        myButtRelease, myKeyPress,
        myButtonNumber;   /* store which events occur */
    long xsize, ysize;



    myExpose = myConfigure = myButtRelease = myKeyPress =
               myButtonNumber = FALSE;

    openwindow(argv[0]);

    while (TRUE) {

        KeySym keysym;
        char buf[4];

    /* this "do while" loop does the `get events' half of the     */
    /* "get events,process events" action of the infinite while.  */
    /* This is to ensure the event queue is always drained before */
    /* the events that have come in are processed.                */
    while (XEventsQueued(dpy,QueuedAfterReading)) { /* end "do { } while"
                       * XEventsQueued(dpy,QueuedAfterReading)
                       * is like qtest()--it only tells you if 
                       * there're any events presently in the 
                       * queue.it does not disturb the event
                       * queue's contents in any way.       */

            XNextEvent(dpy, &event);
            switch (event.type) {

            /* "Expose" events are sort of like "REDRAW" in gl-speak in
             * terms of when a window or a previously invisible part
             * becomes visible */
                case Expose:   /* Exposures */
                    myExpose = TRUE;
                    break;

            /* "ConfigNotify" events are like "REDRAW" in terms of changes to
             * a window's size or position.*/
                case ConfigureNotify:  /* Resize GL manually */
                    xsize = event.xconfigure.width;
                    ysize = event.xconfigure.height;
                    myConfigure = TRUE;
                    break;

            /* Wait for "ButtonRelease" events so the queue doesn't fill up
             * the way it would if the user sits on ButtonPresss. */
                case ButtonRelease:
                    if (event.xbutton.button == Button1) {  
                        myButtonNumber = LEFTMOUSE;        
                        myButtRelease = TRUE;             
                    } else if (event.xbutton.button ==
                               Button2) {
                        myButtonNumber = MIDDLEMOUSE;
                        myButtRelease = TRUE;      
                    } else if (event.xbutton.button ==
                               Button3) {
                        myButtonNumber = RIGHTMOUSE;
                        myButtRelease = TRUE; 
                    }  /* twirl the green sphere */
                    break;

            /* "ClientMessage" is generated if the WM itself is dying
             * and sends an exit signal to any running prog. */
                case ClientMessage:
                    if (event.xclient.data.l[0] == del_atom)
                        clean_exit();
                    break;

            /* "KeyPress" events are those that would be generated before
             * whenever queueing up any KEYBD key via qdevice. */
                case KeyPress:
                   /* save out which unmodified key (i.e. the key was not
                    * modified w/something like "Shift", "Ctrl", or "Alt")
                    * got pressed for use below. */
                    XLookupString((XKeyEvent *)&event, buf, 4, &keysym, 0);
                    myKeyPress = TRUE;
                    break;

            }  /* end switch (event.type) */
        }

    /* On an "Expose" event, redraw the affected pop'd or
     * de-iconized window
     */
        if (myExpose) {
            drawball();       /* draw the GL stuff */
            myExpose = FALSE; /* reset flag--queue now empty */
        }

    /* On a "ConfigureNotify" event, the GL window has either
     * been moved or resized.  Respond accordingly and then
     * redraw its contents.
     */

        if (myConfigure) {
            glViewport(0, 0, xsize, ysize);
            glLoadIdentity();
            gluOrtho2D(XMIN-0.5, XMAX+0.5, YMIN-0.5, YMAX+0.5);
            drawball();           /* draw the GL stuff */
            myConfigure = FALSE;  /* reset flag--queue now
                                   * empty */
        }

    /* On a "ButtonRelease" event, myButtonNumber stores which
     * mouse button was pressed/released and then we update
     * x/yvelocity accordingly
     * /
        if (myButtRelease) {
            if (myButtonNumber == LEFTMOUSE) {  /* increase
                                                   xvelocity */
                if (xvelocity >= 0)
                    xvelocity += 3;
                else
                    xvelocity -= 3;
            } else if (myButtonNumber == MIDDLEMOUSE) {
                                                 /* increase yvelocity*/
                if (yvelocity >= 0)
                    yvelocity += 3;
                else
                    yvelocity -= 3;
            } else if (myButtonNumber == RIGHTMOUSE) {
                                               /* stop ball */
                xvelocity = yvelocity = 0;
            } else {
                fprintf(stderr,"ERROR: %s thinks 
                        mouse button # ");
                fprintf(stderr,"%d was
                        pressed(?)\n",argv[0],myButtonNumber);
            }
            drawball();
            myButtRelease = FALSE;
        }

        /* On a keypress of Esc key, exit program. */
        if (myKeyPress) {
            if (keysym == XK_Escape)
                clean_exit();
        }

        drawball();

    }
}

static int attributeList[] = { GLX_DOUBLEBUFFER, 
                               None };
GLUquadricObj *qobj; 

static Bool WaitForNotify(Display *d, XEvent *e, char *arg) {
    return (e->type == MapNotify) && (e->xmap.window ==
                                      (Window)arg);
}

static void openwindow(char *progname) {

    int scrnnum;       /* X screen number  */    
    int xorig, yorig;  /* window (upper-left) origin */
    XVisualInfo *vi;
    GLXContext cx;
    Colormap cmap;
    XSizeHints Winhints;/* used to fix window size */
    XSetWindowAttributes swa;
    XColor colorstruct;

    /* Connect to the X server and get screen info */
    if ((dpy = XOpenDisplay(NULL)) == NULL) {
        fprintf(stderr, "%s: cannot connect to X server %s\n",
                                 progname, XDisplayName(NULL));
        exit(1);
    }
    scrnnum = DefaultScreen(dpy);
    ymaxscrn = DisplayHeight(dpy, scrnnum);
    xmaxscrn = DisplayWidth(dpy, scrnnum);

    /* get an appropriate visual */
    vi = glXChooseVisual(dpy, DefaultScreen(dpy),
                         attributeList);
    if (vi == NULL) {
        printf("Couldn't get visual.\n");
        exit(0);
    }

    /* create a GLX context */
    cx = glXCreateContext(dpy, vi, None, GL_TRUE);

    if (cx == NULL) {
        printf("Couldn't get context.\n");
        exit(0);
    }

    /* create a colormap */
    cmap = XCreateColormap(dpy, RootWindow(dpy, vi->screen),
                           vi->visual, AllocAll);

    XSync(dpy, 0);
    /* create a window */
    swa.colormap = cmap;
    swa.border_pixel = 0;

    /* express interest in certain events */
    swa.event_mask = StructureNotifyMask | KeyPressMask |
                     ButtonPressMask |
                     ButtonReleaseMask | ExposureMask;
    glwin = XCreateWindow(dpy, RootWindow(dpy, vi->screen), 
                          10, 10, 300, 300,
                          0, vi->depth, InputOutput,
                          vi->visual,
                          CWBorderPixel|CWColormap|CWEventMask, &swa);

    XMapWindow(dpy, glwin);
    XIfEvent(dpy, &event, WaitForNotify, (char*)glwin);

    /* connect the context to the window */
    glXMakeCurrent(dpy, glwin, cx);

   /* express interest in WM killing this app */
    if ((del_atom = XInternAtom(dpy, "WM_DELETE_WINDOW",
                                True)) != None)
        XSetWMProtocols(dpy, glwin, &del_atom, 1);

    colorstruct.pixel = BLACK;    
    colorstruct.red   = 0;
    colorstruct.green = 0;
    colorstruct.blue  = 0;
    colorstruct.flags = DoRed | DoGreen | DoBlue;
    XStoreColor(dpy, cmap, &colorstruct);
    colorstruct.pixel = YELLOW;
    colorstruct.red   = 65535;
    colorstruct.green = 65535;
    colorstruct.blue  = 0;
    colorstruct.flags = DoRed | DoGreen | DoBlue;
    XStoreColor(dpy, cmap, &colorstruct);

    glLoadIdentity();
    gluOrtho2D(XMIN - 0.5,  XMAX + 0.5,  YMIN - 0.5,  YMAX + 0.5);

    /* clear the buffer */
    glClearIndex((GLfloat)BLACK);
    qobj = gluNewQuadric(); 
    gluQuadricDrawStyle(qobj,GLU_FILL);
    glFlush();
}

static void drawball(void) {
    static int xpos = 500, ypos = 500;
    GLdouble radius = 14.0;

    glClear(GL_COLOR_BUFFER_BIT);
    xpos += xvelocity;
    ypos += yvelocity;
    if (xpos > XMAX - radius || xpos < XMIN + radius) {
        xpos -= xvelocity;
        xvelocity = -xvelocity;
    }
    if (ypos > YMAX - radius || ypos < YMIN + radius) {
        ypos -= yvelocity;
        yvelocity = -yvelocity;
    }

    glIndexi(YELLOW);
    glPushMatrix(); 
    glTranslatef(xpos,  ypos, 0.); 
    gluDisk( qobj, 0., radius, 10, 1); 
    glPopMatrix(); 
    glXSwapBuffers(dpy, glwin);
}

/*  clean_exit  --  Clean up before exiting */
static void clean_exit(void)
{
    gluDeleteQuadric(qobj); 
    XCloseDisplay(dpy);
    exit(0);
}LBL="" HELPID=""Example Two: zrgb.cHere's another example program, zrgb.c. This program includes zbuffering. This program won't work on 8-bit IRIS workstations. Again, the IRIS GL version is presented first. LBL="" HELPID=""IRIS GL Version of zrgb.cHere's the IRIS GL version of zrgb.c. Like iobounce.c, this is a pure IRIS GL program./*                  zrgb.c
 *
 *  This program demostrates zbuffering 3 intersecting RGB
 *  polygons while in doublebuffer mode where,movement of the
 *  mouse with the LEFTMOUSE button depressed will, rotate the 3
 *  polygons. This is done via compound rotations allowing
 *  continuous screen-oriented rotations. (See orient(),
 *  and draw_scene() below).  Notice the effective way there
 *  is no wasted CPU usage when the user moves the mouse out
 *  of the window without holding down LEFTMOUSE--there is no
 *  qtest being performed and so the program simply blocks on
 *  the qread statement. Press the "Esc"[ape] key to exit.
 *  Please note that this program will not work on any 8-bit
 *  IRIS machine.
 *                                          ratman - 1989
 */

#include <stdio.h>
#include <gl/gl.h>
#include <gl/device.h>

Matrix objmat = {
    {1.0, 0.0, 0.0, 0.0},
    {0.0, 1.0, 0.0, 0.0},
    {0.0, 0.0, 1.0, 0.0},
    {0.0, 0.0, 0.0, 1.0},
};

Matrix idmat = {
    {1.0, 0.0, 0.0, 0.0},
    {0.0, 1.0, 0.0, 0.0},
    {0.0, 0.0, 1.0, 0.0},
    {0.0, 0.0, 0.0, 1.0},
};

/* Modes the program can be in */
#define NOTHING 0
#define ORIENT 1

int mode = 0;
int omx, mx, omy, my;  /* old and new mouse position */
float scrnaspect;      /* aspect ratio value         */
long zfar;             /* holds specific machine's   */
                       /* maximum Z depth value      */

main(argc, argv)
int argc;
char *argv[];
{
    long dev;
    short val;
    int redrawneeded=TRUE;  /* Is true when the scene */
                            /* needs redrawing */

    initialize(argv[0]);

    while (TRUE) {

        if (redrawneeded) {
            draw_scene();
            redrawneeded=FALSE;
        }

        while (qtest() || (!redrawneeded)) {

            switch(dev=qread(&val)) {

            case ESCKEY:   /* exit when key is going up, */
                           /* not down                   */
                if (val)   /* this avoids the scenario   */
                           /* where a window             */
                    break; /* underneath this program's  */
                           /* window--say                */
                exit(0);   /* another copy of this       */
                           /* program--getting the       */
                           /* ESC UP event and exiting   */
                           /* also.                      */
            case REDRAW:
                reshapeviewport();
                redrawneeded=TRUE;
                break;

            case LEFTMOUSE:
                if (val) {
                    mode = ORIENT;
                    omx = mx;
                    omy = my;
                } else 
                    mode = NOTHING;
                break;

            case MOUSEX:
                omx = mx; 
                mx = val;
                if (mode == ORIENT) {
                    update_scene();
                    redrawneeded=TRUE;
                }
                break;

            case MOUSEY:
                omy = my;
                my = val;
                if (mode == ORIENT) {
                    update_scene();
                    redrawneeded=TRUE;
                }
                break;
            }
        }
    }
}


initialize(progname)
char *progname;
{

    long xscrnsize;   /* size of screen in x used
                       * to set globals  */    
    long testifZinst;

    /*
     * This program requires the following to run:
     *  -- z buffer
     *  -- ability to do double-buffered RGB mode
     */
    /* Test for Z buffer */
    testifZinst = getgdesc(GD_BITS_NORM_ZBUFFER);
    if (testifZinst == FALSE) {
         fprintf(stderr,"BUMmer!--%s won't work on ",
                         progname);
         fprintf(stderr,"this machine--zbuffer option not
                         installed.\n");
         exit(0);
    }
    /* Test for double-buffered RGB */
    if (getgdesc(GD_BITS_NORM_DBL_RED) == 0) {
         fprintf(stderr,"BUMmer!--%s won't work on ",
                         progname);
         fprintf(stderr,"this machine--not enough
                         bitplanes.\n");
         exit(0);
        
    }

    /* Code to keep same aspec ratio as the screen */
    keepaspect(getgdesc(GD_XMMAX), getgdesc(GD_YMMAX));
    scrnaspect =
           (float)getgdesc(GD_XMMAX)/(float)getgdesc(GD_YMMAX);

    winopen(progname);
    wintitle("Zbuffered RGB #1");

    doublebuffer();
    RGBmode();
    gconfig();
    zbuffer(TRUE);
    glcompat(GLC_ZRANGEMAP, 0);
    zfar = getgdesc(GD_ZMAX);

    qdevice(ESCKEY);
    qdevice(LEFTMOUSE);
    qdevice(MOUSEX);
    qdevice(MOUSEY);
}

update_scene() {

    switch (mode) {

        case ORIENT:
            orient();
            break;
    }
}

orient () {

    pushmatrix();

    loadmatrix(idmat);

    rotate(mx-omx, 'y');
    rotate(omy-my, 'x');

    multmatrix(objmat);
    getmatrix(objmat);
    popmatrix();
}

draw_scene() {

    czclear(0x00C86428, zfar);

    perspective(400, scrnaspect, 30.0, 60.0);
    translate(0.0, 0.0, -40.0);
    multmatrix(objmat);
    rotate(-580, 'y');   /* skews original view 
                          * to show all polygons */
    draw_polys();

    swapbuffers();
}
float polygon1[3][3] = { {-10.0, -10.0,   0.0,},
                         { 10.0, -10.0,   0.0,},
                         {-10.0,  10.0,   0.0,} };

float polygon2[3][3] = { {  0.0, -10.0, -10.0,},
                         {  0.0, -10.0,  10.0,},
                         {  0.0,   5.0, -10.0,} };

float polygon3[4][3] = { {-10.0,   6.0,   4.0,},
                         {-10.0,   3.0,   4.0,},
                         {  4.0,  -9.0, -10.0,},
                         {  4.0,  -6.0, -10.0,} };

draw_polys() {

    bgnpolygon();
    cpack(0x00000000);
    v3f(&polygon1[0][0]);
    cpack(0x007F7F7F);
    v3f(&polygon1[1][0]);
    cpack(0x00FFFFFF);
    v3f(&polygon1[2][0]);
    endpolygon();
    bgnpolygon();
    cpack(0x0000FFFF);
    v3f(&polygon2[0][0]);
    cpack(0x007FFF00);
    v3f(&polygon2[1][0]);
    cpack(0x00FF0000);
    v3f(&polygon2[2][0]);
    endpolygon();

    bgnpolygon();
    cpack(0x0000FFFF);
    v3f(&polygon3[0][0]);
    cpack(0x00FF00FF);
    v3f(&polygon3[1][0]);
    cpack(0x00FF0000);
    v3f(&polygon3[2][0]);
    cpack(0x00FF00FF);
    v3f(&polygon3[3][0]);
    endpolygon();
}LBL="" HELPID=""OpenGL version of zrgb.cHere's the OpenGL version of zrgb.c./*
 *                     zrgb.c
 */
#include <GL/glx.h>
/*
#include <GL/gl.h>
#include <GL/glu.h>
*/
#include <stdio.h>
#include <stdlib.h>
#include <X11/keysym.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>

#define TRUE            1
#define FALSE           0

Display *dpy;         /* The X server connection */
Atom del_atom;        /* WM_DELETE_WINDOW atom   */
Window glwin;         /* handle to the GL window */
XEvent event;

/* function declarations */

static void openwindow(char *);
static void resize_buffer(void);
static void clean_exit(void);
void initGL(void);
void orient(void);
void drawScene(void);
void drawPolys(void);

static float objmat[16] = {
         1.0, 0.0, 0.0, 0.0,
         0.0, 1.0, 0.0, 0.0,
         0.0, 0.0, 1.0, 0.0,
         0.0, 0.0, 0.0, 1.0,
};

short ax, ay, az;     /* angles for the "twirling" green
                       * sphere to ride on */
long xsize, ysize;    /* current size-of-window keepers */
long zfar;            /* used in czclear for the machine's
                       * zbuffer max */
long buffermode;      /* flag tracks current window
                       * (single or double) */
double scrnaspect;    /* aspect ratio value */
int xpos, ypos, oxpos, oypos; /* old and new mouse position */


main(argc,argv)
int argc;
char **argv;
{
    int myExpose, myConfigure, myButtPress, myKeyPress; 
    int needToDraw = 0;  /* don't set this to true until
                          * we get our first Expose event */

    myExpose = myConfigure = myButtPress = myKeyPress = FALSE;

    openwindow(argv[0]);
   
  
   /* start out making the singlebuffer window be 
    * our current GL window */
    initGL();     /* do GL init stuff */

    /*
     * The event loop.
     */
    while (1) {      /* standard logic:  get event(s), 
                      * process event(s) */

        XEvent event;
        KeySym keysym;
        char buf[4];

    /* this "do while" loop does the `get events' 
     * half of the "get events, process events" action 
     * of the infinite while. this is to ensure
     * the event queue is always drained before the events
     * that have come in are processed.
     */

        do {

            XNextEvent(dpy, &event);
                switch (event.type) {

            /* "Expose" events are sort of like "REDRAW" in
             * gl-speak in terms of when a window becomes
             * visible, or a previously
             * invisible part becomes visible.
             */
                case Expose:   /* Exposures */
                    needToDraw = myExpose = TRUE;
                    break;

            /* "ConfigNotify" events are like "REDRAW" in
             * terms of changes to a window's size or position.
             */
                case ConfigureNotify: /* Resize GL manually */
                    xsize = event.xconfigure.width;
                    ysize = event.xconfigure.height;
                    needToDraw = myConfigure = TRUE;
                    break;

            /* Wait for "MotionNotify" events so the 
             * queue doesn't fill up
             */
                case MotionNotify:                        
                    myButtPress = TRUE;
                    xpos = event.xmotion.x;
                    ypos = event.xmotion.y;
                    break;

            /* "ClientMessage" is generated if the WM itself
             * is being gunned down and sends an exit signal
             * to any running prog.
             */
                case ClientMessage:
                    if (event.xclient.data.l[0] == del_atom)
                        clean_exit();
                    break;

            /* "KeyPress" events are those that would be
             *  generated before whenever queueing up any
                KEYBD key via qdevice.
             */

                case KeyPress:
                   /* save out which unmodified key (i.e. the
                    * key was not modified w/something like
                    * "Shift", "Ctrl", or "Alt") got pressed
                    * for use below.
                    */
                    XLookupString((XKeyEvent *)&event, buf, 4,
                                   &keysym, 0);
                    myKeyPress = TRUE;
                    break;

              }  /* end switch (event.type) */

        } while (XPending(dpy));   /* end "do { } while".
                                    * XPending() is like
                                    * qtest()--it only
                                    * tells you if there're
                                    * any events presently in
                                    * the queue. it does not
                                    * disturb queue's contents
                                    * in any way.
                                    */

    /* On an "Expose" event, redraw the affected pop'd or
     * de-iconized window
     */
        if (myExpose) {
            resize_buffer();   
            myExpose = FALSE; /* reset flag--queue now empty */
        }

    /* On a "ConfigureNotify" event, the GL window has either
     * been moved or resized. Respond accordingly and then
     * redraw its contents.
     */
        if (myConfigure) {
            oxpos = xpos;
            oypos = ypos;
            resize_buffer();   
            myConfigure = FALSE;  /* reset flag--queue now
                                   * empty */
        }

        if (needToDraw) {
            drawScene();
            needToDraw = FALSE;
        }

        /* On a keypress of Esc key, exit program.
         */
        if (myKeyPress) {
            if (keysym == XK_Escape)
                clean_exit();
        }

        if (myButtPress) {
            orient();
            drawScene();
            myButtPress = FALSE;
        }
    }      /* end while(1) */

}      /* end main */

static int attributeList[] = { GLX_RGBA, 
                               GLX_DOUBLEBUFFER, 
                               GLX_RED_SIZE, 1, 
                               GLX_GREEN_SIZE, 1, 
                               GLX_BLUE_SIZE, 1,
                               GLX_DEPTH_SIZE, 1,
                               None };
static int attributeList2[] = { GLX_RGBA,
                               GLX_RED_SIZE, 1,
                               GLX_GREEN_SIZE, 1,
                               GLX_BLUE_SIZE, 1,
                               GLX_DEPTH_SIZE, 1,
                               None };


static Bool WaitForNotify(Display *d, XEvent *e, char *arg) {
    return (e->type == MapNotify) && (e->xmap.window ==
                                      (Window)arg);
}

XSizeHints Winhints;          /* used to fix window size */

/* openwindow - establish connection to X server, get screen info, specify the
 * attributes we want the WM to try to provide, and create the GL window */
static void openwindow(char *progname) {

    XVisualInfo *vi;
    GLXContext cx;
    Colormap cmap;
    XSizeHints Winhints;       /* used to fix window size*/ 
    XSetWindowAttributes swa;
    int scrnnum;               /* X screen number */
    int xorig, yorig;          /* window (upper-left) origin */
    long scrnheight;

   /* define window initial size */
    xorig = 50;  yorig = 40;
    xsize = 300; ysize = 240;
    scrnaspect = xsize / (double) ysize;

   /* Connect to the X server and get screen info */
    if ((dpy = XOpenDisplay(NULL)) == NULL) {
        fprintf(stderr, "%s: cannot connect to X server %s\n",
                                 progname, XDisplayName(NULL));
        exit(1);
    }

    scrnnum = DefaultScreen(dpy);
    scrnheight = DisplayHeight(dpy, scrnnum);

        /* get an appropriate visual */
    vi = glXChooseVisual(dpy, DefaultScreen(dpy),
                         attributeList);
    if (vi == NULL) {
        fprintf(stderr, "Unable to obtain visual
                         Doublebuffered visual\n");
        vi = glXChooseVisual(dpy, DefaultScreen(dpy),
                             attributeList2);
    }
    if (vi == NULL) {
        printf("Unable to obtain Singlebuffered
               VISUAL(????)\n");
        exit(0);
    }

    /* create a GLX context */
    cx = glXCreateContext(dpy, vi, None, GL_TRUE);

    /* create a colormap */
    cmap = XCreateColormap(dpy, RootWindow(dpy, vi->screen),
                           vi->visual, AllocNone);

    /* create a window */
    swa.colormap = cmap;
    swa.border_pixel = 0;
    swa.event_mask = StructureNotifyMask  | ButtonPressMask |
                     ExposureMask |
                     Button1MotionMask | 
                     KeyPressMask;    /* express interest in
                                       * events */;
    glwin = XCreateWindow(dpy, RootWindow(dpy, vi->screen),
                          xorig, yorig, xsize, ysize, 
                          0, vi->depth, InputOutput,
                          vi->visual,
                          CWBorderPixel|CWColormap|CWEventMask, &swa);

    XMapWindow(dpy, glwin);
    XIfEvent(dpy, &event, WaitForNotify, (char*)glwin);

    /* connect the context to the window */
    glXMakeCurrent(dpy, glwin, cx);

    if (!(glwin)) {
        fprintf(stderr,"%s: couldn't create `parent' X
                        window\n",progname);
        exit(1);
    }

   /* define string that will show up in the window title bar
    * (and icon) */
    XStoreName(dpy, glwin, "z-buffered rgb program");

   /* specify the values for the Window Size Hints we want to
    * enforce: this window's aspect ratio needs to stay at
    * 1:1, constrain min and max window size, and specify the
    * initial size of the window.
    */
    Winhints.width  = xsize;   /* specify desired x/y size of
                                * window */
    Winhints.height = ysize;
    Winhints.min_width = xorig;  /* define min and max */
    Winhints.max_width = scrnheight-1;  /* width and height */
    Winhints.min_height = yorig;
    Winhints.max_height = scrnheight-1;
    Winhints.min_aspect.x = xsize;    /* keep aspect to a xsize:ysize ratio */
    Winhints.max_aspect.x = xsize;
    Winhints.min_aspect.y = ysize;
    Winhints.max_aspect.y = ysize;
    /* set the corresponding flags */                                              
    Winhints.flags = USSize|PMaxSize|PMinSize|PAspect;
    XSetNormalHints(dpy, glwin, &Winhints);

    /* express interest in WM killing this app */
    if ((del_atom = XInternAtom(dpy, "WM_DELETE_WINDOW",
                                True)) != None)
        XSetWMProtocols(dpy, glwin, &del_atom, 1);

    return ;
}

/*  window has been moved or resized so update viewport & CTM stuff. */
static void resize_buffer() {

    XSync(dpy, False);  /* STILL NEED THIS????? */
                        /* Need before GL reshape */
    scrnaspect = xsize / (double) ysize;
    glViewport(0, 0, (short) (xsize-1), (short) (ysize-1));
}

/*  clean up before exiting */
static void clean_exit(void)
{
    XCloseDisplay(dpy);
    exit(0);
}

/* setup all necessary GL initialzation parameters. */
void initGL()
{
    glEnable(GL_DEPTH_TEST);
    glClearColor(0.16, 0.39, 0.78, 0.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();
    gluPerspective(400.0, scrnaspect, 30.0, 1000.0);
}

void orient()
{
    float dx, dy;
    glPushMatrix();
    dx = xpos-oxpos;
    dy = oypos-ypos;
    glLoadIdentity();
    glRotatef((float) (0.03*(xpos-oxpos)), 1.0, 0.0, 0.0);
    glRotatef((float) (0.03*(oypos-ypos)), 0.0, 1.0, 0.0);
    glMultMatrixf(objmat);
    glGetFloatv(GL_MODELVIEW_MATRIX, objmat);

    glPopMatrix();
}

void drawScene() 
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glPushMatrix();
    glTranslatef(0.0, 0.0, -40.0);
    glMultMatrixf(objmat);
    glRotatef(-220.0, 0.0, 1.0, 0.0);  /* skews orig view to
                                        * show all polys */
    drawPolys();
    glPopMatrix();
    glFlush ();
    glXSwapBuffers(dpy, glwin);
}

float polygon1[3][3] = { {-10.0, -10.0,   0.0,},
                         { 10.0, -10.0,   0.0,},
                         {-10.0,  10.0,   0.0,} };

float polygon2[3][3] = { {  0.0, -10.0, -10.0,},
                         {  0.0, -10.0,  10.0,},
                         {  0.0,   5.0, -10.0,} };

float polygon3[4][3] = { {-10.0,   6.0,   4.0,},
                         {-10.0,   3.0,   4.0,},
                         {  4.0,  -9.0, -10.0,},
                         {  4.0,  -6.0, -10.0,} };

void drawPolys()
{
    glBegin(GL_POLYGON);
    glColor4f(0.0, 0.0, 0.0, 0.0);
    glVertex3fv(&polygon1[0][0]);
    glColor4f(0.5, 0.5, 0.5, 0.0);
    glVertex3fv(&polygon1[1][0]);
    glColor4f(1.0, 1.0, 1.0, 0.0);
    glVertex3fv(&polygon1[2][0]);
    glEnd();

    glBegin(GL_POLYGON);
    glColor4f(1.0, 1.0, 0.0, 0.0);
    glVertex3fv(&polygon2[0][0]);
    glColor4f(0.0, 1.0, 0.5, 0.0);
    glVertex3fv(&polygon2[1][0]);
    glColor4f(0.0, 0.0, 1.0, 0.0);
    glVertex3fv(&polygon2[2][0]);
    glEnd();

    glBegin(GL_POLYGON);
    glColor4f(1.0, 1.0, 0.0, 0.0);
    glVertex3fv(&polygon3[0][0]);
    glColor4f(1.0, 0.0, 1.0, 0.0);
    glVertex3fv(&polygon3[1][0]);
    glColor4f(0.0, 0.0, 1.0, 0.0);
    glVertex3fv(&polygon3[2][0]);
    glColor4f(1.0, 0.0, 1.0, 0.0);
    glVertex3fv(&polygon3[3][0]);
    glEnd();

}
AC_ACCUMULATEIDREF="03.finish384"Accumulation Buffer CallsAC_ADDIDREF="03.finish392"Accumulation Buffer CallsAC_CLEAR_ACCUMULATEIDREF="03.finish386"Accumulation Buffer CallsAC_MULTIDREF="03.finish390"Accumulation Buffer CallsAC_RETURNIDREF="03.finish388"Accumulation Buffer Callsacbuf()IDREF="03.finish376"Accumulation Buffer Callsacbuf() argumentsIDREF="03.finish379"Accumulation Buffer Callsaccumulation bufferIDREF="03.finish375"Accumulation Buffer Callsaccumulation buffer operationsIDREF="03.finish379"Accumulation Buffer Callsaccumulation-buffer modeauxliary libraryIDREF="04.auxlib9"Porting Display Mode Initialization Calls with auxInitDisplayMode()acsize()IDREF="03.finish381"Accumulation Buffer CallsIDREF="04.auxlib18"Porting Display Mode Initialization Calls with auxInitDisplayMode()AF_ALWAYSIDREF="03.finish350"afunction() Test FunctionsAF_EQUALIDREF="03.finish356"afunction() Test FunctionsAF_GEQUALIDREF="03.finish362"afunction() Test FunctionsAF_GREATERIDREF="03.finish360"afunction() Test FunctionsAF_LEQUALIDREF="03.finish358"afunction() Test FunctionsAF_LESSIDREF="03.finish354"afunction() Test FunctionsAF_NEVERIDREF="03.finish352"afunction() Test FunctionsAF_NOTEQUALIDREF="03.finish348"afunction() Test Functionsafunction()IDREF="03.finish347"afunction() Test Functionsalpha component, lightingIDREF="03.finish447"Porting Lighting and Materials Callsalpha test functionsIDREF="03.finish347"afunction() Test FunctionsAMBIENTIDREF="03.finish462"Porting Lighting and Materials CallsanglesIDREF="03.finish196"Arcs and CirclesantialiasingIDREF="03.finish338"Porting Antialiasing CallsIDREF="03.finish364"Antialiasing CallsblendingIDREF="03.finish340"Blendingend correctionIDREF="03.finish374"Antialiasing CallslinesIDREF="03.finish115"LinespointsIDREF="03.finish112"Pointsarc()IDREF="03.finish190"Arcs and Circlesarcf()IDREF="03.finish191"Arcs and CirclesIDREF="02.toogl20"Editing toogl Output: An ExamplearcsIDREF="03.finish189"Arcs and Circlesusing quadricsIDREF="03.finish87"The IRIS GL Sphere LibraryAthena widget setIDREF="05.mixed41"What is Xt?IDREF="05.mixed44"You Don't Have to Use IRIS IMattenuationIDREF="03.finish448"Porting Lighting and Materials Callsattribute groupsIDREF="03.finish5"Porting greset()AUX_0IDREF="04.auxlib45"Handling Keyboard InputAUX_9IDREF="04.auxlib46"Handling Keyboard InputAUX_AIDREF="04.auxlib41"Handling Keyboard InputIDREF="04.auxlib43"Handling Keyboard InputAUX_ACCUMIDREF="04.auxlib17"Porting Display Mode Initialization Calls with auxInitDisplayMode()AUX_DEPTHIDREF="04.auxlib15"Porting Display Mode Initialization Calls with auxInitDisplayMode()AUX_DOUBLEIDREF="04.auxlib14"Porting Display Mode Initialization Calls with auxInitDisplayMode()AUX_DOWNIDREF="04.auxlib50"Handling Keyboard InputAUX_ESCAPEIDREF="04.auxlib51"Handling Keyboard InputAUX_EVENTRECIDREF="04.auxlib62"Handling Mouse EventsAUX_INDEXIDREF="04.auxlib12"Porting Display Mode Initialization Calls with auxInitDisplayMode()AUX_LEFTIDREF="04.auxlib47"Handling Keyboard InputAUX_LEFTBUTTONIDREF="04.auxlib56"Handling Mouse EventsAUX_MIDDLEBUTTONIDREF="04.auxlib58"Handling Mouse EventsAUX_MOUSEDOWNIDREF="04.auxlib59"Handling Mouse EventsAUX_MOUSELOCIDREF="04.auxlib61"Handling Mouse EventsAUX_MOUSEUPIDREF="04.auxlib60"Handling Mouse EventsAUX_RETURNIDREF="04.auxlib53"Handling Keyboard InputAUX_RGBAIDREF="04.auxlib11"Porting Display Mode Initialization Calls with auxInitDisplayMode()AUX_RIGHTIDREF="04.auxlib48"Handling Keyboard InputAUX_RIGHTBUTTONIDREF="04.auxlib57"Handling Mouse EventsAUX_SINGLEIDREF="04.auxlib13"Porting Display Mode Initialization Calls with auxInitDisplayMode()AUX_SPACEIDREF="04.auxlib52"Handling Keyboard InputAUX_STENCILIDREF="04.auxlib16"Porting Display Mode Initialization Calls with auxInitDisplayMode()AUX_UPIDREF="04.auxlib49"Handling Keyboard InputAUX_ZIDREF="04.auxlib42"Handling Keyboard InputIDREF="04.auxlib44"Handling Keyboard InputauxIdleFunc()IDREF="04.auxlib66"Managing Background Eventsauxiliary libraryIDREF="04.auxlib1"Using the Auxiliary Library to Replace Windowing and Event Handling CallsauxInitDisplayMode()IDREF="03.finish382"Accumulation Buffer CallsIDREF="04.auxlib8"Porting Display Mode Initialization Calls with auxInitDisplayMode()stencil planesIDREF="03.finish395"Stencil Plane CallsauxInitPosition()IDREF="04.auxlib7"Replacing prefposition() with auxInitPosition()auxInitWindow()IDREF="04.auxlib27"Replacing winopen() with auxInitWindow()auxKeyFunc()IDREF="04.auxlib40"Handling Keyboard InputauxMainLoop()IDREF="04.auxlib4"Running a Program That Uses the Auxiliary LibraryauxMouseFunc()IDREF="04.auxlib63"Handling Mouse EventsIDREF="04.auxlib55"Handling Mouse EventsauxReshapeFunc()IDREF="04.auxlib36"Handling Redraw EventsauxReshapeViewport()IDREF="04.auxlib38"Handling Redraw EventsauxSetOneColor()IDREF="03.finish222"Color CallsIDREF="04.auxlib69"Using Color-Index Modeback, polygonsIDREF="03.finish164"Polygon Modesbackground eventsIDREF="04.auxlib65"Managing Background Eventsbackground windowdefault colorIDREF="04.auxlib30"Replacing winopen() with auxInitWindow()beautifier, cbIDREF="02.toogl7"Hints for Using toogl Effectivelybegin and end commandsIDREF="03.finish100"bgn/end Commandsbgn/end commandsIDREF="03.finish100"bgn/end Commandsbgnclosedline()IDREF="03.finish116"Linesbgncurve()IDREF="03.finish307"NURBS Curvesbgnline()IDREF="03.finish120"Linesbgnpoint()IDREF="03.finish106"Pointsbgnpolygon()IDREF="03.finish149"Polygons and Quadrilateralsbgnqstrip()IDREF="03.finish153"Polygons and Quadrilateralsbgnsurface()IDREF="03.finish328"NURBS Surfacesbgntmesh()IDREF="03.finish187"Trianglesbgntrim()IDREF="03.finish319"Trimming CurvesbindsIDREF="03.finish435"Porting defs, binds, and sets: Replacing `Tables' of Stored Definitionsblend factorsIDREF="03.finish346"Blendingblend functionsIDREF="03.finish339"Blendingblendfunction()IDREF="03.finish344"BlendingblendingIDREF="03.finish340"BlendingbuffersclearingIDREF="03.finish7"Porting Commands that Required Current Graphics PositionC comments, and tooglIDREF="02.toogl9"Hints for Using toogl Effectivelyc()IDREF="03.finish215"Color Callscallbacksconcave polygonsIDREF="03.finish177"Tessellated Polygonswith quadric objectsIDREF="03.finish87"The IRIS GL Sphere Librarycallfunc()IDREF="03.finish418"Porting Display Listscallobj()IDREF="03.finish423"Porting Display ListscbIDREF="02.toogl7"Hints for Using toogl Effectivelycharacter stringsIDREF="05.mixed26"Fonts and Stringschoosing visualsblendingIDREF="03.finish341"Blendingcirc()IDREF="03.finish193"Arcs and Circlescircf()IDREF="03.finish194"Arcs and CirclescirclesIDREF="03.finish189"Arcs and Circlesusing quadricsIDREF="03.finish86"The IRIS GL Sphere Libraryclear()IDREF="02.toogl15"clear() CallsIDREF="03.finish7"Porting Commands that Required Current Graphics Positionclearing screen, buffersIDREF="03.finish7"Porting Commands that Required Current Graphics Positionclipplane()IDREF="03.finish78"Clipping Planescloseobj()IDREF="03.finish420"Porting Display Listscmode()IDREF="04.auxlib19"Porting Display Mode Initialization Calls with auxInitDisplayMode()IDREF="04.auxlib71"Using Color-Index Modecmov()IDREF="03.finish261"Porting Pixel OperationscolorIDREF="03.finish209"Porting Color, Shading, and Writemask Commandsdefault backgroundIDREF="04.auxlib30"Replacing winopen() with auxInitWindow()color constantsIDREF="03.finish214"Porting Color, Shading, and Writemask CommandsIDREF="02.toogl14"Defined Color Constantscolor mapsIDREF="03.finish209"Porting Color, Shading, and Writemask CommandsIDREF="05.mixed22"Installing Color MapsauxiliaryIDREF="04.auxlib67"Using Color-Index Modemixed modelIDREF="05.mixed9"What Is a Mixed-Model Program?XlibIDREF="05.mixed73"X Color Mapscolor()IDREF="03.finish213"Porting Color, Shading, and Writemask Commandscolor-index modeIDREF="04.auxlib68"Using Color-Index Modeauxiliary libraryIDREF="04.auxlib10"Porting Display Mode Initialization Calls with auxInitDisplayMode()COLORINDEXESIDREF="03.finish473"Porting Lighting and Materials Callscolormapsimulating RGB withIDREF="05.mixed24"Installing Color Mapscomments,tooglIDREF="02.toogl5"What toogl Will and Won't Do for Youcomparing filesIDREF="02.toogl4"Using gdiff to Compare Filescomparison functionsstencilIDREF="03.finish406"Stencil Plane Callsconcave polygonsIDREF="03.finish176"Tessellated PolygonsIDREF="03.finish138"Polygons and Quadrilateralsconesusing quadricsIDREF="03.finish87"The IRIS GL Sphere Librarycontrol points, NURBSIDREF="03.finish305"NURBS Objectsconversion tool, see tooglIDREF="02.toogl1"How to Get and Call tooglcoordinates, textureIDREF="03.finish512"Porting Texture Callscpack()IDREF="03.finish212"Porting Color, Shading, and Writemask Commandscrv()IDREF="03.finish290"Porting Curve and Surface Commandscrvn()IDREF="03.finish291"Porting Curve and Surface Commandscurrent graphics positionIDREF="03.finish9"Porting Commands that Required Current Graphics PositionIDREF="03.finish8"Porting Commands that Required Current Graphics Positioncurrent matrix modeIDREF="03.finish19"Porting Matrix and Transformation Callscurve types, NURBSIDREF="03.finish313"NURBS Curvescurvebasis()IDREF="03.finish288"Porting Curve and Surface Commandscurveit()IDREF="03.finish294"Porting Curve and Surface Commandscurveprecision()IDREF="03.finish289"Porting Curve and Surface CommandscurvesIDREF="03.finish286"Porting Curve and Surface Commandscurves, trimmingIDREF="03.finish318"Trimming Curvescylindersusing quadricsIDREF="03.finish87"The IRIS GL Sphere LibraryczclearIDREF="03.finish7"Porting Commands that Required Current Graphics Positionczclear()IDREF="03.finish10"Porting Screen and Buffer Clearing Commandsdefault colorbackground windowIDREF="04.auxlib30"Replacing winopen() with auxInitWindow()defbasis()IDREF="03.finish287"Porting Curve and Surface Commandsdefined color constantsIDREF="02.toogl14"Defined Color ConstantsIDREF="03.finish214"Porting Color, Shading, and Writemask Commandsdeflinestyle()IDREF="03.finish442"Porting defs, binds, and sets: Replacing `Tables' of Stored DefinitionsIDREF="03.finish125"Linesdefpattern()IDREF="03.finish444"Porting defs, binds, and sets: Replacing `Tables' of Stored DefinitionsIDREF="03.finish169"Polygon StipplesdefsIDREF="03.finish435"Porting defs, binds, and sets: Replacing `Tables' of Stored Definitionsdelobj()IDREF="03.finish428"Porting Display Listsdeltag()IDREF="03.finish417"Porting Display Listsdepth cueingIDREF="03.finish272"Porting Depth Cueing and Fog Commandsdepth-buffer modeauxiliary libraryIDREF="04.auxlib9"Porting Display Mode Initialization Calls with auxInitDisplayMode()IDREF="04.auxlib10"Porting Display Mode Initialization Calls with auxInitDisplayMode()depthcue()IDREF="03.finish273"Porting Depth Cueing and Fog Commandsdestination alpha bitsIDREF="03.finish342"Blendingdevice callstooglIDREF="02.toogl12"Windowing, Device, and Event Callsdifferences, OpenGL and IRIS GLIDREF="01.begin1"What's Different?DIFFUSEIDREF="03.finish464"Porting Lighting and Materials Callsdiffuse lighting componentsIDREF="03.finish447"Porting Lighting and Materials Callsdirect renderingIDREF="02.toogl19"Performance disksusing quadricsIDREF="03.finish86"The IRIS GL Sphere Librarydisplay listsIDREF="03.finish409"Porting Display ListseditingIDREF="03.finish433"Edited Display ListsexampleIDREF="03.finish434"A Sample Implementation of a Display Listfor X bitmap fontsIDREF="05.mixed28"Fonts and Stringsperformance ofIDREF="02.toogl18"Performancedisplay modeIDREF="05.mixed18"You Can't Change Window Depth and Display Modedisplay modesauxiliary libraryIDREF="04.auxlib10"Porting Display Mode Initialization Calls with auxInitDisplayMode()dither()IDREF="03.finish245"Shading ModelsditheringIDREF="03.finish240"Shading ModelsdocumentationIDREF="05.mixed64"Other Information Sources for Mixed-Model ProgrammingIRIS IMIDREF="intro1"Where To Get More InformationIDREF="05.mixed65"Other Information Sources for Mixed-Model ProgrammingMotifIDREF="intro1"Where To Get More InformationIDREF="05.mixed65"Other Information Sources for Mixed-Model ProgrammingXIDREF="intro1"Where To Get More InformationIDREF="05.mixed65"Other Information Sources for Mixed-Model Programmingdouble-buffer modeauxiliary libraryIDREF="04.auxlib10"Porting Display Mode Initialization Calls with auxInitDisplayMode()double-matrix modeIDREF="03.finish12"Porting Matrix and Transformation Callsdoublebuffer()IDREF="04.auxlib20"Porting Display Mode Initialization Calls with auxInitDisplayMode()draw()IDREF="03.finish8"Porting Commands that Required Current Graphics Positiondrawing commandsIDREF="03.finish84"Porting Drawing Commandsdrawing objectsauxliary libraryIDREF="04.auxlib74"Other Auxiliary Library RoutinesIDREF="04.auxlib73"Other Auxiliary Library Routinesdrawing single pointsIDREF="03.finish104"Pointsediting display listsIDREF="03.finish432"Edited Display Listsediting toogl outputIDREF="02.toogl11"Editing toogl Output: Areas that Need Special Attentioneditobj()IDREF="03.finish410"Porting Display ListsEMISSIONIDREF="03.finish468"Porting Lighting and Materials Callsend commandsIDREF="03.finish100"bgn/end Commandsend correctionIDREF="03.finish374"Antialiasing Callsendclosedline()IDREF="03.finish117"Linesendcurve()IDREF="03.finish311"NURBS Curvesendfeedback()IDREF="03.finish593"Porting Feedback Callsendpick()IDREF="03.finish577"Porting Picking Callsendpoint()IDREF="03.finish107"Pointsendpolygon()IDREF="03.finish150"Polygons and Quadrilateralsendqstrip()IDREF="03.finish154"Polygons and Quadrilateralsendselect()IDREF="03.finish578"Porting Picking Callsendsurface()IDREF="03.finish332"NURBS Surfacesendtmesh()IDREF="03.finish188"Trianglesendtrim()IDREF="03.finish325"Trimming Curvesescape keyexiting programIDREF="04.auxlib29"Replacing winopen() with auxInitWindow()event callstooglIDREF="02.toogl12"Windowing, Device, and Event Callsevent handlingauxiliary libraryIDREF="04.auxlib31"Event Handling: Replacing qdevice(), qtest(), and qread() mixed modelIDREF="05.mixed6"What Is a Mixed-Model Program?XlibIDREF="05.mixed74"A Sample X Event Loopexiting with escape keyIDREF="04.auxlib29"Replacing winopen() with auxInitWindow()expose eventsIDREF="04.auxlib35"Handling Redraw Eventsextensions to OpenGLIDREF="03.finish598"OpenGL Extensionsfeedback()IDREF="03.finish591"Porting Feedback Callsflat shadingIDREF="03.finish247"Shading ModelsfogIDREF="03.finish272"Porting Depth Cueing and Fog Commandsfog modesIDREF="03.finish285"Porting Depth Cueing and Fog Commandsfogvertex()IDREF="03.finish277"Porting Depth Cueing and Fog CommandsfontsIDREF="05.mixed26"Fonts and Stringsmixed modelIDREF="05.mixed8"What Is a Mixed-Model Program?front, polygonsIDREF="03.finish164"Polygon Modesfunction flagsstencilIDREF="03.finish405"Stencil Plane Callsfunctionsalpha testingIDREF="03.finish347"afunction() Test Functionsfunctions, blendingIDREF="03.finish339"Blendinggconfig()IDREF="04.auxlib25"Porting Display Mode Initialization Calls with auxInitDisplayMode()IDREF="04.auxlib72"Using Color-Index ModegdiffIDREF="02.toogl4"Using gdiff to Compare Filesgenobj()IDREF="03.finish430"Porting Display Listsgentag()IDREF="03.finish415"Porting Display Listsget commandsIDREF="02.toogl16"Get CallsIDREF="03.finish6"Porting IRIS GL `Get' Commandsgetbutton()IDREF="04.auxlib33"Event Handling: Replacing qdevice(), qtest(), and qread() getcmmode()IDREF="03.finish237"Color Callsgetcolor()IDREF="03.finish216"Color Callsgetdcm()IDREF="03.finish276"Porting Depth Cueing and Fog Commandsgetgpos()IDREF="03.finish8"Porting Commands that Required Current Graphics Positiongetlsbackup()IDREF="03.finish134"Linesgetlsrepeat()IDREF="03.finish130"Linesgetlstyle()IDREF="03.finish129"Linesgetlwidth()IDREF="03.finish123"Linesgetmap()IDREF="03.finish239"Color Callsgetmatrix()IDREF="03.finish66"Porting "Get" Calls For Matrices and Transformationsgetmcolor()IDREF="03.finish218"Color Callsgetmmode()IDREF="03.finish64"Porting "Get" Calls For Matrices and Transformationsgetpattern()IDREF="03.finish172"Polygon Stipplesgetresetls()IDREF="03.finish136"Linesgetscrbox()IDREF="03.finish72"Viewports, Screenmasks, and Scrboxesgetscrmask()IDREF="03.finish83"Clipping Planesgetsm()IDREF="03.finish243"Shading Modelsgetvaluator()IDREF="04.auxlib32"Event Handling: Replacing qdevice(), qtest(), and qread() getviewport()IDREF="03.finish77"Viewports, Screenmasks, and Scrboxesgetwritemask()IDREF="03.finish230"Color CallsGL and X mixed programs, see mixed-model programmingIDREF="05.mixed2"Mixed-Model ProgrammingGL_ACCUMIDREF="03.finish385"Accumulation Buffer CallsGL_ADDIDREF="03.finish393"Accumulation Buffer CallsGL_ALWAYSIDREF="03.finish351"afunction() Test FunctionsGL_AMBIENTIDREF="03.finish463"Porting Lighting and Materials CallsGL_AMBIENT_AND_ DIFFUSEIDREF="03.finish472"Porting Lighting and Materials CallsGL_BLENDIDREF="03.finish526"Translating tevdef()GL_COLOR_INDEXESIDREF="03.finish474"Porting Lighting and Materials CallsGL_CONSTANT_IDREF="03.finish486"Porting Lighting and Materials CallsGL_CONSTANT_ATTENUATIONIDREF="03.finish487"Porting Lighting and Materials CallsGL_DECALIDREF="03.finish524"Translating tevdef()GL_DIFFUSEIDREF="03.finish465"Porting Lighting and Materials CallsGL_DONT_CAREIDREF="03.finish373"Antialiasing CallsGL_EMISSIONIDREF="03.finish469"Porting Lighting and Materials CallsGL_EQUALIDREF="03.finish357"afunction() Test FunctionsGL_EYE_LINEARIDREF="03.finish569"Translating texgen()GL_EYE_PLANEIDREF="03.finish570"Translating texgen()GL_FASTESTIDREF="03.finish283"Porting Depth Cueing and Fog CommandsIDREF="03.finish372"Antialiasing CallsGL_GEQUALIDREF="03.finish363"afunction() Test FunctionsGL_GREATERIDREF="03.finish361"afunction() Test FunctionsGL_LEQUALIDREF="03.finish359"afunction() Test FunctionsGL_LESSIDREF="03.finish355"afunction() Test FunctionsGL_LIGHT_MODEL_ AMBIENTIDREF="03.finish475"Porting Lighting and Materials CallsGL_LIGHT_MODEL_ LOCAL_VIEWERIDREF="03.finish476"Porting Lighting and Materials CallsGL_LIGHT_MODEL_ TWO_SIDEIDREF="03.finish477"Porting Lighting and Materials CallsGL_LINEARIDREF="03.finish546"Translating texdef()GL_LINEAR_ATTENUATIONIDREF="03.finish488"Porting Lighting and Materials CallsGL_LINEAR_MIPMAP_LINEARIDREF="03.finish554"Translating texdef()GL_LINEAR_MIPMAP_NEARESTIDREF="03.finish550"Translating texdef()GL_LOADIDREF="03.finish387"Accumulation Buffer CallsGL_MATRIX_MODEIDREF="03.finish65"Porting "Get" Calls For Matrices and TransformationsGL_MODELVIEWIDREF="03.finish61"Porting Matrix and Transformation CallsGL_MODELVIEW_MATRIXIDREF="03.finish67"Porting "Get" Calls For Matrices and TransformationsGL_MODULATEIDREF="03.finish522"Translating tevdef()GL_MULTIDREF="03.finish391"Accumulation Buffer CallsGL_NEARESTIDREF="03.finish544"Translating texdef()GL_NEAREST_MIPMAP_LINEARIDREF="03.finish552"Translating texdef()GL_NEAREST_MIPMAP_NEARESTIDREF="03.finish548"Translating texdef()GL_NEVERIDREF="03.finish353"afunction() Test FunctionsGL_NICESTIDREF="03.finish282"Porting Depth Cueing and Fog CommandsIDREF="03.finish371"Antialiasing CallsGL_NOTEQUALIDREF="03.finish349"afunction() Test FunctionsGL_OBJECT_LINEARIDREF="03.finish566"Translating texgen()GL_OBJECT_PLANEIDREF="03.finish567"Translating texgen()GL_POSITIONIDREF="03.finish480"Porting Lighting and Materials CallsGL_PROJECTIONIDREF="03.finish63"Porting Matrix and Transformation CallsGL_PROJECTION_MATRIXIDREF="03.finish68"Porting "Get" Calls For Matrices and TransformationsGL_QIDREF="03.finish564"Translating texgen()GL_QUADRATIC_ATTENUATIONIDREF="03.finish489"Porting Lighting and Materials CallsGL_RIDREF="03.finish562"Translating texgen()GL_RETURNIDREF="03.finish389"Accumulation Buffer CallsGL_SIDREF="03.finish558"Translating texgen()GL_SHININESSIDREF="03.finish471"Porting Lighting and Materials CallsGL_SPECULARIDREF="03.finish467"Porting Lighting and Materials CallsGL_SPHERE_MAPIDREF="03.finish572"Translating texgen()GL_SPOT_CUTOFFIDREF="03.finish485"Porting Lighting and Materials CallsGL_SPOT_DIRECTIONIDREF="03.finish482"Porting Lighting and Materials CallsGL_SPOT_EXPONENTIDREF="03.finish484"Porting Lighting and Materials CallsGL_TIDREF="03.finish560"Translating texgen()GL_TEXTUREIDREF="03.finish59"Porting Matrix and Transformation CallsGL_TEXTURE_BORDER_COLORIDREF="03.finish542"Translating texdef()GL_TEXTURE_ENV_COLORIDREF="03.finish528"Translating tevdef()GL_TEXTURE_MAG_FILTERIDREF="03.finish535"Translating texdef()GL_TEXTURE_MATRIXIDREF="03.finish69"Porting "Get" Calls For Matrices and TransformationsGL_TEXTURE_MIN_FILTERIDREF="03.finish533"Translating texdef()GL_TEXTURE_WRAP_SIDREF="03.finish538"Translating texdef()GL_TEXTURE_WRAP_TIDREF="03.finish541"Translating texdef()glAccum()IDREF="03.finish377"Accumulation Buffer CallsglBegin()IDREF="03.finish101"bgn/end CommandsIDREF="03.finish100"bgn/end CommandsIDREF="03.finish108"PointslinesIDREF="03.finish118"LinespolygonsIDREF="03.finish151"Polygons and QuadrilateralsglBegin/glEndvalid commandsIDREF="03.finish103"bgn/end CommandsglBlendFunc()IDREF="03.finish345"BlendingglCallList()IDREF="03.finish424"Porting Display ListsglCallLists()IDREF="03.finish425"Porting Display ListsfontsIDREF="05.mixed31"Fonts and Stringsglcear()IDREF="03.finish10"Porting Screen and Buffer Clearing CommandsglClear()IDREF="03.finish7"Porting Commands that Required Current Graphics Positionaccumulation bufferIDREF="03.finish380"Accumulation Buffer Callsstencil planesIDREF="03.finish408"Stencil Plane CallsglClearAccum()IDREF="03.finish378"Accumulation Buffer CallsIDREF="03.finish10"Porting Screen and Buffer Clearing CommandsglClearColor()IDREF="03.finish7"Porting Commands that Required Current Graphics PositionglClearDepth()IDREF="03.finish10"Porting Screen and Buffer Clearing CommandsglClearIndex()IDREF="03.finish7"Porting Commands that Required Current Graphics PositionglClearStencil()IDREF="03.finish403"Stencil Plane CallsIDREF="03.finish10"Porting Screen and Buffer Clearing CommandsglClipPlane()IDREF="03.finish79"Clipping PlanesglColor()IDREF="03.finish211"Porting Color, Shading, and Writemask CommandsglColorMask()IDREF="03.finish229"Color CallsglColorMaterial()IDREF="03.finish458"Porting Lighting and Materials CallsglCopyPixels()IDREF="03.finish258"Porting Pixel OperationsglDeleteLists()IDREF="03.finish429"Porting Display ListsglDepthMask()IDREF="03.finish234"Color CallsglDisable()antialiasingIDREF="03.finish369"Antialiasing CallsditheringIDREF="03.finish248"Shading ModelsfogIDREF="03.finish280"Porting Depth Cueing and Fog Commandspolygon stipplingIDREF="03.finish175"Polygon StipplestexturesIDREF="03.finish496"Porting Texture CallsglDrawPixels()IDREF="03.finish256"Porting Pixel OperationsglEdgeFlag()IDREF="03.finish155"Polygons and QuadrilateralsglEnable()IDREF="03.finish114"PointsantialiasingIDREF="03.finish366"Antialiasing CallsblendingIDREF="03.finish343"BlendingditheringIDREF="03.finish246"Shading ModelsfogIDREF="03.finish279"Porting Depth Cueing and Fog CommandslightingIDREF="03.finish454"Porting Lighting and Materials CallslogicopIDREF="03.finish271"Porting Pixel OperationsNURBSIDREF="03.finish306"NURBS Objectspolygon stipplingIDREF="03.finish174"Polygon Stipplesstencil planesIDREF="03.finish398"Stencil Plane CallstexturesIDREF="03.finish495"Porting Texture CallsglEnd()IDREF="03.finish109"PointsIDREF="03.finish102"bgn/end CommandsIDREF="03.finish100"bgn/end CommandslinesIDREF="03.finish119"LinespolygonsIDREF="03.finish152"Polygons and QuadrilateralsglEndList()IDREF="03.finish422"Porting Display ListsglFeedbackBuffer()IDREF="03.finish594"Porting Feedback CallsglFog()IDREF="03.finish278"Porting Depth Cueing and Fog Commandsarguments IDREF="03.finish281"Porting Depth Cueing and Fog CommandsglFrustum()IDREF="03.finish55"Porting Matrix and Transformation CallsglGenLists()IDREF="03.finish431"Porting Display ListsglGet()IDREF="03.finish6"Porting IRIS GL `Get' Commandscolor indexIDREF="03.finish217"Color Callscolor maskIDREF="03.finish231"Color Callsline widthIDREF="03.finish124"LinesRGB color valuesIDREF="03.finish220"Color Callsshade modelIDREF="03.finish244"Shading ModelsglGetClipPlane()IDREF="03.finish80"Clipping PlanesglGetLight()IDREF="03.finish455"Porting Lighting and Materials CallsglGetMaterial()IDREF="03.finish459"Porting Lighting and Materials CallsglGetPolygonStipple()IDREF="03.finish173"Polygon StipplesglGetTexParameter()IDREF="03.finish515"Porting Texture CallsglHint()antialiasingIDREF="03.finish370"Antialiasing CallsglIndex()IDREF="03.finish210"Porting Color, Shading, and Writemask CommandsglIndexMask()IDREF="03.finish226"Color CallsglInitNames()IDREF="03.finish584"Porting Picking CallsglIsList()IDREF="03.finish427"Porting Display ListsglLight()IDREF="03.finish452"Porting Lighting and Materials CallsglLightModel()IDREF="03.finish453"Porting Lighting and Materials CallsglLineStipple()IDREF="03.finish127"LinesglLineWidth()IDREF="03.finish122"LinesglListBase()fontsIDREF="05.mixed30"Fonts and StringsglLoadIdentity()IDREF="03.finish21"Porting Matrix and Transformation CallsglLoadMatrixd()IDREF="03.finish24"Porting Matrix and Transformation CallsglLoadMatrixf()IDREF="03.finish23"Porting Matrix and Transformation CallsglLoadName()IDREF="03.finish590"Porting Picking CallsglLogicOp()IDREF="03.finish270"Porting Pixel OperationsglMap1()IDREF="03.finish316"NURBS CurvesglMap2()IDREF="03.finish337"NURBS SurfacesglMaterial()IDREF="03.finish456"Porting Lighting and Materials CallsglMaterial() parametersIDREF="03.finish461"Porting Lighting and Materials CallsglMatrixMode()IDREF="03.finish18"Porting Matrix and Transformation CallsglMultMatrix()IDREF="03.finish11"Porting Matrix and Transformation CallsglMultMatrixd()IDREF="03.finish27"Porting Matrix and Transformation CallsglMultMatrixf()IDREF="03.finish26"Porting Matrix and Transformation CallsglNewList()IDREF="03.finish421"Porting Display ListsglOrtho()IDREF="03.finish33"Porting Matrix and Transformation CallsglPassThrough()IDREF="03.finish596"Porting Feedback CallsglPixelStore()IDREF="03.finish168"Polygon StipplesIDREF="03.finish266"Porting Pixel OperationsglPixelTransfer()IDREF="03.finish268"Porting Pixel OperationsglPixelZoom()IDREF="03.finish260"Porting Pixel OperationsglPointSize()IDREF="03.finish111"PointsglPolygonMode()IDREF="03.finish165"Polygon ModesIDREF="03.finish157"Polygons and QuadrilateralsglPolygonStipple()IDREF="03.finish170"Polygon StipplesglPopAttrib()IDREF="03.finish2"Porting greset()IDREF="03.finish4"Porting greset()glPopMatrix()IDREF="03.finish41"Porting Matrix and Transformation CallsglPopName()IDREF="03.finish588"Porting Picking CallsglPushAttrib()IDREF="03.finish2"Porting greset()IDREF="03.finish3"Porting greset()glPushMatrix()IDREF="03.finish43"Porting Matrix and Transformation CallsglPushName()IDREF="03.finish587"Porting Picking CallsglRasterPos()IDREF="03.finish262"Porting Pixel OperationsglReadBuffer()IDREF="03.finish264"Porting Pixel OperationsglReadPixels()IDREF="03.finish253"Porting Pixel OperationsglRect()IDREF="03.finish160"Polygons and QuadrilateralsglRenderMode()feedbackIDREF="03.finish592"Porting Feedback CallspickingIDREF="03.finish576"Porting Picking CallsselectIDREF="03.finish579"Porting Picking CallsglRotate()IDREF="03.finish12"Porting Matrix and Transformation CallsglRotated()IDREF="03.finish46"Porting Matrix and Transformation CallsglRotatef()IDREF="03.finish47"Porting Matrix and Transformation CallsglScaled()IDREF="03.finish49"Porting Matrix and Transformation CallsglScalef()IDREF="03.finish50"Porting Matrix and Transformation CallsglScissor()IDREF="03.finish82"Clipping PlanesglSelectBuffer()IDREF="03.finish582"Porting Picking CallsglShadeModel()IDREF="03.finish242"Shading ModelsglStencilFunc()IDREF="03.finish400"Stencil Plane CallsglStencilMask()IDREF="03.finish402"Stencil Plane CallsglStencilOp()IDREF="03.finish399"Stencil Plane CallsglTexCoord()IDREF="03.finish511"Porting Texture CallsglTexEnv()IDREF="03.finish508"Porting Texture CallsIDREF="03.finish506"Porting Texture CallsglTexGen()IDREF="03.finish514"Porting Texture CallsIDREF="03.finish556"Translating texgen()glTexImage1D()IDREF="03.finish509"Porting Texture CallsglTexImage2D()IDREF="03.finish498"Porting Texture CallsIDREF="03.finish503"Porting Texture CallsglTexParameter()IDREF="03.finish499"Porting Texture CallsIDREF="03.finish502"Porting Texture CallsglTranslated()IDREF="03.finish53"Porting Matrix and Transformation CallsglTranslatef()IDREF="03.finish52"Porting Matrix and Transformation CallsGLU quadrics routinesIDREF="03.finish85"The IRIS GL Sphere LibrarygluBeginCurve()IDREF="03.finish308"NURBS CurvesgluBeginPolygon()IDREF="03.finish181"Tessellated PolygonsgluBeginSurface()IDREF="03.finish329"NURBS SurfacesgluBeginTrim()IDREF="03.finish320"Trimming CurvesgluBuild1DMipmaps()IDREF="03.finish516"Porting Texture CallsgluBuild2DMipmaps()IDREF="03.finish517"Porting Texture CallsIDREF="03.finish494"Porting Texture CallsIDREF="03.finish504"Porting Texture CallsIDREF="03.finish500"Porting Texture CallsgluCylinder()IDREF="03.finish96"The IRIS GL Sphere LibrarygluDeleteNurbsRenderer()IDREF="03.finish302"NURBS ObjectsgluDeleteQuadric()IDREF="03.finish203"SpheresIDREF="03.finish89"The IRIS GL Sphere LibrarygluDeleteTess()IDREF="03.finish179"Tessellated PolygonsgluDisk()IDREF="03.finish195"Arcs and CirclesIDREF="03.finish98"The IRIS GL Sphere LibrarygluEndCurve()IDREF="03.finish312"NURBS CurvesgluEndPolygon()IDREF="03.finish184"Tessellated PolygonsgluEndSurface()IDREF="03.finish333"NURBS SurfacesgluEndTrim()IDREF="03.finish326"Trimming CurvesgluLookAt()IDREF="03.finish16"Porting Matrix and Transformation CallsgluNewNurbsRenderer()IDREF="03.finish301"NURBS ObjectsgluNewQuadric()IDREF="03.finish201"SpheresIDREF="03.finish88"The IRIS GL Sphere LibrarygluNewTess()IDREF="03.finish178"Tessellated PolygonsgluNextContour()IDREF="03.finish183"Tessellated PolygonsgluNurbsCallback()IDREF="03.finish303"NURBS ObjectsgluNurbsCurve()IDREF="03.finish310"NURBS CurvesIDREF="03.finish324"Trimming CurvesgluNurbsSurface()IDREF="03.finish331"NURBS SurfacesgluOrtho2D()IDREF="03.finish35"Porting Matrix and Transformation CallsgluPartialDisk()IDREF="03.finish192"Arcs and CirclesIDREF="03.finish97"The IRIS GL Sphere LibrarygluPerspective()IDREF="03.finish37"Porting Matrix and Transformation CallsgluPickMatrix()IDREF="03.finish39"Porting Matrix and Transformation CallsIDREF="03.finish581"Porting Picking CallsgluProject()IDREF="03.finish31"Porting Matrix and Transformation CallsgluPwlCurve()IDREF="03.finish322"Trimming CurvesgluQuadricCallback()IDREF="03.finish90"The IRIS GL Sphere LibrarygluQuadricDrawstyle()IDREF="03.finish94"The IRIS GL Sphere LibrarygluQuadricNormals()IDREF="03.finish91"The IRIS GL Sphere LibrarygluQuadricOrientation()IDREF="03.finish92"The IRIS GL Sphere LibrarygluQuadricTexture()IDREF="03.finish93"The IRIS GL Sphere LibrarygluScaleImage()IDREF="03.finish518"Porting Texture CallsgluSphere()IDREF="03.finish199"SpheresIDREF="03.finish95"The IRIS GL Sphere LibraryIDREF="03.finish205"SpheresgluTessCallback()IDREF="03.finish180"Tessellated PolygonsgluTessVertex()IDREF="03.finish182"Tessellated PolygonsgluUnProject()IDREF="03.finish30"Porting Matrix and Transformation CallsglVertex()IDREF="03.finish99"The v() CommandsglViewport()IDREF="03.finish73"Viewports, Screenmasks, and ScrboxesIDREF="04.auxlib37"Handling Redraw EventsGLwDrawIDREF="05.mixed14"Using Xt and a Widget SetIDREF="05.mixed33"Porting to Mixed-Model Using Xt and a Widget SetGLwMDrawIDREF="05.mixed15"Using Xt and a Widget SetIDREF="05.mixed35"Porting to Mixed-Model Using Xt and a Widget SetGLX commandsIDREF="05.mixed66"Mixed-Model Programming Using Xlib and OpenGL GLX CommandsGLX routinesIDREF="05.mixed17"Using XlibglXChooseVisual()IDREF="05.mixed68"Mixed-Model Programming Using Xlib and OpenGL GLX Commandsaccumulation bufferIDREF="03.finish383"Accumulation Buffer CallsglXCreateContext()IDREF="05.mixed58"Using the OpenGL WidgetIDREF="05.mixed69"Mixed-Model Programming Using Xlib and OpenGL GLX CommandsGlxCreateMDrawIDREF="05.mixed54"About the GLwDrawingArea WidgetGlxDrawIRIS IM versionIDREF="05.mixed55"About the GLwDrawingArea WidgetGlxDrawingAreaMakeCurrent()IDREF="05.mixed60"Using the OpenGL WidgetIDREF="05.mixed59"Using the OpenGL WidgetglXMakeCurrent()IDREF="05.mixed71"Mixed-Model Programming Using Xlib and OpenGL GLX CommandsGlxMDrawIDREF="05.mixed48"About the GLwDrawingArea WidgetGlxNinputCallbackIDREF="05.mixed61"Using the OpenGL WidgetglXUseXFont()IDREF="05.mixed27"Fonts and Stringsgouraud shadingIDREF="03.finish247"Shading Modelsgraphics position, currentIDREF="03.finish8"Porting Commands that Required Current Graphics Positiongreset()IDREF="03.finish2"Porting greset()gRGBcolor()IDREF="03.finish219"Color CallsgRGBmask()IDREF="03.finish232"Color Callsgroups, state attributeIDREF="03.finish5"Porting greset()header filesIDREF="03.finish1"Header Filesauxiliary libraryIDREF="04.auxlib2"Using the Auxiliary Library to Replace Windowing and Event Handling Callshint modes, fogIDREF="03.finish284"Porting Depth Cueing and Fog Commandshow to portIDREF="01.begin3"How to Port Your Code to OpenGLimage scalingIDREF="03.finish519"Porting Texture Callsinclude filesIDREF="03.finish1"Header Filesauxiliary libraryIDREF="04.auxlib2"Using the Auxiliary Library to Replace Windowing and Event Handling Callsinitnames()IDREF="03.finish583"Porting Picking Callsinput handlingIDREF="04.auxlib64"Input Handling with the Auxiliary Library: Example Programinstalling color mapsIDREF="05.mixed22"Installing Color MapsIRIS IMIDREF="05.mixed32"Porting to Mixed-Model Using Xt and a Widget SetIDREF="05.mixed37"What You Need to Know About Xt and IRIS IMIDREF="05.mixed42"What Is IRIS IM?IDREF="05.mixed12"Two Choices For Mixed-Model ProgrammingtraversalIDREF="05.mixed53"About the GLwDrawingArea WidgetIRIS IM documentationIDREF="intro1"Where To Get More InformationIDREF="05.mixed65"Other Information Sources for Mixed-Model ProgrammingIRIS InventorIDREF="01.begin4"If You're Not Porting Your Code to OpenGL Yetisobj()IDREF="03.finish426"Porting Display Listsistag()IDREF="03.finish416"Porting Display Listskeyboard inputIDREF="04.auxlib39"Handling Keyboard InputLCOLORIDREF="03.finish478"Porting Lighting and Materials Callslight modelsIDREF="03.finish449"Porting Lighting and Materials CallslightingIDREF="03.finish449"Porting Lighting and Materials Callsdisplay listsIDREF="03.finish446"Porting Lighting and Materials Callstwo-sidedIDREF="03.finish491"Porting Lighting and Materials Callslinear fogIDREF="03.finish272"Porting Depth Cueing and Fog CommandslinesdrawingIDREF="03.finish115"Linesquadric routinesIDREF="03.finish87"The IRIS GL Sphere LibrarystipplesIDREF="03.finish115"Lineslinesmooth()IDREF="03.finish131"LinesIDREF="03.finish367"Antialiasing Callslinewidth()IDREF="03.finish121"Lineslmbind()IDREF="03.finish451"Porting Lighting and Materials CallsIDREF="03.finish437"Porting defs, binds, and sets: Replacing `Tables' of Stored Definitionslmcolor()IDREF="03.finish457"Porting Lighting and Materials Callslmdef()IDREF="03.finish450"Porting Lighting and Materials CallsIDREF="03.finish436"Porting defs, binds, and sets: Replacing `Tables' of Stored Definitionsloadmatrix()IDREF="03.finish22"Porting Matrix and Transformation Callsloadname()IDREF="03.finish589"Porting Picking Callslogical pixel operationsIDREF="03.finish249"Porting Pixel Operationslogicop()IDREF="03.finish269"Porting Pixel Operationslookat()IDREF="03.finish15"Porting Matrix and Transformation Callslrectread()IDREF="03.finish250"Porting Pixel Operationslrectwrite()IDREF="03.finish254"Porting Pixel OperationslRGBrange()IDREF="03.finish274"Porting Depth Cueing and Fog Commandslsbackup()IDREF="03.finish133"Lineslshaderange()IDREF="03.finish275"Porting Depth Cueing and Fog Commandslsrepeat()IDREF="03.finish128"Linesmakeobj()IDREF="03.finish419"Porting Display Listsmaketag()IDREF="03.finish414"Porting Display Listsmapcolor()IDREF="04.auxlib70"Using Color-Index ModeIDREF="03.finish221"Color Callsmapw()IDREF="03.finish28"Porting Matrix and Transformation Callsmapw2()IDREF="03.finish29"Porting Matrix and Transformation Callsmaterial parametersIDREF="03.finish460"Porting Lighting and Materials CallsmaterialsIDREF="03.finish449"Porting Lighting and Materials Callsdisplay listsIDREF="03.finish446"Porting Lighting and Materials CallsmatricesIDREF="03.finish12"Porting Matrix and Transformation Callsmatrix modesIDREF="03.finish57"Porting Matrix and Transformation CallsmipmapsIDREF="03.finish493"Porting Texture Callsmixed model programIDREF="05.mixed5"What Is a Mixed-Model Program?mixed model programmingIDREF="05.mixed57"Using the OpenGL Widgetmixed-modelXlibIDREF="05.mixed66"Mixed-Model Programming Using Xlib and OpenGL GLX Commandsmixed-model programmingIDREF="05.mixed1"Mixed-Model ProgrammingAthena widget setIDREF="05.mixed45"You Don't Have to Use IRIS IMGlxDrawIRIS IM versionIDREF="05.mixed47"About the GLwDrawingArea WidgetGlxMdrawIDREF="05.mixed50"About the GLwDrawingArea Widgetinstalling colormapsIDREF="05.mixed20"Installing Color MapsIRIS IMIDREF="05.mixed39"What You Need to Know About Xt and IRIS IMIDREF="05.mixed49"About the GLwDrawingArea WidgetGlxMDrawIDREF="05.mixed46"About the GLwDrawingArea WidgettraversalIDREF="05.mixed51"About the GLwDrawingArea Widgetwithout IRIS IMIDREF="05.mixed43"You Don't Have to Use IRIS IM XlibIDREF="05.mixed16"Using XlibXtIDREF="05.mixed38"What You Need to Know About Xt and IRIS IMmmode()IDREF="03.finish17"Porting Matrix and Transformation Callsmodelview matrixIDREF="03.finish56"Porting Matrix and Transformation Callsmodes, fogIDREF="03.finish285"Porting Depth Cueing and Fog CommandsMotif documentationIDREF="intro1"Where To Get More InformationIDREF="05.mixed65"Other Information Sources for Mixed-Model Programmingmouse eventsIDREF="04.auxlib54"Handling Mouse Eventsmove eventsIDREF="04.auxlib35"Handling Redraw Eventsmove()IDREF="03.finish8"Porting Commands that Required Current Graphics PositionMPROJECTIONIDREF="03.finish62"Porting Matrix and Transformation CallsMTEXTUREIDREF="03.finish58"Porting Matrix and Transformation Callsmultimap()IDREF="03.finish235"Color Callsmultiplying matricesIDREF="03.finish13"Porting Matrix and Transformation Callsmultmatrix()IDREF="03.finish25"Porting Matrix and Transformation CallsIDREF="03.finish11"Porting Matrix and Transformation CallsMVIEWINGIDREF="03.finish60"Porting Matrix and Transformation Callsnormalsand GLU quadricsIDREF="03.finish87"The IRIS GL Sphere LibraryNURBScontrol pointsIDREF="03.finish304"NURBS Objectscurve typesIDREF="03.finish313"NURBS CurvesobjectsIDREF="03.finish300"NURBS Objectsstride parameterIDREF="03.finish304"NURBS Objectssurface typesIDREF="03.finish334"NURBS SurfacessurfacesIDREF="03.finish327"NURBS SurfacestrimmingIDREF="03.finish317"Trimming Curvesnurbscurve()IDREF="03.finish323"Trimming CurvesIDREF="03.finish309"NURBS Curvesnurbssurface()IDREF="03.finish330"NURBS Surfacesobjdelete()IDREF="03.finish411"Porting Display Listsobjinsert()IDREF="03.finish412"Porting Display Listsobjreplace()IDREF="03.finish413"Porting Display Listsonemap()IDREF="03.finish236"Color CallsOpenGL extensionsIDREF="03.finish598"OpenGL ExtensionsOpenGL widgetIDREF="05.mixed57"Using the OpenGL Widgetopening windowsauxiliary libraryIDREF="04.auxlib26"Replacing winopen() with auxInitWindow()ortho()IDREF="03.finish32"Porting Matrix and Transformation Callsortho2()IDREF="03.finish34"Porting Matrix and Transformation Callsparentheses, and tooglIDREF="02.toogl13"Parentheses and Quotespass/fail operationsstencil planesIDREF="03.finish407"Stencil Plane Callspassthrough()IDREF="03.finish595"Porting Feedback Callspatch()IDREF="03.finish298"Porting Curve and Surface Commandspatchbasis()IDREF="03.finish295"Porting Curve and Surface Commandspatchcurves()IDREF="03.finish296"Porting Curve and Surface Commandspatchprecision()IDREF="03.finish297"Porting Curve and Surface Commandspclos()IDREF="03.finish144"Polygons and QuadrilateralsIDREF="03.finish8"Porting Commands that Required Current Graphics Positionpdr()IDREF="03.finish8"Porting Commands that Required Current Graphics PositionIDREF="03.finish8"Porting Commands that Required Current Graphics PositionIDREF="03.finish143"Polygons and QuadrilateralsperformanceIDREF="02.toogl17"Performanceperspective()IDREF="03.finish36"Porting Matrix and Transformation Callspick()IDREF="03.finish574"Porting Picking CallspickingIDREF="03.finish573"Porting Picking Callspicksize()IDREF="03.finish38"Porting Matrix and Transformation CallsIDREF="03.finish580"Porting Picking Callspixel operationsIDREF="03.finish249"Porting Pixel Operationspixmode()IDREF="03.finish267"Porting Pixel OperationsIDREF="03.finish265"Porting Pixel Operationspmv()IDREF="03.finish142"Polygons and QuadrilateralsIDREF="03.finish8"Porting Commands that Required Current Graphics Positionpnt()IDREF="03.finish105"Pointspntsize()IDREF="03.finish110"Pointspntsmooth()IDREF="03.finish113"PointsIDREF="03.finish365"Antialiasing CallspointsIDREF="03.finish104"PointsantialiasingIDREF="03.finish112"Pointsquadric routinesIDREF="03.finish87"The IRIS GL Sphere Libraryset point sizeIDREF="03.finish112"Pointsvertices as pointsIDREF="03.finish112"Pointspol()IDREF="03.finish141"Polygons and Quadrilateralspolarview()IDREF="03.finish14"Porting Matrix and Transformation Callspolling callsIDREF="04.auxlib31"Event Handling: Replacing qdevice(), qtest(), and qread() poly()IDREF="03.finish140"Polygons and QuadrilateralspolygonsIDREF="03.finish137"Polygons and Quadrilateralsarcs, circlesIDREF="03.finish189"Arcs and Circlesback/frontIDREF="03.finish164"Polygon ModesconcaveIDREF="03.finish176"Tessellated PolygonsmodesIDREF="03.finish139"Polygons and QuadrilateralsIDREF="03.finish164"Polygon Modesquadric routinesIDREF="03.finish87"The IRIS GL Sphere LibrarystipplesIDREF="03.finish167"Polygon StipplestessellatedIDREF="03.finish176"Tessellated PolygonstrianglesIDREF="03.finish185"Trianglespolymode()IDREF="03.finish156"Polygons and QuadrilateralsIDREF="03.finish166"Polygon Modespolynomial curveIDREF="03.finish314"NURBS CurvesIDREF="03.finish335"NURBS Surfacespolysmooth()IDREF="03.finish368"Antialiasing Callspopmatrix()IDREF="03.finish40"Porting Matrix and Transformation Callspopname()IDREF="03.finish586"Porting Picking Callspopviewport()IDREF="03.finish75"Viewports, Screenmasks, and Scrboxesporting toolsIDREF="01.begin2"Tools and Libraries to Help Port Your Codeporting, how toIDREF="01.begin3"How to Port Your Code to OpenGLPOSITIONIDREF="03.finish479"Porting Lighting and Materials Callsprefposition()IDREF="04.auxlib6"Replacing prefposition() with auxInitPosition()projection matrixIDREF="03.finish56"Porting Matrix and Transformation Callspushmatrix()IDREF="03.finish42"Porting Matrix and Transformation Callspushname()IDREF="03.finish585"Porting Picking Callspushviewport()IDREF="03.finish76"Viewports, Screenmasks, and Scrboxespwlcurve()IDREF="03.finish321"Trimming Curvesqread()IDREF="05.mixed11"What Is a Mixed-Model Program?quadrics routinesIDREF="03.finish85"The IRIS GL Sphere LibraryquadrilateralsIDREF="03.finish137"Polygons and Quadrilateralsqueuing callsIDREF="04.auxlib31"Event Handling: Replacing qdevice(), qtest(), and qread() quotes, and tooglIDREF="02.toogl13"Parentheses and Quotesrational curvesIDREF="03.finish315"NURBS CurvesIDREF="03.finish336"NURBS Surfacesrcrv()IDREF="03.finish292"Porting Curve and Surface Commandsrcrvn()IDREF="03.finish293"Porting Curve and Surface Commandsrdr()IDREF="03.finish8"Porting Commands that Required Current Graphics PositionreadRGB()IDREF="03.finish252"Porting Pixel Operationsreadsource()IDREF="03.finish263"Porting Pixel OperationsRealityEngine graphicsIDREF="03.finish597"Porting RealityEngine Graphics Featuresrect()IDREF="03.finish158"Polygons and Quadrilateralsrectangles, drawingIDREF="03.finish161"Polygons and Quadrilateralsrectcopy()IDREF="03.finish257"Porting Pixel Operationsrectf()IDREF="03.finish159"Polygons and Quadrilateralsrectread()IDREF="03.finish251"Porting Pixel Operationsrectwrite()IDREF="03.finish255"Porting Pixel Operationsrectzoom()IDREF="03.finish259"Porting Pixel Operationsredraw eventsIDREF="04.auxlib34"Event Handling: Replacing qdevice(), qtest(), and qread() rendering, directIDREF="02.toogl19"Performancerepeat factorlinesIDREF="03.finish115"Linesresetls()IDREF="03.finish135"Linesreshapeviewport()IDREF="03.finish70"Viewports, Screenmasks, and Scrboxesresize eventsIDREF="04.auxlib35"Handling Redraw EventsRGB, simulating with color mapIDREF="05.mixed24"Installing Color MapsRGBA-modeauxiliary libraryIDREF="04.auxlib10"Porting Display Mode Initialization Calls with auxInitDisplayMode()RGBcolor()IDREF="03.finish224"Color CallsRGBmode()IDREF="04.auxlib21"Porting Display Mode Initialization Calls with auxInitDisplayMode()RGBwritemask()IDREF="03.finish228"Color Callsrot()IDREF="03.finish45"Porting Matrix and Transformation Callsrotate()IDREF="03.finish12"Porting Matrix and Transformation CallsIDREF="03.finish44"Porting Matrix and Transformation CallsrotationsIDREF="03.finish12"Porting Matrix and Transformation Callsrpatch()IDREF="03.finish299"Porting Curve and Surface Commandsrpdr()IDREF="03.finish146"Polygons and Quadrilateralsrpmv()IDREF="03.finish145"Polygons and QuadrilateralsIDREF="03.finish8"Porting Commands that Required Current Graphics Positionrunning auxiliary library programIDREF="04.auxlib3"Running a Program That Uses the Auxiliary Librarysbox()IDREF="03.finish162"Polygons and Quadrilateralssboxf()IDREF="03.finish163"Polygons and Quadrilateralsscale()IDREF="03.finish48"Porting Matrix and Transformation Callsscaling imagesIDREF="03.finish519"Porting Texture Callssclear()IDREF="03.finish10"Porting Screen and Buffer Clearing CommandsIDREF="03.finish404"Stencil Plane Callsscrbox()IDREF="03.finish71"Viewports, Screenmasks, and ScrboxesscreenclearingIDREF="03.finish7"Porting Commands that Required Current Graphics Positionscrmask()IDREF="03.finish81"Clipping Planesselect()IDREF="03.finish575"Porting Picking Callssetlinestyle()IDREF="03.finish126"LinesIDREF="03.finish443"Porting defs, binds, and sets: Replacing `Tables' of Stored Definitionssetmap()IDREF="03.finish238"Color Callssetpattern()IDREF="03.finish171"Polygon StipplesIDREF="03.finish445"Porting defs, binds, and sets: Replacing `Tables' of Stored DefinitionssetsIDREF="03.finish435"Porting defs, binds, and sets: Replacing `Tables' of Stored Definitionssetting matrix modeIDREF="03.finish20"Porting Matrix and Transformation Callsshademodel()IDREF="03.finish241"Shading ModelsshadingIDREF="03.finish209"Porting Color, Shading, and Writemask CommandsIDREF="03.finish247"Shading ModelsSHININESSIDREF="03.finish470"Porting Lighting and Materials Callssingle pointsIDREF="03.finish104"Pointssingle-buffer modeauxiliary libraryIDREF="04.auxlib10"Porting Display Mode Initialization Calls with auxInitDisplayMode()single-matrix modeIDREF="03.finish12"Porting Matrix and Transformation Callssinglebuffer()IDREF="04.auxlib22"Porting Display Mode Initialization Calls with auxInitDisplayMode()slices, spheresIDREF="03.finish197"Spheressmooth shadingIDREF="03.finish247"Shading Modelssmoothline()IDREF="03.finish132"Linesspclos()IDREF="03.finish148"Polygons and QuadrilateralsSPECULARIDREF="03.finish466"Porting Lighting and Materials Callsspecular lighting componentsIDREF="03.finish447"Porting Lighting and Materials Callssphdraw()IDREF="03.finish204"SpheresIDREF="03.finish198"Spheressphereusing quadricsIDREF="03.finish87"The IRIS GL Sphere Librarysphere libraryIDREF="03.finish85"The IRIS GL Sphere LibraryspheresIDREF="03.finish197"Spheresslices, stacksIDREF="03.finish197"Spheressphfree()IDREF="03.finish202"Spheressphgnpolys()IDREF="03.finish208"Spheressphmode()IDREF="03.finish206"Spheressphobj()IDREF="03.finish200"Spheressphrotmatrix()IDREF="03.finish207"Spheressplf()IDREF="03.finish147"Polygons and QuadrilateralsSPOTDIRECTIONIDREF="03.finish481"Porting Lighting and Materials CallsSPOTLIGHTIDREF="03.finish483"Porting Lighting and Materials Callsstacks, spheresIDREF="03.finish197"Spheresstate attribute groupsIDREF="03.finish5"Porting greset()state variables, saving/restoringIDREF="03.finish2"Porting greset()stencil function flagsIDREF="03.finish405"Stencil Plane Callsstencil planesIDREF="03.finish394"Stencil Plane Callsstencil()IDREF="04.auxlib23"Porting Display Mode Initialization Calls with auxInitDisplayMode()IDREF="03.finish397"Stencil Plane Callsstencil-buffer modeauxiliary libraryIDREF="04.auxlib10"Porting Display Mode Initialization Calls with auxInitDisplayMode()stensize()IDREF="03.finish396"Stencil Plane Callssteps to portingIDREF="01.begin3"How to Port Your Code to OpenGLstippled polygonsIDREF="03.finish167"Polygon Stipplesstored definitionsIDREF="03.finish435"Porting defs, binds, and sets: Replacing `Tables' of Stored Definitionsstride parameter, NURBSIDREF="03.finish304"NURBS ObjectsstringsIDREF="05.mixed26"Fonts and Stringssubpixel modeIDREF="03.finish338"Porting Antialiasing Callssurface types, NURBSIDREF="03.finish334"NURBS SurfacessurfacesIDREF="03.finish286"Porting Curve and Surface Commandssurfaces, NURBSIDREF="03.finish327"NURBS Surfacesswaptmesh()IDREF="03.finish186"Trianglesswritemask()IDREF="03.finish401"Stencil Plane Callst2()IDREF="03.finish510"Porting Texture CallstablesIDREF="03.finish435"Porting defs, binds, and sets: Replacing `Tables' of Stored Definitionstessellated polygonsIDREF="03.finish176"Tessellated PolygonsIDREF="03.finish138"Polygons and Quadrilateralstest functions, alphaIDREF="03.finish347"afunction() Test Functionstevbind()IDREF="03.finish439"Porting defs, binds, and sets: Replacing `Tables' of Stored DefinitionsIDREF="03.finish507"Porting Texture Callstevdef()IDREF="03.finish438"Porting defs, binds, and sets: Replacing `Tables' of Stored DefinitionsIDREF="03.finish520"Translating tevdef()IDREF="03.finish505"Porting Texture Callstexbind()IDREF="03.finish441"Porting defs, binds, and sets: Replacing `Tables' of Stored DefinitionsIDREF="03.finish501"Porting Texture Callstexdef()IDREF="03.finish440"Porting defs, binds, and sets: Replacing `Tables' of Stored DefinitionsIDREF="03.finish531"Translating texdef()texdef2d()IDREF="03.finish497"Porting Texture Callstexgen()IDREF="03.finish513"Porting Texture CallsIDREF="03.finish555"Translating texgen()text handlingIDREF="05.mixed25"Fonts and Stringstexturewith quadricsIDREF="03.finish87"The IRIS GL Sphere LibrarytexturesIDREF="03.finish492"Porting Texture CallsTG_CONTOURIDREF="03.finish568"Translating texgen()TG_LINEARIDREF="03.finish565"Translating texgen()TG_SPHEREMAPIDREF="03.finish571"Translating texgen()toogland spaces, tabsIDREF="02.toogl6"Hints for Using toogl EffectivelyC comments andIDREF="02.toogl10"Hints for Using toogl Effectively callingIDREF="02.toogl1"How to Get and Call tooglcommentsIDREF="02.toogl5"What toogl Will and Won't Do for Youdevice callsIDREF="02.toogl12"Windowing, Device, and Event Callsediting outputIDREF="02.toogl11"Editing toogl Output: Areas that Need Special Attentionevent callsIDREF="02.toogl12"Windowing, Device, and Event CallsoptionsIDREF="02.toogl2"How to Get and Call tooglparentheses and quotesIDREF="02.toogl13"Parentheses and Quotesprocessing entire directoryIDREF="02.toogl3"How to Get and Call toogltipsIDREF="02.toogl8"Hints for Using toogl Effectivelywindowing callsIDREF="02.toogl12"Windowing, Device, and Event Callstools for portingIDREF="01.begin2"Tools and Libraries to Help Port Your CodetransformationsIDREF="03.finish12"Porting Matrix and Transformation Callstranslate()IDREF="03.finish51"Porting Matrix and Transformation CallstraversalIDREF="05.mixed52"About the GLwDrawingArea Widgettriangle fansIDREF="03.finish185"Trianglestriangle stripsIDREF="03.finish185"TrianglestrianglesIDREF="03.finish185"Trianglestrimming curvesIDREF="03.finish317"Trimming CurvesTV_ALPHAIDREF="03.finish529"Translating tevdef()TV_BLENDIDREF="03.finish525"Translating tevdef()TV_COLORIDREF="03.finish527"Translating tevdef()TV_COMPONENT_SELECTIDREF="03.finish530"Translating tevdef()TV_DECALIDREF="03.finish523"Translating tevdef()TV_MODULATEIDREF="03.finish521"Translating tevdef()two-sided lightingIDREF="03.finish490"Porting Lighting and Materials CallsTX_BILINEARIDREF="03.finish545"Translating texdef()TX_MAGFILTERIDREF="03.finish534"Translating texdef()TX_MINFILTERIDREF="03.finish532"Translating texdef()TX_MIPMAP_BILINEARIDREF="03.finish549"Translating texdef()TX_MIPMAP_LINEARIDREF="03.finish551"Translating texdef()TX_MIPMAP_POINTIDREF="03.finish547"Translating texdef()TX_POINTIDREF="03.finish543"Translating texdef()TX_QIDREF="03.finish563"Translating texgen()TX_RIDREF="03.finish561"Translating texgen()TX_SIDREF="03.finish557"Translating texgen()TX_TIDREF="03.finish559"Translating texgen()TX_TRILINEARIDREF="03.finish553"Translating texdef()TX_WRAPIDREF="03.finish539"Translating texdef()IDREF="03.finish536"Translating texdef()TX_WRAP_SIDREF="03.finish537"Translating texdef()TX_WRAP_TIDREF="03.finish540"Translating texdef()User Interface LanguageIDREF="05.mixed34"Porting to Mixed-Model Using Xt and a Widget Setv()IDREF="03.finish99"The v() CommandsverticesIDREF="03.finish99"The v() Commandsviewport()IDREF="03.finish74"Viewports, Screenmasks, and Scrboxesvisualfor stencil planesIDREF="03.finish394"Stencil Plane Callsvisualsfor blendingIDREF="03.finish341"Blendingwidget setIDREF="05.mixed13"Using Xt and a Widget Setwidget setsIDREF="05.mixed32"Porting to Mixed-Model Using Xt and a Widget Setwindow depthIDREF="05.mixed18"You Can't Change Window Depth and Display Modewindow()IDREF="03.finish54"Porting Matrix and Transformation Callswindowingevent handlingIDREF="04.auxlib5"Windowingwindowing callstooglIDREF="02.toogl12"Windowing, Device, and Event Callswindowsmixed modelIDREF="05.mixed7"What Is a Mixed-Model Program?XlibIDREF="05.mixed72"Code Example: Opening a Window with OpenGL GLXwinopen()IDREF="04.auxlib28"Replacing winopen() with auxInitWindow()IDREF="05.mixed10"What Is a Mixed-Model Program?wmpack()IDREF="03.finish227"Color CallsWorkProcIDREF="05.mixed63"Using the OpenGL Widgetwritemask()IDREF="03.finish225"Color CallswritemasksIDREF="03.finish209"Porting Color, Shading, and Writemask CommandsXmixed modelIDREF="05.mixed4"What Is a Mixed-Model Program?X and GL mixed programs, see mixed-model programmingIDREF="05.mixed3"Mixed-Model ProgrammingX bitmap fontsIDREF="05.mixed29"Fonts and StringsX documentationIDREF="intro1"Where To Get More InformationIDREF="05.mixed64"Other Information Sources for Mixed-Model ProgrammingX functionsXSetWMColormapWindows()IDREF="05.mixed19"Installing Color MapsIDREF="05.mixed21"Installing Color MapsX Toolkit IntrinsicsIDREF="05.mixed40"What is Xt?XCreateWindow()IDREF="05.mixed70"Mixed-Model Programming Using Xlib and OpenGL GLX CommandsXlibIDREF="05.mixed12"Two Choices For Mixed-Model ProgrammingIDREF="05.mixed66"Mixed-Model Programming Using Xlib and OpenGL GLX Commandscolor mapsIDREF="05.mixed73"X Color Mapsevent handlingIDREF="05.mixed74"A Sample X Event LoopwindowsIDREF="05.mixed72"Code Example: Opening a Window with OpenGL GLXXmForm widgetIDREF="05.mixed62"Using the OpenGL WidgetXOpenDisplay()IDREF="05.mixed67"Mixed-Model Programming Using Xlib and OpenGL GLX CommandsXSetWMColormapWindows()IDREF="05.mixed23"Installing Color MapsXStoreColor()IDREF="03.finish223"Color CallsXtIDREF="05.mixed12"Two Choices For Mixed-Model ProgrammingIDREF="05.mixed32"Porting to Mixed-Model Using Xt and a Widget SetIDREF="05.mixed36"What You Need to Know About Xt and IRIS IMmixed model programmingIDREF="05.mixed56"Using the OpenGL Widgetzbuffer()IDREF="04.auxlib24"Porting Display Mode Initialization Calls with auxInitDisplayMode()zclear()IDREF="03.finish10"Porting Screen and Buffer Clearing Commandszwritemask()IDREF="03.finish233"Color Calls