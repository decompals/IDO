#EDIR DATA#
LANG=CIRIS ViewKit‘ Programmer's GuideDocument Number 007-2124-002CONTRIBUTORSWritten by Ken Jones, Douglas B. O'MorainEdited by Christina CaryProduction by Gloria AckleyEngineering contributions by Doug Young, Kim Rachmeler, Mike Yang© Copyright 1994, Silicon Graphics, Inc.name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' All Rights ReservedThis document contains proprietary and confidential information of Silicon Graphics, Inc. The contents of this document may not be disclosed to third parties, copied, or duplicated in any form, in whole or in part, without the prior written permission of Silicon Graphics, Inc.RESTRICTED RIGHTS LEGENDUse, duplication, or disclosure of the technical data contained in this document by the Government is subject to restrictions as set forth in subdivision (c) (1) (ii) of the Rights in Technical Data and Computer Software clause at DFARS 52.227-7013 and/or in similar or successor clauses in the FAR, or in the DOD or NASA FAR Supplement. Unpublished rights reserved under the Copyright Laws of the United States. Contractor/manufacturer is Silicon Graphics, Inc., 2011 N. Shoreline Blvd., Mountain View, CA 94039-7311.Silicon Graphics, the Silicon Graphics logo, and IRIS are registered trademarks and IRIS IM, IRIS Insight, IRIS ViewKit and IRIX are trademarks of Silicon Graphics, Inc. X Window System is a trademark of Massachusetts Institute of Technology. Motif and OSF/Motif are trademarks of Open Software Foundation. NetLS and Network License System are trademarks of Apollo Computer, Inc., a subsidiary of Hewlett-Packard Company. ToolTalk is a trademark of Sun Microsystems, Inc. PostScript is a registered trademark of Adobe Systems, Inc.IntroductionThis guide describes how to create programs using IRIS ViewKit‘, a C++ toolkit that provides commonly needed facilities for applications based on the IRIS IM‘ user interface toolkit (the Silicon Graphics port of the industry-standard OSF/Motif‘ user interface toolkit for use on Silicon Graphics workstations).ID="Intro1"LBL="" HELPID=""What This Guide ContainsThe first two chapters of this guide provide an overview of ViewKit concepts:IDREF="89028" TYPE="TITLE"Chapter 1, "Overview of ViewKit"describes the ViewKit toolkit and the advantages of using it compared to programming directly in IRIS IM and X, discusses the major elements of ViewKit, and provides instructions for compiling ViewKit programs.IDREF="41696" TYPE="TITLE"Chapter 2, "Components"describes the ViewKit component class, gives instructions for using ViewKit components, and lists guidelines for creating new components.The next six chapters describe the common ViewKit components that you use in practically every ViewKit program:IDREF="88118" TYPE="TITLE"Chapter 3, "The ViewKit Application Class"explains the services provided by the ViewKit application class and gives instructions for controlling application-level services in your program.IDREF="45296" TYPE="TITLE"Chapter 4, "ViewKit Windows"explains ViewKit's model for supporting multiple windows in an application, and describes how to create and manipulate application windows.IDREF="84022" TYPE="TITLE"Chapter 5, "Creating Menus With ViewKit"describes how to create and manipulate different types of menus in a ViewKit application.IDREF="56221" TYPE="TITLE"Chapter 6, "ViewKit Undo Management and Command Classes"explains how to implement support for "undoing" operations and describes how to implement actions as command classes.IDREF="57775" TYPE="TITLE"Chapter 7, "Using Dialogs in ViewKit"discusses ViewKit's dialog management support, describes how to post and manipulate dialogs, and provides an overview of the different types of dialogs supported by ViewKit.IDREF="12344" TYPE="TITLE"Chapter 8, "Preference Dialogs"describes how to use preference dialogs to maintain user preferences.The rest of the book describes pre-built ViewKit components:IDREF="92023" TYPE="TITLE"Chapter 9, "The ViewKit Graph Component"discusses the ViewKit component for creating and displaying arc-and-node graphs.IDREF="37403" TYPE="TITLE"Chapter 10, "Miscellaneous ViewKit Display Classes"describes a variety of components that you use primarily to display information or to manage display items.IDREF="72893" TYPE="TITLE"Chapter 11, "Miscellaneous ViewKit Data Input Classes"describes a variety of data input classes.IDREF="12593" TYPE="TITLE"Chapter 12, "The ViewKit NetLS Interface"discusses ViewKit's network licensing support.IDREF="83598" TYPE="TITLE"Appendix A, "ViewKit Interprocess Message Facility"describes ViewKit's support for interprocess communication.IDREF="46022" TYPE="TITLE"Appendix B, "Contributed ViewKit Classes"gives you an idea of how you can expand ViewKit by describing some unsupported ViewKit classes that users have contributed.IDREF="91883" TYPE="TITLE"Appendix C, "Using a Help System with ViewKit"explains how to use a help system with ViewKit applications. It also describes the basic help system provided with ViewKit.LBL="" HELPID=""What You Should Know Before Reading This GuideThis guide assumes that you are already an experienced C++ programmer. It also assumes that you are generally familiar with IRIS IM.For a thorough discussion of the concepts on which the ViewKit toolkit is based, see:ID="Intro2"ID="Intro3"Young, Douglas A. Object-Oriented Programming with C++ and OSF/Motif. Englewood Cliffs, New Jersey: Prentice Hall, Inc., 1992.For information on OSF/Motif, see:ID="Intro4"Open Software Foundation. OSF/Motif Programmer's Guide, Revision 1.2. Englewood Cliffs, New Jersey: Prentice Hall, Inc., 1992.Open Software Foundation. OSF/Motif Programmer's Reference, Revision 1.2. Englewood Cliffs, New Jersey: Prentice Hall, Inc., 1992.Open Software Foundation. OSF/Motif Style Guide, Revision 1.2. Englewood Cliffs, New Jersey: Prentice Hall, Inc., 1992.Heller, Dan. Motif Programming Manual (X Window System Series: Volume Six). Sebastopol, California: O'Reilly & Associates, Inc., 1992.For information on IRIS IM enhancements to OSF/Motif and general tips for programming in IRIS IM on Silicon Graphics workstations, refer to the ID="Intro5"IRIS IM Programming Notes.For comprehensive information on the X Window System‘, Xlib, and Xt, see:ID="Intro6"Nye, Adrian. Xlib Programming Manual (X Window System Series: Volume One). Sebastopol, California: O'Reilly & Associates, Inc., 1992.O'Reilly & Associates, Inc. Xlib Reference Manual (X Window System Series: Volume Two). Sebastopol, California: O'Reilly & Associates, Inc., 1992.Nye, Adrian, and Tim O'Reilly. X Toolkit Intrinsics Programming Manual (X Window System Series: Volume Four). Sebastopol, California: O'Reilly & Associates, Inc., 1992.O'Reilly & Associates, Inc. X Toolkit Intrinsics Reference Manual (X Window System Series: Volume Five). Sebastopol, California: O'Reilly & Associates, Inc., 1992.LBL="" HELPID=""Conventions Used in This GuideThis section describes the conventions used for presenting information in this book.ID="Intro7"LBL="" HELPID=""Typographical ConventionsThese type conventions and symbols are used in this guide:ID="Intro8"ID="Intro9"BoldC++ class names, C++ member functions, C++ data members, function names, literal command-line arguments (options and flags)ItalicsFilenames; onscreen button names; IRIX‘ commands; executable files; manual and book titles; glossary entries; new terms; variable command-line arguments; program variables; and variables to be supplied by the user in examples, code, and syntax statementsScreen typeOnscreen text, prompts, error messages, examples, and code listingsBold screen typeUser input, including keyboard keys (printing and nonprinting); literals supplied by the user in examples, code listings, and syntax statements""(Double quotation marks) Onscreen menu items and references in text to document section titles()(Parentheses) Follow function names; also used to surround reference page (man page) section in which a command, function, or class is described<>(Angle brackets) Surround nonprinting keyboard keys, for example, <Esc>, <Ctrl-D>#IRIX shell prompt for the superuser (root)%IRIX shell prompt for users other than superuserReference pages (also known as man pages) are referred to by name and section number, in this format: name(section), where "name" is the name of a command, system call, library routine, or class; and "section" is the section number where the entry resides. For example, XtSetValues(3Xt) refers to the ID="Intro10"ID="Intro11"ID="Intro12"XtSetValues() reference page in section 3Xt.LBL="" HELPID=""Class Inheritance Graph ConventionsMost of the chapters in this book begin with a graph depicting the inheritance hierarchy of the classes described in that chapter. ID="Intro13"ID="Intro14"ID="Intro15"IDREF="64079" TYPE="TEXT"Figure i shows an example of a class inheritance graph that might appear at the beginning of a chapter.FILE="Fig0-1.ai" POSITION="INLINE" SCALE="FALSE"LBL="i"Figure i ID="64079"Example of a Class Inheritance GraphIn these inheritance graphs, classes are presented with the base classes to the left and the derived classes to the right. Abstract classes have dashed borders and non-abstract classes have solid borders. Classes described within the chapter appear in white boxes, whereas classes described elsewhere appear in shaded boxes.In the inheritance graph shown in IDREF="64079" TYPE="TEXT"Figure i, VkComponent is an abstract base class. As indicated by its shaded box, it is not described within the chapter. The chapter describes three subclasses of VkComponent: VkDoubleBuffer, an abstract class; and VkTickMarks and VkResizer, non-abstract classes. The chapter also discusses the non-abstract class VkAlignmentGroup, which is derived from the non-abstract base class VkWidgetList.LBL="1"ID="89028"Overview of ViewKitViewKit is a C++ toolkit that makes it easier for you to develop applications. It provides a collection of high-level user interface components and other support facilities that you typically must implement in every application. For example, it provides high-level user interface components, such as windows, menus, and dialogs.ID="Ch01_Overview1"ViewKit does not replace IRIS IM or any other user interface toolkit. In fact, it uses IRIS IM widgets to implement all of its user interface components; also, you can directly call IRIS IM functions to create and manipulate widgets in a ViewKit application. The ViewKit architecture helps mask much of the complexity of programming with IRIS IM.ViewKit offers you several benefits:ID="Ch01_Overview2"It provides support for common user interface components such as windows, menus, and dialogs. It also provides specialty interface components for tasks such as displaying and managing arc-and-node graphs, displaying and managing toggle check boxes, and managing the layout of other widgets. Creating these elements using ViewKit is much simpler and faster than using low-level widgets to build them from scratch. Furthermore, by using the same basic components, applications that use ViewKit components have greater visual and behavioral consistency.It simplifies interaction with the X resource manager, allowing you to customize your application using resources more easily. By designing your application to use resource values rather than hard-coding the values in your program, you can easily modify the appearance of your application. This approach is particularly useful for preparing your application for internationalization.All user interface components in ViewKit are C++ classes, which provides a framework for using IRIS IM in a highly structured, object-oriented way. The ViewKit architecture encourages you to develop self-contained objects that you can re-use in multiple applications.It provides support for other common application services such as interprocess communication and interfacing to the Network License System‘.LBL="" HELPID=""Major ViewKit ElementsYou can think of ViewKit as consisting of several sets of classes: framework classes, interface components, network licensing, interapplication communication, and convenience utilities. The following sections discuss these groups.ID="Ch01_Overview3"LBL="" HELPID=""Framework ClassesViewKit provides a small set of classes that are either essential for all applications or provide fundamental support for all other classes. The most basic of these classes is the VkComponent class, which defines the basic structure of all user interface components. All user interface classes are derived from VkComponent.The framework classes also include support for features needed by nearly all applications, including application management and X server setup, top-level windows, menus, and dialog management. All classes are designed to implement as many typical features as possible. For example: all top-level windows and dialogs handle the window manager quit/close protocol; dialogs are cached to balance memory use and display speed; the menu system goes beyond simply constructing menus to support dynamically adding, removing, replacing items, and more.The classes that make up the framework of ViewKit are closely integrated and work together to support essential features required by most applications as automatically as possible. Among the basic services supported by the core ViewKit framework are: single and multi-level undo; interruptible tasks; and an application-level callback mechanism that allows C++ classes to dynamically register member functions to be invoked by other C++ classes.LBL="" HELPID=""Interface ComponentsIn addition to the basic user interface support provided by the core framework classes, ViewKit provides an assortment of ready-to-use interface components. Examples of these components are a graph viewer/editor, an input field that supports name expansion, and an outliner component for displaying and manipulating hierarchical information.You are encouraged to use the architecture of ViewKit to create new components and extend existing components. Creating reusable, high-level components promotes consistency throughout a set of applications by providing elements that users can learn once and then easily recognize in multiple applications.LBL="" HELPID=""Network LicensingThe NetLS‘ network licensing manager provides low-level facilities to support license-protected applications. ViewKit makes it easy for you to use this license protection. To license-protect a ViewKit application, simply instantiate a VkNLS object, providing some simple information about the application in the VkNLS constructor. ViewKit automatically checks for license expiration at regular intervals, displays various dialogs when error situations occur, and closes down applications that are not properly licensed.LBL="" HELPID=""Interapplication CommunicationMany applications need to be able to communicate with other applications to work effectively. ViewKit builds on the ToolTalk‘ interapplication communications service to support simple and effective interapplication communication.LBL="" HELPID=""Convenience UtilitiesViewKit provides various utility functions and classes for your convenience. These utilities include simple functions that make it easier to load resources (including automatic type conversion), classes that support the use of icons, and other miscellaneous utilities.LBL="" HELPID=""Mixing ViewKit and Standard X and IRIS IM FunctionsAs stated earlier, ViewKit does not replace IRIS IM. It uses IRIS IM widgets to implement all of its user interface components, and you are free to make X and IRIS IM calls directly in a ViewKit application. ViewKit doesn't do anything that you can't do yourself using IRIS IM directly, but the advantage of using ViewKit is that many commonly-needed services are already implemented for you.ID="Ch01_Overview4"Naturally, not all ViewKit services are appropriate for all applications at all times. If a situation arises in which a ViewKit facility doesn't meet your needs, you can use the lower-level IRIS IM, Xt, or Xlib facilities to perform the desired operation yourself.Most ViewKit classes are optional; however, you should be aware that certain ViewKit classes depend on other classes. In particular, most classes depend on the existence of an instance of the ID="Ch01_Overview5"ID="Ch01_Overview6"VkApp class for application management. If you plan to use any ViewKit facilities, you should not attempt to bypass VkApp and open your own connection to the X server, or directly call XtAppInitialize() or an equivalent function. For best results, you should always allow VkApp to handle the Xt initialization and event dispatching. VkApp is described in detail in IDREF="88118" TYPE="TITLE"Chapter 3, "The ViewKit Application Class."Also, you should use VkSimpleWindow or VkWindow for all top-level windows. These classes are described in detail in IDREF="45296" TYPE="TITLE"Chapter 4, "ViewKit Windows."As an example of some optional classes, consider the ViewKit dialog management facilities. These are intended to let you use dialogs easily and effectively. ViewKit automatically recycles dialogs (reusing the same dialog over and over for multiple purposes), which uses less memory and can lead to faster response times. It is also easy to add additional buttons to any dialog, to provide context-sensitive help on individual dialogs, and much more. The ViewKit dialog management facility is designed to be as flexible as possible, while minimizing the amount of work required of you. You can even write your own custom dialogs that take advantage of the dialog manager.However, because the design of the ViewKit dialog management classes makes assumptions about the way typical applications use dialogs, the ViewKit dialog manager can't offer the same control that you could obtain by directly constructing and manipulating an IRIS IM dialog. Should you encounter a situation where the behavior of the dialog manager doesn't match your application's needs, you can always take the same approach you would have to take if the dialog manager didn't exist: create and manipulate your own IRIS IM dialog directly using IRIS IM and Xt functions. This doesn't interfere with ViewKit in any way.Before implementing your own mechanisms, you should be sure you understand the support offered by ViewKit. Situations in which it's necessary to duplicate functionality supported by ViewKit should be rare. On the other hand, extending the class library by deriving new classes, or writing completely new classes to meet application-specific needs, is a natural part of developing any application based on ViewKit or any C++ class library.LBL="" HELPID=""Compiling and Linking ViewKit ProgramsThis section describes how to compile ViewKit programs.ID="Ch01_Overview7"LBL="" HELPID=""Required PackagesTo compile and link with the ViewKit libraries, you must install the IRIS Development Option (IDO). This option includes the C compiler and the X Window System‘ and IRIS IM development systems. You must also install the C++ Development Option, including the ViewKit development option subsystems. Consult the ID="Ch01_Overview8"ID="Ch01_Overview9"ID="Ch01_Overview10"ID="Ch01_Overview11"ViewKit Release Notes for a complete list of subsystems that you must install on your system to compile and link ViewKit programs.The ViewKit development option contains the following subsystems:ID="Ch01_Overview12"ViewKit_dev.sw.baseYou are required to install this subsystem, which contains the optimized, unshared C++ ViewKit libraries and include files. (The shared ViewKit libraries are included in the IRIX system software as the ViewKit_eoe.sw.base subsystem.)ViewKit_dev.sw.debugThis subsystem contains the debug version of the optimized ViewKit libraries. You can optionally install this subsystem in addition to the ViewKit_dev.sw.base subsystem. Use this library for program debugging only.ViewKit_dev.man.pagesThe complete set of C++ reference pages (man pages) for ViewKit. This subsystem is optional, but recommended.ViewKit_dev.man.relnotesThe online version of the ViewKit Release Notes. This subsystem is optional, but recommended.ViwKit_dev.books.ViewKit_PGThe IRIS Insight‘ version of this guide. This subsystem is optional, but recommended.ViewKit_dev.sw.demoSample source code to various ViewKit programs. This subsystem is optional, but recommended.The ID="Ch01_Overview13"ViewKit_dev.sw.base subsystem installs the following libraries:libvk.aThe basic ViewKit class librarylibvkmsg.aClasses that support inter-process communication based on the ToolTalk librarylibXpm.aA library that supports X pixmap creation. This is a freely available library, Copyright © 1990, 1991 GROUPE BULL. Some viewkit classes use Xpm.libvkhelp.aA basic help system that you can use with ViewKit applications. IDREF="91883" TYPE="TITLE"Appendix C, "Using a Help System with ViewKit," describes how to use this library.The ID="Ch01_Overview14"ViewKit_dev.sw.debug subsystem installs the following libraries:libvk_d.aThe debug version of the basic ViewKit class librarylibvkmsg_d.aThe debug version of the classes that support inter-process communication based on the ToolTalk libraryLBL="" HELPID=""Required Header FilesAll ViewKit header files appear in ID="Ch01_Overview15"ID="Ch01_Overview16"/usr/include/Vk. In most cases, the header file for a given class is the class name followed by ".h". For example, the header file for the VkWindow class is <Vk/VkWindow.h>. Some minor classes are grouped together into single header files. For example, the header file for the VkMenu class automatically includes the header information for every type of menu supported by ViewKit. These cases are noted in the text where appropriate.You need to include IRIS IM header files for only those IRIS IM widgets that you explicitly use in a ViewKit program. ViewKit automatically includes any X or IRIS IM header files required by ViewKit components that you use in your program.ID="Ch01_Overview17"ID="Ch01_Overview18"LBL="" HELPID=""Required LibrariesYou must link all ViewKit programs with the ViewKit library, ID="Ch01_Overview19"libvk, and the IRIS IM and X libraries. If you use an external help system with your application, you should link with an appropriate help library; otherwise, you should link with the ViewKit help library, ID="Ch01_Overview20"libvkhelp. (See IDREF="91883" TYPE="TITLE"Appendix C, "Using a Help System with ViewKit," for information on using a help system with ViewKit applications.)For example, to compile a file ID="Ch01_Overview21"hello.c++ to produce the executable hello, you enter:CC -o hello hello.c++ -lvk -lvkhelp -lXm -lXt -lX11If you are debugging a program, you might find it useful to compile your program with the debug libraries, which contain additional symbol table information.LBL="" HELPID=""Getting StartedThis section gives you information on example programs that you might find helpful when getting started with ViewKit programming. It first describes the simplest ViewKit program, which displays a window containing a single label, and discusses the structure of the program. Then, it discusses the demonstration programs provided with ViewKit.LBL="" HELPID=""The Simplest ViewKit ProgramApplications based on ViewKit must obey certain conventions. To see how this organization works, consider a simple example of a ViewKit application that displays the label "hello" in a window.LBL="1-1"Example 1-1 The Simplest ViewKit Program: hello.c++#include <Vk/VkApp.h>
#include <Vk/VkSimpleWindow.h>
#include <Xm/Label.h>

// Define a top-level window class

class HelloWindow: public VkSimpleWindow {

  public:
    HelloWindow (const char *name);
    ~HelloWindow();
    virtual const char* className();
};

// Construct a single rooted widget tree, and designate the
// root of the tree as the window's view.  This example is very
// simple, just creating a single XmLabel widget to display the
// string "hello".

HelloWindow::HelloWindow (const char *name) : VkSimpleWindow (name)
{
    Widget label =  XmCreateLabel (mainWindowWidget(), "hello",
                                   NULL, 0);
    addView(label);
}

const char* HelloWindow::className()
{
    return "HelloWindow";  // Identify this class
}

HelloWindow::~HelloWindow()
{
    // Empty
}


// Main driver. Just instantiate a VkApp and a top-level window,
// "show" the window and then "run" the application.

void main ( int argc, char **argv )
{
    VkApp        *app = new VkApp("Hello", &argc, argv);
    HelloWindow  *win = new HelloWindow("hello");

    win->show();
    app->run();
}To build this example, simply compile the file hello.c++ and link with the ViewKit library, the help library, and the IRIS IM and X libraries:CC -o hello hello.c++ -lvk -lvkhelp -lXm -lXt -lX11Running the hello program displays a window that says "hello," as shown in IDREF="31727" TYPE="GRAPHIC"Figure 1-1.FILE="hello1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="1-1"Figure 1-1 ID="31727"Result of Running helloThis example uses two classes: the VkApp class and an application-defined class, HelloWindow. The HelloWindow class is derived from the ViewKit VkSimpleWindow class, which is discussed in a moment.First look at ID="Ch01_Overview22"main(). All ViewKit applications start by creating an instance of VkApp. The arguments to this constructor specify the Xt-style class of the application, a pointer to argc, and the argv array. Instantiating a VkApp object opens a connection to the X server and initializes many other services needed by typical applications. VkApp is described in detail in IDREF="88118" TYPE="TITLE"Chapter 3, "The ViewKit Application Class." Next, the hello.c++ program instantiates a HelloWindow object that serves as the application's top-level window. The constructor for this class requires only a name for the window. Finally, the application concludes by calling the HelloWindow object's show() function and the VkApp object's run() function. The run() method never returns. The body of most ViewKit programs is very similar to this short example.Now look at the HelloWindow class. ViewKit encourages you to create classes to represent all major elements of the user interface. In this simple example, the only major user interface component is a top-level window that contains a label widget. ViewKit provides a class, VkSimpleWindow, that supports many features common to all top-level windows and that works closely with the VkApp class to implement various ViewKit features. To use the VkSimpleWindow class, you derive a new subclass and create a single-rooted widget tree that the window displays as its view. ViewKit applications do not have to create shell widgets directly.The hello.c++ example is so simple that the HelloWindow class creates only a single XmLabel widget. The XmLabel widget is created in the constructor and then designated as the window's view. More complex classes might create a manager widget and create other widgets as children, or might instantiate other objects, as well. IDREF="45296" TYPE="TITLE"Chapter 4, "ViewKit Windows," describes how to create windows using ViewKit.The className() member function is supported, by convention, by all ViewKit classes. This function is used by several ViewKit facilities and is discussed in IDREF="44238" TYPE="TITLE""VkComponent Access Functions".LBL="" HELPID=""Demonstration ProgramsThe ID="Ch01_Overview23"ViewKit_dev.sw.demo subsystem installs in the /usr/share/src/ViewKit directory several demonstration programs that illustrate different features of ViewKit. A few of the highlights include:/usr/share/src/ViewKit/ProgrammersGuide contains several of the example programs from this guide./usr/share/src/ViewKit/Components/CBrowser contains the source for a component browser, which shows examples of many ViewKit components. You might find this particularly useful to run when you read the later chapters in this guide that describe the prebuilt components shipped with ViewKit./usr/share/src/ViewKit/Applications/PhoneBook creates PhoneBook, a full-fledged application that keeps track of names, phone numbers, and addresses.PhoneBook uses a variety of ViewKit classes./usr/share/src/ViewKit/Applications/GLX builds Rotate, a sample application that uses GLX to do GL rendering in an X window./usr/share/src/ViewKit/Applications/Inventor builds IvClock, a ViewKit implementation of the Inventor clock sample program from Inventor 2.0.LBL="2"ID="41696"ComponentsID="Ch02_Components1"This chapter introduces the concept of ViewKit ID="Ch02_Components2"ID="Ch02_Components3"components: C++ classes that encapsulate sets of widgets along with convenient methods for their manipulation.This chapter describes two ViewKit classes: VkCallbackObject and VkComponent. IDREF="33087" TYPE="GRAPHIC"Figure 2-1 shows the inheritance graph for these classes.FILE="Fig2-1.ai" POSITION="INLINE" SCALE="FALSE"LBL="2-1"Figure 2-1 ID="33087"The Inheritance Graph for VkCallbackObject and VkComponentID="Ch02_Components4"LBL="" HELPID=""Definition of a ComponentWidget sets such as IRIS IM provide simple, low-level building blocks, like buttons, scrollbars, and text fields. However, to create interesting and useful applications, you must build collections of widgets that work together to perform given tasks. For example, many applications support a system of menus, which are constructed from several individual widgets. Just as the user thinks of the menu bar as a single logical component of the user interface, ViewKit builds abstractions that let applications deal with a "menu" rather than the individual pieces of the menu.ID="Ch02_Components5"C++ allows you to do exactly this: to encapsulate collections of widgets and other objects as logical entities. By creating C++ classes and providing simple, convenient manipulation functions, you can avoid the complexity of creating widgets, specifying widget locations, setting resources, assigning callbacks, and other common tasks. Furthermore, for commonly used objects like menus, you can design general-purpose classes that you can easily use in many different applications.In ViewKit, the general user interface classes are referred to as components. A component not only encapsulates a collection of widgets, but also defines the behavior of the overall component. ViewKit components are designed to implement as many commonly-used features as possible. Typically, all you need to do to use a ViewKit component is create a subclass of the appropriate ViewKit class and define any application-specific behavior. Furthermore, using the ViewKit classes as a base, you can create your own library of reusable components.LBL="" HELPID=""ID="96941"The VkComponent ClassAll ViewKit components are derived from the abstract base class ID="Ch02_Components6"ID="Ch02_Components7"ID="Ch02_Components8"VkComponent, which defines a basic structure and protocol for all components. When creating your own components, you should also derive them from VkComponent or one of its subclasses.The VkComponent class enforces certain characteristics on components and expects certain behaviors of its subclasses. These characteristics and the features provided by VkComponent are discussed in detail in the following sections; the more important characteristics are summarized below:Widgets encapsulated by a component must form a single-rooted subtree. Components typically use a container widget as the root of the subtree; all other widgets are descendents of this widget. The root of the widget subtree is referred to as the ID="Ch02_Components9"ID="Ch02_Components10"base widget of the component.You can create instances of components and use them in other components's widget subtrees. As a convenience, VkComponent defines an operator that allows you to pass a VkComponent object directly to functions that expect a widget. This operator is described further in IDREF="44238" TYPE="TITLE""VkComponent Access Functions".Components take a string as an argument (typically, the first argument) in the class constructor. This string is used as the name component's base widget. You should give each instance of a component a unique name so that you can identify each widget in an application by a unique path through the application's widget tree. If each widget can be uniquely identified, X resource values can be used to customize the behavior of each widget. ViewKit resource support is described in ID="Ch02_Components11"IDREF="71587" TYPE="TITLE""Component Resource Support".Components take a widget as an argument (typically, the second argument) in the class constructor. This widget is the parent of the component's base widget. Component constructors are discussed in ID="Ch02_Components12"IDREF="36188" TYPE="TITLE""Component Constructors".Most components should create the base widget and all other widgets in the class constructor. The constructor should manage all widgets except the base widget, which should be left unmanaged. You can then manage or unmanage a component's entire widget subtree using the member functions described in ID="Ch02_Components13"IDREF="46525" TYPE="TITLE""Displaying and Hiding Components".VkComponent provides an access function that retrieves the component's base widget. You might need to access the base widget, for example, to set constraint resources so that an XmForm widget can position the component. Normally, other widgets inside a component aren't exposed. Access functions are discussed in IDREF="44238" TYPE="TITLE""VkComponent Access Functions".Components must handle the destruction of widgets within the component's widget tree. The widgets encapsulated by the component must be destroyed when the component is destroyed. Component classes must also prevent dangling references by handling destruction of the widget tree without destruction of the component. ID="Ch02_Components14"VkComponent provides mechanisms for handling widget destruction which are described in IDREF="43744" TYPE="TITLE""Handling Component Widget Destruction".Components should define any Xt callbacks required by a class as private static member functions. Using Xt callbacks in ViewKit is discussed in ID="Ch02_Components15"ID="Ch02_Components16"IDREF="72493" TYPE="TITLE""Using Xt Callbacks with Components".All component classes must override the virtual className() member function so that it returns a string identifying the component's class. ViewKit uses this string for resource handling and other support functions. The className() member function is described in more detail in IDREF="44238" TYPE="TITLE""VkComponent Access Functions". IDREF="71587" TYPE="TITLE""Component Resource Support" describes ViewKit resource support.LBL="" HELPID=""ID="36188"Component ConstructorsThe ID="Ch02_Components17"ID="Ch02_Components18"VkComponent constructor has the following form:VkComponent( const char *name )The VkComponent constructor is declared protected and so can be called only from derived classes. Its primary purpose is to initialize component data members, in particular _name and _baseWidget.Each component should have a unique name, which is used as the name of the component's base widget. The ID="Ch02_Components19"VkComponent constructor accepts a name as an argument, creates a copy of this string, and assigns the address of the copy to the ID="Ch02_Components20"_name data member.The ID="Ch02_Components21"ID="Ch02_Components22"_baseWidget data member is the base widget of the component's widget subtree. The ID="Ch02_Components23"VkComponent constructor initializes _baseWidget to NULL.Each derived class's constructor should take at least two arguments, the component's name and a widget that serves as the parent of the component's widget tree, and perform at least these initialization steps:ID="Ch02_Components24"ID="Ch02_Components25"Pass the name to the VkComponent constructor to initialize the basic component data members.Create the component's widget subtree and assign the base widget to the ID="Ch02_Components26"_baseWidget data member. The base widget should be a direct child of the parent widget passed in the constructor, and should have the same name as the component (as stored in ID="Ch02_Components27"_name) for the ViewKit resource support to work correctly. All other widgets in the component must be children or descendents of the base widget.Immediately after creating the base widget, call ID="Ch02_Components28"ID="Ch02_Components29"installDestroyHandler() to set up a callback to handle widget destruction. This function is described further in IDREF="43744" TYPE="TITLE""Handling Component Widget Destruction".Manage all widgets except the base widget, which should be left unmanaged.ID="Ch02_Components30"Perform any other needed class initialization.As an example, consider a user-defined component called StartStopPanel that implements a simple control panel containing Start and Stop buttons. The code fragment in IDREF="40033" TYPE="TEXT"Example 2-1 shows a possible constructor for this class.LBL="2-1"Example 2-1 ID="40033"Example of a Component Constructor/////////////////////////////
// StartStopPanel.h
/////////////////////////////

// Declare StartStopPanel as a subclass of VkComponent

class StartStopPanel: public VkComponent {

  public:
    StartStopPanel (const char *, Widget);
    ~StartStopPanel();
    // ...

  protected:
    Widget _startButton;
    Widget _stopButton;
    // ...
}


/////////////////////////////
// StartStopPanel.c++
/////////////////////////////


// Pass the name to the VkComponent constructor to initialize the
// basic component data members.

StartStopPanel::StartStopPanel(const char *name, Widget parent) :                                                       VkComponent(name)
{
  // Create an XmRowColumn widget as the component's base widget
  // to contain the buttons. Assign the widget to the _baseWidget
  // data member.
  _baseWidget = XmCreateRowColumn ( parent, _name, NULL, 0 );
  // Set up callback to handle widget destruction

  installDestroyHandler();

  XtVaSetValues(_baseWidget, XmNorientation, XmHORIZONTAL, NULL);

  // Create all other widgets as children of the base widget.
  // Manage all child widgets.

  _startButton = XmCreatePushButton ( _baseWidget, "start", NULL, 0);
  _stopButton  = XtCreatePushButton ( _baseWidget, "stop", NULL, 0);

  XtManageChild(_startButton);
  XtManageChild(_stopButton);

  // Perform any other initialization needed (omitted in this example)
}In this example, the StartStopPanel constructor passes the name argument to the VkComponent constructor to initialize the _name data member. The VkComponent constructor also initializes the _baseWidget data member to NULL. It then creates a RowColumn widget as the base widget to manage the other widgets in the component. The constructor uses the _name data member as the name of the base widget, uses the parent argument as the parent widget, and assigns the RowColumn widget to the _baseWidget data member. Immediately after creating the base widget, the constructor calls installDestroyHandler(). Then, it creates the two buttons as children of the base widget and manages the two child widgets.A real constructor would then perform all other initialization needed by the class, such as setting up callbacks for the buttons and initializing any other data members that belong to the class. IDREF="72493" TYPE="TITLE""Using Xt Callbacks with Components" describes how you should set up Xt callbacks when working with ViewKit components.LBL="" HELPID=""Component DestructorsThe virtual ID="Ch02_Components31"VkComponent destructor performs the following functions:Triggers the ID="Ch02_Components32"ID="Ch02_Components33"VkComponent::deleteCallback ViewKit callback for that component. ViewKit callbacks are described in IDREF="24384" TYPE="TITLE""ViewKit Callback Support", and the VkComponent::deleteCallback is described in IDREF="34147" TYPE="TITLE""Predefined ViewKit Callbacks".Removes the widget destruction handler described in ID="Ch02_Components34"IDREF="43744" TYPE="TITLE""Handling Component Widget Destruction".Destroys the component's base widget, which in turn destroys the component's entire widget subtree.ID="Ch02_Components35"Frees all memory allocated by the VkComponent constructor.Sets to NULL all the data members defined by the VkComponent constructor.The destructor for a derived class need free only the space that was explicitly allocated by the derived class, but of course it can perform any other cleanup your class requires.For example, if your class allocates space for a string, you should free that space in your destructor, as shown in IDREF="72674" TYPE="TEXT"Example 2-2.LBL="2-2"Example 2-2 ID="72674"Freeing Space in a Component DestructorMyComponent: public VkComponent {

  public:
    MyComponent(const char *, Widget);
    ~MyComponent();
    // ...

  private:
    char *_label;
    //...
}

MyComponent::MyComponent(const char *name, Widget parent) : VkComponent(name)
{
    _label = strdup( label );
   // ...
}

MyComponent::~MyComponent()
{
    free ( _label );
}Even if you don't need to perform any actions in a class destructor, you should still declare an empty one. If you don't explicitly declare a destructor, the C++ compiler creates an empty inline destructor for the class; however, because the destructor in the base class, VkCallbackObject, declares the destructor as virtual, the C++ compiler generates a warning because a virtual member function can't be inlined. The compiler then "un-inlines" the destructor and, to ensure that it's available wherever needed, puts a copy of it in every file that uses the class. Explicitly creating an empty destructor for your classes avoids this unnecessary overhead.LBL="" HELPID=""ID="44238"VkComponent Access FunctionsVkComponent provides access functions for accessing some of the class's data members.The ID="Ch02_Components36"ID="Ch02_Components37"name() function returns the name of a component as pointed to by the ID="Ch02_Components38"_name data member. This is the same as the name that you provided in the component's constructor. The syntax of the name() function is:const char * name() constThe ID="Ch02_Components39"ID="Ch02_Components40"ID="Ch02_Components41"ID="Ch02_Components42"className() function returns a string identifying the name of the ViewKit class to which the component belongs. The syntax of className() is:virtual const char *className()All component classes should override this virtual function to return a string that identifies the name of the component's class. ViewKit uses this string for resource handling and other support functions. The class name for the VkComponent class is "VkComponent."For example, if you create a StartStopPanel class, you should override the StartStopPanel::className() function as follows:class StartStopPanel: public VkComponent {
  public:
    // ...
    virtual const char *className();
    // ...
}

const char* StartStopPanel::className()
{
    return "StartStopPanel";
}The ID="Ch02_Components43"ID="Ch02_Components44"ID="Ch02_Components45"baseWidget() function returns the base widget of a component as stored in the ID="Ch02_Components46"ID="Ch02_Components47"_baseWidget data member:Widget baseWidget() constNormally, components are as encapsulated as possible, so you should avoid operating directly on a component's base widget outside the class. However, certain operations might require access to a component's base widget. For example, after instantiating a component as a child of an XmForm widget, you might need to set various constraint resources, as shown below:Widget form = XmCreateForm(parent, "form", NULL, 0);
StartStopPanel *panel = new StartStopPanel("panel", form);
XtVaSetValues(panel->baseWidget(), XmNtopAttachment, XmATTACH_FORM, NULL);As a convenience, ID="Ch02_Components48"VkComponent defines a Widget operator that allows you to pass a VkComponent object directly to functions that expect a widget. By default, the operator converts the component into its base widget. However, the operator is defined as a virtual function so that derived classes can override it to return a different widget. Note that you must use an object, not a pointer to an object, because of the way operators work in C++. For example, the Widget operator makes the following code fragment equivalent to the fragment presented above:Widget form = XmCreateForm(parent, "form", NULL, 0);
StartStopPanel *panel = new StartStopPanel("panel", form);
XtVaSetValues(*panel, XmNtopAttachment, XmATTACH_FORM, NULL);LBL="" HELPID=""ID="46525"Displaying and Hiding ComponentsThe virtual member functionID="Ch02_Components49"ID="Ch02_Components50" show()ID="Ch02_Components51" manages the base widget of the component, displaying the entire component. The virtual member function ID="Ch02_Components52"hide() performs the inverse operation. You can call show() after calling hide() to redisplay a component. The syntax of these commands are simply:virtual void show()
virtual void hide()For example, the following lines display the component panel, an instance of the StartStopPanel:StartStopPanel *panel = new StartStopPanel("panel", form);
panel->show();You could hide this component with the line:panel->hide();If you're familiar with Xt, you can think of these functions as performing operations analogous to managing and unmanaging the widget tree; however, you shouldn't regard these functions simply as "wrappers" for the XtManageChild() and XtUnmanageChild() functions. First, these member functions show and hide an entire component, which typically consists of more than one widget. Second, other actions might be involved in showing a component. In general, the show() member function does whatever is necessary to make a component visible on the screen. You shouldn't circumvent these member functions and manage and unmanage components' base widgets directly. For example, some components might use XtMap() and XtUnmap() as well. Other components might not even create their widget subtrees until show() is called for the first time.The ID="Ch02_Components53"VkComponent class also provides the protected virtual function ID="Ch02_Components54"afterRealizeHook(). This function is called after a component's base widget is realized, just before it's mapped for the first time. The default action is empty. You can override this function in a subclass if you want to perform actions after a component's base widget exists.LBL="" HELPID=""ID="47352"VkComponent Utility FunctionsAll ViewKit components provide the virtual member function ID="Ch02_Components55"ID="Ch02_Components56"okToQuit() to support "safe quit" mechanisms:virtual Boolean okToQuit()A component's okToQuit() function returns TRUE if it is "safe" for the application to quit. For example, you might want okToQuit() to return FALSE if a component is in the process of updating a file. By default, okToQuit() always returns TRUE; you must override okToQuit() for all components that you want to perform a check before quitting.Usually only VkSimpleWindow and its subclasses use okToQuit(). When you call ID="Ch02_Components57"VkApp::quitYourself(), VkApp calls the okToQuit() function for all registered windows before quitting. If the okToQuit() function for any window returns FALSE, the application doesn't exit. IDREF="52836" TYPE="TITLE""Quitting ViewKit Applications" provides more information on how to quit a ViewKit application, and IDREF="33838" TYPE="TITLE""Providing a "Safe Quit" Mechanism" describes how to override VkSimpleWindow::okToQuit() to provide a "safe quit" mechanism for a window.In some cases you might want to check one or more components contained within a window before quitting. To do so, override the okToQuit() function for that window to call the okToQuit() functions for all the desired components. Override the okToQuit() functions for the other components to perform whatever checks are necessary.Another utility function provided by ID="Ch02_Components58"ID="Ch02_Components59"VkComponent is the static member function isComponent():static Boolean isComponent(VkComponent *component)The isComponent() function applies heuristics to determine whether the pointer passed as an argument represents a valid VkComponent object. If component points to a VkComponent that has not been deleted, this function always returns TRUE; otherwise the function returns FALSE. It is possible, though highly unlikely, that this function could mistakenly identify a dangling pointer to a deleted object as a valid object. This could happen if another component were to be allocated at exactly the same address as the deleted object a pointer previously pointed to. The isComponent() function is used primarily for ViewKit internal checking, often within assert() macros.LBL="" HELPID=""ID="72493"Using Xt Callbacks with ComponentsCallbacks pose a minor problem for C++ classes. C++ member functions have a hidden argument, which is used to pass the ID="Ch02_Components60"ID="Ch02_Components61"ID="Ch02_Components62"ID="Ch02_Components63"ID="Ch02_Components64"ID="Ch02_Components65"ID="Ch02_Components66"ID="Ch02_Components67"ID="Ch02_Components68"this pointer to the member function. This hidden argument makes ordinary member functions unusable as callbacks for Xt-based widgets. If a member function were to be called from C (as a callback), the this pointer would not be supplied and the order of the remaining arguments might be incorrect.Fortunately, there is a simple way to handle the problem, although it requires the overhead of one additional function call. The approach is to use a regular member function to perform the desired task, and then use a static member function for the Xt callback. A static member function does not expect a this pointer when it is called. However, it is a member of a class, and as such has the same access privileges as any other member function. It can also be encapsulated so it is not visible outside the class.The only catch is that the static member function used as a callback needs a way to access the appropriate instance of the class. This can be provided by specifying a pointer to the component as the client data when registering the callback.ID="Ch02_Components69"Generally, you should follow these guidelines for using Xt callbacks with ViewKit components:Define any Xt callbacks required by a component as static member functions of that class. You normally declare these functions in the private section of the class, because they are seldom useful to derived classes.Pass the this pointer as client data to all Xt callback functions installed for widgets. Callback functions should retrieve this pointer, cast it to the expected component type, and call a corresponding member function.:Adopt a convention of giving static member functions used as callbacks the same name as the member function they call, with the word "Callback" appended. For example, the static member function ID="Ch02_Components70"ID="Ch02_Components71"activateCallback() should call the member function activate(). This convention is simply meant to make the code easier to read and understand. If you prefer, you can use your own convention for components you create, but this convention is used by all predefined ViewKit components.Member functions called by static member functions are often private, but they can instead be part of the public or protected section of the class. Occasionally it's useful to declare one of these functions as virtual, thereby allowing derived classes to change the function ultimately called as a result of a callback.For example, the constructor presented in ID="Ch02_Components72"ID="Ch02_Components73"IDREF="40033" TYPE="TEXT"Example 2-1 for the simple control panel component described in IDREF="36188" TYPE="TITLE""Component Constructors" omitted the setup of callback routines to handle the activation of the buttons. To implement these callbacks you must:Create regular member functions to perform the tasks desired in response to the user clicking on the buttons.Create static member functions that retrieve the client data passed by the callback, cast it to the expected component type, and call the corresponding member function.Register the static member functions as callback functions in the class constructor.Suppose that for the control panel, you want to call the member function StartStopPanel::start() when the user clicks on the Start button, and to call StartStopPanel::stop() when the user clicks on the Stop button:void StartStopPanel::start(Widget w, XtPointer callData)
{
  // Perform "start" function
}
void StartStopPanel::stop(Widget w, XtPointer callData)
{
  // Perform "stop" function
}You should then define the StartStopPanel::startCallback() and StartStopPanel::stopCallback() static member functions as follows:void StartStopPanel::startCallback(Widget w, XtPointer clientData,
                                   XtPointer callData)
{
  StartStopPanel *obj = ( StartStopPanel * ) clientData;
  obj->start(w, callData);
}

void StartStopPanel::stopCallback(Widget w, XtPointer clientData,
                                  XtPointer callData)
{
  StartStopPanel *obj = ( StartStopPanel * ) clientData;
  obj->stop(w, callData);
}Finally, you need to register the static member functions as callbacks in the constructor. Remember that you must pass the this pointer as client data when registering the callbacks. IDREF="65248" TYPE="TEXT"Example 2-3 shows the updated StartStopPanel constructor, which installs the Xt callbacks for the buttons.LBL="2-3"Example 2-3 ID="65248"Component Constructor with Xt CallbacksStartStopPanel::StartStopPanel(const char *name, Widget parent) :                                                       VkComponent(name)
{
  // Create an XmRowColumn widget as the component's base widget
  // to contain the buttons. Assign the widget to the _baseWidget
  // data member.

  _baseWidget = XmCreateRowColumn ( parent, _name, NULL, 0 );

  // Set up callback to handle widget destruction

  installDestroyHandler();

  XtVaSetValues(_baseWidget, XmNorientation, XmHORIZONTAL, NULL);

  // Create all other widgets as children of the base widget.
  // Manage all child widgets.

  _startButton = XmCreatePushButton ( _baseWidget, "start", NULL, 0);
  _stopButton  = XtCreatePushButton ( _baseWidget, "stop", NULL, 0);

  XtManageChild(_startButton);
  XtManageChild(_stopButton);

  // Install static member functions as callbacks for the pushbuttons

  XtAddCallback(_startButton, XmNactivateCallback,
                &StartStopPanel::startCallback, (XtPointer) this );

  XtAddCallback(_stopButton, XmNactivateCallback,
                &StartStopPanel::stopCallback, (XtPointer) this );
}LBL="" HELPID=""ID="43744"Handling Component Widget DestructionWhen widgets are destroyed, it's easy to leave dangling referencesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'pointers to memory that once represented widgets, but which are no longer valid. For example, when a widget is destroyed, its children are also destroyed. It's often difficult to keep track of the references to these children, so it's fairly easy to write a program that accidentally references the widgets in a class after the widgets have already been destroyed. In some cases, applications might try to delete a widget twice, which usually causes the program to crash. Calling ID="Ch02_Components74"XtSetValues() or other Xt functions with a widget that's been deleted is also an error that can occur easily in this situation.To help protect the encapsulation of ViewKit classes, ID="Ch02_Components75"ID="Ch02_Components76"ID="Ch02_Components77"VkComponent provides a private static member function, widgetDestroyedCallback(), to register as an XmNdestroyCallback for the base widget so that the component can properly handle the deletion of its base widget. This callback can't be registered automatically within the VkComponent constructor because derived classes have not yet created the base widget when the VkComponent constructor is called.As a convenience, rather than force every derived class to install the ID="Ch02_Components78"widgetDestroyedCallback() function directly, VkComponent provides a protected installDestroyHandler() function that performs this task:void installDestroyHandler()Immediately after creating a component's base widget in a derived class, you should call installDestroyHandler(). For example:StartStopPanel::StartStopPanel(const char *name, Widget parent) :
                                                      VkComponent(name)
{
  _baseWidget = XmCreateRowColumn ( parent, _name, NULL, 0 );
  installDestroyHandler();
  // ...
}When you link your program with the debugging version of the ViewKit library, a warning is issued for any class that does not install the widgetDestroyedCallback() function.The widgetDestroyedCallback() function calls the virtual member function widgetDestroyed():virtual void widgetDestroyed()By default, widgetDestroyed() sets the component's _baseWidget data member to NULL. You can override this function in derived classes if you want to perform additional tasks in the event of widget destruction; however, you should always call the base class's widgetDestroyed() function as well.Occasionally, you might need to remove the destroy callback installed by installDestroyHandler(). For example, the VkComponent class destructor removes the callback before destroying the widget. To do so, you can call the ID="Ch02_Components79"removeDestroyHandler() function:void removeDestroyHandler()LBL="" HELPID=""ID="71587"Component Resource SupportThe X resource manager is a very powerful facility for customizing both applications and individual widgets. The resource manager allows the user or programmer to modify both the appearance and behavior of applications and widgets.ID="Ch02_Components80"ID="Ch02_Components81"ViewKit provides a variety of utilities to simplify resource management. Using ViewKit, you can easilyset resource values for a single component or an entire class of componentsinitialize data members using values retrieved from the resource databaseprogrammatically set default resource values for a componentobtain resource valuesFor ViewKit resource support to work properly, you must follow these two guidelines:ID="Ch02_Components82"You must override each components's virtual ID="Ch02_Components83"ID="Ch02_Components84"className() member functions, returning a string that identifies the name of each component's C++ class. For example, if you create a StartStopPanel component class, you must override StartStopPanel::className() as follows:const char* StartStopPanel::className()
{
  return "StartStopPanel";
}You must provide a unique component name when instantiating each component. This string must be used as the name of the component's base widget. Giving each instance of a component a unique name ensures a unique path through the application's widget tree for each widget. Widgets within a component can have hard-coded names because they can be qualified by the name of the root of the component subtree.ID="Ch02_Components85"LBL="" HELPID=""Setting Resource Values by Class or Individual ComponentThe structure of ViewKit allows you to specify resource values for either an individual component or for all components of a given class.ID="Ch02_Components86"To set a resource for an individual instance of a component, refer to the resource using the syntax:*name*resourceIn this case, "name" refers to the ViewKit component's name that you pass as an argument to the component's constructor, and "resource" is the name of the resource. A specification of this form works for setting both widget resources and "synthetic" resources that you use to initialize data member values. (IDREF="83891" TYPE="TITLE""Initializing Data Members Based on Resource Values" describes a convenience function for initializing data members from resource values.)For example, you could set a "verbose" resource to TRUE for the instance named "status" of a hypothetical ProcessMonitor class with a resource entry such as:*status*verbose: TRUETo set a resource for an entire component class, refer to the resource using the syntax:*className*resourceIn this case, "className" is the name of the ViewKit class returned by that class's className() function, and "resource" is the name of the resource. A specification of this form works for setting "synthetic" resources only, not widget resources. You can set resources for widgets within a component when you specify a component's name because the name of component's base widget is the same as the name of the component; the X resource manager can successfully determine a widget hierarchy based on widget names. On the other hand, a component's class name has no relation to its base widget's class name. If you use a component class name in a resource specification, the X resource manager cannot determine the widget hierarchy for widgets in the component.For example, you can set a "verbose" resource for all instances of the hypothetical ProcessMonitor class to TRUE with a resource entry such as:*ProcessMonitor*verbose: TRUELBL="" HELPID=""ID="83891"Initializing Data Members Based on Resource ValuesIf you want to initialize data members in a class using values in the resource database, you can call the ID="Ch02_Components87"ID="Ch02_Components88"ID="Ch02_Components89"VkComponent member function getResources():void getResources ( const XtResourceList resources,
                    const int numResources )The resources argument is a standard resource specification in the form of an XtResource list, and the numResources argument is the number of resources. You should define the XtResource list as a static data member of the class to encapsulate the resource specification with the class. You should call getResources() in the component constructor after creating your component's base widget.getResources() retrieves the specified resources relative to the root of the component's widget subtree. For example, to set the value of a resource for a particular instance of a component, you would need to set the resource with an entry in the resource database of the form:*name.resource:  valuewhere name is the component's name, resource is the name of the resource, and value is the resource value. To set the value of a resource for an entire component class, you would need to set the resource with an entry in the resource database of the form:*className.resource:  valuewhere className is the component class name, resource is the name of the resource, and value is the resource value.IDREF="35240" TYPE="TEXT"Example 2-4 demonstrates the initialization of a data member, _verbose, from the resource database. A default value is specified in the XtResource structure, but the ultimate value is determined by the value of the resource named "verbose" in the resource database.LBL="2-4"Example 2-4 ID="35240"Initializing a Data Member from the Resource Database// Header file: ProcessMonitor.h

#include <Vk/VkComponent.h>
#include <Xm/Frame.h>

class ProcessMonitor : public VkComponent
{
private:
  static XtResource _resources[];

protected:
  Boolean _verbose;

public:
  ProcessMonitor(const char *, Widget);
  ~ProcessMonitor();
  virtual const char *className();
};

// Source file: ProcessMonitor.c++

#include "ProcessMonitor.h"

XtResource ProcessMonitor::_resources [] = {
  {
  "verbose",
  "Verbose",
  XmRBoolean,
  sizeof ( Boolean ),
  XtOffset ( ProcessMonitor *, _verbose ),
  XmRString,
  (XtPointer) "FALSE",
  },
};

ProcessMonitor::ProcessMonitor(Widget parent, const char *name) :
                                                    VkComponent (name)
{
  _baseWidget = XtVaCreateWidget ( _name, xmFrameWidgetClass,
                                   parent, NULL ) ;
  installDestroyHandler();

  // Initialize members from resource database

  getResources ( _resources, XtNumber(_resources) );

  // ...
}So, to initialize the _verbose data member to TRUE in all instances of the ProcessMonitor class, you need only to set the following resource in the resource database:*ProcessMonitor.verbose: TRUETo initialize _verbose to TRUE for an instance of ProcessMonitor named conversionMonitor, you could set the following resource in the resource database:*conversionMonitor.verbose:  TRUELBL="" HELPID=""ID="57967"Setting Default Resource Values for a ComponentOften, you might want to specify default resource values for a component. A common way to accomplish this is to put the resource values in an application resource file. However, this makes the component dependent on that resource file; to use that component in another application, you must remember to copy those resources into the new application's resource file. This is especially inconvenient for classes that you reuse in multiple applications.ID="Ch02_Components90"ID="Ch02_Components91"A better method of encapsulating default resources into a component is to use a ViewKit facility that allows you to specify them programmatically and then merge them into the resource database during execution. Although the resources are specified programmatically, they can be overridden by applications that use the class, or by end users in resource files. However, the default values are specified by the component class and cannot be separated from the class accidentally. If you later want to change the implementation of a component class, you can also change the resource defaults when necessary, knowing that applications that use the class will receive both changes simultaneously.The ID="Ch02_Components92"VkComponent class provides the setDefaultResources() function for storing a collection of default resources in the application's resource database. The resources are loaded with the lowest precedence, so that these resources are true defaults. They can be overridden easily in any resource file. You should call this function in the component constructor before creating the base widget in case any resources apply to the component's base widget.The setDefaultResources() function has the following syntax:void setDefaultResources ( const Widget w,
                           const String *resourceSpec )The first argument is a widget; you should always use the parent widget passed in the component's constructor.The second argument is a NULL-terminated array of strings, written in the style of an X resource database specification. Specify all resources in the list relative to the root of the component's base widget, but do not include the name of the base widget. If you want to apply a resource to the base widget, simply use the name of the resource preceded by a "*" character. When resources are loaded, the value of _name is prefixed to all entries, unless that entry begins with the "-" character. As long as you use unique names for each component that you create of a given class, this results in resource specifications unique to each component. If you precede a resource value in this list with a "-" character, ID="Ch02_Components93"setDefaultResources() does not qualify the resource with the value of _name. This is useful in rare situations where you want to add global resources to the database.You should declare the resource list as a static data member of the class. This encapsulates the set of resources with the class.NoteGenerally, setting resources using ID="Ch02_Components94"setDefaultResources() is most appropriate for components that you plan to reuse in multiple applications. In particular, it is a good method for setting resources for widget labels and other strings that your component displays. You should not use setDefaultResources() to set widget resources, such as orientation, that you would normally set programmatically. Typically you don't need to change these resources when you use the component in different applications, and so you save memory and execution time by not using setDefaultResources() to set these resources. ID="Ch02_Components95"IDREF="17765" TYPE="TEXT"Example 2-5 builds on the StartStopPanel constructor from IDREF="65248" TYPE="TEXT"Example 2-3 to specify the default label strings "Start" and "Stop" for the button widgets.LBL="2-5"Example 2-5 ID="17765"Setting a Component's Default Resource Values// StartStopPanel.h

class StartStopPanel: public VkComponent {

  public:
    StartStopPanel (const char *, Widget);
    ~StartStopPanel();
    // ...

  private:
    static String _defaultResources[];
    // ...
}


// StatStopPanel.c++

String StartStopPanel::_defaultResources[] = {
  "*start.labelString:  Start",
  "*stop.labelString:   Stop",
  NULL
};

StartStopPanel::StartStopPanel(const char *name, Widget parent) :                                                       VkComponent(name)
{
  // Load class-default resources for this object before creating base widget

  setDefaultResources(parent, _defaultResources );

  _baseWidget = XmCreateRowColumn ( parent, _name, NULL, 0 );

  installDestroyHandler();

  XtVaSetValues(_baseWidget, XmNorientation, XmHORIZONTAL, NULL);

  _startButton = XmCreatePushButton ( _baseWidget, "start", NULL, 0);
  _stopButton  = XtCreatePushButton ( _baseWidget, "stop", NULL, 0);

  // ...

}LBL="" HELPID=""Convenience Function for Retrieving Resource ValuesViewKit also provides ID="Ch02_Components96"ID="Ch02_Components97"ID="Ch02_Components98"VkGetResource(), a convenience function for retrieving resource values from the resource database. VkGetResource() is not a member function of any class. You must include the header file <Vk/VkResource.h> to use VkGetResource().VkGetResource() has two forms. The first is:char * VkGetResource( const char * name,
                      const char * className )This form returns a character string containing the value of the application resource you specify by name and class name. This function is similar to XGetDefault(3x) except that this form of VkGetResource() allows you to retrieve the resource by class name whereas XGetDefault() does not.NoteDo not attempt to change or delete the value returned by VkGetResource(). The second form of VkGetResource() is:XtPointer VkGetResource( Widget w,
                         const char *name,
                         const char *className,
                         const char *desiredType,
                         const char *defaultValue)This second form is similar to XtGetSubresource(3Xt) in that it allows you to retrieve a resource relative to a specific widget. You can specify the resource as a dot-separated list of names and classes, allowing you to retrieve "virtual" sub-resources. You can also specify a target type. VkGetResource() will convert the retrieved value, or the default value if no value is retrieved, to the specified type.NoteDo not attempt to change or delete the value returned by ID="Ch02_Components99"VkGetResource(). For example, suppose that you want to design an application for drawing an image and you want to allow the user to select various aspects of the style in which the image is drawn, such as color and fill pattern (a pixmap). You could specify each aspect of each style as a resource and retrieve the values as follows:ID="Ch02_Components100"ID="Ch02_Components101"Widget canvas = XmCreateDrawingArea(parent, "canvas", NULL, 0);
Pixel fgOne = (Pixel) VkGetResource(canvas,
                                    "styleOne.foreground", "Style.Foreground",
                                    XmRString, "Black");
Pixel fgTwo = (Pixel) VkGetResource(canvas,
                                    "styleTwo.foreground", "Style.Foreground",
                                    XmRString, "Black");

Pixel bgOne = (Pixel) VkGetResource(canvas,
                                    "styleOne.background", "Style.Background",
                                    XmRString, "White");
Pixel bgTwo = (Pixel) VkGetResource(canvas,
                                    "styleTwo.background", "Style.Background",
                                    XmRString, "White");

Pixmap pixOne = (Pixmap) VkGetResource(canvas,
                                       "styleOne.pixmap", "Style.Pixmap",
                                       XmRString, "background");
Pixmap pixTwo = (Pixmap) VkGetResource(canvas,
                                       "styleTwo.pixmap", "Style.Pixmap",
                                       XmRString, "background");Another common technique used in ViewKit programming is to use a string to search for resource value and, if no resource exists, use the string as the value. You can do this easily if you pass the string to VkGetResource() as the default value. For example, consider the following code:char *timeMsg = "Time";
// ...
char *timeTitle = (char *) VkGetResource(_baseWidget, timeMsg, "Time",
                                         XmRString, timeMsg);In this case, VkGetResource() searches for a resource (relative to the _baseWidget widget) whose name is specified by the character string timeMsg. If no such resource exists, VkGetResource() returns the value of timeMsg as the default value.If you use this technique, you should not pass a string that contains a embedded spaces or newlines.LBL="" HELPID=""ID="24384"ViewKit Callback SupportAll ViewKit components support ID="Ch02_Components102"ID="Ch02_Components103"ID="Ch02_Components104"ID="Ch02_Components105"ID="Ch02_Components106"ID="Ch02_Components107"ID="Ch02_Components108"ViewKit member function callbacks (also referred to simply as ViewKit callbacks). ViewKit callbacks are analogous to Xt-style callbacks supported by widget sets, but ViewKit callbacks are in no way related to Xt.The ViewKit callback mechanism allows a component to define conditions or events, the names of which are exported as public static string constants encapsulated by that component. Any other component can register any of its member functions to be called when the condition or event associated with that callback occurs.Unlike the case when registering ViewKit functions for Xt-style callbacks, the functions you register for ViewKit callbacks must be regular member functions, not static member functions.ViewKit callbacks are implemented by the ID="Ch02_Components109"VkCallbackObject class. VkComponent is derived from VkCallbackObject, so all ViewKit components can use ViewKit callbacks. If you create a class for use with a ViewKit application, that class must be derived from VkCallbackObject or one of its subclasses (such as VkComponent) for you to be able to use ViewKit callbacks with that class.LBL="" HELPID=""ID="68815"Registering ViewKit CallbacksThe ID="Ch02_Components110"ID="Ch02_Components111"addCallback() function defined in VkCallbackObject registers a member function to be called when the condition or event associated with a callback occurs.CautionWhen registering a ViewKit callback, remember to call the ID="Ch02_Components112"addCallback() member function of the object that triggers the callback, not the object that is registering the callback.The format of addCallback() for registering a member function is:void addCallback(const char *name,
                 VkCallbackObject *component,
                 VkCallbackMethod callbackFunction,
                 void *clientData = NULL)The arguments for this function are:nameThe name of the ViewKit callback. You should always use the name of the public static string constant for the appropriate callback, not a literal string constant. (For example, use VkComponent::deleteCallback, not "deleteCallback".) This allows the compiler to catch any misspellings of callback names.componentA pointer to the object registering the callback function.callbackFunctionThe member function to invoke when the condition or event associated with that callback occurs.clientDataA pointer to data to pass to the callback function when it is invoked.For example, consider a member of a hypothetical ID="Ch02_Components113"Display class that instantiates another hypothetical component class, Control. The code fragment below registers a function to be invoked when the value set by the Control object changes and the Control object triggers its valueChanged callback:Display::createControl()
{
  _control = new Control(_baseWidget, "control");
  _control->addCallback(Control::valueChanged, this,
                      (VkCallbackMethod) &Display::newValue);
}In this example, the Display object requests that when the Control object triggers its valueChanged callback, it should call the Display::newValue() function of the Display object that created the Control object. The "(VkCallbackMethod)" cast for the callback function is required.ID="Ch02_Components114"All ViewKit callback functions must have the form:ID="Ch02_Components115"void memberFunctionCallback(VkCallbackObject *obj,
                            void *clientData,
                            void *callData)The obj argument is the component that triggered the callback, which you must cast to the correct type to allow access to members provided by that class. The clientData argument is the optional client data specified when you registered the callback, and the callData argument is optional data supplied by the component that triggered the callback.For example, you would define the Display::newValue() callback method used above as follows:class Display : VkComponent {
  private:
    void newValue(VkCallbackObject *, void *, void *);
    // ...
};

void Display::newValue(VkCallbackObject* obj,
                       void *clientData,
                       void *callData);
{
  Control *controlObj = (Control *) obj;

  // Perform whatever operation that is needed to update
  // the Display object.  You can also access member
  // functions from the Control object (controlObj).
  // The clientData argument contains any information
  // you provided as clientData when you registered
  // this callback; cast it to the proper type to use it.
  // If the Control object passed the new value as the
  // callData argument, you can cast that to the proper
  // type and use it.
}There is also a version of addCallback() for registering non-member functions. It's syntax is:void addCallback(const char *name,
                 VkCallbackFunction callbackFunction,
                 void *clientData = NULL)The arguments for this version are:nameThe name of the ViewKit callback. You should always use the name of the public static string constant for the appropriate callback, not a literal string constant.callbackFunctionThe non-member function to invoke when the condition or event associated with that callback occurs.clientDataA pointer to data to pass to the callback function when it is invoked.The form of your non-member ViewKit callback functions must be:ID="Ch02_Components116"void functionCallback(VkCallbackObject *obj,
                      void *clientData,
                      void *callData)For example, if you have a non-member function errorCondition():void errorCondition(VkCallbackObject *obj,
                    void *clientData,
                    void *callData)
{
    // Handle error condition
}You could register it for a ViewKit callback with the line such assample->addCallback(SampleComponent::errorCallback,
                    (VkCallbackFunction) &errorCondition);The "(VkCallbackFunction)" cast for the callback function is required.ID="Ch02_Components117"LBL="" HELPID=""Removing ViewKit CallbacksThe ID="Ch02_Components118"ID="Ch02_Components119"ID="Ch02_Components120"ID="Ch02_Components121"removeCallback() function provided by the VkCallbackObject class removes previously registered callbacks. The following version of removeCallback() removes a member function registered as a callback:void removeCallback(char *name,
                    VkCallbackObject *otherObject,
                    VkCallbackMethod memberFunction,
                    void *clientData = NULL)The following version of removeCallback() removes a non-member function registered as a callback:void removeCallback(const char *name,
                    VkCallbackFunction callbackFunction,
                    void *clientData = NULL)To remove a callback, you must provide the same arguments specified when you registered the callback. For example, the following line removes the Control callback registered in the previous section:_control->removeCallback(Control::valueChanged, this,
                      (VkCallbackMethod) &Display::newValue);The ID="Ch02_Components122"removeAllCallbacks() function removes multiple ViewKit callbacks:void removeAllCallbacks()
void removeAllCallbacks(VkCallbackObject *obj)If you don't provide an argument, this function removes all callbacks from an object, regardless of which components registered the callbacks. If you provide a pointer to a component, removeAllCallbacks() removes from an object all ViewKit callbacks that were set by the specified component. For example, the following would remove from the Control object _control all callbacks that the Display object had set:_control->removeAllCallbacks(this);LBL="" HELPID=""Defining and Triggering ViewKit CallbacksTo create a ViewKit callback for a component class, define a public static string constant as the name of the callback. For clarity, you should use the string's name as its value. For example, the following defines a callback, ID="Ch02_Components123"ID="Ch02_Components124"StartStopPanel::actionCallback, for the hypothetical StartStopPanel class discussed earlier in this chapter:class StartStopPanel : public VkComponent {

  public:
    static const char *const actionCallback;
    // ...
}

const char *const StartStopPanel::actionCallback = "actionCallback";The ID="Ch02_Components125"ID="Ch02_Components126"ID="Ch02_Components127"callCallbacks() member function triggers a specified callback, invoking all member functions registered for that callback:callCallbacks(const char *callback, void *callData)The first argument specifies the name of the callback. You should always use the name of the public static string constant for the appropriate callback, not a literal string constant. (For example, use StartStopPanel::startCallback, not "startCallback".) This allows the compiler to catch any misspellings of callback names.The second argument is used to supply any additional data that might be required.For example, you could define the StartStopPanel::start() and StartStopPanel::stop() functions to trigger the actionCallback and pass an enumerated value as call data to indicate which button the user clicked on:enum PanelAction { START, STOP };

class StartStopPanel : public VkComponent {

  public:
    static const char *const actionCallback;
    // ...
}

const char *const StartStopPanel::actionCallback = "actionCallback";

void StartStopPanel::start(Widget w, XtPointer callData)
{
  callCallbacks(actionCallback, (void *) START);
}

void StartStopPanel::stop(Widget w, XtPointer callData)
{
  callCallbacks(actionCallback, (void *) STOP);
}LBL="" HELPID=""ID="34147"Predefined ViewKit CallbacksThe ID="Ch02_Components128"ID="Ch02_Components129"VkComponent class, and therefore all derived classes, includes the ViewKit callback deleteCallback, which is invoked when the component's destructor is called. You can use this callback to prevent dangling pointers when maintaining pointers to other components. The code fragment in ID="Ch02_Components130"IDREF="64670" TYPE="TEXT"Example 2-6 shows an example of this.LBL="2-6"Example 2-6 ID="64670"Using the Predefined deleteCallback ViewKit Callbackclass MainComponent : VkComponent {
  // ...
  AuxComponent *_aux;
  void createAux();
  void auxDeleted(VkCallbackObject *, void *, void *);
  // ...
};

// ...

void MainComponent::createAux()
{
_aux = new AuxComponent(_baseWidget, "auxilliary");
_aux->addCallback(VkComponent::deleteCallback, this,
              (VkCallbackMethod) &MainComponent::auxDeleted);
}
void MainComponent::auxDeleted(VkCallbackObject*,
                               void *, void *)
{
  _aux = NULL;
}In the function MainComponent::createAux(), the MainComponent class creates an instance of the AuxComponent and then immediately registers MainComponent::auxDeleted() as a callback to be invoked when the AuxComponent object is deleted.The auxDeleted() callback definition simply assigns NULL to the AuxComponent object pointer. All other MainComponent functions should test the value of _aux to ensure that it is not NULL before attempting to use the AuxComponent object. This eliminates the possibility that the MainComponent class would try to access the AuxComponent object after deleting it, or attempting to delete it a second time.In most cases you should not need to use this technique of registering deleteCallback callbacks. It is necessary only if you need to create multiple pointers to a single object. In general, you should avoid multiple pointers to the same object, but VkComponent::deleteCallback provides a way to control situations in which you must violate this guideline.LBL="" HELPID=""Deriving Subclasses to Create New ComponentsThis section demonstrates how to use the ID="Ch02_Components131"ID="Ch02_Components132"ID="Ch02_Components133"VkComponent class to create new components. It includes guidelines to follow when creating new components, an example of creating a new component, and an example of subclassing that component to create yet another component class.LBL="" HELPID=""Subclassing SummaryThe following is a summary of guidelines for writing components based on the ID="Ch02_Components134"VkComponent class:Encapsulate all of your component's widgets in a single-rooted subtree. While some extremely simple components might contain only a single widget, the majority of components must create some type of container widget as the root of the component's widget subtree; all other widgets are descendents of this one.When you create your class's base widget, assign it to the _baseWidget data member inherited from the VkComponent class.In most cases, create a component's base widget and all other widgets in the class constructor. The constructor should manage all widgets except the base widget, which should be left unmanaged. You can then manage or unmanage a component's entire widget subtree using the show() and hide() member functions.Accept at least two arguments in your component's constructor: a string to be used as the name of the base widget, and a widget to be used as the parent of the component's base widget. Pass the name argument to the VkComponent constructor, which makes a copy of the string. Refer to a component's name using the _name member inherited from VkComponent or the name() access function. Refer to a component's base widget using the _baseWidget member inherited from VkComponent or the baseWidget() access function.Override the virtual className() member function for your component classes to return a string consisting of the name of the component's C++ class.Define all Xt callbacks required by a component class as private static member functions. In exceptional cases, you might want to declare them as protected so that derived classes can access them.Pass the this pointer as client data to all Xt callback functions. Callback functions should retrieve this pointer, cast it to the expected component type and call a corresponding member function. For clarity, use the convention of giving static member functions used as callbacks the same name as the member function they call, with the word "Callback" appended. For example, name a static member function startCallback() if it calls the member function start().Call installDestroyHandler() immediately after creating a component's base widget.If you need to specify default resources for a component class, call the function setDefaultResources() with an appropriate resource list before creating the component's base widget.If you need to initialize data members from values in the resource database, define an appropriate resource specification and call the function getResources() immediately after creating the component's base widget.LBL="" HELPID=""Example of Creating a New ComponentTo illustrate many of the features of the ID="Ch02_Components135"VkComponent base class, this chapter has shown how to build a simple class called StartStopPanel, which implements a control panel containing two buttons. IDREF="17488" TYPE="GRAPHIC"Figure 2-2 shows the default appearance of a StartStopPanel object.FILE="StartStopPanel1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="2-2"Figure 2-2 ID="17488"The Default Appearance of a StartStopPanel ComponentIDREF="19462" TYPE="TEXT"Example 2-7 lists the full implementation of this class.LBL="2-7"Example 2-7 ID="19462"A Simple User-Defined Component//////////////////////////////////////////////////////////////
// StartStopPanel.h
//////////////////////////////////////////////////////////////

#ifndef _STARTSTOPPANEL_H
#define _STARTSTOPPANEL_H
#include <Vk/VkComponent.h>

enum PanelAction { START, STOP };

class StartStopPanel : public VkComponent {
  public:
    StartStopPanel (const char *, Widget);
    ~StartStopPanel();
    virtual const char *className();

    static const char *const actionCallback;

  protected:
    virtual void start(Widget, XtPointer);
    virtual void stop(Widget, XtPointer);

    Widget _startButton;
    Widget _stopButton;

  private:
    static void startCallback(Widget, XtPointer, XtPointer);
    static void stopCallback(Widget, XtPointer, XtPointer);

    static String _defaultResources[];
};

#endif


/////////////////////////////////////////////////////////////
// StartStopPanel.c++
/////////////////////////////////////////////////////////////

#include "StartStopPanel.h"
#include <Xm/RowColumn.h>
#include <Xm/PushB.h>

// These are default resources for widgets in objects of this class
// All resources will be prefixed by *<name> at instantiation,
// where <name> is the name of the specific instance, as well as the
// name of the baseWidget. These are only defaults, and may be
// overriden in a resource file by providing a more specific resource
// name

String StartStopPanel::_defaultResources[] = {
  "*start.labelString:  Start",
  "*stop.labelString:   Stop",
  NULL
};

const char *const StartStopPanel::actionCallback = "actionCallback";

StartStopPanel::StartStopPanel(const char *name, Widget parent) :                                                       VkComponent(name)
{
  // Load class-default resources for this object before creating base widget

  setDefaultResources(parent, _defaultResources );

  // Create an XmRowColumn widget as the component's base widget
  // to contain the buttons. Assign the widget to the _baseWidget
  // data member.
 
  _baseWidget = XmCreateRowColumn ( parent, _name, NULL, 0 );

  // Set up callback to handle widget destruction

  installDestroyHandler();

  XtVaSetValues(_baseWidget, XmNorientation, XmHORIZONTAL, NULL);

  // Create all other widgets as children of the base widget.
  // Manage all child widgets.

  _startButton = XmCreatePushButton ( _baseWidget, "start", NULL, 0);
  _stopButton  = XmCreatePushButton ( _baseWidget, "stop", NULL, 0);

  XtManageChild(_startButton);
  XtManageChild(_stopButton);

  // Install static member functions as callbacks for the buttons

  XtAddCallback(_startButton, XmNactivateCallback,
                &StartStopPanel::startCallback, (XtPointer) this );

  XtAddCallback(_stopButton, XmNactivateCallback,
                &StartStopPanel::stopCallback, (XtPointer) this );
}

StartStopPanel::~StartStopPanel()
{
  // Empty
}

const char* StartStopPanel::className()
{
  return "StartStopPanel";
}

void StartStopPanel::startCallback(Widget w, XtPointer clientData,
                                   XtPointer callData)
{
  StartStopPanel *obj = ( StartStopPanel * ) clientData;
  obj->start(w, callData);
}

void StartStopPanel::stopCallback(Widget w, XtPointer clientData,
                                  XtPointer callData)
{
  StartStopPanel *obj = ( StartStopPanel * ) clientData;
  obj->stop(w, callData);
}

void StartStopPanel::start(Widget, XtPointer)
{
  callCallbacks(actionCallback, (void *) START);
}

void StartStopPanel::stop(Widget, XtPointer)
{
  callCallbacks(actionCallback, (void *) STOP);
}LBL="" HELPID=""Examples of Using and Subclassing a Component ClassIDREF="19462" TYPE="TEXT"Example 2-7 slightly changes the StartStopPanel class from previous examples by declaring the member function StartStopPanel::start() and StartStopPanel::stop() as virtual functions. This allows you to use the StartStopPanel in two different ways: using the component directly and subclassing the component.LBL="" HELPID=""Example of Using a Component Class DirectlyThe simplest way to use the StartStopPanel class is to register callbacks with StartStopPanel::actionCallback. To do so, instantiate a StartStopPanel object in your application and register as a callback a member function that tests the value of the call data and performs some operation based on the value. This option avoids the additional work required to create a subclass of StartStopPanel. This technique of using a component class is most appropriate if the class already has all the functionality you require.IDREF="62952" TYPE="TEXT"Example 2-8 shows a simple example of using the StartStopPanel directly. The PanelWindow class is a simple subclass of the VkSimpleWindow class, which is discussed in IDREF="45296" TYPE="TITLE"Chapter 4, "ViewKit Windows." It performs the following activities in its constructor:It instantiates a StartStopPanel object named "controlPanel" and assigns it to the _controlPanel variable.It specifies a vertical orientation for the StartStopPanel object.It installs PanelWindow::statusChanged() as a ViewKit callback function to be called whenever StartStopPanel::actionCallback triggers. In this example, PanelWindow::statusChanged() simply prints a status message to standard output whenever it is called.It installs the _controlPanel object as the window's "view." Showing the PanelWindow object will now display the _controlPanel object. (IDREF="52907" TYPE="TITLE""Creating the Window Interface" describes how to create window interfaces.)LBL="2-8"Example 2-8 ID="62952"Example of Using a Component Directly//////////////////////////////////////////////////////////////
// PanelWindow.h
//////////////////////////////////////////////////////////////

#ifndef _PANELWINDOW_H
#define _PANELWINDOW_H

#include "StartStopPanel.h"
#include <Vk/VkSimpleWindow.h>

// Define a top-level window class

class PanelWindow: public VkSimpleWindow {

  public:
    PanelWindow(const char *name);
    ~PanelWindow();
    virtual const char* className();

  protected:
    void statusChanged(VkCallbackObject *, void *, void *);

    StartStopPanel * _controlPanel;
};

#endif


//////////////////////////////////////////////////////////////
// PanelWindow.c++
//////////////////////////////////////////////////////////////

#include "PanelWindow.h"
#include <iostream.h>

PanelWindow::PanelWindow(const char *name) : VkSimpleWindow (name) 
{
    _controlPanel = new StartStopPanel( "controlPanel",
                                        mainWindowWidget() );

    XtVaSetValues(_controlPanel->baseWidget(),
                  XmNorientation, XmVERTICAL, NULL);

    _controlPanel->addCallback( StartStopPanel::actionCallback, this,
                         (VkCallbackMethod) &PanelWindow::statusChanged );

    addView(_controlPanel);
}

const char * PanelWindow::className()
{
    return "PanelWindow";
}      

PanelWindow::~PanelWindow()
{
    // Empty
}

void PanelWindow::statusChanged(VkCallbackObject *obj,
                                void *, void *callData)
{
    StartStopPanel * panel = (StartStopPanel *) obj;
    PanelAction action = (PanelAction) callData;
    switch (action) {
        case START:
            cout << "Process started\n" << flush;
            break;
        case STOP:
            cout << "Process stopped\n" << flush;
            break;
        default:
            cout << "Undefined state\n" << flush;
    }
}The following simple program displays the resulting PanelWindow object (IDREF="88118" TYPE="TITLE"Chapter 3, "The ViewKit Application Class," discusses the VkApp class)://////////////////////////////////////////////////////////////
// PanelTest.c++
//////////////////////////////////////////////////////////////

#include <Vk/VkApp.h>
#include "PanelWindow.h"

// Main driver. Just instantiate a VkApp and the PanelWindow,
// "show" the window and then "run" the application.

void main ( int argc, char **argv )
{
    VkApp        *panelApp = new VkApp("panelApp", &argc, argv);
    PanelWindow  *panelWin = new PanelWindow("panelWin");

    panelWin->show();
    panelApp->run();
}IDREF="72942" TYPE="GRAPHIC"Figure 2-3 shows the resulting PanelWindow window displayed by this program.FILE="PanelWindow1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="2-3"Figure 2-3 ID="72942"The Resulting PanelWindow WindowLBL="" HELPID=""Example of Using a Component Class by SubclassingAnother way to use the StartStopPanel class is to derive a subclass and override the StartStopPanel::start() and StartStopPanel::stop() functions. This technique of using a component class is most appropriate if you need to expand or modify a component's action in some way.IDREF="39820" TYPE="TEXT"Example 2-9 creates ControlPanel, a subclass of StartStopPanel that incorporates the features implemented in the PanelWindow class shown in IDREF="62952" TYPE="TEXT"Example 2-8.LBL="2-9"Example 2-9 ID="39820"Example of Subclassing a Component//////////////////////////////////////////////////////////////
// ControlPanel.h
//////////////////////////////////////////////////////////////

#ifndef _CONTROLPANEL_H
#define _CONTROLPANEL_H
#include "StartStopPanel.h"

class ControlPanel : public StartStopPanel {

  public:
    ControlPanel (const char *, Widget);
    ~ControlPanel();
    virtual const char *className();
  protected:
    virtual void start(Widget, XtPointer);
    virtual void stop(Widget, XtPointer);
};

#endif


//////////////////////////////////////////////////////////////
// ControlPanel.c++
//////////////////////////////////////////////////////////////

#include "ControlPanel.h"
#include <iostream.h>

ControlPanel::ControlPanel (const char *name , Widget parent) :
                                             StartStopPanel (name, parent)
{
    XtVaSetValues(_baseWidget, XmNorientation, XmVERTICAL, NULL);
}

ControlPanel::~ControlPanel()
{
    // Empty
}


const char* ControlPanel::className()
{
    return "ControlPanel";
}

void ControlPanel::start(Widget w, XtPointer callData)
{
    cout << "Process started\n" << flush;
    StartStopPanel::start(w, callData);
}

void ControlPanel::stop(Widget w, XtPointer callData)
{
    cout << "Process stopped\n" << flush;
    StartStopPanel::stop(w, callData);
}The ControlPanel constructor uses the StartStopPanel constructor to initialize the component, creating the widgets and initializing the component's data members. Then, the ControlPanel constructor sets the orientation resource of the RowColumn widget, which is the component's base widget, to VERTICAL.The ControlPanel class also overrides the virtual functions start() and stop() to perform the actions handled previously by the PanelWindow class. After performing these actions, the ControlPanel::start() and ControlPanel::stop() functions call StartStopPanel::start() and StartStopPanel::stop() respectively. While this may seem unnecessary for an example this simple, it helps preserve the encapsulation of the classes. You could now change the implementation of the StartStopPanel class, perhaps adding a status indicator to the component that the StartStopPanel::start() and StartStopPanel::stop() functions would update, and you would not have to change the start() and stop() function definitions in derived classes such as ControlPanel.The following simple example creates a VkSimpleWindow object, adds a ControlPanel as the window's view, and then displays the window://////////////////////////////////////////////////////////////
// PanelTest2.c++
//////////////////////////////////////////////////////////////

#include <Vk/VkApp.h>
#include <Vk/VkSimpleWindow.h>
#include "ControlPanel.h"

// Main driver. Instantiate a VkApp, a VkSimpleWindow, and a
// ControlPanel, add the ControlPanel as the SimpleWindow's view,
// "show" the window and then "run" the application.

void main ( int argc, char **argv )
{
    VkApp *panelApp = new VkApp("panel2App", &argc, argv);
    VkSimpleWindow *panelWin = new VkSimpleWindow("panelWin");
    ControlPanel *control = new ControlPanel("control",
                                             panelWin->mainWindowWidget() );
    panelWin->addView(control);
    panelWin->show();
    panelApp->run();
}LBL="3"ID="88118"The ViewKit Application ClassThis chapter describes the ID="Ch03_App1"ID="Ch03_App2"ID="Ch03_App3"VkApp class, which handles application-level tasks such as Xt initialization, event handling, window management, cursor control, and application busy states. IDREF="92753" TYPE="GRAPHIC"Figure 3-1 shows the inheritance graph for VkApp and an auxiliary class, VkCursorList.FILE="Fig3-1.ai" POSITION="INLINE" SCALE="FALSE"LBL="3-1"Figure 3-1 ID="92753"The Inheritance Graph for VkAppID="Ch03_App4"ID="Ch03_App5"LBL="" HELPID=""Overview of the VkApp ClassThe ID="Ch03_App6"VkApp class, derived from the VkComponent class, provides facilities required by all ViewKit applications. In all of your ViewKit applications you must create a single instance of VkApp or a class derived from VkApp.The primary responsibility of VkApp is to handle the initialization and event-handling operations common to all Xt-based applications. When you write a ViewKit application, instead of calling Xt functions such as XtAppInitialize(3Xt) and XtAppMainLoop(3Xt), you simply instantiate and use a VkApp object.The VkApp class also provides support for other application-level tasks. For example, VkApp provides functions for quitting your application; showing, hiding, iconifying, and opening all of the application's windows; handling application busy states; maintaining product version information; and setting the application's cursor shape.The VkApp class also stores some essential information that can be accessed throughout an application. This information includes: a pointer to the X Display structure associated with the application's connection to the server; the XtAppContext structure required by many Xt functions; the application's name; and the application's class name. This information is maintained in the private portion of the class and is available through public access functions.LBL="" HELPID=""The VkApp ConstructorIn all ViewKit applications you must create a single instance of the ID="Ch03_App7"ID="Ch03_App8"VkApp class (or a derived class) before instantiating any other ViewKit objects. The ID="Ch03_App9"VkApp constructor initializes the Xt Intrinsics and creates a shell, which is never visible, to serve as the parent for all of the application's main windows. ViewKit supports a commonly-used multi-shell architecture as described in the book ID="Ch03_App10"X Window System Toolkit (Asente and Swick, 1990). ViewKit creates all windows (using the VkSimpleWindow and VkWindow classes described in IDREF="45296" TYPE="TITLE"Chapter 4, "ViewKit Windows") as popup children of the shell created by VkApp.When you create an instance of the ID="Ch03_App11"ID="Ch03_App12"VkApp class, the constructor assigns a pointer to the VkApp object to the global variable theApplication. The <Vk/VkApp.h> header file declares this global variable as follows:extern VkApp *theApplication;As a result, the theApplication pointer is available in any file that includes the <Vk/VkApp.h> header file. This provides easy use of VkApp's facilities and data throughout your program.The syntax of the VkApp constructor is:VkApp(char *appClassName, int *argc, char **argv,
      XrmOptionDescRec *options = NULL,
      int numOptions = 0)The ID="Ch03_App13"appClassName argument designates the application class name, which is used when loading application resources. Note that VkApp differs from other ViewKit components in that you provide the application class name as an argument to the constructor rather than overriding the className() function. This allows you to set the application class name without creating a subclass of VkApp.ID="Ch03_App14"VkApp also differs from other ViewKit components in that you do not provide a component name in the constructor; instead, ViewKit uses the command that you used to invoke your application (argv[0]) as the component name.The second and third arguments to the ID="Ch03_App15"ID="Ch03_App16"VkApp constructor must be pointers to argc and the application's argv array. The VkApp constructor passes these arguments to XtOpenDisplay(3Xt), which parses the command line according to the standard Xt command-line options, loads recognized options into the application's resource database, and modifies argc and argv to remove all recognized options.You can specify additional command-line options to parse by passing an XrmOptionDescRec(3Xt) table as the options argument and specifying the number of entries in the table with the numOptions argument. This is sufficient for setting simple resource values from the command line; however, if you want to set application-level variables using either the command line or resource values, you should:Derive a subclass of VkApp.Use the protected member function VkApp::parseCommandLine() to parse command-line options.Use getResources() to set the variables based on resource values.This process is illustrated in IDREF="95213" TYPE="TEXT"Example 3-6 in IDREF="78971" TYPE="TITLE""Deriving Classes from VkApp".LBL="" HELPID=""Running ViewKit ApplicationsOnce you have instantiated a ID="Ch03_App17"ID="Ch03_App18"ID="Ch03_App19"VkApp object and set up your program's interface, call VkApp::run():virtual void run()The run() function enters a custom main loop that supports dispatching raw events in addition to the normal Xt event handling. See IDREF="59065" TYPE="TITLE""ViewKit Event Handling" for more information on event handling.NoteDo not call ID="Ch03_App20"XtMainLoop(3Xt) or XtAppMainLoop(3Xt) in a ViewKit application. ID="Ch03_App21"IDREF="70191" TYPE="TEXT"Example 3-1 illustrates the typical use of the VkApp class in the main body of a ViewKit program.LBL="3-1"Example 3-1 ID="70191"Typical Use of VkApp in a ViewKit Program#include <Vk/VkApp.h>

// Application-specific setup

void main ( int argc, char **argv )
{
    VkApp   *myApp = new VkApp("MyApp", &argc, argv);

    // Application-specific code

    myApp->run();  // Run the application
}LBL="" HELPID=""ID="59065"ViewKit Event HandlingThe ID="Ch03_App22"VkApp::run() function is ViewKit's main event loop. run() implements the event handling normally supported by XtAppMainLoop() or XtMainLoop(). Additionally, run() also supports events not normally handled by the Xt dispatch mechanism. For example, run() can handle events registered for non-widgets (such as a PropertyNotify event on the root window).When ID="Ch03_App23"run() receives an event not handled by the Xt dispatch mechanism, it calls the virtual function VkApp::handleRawEvent():virtual void handleRawEvent(XEvent *event)The default action of VkApp::handleRawEvent() is to pass the event to the handleRawEvent() function of each instance of VkSimpleWindow (or subclass) in the application. By default, these members function are empty.If you want to handle events through this mechanism, call ID="Ch03_App24"XSelectInput(3X) to select the events that you want to receive, and override handleRawEvent() in a VkApp or VkSimpleWindow subclass to implement your event processing. Generally, in keeping with object-oriented practice, you should override handleRawEvent() in a VkSimpleWindow subclass rather than a VkApp subclass, unless your event processing has an application-wide effect. If you override VkApp::handleRawEvent() in a derived class, call the base class's handleRawEvent() function after performing your event processing.NoteIf you explicitly call ID="Ch03_App25"ID="Ch03_App26"XtNextEvent(3Xt) and XtDispatchEvent(3Xt) in your application, you should pass any undispatched events to handleRawEvent(). In addition to the automatic event dispatching provided by ID="Ch03_App27"ID="Ch03_App28"ID="Ch03_App29"run(), you can force your application to handle all pending events immediately by calling VkApp::handlePendingEvents():virtual void handlePendingEvents()This function retrieves and dispatches all X events as long as there are events pending. Unlike XmUpdateDisplay(3Xm), which handles only Expose events, handlePendingEvents() handles all events. In other words, handlePendingEvents() does not just refresh windows, it also handles all pending events including user input. You might want to call this function periodically to process events during a time-consuming task.LBL="" HELPID=""ID="52836"Quitting ViewKit ApplicationsIf you want to exit a ViewKit application, but also want to give other parts of the application the option to abort the shutdown if necessary, call ID="Ch03_App30"ID="Ch03_App31"ID="Ch03_App32"VkApp::quitYourself():virtual void quitYourself()ID="Ch03_App33"VkApp::quitYourself() calls the okToQuit() function for each top-level VkSimpleWindow (or subclass). All windows that return TRUE are deleted; however, if the okToQuit() function of any window returns FALSE, the shutdown is terminated and the windows returning FALSE are not deleted. quitYourself() queries the windows in the reverse order in which they were created, except that it checks the window designated as the ID="Ch03_App34"main window last. (See IDREF="76444" TYPE="TITLE""Managing Top-Level Windows" for information on designating the main window.)The default, as provided by VkComponent, is for the okToQuit() function to return TRUE in all cases. You must override okToQuit() for all components that you want to perform a check before quitting. For example, you could override the okToQuit() function for a window to post a dialog asking the user whether he or she really wants to exit the application and then abort the shutdown if the user says to do so. Another possibility would be to return FALSE if a component is in the process of updating a file.Usually, only VkSimpleWindow and its subclasses use okToQuit(). In some cases, you might want to check one or more components contained within a window before quitting. To do so, override the okToQuit() function for that window to call the okToQuit() functions for all the desired components. Override the okToQuit() functions for the other components to perform whatever checks are necessary.A ViewKit application automatically exits once all of its windows are deleted. This can occur as a result of any of the following circumstances:the application calls quitYourself()the application deletes all of its windows individuallythe user deletes all application windows through window manager interaction (for example, selecting the "Close" option in the window menu provided by the window manager)Once all windows are deleted, the application exits by calling ID="Ch03_App35"VkApp::terminate():virtual void terminate(int status = 0)terminate() is a virtual function that calls exit(2). terminate() is also called from within ViewKit when any fatal error is detected.You can call terminate() explicitly to exit a ViewKit application immediately. Usually you would use this if you encounter a fatal error. If you provide a status argument, your application uses it as the exit value that the application returns.You can override terminate() in a VkApp subclass to perform any cleanup operations that your application requires before aborting (for example, closing a database). If you override terminate() in a derived class, call the base class's terminate() function after performing your cleanup operations.NoteEven though you can override ID="Ch03_App36"quitYourself() in a VkApp subclass, in most cases you should override terminate() instead. This ensures that any cleanup operations you add are performed no matter how the application exits (for example, by error condition or by user interaction with the window manager). If you decide to override quitYourself(), you must perform your cleanup operations before calling the base class's quitYourself(): if quitYourself() succeeds in deleting all windows, your application calls terminate() and exits before ever returning from quitYourself(). LBL="" HELPID=""ID="76444"Managing Top-Level WindowsThe ID="Ch03_App37"VkApp object maintains a list of all windows created in an application. The VkApp object uses this list to manage the application's top-level windows. So that VkApp can properly manage windows, you should always use the VkSimpleWindow and VkWindow classes to create top-level windows in your application. The classes are discussed in IDREF="45296" TYPE="TITLE"Chapter 4, "ViewKit Windows."Every application has a ID="Ch03_App38"main window. By default, the first window you create is treated as the main window. You can use the ID="Ch03_App39"VkApp::setMainWindow() function to specify a different window to treat as the main window:void setMainWindow(VkSimpleWindow *window)The access function ID="Ch03_App40"ID="Ch03_App41"VkApp::mainWindow() returns a pointer to the VkSimpleWindow (or subclass) object installed as the application's main window:VkSimpleWindow *mainWindow() constAdditionally, the VkApp class supports several operations that can be performed on all top-level windows in a multi-window application. All of the following functions take no arguments, have a void return value, and are declared virtual:ID="Ch03_App42"ID="Ch03_App43"show()Displays all of the application's hidden, non-iconified windows.ID="Ch03_App44"ID="Ch03_App45"hide()Removes all of the application's windows from the screen.ID="Ch03_App46"ID="Ch03_App47"iconify()Iconifies all visible windows in the application.ID="Ch03_App48"ID="Ch03_App49"open()Opens all iconified windows in the application.ID="Ch03_App50"ID="Ch03_App51"raise()Raises all visible windows in the application to the top of the window manager's window stack.ID="Ch03_App52"ID="Ch03_App53"lower()Lowers all visible windows in the application to the bottom of the window manager's window stack.You can also specify whether or not your application's windows start in an iconified state using ID="Ch03_App54"ID="Ch03_App55"VkApp::startupIconified():void startupIconified(const Boolean flag)If flag is TRUE, then the application starts all windows in the iconified state.NoteYou must call startupIconified() before calling run(), otherwise it will not have any effect. LBL="" HELPID=""Setting Application CursorsBy default, ID="Ch03_App56"ID="Ch03_App57"VkApp installs two cursors for ViewKit applications: an arrow for normal use, and a watch for display during busy states. (See IDREF="66712" TYPE="TITLE""Supporting Busy States" for information on busy states in ViewKit applications.) The VkApp class also provides several functions for installing your own cursors and retrieving the currently installed cursors.LBL="" HELPID=""Setting and Retrieving the Normal CursorID="Ch03_App58"ID="Ch03_App59"VkApp::setNormalCursor() sets the normal cursor for use in all of your application's windows while the application is not busy:void setNormalCursor(Cursor c)You must provide setNormalCursor() with a Cursor argument. See the XCreateFontCursor(3X) man page for more information on creating an X cursor.You can retrieve the current normal cursor with ID="Ch03_App60"VkApp::normalCursor():virtual Cursor normalCursor()LBL="" HELPID=""Setting and Retrieving the Busy CursorThe ID="Ch03_App61"ID="Ch03_App62"VkApp class supports both fixed and animated busy cursors. A fixed busy cursor retains the same appearance throughout a busy state. An animated busy cursor is actually a sequence of Pixmaps that you can cycle through while in a busy state, giving the appearance of animation. IDREF="46482" TYPE="TITLE""Animating the Busy Cursor" describes the procedure to follow to cycle through an animated busy cursor's Pixmaps. If you install an animated busy cursor but do not cycle it, VkApp simply uses the animated cursor's current Pixmap as a fixed busy cursor.The default busy cursor that ID="Ch03_App63"VkApp installs, a watch, is actually an animated cursor.LBL="" HELPID=""Setting and Retrieving a Fixed Busy CursorID="Ch03_App64"VkApp::setBusyCursor() sets a fixed busy cursor for use in all of your application's windows while the application is busy:void setBusyCursor(Cursor c)You must provide setBusyCursor() with a Cursor argument.You can retrieve the current busy cursor with ID="Ch03_App65"VkApp::busyCursor():virtual Cursor busyCursor()LBL="" HELPID=""Creating, Setting, and Retrieving an Animated Busy CursorTo create an animated busy cursor, you must create a subclass of the abstract base class ID="Ch03_App66"ID="Ch03_App67"VkCursorList. The syntax of the VkCursorList constructor is:VkCursorList (int numCursors)numCursors is the number of cursor Pixmaps in your animated cursor.The VkCursorList constructor uses this value to allocate space for an array of Cursor pointers. In your subclass constructor, you should perform any other initialization required by your cursor.In your subclass, you must also override the pure virtual function ID="Ch03_App68"VkCursorList::createCursor():virtual void createCursor(int index)createCursor() creates the cursor for the given index in the animated cursor array. Cursors are numbered sequentially beginning with zero. When your application animates the cursor, it step through the cursor array sequentially. createCursor() must assign the cursor it creates to the index entry in the protected _cursorList array:Pixmap *ID="Ch03_App69"_cursorListFor example, ID="Ch03_App70"IDREF="37791" TYPE="TEXT"Example 3-2 shows the code needed to create an animated hourglass busy cursor.LBL="3-2"Example 3-2 ID="37791"Example of Creating an Animated Busy Cursor#include <Vk/VkApp.h>
#include <Vk/VkResource.h>
#include <Vk/VkCursorList.h>

// Define an array of bit patterns that represent each frame of the cursor
// animation.

#define NUMCURSORS 8

static char time_bits[NUMCURSORS][32*32] = {
{
   0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x7f,
   0x8c, 0x00, 0x00, 0x31, 0x4c, 0x00, 0x00, 0x32, 0x4c, 0xff, 0xff, 0x32,
   0x4c, 0xff, 0xff, 0x32, 0x4c, 0xff, 0xff, 0x32, 0x4c, 0xff, 0xff, 0x32,
   0x8c, 0xfe, 0x7f, 0x31, 0x0c, 0xfd, 0xbf, 0x30, 0x0c, 0xfa, 0x5f, 0x30,
   0x0c, 0xe4, 0x27, 0x30, 0x0c, 0x98, 0x19, 0x30, 0x0c, 0x60, 0x06, 0x30,
   0x0c, 0x80, 0x01, 0x30, 0x0c, 0x80, 0x01, 0x30, 0x0c, 0x60, 0x06, 0x30,
   0x0c, 0x18, 0x18, 0x30, 0x0c, 0x04, 0x20, 0x30, 0x0c, 0x02, 0x40, 0x30,
   0x0c, 0x01, 0x80, 0x30, 0x8c, 0x00, 0x00, 0x31, 0x4c, 0x00, 0x00, 0x32,
   0x4c, 0x00, 0x00, 0x32, 0x4c, 0x00, 0x00, 0x32, 0x4c, 0x00, 0x00, 0x32,
   0x4c, 0x00, 0x00, 0x32, 0x8c, 0x00, 0x00, 0x31, 0xfe, 0xff, 0xff, 0x7f,
   0xfe, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00},
{
   0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x7f,
   0x8c, 0x00, 0x00, 0x31, 0x4c, 0x00, 0x00, 0x32, 0x4c, 0x03, 0xc0, 0x32,
   0x4c, 0x3f, 0xfc, 0x32, 0x4c, 0xff, 0xff, 0x32, 0x4c, 0xff, 0xff, 0x32,
   0x8c, 0xfe, 0x7f, 0x31, 0x0c, 0xfd, 0xbf, 0x30, 0x0c, 0xfa, 0x5f, 0x30,
   0x0c, 0xe4, 0x27, 0x30, 0x0c, 0x98, 0x19, 0x30, 0x0c, 0x60, 0x06, 0x30,
   0x0c, 0x80, 0x01, 0x30, 0x0c, 0x80, 0x01, 0x30, 0x0c, 0x60, 0x06, 0x30,
   0x0c, 0x18, 0x19, 0x30, 0x0c, 0x84, 0x20, 0x30, 0x0c, 0x02, 0x41, 0x30,
   0x0c, 0x81, 0x80, 0x30, 0x8c, 0x00, 0x01, 0x31, 0x4c, 0x80, 0x00, 0x32,
   0x4c, 0x00, 0x01, 0x32, 0x4c, 0xfc, 0x3f, 0x32, 0x4c, 0xff, 0xff, 0x32,
   0x4c, 0x00, 0x00, 0x32, 0x8c, 0x00, 0x00, 0x31, 0xfe, 0xff, 0xff, 0x7f,
   0xfe, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00},
{
   0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x7f,
   0x8c, 0x00, 0x00, 0x31, 0x4c, 0x00, 0x00, 0x32, 0x4c, 0x00, 0x00, 0x32,
   0x4c, 0x03, 0xc0, 0x32, 0x4c, 0x1f, 0xf8, 0x32, 0x4c, 0x7f, 0xfe, 0x32,
   0x8c, 0xfe, 0x7f, 0x31, 0x0c, 0xfd, 0xbf, 0x30, 0x0c, 0xfa, 0x5f, 0x30,
   0x0c, 0xe4, 0x27, 0x30, 0x0c, 0x98, 0x19, 0x30, 0x0c, 0x60, 0x06, 0x30,
   0x0c, 0x80, 0x01, 0x30, 0x0c, 0x80, 0x01, 0x30, 0x0c, 0x60, 0x06, 0x30,
   0x0c, 0x18, 0x19, 0x30, 0x0c, 0x84, 0x20, 0x30, 0x0c, 0x02, 0x41, 0x30,
   0x0c, 0x81, 0x80, 0x30, 0x8c, 0x00, 0x01, 0x31, 0x4c, 0xc0, 0x07, 0x32,
   0x4c, 0xfc, 0x3f, 0x32, 0x4c, 0xfe, 0x7f, 0x32, 0x4c, 0xff, 0xff, 0x32,
   0x4c, 0x00, 0x00, 0x32, 0x8c, 0x00, 0x00, 0x31, 0xfe, 0xff, 0xff, 0x7f,
   0xfe, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00},
{
   0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x7f,
   0x8c, 0x00, 0x00, 0x31, 0x4c, 0x00, 0x00, 0x32, 0x4c, 0x00, 0x00, 0x32,
   0x4c, 0x00, 0x00, 0x32, 0x4c, 0x03, 0xc0, 0x32, 0x4c, 0x0f, 0xf0, 0x32,
   0x8c, 0x3e, 0x7c, 0x31, 0x0c, 0xfd, 0xbf, 0x30, 0x0c, 0xfa, 0x5f, 0x30,
   0x0c, 0xe4, 0x27, 0x30, 0x0c, 0x98, 0x19, 0x30, 0x0c, 0x60, 0x06, 0x30,
   0x0c, 0x80, 0x01, 0x30, 0x0c, 0x80, 0x01, 0x30, 0x0c, 0x60, 0x06, 0x30,
   0x0c, 0x18, 0x19, 0x30, 0x0c, 0x84, 0x20, 0x30, 0x0c, 0x02, 0x41, 0x30,
   0x0c, 0x81, 0x80, 0x30, 0x8c, 0xe0, 0x07, 0x31, 0x4c, 0xfc, 0x3f, 0x32,
   0x4c, 0xfe, 0x7f, 0x32, 0x4c, 0xff, 0xff, 0x32, 0x4c, 0xff, 0xff, 0x32,
   0x4c, 0x00, 0x00, 0x32, 0x8c, 0x00, 0x00, 0x31, 0xfe, 0xff, 0xff, 0x7f,
   0xfe, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00},

{
    0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x7f,
   0x8c, 0x00, 0x00, 0x31, 0x4c, 0x00, 0x00, 0x32, 0x4c, 0x00, 0x00, 0x32,
   0x4c, 0x00, 0x00, 0x32, 0x4c, 0x00, 0x00, 0x32, 0x4c, 0x03, 0xc0, 0x32,
   0x8c, 0x06, 0x60, 0x31, 0x0c, 0x1d, 0xb8, 0x30, 0x0c, 0x7a, 0x5e, 0x30,
   0x0c, 0xe4, 0x27, 0x30, 0x0c, 0x98, 0x19, 0x30, 0x0c, 0x60, 0x06, 0x30,
   0x0c, 0x80, 0x01, 0x30, 0x0c, 0x80, 0x01, 0x30, 0x0c, 0x60, 0x06, 0x30,
   0x0c, 0x18, 0x19, 0x30, 0x0c, 0x84, 0x20, 0x30, 0x0c, 0x82, 0x41, 0x30,
   0x0c, 0xf1, 0x8f, 0x30, 0x8c, 0xfc, 0x3f, 0x31, 0x4c, 0xfe, 0x7f, 0x32,
   0x4c, 0xff, 0xff, 0x32, 0x4c, 0xff, 0xff, 0x32, 0x4c, 0xff, 0xff, 0x32,
   0x4c, 0x00, 0x00, 0x32, 0x8c, 0x00, 0x00, 0x31, 0xfe, 0xff, 0xff, 0x7f,
   0xfe, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00},
{
   0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x7f,
   0x8c, 0x00, 0x00, 0x31, 0x4c, 0x00, 0x00, 0x32, 0x4c, 0x00, 0x00, 0x32,
   0x4c, 0x00, 0x00, 0x32, 0x4c, 0x00, 0x00, 0x32, 0x4c, 0x00, 0x00, 0x32,
   0x8c, 0x02, 0x40, 0x31, 0x0c, 0x05, 0xa0, 0x30, 0x0c, 0x1a, 0x58, 0x30,
   0x0c, 0x64, 0x26, 0x30, 0x0c, 0x98, 0x19, 0x30, 0x0c, 0x60, 0x06, 0x30,
   0x0c, 0x80, 0x01, 0x30, 0x0c, 0x80, 0x01, 0x30, 0x0c, 0x60, 0x06, 0x30,
   0x0c, 0x18, 0x19, 0x30, 0x0c, 0x84, 0x20, 0x30, 0x0c, 0xe2, 0x47, 0x30,
   0x0c, 0xf9, 0x9f, 0x30, 0x8c, 0xfe, 0x7f, 0x31, 0x4c, 0xff, 0xff, 0x32,
   0x4c, 0xff, 0xff, 0x32, 0x4c, 0xff, 0xff, 0x32, 0x4c, 0xff, 0xff, 0x32,
   0x4c, 0x00, 0x00, 0x32, 0x8c, 0x00, 0x00, 0x31, 0xfe, 0xff, 0xff, 0x7f,
   0xfe, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00},
   
{
   0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x7f,
   0x8c, 0xff, 0xff, 0x31, 0xcc, 0xff, 0xff, 0x33, 0x4c, 0x00, 0x00, 0x32,
   0x4c, 0x00, 0x00, 0x32, 0x4c, 0x00, 0x00, 0x32, 0x4c, 0x00, 0x00, 0x32,
   0x8c, 0x00, 0x00, 0x31, 0x0c, 0x01, 0x80, 0x30, 0x0c, 0x02, 0x40, 0x30,
   0x0c, 0x04, 0x20, 0x30, 0x0c, 0x18, 0x18, 0x30, 0x0c, 0x60, 0x06, 0x30,
   0x0c, 0x80, 0x01, 0x30, 0x0c, 0x80, 0x01, 0x30, 0x0c, 0x60, 0x06, 0x30,
   0x0c, 0x98, 0x19, 0x30, 0x0c, 0xe4, 0x27, 0x30, 0x0c, 0xfa, 0x5f, 0x30,
   0x0c, 0xfd, 0xbf, 0x30, 0x8c, 0xfe, 0x7f, 0x31, 0x4c, 0xff, 0xff, 0x32,
   0x4c, 0xff, 0xff, 0x32, 0x4c, 0xff, 0xff, 0x32, 0x4c, 0xff, 0xff, 0x32,
   0x4c, 0x00, 0x00, 0x32, 0x8c, 0x00, 0x00, 0x31, 0xfe, 0xff, 0xff, 0x7f,
   0xfe, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00},

{
   0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x60, 0xfe, 0xff, 0xff, 0x7f,
   0xfe, 0xff, 0xff, 0x7f, 0x06, 0x00, 0x00, 0x60, 0x06, 0x00, 0x00, 0x60,
   0xf6, 0x01, 0x80, 0x6f, 0x0e, 0x02, 0x40, 0x78, 0xe6, 0x05, 0x20, 0x78,
   0xe6, 0x0b, 0x10, 0x78, 0xe6, 0x17, 0x08, 0x78, 0xe6, 0x2f, 0x04, 0x78,
   0xe6, 0x2f, 0x04, 0x78, 0xe6, 0x5f, 0x02, 0x78, 0xe6, 0x5f, 0x02, 0x78,
   0xe6, 0xbf, 0x01, 0x78, 0xe6, 0xbf, 0x01, 0x78, 0xe6, 0x5f, 0x02, 0x78,
   0xe6, 0x5f, 0x02, 0x78, 0xe6, 0x2f, 0x04, 0x78, 0xe6, 0x2f, 0x04, 0x78,
   0xe6, 0x17, 0x08, 0x78, 0xe6, 0x0b, 0x10, 0x78, 0xe6, 0x05, 0x20, 0x78,
   0x0e, 0x02, 0x40, 0x78, 0xf6, 0x01, 0x80, 0x6f, 0x06, 0x00, 0x00, 0x60,
   0x06, 0x00, 0x00, 0x60, 0xfe, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x7f,
   0x06, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00}
};

// Masks used for this cursor. The last frame requires a different
// mask, but all other frames can use the same mask.

static  char time_mask_bits[] = {
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0x8e, 0xff, 0xff, 0x71, 0xce, 0xff, 0xff, 0x73, 0xce, 0xff, 0xff, 0x73,
   0xce, 0xff, 0xff, 0x73, 0xce, 0xff, 0xff, 0x73, 0xce, 0xff, 0xff, 0x73,
   0x8e, 0xff, 0xff, 0x71, 0x0e, 0xff, 0xff, 0x70, 0x0e, 0xfe, 0x7f, 0x70,
   0x0e, 0xfc, 0x3f, 0x70, 0x0e, 0xf8, 0x1f, 0x70, 0x0e, 0xe0, 0x07, 0x70,
   0x0e, 0x80, 0x01, 0x70, 0x0e, 0x80, 0x01, 0x70, 0x0e, 0xe0, 0x07, 0x70,
   0x0e, 0xf8, 0x1f, 0x70, 0x0e, 0xfc, 0x3f, 0x70, 0x0e, 0xfe, 0x7f, 0x70,
   0x0e, 0xff, 0xff, 0x70, 0x8e, 0xff, 0xff, 0x71, 0xce, 0xff, 0xff, 0x73,
   0xce, 0xff, 0xff, 0x73, 0xce, 0xff, 0xff, 0x73, 0xce, 0xff, 0xff, 0x73,
   0xce, 0xff, 0xff, 0x73, 0x8e, 0xff, 0xff, 0xf1, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

#define time7_mask_width 32
#define time7_mask_height 32
#define time7_mask_x_hot 15
#define time7_mask_y_hot 15
static  char time7_mask_bits[] = {
   0x0f, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0,
   0xf7, 0x01, 0x80, 0xef, 0xff, 0x03, 0xc0, 0xff, 0xff, 0x07, 0xe0, 0xff,
   0xff, 0x0f, 0xf0, 0xff, 0xff, 0x1f, 0xf8, 0xff, 0xff, 0x3f, 0xfc, 0xff,
   0xff, 0x3f, 0xfc, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x7f, 0xfe, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff,
   0xff, 0x7f, 0xfe, 0xff, 0xff, 0x3f, 0xfc, 0xff, 0xff, 0x3f, 0xfc, 0xff,
   0xff, 0x1f, 0xf8, 0xff, 0xff, 0x0f, 0xf0, 0xff, 0xff, 0x07, 0xe0, 0xff,
   0xff, 0x03, 0xc0, 0xff, 0xf7, 0x01, 0x80, 0xef, 0x07, 0x00, 0x00, 0xe0,
   0x07, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0xf0};

/////////////////////////////////////////////////
// Class declaration. Subclass VkCursorList
///////////////////////////////////////////////////


class HourGlassCursors : public VkCursorList {
    
  public:
    HourGlassCursors( );

  protected:
    void createCursor(int index);   // Overrides base class' pure virtual

  private:
    XColor  xcolors[2];    
};


// The constructor gets two colors to use for the cursor.

HourGlassCursors::HourGlassCursors ( ) :  VkCursorList ( NUMCURSORS )
{
    xcolors[0].pixel= (Pixel) VkGetResource(theApplication->baseWidget(), 
                                            "busyCursorForeground", 
                                            XmCForeground, 
                                            XmRPixel, 
                                            (char *) "Black");
    
    xcolors[1].pixel= (Pixel) VkGetResource(theApplication->baseWidget(), 
                                            "busyCursorBackground",
                                            XmCBackground, 
                                            XmRPixel, 
                                            char *) "White");
    XQueryColors (theApplication->display(),
                  DefaultColormapOfScreen(DefaultScreenOfDisplay(dpy)),
                  xcolors, 2);
}

// This function is called as needed, to create a new cursor frame.
// Just create the cursor corresponding to the requested index and
// install it in _cursorList.

void HourGlassCursors::createCursor(int index)
{
    Pixmap pixmap = 0, maskPixmap = 0;
    Display *dpy = theApplication->display();

    pixmap = XCreateBitmapFromData (dpy,
                                    DefaultRootWindow(dpy),
                                    time_bits[index],
                                    32, 32);

    if(index == 7)
        maskPixmap = XCreateBitmapFromData (dpy,
                                            DefaultRootWindow(dpy),
                                            time7_mask_bits,
                                            32, 32);
    else
        maskPixmap = XCreateBitmapFromData (dpy,
                                            DefaultRootWindow(dpy),
                                            time_mask_bits,
                                            32, 32);

    _cursorList[index] = XCreatePixmapCursor ( dpy, pixmap, maskPixmap,
                                               &(xcolors[0]), &(xcolors[1]),
                                               0, 0);
    if(pixmap)
        XFreePixmap (dpy, pixmap);
    if(maskPixmap)
        XFreePixmap (dpy, maskPixmap);
}Once you have created an animated busy cursor, you can install it as your application's busy cursor using an overloaded version of the ID="Ch03_App71"VkApp::setBusyCursor() function:void setBusyCursor(VkCursorList *animatedCursor)You should provide as the argument to setBusyCursor() a pointer to your animated busy cursor object.When you use an animated busy cursor, the ID="Ch03_App72"busyCursor() function returns the currently displayed Pixmap of your busy cursor.LBL="" HELPID=""Setting and Retrieving a Temporary CursorYou can set a temporary cursor for use in all of your application's windows using ID="Ch03_App73"ID="Ch03_App74"VkApp::showCursor():void showCursor(Cursor c)Calling showCursor() immediately displays the temporary cursor. The cursor stays in effect until the application enters or exits a busy state, or you reset the cursor back to the normal cursor by calling showCursor() with a NULL cursor argument.You should use this function to display a cursor only briefly. If you want to change the cursor for an extended period, you should instead use setNormalCursor() or setBusyCursor().LBL="" HELPID=""ID="66712"Supporting Busy StatesThis section describes ViewKit's support for ID="Ch03_App75"busy states, when you lock out user input during an operation.LBL="" HELPID=""Entering and Exiting Busy States Using ViewKitWhenever you expect a procedure to take considerable time to complete, you can call the ID="Ch03_App76"ID="Ch03_App77"VkApp::busy() function before entering the relevant region of code to lock out user input in all application windows:virtual void busy(char *msg = NULL,
                  VkSimpleWindow window = NULL)If you call ID="Ch03_App78"ID="Ch03_App79"busy() with no arguments, the application simply displays a busy cursor. If you provide a string as the first argument, the application posts a dialog to display the string. The string is treated first as a resource name that ID="Ch03_App80"busy() looks up relative to the dialog widget. If the resource exists, its value is used as the message. If the resource does not exist, or if the string contains spaces or newline characters, busy() uses the string itself as the message.If you provide a VkSimpleWindow (or subclass) as the second argument, the application posts the dialog over this specified window. If you do not specify a window, the application posts the dialog over the main window. (See IDREF="76444" TYPE="TITLE""Managing Top-Level Windows" for instructions on setting the main window. See IDREF="57775" TYPE="TITLE"Chapter 7, "Using Dialogs in ViewKit," for more details on dialog behavior.)The ID="Ch03_App81"ID="Ch03_App82"VkApp::notBusy() function undoes the previous call to busy():virtual void notBusy()You can nest calls to ID="Ch03_App83"busy(), but you must always have matching busy()/notBusy() pairs. An application exits the busy state only when the number of notBusy() calls matches the number of busy() calls.NoteViewKit does not "stack" nested busy dialogs, it simply displays the most recently posted busy dialog. Once you post a busy dialog, it remains displayed until the busy state is over or you replace it with another busy dialog. ID="Ch03_App84"ID="Ch03_App85"IDREF="59946" TYPE="TEXT"Example 3-3 shows an example of setting busy dialog messages using resource values and using nested busy()/notBusy() calls. Note that this is not a complete example: it lists only the code relating to the busy states.LBL="3-3"Example 3-3 ID="59946"Using Busy States in a ViewKit Applicationclass ReportWindow: public VkSimpleWindow {

  public:
    ReportWindow ( const char *name );
    ~ReportWindow();
    virtual const char* className();
    void report();
    void sort();

  private:
    static String _defaultResources[];
};

String _defaultResources[] = {
    "*sortDialogMsg:    Sorting records...",
    "*reportDialogMsg:  Generating report...",
    NULL
};


ReportWindow::ReportWindow(const char *name) : VkSimpleWindow ( name )
{
  setDefaultResources(theApplication->baseWidget(), _defaultResources);
  // Create window...
}

void ReportWindow::sort()
{

  theApplication->busy("sortDialogMsg");
  // Sort records...
  theApplication->notBusy(); 
}
 
void ReportWindow::report()
{
  theApplication->busy("reportDialogMsg");
  // Report generation...
  sort();
  // Report generation continued...
  theApplication->notBusy(); 
}The ReportWindow class defines the busy dialog messages as resource values and loads these values using setDefaultResources() in the ReportWindow constructor. Unlike most ViewKit components, the VkSimpleWindow class constructor is not passed a parent widget. All ViewKit windows are children of the application's VkApp base widget. So, to access a window's parent widget, you must use the VkApp::baseWidget() access function as shown in this example.
 The calls to busy() pass these resource names instead of passing the actual dialog text. This allows you to override these resource values in an app-defaults file should you need to.When the application calls ReportWindow::report(), it posts the busy dialog shown in IDREF="89608" TYPE="GRAPHIC"Figure 3-2.FILE="busy1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="3-2"Figure 3-2 ID="89608"Example of Busy DialogWhen the application calls ReportWindow::sort(), it posts the busy dialog shown in IDREF="19288" TYPE="GRAPHIC"Figure 3-3.FILE="busy1-2.bw" POSITION="INLINE" SCALE="FALSE"LBL="3-3"Figure 3-3 ID="19288"Example of Nested Busy DialogNote that the application continues to display the second busy dialog until reaching the theApplication->notBusy() statement in ReportWindow::report().LBL="" HELPID=""ID="46482"Animating the Busy CursorTo animate the busy cursor during a busy state, periodically call ID="Ch03_App86"ID="Ch03_App87"VkApp::progressing():virtual void progressing(const char *msg = NULL)If you have an animated busy cursor installed, progressing() cycles to the next Pixmap in the cursor list. If you have a fixed cursor installed, progressing() has no effect on the busy cursor.If you provide a character string argument, your application posts a dialog to display the message. The string is treated first as a resource name that progressing() looks up relative to the dialog widget. If the resource exists, its value is used as the message. If the resource does not exist, or if the string contains spaces or newline characters, progressing() uses the string itself as the message.The code fragment in IDREF="70241" TYPE="TEXT"Example 3-4 performs a simulated lengthy task and periodically cycles the busy cursor.LBL="3-4"Example 3-4 ID="70241"Example of Animating the Busy Cursorint i;

// Start being "busy"

theApplication->busy("Busy", (BusyWindow *) clientData);

for(i=0; i<100; i++)
{
  // Every so often, update the busy cursor
  theApplication->progressing();
  sleep(1);
}

// Task done, so we"re not busy anymore
theApplication->notBusy();LBL="" HELPID=""Installing Different Busy DialogsBy default, ID="Ch03_App88"ID="Ch03_App89"ID="Ch03_App90"busy() displays the dialog using ID="Ch03_App91"ID="Ch03_App92"theBusyDialog, a global pointer to an instantiation of the VkBusyDialog classtheBusyDialog is actually implemented as a compiler macro that invokes a VkBusyDialog access function to return a pointer to the unique instantiation of the VkBusyDialog class. Although you should never need to use this access function directly, you might encounter it while debugging a ViewKit application that uses the busy dialog.
 (described in IDREF="49996" TYPE="TITLE""The Busy Dialog"). If you prefer to use a different dialog object, you can pass a pointer to the object to the setBusyDialog() function:void setBusyDialog(VkBusyDialog *dialog)This alternate busy dialog must be implemented as a subclass of VkBusyDialog. Calling setBusyDialog() with a NULL argument restores the default VkBusyDialog object.Most frequently, you will use ID="Ch03_App93"setBusyDialog() to install ID="Ch03_App94"ID="Ch03_App95"theInterruptDialog, a global pointer to an instantiation of the VkInterruptDialog class, which implements an interruptible busy dialogtheInterruptDialog is actually implemented as a compiler macro that invokes a VkInterruptDialog access function to return a pointer to the unique instantiation of the VkInterruptDialog class. Although you should never need to use this access function directly, you might encounter it while debugging a ViewKit application that uses the interruptible busy dialog.
. (IDREF="25718" TYPE="TITLE""The Interruptible Busy Dialog" describes the VkInterruptDialog class.) IDREF="75229" TYPE="TEXT"Example 3-5 shows a typical example of temporarily installing an interruptible busy dialog for a task.LBL="3-5"Example 3-5 ID="75229"Temporarily Installing an Interruptible Busy Dialog#inlcude <Vk/VkApp.h>
#include <Vk/VkInterruptDialog.h>

// ...

// Install theInterruptDialog as the busy dialog

theApplication->setBusyDialog(theInterruptDialog);
theApplication->busy("Generating report");  // Enter busy state

// Perform task...

theApplication->notBusy();                  // Exit busy state
theApplication->setBusyDialog(NULL);        // Install default busy dialogLBL="" HELPID=""ID="30388"Maintaining Product and Version InformationThe ID="Ch03_App96"VkApp class provides several access functions and constant data members that you can use to identify your application and the current ViewKit release.ID="Ch03_App97"VkApp::ViewKitMajorRelease is a static integer constant that identifies the major release of ViewKit; ID="Ch03_App98"VkApp::ViewKitMinorRelease is a static integer constant that identifies the minor release of ViewKit, and ID="Ch03_App99"VkApp::ViewKitReleaseString is a static character array constant that contains the complete major and minor release information. For example, in a 1.2 release, the value of VkApp::ViewKitMajorRelease would be 1, the value of VkApp::ViewKitMinorRelease would be 2, and the value of VkApp::ViewKitReleaseString would be "ViewKit Release: 1.2". These values can be useful if you need to provide conditional statements in your code to handle different versions of the ViewKit library.You can use ID="Ch03_App100"ID="Ch03_App101"VkApp::setVersionString() to set version information for an application based on ViewKit:void setVersionString(const char *versionInfo)You can retrieve the version string using ID="Ch03_App102"VkApp::versionString():const char *versionString()ViewKit displays this version string in the Product Information dialog that is posted when a user selects "Product Info" from the default Help menu. (See ID="Ch03_App103"ID="Ch03_App104"IDREF="29804" TYPE="TITLE""The ViewKit Help Menu" for more information on the default Help menu.) For example, consider an application that you invoke with the command MapMaker that includes the following line of code:theApplication->setVersionString("MapMaker 2.1");If you select "Product Info" from the default Help menu, your application posts the dialog shown in IDREF="42226" TYPE="GRAPHIC"Figure 3-4.FILE="ProductInfoDialog1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="3-4"Figure 3-4 ID="42226"Example of the Product Information DialogYou can use ID="Ch03_App105"VkApp::setAboutDialog() to replace the standard Product Information dialog with your own custom dialog:void setAboutDialog(VkDialogManager *dialog)You must provide setAboutDialog() with a pointer to an object that is a subclass of VkDialogManager. Most frequently, you will actually create a subclass of VkGenericDialog, an abstract subclass of VkDialogManager that simplifies the process of creating custom dialogs. IDREF="36739" TYPE="TITLE""Deriving New Dialog Classes Using the Generic Dialog"describes creating a custom dialog.The ID="Ch03_App106"VkApp::aboutDialog() function returns a pointer to the custom Product Information dialog you have installed:VkDialogManager* aboutDialog()LBL="" HELPID=""ID="21821"Application Data Access FunctionsVkApp provides several access functions for retrieving data useful for your application:char *ID="Ch03_App107"name() constReturns the command name you used to invoke the application (ID="Ch03_App108"argv[0]).char *ID="Ch03_App109"applicationClassName() constReturns the application class name set in the ID="Ch03_App110"VkApp constructor. This application class name is used when loading application resources.virtual const char *ID="Ch03_App111"className() constReturns the class name of the VkApp (or subclass) instance being used. By default, this is "VkApp". Note that unlike all other ViewKit components, the VkApp class does not use the value returned by className() when loading resources; instead, it uses the application class name that you provide as an argument to the VkApp constructor. This allows you to set the application class name without creating a subclass of VkApp.XtAppContext ID="Ch03_App112"appContext() constReturns the application's XtAppContext structure, which is required by many IRIS IM and Xt functions.ID="Ch03_App113"Display *ID="Ch03_App114"display() constReturns a pointer to the X Display structure associated with the application's connection to the X server.ID="Ch03_App115"char *ID="Ch03_App116"shellGeometry() constReturns a string containing the geometry of the application's base shell. You may want to use this information to size other windows in your application.ID="Ch03_App117"int ID="Ch03_App118"argc() constReturns the number of items remaining in the ID="Ch03_App119"argv array after all arguments recognized by Xt have been removed.char **ID="Ch03_App120"argv() constCalled without arguments, this function returns a pointer to the ID="Ch03_App121"argv array after all arguments recognized by Xt have been removed.char *argv(int index) constCalled with an integer argument, this function returns a single argv array item (after all arguments recognized by Xt have been removed) specified by the index argument.Boolean ID="Ch03_App122"startupIconified() constCalled with no arguments, this function returns the value TRUE if the application starts with all windows iconified and FALSE if it starts with all windows displayed normally.ID="Ch03_App123"Widget ID="Ch03_App124"baseWidget()For the ID="Ch03_App125"ID="Ch03_App126"VkApp class, baseWidget() returns the hidden shell widget.LBL="" HELPID=""ID="78971"Deriving Classes from VkAppThis section describes ID="Ch03_App127"VkApp protected functions and data members that you can use in a VkApp subclass. Following that is an example of subclassing VkApp to parse command-line options.LBL="" HELPID=""VkApp Protected Functions and Data MembersYou can use ID="Ch03_App128"ID="Ch03_App129"VkApp::parseCommandLine() to parse command line options:int parseCommandLine(XrmOptionDescRec *options,
                     Cardinal numOptions)You should call parseCommandLine() from within the constructor of your VkApp subclass. Provide an XrmOptionDescRec(3Xt) table as the options argument and specify the number of entries in the table with the numOptions argument. parseCommandLine() passes these arguments to XtOpenDisplay(3Xt), which parses the command line and loads recognized options into the application's resource database. parseCommandLine() modifies argv to remove all recognized options and returns an updated value of argc which you must use to update the value of argc. IDREF="95213" TYPE="TEXT"Example 3-6 shows an example of using parseCommandLine().You can override ID="Ch03_App130"VkApp::afterRealizeHook() to perform certain actions after all application windows have been realized:virtual void afterRealizeHook()For example, you could override afterRealizeHook() to install a colormap or set properties on the application's windows. By default, this function is empty.When subclassing ID="Ch03_App131"VkApp, you also have access to the protected data member VkApp::_winList:VkComponentList _winListThis data member maintains the list of the application's top-level windows. Consult the VkComponentList(3Vk) reference page for more information on the VkComponentList class.LBL="" HELPID=""Example of Subclassing VkAppThe most common reason for creating a subclass of ID="Ch03_App132"ID="Ch03_App133"VkApp is to parse the command line and set global resources based on command line options. Also, rather than use global variables, you can store data that is needed throughout your application in data members of your VkApp subclass.The program in IDREF="95213" TYPE="TEXT"Example 3-6 creates MyApp, a VkApp subclass that recognizes a -verbose command line argument and initializes a protected data member depending on whether or not the flag is present.Note that this example uses the protected VkApp function parseCommandLine() to extract the flag if it exists. This function returns an updated value of argc which must be used to update the value of argc as passed by the calling application.LBL="3-6"Example 3-6 ID="95213"Deriving a Subclass from VkApp#include <Vk/VkApp.h>
#include <Vk/VkResource.h>

class MyApp : public VkApp {

  public:
    MyApp(char             *appClassName,
          int              *arg_c,
          char            **arg_v,
          XrmOptionDescRec *optionList       = NULL,
          int               sizeOfOptionList = 0);

    Boolean verbose() { return _verbose; }       // Access function

  protected:
    Boolean   _verbose;                         // Data member to initialize

  private:
    static XrmOptionDescRec _cmdLineOptions[];  // Command-line options
    static XtResource _resources[];             // Resource descriptions
};


// Describe the command line options

XrmOptionDescRec MyApp::_cmdLineOptions[] = 
{
    {
    "-verbose", "*verbose", XrmoptionNoArg, "TRUE",
    },
};

// Describe the resources to retrieve and use to initialize the class

XtResource MyApp::_resources [] = {
{
    "verbose", 
    "Verbose", 
    XmRBoolean, 
    sizeof ( Boolean ),
    XtOffset ( MyApp *, _verbose ), 
    XmRString,
    (XtPointer) "FALSE",
  },
};

MyApp::MyApp(char    *appClassName,
    int              *arg_c, 
    char            **arg_v,
    XrmOptionDescRec *optionList,
    int               sizeOfOptionList) : VkApp(appClassName,
                                              arg_c, 
                                              arg_v,
                                              optionList,
                                              sizeOfOptionList)
{
    // Parse the command line, loading options into the resource database

    *arg_c = parseCommandLine(_cmdLineOptions,
                              XtNumber(_cmdLineOptions));

    // Initialize this class from the resource data base

    getResources (_resources, XtNumber(_resources));
}"Adding a Window Interface to a Direct Instantiation of a ViewKit Window Class"LBL="4"ID="45296"ViewKit WindowsThis chapter introduces the basic ViewKit classes needed to create and manipulate the top-level windows in a ViewKit application: ID="Ch04_Windows1"ID="Ch04_Windows2"ID="Ch04_Windows3"ID="Ch04_Windows4"VkSimpleWindow and VkWindow. IDREF="68839" TYPE="GRAPHIC"Figure 4-1 shows the inheritance graph for these classes.FILE="Fig4-1.ai" POSITION="INLINE" SCALE="FALSE"LBL="4-1"Figure 4-1 ID="68839"The Inheritance Graph for VkSimpleWindow and VkWindowID="Ch04_Windows5"LBL="" HELPID=""Overview of ViewKit Window SupportThis section describes how ViewKit supports multiple top-level windows in an application, and then describes the ViewKit classes that implement these windows.ID="Ch04_Windows6"LBL="" HELPID=""ViewKit's Multi-Window ModelThere are several possible models for multi-window applications in Xt. One approach is to create a single top-level window used as the main window of the application. All other windows are then popup shells whose parent is the main window. Another approach is to create a single shell that never appears on the screen. All other windows are then popup children of the main shell. In this model, all top-level windows are treated equally, as siblings. One window may logically be the top-level window of the application, but as far as Xt is concerned, all windows are equal.ID="Ch04_Windows7"ViewKit follows the second model. The VkApp class, described in IDREF="88118" TYPE="TITLE"Chapter 3, "The ViewKit Application Class," creates a single widget that serves as the parent of all top-level windows created by the program. The VkApp base widget does not appear on the screen.LBL="" HELPID=""ViewKit Window ClassesAll top-level windows in a ViewKit application must be instances of ID="Ch04_Windows8"VkSimpleWindow, VkWindow, or a subclass of one of these classes. The VkSimpleWindow class supports a top-level window that does not include a menu bar. The VkWindow class, derived from VkSimpleWindow, adds support for a menu bar along the top of the window. You must create a separate instance of VkSimpleWindow, VkWindow, or a subclass of one of these classes for each top-level window in your application.Instantiating a VkSimpleWindow or VkWindow object creates a popup shell as a child of the invisible shell created by your application's instance of VkApp. VkSimpleWindow and VkWindow also create a XmMainWindow widget as a child of the popup shell. You define the contents of a window by creating a widget or ViewKit component to use as the work area (or ID="Ch04_Windows9"ID="Ch04_Windows10"ID="Ch04_Windows11"view) for the XmMainWindow widget. In most cases, you will create several widgets and/or ViewKit components as children of a container widget and then assign that container widget as the view of the XmMainWindow widget. IDREF="52907" TYPE="TITLE""Creating the Window Interface" describes how to assign a view to a window. IDREF="42449" TYPE="GRAPHIC"Figure 4-2 shows an example of a widget hierarchy for the top-level windows of a simple ViewKit application with two top-level windows.FILE="Fig4-2.ai" POSITION="INLINE" SCALE="FALSE"LBL="4-2"Figure 4-2 ID="42449"Widget Hierarchy of Top-Level Windows in ViewKit ApplicationsIn most cases, directly instantiating a VkSimpleWindow or VkWindow object is not appropriate. There are exceptional cases for which you might choose to directly instantiate a VkSimpleWindow or VkWindow object and then associate a view with the window. For example, if you have a complex, self-contained component and need a window simply to display the component, you might find this method acceptable. IDREF="50466" TYPE="TITLE" describes how to do this.
 In addition to the widgets and components composing the window's interface, most windows require other data and support functions. In accordance with good object-oriented programming style, the functions and data associated with a window should be contained within that window's class. Therefore, the best practice to follow when creating a ViewKit application is to create a separate subclass for each window in your application. You can derive these subclasses from VkWindow for those windows that require menu bars, and from VkSimpleWindow for those windows that do not. IDREF="11089" TYPE="TITLE""Deriving Window Subclasses" describes in detail the process of deriving window subclasses.In addition to creating shell and XmMainWindow widgets, the VkSimpleWindow and VkWindow classes set up various properties on the shell window and provide simple hooks for window manager interactions. IDREF="67202" TYPE="TITLE""Window Manager Interface" discusses the built-in window manager support.The VkSimpleWindow and VkWindow classes provide simple functions to raise, lower, iconify, and open windows, as described in IDREF="12584" TYPE="TITLE""Manipulating Windows". The classes also provide several convenience function for determining a window's state (for example, whether it is visible, iconified, and so on) and for retrieving other window information. These access functions are described in IDREF="71268" TYPE="TITLE""Window Data Access Functions".The VkSimpleWindow and VkWindow classes also register their windows with the application's VkApp instance to support application-wide services such as setting the cursor for all of an application's windows, entering busy states, and manipulating all windows in an application. IDREF="88118" TYPE="TITLE"Chapter 3, "The ViewKit Application Class," describes how to use these application-wide services.LBL="" HELPID=""Window Class ConstructorsThe ID="Ch04_Windows12"ID="Ch04_Windows13"VkSimpleWindow and VkWindow constructors both have the same form:VkSimpleWindow(const char *name,
               ArgList args = NULL,
               Cardinal argCount = 0)

VkWindow(const char *name,
         ArgList args = NULL,
         Cardinal argCount = 0)Unlike most other ViewKit components, the VkSimpleWindow and VkWindow constructors do not require a parent widget as an argument: all ViewKit windows are automatically created as children of the invisible shell created by your application's instance of ID="Ch04_Windows14"VkApp. You must specify a name for your window. Optionally, you can also provide a standard Xt argument list that the constructor will use when creating the window's popup shell.Every application has a ID="Ch04_Windows15"ID="Ch04_Windows16"main window. By default, the first window you create is treated as the main window. To specify a different window to use as the main window, use the VkApp::setMainWindow() function described in IDREF="76444" TYPE="TITLE""Managing Top-Level Windows".Because the first window you create is by default the main window, the window class constructors also set some shell resources on the popup shell widget of that window. The constructors obtain the geometry of the invisible application shell created by ID="Ch04_Windows17"ID="Ch04_Windows18"VkApp and assign that geometry to the window's popup shell widget. The constructors also set the XmNargc and XmNargv resources on the popup shell to the values of ID="Ch04_Windows19"ID="Ch04_Windows20"ID="Ch04_Windows21"VkApp::argc() and VkApp::argv() respectively. (IDREF="21821" TYPE="TITLE""Application Data Access Functions" describes VkApp::argc() and VkApp::argv().)Finally, for all windows, the window class constructors register a callback function to handle messages from the window manager. The default action of upon receiving a WM_DELETE_WINDOW message is to delete the window object. To change this behavior, override the ID="Ch04_Windows22"ID="Ch04_Windows23"handleWmDeleteMessage() member function as described in IDREF="73633" TYPE="TITLE""Window Properties and Shell Resources". The default action of upon receiving a WM_QUIT_APP message is to quit the application. To change this behavior, override the ID="Ch04_Windows24"handleWmQuitMessage() member function as described in IDREF="73633" TYPE="TITLE""Window Properties and Shell Resources".LBL="" HELPID=""Window Class DestructorsThe ID="Ch04_Windows25"ID="Ch04_Windows26"VkSimpleWindow and VkWindow destructors delete all privately allocated data and destroy the views associated with the windows. The ID="Ch04_Windows27"VkWindow destructor also destroys any menu bar associated with the window, no matter how you added it (see IDREF="88773" TYPE="TITLE""Menu Bar Support"). If you created a subclass, you should provide a destructor to free any space that you explicitly allocated in the derived class.The ID="Ch04_Windows28"VkSimpleWindow and VkWindow destructors also remove the window from the application's list of windows. If this window is the only window still associated with the application (for example, if it is the only window created or all other windows have also been deleted), then your application automatically calls ID="Ch04_Windows29"VkApp::terminate() to quit itself. IDREF="52836" TYPE="TITLE""Quitting ViewKit Applications" describes VkApp::terminate().LBL="" HELPID=""ID="52907"Creating the Window InterfaceThere are three methods that you can use to create the contents of a window:ID="Ch04_Windows30"ID="Ch04_Windows31"ID="Ch04_Windows32"ID="Ch04_Windows33"ID="Ch04_Windows34"ID="Ch04_Windows35"ID="Ch04_Windows36"Create a subclass of VkSimpleWindow or VkWindow and define the interface in the class constructorCreate a subclass of VkSimpleWindow or VkWindow and define the interface by overriding the virtual function setUpInterface(), Create an instance of VkSimpleWindow or VkWindow, define the interface separately, and then add the interface as the window's viewThese methods, and the advantages and disadvantages of each approach, are discussed in the following sections.LBL="" HELPID=""ID="23789"Creating the Window Interface in the ConstructorThe preferred method of defining the contents of a window is to create the interface in the constructor of a ID="Ch04_Windows37"ID="Ch04_Windows38"ID="Ch04_Windows39"VkSimpleWindow or VkWindow subclass. In this case, you simply create the widgets and components that you want to appear in your window in your subclass constructor. Remember that each window can have only one direct child widget as a view, so in most cases you must create a container widget and then create all other widgets and components as descendents of this direct child. Manage all widgets except the container widget, which you should leave unmanaged.ID="Ch04_Windows40"ID="Ch04_Windows41"ID="Ch04_Windows42"The parent widget of your view's top-level widget or component must be the window's XmMainWindow widget. You can retrieve this widget by calling the ID="Ch04_Windows43"ID="Ch04_Windows44"mainWindowWidget() function inherited from VkSimpleWindow. IDREF="71268" TYPE="TITLE""Window Data Access Functions" discusses the mainWindowWidget() function.NoteThe ID="Ch04_Windows45"ID="Ch04_Windows46"ID="Ch04_Windows47"ID="Ch04_Windows48"_baseWidget data member for VkSimpleWindow and derived classes is the window's popup shell widget. Do not assign any other widget to this data member in a derived class. After creating your interface, call ID="Ch04_Windows49"ID="Ch04_Windows50"addView():void addView(Widget w)
void addView(VkComponent *component)addView() accepts as an argument either a widget or a pointer to a component, which addView() installs as the view for the window.NoteSome IRIS IM functions such as XmCreateScrolledText(3Xm) create a ScrolledWindow widget and a child widget, and then return the ID of the child widget. As a convenience for using these functions, ID="Ch04_Windows51"addView() can automatically determine the correct parent widget if you provide the child widget ID instead of the ScrolledWindow ID. IDREF="69935" TYPE="TEXT"Example 4-1 shows a simple example that defines ScaleWindow, which creates a window with a RowColumn widget containing three Scale widgets. Because ScaleWindow is derived from VkSimpleWindow, it does not support a menu bar. If you required a menu bar, you would instead derive this class from VkWindow.Note that ScaleWindow includes default resources for the Scale widget labels. This encapsulation technique is a good object-oriented practice to follow when creating reusable components in ViewKit. For example, if you were to extend this class by adding callback functions to the Scale widgets, you should make the callback functions members of the ScaleWindow class.LBL="4-1"Example 4-1 ID="69935"Example of Creating a Window Interface in the Class Constructor///////////////////////////
// ScaleWindow.h
///////////////////////////

#include <Vk/VkSimpleWindow.h>

class ScaleWindow: public VkSimpleWindow {

  public:
    ScaleWindow (const char *);
    ~ScaleWindow();
    virtual const char* className();

  private:
    static String _defaultResources[];
};

///////////////////////////
// ScaleWindow.c++
///////////////////////////

#include "ScaleWindow.h"
#include <Xm/RowColumn.h>
#include <Xm/Scale.h>

String ScaleWindow::_defaultResources[] = {
    "*dayScale.titleString:    Days",
    "*weekScale.titleString:   Weeks",
    "*monthScale.titleString:  Months",
    NULL };

ScaleWindow::ScaleWindow (const char *name) : VkSimpleWindow (name)
{
    setDefaultResources(mainWindowWidget(), _defaultResources);
    
    Widget scales = XtCreateWidget("scales", xmRowColumnWidgetClass,
                                   mainWindowWidget(), NULL, 0);
    
    Widget dayScale = XtCreateManagedWidget("dayScale", xmScaleWidgetClass,
                                            scales, NULL, 0);
    XtVaSetValues(dayScale,
                  XmNorientation, XmHORIZONTAL,
                  XmNminimum, 1,
                  XmNmaximum, 7,
                  XmNvalue, 1,
                  XmNshowValue, TRUE,
                  NULL);

    Widget weekScale = XtCreateManagedWidget("weekScale", xmScaleWidgetClass,
                                             scales, NULL, 0);
    XtVaSetValues(weekScale,
                  XmNorientation, XmHORIZONTAL,
                  XmNminimum, 1,
                  XmNmaximum, 52,
                  XmNvalue, 1,
                  XmNshowValue, TRUE,
                  NULL);
    Widget monthScale = XtCreateManagedWidget("monthScale", xmScaleWidgetClass,
                                              scales, NULL, 0);
    XtVaSetValues(monthScale,
                  XmNorientation, XmHORIZONTAL,
                  XmNminimum, 1,
                  XmNmaximum, 12,
                  XmNvalue, 1,
                  XmNshowValue, TRUE,
                  NULL);

    addView(scales);    
}

ScaleWindow::~ScaleWindow()
{
    // Empty
}

const char* ScaleWindow::className()
{
    return "ScaleWindow";
}


///////////////////////////
// scaleApp.c++
///////////////////////////

#include "ScaleWindow.h"
#include <Vk/VkApp.h>

void main ( int argc, char **argv )
{
    VkApp *scaleApp = new VkApp("ScaleApp", &argc, argv);
    ScaleWindow *scaleWin = new ScaleWindow("scaleWin");

    scaleWin->show();
    scaleApp->run();
}Running the scaleApp program shown above displays a ScaleWindow, as shown in IDREF="84605" TYPE="GRAPHIC"Figure 4-3.FILE="ScaleWindow1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="4-3"Figure 4-3 ID="84605"A Simple Example of a VkSimpleWindow SubclassYou can also create components and add them just as you would widgets. The constructor shown in IDREF="86265" TYPE="TEXT"Example 4-2 creates a VkRadioBox(3Vk) component and installs several items.LBL="4-2"Example 4-2 ID="86265"Using a Component as a Window's View///////////////////////////
// RadioWindow.h
///////////////////////////

#include <Vk/VkSimpleWindow.h>

class RadioWindow: public VkSimpleWindow {

  public:
    RadioWindow (const char *);
    ~RadioWindow();
    virtual const char* className();

  private:
    static String _defaultResources[];
};
///////////////////////////
// RadioWindow.c++
///////////////////////////

#include "RadioWindow.h"
#include <Vk/VkRadioBox.h>

String RadioWindow::_defaultResources[] = {
    "*color*label*labelString:  Color",
    "*red.labelString:    Red",
    "*green.labelString:  Green",
    "*blue.labelString:   Blue",
    NULL };

RadioWindow::RadioWindow (const char *name) : VkSimpleWindow (name)
{
    setDefaultResources(mainWindowWidget(), _defaultResources);
    
    VkRadioBox *rb = new VkRadioBox( "color", mainWindowWidget() );

    rb->addItem("red");
    rb->addItem("green");
    rb->addItem("blue");

    addView(rb);
}

RadioWindow::~RadioWindow()
{
    // Empty
}

const char* RadioWindow::className()
{
    return "RadioWindow";
}


///////////////////////////
// radioApp.c++
///////////////////////////

#include <Vk/VkApp.h>
#include "RadioWindow.h"

void main ( int argc, char **argv )
{
    VkApp *radioApp = new VkApp("RadioApp", &argc, argv);
    RadioWindow *radioWin = new RadioWindow("radioWin");

    radioWin->show();
    radioApp->run();
}Running the radioApp program shown above displays a RadioWindow as shown in IDREF="44339" TYPE="GRAPHIC"Figure 4-4.FILE="RadioWindow1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="4-4"Figure 4-4 ID="44339"A Simple Example of Using a Component as a Window's ViewLBL="" HELPID=""Creating the Window Interface in the setUpInterface() FunctionWhen you create your window interface in your window constructor using ID="Ch04_Windows52"ID="Ch04_Windows53"ID="Ch04_Windows54"ID="Ch04_Windows55"addView(), all setup overhead occurs when the window is instantiated. Additionally, your program allocates memory for all of the widgets created. Occasionally, you might need to instantiate a window so that your application can access some of its public functions, but not display it. If the window interface is large or complex, the time and memory consumed to create the interface is unnecessary if the user might not display it.The ViewKit window classes provide a mechanism for delaying the creation of a window's interface until the window needs to be displayed. Rather than including the interface code in the window constructor, you can include the code in the definition of the protected virtual member function ID="Ch04_Windows56"ID="Ch04_Windows57"setUpInterface().When you call ID="Ch04_Windows58"ID="Ch04_Windows59"show() to display a window, show() checks to see whether you have already added a view to the window (for example, in the window's constructor). If not, show() calls setUpInterface() to create the window's interface.Using this approach, you do not allocate memory for the window interface until your application actually displays the window for the first timename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'and you never allocate the memory if your application never displays the window. Additionally, this approach reduces your application's startup time. The trade-off is that the first time you display this window, the response time might be slow because your application must create the interface before displaying the window.The syntax of setUpInterface() is:virtual Widget setUpInterface(Widget parent)show() passes the main window widget to setUpInterface() for you to use as the parent of the window's widget hierarchy. You must return a widget to be added as a view. Do not call addView() from within setUpInterface().NoteSome IRIS IM functions such as XmCreateScrolledText(3Xm) create a ScrolledWindow widget and a child widget, and then return the ID of the child widget. As a convenience for using these functions, setUpInterface() can automatically determine the correct parent widget if you provide the child widget ID instead of the ScrolledWindow ID. IDREF="56413" TYPE="TEXT"Example 4-3 shows the RadioWindow example from IDREF="86265" TYPE="TEXT"Example 4-2 rewritten to use setUpInterface() instead of addView() in the constructor.LBL="4-3"Example 4-3 ID="56413"Example of Creating a Window's Interface in the setUpInterface() Function///////////////////////////
// RadioWindow2.h
///////////////////////////

#include <Vk/VkSimpleWindow.h>

class RadioWindow: public VkSimpleWindow {

  public:
    RadioWindow (const char *);
    ~RadioWindow();
    virtual const char* className();

  protected:
    Widget setUpInterface(Widget);

  private:
    static String _defaultResources[];
};


///////////////////////////
// RadioWindow2.c++
///////////////////////////

#include "RadioWindow2.h"
#include <Vk/VkRadioBox.h>

String RadioWindow::_defaultResources[] = {
    "*color*label*labelString:  Color",
    "*red.labelString:    Red",
    "*green.labelString:  Green",
    "*blue.labelString:   Blue",
    NULL };

RadioWindow::RadioWindow (const char *name) : VkSimpleWindow (name)
{
    // Empty
}

RadioWindow::~RadioWindow()
{
    // Empty
}

const char* RadioWindow::className()
{
    return "RadioWindow";
}

Widget RadioWindow::setUpInterface (Widget parent)
{
    setDefaultResources(mainWindowWidget(), _defaultResources);
    
    VkRadioBox *rb = new VkRadioBox( "color", parent );

    rb->addItem("red");
    rb->addItem("green");
    rb->addItem("blue");

    return(*rb);
}Note that this example uses the Widget operator defined by VkComponent to return the VkRadioBox's base widget in setUpInterface(). (See IDREF="44238" TYPE="TITLE""VkComponent Access Functions" for information on the Widget operator.) If you prefer, you could explicitly call baseWidget():return( rb->baseWidget() );LBL="" HELPID=""ID="50466"Adding a Window Interface to a Direct Instantiation of a ViewKit Window ClassThere are exceptional cases for which you may choose to directly instantiate a ID="Ch04_Windows60"ID="Ch04_Windows61"ID="Ch04_Windows62"ID="Ch04_Windows63"VkSimpleWindow or VkWindow object and use addView() to associate a view with the window. For example, if you have a complex, self-contained component and need a window simply to display the component, you might find this method acceptable. IDREF="43644" TYPE="TEXT"Example 4-4 shows a simple example of adding a component to a direct instantation of the VkSimpleWindow class.LBL="4-4"Example 4-4 ID="43644"Example of Adding a View to a Direct Instantiation of a ViewKit Window ClassVkSimpleWindow *roloWindow = VkSimpleWindow("roloWindow");
Rolodex *rolodex = Rolodex( "rolodex", roloWindow->mainWindowWidget() );
roloWindow->addView(rolodex);In most cases, you should not use this technique because most windows require data and support functions that should be encapsulated by the window class to follow proper object-oriented programming style.LBL="" HELPID=""Replacing a Window's ViewOccasionally, you might want to replace the view of an existing window. To do so, you must first remove the current view using the ID="Ch04_Windows64"ID="Ch04_Windows65"ID="Ch04_Windows66"ID="Ch04_Windows67"removeView() function:void removeView()You should not call this function unless you have previously added a view to this window. removeView() does not destroy the view; if you no longer need the view, you should destroy it.After removing a view, you can add another view using addView().LBL="" HELPID=""ID="12584"Manipulating WindowsThe ID="Ch04_Windows68"VkSimpleWindow and VkWindow classes provide simple functions to show, hide, raise, lower, iconify, and open windows. All of the following functions take no arguments and have a void return value:ID="Ch04_Windows69"ID="Ch04_Windows70"ID="Ch04_Windows71"show()Displays the window. show() has no effect if the window is currently iconified.ID="Ch04_Windows72"ID="Ch04_Windows73"ID="Ch04_Windows74"hide()Removes the window from the screen.ID="Ch04_Windows75"ID="Ch04_Windows76"ID="Ch04_Windows77"iconify()Iconifies the window.ID="Ch04_Windows78"ID="Ch04_Windows79"ID="Ch04_Windows80"open()Opens the window if it is iconified.ID="Ch04_Windows81"ID="Ch04_Windows82"ID="Ch04_Windows83"raise()Raises the window to the top of the application's window stack.ID="Ch04_Windows84"ID="Ch04_Windows85"ID="Ch04_Windows86"lower()Lowers the window to the bottom of the application's window stack.All of these functions are declared virtual. If you override them in a subclass, you should call the corresponding base class function after performing whatever operations your subclass requires.LBL="" HELPID=""ID="71268"Window Data Access FunctionsThe VkSimpleWindow and VkWindow classes support several data access functions:ID="Ch04_Windows87"ID="Ch04_Windows88"ID="Ch04_Windows89"ID="Ch04_Windows90"mainWindowWidget() returns the XmMainWindow widget created by the window constructor. Most frequently, you use mainWindowWidget() to obtain a parent widget for creating a view widget or component. You can also use this function to access and configure the window's XmMainWindow widget. For example, by default, the ViewKit window classes configure the window's XmMainWindow widget to not display scrollbars. You can use mainWindowWidget() to obtain the XmMainWindow widget and then use XtSetValues(3Xt) to enable the scrollbars.virtual Widget mainWindowWidget() constID="Ch04_Windows91"ID="Ch04_Windows92"ID="Ch04_Windows93"ID="Ch04_Windows94"ID="Ch04_Windows95"viewWidget() returns the widget currently installed as the window's view.virtual Widget viewWidget() constID="Ch04_Windows96"ID="Ch04_Windows97"visible() returns TRUE if the window is currently displayed and FALSE if it is hidden.Boolean visible() constID="Ch04_Windows98"ID="Ch04_Windows99"iconic() returns TRUE if the window is currently iconified and FALSE if it is not.Boolean iconic() constLBL="" HELPID=""ID="67202"Window Manager InterfaceThe ID="Ch04_Windows100"VkSimpleWindow and VkWindow classes set up various properties on the shell window and provide simple hooks for window manager interactions.LBL="" HELPID=""Window and Icon TitlesThe ID="Ch04_Windows101"VkSimpleWindow and VkWindow classes provide easy-to-use functions to set your application's window and icon titles.The ID="Ch04_Windows102"ID="Ch04_Windows103"setTitle() function sets the title of a window:void setTitle(const char *newTitle)The string is treated first as a resource name that setTitle() looks up relative to the window. If the resource exists, its value is used as the window title. If the resource does not exist, or if the string contains spaces or newline characters, setTitle() uses the string itself as the window title. This allows applications to dynamically change a window title without hard-coding the exact title names in the application code. IDREF="90399" TYPE="TEXT"Example 4-5 shows an example of setting a window title using a resource value.You can retrieve the current window title using ID="Ch04_Windows104"ID="Ch04_Windows105"getTitle():const char *getTitle()The ID="Ch04_Windows106"ID="Ch04_Windows107"ID="Ch04_Windows108"setIconName() function sets the title of a window's icon:void setIconName(const char *newTitle)The string is treated first as a resource name that setIconName() looks up relative to the window. If the resource exists, its value is used as the window's icon title. If the resource does not exist, or if the string contains spaces or newline characters, setIconName() uses the string itself as the icon title. This allows applications to dynamically change a window's icon title without hard-coding the exact title names in the application code. IDREF="90399" TYPE="TEXT"Example 4-5 shows an example of setting a window's icon title using a resource value.LBL="4-5"Example 4-5 ID="90399"Setting Window and Icon Titles Using Resource Valuesclass MainWindow : public VkSimpleWindow {

  public:
    MainWindow (const char *);
    // ...

  private:
    static String _defaultResources[];
    // ...
};


String _defaultResources[] = {
    "*winTitle:    Foobar Main Window",
    "*iconTitle:   Foobar",
    NULL
};

MainWindow::MainWindow(const char *name) : VkSimpleWindow(name)
{
    setDefaultResources(mainWindowWidget(), _defaultResources);

    setTitle("winTitle");
    setIconName("iconTitle");

    // ...
}LBL="" HELPID=""ID="73633"Window Properties and Shell ResourcesThe window class constructors automatically set up various window properties and shell resources when you create a window. The window classes also provide some hooks to allow you to set your own properties or change the window manager message handling in a derived class.ID="Ch04_Windows109"Because the first window you create is by default the main window, the window class constructors also set some shell resources on the popup shell widget of that window. The constructors obtain the geometry of the invisible application shell created by ID="Ch04_Windows110"ID="Ch04_Windows111"ID="Ch04_Windows112"VkApp and assign that geometry to the window's popup shell widget. The constructors also set the XmNargc and XmNargv resources on the popup shell to the values of ID="Ch04_Windows113"ID="Ch04_Windows114"VkApp::argc() and VkApp::argv() respectively. (IDREF="21821" TYPE="TITLE""Application Data Access Functions" describes VkApp::argc() and VkApp::argv().)For all windows, the window class constructors register a callback function to handle WM_DELETE_WINDOW messages from the window manager. This callback function calls ID="Ch04_Windows115"ID="Ch04_Windows116"ID="Ch04_Windows117"handleWmDeleteMessage():virtual void handleWmDeleteMessage()By default, handleWmDeleteMessage() calls the window's ID="Ch04_Windows118"ID="Ch04_Windows119"okToQuit() function. If okToQuit() returns TRUE, then handleWmDeleteMessage() deletes the window. You can override handleWmDeleteMessage() to change how your window handles a WM_DELETE_WINDOW message. In most cases, you should simply perform any additional actions that you desire and then call the base class's handleWmDeleteMessage() function.The window class constructors also register a callback function to handle WM_QUIT_APP messages from the window manager. This callback function calls ID="Ch04_Windows120"ID="Ch04_Windows121"ID="Ch04_Windows122"ID="Ch04_Windows123"handleWmQuitMessage():virtual void handleWmQuitMessage()By default, handleWmQuitMessage() calls the application's ID="Ch04_Windows124"quitYourself() function to quit the application. You can override handleWmQuitMessage() to change how your windows handles a WM_QUIT_APP message. In most cases, you should simply perform any additional actions that you desire and then call the base class's handleWmQuitMessage() function to exit your application.If you want to set any additional properties on a window, you can override ID="Ch04_Windows125"ID="Ch04_Windows126"setUpWindowProperties():virtual void setUpWindowProperties()setUpWindowProperties() is called after realizing a window's popup shell widget but before mapping it. Subclasses that wish to store other properties on windows can override this function and perform additional actions. If you override this function, you should set all desired properties and then call the base class's setUpWindowProperties() function.Note that you should use ID="Ch04_Windows127"ID="Ch04_Windows128"setUpWindowProperties() to set window properties instead of VkComponent::afterRealizeHook() as described in IDREF="46525" TYPE="TITLE""Displaying and Hiding Components". The difference between the two is that setUpWindowProperties() is guaranteed to be called before the window manager is notified of the window's existence. Because of race conditions, this might not be true of afterRealizeHook().You can also change the value of the window manager class hint stored on a window using ID="Ch04_Windows129"ID="Ch04_Windows130"ID="Ch04_Windows131"ID="Ch04_Windows132"setClassHint():void setClassHint(const char *className)setClassHint() sets the class resource element of the XA_WM_CLASS property stored on this window to the string you pass as an argument.ID="Ch04_Windows133"LBL="" HELPID=""ID="88773"Menu Bar SupportThe ID="Ch04_Windows134"ID="Ch04_Windows135"VkSimpleWindow class is useful for windows that require only a work area; however, windows frequently require menus. The VkWindow class extends the VkSimpleWindow class by providing support for a menu bar along the top of the window.In ViewKit, the VkMenuBar(3Vk) class provides support for menu bars. IDREF="84022" TYPE="TITLE"Chapter 5, "Creating Menus With ViewKit," describes in depth the process of creating and manipulating menus; IDREF="77318" TYPE="TITLE""Menu Bar" describes additional functions specific to the VkMenuBar class and provides an example of constructing a menu bar for an application. This section describes only those functions provided by VkWindow for installing and manipulating a menu bar.You install a menu bar using ID="Ch04_Windows136"setMenuBar():void setMenuBar(VkMenuBar *menuObj)
void setMenuBar(VkMenuDesc *menudesc)If you provide a pointer to an existing VkMenuBar object, setMenuBar() installs that menu bar. If you prove a VkMenuDesc static menu description, setMenuBar() creates a menu bar from that description and then installs the menu bar.Once you have installed a menu bar, ID="Ch04_Windows137"menu() will return a pointer to the menu bar object:virtual VkMenuBar *menu() constYou can add a menu pane to the menu bar using ID="Ch04_Windows138"addMenuPane():VkSubMenu *addMenuPane(const char *name)
VkSubMenu *addMenuPane(const char *name, VkMenuDesc *menudesc)addMenuPane() creates a VkSubMenu(3Vk) object and adds it to the window's menu bar. If you provide a VkMenuDesc static menu description, addMenuPane() uses it to create the menu pane. Additionally, addMenuPane() automatically creates and installs a menu bar if the window does not currently have one.You can add a menu pane that enforces radio behavior on the toggle items it contains using addRadioMenuPane():VkRadioSubMenu *addRadioMenuPane(const char *name)
VkRadioSubMenu *addRadioMenuPane(const char *name,
                                 VkMenuDesc *menudesc)ID="Ch04_Windows139"addRadioMenuPane() creates a VkRadioSubMenu(3Vk) object and adds it to the window's menu bar. If you provide a VkMenuDesc static menu description, addRadioMenuPane() uses it to create the menu pane. Additionally, addRadioMenuPane() automatically creates and installs a menu bar if the window does not currently have one.LBL="" HELPID=""ID="11089"Deriving Window SubclassesThis section summarizes how to create subclasses from the ViewKit window classes. It describes additional virtual functions and data members not covered in previous sections, provides a window creation checklist, and shows an example of deriving a window subclass.ID="Ch04_Windows140"LBL="" HELPID=""Additional Virtual Functions and Data MembersIn addition to those functions described in previous sections, the ViewKit window classes provide a number of virtual functions and data members that you can access from window subclasses. These functions and data allow you to:provide a "safe quit" mechanism for your windowdetermine your window's state and perform actions on state changesperform actions after realizing a windowhandle raw events not normally handled by the Xt dispatch mechanismLBL="" HELPID=""ID="33838"Providing a "Safe Quit" MechanismThe ID="Ch04_Windows141"ID="Ch04_Windows142"ID="Ch04_Windows143"VkComponent class provides the virtual function okToQuit() to support "safe quit" mechanisms:virtual Boolean okToQuit()A component's okToQuit() function returns TRUE if it is "safe" for the application to quit. For example, you might want okToQuit() to return FALSE if a component is in the process of updating a file. By default, okToQuit() always returns TRUE; you must override okToQuit() for all components that you want to perform a check before quitting. Usually, only VkSimpleWindow and its subclasses use okToQuit().When you call VkApp::quitYourself(), VkApp calls the okToQuit() function for all registered windows before quitting. If the okToQuit() function for any window returns FALSE, the application does not exit. (IDREF="52836" TYPE="TITLE""Quitting ViewKit Applications" describes VkApp::quitYourself().)Also, the window's handleWmDeleteMessage() function calls okToQuit() when the window receives a WM_DELETE_WINDOW message from the window manager. This determines whether it is safe to delete the window. (IDREF="73633" TYPE="TITLE""Window Properties and Shell Resources" describes handleWmDeleteMessage().)If you want to perform a test to see whether it is safe to delete a window, override the window's okToQuit() function. If you want to check one or more components contained within a window, you can override the window's okToQuit() function so that it calls the okToQuit() functions for all the desired components. You can then override the okToQuit() functions for the other components so you can perform whatever checks or shutdown actions are necessary. For example, you could post a blocking dialog asking whether the user wants to save data before quitting. (IDREF="57775" TYPE="TITLE"Chapter 7, "Using Dialogs in ViewKit," describes how to use ViewKit dialogs.LBL="" HELPID=""Determining Window StatesThe ViewKit window classes provide the following protected data members for determining the current states of a window:IconState ID="Ch04_Windows144"ID="Ch04_Windows145"_iconStateContains an enumerated constant of type IconState that describes the current iconification state of the window. This variable contains OPEN if the window is not iconified, CLOSED if it is iconified, and ICON_UNKNOWN if it is in an unknown state. (Typically, the unknown state is used only internally to the VkSimpleWindow class.)VisibleState ID="Ch04_Windows146"ID="Ch04_Windows147"_visibleStateContains an enumerated constant of type VisibleState that describes the current visibility state of the window. This variable contains VISIBLE if the window is visible, HIDDEN if it is not visible, and VISIBLE_UNKNOWN if it is in an unknown state. (Typically, the unknown state occurs only before you add a view to your window.)StackingState ID="Ch04_Windows148"ID="Ch04_Windows149"_stackingStateContains an enumerated constant of type StackingState that describes the current stacking state of the window relative to the application. This variable contains RAISED if the window is at the top of the application's window stack, LOWERED if it is at the bottom of the window stack, and STACKING_UNKNOWN if it is in an unknown state (the state before you make any calls to raise() or lower() on this window).If you need to perform any operations when your window changes its iconification state, you can override ID="Ch04_Windows150"ID="Ch04_Windows151"stateChanged():virtual void stateChanged(IconState newState)stateChanged() is called whenever the window's iconification state changes, whether programmatically (by calls to iconify() and open()) or through window manager interaction. Because this function is responsible for maintaining the window's state information, if you override this function in a subclass you should call the base class's stateChanged() function before performing any additional operations.LBL="" HELPID=""Performing Actions After Realizing a WindowIf you want to perform certain actions only after a window exists, you can override the ID="Ch04_Windows152"ID="Ch04_Windows153"afterRealizeHook() function inherited from VkComponent:virtual void afterRealizeHook()Note that you should use setUpWindowProperties() to set window properties instead of afterRealizeHook(). The difference between afterRealizeHook() and setUpWindowProperties() is that setUpWindowProperties() is guaranteed to be called before the window manager is notified of the window's existence. Because of race conditions, this might not be true of afterRealizeHook(). afterRealizeHook() is appropriate for performing actions that do not affect the window's interaction with the window manager.LBL="" HELPID=""Handling Raw EventsYou can handle events not normally handled by the Xt dispatch mechanism by overriding the window's ID="Ch04_Windows154"ID="Ch04_Windows155"ID="Ch04_Windows156"handleRawEvent() function:virtual void handleRawEvent(XEvent *event)As described in IDREF="59065" TYPE="TITLE""ViewKit Event Handling", VkApp::run() supports events not normally handled by the Xt dispatch mechanism. For example, VkApp::run() can handle client messages and events registered for non-widgets (such as a PropertyNotify event on the root window).When run() receives an event not handled by the Xt dispatch mechanism, it calls the virtual function VkApp::handleRawEvent(), which passes the event to the handleRawEvent() function of each instance of VkSimpleWindow (or subclass) in the application. By default, these member functions are empty.If you want a window to handle events through this mechanism, call ID="Ch04_Windows157"XSelectInput(3X) to select the events that you want to receive, and override handleRawEvent() in the VkSimpleWindow subclass to implement your event processing.LBL="" HELPID=""Additional Data MembersThe ViewKit window classes also provide the protected data member ID="Ch04_Windows158"ID="Ch04_Windows159"_mainWindowWidget:Widget _mainWindowWidget_mainWindowWidget contains the XmMainWindow widget created by the window constructor. In a subclass, you can use this data member instead of calling mainWindowWidget(), although this is not recommended.LBL="" HELPID=""Window Creation SummaryThe following is a summary of guidelines for creating subclasses of the ViewKit window classes:ID="Ch04_Windows160"Decide whether this window requires a menu bar. If it does, derive your subclass from VkWindow; otherwise, derive it from VkSimpleWindow.In most cases where you provide a menu bar for your window, you should create it in the window class when you create the rest of your window's interface.Determine whether users will often use your application without displaying this window even after the object is instantiated. If so, and the window interface is large or complex, you might consider creating the window interface using setUpInterface() to reduce the time it takes to start your application; otherwise, create the interface in the window's constructor.Implement the window interface as a single-rooted widget subtree whose parent is the window's XmMainWindow widget (obtained by the mainWindowWidget() function). While some windows might contain only a single complex component, the majority of windows must create some type of container widget as the root of the window's interface; all other widgets and components are descendents of this widget.Do not assign any widget to the _baseWidget data member. The ViewKit window classes assign the window's popup shell widget to _baseWidget.Wherever appropriate, use resource values to set labels, other interface characteristics, and user-configurable component behavior. Define a default resource list as a static member variable of your window class, and call setDefaultResources() to set your window's default resources before creating the window interface.Override the className() function to return the name of your window's class.In addition to the widgets and components composing the window's interface, encapsulate any other required data and support functions as members of your window class.If you explicitly allocate any memory in your derived window class, remember to free it in the window's destructor.To explicitly set your window's title or its icon's title, call setTitle() or setIconName() respectively. You can also set these characteristics using the normal resource mechanisms.To provide a "safe quit" mechanism for your window, override okToQuit() to perform any checking you want to perform before deleting the window.To change how your window handles a WM_DELETE_MESSAGE from the window manager, override handleWmDeleteMessage().To change how your window handles a WM_QUIT_APP from the window manager, override handleWmQuitMessage().To set any additional properties on your window, override setUpWindowProperties().To change the value of the window manager class hint stored on a window, call setClassHint().To perform certain actions only after the window exists, override afterRealizeHook().To handle events not normally handled by the Xt dispatch mechanism, call XSelectInput(3X) to select the events that you want to receive, and override handleRawEvent() in your window subclass to implement your event processing.LBL="" HELPID=""ID="92272"Window Subclassing ExampleThe program in ID="Ch04_Windows161"IDREF="54310" TYPE="TEXT"Example 4-6 creates ColorWindow, a VkSimpleWindow subclass that implements a simple utility for determining the results of mixing primary ink colors when printing. The user can use toggles to select any of the three primary colorsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'cyan, magenta, and yellowname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'and the window reports the resulting color.IDREF="54555" TYPE="GRAPHIC"Figure 4-5 shows the widget hierarchy of the ColorWindow subclass. The VkSimpleWindow constructor creates the window's popup shell and XmMainWindow widget. The ColorWindow constructor creates a Form widget to serve as the window's view. The constructor adds a VkCheckBox component as a child of the Form to provide the toggle buttons. The constructor then adds a Frame widget as a child of the Form widget, and creates two Label gadgets as children of the Frame: one to serve as a title, and one to report the resulting color. The constructor manages all of these widgets except for the top-level Form widget. (The constructor manages the VkCheckBox component by calling its show() member function.)FILE="Fig4-5.ai" POSITION="INLINE" SCALE="FALSE"LBL="4-5"Figure 4-5 ID="54555"Widget Hierarchy of ColorWindow SubclassThis example illustrates a number of object-oriented techniques that you should follow when programming in ViewKit. Note that all data and utility functions used by the window are declared as members of the ColorWindow class. Also note that ColorWindow uses resources to set all the text that it displays. It includes a set of default values, but you can override these values in a resource file (for example, to provide German-language equivalents for all the strings).LBL="4-6"Example 4-6 ID="54310"Example of Creating a Window Subclass///////////////////////////
// ColorWindow.h
///////////////////////////

#include <Vk/VkSimpleWindow.h>
#include <Vk/VkCheckBox.h>

class ColorWindow: public VkSimpleWindow {

  public:
    ColorWindow (const char *);
    ~ColorWindow();
    virtual const char* className();
  private:
    void displayColor(char *);
    void colorChanged(VkCallbackObject *, void *, void *);

    static String _defaultResources[]; // Default resource values
    static String _colors[];           // Array of possible resulting colors
    Widget _resultColor;               // Label to display resulting color
    VkCheckBox *_primaries;            // Checkbox for setting colors
    int _colorStatus;                  // Bit-wise color status variable
                                       //     Bit 0: Cyan
                                       //     Bit 1: Magenta
                                       //     Bit 2: Yellow
                                       //   Also used as index into _colors[]
};


///////////////////////////
// ColorWindow.c++
///////////////////////////

#include "ColorWindow.h"
#include <Xm/RowColumn.h>
#include <Xm/Form.h>
#include <Xm/Frame.h>
#include <Xm/LabelG.h>
#include <Vk/VkCheckBox.h>
#include <Vk/VkResource.h>

// Default ColorWindow class resource values.

String ColorWindow::_defaultResources[] = {
    "*windowTitle:                  Color Mixer",
    "*iconTitle:                    Color Mixer",
    "*primaries*label*labelString:  Primary Colors",
    "*cyan.labelString:             Cyan",
    "*magenta.labelString:          Magenta",
    "*yellow.labelString:           Yellow",
    "*resultLabel.labelString:      Resulting Color",
    "*cyan:                         Cyan",
    "*magenta:                      Magenta",
    "*yellow:                       Yellow",
    "*blue:                         Blue",
    "*red:                          Red",
    "*green:                        Green",
    "*white:                        White",
    "*black:                        Black",
    NULL };

// Set _colors array to correspond to color values indicated by the
// bits in the _colorStatus variable.

String ColorWindow::_colors[] = {
    "white",
    "cyan",
    "magenta",
    "blue",
    "yellow",
    "green",
    "red",
    "black" };

ColorWindow::ColorWindow (const char *name) : VkSimpleWindow (name)
{
    Arg args[5];
    int n;

    // Set default resources for the window.

    setDefaultResources(mainWindowWidget(), _defaultResources);
    
    // Create a Form widget to use as the window's view.

    Widget _form = XmCreateForm(mainWindowWidget(), "form", NULL, 0);

    
    // Create a VkCheckBox object to allow users to select primary colors.
    // Add toggle buttons and set their intial values to FALSE (unselected).
    // The labels for the checkbox frame and the toggle buttons are set
    // by the resouce database.
    
    _primaries = new VkCheckBox( "primaries", _form );
    _primaries->addItem("cyan", FALSE);
    _primaries->addItem("magenta", FALSE);
    _primaries->addItem("yellow", FALSE);
    _primaries->addCallback(VkCheckBox::itemChangedCallback, this,
                            (VkCallbackMethod) &ColorWindow::colorChanged);
    _primaries->show();
    
    // Set constraint resources on checkbox's base widget.
    
    n = 0;
    XtSetArg(args[n], XmNtopAttachment, XmATTACH_FORM); n++;
    XtSetArg(args[n], XmNbottomAttachment, XmATTACH_FORM); n++;
    XtSetArg(args[n], XmNleftAttachment, XmATTACH_FORM); n++;
    XtSetValues(_primaries->baseWidget(), args, n);

    // Create a frame to display the name of the resulting blended color.

    n = 0;
    XtSetArg(args[n], XmNtopAttachment, XmATTACH_FORM); n++;
    XtSetArg(args[n], XmNbottomAttachment, XmATTACH_FORM); n++;
    XtSetArg(args[n], XmNrightAttachment, XmATTACH_FORM); n++;
    XtSetArg(args[n], XmNleftAttachment, XmATTACH_WIDGET); n++;
    XtSetArg(args[n], XmNleftWidget, _primaries->baseWidget()); n++;
    Widget _result = XmCreateFrame(_form, "result", args, n);
    XtManageChild(_result);
    
    // Create a frame title label.  The label text is set by the resource
    // database.
    
    n = 0;
    XtSetArg(args[n], XmNchildType, XmFRAME_TITLE_CHILD); n++;
    Widget _resultLabel = XmCreateLabelGadget( _result, "resultLabel", args, n);
    
    // Create the label to display the blended color name.
    
    _resultColor = XmCreateLabelGadget( _result, "resultColor", NULL, 0);
    
    // Set intial value of _colorStatus and label string to white (all off).
    
    _colorStatus = 0;
    displayColor(_colors[_colorStatus]);
    
    XtManageChild(_resultLabel);
    XtManageChild(_resultColor);

    // Add the top-level Form widget as the window's view.

    addView(_form);
    
    // Set the window title and the icon title.
    
    setTitle("windowTitle");
    setIconName("iconTitle");
}

ColorWindow::~ColorWindow()
{
    // Empty
}

const char* ColorWindow::className()
{
    return "ColorWindow";
}

// Given a color name, update the label to display the color

void ColorWindow::displayColor(char *newColor)
{
    Arg args[2];
    int n;

    // Common resource trick in ViewKit applications.
    // Given a string, check the resource database for a corresponding
    // value.  If none exists, use the string as the value.

    char *_colorName = (char *) VkGetResource(_baseWidget, newColor, "Color",
                                              XmRString, newColor);

    // Update the label

    XmString _label = XmStringCreateSimple(_colorName);
    n = 0;
    XtSetArg(args[n], XmNlabelString, _label); n++;
    XtSetValues(_resultColor, args, n);
    XmStringFree(_label);
}

// When the user changes the value of one of the toggles, update the
// display to show the new blended color.

void ColorWindow::colorChanged(VkCallbackObject *obj, void *, void *callData)
{
    ColorWindow *win = (ColorWindow *) obj;
    int index = (int) callData;
    
    // Update color status based on toggle value.  Set or rest the
    // status bit corresponding to the respective toggle.

    if (_primaries->getValue(index))
        _colorStatus |= 1<<index;
    else
        _colorStatus &= ~(1<<index);

    // Update the display to show the new blended color, using
    // _colorStatus as an index.

    displayColor(_colors[_colorStatus]);
}


///////////////////////////
// colors.c++
///////////////////////////

#include <Vk/VkApp.h>
#include "ColorWindow.h"

void main ( int argc, char **argv )
{
    VkApp *colorApp = new VkApp("ColorApp", &argc, argv);
    ColorWindow *colorWin = new ColorWindow("colorWin");

    colorWin->show();
    colorApp->run();
}IDREF="98239" TYPE="GRAPHIC"Figure 4-6 shows the ColorWindow window displayed by the colors program.FILE="ColorWindow1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="4-6"Figure 4-6 ID="98239"Example of the ColorWindow Window SubclassLBL="5"ID="84022"Creating Menus With ViewKitThis chapter introduces the basic ViewKit classes needed to create and manipulate the menus in a ViewKit application. ID="Ch05_Menus1"IDREF="30981" TYPE="GRAPHIC"Figure 5-1 shows the inheritance graph for these classes.FILE="Fig5-1.ai" POSITION="INLINE" SCALE="FALSE"LBL="5-1"Figure 5-1 ID="30981"The Inheritance Graph for the ViewKit Menu ClassesID="Ch05_Menus2"ID="Ch05_Menus3"ID="Ch05_Menus4"ID="Ch05_Menus5"LBL="" HELPID=""Overview of ViewKit Menu SupportIRIS IM provides the components for building menus (buttons, menu shells, and so on) but does little to make menu construction easy. ViewKit provides a set of classes that facilitate common operations on menus, including creating menu bars, menu panes, popup menus, option menus, and cascading menu panes. The ViewKit menu package also provides an object-oriented interface for activating and deactivating menu items, dynamically adding, removing, or replacing menus items or menu panes, and performing other operations.ID="Ch05_Menus6"The basis for all ViewKit menu classes is the abstract class ID="Ch05_Menus7"VkMenuItem, which is derived from VkComponent. There are two types of classes derived from VkMenuItem. The first serve as containers and correspond to the menu types supported by IRIS IM: popup menus, pulldown menu panes, menu bars, and option menus. The second type of derived classes are individual menu items: actions, toggles, labels, and separators.The classes derived from ID="Ch05_Menus8"VkMenuItem correspond closely with IRIS IM widgets and gadgets. For example, an action implemented as a VkMenuAction object represents a XmPushButton gadget along with an associated callback. However, the ViewKit menus offer several advantages over directly using IRIS IM widgets and gadgets. You can manipulate the menu objects more easily than widgets. You can display, activate, and deactivate items with a single function call. You can also easily move or replace items.CautionViewKit implements menu items as gadgets rather than widgets. This causes a problem in callbacks and other situations if you try to use certain Xt functions (such as ID="Ch05_Menus9"ID="Ch05_Menus10"ID="Ch05_Menus11"ID="Ch05_Menus12"ID="Ch05_Menus13"ID="Ch05_Menus14"XtDisplay(3Xt), XtScreen(3Xt), and XtWindow(3Xt)) that expect widgets as arguments. Therefore, you should use the more general functions (such as XtDisplayofObject(3Xt), XtScreenofObject(3Xt), and XtWindowofObject(3Xt)) when you need to obtain this information for ViewKit menu items.ID="Ch05_Menus15"VkMenu, derived from VkMenuItem, is the abstract base class that implements the functionality needed to create and manipulate menus. It provides support for creating menus and adding, removing, replacing, finding, activating, and deactivating menu items.Separate subclasses of VkMenu implement the various types of menus supported by ViewKit:VkMenuBarMenu bars designed to work with the VkWindow classVkPopupMenuPopup menus that automatically pop up when the user clicks the right mouse button over a widgetVkOptionMenuOption menusVkSubMenuPulldown menus panes that can be used either as pull-down panes in a menu bar or pull-right panes in a popup or other pull-down menuVkRadioSubMenuA subclass of VkSubMenu used to enforce radio behavior on toggle items that it containsIndividual menu items are implemented as subclasses derived from VkMenuItem:VkMenuActionA selectable menu item that performs an action, implemented as a PushButtonGadgetVkMenuConfirmFirstActionA selectable menu item that performs an action that the user must confirm before it is executed. When the user selects this type of menu item, the application posts a question dialog asking the user for confirmation. The application performs the action only if the user confirms it.VkMenuToggleA two-state toggle button gadget. To enforce radio behavior on a group of toggles, you must add them to a VkRadioSubMenu object.VkMenuLabelA non-selectable labelVkMenuSeparatorA non-selectable separatorLBL="" HELPID=""The ViewKit Menu Item ClassesThis section describes the features of the ViewKit menu item classes. First it describes the features implemented by ID="Ch05_Menus16"ID="Ch05_Menus17"VkMenuItem, which are common to all the menu item classes. Then it describes the unique features of each individual menu item class.Submenus are described in IDREF="68387" TYPE="TITLE""Submenus" and IDREF="39602" TYPE="TITLE""Radio Submenus".NoteThe header file <Vk/VkMenuItem.h> contains the declarations for all menu item classes. LBL="" HELPID=""Common Features of Menu ItemsIndividual menu items are implemented as subclasses derived from ID="Ch05_Menus18"ID="Ch05_Menus19"VkMenuItem, which provides a standard set of functions for accessing and manipulating menu items.Unlike many other ViewKit classes, you should never need to directly instantiate a menu item class. ViewKit automatically instantiates menu item objects as needed when you create menus, as described in IDREF="25639" TYPE="TITLE""Constructing Menus". Therefore, this guide does not describe the menu item constructors and destructors.You should keep in mind that ViewKit implements menu items as gadgets rather than widgets. If you need to directly access menu item gadgets, remember to use Xt functions that accept gadgets as well as widgets as arguments.LBL="" HELPID=""ID="33903"Displaying and Hiding Menu ItemsThe ID="Ch05_Menus20"ID="Ch05_Menus21"ID="Ch05_Menus22"VkMenuItem::show() function makes a menu item visible when you display the menu to which it belongs:void show()By default, all menu items are visible when they are created (that is, they appear when you display the menu to which they belong). You do not have to explicitly call a menu item's show() function to display it. You can call show() to display a menu item after you have hidden it with hide().The ID="Ch05_Menus23"ID="Ch05_Menus24"ID="Ch05_Menus25"VkMenuItem::hide() function makes a menu item invisible when you display the menu to which it belongs:void hide()hide() does not remove the menu item from the menu, it simply unmanages the widget or gadget associated with a menu item. You can display a hidden menu item by calling its show() function.If you want to remove a menu item from a menu, you can call ID="Ch05_Menus26"ID="Ch05_Menus27"ID="Ch05_Menus28"VkMenuItem::remove():void remove()remove() does not destroy a menu item, it simply removes the item from the menu hierarchy.Note that instead of retaining pointers to all of your menu items and using VkMenuItem::remove() to remove menu items, you can instead use VkMenu::removeItem(). The effect is the same no matter which function you use, though typically you will find it easier to use the VkMenu function. IDREF="88889" TYPE="TITLE""Removing Items from a Menu" describes VkMenu::removeItem().LBL="" HELPID=""ID="53932"Activating and Deactivating Menu ItemsThe ID="Ch05_Menus29"ID="Ch05_Menus30"ID="Ch05_Menus31"VkMenuItem::activate() function makes a menu item sensitive so that it accepts user input (that is, a user can select the item):void activate()By default, all menu items are activated (sensitive) when they are created.The ID="Ch05_Menus32"ID="Ch05_Menus33"ID="Ch05_Menus34"VkMenuItem::deactivate() function makes a menu item insensitive so that it does not accept user input (that is, a user cannot select the item):void deactivate()When insensitive, the menu item appears "grayed out" when you display the menu to which it belongs. You can re-activate a menu item by calling its activate() function.Note that instead of retaining pointers to all of your menu items and using VkMenuItem::activate() and VkMenuItem::deactivate() to activate and deactivate menu items, you can instead use VkMenu::activateItem() and VkMenu::deactivateItem() respectively. The effect is the same no matter which functions you use, though typically you will find it easier to use the VkMenu functions. IDREF="13124" TYPE="TITLE""Activating and Deactivating Items in a Menu" describes VkMenuItem::activate() and VkMenuItem::deactivate().LBL="" HELPID=""ID="20461"Setting Menu Item LabelsGenerally, you should set the label for a menu item by setting a value in the resource database for that item's XmNlabelString resource. For example, if you have a menu item named "addPage", you could set the label for that item by including a resource specification such as:ID="Ch05_Menus35"ID="Ch05_Menus36"ID="Ch05_Menus37"ID="Ch05_Menus38"*addPage.labelString:    Add PageIf you do not set the menu item's XmNlabelString resource, ViewKit uses the item's name.In some case, you might need to set the label of an item programmatically. For example, in a page layout system you might want to change the labels for the items in an Edit menu to reflect the type of object the user has currently selected. You can change a menu item's label programmatically with the ID="Ch05_Menus39"setLabel() function:virtual void setLabel(const char * str)The string is treated first as a resource name that setLabel() looks up relative to the menu item's widget. If the resource exists, its value is used as the item's label. If the resource does not exist, or if the string contains spaces or newline characters, setLabel() uses the string itself as the item's label. This allows applications to dynamically set and change menu item labels without hard-coding the exact label strings in the application code.LBL="" HELPID=""Setting the Position of Menu ItemsBy default, ViewKit inserts items into a menu in the order you specify them. Therefore, the easiest way to set the positions of menu items is to add them to the menu in the order that you want them to appear.ID="Ch05_Menus40"ID="Ch05_Menus41"Occasionally you might need to explicitly set the position of a menu item. To do so, use ID="Ch05_Menus42"VkMenuItem::setPosition():void setPosition(int position)setPosition() sets the item's position in the menu. You can specify any integer value from zero to the number of items in the menu; a value of zero specifies the first position in the menu. setPosition() ignores invalid values.NotesetPosition() is effective only before ViewKit realizes the menu to which the menu item belongs. If you call setPosition() after realizing a menu, it has no effect. For example, if you create a menu bar in a window's constructor, you can safely use setPosition() to position menu items; however, after calling the window's show() function, setPosition() has no effect. LBL="" HELPID=""Menu Items Utility FunctionsYou can use ID="Ch05_Menus43"ID="Ch05_Menus44"MenuItem::menuType() to determine the specific menu item type when given a pointer to a VkMenuItem object:virtual VkMenuItemType menuType()menuType() returns one of the following enumerated values of type VkMenuItem::VkMenuItemType:ID="Ch05_Menus45"ACTIONA VkMenuAction objectCONFIRMFIRSTACTIONA VkMenuConfirmFirstAction objectTOGGLEA VkMenuToggle objectLABELA VkMenuLabel objectSEPARATORA VkMenuSeparator objectSUBMENUA VkSubMenu objectRADIOSUBMENUA VkRadioSubMenu objectBARA VkMenuBar objectOPTIONA VkOptionMenu objectPOPUPA VkPopupMenu objectOBJECTA user-defined subclass of VkMenuActionObject (described in IDREF="77326" TYPE="TITLE""Command Classes")You can also determine when an object pointed to by a ID="Ch05_Menus46"VkMenuItem pointer is a menu by calling MenuItem::isContainer():virtual Boolean isContainer()isContainer() returns TRUE if the VkMenuItem object is an item that can "contain" other menu items (in other words, a menu).LBL="" HELPID=""ID="48833"Menu ActionsThe ID="Ch05_Menus47"ID="Ch05_Menus48"ID="Ch05_Menus49"ID="Ch05_Menus50"VkMenuAction class provides a selectable menu item that performs an action. A VkMenuAction object is implemented as a PushButtonGadget.A VkMenuAction object has associated with it a callback function that performs an operation and, optionally, a callback function that "undoes" the operation. You specify these callback functions when you add the item to a menu using one of the methods described in IDREF="25639" TYPE="TITLE""Constructing Menus". Consult that section for information on using VkMenuAction objects in a menu.VkMenuAction provides a couple of public functions in addition to those implemented by VkMenuItem.You can determine whether an action has an undo callback associated with it by calling ID="Ch05_Menus51"VkMenuAction::hasUndo():Boolean hasUndo()hasUndo() returns TRUE if the object has an associated undo callback function.If an object has an undo callback function, you can call it programmatically using ID="Ch05_Menus52"ID="Ch05_Menus53"VkMenuAction::undo():virtual void undo()Typically, you won't have any need to call undo() explicitly. ViewKit provides automatic undo handling for your application using the VkUndoManager class, as described in IDREF="56221" TYPE="TITLE"Chapter 6, "ViewKit Undo Management and Command Classes." All you have to do is provide undo callback functions for your VkMenuAction objects and create an instance of VkUndoManager as described in IDREF="56221" TYPE="TITLE"Chapter 6.LBL="" HELPID=""Confirmable Menu ActionsThe ID="Ch05_Menus54"ID="Ch05_Menus55"ID="Ch05_Menus56"ID="Ch05_Menus57"VkMenuConfirmFirstAction class, which is derived from VkMenuAction, provides a selectable menu item that performs an action. When the user selects this type of menu item, the application posts a question dialog asking the user for confirmation. The application performs the action only if the user confirms it.Because the VkMenuConfirmFirstAction class is intended for irrecoverable actions (for example, deleting a file), VkMenuConfirmFirstAction objects do not support undo callback functions.The VkMenuConfirmFirstAction class uses a PushButtonGadget to implement the menu choice and the VkQuestionDialog(3Vk) to implement the question dialog. (See ID="Ch05_Menus58"IDREF="54735" TYPE="TITLE""The Question Dialog" for more information on the VkQuestionDialog class.)The question displayed in the confirmation dialog is determined by the value of the resource "noUndoQuestion", which ViewKit looks up relative to the menu item's widget. For example, if you have a menu item named "quit", you could set the question text for that item by including a resource specification such as:ID="Ch05_Menus59"*quit.noUndoQuestion:    Do you really want to quit?If you do not provide a value for this resource, ViewKit uses the default question: "This action cannot be undone. Do you want to proceed anyway?"LBL="" HELPID=""Menu TogglesThe ID="Ch05_Menus60"ID="Ch05_Menus61"ID="Ch05_Menus62"ID="Ch05_Menus63"VkMenuToggle class, which is derived from VkMenuAction, provides a two-state toggle as a menu item. To enforce radio behavior on a group of toggles, you must add them to a VkRadioSubMenu object; otherwise, VkMenuToggle object exhibit simple checkbox-style behavior. A VkMenuToggle object is implemented as a ToggleButtonGadget.In addition to the public functions provided by VkMenuItem, VkMenuToggle provides functions for setting and retrieving the toggle state.You can set the visual state of a ID="Ch05_Menus64"VkMenuToggle object, without activating its associated callback, using VkMenuToggle::setVisualState():void setVisualState(Boolean state)setVisualState() selects the toggle if state is TRUE and deselects the toggle if state is FALSE.You can set the visual state of a ID="Ch05_Menus65"VkMenuToggle object and activate its associated callback with VkMenuToggle::setStateAndNotify():void setStateAndNotify(Boolean state)Call ID="Ch05_Menus66"VkMenuToggle::getState() to retrieve the current value of a VkMenuToggle object:Boolean getState()getState() returns TRUE if the toggle is currently selected and FALSE if it is currently deselected.LBL="" HELPID=""Menu LabelsThe ID="Ch05_Menus67"ID="Ch05_Menus68"ID="Ch05_Menus69"ID="Ch05_Menus70"VkMenuLabel class provides a non-selectable label as a menu item. A VkMenuLabel object is implemented as a LabelGadget.The VkMenuLabel class does not provide any public functions other than those implemented by VkMenuItem.LBL="" HELPID=""Menu SeparatorsThe ID="Ch05_Menus71"ID="Ch05_Menus72"ID="Ch05_Menus73"ID="Ch05_Menus74"VkMenuSeparator class provides a non-selectable separator as a menu item. A VkMenuSeparator object is implemented as a SeparatorGadget.The VkMenuSeparator class does not provide any public functions other than those implemented by VkMenuItem.LBL="" HELPID=""ID="42452"The ViewKit Menu Base ClassThis section describes the abstract ID="Ch05_Menus75"ID="Ch05_Menus76"ID="Ch05_Menus77"VkMenu class, which provides the basic features of the ViewKit menu classes. It describes how to construct menus, manipulate items contained in the menus, and use the menu access functions. Because all ViewKit menu classes are derived from VkMenu, the functions and techniques described in this section apply to all menu classes.LBL="" HELPID=""ID="25639"Constructing MenusThe methods of constructing menus are the same for all types of menus (menu bars, options menus, etc.). The examples in this section use the VkMenuBar class, but the principles are similar for any of the ViewKit menu classes.You can build menus either by passing a static menu description to the class constructor for a menu, or by adding items dynamically through function calls. You can mix the two approaches, initially defining a static menu structure and then dynamically adding items as needed.LBL="" HELPID=""ID="88579"Constructing Menus from a Static DescriptionTo construct a menu from a static description, you must create a VkMenuDesc array that describes the contents of the menu and then pass that array as an argument to an appropriate menu constructor. This section describes the format of the VkMenuDesc structure and provides examples of its use.ID="Ch05_Menus78"LBL="" HELPID=""The VkMenuDesc StructureThe definition for the VkMenuDesc structure is:ID="Ch05_Menus79"ID="Ch05_Menus80"ID="Ch05_Menus81"struct VkMenuDesc {
    VkMenuItemType   menuType;
    char            *name;
    XtCallbackProc   callback;
    VkMenuDesc      *submenu;
    XtPointer        clientData;
    XtCallbackProc   undoCallback;
};The purposes of the VkMenuDesc fields are:menuTypeThe type of menu item. The value of this field must be one of the enumerated constants listed below.nameThe menu item's name, which is also used as the menu item's default label.callbackAn Xt-style callback procedure that is executed when this menu item is activated.submenuA pointer to an array of a VkMenuDesc structures that describes the contents of a submenu.clientDataData that is passed to the callback procedure when it is executed.undoCallbackA callback procedure that can be executed to undo the effects of the actions of the activation callback. Implementation of support for undoing actions is described in ID="Ch05_Menus82"IDREF="56221" TYPE="TITLE"Chapter 6, "ViewKit Undo Management and Command Classes."The menu type parameter is an enumerated value of type VkMenuItemType. Possible values are:ID="Ch05_Menus83"ACTIONA selectable menu item, implemented as a VkMenuAction objectCONFIRMFIRSTACTIONA selectable menu item, implemented as a VkMenuConfirmFirstAction object, which performs an action that the user must confirm before it is executedTOGGLEA two-state toggle button gadget, implemented as a VkMenuToggle objectLABELA label, implemented as a VkMenuLabel objectSEPARATORA separator, implemented as a VkMenuSeparator objectSUBMENUA cascading submenu, implemented as a VkSubMenu objectRADIOSUBMENUA cascading submenu that acts as a radio-style pane, implemented as a VkRadioSubMenu objectENDAll menu descriptions must be terminated by this constant.Not all fields are used for each menu item type. IDREF="92767" TYPE="TABLE"Table 5-1 summarizes the optional and required fields for each menu item type.COLUMNS="6"LBL="5-1"Table 5-1 ID="92767"Required and Optional Parameters in a Static Menu DescriptionLEFT="0" WIDTH="117"menuTypeLEFT="125" WIDTH="54"nameLEFT="185" WIDTH="54"callbackLEFT="245" WIDTH="54"submenuLEFT="305" WIDTH="54"clientDataIDREF="Ch05_MenusTF0a"aLEFT="365" WIDTH="63"undoCallbackLEFT="0" WIDTH="117"ACTIONLEFT="125" WIDTH="54"RLEFT="185" WIDTH="54"OIDREF="Ch05_MenusTF0b"bLEFT="245" WIDTH="54"ILEFT="305" WIDTH="54"OLEFT="365" WIDTH="63"OLEFT="0" WIDTH="117"CONFIRMFIRSTACTIONLEFT="125" WIDTH="54"RLEFT="185" WIDTH="54"ObLEFT="245" WIDTH="54"ILEFT="305" WIDTH="54"OLEFT="365" WIDTH="63"ILEFT="0" WIDTH="117"TOGGLELEFT="125" WIDTH="54"RLEFT="185" WIDTH="54"ObLEFT="245" WIDTH="54"ILEFT="305" WIDTH="54"OLEFT="365" WIDTH="63"ILEFT="0" WIDTH="117"LABELLEFT="125" WIDTH="54"RLEFT="185" WIDTH="54"ILEFT="245" WIDTH="54"ILEFT="305" WIDTH="54"ILEFT="365" WIDTH="63"ILEFT="0" WIDTH="117"SEPARATORLEFT="125" WIDTH="54"ILEFT="185" WIDTH="54"ILEFT="245" WIDTH="54"ILEFT="305" WIDTH="54"ILEFT="365" WIDTH="63"ILEFT="0" WIDTH="117"SUBMENULEFT="125" WIDTH="54"RLEFT="185" WIDTH="54"ILEFT="245" WIDTH="54"RLEFT="305" WIDTH="54"OIDREF="Ch05_MenusTF0c"cLEFT="365" WIDTH="63"ILEFT="0" WIDTH="117"RADIOSUBMENULEFT="125" WIDTH="54"RLEFT="185" WIDTH="54"ILEFT="245" WIDTH="54"RLEFT="305" WIDTH="54"OcLEFT="365" WIDTH="63"ILEFT="0" WIDTH="117"ENDLEFT="125" WIDTH="54"RLEFT="185" WIDTH="54"ILEFT="245" WIDTH="54"ILEFT="305" WIDTH="54"ILEFT="365" WIDTH="63"ILEFT="0" WIDTH="117"R = Required parameterLEFT="125" WIDTH="54"LEFT="185" WIDTH="54"LEFT="245" WIDTH="54"LEFT="305" WIDTH="54"LEFT="365" WIDTH="63"LEFT="0" WIDTH="117"O = Optional parameterLEFT="125" WIDTH="54"LEFT="185" WIDTH="54"LEFT="245" WIDTH="54"LEFT="305" WIDTH="54"LEFT="365" WIDTH="63"LEFT="0" WIDTH="117"I = Ignored parameterLEFT="125" WIDTH="54"LEFT="185" WIDTH="54"LEFT="245" WIDTH="54"LEFT="305" WIDTH="54"LEFT="365" WIDTH="63"LBL="a" ID="Ch05_MenusTF0a"If you provide a default client data argument to the menu constructor, that value is used for all menu items for 
which you do not explicitly provide a client data parameter.LBL="b" ID="Ch05_MenusTF0b"While this parameter is optional, the menu item is useless unless you provide a callback function.LBL="c" ID="Ch05_MenusTF0c"If you provide a client data parameter, that value is used as default client data for all menu items in the sub
menu.For example, consider the following array definition:class EditWindow: public VkWindow {
  private:
    static VkMenuDesc editMenu[];
    // ...
};

VkMenuDesc EditWindow::editMenu[] = {
  { ACTION,   "Cut",   &EditWindow::cutCallback,
                               NULL,   NULL,   &EditWindow::undoCutCallback },
  { ACTION,   "Copy",  &EditWindow::copyCallback,
                               NULL,   NULL,   &EditWindow::undoCopyCallback },
  { ACTION,   "Paste", &EditWindow::pasteCallback,
                               NULL,   NULL,   &EditWindow::undoPasteCallback },
  { ACTION,   "Search" &EditWindow::searchCallback }
  { SEPARATOR },
  { CONFIRMFIRSTACTION, "Revert", &EditWindow::revertCallback },
  { END }
};The editMenu array describes a simple menu for editing in an application. The menu consists of five actions and a separator. The menu's "Cut" item calls the cutCallback() function when it is activated with no client data passed to it. "Cut" also supports an undo action through the undoCutCallback() function. The "Copy" and "Paste" items work similarly.The "Search" action does not support an undo action. Presumably, the action performed by this item is either too complex to undo or is meaningless to undo.The "Revert" item is implemented as a CONFIRMFIRSTACTION. When the user activates this item, the application posts a confirmation dialog to warn the user that the action cannot be undone.As a more complex example, consider a menu that contains two submenus, each of which contains two selectable items. You could describe this menu with definitions such as:class TextWindow: public VkWindow {
  private:
    static VkMenuDesc menu[];
    static VkMenuDesc applicationPane[];
    static VkMenuDesc editPane[];
    // ...
};

VkMenuDesc TextWindow::applicationPane[] = {
    { ACTION, "Open", &TextWindow::openCallback },
    { ACTION, "Save", &TextWindow::saveCallback },
    { END }
};

VkMenuDesc TextWindow::editPane[] = {
    { ACTION, "Cut",   &TextWindow::cutCallback },
    { ACTION, "Paste", &TextWindow::pasteCallback },
    { END }
};

VkMenuDesc TextWindow::menu[] = {
    { SUBMENU, "Application", NULL, applicationPane },
    { SUBMENU, "Edit",        NULL, editPane },
    { END }
};After constructing a static menu description, you create it by passing it as an argument to a menu constructor. For example, to implement the menus defined above as a menu bar, you could execute:VkMenuBar *menubar = new VkMenuBar(menu);You could implement the same menu as a popup menu simply by passing the definition to a popup menu constructor:VkPopupMenu *popup = new VkPopupMenu(menu);LBL="" HELPID=""ID="46990"Special Considerations for Xt Callback Client Data When Using Static Menu DescriptionsAs described in ID="Ch05_Menus84"ID="Ch05_Menus85"ID="Ch05_Menus86"IDREF="72493" TYPE="TITLE""Using Xt Callbacks with Components", when using Xt-style callbacks in ViewKit, you should pass the this pointer as client data to all Xt callback functions. Callback functions then retrieve this pointer, cast it to the expected component type, and call a corresponding member function.However, you cannot use the this pointer when you define a static data member. To get around this limitation, menu constructors accept a defaultClientData argument. If you provide a value for this argument, any menu item that does not provide a client data argument uses this argument instead. This allows you to specify menus statically while still allowing you to use an instance pointer with Xt callbacks. The code fragment IDREF="17825" TYPE="TEXT"Example 5-1 illustrates this technique.LBL="5-1"Example 5-1 ID="17825"Providing Default Client Data when Using Static Menu Descriptionsclass SampleWindow: public VkWindow {

  private:
    static void oneCallback(Widget,  XtPointer, XtPointer);
    static void twoCallback(Widget,  XtPointer, XtPointer);
    static void cutCallback(Widget,  XtPointer, XtPointer);
    static void pasteCallback(Widget,  XtPointer, XtPointer);

    static VkMenuDesc applicationPane[];
    static VkMenuDesc editPane[];
    static VkMenuDesc menu[];

  public:
    SampleWindow(const char *name);

    // Other members
};
SampleWindow::SampleWindow(char *name) : VkWindow(name)
{
     setMenuBar(new VkMenuBar(menu, (XtPointer) this));

     // Other actions
}NoteVkWindow::addMenuPane(), VkWindow::addRadioMenuPane(), and the form of the VkWindow::setMenuBar() function that accepts a VkMenuDesc array as an argument all automatically use the this pointer as default client data for the menu bars and menu panes that they create. LBL="" HELPID=""ID="82624"Example of a Creating a Menu Bar Using a Static DescriptionID="Ch05_Menus87"IDREF="28657" TYPE="TEXT"Example 5-2 illustrates using a static description of a menu tree to create a menu bar. The program creates its main window using MyWindow, a subclass of VkWindow. The menu description and all menu callbacks are contained within the MyWindow subclass definition.LBL="5-2"Example 5-2 ID="28657"Example of Creating a Menu Bar Using a Static Description#include <Vk/VkApp.h>
#include <Vk/VkWindow.h>
#include <Vk/VkMenu.h>
#include <iostream.h>
#include <Xm/Label.h>

class MyWindow: public VkWindow {
  private:
    static void sampleCallback( Widget,  XtPointer , XtPointer);
    static void quitCallback( Widget,  XtPointer , XtPointer);

    void quit();
    void sample();

    static VkMenuDesc subMenu[];
    static VkMenuDesc sampleMenuPane[];
    static VkMenuDesc appMenuPane[];
    static VkMenuDesc mainMenuPane[];

  public:
    MyWindow( const char *name);
    ~MyWindow();

    virtual const char* className();
};

MyWindow::MyWindow( const char *name) : VkWindow( name)
{
    Widget label =  XmCreateLabel(mainWindowWidget(), "a menu",
                                  NULL, 0);
    setMenuBar(mainMenuPane);
    addView(label);
}

MyWindow::~MyWindow()
{
    // Empty
}

const char* MyWindow::className() 
{
    return "MyWindow";
}

// The menu bar is essentially a set of cascading menu panes, so the
// top level of the menu tree is always defined as a list of submenus

VkMenuDesc  MyWindow::mainMenuPane[] = {
  { SUBMENU, "Application",  NULL, MyWindow::appMenuPane },
  { SUBMENU, "Sample",       NULL, MyWindow::sampleMenuPane },
  { END }
};

VkMenuDesc MyWindow::appMenuPane[] = {
  { ACTION,   "One",     &MyWindow::sampleCallback },
  { ACTION,   "Two",     &MyWindow::sampleCallback },
  { ACTION,   "Three",   &MyWindow::sampleCallback },
  { SEPARATOR },
  { ACTION,   "Quit",    &MyWindow::quitCallback },
  { END },
};

VkMenuDesc MyWindow::sampleMenuPane[] = {
  { LABEL,    "Test Label" },
  { SEPARATOR },
  { ACTION,    "An Action",       &MyWindow::sampleCallback },
  { ACTION,    "Another Action",  &MyWindow::sampleCallback },
  { SUBMENU,   "A Submenu",       NULL, MyWindow::subMenu },
  { END },
};

VkMenuDesc MyWindow::subMenu[] = {
  { ACTION,  "foo",   &MyWindow::sampleCallback },
  { ACTION,  "bar",   &MyWindow::sampleCallback },
  { ACTION,  "baz",   &MyWindow::sampleCallback },
  { END },
};

void MyWindow::sample()
{
    cout << "sample callback" <<  "\n" << flush;
}

void MyWindow::sampleCallback(Widget, XtPointer clientData, XtPointer)
{
    MyWindow *obj = (MyWindow *) clientData;
    obj->sample();
}

void MyWindow::quitCallback ( Widget, XtPointer, XtPointer )
{
    theApplication->quitYourself();
}

void main(int argc, char **argv)
{
  VkApp     *myApp    = new VkApp("Menudemo",  &argc,  argv);
  MyWindow  *menuWin  = new MyWindow("MenuWindow");

  menuWin->show();
  myApp->run();
}When you run this program, you see the window shown in IDREF="66628" TYPE="GRAPHIC"Figure 5-2.FILE="menu1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="5-2"Figure 5-2 ID="66628"Main Window with Menu Bar Created by Static DescriptionThe first pane, shown in IDREF="93252" TYPE="GRAPHIC"Figure 5-3, contains three selectable entries (actions), followed by a separator, followed by a fourth action. The first three menu items simply invoke a stub function when selected. The fourth item calls quitCallback(), which exits the application.FILE="menu1-2.bw" POSITION="INLINE" SCALE="FALSE"LBL="5-3"Figure 5-3 ID="93252"A Menu Pane Created by a Static DescriptionThe second menu pane, shown in IDREF="78532" TYPE="GRAPHIC"Figure 5-4, demonstrates a non-selectable label, a separator, and a cascading submenu.FILE="menu1-3.bw" POSITION="INLINE" SCALE="FALSE"LBL="5-4"Figure 5-4 ID="78532"A Menu Pane Containing a Label and a SubmenuIn addition to these application-defined menu panes, ViewKit can automatically add a Help menu to a menu bar, which provides a user interface to a help system. IDREF="29804" TYPE="TITLE""The ViewKit Help Menu" describes the Help menu. IDREF="91883" TYPE="TITLE"Appendix C, "Using a Help System with ViewKit," describes how to interface an external help system to a ViewKit application.LBL="" HELPID=""ID="24537"Constructing Menus DynamicallyIn addition to the static description approach demonstrated in the previous section, ViewKit allows applications to construct menus and menu items dynamically using functions defined in ID="Ch05_Menus88"VkMenu. This section describes the menu-creation functions and provides examples of their use.LBL="" HELPID=""ID="54594"Functions for Dynamically Creating MenusThe ID="Ch05_Menus89"VkMenu class provides a number of member functions for creating menus. Each function adds a single menu item to a given menu. You can use these functions at any time in your program. Even if you created a menu using a static definition, you can use these functions to add items to the menu.ID="Ch05_Menus90"ID="Ch05_Menus91"VkMenu::addAction() adds to a menu a selectable menu action, implemented as a VkMenuAction object:VkMenuAction *addAction(const char *name,
                        XtCallbackProc actionCallback = NULL,
                        XtPointer clientData = NULL,
                        int position = -1)

VkMenuAction *addAction(const char *name,
                        XtCallbackProc actionCallback,
                        XtCallbackProc undoCallback,
                        XtPointer clientData,
                        int position = -1)addAction() creates a VkMenuAction object named name and adds it to the menu. By default, addAction() adds the item to the end of the menu; if you specify a value for position, addAction() adds the item at that position. actionCallback is the callback function that performs the item's action and ID="Ch05_Menus92"undoCallback is the callback function that undoes the action. If you do not provide an undo callback, the action cannot be undone and does not participate in the ViewKit undo mechanism as described in IDREF="56221" TYPE="TITLE"Chapter 6. clientData is client data passed to the callback functions. Following ViewKit conventions as described in IDREF="72493" TYPE="TITLE""Using Xt Callbacks with Components", you should pass the this pointer as client data so that the callback functions can retrieve the pointer, cast it to the expected component type, and call a corresponding member function.ID="Ch05_Menus93"ID="Ch05_Menus94"VkMenu::addConfirmFirstAction() adds to a menu a selectable menu action, implemented as a VkMenuConfirmFirstAction object:VkMenuConfirmFirstAction *
      addConfirmFirstAction(const char *name,
                            XtCallbackProc actionCallback = NULL,
                            XtPointer clientData = NULL,
                            int position = -1)addConfirmFirstAction() creates a VkMenuConfirmFirstAction object named name and adds it to the menu. By default, addConfirmFirstAction() adds the item to the end of the menu; if you specify a value for position, addConfirmFirstAction() adds the item at that position. actionCallback is the callback function that performs the item's action and clientData is client data passed to the callback function. As described above, you should pass the this pointer as client data.ID="Ch05_Menus95"ID="Ch05_Menus96"VkMenu::addToggle() adds to a menu a selectable menu toggle, implemented as a VkMenuToggle object:VkMenuToggle *addToggle(const char *name,
                        XtCallbackProc actionCallback = NULL,
                        XtPointer clientData = NULL,
                        int state = -1)
                        int position = -1)addToggle() creates a VkMenuToggle object named name and adds it to the menu. By default, addToggle() adds the item to the end of the menu; if you specify a value for position, addToggle() adds the item at that position. If you provide a state argument, addToggle() sets the initial state of the toggle to that value. actionCallback is the callback function that performs the item's action and clientData is client data passed to the callback function. As described above, you should pass the this pointer as client data.ID="Ch05_Menus97"ID="Ch05_Menus98"VkMenu::addLabel() adds to a menu a non-selectable menu label, implemented as a VkMenuLabel object:VkMenuLabel *addLabel(const char *name,
                      int position = -1)addLabel() creates a VkMenuLabel object named name and adds it to the menu. By default, addLabel() adds the item to the end of the menu; if you specify a value for position, addLabel() adds the item at that position.ID="Ch05_Menus99"ID="Ch05_Menus100"VkMenu::addSeparator() adds to a menu a non-selectable menu separator, implemented as a VkMenuSeparator object:VkMenuSeparator *addSeparator(const char *name,
                              int position = -1)addSeparator() creates a VkMenuSeparator object named name and adds it to the menu. By default, addSeparator() adds the item to the end of the menu; if you specify a value for position, addSeparator() adds the item at that position.ID="Ch05_Menus101"ID="Ch05_Menus102"VkMenu::addSubmenu() adds to a menu a submenu, implemented as a VkSubMenu object:VkSubMenu *addSubmenu(VkSubMenu *submenu,
                      int position = -1)

VkSubMenu *addSubmenu(const char *name,
                      int position = -1)

VkSubMenu *addSubmenu(const char *name,
                      VkMenuDesc *menuDesc)
                      XtPointer *defaultClientData = NULL)
                      int position = -1)addSubmenu() is overloaded so that you can: 1) add an existing VkSubMenu object; 2) create and add a VkSubMenu object containing no items; or 3) create and add a VkSubMenu object from the static menu description, menuDesc. If you create and add the submenu using the static menu description, you can also provide a defaultClientData value that is used as the default client data for all items contained by the submenu. By default, addSubmenu() adds the item to the end of the menu; if you specify a value for position, addSubmenu() adds the item at that position.NoteThe "m" in addSubmenu() is lower case, whereas the "M" in VkSubMenu is in upper case. ID="Ch05_Menus103"ID="Ch05_Menus104"VkMenu::addRadioSubmenu() adds to a menu a submenu that enforces radio-style behavior on the toggle items it contains:VkRadioSubMenu *addRadioSubmenu(VkRadioSubMenu *submenu,
                                int position = -1)

VkRadioSubMenu *addRadioSubmenu(const char *name,
                                int position = -1)

VkRadioSubMenu *addRadioSubmenu(const char *name,
                              VkMenuDesc *menuDesc)
                              XtPointer *defaultClientData = NULL)
                              int position = -1)addRadioSubmenu() is overloaded so that you can: 1) add an existing VkRadioSubMenu object; 2) create and add a VkRadioSubMenu object containing no items; or 3) create and add a VkRadioSubMenu object from the static menu description, menuDesc. If you create and add the submenu using the static menu description, you can also provide a defaultClientData value that is used as the default client data for all items contained by the submenu. By default, addSubmenu() adds the item to the end of the menu; if you specify a value for position, addSubmenu() adds the item at that position.NoteThe "m" in addRadioSubmenu() is lower case, whereas the "M" in VkRadioSubMenu is in upper case. ID="Ch05_Menus105"VkMenu::add() adds an existing menu item to a menu:void add(VkMenuItem *item, int position = -1)By default, add() adds the item to the end of the menu; if you specify a value for position, add() adds the item at that position. Though you can use add() to add any type of menu item to a menu, you typically need it to add only the ViewKit undo manager and VkMenuActionObject objects. IDREF="48591" TYPE="TITLE""Undo Management" describes the ViewKit undo manager and IDREF="77326" TYPE="TITLE""Command Classes" describes the VkMenuActionObject class.LBL="" HELPID=""ID="92911"Example of a Creating a Menu Bar DynamicallyID="Ch05_Menus106"IDREF="49674" TYPE="TEXT"Example 5-3 is functionally equivalent to IDREF="28657" TYPE="TEXT"Example 5-2. It constructs a menu by adding items one at a time to the window's menu bar and to individual menu panes.LBL="5-3"Example 5-3 ID="49674"Example of Creating a Menu Bar Dynamically#include <Vk/VkApp.h>
#include <Vk/VkWindow.h>
#include <Vk/VkSubMenu.h>
#include <Vk/VkMenu.h>
#include <Xm/Label.h>
#include <iostream.h>

class MyWindow: public VkWindow {
  private:
    static void sampleCallback( Widget, XtPointer, XtPointer);
    static void quitCallback( Widget, XtPointer, XtPointer);

  protected:
    void sample();

  public:
    MyWindow( const char *name);
    ~MyWindow();

    virtual const char* className();
};

MyWindow::MyWindow( const char *name) : VkWindow( name) 
{
    Widget label =  XmCreateLabel(mainWindowWidget(), "a menu", NULL, 0);

    // Add a menu pane

    VkSubMenu *appMenuPane = addMenuPane("Application");
    
    appMenuPane->addAction("One",   &MyWindow::sampleCallback,
                           (XtPointer) this);
    appMenuPane->addAction("Two",   &MyWindow::sampleCallback,
                           (XtPointer) this);
    appMenuPane->addAction("Three", &MyWindow::sampleCallback,
                           (XtPointer) this);
    appMenuPane->addSeparator();
    appMenuPane->addAction("Quit", &MyWindow::quitCallback,
                           (XtPointer) this); 

    // Add a menu second pane
    
    VkSubMenu *sampleMenuPane = addMenuPane("Sample");
    
    sampleMenuPane->addLabel("Test Label");
    sampleMenuPane->addSeparator();
    sampleMenuPane->addAction("An Action",
                              &MyWindow::sampleCallback,
                              (XtPointer) this);
    sampleMenuPane->addAction("Another Action",
                              &MyWindow::sampleCallback,
                              (XtPointer) this);

    // Create a cascading submenu

    VkSubMenu *subMenu = sampleMenuPane->addSubmenu("A Submenu"); 
    
    subMenu->addAction("foo", &MyWindow::sampleCallback,
                       (XtPointer) this);
    subMenu->addAction("bar", &MyWindow::sampleCallback,
                       (XtPointer) this);
    subMenu->addAction("baz", &MyWindow::sampleCallback,
                       (XtPointer) this);
    
    addView(label);
}

MyWindow::~MyWindow()
{
    // Empty
}

const char* MyWindow::className() { return "MyWindow";}

void MyWindow::sampleCallback(Widget, XtPointer clientData, XtPointer)
{
    MyWindow *obj = (MyWindow *) clientData;
    obj->sample();
}

void MyWindow::sample()
{
    cout << "sample callback" << "\n" << flush;
}

void MyWindow::quitCallback ( Widget, XtPointer, XtPointer )
{
    theApplication->quitYourself();
}

void main(int argc, char **argv)
{
    VkApp  *myApp = new VkApp("Menu", &argc, argv);
    MyWindow  *w1  = new MyWindow("menuWindow");

    w1->show();
    myApp->run();
}LBL="" HELPID=""Manipulating Items in MenuOne of the advantages of the ViewKit menu system is the ability to manipulate the items in a menu after the menu has been created. The ViewKit menu system allows menu items to be manipulated by sending messages to any menu item. Menu items can also be found and manipulated by name.LBL="" HELPID=""Finding Items in a MenuThe ID="Ch05_Menus107"ID="Ch05_Menus108"ID="Ch05_Menus109"VkMenu::findNamedItem() function allows you to find an item in a menu given its component name:VkMenuItem *findNamedItem(const char *name,
                          Boolean caseless = FALSE)findNamedItem() finds and returns a pointer to a menu item of the specified name belonging to the menu object or any submenus of the menu object. You can also pass an optional Boolean argument specifying whether or not the search is case-sensitive. If findNamedItem() finds no menu item with the given name, it returns NULL. If multiple instances of the same name exist, findNamedItem() returns the first name found in a depth-first search.NoteRemember that you need to cast the return value if you need to access a member function provided by a VkMenuItem subclass. For example, if you search for a toggle item, remember to cast the return value to VkMenuToggle before calling a member function such as VkMenuToggle::setVisualState(). LBL="" HELPID=""ID="13124"Activating and Deactivating Items in a MenuThe ID="Ch05_Menus110"ID="Ch05_Menus111"ID="Ch05_Menus112"VkMenu::activateItem() function makes a menu item sensitive so that it accepts user input (that is, a user can select the item):VkMenuItem *activateItem(const char *name)You provide as an argument to activateItem() the name of the menu item to activate. This is the same name that you gave the menu item when you created it. activateItem() returns a VkMenuItem pointer to the item activated (or NULL if you did not provide a valid menu item name). By default, all menu items are activated (sensitive) when they are created.The ID="Ch05_Menus113"ID="Ch05_Menus114"ID="Ch05_Menus115"VkMenu::deactivateItem() function makes a menu item insensitive so that it does not accept user input (that is, a user cannot select the item):VkMenuItem *deactivateItem(const char *name)You provide as an argument to deactivateItem() the name of the menu item to deactivate. This is the same name that you gave the menu item when you created it. deactivateItem() returns a VkMenuItem pointer to the item deactivated (or NULL if you did not provide a valid menu item name).When insensitive, the menu item appears "grayed out" when you display the menu. You can re-activate a menu item by calling deactivateItem() on that item.Note that instead of using VkMenu::activateItem() and VkMenu::deactivateItem() to activate and deactivate menu items, you could retain pointers to all of your menu items and use VkMenuItem::activate() and VkMenuItem::deactivate() respectively. The effect is the same no matter which functions you use, though typically you will find it easier to use the VkMenu functions. IDREF="53932" TYPE="TITLE""Activating and Deactivating Menu Items" describes VkMenuItem::activate() and VkMenuItem::deactivate().LBL="" HELPID=""ID="88889"Removing Items from a MenuIf you want to remove a menu item from a menu, you can call ID="Ch05_Menus116"ID="Ch05_Menus117"ID="Ch05_Menus118"VkMenu::removeItem():VkMenuItem *removeItem(const char *name)You provide as an argument to removeItem() the name of the menu item to remove from the menu. This is the same name that you gave the menu item when you created it. removeItem() returns a VkMenuItem pointer to the item removed. removeItem() does not destroy a menu item, it simply removes the item from the menu hierarchy.Note that instead of using VkMenu::removeItem(), you could retain pointers to all of your menu items and use VkMenuItem::remove(). The effect is the same no matter which functions you use, though typically you will find it easier to use the VkMenu functions. IDREF="33903" TYPE="TITLE""Displaying and Hiding Menu Items" describes VkMenuItem::remove().LBL="" HELPID=""Replacing Items in a MenuYou can replace an item in a menu with another menu item using ID="Ch05_Menus119"ID="Ch05_Menus120"ID="Ch05_Menus121"VkMenu::replace():VkMenuItem *replace(const char *name, VkMenuItem *newItem)replace() first uses VkMenu::findNamedItem to find the item specified by name. Then it removes that item from the menu and adds the menu item specified by newItem in its place. replace() returns a pointer to the menu item that you replaced.LBL="" HELPID=""Example of Manipulating Menu ItemsThe program in IDREF="96321" TYPE="TEXT"Example 5-4 allows users to dynamically add and remove items from a menu, and also to activate and deactivate items.LBL="5-4"Example 5-4 ID="96321"Example of Manipulating Menu Items#include <Vk/VkApp.h>
#include <Vk/VkWindow.h>
#include <Vk/VkMenu.h>
#include <Vk/VkSubMenu.h>
#include <Xm/Label.h>
#include <stream.h>
#include <stdlib.h>

class MyWindow: public VkWindow {

  private:
    static void addOneCallback       (Widget, XtPointer, XtPointer);
    static void removeOneCallback    (Widget, XtPointer, XtPointer);
    static void activateOneCallback  (Widget, XtPointer, XtPointer);
    static void deactivateOneCallback(Widget, XtPointer, XtPointer);
    static void sampleCallback       (Widget, XtPointer, XtPointer);
    static void quitCallback         (Widget, XtPointer, XtPointer);

  protected:
    VkSubMenu *_appMenuPane;
    VkSubMenu *_menuPaneTwo;

    void addOne();
    void removeOne();
    void activateOne();
    void deactivateOne();
    void sample();

  public:
    MyWindow( const char *name);
    ~MyWindow();
    virtual const char* className();
};

MyWindow::~MyWindow()
{
    // Empty
}

const char* MyWindow::className() { return "MyWindow";}

void MyWindow::sampleCallback(Widget, XtPointer clientData, XtPointer)
{
    MyWindow *obj = ( MyWindow * ) clientData;
    obj->sample();
}

void MyWindow::sample()
{
    cout << "sample callback" << "\n" << flush;
}

void MyWindow::addOneCallback(Widget, XtPointer clientData, XtPointer)
{
    MyWindow *obj = ( MyWindow * ) clientData;
    obj->addOne();
}

void MyWindow::addOne()
{
    _menuPaneTwo->addAction("A New Action", &MyWindow::sampleCallback,
                            (XtPointer) this);
}

void MyWindow::removeOneCallback(Widget, XtPointer clientData,
                                 XtPointer)
{
    MyWindow *obj = (MyWindow *) clientData;
    obj->removeOne();
}

void MyWindow::removeOne()
{
    _menuPaneTwo->removeItem("A New Action");
}

void MyWindow::activateOneCallback(Widget, XtPointer clientData,
                                   XtPointer)
{
    MyWindow *obj = (MyWindow *) clientData;
    obj->activateOne();
}

void MyWindow::activateOne()
{
    _menuPaneTwo->activateItem("A New Action");
}

void MyWindow::deactivateOneCallback(Widget, XtPointer clientData,
                                     XtPointer)
{
    MyWindow *obj = (MyWindow *) clientData;
    obj->deactivateOne();
}

void MyWindow::deactivateOne()
{
    _menuPaneTwo->deactivateItem("A New Action");
}

void MyWindow::quitCallback (Widget, XtPointer, XtPointer)
{
    theApplication->quitYourself();
}

MyWindow::MyWindow( const char *name) : VkWindow( name) 
{
    Widget label =  XmCreateLabel(mainWindowWidget(), "a menu",
                                  NULL, 0);

    // Add a menu pane

    _appMenuPane = addMenuPane("Application");
    
    _appMenuPane->addAction("Add One",
                            &MyWindow::addOneCallback,
                            (XtPointer) this); 
    _appMenuPane->addAction("Remove One",
                            &MyWindow::removeOneCallback,
                            (XtPointer) this); 
    _appMenuPane->addAction("Activate One",
                            &MyWindow::activateOneCallback,
                            (XtPointer) this); 
    _appMenuPane->addAction("Deactivate One",
                            &MyWindow::deactivateOneCallback,
                            (XtPointer) this); 
    _appMenuPane->addSeparator();
    _appMenuPane->addAction("Quit",
                            &MyWindow::quitCallback,
                            (XtPointer) this ); 

    // Add a menu second pane
    
    _menuPaneTwo = addMenuPane("PaneTwo");

    addView(label); 
}


void main(int argc, char **argv)
{
  VkApp  *myApp = new VkApp("Menudemo3",  &argc,  argv);
  MyWindow  *menuWin  = new MyWindow("menuWindow");

  menuWin->show();
  myApp->run();
}LBL="" HELPID=""Menu Access FunctionsThe VkMenu class also provides some access functions to help manipulate menu items.You can determine the number of items currently associated with a menu by using ID="Ch05_Menus122"VkMenu::numItems():int numItems() constYou can determine the position of an item in a menu with ID="Ch05_Menus123"ID="Ch05_Menus124"ID="Ch05_Menus125"VkMenu::getItemPosition():int getItemPosition(VkMenuItem * item)
int getItemPosition(char *name)
int getItemPosition(Widget w)You can specify the menu item by pointer, name, or widget. getItemPosition() returns the position of the item within the menu, with zero representing the first position in the menu.As a convenience, you can also access items in a menu using standard array subscript notation:ID="Ch05_Menus126"VkMenuItem * operator[] (int index) constFor example, you can use VkMenu::numItems() with the array subscript notation to loop through an entire menu and perform some operation on all of the items it contains. For example, if menubar is a menu, the following code prints the name and class of each item in the menubar menu:for ( i=0; i < menubar->numItems(); i++ )
    cout << "Name: " << (*menubar)[i]->name() << "\t"
         << "Class: " << (*menubar)[i]->className() << "\n";LBL="" HELPID=""Using ViewKit Menu SubclassesThis section describes the features of each ViewKit menu subclass. In addition to specific member functions listed, each class also supports all functions provided by the VkMenu class.LBL="" HELPID=""ID="77318"Menu BarThe ID="Ch05_Menus127"ID="Ch05_Menus128"ID="Ch05_Menus129"ID="Ch05_Menus130"ID="Ch05_Menus131"ID="Ch05_Menus132"VkMenuBar class provides a menu bar designed to work with the VkWindow class. In addition to the functions described in this section, the VkWindow class provides some member functions for installing a VkMenuBar object as a menu bar. IDREF="88773" TYPE="TITLE""Menu Bar Support" describes the functions provided by VkWindow.Examples of menu bar construction were given in IDREF="82624" TYPE="TITLE""Example of a Creating a Menu Bar Using a Static Description" (IDREF="28657" TYPE="TEXT"Example 5-2) and IDREF="92911" TYPE="TITLE""Example of a Creating a Menu Bar Dynamically" (IDREF="49674" TYPE="TEXT"Example 5-3).LBL="" HELPID=""ID="54015"Menu Bar ConstructorsThere are four different versions of the ID="Ch05_Menus133"VkMenuBar constructor:VkMenuBar(Boolean showHelpPane = TRUE)

VkMenuBar(const char *name,
          Boolean showHelpPane = TRUE);

VkMenuBar(VkMenuDesc *menuDesc,
          XtPointer defaultCientData= NULL,
          Boolean showHelpPane = TRUE)

VkMenuBar(const char *name,
          VkMenuDesc *menuDesc,
          XtPointer defaultCientData = NULL,
          Boolean showHelpPane = TRUE)To work with Silicon Graphics's color schemes, you should give the menu bar the name "menuBar". (For information on schemes, consult the ID="Ch05_Menus134"schemes(3x) reference page.) The forms of the constructor that do not take a name argument automatically use the name "menuBar". You can specify another name, but schemes will not work correctly.If you use a form of the VkMenuBar constructor that accepts a menuDesc argument, the constructor creates a menu from the VkMenuDesc structure you provide.Some forms of the constructor also accept an optional defaultClientData argument. If provided, any menu item that does not provide a client data argument will use this argument instead. This allows menus to be specified statically, while still allowing an instance pointer to be used with callbacks, as described in IDREF="46990" TYPE="TITLE""Special Considerations for Xt Callback Client Data When Using Static Menu Descriptions".The last argument to each version of the constructor is a Boolean value that specifies whether the constructor should create a help pane that interfaces to the Silicon Graphics help system. The default is to automatically provide the help pane. The help pane is implemented by the VkHelpPane class, described in IDREF="29804" TYPE="TITLE""The ViewKit Help Menu".LBL="" HELPID=""Menu Bar Access FunctionsThe ID="Ch05_Menus135"VkMenuBar class also provides the helpPane() member function:VkHelpPane *helpPane() consthelpPane() returns a pointer to the menu bar's help pane. If the menu bar does not have a help pane, ID="Ch05_Menus136"helpPane() returns NULL.LBL="" HELPID=""ID="68387"SubmenusThe VkSubMenu class supports pull-down menu panes. You can use these menu panes within a menu bar (a ID="Ch05_Menus137"ID="Ch05_Menus138"ID="Ch05_Menus139"ID="Ch05_Menus140"VkMenuBar object), or as a cascading, pull-right menu in a popup or other pull-down menu.LBL="" HELPID=""Submenu ConstructorYou should seldom need to instantiate a VkSubMenu object directly. You can add a submenu to any type of menu by calling that menu's addSubmenu() member function. You can also add menu panes to the menu bar of a VkWindow object by calling VkWindow::addMenuPane().For those cases where you do need to instantiate a ID="Ch05_Menus141"VkSubMenu object directly, the form of the constructor you should use is:VkSubMenu(const char *name, 
          VkMenuDesc *menuDesc = NULL, 
          XtPointer defaultClientData = NULL)name specifies the name of the submenu. If you provide the optional menuDesc argument, the constructor creates a menu from the VkMenuDesc structure you provide. If you provide the optional defaultClientData argument, any menu item that does not provide a client data argument will use this argument instead. This allows menus to be specified statically, while still allowing an instance pointer to be used with callbacks, as described in IDREF="46990" TYPE="TITLE""Special Considerations for Xt Callback Client Data When Using Static Menu Descriptions".LBL="" HELPID=""ID="84703"Submenu Utility and Access FunctionsThe VkSubMenu class provides a couple of additional public member functions.IRIS IM supports tear-off menus, which enable the user to retain a menu pane on the screen. If tear-off behavior is enabled for a menu pane, a tear-off button, which has the appearance of a dashed line, appears at the top of the menu pane. The user can tear off the pane by selecting the tear-off button.ID="Ch05_Menus142"By default, tear-off behavior is disabled for all menu panes. You can change the tear-off behavior of a submenu using ID="Ch05_Menus143"VkSubMenu::showTearOff():void showTearOff(Boolean showIt)If you pass the Boolean value TRUE to showTearOff(), the submenu displays the tear-off button; if you pass the value FALSE, it hides the tear-off button.You can also enable tear-off behavior for a menu by setting the its XmNtearOffModel resource to XmTEAR_OFF_ENABLED (for example, in a resource file).ID="Ch05_Menus144"You can access the RowColumn widget used to implement the submenu's pulldown pane, by calling ID="Ch05_Menus145"VkSubMenu::pulldown():Widget pulldown()LBL="" HELPID=""The ID="Ch05_Menus146"baseWidget() function of a VkSubMenu object returns the CascadeButton widget required by IRIS IM pulldown menus.ID="39602"Radio SubmenusThe ID="Ch05_Menus147"ID="Ch05_Menus148"ID="Ch05_Menus149"ID="Ch05_Menus150"VkRadioSubMenu class, derived from VkSubMenu, supports pull-down menu panes. Its function is similar to that of VkSubMenu, but the RowColumn widget used as a menu pane is set to exhibit radio behavior. This class is intended to support one-of-many collections of VkToggleItem objects. You can use VkRadioSubMenu objects as menu panes within a menu bar (a VkMenuBar object), or as a cascading, pull-right menu in a popup or other pull-down menu.It is seldom necessary to directly create a VkRadioSubMenu object. You can add radio submenus to any VkMenuBar, VkPopupMenu, or VkSubMenu by calling those classes's addRadioSubmenu() member function. You can also add menu panes to a VkWindow by calling VkWindow::addRadioMenuPane().LBL="" HELPID=""Radio Submenu ConstructorYou should seldom need to instantiate a ID="Ch05_Menus151"VkRadioSubMenu object directly. You can add a radio submenu to any type of menu by calling that menu's addRadioSubmenu() member function. You can also add radio menu panes to the menu bar of a VkWindow object by calling VkWindow::addRadioMenuPane().For those cases where you do need to instantiate a VkRadioSubMenu object directly, the form of the constructor you should use is:VkRadioSubMenu(const char *name, 
               VkMenuDesc *menuDesc = NULL, 
               XtPointer defaultClientData = NULL)name specifies the name of the radio submenu. If you provide the optional menuDesc argument, the constructor creates a menu from the VkMenuDesc structure you provide. If you provide the optional defaultClientData argument, any menu item that does not provide a client data argument will use this argument instead. This allows menus to be specified statically, while still allowing an instance pointer to be used with callbacks, as described in IDREF="46990" TYPE="TITLE""Special Considerations for Xt Callback Client Data When Using Static Menu Descriptions".LBL="" HELPID=""Radio Submenu Utility and Access FunctionsThe VkRadioSubMenu class does not provide any public member functions in addition to those provided by the VkSubMenu class. For information on the utility and access functions provided by VkSubMenu, see IDREF="84703" TYPE="TITLE""Submenu Utility and Access Functions".LBL="" HELPID=""Radio Submenu ExampleIDREF="27931" TYPE="TEXT"Example 5-5 shows an example of using a VkRadioSubMenu class.LBL="5-5"Example 5-5 ID="27931"Example of Using a VkRadioSubMenu Object#include <Vk/VkApp.h>
#include <Vk/VkWindow.h>
#include <Vk/VkSubMenu.h>
#include <Vk/VkRadioSubMenu.h>
#include <Vk/VkMenu.h>
#include <Xm/Label.h>
#include <stream.h>
#include <stdlib.h>

class MyWindow: public VkWindow {

  private:

    static void sampleCallback( Widget,  XtPointer , XtPointer);
    static void quitCallback( Widget,  XtPointer , XtPointer);
  protected:

    void sample();

  public:
 
    MyWindow( const char *name);
    ~MyWindow();

    virtual const char* className();
};


MyWindow::~MyWindow()
{
    // Empty
}

void MyWindow::sampleCallback( Widget,  XtPointer clientData , XtPointer)
{
    MyWindow *obj = (MyWindow *) clientData;
    obj->sample();
}

const char* MyWindow::className() { return "MyWindow";}

void MyWindow::sample()
{

    cout << "In Sample Callback" << "\n" << flush;
}

void MyWindow::quitCallback ( Widget, XtPointer, XtPointer )
{
    exit(0);
}

MyWindow::MyWindow( const char *name) : VkWindow( name) 
{
    Widget label =  XmCreateLabel(mainWindowWidget(), "a menu", NULL, 0);

    // Add a menu pane

    VkSubMenu *appMenuPane = addMenuPane("Application");
    
    appMenuPane->addAction("One",  &MyWindow::sampleCallback, (XtPointer) this);
    appMenuPane->addAction("Two",  &MyWindow::sampleCallback, (XtPointer) this);
    appMenuPane->addSeparator();
    appMenuPane->addAction("Quit", &MyWindow::quitCallback, (XtPointer) this); 

    // Add a menu second pane
    
    VkSubMenu *sampleMenuPane = addMenuPane("Sample");
    
    sampleMenuPane->addLabel("Test Label");
    sampleMenuPane->addSeparator();
    sampleMenuPane->addAction("An Action", &MyWindow::sampleCallback,
                              (XtPointer) this); 

    // Create a cascading submenu

    VkRadioSubMenu *subMenu = sampleMenuPane->addRadioSubmenu("A Submenu"); 
    
    subMenu->addToggle("foo", &MyWindow::sampleCallback, (XtPointer) this); 
    subMenu->addToggle("bar", &MyWindow::sampleCallback, (XtPointer) this); 
    subMenu->addToggle("baz", &MyWindow::sampleCallback, (XtPointer) this); 
    
    addView(label);
}


void main(int argc, char **argv)
{
    VkApp  *myApp = new VkApp("Menu",  &argc,  argv);
    MyWindow  *w1  = new MyWindow("menuwindow");

    w1->show();
    
    myApp->run();
}LBL="" HELPID=""Option MenusThe ID="Ch05_Menus152"ID="Ch05_Menus153"ID="Ch05_Menus154"ID="Ch05_Menus155"VkOptionMenu class supports option menus. You can use this component anywhere in your interface.LBL="" HELPID=""Unlike many other ViewKit components, VkOptionMenu objects are automatically visible when you create them; you do not need to call show() initially to display a VkOptionMenu object.Option Menu ConstructorsThere are two different versions of the ID="Ch05_Menus156"VkOptionMenu constructor that you can use:VkOptionMenu(Widget parent,
             VkMenuDesc *menuDesc,
             XtPointer defaultClientData = NULL)

VkOptionMenu(Widget parent,
             const char *name = "optionMenu",
             VkMenuDesc *menuDesc = NULL,
             XtPointer defaultClientData = NULL)You must provide a parent argument specifying the parent widget of the option menu.To work with Silicon Graphics's color schemes, you should give the option menu the name "optionMenu". (For information on schemes, consult the ID="Ch05_Menus157"schemes(3x) reference page.) The forms of the constructor that do not take a name argument automatically use the name "optionMenu". You can specify another name, but schemes will not work correctly.If you provide the optional menuDesc argument, the constructor creates a menu from the VkMenuDesc structure you provide.If you provide the optional defaultClientData argument, any menu item that does not provide a client data argument uses this argument instead. This allows menus to be specified statically, while still allowing an instance pointer to be used with callbacks. This is described in IDREF="46990" TYPE="TITLE""Special Considerations for Xt Callback Client Data When Using Static Menu Descriptions".LBL="" HELPID=""Setting the Option Menu LabelTo specify the string that is displayed as the options menu's label, you must set the XmNlabelString resource for the menu's label widget. To do so you can:ID="Ch05_Menus158"ID="Ch05_Menus159"ID="Ch05_Menus160"Use the VkComponent::setDefaultResources() function to provide default resource values.Set resource values in an external app-defaults resource file. Any values you provide in an external file will override values that you set using the VkComponent::setDefaultResources() function. This is useful when your application must support multiple languages; you can provide a separate resource file for each language supported.Set the resource value directly using the XtSetValues() function. Values you set using this method override any values set using either of the above two methods. You should generally avoid using this method as it "hard codes" the resource values into the code, making them more difficult to change.Because all option menus must be named "optionMenu" to work with Silicon Graphics's color schemes, if you set the label through a resource value you should qualify the resource specifications with the name of a parent widget or component so that the X resource database can distinguish between instances of VkOptionMenu. For example, you could use resource specifications such as "*mainWindow*optionMenu*labelString" and "*graphWindow*optionMenu*labelString" to distinguish between an option menu that is a descendant of a "mainWindow" component and one that is a descendant of a "graphWindow" component respectively.LBL="" HELPID=""Selecting Items in an Option MenuYou can programmatically set the selected item in an option menu using ID="Ch05_Menus161"ID="Ch05_Menus162"VkOptionMenu::set():void set(char* name)
void set(int index)
void set(VkMenuItem *item)You can specify the selected item either by a pointer to the item, the item's component name, or the item's index (position) in the option menu, where the top item in the menu has an index of zero.LBL="" HELPID=""Determining Selected Items in an Option MenuThere are two functions that you can use to determine which item is selected in an option menu.ID="Ch05_Menus163"You can retrieve the index (position) of the currently selected menu item using ID="Ch05_Menus164"VkOptionMenu::getIndex():int getIndex()getIndex() returns the index (position) of the selected item, where the top item in the menu has an index of zero.You can retrieve a pointer to the currently selected menu item using ID="Ch05_Menus165"VkOptionMenu::getItem():VkMenuItem *getItem()LBL="" HELPID=""Option Menu Utility FunctionsNormally, the width of the option menu is set to be that of the largest item it contains. You can force the option menu to a different width using ID="Ch05_Menus166"ID="Ch05_Menus167"VkOptionMenu::forceWidth()void forceWidth(int width)forceWidth() sets all of the items in the option menu to be width pixels wide.LBL="" HELPID=""Option Menu ExampleID="Ch05_Menus168"IDREF="39612" TYPE="TEXT"Example 5-6 shows an example of using a VkOptionMenu class.LBL="5-6"Example 5-6 ID="39612"Example of Using a VkOptionMenu Object////////////////////////////////////////////////////////////////////
// Demostrate viewkit interface to option menus
///////////////////////////////////////////////////////////////////
#include <Vk/VkApp.h>
#include <Vk/VkSimpleWindow.h>
#include <Vk/VkOptionMenu.h>
#include <stream.h>
#include <Xm/RowColumn.h>

class MyWindow: public VkSimpleWindow {

  private:

    static void sampleCallback( Widget,  XtPointer , XtPointer);

    static VkMenuDesc MyWindow::optionPaneDesc[];

  protected:

    void sample(Widget, XtPointer);
    VkOptionMenu *_optionMenu;

  public:
 
    MyWindow( const char *name);
    ~MyWindow( );

    virtual const char* className();
};

VkMenuDesc MyWindow::optionPaneDesc[] = {
  { ACTION,   "Red",   &MyWindow::sampleCallback},
  { ACTION,   "Green", &MyWindow::sampleCallback},
  { ACTION,   "Blue",  &MyWindow::sampleCallback},
  { END},
};

MyWindow::MyWindow( const char *name) : VkSimpleWindow( name)
{
    Widget rc = XmCreateRowColumn(mainWindowWidget(), "rc", NULL, 0);

    _optionMenu = new VkOptionMenu(rc, optionPaneDesc, (XtPointer) this);
    _optionMenu->set("Green");

    addView(rc);
}

MyWindow::~MyWindow( )
{

}

const char* MyWindow::className() { return "MyWindow";}

void MyWindow::sampleCallback( Widget w, XtPointer clientData, XtPointer callData)
{
    MyWindow *obj = (MyWindow *) clientData;
    obj->sample(w, callData);
}

void MyWindow::sample(Widget, XtPointer)
{
    cout << "Selected item's index = " 
    << _optionMenu->getIndex() 
    << ",  name = " 
    <<  _optionMenu->getItem()->name() 
    << "\n"
    << flush;
}

void main(int argc, char **argv)
{
  VkApp     *app    = new VkApp("Option",  &argc,  argv);
  MyWindow  *win  = new MyWindow("OptionMenu");

  win->show();

  app->run();
}LBL="" HELPID=""Popup MenusThe ID="Ch05_Menus169"ID="Ch05_Menus170"ID="Ch05_Menus171"ID="Ch05_Menus172"VkPopupMenu class supports popup menus. You can attach a ViewKit popup menu to one or more widgets in your application so that it pops up automatically whenever the user clicks on any of those widgets with the right mouse button. You can also pop up the menu programmatically.LBL="" HELPID=""Popup Menu ConstructorsThere are four different versions of the ID="Ch05_Menus173"VkPopupMenu constructor:VkPopupMenu(VkMenuDesc *menuDesc,
            XtPointer defaultClientData = NULL)

VkPopupMenu(const char *name = "popupMenu",
            VkMenuDesc *menuDesc = NULL,
            XtPointer defaultClientData = NULL)

VkPopupMenu(Widget parent,
            VkMenuDesc *menuDesc = NULL,
            XtPointer defaultClientData = NULL)
VkPopupMenu(Widget parent,
            const char *name = "popupMenu",
            VkMenuDesc *menuDesc = NULL,
            XtPointer defaultClientData = NULL)The forms of the constructor that do not take a name argument automatically use the name "popupMenu". You can specify another name, but schemes will not work correctly.If you provide the optional menuDesc argument, the constructor creates a menu from the VkMenuDesc structure you provide.If you provide the optional defaultClientData argument, any menu item that does not provide a client data argument uses this argument instead. This allows menus to be specified statically, while still allowing an instance pointer to be used with callbacks. This is described in IDREF="46990" TYPE="TITLE""Special Considerations for Xt Callback Client Data When Using Static Menu Descriptions".If you use a form of the ID="Ch05_Menus174"ID="Ch05_Menus175"VkPopupMenu constructor that accepts a parent argument, the constructor automatically attaches the menu to the widget. This builds the menu as a child of the widget and installs an event handler to pop up the menu whenever the user clicks on the widget with the right mouse button. For more information on attaching a popup menu to a widget, see the description of VkPopupMenu::attach() in IDREF="68816" TYPE="TITLE""Attaching Popup Menus to Widgets".LBL="" HELPID=""ID="68816"Attaching Popup Menus to WidgetsThe ID="Ch05_Menus176"VkPopupMenu::attach() function attaches a popup menu to a widget:virtual void attach(Widget w)The first call to attach() creates all widgets in the popup menu, using the given widget as the parent of the menu. attach() then adds an event handler to post the menu automatically whenever the user clicks on the widget with the right mouse button. Subsequent calls to attach() add the ability to post the menu over additional widgets.LBL="" HELPID=""Popping Up Popup MenusOnce you have attached a popup menu to one or more widgets in your application, ViewKit automatically posts the menu whenever the user clicks on any of those widgets with the right mouse button.ID="Ch05_Menus177"You can also post the menu programmatically even if you have not attached the popup menu to a widget.If you have not attached the popup menu to a widget, you must first build the menu using ID="Ch05_Menus178"VkPopupMenu::build():virtual void build(Widget parent)build() builds the menu as a child of the parent widget, but does not install an event handler to post the menu.Once you have built the menu, you can post it with ID="Ch05_Menus179"VkPopupMenu::show():virtual void show(XEvent *buttonPressEvent)show() requires an X ButtonPress event as an argument to position the menu on the screen. This requires you to register your own event handler to handle the ButtonPress events.build() and show() supports applications that wish to control the posting of menus directly. Normally, attach() provides an easier way to use popup menus.LBL="" HELPID=""Popup Menu ExampleID="Ch05_Menus180"IDREF="13559" TYPE="TEXT"Example 5-7 shows an example of using a VkPopupMenu class.LBL="5-7"Example 5-7 ID="13559"Example of Using a VkPopupMenu Object//////////////////////////////////////////////////////////////////
// Sample program that demonstrates how to create a popup menu
/////////////////////////////////////////////////////////////////
#include <Vk/VkApp.h>
#include <Vk/VkWindow.h>
#include <Vk/VkPopupMenu.h>
#include <stream.h>
#include <Xm/Label.h>

class MyWindow: public VkWindow {

  private:

    VkPopupMenu *_popup;

    static void sampleCallback( Widget,  XtPointer , XtPointer);
    void sample();

    static VkMenuDesc subMenu[];
    static VkMenuDesc sampleMenuPane[];

  protected:


  public:
 
    MyWindow( const char *name);
    ~MyWindow();

    virtual const char* className();
};

MyWindow::MyWindow( const char *name) : VkWindow( name)
{
    Widget label =  XmCreateLabel(mainWindowWidget(), "a menu", NULL, 0);
 
    _popup = new VkPopupMenu(label, sampleMenuPane, (XtPointer) this);
    
    addView(label); 
}

MyWindow::~MyWindow( )
{

}

const char* MyWindow::className() { return "MyWindow";}

// The menu bar is essentially a set of cascading menu panes, so the
// top level of the menu tree is always defined as a list of submenus


VkMenuDesc MyWindow::sampleMenuPane[] = {
  { LABEL,    "Test Label"},
  { SEPARATOR },
  { ACTION,    "An Action",       &MyWindow::sampleCallback},
  { ACTION,    "Another Action",  &MyWindow::sampleCallback},
  { SUBMENU,   "A Submenu",       NULL, MyWindow::subMenu},
  { END},
};


VkMenuDesc MyWindow::subMenu[] = {
  { ACTION,  "foo",   &MyWindow::sampleCallback},
  { ACTION,  "bar",   &MyWindow::sampleCallback},
  { ACTION,  "baz",   &MyWindow::sampleCallback},
  { END},
};


void MyWindow::sample()
{
    cout << "sample callback" <<  "\n" << flush;
}
void MyWindow::sampleCallback( Widget,  XtPointer clientData  , XtPointer)
{
    MyWindow *obj = (MyWindow *) clientData;
    obj->sample();
}

void main(int argc, char **argv)
{
  VkApp     *myApp    = new VkApp("Menudemo",  &argc,  argv);
  MyWindow  *menuWin  = new MyWindow("MenuWindow");

  menuWin->show();

  myApp->run();
}LBL="" HELPID=""ID="29804"The ViewKit Help MenuThe Help menu, implemented by the ID="Ch05_Menus181"ID="Ch05_Menus182"ID="Ch05_Menus183"ID="Ch05_Menus184"VkHelpPane class, provides a simple user interface to a help system. Note that VkHelpPane does not actually implement a help system; you must link an external help system to your application. For more information on integrating a help system with your application, consult IDREF="91883" TYPE="TITLE"Appendix C, "Using a Help System with ViewKit."LBL="" HELPID=""Implementation of the Help MenuVkHelpPane is a subclass of VkSubMenu. VkHelpPane automatically provides five standard menu items, as shown in IDREF="83122" TYPE="GRAPHIC"Figure 5-5FILE="menu1-4.bw" POSITION="INLINE" SCALE="FALSE"LBL="5-5"Figure 5-5 ID="83122"The ViewKit Help MenuThe first four items interface to an external help system. The help system must provide help request handling and appropriate help messages for the menu item selected:"Click for Help"ID="Ch05_Menus185"Provides context-sensitive help. When the user selects this item, the cursor changes into a question mark. The user can then click on any widget in the application."Overview"ID="Ch05_Menus186"Requests request overview help"Index"ID="Ch05_Menus187"Requests an index of available help topics"Keys & Shortcuts"ID="Ch05_Menus188"Requests help on keys and shortcuts"Product Info" displays the Product Information dialog described in ID="Ch05_Menus189"ID="Ch05_Menus190"IDREF="30388" TYPE="TITLE""Maintaining Product and Version Information". The Product Information dialog has no connection to the help system.Because VkHelpPane is a subclass of VkSubMenu, you can also use the functions provided by VkSubMenu to add custom Help menu items and delete predefined Help menu items.LBL="" HELPID=""Adding the Help Pane to a MenuThe VkMenuBar constructor, described in IDREF="54015" TYPE="TITLE""Menu Bar Constructors", accepts a showHelpPane argument. If this argument is TRUE, the default, then the VkMenuBar constructor automatically creates a VkHelpPane object and installs it in the menu bar.You can create a VkHelpPane object and add it to another menu, for example a popup menu, but you should rarely need to do this.LBL="" HELPID=""X Resources Associated with the Help PaneThe following X resources affect the appearance and behavior of the ID="Ch05_Menus191"ID="Ch05_Menus192"VkHelpPane class:*helpMenu.labelStringThe label for the Help menu (default value "Help")*helpMenu.mnemonicThe Help menu mnemonic (default value "H")*helpMenu.helpOnContextMenuItem.labelStringThe label for the context-sensitive help item (default value "Click for Help")*helpMenu.helpOnContextMenuItem.mnemonicThe context-sensitive help item mnemonic (default value "C")*helpMenu.helpOnContextMenuItem.acceleratorThe context-sensitive help item accelerator (default value "Shift<Key>F1")*helpMenu.helpOnContextMenuItem.acceleratorTextThe context-sensitive help item accelerator label (default value "Shift+F1")*helpMenu.helpOverviewMenuItem.labelStringThe label for the help overview item (default value "Overview")*helpMenu.helpOverviewMenuItem.mnemonicThe help overview item mnemonic (default value "O")*helpMenu.helpIndexMenuItem.labelStringThe label for the help index item (default value "Index")*helpMenu.helpIndexMenuItem.mnemonicThe help index item mnemonic (default value "I")*helpMenu.helpKeysMenuItem.labelStringThe label for the keys and shortcuts item (default value "Keys & Shortcuts")*helpMenu.helpKeysMenuItem.mnemonicThe keys and shortcuts item mnemonic (default value "K")*helpMenu.helpVersionMenuItem*labelStringThe label for the product information item (default value "Product Info")*helpMenu.helpVersionMenuItem*mnemonicThe product information item mnemonic (default value "P")LBL="6"ID="56221"ViewKit Undo Management and Command ClassesMany applications offer users the ability to reverse or "undo" various actions. This chapter describes how ViewKit provides undo support. It also describes how ViewKit supports command classes, commands implemented as classes.IDREF="93468" TYPE="GRAPHIC"Figure 6-1 shows the inheritance graph for ViewKit classes that support undo management and command classes.FILE="Fig6-1.ai" POSITION="INLINE" SCALE="FALSE"LBL="6-1"Figure 6-1 ID="93468"The Inheritance Graph for the ViewKit Classes Supporting Undo Management and Command ClassesID="Ch06_Undo1"LBL="" HELPID=""ID="48591"Undo ManagementThis section describes the ViewKit undo manager, which supports reversing or "undoing" actions.ID="Ch06_Undo2"LBL="" HELPID=""Overview of ViewKit Undo ManagementThe ID="Ch06_Undo3"VkMenuUndoManager class is the basis of ViewKit's undo manager. The ViewKit undo manager provides an easy-to-use method for users to undo commands that they issue to your application.The user interface to the ViewKit undo manager is a single menu item that you add to one of your application's menus. By default, the label of that menu item is "Undo: ID="Ch06_Undo4"last_command", where last_command is the name of the last command the user issued. Whenever the user issues a command, the undo manager automatically updates the menu item to reflect the latest command. To undo the command, the user simply selects the undo manager's menu item.By default, ViewKit's undo manager provides multi-level undo support. The undo manager keeps commands on a stack. When the user undoes a command, the undo manager pops it from the stack, revealing the previously executed command. Once a user has undone at least one command, executing any new command clears the undo stack. Also, executing any non-undoable command clears the undo stack. If you choose, you can also force the undo manager to provide only single-level undo support, where it remembers only the last command the user issued.ID="Ch06_Undo5"You can use the undo manager to support undoing any command, regardless of whether the user issues the command through a menu or through other interface methods (for example, pushbuttons). The undo manager also supports undoing command classes as implemented by the VkAction(3Vk) and VkMenuActionObject(3Vk) classes described in IDREF="77326" TYPE="TITLE""Command Classes". In most cases, all you need to provide for each command is a callback function that reverses the effects of that command.LBL="" HELPID=""Using ViewKit's Undo Manager The programmatic interface to the undo manager is simple to use. Because the ID="Ch06_Undo6"ID="Ch06_Undo7"VkMenuUndoManager class is a subclass of VkMenuItem, you can add it to a menu and manipulate it as you would any other menu item.To add undo support for an undoable menu item (VkMenuAction(3Vk) and VkMenuToggle(3Vk) items), simply provide an undo callback function (a function that reverses the effects of the item's action) when you either statically or dynamically define the menu item. Similarly, to add undo support for a command class (VkAction and VkMenuActionObject objects), you provide a member function to undo the effects of the command. For those action that are not implemented in your application as menu items or action classes, you can add undo callbacks directly to the undo stack.LBL="" HELPID=""Instantiating ViewKit's Undo ManagerDo not directly instantiate a ID="Ch06_Undo8"VkMenuUndoManager object in your program. If you provide an undo callback to any menu item or if you use a subclass of VkAction or VkMenuActionObject in your program, ViewKit automatically creates an instance of VkMenuUndoManager named "Undo". (IDREF="77326" TYPE="TITLE""Command Classes" describes the VkAction and VkMenuActionObject classes.) The <Vk/VkMenuItem.h> header file provides ID="Ch06_Undo9"theUndoManager, a global pointer to this instance. To access the ViewKit undo manager, simply use this global pointer.theUndoManager is actually implemented as a compiler macro that invokes a VkUndoManager access function to return a pointer to the unique instantiation of the VkUndoManager class. Although you should never need to use this access function directly, you might encounter it while debugging a ViewKit application that uses the undo manager.LBL="" HELPID=""Adding the Undo Manager to a MenuYou add the undo manager to a menu just as you would any other menu item: using the ID="Ch06_Undo10"ID="Ch06_Undo11"VkMenu::add() function of the menu object to which you want to add the undo manager. For example, the following line adds the undo manager to a menu pane specified by the variable edit:edit->add(theUndoManager);You cannot include the undo manager in a static menu description; however, you can add the undo manager to a statically-defined menu after creating the menu. To specify the position of the undo manager within the menu, include a position parameter when you add the undo manager. For example, the following line adds the undo manager to the top of a menu pane specified by the variable edit:edit->add(theUndoManager, 0);LBL="" HELPID=""Providing Undo Support for Actions That Are Menu ItemsTo add undo support for an undoable menu item (ID="Ch06_Undo12"ID="Ch06_Undo13"VkMenuAction and VkMenuToggle items), simply provide an undo callback function when you define the menu item. The undo callback function should reverse the effects of the item's action.For example, the following static description describes a "Cut" menu item that executes the callback function cutCallback() when the user selects the item and undoCutCallback() when the user undoes the command:class EditWindow: public VkWindow {
  private:
    static VkMenuDesc editPane[];
    static void cutCallback(Widget, XtPointer, XtPointer);
    static void undoCutCallback(Widget, XtPointer, XtPointer);
    // ...
};

VkMenuDesc EditWindow::editPane[] = {
  { ACTION,   "Cut",   &EditWindow::cutCallback,
                               NULL,   NULL,   &EditWindow::undoCutCallback },
  { END }
};You could do the same thing by adding the menu item dynamically:class EditWindow: public VkWindow {
  private:
    static VkSubMenu *editMenu;
    static void cutCallback(Widget, XtPointer, XtPointer);
    static void undoCutCallback(Widget, XtPointer, XtPointer);
    // ...
};

EditWindow::EditWindow(char *name) : VkWindow(name)
{
  // ...
  editMenu->addAction("Cut", &EditWindow::cutCallback,
                      &EditWindow::undoCutCallback, this);
}LBL="" HELPID=""ID="55982"Providing Undo Support for Actions That Are Not Menu ItemsSometimes you might want to provide undo support for an action not implemented as a menu item (for example, an action invoked by a pushbutton). ViewKit allows you to do this by adding the action directly to the undo stack using ID="Ch06_Undo14"ID="Ch06_Undo15"VkMenuUndoManager::add():void add(const char *name,
         XtCallbackProc undoCallback,
         XtPointer clientData)The name argument provides a name for the action to appear in the undo manager's menu item. The undoCallback argument must be an Xt-style callback function that the undo manager can call to undo the action. The undo manager passes the clientData argument to the undo callback function as client data when it invokes the callback. Following ViewKit conventions as described in IDREF="72493" TYPE="TITLE""Using Xt Callbacks with Components", you should pass the this pointer as client data so that the callback function can retrieve the pointer, cast it to the expected component type, and call a corresponding member function.Noteadd() simply adds an action to the undo stack; it does not "register" a permanent undo callback for an action. Once the undo stack is cleared, the undo information for that action is deleted. If you later perform the action again and you want to provide undo support for that action, you must use add() again to add the action to the undo stack. IDREF="43756" TYPE="TEXT"Example 6-1 shows a simple example of adding an action to the undo stack. The MyComponent constructor creates a pushbutton as part of its widget hierarchy and registers actionCallback() as the button's activation callback function. actionCallback(), in addition to performing an action, adds undoActionCallback() to the undo stack.LBL="6-1"Example 6-1 ID="43756"Adding a Non-Menu Item Directly to the Undo StackMyComponent: public VkComponent {

  public:
    MyComponent(const char *, Widget);
    void actionCallback(Widget, XtPointer, XtPointer);
    void undoActionCallback(Widget, XtPointer, XtPointer);
    // ...
};

MyComponent::MyComponent(const char *, Widget parent)
{
  // ...
  Widget button = XmCreatePushButton(viewWidget, "button", NULL, 0);
  XtAddCallback(button, XmNactivateCallback,
                &MyWindow::actionCallback, (XtPointer) this);
  // ...
}

void MyComponent::actionCallback(Widget w, XtPointer clientData,
                                     XtPointer callData)
{
  // Perform action...

  theUndoManager->add("Action", &MyComponent::undoActionCallback, this);
}LBL="" HELPID=""Providing Undo Support for Command Class ObjectsThe ViewKit classes that support command classes, ID="Ch06_Undo16"ID="Ch06_Undo17"ID="Ch06_Undo18"VkAction and VkMenuActionObject, both require you to override the pure virtual function undoit(), which the undo manager calls to undo an action implemented as a command class. IDREF="77326" TYPE="TITLE""Command Classes" describes how to use VkAction and VkMenuActionObject to implement command classes.LBL="" HELPID=""Enabling and Disabling Multi-level Undo SupportBy default, ID="Ch06_Undo19"ID="Ch06_Undo20"VkMenuUndoManager provides multi-level undo support. The undo manager keeps commands on a stack. When the user undoes a command, the undo manager pops it from the stack, revealing the previously executed command. Once a user has undone at least one command, executing any new command clears the undo stack. Also, executing any undoable command clears the undo stack.Supporting multi-level undo in your application can be difficult. If you prefer to support undoing only the last command executed, you can change the behavior of the undo manager with the ID="Ch06_Undo21"VkMenuUndoManager::multiLevel() function:void multiLevel(Boolean flag)If flag is FALSE, the undo manager remembers only the last command executed.LBL="" HELPID=""Clearing the Undo StackYou can force the undo manager to clear its command stack with the ID="Ch06_Undo22"ID="Ch06_Undo23"VkMenuUndoManager::reset() function:void reset()LBL="" HELPID=""Examining the Undo StackYou can examine the contents of the undo manager's command stack using ID="Ch06_Undo24"ID="Ch06_Undo25"ID="Ch06_Undo26"VkMenuUndoManager::historyList():VkComponentList *historyList()historyList() returns a list of objects representing commands that have been executed and are available to be undone. Commands are listed in order of execution; the last command executed is the last item in the list. All of the objects in the list are subclasses of VkMenuItem. Commands added directly to the undo stack (as described in IDREF="55982" TYPE="TITLE""Providing Undo Support for Actions That Are Not Menu Items") or commands implemented as VkAction objects (as described in IDREF="77326" TYPE="TITLE""Command Classes") appear as VkMenuActionStub objects. VkMenuActionStub is an empty subclass of VkMenuAction.LBL="" HELPID=""Setting the Label of the Undo Manager Menu ItemThe label that the undo manager menu item displays is of the form ID="Ch06_Undo27"ID="Ch06_Undo28"Undo_label:Command_label. Undo_label is the value of the labelXmNlabelString resource of the undo manager. By default, this value is "Undo". You can change this string (for example, for a German-language app-defaults file) by providing a different value for the XmNlabelString resource. For example, you could set the resource as follows:ID="Ch06_Undo29"*Undo.labelString:    AnnulCommand_label is the label for the last executed command registered with the undo manager, determined as follows:For commands executed by menu itemsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'VkMenuAction, VkMenuToggle, or VkMenuActionObject (described in IDREF="77326" TYPE="TITLE""Command Classes") objectsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the label is the item's XmNlabelString resource.For VkAction objects (described in IDREF="77326" TYPE="TITLE""Command Classes"), the undo manager uses the object's "labelString" resource if one is defined, otherwise it uses the VkAction object's name as the label.For actions that you add directly to the undo stack (described in IDREF="55982" TYPE="TITLE""Providing Undo Support for Actions That Are Not Menu Items"), the undo manager uses the action name that you provided when you added the action.LBL="" HELPID=""Example of Using ViewKit's Undo ManagerID="Ch06_Undo30"IDREF="68277" TYPE="TEXT"Example 6-2 shows an example of using the undo manager.LBL="6-2"Example 6-2 ID="68277"Example of Using the Undo Manager////////////////////////////////////////////////////////////////
// Simple example to exercise Vk undo facilities
///////////////////////////////////////////////////////////////
#include <Vk/VkApp.h>
#include <Vk/VkWindow.h>
#include <Vk/VkMenu.h>
#include <Vk/VkMenuItem.h>
#include <Vk/VkSubMenu.h>
#include <stream.h>
#include <Xm/Label.h>
#include <Xm/RowColumn.h>
#include <Xm/PushB.h>

class MyWindow: public VkWindow {
  
  private:
  
    static void pushCallback( Widget,  XtPointer, XtPointer);
    static void undoPushCallback( Widget,  XtPointer, XtPointer);
  
    static void oneCallback( Widget,  XtPointer , XtPointer);
    static void twoCallback( Widget,  XtPointer , XtPointer);
    static void threeCallback( Widget,  XtPointer , XtPointer);
  
    static void undoOneCallback( Widget,  XtPointer , XtPointer);
    static void undoTwoCallback( Widget,  XtPointer , XtPointer);
    static void undoThreeCallback( Widget,  XtPointer , XtPointer);
  
    static void quitCallback( Widget,  XtPointer , XtPointer);
  
    void quit();
    void one();
    void two();
    void three();
    void undoOne();
  
    void undoTwo();
    void undoThree();
  
    static VkMenuDesc appMenuPane[];
    static VkMenuDesc mainMenuPane[];
  
  public:

    MyWindow( const char *name);
    ~MyWindow( );
    virtual const char* className();
};
MyWindow::MyWindow( const char *name) : VkWindow( name) 
{
    Widget rc =  XmCreateRowColumn(mainWindowWidget(), "rc", NULL, 0);
    Widget label =  XmCreateLabel(rc, "an undo test", NULL, 0);
    Widget pb =  XmCreatePushButton(rc, "push", NULL, 0);

    XtAddCallback(pb, XmNactivateCallback, &MyWindow::pushCallback,
                  (XtPointer) this);
    XtManageChild(label);
    XtManageChild(pb);
    
    setMenuBar(mainMenuPane);
    
    VkSubMenu * editMenuPane = addMenuPane("Edit");
    
    editMenuPane->add(theUndoManager);
    
    addView(rc);
}

MyWindow::~MyWindow()
{

}

const char* MyWindow::className() 
{
 return "MyWindow";
}


// The menu bar is essentially a set of cascading menu panes, so the
// top level of the menu tree is always defined as a list of submenus

VkMenuDesc  MyWindow::mainMenuPane[] = {
  { SUBMENU, "Application",  NULL, MyWindow::appMenuPane},
  { END}
};

VkMenuDesc MyWindow::appMenuPane[] = {
  { ACTION,   "Command One",   &MyWindow::oneCallback, NULL, NULL,
                                                 &MyWindow::undoOneCallback },
  { ACTION,   "Command Two",   &MyWindow::twoCallback, NULL, NULL,
                                                 &MyWindow::undoTwoCallback },
  { ACTION,   "Command Three", &MyWindow::threeCallback, NULL, NULL,
                                                 &MyWindow::undoThreeCallback },
  { SEPARATOR },
  { CONFIRMFIRSTACTION,  "Quit",    &MyWindow::quitCallback},
  { END},
};


void MyWindow::one()
{
    cout << "Command One executed" <<  "\n" << flush;
}

void MyWindow::two()
{
    cout << "Command Two executed" <<  "\n" << flush;
}

void MyWindow::three()
{
    cout << "Command Three executed" <<  "\n" << flush;
}

void MyWindow::undoOne()
{
    cout << "Undoing Command One" <<  "\n" << flush;
}

void MyWindow::undoTwo()
{
    cout << "UNdoing Command Two" <<  "\n" << flush;
}

void MyWindow::undoThree()
{
    cout << "Undoing Command Three" <<  "\n" << flush;
}

void MyWindow::oneCallback( Widget,  XtPointer clientData, XtPointer)
{
    MyWindow *obj = (MyWindow *) clientData;
    obj->one();
}
void MyWindow::twoCallback( Widget,  XtPointer clientData, XtPointer)
{
    MyWindow *obj = (MyWindow *) clientData;
    obj->two();
}
void MyWindow::threeCallback( Widget,  XtPointer clientData, XtPointer)
{
    MyWindow *obj = (MyWindow *) clientData;
    obj->three();
}

void MyWindow::undoOneCallback( Widget,  XtPointer clientData, XtPointer)
{
    MyWindow *obj = (MyWindow *) clientData;
    obj->undoOne();
}
void MyWindow::undoTwoCallback( Widget,  XtPointer clientData, XtPointer)
{
    MyWindow *obj = (MyWindow *) clientData;
    obj->undoTwo();
}
void MyWindow::undoThreeCallback( Widget,  XtPointer clientData, XtPointer)
{
    MyWindow *obj = (MyWindow *) clientData;
    obj->undoThree();
}

void MyWindow::quitCallback ( Widget, XtPointer clientData, XtPointer )
{
    MyWindow *obj = (MyWindow*) clientData;
    delete obj;
}


void MyWindow::pushCallback( Widget,  XtPointer clientData, XtPointer)
{
    cout << "doing a push command\n" << flush;

    theUndoManager->add("Push", &MyWindow::undoPushCallback, (XtPointer) clientData);
}

void MyWindow::undoPushCallback( Widget,  XtPointer clientData, XtPointer)
{
    cout << "undoing the push command\n" << flush;
}



main(int argc, char **argv)
{
  VkApp     *app    = new VkApp("Menudemo",  &argc,  argv);
  MyWindow  *win  = new MyWindow("MenuWindow");

  win->show();
  app->run();
}LBL="" HELPID=""ID="77326"Command ClassesThis section describes the ID="Ch06_Undo31"ID="Ch06_Undo32"VkAction class, which supports ViewKit command classes. Command classes allow you to implement actions as objects.LBL="" HELPID=""Overview of Command ClassesNearly every user action in an interactive application can be thought of as a "command." Programmers typically implement commands as functions (callback functions, for example) that are invoked as a result of some user action. This section explores an approach in which each command in a system is modelled as an object.ID="Ch06_Undo33"Representing commands as objects has many advantages. Many commands have some state or data associated with the command, while others may involve a set of related functions. In both cases, a class allows the data and functions associated with a single logical operation to be encapsulated in one place. Because command objects are complete and self-contained, you can queue them for later execution, store them in "history" lists, re-execute them, and so on. Representing commands as objects can also facilitate undoing the command. For example, to prepare to undo a command, you might need to save some state data before executing the command. When you model commands as objects, you can store this information in data members.The VkMenuAction class (described in IDREF="48833" TYPE="TITLE""Menu Actions") implements the command class model to a certain extent in that it allows you to specify callback functions both for performing an action and undoing that action. But the VkMenuAction class does not provide a true command class in that it does not allow you to encapsulate any data or support functions the action might need within a discrete object. Furthermore, you must use the VkMenuAction class within a menu; it does not allow you to implement command classes activated by pushbuttons, text fields, or other input mechanisms.ViewKit provides two abstract classes to implement command classes in an application: ID="Ch06_Undo34"ID="Ch06_Undo35"ID="Ch06_Undo36"VkAction and VkMenuActionObject. VkAction supports commands that do not appear in menus and VkMenuActionObject supports commands that appear in menus. VkAction does not inherit from any other classes, whereas VkMenuActionObject is a subclass of VkMenuAction, which allows you to add instances of it to a menu and manipulate them as you would any other menu item.You can encapsulate with a subclass of VkAction or VkMenuActionObject any data or support functions required to perform an action. Additionally, commands implemented as subclasses of VkAction and VkMenuActionObject automatically register themselves with the ViewKit undo manager whenever you execute them.LBL="" HELPID=""Using Command Classes in ViewKitTo use command classes in ViewKit, you must create a separate subclass for each command in your application.LBL="" HELPID=""Command Class ConstructorsThe syntax of the ID="Ch06_Undo37"ID="Ch06_Undo38"VkAction constructor is:VkAction(const char *name)Each class derived from VkAction should provide a constructor that takes at least one argument: the object's name. All derived class constructors should pass the name to the VkAction constructor to initialize the basic class data members, and then initialize any subclass-specific data members.The syntax of the ID="Ch06_Undo39"VkMenuActionObject constructor is:VkMenuActionObject(const char *name, XtPointer clientData = NULL)Each class derived from VkMenuActionObject should provide a constructor that takes two arguments: the object's name and optional client data. All derived class constructors should pass the name and the client data to the VkMenuActionObject constructor to initialize the basic class data members, and then initialize any subclass-specific data members.The ID="Ch06_Undo40"VkMenuActionObject constructor stores the client data in the protected data member _clientData:void *_clientDataVkMenuActionObject objects do not use the _clientData data member for callback functions. Instead it is simply an untyped pointer that you can use to pass any information your command object might need. For example, you could pass a pointer to another object, a value, a string, or any other value. You can access and manipulate _clientData from member functions of your command subclass.LBL="" HELPID=""Overriding Virtual FunctionsBoth ID="Ch06_Undo41"ID="Ch06_Undo42"ID="Ch06_Undo43"ID="Ch06_Undo44"VkAction and VkMenuActionObject have two protected pure virtual functions that you must override: doit() and undoit():virtual void doit()
virtual void undoit()doit() performs the command class's action; undoit() undoes the action.LBL="" HELPID=""Using Command Classes as Menu ItemsYou can use command classes derived only from ID="Ch06_Undo45"VkMenuActionObject in a ViewKit menu. Because VkAction is not derived from VkMenuItem, it does not provide the services required of a menu item.cannot specify VkMenuActionObject objects in a static menu description; you must add them dynamically using VkMenu::add(), which is described in IDREF="54594" TYPE="TITLE""Functions for Dynamically Creating Menus".LBL="" HELPID=""Activating Command ClassesWhen a user selects a ID="Ch06_Undo46"ID="Ch06_Undo47"VkMenuActionObject command object from a menu, ViewKit executes the command by calling the object's doit() function. ViewKit also automatically registers the command with the undo manager.To activate a command object that is a subclass of ID="Ch06_Undo48"VkAction, call that action's execute() member function:void execute()execute() calls the object's doit() function. execute() also registers the command with the undo manager.NoteDo not call a command object's doit() function directly. If you do, ViewKit cannot register the command with the undo manager. LBL="" HELPID=""Setting the Label Used by Command ClassesYou can set the label of a ID="Ch06_Undo49"VkMenuActionObject command object as you would any other VkMenuItem item: by setting the object's XmNlabelString resource or by calling the object's setLabel() function. IDREF="20461" TYPE="TITLE""Setting Menu Item Labels" describes how to set the label for a menu item.Because ID="Ch06_Undo50"ID="Ch06_Undo51"VkAction objects are command classes and not interface classes, they technically do not have labels; however, the undo manager requires a label that it can display after you have executed a VkAction command. Therefore, ViewKit allows you to set the value of a "labelString" resource for VkAction objects, qualified by the object's name. For example, if you have an instance of a VkAction named "formatPara", you can set the label for this object by providing a value for the "formatPara.labelString" resource:*formatPara:    Format ParagraphIf you do not provide a value for a VkAction object's "labelString" resource, the undo manager uses the object's name as the label.NoteThe VkAction "labelString" resource is a "synthetic" resource, not a widget resource. The only way that you can set the value of this resource is through a resource file. You can't use XtSetValues() because the object contains no widgets, and you can't use setDefaultResources() because VkAction is not a subclass of VkComponent. LBL="7"ID="57775"Using Dialogs in ViewKitThis chapter introduces the basic ViewKit classes needed to create and manipulate the dialogs in a ViewKit application. ID="Ch07_Dialogs1"ID="Ch07_Dialogs2"IDREF="71377" TYPE="GRAPHIC"Figure 7-1 shows the inheritance graph for these classes.FILE="Fig7-1.ai" POSITION="INLINE" SCALE="FALSE"LBL="7-1"Figure 7-1 ID="71377"The Inheritance Graph for the ViewKit Dialog ClassesID="Ch07_Dialogs3"ID="Ch07_Dialogs4"ID="Ch07_Dialogs5"ID="Ch07_Dialogs6"ID="Ch07_Dialogs7"LBL="" HELPID=""Overview of ViewKit Dialog ManagementCreating all of the dialogs your application uses when you start the application is inefficient: the dialogs, which might or might not be displayed, take time to create, consume memory, and tie up server resources. If an application does not create a dialog until it is needed, it is smaller and has faster initial startup time; however, depending on the performance of the system, there may be an unacceptable delay in posting each dialog because the application must create a new dialog for each message.ID="Ch07_Dialogs8"The compromise used by ViewKit is to cache dialogs when they are created. When a particular dialog is no longer needed, the application unmanages that dialog but retains it in the cache. Then, if the cache contains an unused dialog widget when the application needs to post a dialog, the application reuses the cached dialog widget; otherwise it creates a new dialog widget. ViewKit caches up to one dialog of each class for each window in the application (for example, information dialogs and question dialogs are cached separately).The ViewKit dialog classes also offer the following features:single function mechanisms for posting dialogsability to post any dialog in non-blocking, non-modal mode; modal mode; and two blocking modespositioning in multi-window applicationsposting of dialogs even when windows are iconified, if desiredcorrect handling of dialog references when widgets are destroyedLBL="" HELPID=""ViewKit Dialog Class OverviewViewKit encapsulates dialog management, including caching, in the abstract VkDialogManager class that serves as a base class for other, specific dialog classes. Each type of dialog in ViewKit has a separate class derived from VkDialogManager. Each class is responsible for managing its own type of dialog (for example, each class maintains its own dialog cache).The dialog classes provided by ViewKit fall into three categories: information and error dialogs; busy dialogs; and data input dialogs.The information and error dialogs provide feedback to the user about actions or conditions in the application. The dialog classes in this category are:VkInfoDialogDisplays informationVkWarningDialogWarns the user about the consequences of an action (for example, that an action will irretrievably delete items)VkErrorDialogInforms the user of an invalid action (such as entering out-of-range data) or a potentially dangerous condition (for example, the inability to create a backup file)VkFatalErrorDialogInforms the user of a fatal error; the application terminates when the user acknowledges the dialogThe busy dialogs inform the user that an action is underway which might take considerable time. While a busy dialog is displayed, the user cannot interact with the application. The dialog classes in this category are:VkBusyDialogBusy or working dialog displayed while the application is busyVkInterruptDialogBusy or working dialog that allows the user to interrupt the actionThe data input dialogs allow the application to request input from the user. The dialog classes in this category are:VkQuestionDialogAllows the user to select among simple choices by clicking on pushbuttonsVkPromptDialogPrompts the user to enter a text stringVkFileSelectionDialogAllows the user to interactively browse and select a file or directoryVkPrefDialogSupports preference dialogs capable of displaying a wide variety of program-configurable controls that allow the user to observe and set values used by the program. IDREF="12344" TYPE="TITLE"Chapter 8, "Preference Dialogs," discusses preference dialogs.Additionally, ViewKit provides the VkGenericDialog class, an abstract class providing a convenient interface for creating custom dialogs that use the ViewKit interface.Do not directly instantiate dialog manager objects in your program for the predefined dialog types. ViewKit automatically creates an instance of an appropriate dialog manager if you attempt to use a predefined dialog type in your program.The header file for each dialog class provides a global pointer to the instance of that class's dialog manager. The name of the pointer consists of "the" followed by the dialog type. For example, the global pointer to the information dialog manager declared in ID="Ch07_Dialogs9"<Vk/VkInfoDialog.h> is theInfoDialog, the global pointer to the error dialog manager declared in <Vk/VkErrorDialog.h> is theErrorDialog, and so forth. To access the dialog managers in your application, simply use these global pointers. These global pointers are actually implemented as compiler macros that invokes access functions to return pointers to the unique instantiation of the dialog managers. Although you should never need to use these access functions directly, you might encounter them while debugging a ViewKit application that uses dialogs.NoteVkGenericDialog, being an abstract class designed for creating customized dialogs, does not automatically create a dialog manager or provide a global pointer. LBL="" HELPID=""The ViewKit Dialog Base ClassThis section describes the dialog management features provided by the abstract ID="Ch07_Dialogs10"ID="Ch07_Dialogs11"VkDialogManager base class. It describes how to post dialogs, unpost dialogs, set dialog titles, and set dialog button labels. Because all ViewKit dialog management classes are derived from VkDialogManager, the functions and techniques described in this section apply to all dialog management classes.LBL="" HELPID=""ID="30538"Posting DialogsThis section describes the various methods of posting dialogs and provides some simple examples.ID="Ch07_Dialogs12"LBL="" HELPID=""Methods of Posting DialogsViewKit offers four different functions for posting dialogs:ID="Ch07_Dialogs13"ID="Ch07_Dialogs14"post()Posts a non-blocking, non-modal dialog. The function immediately returns, and the application continues to process user input in all windows.ID="Ch07_Dialogs15"ID="Ch07_Dialogs16"postModal()Posts a non-blocking, full-application-modal dialog. The function immediately returns, but the user cannot interact with any application windows until after dismissing the dialog.ID="Ch07_Dialogs17"ID="Ch07_Dialogs18"postBlocked()Posts a blocking, full-application-modal dialog. The user cannot interact with any application windows until after dismissing the dialog. Furthermore, the function does not return until the user dismisses the dialog.ID="Ch07_Dialogs19"ID="Ch07_Dialogs20"postAndWait()Posts a blocking, full-application-modal dialog. The user cannot interact with any application windows until after dismissing the dialog. Furthermore, the function does not return until the user dismisses the dialog. ID="Ch07_Dialogs21"postAndWait() is simpler to use than postBlocked(), but it does not allow as much programming flexibility.post(), postModal(), and postBlocked() accept the same arguments. They are also overloaded identically to allow for almost any combination of arguments without resorting to using NULLs as placeholders. Consult the VkDialogManager(3Vk) reference page for a complete listing of the overloaded versions of the post(), postModal(), and postBlocked() functions. The most general form of the post() function is:virtual Widget post ( const char      *msg = NULL,
                      XtCallbackProc   okCB = NULL,
                      XtCallbackProc   cancelCB = NULL,
                      XtCallbackProc   applyCB = NULL,
                      XtPointer        clientData = NULL,
                      const char      *helpString = NULL,
                      Widget          *parent = NULL)The arguments for these methods are:msgThe message to display in the dialog. This string is first treated as a resource name which is looked up relative to the dialog widget. If it exists, the resource value is used as the message. If the resource does not exist, or if the string contains spaces or newline characters, the string itself is used as the message.ID="Ch07_Dialogs22"Most dialogs are not useful if you do not provide a message argument: they display no text. VkFileDialog and VkPreferenceDialog are exceptions in that they provide their own complex interfaces.okCBAn Xt-style callback function executed when the user clicks on the ID="Ch07_Dialogs23"OK button. (All dialogs except for the VkBusyDialog and VkInterruptDialog dialogs display an OK button by default.)cancelCBAn Xt-style callback function executed when the user clicks on the ID="Ch07_Dialogs24"Cancel button. For many of the dialog classes, ViewKit does not display a Cancel button unless you provide this callback.applyCBAn Xt-style callback function executed when the user clicks on the ID="Ch07_Dialogs25"Apply button. For many of the dialog classes, ViewKit does not display an Apply button unless you provide this callback.clientDataClient data to pass to the button callback functions. Following ViewKit conventions as described in IDREF="72493" TYPE="TITLE""Using Xt Callbacks with Components", you should normally pass the this pointer as client data so that the callback functions can retrieve the pointer, cast it to the expected component type, and call a corresponding member function.helpStringA help string to pass to the help system. See ID="Ch07_Dialogs26"IDREF="91883" TYPE="TITLE"Appendix C, "Using a Help System with ViewKit," for information on the help system. If you provide a string, the dialog displays a ID="Ch07_Dialogs27"Help button.parentThe widget over which ViewKit should display the dialog. If you do not provide a widget, or if the given widget is hidden or iconified, ViewKit posts the dialog over the main window if it is managed and not iconified. (ID="Ch07_Dialogs28"IDREF="76444" TYPE="TITLE""Managing Top-Level Windows" describes how the main window is determined.) If both the widget you specify and the main window are hidden or iconified, ViewKit posts the dialog as a child of the hidden application shell created by the VkApp class. Also see the description of VkDialogManager::centerOnScreen() in IDREF="10512" TYPE="TITLE""Dialog Access and Utility Functions".All versions of the post(), postModal(), and postBlocked() functions return the widget ID of the posted dialog. You should rarely need to use this value.NoteThe arguments that you provide apply only to the dialog posted by the current call to post(), postModal(), and postBlocked(); they have no effect on subsequent dialogs. For example, if you provide an apply callback function to a call to post(), it is used only for the dialog posted by that call. If you want to use that callback for subsequent dialogs, you must provide it as an argument every time you post a dialog. ID="Ch07_Dialogs29"postAndWait() provides a simpler method for posting blocking, application-modal dialogs than using postBlocked(). The most general form of the postAndWait() function is:virtual VkDialogReason postAndWait ( const char      *msg = NULL, 
                                     Boolean          ok = TRUE, 
                                     Boolean          cancel = TRUE, 
                                     Boolean          apply = FALSE, 
                                     const char      *helpString = NULL,
                                     Widget          *parent = NULL)msg is the message to display in the dialog. As with the other posting functions, postAndWait() first treats the string as a resource name which it looks up relative to the dialog widget. If the resource exists, postAndWait() uses the resource value as the message. If postAndWait() finds no resource, or if the string contains spaces or newline characters, it uses the string itself as the message. The next three arguments determine which buttons the dialog should display. A TRUE value displays the button and a FALSE value hides the button. helpString and parent specify a help string and a parent window, just as with the other posting functions.NoteThe arguments that you provide apply only to the dialog posted by the current call to postAndWait(); they have no effect on subsequent dialogs. When you call ID="Ch07_Dialogs30"ID="Ch07_Dialogs31"ID="Ch07_Dialogs32"postAndWait(), ViewKit posts the dialog, enters a secondary event loop, and does not return until the user dismisses the dialog. Unlike postBlocked(), postAndWait() handles all callbacks internally and simply returns an enumerated value of type VkDialogReason indicating which button the user selected. The possible return values are VkDialogManager::OK, VkDialogManager::CANCEL, or VkDialogManager::APPLY. postAndWait() is useful for cases in which it is necessary or convenient not to go on to the next line of code until the user dismisses the dialog. For example:if ( theFileSectionDialog->postAndWait() == VkDialogManager::OK )
    int fd = open( theFileSelectionDialog->fileName(), O_RDONLY);NotepostAndWait() posts dialogs as full-application modal dialogs to minimize potential problems that can be caused by the secondary event loop, but you should be aware that the second event loop is used and be sure that no non-re-entrant code can be called. As with the other functions for posting a dialog, postAndWait() is overloaded to allow for almost any combination of arguments without resorting to using NULLs as placeholders. Consult the VkDialogManager reference page for a complete listing of the overloaded versions of postAndWait().LBL="" HELPID=""Examples of Posting DialogsThe following line posts a simple non-modal, non-blocking information dialog over the application's main window:ID="Ch07_Dialogs33"theInfoDialog->post("You have new mail in your system mailbox");IDREF="14687" TYPE="GRAPHIC"Figure 7-2 shows the appearance of this dialog when posted. Because the call did not provide any callback for the OK button, when the user clicks on the button, ViewKit simply dismisses the dialog.FILE="dialog1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="7-2"Figure 7-2 ID="14687"Example Information DialogYou could also specify the message as an X resource. In the above example, you could name the resource something such as newMailMessage and set it in a resource file with the line:*newMailMessage:  You have new mail in your system mailboxThen you could use the following line to post the information dialog:theInfoDialog->post("newMailMessage");The following line displays a non-modal, non-blocking question dialog over the application's main window:void MailWindow::newMail()
{
  // ...
    theQuestionDialog->post("Read new mail?",
                            &MailWindow::readMailCallback,
                            (XtPointer) this);
  // ...
}IDREF="49218" TYPE="GRAPHIC"Figure 7-3 shows the appearance of this dialog when posted. If the user clicks on the OK button, the program dismisses the dialog and executes the MailWindow::readMailCallback() function. Following ViewKit conventions as described in IDREF="72493" TYPE="TITLE""Using Xt Callbacks with Components", the client data argument is set to the value of the this pointer so that MailWindow::readMailCallback() can retrieve the pointer, cast it to the expected component type, and call a corresponding member function.FILE="dialog2-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="7-3"Figure 7-3 ID="49218"Example Question DialogBecause the call to post() did not provide any callback for the Cancel button, when the user clicks on the button, ViewKit simply dismisses the dialog. If instead you needed to perform some type of cleanup operation when the user clicks on the Cancel button, you would need to provide a callback for the Cancel button:void MailWindow::newMail()
{
  // ...
    theQuestionDialog->post("Read new mail?",
                            &MailWindow::readMailCallback,
                            &MailWindow::cleanupMailCallback,
                            (XtPointer) this);
  // ...
}In general, you should try to encapsulate all dialog callbacks and related information in the subclass of the object with which they are associated. For example, for dialogs that are associated with a specific window, you include all the code related to those dialogs in the subclass definition for that window.This technique is illustrated in IDREF="93162" TYPE="TEXT"Example 7-1, which shows a simple example of using the VkWarningDialog class to post a warning dialog.LBL="7-1"Example 7-1 ID="93162"Example of Posting a Dialog#include <Vk/VkApp.h>
#include <Vk/VkSimpleWindow.h>
#include <Vk/VkWarningDialog.h>
#include <Xm/PushB.h>

class MyWindow: public VkSimpleWindow {

  protected:
    static void postCallback(Widget, XtPointer, XtPointer);

  public:
    MyWindow (const char *name);
    ~MyWindow ( );
    virtual const char* className();
};

MyWindow::MyWindow (const char *name) : VkSimpleWindow (name) 
{
    Widget button =  XmCreatePushButton (mainWindowWidget(), "Push Me",
                                         NULL, 0);
    XtAddCallback(button, XmNactivateCallback, 
                  &MyWindow::postCallback, 
                  (XtPointer) this);
    addView(button);
}

const char* MyWindow::className() { return "MyWindow"; }

MyWindow::~MyWindow()
{
    // Empty
}

void MyWindow::postCallback(Widget, XtPointer clientData, XtPointer)
{
    theWarningDialog->post("Watch Out!!!", NULL,
                            (MyWindow *) clientData);
}

void main ( int argc, char **argv )
{
    VkApp     *app  = new VkApp("Dialog", &argc, argv);
    MyWindow  *win  = new MyWindow("Dialog");

    win->show();
    app->run();
}LBL="" HELPID=""Unposting DialogsAfter posting a dialog, you might encounter situations in which you want to unpost it even though the user has not acknowledged and dismissed it. For example, your application might post an information dialog that the user doesn't bother to acknowledge. At some later point, the information presented in the dialog might no longer be valid, in which case the application should unpost the dialog. In situations such as these, you can use the ID="Ch07_Dialogs34"ID="Ch07_Dialogs35"VkDialogManager::unpost() function to remove the dialog:void unpost()
void unpost(Widget w)If you provide the widget ID of a specific dialog, unpost() dismisses that dialog. Otherwise, unpost() dismisses the most recent dialog of that class posted.If you want to dismiss all dialogs of a given class, you can call the ID="Ch07_Dialogs36"VkDialogManager::unpostAll() function:void unpostAll()For example, the following dismisses all information dialogs currently posted:theInformationDialog->unpostAll();LBL="" HELPID=""Setting the Title of the DialogBy default, ViewKit sets the title of a dialog (displayed in the window manager title bar for the dialog) to the name of the application; however, you have the ability to set dialog titles on both a per-class and per-dialog basis.ID="Ch07_Dialogs37"If you want all dialogs of a certain class to have a title other than the default, you can specify the title with an X resource. For example, you could set the title of all warning dialogs in an application to "Warning" by including the following line in a resource file:*warningDialog.dialogTitle: WarningYou can use the ID="Ch07_Dialogs38"VkDialogManager::setTitle() function to set the title for the next dialog of that class that you post:void setTitle(const char *nextTitle = NULL)setTitle() accepts as an argument a character string. setTitle() first treats the string as a resource name which it looks up relative to the dialog widget. If the resource exists, setTitle() uses the resource value as the dialog title. If setTitle() finds no resource, or if the string contains spaces or newline characters, it uses the string itself as the dialog title.setTitle() affects only the next dialog posted; subsequent dialogs revert to the default title for that class.For example, imagine an editor that uses the question dialog to post two dialogs, one that asks "Do you really want to replace the current buffer?" and one that asks "Do you really want to exit?" If you want different titles for each dialog, you could define resources for each:*replaceTitle: Dangerous Replacement Dialog
*exitTitle: Last Chance Before Exit DialogThen to post the question dialog for replacing the buffer, call:theQuestionDialog->setTitle("replaceTitle");
theQuestionDialog->post("Do you really want to replace the current buffer?",
                         &EditWindow::replaceBufferCallback, 
                         XtPointer) this);IDREF="57378" TYPE="GRAPHIC"Figure 7-4 shows the resulting dialog.FILE="dialog3-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="7-4"Figure 7-4 ID="57378"Example of Setting the Dialog TitleTo post the exit question dialog as a modal dialog, call:theQuestionDialog->setTitle("exitTitle");
theQuestionDialog->postModal("Do you really want to exit?",
                             &EditWindow::replaceBufferCallback,
                             (XtPointer) this);IDREF="57691" TYPE="GRAPHIC"Figure 7-5 shows the resulting dialog.FILE="dialog4-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="7-5"Figure 7-5 ID="57691"Another Example of Setting the Dialog TitleLBL="" HELPID=""Setting the Button LabelsThe button labels (the text that appears on the buttons) used for a dialog are controlled by the XmNokLabelString, XmNcancelLabelString, and XmNapplyLabelString resources. The default values of these resources are respectively "OK", "Cancel", and "Apply".ID="Ch07_Dialogs39"You can use the ID="Ch07_Dialogs40"VkDialogManager::setButtonLabels() function to set the button labels for the next dialog that you post:void setButtonLabels(const char *ok = NULL,
                     const char *cancel = NULL,
                     const char *apply = NULL)setButtonLabels() accepts as arguments up to three character strings: the first string controls the label for the OK button, the second the label for the Cancel button, and the third the label for the Apply button. If you pass NULL as an argument for any of these strings, the corresponding button uses the default label. setTitle() first treats each string as a resource name which it looks up relative to the dialog widget. If the resource exists, setTitle() uses the resource value as the button label. If setTitle() finds no resource, or if the string contains spaces or newline characters, it uses the string itself as the button label.setButtonLabels() affects only the next dialog posted; subsequent dialogs revert to the default button labels.LBL="" HELPID=""ID="10512"Dialog Access and Utility FunctionsThe VkDialogManager class also provides some access and utility functions to help manipulate dialogs.The ID="Ch07_Dialogs41"ID="Ch07_Dialogs42"VkDialogManager::centerOnScreen() function controls the algorithm that ViewKit uses to determine where on the screen to post a dialog:void centerOnScreen(Boolean flag)If flag is TRUE, ViewKit uses the following algorithm:If you provide a parent window argument when you call one of the posting functions, and that window is visible and not iconified, ViewKit posts the dialog over that window.If a) you provide a parent window argument but the window is hidden or iconified, or b) you do not provide a parent window argument, ViewKit creates the dialog as a child of the hidden application shell created by the VkApp class and posts the dialog over that shell. Unless you or the user explicitly sets the geometry for the application, ViewKit centers the application shell on the screen, so the dialog appears centered on the screen.If flag is FALSE, ViewKit uses the following algorithm, which is the default algorithm:If you provide a parent window argument when you call one of the posting functions, and that window is visible and not iconified, ViewKit posts the dialog over that window.If a) you provide a parent window argument but the window is hidden or iconified, or b) you do not provide a parent window argument, ViewKit attempts to create the dialog as a child of the application's main window and post the dialog over that window. (IDREF="76444" TYPE="TITLE""Managing Top-Level Windows" describes how the main window is determined.) If the main window is hidden or iconified, ViewKit creates the dialog as a child of the hidden application shell created by the VkApp class and posts the dialog over that shell. Unless you or the user explicitly sets the geometry for the application, ViewKit centers the application shell on the screen, so the dialog appears centered on the screen.The ID="Ch07_Dialogs43"VkDialogManager::lastPosted() returns the widget ID of the last dialog posted of that class:Widget lastPosted()LBL="" HELPID=""Using the ViewKit Dialog SubclassesThis section describes the features of each ViewKit dialog subclass. In addition to specific member functions listed, each class also supports all functions provided by the VkDialogManager class.LBL="" HELPID=""Information DialogsThe ID="Ch07_Dialogs44"ID="Ch07_Dialogs45"ID="Ch07_Dialogs46"ID="Ch07_Dialogs47"VkInfoDialog class supports standard IRIS IM information dialogs. The global pointer to the information dialog manager, declared in <Vk/VkInfoDialog.h>, is ID="Ch07_Dialogs48"theInfoDialog.Use information dialogs to display useful information. Do not use information dialogs to display error messages, which should be handled by the VkErrorDialog, VkWarningDialog, or VkFatalErrorDialog class.Because the message contained in an information dialog should not require any decision to be made by the user, information dialogs display only the OK button by default. If you need the user to make a selection, you should use another dialog class such as VkQuestionDialog.VkInfoDialog does not provide any additional functions beyond those offered by the VkDialogManager.IDREF="31776" TYPE="TEXT"Example 7-2 shows a simple example of posting an information dialog. Note that the window subclass that posts the dialog defines the dialog title and message as resource values.LBL="7-2"Example 7-2 ID="31776"Example of Posting an Information Dialog#include <Vk/VkWindow.h>
#include <Vk/VkInfoDialog.h>

class MailWindow: public VkWindow {
  public:
    MailWindow(const char*);
    void newMail();
    // ...

  private:
    static String _defaultResources[];
    // ...
};

String MailWindow::_defaultResources[] = {
    "-*newMailMsg:     You have new mail in your system mailbox.",
    "-*newMailTitle:   New Mail",
    NULL
};

MailWindow::MailWindow(const char *name) : VkSimpleWindow (name)
{
    setDefaultResources( mainWindowWidget(), _defaultResources );
    // ...
}

void MailWindow::newMail()
{
    // ...
    theInfoDialog->setTitle("newMailTitle");
    theInfoDialog->post("newMailMsg");
    // ...
}IDREF="96716" TYPE="GRAPHIC"Figure 7-6 shows the appearance of the resulting dialog.FILE="InfoDialog1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="7-6"Figure 7-6 ID="96716"Example of an Information DialogLBL="" HELPID=""Warning DialogsThe ID="Ch07_Dialogs49"ID="Ch07_Dialogs50"ID="Ch07_Dialogs51"ID="Ch07_Dialogs52"VkWarningDialog class supports standard IRIS IM warning dialogs. The global pointer to the warning dialog manager, declared in <Vk/VkWarningDialog.h>, is ID="Ch07_Dialogs53"theWarningDialog.Use VkWarningDialog to warn the user of the consequences of an action. For example, VkWarningDialog is appropriate for warning the user that an action will irretrievably delete information.By default, the dialogs posted by VkWarningDialog contain only an OK button; however, according to Open Software Foundation style guidelines, if you have posted a warning dialog to warn the user about an unrecoverable action, you must allow the user to cancel the destructive action. To add a Cancel button to your warning dialog, simply provide a cancel callback function when you post the dialog.TipIf you perform the action in the warning dialog's OK callback, you can simply define an empty function as a cancel callback. If the user clicks on the warning dialog's OK, button, the ok callback performs the action; if the user clicks on the Cancel button, ViewKit dismisses the dialog without performing any action. VkWarningDialog does not provide any additional functions beyond those offered by the VkDialogManager.LBL="" HELPID=""Error DialogsThe ID="Ch07_Dialogs54"ID="Ch07_Dialogs55"ID="Ch07_Dialogs56"ID="Ch07_Dialogs57"VkErrorDialog class supports standard IRIS IM error dialogs. The global pointer to the error dialog manager, declared in <Vk/VkErrorDialog.h>, is ID="Ch07_Dialogs58"theErrorDialog.Use VkErrorDialog to inform the user of an invalid action (such as entering out-of-range data) or potentially dangerous condition (for example, the inability to create a backup file).The messages contained in the error dialogs should not require any decision to be made by the user. Therefore, the error dialogs display only the OK button by default. If you need the user to make a selection, you should use another dialog class such as VkQuestionDialog.VkErrorDialog does not provide any additional functions beyond those offered by the VkDialogManager.LBL="" HELPID=""Fatal Error DialogsThe ID="Ch07_Dialogs59"ID="Ch07_Dialogs60"ID="Ch07_Dialogs61"ID="Ch07_Dialogs62"ID="Ch07_Dialogs63"ID="Ch07_Dialogs64"VkFatalErrorDialog class supports an error dialog that terminates the application when the user dismisses it. The global pointer to the fatal error dialog manager, declared in <Vk/VkFatalErrorDialog.h>, is ID="Ch07_Dialogs65"theFatalErrorDialog.Use ID="Ch07_Dialogs66"VkFatalErrorDialog only for those errors from which your program cannot recover. For example, VkFatalErrorDialog is appropriate if an application terminates because it cannot open a necessary data file. When the user acknowledges the dialog posted by VkFatalErrorDialog, the application terminates by calling ID="Ch07_Dialogs67"VkApp::terminate() with an error value of 1. IDREF="52836" TYPE="TITLE""Quitting ViewKit Applications" describes the terminate() function.The messages contained in a fatal error dialog should not require any decision to be made by the user. Therefore, the fatal error dialog displays only the OK button by default.VkFatalErrorDialog does not provide any additional functions beyond those offered by the VkDialogManager.LBL="" HELPID=""ID="49996"The Busy DialogThe ID="Ch07_Dialogs68"ID="Ch07_Dialogs69"ID="Ch07_Dialogs70"ID="Ch07_Dialogs71"ID="Ch07_Dialogs72"VkBusyDialog class supports a busy dialog (also called a working dialog in IRIS IM) that is displayed when the application is busy. The global pointer to the busy dialog manager, declared in <Vk/VkBusyDialog.h>, is ID="Ch07_Dialogs73"theBusyDialog.Unlike most other dialog classes, you should not directly post and unpost the busy dialog. VkBusyDialog is used by the VkApp object to display a busy dialog when you place the application in a busy state. The busy dialog is displayed automatically when you call VkApp::busy(), and dismissed automatically when you make a corresponding call to VkApp::notBusy(). VkApp also allows you to use the VkApp::setBusyDialog() function to use a busy dialog other than that provided by VkBusyDialog. Consult IDREF="66712" TYPE="TITLE""Supporting Busy States" for more information about how VkApp handles busy states.Because the busy dialog is intended to lock out user input during a busy state, by default the busy dialog does not display any buttons. If you want to allow the user to interrupt the busy state, you should use the VkApp::setBusyDialog() function to substitute the VkInterruptDialog class object for the normal busy dialog.VkBusyDialog does not provide any additional functions beyond those offered by the VkDialogManager.LBL="" HELPID=""ID="25718"The Interruptible Busy DialogThe ID="Ch07_Dialogs74"ID="Ch07_Dialogs75"ID="Ch07_Dialogs76"ID="Ch07_Dialogs77"VkInterruptDialog class supports an interruptible busy dialog that you can substitute for the normal busy dialog. The dialog posted by the VkInterruptDialog class includes a Cancel button that the user can click on to cancel the current action. The global pointer to the interruptible busy dialog manager, declared in <Vk/VkInterruptDialog.h>, is ID="Ch07_Dialogs78"theInterruptDialog.In addition to those functions offered by the ID="Ch07_Dialogs79"ID="Ch07_Dialogs80"ID="Ch07_Dialogs81"VkDialogManager class, VkInterruptDialog provides the wasInterrupted() member function:Boolean wasInterrupted()Applications that use VkInterruptDialog must periodically call wasInterrupted() to determine whether the user has clicked on the dialog's Cancel button since the last time the function was called. The period of time between checks is up to the application, which must weigh responsiveness against time spent checking.Note that ID="Ch07_Dialogs82"ID="Ch07_Dialogs83"ID="Ch07_Dialogs84"wasInterrupted() also calls VkApp::handlePendingEvents() to process any events that have occurred while the application was busy. Because checking for interrupts involves entering a secondary event loop for a short time, you should beware of any problems with re-entrant code in any callbacks that could be invoked.Also note that you are responsible for performing any cleanup operations required by your application if the user interrupts a process before it is finished (that is, before you would normally call VkApp::notBusy() to end the busy state).ID="Ch07_Dialogs85"ID="Ch07_Dialogs86"VkInterruptDialog also provides the ViewKit callback VkInterruptDialog::interruptedCallback. This callback allows objects to register a member function to be called when the user selects the Cancel button of a VkInterruptDialog dialog. This callback can be called only if the application calls VkInterruptDialog::wasInterrupted().Unlike most other dialog classes, you should not directly post and unpost the interruptible busy dialog. You can use the ID="Ch07_Dialogs87"ID="Ch07_Dialogs88"VkApp::setBusyDialog() function to instruct the VkApp object to use the interruptible busy dialog rather than the normal busy dialog provided by the VkBusyDialog class. The following line shows how you could do this in a program:theApplication->setBusyDialog(theInterruptDialog);The following line instructs the VkApp object to revert back to the normal busy dialog:theApplication->setBusyDialog(NULL);If you instruct the VkApp object to use the interruptible busy dialog, it is displayed automatically when you call VkApp::busy(), and dismissed automatically when you make a corresponding call to VkApp::notBusy(). Consult IDREF="66712" TYPE="TITLE""Supporting Busy States" for more information about how VkApp handles busy states.The code fragment in IDREF="68990" TYPE="TEXT"Example 7-3 installs the interruptible busy dialog and performs a simulated lengthy task, checking for interrupts periodically. After completing the task, the code reinstalls the normal busy dialog.LBL="7-3"Example 7-3 ID="68990"Example of Using the Interruptible Busy Dialogint i;

// Install the interruptible dialog as the dialog
// to post when busy

theApplication->setBusyDialog(theInterruptDialog);

// Start being "busy"

theApplication->busy("Very Busy", (BusyWindow *) clientData);

for(i=0; i<10000; i++)
{
  // Every so often, see if the task was interrupted

  if( theInterruptDialog->wasInterupted() )
  {
    break; // kick out of current task if user interrupts
  }
  sleep(1);
}

// Task done, so we"re not busy anymore

theApplication->notBusy(); 

// Restore the application's busy dialog as the default

theApplication->setBusyDialog(NULL);LBL="" HELPID=""ID="54735"The Question DialogThe ID="Ch07_Dialogs89"ID="Ch07_Dialogs90"ID="Ch07_Dialogs91"ID="Ch07_Dialogs92"VkQuestionDialog class supports standard IRIS IM question dialogs. These allow the user to select among simple choices by clicking on pushbuttons. The global pointer to the question dialog manager, declared in <Vk/VkQuestionDialog.h>, is ID="Ch07_Dialogs93"theQuestionDialog.As described in IDREF="30538" TYPE="TITLE""Posting Dialogs", the post(), postModal(), and postBlocked() functions allow you to specify callback functions to be executed when the user clicks on the OK, Cancel, or Apply button. These callbacks apply only to the dialog posted by the current function call; they do not affect any subsequent dialog postings. You can also provide client data that is passed to all of the callbacks. Following ViewKit conventions as described in IDREF="72493" TYPE="TITLE""Using Xt Callbacks with Components", you should normally pass the this pointer as client data so that the callback functions can retrieve the pointer, cast it to the expected component type, and call a corresponding member function.For the postAndWait() function, instead of providing callbacks, you simply pass a Boolean value for each button specifying whether or not it is displayed. Unlike the other posting functions, the value returned by postAndWait() is an enumerated constant of type VkDialogReason (defined in VkDialogManager). This value is CANCEL, OK, or APPLY, corresponding to the button the user clicked on.By default, VkQuestionDialog displays only the OK and Cancel buttons. VkQuestionDialog displays the Apply button only if you provide a callback for that button.VkQuestionDialog does not provide any additional functions beyond those offered by the VkDialogManager.LBL="" HELPID=""The Prompt DialogThe ID="Ch07_Dialogs94"ID="Ch07_Dialogs95"ID="Ch07_Dialogs96"ID="Ch07_Dialogs97"VkPromptDialog supports standard IRIS IM prompt dialogs that allow the user to enter a text string. The global pointer to the prompt dialog manager, declared in <Vk/VkPromptDialog.h>, is ID="Ch07_Dialogs98"thePromptDialog.You can use VkPromptDialog any time you need to prompt the user to enter a single piece of information. If you need the user to enter more than one value, you should consider whether it is more appropriate to create a preference dialog as described in IDREF="12344" TYPE="TITLE"Chapter 8, "Preference Dialogs." Another option is to create your own custom dialog using VkGenericDialog as described in IDREF="36739" TYPE="TITLE""Deriving New Dialog Classes Using the Generic Dialog".By default, VkPromptDialog displays only the OK and Cancel buttons. VkPromptDialog displays the Apply button only if you provide a callback for that button.One method of obtaining the prompt dialog's text string is to extract it and use it in the OK callback function (and the apply callback function if you provide one). IDREF="22941" TYPE="TEXT"Example 7-4 demonstrates this technique.LBL="7-4"Example 7-4 ID="22941"Extracting the Text String from a Prompt Dialogvoid MailWindow::okCallback(Widget w, XtPointer, clientData, XtPointer callData)
{
    MailWindow *obj = (MailWindow *) clientData;
    obj->ok(w, callData);
}

void MailWindow::ok(Widget dialog, XtPointer callData);
{
    char *_text;
    XmSelectionBoxCallbackStruct *cbs =
                                      (XmSelectionBoxCallbackStruct *) callData;

    XmStringGetLtoR(cbs->value,
                    XmFONTLIST_DEFAULT_TAG,
                    &_text );
    // ...
}Another method of obtaining the text string is to call ID="Ch07_Dialogs99"VkPromptDialog::text() after the user has dismissed the dialog:const char *text()If the user clicks on the OK button, the dialog accepts the currently displayed text as input and uses that string as the return value of text(). If the user clicks the Cancel button, the dialog discards the currently displayed value and any previously-displayed string the dialog might have contain is returned as the value of text(). Do not attempt to free the string returned by text(). Typically, you should call text() only if you post the dialog using postAndWait() and postAndWait() returns a value of VkDialogManager::OK.NoteDo not use text() from within one of the VkPromptDialog callback functions. VkPromptDialog sets the value returned by text() using its own OK callback function. Because IRIS IM does not guarantee the calling order of callback functions, you cannot be certain that text() will return the correct value from within another callback function. CautionBe aware that subsequent posting of ID="Ch07_Dialogs100"thePromptDialog can alter the text value. In rare conditions, if you post non-modal, non-blocking dialogs, this could occur even before you retrieved the value using text(). To prevent this, either retrieve the text string in the OK callback function as shown in IDREF="22941" TYPE="TEXT"Example 7-4, or call text() only after posting the dialog using postAndWait() and verifying that postAndWait() returned the value VkDialogManager::OK).LBL="" HELPID=""The File Selection DialogThe ID="Ch07_Dialogs101"ID="Ch07_Dialogs102"ID="Ch07_Dialogs103"ID="Ch07_Dialogs104"VkFileSelectionDialog class supports standard IRIS IM file selection dialogs (an example of which is shown in IDREF="89709" TYPE="GRAPHIC"Figure 7-7). These allow the user to interactively browse and select a file or directory. The global pointer to the file selection dialog manager, declared in <Vk/VkFileSelectionDialog.h>, is ID="Ch07_Dialogs105"theFileSelectionDialog.FILE="FileSelectDialog1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="7-7"Figure 7-7 ID="89709"Example of a File Selection DialogYou can set the initial directory displayed by the dialog using ID="Ch07_Dialogs106"VkFileSelectionDialog::setDirectory():void setDirectory(const char *directory)If you do not explicitly set a directory, the dialog defaults to the current directory.You can set the initial filter pattern used by the dialog, which determines the files displayed in the list box by using ID="Ch07_Dialogs107"VkFileSelectionDialog::setFilterPattern():void setFilterPattern(const char *pattern)If you do not explicitly set a selection, the dialog displays all files in a directory.You can set the initial selection used of the dialog using ID="Ch07_Dialogs108"VkFileSelectionDialog::setSelection():void setSelection(const char *selection)One method of obtaining the selection string of the file selection dialog is to extract it and use it in the OK callback function. IDREF="99952" TYPE="TEXT"Example 7-5 demonstrates this technique.LBL="7-5"Example 7-5 ID="99952"Extracting the Text String from a File Selection Dialogvoid MailWindow::okCallback(Widget w, XtPointer, clientData, XtPointer callData)
{
    MailWindow *obj = (MailWindow *) clientData;
    obj->ok(w, callData);
}

void MailWindow::ok(Widget dialog, XtPointer callData);
{
    char *_text;
    XmFileSelectionBoxCallbackStruct *cbs =
                                  (XmFileSelectionBoxCallbackStruct *) callData;

    XmStringGetLtoR(cbs->value,
                    XmFONTLIST_DEFAULT_TAG,
                    &_text );
    // ...
}Another method of obtaining the selection string is to call ID="Ch07_Dialogs109"VkFileSelectionDialog::fileName() after the user has dismissed the dialog:const char* fileName()If the user clicks on the OK button, the dialog accepts the currently displayed text as input and uses that string as the return value of fileName(). If the user clicks the Cancel button, the dialog discards the currently displayed value, and any previously-displayed string the dialog might have contained is returned as the value of fileName(). Do not attempt to free the string returned by fileName(). Typically, you should call fileName() only if you post the dialog using postAndWait(), and postAndWait() returns a value of VkDialogManager::OK.NoteDo not use fileName() from within one of the VkFileSelectionDialog callback functions. VkFileSelectionDialog sets the value returned by fileName() using its own OK callback function. Because IRIS IM does not guarantee the calling order of callback functions, you cannot be certain that fileName() will return the correct value from within another callback function. CautionBe aware that subsequent posting of ID="Ch07_Dialogs110"ID="Ch07_Dialogs111"theFileSelectionDialog can alter the selection value. In rare conditions, if you post non-modal, non-blocking dialogs, this could occur even before you retrieve the value using fileName(). To prevent this, either retrieve the selection string in the OK callback function, or call fileName() only after posting the dialog using postAndWait(), and verifying that postAndWait() returned the value VkDialogManager::OK).The following code fragment shows a simple example of using the VkFileSelectionDialog class:#include <iostream.h>
#include <Vk/VkFileSelectionDialog.h>

// ...

theFileSelectionDialog->setDirectory("/usr/tmp");

if(theFileSelectionDialog->postAndWait( ) == VkDialogManager::OK)
  cout << "File name: " << theFileSelectionDialog->fileName()
       << '\n' << flush;LBL="" HELPID=""ID="36739"Deriving New Dialog Classes Using the Generic DialogThe ID="Ch07_Dialogs112"ID="Ch07_Dialogs113"ID="Ch07_Dialogs114"ID="Ch07_Dialogs115"ID="Ch07_Dialogs116"ID="Ch07_Dialogs117"ID="Ch07_Dialogs118"VkGenericDialog class is an abstract subclass of VkDialogManager. It provides a convenient interface for creating custom dialogs that use the ViewKit interface. Custom dialogs that you derive from this class automatically support caching and all the other features supported by VkDialogManager. You can post and manipulate your custom dialogs using the functions provided by VkDialogManager.Minimally, when you derive a new dialog class, you must override the ID="Ch07_Dialogs119"VkGenericDialog::createDialog() function to create the dialog used by your class:virtual Widget createDialog(Widget parent)ViewKit passes to createDialog() the parent widget for the dialog, and createDialog() must return the dialog you create. Your overriding function must first call VkGenericDialog::createDialog(), which creates a MessageBox dialog template. By default, the dialog displays OK and Cancel buttons. Then, you simply add the interface to the MessageBox widget.You can change the buttons displayed by default and other characteristics for your custom dialog by setting certain protected data members:Boolean ID="Ch07_Dialogs120"_showOKSet this value to TRUE (the default) to force the OK button to always appear in your custom dialog. If you set _showOK to FALSE, the OK button appears only if you provide an OK callback function when posting the dialog.Boolean ID="Ch07_Dialogs121"_showCancelSet this value to TRUE (the default) to force the Cancel button to always appear in your custom dialog. If you set _showCancel to FALSE, the Cancel button appears only if you provide a cancel callback function when posting the dialog.Boolean ID="Ch07_Dialogs122"_showApplySet this value to TRUE to force the Apply button to always appear in your custom dialog. If you set _showApply to FALSE (the default), the Apply button appears only if you provide an apply callback function when posting the dialog.Boolean ID="Ch07_Dialogs123"_allowMultipleDialogsThe default behavior of the VkDialogManager class is to allow multiple dialogs of any given type to be posted at once. The VkDialogManager class calls derived classes's createDialog() member function as needed to create additional widgets. For some types of dialogs, it makes more sense to allow only one instance of a particular dialog type to exist at any one time. For example, multiple nested calls to VkApp::busy() should not normally produce multiple dialogs. If you set _allowMultipleDialogs to FALSE, the VkDialogManager class does not create additional dialogs, but reuses an existing dialog in all cases.Boolean ID="Ch07_Dialogs124"_minimizeMultipleDialogsNormally, VkDialogManager caches dialogs on a per-top-level window basis. If there are many top-level windows, this could result in having many dialogs of the same type, which may be undesirable for some types of dialogs, particularly if they are expensive to create. If you set _minimizeMultipleDialogs TRUE, VkDialogManager reuses any existing dialog that is not currently displayed. VkDialogManager creates a new dialog only if all existing instances of the dialog type are currently displayed.Also, by default ViewKit dismisses your dialog whenever the user clicks on either the ID="Ch07_Dialogs125"ID="Ch07_Dialogs126"ID="Ch07_Dialogs127"OK or Cancel button, and keeps the dialog posted whenever the user clicks on the Apply button. You can change this behavior by overriding the functions VkDialogManager::ok(), VkDialogManager::cancel(), and VkDialogManager::apply() respectively:virtual void ok(Widget dialog, XtPointer callData)
virtual void cancel(Widget dialog, XtPointer callData)
virtual void apply(Widget dialog, XtPointer callData)ViewKit calls these functions whenever the user clicks on one of the buttons in the dialog. By default, ok() and cancel() unpost the dialog and apply() is empty. You can override these functions to change the unposting behavior or to perform any other actions you want.LBL="8"ID="12344"Preference DialogsThis chapter introduces the basic ViewKit classes needed to create and manipulate ID="Ch08_Pref1"ID="Ch08_Pref2"ID="Ch08_Pref3"preference dialogs in a ViewKit application. IDREF="56823" TYPE="GRAPHIC"Figure 8-1 shows the inheritance graph for these classes.FILE="Fig8-1.ai" POSITION="INLINE" SCALE="FALSE"LBL="8-1"Figure 8-1 ID="56823"The Inheritance Graph for the ViewKit Preference Dialog ClassesID="Ch08_Pref4"ID="Ch08_Pref5"ID="Ch08_Pref6"ID="Ch08_Pref7"LBL="" HELPID=""Overview of ViewKit Preference DialogsPreference dialogs allow users to customize the behavior of an application. Without high-level support, preference dialogs can take considerable time and effort to write because they can involve large numbers of text input fields, labels, toggle buttons, and other controls. A user expects preference dialogs to work in a specific way, as well. Usually, a user sets a number of preferences and then clicks on an ID="Ch08_Pref8"Apply button or an OK button to apply all changes at once. A user also expects to be able to click on Cancel and return all preferences to their previous state, regardless of how many changes the user might have made.ViewKit supports an easy-to-use collection of classes for building preference dialogs. Rather than dealing directly with widgets, their placement, callbacks, and so on, programmers who use ViewKit can simply create groups of ID="Ch08_Pref9"preference items. These items maintain their own states, which allows an application to simply query each item to see if it has been changed. Layout is handled automatically, and ViewKit provides the ability to apply or revert all preferences to their previous state.LBL="" HELPID=""The ViewKit Preference Dialog ClassIn ViewKit, preference dialogs are implemented as a specialized class of dialog. Specifically, the base preference dialog class, ID="Ch08_Pref10"ID="Ch08_Pref11"VkPrefDialog, is a subclass of VkGenericDialog, which is in turn a subclass of VkDialogManager. Thus, the VkPrefDialog class inherits all of the functions and data members provided by these base classes.However, there are some significant differences in the way you use preference dialogs in your programs compared to the other dialog classes. For the other dialog classes, a single, reusable instance of each type of dialog is sufficient. Details such the message, the button labels, or the dialog title change from posting to posting, but the general dialog behavior remains the same.On the other hand, individual postings of preference dialogs often vary significantly; they usually have greatly different preference items and data structures associated with each preference item. Therefore, unlike the other dialog classes, VkPrefDialog does not create a global instance of a preference dialog. Instead, you must create a separate instance of VkPrefDialog for each preference dialog that you want to display in your program. For very simple preference dialogs (for example, just a few toggle buttons), you might be able to directly instantiate a VkPrefDialog object; however, in most cases you should create a separate subclass of VkPrefDialog for each preference dialog in your application.For each preference dialog, you create a collection of preference items and associate them with the dialog. Each preference item maintains its own state or value, and your program can query the value of preference items as needed. Users can change the values associated with any number of preference items, then click on the Apply button to apply all changes and keep the dialog up, or the OK button to apply all changes and dismiss the dialog. Users can also click on the Cancel button to return all preferences to their last applied values and dismiss the dialog.The VkPrefDialog class also supplies a ViewKit callback named prefCallback. The preference dialog activates this callback whenever the user clicks on the dialog's Apply, OK, or Cancel button.LBL="" HELPID=""The ViewKit Preference Item ClassesThe basis for all ViewKit preference item classes is the abstract class ID="Ch08_Pref12"ID="Ch08_Pref13"ID="Ch08_Pref14"ID="Ch08_Pref15"VkPrefItem, which is derived from VkComponent. All preference items are derived from the base class VkPrefItem, which provides a common set of manipulation functions.Preference items can be divided into three groups: those that implement various controls such as text fields, toggles, and option menus; those that are "ornamental"; and those that arrange other preference items and manage them as a group.The following preference items implement controls:VkPrefTextA text fieldVkPrefToggleA single toggle button (you can group multiple toggle buttons into a VkPrefRadio item, described below, to enforce radio-style behavior of the buttons)VkPrefOptionAn option menuThe following preference items are ornamental:VkPrefLabelA text labelVkPrefSeparatorA separatorVkPrefEmptyA "null" item that you can use to add extra space between other itemsThe following preference items create groups of items:VkPrefGroupDefines a group of related items. You can specify either vertical or horizontal layout; the default is vertical. With a vertical layout, VkPrefGroup pads items so that they take equal space. You have the option of displaying a label for the group.VkPrefRadioA subclass of VkPrefGroup for managing a group of toggle items in a radio box style. You can specify either vertical or horizontal layout; the default is vertical. Items are always padded so that they take equal space. You have the option of displaying a label for the group.VkPrefListDefines a group of related items. The VkPrefList class arranges its items vertically. Unlike VkPrefGroup, items are not padded so that they take equal space; instead, each item takes only as much space as it needs. Also in contrast to VkPrefGroup, VkPrefList does not display any label for the group.Each preference item maintains its own state or value, and your program can query the value of preference items as needed. Preference items automatically handle updating their stored values when the user clicks on the preference dialog's Apply or OK button, and reverting to their previous values when the user clicks on the dialog's Cancel button.LBL="" HELPID=""Example of Building a ViewKit Preference DialogID="Ch08_Pref16"IDREF="14721" TYPE="GRAPHIC"Figure 8-2 shows an example of a preference dialog created using the ViewKit classes.FILE="examplePref.bw" POSITION="INLINE" SCALE="FALSE"LBL="8-2"Figure 8-2 ID="14721"Example of a ViewKit Preference DialogIDREF="89023" TYPE="TEXT"Example 8-1 lists the code used to create this preference dialog.LBL="8-1"Example 8-1 ID="89023"Example of Creating a ViewKit Preference Dialog/////////////////////
//  DocPrefDiag.c++
/////////////////////

#include <Vk/VkApp.h>
#include <Vk/VkPrefDialog.h>
#include <Vk/VkPrefItem.h>

class DocPrefDialog: public VkPrefDialog {

 protected:

 VkPrefLabel *dialogName;
 VkPrefSeparator *sep1;
 VkPrefText *firstPageNumber;
 VkPrefOption *firstPageSide;
 VkPrefGroup *numberGroup;
 VkPrefSeparator *sep2;
 VkPrefToggle *paginSingleSide;
 VkPrefToggle *paginDoubleSide;
 VkPrefRadio *paginationGroup;
 VkPrefSeparator *sep3;
 VkPrefToggle *textQuotes;
 VkPrefToggle *textSpaces;
 VkPrefGroup *textGroup;
 VkPrefList *docList;
 
 static String _defaultResources[];
 virtual Widget createDialog(Widget parent);

 public:

 DocPrefDialog ( const char *name );
 ~DocPrefDialog();
 virtual const char* className();

};


String DocPrefDialog::_defaultResources[] = {
 "*dialogNameBase.labelString: Document Properties",
 "*numberGroupLabel.labelString: Numbering:",
 "*firstPageNumberLabel.labelString: 1st Page #:",
 "*firstPageSideLabel.labelString: 1st Page:",
 "*firstPageRight:   Right",
 "*firstPageLeft:   Left",
 "*paginationGroupLabel.labelString: Pagination:",
 "*paginSingleSideBase.labelString: Single-sided",
 "*paginDoubleSideBase.labelString: Double-sided",
 "*textGroupLabel.labelString: Text:",
 "*textQuotesBase.labelString: Smart Quotes",
 "*textSpacesBase.labelString: Smart Spaces",
 NULL
};

DocPrefDialog::DocPrefDialog ( const char *name ) : VkPrefDialog ( name )
{
 // Empty
}

Widget DocPrefDialog::createDialog(Widget parent) {

 setDefaultResources(parent, _defaultResources);
 
 VkPrefLabel *dialogName = new VkPrefLabel("dialogName");
 
 VkPrefSeparator *sep1 = new VkPrefSeparator("sep1");
 
 VkPrefText *firstPageNumber = new VkPrefText("firstPageNumber");
 
 VkPrefOption *firstPageSide = new VkPrefOption("firstPageSide", 2);
 firstPageSide->setLabel(0, "firstPageRight");
 firstPageSide->setLabel(1, "firstPageLeft");
 
 VkPrefGroup *numberGroup = new VkPrefGroup("numberGroup");
 numberGroup->addItem(firstPageNumber);
 numberGroup->addItem(firstPageSide);
 
 VkPrefSeparator *sep2 = new VkPrefSeparator("sep2");
 
 VkPrefToggle *paginSingleSide = new VkPrefToggle("paginSingleSide");
 VkPrefToggle *paginDoubleSide = new VkPrefToggle("paginDoubleSide");
 
 VkPrefRadio *paginationGroup = new VkPrefRadio("paginationGroup", TRUE);
 paginationGroup->addItem(paginSingleSide);
 paginationGroup->addItem(paginDoubleSide);
 
 VkPrefSeparator *sep3 = new VkPrefSeparator("sep3");
 
 VkPrefToggle *textQuotes = new VkPrefToggle("textQuotes");
 VkPrefToggle *textSpaces = new VkPrefToggle("textSpaces");
 
 VkPrefGroup *textGroup = new VkPrefGroup("textGroup", TRUE);
 textGroup->addItem(textQuotes);
 textGroup->addItem(textSpaces);
 
 VkPrefList *docList = new VkPrefList("docList");
 docList->addItem(dialogName);
 docList->addItem(sep1);
 docList->addItem(numberGroup);
 docList->addItem(sep2);
 docList->addItem(paginationGroup);
 docList->addItem(sep3);
 docList->addItem(textGroup);
 
 setItem(docList);

 Widget base = VkPrefDialog::createDialog(parent);

 return(base);
}

DocPrefDialog::~DocPrefDialog()
{
 // Empty
}

const char* DocPrefDialog::className()
{
 return "DocPrefDialog";
}


void main ( int argc, char **argv )
{
 VkApp *app = new VkApp("PrefDialogDemoApp", &argc, argv);
 DocPrefDialog *docPrefs = new DocPrefDialog("docPrefs");

 docPrefs->show();
 app->run();
}To post this dialog, you simply create an instance of the DocPrefDialog class and use one of the post() functions described in IDREF="30538" TYPE="TITLE""Posting Dialogs". For example:DocPrefDialog *docPref = new DocPrefDialog("docPref");
// ...
docPref->post();You can retrieve the value of a preference item with the getValue() function as described in IDREF="77703" TYPE="TITLE""Getting and Setting Preference Item Values". For example:Boolean smartSpaces;
// ...
smartSpaces = docPref->textSpaces->getValue();LBL="" HELPID=""The ViewKit Preference Item Base ClassAll preference items are derived from an abstract base class, ID="Ch08_Pref17"ID="Ch08_Pref18"VkPrefItem, which defines the structure of ViewKit preference items and provides a common set of manipulation functions.LBL="" HELPID=""ID="33823"Preference Item LabelsMost preference items contain two top-level widgets: a base widget and a label widget. The base widget implements the preference items "control" mechanism (for example, a text field, an option menu, or a toggle button). The label widget (actually implemented as a gadget) displays a text label for the item.ID="Ch08_Pref19"ID="Ch08_Pref20"ID="Ch08_Pref21"ID="Ch08_Pref22"The name of the base widget is the string "Base" appended to the name of the preference item as given in its constructor. The name of the label widget is the string "Label" appended to the name of the preference item as given in its constructor. So, if you create a VkPrefText object named "firstName," the name of the base widget is "firstNameBase" and the name of the label widget is "firstNameLabel."To specify the string that is displayed as the label, you must set the XmNlabelString resource for the label widget. There are various ways to do this:ID="Ch08_Pref23"Use the VkComponent::setDefaultResources() function to provide default resource values. See IDREF="27321" TYPE="TITLE""Creating Preference Dialog Subclasses" for information on using the setDefaultResources() function when you create a subclass of VkPrefDialog.Set resource values in an external app-defaults resource file. Any values you provide in an external file will override values that you set using the VkComponent::setDefaultResources() function. This is useful when your application must support multiple languages; you can provide a separate resource file for each language supported.Set the resource value directly using the XtSetValues() function. Values you set using this method override any values set using either of the above two methods. You should avoid using this method as it "hard codes" the resource values into the code, making them more difficult to change.The code fragment below sets the labels for two VkPrefText items using the first method:LBL="8-2"Example 8-2 ID="64162"Setting Default Resource Values for Preference Items#include <Vk/VkPrefDialog.h>
#include <Vk/VkPrefItem.h>

class NameDialog: public VkPrefDialog {
  public:
    VkPrefText *firstName;
    VkPrefText *lastName;
    // ...

  protected:
    Widget createDialog(Widget)

  private:
    static String _defaultResources[];
    // ...
};

String NameDialog::_defaultResources[] = {
 "*firstNameLabel.labelString:  First Name:",
 "*lastNameLabel.labelString:   Last Name:",
};

Widget NameDialog::createDialog(Widget parent)
{
  setDefaultResources(mainWindowWidget(), _defaultResources);

  firstName = new VkPrefText("firstName");
  lastName = new VkPrefText("lastName");
  VkPrefList *nameList = new VkPrefList("nameList");
  // ...
}Not all items display a label. VkPrefSeparator is an example of this type of preference item. Some preference items, such as VkPrefGroup, allow you to specify in the constructor whether or not you want to display a label for the item. The sections appearing later in this chapter that describe individual preference items discuss how each item uses its label widget.LBL="" HELPID=""ID="77703"Getting and Setting Preference Item ValuesPreference items that allow the user to input informationname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'ID="Ch08_Pref24"ID="Ch08_Pref25"VkPrefText, VkPrefToggle, and VkPrefOptionname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'have values associated with them. Each such item stores its own value internally. This value might or might not match the value currently displayed in the preference dialog. Because users can click on the Cancel button to return all preferences to their last applied values, a preference item must not immediately store a new value that a user enters. Only when the user clicks on the dialog's Apply button or OK button do preference items update their internally-stored values to match the values displayed on the screen.Preference items provide a ID="Ch08_Pref26"ID="Ch08_Pref27"getValue() function that updates the internally-stored value with the currently displayed value and returns the updated value. The getValue() function is not actually declared in the VkPrefItem base class because different types of preference items use different types of values (for example, VkPrefToggle uses a Boolean value whereas VkPrefText uses a character string). Each preference item with an associated value provides its own definition of getValue().The ID="Ch08_Pref28"setValue() function allows you to programmatically set the internally-stored value of a preference item. The setValue() function automatically updates the displayed value to reflect the new internal value. As with the getValue() function, setValue() is not actually declared in the VkPrefItem base class; each preference item with an associated value provides its own definition of setValue().The ID="Ch08_Pref29"VkPrefItem::changed() function checks to see whether or not the user has changed the value displayed on the screen so that it no longer matches the item's internally-stored value:virtual Boolean changed()If the value has changed, changed() returns the Boolean value TRUE; otherwise, it returns FALSE. You should use changed() as a test to determine whether or not you need to call getValue() for a preference item.LBL="" HELPID=""Preference Item Access FunctionsThe ID="Ch08_Pref30"ID="Ch08_Pref31"ID="Ch08_Pref32"ID="Ch08_Pref33"activate() and deactivate() functions control whether or not a preference item is activated:void activate()
void deactivate()If the item is deactivated, the item is "grayed out" on the screen and the user cannot change the item's value. Call activate() to activate an item and deactivate() to deactivate an item.Occasionally you might want to achieve certain effects by manually setting the height of a preference item's label or base widget. The ID="Ch08_Pref34"ID="Ch08_Pref35"ID="Ch08_Pref36"ID="Ch08_Pref37"setLabelHeight() and setBaseHeight() functions each accept as an argument an Xt Dimension value and respectively set the item's label and base widget to the given height:void setLabelHeight(Dimension h)
void setBaseHeight(Dimension h)The ID="Ch08_Pref38"ID="Ch08_Pref39"labelHeight() function returns the current height of the item's label widget, and the baseHeight() function returns the current height of the item's base widget, each expressed as an Xt Dimension value:Dimension labelHeight()
Dimension baseHeight()The ID="Ch08_Pref40"labelWidget() function returns the item's label widget:Widget labelWidget()labelWidget() returns NULL if an item does not have a label widget.The ID="Ch08_Pref41"ID="Ch08_Pref42"type() function returns an enumerated value of type VkPrefItemType that identifies an item's type:virtual VkPrefItemType type()Valid return values are: PI_group, PI_list, PI_radio, PI_text, PI_toggle, PI_option, PI_empty, PI_label, PI_separator, PI_custom, and PI_none.The ID="Ch08_Pref43"isContainer() function returns TRUE if the preference item is one used to group (or contain) other items:virtual Boolean isContainer()Currently, isContainer() returns true for VkPrefGroup, VkPrefRadio, and VkPrefList items.LBL="" HELPID=""The ViewKit Preference Item ClassesThe following sections describe the preference item classes provided by ViewKit. In addition to specific member functions listed, each class also supports all functions provided by the VkPrefItem class.LBL="" HELPID=""Text FieldsThe ID="Ch08_Pref44"ID="Ch08_Pref45"ID="Ch08_Pref46"VkPrefText class supports text field preference items, allowing users to enter text strings. IDREF="50146" TYPE="GRAPHIC"Figure 8-3 shows a simple preference dialog containing a text field preference item.FILE="textPref1.bw" POSITION="INLINE" SCALE="FALSE"LBL="8-3"Figure 8-3 ID="50146"Example of a Text Field Preference ItemThe ID="Ch08_Pref47"VkPrefText constructor has the following form:VkPrefText(const char *name, int columns = 5)The VkPrefText constructor expects as its first argument the name of the preference item. You can optionally provide as a second argument an integer value specifying the default number of columns for the text field.For example, creating the text field shown in IDREF="50146" TYPE="GRAPHIC"Figure 8-3 requires only the line:VkPrefText *name = new VkPrefText("name");To set the label for the text field you must set the XmNlabelString resource of the preference item's label widget. Therefore, to set the label as shown in IDREF="50146" TYPE="GRAPHIC"Figure 8-3, you must set the resource:*nameLabel.labelString: Enter your name:Refer to IDREF="33823" TYPE="TITLE""Preference Item Labels" for more information on setting the label of a preference item.Use the ID="Ch08_Pref48"getValue() function to retrieve the internally-stored value of the text field:char *getValue()getValue() duplicates the internal value and then returns a pointer to the duplicate string. (You should free this string when you no longer need it.) For example, the following line retrieves the value of the name text field shown above:userName = name->getValue();Use the ID="Ch08_Pref49"setValue() function to programmatically set the value of the text field:void setValue(const char *str)setValue() copies the string that you pass as an argument, sets the internally-stored value to that string, and updates the value displayed by the text field. For example, the following line sets the value of the name text field shown above to "John Doe:"name->setValue("John Doe");LBL="" HELPID=""Toggle ButtonsThe ID="Ch08_Pref50"ID="Ch08_Pref51"ID="Ch08_Pref52"VkPrefToggle class supports a single toggle button preference item. You can group multiple toggle buttons using a VkPrefGroup or VkPrefList item, and you can enforce radio-style behavior on a group of toggles by grouping them in a VkPrefRadio item. These classes are discussed later in this chapter.IDREF="68588" TYPE="GRAPHIC"Figure 8-4 shows a simple preference dialog containing a single toggle button preference item.FILE="togglePref1.bw" POSITION="INLINE" SCALE="FALSE"LBL="8-4"Figure 8-4 ID="68588"Example of a Toggle Button Preference ItemThe ID="Ch08_Pref53"VkPrefToggle constructor has the following form:VkPrefToggle(const char *name, Boolean forceLabelFormat = FALSE)The first argument the VkPrefToggle constructor expects is the name of the preference item. For example, creating the toggle button shown in IDREF="68588" TYPE="GRAPHIC"Figure 8-4 requires only the line:VkPrefToggle *erase = new VkPrefToggle("erase");You can provide an optional Boolean value as a second argument to the VkPrefToggle constructor. A TRUE value forces the VkPrefToggle object to create and use a label widget as described in IDREF="33823" TYPE="TITLE""Preference Item Labels". Otherwise, if the value is FALSE, the behavior of the label is determined as described below in IDREF="75847" TYPE="TITLE""Setting Toggle Preference Item Labels." The default value is FALSE.LBL="" HELPID=""ID="75847"Setting Toggle Preference Item LabelsSetting the label for a toggle preference item is more complex than with other preference items. Unlike many of the other preference items, the ToggleButton widget that is the base widget of the ID="Ch08_Pref54"ID="Ch08_Pref55"ID="Ch08_Pref56"VkPrefToggle item includes a text label. Therefore, to set that label, you must set the XmNlabelString resource of the preference item's base widget instead of its label widget. For example, to set the label as shown in IDREF="68588" TYPE="GRAPHIC"Figure 8-4, you must set the resource:*eraseBase.labelString: History EraseThis works for all cases except for when a toggle is an item in a vertical VkPrefGroup or VkPrefRadio item that contains items other than toggles. (A group that contains more than one type of preference item is a non-homogenous group; a group that contains only one type of preference item is a homogenous group.) To understand why this is done, consider first a simple vertical VkPrefGroup containing only two toggles, as shown in IDREF="80100" TYPE="GRAPHIC"Figure 8-5. In this case, the labels appear to the right side of the buttons as they normally do.FILE="toggleGroup1.bw" POSITION="INLINE" SCALE="FALSE"LBL="8-5"Figure 8-5 ID="80100"Toggle Preference Items in a Homogenous Vertical GroupWhen toggle items appear in a homogenous group like the one shown in IDREF="80100" TYPE="GRAPHIC"Figure 8-5, you should set the XmNlabelString resources for the base widgets of the toggle items. For example:*firstToggleBase.labelString:   Toggle One
*secondToggleBase.labelString:  Toggle TwoHowever, the labels for most other preference items appear to the left of the items. Left uncorrected, if a vertical, non-homogenous VkPrefGroup or VkPrefRadio contained a toggle item, the label for the toggle would not align with the other labels.Therefore, in the case of a non-homogenous vertical VkPrefGroup or VkPrefRadio, ViewKit sets the XmNlabelString resource of all toggle items' base widgets to NULL and instead displays their label widgets. The result is that all of the preference items' labels correctly align, as shown in IDREF="75436" TYPE="GRAPHIC"Figure 8-6.FILE="toggleGroup2.bw" POSITION="INLINE" SCALE="FALSE"LBL="8-6"Figure 8-6 ID="75436"Toggle Preference Items in a Non-Homogenous Vertical GroupWhen toggle items appear in a non-homogenous, vertical group like the one shown in IDREF="75436" TYPE="GRAPHIC"Figure 8-6, you should set the XmNlabelString resources for the label widgets of the toggle items rather than the base widgets. For example:*firstToggleLabel.labelString:   Toggle One
*secondToggleLabel.labelString:  Toggle TwoNote that if you provide the Boolean value TRUE as a second argument to the VkPrefToggle constructor, the VkPrefToggle object always creates and uses a label widget instead of using the base widget's text label.Refer to IDREF="33823" TYPE="TITLE""Preference Item Labels" for more information on setting the label of a preference item.LBL="" HELPID=""Getting and Setting Toggle Preference Item ValuesUse the ID="Ch08_Pref57"getValue() function to retrieve the Boolean value of the toggle:Boolean getValue()For example, the following line retrieves the value of the firstToggle toggle shown above:toggleSet = firstToggle->getValue();Use the ID="Ch08_Pref58"setValue() function to programmatically set the value of the toggle:void setValue(Boolean value)setValue() sets the internally-stored value to the Boolean value you pass as an argument, and updates the value displayed by the toggle. For example, the following line sets the value of the secondToggle toggle shown above to TRUE:secondToggle->setValue(TRUE);LBL="" HELPID=""Option MenusThe ID="Ch08_Pref59"ID="Ch08_Pref60"ID="Ch08_Pref61"VkPrefOption class supports option menu preference items, allowing users to select an option from a menu. IDREF="62989" TYPE="GRAPHIC"Figure 8-7 shows a simple preference dialog containing an option menu preference item.FILE="optionPref.bw" POSITION="INLINE" SCALE="FALSE"LBL="8-7"Figure 8-7 ID="62989"Example of an Option Menu Preference ItemThe ID="Ch08_Pref62"VkPrefOption constructor has the following form:VkPrefOption(const char *name, int numEntries)The VkPrefOption constructor expects as its first argument the name of the preference item. The second argument is an integer value specifying the number of entries in the option menu.For example, you can create the option menu shown in IDREF="62989" TYPE="GRAPHIC"Figure 8-7 with the line:VkPrefOption *align = new VkPrefOption("align", 3);LBL="" HELPID=""Setting Option Menu Preference Item LabelsTo set the label for the option menu you must set the XmNlabelString resource of the preference item's label widget. Therefore, to set the label as shown in ID="Ch08_Pref63"ID="Ch08_Pref64"IDREF="62989" TYPE="GRAPHIC"Figure 8-7, you must set the resource:*alignLabel.labelString: AlignmentRefer to IDREF="33823" TYPE="TITLE""Preference Item Labels" for more information on setting the label of a preference item.To set the labels for the individual items in the option menu, use the ID="Ch08_Pref65"setLabel() function:void setLabel(int index, const char *label)setLabel() expects two arguments. The first is an integer value specifying the index of the of the menu item. Menu items are numbered starting with 0.The second setLabel() argument is a character string. This string is first treated as a resource name which is looked up relative to the menu item's widget. If the resource value exists, it is used as the label. If no resource is found, or if the string contains spaces or newline characters, the string itself is used as the label.For example, the following lines set the labels for the option menu items shown in IDREF="62989" TYPE="GRAPHIC"Figure 8-7 directly:align->setLabel(0, "Align Left");
align->setLabel(1, "Align Center");
align->setLabel(2, "Align Right");On the other hand, the following lines set the labels using resource values:align->setLabel(0, "alignLeft");
align->setLabel(1, "alignCenter");
align->setLabel(2, "alignRight");In the second case, you would also have to set the appropriate resource values. You could do so using the setDefaultResources() function, or you could include the following lines in a resource file:*align*alignLeft:    Align Left
*align*alignCenter:  Align Center
*align*alignRight:   Align RightYou can retrieve the label for a given item using the ID="Ch08_Pref66"getLabel() function:char *getLabel(int index)index is the index of the menu item.NotegetLabel() returns the same string that you passed to setLabel() when setting the item's label. Therefore, if you set the item's label by specifying a resource name, getLabel() returns the resource name, not the value of the resource. LBL="" HELPID=""Dynamically Changing the Number of Option Menu ItemsIn the ID="Ch08_Pref67"ID="Ch08_Pref68"VkPrefOption constructor, you must provide an argument specifying the number of elements in the option menu. However, after creating an option menu preference item, you can resize it as needed using the setSize() function:void setSize(int numEntries)setSize() accepts an integer argument specifying the new size of the option menu. If the new size is smaller than the old size, setSize() automatically deletes all unneeded widgets. If the new size is larger, setSize() automatically creates and manages any additional widgets needed.You can determine the current size of an option menu preference item using the ID="Ch08_Pref69"size() function:int size()You can access any of the button widgets contained in the option menu with the ID="Ch08_Pref70"getButton() function:Widget getButton(int index)Simply specify the index of the button you want and getButton() returns the appropriate widget.LBL="" HELPID=""Getting and Setting Option Menu Preference Item ValuesUse the ID="Ch08_Pref71"getValue() function to retrieve the internally-stored value of the option menu:int getValue()getValue() returns an integer value specifying the index of the selected menu entry. For example, the following line retrieves the value of the align text field shown above:alignment = align->getValue();Use the ID="Ch08_Pref72"setValue() function to programmatically set the value of the option menu:void setValue(int index)setValue() sets the internally-stored value to the index value you pass as an argument, and updates the value displayed by the option menu. For example, the following line sets the value of the alignment text field shown above to 1, corresponding to the "Align Center" option:align->setValue(1);LBL="" HELPID=""LabelsThe ID="Ch08_Pref73"ID="Ch08_Pref74"ID="Ch08_Pref75"VkPrefLabel class supports text labels for preference dialogs.NoteVkPrefLabel is useful only in conjunction with VkPrefList. You should not use VkPrefLabel with either VkPrefGroup or VkPrefRadio; VkPrefLabel does not create a label widget and therefore it does not align properly with other items contained in a VkPrefGroup or VkPrefRadio item.IDREF="60945" TYPE="GRAPHIC"Figure 8-8 shows a simple preference dialog containing a label preference item.FILE="labelPref.bw" POSITION="INLINE" SCALE="FALSE"LBL="8-8"Figure 8-8 ID="60945"Example of a Label Preference ItemThe only argument the ID="Ch08_Pref76"VkPrefLabel constructor expects is the name of the preference item:VkPrefLabel(const char *name)For example, creating the label shown in IDREF="60945" TYPE="GRAPHIC"Figure 8-8 requires only the line:VkPrefLabel *dialogName = new VkPrefLabel("dialogName");Many other ViewKit preference items include label widgets in addition to their base widget; however, in the case of the VkPrefLabel item, the label is the base widget. Therefore, in preference item groups, a VkPrefLabel item aligns with other base widgets, not with other label widgets.Because the label that is displayed for a ID="Ch08_Pref77"ID="Ch08_Pref78"VkPrefLabel item is the base widget, you set the label's text by setting the XmNlabelString resource of the item's base widget. Therefore, to set the label as shown in IDREF="60945" TYPE="GRAPHIC"Figure 8-8, you must set the resource:*dialogNameBase.labelString: Document PropertiesRefer to IDREF="33823" TYPE="TITLE""Preference Item Labels" for more information on setting the label of a preference item.LBL="" HELPID=""SeparatorsThe ID="Ch08_Pref79"ID="Ch08_Pref80"ID="Ch08_Pref81"VkPrefSeparator class supports a simple separator for use in preference dialogs.NoteVkPrefSeparator is useful only in conjunction with VkPrefList. You should not use VkPrefSeparator with either VkPrefGroup or VkPrefRadio; VkPrefSeparator does not create a label widget and therefore it does not align properly with other items contained in a VkPrefGroup or VkPrefRadio item. The only argument the ID="Ch08_Pref82"VkPrefSeparator constructor expects is the name of the preference item:VkPrefSeparator(const char *name)For example:VkPrefSeparator *sep = new VkPrefSeparator("sep");LBL="" HELPID="""Empty" Space Preference ItemsThe ID="Ch08_Pref83"ID="Ch08_Pref84"ID="Ch08_Pref85"VkPrefEmpty class provides a "null" item that you can use to add extra space between other items. This preference item is useful only in conjunction with one of the grouping preference items: VkPrefGroup, VkPrefRadio, or VkPrefList.The ID="Ch08_Pref86"VkPrefEmpty constructor accepts no arguments:VkPrefEmpty()For example:VkPrefEmpty *space = new VkPrefEmpty();LBL="" HELPID=""Groups of Preference ItemsViewKit provides three classes for creating groups of items: ID="Ch08_Pref87"ID="Ch08_Pref88"ID="Ch08_Pref89"ID="Ch08_Pref90"ID="Ch08_Pref91"VkPrefGroup, VkPrefRadio, and VkPrefList. Both VkPrefRadio and VkPrefList are implemented as subclasses of VkPrefGroup.LBL="" HELPID=""Comparison of Group Preference ItemsID="Ch08_Pref92"ID="Ch08_Pref93"VkPrefGroup defines a group of related items. You can specify either vertical or horizontal layout; the default is vertical. With a vertical layout, VkPrefGroup pads items so that they take equal space. You have the option of displaying a label for the group.IDREF="64701" TYPE="GRAPHIC"Figure 8-9 shows an example of a vertical VkPrefGroup item with a label. The label is the group item's label widget, not a VkPrefLabel item. The VkPrefGroup item right-aligns the labels for all of the items it contains. (Because the VkPrefToggle items are part of a non-homogenous VkPrefGroup item, you must set the XmNlabelString resources of their label widgets instead of their base widgets, as described in IDREF="75847" TYPE="TITLE""Setting Toggle Preference Item Labels".) Also, all items are allocated the same amount of vertical space. If you were to add a larger item to this group, the group item would allocate for each item the same amount of vertical space.FILE="GroupPrefV1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="8-9"Figure 8-9 ID="64701"Example of a Vertical VkPrefGroup Item with LabelIDREF="28132" TYPE="GRAPHIC"Figure 8-10 shows the same preference items grouped by a horizontal VkPrefGroup item with a label.FILE="GroupPrefH1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="8-10"Figure 8-10 ID="28132"Example of a Horizontal VkPrefGroup Item with LabelID="Ch08_Pref94"VkPrefList is similar to VkPrefGroup; however, it supports only a vertical orientation and it does not support displaying a group label. Unlike VkPrefGroup, VkPrefList does not pad its items so that they take equal space; instead, each item takes only as much space as it needs. Typically, you use a VkPrefList item to group other group items. For example, in IDREF="89023" TYPE="TEXT"Example 8-1, the top-level VkPrefList item contained a VkPrefLabel item and two VkPrefGroup itemsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'one vertical and one horizontalname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'separated by two VkPrefSeparator items.VkPrefList is also the only grouping item to which you should add VkPrefLabel or VkPrefSeparator items. You should not use VkPrefLabel or VkPrefSeparator with either VkPrefGroup or VkPrefRadio; they do not create label widgets and therefore do not align properly with other items contained in a VkPrefGroup or VkPrefRadio item.IDREF="73589" TYPE="GRAPHIC"Figure 8-11 shows an example of a VkPrefList. Note that the VkPrefList item does not contain a group label; if you want to provide a label for a VkPrefList item, you can include a VkPrefLabel item in it. Also note that the VkPrefList item does not align the labels of the items it contains. (Because the VkPrefToggle items are part of a VkPrefList item, you must set the XmNlabelString resources of their base widgets instead of their label widgets, as described in IDREF="75847" TYPE="TITLE""Setting Toggle Preference Item Labels".) Each item is allocated only as much vertical space as it needs. If you were to add a larger item to this group, it would not affect the vertical spacing of the other items.FILE="ListPref1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="8-11"Figure 8-11 ID="73589"Example of a VkPrefList ItemID="Ch08_Pref95"VkPrefRadio is almost identical to VkPrefGroup except that you use it only for enforcing radio-style behavior on the VkPrefToggle items that it contains. You should add only VkPrefToggle items to a VkPrefRadio item. Otherwise, VkPrefRadio supports the same functionality as VkPrefGroup.IDREF="48289" TYPE="GRAPHIC"Figure 8-12 shows an example of a vertical VkPrefRadio item with a label. The label is the group item's label widget, not a VkPrefLabel item. Because the VkPrefToggle items are part of a homogenous VkPrefRadio item, you must set the XmNlabelString resources of their base widgets instead of their label widgets, as described in IDREF="75847" TYPE="TITLE""Setting Toggle Preference Item Labels".FILE="RadioPrefV1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="8-12"Figure 8-12 ID="48289"Example of a Vertical VkPrefRadio Item with LabelLBL="" HELPID=""Creating Group Preference ItemsThe ID="Ch08_Pref96"ID="Ch08_Pref97"VkPrefGroup constructor has the following form:VkPrefGroup(const char *name,  
            Boolean horizOrientation = FALSE,
            Boolean noLabel = FALSE)The VkPrefGroup constructor expects as its first argument the name of the preference item. The second argument is an optional Boolean value that determines the orientation of the group; FALSE, the default value, specifies a vertical orientation and TRUE specifies a horizontal orientation. The third argument is an optional Boolean value that determines whether or not to display a label for the group; FALSE, the default value, specifies that the group should display the label and TRUE specifies that the group should not display the label.For instance, IDREF="89023" TYPE="TEXT"Example 8-1 contained the following constructor:VkPrefGroup *numberGroup = new VkPrefGroup("numberGroup");This created a new VkPrefGroup item named "numberGroup" with a vertical orientation and a visible label. IDREF="89023" TYPE="TEXT"Example 8-1 also contained the following constructor:VkPrefGroup *horizGroup = new VkPrefGroup("horizGroup",
                                          TRUE, TRUE);This created a new VkPrefGroup item named "horizGroup" with a horizontal orientation and no visible label.The ID="Ch08_Pref98"VkPrefRadio constructor accepts the same arguments as the VkPrefGroup constructor:VkPrefRadio(const char *name, 
            Boolean horizOrientation = FALSE,
            Boolean noLabel = FALSE)For instance, IDREF="89023" TYPE="TEXT"Example 8-1 contained the following constructor:VkPrefRadio *paginationGroup = new VkPrefRadio("paginationGroup");This created a new VkPrefRadio item named "paginationGroup" with a vertical orientation and a visible label.ID="Ch08_Pref99"VkPrefList accepts only one argument, a character string specifying the name of the item:VkPrefList(const char *name)As noted earlier, all VkPrefList items have a vertical orientation and do not display a label. IDREF="89023" TYPE="TEXT"Example 8-1 created a VkPrefList item as the top-level preference item to contain all other preference items:VkPrefList *docList = new VkPrefList("docList");LBL="" HELPID=""Adding and Deleting Preference Items from a Group ItemAfter creating a group item, you can add other items to it with the ID="Ch08_Pref100"ID="Ch08_Pref101"ID="Ch08_Pref102"addItem() function:void addItem(VkPrefItem *item)Preference items appear in the order in which you add them. IDREF="89023" TYPE="TEXT"Example 8-1 added five preference items to the docList preference item:docList->addItem(dialogName);
docList->addItem(sep1);
docList->addItem(numberGroup);
docList->addItem(sep2);
docList->addItem(horizGroup);Once you have added items to a group item, you can access an individual child item with the ID="Ch08_Pref103"ID="Ch08_Pref104"item() function:VkPrefItem *item(int item)Simply provide an integer index value as an argument and item() returns a pointer to the desired preference item. The numbering of preference items within a group begins with 0, so to retrieve a pointer to the numberGroup item added above to docList, you could use the line:item = docList->index(2);The ID="Ch08_Pref105"ID="Ch08_Pref106"size() function returns the number of preference items currently associated with a group item:int size()The ID="Ch08_Pref107"ID="Ch08_Pref108"ID="Ch08_Pref109"deleteChildren() function deletes all the items contained by a group item:virtual void deleteChildren()Note that this function does not just disassociate the items from the parent group item, it actually deletes the items. This is useful for freeing memory in a destructor. ViewKit does not provide any means of disassociating preference items without deleting them or of deleting individual items in a group. This should not pose a problem as most applications create preference dialogs at startup and almost never need to modify them afterwards.LBL="" HELPID=""Monitoring the Values of Preference Items Associated with a Group ItemThe group preference items provide a ID="Ch08_Pref110"ID="Ch08_Pref111"ID="Ch08_Pref112"changed() function just like all other preference items; however changed() operates differently with group items than it does with individual preference items. In group items, changed() calls the changed() functions of all child items in the group and returns TRUE if any of the child items have changed.LBL="" HELPID=""Setting Group Item LabelsTo set the label for a ID="Ch08_Pref113"ID="Ch08_Pref114"VkPrefGroup or VkPrefRadio item, you must set the XmNlabelString resource of the preference item's label widget. (Remember that VkPrefList items do not display labels.) IDREF="89023" TYPE="TEXT"Example 8-1 illustrated this by setting the labels for numerous group items:*numberGroupLabel.labelString:      Numbering:
*paginationGroupLabel.labelString:  Pagination:
*textGroupLabel.labelString:        Text:Refer to IDREF="33823" TYPE="TITLE""Preference Item Labels" for more information on setting the label of a preference item.LBL="" HELPID=""The ViewKit Preference Dialog ClassThe base preference dialog class, VkPrefDialog, is a subclass of VkGenericDialog, which is in turn a subclass of VkDialogManager. Thus, the VkPrefDialog class inherits all of the functions and data members provided by these base classes. For example, you post preference dialogs using the various post() variants, you set a preference dialog's title using the setTitle() function, and you set its button labels using the setButtonLabels() function.LBL="" HELPID=""ID="16382"Creating a Preference DialogUnlike the other dialog classes, ID="Ch08_Pref115"VkPrefDialog does not create a global instance of a preference dialog. Instead, you must create a separate instance of VkPrefDialog for each preference dialog that you want to display in your program. For very simple preference dialogs (for example, just a few toggle buttons), you might be able to directly instantiate a VkPrefDialog object; however, in most cases you should create a separate subclass of VkPrefDialog for each preference dialog in your application. This is described in IDREF="27321" TYPE="TITLE""Creating Preference Dialog Subclasses".The form of the ID="Ch08_Pref116"VkPrefDialog constructor is:VkPrefDialog(const char *name, VkPrefItem *item = NULL)The VkPrefDialog constructor expects as its first argument the name of the preference dialog. The second argument is an optional pointer to a preference item that the dialog should use as the top-level preference item. See ID="Ch08_Pref117"IDREF="83154" TYPE="TITLE""Setting the Preference Items for a Preference Dialog" for more information on setting the top-level preference item.For example, the following line creates a preference dialog named "simplePref":VkPrefDialog *simplePref = new VkPrefDialog("simplePref");LBL="" HELPID=""ID="83154"Setting the Preference Items for a Preference DialogA preference dialog can have only one top-level preference item. In most cases, you use a group item such as ID="Ch08_Pref118"VkPrefList as the top-level item.As described in ID="Ch08_Pref119"IDREF="16382" TYPE="TITLE""Creating a Preference Dialog", you can set the top-level preference item in the VkPrefDialog constructor. You can also set the top-level item with the setItem() function:void setItem(VkPrefItem *item)NoteIf the preference dialog already has a top-level preference item associated with it, setItem() replaces that item with the new item, but does not delete the old item. This allows you to reuse the old preference item later. For example, the following line sets the item docList as the top-level item of the preference dialog simplePref:simplePref->setItem(docList);The ID="Ch08_Pref120"item() function returns a pointer to the top-level item associated with a preference dialog:VkPrefItem *item()LBL="" HELPID=""Posting and Dismissing Preference DialogsYou post preference dialogs using any of the various ID="Ch08_Pref121"ID="Ch08_Pref122"ID="Ch08_Pref123"post() variants provided by the base ViewKit dialog classes. You should not pass a message string argument to the post() function when posting a preference dialog.For example, the following line posts the simplePref dialog as a non-modal, non-blocking dialog:simplePref->post();You should rarely have to unpost a preference dialog programmatically. ViewKit automatically dismisses a preference dialog when the user clicks on either the ID="Ch08_Pref124"ID="Ch08_Pref125"ID="Ch08_Pref126"OK or Cancel button. If for some reason you do need to unpost a preference dialog from your program, use the unpost() function.LBL="" HELPID=""Responding When the User Clicks on a Preference Dialog ButtonWhen the user clicks on the ID="Ch08_Pref127"OK or Apply button on a preference dialog, the dialog automatically applies any change of values to the preference dialog's items by setting the items's internally-stored values so that they match whatever is currently displayed on the screen. If the user clicks on the OK button, the preference dialog calls its hide() function to remove itself from the screen. If the user clicks on the Apply button, the preference dialog remains visible on the screen.When the user clicks on the Cancel button on a preference dialog, the dialog automatically resets all of the dialog's preference items's on-screen values so that they match the items's internally-stored values. Additionally, the preference dialog calls its hide() function to remove itself from the screen.The ID="Ch08_Pref128"ID="Ch08_Pref129"VkPrefDialog class also supplies a ViewKit member function callback named prefCallback. The preference dialog activates this callback whenever the user clicks on the dialog's Apply, OK, or Cancel button. The callback passes as call data an enumerated value of type VkDialogReason, which is defined in VkDialogManager. The value can be any of VkDialogManager::OK, VkDialogManager::APPLY, or VkDialogManager::CANCEL, corresponding to the button that the user clicked on. To notify components in your application when the user changes preferences associated with a preference dialog, register member functions with this ViewKit callback.NoteWhen the user clicks on the OK button, ViewKit first updates the preference items's internally stored values and activates the prefCallback callback with VkDialogManager::APPLY as the call data. Then, ViewKit activates the prefCallback callback with VkDialogManager::OK as the call data. In some ways, this is analogous to a IRIS IM pushbutton performing an activate() action followed by a disarm() action when a user clicks on it. You can use this feature to perform certain actions whenever the user updates preference values by clicking on either the Apply or OK button, and a separate set of actions when the user dismisses the preference dialog by clicking on the OK button. For example, consider a window, myWindow, that is a member of the subclass MyWindow, derived from VkWindow. In this example, assume that there is a preference dialog, displayPrefs, that is a member of the subclass DisplayPrefDialog, derived from VkPrefDialog, that allows the user to specify certain display parameters such as the font. myWindow could register its member function MyWindow::fontChanged() to be called whenever the user clicks a button in the preference dialog displayPrefs, by using the following line of code:displayPrefs->addCallback(VkPrefDialog::prefCallback,
                  this,
                  (VkCallbackMethod) &MyWindow::fontChanged);When MyWindow::fontChanged() is called, it checks to see if any of the parameters in which it is interested have changed and, if so, performs whatever processing is needed. For example:void MyWindow::fontChanged(VkComponent *obj,
                           void *clientData,
                           void *callData)
{
  DisplayPrefDialog *dialog = (DisplayPrefDialog*) obj;
  MyWindow *win = (MyWindow*) clientdata;
  VkDialogManager::VkDialogReason reason =
                  (VkDialogManager::VkDialogReason) callData;
  // If the user clicked on Cancel, nothing changed
  if (reason == VkDialogManager::CANCEL)
    return;
  // Now process new preference values as needed ...
}LBL="" HELPID=""Using Values Set in a Preference DialogTo retrieve the value of a preference item, simply call that item's ID="Ch08_Pref130"getValue() function.This implies that preference items must be accessible to all components that need to use the preference values. For example, if you create a subclass for a preference dialog, declare as "public" those preference items that you want to access outside of the dialog.IDREF="26501" TYPE="TEXT"Example 8-3 shows the header for a NamePref subclass in which two preference items, firstName and lastName, are declared "public." These two preference items can be accessed by other components in the applications.LBL="8-3"Example 8-3 ID="26501"Declaring Preference Items as Publicly Accessibleclass NamePref: public VkPrefDialog {

  protected:
    VkPrefGroup *nameGroup;
 
    static String _defaultResources[];
    virtual Widget createDialog(Widget parent);

  public:
    VkPrefText *firstName;
    VkPrefText *lastName;

    NamePref ( const char *name );
    ~NamePref();
    virtual const char* className();
};The NamePref subclass also contains a group, nameGroup, which is declared "protected." In most cases, outside components would not need to access a group item. One case in which it could be useful to make a group item publicly accessible is if you want other components to be able to activate and deactivate a group of preference items by calling the activate() and deactivate() functions on that group item.LBL="" HELPID=""ID="27321"Creating Preference Dialog SubclassesThe preferred method of handling preference dialogs in ViewKit applications is to create a separate subclass for each preference dialog in the application. Properly designed, a preference dialog can serve as a self-contained component that you can use in multiple applications.ID="Ch08_Pref131"The first step in creating a preference dialog subclass is to decide what preference items to include. List all of the information you want to be able to set with the preference dialog and determine which preference item class is appropriate for each item. For example, an item requiring text input is an obvious candidate for a VkPrefText item. However, an item allowing the user to choose one of several options can be handled by either a single VkPrefOption item or a number of VkPrefToggle items grouped with a VkPrefRadio item. Presumably, you want all of these preference items to be accessible outside of the preference dialog, so you want to declare these items in the "public" section of your class declaration.Then determine the layout you want for the preference dialog. You should group similar items together so that a user can easily find and set related items. The layout determines what group items you need. Usually, you can define these items in the "private" or "protected" section of your class declaration; however, in some cases, you might want to declare some groups as "public." For example, you might want to be able to activate and deactivate a group of preference items by calling the activate() and deactivate() functions on that group item.Then determine how you want to "publicize" changes in preference items to other components in your application. In many cases, those components can simply call the getValue() functions for appropriate items as needed. However, some components need to be notified immediately whenever certain preference items change. In most cases, these components can register ViewKit member function callbacks with the preference dialog that are called whenever the user clicks on one of the dialog's buttons. The components can then test for changes in preference item values in their callback functions and react accordingly.In some cases, you might need to perform special processing when the user clicks on one of the preference dialog's buttons. In that case, you can override the default ok(), apply(), or cancel() function for the dialog. These functions are called whenever the user clicks on the corresponding button. In your override definition, you should perform whatever processing is needed and then call the base VkPrefDialog::ok(), VkPrefDialog::apply(), of VkPrefDialog::cancel() function as appropriate.Usually you should also provide a set of default resource values to serve as labels for all the dialog's preference items. To do so, you must override the createDialog() function, which creates and manages all of the widgets in a preference dialog. Your preference dialog's createDialog() function must perform the following tasks in order:Call setDefaultResources() to set the dialog's default resources.Create all preference items for the dialog.Set the dialog's top-level item using the setItem() function.Call the base VkPrefDialog::createDialog() function to create the dialog.Pass the dialog's base widget, returned by VkPrefDialog::createDialog(), as the return value of createDialog().IDREF="89023" TYPE="TEXT"Example 8-1 shows a complete example of a preference dialog subclass. You could include DocPrefDialog dialogs in any application that needed to set various document parameters.LBL="9"ID="92023"The ViewKit Graph ComponentViewKit provides a high-level component, ID="Ch09_Graph1"ID="Ch09_Graph2"ID="Ch09_Graph3"VkGraph, for displaying and manipulating complex arc-and-node graphs. IDREF="34151" TYPE="GRAPHIC"Figure 9-1 shows the inheritance graph for VkGraph and an auxiliary class, VkNode.FILE="Fig9-1.ai" POSITION="INLINE" SCALE="FALSE"LBL="9-1"Figure 9-1 ID="34151"The Inheritance Graph for the ViewKit Graph ClassesID="Ch09_Graph4"LBL="" HELPID=""Overview of ViewKit GraphsID="Ch09_Graph5"VkGraph is a self-contained ViewKit component for displaying and manipulating complex arc-and-node graphs. The graph can be disconnected and can contain cycles. VkGraph can arrange the nodes horizontally or vertically and change the orientation interactively. VkGraph also provides controls for interactive zooming, node repositioning, and node alignment. IDREF="44263" TYPE="GRAPHIC"Figure 9-2 shows an example of a graph created using the VkGraph component.FILE="graph1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="9-2"Figure 9-2 ID="44263"Example of a Graph Created with VkGraphAll nodes displayed by a VkGraph component must be instances of the VkNode class or subclasses that you derive from it. By default, VkNode creates a SgIconGadget(3x), but if you create a subclass VkNode, you can use any widget for a node.LBL="" HELPID=""ID="83241"The Graph WidgetThe basis of the ID="Ch09_Graph6"VkGraph class is the SgGraph widget, which manages and displays the graph. This section provides an overview of the SgGraph widget. For in-depth information on interacting with the graph widget, consult the SgGraph(3x) man page.A primary responsibility of the SgGraph widget is to clearly and systematically lay out the nodes. The graph layout algorithm is a simple and efficient tree layout algorithm designed to handle forests of nodes. It lays out nodes as a multi-rooted tree.By default, the graph widget created by the ID="Ch09_Graph7"VkGraph class operates in a read-only mode in which the graph widget is used primarily as a layout manager for arranging the node widgets. By modifying certain SgGraph resources, you can also interactively edit the displayed graph, creating and moving arcs and nodes. However, to support most of the functionality of the edit mode, you must provide callback functions and other information to the graph widget so that you can interpret the edit operations and use them in your program. Refer to the SgGraph(3x) man page for details on the resources and callbacks used for edit mode. Also refer to the example in /usr/share/src/ViewKit/ComponentDemos/graph.LBL="" HELPID=""Example of Building a GraphThe process of building and displaying a graph using the ID="Ch09_Graph8"VkGraph component consists of the following steps:Creating the nodesSpecifying node connectivityIndicating which nodes to displayLaying out the graphIDREF="29111" TYPE="TEXT"Example 9-1 illustrates this process by showing the code used to create the graph shown in IDREF="44263" TYPE="GRAPHIC"Figure 9-2.LBL="9-1"Example 9-1 ID="29111"Example of Creating a Graph Using VkGraph#include <Vk/VkApp.h>
#include <Vk/VkWindow.h>
#include <Vk/VkNode.h>
#include <Vk/VkGraph.h>
#include <Vk/VkMenu.h>

class GraphWindow: public VkWindow {

  public:
    GraphWindow( const char *);
    ~GraphWindow();
    virtual const char* className();
  protected:
    VkGraph *graph;
    VkNode *p_node, *c1_node, *c2_node, *gc1_node, *gc2_node;

  private:
    static void quitCallback (Widget, XtPointer, XtPointer);

    static VkMenuDesc appMenuPane[];
};


VkMenuDesc GraphWindow::appMenuPane[] = {
  { ACTION,   "Quit",      &GraphWindow::quitCallback },
  { END }
};

GraphWindow::GraphWindow(const char *name) : VkWindow( name )
{
    // Create nodes

    p_node   = new VkNode("parentNode", "Parent");
    c1_node  = new VkNode("childNode1", "Child 1");
    c2_node  = new VkNode("childNode2", "Child 2");
    gc1_node = new VkNode("grandChildNode1", "Grandchild 1");
    gc2_node = new VkNode("grandChildNode2", "Grandchild 2");
    
    // Create graph

    graph   = new VkGraph( "graph", mainWindowWidget() );

    // Add nodes to graph

    graph->add(p_node, c1_node);     // p_node is parent to c1_node
    graph->add(p_node, c2_node);     // p_node is parent to c2_node
    graph->add(c1_node, gc1_node);   // c1_node is parent to gc1_node
    graph->add(c1_node, gc2_node);   // c1_node is parent to gc2_node

    graph->displayAll();             // Display all nodes in graph
    graph->doLayout();               // Layout the graph
    
    addView(graph);                  // Set graph to be window's view
    addMenuPane("Application", appMenuPane);         // Create menu bar
}
GraphWindow::~GraphWindow()
{
    delete graph;
    delete p_node;
    delete c1_node;
    delete c2_node;
    delete gc1_node;
    delete gc2_node;
}

const char* GraphWindow::className()
{
    return "GraphWindow";
}

void GraphWindow::quitCallback ( Widget, XtPointer, XtPointer )
{
    theApplication->quitYourself();
}

void main(int argc, char **argv)
{
  VkApp       *myApp    = new VkApp("GraphViewer", &argc, argv);
  GraphWindow *graphWin = new GraphWindow("GraphViewer");

  graphWin->show();
  myApp->run();
}This example creates a VkWindow subclass to contain the graph. The graph itself is created in the GraphWindow constructor:The program creates five nodes. These nodes are instances of the VkNode class, which is described in IDREF="78471" TYPE="TITLE""The ViewKit Node Class". The version of the VkNode constructor used in this example accepts a name that is used for internal reference and a label that is displayed.The program creates a VkGraph object. The VkGraph constructor accepts as arguments a name and a parent widget, in this case, the main window widget obtained by mainWindowWidget().The program adds the nodes to the graph using VkGraph::add(). When called with pointers to two nodes, this function associates the nodes with the graph, and marks the first node as being the parent of the second node. In this way, the program specifies the structure of the graph.The program calls VkGraph::displayAll(), which indicates that the graph should display all nodes.The program calls VkGraph::doLayout(), which lays out the graph according to the layout algorithm and manages all widgets associated with the graph.LBL="" HELPID=""Interactive Viewing Features Provided by VkGraphIn addition to displaying a graph, ID="Ch09_Graph9"VkGraph automatically provides controls for interactively manipulating the graph. One set of controls is contained in the control panel, shown in IDREF="18600" TYPE="GRAPHIC"Figure 9-3, which appears along the bottom of the graph.FILE="Ch09_Graph.ras3" POSITION="INLINE" SCALE="FALSE"LBL="9-3"Figure 9-3 ID="18600"The Graph Command PanelThe control panel contains buttons and a menu that allow the user to interactively control various characteristics of the graph's display. Using the control panel the user can:zoom in or outdisplay a graph overviewtoggle between displaying and hiding duplicate arcs connecting nodesalign nodestoggle between horizontal and vertical orientationAdditionally, VkGraph automatically creates popup menus that contain commands that allow the user to hide and display nodes in the graph.LBL="" HELPID=""ID="58092"ZoomingID="Ch09_Graph10"ID="Ch09_Graph11"VkGraph provides eight preset zoom settings that allow the user to shrink or enlarge the size of the graph. The user can directly set the zoom value using the Zoom menu shown in IDREF="60095" TYPE="GRAPHIC"Figure 9-4.FILE="graph1-2.bw" POSITION="INLINE" SCALE="FALSE"LBL="9-4"Figure 9-4 ID="60095"Interactively Changing the Graph Zoom ValueClicking the ID="Ch09_Graph12"Zoom Out button (the down-arrow button immediately to the right of the Zoom menu) changes the zoom setting to the next lower value, and clicking on the ID="Ch09_Graph13"Zoom In button (the up-arrow button to the right of the Zoom Out button) changes the zoom setting to the next higher value.LBL="" HELPID=""ID="80499"Graph OverviewThe user can display an overview of all a graph's visible nodes by clicking on the ID="Ch09_Graph14"ID="Ch09_Graph15"ID="Ch09_Graph16"Graph Overview button.Within the overview window is a viewport that represents the boundaries of the graph visible in the main graph window. The user can click on the viewport and drag it to a new location to change the area visible in the main graph window. As the user drags the viewport, the main graph window scrolls to match the viewport's location in the overview.The overview window also contains an Admin menu with these commands:ID="Ch09_Graph17""Scale to Fit"ID="Ch09_Graph18"Scales the graph in the window to match the aspect ratio of the window."Show Arcs"ID="Ch09_Graph19"Shows the arcs between nodes. This option is turned on by default; if the arcs clutter the window, the user can turn off the option, which removes the arcs from the window."Close"ID="Ch09_Graph20"Closes the overview window.LBL="" HELPID=""ID="74679"Displaying Duplicate ArcsBy default, the graph displays only a single arc between nodes, even if you define multiple connections between the nodes. The user can click on the ID="Ch09_Graph21"ID="Ch09_Graph22"Multiple Arcs button to display multiple arcs between nodes; the graph displays an arc for each connection you defined. The user can turn off multiple-arc display by clicking again on the Multiple Arcs button.LBL="" HELPID=""Realigning NodesOccasionally, as a result of moving or displaying nodes, your graph display might become cluttered. The ID="Ch09_Graph23"ID="Ch09_Graph24"ID="Ch09_Graph25"Realign button "cleans up" the graph display by laying out all visible nodes again.LBL="" HELPID=""Toggling Between Horizontal and Vertical OrientationThe default graph orientation is horizontal. The user can change to a vertical orientation by clicking on the ID="Ch09_Graph26"ID="Ch09_Graph27"Rotate Graph button. The user can return to the horizontal orientation by clicking again on the Rotate Graph button.LBL="" HELPID=""ID="72832"Hiding and Displaying NodesID="Ch09_Graph28"ID="Ch09_Graph29"VkGraph provides controls that allow the user to hide a single node, reveal a node's parents or children, or collapse the part of the graph that branches from a node. To perform any of these actions, the user moves the pointer onto the node and presses the right mouse button to open the popup Node menu. The Node menu contains four commands; only commands applicable to that node are made available. Nonapplicable commands are grayed. The commands are:ID="Ch09_Graph30""Hide Node"ID="Ch09_Graph31"Hides the node and connecting arcs from the graph."Collapse Subgraph"ID="Ch09_Graph32"Hides all descendent nodes and connecting arcs."Show Immediate Children"ID="Ch09_Graph33"Displays the node's immediate child nodes and connecting arcs. This command does not display more than the first subordinate level of nodes."Show Parents"ID="Ch09_Graph34"Displays the node's immediate parent nodes and connecting arcs.LBL="" HELPID=""ID="98260"Edit Mode OperationsThere are additional operations that a user can perform if you set the graph to edit mode, as described in ID="Ch09_Graph35"IDREF="83241" TYPE="TITLE""The Graph Widget". By default, the graph widget created by the VkGraph class operates in read-only mode. You can set the graph widget to edit mode in a VkGraph subclass.NoteTo support much of the functionality of the edit mode, you must provide callback functions and other information to the graph widget so that you can interpret the edit operations and use them in your program. Refer to the SgGraph(3x) man page for details on the resources and callbacks used for edit mode. You must select one or more nodes before you can perform an operation on it. You can select nodes only if the graph is in edit mode. By default, the graph is created in display-only mode.ID="Ch09_Graph36"To perform most operations in edit mode, the user must first select one or more nodes. The user can select a single node by clicking on it with the left mouse button. The graph highlights the selected node. The user can select additional nodes by holding down the <Control> key as he or she clicks on additional nodes with the left mouse button. The user can also select multiple nodes with a bounding box by moving the pointer to a spot on the graph where there is no node or arc, then holding down the left mouse button and dragging out a bounding box. When the button is released, all nodes fully enclosed by the box are selected. (Partially enclosed nodes aren't selected.)The user can deselect nodes by clicking the left mouse button on a blank section of the graph.ID="Ch09_Graph37"The user can move a node by clicking on that node with the middle mouse button and then dragging the node anywhere in the graph window. The user can move several nodes at once by first selecting the nodes and then clicking on any one of the nodes with the middle mouse button and dragging the nodes to their new position.ID="Ch09_Graph38"The popup Selected Nodes menu allows the user to perform an operation on all selected nodes. To open the Selected Nodes menu, the user moves the pointer to any blank area of the graph, and then presses the right mouse button. The menu has three commands:ID="Ch09_Graph39""Hide Selected Nodes"ID="Ch09_Graph40"ID="Ch09_Graph41"Hides all selected nodes and their connecting arcs."Collapse Selected Nodes"ID="Ch09_Graph42"Hides all descendent nodes and connecting arcs of the selected nodes."Expand Selected Nodes"ID="Ch09_Graph43"ID="Ch09_Graph44"Displays the immediate children of all the selected nodes.LBL="" HELPID=""ID="78471"The ViewKit Node ClassID="Ch09_Graph45"ID="Ch09_Graph46"ID="Ch09_Graph47"ID="Ch09_Graph48"VkGraph requires that all nodes that it contains be instances of either the VkNode class or a subclass of VkNode. The VkNode class is responsible for tracking the connectivity, display characteristics, and other features of the nodes. VkNode is a subclass of VkComponent.The VkNode class provides only basic support for interacting with the node widget. In particular, you can set the string displayed as a label through the VkNode constructor; however, you can create subclasses of VkNode that support any widget type, as discussed in IDREF="28113" TYPE="TITLE""Creating Node Subclasses".LBL="" HELPID=""Basic Node FunctionalityThis section describes the basic functionality provided by the VkNode class. Most VkNode functions other than the constructor are for use by VkGraph; however, you might occasionally find some of the utility and access functions useful.LBL="" HELPID=""Node Constructor and DestructorThe ID="Ch09_Graph49"VkNode constructor has two forms:VkNode(const char *name, const char *label = NULL)

VkNode(const char *name, VkNode *parent,
       const char *label = NULL)name is the node's component name. You should provide unique names for all nodes. label is the label that the node displays when visible in a graph. If you do not provide a label, the node uses the component name as the label. You can optionally provide a pointer to an existing node, which the constructor uses as a parent node for the new node.ID="Ch09_Graph50"ID="Ch09_Graph51"As an example, the following line of code creates the node state19 with the internal name "state19" and the label "Indiana":VkNode state19 = new VkNode("state19", "Indiana");The following line of code creates a new node, city41, as a child of state19. The name of the new node is "city41" and the label is "Terre Haute":ID="Ch09_Graph52"VkNode city41 = new VkNode("city41", state19, "Terre Haute");NoteThe VkNode constructor merely initializes internal variables; it does not create any widgets. The VkGraph object of which a VkNode object is a member can create and destroy node widgets as needed. The VkGraph object calls a protected member function, VkNode::build(), whenever it needs to create a node's widget. IDREF="28113" TYPE="TITLE""Creating Node Subclasses" discusses build() in more detail. The ID="Ch09_Graph53"VkNode destructor destroys the node's widget if it exists and deallocates all other internal storage.LBL="" HELPID=""ID="67672"Node Utility FunctionsID="Ch09_Graph54"ID="Ch09_Graph55"VkNode maintains a list of child nodes that you can access using the access functions described in IDREF="67433" TYPE="TITLE""Node Access Functions". By default, the order of the child nodes in this list depends on the order in which you specified the child relationships. The first child node you specify has an index of 0, the second 1, and so on.You can use the VkNode::sortChildren() to sort the immediate child nodes of a node:void sortChildren()The default algorithm used by sortChildren() sorts nodes alphabetically by their internal node names (not their labels).You can direct ID="Ch09_Graph56"VkNode to use a different sort comparison function with VkNode::setSortFunction():static void setSortFunction(VkNodeSortFunction func)The type definition of VkNodeSortFunction is:ID="Ch09_Graph57"typedef int (*VkNodeSortFunction)(VkNode *, VkNode *)The function you provide must be a static function that accepts as arguments two nodes, and returns an integer value less than zero if the first node comes before the second node, zero if the two nodes are equal, and greater than zero if the second node comes before the first node. For example, the following function sorts nodes by their label strings:static int sortNodesByLabel(VkNode *one, VkNode *two)
{
    int value = strcmp(one->label(), two->label());
    return value;
}(IDREF="67433" TYPE="TITLE""Node Access Functions" describes VkNode::label().)LBL="" HELPID=""ID="67433"Node Access FunctionsVkNode provides a number of access functions for obtaining values associated with a node.You can retrieve the node's component name using VkNode::name():char *name() constYou can retrieve the node's label string with ID="Ch09_Graph58"ID="Ch09_Graph59"VkNode::label():virtual char *label()If you did not provide a label string in the node constructor, the value of the label string is the same as the component's name.You can determine the number of parent and child nodes with ID="Ch09_Graph60"ID="Ch09_Graph61"ID="Ch09_Graph62"VkNode::nParents() and VkNode::nChildren() respectively:int nParents() const
int nChildren() constYou can retrieve a specific parent or child node using ID="Ch09_Graph63"ID="Ch09_Graph64"VkNode::parent() and VkNode::child() respectively:VkNode *parent(int index) const
VkNode *child(int index) constBy default, the order of the parent and child nodes depends on the order in which you specified the parent or child relationships. The first parent node you specify has an index of 0, the second 1, and so on. Initially, the child nodes are numbered similarly; however, if you sort the child nodes using the sortChildren() function, the nodes are reordered according to the sort function you used. For example, if you sorted the child nodes alphabetically by component name, the first child node alphabetically has an index of 0, the second 1, and so on.You can find a particular parent or child node by component name using ID="Ch09_Graph65"ID="Ch09_Graph66"ID="Ch09_Graph67"VkNode::findParent() and VkNode::findChild() respectively:VkNode *findParent(char *name)
VkNode *findChild(char *name)These functions return a pointer to the node if found, and NULL if they do not find the node. These functions search only immediate parent or child nodes, not all ancestor or descendent nodes.LBL="" HELPID=""ID="28113"Creating Node SubclassesYou can create subclasses of ID="Ch09_Graph68"VkNode to extend its features in a variety of ways to maintain additional data or to change the way the node displays itself in a graph. Some possibilities include:providing access functions for setting and retrieving resources of the default SgIconGadget(3x) widget provided by the VkNode base classusing widgets other than the default SgIconGadget(3x) widgetcreating additional data members and member functions to store application-specific node informationYou have a great deal of flexibility in deciding how to extend the VkNode class. The important restriction that you must keep in mind is that the VkGraph object of which a VkNode object is a member can create and destroy node widgets as needed. Therefore, in your subclass function definitions you cannot assume that your node's widget exists.The ID="Ch09_Graph69"VkGraph object calls a protected member function, VkNode::build(), whenever it needs to create a node's widget. If you want to use the additional features of the default SgIconGadget widget or if you want to use a different widget in you subclass, you must override build():virtual void build(Widget parent)If you simply want to use the additional features of the default SgIconGadget widget, you can call VkNode::build() from within your subclass's build() function to create the SgIconGadget widget and set the widget's label. Then, you can perform any additional operations you want. (Consult the SgIconGadget(3x) reference page for more information on using this widget.) For example:void MyNode::build(Widget parent)
{
    VkNode::build(parent);
    // Additional setup...
}If you want to use your own widget or widget hierarchy, create the widget(s) using parent as the parent widget, and assign the widget or root of a widget hierarchy to the _baseWidget data member. After creating the _baseWidget, call installDestroyHandler(), as described in IDREF="43744" TYPE="TITLE""Handling Component Widget Destruction".From within a ID="Ch09_Graph70"ID="Ch09_Graph71"VkNode subclass you can also access the _label data member:char *_label_label contains the node's label string as set by the VkNode constructor.LBL="" HELPID=""The ViewKit Graph ClassThis section describes how to build and manipulate graphs using the ID="Ch09_Graph72"VkGraph class. Minimally, you must perform the following actions to build and display a ViewKit graph:Create the VkGraph objectCreate the nodes as instances of VkNode or a subclassAdd the nodes to the graph and specify the node connectivityIndicate which nodes to displayLay out the graphLBL="" HELPID=""The Graph Constructor and DestructorThe ID="Ch09_Graph73"VkGraph constructor is simple with few arguments. You must provide a name and the parent widget for the graph:VkGraph(char *name, Widget parent)The ID="Ch09_Graph74"VkGraph destructor destroys the graph. It does not destroy any VkNode objects that are part of the graph.LBL="" HELPID=""Adding Nodes and Specifying Node ConnectivityAfter you create nodes, you must add them to the graph object you created. Also, if you didn't specify the parent-child relationship for the nodes when you created them, you should supply the remaining connectivity information when adding the nodes to the graph. (See ID="Ch09_Graph75"IDREF="78471" TYPE="TITLE""The ViewKit Node Class" for information on creating nodes.)The ID="Ch09_Graph76"VkGraph::add() function adds nodes to a graph object:virtual int add(VkNode *node)

virtual void add(VkNode *parent, VkNode *child,
                 char *attribute = NULL)If you supply only one node pointer as an argument, add() simply adds the node to the graph. If you have already added the node to the graph, add() does nothing.If you supply two node pointers as arguments, ID="Ch09_Graph77"add() adds both nodes to the graph and establishes the first node as the parent of the second node. If you have already added either node to the graph, add() does not add the node again, but it does establish the parent-child relationship between the nodes.NoteThe second form of add() establishes the parent-child relationship between nodes even if one already exists. Thus, it is possible to have more than one connection between nodes. By default, the graph displays only a single arc between connected nodes, even if you define multiple connections between the nodes. However, as described in IDREF="74679" TYPE="TITLE""Displaying Duplicate Arcs", by clicking on the graph's Multiple Arcs button the user can force the graph to an arc for each connection you defined. To turn off multiple-arc display, the user can click again on the Multiple Arcs button. When specifying a parent/child connection using ID="Ch09_Graph78"ID="Ch09_Graph79"add(), you can specify an attribute for that connection. An attribute is an arbitrary name that you can use to control the appearance of the arc widget that connects the two nodes. For example, assume that you add two nodes to a graph as follows:graph->add(parent, child, "primary");
graph->add(parent, child, "secondary");The resulting graph displays two connecting arcs between the two nodes. You can now specify X resources to control various aspects of the arc. For example:*primary*foreground:      red
*primary*arcDirection:    bidirected
*secondary*foreground:    blue
*secondary*arcDirection:  undirected
*secondary*style:         LineOnOffDashYou can use this method to set many of the resources supported by the SgArc widget. The resources you can specify are: XmNforeground, XmNtoSide, XmNfromSide, XmNfromPosition, XmNtoPosition, XmNarcDirection, XmNfontList, XmNarcWidth, XmNstyle, and XmNdashes. See the SgArc(3x) man page for details on these resources.ID="Ch09_Graph80"The following code fragment creates a graph, creates two nodes, establishes a parent-child relationship between the nodes, and adds the nodes to the graph:graph   = new VkGraph("graph", parent);
p_node  = new VkNode("parentNode", "Parent");
c1_node = new VkNode("childNode1", p_node, "Child 1");
graph->add(p_node);
graph->add(c1_node);Note that in this example, the connection between the two nodes is established when you create c1_node. Therefore, you must add the nodes to the graph using separate calls to add(). If, instead of the two separate calls, you execute:graph->add(p_node, c1_node);then you not only add the two nodes to the graph, but you establish a second connection between the nodes.You can accomplish the same result as above by creating the nodes without providing the parent-child relationship, and then specifying the connection when you add the nodes to the graph. The following code fragment is functionally equivalent to that shown above:graph   = new VkGraph("graph", parent);
p_node  = new VkNode("parentNode", "Parent");
c1_node = new VkNode("childNode1", "Child 1");
graph->add(p_node, c1_node);LBL="" HELPID=""Removing NodesYou can remove nodes from a graph using ID="Ch09_Graph81"ID="Ch09_Graph82"VkGraph::remove():virtual void remove(VkNode *node, Boolean deleteNode = FALSE)By default, remove() removes the node from the graph but does not delete it. If you set the deleteNode argument to TRUE, remove() deletes the node when it removes it.LBL="" HELPID=""ID="74160"Indicating Which Nodes to DisplayOnce you have added all nodes to a graph and specified their connectivity, you must indicate which nodes the graph should display. ID="Ch09_Graph83"ID="Ch09_Graph84"VkGraph provides many functions that allow you to display or hide all of the graph, individual nodes, and portions of node subtrees.After displaying nodes, you should call one of the graph layout member functions as described in IDREF="12635" TYPE="TITLE""Laying Out the Graph". Otherwise, the nodes might not display in desired locations.The basic display functions are ID="Ch09_Graph85"ID="Ch09_Graph86"VkGraph::displayAll() and VkGraph::clearAll():virtual void displayAll()
void clearAll()displayAll() displays all nodes and clearAll() hides all nodes. Typically, after creating your graph, you execute displayAll() to display all of the nodes. For example:graph->displayAll();Sometimes you might want to display only portions of your graph. VkGraph provides functions to operate on either single nodes or subtrees of nodes.The ID="Ch09_Graph87"VkGraph::display() function displays a single node:virtual void display(VkNode *child)
virtual VkNode *display(char *name)You can provide display() with either a pointer to the node or the component name of the node. If you provide the node's name, this function returns a pointer to the node.ID="Ch09_Graph88"ID="Ch09_Graph89"VkGraph::undisplay() hides a single node:virtual void undisplay(VkNode *node)
virtual void hideNode(VkNode *node)VkGraph::hideNode() is equivalent to undisplay().VkGraph also provides a large number of functions that display or hide portions of the graph:ID="Ch09_Graph90"displayWithChildren() displays a node and all of its immediate child nodes (not all descendent nodes). If you provide the node's name, this function returns a pointer to the node.virtual void displayWithChildren(VkNode *node)
virtual VkNode *displayWithChildren(char *name)ID="Ch09_Graph91"expandNode() is functionally equivalent to displayWithChildren() except that it also calls VkGraph::doSubtreeLayout() to lay out the child nodes according to the graph's layout algorithm. See IDREF="12635" TYPE="TITLE""Laying Out the Graph" for more information on doSubtreeLayout().virtual void expandNode(VkNode *node)ID="Ch09_Graph92"displayWithAllChildren() displays a node and all of its descendent nodes. If you provide the node's name, this function returns a pointer to the node.virtual void displayWithAllChildren(VkNode *node)
virtual VkNode *displayWithAllChildren(char *name)ID="Ch09_Graph93"expandSubgraph() is functionally equivalent to displayWithAllChildren() except that it also calls VkGraph::doSubtreeLayout() to lay out the child nodes according to the graph's layout algorithm. See IDREF="12635" TYPE="TITLE""Laying Out the Graph" for more information on doSubtreeLayout().virtual void expandSubgraph(VkNode *node)ID="Ch09_Graph94"hideAllChildren() hides all of a node's descendent nodes. Note that this function does not hide node itself.virtual void hideAllChildren(VkNode *node)ID="Ch09_Graph95"hideWithAllChildren() hides a node and all of its descendent nodes.virtual void hideWithAllChildren(VkNode *node)ID="Ch09_Graph96"displayWithParents() displays a node and all of its immediate parent nodes (not all ancestor nodes). If you provide the node's name, this function returns a pointer to the node.virtual void displayWithParents(VkNode *node)
virtual VkNode *displayWithParents(char *name)ID="Ch09_Graph97"displayWithAllParents() displays a node and all of its ancestor nodes. If you provide the node's name, this function returns a pointer to the node.virtual void displayWithAllParents(VkNode *node)
virtual VkNode *displayWithAllParents(char *name)ID="Ch09_Graph98"hideParents() hides all of a node's immediate parent nodes (not all ancestor nodes). Note that this function does not hide node itself.virtual void hideParents(VkNode *node)ID="Ch09_Graph99"displayParentsAndChildren() displays a node and all of its immediate parent and child nodes (not all ancestor and descendent nodes). If you provide the node's name, this function returns a pointer to the node. Note that this function does display node itself.virtual void displayParentsAndChildren(VkNode *node)
virtual VkNode *displayParentsAndChildren(char *name)ID="Ch09_Graph100"hideParentsAndChildren() hides all of a node's immediate parent and child nodes (not all ancestor and descendent nodes). Note that this function doesnot hide node itself.virtual void hideParentsAndChildren(VkNode *node)You can also create your own functions for determining whether or not nodes are displayed and then use the ID="Ch09_Graph101"VkGraph::displayIf() function to apply those functions:virtual void displayIf(VkGraphFilterProc)The type definition of VkGraphFilterProc is:ID="Ch09_Graph102"typedef Boolean (*VkGraphFilterProc) (VkNode *)The function you provide must be a static function that accepts a node as an arguments and returns TRUE if the node should be displayed.NotedisplayIf() does not hide (that is, call undisplay()) if the filter function returns FALSE for a node. Therefore, if you want to display only those nodes for which the filter function returns TRUE, you must first call clearAll(). For example, the following function displays only those nodes whose names begin with the string "state":static Boolean displayState(VkNode *node)
{
    if ( strcmp("state", node->name(), 5)
        return TRUE;
    else
        return FALSE;
}LBL="" HELPID=""ID="12635"Laying Out the GraphThe final step in displaying a graph is to lay it out. Laying out the graph arranges the widgets in a logical manner and then manages the widgets.ID="Ch09_Graph103"ID="Ch09_Graph104"To lay out the entire graph, call the ID="Ch09_Graph105"VkGraph::doLayout() function, which applies the layout algorithm to the entire graph and then manages all widgets associated with the graph:void doLayout()If you modify the graph after displaying it, or if you allow the user to edit the graph interactively, the graph might become cluttered and you might want to lay out the graph again. To do so you can call doLayout() again to force the graph to reapply the layout algorithm to the graph to clean up the display. As an example, the Realign button provided on the graph command panel simply calls doLayout() whenever the user clicks on the button.If, after displaying the graph, you display any additional nodes (for example, using the ID="Ch09_Graph106"VkGraph::display() function), you must force a layout of the graph to manage all the widgets you created. You can call doLayout() again to do so, but this applies the layout algorithm to the entire graph. Doing so could produce major changes in the layout of the entire graph, which could be disruptive and undesired if the user has previously moved nodes. Also, it could take considerable time if the graph is large. In this case, you can instead call the VkGraph::doSubtreeLayout() function which, given a root node, applies the layout algorithm to just a subtree of the graph:void doSubtreeLayout(VkNode *node)For example, the following code fragment illustrates displaying a graph, graph, and then displaying another node, newNode:// At this point, all nodes are created, the connectivity is
// specified, and certain nodes selected to be displayed

// Lay out and display the graph

graph->doLayout();

// Mark newNode to be displayed

graph->display(newNode);

// Display newNode, re-laying out only the subtree
// under newNode

graph->doSubtreeLayout(newNode);ID="Ch09_Graph107"VkGraph::doSparseLayout() is a special-purpose build and layout function that displays the relationship between a node and its grandparent nodes even if the node's parents are not displayed:void doSparseLayout()doSparseLayout() performs a special build of the graph and whenever it finds a node with an undisplayed parent node, it checks to see whether there are any displayed grandparent nodes. If doSparseLayout() finds such grandparent nodes, it creates a dashed-line arc (instead of a solid-line arc) to connect the node and its grandparent nodes. After finishing the build process, doSparseLayout() performs a layout of the entire graph and manages all widgets associated with the graph.LBL="" HELPID=""Butterfly GraphsSo far, this chapter has discussed creating tree graphs using the ID="Ch09_Graph108"VkGraph class. However, VkGraph also supports butterfly graphs, which display only a central node and its immediate parent and child nodes. The central node of a butterfly graph is called the ID="Ch09_Graph109"butterfly node.ID="Ch09_Graph110"VkGraph can construct a butterfly graph from any graph specification. All you need to do is call VkGraph::displayButterfly() to specify one node as the butterfly node; VkGraph automatically determines which nodes to display:virtual void displayButterfly(VkNode *node)
virtual VkNode *displayButterfly(char *name)Then call VkGraph::doLayout() to lay out the graph as you normally would. For example, assuming that you have already defined a graph specification for a graph called graph, the following code fragment would instruct the graph object to display a butterfly graph centered on the node centerNode:graph->displayButterfly( centerNode );
graph->doLayout();After displaying a butterfly graph, you can use displayButterfly() to specify a new butterfly node and display a different butterfly graph given the same graph specification. For example, the following code fragment illustrates setting a new butterfly node, newCenter, after displaying the butterfly graph in the example above:graph->displayButterfly( newCenter );
graph->doLayout();After displaying a butterfly graph, you can return to displaying a normal tree graph by setting the layout style to XmGRAPH using the ID="Ch09_Graph111"ID="Ch09_Graph112"VkGraph::setLayoutStyle() function:virtual void setLayoutStyle(char type)For example, the following code fragment illustrates displaying the entire graph specified by graph after displaying the butterfly graphs above:graph->setLayoutStyle( XmGRAPH );
graph->displayAll();
graph->doLayout();LBL="" HELPID=""Displaying a Graph OverviewAs discussed in ID="Ch09_Graph113"IDREF="80499" TYPE="TITLE""Graph Overview", by clicking on the Graph Overview button in the graph command panel, a user can display an overview of all a graph's visible nodes.You can also display the overview window programmatically using ID="Ch09_Graph114"ID="Ch09_Graph115"VkGraph::showOverview():void showOverview()Call ID="Ch09_Graph116"ID="Ch09_Graph117"VkGraph::hideOverview() to programmatically hide the overview window:void hideOverview()You can obtain a pointer to the overview window's ID="Ch09_Graph118"VkWindow object using VkGraph::overviewWindow():VkWindow *overviewWindow()LBL="" HELPID=""Graph Utility FunctionsVkGraph provides the following utility functions:ID="Ch09_Graph119"ID="Ch09_Graph120"VkGraph::setZoomOption() sets the zoom value for the graph. Pass to this function the integer index corresponding to the index in the Zoom Menu of the magnification that you want. (IDREF="58092" TYPE="TITLE""Zooming" describes the Zoom Menu and its default values.)virtual void setZoomOption(int index)ID="Ch09_Graph121"ID="Ch09_Graph122"VkGraph::sortAll() sorts all nodes associated with the graph by calling VkNode::sortChildren() on all nodes. (IDREF="67672" TYPE="TITLE""Node Utility Functions" describes VkNode::sortChildren().)void sortAll()ID="Ch09_Graph123"ID="Ch09_Graph124"VkGraph::forAllNodesDo() allows you to perform some action on all nodes registered with a graph. The type definition of VkGraphNodeProc is:ID="Ch09_Graph125"typedef void (*VkGraphNodeProc) (VkNode *)The function you provide must be a static function that accepts a node as an arguments and has a void return value.virtual void forAllNodesDo(VkGraphNodeProc function)ID="Ch09_Graph126"ID="Ch09_Graph127"VkGraph::makeNodeVisible() ensures that a particular node is in the visible portion of the graph's window. If the node you specify is not currently visible, makeNodeVisible() scrolls the graph until the specified node appears in the visible portion of the window.void makeNodeVisible(VkNode *node)ID="Ch09_Graph128"ID="Ch09_Graph129"VkGraph::saveToFile() prompts the users for a file name and saves a PostScriptÆ version of the graph to that file.void saveToFile()ID="Ch09_Graph130"VkGraph::setSize() allows you to pre-allocate space in your graph's internal tables for the number of nodes you specify. If you know how many nodes you plan to add to your graph, calling setSize() before adding nodes to your graph can save time because the graph can allocate all memory needed in one operation instead of expanding the tables dynamically as you add nodes. Your graph can still allocate additional space if you actually add more nodes than you reserved space for using setSize().void setSize(int entries)LBL="" HELPID=""Graph Access FunctionsVkGraph provides the following access functions for obtaining values associated with the graph:ID="Ch09_Graph131"VkGraph::numNodes() returns the number of nodes in the graph.int numNodes()ID="Ch09_Graph132"ID="Ch09_Graph133"VkGraph::find() returns the first VkNode object registered with the VkGraph object that has the given name.VkNode *find(char *name)ID="Ch09_Graph134"ID="Ch09_Graph135"VkGraph::graphWidget() returns the SgGraph widget instantiated by the VkGraph component. Not all the functionality of the SgGraph widget is encapsulated in the VkGraph class, and it is sometimes useful to set various resources directly on the graph widget.Widget graphWidget()ID="Ch09_Graph136"VkGraph::workArea() returns the XmForm widget at the bottom of the VkGraph component, which contains the graph controls. You can use this area to add additional controls.Widget workArea()ID="Ch09_Graph137"VkGraph::twinsButton() returns the Multiple Arcs button widget used to control whether sibling arcs are shown.Widget twinsButton()ID="Ch09_Graph138"VkGraph::relayButton() returns the Realign button widget used to relay the graph.Widget relayButton()ID="Ch09_Graph139"VkGraph::reorientButton() returns the Rotate button widget used to reorient the graph.Widget reorientButton()LBL="" HELPID=""Reusing a Graph ObjectOccasionally, after displaying one graph, you might want to display an entirely different graph. The simplest method of accomplishing this is to create another ID="Ch09_Graph140"VkGraph object for the new graph.However, creating a new graph object entails the overhead of creating many new widgets and data structures. Sometimes it is simpler, faster, and more appropriate to re-use the existing graph object. For example, consider a window in which you are displaying a graph of C++ class hierarchies associated with a program. The window might contain controls that allow the user to select other programs to examine. If the user selects a new program to examine, the most convenient thing to do would be to keep the existing graph object but "clear it" of all existing information.The ID="Ch09_Graph141"VkGraph::tearDownGraph() function provides this ability:virtual void tearDownGraph()It tears down the graph by destroying all arc and node widgets and deleting all VkNode objects associated with the graph. This function is equivalent to deleting all VkNode objects associated with the graph, deleting the graph object, and creating a new graph object with the same name, but entails less overhead processing than if you were to explicitly perform these actions separately.LBL="" HELPID=""ViewKit Callbacks Associated with VkGraphThe VkGraph class declares two ViewKit member function callbacks.ID="Ch09_Graph142"ID="Ch09_Graph143"VkGraph activates the VkGraph::arcCreatedCallback whenever the graph creates a SgArc widget to connect two nodes. The arcCreatedCallback callback includes as call data the newly created SgArc widget. See the SgArc(3x) reference pages for information on the SgArc widget.ID="Ch09_Graph144"ID="Ch09_Graph145"VkGraph activates the VkGraph::arcDestroyedCallback whenever the graph destroys all arc widgets as a result of a call to VkGraph::clearAll() (see IDREF="74160" TYPE="TITLE""Indicating Which Nodes to Display"). VkGraph activates the arcDestroyedCallback callback once for every arc destroyed, including as call data the SgArc widget destroyed. See the SgArc(3x) reference pages for information on the SgArc widget.LBL="" HELPID=""X Resources Associated with VkGraphID="Ch09_Graph146"VkGraph sets several X resources that specify the labels of its popup menus. You can override these values in an app-defaults file if you want to provide your own labels. The resources and their default values are:*graph*popupMenu*hideNode*labelString:               Hide Node
*graph*popupMenu*collapseSubgraph*labelString:       Collapse Subgraph
*graph*popupMenu*expandOneLevel*labelString:         Show Immediate Children
*graph*popupMenu*expandSubgraph*labelString:         Expand Subgraph
*graph*popupMenu*hideParents.labelString:            Hide Parents
*graph*popupMenu*expandParents.labelString:          Show Parents
*graph*popupMenu*selectedNodes.labelString:          Selected Nodes
*graph*popupMenu*hideSelectedNodes.labelString:      Hide
*graph*popupMenu*collapseSelectedNodes.labelString:  Collapse
*graph*popupMenu*expandSelectedNodes.labelString:    ExpandLBL="" HELPID=""Subclassing VkGraphID="Ch09_Graph147"VkGraph provides much of the functionality that you should require for displaying and manipulating graphs. In most other cases, you can obtain a pointer to the SgGraph widget using the graphWidget() access function and operate directly on the widget.However, sometimes you might want to perform additional processing when certain actions occur. In a case like this, you can create a subclass of VkGraph. VkGraph provides a number of virtual "hook" functions that you can override and implement additional functionality:ID="Ch09_Graph148"VkGraph::buildCmdPanel() builds the command panel at the bottom of the graph. You can override this function to create your own custom command panel for your graph.virtual void buildCmdPanel(Widget parent)ID="Ch09_Graph149"VkGraph::buildZoomMenu() builds the Zoom menu, the Zoom Out button, and the Zoom In button as part of the command panel. You can override this function to provide your own custom zoom controls for your graph.virtual void buildZoomMenu(Widget parent)ID="Ch09_Graph150"VkGraph::addMenuItems() allows you to modify the Node popup menu described in IDREF="72832" TYPE="TITLE""Hiding and Displaying Nodes". You can override this function and use the various functions provided by the VkMenu class to add new menu item or delete default menu items. IDREF="42452" TYPE="TITLE""The ViewKit Menu Base Class" describes the functions provided by VkMenu.virtual void addMenuItems(VkPopupMenu *menu)ID="Ch09_Graph151"VkGraph::popupMenu() posts the Node popup menu described in IDREF="72832" TYPE="TITLE""Hiding and Displaying Nodes." The function receives two arguments: a pointer to the node on which the user clicked the right mouse button, and the X ButtonPress event. By default, the function: 1) activates and deactivates menu items to reflect the valid options for the node; 2) sets the label of the popup menu to be the same as the label of the node; and 3) calls the popup menu's show() function, passing event as an argument.You can override this function if you want to change its behavior or support any additional menu items that you added by overriding addMenuItems().virtual void popupMenu(VkNode *node, XEvent *event)ID="Ch09_Graph152"VkGraph::addDesktopMenuItems() allows you to modify the Selected Nodes popup menu described in IDREF="98260" TYPE="TITLE""Edit Mode Operations". You can override this function and use the various functions provided by the VkMenu class to add new menu items or delete default menu items. IDREF="42452" TYPE="TITLE""The ViewKit Menu Base Class" describes the functions provided by VkMenu.virtual void addDesktopMenuItems(VkPopupMenu *menu)ID="Ch09_Graph153"VkGraph::twinsVisibleHook() is called when the user toggles the Multiple Arcs or "twins" button. The new state of the twins buttons is passed as an argument to this function. By default, the function is empty. You can override this function to perform additional operations when the graph changes its display mode.virtual void twinsVisibleHook(Boolean state)LBL="10"ID="37403"Miscellaneous ViewKit Display ClassesThis chapter contains descriptions of miscellaneous ViewKit classes that you use primarily to display information or to manage display items. IDREF="94659" TYPE="GRAPHIC"Figure 10-1 shows the inheritance graph for these classes.FILE="Fig10-1.ai" POSITION="INLINE" SCALE="FALSE"LBL="10-1"Figure 10-1 ID="94659"The Inheritance Graph for the Miscellaneous ViewKit Display ClassesID="Ch10_Display1"LBL="" HELPID=""ViewKit Support for Double-Buffered GraphicsID="Ch10_Display2"ID="Ch10_Display3"ID="Ch10_Display4"VkDoubleBuffer is an abstract class that provides support for components that need to display double-buffered graphics.NoteVkDoubleBuffer provides software double-buffering only; it does not use the hardware double-buffering available on many Silicon Graphics workstations. As a result, you might notice some flickering in your VkDoubleBuffer animations. You must create a separate subclass of VkDoubleBuffer for each double-buffered display component in your application. In each subclass, you include the Xlib calls to create the text or graphics that the component displays. You do not have to worry about handling Expose events or resize requests as VkDoubleBuffer handles these automatically.The public interface to VkDoubleBuffer consists simply of a function that your application calls whenever it needs to update the component's display. For example, to drive an animation, you could set a timer to update a component at a desired interval.LBL="" HELPID=""Double Buffer Constructor and DestructorThe ID="Ch10_Display5"VkDoubleBuffer constructor accepts the standard ViewKit component constructor arguments, a component name and a parent widget:VkDoubleBuffer(const char *name, Widget parent)The constructor creates the various widgets and Pixmaps used by the component and installs callbacks to handle Expose events and resize requests. In your subclass constructor, you can initialize any graphics contexts and other data that your component requires.The ID="Ch10_Display6"VkDoubleBuffer destructor frees the widgets and Pixmaps allocated by the VkDoubleBuffer constructor:~VkDoubleBuffer()In your subclass destructor you should free any graphics contexts and other data allocated by your component.LBL="" HELPID=""Drawing in the Double Buffer ComponentThe ID="Ch10_Display7"ID="Ch10_Display8"ID="Ch10_Display9"VkDoubleBuffer class calls your component's draw() function when your component needs to draw a new frame:virtual void draw()draw() is declared by VkDoubleBuffer as a pure virtual function, and it is the only function you must override when creating a derived class of VkDoubleBuffer. The draw() function should use Xlib calls to display text or graphics by drawing to the _canvas data member:Pixmap ID="Ch10_Display10"_canvasThe derived class always draws to the back buffer, although the derived class does not need to be aware of this. The VkDoubleBuffer class copies the contents of this Pixmap to the front buffer as needed.LBL="" HELPID=""Switching Buffers in the Double Buffer ComponentID="Ch10_Display11"ID="Ch10_Display12"VkDoubleBuffer::update() is the public member function that the application calls to update the component's display:virtual void update()update() calls your component's draw() function to obtain a new frame. Then it swaps buffers, and if the component is currently displayed, updates the screen with the contents of the front buffer. Finally, update() clears the back buffer by filling it with the component's background color.LBL="" HELPID=""Handling Double Buffer Component Resize RequestsID="Ch10_Display13"ID="Ch10_Display14"VkDoubleBuffer automatically handles window resize requests, resizing the front and back buffers and filling them with the component's background color. If you need to perform additional operations in your derived class, you can override the virtual function VkDoubleBuffer::resize():virtual void resize()VkDoubleBuffer calls resize() after resizing and reinitializing the buffers. The new height and width of the drawing area are contained in the _width and _height data members:Dimension ID="Ch10_Display15"_width
Dimension ID="Ch10_Display16"_heightLBL="" HELPID=""Tick Marks for ScalesThe ID="Ch10_Display17"ID="Ch10_Display18"ID="Ch10_Display19"VkTickMarks class, derived from VkComponent, displays a vertical set of tick marks. Most frequently, you would use this component next to a vertical IRIS IM XmScale(3Xm) widget. By default, a VkTickMarks component right-justifies its tick marks and displays its labels to the left, which is appropriate if you display the component to the left of a scale. You can also configure a VkTickMarks component to left-justify its tick marks and display its labels to the right, which is appropriate if you display the component to the right of a scale. IDREF="53267" TYPE="GRAPHIC"Figure 10-2 shows an example of each version of the tick marks.FILE="TickMarks1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="10-2"Figure 10-2 ID="53267"Examples of the VkTickMarks ComponentLBL="" HELPID=""Tick Marks Component ConstructorThe ID="Ch10_Display20"VkTickMarks constructor accepts five arguments:VkTickMarks(char* name, Widget parent, Boolean labelsToLeft = TRUE,
            Boolean noLabels = FALSE, Boolean centerLabels = FALSE)The first two arguments are the standard ViewKit component constructor arguments, a component name and a parent widget. If ID="Ch10_Display21"labelsToLeft is TRUE, the tick marks are right-justified and the labels appear to the left; if labelsToLeft is FALSE, the tick marks are left-justified and the labels appear to the right. If you set noLabels to TRUE, the VkTickMarks component does not display any labels. If you set centerLabels to TRUE, the VkTickMarks component centers the labels. This is useful if you want to center a VkTickMarks object between two XmScale widgets.LBL="" HELPID=""Configuring the Tick MarksYou can set the scale of the tick marks with the ID="Ch10_Display22"ID="Ch10_Display23"VkTickMarks::setScale() function:void setScale(int min, int max,
              int majorInterval, int minorInterval)min and max specify the minimum and maximum values for the tick mark component. If you set the VkTickMarks component to display labels, it displays these minimum and maximum values next to the bottom and top tick marks respectively.majorInterval and minorInterval specify the tick mark spacing. You can specify the number of units (not pixels) between each major and minor tick mark.For example, the following sets the minimum value of the ticksVkTickMarks object to 0, the maximum to 1000, the major interval to 100, and the minor interval to 50:ticks->setScale( 0, 1000, 100, 50 );IDREF="82825" TYPE="GRAPHIC"Figure 10-3 shows the resulting display of the VkTickMarks object.FILE="TickMarks1-2.bw" POSITION="INLINE" SCALE="FALSE"LBL="10-3"Figure 10-3 ID="82825"Example of Setting Tick Mark Scale and SpacingIf you do not use setScale() to set the scale of the tick marks, VkTickMarks uses the values of the resources "minimum," "maximum," "majorInterval," and "minorInterval" to set the respective scale values.You can add additional labels to the scale with ID="Ch10_Display24"ID="Ch10_Display25"VkTickMarks::addLabel():void addLabel(int value)The VkTickMarks object displays a label at the value you indicate. You can call addLabel() multiple times to add multiple labels.The ID="Ch10_Display26"VkTickMarks::setMargin() function controls the VkTickMarks margins:void setMargin(int marginTop, int marginBottom);setMargin() allows you to specify the spacing between the top of the VkTickMarks component and the first tick mark, and the bottom of the component and the last tick mark. The default settings are designed for use next to an XmScale widget: the first and last tick marks align horizontally with the mark in the middle of the scale's slider.LBL="" HELPID=""X Resources Associated with the Tick Marks ComponentThe ID="Ch10_Display27"VkTickMarks class provides several X resources that determine display characteristics of the component:minimumThe initial minimum value (default value 0)maximumThe initial maximum value (default value 10)majorIntervalThe major tick interval (default value 5)minorIntervalThe minor tick interval (default value 1)majorSizeThe width in pixels of the major tick marks (default value 10)minorSizeThe width in pixels of the minor tick mark width (default value 6)labelSpacingThe spacing in pixels between tick marks and labels (default value 3)marginTopThe margin in pixels between the top of the component and the top tick mark (default value 19)marginBottomThe margin in pixels between the bottom of the component and the bottom tick mark (default value 19)lineThicknessThe thickness in pixels of the tick marks thickness (default value 1)label.foregroundThe foreground color used for labels and tick markslabel.backgroundThe background color used for labels and tick markslabel.fontListThe font used for labelsLBL="" HELPID=""Management Classes for Controlling Component and Widget Display CharacteristicsViewKit provides some management classes that control the display of components and widgets. These classes function as attachments: you attach them to one or more existing widgets or components. Then you can use the management class to control some aspect of displaying the widgets and components to which the class is attached.ID="Ch10_Display28"LBL="" HELPID=""ViewKit Support for Aligning WidgetsThe ID="Ch10_Display29"ID="Ch10_Display30"ID="Ch10_Display31"ID="Ch10_Display32"ID="Ch10_Display33"ID="Ch10_Display34"VkAlignmentGroup class provides support for aligning collections of widgets with each other in various ways. VkAlignmentGroup is derived from the convenience class VkWidgetList. Consult the VkWidgetList(3x) reference page for more information on that class.To use the VkAlignmentGroup class, you create a VkAlignmentGroup object, add widgets or components to the group, and then call one of the alignment functions provided by VkAlignmentGroup.LBL="" HELPID=""The Alignment Group Constructor and DestructorThe ID="Ch10_Display35"VkAlignmentGroup constructor does not take any arguments:VkAlignmentGroup()VkAlignmentGroup objects do not require names because they are not components; ViewKit uses names to uniquely identify the widget trees of components, and the VkAlignmentGroup class does not create any widgets.The ID="Ch10_Display36"VkAlignmentGroup destructor destroys only the VkAlignmentGroup object. If you have widgets managed by the object, they are unaffected by the VkAlignmentGroup destructor.LBL="" HELPID=""Adding Widgets and Components to an Alignment GroupUse the ID="Ch10_Display37"ID="Ch10_Display38"add() function to add widgets or components to a VkAlignmentGroup object:virtual void add(Widget w)
virtual void add(VkComponent *obj)
virtual void add(VkOptionMenu *menu)If you provide a widget, add() adds that widget to the alignment group. If you provide a pointer to a component, add() adds the component's base widget to the alignment group. If you provide a pointer to a VkOptionMenu object, add() adds all menu items individually to the VkAlignmentGroup object rather than adding the VkOptionMenu object as an entity.LBL="" HELPID=""Removing Widgets and Components from an Alignment GroupYou can remove widgets or components from a ID="Ch10_Display39"ID="Ch10_Display40"VkAlignmentGroup object with the remove() function inherited from VkWidgetList:virtual void remove(Widget w)
virtual void remove(VkComponent *obj)Provide the widget ID or component pointer that you used to add the widget or component to the alignment group.LBL="" HELPID=""Aligning Widgets and Components in an Alignment GroupTo align or distribute the elements in a ID="Ch10_Display41"VkAlignmentGroup object, call one of the following functions (all of which take no arguments and have a void return type):ID="Ch10_Display42"alignLeft()Aligns the left edges of all widgets by repositioning all widgets so that the left side of each widget is moved to the right-most left edge of any widget in the group.ID="Ch10_Display43"alignRight()Aligns the right edges of all widgets by repositioning all widgets so that the right side of each widget is moved to the right-most position occupied by any widget in the group.ID="Ch10_Display44"alignTop()Aligns the top edges of all widgets by repositioning all widgets so that the top of each widget is moved to the bottom-most top edge of any widget in the group.ID="Ch10_Display45"alignBottom()Aligns the bottom edges of all widgets by repositioning all widgets so that the bottom of each widget is moved to the bottom-most position occupied by any widget in the group.ID="Ch10_Display46"alignWidth()Resizes all widgets to the width of the largest widget in the group.ID="Ch10_Display47"alignHeight()Resizes all widgets to the height of the largest widget in the group.ID="Ch10_Display48"makeNormal()Returns all widgets to their desired widths and heights.ID="Ch10_Display49"distributeVertical()Repositions all widgets so that they are positioned evenly in the vertical direction, according to the spacing between widgets, between the position of the first and last widgets in the group.ID="Ch10_Display50"distributeHorizontal()Repositions all widgets so that they are positioned evenly in the horizontal direction, according to the spacing between widgets, between the position of the first and last widgets in the group.LBL="" HELPID=""Alignment Group Access FunctionsVkAlignmentGroup provides the following access functions:ID="Ch10_Display51"VkAlignmentGroup::width() returns the maximum width of all widgets in the group. This value is not set until after you have called alignWidth().Dimension width()ID="Ch10_Display52"VkAlignmentGroup::height() returns the maximum height of all widgets in the group. This value is not set until after you have called alignHeight().Dimension height()ID="Ch10_Display53"VkAlignmentGroup::x() returns the minimum x position of all widgets in the group. This value is not set until after you have called either alignLeft() or alignRight().Position x()ID="Ch10_Display54"VkAlignmentGroup::y() returns the minimum y position of all widgets in the group. This value is not set until after you have called either alignTop() or alignBottom().Position y()VkAlignmentGroup also inherits all of the access and utility functions provided by VkWidgetList. Consult the VkWidgetList(3x) reference page for more information on that class.LBL="" HELPID=""ViewKit Support for Resizing and Moving WidgetsThe ID="Ch10_Display55"ID="Ch10_Display56"ID="Ch10_Display57"ID="Ch10_Display58"ID="Ch10_Display59"ID="Ch10_Display60"ID="Ch10_Display61"ID="Ch10_Display62"ID="Ch10_Display63"VkResizer class provides controls for moving and resizing an existing widget. IDREF="18138" TYPE="GRAPHIC"Figure 10-4 shows a simple example of a push button with a VkResizer attachment.FILE="resizer1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="10-4"Figure 10-4 ID="18138"A Widget With a VkResizer AttachmentIf you use the left mouse button to click on either of the square handles provided by the VkResizer object, you can drag the handle to a new location. When you release the handle, the VkResizer object resizes the widget to which it is attached so that the widget matches the new size of the VkResizer object. IDREF="48261" TYPE="GRAPHIC"Figure 10-5 shows an example of resizing the push button shown in IDREF="18138" TYPE="GRAPHIC"Figure 10-4.FILE="resizer1-2.bw" POSITION="INLINE" SCALE="FALSE"LBL="10-5"Figure 10-5 ID="48261"Effect of Resizing a Widget With a VkResizer AttachmentIf you use the middle mouse button to click on either of the square handles provided by the VkResizer object, you can drag the entire widget to a new location. When you release the handle, the VkResizer object moves the widget to which it is attached to the new location of the VkResizer object. IDREF="49752" TYPE="GRAPHIC"Figure 10-6 shows an example of moving the push button shown in IDREF="48261" TYPE="GRAPHIC"Figure 10-5.FILE="resizer1-3.bw" POSITION="INLINE" SCALE="FALSE"LBL="10-6"Figure 10-6 ID="49752"Effect of Moving a Widget With a VkResizer AttachmentTo use the VkResizer class, you create a VkResizer object, associate an existing widget with the object, and then display the resizer's geometry controls.LBL="" HELPID=""The Resizer Constructor and DestructorThe ID="Ch10_Display64"VkResizer constructor accepts two Boolean arguments:VkResizer(Boolean autoAdjust = FALSE, Boolean liveResize = FALSE)autoAdjust controls whether the VkResizer object automatically tracks outside geometry changes of its attached widget. If you set this value to TRUE, the VkResizer object automatically adjusts its geometry controls whenever its attached widget changes geometry. If you set this value to FALSE, you must call the VkResizer::adjustGeometry() function whenever you want the VkResizer object to adjust its geometry controls to the geometry of its attached widget. The default value of this argument is FALSE.liveResize controls whether the widget itself or a rectangle representing the widget area is displayed during geometry changes. Setting the second parameter to TRUE causes intermediate geometry changes in the attached widget, which may affect performance. The default value is FALSE.VkResizer objects do not require names because they are not components; ViewKit uses names to uniquely identify the widget trees of components, and the VkResizer class does not create any widgets.The ID="Ch10_Display65"VkResizer destructor destroys only the VkResizer object. If you have a widget attached to the object, it is unaffected by the VkResizer destructor.LBL="" HELPID=""Attaching and Detaching a Resizer Object to and from a WidgetOnce you have created a ID="Ch10_Display66"ID="Ch10_Display67"VkResizer object, use the VkResizer::attach() function to attach it to an existing widget:void attach(Widget w)You can also attach a VkResizer object to a component by attaching it to the component's base widget. For example, if resizer is a VkResizer object and obj is a component, you can attach the resizer to the component as follows:resizer->attach( obj->baseWidget() );If the ID="Ch10_Display68"VkResizer object is already attached to a widget, it detaches from the old widget before attaching to the new one. You can use the VkResizer::detach() function to detach a VkResizer object from a widget without immediately attaching it to another:void detach()
ID="Ch10_Display69"LBL="" HELPID=""Displaying the Resizer Object's Geometry ControlsAfter attaching a ID="Ch10_Display70"ID="Ch10_Display71"VkResizer object to a widget, you must call the VkResizer object's VkResizer::show() function to display its geometry controls:void show()You can hide the geometry controls by calling the ID="Ch10_Display72"ID="Ch10_Display73"VkResizer object's VkResizer::hide() function:void hide()The ID="Ch10_Display74"VkResizer::shown() function returns a Boolean value indicating whether the VkResizer object is visible and displaying its geometry controls:Boolean shown()LBL="" HELPID=""Resizer Utility FunctionsYou can configure the ID="Ch10_Display75"ID="Ch10_Display76"VkResizer object's geometry manipulations with the VkResizer::setIncrements() function:void setIncrements(int resizeWidth, int resizeHeight,
                   int moveX, int moveY)setIncrements() accepts four integer arguments. The first two arguments specify the resize increments in the horizontal and vertical dimension, respectively. The last two arguments specify the move increments in the horizontal and vertical dimension, respectively. Setting an increment to zero prohibits resizing or moving in that dimension.LBL="" HELPID=""ViewKit Callbacks Associated with the ResizerThe ID="Ch10_Display77"ID="Ch10_Display78"ID="Ch10_Display79"VkResizer class also provides a ViewKit member function callback named VkResizer::stateChangedCallback:static const char *const stateChangedCallbackThis callback informs the application when VkResizer has modified the geometry of its attached widget. The callback supplies as call data a value of the enumerated type VkResizerReason (defined in <Vk/VkResizer.h>). The value can be any of VR_resizing, VR_moving, VR_resized, or VR_moved. VR_resizing and VR_moving indicate that resizing or moving are in progress, and are sent repeatedly as the user adjusts the geometry. VR_resized and VR_moved indicate that the resizing or moving is complete, and are sent when the user releases the VkResizer geometry controls.LBL="11"ID="72893"Miscellaneous ViewKit Data Input ClassesThis chapter contains descriptions of miscellaneous ViewKit classes that you would use primarily for data input. IDREF="29454" TYPE="GRAPHIC"Figure 11-1 shows the inheritance graph for these classes.FILE="Fig11-1.ai" POSITION="INLINE" SCALE="FALSE"LBL="11-1"Figure 11-1 ID="29454"The Inheritance Graph for the Miscellaneous ViewKit Input ClassesID="Ch11_Input1"ID="Ch11_Input2"ID="Ch11_Input3"LBL="" HELPID=""The Check Box ComponentThe ID="Ch11_Input4"ID="Ch11_Input5"ID="Ch11_Input6"VkCheckBox class, derived from VkComponent, provides a simple method for creating check boxes. Instantiating the component creates an empty, labeled component to which you can add individual toggle buttons. VkCheckBox provides a variety of methods for determining when the user changes the state of a toggle; you can use the method most convenient for your applications. You can also programmatically change the values of the toggles.LBL="" HELPID=""Creating a Check BoxThe ID="Ch11_Input7"VkCheckBox constructor accepts the standard ViewKit component name and parent widget arguments:VkCheckBox(const char *name, Widget parent)The constructor creates an empty, labeled component.LBL="" HELPID=""Adding Toggles to the Check BoxYou add toggles to the check box using the ID="Ch11_Input8"ID="Ch11_Input9"VkCheckBox::addItem() function:Widget addItem(char *name, Boolean state = FALSE,
               XtCallbackProc proc = NULL,
               XtPointer clientData = NULL)name is the name of the toggle item. You can specify its initial state by providing a state argument; TRUE sets the toggle and FALSE clears it.You can also provide an Xt-style callback function, proc, that VkCheckBox activates whenever the user changes the value of the toggle; and clientData, which VkCheckBox passes as client data to the callback function. Following ViewKit conventions as described in IDREF="72493" TYPE="TITLE""Using Xt Callbacks with Components", if you provide a callback function, you should pass the this pointer as client data so that the callback functions can retrieve the pointer, cast it to the expected component type, and call a corresponding member function. IDREF="30437" TYPE="TITLE""Using Xt-Style Callbacks to Handle Changes in Check Box Toggle Values" further discusses how to use the callback function.LBL="" HELPID=""Setting Check Box and Toggle LabelsThe ID="Ch11_Input10"VkCheckBox component creates a LabelGadget named "label" to display a label. Each toggle in the check box is implemented as a ToggleButtonGadget. The name of the gadget is the name string that you provide to addItem() when you add the toggle.Set the XmNlabelString resource of the check box label and its toggles to set their labels:Use the VkComponent::setDefaultResources() function to provide default resource values as described in IDREF="57967" TYPE="TITLE""Setting Default Resource Values for a Component".Set resource values in an external app-defaults resource file. Any values you provide in an external file will override values that you set using the VkComponent::setDefaultResources() function. This is useful when your application must support multiple languages; you can provide a separate resource file for each language supported.Set the resource values directly using the XtSetValues() function. Values you set using this method override any values set using either of the above two methods. You should avoid using this method as it "hard codes" the resource values into the code, making them more difficult to change.For example, consider a simple window that contains only a check box with four toggles, as shown in ID="Ch11_Input11"IDREF="80655" TYPE="GRAPHIC"Figure 11-2.FILE="checkbox1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="11-2"Figure 11-2 ID="80655"Example Check BoxIDREF="31689" TYPE="TEXT"Example 11-1 shows the code used to create this check box.LBL="11-1"Example 11-1 ID="31689"Code to Create Example Check Box#include <Vk/VkApp.h>
#include <Vk/VkSimpleWindow.h>
#include <Vk/VkCheckBox.h>

class CheckBoxWindow: public VkSimpleWindow {

  protected:
    virtual Widget setUpInterface ( Widget parent );
    static String _defaultResources[];

  public:
    CheckBoxWindow ( const char *name ) : VkSimpleWindow ( name ) { }
    ~CheckBoxWindow();
    virtual const char* className();
};

CheckBoxWindow:: ~CheckBoxWindow()
{ }

const char* CheckBoxWindow::className() { return "CheckBoxWindow"; }

String CheckBoxWindow::_defaultResources[] = {
  "*check*label.labelString: Selections:",
  "*check*one*labelString: First choice",
  "*check*two*labelString: Second choice",
  "*check*three*labelString: Third choice",
  "*check*four*labelString: Fourth choice",
  NULL
};

Widget CheckBoxWindow::setUpInterface ( Widget parent )
{
  setDefaultResources(parent, _defaultResources);

  VkCheckBox *cb = new VkCheckBox("check", parent);
  cb->addItem("one");
  cb->addItem("two");
  cb->addItem("three");
  cb->addItem("four");
  cb->show();

  return cb->baseWidget();
}

void main ( int argc, char **argv )
{
VkApp *cbApp = new VkApp("checkBoxApp", &argc, argv);
CheckBoxWindow *cbWin = new CheckBoxWindow("checkbox");

cbWin->show();
cbApp->run();
}LBL="" HELPID=""Setting and Getting Check Box Toggle ValuesAfter creation, you can programmatically set the state of any toggle with the ID="Ch11_Input12"ID="Ch11_Input13"VkCheckBox::setValue() function:void setValue(int index, Boolean newValue)index is the position of the toggle in the check box; the first toggle in the check box has an index of 0. newValue is the new state for the toggle; TRUE sets the toggle and FALSE clears it.NoteSetting a toggle using setValue() activates the toggle's valueChanged callback. This in turn activates all of the VkCheckBox object's methods for detecting changes in toggle values as described in IDREF="65322" TYPE="TITLE""Recognizing Changes in Check Box Toggle Values". You can set the values of multiple toggles using the ID="Ch11_Input14"VkCheckBox::setValues() function:void setValues(Boolean *values, int numValues)The Boolean array values specifies the new values for a group of toggles in the check box beginning with the first toggle. numValues specifies the number of values the values array contains.NoteSetting toggles using setValues() activates each toggle's valueChanged callback. This, in turn, activates all of the VkCheckBox object's methods for detecting changes in toggle values, as described in IDREF="65322" TYPE="TITLE""Recognizing Changes in Check Box Toggle Values," once for each toggle changed. You can retrieve the value of a specific toggle with the ID="Ch11_Input15"ID="Ch11_Input16"VkCheckBox::getValue() function:int getValue(int index)index is the position of the toggle in the check box; the first toggle in the check box has an index of 0. The function returns TRUE if the toggle is set and FALSE if the toggle is not set.LBL="" HELPID=""ID="65322"Recognizing Changes in Check Box Toggle ValuesID="Ch11_Input17"VkCheckBox provides three different methods that you can use to determine when the user changes the value of a toggle: Xt-style callbacks, ViewKit callbacks, and subclassing. You can use whichever method is most convenient.LBL="" HELPID=""ID="30437"Using Xt-Style Callbacks to Handle Changes in Check Box Toggle ValuesThe first method of determining when the user changes a toggle value is to register an Xt-style callback for each toggle button. When you create a toggle with the addItem() function, you can optionally specify a callback function and client data. When the value of the toggle changes, the callback function is called with the client data you provided, and a pointer to a XmToggleButtonCallbackStruct structure as call data.For example, the following adds a toggle named "lineNumbers" to the parametersBox check box and registers a callback function:MyComponent::MyComponent(const char *name, Widget parent) : VkComponent (name)
{
  // ...
  parametersBox->addItem("lineNumbers", FALSE,
                         &MyComponent::toggleLineNumbersCallback(),
                         (XtPointer) this );
  // ...
}MyComponent::toggleLineNumbersCallback(), which must be declared as a static member function of the class MyComponent, is registered as a callback function for this toggle, and the this pointer is used as the client data. The definition of toggleLineNumbersCallback() could look like this:void MyComponent::toggleLineNumbersCallback(Widget,
                                          XtPointer clientData,
                                          XtPointer callData )
{
  MyComponent *obj = (MyComponent) clientData;
  XmToggleButtonCallbackStruct *cb =
                               (XmToggleButtonCallbackStruct) callData;

  // Call MyComponent::toggleLineNumbers(), a regular member function to either
  // display or hide line numbers based on the value of the toggle.

  obj->toggleLineNumbers(cb->set);
}LBL="" HELPID=""Using ViewKit Callbacks to Handle Changes in Check Box Toggle ValuesThe second method of determining when the user changes a toggle value is to use a ViewKit callback. The ID="Ch11_Input18"ID="Ch11_Input19"VkCheckBox component provides the VkCheckBox::itemChanged callback. Any ViewKit component can register a member function to be called when the user changes a check box toggle. The VkCheckBox object provides the integer index of the toggle as client data to the callback functions.NoteThe itemChanged callback is activated whenever the user changes any of the toggles; you cannot register a ViewKit callback for an individual toggle. For example, the following line registers the member function MyComponent::parameterChanged() as a ViewKit callback function to be called whenever the user changes a toggle in the parametersBox check box:MyComponent::MyComponent(const char *name, Widget parent) : VkComponent (name)
{
  // ...
  parametersBox->addCallback(VkCheckBox::itemChanged, this,
                            (VkCallbackMethod) &MyComponent::parameterChanged );
  // ...
}Note that in this example, no client data is provided.The definition of parameterChanged() could look like this:void MyComponent::parameterChanged(VkComponent *obj, void *, 
                                   void *callData )
{
  VkCheckBox *checkBox = (VkCheckBox) obj;
  int index = (int) callData;
  switch (index) {
    // ...

    // Assume that the constant LINE_NUMBER_INDEX is set to the index of
    // the "lineNumber" toggle. If the "lineNumber" toggle value changed,
    // Call MyComponent::toggleLineNumbers(), a regular member function to
    // either display or hide line numbers based on the value of the toggle
    case LINE_NUMBER_INDEX:
      toggleLineNumbers( checkBox->getValue(index) );

    // ...
  }
}LBL="" HELPID=""Using SubClassing to Handle Changes in Check Box Toggle ValuesThe third method of determining when the user changes a toggle value is to create a subclass of ID="Ch11_Input20"ID="Ch11_Input21"VkCheckBox. Whenever the user changes a toggle, VkCheckBox calls the virtual function VkCheckBox::valueChanged():virtual void valueChanged(int index, Boolean newValue)index is the index of the item that changed and newValue is the current (new) value of that item. By default, valueChanged() is empty. You can override its definition in a subclass and perform whatever processing you need.Derived classes have access to the following protected data members of the VkCheckBox class:An instance of the ViewKit WidgetList(3x) class that contains all toggle buttons added to the check boxVkWidgetList *ID="Ch11_Input22"_widgetListThe RowColumn widget that contains the toggle buttonsWidget ID="Ch11_Input23"_rcThe label widget for the check boxWidget ID="Ch11_Input24"_labelLBL="" HELPID=""The Radio Check Box ComponentThe ID="Ch11_Input25"ID="Ch11_Input26"ID="Ch11_Input27"VkRadioBox class provides a simple method for creating radio check boxes (that is, check boxes in which only one toggle at a time can be selected). VkRadioBox is a subclass of VkCheckBox. The only difference between the two classes is that VkRadioBox enforces radio behavior on the toggles it contains.VkRadioBox provides all of the same functions and data members as VkCheckBox does. You use the VkRadioBox class in the same way that you do the VkCheckBox class.For example, consider a simple window that contains only a check box with four toggles as shown in ID="Ch11_Input28"IDREF="92532" TYPE="GRAPHIC"Figure 11-3.FILE="radiobox1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="11-3"Figure 11-3 ID="92532"Example Radio BoxIDREF="68778" TYPE="TEXT"Example 11-2 contains the code used to create this check box.LBL="11-2"Example 11-2 ID="68778"Code to Create Example Radio Box#include <Vk/VkApp.h>
#include <Vk/VkSimpleWindow.h>
#include <Vk/VkRadioBox.h>

class RadioBoxWindow: public VkSimpleWindow {

  protected:
    virtual Widget setUpInterface ( Widget parent );
    static String _defaultResources[];

  public:
    RadioBoxWindow ( const char *name ) : VkSimpleWindow ( name ) { }
    ~RadioBoxWindow();
    virtual const char* className();
};
RadioBoxWindow:: ~RadioBoxWindow()
{ }

const char* RadioBoxWindow::className() { return "RadioBoxWindow"; }

String RadioBoxWindow::_defaultResources[] = {
  "*radio*label.labelString: Select one:",
  "*radio*one*labelString: First choice",
  "*radio*two*labelString: Second choice",
  "*radio*three*labelString: Third choice",
  "*radio*four*labelString: Fourth choice",
 NULL
};

Widget RadioBoxWindow::setUpInterface ( Widget parent )
{
  setDefaultResources(parent, _defaultResources);

  VkRadioBox *rb = new VkRadioBox("radio", parent);
  rb->addItem("one");
  rb->addItem("two");
  rb->addItem("three");
  rb->addItem("four");
  rb->show();

  return rb->baseWidget();
}

void main ( int argc, char **argv )
{
  VkApp *rbApp = new VkApp("radioBoxApp", &argc, argv);
  RadioBoxWindow *rbWin = new RadioBoxWindow("radiobox");

  rbWin->show();
  rbApp->run();
}LBL="" HELPID=""The Tab Panel ComponentThe ID="Ch11_Input29"ID="Ch11_Input30"ID="Ch11_Input31"ID="Ch11_Input32"VkTabPanel class, derived from VkComponent, displays a row or column of overlaid tabs. A tab can contain text, a pixmap, or both. The user can click on a tab with the left mouse button to select it. One tab is always selected, and appears on top of all the others. When the user selects a tab, VkTabPanel activates a ViewKit member function callback indicating which tab the user selected. You can register callback functions to perform actions based on the tabs selected.IDREF="27185" TYPE="GRAPHIC"Figure 11-4 shows an example of a horizontal VkTabPanel component.FILE="TabHoriz1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="11-4"Figure 11-4 ID="27185"Example of a Horizontal VkTabPanel ComponentIDREF="64320" TYPE="GRAPHIC"Figure 11-5 shows an example of a vertical VkTabPanel component.FILE="TabVert1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="11-5"Figure 11-5 ID="64320"Example of a Vertical VkTabPanel ComponentWhen the tabs do not fit within the provided space, the VkTabPanel object "collapses" tabs on the left and right ends of the component (or top and bottom if the VkTabPanel object is vertical). The example in IDREF="82692" TYPE="GRAPHIC"Figure 11-6 shows these collapsed tabs.FILE="TabHoriz1-2.bw" POSITION="INLINE" SCALE="FALSE"LBL="11-6"Figure 11-6 ID="82692"Example of Collapsed Tabs in a VkTabPanel ComponentThe user can click on the collapsed tabs with either the left or right mouse button to display a popup menu listing all the tabs, as shown in IDREF="20068" TYPE="GRAPHIC"Figure 11-7. The user can then select a tab by choosing the corresponding menu item.FILE="TabHoriz1-3.bw" POSITION="INLINE" SCALE="FALSE"LBL="11-7"Figure 11-7 ID="20068"Using the Popup Menu to Select a Collapsed Tab in a VkTabPanel ComponentThe VkTabPanel class also provides work areas implemented as IRIS IM Form widgets to the left and right of the tab display (or top and bottom if the VkTabPanel object is vertical). By default, these work areas are empty. You can access these work area widgets and implement additional displays or controls if you desire. IDREF="36573" TYPE="TITLE""Tab Panel Access Functions" describes the work area access functions.LBL="" HELPID=""The Tab Panel ConstructorThe ID="Ch11_Input33"VkTabPanel constructor initializes the tab panel and allocates all resources required by the component:VkTabPanel(char* name, Widget parent,
           Boolean horizOrientation = TRUE, int tabHeight = 0)name and parent are the standard component name and parent widget arguments.The optional horizOrientation argument determines the orientation of the tab panel. If horizOrientation is TRUE, the tab panel is horizontal; if it is FALSE, the tab panel is vertical.The optional tabHeight argument determines the height of the tab display area. The default value, 0, indicates that tab height is determined by the default label height. If you plan to include pixmaps in your tabs, you should specify a height sufficient to contain your largest pixmap. You can also set the tab height by setting the value of the VkTabPanel object's "tabHeight" resource. For example, to set the tab height of the VkTabPanel object tabs to 30, you could include the following line in an app-default file:*tabs*tabHeight:    30NoteIn most cases when you display a vertical tab panel, you must explicitly set the height of the tab display area. As described above, the default tab display area height is determined by the tab label's font height rather than the width of the label. As a result, the tabs might not be large enough to display all of the label text. LBL="" HELPID=""Adding Tabs to a Tab PanelOnce you have created a tab panel, you can add a tab to it using ID="Ch11_Input34"ID="Ch11_Input35"VkTabPanel::addTab():int addTab(char *label, void *clientData, Boolean sorted = FALSE)label specifies the label displayed by the tab. You should use a distinct label for each tab. addTab() first treats this argument as a resource name which is looked up relative to the tab panel's name. If the resource exists, its value is used as the tab label. If no resource is found, or if the string contains spaces or newline characters, the string itself is used as the tab label.When the user selects this tab, the VkTabPanel object activates either VkTabPanel::tabSelectCallback or VkTabPanel::tabPopupCallback (depending on how the user selected the tab). If you provide a pointer to some data as the clientData argument to addTab(), the tab panel includes that data as part of the VkTabCallbackStruct returned as call data by the callbacks. IDREF="41112" TYPE="TITLE""Responding to Tab Selection" describes in depth these callbacks and how to use them.The sorted flag determines where the new tab is added in relation to existing tabs. If sorted is FALSE, addTab() adds the tab after all existing tabs; if sorted is TRUE, addTab() inserts the tab before the first tab whose label alphabetically succeeds the new tab's label.NoteaddTab() compares the labels actually displayed in the tabs, so if you use resources to specify tab labels, addTab() correctly uses the labels specified by the resource values. The return value of addTab() is the position of the newly-added tab in the tab panel. Tabs are numbered sequentially, with 0 representing the left-most tab in a horizontal tab panel or the top-most tab in a vertical tab panel.New tabs initially have a NULL pixmap. If you want to add a pixmap to a label, see IDREF="96153" TYPE="TITLE""Adding a Pixmap to a Tab".If the new tab is the first tab in the group, ID="Ch11_Input36"addTab() automatically selects the tab by calling VkTabPanel::selectTab(). Note that selectTab() activates VkTabPanel::tabSelectCallback, so if you register a callback function before adding a tab, you activate that callback function when you add your first tab. See IDREF="41112" TYPE="TITLE""Responding to Tab Selection" for more information on selectTab() and VkTabPanel::tabSelectCallback.You can add more than one tab at a time using ID="Ch11_Input37"VkTabPanel::addTabs():void addTabs(char **labels, void **clientDatas, int numTabs,
             Boolean sorted = FALSE)labels is an array of tab label strings. As with addTab(), these label strings are first treated as resource names which are looked up relative to the tab panel's name. If the resources exist, their values are used as the tab labels. If a particular resource name is not found, or if the string contains spaces or newline characters, the label string itself is used as the tab label. clientDatas is an array of client data; the data for a particular tab is included as part of the VkTabCallbackStruct returned as call data by the selection callbacks. numLabels specifies the number of tabs to be added by addTabs(). sorted determines whether or not the tabs are sorted as addTabs() adds them.LBL="" HELPID=""Removing a Tab from a Tab PanelYou can remove a tab from a tab panel using ID="Ch11_Input38"ID="Ch11_Input39"VkTabPanel::removeTab():Boolean removeTab(int index)
Boolean removeTab(char *label)You can specify the tab to remove using either its position index or its label. If removeTab() successfully removes the tab, it returns TRUE; otherwise, if the position index was out of range or it couldn't find a tab with the label string you specified, it returns FALSE.NoteIf you use the same label for two or more tabs and provide a label string to removeTab(), it removes the first tab (that is, the one with the lowest index) that matches the label string. In general, you should avoid using duplicate label strings. LBL="" HELPID=""ID="96153"Adding a Pixmap to a TabYou can set or change the pixmap associated with a tab using ID="Ch11_Input40"ID="Ch11_Input41"VkTabPanel::setTabPixmap():Boolean setTabPixmap(int index, Pixmap pixmap)
Boolean setTabPixmap(char *label, Pixmap pixmap)You can specify the tab using either its position index or its label. If setTabPixmap() successfully sets the tab, it redraws the tabs and returns TRUE; otherwise, if the position index was out of range or it couldn't find a tab with the label string you specified, it returns FALSE.The Pixmap can be either a bitmap (Pixmap of depth 1) or a full color Pixmap.NoteIf you use the same label for two or more tabs and provide a label string to setTabPixmap(), it sets the pixmap for the first tab (that is, the one with the lowest index) that matches the label string. In general, you should avoid using duplicate label strings. To remove an existing pixmap from a tab, call ID="Ch11_Input42"setTabPixmap() with a NULL pixmap.You can retrieve the pixmap currently installed in a tab using ID="Ch11_Input43"VkTabPanel::tabPixmap():Boolean tabPixmap(int index, Pixmap *pixmap_return)
Boolean tabPixmap(char *label, Pixmap *pixmap_return)You can specify the tab using either its position index or its label. If tabPixmap() is successful, the function returns TRUE and the value of the pixmap_return argument is set to point to the tab's pixmap; otherwise, if the position index was out of range or the function couldn't find a tab with the label string you specified, tabPixmap() returns FALSE.LBL="" HELPID=""ID="41112"Responding to Tab SelectionThe user can select a tab two different ways: 1) by clicking on a tab with the left mouse button; or 2) by clicking on a group of collapsed tabs with either the left or right mouse button and choosing a menu item corresponding to a tab. When the user selects a tab by either method, the ID="Ch11_Input44"ID="Ch11_Input45"ID="Ch11_Input46"VkTabPanel object activates its VkTabPanel::tabSelectCallback. You can register callback functions to perform actions based on the tabs selected.When activated, ID="Ch11_Input47"tabSelectCallback provides a pointer to a VkTabCallbackStruct as call data. The format of VkTabCallbackStruct is:typedef struct {
    char *label;
    void *clientData;
    int tabIndex;
    XEvent *event;
} VkTabCallbackStructlabel is the label displayed by the tab. Note that if you set the label by specifying a resource name when you added this tab, the value of label is the value of the resource you specified.clientData is the client data you provided when you added this tab to the tab panel.tabIndex is the position index of the tab. Tabs are numbered sequentially, with 0 representing the left-most tab in a horizontal tab panel or the top-most tab in a vertical tab panel.If the user selected the tab directly (that is, not through the popup menu), event is the ButtonPress event that triggered the selection. Otherwise, event is NULL.In your callback function, you should cast the call data to (VkTabCallbackStruct *), determine which tab the user selected, and perform whatever action is appropriate.The ID="Ch11_Input48"ID="Ch11_Input49"VkTabPanel object also detects when the user clicks the right mouse button on one of the tabs. Doing so does not select the tab, but it does cause VkTabPanel to activate its VkTabPanel::tabPopupCallback. When activated, tabPopupCallback provides a pointer to a VkTabCallbackStruct as call data. You can register callback functions to handle this event and perform any actions that you want.You can programmatically select a tab using ID="Ch11_Input50"VkTabPanel::selectTab():Boolean selectTab(int index, XEvent *event = NULL);
Boolean selectTab(char *label, XEvent *event = NULL);You can specify the tab to select using either its position index or its label. If selectTab() successfully selects the tab, it returns TRUE; otherwise, if the position index is out of range or it can't find a tab with the label string you specified, it returns FALSE.NoteIf you use the same label for two or more tabs and provide a label string to selectTab(), it selects the first tab (that is, the one with the lowest index) that matches the label string. In general, you should avoid using duplicate label strings. You can optionally provide an event argument that selectTab() places in a VkTabCallbackStruct structure, which is then passed as call data to tabSelectCallback.You can also determine the currently selected tab with ID="Ch11_Input51"VkTabPanel::selectedTab():int selectedTab()selectedTab() returns the index of the currently selected tab. Tabs are numbered sequentially, with 0 representing the left-most tab in a horizontal tab panel or the top-most tab in a vertical tab panel.LBL="" HELPID=""ID="36573"Tab Panel Access FunctionsVkTabPanel provides several functions for accessing information about a tab panel and its tabs:ID="Ch11_Input52"VkTabPanel::getTab() retrieves information about a specific tab. Specify the position index of the tab with the index argument. getTab() sets the value of the label_return argument to point to the tab's label. Note that if you set the label by specifying a resource name when you added this tab, the value of label_return is the value of the resource you specified. getTab() sets the value of the clientData_return argument to point to the client data you provided when you added the tab.getTab() returns TRUE if it is successful, and FALSE if the position index was out of range.Boolean getTab(int index, char **label_return,
               void **clientData_return)ID="Ch11_Input53"VkTabPanel::horiz() returns TRUE if the tab component is horizontally oriented, and FALSE if it is vertically oriented.Boolean horiz()ID="Ch11_Input54"VkTabPanel::size() returns the number of tabs in the tab panel.int size()ID="Ch11_Input55"VkTabPanel::tabHeight() returns the height of the tab display area. This is the maximum display height for pixmaps. Larger pixmaps are truncated, and smaller pixmaps are centered. The height of the tab display area is determined by: 1) the value you specify in the VkTabPanel constructor; 2) the value of the VkTabPanel component's "tabHeight" resource; 3) the value of the "height" resource of the "tabLabel" widget created by VkTabPanel; or 4) the height of the tab label's font as specified by the "fontList" resource of the "tabLabel" widget created by VkTabPanel. If you attempt to set the tab height through multiple methods, method 1 has the highest precedence and method 4 has the lowest.NoteIn most cases when you display a vertical tab panel, you must explicitly set the height of the tab display area. As described above, the default tab display area height is determined by the tab label's font height rather than the width of the label. As a result, the tabs might not be large enough to display all of the label text. The total height of a tab, including decoration, is:the height of the tab display area as returned by tabHeight(); plus the tab's top and bottom margin, determined by the value of the "marginHeight" resource of the "tabLabel" widget created by VkTabPanel; plusthe value of the VkTabPanel component's "additionalMarginHeight" resource.The total height of the VkTabPanel component (or width, if the tab panel is horizontal) is the total height of the tab as described above, plus the value of the VkTabPanel component's "margin" resource.int tabHeight()ID="Ch11_Input56"VkTabPanel::uniformTabs() returns TRUE if the tabs have a uniform width (or height, if the tab panel is vertical). By default, tabs take on the width necessary to display their label and pixmap. You can force all tabs to take the width of the largest tab in the group by setting the VkTabPanel component's "uniformTabs" resource to TRUE.The total width of a tab, including decoration, is: 1) the width of the tab label; plus 2) if the tab has a pixmap installed, the width of the pixmap plus the pixmap spacing, determined by the value of the VkTabPanel component's "pixmapSpacing" resource; plus 3) the tab's left and right margin, determined by the value of the "marginWidth" resource of the "tabLabel" widget created by VkTabPanel plus the value of the VkTabPanel component's "additionalMarginWidth" resource.Boolean uniformTabs()ID="Ch11_Input57"VkTabPanel::lineThickness() returns the line thickness used when drawing the tab edges. The line thickness defaults to 1. You can set this value through the "lineThickness" resource of the VkTabPanel component, but a line thickness other than 1 might not render properly.int lineThickness()ID="Ch11_Input58"VkTabPanel::tabBg() returns the color used for the background area around the tabs. This color is set by the "background" resource of the VkTabPanel component.Pixel tabBg()ID="Ch11_Input59"VkTabPanel::labelFg() returns the color used for tab foregrounds (that is, the tab lettering and the foreground bits if the pixmap you supply is a bitmap). This color is set by the "foreground" resource for the "tabLabel" widget created by VkTabPanel.Pixel labelFg()ID="Ch11_Input60"VkTabPanel::labelBg() returns the color used for tab backgrounds. This color is set by the "background" resource for the "tabLabel" widget created by VkTabPanel. When a bitmap is supplied as the pixmap, this color is used for the background bits.Pixel labelBg()ID="Ch11_Input61"VkTabPanel::gc() returns the X graphics context used for drawing the tabs. This might be useful if you create pixmaps and want to use the same foreground and background colors as the tabs.GC gc()ID="Ch11_Input62"ID="Ch11_Input63"VkTabPanel::area1() returns the work area widget to the left of the tab display (or top if the tab panel is vertical), and VkTabPanel::area2() returns the work area widget to the right of the tab display (or bottom if the tab panel is vertical). Both work areas are implemented as IRIS IM Form widgets. By default, these work areas are empty. You can access these work area widgets and implement additional displays or controls if you desire.Widget area1()
Widget area2()LBL="" HELPID=""X Resources Associated with the Tab Panel ComponentThe ID="Ch11_Input64"VkTabPanel class provides several X resources that determine display characteristics of the component:additionalMarginHeightAdditional height, expressed in pixels, added to the margin between the top and bottom of the tab border and the tab display area (default value 2)additionalMarginWidthAdditional width, expressed in pixels, added to the margin between the sides of the tab border and the tab display area (default value 4)backgroundThe background color of the VkTabPanel component, shown in the space around the tabsendMultiplierThe number of overlapped tab symbols displayed as an "end indicator" when there are more tabs in the panel than can be displayed at one time (default value 3)endSpacingThe space, expressed in pixels, between overlapped tab symbols in the "end indicator" (default value 9)lineThicknessThe line thickness used when drawing the tab edges. The default value is 1. You can provide another value, but line thickness other than 1 might not render properly.marginThe margin, expressed in pixels, between the tab edges and the component edge (default value 5)margin1The margin, expressed in pixels, between the left or top work area widget and the tabs (default value 5)margin2The margin, expressed in pixels, between the right or bottom work area widget and the tabs (default value 5)pixmapSpacingIf the tab contains a pixmap, the space, expressed in pixels, between the tab label and the pixmap (default value 3)selectedTabBackgroundThe background color of the selected tabsideOffsetThe amount of tab overlap, expressed in pixels (default value 17)tabHeightThe height of the tab display area is determined by: 1) the value you specify in the VkTabPanel constructor; 2) the value of the VkTabPanel component's "tabHeight" resource; 3) the value of the "height" resource of the "tabLabel" widget created by VkTabPanel; or 4) the height of the tab label's font as specified by the "fontList" resource of the "tabLabel" widget created by VkTabPanel. If you attempt to set the tab height through multiple methods, method 1 has the highest precedence and method 4 has the lowest precedence. The default value of "tabHeight" is 0.uniformTabsDetermines whether all tabs have the same width. The default value, FALSE, allows tabs to be wide enough to display their label and pixmap. You can force all tabs to take the width of the largest tab in the group by setting this resource to TRUE.The VkTabPanel class creates a widget called "tabLabel" to manage the tabs in a tab panel. VkTabPanel provides several X resources that determine display characteristics of the "tabLabel" widget:tabLabel.backgroundThe color used for tab backgrounds. When a bitmap is supplied as the pixmap, this color is used for the background bits.tabLabel.fontListThe font used for tab labels. If the values of the "tabLabel.height" and "tabHeight" resources are 0, and you do not specify a tab height in the VkTabPanel constructor, the height of the font is also used as the height of the tab display area.tabLabel.foregroundThe color used for tab foregrounds (that is, the tab lettering and the foreground bits if the pixmap you supply is a bitmap)tabLabel.heightThe height of the tab display area is determined by: 1) the value you specify in the VkTabPanel constructor; 2) the value of the VkTabPanel component's "tabHeight" resource; 3) the value of the "height" resource of the "tabLabel" widget created by VkTabPanel; or 4) the height of the tab label's font as specified by the "fontList" resource of the "tabLabel" widget created by VkTabPanel. If you attempt to set the tab height through multiple methods, method 1 has the highest precedence and method 4 has the lowest precedence. The default value of "tabLabel.height" is 0.tabLabel.marginHeightThe margin, expressed in pixels, between the top and bottom of the tab border and the tab display areatabLabel.marginWidthThe margin, expressed in pixels, between the sides of the tab border and the tab display areaLBL="" HELPID=""The Text Completion Field ComponentThe ID="Ch11_Input65"ID="Ch11_Input66"ID="Ch11_Input67"ID="Ch11_Input68"VkCompletionField class, derived from VkComponent, provides a text input field component that supports name expansion. While typing in the field, if the user types a space, then the component attempts to complete the current contents of the field based on a list of possible expansions provided by the application. For example, in a field where the user is expected to enter a file name, the application could provide a list of all files in the current working directory.LBL="" HELPID=""The Text Completion Field Constructor and DestructorThe ID="Ch11_Input69"VkCompletionField constructor accepts the standard ViewKit component name and parent widget arguments:VkCompletionField(const char *name, Widget parent)The constructor creates an IRIS IM TextField widget as the component's base widget. You can access this widget using the baseWidget() function provided by VkComponent.The ID="Ch11_Input70"VkCompletionField destructor destroys the component's widget and associated data, including the VkNameList object that stores the list of possible expansions. You should be aware of this in case you provide an existing VkNameList object as an argument to the VkCompletionField::clear() function, described in IDREF="91119" TYPE="TITLE""Setting and Clearing the Text Completion Field Expansion List." Consult the VkNameList(3x) reference page for more information on that class.LBL="" HELPID=""ID="91119"Setting and Clearing the Text Completion Field Expansion ListYou can add individual strings to the completion list by passing them as arguments to the ID="Ch11_Input71"ID="Ch11_Input72"VkCompletionField::add() function:void add(char *name)You can clear the completion list by calling the ID="Ch11_Input73"ID="Ch11_Input74"VkCompletionField::clear() function:void clear(VkNameList *nameList = NULL)If you provide a ID="Ch11_Input75"VkNameList object, clear() deletes the current completion list and uses the VkNameList object that you provide as the new completion list for the completion field. Consult the VkNameList(3x) reference page for more information on that class.LBL="" HELPID=""Retrieving the Text Completion Field ContentsThe ID="Ch11_Input76"ID="Ch11_Input77"VkCompletionField::getText() function duplicates the contents of the text field and then returns a pointer to the duplicate string:char *getText()NoteBecause getText() creates a copy of the text field's contents, you can safely change or delete the returned string. For example, the following line retrieves the contents of a VkCompletionField object called fileName and assigns the string to the variable openFile:openFile = fileName->getText();LBL="" HELPID=""Responding to Text Completion Field ActivationThe ID="Ch11_Input78"ID="Ch11_Input79"ID="Ch11_Input80"VkCompletionField class supplies a ViewKit member function callback named VkCompletionField::enterCallback. This callback is activated whenever the user presses the <Enter> key while typing in the text field. The callback does not pass any call data. If you want to notify a ViewKit component whenever the user presses the <Enter> key while typing in a VkCompletionField object, register a member function of that component as an enterCallback function.LBL="" HELPID=""Deriving Text Completion Field SubclassesThe ID="Ch11_Input81"VkCompletionField class should be sufficient for most applications; however, if you want to have more control over the expansion process you can create a subclass of VkCompletionField.The protected member function ID="Ch11_Input82"VkCompletionField::expand() is called whenever the user types in the text field:virtual void expand(struct XmTextVerifyCallbackStruct *cb)By default, expand() checks whether the user has typed a space, and if so, tries to expand the current contents of the text field; if the user types any other character, expand() simply adds that character to the text field. At any point after an expansion, the VkNameList object pointed to by the protected data member _currentMatchList contains a list of all possible expansions:VkNameList *ID="Ch11_Input83"_currentMatchListYou can override the expand() function to install your own expansion algorithm.You have access to the VkNameList object pointed to by the protected data member _nameList, which contains all possible expansions registered with the component:VkNameList *ID="Ch11_Input84"_nameListYou can also override the protected member function ID="Ch11_Input85"VkCompletionField::activate(), which is called whenever the user presses the <Enter> key while typing in the text field:virtual void activate(struct XmTextVerifyCallbackStruct *cb)activate() is called after expanding the current contents of the text field and after invoking all member functions registered with the enterCallback callback. By default, this function is empty.LBL="" HELPID=""The Repeating Button ComponentThe ID="Ch11_Input86"ID="Ch11_Input87"ID="Ch11_Input88"ID="Ch11_Input89"VkRepeatButton class, derived from VkComponent, provides an auto-repeating pushbutton. A regular pushbutton activates only once when the user clicks on it and releases it. A VkRepeatButton behaves more like a scrollbar button: it activates when the user clicks on it; after a given delay it begins repeating at a given interval; and it stops activating when the user releases it.LBL="" HELPID=""The Repeating Button ConstructorThe ID="Ch11_Input90"VkRepeatButton constructor takes three arguments:VkRepeatButton(char *name, Widget parent,
               VkRepeatButtonType type)name is a character string specifying the component name. parent is the parent widget of the component. type is a VkRepeatButtonType enumerated value specifying the type of button to create. This value can be any of RB_pushButton, RB_pushButtonGadget, RB_arrowButton, or RB_arrowButtonGadget. These create PushButton, PushButtonGadget, ArrowButton, and ArrowButtonGadget widgets, respectively.ID="Ch11_Input91"LBL="" HELPID=""Responding to Repeat Button ActivationA ID="Ch11_Input92"ID="Ch11_Input93"ID="Ch11_Input94"VkRepeatButton object triggers a VkRepeatButton::buttonCallback ViewKit callback whenever the button activates. Any ViewKit object can register a member function with the callback to be invoked when the button activates.The callback provides an XmAnyCallbackStruct pointer as call data; the XmAnyCallbackStruct.reason contains the reason for the callback, and the XmAnyCallbackStruct.event field contains the event that triggered the callback.LBL="" HELPID=""Repeating Button Utility and Access FunctionsThe ID="Ch11_Input95"VkRepeatButton::setParameters() function changes the delay parameters for the button:void setParameters(long initial, long repeat)initial controls how long, in milliseconds, the user has to hold the button down before it begins to repeat. repeat controls the interval between auto-repeat activations, in milliseconds.If you need to determine the type of a ID="Ch11_Input96"VkRepeatButton after creation, you can call the VkRepeatButton::type() function:VkRepeatButtonType type()The return value is a VkRepeatButtonType enumerated value specifying the type of button. This value can be any of RB_pushButton, RB_pushButtonGadget, RB_arrowButton, or RB_arrowButtonGadget, which indicates PushButton, PushButtonGadget, ArrowButton, and ArrowButtonGadget widgets, respectively.ID="Ch11_Input97"LBL="" HELPID=""X Resources Associated with the Repeating Button ComponentThe ID="Ch11_Input98"VkRepeatButton class provides the following X resources that determine operating characteristics of the component:initialDelayThe initial delay in milliseconds before auto-repeat begins (default value 1000)repeatDelayThe auto-repeat interval in milliseconds (default value 200)LBL="" HELPID=""Management Classes for Controlling Component and Widget OperationViewKit provides some management classes that control the operation of components and widgets. These classes function as ID="Ch11_Input99"attachments: you attach them to one or more existing widgets or components. Then, you can use the management class to control some aspect of operation of the widgets and components to which the class is attached.LBL="" HELPID=""Supporting "Ganged" Scrollbar OperationThe ID="Ch11_Input100"ID="Ch11_Input101"ID="Ch11_Input102"ID="Ch11_Input103"ID="Ch11_Input104"ID="Ch11_Input105"VkGangedGroup class provides support for "ganging" together IRIS IM ScrollBar or Scale widgets so that all of them move together; when the value of one of the ScrollBar or Scale widgets changes, all other widgets in the group are updated with that value. VkGangedGroup is derived from the convenience class VkWidgetList. Consult the VkWidgetList(3x) reference page for more information on that class.To use the VkGangedGroup class, you create a VkGangedGroup object and add widgets or components to the group. Thereafter, the VkGangedGroup object automatically updates all of the scales and scrollbars in the group whenever the value of one of them changes.LBL="" HELPID=""The Ganged Scrollbar Group Constructor and DestructorThe ID="Ch11_Input106"VkGangedGroup constructor does not take any arguments:VkGangedGroup()VkGangedGroup objects do not require names because they are not components; ViewKit uses names to uniquely identify the widget trees of components, and the VkGangedGroup class does not create any widgets.The ID="Ch11_Input107"VkGangedGroup destructor destroys only the VkGangedGroup object. If you have widgets or components managed by the object, they are unaffected by the VkGangedGroup destructor.LBL="" HELPID=""Adding Scales and Scrollbars to a Ganged GroupUse the ID="Ch11_Input108"ID="Ch11_Input109"VkGangedGroup::add() function to add widgets or components to a VkGangedGroup object:virtual void add(Widget w)
virtual void add(VkComponent *obj)If you provide a widget, add() adds that widget to the alignment group. If you provide a pointer to a component, add() adds the component's base widget to the alignment group.NoteIf you add a component to a VkGangedGroup object, the base widget of that component must be an IRIS IM ScrollBar or Scale widget. LBL="" HELPID=""Removing Scales and Scrollbars from a Ganged GroupYou can remove widgets or components from a ID="Ch11_Input110"ID="Ch11_Input111"VkGangedGroup object with the remove() function inherited from VkWidgetList:virtual void remove(Widget w)
virtual void remove(VkComponent *obj)Provide the widget ID or component pointer that you used to add the widget or component to the ganged group.You can also use the removeFirst() and removeLast() functions inherited from VkWidgetList to remove the first or last item respectively in the ganged group:virtual void removeFirst()
virtual void removeLast()
ID="Ch11_Input112"ID="Ch11_Input113"LBL="" HELPID=""Enforcing Radio-Style Behavior on Toggle ButtonsIRIS IM supports collections of toggle buttons that exhibit one-of-many or "radio-style" behavior by placing all related buttons in a RadioBox widget. This is adequate in many cases, but in some cases it is useful to enforce radio-style behavior on a collection of buttons dispersed throughout an application.ID="Ch11_Input114"ID="Ch11_Input115"ID="Ch11_Input116"ID="Ch11_Input117"ID="Ch11_Input118"ID="Ch11_Input119"ID="Ch11_Input120"The VkRadioGroup class provides support for enforcing radio-style behavior on an arbitrary group of toggle buttons, no matter where they appear in your application's widget hierarchy. The VkRadioGroup class supports both IRIS IM ToggleButton and ToggleButtonGadget widgets. Furthermore, you can add IRIS IM PushButton and PushButtonGadget widgets to a VkRadioGroup object; the VkRadioGroup object simulates radio-style behavior on these buttons by displaying them as armed when the user selects them (using the XmNarmColor color resource as the button's background color and displaying the XmNarmPixmap if the button contains a pixmap).VkRadioGroup is derived from the convenience class VkWidgetList. Consult the VkWidgetList(3x) reference page for more information on that class.To use the VkRadioGroup class, create a VkRadioGroup object and add widgets or components to the group. Thereafter, the VkRadioGroup object automatically updates all buttons contained in the group whenever the user selects one of the buttons.NoteMembership in a VkRadioGroup object is not exclusive; a widget can potentially belong to multiple groups at once. LBL="" HELPID=""The Radio Group Constructor and DestructorThe ID="Ch11_Input121"VkRadioGroup constructor does not take any arguments:VkGangedGroup()VkRadioGroup objects do not require names because they are not components; ViewKit uses names to uniquely identify the widget trees of components, and the VkRadioGroup class does not create any widgets.The ID="Ch11_Input122"VkRadioGroup destructor destroys only the VkRadioGroup object. If you have widgets or components managed by the object, they are unaffected by the VkRadioGroup destructor.LBL="" HELPID=""Adding Toggles and Buttons to a Radio GroupUse the ID="Ch11_Input123"ID="Ch11_Input124"VkRadioGroup::add() function to add widgets or components to a VkRadioGroup object:virtual void add(Widget w)
virtual void add(VkComponent *obj)If you provide a widget, add() adds that widget to the radio group. If you provide a pointer to a component, add() adds the component's base widget to the alignment group.NoteIf you add a component to a VkRadioGroup object, the base widget of that component must be an IRIS IM ToggleButton, ToggleButtonGadget, PushButton, or PushButtonGadget widget. LBL="" HELPID=""Removing Toggles and Buttons from a Radio GroupYou can remove widgets or components from a ID="Ch11_Input125"ID="Ch11_Input126"VkRadioGroup object with the remove() function inherited from VkWidgetList:virtual void remove(Widget w)
virtual void remove(VkComponent *obj)Provide the widget ID or component pointer that you used to add the widget or component to the radio group.You can also use the removeFirst() and removeLast() functions inherited from VkWidgetList to remove the first or last item, respectively, in the radio group:virtual void removeFirst()
virtual void removeLast()
ID="Ch11_Input127"ID="Ch11_Input128"LBL="" HELPID=""Deriving Radio Group SubclassesIf you use a direct instantiation of ID="Ch11_Input129"ID="Ch11_Input130"VkRadioGroup, you must rely on Xt callback functions registered directly with the toggle buttons to detect and handle state changes in the group. Another approach is to derive a subclass of VkRadioGroup and override the protected VkRadioGroup::valueChanged() function:virtual void valueChanged (Widget w, XtPointer callData)valueChanged() is called whenever any member of the radio group changes state. The first argument is the selected widget. The second argument is the call data from the XmNvalueChangedCallback (in the case of a ToggleButton or ToggleButtonGadget widget) or the XmNactivateCallback (in the case of a PushButton or PushButtonGadget widget).You can override valueChanged() to receive notification of state changes and perform any actions you want. If you override valueChanged(), you should call VkRadioGroup::valueChanged() to update the states of all members of the radio group before performing any other actions.LBL="" HELPID=""Modified Text AttachmentThe ID="Ch11_Input131"ID="Ch11_Input132"ID="Ch11_Input133"ID="Ch11_Input134"ID="Ch11_Input135"ID="Ch11_Input136"VkModifiedAttachment class provides support for tracking the previous and current values in an IRIS IM Text or TextField widget. The VkModifiedAttachment class automatically displays a dogear (a "folded corner") in the upper-right corner of the text widget when the user changes the text value. IDREF="47856" TYPE="GRAPHIC"Figure 11-8 shows an example of a text widget with a VkModifiedAttachment dogear.FILE="Modified1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="11-8"Figure 11-8 ID="47856"Example of a VkModifiedAttachment DogearThe user can "flip" between the previous and current text values by clicking on the dogear. IDREF="55838" TYPE="GRAPHIC"Figure 11-9 demonstrates the results of flipping to a previous text value by clicking on the dogear.FILE="Modified1-2.bw" POSITION="INLINE" SCALE="FALSE"LBL="11-9"Figure 11-9 ID="55838"Example of "Flipping" to a Previous Text Widget Value Using a VkModifiedAttachment DogearWhen the user presses the <Return> key in the text field, the text displayed becomes the current value of the text field and the previously-displayed text becomes the previous value. If the current and previous values are the same, the VkModifiedAttachment object does not display the dogear; the VkModifiedAttachment object redisplays the dogear when the current and previous values are different.NoteIf the user clicks on the dogear before pressing the <Return> key, any changes the user made are discarded. To use the VkModifiedAttachment class, you must: 1) create an IRIS IM Text or TextField widget; 2) create a VkModifiedAttachment object; 3) attach the VkModifiedAttachment object to the widget; and 4) display the VkModifiedAttachment object (to display its dogear).The VkModifiedAttachment class also provides several functions for retrieving the previous and current values of the text field, setting the value of the text field, and managing the display of the object.NoteBecause the VkModifiedAttachment class adds callback functions to handle the changes in value of the text widget, you should not register your own XmNactivateCallback or XmNvalueChangedCallback functions with the text widget. Instead, you should use the VkModifiedAttachment::modifiedCallback ViewKit callback to determine when the text widget changes its value, and use the VkModifiedAttachment access functions to obtain the current or previous value of the text widget.VkModifiedAttachment is derived from the VkModified base class, which tracks previous and current text values not necessarily associated with a text widget. In most cases, you will use the VkModifiedAttachment class; therefore, this section describes the functions inherited from VkModified along with the functions implemented by VkModifiedAttachment. For more information on the VkModified class, consult the VkModified(3Vk) reference page.NoteThe VkModified and VkModifiedAttachment classes are both declared in the <Vk/VkModified.h> header file. LBL="" HELPID=""The Modified Text Attachment Constructor and DestructorThe ID="Ch11_Input137"VkModifiedAttachment constructor accepts three Boolean values:VkModifiedAttachment(Boolean blankIsValue = FALSE,
                     Boolean autoAdjust = TRUE,
                     Boolean incrementalChange = FALSE)blankIsValue determines whether the VkModifiedAttachment object accepts a null string (a blank) as a valid previous value when displaying the dogear. If blankIsValue is FALSE, the VkModifiedAttachment object does not display the dogear if the previous value is blank.autoAdjust determines whether the VkModifiedAttachment object automatically watches its attached text widget for geometry changes and adjusts its own area accordingly. If you set this value to FALSE, you must explicitly call VkModifiedAttachment::adjustGeometry() after changing the geometry of the text widget.If incrementalChange is TRUE, each incremental change to the text value updates the current and previous values. In this mode, activation of the text widget's XmNvalueChangedCallback callback is considered an incremental change. Examples of incremental changes are: each character added or deleted, each deletion of selected characters, and each text insertion by pasting selected text. If incrementalChange is FALSE, the VkModifiedAttachment object updates the current and previous values only when the user presses the <Return> key in the text field.The ID="Ch11_Input138"VkModifiedAttachment destructor destroys only the VkModifiedAttachment object. If you have a widget attached to the object, it is unaffected by the VkModifiedAttachment destructor.LBL="" HELPID=""Attaching and Detaching the Modified Text Attachment to and from a WidgetOnce you have created a ID="Ch11_Input139"ID="Ch11_Input140"VkModifiedAttachment object, use the VkModifiedAttachment::attach() function to attach it to an existing widget:void attach(Widget w)If the ID="Ch11_Input141"VkModifiedAttachment object is already attached to a widget, it detaches from the old widget before attaching to the new widget. You can use the ID="Ch11_Input142"VkModifiedAttachment::detach() function to detach a VkModifiedAttachment object from a widget without immediately attaching it to another widget:void detach()LBL="" HELPID=""Displaying and Hiding the Modified Text AttachmentOnce you have attached a ID="Ch11_Input143"ID="Ch11_Input144"VkModifiedAttachment object to a text widget, you must call VkModifiedAttachment::show() to display the attachment:void show()You can hide a ID="Ch11_Input145"ID="Ch11_Input146"VkModifiedAttachment object by calling VkModifiedAttachment::hide():void hide()When a VkModifiedAttachment object is hidden, it still tracks the current and previous values of the text widget to which it is attached; the user simply cannot toggle between the values. You can still use the VkModifiedAttachment class's access functions to retrieve the previous and current values of the text field.ID="Ch11_Input147"VkModifiedAttachment::expose() forces a redraw of the attachment's dogear:void expose()expose() is called whenever the dogear widget receives an Expose event. Normally, you should not need to call this function.LBL="" HELPID=""Retrieving the Current and Previous Values of the Text WidgetYou can retrieve the current and previous values of the text widget with ID="Ch11_Input148"ID="Ch11_Input149"ID="Ch11_Input150"value() and previousValue() respectively:char *value()
char *previousValue()NoteDo not change or delete the character strings returned by value() and previousValue(). LBL="" HELPID=""Detecting Changes in the Text WidgetThe ID="Ch11_Input151"ID="Ch11_Input152"ID="Ch11_Input153"VkModifiedAttachment class provides a ViewKit member function callback named VkModifiedAttachment::modifiedCallback:static const char *const modifiedCallbackThe VkModifiedAttachment object activates this callback whenever the text widget triggers its XmNactivateCallback or XmNvalueChangedCallback callback. The ID="Ch11_Input154"modifiedCallback provides a pointer to a VkModifiedCallback structure as call data. VkModifiedCallback has the following structure:typedef struct {
    VkModifiedReason reason;
    class VkModified *obj;
    XEvent *event;
} VkModifiedCallbackThe VkModifiedCallback fields are:reasonThe reason for the callback. It can take one of two values: VM_activate, if the text widget triggered its XmNactivateCallback callback; or VM_valueChanged if the text widget triggered its XmNvalueChangedCallback callback.ID="Ch11_Input155"objA pointer to the VkModifiedAttachment objecteventA pointer to the event that triggered the callbackTypically, your callback function should test the reason for the callback and perform an action if appropriate. For example, you can use one of the access functions to obtain the current or previous value of the text widget.NoteBecause the VkModifiedAttachment class adds callback functions to handle the changes in value of the text widget, you should not register your own XmNactivateCallback or XmNvalueChangedCallback callback functions with the text widget. Instead, always use the modifiedCallback ViewKit callback to determine when the text widget changes its value. LBL="" HELPID=""Controlling the Contents of the Text WidgetYou can programmatically set the new current value of a ID="Ch11_Input156"ID="Ch11_Input157"VkModifiedAttachment object with VkModifiedAttachment::setValue():virtual void setValue(const char *value)setValue() sets the object's new current value; the old current value becomes the previous value. VkModifiedAttachment forces the text widget to display the new current value.ID="Ch11_Input158"VkModifiedAttachment::toggleDisplay() programmatically toggles the text widget display between the current value and the previous value:virtual void toggleDisplay()To determine which value the text widget is displaying, call ID="Ch11_Input159"VkModifiedAttachment::latestDisplay():Boolean latestDisplay()latestDisplay() returns TRUE if the text widget is displaying the current value or FALSE if the text widget is displaying the previous value.Finally, you can reset the contents of the text widget with ID="Ch11_Input160"VkModifiedAttachment::displayValue()void displayValue()displayValue() discards any changes the user may have made and updates the text widget with the current value (if the user has the current view selected) or the previous value (if the user has the previous view selected).LBL="" HELPID=""Adjusting the Modified Text Attachment's GeometryBy default, the ID="Ch11_Input161"ID="Ch11_Input162"VkModifiedAttachment object automatically watches its attached text widget for geometry changes and adjusts its own area accordingly. If you set the autoAdjust argument in the VkModifiedAttachment constructor to FALSE, you must explicitly call VkModifiedAttachment::adjustGeometry() after changing the geometry of the text widget to adjust the attachment's geometry:void adjustGeometry()You can also control the size of the ID="Ch11_Input163"VkModifiedAttachment dogear. By default, the dogear is 10 pixels wide by 10 pixels tall. You can set the width and height to different values with the VkModifiedAttachment::setParameters() function:virtual void setParameters(Dimension width, Dimension height)To retrieve the current width and height of the dogear, call ID="Ch11_Input164"VkModifiedAttachment::getParameters():void getParameters(Dimension *width, Dimension *height)LBL="" HELPID=""Other Modified Text Attachment Utility and Access FunctionsThe VkModifiedAttachment class provides several additional utility and access functions:ID="Ch11_Input165"ID="Ch11_Input166"VkModifiedAttachment::fixPreviousValue() allows you to specify a fixed value to use as the attachment's previous value. After setting a fixed previous value, the attachment does not update the previous value; this provides a "default" value that the user can always toggle to and use.If setValueAlso is TRUE, fixPreviousValue() also updates the attachment's current value to fixedValue; however, this does not permanently fix the current value.virtual void fixPreviousValue(char *fixedValue,
                              Boolean setValueAlso = TRUE)ID="Ch11_Input167"VkModifiedAttachment::widget() returns the text widget to which the VkModifiedAttachment object is currently attached.Widget widget()ID="Ch11_Input168"VkModifiedAttachment::modified() returns TRUE if the current value and the previous value are equal and FALSE if they are not equal.Boolean modified()ID="Ch11_Input169"VkModifiedAttachment::setModified() forces the value of the object's modified flag. If you set the value to TRUE, the VkModifiedAttachment object displays its dogear; otherwise, it hides its dogear.virtual void setModified(Boolean value)LBL="" HELPID=""X Resources Associated with the Modified Text AttachmentYou can set the value of an XmNdisplayModified resource for a text widget to determine whether or not the attached ID="Ch11_Input170"VkModifiedAttachment object should display its dogear. If you set the text widget's XmNdisplayModified resource to TRUE or if you do not provide a value for the text widget's XmNdisplayModified resource, the attached VkModifiedAttachment object displays its dogear. This is the default behavior.If you set the text widget's XmNdisplayModified resource to FALSE, the attached VkModifiedAttachment object does not display its dogear, but it does continue to track the text widget's current and previous values. You can still use the functions and callbacks provided by VkModifiedAttachment to manipulate the values and manage the text widget.LBL="12"ID="12593"The ViewKit NetLS InterfaceThis chapter describes the ID="Ch13_NetLS1"ID="Ch13_NetLS2"ID="Ch13_NetLS3"ID="Ch13_NetLS4"VkNLS class, which provides ViewKit's support for the NetLS‘ network licensing manager. VkNLS is a base class.LBL="" HELPID=""Overview of ViewKit NetLS SupportThe ID="Ch13_NetLS5"VkNLS class provides a high-level interface to the NetLS network licensing manager. VkNLS simplifies the process of interacting with the network licensing manager by handling all license verification, informing the user if it could not obtain a license or if the license is about to expire, and shutting down the application if it could not obtain a license. All you need to do to add licensing support in your application is instantiate a VkNLS object and provide some basic information about the application and its licensing. The exact nature of the license is determined by the license generation process, which is separate from the program itself. You must contact your NetLS administrator for information on generating licenses appropriate for your application.Upon instantiation, the VkNLS object looks for either a node-locked or concurrent (networked) license; the application does not differentiate between these forms of licensing. If it finds no valid license, the VkNLS object posts a fatal error dialog to exit the application.If the VkNLS object obtains a license, it rechecks the license every ten minutes. If the application loses its license, the VkNLS object posts a warning dialog informing the user that the license is no longer valid. VkNLS does not terminate the application, but reposts the warning message every minute until the license is restored.When the VkNLS object initially obtains a license, it also checks to see whether the license is about to expire. VkNLS can post a warning dialog if the license has 90 days or less until expiration.LBL="" HELPID=""Using the VkNLS ClassAll you need to do to use the ID="Ch13_NetLS6"VkNLS class in your application is to instantiate a VkNLS object:VkNLS (char *vendorID, long key, int productID, char *version,
       NLSCallback loseLicenseCallback = NULL,
       void *clientData = NULL)vendorID is an encrypted string that uniquely identifies a vendor. key is an integer key. productID is an integer value that uniquely identifies a vendor's products. You must obtain these values from your NetLS administrator. version specifies the version of the product, and can be any string you desire.You can optionally provide a function pointer as the loseLicenseCallback argument. The VkNLS object calls this function if it is not able to obtain a license. If you provide a loseLicenseCallback function, VkNLS does not post the fatal error dialog to exit the application; you must perform whatever error recovery is needed in the function and then exit if appropriate. The NLSCallback definition is:typedef void (*NLSCallback)( void *)VkNLS passes to the loseLicenseCallback function the clientData pointer, if you provide one. Currently, VkNLS does not use any return value that you might provide.NoteThe NLSCallback function must be either a global function or a static member function; it cannot be a regular member function. The ID="Ch13_NetLS7"VkNLS destructor frees all storage associated with a VkNLS object and returns any license currently in use by the application.LBL="" HELPID=""X Resources Associated With the VkNLS ClassID="Ch13_NetLS8"VkNLS recognizes several X application resources that control the messages posted by the various dialogs:thirtyDayMessageThe message displayed when 30 or fewer days are left before a license expires. The message should include a "%d" printf(3S)-style integer specification. VkNLS replaces this with the remaining number of days. For example:*thirtyDayMessage: Your license will expire in %d daysIf there is no value for this resource (the default), then VkNLS does not post a warning dialog when 30 or fewer days are left before a license expires.sixtyDayMessageThe message displayed when between 60 and 30 days are left before a license expires. The message should include a "%d" printf()-style integer specification. VkNLS replaces this with the remaining number of days. If there is no value for this resource (the default), then VkNLS does not post a warning dialog when between 60 and 30 days are left before a license expires.ninetyDayMessageThe message displayed when between 90 and 60 days are left before a license expires. The message should include a "%d" printf()-style integer specification. VkNLS replaces this with the remaining number of days. If there is no value for this resource (the default), then VkNLS does not post a warning dialog when between 90 and 60 days are left before a license expires.disableLicenseWarningsIf TRUE, then the VkNLS object does not display warnings that a license has 90 or fewer days before expiration. The default is FALSE. This resource does not disable messages when the license has 30 or fewer days before expiration.disableThirtyDayLicenseWarningsIf TRUE, then the VkNLS object does not display warnings that a license has 30 or fewer days before expiration. The default is FALSE.notEnoughLicensesMessageThe message displayed when an application is licensed, but there are not enough licenses currently available to support the number of people using them. If you do not provide a value for this resource, the warning dialog that VkNLS posts is empty.noLicenseMessageThe message displayed when the VkNLS object finds no valid license. If you do not provide a value for this resource, the warning dialog that VkNLS posts is empty.licenseExpiredMessageThe message displayed when the application's license expires. If you do not provide a value for this resource, the warning dialog that VkNLS posts is empty.warnLoseLicenseMessageThe message displayed when an application loses its license while it is running. If there is no value for this resource (the default), then VkNLS does not post a warning dialog when the application loses its license.LBL="" HELPID=""Example of Using VkNLSThe program in ID="Ch13_NetLS9"IDREF="24590" TYPE="TEXT"Example 12-1 demonstrates how to add network license support to an application. Note that the vendor ID, the key, and the product ID in this program are only samples. If you attempt to compile this program, you will not be able to obtain a license.LBL="12-1"Example 12-1 ID="24590"Example of Using VkNLS///////////////////////////////////////////////////////////////////
// Demonstrate how to add NetLS protection to a program
///////////////////////////////////////////////////////////////////

#include <Vk/VkApp.h>
#include <Vk/VkSimpleWindow.h>
#include <Vk/VkNLS.h>
#include <Xm/Label.h>

// Sample vendor ID - not real
#define VENDOR_ID "123456789.01.02.03.04.05.00.00.00" 
// Sample KEY - not real
#define KEY 12345
// Sample product ID - not real
#define PRODUCT_ID  21
#define VERSION  "2.1.1"

class HelloWindow: public VkSimpleWindow {

  protected:
    Widget _label;

  public:
    HelloWindow ( const char *name );
    ~HelloWindow();
    virtual const char* className();
};


HelloWindow::HelloWindow ( const char *name ) : VkSimpleWindow ( name ) 
{
    _label =  XmCreateLabel ( mainWindowWidget(), "hello", NULL, 0 );
    addView(_label);
}

const char * HelloWindow::className()
{
    return "HelloWindow";
}

HelloWindow::~HelloWindow()
{
    // Empty
}


void main ( int argc, char **argv )
{
    VkApp        *app = new VkApp("Hello", &argc, argv);
    HelloWindow  *win = new HelloWindow("hello");

    win->show();
    VkNLS *netls = new VkNLS(VENDOR_ID, KEY, PRODUCT_ID, VERSION);
    app->run();
}LBL="A"ID="83598"ViewKit Interprocess Message FacilityThis appendix describes the ViewKit interprocess message facility, which consists of a set of classes that support the ToolTalk‘ message service for interprocess communication.ID="ChA_ToolTalk3"ID="ChA_ToolTalk4"ID="ChA_ToolTalk5"NoteTo develop applications that use ToolTalk, you must purchase the ToolTalk Development Option. In the United States and Canada, call SGI Direct at 800-800-SGI1 (7441) for more information about how to order the ToolTalk Development Option; outside the United States and Canada, please contact your local sales office or distributor. The ToolTalk development library provides low-level functions for setting up connections to the ToolTalk server and sending and receiving messages. The ViewKit message facility is built on top of the ToolTalk development library to provide a higher-level interface to creating and handling interprocess messages. IDREF="73097" TYPE="GRAPHIC"Figure A-1 shows the inheritance graph for the classes supporting the ViewKit message facility. The ViewKit message facility also provides several utility functions that are not class member functions.FILE="FigA-1.ai" POSITION="INLINE" SCALE="FALSE"LBL="A-1"Figure A-1 ID="73097"The Inheritance Graph for the ViewKit Message Facility ClassesID="ChA_ToolTalk6"ID="ChA_ToolTalk7"LBL="" HELPID=""Review of ToolTalk ConceptsThis section provides a brief review of some ToolTalk concepts and terms. For a complete description of the ToolTalk message service and directions for creating applications that interface with the ToolTalk service, consult the ID="ChA_ToolTalk8"ToolTalk Programmer's Guide.The ToolTalk message service allows independent applications to communicate with each other without having direct knowledge of each other. Applications exchange ToolTalk messages to communicate with other applications. Sending applications create, fill in, and send a message; the ToolTalk service determines the recipients and delivers the message to the receiving applications. Receiving applications retrieve messages, examine the information in the message, and then either discard the message or perform an operation and reply with the results.Messages consist of a character string operator, followed by any number of arguments. The arguments can be integers, character strings, or binary strings. Also, a message can have attributes such as a filename. The receiver of a message is told the number and type of arguments, and is also given access to any attribute values.For each type of message an application wants to receive, it must register a message pattern with the ToolTalk service. The message pattern describes the operator, arguments, and attributes that a message must have to be delivered to the application. When the application registers a pattern, it must indicate whether it wants to observe or handle messages of that type. Any number of applications can observe a message. The ToolTalk service forwards a copy of the message to each application with a matching message pattern. On the other hand, to ensure that a requested operation is performed only once, only one application can handle a message. If the ToolTalk service cannot find a handler for a message, it returns the message to the sending application indicating that delivery failed.There are two types of messages: notices and requests. A sending application sends a notice to provide information to other applications; the sending application does not expect a reply to a notice. Receiving applications receive notices and perform whatever actions are needed to process the notice; the receiving applications do not send reply message in response to notices. A sending application sends a request to ask another application to perform an action; the sending application expects a single reply to a request. A receiving application receives the request, performs whatever actions are needed to process the request, and sends a reply message. The ToolTalk service handles the details of how requests are handled, and ensures that only one receiver gets to reply.When the ToolTalk service determines that a message needs to be delivered to a specific process, but the process is not currently running, the ToolTalk service looks for instructions (provided by the application at installation time) on how to start the application.LBL="" HELPID=""Overview of ViewKit's ToolTalk SupportThis section provides an overview of ViewKit's ToolTalk support. It discusses the classes you use to interface with ToolTalk and the policies enforced by those classes.ID="ChA_ToolTalk9"LBL="" HELPID=""ViewKit Classes Supporting ToolTalkThe ID="ChA_ToolTalk10"ID="ChA_ToolTalk11"VkMsgClient class is the basis for interacting with ToolTalk in your application. VkMsgClient allows you to register and manage message patterns; declare actions for your application to perform when it receives messages; compose messages; and send notices and requests.The ID="ChA_ToolTalk12"ID="ChA_ToolTalk13"ID="ChA_ToolTalk14"ID="ChA_ToolTalk15"VkMsgApp class, a subclass of VkApp, opens a ToolTalk connection and sets up all resources needed to send and receive ToolTalk messages.VkMsgApp actually instantiates a VkMsgServiceID="ChA_ToolTalk1" objectname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'which is in turn a subclass of VkMsgFacilityID="ChA_ToolTalk2"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'to perform ToolTalk initialization and support ToolTalk interaction. Although you should never need to use either the VkMsgFacility or VkMsgService classes directly, you might encounter them while debugging a ViewKit application that uses the ViewKit interprocess message facility. Consult the VkMsgFacility(3Vk) and the VkMsgService(3Vk) reference pages for more information on these classes.
 You must instantiate a VkMsgApp object in your application instead of a VkApp object if you want ToolTalk support for your application. The VkMsgApp constructor creates an instance of VkMsgClient that you can use to manage messages in your application.The ID="ChA_ToolTalk16"ID="ChA_ToolTalk17"VkMsgWindow class is a subclass of VkWindow that works with VkMsgApp to support the ViewKit interprocess message facility. To provide ToolTalk support for your application, you must use VkMsgWindow for your application's windows instead of VkSimpleWindow or VkWindow. The VkMsgWindow constructor creates an instance of VkMsgClient that you can use to manage messages in that window.The ID="ChA_ToolTalk18"ID="ChA_ToolTalk19"VkMsgComponent class is a subclass of VkComponent that works with VkMsgApp to support the ViewKit interprocess message facility. You should use VkMsgComponent to derive new components if those components must send or receive ToolTalk messages. You do not need to derive components from VkMsgComponent if those components do not interact with ToolTalk. The VkMsgComponent constructor creates an instance of VkMsgClient that you can use to manage messages in that component.The ViewKit message facility also provides several utility functions for manipulating messages. These functions are implemented as normal functions rather than class member functions.LBL="" HELPID=""ViewKit Message Facility PoliciesThe ViewKit message facility provides mostly a mechanism for exchanging ToolTalk messages between applications, but it does impose some policies:ID="ChA_ToolTalk20"Messages are always sent to all members of the session.Message actions receive all messages for a given operator, and cannot set patterns based on argument number or type.By default, applications connect to the default session when they're started.These are the policies currently implemented, but they are subject to change in future releases of ViewKit; however, applications that adhere to these policies should not be affected by future changes.LBL="" HELPID=""Establishing a Connection to the ToolTalk ServiceCreating an instance of the ID="ChA_ToolTalk21"ID="ChA_ToolTalk22"ID="ChA_ToolTalk23"ID="ChA_ToolTalk24"VkMsgApp class opens a ToolTalk connection and sets up all resources needed to send and receive ToolTalk messages. Remember to use the VkMsgApp class in your application instead of a VkApp object if you want ToolTalk support for your application. The syntax of the VkMsgApp constructor is:VkMsgApp(char* appClassName, int* argc, char** argv,
         XrmOptionDescRec* optionList = NULL,
         int sizeOfOptionList = 0,
         const char* ptid = NULL,
         const char* sessid = NULL
         Boolean noProtocol = FALSE)The first five arguments are the same as those that you can provide to the VkApp constructor. The ptid argument specifies a process type. It defaults to NULL which indicates no process type. You need to provide a ptid argument only if this application is autostarted (see IDREF="79980" TYPE="TITLE""Registering Services for Autostart"). sessid specifies a session to join. If you don't provide a value, the process joins the default session.The noProtocol argument determines whether your application automatically provides support for handling "Lower," "Raise," and "Quit" messages. If this value is FALSE (the default), your application calls VkApp::iconify() upon receiving a "Lower" message, VkApp::open() and VkApp::raise() upon receiving a "Raise" message, and VkApp::quitYourself() upon receiving a "Quit" message.You can also specify the session using command line arguments when you invoke your applications:-project sessidJoin the session specified by sessid-projectWindow windowidJoin the same session as the window specified by windowid-projectWindowAllow the user to click on a window and join the same session as the window specifiedThe ID="ChA_ToolTalk25"VkMsgApp class also creates an instance of VkMsgClient that you can use to manage messages in your application. You can retrieve a pointer to this object with the VkMsgApp::messageClient() function:VkMsgClient* messageClient()LBL="" HELPID=""Sending and Receiving ToolTalk MessagesThis section describes how to register and manage message patterns, declare actions for your application to perform when it receives messages, composes messages, and sends notices and requests. You accomplish all of these tasks using the ID="ChA_ToolTalk26"VkMsgClient class.You do not explicitly instantiate VkMsgClient objects. Instead, the VkMsgApp, VkMsgWindow, and VkMsgComponent classes all automatically instantiate their own VkMsgClient objects and provide access functions to those objects.LBL="" HELPID=""Sending Notices and RequestsThis section describes how to send notices and requests using ID="ChA_ToolTalk27"VkMsgClient. Both notices and requests are types of messages. A sending application sends a notice message to provide information to other applications; the sending application does not expect a reply to a notice. All of the parameters in a notice have a mode of "in", which indicates that receiving applications should read only those parameters.A sending application sends a request message to ask another application to perform an action; the sending application expects a single reply to a request. In a request, some of the message parameters have a mode of "out", which indicates that the receiving application should fill in these parameters for the reply message, or "in/out", which indicates that the receiving application should read those parameters and then fill them in with new values for the reply message.LBL="" HELPID=""Sending Simple NoticesIf you're sending a notice consisting of only string arguments or only integer arguments, you can use the ID="ChA_ToolTalk28"ID="ChA_ToolTalk29"VkMsgClient::sendStringNotice() or VkMsgClient::sendIntNotice() function, respectively:void sendStringNotice(char *op ...)
void sendIntNotice(char *op ...)For both functions, op is the message operator. sendStringNotice() expects a NULL-terminated list of pointers to character strings; sendIntNotice() expects a NULL-terminated list of integers. These functions create a message with the arguments you provide, send the message, and then automatically delete the message (that is, delete the storage space allocated by your application when the functions create the message).CautionBecause sendIntNotice() expects a NULL-terminated list of arguments, be sure that you don't provide a zero-valued argument or else you'll prematurely terminate your argument list.LBL="" HELPID=""Composing and Sending MessagesTo send requests or to send notices that contain a mix of argument types, you must compose the message before sending it. To begin composing a message, call ID="ChA_ToolTalk30"VkMsgClient::composeBegin():void composeBegin()NoteYou can compose only one message at a time among all VkMsgClient objects. You can then add arguments to your message one at a time, using ID="ChA_ToolTalk31"VkMsgClient::composeAdd():void composeAdd(char *val, VkMsgMode mode = VK_MSG_IN)
void composeAdd(int ival, VkMsgMode mode = VK_MSG_IN)
void composeAdd(unsigned char *val, int len,
                VkMsgMode mode = VK_MSG_IN)You can add as an argument: 1) a NULL-terminated character string; 2) an integer value; or 3) a binary string. If you provide a binary string, you must also specify the length of the string as the len argument.The mode argument is an enumerated value of type VkMsgMode. VK_MSG_IN indicates that the argument is written by the sending application and can be read by the handling application and any observing applications. VK_MSG_OUT indicates that the argument is written by the handling applications and is read by the sending application. VK_MSG_INOUT indicates that the argument can be written by both the sending and handling applications, and can be read by the sending, handling, or any observing applications.Once you finish composing the message, you send the message. If the message is a notice, use ID="ChA_ToolTalk32"VkMsgClient::sendNotice():void sendNotice(char *op)op is the message operator. sendNotice() sends the message you composed, and then automatically deletes the message (that is, deletes the storage space allocated by your application when you compose the message).To send a request, use ID="ChA_ToolTalk33"VkMsgClient::sendRequest():VkMsgMessage sendRequest(char *op)sendRequest() sends the message you composed. op is the message operator. sendRequest() returns an opaque message handle. You can use this handle when calling the various utility functions provided by the ViewKit message facility as described in IDREF="75836" TYPE="TITLE""Useful Functions When Handling Messages".When you send a request using sendRequest(), the function returns immediately. To obtain and handle the reply message to your request, your application must register a message action as described in IDREF="97196" TYPE="TITLE""Receiving Notices and Handling Requests".NoteThe ViewKit message facility automatically deletes the request message when your application receives the corresponding reply or failure message. LBL="" HELPID=""Sending Synchronous RequestsIn some cases, your application might require a reply to a request before performing any other processing. In these cases, you can use ID="ChA_ToolTalk34"VkMsgClient::sendSyncRequest() to send a synchronous request:VkMsgMessage sendSyncRequest(char *op)ID="ChA_ToolTalk35"ID="ChA_ToolTalk36"ID="ChA_ToolTalk37"sendSyncRequest() uses a secondary X event loop to simulate a synchronous reply to a request. sendSyncRequest() blocks until it receives the reply message, which it passes as its return value. If the request fails, sendSyncRequest() returns NULL. Note that because sendSyncRequest() uses a secondary X event loop, you should beware of any problems with re-entrant code in any callbacks that could be invoked.Once you receive the reply message, you can use the various utility functions provided by the ViewKit message facility, as described in ID="ChA_ToolTalk38"IDREF="75836" TYPE="TITLE""Useful Functions When Handling Messages", to parse the reply. You must also use VkMsgDestroy() to destroy the message when you no longer need the reply:VkMsgStatus VkMsgDestroy(VkMsgMessage msg)VkMsgDestroy() is implemented as a normal function rather than a class member function. It is declared in the header file <Vk/VkMsg.h>. The VkMsgStatus return value is the same as the tt_status values used by ToolTalk; consult the ToolTalk Programmer's Guide for information on these values.LBL="" HELPID=""Specifying a Filename Message AttributeThe convention for passing a filename argument in a message is to specify the filename as a message attribute rather than a message argument. The VkMsgClient class provides the following functions for sending a message with a filename attribute:void sendStringFileNotice(char *ID="ChA_ToolTalk39"op, char *file ...)
void sendIntFileNotice(char *ID="ChA_ToolTalk40"op, char *file ...)
void sendFileNotice(char *ID="ChA_ToolTalk41"op, char *file)
void sendFileRequest(char *ID="ChA_ToolTalk42"op, char *file)
void sendSyncFileRequest(char *ID="ChA_ToolTalk43"op, char *file)In these functions, file is the filename.LBL="" HELPID=""ID="97196"Receiving Notices and Handling RequestsThis section describes how to receive notices and handle requests using the ViewKit message facility. It discusses message dispatch, writing message action callbacks, creating message patterns, associating message actions with the message patterns, and registering and unregistering message patterns.ID="ChA_ToolTalk44"LBL="" HELPID=""Overview of Message DispatchFor each type of message an application wants to receive, it must register a ID="ChA_ToolTalk45"message pattern with the ToolTalk service. The message pattern describes the operator, arguments, and attributes that a message must have to be delivered to the application. Your application must also register message actions, callback functions that are called when your application receives messages with a particular message pattern.When the ToolTalk service receives a message, it matches the message against all registered patterns. If the message is a notice, the ToolTalk service delivers a separate message to each application with a matching pattern; if the message is a request, the ToolTalk service selects the "best" pattern match and delivers a single message to the application with the matching pattern.The ViewKit message facility then dispatches the message received by the application to each action registered for the matching operator, regardless of any other pattern information you provided when registering the action. Your action is responsible for testing the message arguments and determining whether to process the message or not.As an example, consider an application that registers an action for a message pattern consisting of a "show" operator and an integer argument. If another process then sends a "show" message with an integer argument, the ToolTalk service sends the message to your application, and your application dispatches the message to the action. On the other hand, if another process sends a "show" message with a character string argument, the ToolTalk service does not send the message to your application because it does not match the registered pattern.A complication arises if you have multiple actions registered for a particular message operator; for example, if in addition to the action described above, your application registered an action for a message pattern consisting of a "show" operator and a character string argument. In this case, the ToolTalk service sends to your application any "show" message with either an integer or a character string argument. The ViewKit message facility then dispatches those messages to each action in your application registered for the "show" operator. Each action is then responsible for testing the message arguments and determining whether to process the message or not.LBL="" HELPID=""ID="80454"Writing Message Action CallbacksYou implement message actions as callback functions that your application invokes when it receives a message matching a given message pattern. This section describes how to write the message action callback functions. ID="ChA_ToolTalk46"IDREF="73556" TYPE="TITLE""Creating and Registering Simple Message Patterns" describes how to register these callback functions with the ViewKit message facility.All message action callback functions must be of type VkMsgClientAction:ID="ChA_ToolTalk47"typedef Boolean (*VkMsgClientAction)(
  void*                /* clientData */,
  VkMsgFacilityReason  /* reason */,  
  VkMsgMessage         /* msg_in */,
  char*                /* op */,
  int                  /* argc */,
  VkMsgArg*            /* argv */
)NoteThe VkMsgClientAction function must be a regular function or a static member function; it cannot be a regular class member function. The callback function arguments are:clientDataThe arbitrary client data you provided as the clientData argument when you registered this callback function using the addAction() function, as described in IDREF="73556" TYPE="TITLE""Creating and Registering Simple Message Patterns".reasonThe reason for calling the callback function, expressed as an enumerated value of type VkMsgFacilityReason. Possible values are:ID="ChA_ToolTalk48"VK_MSG_FACILITY_NOTICEname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'NoticeVK_MSG_FACILITY_REQUESTname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'RequestVK_MSG_FACILITY_REPLYname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Reply to a previous requestVK_MSG_FACILITY_FAILEDname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Request failed (not handled)VK_MSG_FACILITY_STARTEDname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Request caused autostart of the handler and was queuedmsg_inThe incoming message in the form of an opaque message handle. You can use this handle when calling the various utility functions provided by the ViewKit message facility as described in IDREF="75836" TYPE="TITLE""Useful Functions When Handling Messages". For example, you might want to compare returned values against those you sent in your request.opThe message operatorargcThe number of message argumentsargvThe message arguments, passed as an array of VkMsgArg structures.ID="ChA_ToolTalk49"The format of the VkMsgArg structure, used to pass the message arguments, is:typedef struct {
  char *type;
  VkMsgValue value;
  VkMsgMode mode;
} VkMsgArgThe elements of the structure are:typeThe argument type. This can take any of three pre-defined constant values:VK_MSG_INT_MSG_ARG_TYPEname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'integer valueVK_MSG_STRING_MSG_ARG_TYPEname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'character string valueVK_MSG_BSTRING_MSG_ARG_TYPEname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'binary string valuetypeThe argument value, expressed as a VkMsgValue union. The definition of the VkMsgValue union is:ID="ChA_ToolTalk50"typedef union {
  int ival;
  char *val;
  VkMsgBValue bval;
} VkMsgValue

typedef struct {
  unsigned char *val;
  int len;
} VkMsgBValuetypeThe argument mode, expressed as an enumerated value of type VkMsgMode. Possible values are:ID="ChA_ToolTalk51"VK_MSG_INname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the argument is written by the sending application and can be read by the handling application and any observing applications.VK_MSG_OUTname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the argument is written by the handling applications and is read by the sending application.VK_MSG_INOUTname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the argument can be written by both the sending and handling applications, and can be read by the sending, handling, or any observing applications.NoteRemember that the ViewKit message facility dispatches the messages received by the application to each action registered for the matching operator, regardless of any other pattern information you provided when registering the actions. Your actions are responsible for testing the message arguments and determining whether or not to process the messages they receive. Message action callbacks that process notices are relatively straightforward to write; the callback simply examines the message data and performs any actions required by the application. You can use the various utility functions provided by the ViewKit message facility, as described in IDREF="75836" TYPE="TITLE""Useful Functions When Handling Messages", to parse the message. Notice callbacks are not expected to send reply messages.Message action callbacks that process requests must first decide whether or not to handle the request. If so, the callback should: 1) read any required data from the message's "in" or "in/out" arguments; 2) perform any appropriate actions; 3) modify any "out" or "in/out" arguments; and 4) send the reply message using ID="ChA_ToolTalk52"VkMsgReply():VkMsgStatus VkMsgReply(VkMsgMessage msg)VkMsgReply() is implemented as a normal function rather than a class member function. It is declared in the header file <Vk/VkMsg.h>.After performing any appropriate actions, your message action callback should return a Boolean value to indicate whether or not the ViewKit message facility should propagate the message to other callbacks registered for that action. A Boolean value of FALSE propagates the message; a value of TRUE does not propagate the message.If a message action callback that processes a request decides to handle a request, it should return TRUE to prevent other message action callbacks from attempting to handle the request as well. If the callback decides not to handle a request, it should return FALSE to allow other callbacks to attempt to handle the message. If all of an application's message actions reject a message, the ToolTalk service tries to dispatch the request to another application.You should always return FALSE in message action callbacks that process notice messages.The ViewKit message facility automatically destroys request messages when your application receives the corresponding reply or failure message. If for some reason you need to explicitly destroy a request message, call the ID="ChA_ToolTalk53"VkMsgDestroyRequest() function:VkMsgStatus VkMsgDestroyRequest(VkMsgMessage msg)VkMsgDestroyRequest() is implemented as a normal function rather than a class member function. It is declared in the header file <Vk/VkMsg.h>. The VkMsgStatus return value is the same as the tt_status values used by ToolTalk; consult the ToolTalk Programmer's Guide for information on these values.LBL="" HELPID=""ID="75836"Useful Functions When Handling MessagesThe ViewKit message facility also provides several utility functions for manipulating messages. These functions are implemented as normal functions rather than class member functions. Most of these utility function are actually redefined ToolTalk functions. The ViewKit message facility provides this level of indirection to allow messaging services other than ToolTalk to be used. You should never directly call any of the ToolTalk routines in your application. Similarly, all of the ToolTalk constants (TT_*) have been replaced by ViewKit message facility equivalents (VK_MSG_*).ID="ChA_ToolTalk54"VkMsgTypeIsInt(), ID="ChA_ToolTalk55"VkMsgTypeIsString(), and ID="ChA_ToolTalk56"VkMsgTypeIsBString() check to see whether a given argument is an integer, a character string, or a binary string respectively:Boolean VkMsgTypeIsInt(char *atype)
Boolean VkMsgTypeIsString(char *atype)
Boolean VkMsgTypeIsBString(char *atype)The header file <Vk/VkMsgUtils.h> contains these declarations.ID="ChA_ToolTalk57"VkMsgSetIVal(), ID="ChA_ToolTalk58"VkMsgSetVal(), and ID="ChA_ToolTalk59"VkMsgSetBVal() change the integer, character string, or binary string value, respectively, of a given message argument:VkMsgSetIVal(VkMsgMessage msg, int index, int value)
VkMsgSetVal(VkMsgMessage msg, int index, char *value)
VkMsgSetBVal(VkMsgMessage msg, int index,
             unsigned char *value, int len)The header file <Vk/VkMsg.h> contains these declarations.You can parse a message's arguments into a VkMsgArg structure (as described in IDREF="80454" TYPE="TITLE""Writing Message Action Callbacks") with the ID="ChA_ToolTalk60"VkMsgParseArguments() function:void VkMsgParseArguments(VkMsgMessage msg, int *argc_return, VkMsgArg **argv_return)This function is declared in the header file <Vk/VkMsgUtils.h>. You must free the argv result when done.You can retrieve the file attribute associated with a message using the ID="ChA_ToolTalk61"VkMsgFile() function:char *VkMsgFile(VkMsgMessage msg)This function is declared in the header file <Vk/VkMsg.h>. You are responsible for freeing the returned value when you are finished using it. If there is no file attribute, VkMsgFile() returns NULL.ID="ChA_ToolTalk62"VkMsgIsErr() checks to see whether a VkMsgStatus value is an error status:int VkMsgIsErr(VkMsgStatus status)This function is declared in the header file <Vk/VkMsg.h>. If the VkMsgStatus value is a warning, VkMsgIsErr() returns 0; if it is an error VkMsgIsErr() returns 1.ID="ChA_ToolTalk63"VkMsgPtrError() determines whether a given opaque handle returned by a ViewKit message facility function is valid:VkMsgStatus VkMsgPtrError(void *pointer)This function is declared in the header file <Vk/VkMsg.h>. You can use this function to test for valid message handles or pattern handles. If the handle is valid, VkMsgPtrError() returns the constant VK_MSG_OK.ID="ChA_ToolTalk64"VkMsgFail() informs the ToolTalk service that your process cannot handle this request and that the message should not be offered to other processes of the same ptype as yours:VkMsgStatus VkMsgFail(VkMsgMessage msg)This function is declared in the header file <Vk/VkMsg.h>. The ToolTalk service sends the message back to the sender with state VK_MSG_FAILED.ID="ChA_ToolTalk65"VkMsgReject() informs the ToolTalk service that your process cannot handle this message:VkMsgStatus VkMsgReject(VkMsgMesage msg)This function is declared in the header file <Vk/VkMsg.h>. The ToolTalk service will try other handlers.LBL="" HELPID=""ID="73556"Creating and Registering Simple Message PatternsTo use your message actions, you must associate them with message patterns and then register those patterns with the ViewKit message facility.ID="ChA_ToolTalk66"NoteBe sure to register your application's message actions before executing VkApp::run() or posting any ViewKit dialog. You must register your message actions before entering any Xt event loop; otherwise your application might receive messages before registering message actions, and your application will not process the message as expected. Use the ID="ChA_ToolTalk67"VkMsgClient::addAction() function to create a message pattern and associate a message action with that pattern:VkMsgPattern addAction(char *op, VkMsgClientAction proc,
                       void *clientData, VkMsgActionType type,
                       Boolean deleteMessage = TRUE)addAction() creates and registers a simple message pattern consisting of only a message operator, op. You can create more detailed message patterns using the functions described in IDREF="85223" TYPE="TITLE""Creating More Detailed Message Patterns". After your application registers this pattern, it receives all messages sent that contain this operator. addAction() returns an opaque message pattern handle. You use this handle to remove this action with the removeAction() function described later in this section.The proc argument is the callback function invoked when your application receives a message matching the message pattern. The function must be of type VkMsgClientAction. The ViewKit message facility passes the clientData argument to the function as client data. See IDREF="80454" TYPE="TITLE""Writing Message Action Callbacks" for information on writing message action callbacks.The type argument specifies the type of message processing the message action implements. type is an enumerated value of type VkMsgActionType, which can take any of the following values:VK_MSG_ACTION_OBSERVEObserve messages; use this value to process noticesVK_MSG_ACTION_HANDLEHandle messages; use this value to process requestsVK_MSG_ACTION_REPLYProcess replies to a requestVK_MSG_ACTION_FAILProcess request failuresVK_MSG_ACTION_STARTProcess notices of a message handler startingThe deleteMessage argument determines whether or not your application automatically deletes the message after all actions process it. By default, the ViewKit message facility automatically destroys the message and your message actions don't need to worry about it. However, if you want to save a copy of the message to deal with it later (for example, to send a reply), you must set deleteMessage to False.After you've created your message patterns, you must call ID="ChA_ToolTalk68"VkMsgClient::updatePatterns() to register those patterns:void updatePatterns()The ID="ChA_ToolTalk69"VkMsgClient::removeAction() function removes an action:void removeAction(VkMsgPattern pat)pat is the message pattern returned by addAction(). removeAction() automatically unregisters the associated message pattern from the ViewKit message facility.LBL="" HELPID=""ID="85223"Creating More Detailed Message PatternsThe message pattern created by addAction() consists of only the message operator string. Any message received with that operator matches the particular message pattern and is dispatched to your action.You can create more detailed message patterns, adding arguments and attributes, to restrict the messages that the ToolTalk service dispatches to your application. To create a more detailed pattern, you first create a basic message pattern using the ID="ChA_ToolTalk70"VkMsgClient::createAction() function:VkMsgPattern createAction(char *op, VkMsgClientAction proc,
                          void *clientData, VkMsgActionType type,
                          Boolean deleteMessage = TRUE)createAction() accepts the same arguments as addAction(). Like addAction(), it creates a simple message pattern consisting of only a message operator, op, and associates the message action, proc, with that pattern. Unlike addAction(), createAction() does not automatically register the pattern with the ViewKit message facility. Instead, you can specify additional arguments or attributes to the message pattern using various pattern modifier functions.All of the pattern modifier functions are implemented as normal functions rather than class member functions. They are actually redefined ToolTalk functions. The header file <Vk/VkMsg.h> contains these declarations. The ViewKit message facility provides this level of indirection to allow messaging services other than ToolTalk to be used. You should never directly call any of the ToolTalk routines in your application.Consult the <Vk/VkMsg.h> header file for a list of pattern modifier functions you might find useful. Refer to the ToolTalk Programmer's Guide for information on these functions.After modifying the message pattern, call ID="ChA_ToolTalk71"VkMsgClient::registerPattern() to register the pattern with the ViewKit message facility:VkMsgStatus registerPattern(VkMsgPattern pat)pat is the opaque message pattern handle returned by createAction(). registerPattern() returns a VkMsgStatus value indicating its status. The VkMsgStatus values are the same as the tt_status values used by ToolTalk; consult the ToolTalk Programmer's Guide for information on these values.After you've created your message patterns, you must call ID="ChA_ToolTalk72"VkMsgClient::updatePatterns() to register those patterns:void updatePatterns()You can unregister a message pattern with the ID="ChA_ToolTalk73"VkMsgClient::unregisterPattern() function:VkMsgStatus unregisterPattern(VkMsgPattern pat)pat is the opaque message pattern handle returned by createAction(). unregisterPattern() returns a VkMsgStatus value indicating its status. The VkMsgStatus values are the same as the tt_status values used by ToolTalk; consult the ToolTalk Programmer's Guide for information on these values.As an example of creating a detailed message pattern, consider the following code:pat = createAction("message_op", callback, this, VK_MSG_ACTION_HANDLE);
VkMsgPatternArg(pat, VK_MSG_IN, VK_MSG_INT_MSG_ARG_TYPE, NULL)
VkMsgPatternArg(pat, VK_MSG_OUT, VK_MSG_ALL_MSG_ARG_TYPE, NULL);
VkMsgPatternIArg(pat, VK_MSG_IN, VK_MSG_INT_MSG_ARG_TYPE, 5);
registerPattern(pat);
updatePatterns();This example creates a message pattern that matches messages with the operator "message_op," and has three arguments. The first is an "in" integer argument. The second is an "out" argument of any type. The last is an "in" integer argument with value 5.LBL="" HELPID=""Detecting and Handling Errors in Handling RequestsThere are two kinds of errors that can occur when a request is made and a reply is expected. Either no one handles the request (and ToolTalk could not autostart an appropriate service), or someone does handle the request and replies, but some error occurs while handling the request.For instance, a request to "Raise the Mail Tool" would fail if there is no mail tool, since no reply could be received. In this case, if you had registered a VK_MSG_ACTION_FAIL type message action for the "Raise the Mail Tool" operator, your application would call that message action. If you were using VkMsgClient::sendSyncRequest(), it would return NULL.If your request is successfully sent to a handler, but an error occurs while processing the request, most handlers send a reply but indicate that an error condition occurred. Many handlers return a status code indicating the return status. To obtain the status code of a reply, call the ID="ChA_ToolTalk74"VkMsgStatusCode() function:int VkMsgStatusCode(VkMsgMessage msg)Furthermore, some handlers provide useful error strings to display in the case of errors. To obtain the error string of a reply, call the ID="ChA_ToolTalk75"VkMsgStatusString() function:char *VkMsgStatusString(VkMsgMessage msg)The meaning of status codes and the validity of status strings is dependent on the service handling the request. Both of these functions are implemented as a normal functions rather than class member functions. They are actually redefined ToolTalk functions. The header file <Vk/VkMsg.h> contains these declarations.LBL="" HELPID=""Supporting Messaging in Application WindowsThe ID="ChA_ToolTalk76"VkMsgWindow class is a subclass of VkWindow that works with VkMsgApp to support the ViewKit interprocess message facility. You should use VkMsgWindow for your application's windows instead of VkSimpleWindow or VkWindow if you want ToolTalk support for your application.The ID="ChA_ToolTalk77"VkMsgWindow constructor creates an instance of VkMsgClient that you can use to manage messages in that window. You can access the window's VkMsgClient object with the VkMsgWindow::messageClient() function:VkMsgClient *messageClient()VkMsgWindow also provides a variety of convenience functions for directly manipulating a window's VkMsgClient object. Consult the VkMsgWindow(3Vk) reference page for more information on these functions.LBL="" HELPID=""Supporting Messaging in ComponentsThe ID="ChA_ToolTalk78"VkMsgComponent class is a subclass of VkComponent that works with VkMsgApp to support the ViewKit interprocess message facility. You should use VkMsgComponent to derive new components if those components must send or receive ToolTalk messages. You do not need to derive components from VkMsgComponent if those components do not interact with ToolTalk. Furthermore, you usually should handle the ToolTalk interaction in an application through the application's VkMsgApp object or one of its VkMsgWindow objects.The ID="ChA_ToolTalk79"VkMsgComponent constructor creates an instance of VkMsgClient that you can use to manage messages in that component. You can access the window's VkMsgClient object with the VkMsgWindow::messageClient() function:VkMsgClient *messageClient()VkMsgComponent also provides a variety of convenience functions for directly manipulating a component's VkMsgClient object. Consult the VkMsgComponent(3Vk) reference page for more information on these functions.LBL="" HELPID=""ID="79980"Registering Services for AutostartFor some messages, you might want a service process to get autostarted as necessary. When the message is sent and the process is not available, the ToolTalk service starts the process and queues the message.ID="ChA_ToolTalk80"To set this up, you need to register your application class with what ToolTalk calls a "ptype," a process type. Refer to the ToolTalk Programmer's Guide for details, but in most situations the setup is similar. For example, you might have a file called myapp.ptype that contains:ptype USR_MY_APP
{
  start "/usr/sbin/myApp";
  observe: session load_file() => start;
}This indicates that the message "load_file" is observed by a process typed "USR_MY_APP" and that when a "load_file" message is sent, the ToolTalk service should execute "/usr/sbin/myApp."Then, you instantiate the VkMsgApp object in the myApp application as follows:VkMsgApp *myApp = new VkMsgApp("MyApp", &argc, argv, NULL, 0,
                               "USR_MY_APP");Finally, when you install your application, you need to register this information in the static ToolTalk config file by executing:/usr/sbin/tt_type_comp -dsystem myapp.ptype
/etc/killall -USR2 ttsessionThis adds the contents of myapp.ptype to the system config file, and tells all existing ttsession processes to update their configurations.When you express message patterns in a ptype, you should not register the pattern in your application. Otherwise, your message handler will be called twice. To register an action but not register the corresponding pattern, use createAction() instead of addAction().LBL="" HELPID=""Troubleshooting ChecklistHere are some common mistakes to watch out for:ID="ChA_ToolTalk81"When using ptype-registered patterns for autostart, make sure your executable has registered its ptype name in VkMsgApp::VkMsgApp() and that it has a non-specific action with no pattern (use VkMsgClient::createAction() instead of addAction()) to handle the request. Otherwise, ToolTalk autostarts your executable indefinitely.If you don't set the optional deleteMessage argument to TRUE in VkMsgClient::addAction(), you should never call VkMsgDestroy() or VkMsgDestroyRequest() in your message action.If you set the optional deleteMessage argument to FALSE in VkMsgClient::addAction(), you're responsible for destroying the message when you're through with it. If the message is a request, be sure to use VkMsgDestroyRequest() instead of VkMsgDestroy(). Otherwise, you may have memory heap corruption caused by double frees, if the requestor and handler are in the same process.You must call VkMsgClient::updatePatterns() after you use VkMsgClient:::addAction(). Otherwise, your new actions have no effect.Anytime you go into an X event loop, messages can be received. Therefore, be careful about registering your message actions before calling VkApp::run(), or using a blocking dialog with a secondary event loop. For instance, a NetLS dialog should be used after your actions are added. Otherwise, autostart messages may not be handled properly.When using the VkMsgClient::composeAdd() routines, be careful that you call VkMsgClient::composeBegin() first to reset the state of your composed arguments. Otherwise, random arguments will get added to your message.If you return TRUE from a message action where the reason was VK_MSG_ACTION_HANDLE, be sure that you call VkMsgReply(). Otherwise, ToolTalk assumes that your process is handling the message when in fact you never reply. The requestor waits forever for a response.Also, it is useful to turn on ttsession (the ToolTalk server process) debugging output. You can toggle it on/off with:/etc/killall -USR1 ttsessionLBL="B"ID="46022"Contributed ViewKit ClassesThis appendix gives you an idea of how you can expand ViewKit by describing some ViewKit classes that users have contributed. These classes are not supported by Silicon Graphics and their interfaces might change in future ViewKit releases.LBL="" HELPID=""The ViewKit Meter ComponentThe ID="ChB_Contrib1"ID="ChB_Contrib2"ID="ChB_Contrib3"VkMeter class supports simple compound bar charts, displayed in either vertical or horizontal mode. If you display multiple values, the data is presented in layers, with the bar representing the second value starting where the first value ends.LBL="" HELPID=""Meter Constructor and DestructorThe ID="ChB_Contrib4"VkMeter accepts the standard ViewKit component constructor arguments: a component name and a parent widget:VkMeter(const char *name, Widget parent)You should rarely need to create subclasses of VkMeter.The ID="ChB_Contrib5"VkMeter destructor frees all space associated with the meter:~VkMeter()LBL="" HELPID=""Resetting the MeterBefore adding any items for display to a ID="ChB_Contrib6"ID="ChB_Contrib7"VkMeter object, you must call VkMeter::reset() to reset the meter:void reset(int peak = -1)The first value, peak, sets the initial peak value displayed by the meter. All items displayed by the meter are scaled relative to the peak value. For example, if the peak value is 200 and one of your items is 40 units long, that item will be scaled to take 20% of the meter's total length. The default peak size is 100 units.NoteTo change meter values or otherwise update a meter object, you must call reset() and then add the items to the meter again. LBL="" HELPID=""Adding Items to a MeterYou add items for a ID="ChB_Contrib8"ID="ChB_Contrib9"VkMeter object to display with VkMeter:add():void add(int value, char *color)
void add(int value, Pixel pixel)
void add(int value, int width, char *color)
void add(int value, int width, Pixel pixel)The value argument is the item's value. When displayed, the VkMeter class scales this value relative to the peak value set by reset(). For example, if the peak value is 500 and one of your items is 80 units long, that item will be scaled to take 16% of the meter's total length.When you use these forms of the add() function, the VkMeter object displays the items sequentially. For example, if you have set the peak value to 100 and you add three items with values of 20, 10, and 30 in that order, the meter displays three bars: the first ranging from 0 to 20, the second from 20 to 30, and the third from 30 to 60.All data items must have an associated color. You can specify the color as a Pixel value, pixel, or as a string, color. If you provide a string, add() first treats the string as the name of a resource that add() looks up relative to the component and converts to the desired color. If add() finds no such resource, it uses the string itself as the name of a color. For example, the following adds an item with the color "red":add(10, "red");The following adds an item with the color specified by the resource name "criticalColor":add(20, "criticalColor");You can specify the width of an item by providing a width argument, expressed in pixels. If you do not provide a width, the width of the item is the same as the width of the meter.Two more complex forms of add() allow you to precisely control the position of bars in a meter, and even display bars side by side:void add(int start, int size, int sideValue, int width, char *color)
void add(int start, int size, int sideValue, int width,
         Pixel color)In these forms of add(), the first value, start, specifies the starting position of the bar, and the second value, size, specifies the size (length) of the bar. VkMeter scales these values relative to the peak value set by reset(). The third argument, sideValue, and the fourth argument, width, specify values in the opposite dimension. VkMeter does not scale these values relative to the meter's peak value.For example, consider a meter with a peak value of 100. The following lines add four bars to the meter:add(0, 20, 0, 10, "red");
add(0, 20, 10, 10, "blue");
add(0, 20, 20, 10, "green");
add(20, 20, 0, 30, "yellow");If you display this meter vertically, it shows three vertical bars ranging from 0 to 20 side by side in red, blue, and green. Above them is a yellow bar spanning all of them and ranging from 20 to 40.LBL="" HELPID=""Updating the Meter DisplayAfter adding all items to a meter, call the ID="ChB_Contrib10"ID="ChB_Contrib11"VkMeter::update() function to update the meter's display:void update()NoteRemember that if you want to change the meter display, you must first call reset() and then add each item in the new display. LBL="" HELPID=""ID="76763"Setting the Meter's Resize PolicyThe meter you create can have either a fixed size or it can attempt to resize itself dynamically as it requires more or less room to display the items it contains. You can specify the meter's resize policy with ID="ChB_Contrib12"ID="ChB_Contrib13"VkMeter::setResizePolicy():void setResizePolicy( unsigned char policy )You can provide any of the following values:XmRESIZE_NONEThe meter never attempts to resize itself. The application, or managing widget, is in complete control of the meter's size.XmRESIZE_GROWThe meter calls XtSetValues() on the widget used to display the meter to attempt to grow as needed. The success of the call to XtSetValues() depends on the parent widget's geometry management policy.XmRESIZE_ANYThe meter calls XtSetValues() on the widget used to display the meter to attempt to grow or shrink as needed. The success of the call to XtSetValues() depends on the parent widget's geometry management policy.LBL="" HELPID=""Determining the Desired Dimensions of the MeterYou can determine the dimensions that a meter needs to display itself completely by calling ID="ChB_Contrib14"ID="ChB_Contrib15"ID="ChB_Contrib16"VkMeter::neededWidth() and VkMeter::neededHeight():Dimension neededWidth()
Dimension neededHeight()LBL="" HELPID=""X Resources Associated with the Meter ComponentThe following X resources are associated with the ID="ChB_Contrib17"VkMeter class:XmNorientationDetermines the orientation of the meter. The default value is XmVERTICAL which specifies a vertical meter. Set the value of the resource to XmHORIZONTAL for a horizontal meter.XmNresizePolicyDetermines the resize policy of the meter, as described in IDREF="76763" TYPE="TITLE""Setting the Meter's Resize Policy". The default value is XmRESIZE_NONE.XmNdrawBorderDetermines whether bars are drawn with borders. The default value is FALSE, in which case bars do not have borders. If you set the value to TRUE, bars have borders drawn in the color specified by the XmNborderColor resource.LBL="" HELPID=""The ViewKit Pie Chart ComponentThe ID="ChB_Contrib18"ID="ChB_Contrib19"ID="ChB_Contrib20"VkPie class is derived from VkMeter and displays data in the same way as that class. However, rather than displaying the values as a bar chart, the VkPie class displays the data as a pie chart. See the description of VkMeter for details.LBL="" HELPID=""The ViewKit Outline ComponentThe ID="ChB_Contrib21"ID="ChB_Contrib22"VkOutline component, derived from VkComponent, displays a textual outline. VkOutline automatically indents items according to their depth in the outline. IDREF="11559" TYPE="GRAPHIC"Figure B-1 shows an example of a VkOutline component containing three top-level items, each with several subitems.FILE="Outline1-1.bw" POSITION="INLINE" SCALE="FALSE"LBL="B-1"Figure B-1 ID="11559"Example of a VkOutline ComponentIf there is not sufficient space to display the entire outline, the VkOutline component automatically displays a scrollbar, as shown in IDREF="35771" TYPE="GRAPHIC"Figure B-2.FILE="Outline1-2.bw" POSITION="INLINE" SCALE="FALSE"LBL="B-2"Figure B-2 ID="35771"Example of a VkOutline Component with the Scrollbar VisibleThe VkOutline component displays a control icon to the left of each outline item that contains subitems. The control icon denotes whether the sub-tree under the item is displayed (open) or not (closed). The user can click the left mouse button on the control icon to toggle between the open and closed states. IDREF="88352" TYPE="GRAPHIC"Figure B-3 shows the results of closing the item "Subheading 2B," shown in the previous figure.FILE="Outline1-3.bw" POSITION="INLINE" SCALE="FALSE"LBL="B-3"Figure B-3 ID="88352"Example of Closing a Heading in a VkOutline ComponentLBL="" HELPID=""Constructing an Outline ComponentThe VkOutline constructor accepts the standard ViewKit component constructor arguments: a component name and a parent widget:VkOutline (const char *name, Widget parent)LBL="" HELPID=""ID="81537"Adding Items to an OutlineYou can add items to the outline in a simple parent-child relation with VkOutline::add():void add(char* parentName, char* childName)The actions performed by add() depend on whether either or both of the items already exist in the outline.If both items already exist in the outline, add() does nothing.If neither exists, add() creates parentName as a top-level item in the outline and then creates childName as a subitem of parentName.If parentName already exists but childName does not, add() creates childName as a subitem of parentName.If childName exists and parentName does not, and childName is a top-level item, add() "reparents" childName by adding parentName as a top-level item and moving childName in the outline so that it is a subitem of parentName.If childName exists and parentName does not, but childName is not a top-level item, add() does nothing.parentName and childName are used both as item names and the text displayed in the outline. Note that you must use unique names for each item in the outline.You can add multiple subitems to an existing item using VkOutline::addChildren():void addChildren(char** parentPath, char** childNames)

void addChildren(char** parentPath, char** childLabels,
                 char** childNames, void** childData)The character string array parentPath specifies the complete path of the parent item through the outline. The first element of the parentPath array is the name of the top-most item of the outline containing the specified item, the second element is the name of the second-highest item, and so on, with the name of the item itself appearing last. You must NULL-terminate the array.The character string array childNames contains the names of the subitems to add to the specified parent item. Note that you must use unique names for each item in the outline.In the second form of addChildren(), you can provide childLabels, an array of character strings that provide display labels for the subitem you add. VkOutline displays these labels for the items instead of the item names.In the second form of addChildren(), you can also provide childData, an array of pointers to arbitrary data. You can retrieve a pointer to the data associated with an item using VkOutline::getHookAt(), described in IDREF="37743" TYPE="TITLE""Outline Utility and Access Functions". Usually you need to use this data only if you create a subclass of VkOutline. In a subclass, you can add callbacks so that when the user selects an outline item, you can retrieve the data associated with that item and perform some action.VkOutline::createPath() creates or extends a path in the outline:void createPath(char** itemLabels, char** itemNames)The character string array itemNames specifies a path through the outline. The first element of the itemNames array is the name of the top-most item of the outline containing the specified item, the second element is the name of the second-highest item, and so on, with the name of the item itself appearing last. You must NULL-terminate the array.If path does not exist, then createPath() creates a new set of items with the first element in the path as the top-level item, the second element a subitem of the first, and so on. If createPath() finds a partial match in the existing outline, where the first element of itemNames matches the name of an existing top-level item and one or more lower-level items match succeeding elements of itemNames, createPath() adds those items needed to fully extend the path.For those items that createPath() adds, it uses the corresponding elements from the itemLabels character string array as the display labels for those items. VkOutline displays these labels for the items instead of the item names.NotecreatePath() does not alter the labels for any existing items. createPath() uses the labels only when adding new items. Whenever you add items to the outline, no matter which function you use to add them, you must call VkOutline::displayAll() to update the outline display:void displayAll()LBL="" HELPID=""Setting Display Attributes for Outline ItemsVkOutline allows you to designate items as "keywords" and display them in a different foreground color, background color, and/or font. You can also define up to four custom item highlights, each with its own foreground color, background color, and font attributes.Use VkOutline::setKeywordAttributes() to define the keyword display attributes:void setKeywordAttributes(Pixel fg, Pixel bg, XmFontList font)fg is the foreground color for the item's text. bg is the background color for the item. font is the font used to display the item's text.Use VkOutline::displayAsKeyword() to display an item with the keyword display attributes:void displayAsKeyword(char** path)You specify the complete path of the item through the outline as an array of character strings. The first element of the path array is the name of the top-most item of the outline containing the specified item, the second element is the name of the second-highest item, and so on, with the name of the item itself appearing last. You must NULL-terminate the array. Note that displayAsKeyword() requires the item names, not their display labels.Use VkOutline::setHighlightAttributes() to define the display attributes of a custom highlight:int setHighlightAttributes(Pixel fg, Pixel bg, XmFontList font)fg is the foreground color for the item's text. bg is the background color for the item. font is the font used to display the item's text. setHighlightAttributes() returns an integer identifier for the highlight. You use this identifier to apply the highlight to outline items with the highlight() function described below. If setHighlightAttributes() could not allocate a custom highlight, it returns 0.Use VkOutline::highlight() to display one or more items with display attributes of a custom highlight:void highlight(int itemPos, int attribID)
void highlight(char** items, int attribID)In the first form of highlight(), you specify the position index in the outline of the item you want to highlight. Items are numbered sequentially from the top of the outline starting with zero. attribID is the attribute identifier returned by setHighlightAttributes() of the custom highlight that you want to assign to the items.In the second form of highlight(), items is an array of strings specifying the names of the items to highlight. Note that highlight() requires the item names, not their display labels. Again, attribID is the attribute identifier (returned by setHighlightAttributes()) of the custom highlight that you want to assign to the items.You cannot remove a custom highlight from individual items; you can only remove the highlight from all items to which you have applied it. VkOutline::unhighlight() removes a custom highlight:void unhighlight(int attribID)attribID is the attribute identifier (returned by setHighlightAttributes()) of the custom highlight that you want to assign to the items.LBL="" HELPID=""Closing and Opening Outline TopicsYou can programmatically toggle an outline item open or closed with VkOutline::toggleChildren():virtual void toggleChildren(int position)position is the item's position in the SgList widget. Items are numbered sequentially from the top of the outline starting with zero.You can determine the effects of the last toggle operation, whether a result of user interaction or a call to toggleChildren(), by calling VkOutline::effectOfLastToggle():int effectOfLastToggle(int& from, int& count)If the last toggle operation opened an item (and therefore inserted items into the SgList widget), effectOfLastToggle() returns 1, sets the value of from to the position of the toggled item in the list, and sets the value of count to the number of items displayed by opening the item. If the last toggle operation closed an item (deleting items from the SgList widget), effectOfLastToggle() returns 0, sets the value of from to the position of the toggled item in the list, and sets the value of count to the number of items deleted from the list by closing the item.You can determine whether a given item is closed with VkOutline::isPathClosed():int isPathClosed(char** path)The character string array path specifies the complete path of the item through the outline. The first element of the path array is the name of the top-most item of the outline containing the specified item, the second element is the name of the second-highest item, and so on, with the name of the item itself appearing last. You must NULL-terminate the array.isPathClosed() returns 1 if the item is closed, 0 if the item is open, and -1 if the item has no subitems.LBL="" HELPID=""ID="37743"Outline Utility and Access FunctionsVkOutline provides the following utility and access functions:void setIndentationWidth(int width)VkOutline::setIndentationWidth() sets indentation width for future displays. The indentation width is the number of pixels to the right that the outline offsets a child item from its parent item.void printTree()VkOutline::printTree() prints the outline on the application's standard output.void reset()VkOutline::reset() re-initializes the outline, deleting all items. reset() retains any display attributes you created.Widget listWidget()VkOutline::listWidget() returns the widget ID of the SgList widget that the VkOutline uses to display the outline. Consult the SgList(3x) reference page for more information on the SgList widget.void select(int position)VkOutline::select() selects the string displayed at the given position of the SgList widget.void getHookAt(int position)VkOutline::getHookAt() retrieves the pointer to the data associated with an item given the item's position in the SgList widget. This is the data that you provided as the childData argument to addChildren() (see IDREF="81537" TYPE="TITLE""Adding Items to an Outline").Usually, you need to use this data only if you create a subclass of VkOutline. In a subclass, you can add callbacks to the SgList widget so that when the user selects an outline item, you can retrieve the data associated with that item and perform some action.LBL="" HELPID=""VkOutlineASBThe ID="ChB_Contrib23"VkOutlineASB class, a subclass of VkOutline, provides the same functionality as VkOutline except that it uses an annotated scrollbar. With VkOutlineASB, you can display colored bars in the scrollbar to indicate the positions of highlighted items in the outline.All functions that VkOutlineASB inherits from VkOutline operate identically. VkOutlineASB provides one additional function, VkOutlineASB::setAnnotation():void setAnnotation(int attribID, Boolean state)setAnnotation() determines whether or not the scrollbar displays annotations for a given display highlight. attribID is the attribute identifier returned by setHighlightAttributes() of a particular custom highlight. If state is TRUE, the scrollbar displays annotations for the given display highlight; if state is FALSE, the scrollbar does not display annotations for the given display highlight.LBL="C"ID="91883"Using a Help System with ViewKitThis appendix describes how to use a help system with ViewKit applications. It covers:ID="ChC_Help1"the user interfaces through which a user can obtain helpViewKit's programmatic interface (API) to external help libraries and instructions for creating ViewKit-compatible help librariesViewKit's own simple help libraryAdditional support provided by the ViewKit help library for creating help information for your applicationsLBL="" HELPID=""User Interfaces to the Help System in a ViewKit ApplicationIn a ViewKit application, the user can invoke the help system three different ways: 1) by pressing the <F1> key while the mouse pointer is over a widget; 2) by clicking on the Help button in a dialog; or 3) by selecting an item from the Help menu.The ID="ChC_Help2"<F1> key is a standard IRIS IM method of invoking help. ViewKit applications provide an additional layer of interpretation to allow you to integrate this method of invoking help with the other methods provided by ViewKit. Rather than installing XmNhelpCallback functions on widgets, you should use ViewKit's programmatic interface to the help libraries as described in ID="ChC_Help3"IDREF="82752" TYPE="TITLE""ViewKit's Programmatic Interface to a Help Library".ViewKit dialogs also allow you to include a ID="ChC_Help4"ID="ChC_Help5"Help button as described in IDREF="30538" TYPE="TITLE""Posting Dialogs". The Help menu, implemented by the VkHelpPane class, also allows the user to invoke the help system. IDREF="82752" TYPE="TITLE""ViewKit's Programmatic Interface to a Help Library" describes how to link these interfaces to a help system.LBL="" HELPID=""ID="82752"ViewKit's Programmatic Interface to a Help LibraryViewKit applications interact with a help library through three C functions. To interface a ViewKit application to a help system, you need only to implement these three functions. ViewKit also provides a rudimentary help library that you can use if you do not want to implement your own. ID="ChC_Help6"IDREF="93580" TYPE="TITLE""The ViewKit Help Library" describes this library.ID="ChC_Help7"SGIHelpInit() initializes the help system:int SGIHelpInit(Display *display, char *appClass, char *)VkApp calls SGIHelpInit() from its constructor. display is the application's Display structure, and appClass is the application's class name. The third argument to SGIHelpInit() is reserved for future Silicon Graphics use. A return value of 0 indicates failure.A ViewKit application calls ID="ChC_Help8"SGIHelpMsg() when it needs to request help:int SGIHelpMsg(char *in_key, char *, char *)in_key is a character token that SGIHelpMsg() uses to look up help material. The value of in_key depends on how the user requested help. The subsections that follow describe how the value is determined. The other argument to SGIHelpMsg() is reserved for future Silicon Graphics use. A return value of 0 indicates failure.A ViewKit application calls ID="ChC_Help9"SGIHelpIndexMsg() when it needs to display an index of help available:int SGIHelpIndexMsg(char *in_key, char *)in_key is a character token that SGIHelpIndexMsg() uses to look up a help index. The value of in_key depends on how the user requested help. The subsections that follow describe how the value is determined. The other arguments to SGIHelpIndexMsg() are reserved for future Silicon Graphics use. A return value of 0 indicates failure.LBL="" HELPID=""Dialog Help ProceduresWhen you post a dialog as described in ID="ChC_Help10"ID="ChC_Help11"IDREF="30538" TYPE="TITLE""Posting Dialogs", you have the option of providing a helpString argument. If you provide a helpString argument, the dialog posted displays a Help button.When the user clicks on the Help button, your application calls SGIHelpMsg(), passing the helpString as the in_key character token.LBL="" HELPID=""Context-Sensitive Help ProceduresWhen the user presses the ID="ChC_Help12"<F1> key while the mouse pointer is over a widget, as long as you have not provided XmNhelpCallback functions for widgets in your application, your applications calls SGIHelpMsg(). The in_key character token that your application provides to SGIHelpMsg() is the fully-qualified instance name hierarchy for the widget.LBL="" HELPID=""Help Menu ProceduresAs noted in ID="ChC_Help13"IDREF="29804" TYPE="TITLE""The ViewKit Help Menu", the Help menu implemented by the VkHelpPane class contains five selectable items: "Click for Help," "Overview," "Index," "Keys & Shortcuts," and "Product Info.""Click for Help" provides another method of obtaining context-sensitive help. When the user selects this item, the cursor changes into a question mark. The user can then click on any widget in the application. When the user clicks on a widget, the application calls SGIHelpMsg(). The in_key character token that your application provides to SGIHelpMsg() is the fully-qualified instance name hierarchy for the widget."Overview" calls SGIHelpMsg() to request overview help. If the VkHelpPane object is a descendant of a shell widget, the in_key character token that your application provides to SGIHelpMsg() is "shellName.overview" where shellName is the name of the shell widget. In most cases, the VkHelpPane object is a pane in a window's menu bar, so the shellName is the name of the window. If the VkHelpPane object is not a descendent of a shell widget, the in_key character token that your application provides to SGIHelpMsg() is simply "overview"."Index" calls SGIHelpIndexMsg() to request an index of available help topics. If the VkHelpPane object is a descendant of a shell widget, the in_key character token that your application provides to SGIHelpIndexMsg() is "shellName.index" where shellName is the name of the shell widget. In most cases, the VkHelpPane object is a pane in a window's menu bar, so the shellName is the name of the window. If the VkHelpPane object is not a descendent of a shell widget, the in_key character token that your application provides to SGIHelpIndexMsg() is simply "index"."Keys & Shortcuts" calls SGIHelpMsg() to request help on keys and shortcuts. If the VkHelpPane object is a descendant of a shell widget, the in_key character token that your application provides to SGIHelpMsg() is "shellName.keys" where shellName is the name of the shell widget. In most cases, the VkHelpPane object is a pane in a window's menu bar, so the shellName is the name of the window. If the VkHelpPane object is not a descendent of a shell widget, the in_key character token that your application provides to SGIHelpMsg() is simply "keys"."Product Info" displays the Product Information dialog described in IDREF="30388" TYPE="TITLE""Maintaining Product and Version Information". The Product Information dialog has no connection to the help library.LBL="" HELPID=""ID="93580"The ViewKit Help LibraryViewKit provides a rudimentary help library, ID="ChC_Help14"ID="ChC_Help15"libvkhelp, that you can use if you do not want to implement your own. The ViewKit help library does not provide extensive help browsing or other search features; however, it does allow you to include help messages for your application by defining them in the X resource database.The source for the ViewKit help library is included in /usr/share/src/ViewKit/Utilities/VkHelpAPI.c++. You can examine this source to get ideas for implementing your own help library.The ViewKit help library is simple enough not to require any initialization, so SGIHelpInit() is defined to simply return the value 1.Both SGIHelpMsg() and SGIHelpIndexMsg() are defined to accept the in_key character token argument and look up the resource "in_key.helpText" in the X resource library. They then display the help text retrieved from the resource database in an IRIS IM information dialog. If these function cannot find an appropriate resource value, they display the message "Sorry, no help available on this topic" in the dialog.The following lines show how you create the help message specifications for an application:*helpText:             Application default help message
*row1*helpText:        Help message for the row1 widgets and its descendants
*row2*helpText:        Help message for the row2 widgets and its descendants
*row2*start*helpText:  Special help message for start, child widget of row2
*overview*helpText:    Overview help messageIn this example, the "*helpText" resource specification provides a default help message for the entire application. If a widget does not have a more specific help message resource specification, the application displays this default help message.The "*row1*helpText" and "*row2*helpText" resource specifications provide help messages for these widgets and their descendants. For example, you could use a specification like this to provide a help message for a group of toggles or pushbuttons in a RowColumn widget.The "*row2*start*helpText" specification provides a help message for a "start" widget, a descendant of the "row2" widget. It overrides the "*row2*helpText" message."*overview*helpText" provides a message that the application displays when the user selects "Overview" from the Help menu.LBL="" HELPID=""ViewKit Support for Building HelpThe ViewKit help library also provides support for determining the token strings passed to the help system. You must link your application with the ID="ChC_Help16"libvkhelp library to use this feature, but after you determine all of the token strings you needs, you can link with another help library to provide the final help system for your application.To determine the token strings, set the "*helpAuthorMode" resource for your application to TRUE. Then, when you run your application, whenever the help system would normally display a help message, it instead displays the token string passed to the help system.ID="ChC_Help17"menu bars0IDREF="Ch05_Menus131"Menu Bar"Click for Help" selection (in Help menu)IDREF="Ch05_Menus185"Implementation of the Help Menu"Close" selection (in Admin menu)IDREF="Ch09_Graph20"Graph Overview"Collapse Selected Nodes" (in Selected Nodes menu)IDREF="Ch09_Graph42"Edit Mode Operations"Collapse Subgraph" selection (in Node menu)IDREF="Ch09_Graph32"Hiding and Displaying Nodes"Expand Selected Nodes" (in Selected Nodes menu)IDREF="Ch09_Graph44"Edit Mode Operations"helpAuthorMode" resourceIDREF="ChC_Help17"ViewKit Support for Building Help"Hide Node" selection (in Node menu)IDREF="Ch09_Graph31"Hiding and Displaying Nodes"Hide Selected Nodes" (in Selected Nodes menu)IDREF="Ch09_Graph41"Edit Mode Operations"Index" selection (in Help menu)IDREF="Ch05_Menus187"Implementation of the Help Menu"Keys & Shortcuts" selection (in Help menu)IDREF="Ch05_Menus188"Implementation of the Help Menu"labelString" resource (in VkAction)IDREF="Ch06_Undo51"Setting the Label Used by Command Classes"noUndoQuestion" resource (in VkMenuConfirmFirstAction)IDREF="Ch05_Menus59"Confirmable Menu Actions"Overview" selection (in Help menu)IDREF="Ch05_Menus186"Implementation of the Help Menu"Product Info" selection (in Help menu)IDREF="Ch05_Menus189"Implementation of the Help MenuIDREF="Ch03_App104"Maintaining Product and Version Information"safe quit" mechanismIDREF="Ch04_Windows141"Providing a "Safe Quit" MechanismIDREF="Ch02_Components55"VkComponent Utility FunctionsIDREF="Ch03_App31"Quitting ViewKit Applications"Scale to Fit" selection (in Admin menu)IDREF="Ch09_Graph18"Graph Overview"Show Arcs" selection (in Admin menu)IDREF="Ch09_Graph19"Graph Overview"Show Immediate Children" selection (in Node menu)IDREF="Ch09_Graph33"Hiding and Displaying Nodes"Show Parents" selection (in Node menu)IDREF="Ch09_Graph34"Hiding and Displaying Nodes"Undo" menu selection labelIDREF="Ch06_Undo28"Setting the Label of the Undo Manager Menu Item[] (subscript) operator (in VkMenu)IDREF="Ch05_Menus126"Menu Access Functionsactivatingcommand classesIDREF="Ch06_Undo46"Activating Command Classesmenu itemsIDREF="Ch05_Menus111"Activating and Deactivating Items in a MenuIDREF="Ch05_Menus30"Activating and Deactivating Menu Itemspreference itemsIDREF="Ch08_Pref30"Preference Item Access Functionsaddingbuttons to radio groupIDREF="Ch11_Input123"Adding Toggles and Buttons to a Radio Groupitems to meter componentIDREF="ChB_Contrib8"Adding Items to a Meternodes to graphsIDREF="Ch09_Graph75"Adding Nodes and Specifying Node Connectivitypixmaps to tabsIDREF="Ch11_Input40"Adding a Pixmap to a Tabscrollbars to a ganged groupIDREF="Ch11_Input108"Adding Scales and Scrollbars to a Ganged Grouptabs to tab panelIDREF="Ch11_Input34"Adding Tabs to a Tab Paneltoggles to check boxIDREF="Ch11_Input8"Adding Toggles to the Check Boxwidgets to alignment groupIDREF="Ch10_Display37"Adding Widgets and Components to an Alignment GroupAdmin menu (in graph overview window)IDREF="Ch09_Graph17"Graph Overviewaligningnodes in graphsIDREF="Ch09_Graph24"Realigning NodesIDREF="Ch09_Graph104"Laying Out the GraphwidgetsIDREF="Ch10_Display34"ViewKit Support for Aligning Widgets0IDREF="Ch10_Display31"ViewKit Support for Aligning Widgetsalignment groupsIDREF="Ch10_Display34"ViewKit Support for Aligning Widgets0IDREF="Ch10_Display33"ViewKit Support for Aligning Widgetsadding widgetsIDREF="Ch10_Display37"Adding Widgets and Components to an Alignment Groupaligning widgetsIDREF="Ch10_Display41"Aligning Widgets and Components in an Alignment Groupremoving widgetsIDREF="Ch10_Display39"Removing Widgets and Components from an Alignment Groupapplications:See alsoVkApp classIDREF="Ch03_App2"The ViewKit Application Classbusy statesIDREF="Ch03_App75"Supporting Busy StatesIDREF="Ch07_Dialogs72"The Busy Dialog0IDREF="Ch03_App78"Entering and Exiting Busy States Using ViewKitbusy dialogIDREF="Ch03_App89"Installing Different Busy DialogsIDREF="Ch03_App80"Entering and Exiting Busy States Using ViewKitenteringIDREF="Ch03_App76"Entering and Exiting Busy States Using ViewKitexampleIDREF="Ch03_App85"Entering and Exiting Busy States Using ViewKitexitingIDREF="Ch03_App81"Entering and Exiting Busy States Using ViewKitnestedIDREF="Ch03_App83"Entering and Exiting Busy States Using ViewKitclass nameIDREF="Ch03_App13"The VkApp ConstructorIDREF="Ch03_App110"Application Data Access Functionscommand-line options, parsingIDREF="Ch03_App15"The VkApp ConstructorIDREF="Ch03_App128"VkApp Protected Functions and Data MembersexampleIDREF="Ch03_App133"Example of Subclassing VkAppcursorsIDREF="Ch03_App56"Setting Application Cursorsbusy, animatedIDREF="Ch03_App62"Setting and Retrieving the Busy CursorIDREF="Ch03_App66"Creating, Setting, and Retrieving an Animated Busy CursorIDREF="Ch03_App86"Animating the Busy Cursorbusy, fixedIDREF="Ch03_App61"Setting and Retrieving the Busy CursordefaultIDREF="Ch03_App57"Setting Application CursorsIDREF="Ch03_App63"Setting and Retrieving the Busy CursornormalIDREF="Ch03_App58"Setting and Retrieving the Normal CursortemporaryIDREF="Ch03_App73"Setting and Retrieving a Temporary CursorDisplay structureIDREF="Ch03_App115"Application Data Access Functionsevent handlingIDREF="Ch03_App18"Running ViewKit Applicationsduring postAndWait()IDREF="Ch07_Dialogs30"Methods of Posting Dialogsduring sendSyncRequest()IDREF="ChA_ToolTalk35"Sending Synchronous Requestsduring wasInterrupted()IDREF="Ch07_Dialogs82"The Interruptible Busy Dialogpending eventsIDREF="Ch03_App27"ViewKit Event Handlingraw eventsIDREF="Ch03_App22"ViewKit Event HandlingIDREF="Ch04_Windows154"Handling Raw EventsnameIDREF="Ch03_App108"Application Data Access FunctionsIDREF="Ch03_App14"The VkApp ConstructorpointerIDREF="Ch03_App12"The VkApp Constructorproduct informationIDREF="Ch03_App100"Maintaining Product and Version InformationquittingIDREF="Ch02_Components55"VkComponent Utility FunctionsIDREF="Ch07_Dialogs66"Fatal Error DialogsIDREF="Ch04_Windows120"Window Properties and Shell ResourcesIDREF="Ch03_App31"Quitting ViewKit ApplicationsIDREF="Ch04_Windows28"Window Class DestructorsIDREF="Ch04_Windows141"Providing a "Safe Quit" MechanismrunningIDREF="Ch03_App17"Running ViewKit ApplicationsshellIDREF="Ch04_Windows7"ViewKit's Multi-Window ModelIDREF="Ch03_App9"The VkApp ConstructorIDREF="Ch03_App125"Application Data Access FunctionsgeometryIDREF="Ch03_App117"Application Data Access Functionsversion informationIDREF="Ch03_App96"Maintaining Product and Version Informationwindows, managingIDREF="Ch04_Windows68"Manipulating WindowsIDREF="Ch03_App37"Managing Top-Level WindowsXtAppContext structureIDREF="Ch03_App113"Application Data Access Functionsarcs (in graphs)attributesIDREF="Ch09_Graph78"Adding Nodes and Specifying Node ConnectivityattachmentsIDREF="Ch10_Display28"Management Classes for Controlling Component and Widget Display CharacteristicsIDREF="Ch11_Input99"Management Classes for Controlling Component and Widget Operationalignment groupsIDREF="Ch10_Display29"ViewKit Support for Aligning Widgetsganged scrollbarsIDREF="Ch11_Input100"Supporting "Ganged" Scrollbar Operationmodified textIDREF="Ch11_Input131"Modified Text Attachmentradio-style togglesIDREF="Ch11_Input114"Enforcing Radio-Style Behavior on Toggle ButtonsresizersIDREF="Ch10_Display55"ViewKit Support for Resizing and Moving Widgetsattributesarcs in graphsIDREF="Ch09_Graph78"Adding Nodes and Specifying Node Connectivitybase widget:See alsobaseWidget()IDREF="Ch02_Components43"VkComponent Access FunctionsapplicationsIDREF="Ch03_App126"Application Data Access FunctionscomponentsIDREF="Ch02_Components10"The VkComponent ClassIDREF="Ch02_Components46"VkComponent Access FunctionsIDREF="Ch02_Components35"Component DestructorsIDREF="Ch02_Components23"Component Constructorsdeletion, handlingIDREF="Ch02_Components76"Handling Component Widget Destructionpreference itemsIDREF="Ch08_Pref21"Preference Item LabelsIDREF="Ch08_Pref34"Preference Item Access Functionsrealization, detectingIDREF="Ch02_Components53"Displaying and Hiding ComponentswindowsIDREF="Ch04_Windows46"Creating the Window Interface in the Constructorblocking, modal dialogsIDREF="Ch07_Dialogs21"Methods of Posting DialogsIDREF="Ch07_Dialogs19"Methods of Posting DialogsVkAction class:See also command classes; VkMenuActionObject classIDREF="Ch06_Undo34"Overview of Command ClassesactivatingIDREF="Ch06_Undo48"Activating Command ClassesexecutingIDREF="Ch06_Undo48"Activating Command Classesinheritance graphIDREF="Ch06_Undo1"ViewKit Undo Management and Command Classesmember functionsconstructorIDREF="Ch06_Undo38"Command Class Constructorsdoit()IDREF="Ch06_Undo44"Overriding Virtual Functionsundoit()IDREF="Ch06_Undo42"Overriding Virtual FunctionsVkAction()IDREF="Ch06_Undo38"Command Class ConstructorsoverviewIDREF="Ch06_Undo36"Overview of Command Classessetting label for "Undo" selectionIDREF="Ch06_Undo50"Setting the Label Used by Command ClassesVkAlignmentGroup classIDREF="Ch10_Display34"ViewKit Support for Aligning Widgets0IDREF="Ch10_Display32"ViewKit Support for Aligning Widgetsadding widgetsIDREF="Ch10_Display37"Adding Widgets and Components to an Alignment Groupaligning widgetsIDREF="Ch10_Display41"Aligning Widgets and Components in an Alignment Groupinheritance graphIDREF="Ch10_Display1"Miscellaneous ViewKit Display Classesmember functionsconstructorIDREF="Ch10_Display35"The Alignment Group Constructor and DestructordestructorIDREF="Ch10_Display36"The Alignment Group Constructor and Destructoradd()IDREF="Ch10_Display38"Adding Widgets and Components to an Alignment GroupalignBottom()IDREF="Ch10_Display45"Aligning Widgets and Components in an Alignment GroupalignHeight()IDREF="Ch10_Display47"Aligning Widgets and Components in an Alignment GroupalignLeft()IDREF="Ch10_Display42"Aligning Widgets and Components in an Alignment GroupalignRight()IDREF="Ch10_Display43"Aligning Widgets and Components in an Alignment GroupalignTop()IDREF="Ch10_Display44"Aligning Widgets and Components in an Alignment GroupalignWidth()IDREF="Ch10_Display46"Aligning Widgets and Components in an Alignment GroupdistributeHorizontal()IDREF="Ch10_Display50"Aligning Widgets and Components in an Alignment GroupdistributeVertical()IDREF="Ch10_Display49"Aligning Widgets and Components in an Alignment Groupheight()IDREF="Ch10_Display52"Alignment Group Access FunctionsmakeNormal()IDREF="Ch10_Display48"Aligning Widgets and Components in an Alignment Groupremove()IDREF="Ch10_Display40"Removing Widgets and Components from an Alignment GroupVkAlignmentGroup()IDREF="Ch10_Display35"The Alignment Group Constructor and Destructorwidth()IDREF="Ch10_Display51"Alignment Group Access Functionsx()IDREF="Ch10_Display53"Alignment Group Access Functionsy()IDREF="Ch10_Display54"Alignment Group Access Functions~VkAlignmentGroup()IDREF="Ch10_Display36"The Alignment Group Constructor and Destructorremoving widgetsIDREF="Ch10_Display39"Removing Widgets and Components from an Alignment GroupVkApp classIDREF="Ch03_App3"The ViewKit Application Class0IDREF="Ch03_App1"The ViewKit Application Classapplication nameIDREF="Ch03_App14"The VkApp ConstructorIDREF="Ch03_App108"Application Data Access Functionsapplication pointerIDREF="Ch03_App12"The VkApp Constructorbusy statesIDREF="Ch07_Dialogs72"The Busy DialogIDREF="Ch03_App75"Supporting Busy States0IDREF="Ch03_App79"Entering and Exiting Busy States Using ViewKitbusy dialogIDREF="Ch03_App80"Entering and Exiting Busy States Using ViewKitIDREF="Ch03_App89"Installing Different Busy DialogsenteringIDREF="Ch03_App76"Entering and Exiting Busy States Using ViewKitexampleIDREF="Ch03_App85"Entering and Exiting Busy States Using ViewKitexitingIDREF="Ch03_App81"Entering and Exiting Busy States Using ViewKitnestedIDREF="Ch03_App83"Entering and Exiting Busy States Using ViewKitclass nameIDREF="Ch03_App110"Application Data Access FunctionsIDREF="Ch03_App13"The VkApp Constructorcommand-line options, parsingIDREF="Ch03_App15"The VkApp ConstructorIDREF="Ch03_App128"VkApp Protected Functions and Data MembersexampleIDREF="Ch03_App133"Example of Subclassing VkAppcomponent nameIDREF="Ch03_App108"Application Data Access FunctionsIDREF="Ch03_App14"The VkApp ConstructorcursorsIDREF="Ch03_App56"Setting Application Cursorsbusy, animatedIDREF="Ch03_App66"Creating, Setting, and Retrieving an Animated Busy CursorIDREF="Ch03_App62"Setting and Retrieving the Busy CursorIDREF="Ch03_App86"Animating the Busy Cursorbusy, fixedIDREF="Ch03_App61"Setting and Retrieving the Busy CursordefaultIDREF="Ch03_App63"Setting and Retrieving the Busy CursorIDREF="Ch03_App57"Setting Application CursorsnormalIDREF="Ch03_App58"Setting and Retrieving the Normal CursortemporaryIDREF="Ch03_App73"Setting and Retrieving a Temporary Cursordata members_winListIDREF="Ch03_App131"VkApp Protected Functions and Data MemberstheApplicationIDREF="Ch03_App11"The VkApp ConstructorViewKitMajorReleaseIDREF="Ch03_App97"Maintaining Product and Version InformationViewKitMinorReleaseIDREF="Ch03_App98"Maintaining Product and Version InformationViewKitReleaseStringIDREF="Ch03_App99"Maintaining Product and Version InformationDisplay structureIDREF="Ch03_App115"Application Data Access Functionsevent handlingIDREF="Ch03_App18"Running ViewKit Applicationsduring postAndWait()IDREF="Ch07_Dialogs30"Methods of Posting Dialogsduring sendSyncRequest()IDREF="ChA_ToolTalk35"Sending Synchronous Requestsduring wasInterrupted()IDREF="Ch07_Dialogs82"The Interruptible Busy Dialogpending eventsIDREF="Ch03_App27"ViewKit Event Handlingraw eventsIDREF="Ch04_Windows154"Handling Raw EventsIDREF="Ch03_App22"ViewKit Event Handlinginheritance graphIDREF="Ch03_App4"The ViewKit Application Classmember functionsconstructorIDREF="Ch03_App7"The VkApp ConstructoraboutDialog()IDREF="Ch03_App106"Maintaining Product and Version InformationafterRealizeHook()IDREF="Ch03_App130"VkApp Protected Functions and Data MembersappContext()IDREF="Ch03_App112"Application Data Access FunctionsapplicationClassName()IDREF="Ch03_App109"Application Data Access Functionsargc()IDREF="Ch03_App118"Application Data Access Functionsargv()IDREF="Ch03_App120"Application Data Access FunctionsbaseWidget()IDREF="Ch03_App124"Application Data Access Functionsbusy()IDREF="Ch03_App77"Entering and Exiting Busy States Using ViewKitbusyCursor()IDREF="Ch03_App72"Creating, Setting, and Retrieving an Animated Busy CursorIDREF="Ch03_App65"Setting and Retrieving a Fixed Busy CursorclassName()IDREF="Ch03_App111"Application Data Access Functionsdisplay()IDREF="Ch03_App114"Application Data Access FunctionshandlePendingEvents()IDREF="Ch03_App28"ViewKit Event HandlinghandleRawEvent()IDREF="Ch03_App23"ViewKit Event Handlinghide()IDREF="Ch03_App45"Managing Top-Level Windowsiconify()IDREF="Ch03_App47"Managing Top-Level Windowslower()IDREF="Ch03_App53"Managing Top-Level WindowsmainWindow()IDREF="Ch03_App41"Managing Top-Level Windowsname()IDREF="Ch03_App107"Application Data Access FunctionsnormalCursor()IDREF="Ch03_App60"Setting and Retrieving the Normal CursornotBusy()IDREF="Ch03_App82"Entering and Exiting Busy States Using ViewKitopen()IDREF="Ch03_App49"Managing Top-Level WindowsparseCommandLine()IDREF="Ch03_App129"VkApp Protected Functions and Data Membersprogressing()IDREF="Ch03_App87"Animating the Busy CursorquitYourself()IDREF="Ch03_App32"Quitting ViewKit ApplicationsIDREF="Ch02_Components57"VkComponent Utility FunctionsIDREF="Ch04_Windows124"Window Properties and Shell Resourcesraise()IDREF="Ch03_App51"Managing Top-Level Windowsrun()IDREF="Ch03_App19"Running ViewKit ApplicationssetAboutDialog()IDREF="Ch03_App105"Maintaining Product and Version InformationsetBusyCursor()IDREF="Ch03_App64"Setting and Retrieving a Fixed Busy CursorIDREF="Ch03_App71"Creating, Setting, and Retrieving an Animated Busy CursorsetBusyDialog()IDREF="Ch03_App90"Installing Different Busy DialogssetMainWindow()IDREF="Ch03_App39"Managing Top-Level WindowssetNormalCursor()IDREF="Ch03_App59"Setting and Retrieving the Normal CursorsetVersionString()IDREF="Ch03_App101"Maintaining Product and Version InformationshellGeometry()IDREF="Ch03_App116"Application Data Access Functionsshow()IDREF="Ch03_App43"Managing Top-Level WindowsshowCursor()IDREF="Ch03_App74"Setting and Retrieving a Temporary CursorstartupIconified()IDREF="Ch03_App122"Application Data Access FunctionsIDREF="Ch03_App55"Managing Top-Level Windowsterminate()IDREF="Ch07_Dialogs67"Fatal Error DialogsIDREF="Ch03_App35"Quitting ViewKit ApplicationsIDREF="Ch04_Windows29"Window Class DestructorsversionString()IDREF="Ch03_App102"Maintaining Product and Version InformationVkApp()IDREF="Ch03_App7"The VkApp ConstructoroverviewIDREF="Ch03_App6"Overview of the VkApp Classproduct informationIDREF="Ch03_App100"Maintaining Product and Version Informationquitting applicationsIDREF="Ch04_Windows28"Window Class DestructorsIDREF="Ch04_Windows120"Window Properties and Shell ResourcesIDREF="Ch04_Windows141"Providing a "Safe Quit" MechanismIDREF="Ch02_Components55"VkComponent Utility FunctionsIDREF="Ch07_Dialogs66"Fatal Error DialogsIDREF="Ch03_App31"Quitting ViewKit Applicationsrunning applicationsIDREF="Ch03_App17"Running ViewKit Applicationsshell, applicationIDREF="Ch03_App9"The VkApp ConstructorIDREF="Ch04_Windows7"ViewKit's Multi-Window ModelIDREF="Ch03_App125"Application Data Access FunctionsgeometryIDREF="Ch03_App117"Application Data Access FunctionssubclassingIDREF="Ch03_App127"Deriving Classes from VkAppexampleIDREF="Ch03_App132"Example of Subclassing VkApptypical useIDREF="Ch03_App21"Running ViewKit Applicationsversion informationIDREF="Ch03_App96"Maintaining Product and Version InformationViewKit callbacks0IDREF="Ch02_Components102"ViewKit Callback Supportwindows, managingIDREF="Ch03_App37"Managing Top-Level WindowsIDREF="Ch04_Windows68"Manipulating WindowsXtAppContext structureIDREF="Ch03_App113"Application Data Access FunctionsVkBusyDialog classIDREF="Ch07_Dialogs71"The Busy Dialog0IDREF="Ch07_Dialogs70"The Busy Dialoginheritance graphIDREF="Ch07_Dialogs5"Using Dialogs in ViewKitinstalling as busy dialogIDREF="Ch03_App91"Installing Different Busy DialogstheBusyDialogIDREF="Ch07_Dialogs73"The Busy DialogVkCallbackObject class:See also ViewKit callbacks; VkComponent classIDREF="Ch02_Components103"ViewKit Callback SupportVkCallbackObject classIDREF="Ch02_Components109"ViewKit Callback Supportinheritance graphIDREF="Ch02_Components4"Componentsmember functionsaddCallback()IDREF="Ch02_Components111"Registering ViewKit CallbackscallCallbacks()IDREF="Ch02_Components127"Defining and Triggering ViewKit CallbacksremoveAllCallbacks()IDREF="Ch02_Components122"Removing ViewKit CallbacksremoveCallback()IDREF="Ch02_Components121"Removing ViewKit CallbacksVkCheckBox classIDREF="Ch11_Input6"The Check Box Component0IDREF="Ch11_Input4"The Check Box Componentdata members_labelIDREF="Ch11_Input24"Using SubClassing to Handle Changes in Check Box Toggle Values_rcIDREF="Ch11_Input23"Using SubClassing to Handle Changes in Check Box Toggle Values_widgetListIDREF="Ch11_Input22"Using SubClassing to Handle Changes in Check Box Toggle ValuesexampleIDREF="Ch11_Input11"Setting Check Box and Toggle Labelsinheritance graphIDREF="Ch11_Input1"Miscellaneous ViewKit Data Input Classesmember functionsconstructorIDREF="Ch11_Input7"Creating a Check BoxaddItem()IDREF="Ch11_Input9"Adding Toggles to the Check BoxgetValue()IDREF="Ch11_Input16"Setting and Getting Check Box Toggle ValuessetValue()IDREF="Ch11_Input13"Setting and Getting Check Box Toggle ValuessetValues()IDREF="Ch11_Input14"Setting and Getting Check Box Toggle ValuesvalueChanged()IDREF="Ch11_Input21"Using SubClassing to Handle Changes in Check Box Toggle ValuesVkCheckBox()IDREF="Ch11_Input7"Creating a Check Boxsetting labelsIDREF="Ch11_Input10"Setting Check Box and Toggle LabelssubclassingIDREF="Ch11_Input20"Using SubClassing to Handle Changes in Check Box Toggle ValuestogglesaddingIDREF="Ch11_Input8"Adding Toggles to the Check Boxdetecting value changesIDREF="Ch11_Input17"Recognizing Changes in Check Box Toggle Valuesgetting valuesIDREF="Ch11_Input15"Setting and Getting Check Box Toggle Valuessetting valuesIDREF="Ch11_Input12"Setting and Getting Check Box Toggle ValuesViewKit callbacksitemChangedIDREF="Ch11_Input18"Using ViewKit Callbacks to Handle Changes in Check Box Toggle ValuesVkCompletionField classIDREF="Ch11_Input68"The Text Completion Field Component0IDREF="Ch11_Input67"The Text Completion Field Componentactivation, respondingIDREF="Ch11_Input78"Responding to Text Completion Field Activationclearing expansion listIDREF="Ch11_Input73"Setting and Clearing the Text Completion Field Expansion Listdata members_currentMatchListIDREF="Ch11_Input83"Deriving Text Completion Field Subclasses_nameListIDREF="Ch11_Input84"Deriving Text Completion Field Subclassesinheritance graphIDREF="Ch11_Input2"Miscellaneous ViewKit Data Input Classesmember functionsconstructorIDREF="Ch11_Input69"The Text Completion Field Constructor and DestructordestructorIDREF="Ch11_Input70"The Text Completion Field Constructor and Destructoractivate()IDREF="Ch11_Input85"Deriving Text Completion Field Subclassesadd()IDREF="Ch11_Input72"Setting and Clearing the Text Completion Field Expansion Listclear()IDREF="Ch11_Input74"Setting and Clearing the Text Completion Field Expansion Listexpand()IDREF="Ch11_Input82"Deriving Text Completion Field SubclassesgetText()IDREF="Ch11_Input77"Retrieving the Text Completion Field ContentsVkCompletionField()IDREF="Ch11_Input69"The Text Completion Field Constructor and Destructor~VkCompletionField()IDREF="Ch11_Input70"The Text Completion Field Constructor and Destructorreplacing expansion listIDREF="Ch11_Input75"Setting and Clearing the Text Completion Field Expansion Listretrieving contentsIDREF="Ch11_Input76"Retrieving the Text Completion Field Contentssetting expansion listIDREF="Ch11_Input71"Setting and Clearing the Text Completion Field Expansion ListsubclassingIDREF="Ch11_Input81"Deriving Text Completion Field SubclassesViewKit callbacksenterCallbackIDREF="Ch11_Input79"Responding to Text Completion Field ActivationVkComponent class:See also components; VkCallbackObject classIDREF="Ch02_Components6"The VkComponent Classbase widgetIDREF="Ch02_Components35"Component DestructorsIDREF="Ch02_Components10"The VkComponent ClassIDREF="Ch02_Components46"VkComponent Access FunctionsIDREF="Ch02_Components23"Component Constructorsdeletion, handlingIDREF="Ch02_Components77"Handling Component Widget Destructionrealization, detectingIDREF="Ch02_Components53"Displaying and Hiding Componentscallbacks. SeeVkCallbackObject class; VkComponent class Xt callbacksIDREF="Ch02_Components60"Using Xt Callbacks with Componentsclass nameIDREF="Ch02_Components83"Component Resource SupportIDREF="Ch02_Components41"VkComponent Access Functionsdata members_baseWidgetIDREF="Ch02_Components22"Component ConstructorsIDREF="Ch02_Components26"Component ConstructorsIDREF="Ch02_Components47"VkComponent Access Functions_nameIDREF="Ch02_Components27"Component ConstructorsIDREF="Ch02_Components38"VkComponent Access FunctionsIDREF="Ch02_Components20"Component ConstructorsdisplayingIDREF="Ch02_Components50"Displaying and Hiding ComponentshidingIDREF="Ch02_Components49"Displaying and Hiding Componentsinheritance graphIDREF="Ch02_Components4"Componentsmanaging widgetsIDREF="Ch02_Components13"The VkComponent ClassIDREF="Ch02_Components30"Component Constructorsmember functionsconstructorIDREF="Ch02_Components18"Component ConstructorsdestructorIDREF="Ch02_Components31"Component DestructorsafterRealizeHook()IDREF="Ch02_Components54"Displaying and Hiding ComponentsbaseWidget()IDREF="Ch02_Components45"VkComponent Access FunctionsclassName()IDREF="Ch02_Components84"Component Resource SupportIDREF="Ch02_Components42"VkComponent Access FunctionsgetResources()IDREF="Ch02_Components89"Initializing Data Members Based on Resource Valueshide()IDREF="Ch02_Components52"Displaying and Hiding ComponentsinstallDestroyHandler()IDREF="Ch02_Components29"Component ConstructorsIDREF="Ch02_Components78"Handling Component Widget DestructionisComponent()IDREF="Ch02_Components59"VkComponent Utility Functionsname()IDREF="Ch02_Components37"VkComponent Access FunctionsokToQuit()IDREF="Ch02_Components56"VkComponent Utility FunctionsremoveDestroyHandler()IDREF="Ch02_Components79"Handling Component Widget DestructionsetDefaultResources()IDREF="Ch02_Components92"Setting Default Resource Values for a Componentshow()IDREF="Ch02_Components51"Displaying and Hiding ComponentsVkComponent()IDREF="Ch02_Components18"Component ConstructorswidgetDestroyedCallback()IDREF="Ch02_Components75"Handling Component Widget Destruction~VkComponent()IDREF="Ch02_Components31"Component Destructorsmultiple pointers to componentIDREF="Ch02_Components130"Predefined ViewKit CallbacksnameIDREF="Ch02_Components36"VkComponent Access FunctionsIDREF="Ch02_Components11"The VkComponent ClassIDREF="Ch02_Components85"Component Resource SupportIDREF="Ch02_Components19"Component ConstructorsoperatorsWidgetIDREF="Ch02_Components48"VkComponent Access FunctionsoverviewIDREF="Ch02_Components8"The VkComponent Classparent widgetIDREF="Ch02_Components12"The VkComponent ClassIDREF="Ch02_Components25"Component Constructorsresource supportIDREF="Ch02_Components80"Component Resource Supportdata members, initializingIDREF="Ch02_Components88"Initializing Data Members Based on Resource Valuesdefault values, settingIDREF="Ch02_Components91"Setting Default Resource Values for a Componentglobal values, settingIDREF="Ch02_Components93"Setting Default Resource Values for a ComponentrequirementsIDREF="Ch02_Components82"Component Resource Supportresource values, settingIDREF="Ch02_Components86"Setting Resource Values by Class or Individual Componentvalues, retrievingIDREF="Ch02_Components96"Convenience Function for Retrieving Resource Valueswidget resources, noteIDREF="Ch02_Components1"Componentsstatic member functions and Xt callbacksIDREF="Ch02_Components16"The VkComponent ClassIDREF="Ch02_Components64"Using Xt Callbacks with ComponentsexampleIDREF="Ch02_Components73"Using Xt Callbacks with Componentsnaming conventionIDREF="Ch02_Components71"Using Xt Callbacks with Componentsthis pointerIDREF="Ch02_Components68"Using Xt Callbacks with ComponentssubclassingIDREF="Ch02_Components133"Deriving Subclasses to Create New ComponentsconstructorIDREF="Ch02_Components24"Component ConstructorsexamplesIDREF="Ch02_Components135"Example of Creating a New ComponentVkComponent()IDREF="Ch02_Components24"Component ConstructorssummaryIDREF="Ch02_Components134"Subclassing Summarytesting for valid componentIDREF="Ch02_Components58"VkComponent Utility FunctionsViewKit callbacksdeleteCallbackIDREF="Ch02_Components32"Component DestructorsIDREF="Ch02_Components128"Predefined ViewKit Callbackswidget destructionIDREF="Ch02_Components74"Handling Component Widget DestructionIDREF="Ch02_Components34"Component DestructorsIDREF="Ch02_Components14"The VkComponent ClassIDREF="Ch02_Components28"Component ConstructorswidgetsIDREF="Ch02_Components9"The VkComponent ClassIDREF="Ch02_Components21"Component ConstructorsXt callbacksIDREF="Ch02_Components64"Using Xt Callbacks with ComponentsIDREF="Ch02_Components16"The VkComponent ClassexampleIDREF="Ch02_Components73"Using Xt Callbacks with Componentsnaming conventionIDREF="Ch02_Components71"Using Xt Callbacks with Componentsthis pointerIDREF="Ch02_Components68"Using Xt Callbacks with ComponentsVkCursorList classdata members_cursorListIDREF="Ch03_App69"Creating, Setting, and Retrieving an Animated Busy Cursorinheritance graphIDREF="Ch03_App5"The ViewKit Application Classmember functionsconstructorIDREF="Ch03_App67"Creating, Setting, and Retrieving an Animated Busy CursorcreateCursor()IDREF="Ch03_App68"Creating, Setting, and Retrieving an Animated Busy CursorVkCursorList()IDREF="Ch03_App67"Creating, Setting, and Retrieving an Animated Busy CursorVkDialogManager classIDREF="Ch07_Dialogs11"The ViewKit Dialog Base Class0IDREF="Ch07_Dialogs10"The ViewKit Dialog Base Classbutton labels, settingIDREF="Ch07_Dialogs39"Setting the Button LabelsApply buttonIDREF="Ch07_Dialogs25"Methods of Posting DialogsCancel buttonIDREF="Ch07_Dialogs24"Methods of Posting DialogsHelp buttonIDREF="Ch07_Dialogs27"Methods of Posting DialogsIDREF="ChC_Help4"User Interfaces to the Help System in a ViewKit ApplicationIDREF="ChC_Help10"Dialog Help ProceduresOK buttonIDREF="Ch07_Dialogs23"Methods of Posting Dialogscentering algorithmIDREF="Ch07_Dialogs41"Dialog Access and Utility Functionsinheritance graphIDREF="Ch07_Dialogs3"Using Dialogs in ViewKitmember functionsapply()IDREF="Ch07_Dialogs127"Deriving New Dialog Classes Using the Generic Dialogcancel()IDREF="Ch07_Dialogs126"Deriving New Dialog Classes Using the Generic DialogcenterOnScreen()IDREF="Ch07_Dialogs42"Dialog Access and Utility FunctionslastPosted()IDREF="Ch07_Dialogs43"Dialog Access and Utility Functionsok()IDREF="Ch07_Dialogs125"Deriving New Dialog Classes Using the Generic Dialogpost()IDREF="Ch07_Dialogs14"Methods of Posting DialogspostAndWait()IDREF="Ch07_Dialogs29"Methods of Posting DialogsIDREF="Ch07_Dialogs20"Methods of Posting DialogspostBlocked()IDREF="Ch07_Dialogs18"Methods of Posting DialogspostModal()IDREF="Ch07_Dialogs16"Methods of Posting DialogssetButtonLabels()IDREF="Ch07_Dialogs40"Setting the Button LabelssetTitle()IDREF="Ch07_Dialogs38"Setting the Title of the Dialogunpost()IDREF="Ch07_Dialogs35"Unposting DialogsunpostAll()IDREF="Ch07_Dialogs36"Unposting DialogsmessageIDREF="Ch07_Dialogs22"Methods of Posting Dialogsparent widgetIDREF="Ch07_Dialogs28"Methods of Posting DialogspostingIDREF="Ch07_Dialogs12"Posting DialogsexamplesIDREF="Ch07_Dialogs33"Examples of Posting DialogsmethodsIDREF="Ch07_Dialogs13"Methods of Posting Dialogstitle, settingIDREF="Ch07_Dialogs37"Setting the Title of the DialogunpostingIDREF="Ch07_Dialogs34"Unposting DialogsVkDoubleBuffer classIDREF="Ch10_Display4"ViewKit Support for Double-Buffered Graphics0IDREF="Ch10_Display3"ViewKit Support for Double-Buffered Graphicsdata members_canvasIDREF="Ch10_Display10"Drawing in the Double Buffer Component_heightIDREF="Ch10_Display16"Handling Double Buffer Component Resize Requests_widthIDREF="Ch10_Display15"Handling Double Buffer Component Resize RequestsdrawingIDREF="Ch10_Display8"Drawing in the Double Buffer Componentinheritance graphIDREF="Ch10_Display1"Miscellaneous ViewKit Display Classesmember functionsconstructorIDREF="Ch10_Display5"Double Buffer Constructor and DestructordestructorIDREF="Ch10_Display6"Double Buffer Constructor and Destructordraw()IDREF="Ch10_Display9"Drawing in the Double Buffer Componentresize()IDREF="Ch10_Display14"Handling Double Buffer Component Resize Requestsupdate()IDREF="Ch10_Display12"Switching Buffers in the Double Buffer ComponentVkDoubleBuffer()IDREF="Ch10_Display5"Double Buffer Constructor and Destructor~VkDoubleBuffer()IDREF="Ch10_Display6"Double Buffer Constructor and DestructorresizingIDREF="Ch10_Display13"Handling Double Buffer Component Resize Requestsswitching buffersIDREF="Ch10_Display11"Switching Buffers in the Double Buffer ComponentVkErrorDialog classIDREF="Ch07_Dialogs57"Error Dialogs0IDREF="Ch07_Dialogs56"Error Dialogsinheritance graphIDREF="Ch07_Dialogs4"Using Dialogs in ViewKittheErrorDialogIDREF="Ch07_Dialogs58"Error DialogsVkFatalErrorDialog classIDREF="Ch07_Dialogs63"Fatal Error Dialogs0IDREF="Ch07_Dialogs62"Fatal Error Dialogsinheritance graphIDREF="Ch07_Dialogs4"Using Dialogs in ViewKittheFatalErrorDialogIDREF="Ch07_Dialogs65"Fatal Error DialogsVkFileSelectionDialog classIDREF="Ch07_Dialogs104"The File Selection Dialog0IDREF="Ch07_Dialogs103"The File Selection DialogcautionIDREF="Ch07_Dialogs110"The File Selection Dialoginheritance graphIDREF="Ch07_Dialogs7"Using Dialogs in ViewKitmember functionsfileName()IDREF="Ch07_Dialogs109"The File Selection DialogsetDirectory()IDREF="Ch07_Dialogs106"The File Selection DialogsetFilterPattern()IDREF="Ch07_Dialogs107"The File Selection DialogsetSelection()IDREF="Ch07_Dialogs108"The File Selection DialogtheFileSelectionDialogIDREF="Ch07_Dialogs105"The File Selection DialogVkGangedGroup class:See also ganged scrollbarsIDREF="Ch11_Input104"Supporting "Ganged" Scrollbar OperationVkGangedGroup classIDREF="Ch11_Input105"Supporting "Ganged" Scrollbar Operationadding scrollbarsIDREF="Ch11_Input108"Adding Scales and Scrollbars to a Ganged Groupinheritance graphIDREF="Ch11_Input3"Miscellaneous ViewKit Data Input Classesmember functionsconstructorIDREF="Ch11_Input106"The Ganged Scrollbar Group Constructor and DestructordestructorIDREF="Ch11_Input107"The Ganged Scrollbar Group Constructor and Destructoradd()IDREF="Ch11_Input109"Adding Scales and Scrollbars to a Ganged Groupremove()IDREF="Ch11_Input111"Removing Scales and Scrollbars from a Ganged GroupremoveFirst()IDREF="Ch11_Input112"Removing Scales and Scrollbars from a Ganged GroupremoveLast()IDREF="Ch11_Input113"Removing Scales and Scrollbars from a Ganged GroupVkGangedGroup()IDREF="Ch11_Input106"The Ganged Scrollbar Group Constructor and Destructor~VkGangedGroup()IDREF="Ch11_Input107"The Ganged Scrollbar Group Constructor and Destructorremoving scrollbarsIDREF="Ch11_Input110"Removing Scales and Scrollbars from a Ganged GroupVkGenericDialog classIDREF="Ch07_Dialogs117"Deriving New Dialog Classes Using the Generic Dialog0IDREF="Ch07_Dialogs116"Deriving New Dialog Classes Using the Generic Dialogdata members_allowMultipleDialogsIDREF="Ch07_Dialogs123"Deriving New Dialog Classes Using the Generic Dialog_minimizeMultipleDialogsIDREF="Ch07_Dialogs124"Deriving New Dialog Classes Using the Generic Dialog_showApplyIDREF="Ch07_Dialogs122"Deriving New Dialog Classes Using the Generic Dialog_showCancelIDREF="Ch07_Dialogs121"Deriving New Dialog Classes Using the Generic Dialog_showOKIDREF="Ch07_Dialogs120"Deriving New Dialog Classes Using the Generic Dialoginheritance graphIDREF="Ch07_Dialogs7"Using Dialogs in ViewKitmember functionscreateDialog()IDREF="Ch07_Dialogs119"Deriving New Dialog Classes Using the Generic DialogVkGraph classIDREF="Ch09_Graph5"Overview of ViewKit GraphsIDREF="Ch09_Graph72"The ViewKit Graph Class0IDREF="Ch09_Graph1"The ViewKit Graph Componentarc attributesIDREF="Ch09_Graph79"Adding Nodes and Specifying Node Connectivitybutterfly graphsIDREF="Ch09_Graph108"Butterfly Graphscontrol panelIDREF="Ch09_Graph9"Interactive Viewing Features Provided by VkGraphedit modeIDREF="Ch09_Graph7"The Graph WidgetIDREF="Ch09_Graph35"Edit Mode OperationsexampleIDREF="Ch09_Graph8"Example of Building a GraphfindingIDREF="Ch09_Graph132"Graph Access Functionsgraph widgetIDREF="Ch09_Graph6"The Graph Widgetinheritance graphIDREF="Ch09_Graph4"The ViewKit Graph Componentmember functionsconstructorIDREF="Ch09_Graph73"The Graph Constructor and DestructordestructorIDREF="Ch09_Graph74"The Graph Constructor and Destructoradd()IDREF="Ch09_Graph76"Adding Nodes and Specifying Node ConnectivityaddDesktopMenuItems()IDREF="Ch09_Graph152"Subclassing VkGraphaddMenuItems()IDREF="Ch09_Graph150"Subclassing VkGraphbuildCmdPanel()IDREF="Ch09_Graph148"Subclassing VkGraphbuildZoomMenu()IDREF="Ch09_Graph149"Subclassing VkGraphclearAll()IDREF="Ch09_Graph85"Indicating Which Nodes to Displaydisplay()IDREF="Ch09_Graph87"Indicating Which Nodes to DisplaydisplayAll()IDREF="Ch09_Graph86"Indicating Which Nodes to DisplaydisplayButterfly()IDREF="Ch09_Graph110"Butterfly GraphsdisplayIf()IDREF="Ch09_Graph101"Indicating Which Nodes to DisplaydisplayParentsAndChildren()IDREF="Ch09_Graph99"Indicating Which Nodes to DisplaydisplayWithAllChildren()IDREF="Ch09_Graph92"Indicating Which Nodes to DisplaydisplayWithAllParents()IDREF="Ch09_Graph97"Indicating Which Nodes to DisplaydisplayWithChildren()IDREF="Ch09_Graph90"Indicating Which Nodes to DisplaydisplayWithParents()IDREF="Ch09_Graph96"Indicating Which Nodes to DisplaydoLayout()IDREF="Ch09_Graph105"Laying Out the GraphdoSparseLayout()IDREF="Ch09_Graph107"Laying Out the GraphdoSubtreeLayout()IDREF="Ch09_Graph106"Laying Out the GraphexpandNode()IDREF="Ch09_Graph91"Indicating Which Nodes to DisplayexpandSubgraph()IDREF="Ch09_Graph93"Indicating Which Nodes to Displayfind()IDREF="Ch09_Graph133"Graph Access FunctionsforAllNodesDo()IDREF="Ch09_Graph124"Graph Utility FunctionsgraphWidget()IDREF="Ch09_Graph135"Graph Access FunctionshideAllChildren()IDREF="Ch09_Graph94"Indicating Which Nodes to DisplayhideNode()IDREF="Ch09_Graph88"Indicating Which Nodes to DisplayhideOverview()IDREF="Ch09_Graph116"Displaying a Graph OverviewhideParents()IDREF="Ch09_Graph98"Indicating Which Nodes to DisplayhideParentsAndChildren()IDREF="Ch09_Graph100"Indicating Which Nodes to DisplayhideWithAllChildren()IDREF="Ch09_Graph95"Indicating Which Nodes to DisplaymakeNodeVisible()IDREF="Ch09_Graph127"Graph Utility FunctionsnumNodes()IDREF="Ch09_Graph131"Graph Access FunctionsoverviewWindow()IDREF="Ch09_Graph118"Displaying a Graph OverviewpopupMenu()IDREF="Ch09_Graph151"Subclassing VkGraphrelayButton()IDREF="Ch09_Graph138"Graph Access Functionsremove()IDREF="Ch09_Graph82"Removing NodesreorientButton()IDREF="Ch09_Graph139"Graph Access FunctionssaveToFile()IDREF="Ch09_Graph129"Graph Utility FunctionssetLayoutStyle()IDREF="Ch09_Graph111"Butterfly GraphssetSize()IDREF="Ch09_Graph130"Graph Utility FunctionssetZoomOption()IDREF="Ch09_Graph120"Graph Utility FunctionsshowOverview()IDREF="Ch09_Graph114"Displaying a Graph OverviewsortAll()IDREF="Ch09_Graph122"Graph Utility FunctionstearDownGraph()IDREF="Ch09_Graph141"Reusing a Graph ObjecttwinsButton()IDREF="Ch09_Graph137"Graph Access FunctionstwinsVisibleHook()IDREF="Ch09_Graph153"Subclassing VkGraphundisplay()IDREF="Ch09_Graph89"Indicating Which Nodes to DisplayVkGraph()IDREF="Ch09_Graph73"The Graph Constructor and DestructorworkArea()IDREF="Ch09_Graph136"Graph Access Functions~VkGraph()IDREF="Ch09_Graph74"The Graph Constructor and Destructormultiple arcsIDREF="Ch09_Graph21"Displaying Duplicate ArcsNode menuIDREF="Ch09_Graph30"Hiding and Displaying NodesnodesaddingIDREF="Ch09_Graph75"Adding Nodes and Specifying Node ConnectivityaligningIDREF="Ch09_Graph104"Laying Out the GraphIDREF="Ch09_Graph24"Realigning NodesdeselectingIDREF="Ch09_Graph37"Edit Mode OperationsdisplayingIDREF="Ch09_Graph126"Graph Utility FunctionsIDREF="Ch09_Graph43"Edit Mode OperationsIDREF="Ch09_Graph83"Indicating Which Nodes to DisplayIDREF="Ch09_Graph28"Hiding and Displaying Nodesestablishing connectionsIDREF="Ch09_Graph51"Node Constructor and DestructorIDREF="Ch09_Graph77"Adding Nodes and Specifying Node ConnectivityhidingIDREF="Ch09_Graph84"Indicating Which Nodes to DisplayIDREF="Ch09_Graph29"Hiding and Displaying NodesIDREF="Ch09_Graph40"Edit Mode Operationslaying outIDREF="Ch09_Graph23"Realigning NodesIDREF="Ch09_Graph103"Laying Out the GraphmovingIDREF="Ch09_Graph38"Edit Mode Operationsperforming actionIDREF="Ch09_Graph123"Graph Utility FunctionsremovingIDREF="Ch09_Graph81"Removing NodesselectingIDREF="Ch09_Graph36"Edit Mode OperationssortingIDREF="Ch09_Graph121"Graph Utility FunctionsorientationIDREF="Ch09_Graph26"Toggling Between Horizontal and Vertical OrientationoverviewIDREF="Ch09_Graph5"Overview of ViewKit Graphsoverview windowIDREF="Ch09_Graph113"Displaying a Graph OverviewIDREF="Ch09_Graph14"Graph OverviewAdmin menuIDREF="Ch09_Graph17"Graph Overviewread-only modeIDREF="Ch09_Graph7"The Graph WidgetreusingIDREF="Ch09_Graph140"Reusing a Graph ObjectsavingIDREF="Ch09_Graph128"Graph Utility FunctionsSelected Nodes menuIDREF="Ch09_Graph39"Edit Mode OperationssubclassingIDREF="Ch09_Graph147"Subclassing VkGraphViewKit callbacksarcCreatedCallbackIDREF="Ch09_Graph142"ViewKit Callbacks Associated with VkGrapharcDestroyedCallbackIDREF="Ch09_Graph144"ViewKit Callbacks Associated with VkGraphwidgetIDREF="Ch09_Graph134"Graph Access FunctionsX resourceIDREF="Ch09_Graph146"X Resources Associated with VkGraphzoomingIDREF="Ch09_Graph119"Graph Utility FunctionsIDREF="Ch09_Graph10"ZoomingVkHelpPane classIDREF="Ch05_Menus184"The ViewKit Help MenuIDREF="ChC_Help13"Help Menu Procedures0IDREF="Ch05_Menus183"The ViewKit Help Menuinheritance graphIDREF="Ch05_Menus3"Creating Menus With ViewKitresourcesIDREF="Ch05_Menus191"X Resources Associated with the Help PaneVkInfoDialog classIDREF="Ch07_Dialogs47"Information Dialogs0IDREF="Ch07_Dialogs46"Information Dialogsinheritance graphIDREF="Ch07_Dialogs3"Using Dialogs in ViewKittheInfoDialogIDREF="Ch07_Dialogs48"Information DialogsVkInterruptDialog classIDREF="Ch07_Dialogs77"The Interruptible Busy Dialog0IDREF="Ch07_Dialogs76"The Interruptible Busy Dialogchecking for interruptionsIDREF="Ch07_Dialogs79"The Interruptible Busy Dialoginheritance graphIDREF="Ch07_Dialogs5"Using Dialogs in ViewKitinstalling as busy dialogIDREF="Ch07_Dialogs88"The Interruptible Busy DialogIDREF="Ch03_App94"Installing Different Busy Dialogsmember functionswasInterrupted()IDREF="Ch07_Dialogs81"The Interruptible Busy DialogtheInterruptDialogIDREF="Ch07_Dialogs78"The Interruptible Busy DialogViewKit callbacksinterruptedCallbackIDREF="Ch07_Dialogs85"The Interruptible Busy DialogVkMenu classIDREF="Ch05_Menus77"The ViewKit Menu Base Class0IDREF="Ch05_Menus76"The ViewKit Menu Base Classactivating menu itemsIDREF="Ch05_Menus110"Activating and Deactivating Items in a Menuconstructing dynamicallyIDREF="Ch05_Menus88"Constructing Menus DynamicallyexampleIDREF="Ch05_Menus106"Example of a Creating a Menu Bar Dynamicallyconstructing from static descriptionIDREF="Ch05_Menus78"Constructing Menus from a Static DescriptionexampleIDREF="Ch05_Menus87"Example of a Creating a Menu Bar Using a Static DescriptionVkMenuDesc structureIDREF="Ch05_Menus81"The VkMenuDesc StructureXt callback client dataIDREF="Ch05_Menus86"Special Considerations for Xt Callback Client Data When Using Static Menu Descriptionsdeactivating menu itemsIDREF="Ch05_Menus113"Activating and Deactivating Items in a Menudetermining menu item positionIDREF="Ch05_Menus123"Menu Access Functionsfinding menu itemsIDREF="Ch05_Menus109"Finding Items in a MenuXtDisplay() cautionIDREF="Ch05_Menus11"Overview of ViewKit Menu SupportXtScreen() cautionIDREF="Ch05_Menus11"Overview of ViewKit Menu SupportXtWindow() cautionIDREF="Ch05_Menus12"Overview of ViewKit Menu Supportinheritance graphIDREF="Ch05_Menus2"Creating Menus With ViewKitmember functionsactivateItem()IDREF="Ch05_Menus112"Activating and Deactivating Items in a Menuadd()IDREF="Ch05_Menus105"Functions for Dynamically Creating MenusaddAction()IDREF="Ch05_Menus91"Functions for Dynamically Creating MenusaddConfirmFirstAction()IDREF="Ch05_Menus94"Functions for Dynamically Creating MenusaddLabel()IDREF="Ch05_Menus98"Functions for Dynamically Creating MenusaddRadioSubmenu()IDREF="Ch05_Menus104"Functions for Dynamically Creating MenusaddSeparator()IDREF="Ch05_Menus100"Functions for Dynamically Creating MenusaddSubmenu()IDREF="Ch05_Menus102"Functions for Dynamically Creating MenusaddToggle()IDREF="Ch05_Menus96"Functions for Dynamically Creating Menusdeactivate()IDREF="Ch05_Menus115"Activating and Deactivating Items in a MenufindNamedItem()IDREF="Ch05_Menus107"Finding Items in a MenugetItemPosition()IDREF="Ch05_Menus125"Menu Access FunctionsnumItems()IDREF="Ch05_Menus122"Menu Access FunctionsremoveItem()IDREF="Ch05_Menus118"Removing Items from a Menureplace()IDREF="Ch05_Menus121"Replacing Items in a Menuoperators[] (subscript)IDREF="Ch05_Menus126"Menu Access FunctionsoverviewIDREF="Ch05_Menus15"Overview of ViewKit Menu Supportremoving menu itemsIDREF="Ch05_Menus116"Removing Items from a Menureplacing menu itemsIDREF="Ch05_Menus119"Replacing Items in a MenuVkMenuItemType typeIDREF="Ch05_Menus83"The VkMenuDesc StructureVkMenuAction classIDREF="Ch05_Menus50"Menu Actions0IDREF="Ch05_Menus49"Menu Actionsadding to menusIDREF="Ch05_Menus90"Functions for Dynamically Creating Menusinheritance graphIDREF="Ch05_Menus4"Creating Menus With ViewKitmember functionshasUndo()IDREF="Ch05_Menus51"Menu Actionsundo()IDREF="Ch05_Menus52"Menu ActionsVkMenuActionObject class:See also command classes; VkAction class; VkMenuItem classIDREF="Ch06_Undo35"Overview of Command ClassesactivatingIDREF="Ch06_Undo47"Activating Command Classesdata members_clientData()IDREF="Ch06_Undo40"Command Class ConstructorsexecutingIDREF="Ch06_Undo47"Activating Command Classesinheritance graphIDREF="Ch06_Undo1"ViewKit Undo Management and Command Classesmember functionsconstructorIDREF="Ch06_Undo39"Command Class Constructorsdoit()IDREF="Ch06_Undo43"Overriding Virtual Functionsundoit()IDREF="Ch06_Undo41"Overriding Virtual FunctionsVkMenuActionObject()IDREF="Ch06_Undo39"Command Class ConstructorsoverviewIDREF="Ch06_Undo36"Overview of Command ClassesVkMenuBar classIDREF="Ch05_Menus132"Menu Bar0IDREF="Ch05_Menus127"Menu BarVkWindow destructor, andIDREF="Ch04_Windows27"Window Class DestructorsVkWindow supportIDREF="Ch04_Windows135"Menu Bar Supportinheritance graphIDREF="Ch05_Menus2"Creating Menus With ViewKitmember functionsconstructorIDREF="Ch05_Menus133"Menu Bar ConstructorshelpPane()IDREF="Ch05_Menus135"Menu Bar Access FunctionsVkMenuBar()IDREF="Ch05_Menus133"Menu Bar ConstructorsVkMenuConfirmFirstAction classIDREF="Ch05_Menus57"Confirmable Menu Actions0IDREF="Ch05_Menus56"Confirmable Menu Actionsadding to menusIDREF="Ch05_Menus93"Functions for Dynamically Creating Menusinheritance graphIDREF="Ch05_Menus4"Creating Menus With ViewKitVkMenuItem class:See also menu items; VkComponent class; specific menu items classesIDREF="Ch05_Menus18"Common Features of Menu ItemsVkMenuItem classIDREF="Ch05_Menus19"Common Features of Menu Itemsactivating menu itemsIDREF="Ch05_Menus111"Activating and Deactivating Items in a MenuIDREF="Ch05_Menus30"Activating and Deactivating Menu Itemsdeactivating menu itemsIDREF="Ch05_Menus33"Activating and Deactivating Menu ItemsIDREF="Ch05_Menus114"Activating and Deactivating Items in a Menudetermining position in menuIDREF="Ch05_Menus124"Menu Access Functionsdisplaying menu itemsIDREF="Ch05_Menus21"Displaying and Hiding Menu Itemsfinding menu itemsIDREF="Ch05_Menus108"Finding Items in a MenuXtDisplay() cautionIDREF="Ch05_Menus9"Overview of ViewKit Menu SupportXtScreen() cautionIDREF="Ch05_Menus9"Overview of ViewKit Menu SupportXtWindow() cautionIDREF="Ch05_Menus10"Overview of ViewKit Menu Supporthiding menu itemsIDREF="Ch05_Menus24"Displaying and Hiding Menu Itemsinheritance graphIDREF="Ch05_Menus2"Creating Menus With ViewKitlabelsIDREF="Ch05_Menus36"Setting Menu Item Labelsmember functionsactivate()IDREF="Ch05_Menus31"Activating and Deactivating Menu Itemsdeactivate()IDREF="Ch05_Menus34"Activating and Deactivating Menu Itemshide()IDREF="Ch05_Menus25"Displaying and Hiding Menu ItemsisContainer()IDREF="Ch05_Menus46"Menu Items Utility FunctionsmenuType()IDREF="Ch05_Menus44"Menu Items Utility Functionsremove()IDREF="Ch05_Menus28"Displaying and Hiding Menu ItemssetLabel()IDREF="Ch05_Menus39"Setting Menu Item LabelssetPosition()IDREF="Ch05_Menus42"Setting the Position of Menu Itemsshow()IDREF="Ch05_Menus22"Displaying and Hiding Menu ItemsoverviewIDREF="Ch05_Menus7"Overview of ViewKit Menu SupportpositionIDREF="Ch05_Menus41"Setting the Position of Menu Itemsremoving menu itemsIDREF="Ch05_Menus27"Displaying and Hiding Menu ItemsIDREF="Ch05_Menus117"Removing Items from a Menureplacing menu itemsIDREF="Ch05_Menus120"Replacing Items in a MenutypeIDREF="Ch05_Menus43"Menu Items Utility FunctionsVkMenuLabel classIDREF="Ch05_Menus70"Menu Labels0IDREF="Ch05_Menus69"Menu Labelsadding to menusIDREF="Ch05_Menus97"Functions for Dynamically Creating Menusinheritance graphIDREF="Ch05_Menus5"Creating Menus With ViewKitVkMenuSeparator classIDREF="Ch05_Menus74"Menu Separators0IDREF="Ch05_Menus73"Menu Separatorsadding to menusIDREF="Ch05_Menus99"Functions for Dynamically Creating Menusinheritance graphIDREF="Ch05_Menus5"Creating Menus With ViewKitVkMenuToggle classIDREF="Ch05_Menus63"Menu Toggles0IDREF="Ch05_Menus62"Menu Togglesadding to menusIDREF="Ch05_Menus95"Functions for Dynamically Creating Menusinheritance graphIDREF="Ch05_Menus4"Creating Menus With ViewKitmember functionsgetState()IDREF="Ch05_Menus66"Menu TogglessetStateAndNotify()IDREF="Ch05_Menus65"Menu TogglessetVisualState()IDREF="Ch05_Menus64"Menu TogglesVkMenuUndoManager classIDREF="Ch06_Undo7"Using ViewKit's Undo Manager0IDREF="Ch06_Undo6"Using ViewKit's Undo Manageradding "Undo" selection to menuIDREF="Ch06_Undo10"Adding the Undo Manager to a MenuVkAction classIDREF="Ch06_Undo16"Providing Undo Support for Command Class ObjectsVkMenuActionObject classIDREF="Ch06_Undo17"Providing Undo Support for Command Class ObjectsexampleIDREF="Ch06_Undo30"Example of Using ViewKit's Undo Managerinheritance graphIDREF="Ch06_Undo1"ViewKit Undo Management and Command ClassesinstantiatingIDREF="Ch06_Undo8"Instantiating ViewKit's Undo Managermember functionsadd()IDREF="Ch06_Undo15"Providing Undo Support for Actions That Are Not Menu ItemshistoryList()IDREF="Ch06_Undo26"Examining the Undo StackmultiLevel()IDREF="Ch06_Undo21"Enabling and Disabling Multi-level Undo Supportreset()IDREF="Ch06_Undo23"Clearing the Undo Stackmulti-level undo supportIDREF="Ch06_Undo19"Enabling and Disabling Multi-level Undo Supportsetting "Undo" selection labelIDREF="Ch06_Undo27"Setting the Label of the Undo Manager Menu Itemundo stackclearingIDREF="Ch06_Undo22"Clearing the Undo StackexaminingIDREF="Ch06_Undo24"Examining the Undo Stackundoingcommand class objectsIDREF="Ch06_Undo16"Providing Undo Support for Command Class Objectsmenu item actionsIDREF="Ch06_Undo12"Providing Undo Support for Actions That Are Menu Itemsnon-menu item actionsIDREF="Ch06_Undo14"Providing Undo Support for Actions That Are Not Menu ItemstheUndoManagerIDREF="Ch06_Undo9"Instantiating ViewKit's Undo ManagerVkMeter classIDREF="ChB_Contrib3"The ViewKit Meter Component0IDREF="ChB_Contrib1"The ViewKit Meter Componentadding itemsIDREF="ChB_Contrib8"Adding Items to a Meterdesired dimensionsIDREF="ChB_Contrib14"Determining the Desired Dimensions of the Metermember functionsconstructorIDREF="ChB_Contrib4"Meter Constructor and DestructordestructorIDREF="ChB_Contrib5"Meter Constructor and Destructoradd()IDREF="ChB_Contrib9"Adding Items to a MeterneededHeight()IDREF="ChB_Contrib16"Determining the Desired Dimensions of the MeterneededWidth()IDREF="ChB_Contrib15"Determining the Desired Dimensions of the Meterreset()IDREF="ChB_Contrib7"Resetting the MetersetResizePolicy()IDREF="ChB_Contrib13"Setting the Meter's Resize Policyupdate()IDREF="ChB_Contrib11"Updating the Meter DisplayVkMeter()IDREF="ChB_Contrib4"Meter Constructor and Destructor~VkMeter()IDREF="ChB_Contrib5"Meter Constructor and DestructorresettingIDREF="ChB_Contrib6"Resetting the Meterresize policyIDREF="ChB_Contrib12"Setting the Meter's Resize Policyupdating displayIDREF="ChB_Contrib10"Updating the Meter DisplayX resourcesIDREF="ChB_Contrib17"X Resources Associated with the Meter ComponentVkModified classinheritance graphIDREF="Ch11_Input2"Miscellaneous ViewKit Data Input ClassesVkModifiedAttachment classIDREF="Ch11_Input135"Modified Text Attachment0IDREF="Ch11_Input134"Modified Text Attachmentadjusting geometryIDREF="Ch11_Input161"Adjusting the Modified Text Attachment's Geometryattaching widgetsIDREF="Ch11_Input139"Attaching and Detaching the Modified Text Attachment to and from a Widgetcontrolling contentsIDREF="Ch11_Input156"Controlling the Contents of the Text WidgetIDREF="Ch11_Input165"Other Modified Text Attachment Utility and Access Functionsdetaching widgetsIDREF="Ch11_Input141"Attaching and Detaching the Modified Text Attachment to and from a Widgetdetecting changesIDREF="Ch11_Input151"Detecting Changes in the Text Widgetdisplaying dogearIDREF="Ch11_Input143"Displaying and Hiding the Modified Text Attachmenthiding dogearIDREF="Ch11_Input145"Displaying and Hiding the Modified Text Attachmentinheritance graphIDREF="Ch11_Input3"Miscellaneous ViewKit Data Input Classesmember functionsconstructorIDREF="Ch11_Input137"The Modified Text Attachment Constructor and DestructordestructorIDREF="Ch11_Input138"The Modified Text Attachment Constructor and DestructoradjustGeometry()IDREF="Ch11_Input162"Adjusting the Modified Text Attachment's Geometryattach()IDREF="Ch11_Input140"Attaching and Detaching the Modified Text Attachment to and from a Widgetdetach()IDREF="Ch11_Input142"Attaching and Detaching the Modified Text Attachment to and from a WidgetdisplayValue()IDREF="Ch11_Input160"Controlling the Contents of the Text Widgetexpose()IDREF="Ch11_Input147"Displaying and Hiding the Modified Text AttachmentfixPreviousValue()IDREF="Ch11_Input166"Other Modified Text Attachment Utility and Access FunctionsgetParameters()IDREF="Ch11_Input164"Adjusting the Modified Text Attachment's Geometryhide()IDREF="Ch11_Input146"Displaying and Hiding the Modified Text AttachmentlatestDisplay()IDREF="Ch11_Input159"Controlling the Contents of the Text Widgetmodified()IDREF="Ch11_Input168"Other Modified Text Attachment Utility and Access FunctionspreviousValue()IDREF="Ch11_Input150"Retrieving the Current and Previous Values of the Text WidgetsetModified()IDREF="Ch11_Input169"Other Modified Text Attachment Utility and Access FunctionssetParameters()IDREF="Ch11_Input163"Adjusting the Modified Text Attachment's GeometrysetValue()IDREF="Ch11_Input157"Controlling the Contents of the Text Widgetshow()IDREF="Ch11_Input144"Displaying and Hiding the Modified Text AttachmenttoggleDisplay()IDREF="Ch11_Input158"Controlling the Contents of the Text Widgetvalue()IDREF="Ch11_Input149"Retrieving the Current and Previous Values of the Text WidgetVkModifiedAttachment()IDREF="Ch11_Input137"The Modified Text Attachment Constructor and Destructorwidget()IDREF="Ch11_Input167"Other Modified Text Attachment Utility and Access Functions~VkModifiedAttachment()IDREF="Ch11_Input138"The Modified Text Attachment Constructor and DestructoroverviewIDREF="Ch11_Input136"Modified Text Attachmentretrieving valuesIDREF="Ch11_Input148"Retrieving the Current and Previous Values of the Text WidgetViewKit callbacksmodifiedCallbackIDREF="Ch11_Input152"Detecting Changes in the Text WidgetX resourceIDREF="Ch11_Input170"X Resources Associated with the Modified Text AttachmentVkMsgApp classIDREF="ChA_ToolTalk23"Establishing a Connection to the ToolTalk ServiceIDREF="ChA_ToolTalk15"ViewKit Classes Supporting ToolTalk0IDREF="ChA_ToolTalk14"ViewKit Classes Supporting ToolTalkinheritance graphIDREF="ChA_ToolTalk6"ViewKit Interprocess Message Facilitymember functionsconstructorIDREF="ChA_ToolTalk24"Establishing a Connection to the ToolTalk ServicemessageClient()IDREF="ChA_ToolTalk25"Establishing a Connection to the ToolTalk ServiceVkMsgApp()IDREF="ChA_ToolTalk24"Establishing a Connection to the ToolTalk ServiceVkMsgClient classIDREF="ChA_ToolTalk26"Sending and Receiving ToolTalk MessagesIDREF="ChA_ToolTalk11"ViewKit Classes Supporting ToolTalk0IDREF="ChA_ToolTalk10"ViewKit Classes Supporting ToolTalkinheritance graphIDREF="ChA_ToolTalk6"ViewKit Interprocess Message Facilitymember functionsaddAction()IDREF="ChA_ToolTalk67"Creating and Registering Simple Message PatternscomposeAdd()IDREF="ChA_ToolTalk31"Composing and Sending MessagescomposeBegin()IDREF="ChA_ToolTalk30"Composing and Sending MessagescreateAction()IDREF="ChA_ToolTalk70"Creating More Detailed Message PatternsregisterPattern()IDREF="ChA_ToolTalk71"Creating More Detailed Message PatternsremoveAction()IDREF="ChA_ToolTalk69"Creating and Registering Simple Message PatternssendFileNotice()IDREF="ChA_ToolTalk41"Specifying a Filename Message AttributesendFileRequest()IDREF="ChA_ToolTalk42"Specifying a Filename Message AttributesendIntFileNotice()IDREF="ChA_ToolTalk40"Specifying a Filename Message AttributesendIntNotice()IDREF="ChA_ToolTalk28"Sending Simple NoticessendNotice()IDREF="ChA_ToolTalk32"Composing and Sending MessagessendRequest()IDREF="ChA_ToolTalk33"Composing and Sending MessagessendStringFileNotice()IDREF="ChA_ToolTalk39"Specifying a Filename Message AttributesendStringNotice()IDREF="ChA_ToolTalk29"Sending Simple NoticessendSyncFileRequest()IDREF="ChA_ToolTalk43"Specifying a Filename Message AttributesendSyncRequest()IDREF="ChA_ToolTalk34"Sending Synchronous Requestsunregister()IDREF="ChA_ToolTalk73"Creating More Detailed Message PatternsupdatePatterns()IDREF="ChA_ToolTalk72"Creating More Detailed Message PatternsIDREF="ChA_ToolTalk68"Creating and Registering Simple Message PatternsVkMsgComponent classIDREF="ChA_ToolTalk78"Supporting Messaging in ComponentsIDREF="ChA_ToolTalk19"ViewKit Classes Supporting ToolTalk0IDREF="ChA_ToolTalk18"ViewKit Classes Supporting ToolTalkinheritance graphIDREF="ChA_ToolTalk7"ViewKit Interprocess Message Facilitymember functionsmessageClient()IDREF="ChA_ToolTalk79"Supporting Messaging in ComponentsVkMsgFacility classIDREF="ChA_ToolTalk2"ViewKit Classes Supporting ToolTalk0IDREF="ChA_ToolTalk12"ViewKit Classes Supporting ToolTalkinheritance graphIDREF="ChA_ToolTalk6"ViewKit Interprocess Message FacilityVkMsgService classIDREF="ChA_ToolTalk1"ViewKit Classes Supporting ToolTalk0IDREF="ChA_ToolTalk13"ViewKit Classes Supporting ToolTalkinheritance graphIDREF="ChA_ToolTalk6"ViewKit Interprocess Message FacilityVkMsgWindow classIDREF="ChA_ToolTalk76"Supporting Messaging in Application WindowsIDREF="ChA_ToolTalk17"ViewKit Classes Supporting ToolTalk0IDREF="ChA_ToolTalk16"ViewKit Classes Supporting ToolTalkinheritance graphIDREF="ChA_ToolTalk7"ViewKit Interprocess Message Facilitymember functionsmessageClient()IDREF="ChA_ToolTalk77"Supporting Messaging in Application WindowsVkNLS classIDREF="Ch13_NetLS4"The ViewKit NetLS InterfaceexampleIDREF="Ch13_NetLS9"Example of Using VkNLSmember functionsconstructorIDREF="Ch13_NetLS6"Using the VkNLS ClassdestructorIDREF="Ch13_NetLS7"Using the VkNLS ClassVkNLS()IDREF="Ch13_NetLS6"Using the VkNLS Class~VkNLS()IDREF="Ch13_NetLS7"Using the VkNLS ClassoverviewIDREF="Ch13_NetLS5"Overview of ViewKit NetLS SupportX resourcesIDREF="Ch13_NetLS8"X Resources Associated With the VkNLS ClassVkNode classIDREF="Ch09_Graph48"The ViewKit Node Class0IDREF="Ch09_Graph46"The ViewKit Node Classarc attributesIDREF="Ch09_Graph79"Adding Nodes and Specifying Node Connectivitychild nodesIDREF="Ch09_Graph60"Node Access Functionsdata members_labelIDREF="Ch09_Graph71"Creating Node SubclassesfindingIDREF="Ch09_Graph65"Node Access FunctionsIDREF="Ch09_Graph132"Graph Access Functionsinheritance graphIDREF="Ch09_Graph4"The ViewKit Graph ComponentlabelIDREF="Ch09_Graph58"Node Access FunctionsIDREF="Ch09_Graph70"Creating Node SubclassesIDREF="Ch09_Graph50"Node Constructor and Destructormember functionsconstructorIDREF="Ch09_Graph49"Node Constructor and DestructordestructorIDREF="Ch09_Graph53"Node Constructor and Destructorbuild()IDREF="Ch09_Graph69"Creating Node Subclasseschild()IDREF="Ch09_Graph64"Node Access FunctionsfindChild()IDREF="Ch09_Graph67"Node Access FunctionsfindParent()IDREF="Ch09_Graph66"Node Access Functionslabel()IDREF="Ch09_Graph59"Node Access FunctionsnChildren()IDREF="Ch09_Graph62"Node Access FunctionsnParents()IDREF="Ch09_Graph61"Node Access Functionsparent()IDREF="Ch09_Graph63"Node Access FunctionssetSortFunction()IDREF="Ch09_Graph56"Node Utility FunctionssortChildren()IDREF="Ch09_Graph55"Node Utility FunctionsVkNode()IDREF="Ch09_Graph49"Node Constructor and Destructor~VkNode()IDREF="Ch09_Graph53"Node Constructor and Destructorparent nodesIDREF="Ch09_Graph60"Node Access Functionsperforming actionIDREF="Ch09_Graph123"Graph Utility FunctionssortingIDREF="Ch09_Graph121"Graph Utility FunctionsIDREF="Ch09_Graph54"Node Utility FunctionssubclassingIDREF="Ch09_Graph68"Creating Node SubclassesVkOptionMenu classIDREF="Ch05_Menus155"Option Menus0IDREF="Ch05_Menus152"Option MenusexampleIDREF="Ch05_Menus168"Option Menu Exampleinheritance graphIDREF="Ch05_Menus3"Creating Menus With ViewKititem width, settingIDREF="Ch05_Menus166"Option Menu Utility Functionsmember functionsconstructorIDREF="Ch05_Menus156"Unlike many other ViewKit components, VkOptionMenu objects are automatically visible when you create them; you do not need to call show() initially to display a VkOptionMenu object.Option Menu ConstructorsforceWidth()IDREF="Ch05_Menus167"Option Menu Utility FunctionsgetIndex()IDREF="Ch05_Menus164"Determining Selected Items in an Option MenugetItem()IDREF="Ch05_Menus165"Determining Selected Items in an Option Menuset()IDREF="Ch05_Menus162"Selecting Items in an Option MenuVkOptionMenu()IDREF="Ch05_Menus156"Unlike many other ViewKit components, VkOptionMenu objects are automatically visible when you create them; you do not need to call show() initially to display a VkOptionMenu object.Option Menu Constructorsmenu label, settingIDREF="Ch05_Menus158"Setting the Option Menu Labelselected itemsettingIDREF="Ch05_Menus163"Determining Selected Items in an Option Menuselected item, settingIDREF="Ch05_Menus161"Selecting Items in an Option MenuVkOutline classIDREF="ChB_Contrib22"The ViewKit Outline ComponentVkOutlineASB classIDREF="ChB_Contrib23"VkOutlineASBVkPie classIDREF="ChB_Contrib20"The ViewKit Pie Chart Component0IDREF="ChB_Contrib18"The ViewKit Pie Chart ComponentVkPopupMenu classIDREF="Ch05_Menus172"Popup Menus0IDREF="Ch05_Menus169"Popup Menusattaching to widgetIDREF="Ch05_Menus174"Popup Menu ConstructorsexampleIDREF="Ch05_Menus180"Popup Menu Exampleinheritance graphIDREF="Ch05_Menus2"Creating Menus With ViewKitmember functionsconstructorIDREF="Ch05_Menus173"Popup Menu Constructorsattach()IDREF="Ch05_Menus176"Attaching Popup Menus to Widgetsbuild()IDREF="Ch05_Menus178"Popping Up Popup Menusshow()IDREF="Ch05_Menus179"Popping Up Popup MenusVkPopupMenu()IDREF="Ch05_Menus173"Popup Menu Constructorspopping upIDREF="Ch05_Menus177"Popping Up Popup MenusVkPrefCustom classinheritance graphIDREF="Ch08_Pref6"Preference DialogsVkPrefDialog class:See also preference dialogs; VkDialogManager class; VkGenericDialog classIDREF="Ch08_Pref10"The ViewKit Preference Dialog Classadding preference itemsIDREF="Ch08_Pref117"Creating a Preference DialogIDREF="Ch08_Pref118"Setting the Preference Items for a Preference DialogexampleIDREF="Ch08_Pref16"Example of Building a ViewKit Preference Dialoginheritance graphIDREF="Ch08_Pref4"Preference Dialogsmember functionsconstructorIDREF="Ch08_Pref116"Creating a Preference Dialogitem()IDREF="Ch08_Pref120"Setting the Preference Items for a Preference DialogsetItem()IDREF="Ch08_Pref119"Setting the Preference Items for a Preference DialogVkPrefDialog()IDREF="Ch08_Pref116"Creating a Preference DialogoverviewIDREF="Ch08_Pref11"The ViewKit Preference Dialog ClasspostingIDREF="Ch08_Pref123"Posting and Dismissing Preference Dialogs0IDREF="Ch08_Pref122"Posting and Dismissing Preference Dialogsretrieving valuesIDREF="Ch08_Pref130"Using Values Set in a Preference DialogsubclassingIDREF="Ch08_Pref131"Creating Preference Dialog SubclassesunpostingIDREF="Ch08_Pref126"Posting and Dismissing Preference Dialogs0IDREF="Ch08_Pref125"Posting and Dismissing Preference Dialogsuser interaction, respondingIDREF="Ch08_Pref127"Responding When the User Clicks on a Preference Dialog ButtonViewKit callbacksprefCallbackIDREF="Ch08_Pref128"Responding When the User Clicks on a Preference Dialog ButtonVkPrefEmpty classIDREF="Ch08_Pref85""Empty" Space Preference Items0IDREF="Ch08_Pref84""Empty" Space Preference Itemsinheritance graphIDREF="Ch08_Pref6"Preference Dialogsmember functionsconstructorIDREF="Ch08_Pref86""Empty" Space Preference ItemsVkPrefEmpty()IDREF="Ch08_Pref86""Empty" Space Preference ItemsVkPrefGroup classIDREF="Ch08_Pref93"Comparison of Group Preference Items0IDREF="Ch08_Pref90"Groups of Preference Itemsinheritance graphIDREF="Ch08_Pref7"Preference Dialogslabels, settingIDREF="Ch08_Pref114"Setting Group Item Labelsmember functionsconstructorIDREF="Ch08_Pref97"Creating Group Preference ItemsaddItem()IDREF="Ch08_Pref102"Adding and Deleting Preference Items from a Group Itemchanged()IDREF="Ch08_Pref112"Monitoring the Values of Preference Items Associated with a Group ItemdeleteChildren()IDREF="Ch08_Pref109"Adding and Deleting Preference Items from a Group Itemitem()IDREF="Ch08_Pref104"Adding and Deleting Preference Items from a Group Itemsize()IDREF="Ch08_Pref106"Adding and Deleting Preference Items from a Group ItemVkPrefGroup()IDREF="Ch08_Pref97"Creating Group Preference Itemstoggle item labelsIDREF="Ch08_Pref56"Setting Toggle Preference Item LabelsVkPrefItem classIDREF="Ch08_Pref18"The ViewKit Preference Item Base Class0IDREF="Ch08_Pref13"The ViewKit Preference Item ClassesactivatingIDREF="Ch08_Pref30"Preference Item Access Functionsbase widgetIDREF="Ch08_Pref21"Preference Item LabelsIDREF="Ch08_Pref34"Preference Item Access FunctionsdeactivatingIDREF="Ch08_Pref31"Preference Item Access Functionsinheritance graphIDREF="Ch08_Pref4"Preference Dialogslabel widgetIDREF="Ch08_Pref35"Preference Item Access FunctionsIDREF="Ch08_Pref22"Preference Item LabelslabelsIDREF="Ch08_Pref20"Preference Item LabelsgroupsIDREF="Ch08_Pref113"Setting Group Item Labelslabel itemsIDREF="Ch08_Pref77"Labelsoption menusIDREF="Ch08_Pref63"Setting Option Menu Preference Item LabelstogglesIDREF="Ch08_Pref54"Setting Toggle Preference Item Labelsmember functionsactivate()IDREF="Ch08_Pref32"Preference Item Access FunctionsbaseHeight()IDREF="Ch08_Pref39"Preference Item Access Functionschanged()IDREF="Ch08_Pref29"Getting and Setting Preference Item Valuesdeactivate()IDREF="Ch08_Pref33"Preference Item Access FunctionsgetValue()IDREF="Ch08_Pref27"Getting and Setting Preference Item ValuesisContainer()IDREF="Ch08_Pref43"Preference Item Access FunctionslabelHeight()IDREF="Ch08_Pref38"Preference Item Access FunctionslabelWidget()IDREF="Ch08_Pref40"Preference Item Access FunctionssetBaseHeight()IDREF="Ch08_Pref36"Preference Item Access FunctionssetLabelHeight()IDREF="Ch08_Pref37"Preference Item Access FunctionssetValue()IDREF="Ch08_Pref28"Getting and Setting Preference Item Valuestype()IDREF="Ch08_Pref41"Preference Item Access FunctionsoverviewIDREF="Ch08_Pref14"The ViewKit Preference Item ClassesvaluesIDREF="Ch08_Pref25"Getting and Setting Preference Item ValuesVkPrefLabel classIDREF="Ch08_Pref75"Labels0IDREF="Ch08_Pref74"Labelsinheritance graphIDREF="Ch08_Pref5"Preference Dialogsmember functionsconstructorIDREF="Ch08_Pref76"LabelsVkPrefLabel()IDREF="Ch08_Pref76"Labelssetting labelsIDREF="Ch08_Pref78"LabelsVkPrefList classIDREF="Ch08_Pref94"Comparison of Group Preference Items0IDREF="Ch08_Pref88"Groups of Preference Itemsinheritance graphIDREF="Ch08_Pref7"Preference Dialogsmember functionsconstructorIDREF="Ch08_Pref99"Creating Group Preference ItemsaddItem()IDREF="Ch08_Pref101"Adding and Deleting Preference Items from a Group Itemchanged()IDREF="Ch08_Pref111"Monitoring the Values of Preference Items Associated with a Group ItemdeleteChildren()IDREF="Ch08_Pref108"Adding and Deleting Preference Items from a Group Itemitem()IDREF="Ch08_Pref103"Adding and Deleting Preference Items from a Group Itemsize()IDREF="Ch08_Pref105"Adding and Deleting Preference Items from a Group ItemVkPrefList()IDREF="Ch08_Pref99"Creating Group Preference ItemsVkPrefOption classIDREF="Ch08_Pref61"Option Menus0IDREF="Ch08_Pref60"Option Menusinheritance graphIDREF="Ch08_Pref5"Preference Dialogslabels, settingIDREF="Ch08_Pref64"Setting Option Menu Preference Item Labelsmember functionsconstructorIDREF="Ch08_Pref62"Option MenusgetButton()IDREF="Ch08_Pref70"Dynamically Changing the Number of Option Menu ItemsgetLabel()IDREF="Ch08_Pref66"Setting Option Menu Preference Item LabelsgetValue()IDREF="Ch08_Pref71"Getting and Setting Option Menu Preference Item ValuessetLabel()IDREF="Ch08_Pref65"Setting Option Menu Preference Item LabelssetSize()IDREF="Ch08_Pref68"Dynamically Changing the Number of Option Menu ItemssetValue()IDREF="Ch08_Pref72"Getting and Setting Option Menu Preference Item Valuessize()IDREF="Ch08_Pref69"Dynamically Changing the Number of Option Menu ItemsVkPrefOption()IDREF="Ch08_Pref62"Option Menusnumber of options, settingIDREF="Ch08_Pref67"Dynamically Changing the Number of Option Menu ItemsVkPrefRadio classIDREF="Ch08_Pref95"Comparison of Group Preference Items0IDREF="Ch08_Pref89"Groups of Preference Itemsinheritance graphIDREF="Ch08_Pref7"Preference Dialogslabels, settingIDREF="Ch08_Pref114"Setting Group Item Labelsmember functionsconstructorIDREF="Ch08_Pref98"Creating Group Preference ItemsaddItem()IDREF="Ch08_Pref101"Adding and Deleting Preference Items from a Group Itemchanged()IDREF="Ch08_Pref111"Monitoring the Values of Preference Items Associated with a Group ItemdeleteChildren()IDREF="Ch08_Pref108"Adding and Deleting Preference Items from a Group Itemitem()IDREF="Ch08_Pref103"Adding and Deleting Preference Items from a Group Itemsize()IDREF="Ch08_Pref105"Adding and Deleting Preference Items from a Group ItemVkPrefRadio()IDREF="Ch08_Pref98"Creating Group Preference Itemstoggle item labelsIDREF="Ch08_Pref56"Setting Toggle Preference Item LabelsVkPrefSeparator classIDREF="Ch08_Pref81"Separators0IDREF="Ch08_Pref80"Separatorsinheritance graphIDREF="Ch08_Pref6"Preference Dialogsmember functionsconstructorIDREF="Ch08_Pref82"SeparatorsVkPrefSeparator()IDREF="Ch08_Pref82"SeparatorsVkPrefText classIDREF="Ch08_Pref46"Text Fields0IDREF="Ch08_Pref45"Text Fieldsinheritance graphIDREF="Ch08_Pref4"Preference Dialogsmember functionsconstructorIDREF="Ch08_Pref47"Text FieldsgetValue()IDREF="Ch08_Pref48"Text FieldssetValue()IDREF="Ch08_Pref49"Text FieldsVkPrefText()IDREF="Ch08_Pref47"Text FieldsVkPrefToggle classIDREF="Ch08_Pref52"Toggle Buttons0IDREF="Ch08_Pref51"Toggle Buttonsinheritance graphIDREF="Ch08_Pref5"Preference Dialogsmember functionsconstructorIDREF="Ch08_Pref53"Toggle ButtonsgetValue()IDREF="Ch08_Pref57"Getting and Setting Toggle Preference Item ValuessetValue()IDREF="Ch08_Pref58"Getting and Setting Toggle Preference Item ValuesVkPrefToggle()IDREF="Ch08_Pref53"Toggle Buttonssetting labels<$startrangeIDREF="Ch08_Pref55"Setting Toggle Preference Item LabelsVkPromptDialog classIDREF="Ch07_Dialogs97"The Prompt Dialog0IDREF="Ch07_Dialogs96"The Prompt DialogcautionIDREF="Ch07_Dialogs100"The Prompt Dialoginheritance graphIDREF="Ch07_Dialogs6"Using Dialogs in ViewKitmember functionstext()IDREF="Ch07_Dialogs99"The Prompt DialogthePromptDialogIDREF="Ch07_Dialogs98"The Prompt DialogVkQuestionDialog classIDREF="Ch07_Dialogs92"The Question Dialog0IDREF="Ch07_Dialogs91"The Question DialogVkMenuConfirmFirstAction useIDREF="Ch05_Menus58"Confirmable Menu Actionsinheritance graphIDREF="Ch07_Dialogs6"Using Dialogs in ViewKittheQuestionDialogIDREF="Ch07_Dialogs93"The Question DialogVkRadioBox classIDREF="Ch11_Input27"The Radio Check Box Component0IDREF="Ch11_Input25"The Radio Check Box ComponentexampleIDREF="Ch11_Input28"The Radio Check Box Componentinheritance graphIDREF="Ch11_Input1"Miscellaneous ViewKit Data Input ClassesVkRadioGroup class:See also radio-style togglesIDREF="Ch11_Input119"Enforcing Radio-Style Behavior on Toggle ButtonsVkRadioGroup classIDREF="Ch11_Input120"Enforcing Radio-Style Behavior on Toggle Buttonsadding buttonsIDREF="Ch11_Input123"Adding Toggles and Buttons to a Radio Groupinheritance graphIDREF="Ch11_Input3"Miscellaneous ViewKit Data Input Classesmember functionsconstructorIDREF="Ch11_Input121"The Radio Group Constructor and DestructordestructorIDREF="Ch11_Input122"The Radio Group Constructor and Destructoradd()IDREF="Ch11_Input124"Adding Toggles and Buttons to a Radio Groupremove()IDREF="Ch11_Input126"Removing Toggles and Buttons from a Radio GroupremoveFirst()IDREF="Ch11_Input127"Removing Toggles and Buttons from a Radio GroupremoveLast()IDREF="Ch11_Input128"Removing Toggles and Buttons from a Radio GroupvalueChanged()IDREF="Ch11_Input130"Deriving Radio Group SubclassesVkRadioGroup()IDREF="Ch11_Input121"The Radio Group Constructor and Destructor~VkRadioGroup()IDREF="Ch11_Input122"The Radio Group Constructor and Destructorremoving buttonsIDREF="Ch11_Input125"Removing Toggles and Buttons from a Radio GroupsubclassingIDREF="Ch11_Input129"Deriving Radio Group SubclassesVkRadioSubMenu classIDREF="Ch05_Menus150"The baseWidget() function of a VkSubMenu object returns the CascadeButton widget required by IRIS IM pulldown menus.Radio Submenus0IDREF="Ch05_Menus147"The baseWidget() function of a VkSubMenu object returns the CascadeButton widget required by IRIS IM pulldown menus.Radio Submenusadding to menusIDREF="Ch05_Menus103"Functions for Dynamically Creating Menusinheritance graphIDREF="Ch05_Menus3"Creating Menus With ViewKitmember functionsconstructorIDREF="Ch05_Menus151"Radio Submenu ConstructorVkRadioSubMenu()IDREF="Ch05_Menus151"Radio Submenu ConstructorVkRepeatButton classIDREF="Ch11_Input89"The Repeating Button Component0IDREF="Ch11_Input88"The Repeating Button Componentactivation, respondingIDREF="Ch11_Input92"Responding to Repeat Button Activationinheritance graphIDREF="Ch11_Input2"Miscellaneous ViewKit Data Input Classesmember functionsconstructorIDREF="Ch11_Input90"The Repeating Button ConstructorsetParameters()IDREF="Ch11_Input95"Repeating Button Utility and Access Functionstype()IDREF="Ch11_Input96"Repeating Button Utility and Access FunctionsVkRepeatButton()IDREF="Ch11_Input90"The Repeating Button ConstructorViewKit callbacksbuttonCallbackIDREF="Ch11_Input93"Responding to Repeat Button ActivationX resourcesIDREF="Ch11_Input98"X Resources Associated with the Repeating Button ComponentVkResizer classIDREF="Ch10_Display62"ViewKit Support for Resizing and Moving Widgets0IDREF="Ch10_Display60"ViewKit Support for Resizing and Moving Widgetsattaching widgetsIDREF="Ch10_Display66"Attaching and Detaching a Resizer Object to and from a Widgetdetaching widgetsIDREF="Ch10_Display68"Attaching and Detaching a Resizer Object to and from a Widgetdisplaying geometry controlsIDREF="Ch10_Display70"Displaying the Resizer Object's Geometry Controlsgeometry changesdetectingIDREF="Ch10_Display77"ViewKit Callbacks Associated with the ResizerrestrictingIDREF="Ch10_Display75"Resizer Utility Functionshiding geometry controlsIDREF="Ch10_Display72"Displaying the Resizer Object's Geometry Controlsinheritance graphIDREF="Ch10_Display1"Miscellaneous ViewKit Display Classesmember functionsconstructorIDREF="Ch10_Display64"The Resizer Constructor and DestructordestructorIDREF="Ch10_Display65"The Resizer Constructor and Destructorattach()IDREF="Ch10_Display67"Attaching and Detaching a Resizer Object to and from a Widgetdetach()IDREF="Ch10_Display69"Attaching and Detaching a Resizer Object to and from a Widgethide()IDREF="Ch10_Display73"Displaying the Resizer Object's Geometry ControlssetIncrements()IDREF="Ch10_Display76"Resizer Utility Functionsshow()IDREF="Ch10_Display71"Displaying the Resizer Object's Geometry Controlsshown()IDREF="Ch10_Display74"Displaying the Resizer Object's Geometry ControlsVkResizer()IDREF="Ch10_Display64"The Resizer Constructor and Destructor~VkResizer()IDREF="Ch10_Display65"The Resizer Constructor and DestructoroverviewIDREF="Ch10_Display63"ViewKit Support for Resizing and Moving WidgetsViewKit callbacksstateChangedCallbackIDREF="Ch10_Display78"ViewKit Callbacks Associated with the ResizerVkSimpleWindow classIDREF="Ch04_Windows4"ViewKit Windows0IDREF="Ch04_Windows1"ViewKit Windowsbase widgetIDREF="Ch04_Windows45"Creating the Window Interface in the Constructorclass hintsIDREF="Ch04_Windows129"Window Properties and Shell Resourcesdata members_baseWidgetIDREF="Ch04_Windows48"Creating the Window Interface in the ConstructorIDREF="Ch04_Windows47"Creating the Window Interface in the Constructor_iconStateIDREF="Ch04_Windows144"Determining Window States_mainWindowWidgetIDREF="Ch04_Windows158"Additional Data Members_stackingStateIDREF="Ch04_Windows148"Determining Window States_visibleStateIDREF="Ch04_Windows146"Determining Window Statesdisplaying windowsIDREF="Ch04_Windows69"Manipulating WindowsIDREF="Ch03_App42"Managing Top-Level Windowshiding windowsIDREF="Ch03_App44"Managing Top-Level WindowsIDREF="Ch04_Windows72"Manipulating Windowsicon titlesIDREF="Ch04_Windows106"Window and Icon Titlesiconifying windowsIDREF="Ch04_Windows75"Manipulating WindowsIDREF="Ch03_App46"Managing Top-Level Windowsinheritance graphIDREF="Ch04_Windows5"ViewKit Windowslowering windowsIDREF="Ch04_Windows84"Manipulating WindowsIDREF="Ch03_App52"Managing Top-Level Windowsmain windowIDREF="Ch04_Windows15"Window Class Constructorsmanaging widgetsIDREF="Ch04_Windows42"Creating the Window Interface in the Constructormember functionsconstructorIDREF="Ch04_Windows12"Window Class ConstructorsdestructorIDREF="Ch04_Windows25"Window Class DestructorsaddView()IDREF="Ch04_Windows49"Creating the Window Interface in the ConstructorafterRealizeHook()IDREF="Ch04_Windows152"Performing Actions After Realizing a WindowIDREF="Ch04_Windows127"Window Properties and Shell ResourcesgetTitle()IDREF="Ch04_Windows104"Window and Icon TitleshandleRawEvent()IDREF="Ch04_Windows155"Handling Raw EventshandleWmDeleteMessage()IDREF="Ch04_Windows115"Window Properties and Shell ResourceshandleWmQuitMessage()IDREF="Ch04_Windows121"Window Properties and Shell Resourceshide()IDREF="Ch04_Windows73"Manipulating Windowsiconic()IDREF="Ch04_Windows98"Window Data Access Functionsiconify()IDREF="Ch04_Windows76"Manipulating Windowslower()IDREF="Ch04_Windows85"Manipulating WindowsmainWindowWidget()IDREF="Ch04_Windows43"Creating the Window Interface in the ConstructorIDREF="Ch04_Windows89"Window Data Access FunctionsokToQuit()IDREF="Ch04_Windows118"Window Properties and Shell ResourcesIDREF="Ch03_App33"Quitting ViewKit ApplicationsIDREF="Ch04_Windows142"Providing a "Safe Quit" Mechanismopen()IDREF="Ch04_Windows79"Manipulating Windowsraise()IDREF="Ch04_Windows82"Manipulating WindowssetClassHint()IDREF="Ch04_Windows131"Window Properties and Shell ResourcessetIconName()IDREF="Ch04_Windows107"Window and Icon TitlessetTitle()IDREF="Ch04_Windows102"Window and Icon TitlessetUpInterface()IDREF="Ch04_Windows56"Creating the Window Interface in the setUpInterface() FunctionsetUpWindowProperties()IDREF="Ch04_Windows125"Window Properties and Shell Resourcesshow()IDREF="Ch04_Windows70"Manipulating WindowsIDREF="Ch04_Windows58"Creating the Window Interface in the setUpInterface() FunctionstateChanged()IDREF="Ch04_Windows150"Determining Window StatesviewWidget()IDREF="Ch04_Windows94"Window Data Access Functionsvisible()IDREF="Ch04_Windows96"Window Data Access FunctionsVkSimpleWindow()IDREF="Ch04_Windows12"Window Class Constructors~VkSimpleWindow()IDREF="Ch04_Windows25"Window Class Destructorsopening windowsIDREF="Ch03_App48"Managing Top-Level WindowsIDREF="Ch04_Windows78"Manipulating WindowsoverviewIDREF="Ch04_Windows8"ViewKit Window Classesparent widgetIDREF="Ch04_Windows14"Window Class Constructorsraising windowsIDREF="Ch03_App50"Managing Top-Level WindowsIDREF="Ch04_Windows81"Manipulating WindowsScrolledWindow widgetIDREF="Ch04_Windows51"Creating the Window Interface in the ConstructorsubclassingIDREF="Ch04_Windows140"Deriving Window SubclassesexampleIDREF="Ch04_Windows161"Window Subclassing ExamplesummaryIDREF="Ch04_Windows160"Window Creation SummaryviewsIDREF="Ch04_Windows31"Creating the Window InterfaceIDREF="Ch04_Windows10"ViewKit Window ClassesIDREF="Ch04_Windows92"Window Data Access Functionsconstructor, creating inIDREF="Ch04_Windows38"Creating the Window Interface in the Constructordirect instantiation, adding toIDREF="Ch04_Windows62"Adding a Window Interface to a Direct Instantiation of a ViewKit Window ClasssetUpInterface(), creating inIDREF="Ch04_Windows54"Creating the Window Interface in the setUpInterface() FunctionreplacingIDREF="Ch04_Windows66"Replacing a Window's ViewwidgetsIDREF="Ch04_Windows40"Creating the Window Interface in the ConstructorIDREF="Ch04_Windows87"Window Data Access Functionswindow manager interactionIDREF="Ch04_Windows100"Window Manager InterfaceIDREF="Ch04_Windows22"Window Class Constructorswindow propertiesIDREF="Ch04_Windows109"Window Properties and Shell Resourceswindow shell resourcesIDREF="Ch04_Windows17"Window Class ConstructorsIDREF="Ch04_Windows110"Window Properties and Shell Resourceswindow titlesIDREF="Ch04_Windows101"Window and Icon Titleswork areasIDREF="Ch04_Windows92"Window Data Access FunctionsIDREF="Ch04_Windows10"ViewKit Window ClassesIDREF="Ch04_Windows31"Creating the Window Interfaceconstructor, creating inIDREF="Ch04_Windows38"Creating the Window Interface in the Constructordirect instantiation, adding toIDREF="Ch04_Windows62"Adding a Window Interface to a Direct Instantiation of a ViewKit Window ClasssetUpInterface(), creating inIDREF="Ch04_Windows54"Creating the Window Interface in the setUpInterface() FunctionreplacingIDREF="Ch04_Windows66"Replacing a Window's ViewVkSubMenu classIDREF="Ch05_Menus140"Submenus0IDREF="Ch05_Menus137"Submenusadding to menusIDREF="Ch05_Menus101"Functions for Dynamically Creating Menusinheritance graphIDREF="Ch05_Menus3"Creating Menus With ViewKitmember functionsconstructorIDREF="Ch05_Menus141"Submenu ConstructorbaseWidget()IDREF="Ch05_Menus146"The baseWidget() function of a VkSubMenu object returns the CascadeButton widget required by IRIS IM pulldown menus.Radio Submenuspulldown()IDREF="Ch05_Menus145"Submenu Utility and Access FunctionsshowTearOff()IDREF="Ch05_Menus143"Submenu Utility and Access FunctionsVkSubMenu()IDREF="Ch05_Menus141"Submenu ConstructorVkTabPanel classIDREF="Ch11_Input31"The Tab Panel Component0IDREF="Ch11_Input30"The Tab Panel Componentinheritance graphIDREF="Ch11_Input1"Miscellaneous ViewKit Data Input Classesmember functionsconstructorIDREF="Ch11_Input33"The Tab Panel ConstructoraddTab()IDREF="Ch11_Input35"Adding Tabs to a Tab PaneladdTabs()IDREF="Ch11_Input37"Adding Tabs to a Tab Panelarea1()IDREF="Ch11_Input62"Tab Panel Access Functionsarea2()IDREF="Ch11_Input63"Tab Panel Access Functionsgc()IDREF="Ch11_Input61"Tab Panel Access FunctionsgetTab()IDREF="Ch11_Input52"Tab Panel Access Functionshoriz()IDREF="Ch11_Input53"Tab Panel Access FunctionslabelBg()IDREF="Ch11_Input60"Tab Panel Access FunctionslabelFg()IDREF="Ch11_Input59"Tab Panel Access FunctionslineThickness()IDREF="Ch11_Input57"Tab Panel Access FunctionsremoveTab()IDREF="Ch11_Input39"Removing a Tab from a Tab PanelselectedTab()IDREF="Ch11_Input51"Responding to Tab SelectionselectTab()IDREF="Ch11_Input36"Adding Tabs to a Tab PanelIDREF="Ch11_Input50"Responding to Tab SelectionsetTabPixmap()IDREF="Ch11_Input41"Adding a Pixmap to a Tabsize()IDREF="Ch11_Input54"Tab Panel Access FunctionstabBg()IDREF="Ch11_Input58"Tab Panel Access FunctionstabHeight()IDREF="Ch11_Input55"Tab Panel Access FunctionstabPixmap()IDREF="Ch11_Input43"Adding a Pixmap to a TabuniformTabs()IDREF="Ch11_Input56"Tab Panel Access FunctionsVkTabPanel()IDREF="Ch11_Input33"The Tab Panel ConstructoroverviewIDREF="Ch11_Input32"The Tab Panel ComponenttabsaddingIDREF="Ch11_Input34"Adding Tabs to a Tab Paneladding pixmapsIDREF="Ch11_Input40"Adding a Pixmap to a TabremovingIDREF="Ch11_Input38"Removing a Tab from a Tab Panelremoving pixmapsIDREF="Ch11_Input42"Adding a Pixmap to a Tabselection, responding toIDREF="Ch11_Input44"Responding to Tab SelectionViewKit callbackstabPopupCallbackIDREF="Ch11_Input48"Responding to Tab SelectiontabSelectCallbackIDREF="Ch11_Input45"Responding to Tab SelectionX resourcesIDREF="Ch11_Input64"X Resources Associated with the Tab Panel ComponentVkTickMarks classIDREF="Ch10_Display19"Tick Marks for Scales0IDREF="Ch10_Display17"Tick Marks for Scalesinheritance graphIDREF="Ch10_Display1"Miscellaneous ViewKit Display ClasseslabelsIDREF="Ch10_Display24"Configuring the Tick MarksIDREF="Ch10_Display21"Tick Marks Component Constructormember functionsconstructorIDREF="Ch10_Display20"Tick Marks Component ConstructoraddLabel()IDREF="Ch10_Display25"Configuring the Tick MarkssetMargin()IDREF="Ch10_Display26"Configuring the Tick MarkssetScale()IDREF="Ch10_Display23"Configuring the Tick MarksVkTickMarks()IDREF="Ch10_Display20"Tick Marks Component Constructorscale, settingIDREF="Ch10_Display22"Configuring the Tick MarksX resourcesIDREF="Ch10_Display27"X Resources Associated with the Tick Marks ComponentVkWarningDialog classIDREF="Ch07_Dialogs52"Warning Dialogs0IDREF="Ch07_Dialogs51"Warning Dialogsinheritance graphIDREF="Ch07_Dialogs3"Using Dialogs in ViewKittheWarningDialogIDREF="Ch07_Dialogs53"Warning DialogsVkWindow classIDREF="Ch04_Windows4"ViewKit Windows0IDREF="Ch04_Windows2"ViewKit Windowsbase widgetIDREF="Ch04_Windows45"Creating the Window Interface in the Constructorclass hintsIDREF="Ch04_Windows129"Window Properties and Shell Resourcesdata members_iconStateIDREF="Ch04_Windows145"Determining Window States_mainWindowWidgetIDREF="Ch04_Windows159"Additional Data Members_stackingStateIDREF="Ch04_Windows149"Determining Window States_visibleStateIDREF="Ch04_Windows147"Determining Window Statesdisplaying windowsIDREF="Ch03_App42"Managing Top-Level WindowsIDREF="Ch04_Windows69"Manipulating Windowshiding windowsIDREF="Ch04_Windows72"Manipulating WindowsIDREF="Ch03_App44"Managing Top-Level Windowsicon titlesIDREF="Ch04_Windows106"Window and Icon Titlesiconifying windowsIDREF="Ch03_App46"Managing Top-Level WindowsIDREF="Ch04_Windows75"Manipulating Windowsinheritance graphIDREF="Ch04_Windows5"ViewKit Windowslowering windowsIDREF="Ch03_App52"Managing Top-Level WindowsIDREF="Ch04_Windows84"Manipulating Windowsmain windowIDREF="Ch04_Windows15"Window Class Constructorsmanaging widgetsIDREF="Ch04_Windows42"Creating the Window Interface in the Constructormember functionsconstructorIDREF="Ch04_Windows13"Window Class ConstructorsdestructorIDREF="Ch04_Windows26"Window Class DestructorsaddMenuPane()IDREF="Ch04_Windows138"Menu Bar SupportaddRadioMenuPane()IDREF="Ch04_Windows139"Menu Bar SupportaddView()IDREF="Ch04_Windows50"Creating the Window Interface in the ConstructorafterRealizeHook()IDREF="Ch04_Windows153"Performing Actions After Realizing a WindowIDREF="Ch04_Windows128"Window Properties and Shell ResourcesgetTitle()IDREF="Ch04_Windows105"Window and Icon TitleshandleRawEvent()IDREF="Ch04_Windows156"Handling Raw EventshandleWmDeleteMessage()IDREF="Ch04_Windows116"Window Properties and Shell ResourceshandleWmQuitMessage()IDREF="Ch04_Windows122"Window Properties and Shell Resourceshide()IDREF="Ch04_Windows74"Manipulating Windowsiconic()IDREF="Ch04_Windows99"Window Data Access Functionsiconify()IDREF="Ch04_Windows77"Manipulating Windowslower()IDREF="Ch04_Windows86"Manipulating WindowsmainWindowWidget()IDREF="Ch04_Windows90"Window Data Access FunctionsIDREF="Ch04_Windows44"Creating the Window Interface in the Constructormenu()IDREF="Ch04_Windows137"Menu Bar SupportokToQuit()IDREF="Ch04_Windows143"Providing a "Safe Quit" MechanismIDREF="Ch04_Windows119"Window Properties and Shell Resourcesopen()IDREF="Ch04_Windows80"Manipulating Windowsraise()IDREF="Ch04_Windows83"Manipulating WindowssetClassHint()IDREF="Ch04_Windows132"Window Properties and Shell ResourcessetIconName()IDREF="Ch04_Windows108"Window and Icon TitlessetMenuBar()IDREF="Ch04_Windows136"Menu Bar SupportsetTitle()IDREF="Ch04_Windows103"Window and Icon TitlessetUpInterface()IDREF="Ch04_Windows57"Creating the Window Interface in the setUpInterface() FunctionsetUpWindowProperties()IDREF="Ch04_Windows126"Window Properties and Shell Resourcesshow()IDREF="Ch04_Windows71"Manipulating WindowsIDREF="Ch04_Windows59"Creating the Window Interface in the setUpInterface() FunctionstateChanged()IDREF="Ch04_Windows151"Determining Window StatesviewWidget()IDREF="Ch04_Windows95"Window Data Access Functionsvisible()IDREF="Ch04_Windows97"Window Data Access FunctionsVkWindow()IDREF="Ch04_Windows13"Window Class Constructors~VkWindow()IDREF="Ch04_Windows26"Window Class Destructorsmenu barsIDREF="Ch04_Windows134"Menu Bar SupportIDREF="Ch05_Menus132"Menu Bar0IDREF="Ch05_Menus130"Menu Baropening windowsIDREF="Ch03_App48"Managing Top-Level WindowsIDREF="Ch04_Windows78"Manipulating WindowsoverviewIDREF="Ch04_Windows8"ViewKit Window Classesparent widgetIDREF="Ch04_Windows14"Window Class Constructorsraising windowsIDREF="Ch03_App50"Managing Top-Level WindowsIDREF="Ch04_Windows81"Manipulating WindowsScrolledWindow widgetIDREF="Ch04_Windows51"Creating the Window Interface in the ConstructorsubclassingIDREF="Ch04_Windows140"Deriving Window SubclassesexampleIDREF="Ch04_Windows161"Window Subclassing ExamplesummaryIDREF="Ch04_Windows160"Window Creation SummaryviewsIDREF="Ch04_Windows11"ViewKit Window ClassesIDREF="Ch04_Windows93"Window Data Access FunctionsIDREF="Ch04_Windows32"Creating the Window Interfaceconstructor, creating inIDREF="Ch04_Windows39"Creating the Window Interface in the Constructordirect instantiation, adding toIDREF="Ch04_Windows63"Adding a Window Interface to a Direct Instantiation of a ViewKit Window ClasssetUpInterface(), creating inIDREF="Ch04_Windows55"Creating the Window Interface in the setUpInterface() FunctionreplacingIDREF="Ch04_Windows67"Replacing a Window's ViewwidgetsIDREF="Ch04_Windows40"Creating the Window Interface in the ConstructorIDREF="Ch04_Windows87"Window Data Access Functionswindow manager interactionIDREF="Ch04_Windows22"Window Class ConstructorsIDREF="Ch04_Windows100"Window Manager Interfacewindow propertiesIDREF="Ch04_Windows109"Window Properties and Shell Resourceswindow shell resourcesIDREF="Ch04_Windows17"Window Class ConstructorsIDREF="Ch04_Windows110"Window Properties and Shell Resourceswindow titlesIDREF="Ch04_Windows101"Window and Icon Titleswork areasIDREF="Ch04_Windows11"ViewKit Window ClassesIDREF="Ch04_Windows32"Creating the Window InterfaceIDREF="Ch04_Windows93"Window Data Access Functionsconstructor, creating inIDREF="Ch04_Windows39"Creating the Window Interface in the Constructordirect instantiation, adding toIDREF="Ch04_Windows63"Adding a Window Interface to a Direct Instantiation of a ViewKit Window ClasssetUpInterface(), creating inIDREF="Ch04_Windows55"Creating the Window Interface in the setUpInterface() FunctionreplacingIDREF="Ch04_Windows67"Replacing a Window's Viewbusy dialogIDREF="Ch03_App80"Entering and Exiting Busy States Using ViewKitIDREF="Ch07_Dialogs71"The Busy Dialog0IDREF="Ch07_Dialogs68"The Busy DialoginstallingIDREF="Ch03_App88"Installing Different Busy Dialogsbusy statesIDREF="Ch03_App75"Supporting Busy StatesIDREF="Ch07_Dialogs72"The Busy Dialogbusy dialogIDREF="Ch03_App80"Entering and Exiting Busy States Using ViewKitinstallingIDREF="Ch03_App89"Installing Different Busy DialogsenteringIDREF="Ch03_App76"Entering and Exiting Busy States Using ViewKitexampleIDREF="Ch03_App85"Entering and Exiting Busy States Using ViewKitexitingIDREF="Ch03_App81"Entering and Exiting Busy States Using ViewKitnestedIDREF="Ch03_App83"Entering and Exiting Busy States Using ViewKitbutterfly graphsIDREF="Ch09_Graph108"Butterfly Graphsbutterfly nodeIDREF="Ch09_Graph109"Butterfly GraphsApply button, dialogsIDREF="Ch07_Dialogs25"Methods of Posting DialogsCancel button, dialogsIDREF="Ch07_Dialogs24"Methods of Posting DialogsGraph Overview button (in VkGraph control panel)IDREF="Ch09_Graph16"Graph OverviewHelp button, dialogsIDREF="Ch07_Dialogs27"Methods of Posting DialogsIDREF="ChC_Help10"Dialog Help ProceduresIDREF="ChC_Help4"User Interfaces to the Help System in a ViewKit ApplicationMultiple Arcs button (in VkGraph control panel)IDREF="Ch09_Graph22"Displaying Duplicate ArcsOK button, dialogsIDREF="Ch07_Dialogs23"Methods of Posting DialogsRealign button (in VkGraph control panel)IDREF="Ch09_Graph25"Realigning NodesRotate Graph button (in VkGraph control panel)IDREF="Ch09_Graph27"Toggling Between Horizontal and Vertical OrientationZoom In button (in VkGraph control panel)IDREF="Ch09_Graph13"ZoomingZoom Out button (in VkGraph control panel)IDREF="Ch09_Graph12"Zoomingbuttonsradio-style. See radio-style toggles; VkRadioGroup classIDREF="Ch11_Input116"Enforcing Radio-Style Behavior on Toggle Buttonsrepeating. See repeating buttons; VkRepeatButton classIDREF="Ch11_Input86"The Repeating Button ComponentC++ Development OptionIDREF="Ch01_Overview11"Required Packagescallbacks. See ViewKit callbacks; Xt callbacksIDREF="Ch02_Components62"Using Xt Callbacks with Componentscentering algorithm, dialogsIDREF="Ch07_Dialogs41"Dialog Access and Utility Functionscheck box componentIDREF="Ch11_Input6"The Check Box Component0IDREF="Ch11_Input5"The Check Box ComponentexampleIDREF="Ch11_Input11"Setting Check Box and Toggle Labelssetting labelsIDREF="Ch11_Input10"Setting Check Box and Toggle LabelstogglesaddingIDREF="Ch11_Input8"Adding Toggles to the Check Boxdetecting value changesIDREF="Ch11_Input17"Recognizing Changes in Check Box Toggle Valuesgetting valuesIDREF="Ch11_Input15"Setting and Getting Check Box Toggle Valuessetting valuesIDREF="Ch11_Input12"Setting and Getting Check Box Toggle Valuesclass0IDREF="Ch05_Menus18"Common Features of Menu Itemsclass hintsIDREF="Ch04_Windows130"Window Properties and Shell Resourcesclass name:See alsoclassName()IDREF="Ch02_Components40"VkComponent Access FunctionsapplicationIDREF="Ch03_App110"Application Data Access FunctionsIDREF="Ch03_App13"The VkApp ConstructorcomponentsIDREF="Ch02_Components83"Component Resource SupportIDREF="Ch02_Components41"VkComponent Access FunctionsclassesdependenciesIDREF="Ch01_Overview5"Mixing ViewKit and Standard X and IRIS IM FunctionsmanagementIDREF="Ch11_Input99"Management Classes for Controlling Component and Widget OperationIDREF="Ch10_Display28"Management Classes for Controlling Component and Widget Display Characteristicsalignment groupsIDREF="Ch10_Display29"ViewKit Support for Aligning Widgetsganged scrollbarsIDREF="Ch11_Input100"Supporting "Ganged" Scrollbar Operationmodified textIDREF="Ch11_Input131"Modified Text Attachmentradio-style togglesIDREF="Ch11_Input114"Enforcing Radio-Style Behavior on Toggle ButtonsresizersIDREF="Ch10_Display55"ViewKit Support for Resizing and Moving Widgetsclearingcompletion field expansion listIDREF="Ch11_Input73"Setting and Clearing the Text Completion Field Expansion Listundo stackIDREF="Ch06_Undo22"Clearing the Undo Stackclient data, Xt callbackscomponentsIDREF="Ch02_Components69"Using Xt Callbacks with Componentsstatic menu descriptionsIDREF="Ch05_Menus84"Special Considerations for Xt Callback Client Data When Using Static Menu Descriptionscommand classesIDREF="Ch06_Undo32"Command Classes0IDREF="Ch06_Undo31"Command ClassesactivatingIDREF="Ch06_Undo46"Activating Command ClassesconstructorsIDREF="Ch06_Undo37"Command Class ConstructorsexecutingIDREF="Ch06_Undo46"Activating Command Classesmenu itemsIDREF="Ch06_Undo45"Using Command Classes as Menu ItemsoverviewIDREF="Ch06_Undo33"Overview of Command Classessetting labelsIDREF="Ch06_Undo49"Setting the Label Used by Command Classescommand-line options, parsingIDREF="Ch03_App128"VkApp Protected Functions and Data MembersIDREF="Ch03_App15"The VkApp ConstructorexampleIDREF="Ch03_App133"Example of Subclassing VkAppcompiling ViewKit programsIDREF="Ch01_Overview7"Compiling and Linking ViewKit ProgramsexampleIDREF="Ch01_Overview21"Required Librariescompletion fieldsIDREF="Ch11_Input68"The Text Completion Field Component0IDREF="Ch11_Input66"The Text Completion Field Componentactivation, respondingIDREF="Ch11_Input78"Responding to Text Completion Field Activationclearing expansion listIDREF="Ch11_Input73"Setting and Clearing the Text Completion Field Expansion Listreplacing expansion listIDREF="Ch11_Input75"Setting and Clearing the Text Completion Field Expansion Listretrieving contentsIDREF="Ch11_Input76"Retrieving the Text Completion Field Contentssetting expansion listIDREF="Ch11_Input71"Setting and Clearing the Text Completion Field Expansion ListcomponentsIDREF="Ch02_Components3"Components0IDREF="Ch02_Components2"Componentsbase widgetIDREF="Ch02_Components10"The VkComponent ClassIDREF="Ch02_Components35"Component DestructorsIDREF="Ch02_Components23"Component ConstructorsIDREF="Ch02_Components46"VkComponent Access Functions0IDREF="Ch02_Components43"VkComponent Access Functionsdeletion, handlingIDREF="Ch02_Components76"Handling Component Widget Destructionrealization, detectingIDREF="Ch02_Components53"Displaying and Hiding Componentscallbacks. See components ViewKit callbacks; components: Xt callbacksIDREF="Ch02_Components61"Using Xt Callbacks with ComponentscharacteristicsIDREF="Ch02_Components7"The VkComponent Classclass nameIDREF="Ch02_Components41"VkComponent Access FunctionsIDREF="Ch02_Components83"Component Resource Support0IDREF="Ch02_Components39"VkComponent Access FunctionsconstructorIDREF="Ch02_Components18"Component ConstructorsdefinitionIDREF="Ch02_Components5"Definition of a ComponentdestructorIDREF="Ch02_Components31"Component DestructorsdisplayingIDREF="Ch02_Components50"Displaying and Hiding ComponentshidingIDREF="Ch02_Components49"Displaying and Hiding Componentsmanaging widgetsIDREF="Ch02_Components13"The VkComponent ClassIDREF="Ch02_Components30"Component Constructorsmultiple pointers toIDREF="Ch02_Components130"Predefined ViewKit CallbacksnameIDREF="Ch02_Components19"Component ConstructorsIDREF="Ch02_Components85"Component Resource SupportIDREF="Ch02_Components36"VkComponent Access FunctionsIDREF="Ch02_Components11"The VkComponent ClassoverviewIDREF="Ch02_Components5"Definition of a Componentparent widgetIDREF="Ch02_Components25"Component ConstructorsIDREF="Ch02_Components12"The VkComponent Classresource supportIDREF="Ch02_Components80"Component Resource Supportdata members, initializingIDREF="Ch02_Components88"Initializing Data Members Based on Resource Valuesdefault values, settingIDREF="Ch02_Components91"Setting Default Resource Values for a Componentglobal values, settingIDREF="Ch02_Components93"Setting Default Resource Values for a ComponentrequirementsIDREF="Ch02_Components82"Component Resource Supportresource values, settingIDREF="Ch02_Components86"Setting Resource Values by Class or Individual Componentvalues, retrievingIDREF="Ch02_Components96"Convenience Function for Retrieving Resource Valueswidget resources, noteIDREF="Ch02_Components1"Componentsstatic member functions and Xt callbacksIDREF="Ch02_Components15"The VkComponent ClassIDREF="Ch02_Components63"Using Xt Callbacks with ComponentsexampleIDREF="Ch02_Components72"Using Xt Callbacks with Componentsnaming conventionIDREF="Ch02_Components70"Using Xt Callbacks with Componentsthis pointerIDREF="Ch02_Components67"Using Xt Callbacks with ComponentssubclassingIDREF="Ch02_Components133"Deriving Subclasses to Create New ComponentsconstructorIDREF="Ch02_Components24"Component ConstructorsexamplesIDREF="Ch02_Components135"Example of Creating a New ComponentsummaryIDREF="Ch02_Components134"Subclassing Summarytesting for validIDREF="Ch02_Components58"VkComponent Utility FunctionsViewKit callbacksIDREF="Ch02_Components107"ViewKit Callback SupportcreatingIDREF="Ch02_Components124"Defining and Triggering ViewKit CallbacksdefiningIDREF="Ch02_Components124"Defining and Triggering ViewKit CallbacksinvokingIDREF="Ch02_Components126"Defining and Triggering ViewKit CallbacksoverviewIDREF="Ch02_Components108"ViewKit Callback Supportregistering callback functionsIDREF="Ch02_Components110"Registering ViewKit Callbacksremoving callback functionsIDREF="Ch02_Components119"Removing ViewKit CallbackstriggeringIDREF="Ch02_Components126"Defining and Triggering ViewKit Callbacksunregistering callback functionsIDREF="Ch02_Components120"Removing ViewKit Callbackswidget destructionIDREF="Ch02_Components74"Handling Component Widget DestructionIDREF="Ch02_Components34"Component DestructorsIDREF="Ch02_Components28"Component ConstructorsIDREF="Ch02_Components14"The VkComponent ClasswidgetsIDREF="Ch02_Components21"Component ConstructorsIDREF="Ch02_Components9"The VkComponent ClassXt callbacksIDREF="Ch02_Components63"Using Xt Callbacks with ComponentsIDREF="Ch02_Components15"The VkComponent ClassexampleIDREF="Ch02_Components72"Using Xt Callbacks with Componentsnaming conventionIDREF="Ch02_Components70"Using Xt Callbacks with Componentsthis pointerIDREF="Ch02_Components67"Using Xt Callbacks with Componentsconceptssuggested readingIDREF="Intro3"What You Should Know Before Reading This Guideconstructing menusdynamicallyIDREF="Ch05_Menus88"Constructing Menus DynamicallyexampleIDREF="Ch05_Menus106"Example of a Creating a Menu Bar Dynamicallystatic description, fromIDREF="Ch05_Menus78"Constructing Menus from a Static DescriptionexampleIDREF="Ch05_Menus87"Example of a Creating a Menu Bar Using a Static DescriptionVkMenuDesc structureIDREF="Ch05_Menus80"The VkMenuDesc StructureXt callback client dataIDREF="Ch05_Menus85"Special Considerations for Xt Callback Client Data When Using Static Menu DescriptionsconstructorsSee individual class namesIDREF="Ch02_Components17"Component Constructorscontext-sensitive helpIDREF="ChC_Help2"User Interfaces to the Help System in a ViewKit ApplicationIDREF="ChC_Help12"Context-Sensitive Help ProceduresconventionsIDREF="Intro7"Conventions Used in This Guideinheritance graphsIDREF="Intro15"Class Inheritance Graph Conventionsreference pagesIDREF="Intro12"Typographical ConventionstypographicalIDREF="Intro9"Typographical ConventionscreatingViewKit callbacksIDREF="Ch02_Components123"Defining and Triggering ViewKit Callbackswindow interfacesIDREF="Ch04_Windows33"Creating the Window Interface0IDREF="Ch04_Windows34"Creating the Window InterfacecursorsIDREF="Ch03_App56"Setting Application Cursorsbusy, animatedIDREF="Ch03_App66"Creating, Setting, and Retrieving an Animated Busy CursorIDREF="Ch03_App62"Setting and Retrieving the Busy CursoranimatingIDREF="Ch03_App86"Animating the Busy CursorexampleIDREF="Ch03_App70"Creating, Setting, and Retrieving an Animated Busy Cursorbusy, fixedIDREF="Ch03_App61"Setting and Retrieving the Busy CursordefaultIDREF="Ch03_App57"Setting Application CursorsIDREF="Ch03_App63"Setting and Retrieving the Busy CursornormalIDREF="Ch03_App58"Setting and Retrieving the Normal CursortemporaryIDREF="Ch03_App73"Setting and Retrieving a Temporary Cursorcustom dialogIDREF="Ch07_Dialogs118"Deriving New Dialog Classes Using the Generic Dialog0IDREF="Ch07_Dialogs112"Deriving New Dialog Classes Using the Generic Dialogdata members, initializing with X resourcesIDREF="Ch02_Components87"Initializing Data Members Based on Resource Valuesdeactivatingmenu itemsIDREF="Ch05_Menus33"Activating and Deactivating Menu ItemsIDREF="Ch05_Menus114"Activating and Deactivating Items in a Menupreference itemsIDREF="Ch08_Pref31"Preference Item Access Functionsdebug libraries, ViewKitIDREF="Ch01_Overview14"Required Packagesdefining ViewKit callbacksIDREF="Ch02_Components123"Defining and Triggering ViewKit Callbacksdemonstration programsIDREF="Ch01_Overview23"Demonstration ProgramsdependenciesVkAppIDREF="Ch03_App8"The VkApp ConstructorIDREF="Ch01_Overview6"Mixing ViewKit and Standard X and IRIS IM FunctionsclassesIDREF="Ch01_Overview5"Mixing ViewKit and Standard X and IRIS IM Functions deriving subclasses. See components subclassingSee also specific classesIDREF="Ch02_Components132"Deriving Subclasses to Create New Componentsderiving subclasses. See components subclassingIDREF="Ch02_Components132"Deriving Subclasses to Create New Componentsdeselectingnodes in graphsIDREF="Ch09_Graph37"Edit Mode OperationsdialogsIDREF="Ch07_Dialogs2"Using Dialogs in ViewKit0IDREF="Ch07_Dialogs1"Using Dialogs in ViewKitbusyIDREF="Ch07_Dialogs71"The Busy DialogIDREF="Ch03_App80"Entering and Exiting Busy States Using ViewKit0IDREF="Ch07_Dialogs69"The Busy DialoginstallingIDREF="Ch03_App88"Installing Different Busy Dialogsbutton labels, settingIDREF="Ch07_Dialogs39"Setting the Button LabelsApply buttonIDREF="Ch07_Dialogs25"Methods of Posting DialogsCancel buttonIDREF="Ch07_Dialogs24"Methods of Posting DialogsHelp buttonIDREF="ChC_Help10"Dialog Help ProceduresIDREF="Ch07_Dialogs27"Methods of Posting DialogsIDREF="ChC_Help4"User Interfaces to the Help System in a ViewKit ApplicationOK buttonIDREF="Ch07_Dialogs23"Methods of Posting Dialogscentering algorithmIDREF="Ch07_Dialogs41"Dialog Access and Utility FunctionscustomIDREF="Ch07_Dialogs118"Deriving New Dialog Classes Using the Generic Dialog0IDREF="Ch07_Dialogs113"Deriving New Dialog Classes Using the Generic DialogerrorIDREF="Ch07_Dialogs57"Error Dialogs0IDREF="Ch07_Dialogs55"Error Dialogsevent handlingduring postAndWait()IDREF="Ch07_Dialogs31"Methods of Posting Dialogsduring sendSyncRequest()IDREF="ChA_ToolTalk36"Sending Synchronous Requestsduring wasInterrupted()IDREF="Ch07_Dialogs83"The Interruptible Busy Dialogfatal errorIDREF="Ch07_Dialogs63"Fatal Error Dialogs0IDREF="Ch07_Dialogs61"Fatal Error Dialogsfile selectionIDREF="Ch07_Dialogs104"The File Selection Dialog0IDREF="Ch07_Dialogs102"The File Selection DialogcautionIDREF="Ch07_Dialogs110"The File Selection DialoggenericIDREF="Ch07_Dialogs117"Deriving New Dialog Classes Using the Generic Dialog0IDREF="Ch07_Dialogs115"Deriving New Dialog Classes Using the Generic DialoginformationIDREF="Ch07_Dialogs47"Information Dialogs0IDREF="Ch07_Dialogs45"Information Dialogsinterruptible busyIDREF="Ch07_Dialogs77"The Interruptible Busy Dialog0IDREF="Ch07_Dialogs75"The Interruptible Busy Dialogchecking for interruptionsIDREF="Ch07_Dialogs79"The Interruptible Busy DialoginstallingIDREF="Ch03_App93"Installing Different Busy DialogsIDREF="Ch07_Dialogs87"The Interruptible Busy DialogmessageIDREF="Ch07_Dialogs22"Methods of Posting DialogsoverviewIDREF="Ch07_Dialogs8"Overview of ViewKit Dialog Managementparent widgetIDREF="Ch07_Dialogs28"Methods of Posting DialogspointersIDREF="Ch07_Dialogs9"ViewKit Dialog Class OverviewpostingIDREF="Ch07_Dialogs12"Posting DialogsexamplesIDREF="Ch07_Dialogs33"Examples of Posting DialogsmethodsIDREF="Ch07_Dialogs13"Methods of Posting Dialogspreference. See preference dialogs; VkPrefDialog classIDREF="Ch08_Pref2"Preference DialogsProduct InformationIDREF="Ch03_App103"Maintaining Product and Version InformationIDREF="Ch05_Menus190"Implementation of the Help MenupromptIDREF="Ch07_Dialogs97"The Prompt Dialog0IDREF="Ch07_Dialogs95"The Prompt DialogcautionIDREF="Ch07_Dialogs100"The Prompt DialogquestionIDREF="Ch07_Dialogs92"The Question Dialog0IDREF="Ch07_Dialogs90"The Question DialogVkMenuConfirmFirstAction useIDREF="Ch05_Menus58"Confirmable Menu Actionstitle, settingIDREF="Ch07_Dialogs37"Setting the Title of the DialogunpostingIDREF="Ch07_Dialogs34"Unposting DialogswarningIDREF="Ch07_Dialogs52"Warning Dialogs0IDREF="Ch07_Dialogs50"Warning Dialogsdisabling multi-level undo supportIDREF="Ch06_Undo20"Enabling and Disabling Multi-level Undo SupportDisplay structureIDREF="Ch03_App115"Application Data Access FunctionsdisplayingcomponentsIDREF="Ch02_Components50"Displaying and Hiding Componentsgraph overview windowIDREF="Ch09_Graph115"Displaying a Graph OverviewIDREF="Ch09_Graph15"Graph Overviewmenu itemsIDREF="Ch05_Menus21"Displaying and Hiding Menu Itemsmodified text attachment dogearIDREF="Ch11_Input143"Displaying and Hiding the Modified Text Attachmentnodes in graphsIDREF="Ch09_Graph28"Hiding and Displaying NodesIDREF="Ch09_Graph126"Graph Utility FunctionsIDREF="Ch09_Graph43"Edit Mode OperationsIDREF="Ch09_Graph83"Indicating Which Nodes to Displayresizer geometry controlsIDREF="Ch10_Display70"Displaying the Resizer Object's Geometry ControlswindowsIDREF="Ch03_App42"Managing Top-Level WindowsIDREF="Ch04_Windows69"Manipulating Windowsdouble-buffer componentIDREF="Ch10_Display4"ViewKit Support for Double-Buffered Graphics0IDREF="Ch10_Display2"ViewKit Support for Double-Buffered GraphicsdrawingIDREF="Ch10_Display8"Drawing in the Double Buffer ComponentresizingIDREF="Ch10_Display13"Handling Double Buffer Component Resize Requestsswitching buffersIDREF="Ch10_Display11"Switching Buffers in the Double Buffer Componentdrawing, double-bufferedIDREF="Ch10_Display8"Drawing in the Double Buffer Component0IDREF="Ch10_Display7"Drawing in the Double Buffer Componenterror dialogIDREF="Ch07_Dialogs57"Error Dialogs0IDREF="Ch07_Dialogs54"Error Dialogserror dialog, fatalIDREF="Ch07_Dialogs63"Fatal Error Dialogs0IDREF="Ch07_Dialogs59"Fatal Error Dialogsestablishing connectionsnodes in graphsIDREF="Ch09_Graph51"Node Constructor and DestructorIDREF="Ch09_Graph77"Adding Nodes and Specifying Node Connectivityestablishing ToolTalk connectionIDREF="ChA_ToolTalk21"Establishing a Connection to the ToolTalk Serviceevent handlingIDREF="Ch03_App18"Running ViewKit Applicationsduring postAndWait()IDREF="Ch07_Dialogs31"Methods of Posting Dialogsduring sendSyncRequest()IDREF="ChA_ToolTalk36"Sending Synchronous Requestsduring wasInterrupted()IDREF="Ch07_Dialogs83"The Interruptible Busy Dialogpending eventsIDREF="Ch03_App27"ViewKit Event Handlingraw eventsIDREF="Ch04_Windows154"Handling Raw EventsIDREF="Ch03_App22"ViewKit Event Handlingexamining undo stackIDREF="Ch06_Undo25"Examining the Undo Stackexecuting command classesIDREF="Ch06_Undo46"Activating Command Classesexiting applications. See quitting applicationsIDREF="Ch03_App30"Quitting ViewKit Applicationsfatal error dialogIDREF="Ch07_Dialogs63"Fatal Error Dialogs0IDREF="Ch07_Dialogs60"Fatal Error Dialogsfile selection dialogIDREF="Ch07_Dialogs104"The File Selection Dialog0IDREF="Ch07_Dialogs101"The File Selection DialogcautionIDREF="Ch07_Dialogs110"The File Selection DialoglibvkhelpIDREF="Ch01_Overview20"Required LibrariesIDREF="ChC_Help14"The ViewKit Help Libraryfindingmenu itemsIDREF="Ch05_Menus108"Finding Items in a Menunodes (in graphs)IDREF="Ch09_Graph132"Graph Access FunctionsIDREF="Ch09_Graph65"Node Access FunctionsaboutDialog() (in VkApp)IDREF="Ch03_App106"Maintaining Product and Version Informationactivate() (in VkCompletionField)IDREF="Ch11_Input85"Deriving Text Completion Field Subclassesactivate() (in VkMenuItem)IDREF="Ch05_Menus31"Activating and Deactivating Menu Itemsactivate() (in VkPrefItem)IDREF="Ch08_Pref32"Preference Item Access FunctionsactivateItem() (in VkMenu)IDREF="Ch05_Menus112"Activating and Deactivating Items in a Menuadd() (in VkAlignmentGroup)IDREF="Ch10_Display38"Adding Widgets and Components to an Alignment Groupadd() (in VkCompletionField)IDREF="Ch11_Input72"Setting and Clearing the Text Completion Field Expansion Listadd() (in VkGangedGroup)IDREF="Ch11_Input109"Adding Scales and Scrollbars to a Ganged Groupadd() (in VkGraph)IDREF="Ch09_Graph76"Adding Nodes and Specifying Node Connectivityadd() (in VkMenu)IDREF="Ch05_Menus105"Functions for Dynamically Creating Menusadd() (in VkMenuUndoManager)IDREF="Ch06_Undo15"Providing Undo Support for Actions That Are Not Menu Itemsadd() (in VkMeter)IDREF="ChB_Contrib9"Adding Items to a Meteradd() (in VkRadioGroup)IDREF="Ch11_Input124"Adding Toggles and Buttons to a Radio GroupaddAction() (in VkMenu)IDREF="Ch05_Menus91"Functions for Dynamically Creating MenusaddAction() (in VkMsgClient)IDREF="ChA_ToolTalk67"Creating and Registering Simple Message PatternsaddCallback() (in VkCallbackObject)IDREF="Ch02_Components111"Registering ViewKit CallbacksaddConfirmFirstAction() (in VkMenu)IDREF="Ch05_Menus94"Functions for Dynamically Creating MenusaddDesktopMenuItems() (in VkGraph)IDREF="Ch09_Graph152"Subclassing VkGraphaddItem() (in VkCheckBox)IDREF="Ch11_Input9"Adding Toggles to the Check BoxaddItem() (in VkPrefGroup)IDREF="Ch08_Pref102"Adding and Deleting Preference Items from a Group ItemaddLabel() (in VkMenu)IDREF="Ch05_Menus98"Functions for Dynamically Creating MenusaddLabel() (in VkTickMarks)IDREF="Ch10_Display25"Configuring the Tick MarksaddMenuItems() (in VkGraph)IDREF="Ch09_Graph150"Subclassing VkGraphaddMenuPane() (in VkWindow)IDREF="Ch04_Windows138"Menu Bar SupportaddRadioMenuPane() (in VkWindow)IDREF="Ch04_Windows139"Menu Bar SupportaddRadioSubmenu() (in VkMenu)IDREF="Ch05_Menus104"Functions for Dynamically Creating MenusaddSeparator() (in VkMenu)IDREF="Ch05_Menus100"Functions for Dynamically Creating MenusaddSubmenu() (in VkMenu)IDREF="Ch05_Menus102"Functions for Dynamically Creating MenusaddTab() (in VkTabPanel)IDREF="Ch11_Input35"Adding Tabs to a Tab PaneladdTabs() (in VkTabPanel)IDREF="Ch11_Input37"Adding Tabs to a Tab PaneladdToggle() (in VkMenu)IDREF="Ch05_Menus96"Functions for Dynamically Creating MenusaddView() (in VkSimpleWindow)IDREF="Ch04_Windows49"Creating the Window Interface in the ConstructoradjustGeometry() (in VkModifiedAttachment)IDREF="Ch11_Input162"Adjusting the Modified Text Attachment's GeometryafterRealizeHook() (in VkApp)IDREF="Ch03_App130"VkApp Protected Functions and Data MembersafterRealizeHook() (in VkComponent)IDREF="Ch02_Components54"Displaying and Hiding ComponentsafterRealizeHook() (in VkSimpleWindow)IDREF="Ch04_Windows127"Window Properties and Shell ResourcesIDREF="Ch04_Windows152"Performing Actions After Realizing a WindowalignBottom() (in VkAlignmentGroup)IDREF="Ch10_Display45"Aligning Widgets and Components in an Alignment GroupalignHeight() (in VkAlignmentGroup)IDREF="Ch10_Display47"Aligning Widgets and Components in an Alignment GroupalignLeft() (in VkAlignmentGroup)IDREF="Ch10_Display42"Aligning Widgets and Components in an Alignment GroupalignRight() (in VkAlignmentGroup)IDREF="Ch10_Display43"Aligning Widgets and Components in an Alignment GroupalignTop() (in VkAlignmentGroup)IDREF="Ch10_Display44"Aligning Widgets and Components in an Alignment GroupalignWidth() (in VkAlignmentGroup)IDREF="Ch10_Display46"Aligning Widgets and Components in an Alignment GroupappContext() (in VkApp)IDREF="Ch03_App112"Application Data Access FunctionsapplicationClassName() (in VkApp)IDREF="Ch03_App109"Application Data Access Functionsapply() (in VkDialogManager)IDREF="Ch07_Dialogs127"Deriving New Dialog Classes Using the Generic Dialogarea1() (in VkTabPanel)IDREF="Ch11_Input62"Tab Panel Access Functionsarea2() (in VkTabPanel)IDREF="Ch11_Input63"Tab Panel Access Functionsargc() (in VkApp)IDREF="Ch03_App118"Application Data Access Functionsargv() (in VkApp)IDREF="Ch03_App120"Application Data Access Functionsattach() (in VkModifiedAttachment)IDREF="Ch11_Input140"Attaching and Detaching the Modified Text Attachment to and from a Widgetattach() (in VkPopupMenu)IDREF="Ch05_Menus176"Attaching Popup Menus to Widgetsattach() (in VkResizer)IDREF="Ch10_Display67"Attaching and Detaching a Resizer Object to and from a WidgetbaseHeight() (in VkPrefItem)IDREF="Ch08_Pref39"Preference Item Access FunctionsbaseWidget() (in VkApp)IDREF="Ch03_App124"Application Data Access FunctionsbaseWidget() (in VkComponent)IDREF="Ch02_Components45"VkComponent Access FunctionsbaseWidget() (in VkSubMenu)IDREF="Ch05_Menus146"The baseWidget() function of a VkSubMenu object returns the CascadeButton widget required by IRIS IM pulldown menus.Radio Submenusbuild() (in VkNode)IDREF="Ch09_Graph69"Creating Node Subclassesbuild() (in VkPopupMenu)IDREF="Ch05_Menus178"Popping Up Popup MenusbuildCmdPanel() (in VkGraph)IDREF="Ch09_Graph148"Subclassing VkGraphbuildZoomMenu() (in VkGraph)IDREF="Ch09_Graph149"Subclassing VkGraphbusy() (in VkApp)IDREF="Ch03_App77"Entering and Exiting Busy States Using ViewKitnoteIDREF="Ch03_App84"Entering and Exiting Busy States Using ViewKitbusyCursor() (in VkApp)IDREF="Ch03_App65"Setting and Retrieving a Fixed Busy CursorIDREF="Ch03_App72"Creating, Setting, and Retrieving an Animated Busy CursorcallCallbacks() (in VkCallbackObject)IDREF="Ch02_Components127"Defining and Triggering ViewKit Callbackscancel() (in VkDialogManager)IDREF="Ch07_Dialogs126"Deriving New Dialog Classes Using the Generic DialogcenterOnScreen() (in VkDialogManager)IDREF="Ch07_Dialogs42"Dialog Access and Utility Functionschanged() (in VkPrefGroup)IDREF="Ch08_Pref112"Monitoring the Values of Preference Items Associated with a Group Itemchanged() (in VkPrefItem)IDREF="Ch08_Pref29"Getting and Setting Preference Item Valueschild() (in VkNode)IDREF="Ch09_Graph64"Node Access FunctionsclassName() (in VkApp)IDREF="Ch03_App111"Application Data Access FunctionsclassName() (in VkComponent)IDREF="Ch02_Components42"VkComponent Access FunctionsIDREF="Ch02_Components84"Component Resource Supportclear() (in VkCompletionField)IDREF="Ch11_Input74"Setting and Clearing the Text Completion Field Expansion ListclearAll() (in VkGraph)IDREF="Ch09_Graph85"Indicating Which Nodes to DisplaycomposeAdd() (in VkMsgClient)IDREF="ChA_ToolTalk31"Composing and Sending MessagescomposeBegin() (in VkMsgClient)IDREF="ChA_ToolTalk30"Composing and Sending MessagescreateAction() (in VkMsgClient)IDREF="ChA_ToolTalk70"Creating More Detailed Message PatternscreateCursor() (in VkCursorList)IDREF="Ch03_App68"Creating, Setting, and Retrieving an Animated Busy CursorcreateDialog() (in VkGenericDialog)IDREF="Ch07_Dialogs119"Deriving New Dialog Classes Using the Generic Dialogdeactivate() (in VkMenu)IDREF="Ch05_Menus115"Activating and Deactivating Items in a Menudeactivate() (in VkMenuItem)IDREF="Ch05_Menus34"Activating and Deactivating Menu Itemsdeactivate() (in VkPrefItem)IDREF="Ch08_Pref33"Preference Item Access FunctionsdeleteChildren() (in VkPrefGroup)IDREF="Ch08_Pref109"Adding and Deleting Preference Items from a Group Itemdetach() (in VkModifiedAttachment)IDREF="Ch11_Input142"Attaching and Detaching the Modified Text Attachment to and from a Widgetdetach() (in VkResizer)IDREF="Ch10_Display69"Attaching and Detaching a Resizer Object to and from a Widgetdisplay() (in VkApp)IDREF="Ch03_App114"Application Data Access Functionsdisplay() (in VkGraph)IDREF="Ch09_Graph87"Indicating Which Nodes to DisplaydisplayAll() (in VkGraph)IDREF="Ch09_Graph86"Indicating Which Nodes to DisplaydisplayButterfly() (in VkGraph)IDREF="Ch09_Graph110"Butterfly GraphsdisplayIf() (in VkGraph)IDREF="Ch09_Graph101"Indicating Which Nodes to DisplaydisplayParentsAndChildren() (in VkGraph)IDREF="Ch09_Graph99"Indicating Which Nodes to DisplaydisplayValue() (in VkModifiedAttachment)IDREF="Ch11_Input160"Controlling the Contents of the Text WidgetdisplayWithAllChildren() (in VkGraph)IDREF="Ch09_Graph92"Indicating Which Nodes to DisplaydisplayWithAllParents() (in VkGraph)IDREF="Ch09_Graph97"Indicating Which Nodes to DisplaydisplayWithChildren() (in VkGraph)IDREF="Ch09_Graph90"Indicating Which Nodes to DisplaydisplayWithParents() (in VkGraph)IDREF="Ch09_Graph96"Indicating Which Nodes to DisplaydistributeHorizontal() (in VkAlignmentGroup)IDREF="Ch10_Display50"Aligning Widgets and Components in an Alignment GroupdistributeVertical() (in VkAlignmentGroup)IDREF="Ch10_Display49"Aligning Widgets and Components in an Alignment Groupdoit() (in VkAction)IDREF="Ch06_Undo44"Overriding Virtual Functionsdoit() (in VkMenuActionObject)IDREF="Ch06_Undo43"Overriding Virtual FunctionsdoLayout() (in VkGraph)IDREF="Ch09_Graph105"Laying Out the GraphdoSparseLayout() (in VkGraph)IDREF="Ch09_Graph107"Laying Out the GraphdoSubtreeLayout() (in VkGraph)IDREF="Ch09_Graph106"Laying Out the Graphdraw() (in VkDoubleBuffer)IDREF="Ch10_Display9"Drawing in the Double Buffer Componentexpand() (in VkCompletionField)IDREF="Ch11_Input82"Deriving Text Completion Field SubclassesexpandNode() (in VkGraph)IDREF="Ch09_Graph91"Indicating Which Nodes to DisplayexpandSubgraph() (in VkGraph)IDREF="Ch09_Graph93"Indicating Which Nodes to Displayexpose() (in VkModifiedAttachment)IDREF="Ch11_Input147"Displaying and Hiding the Modified Text AttachmentfileName() (in VkFileSelectionDialog)IDREF="Ch07_Dialogs109"The File Selection Dialogfind() (in VkGraph)IDREF="Ch09_Graph133"Graph Access FunctionsfindChild() (in VkNode)IDREF="Ch09_Graph67"Node Access FunctionsfindNamedItem() (in VkMenu)IDREF="Ch05_Menus107"Finding Items in a MenufindParent() (in VkNode)IDREF="Ch09_Graph66"Node Access FunctionsfixPreviousValue() (in VkModifiedAttachment)IDREF="Ch11_Input166"Other Modified Text Attachment Utility and Access FunctionsforAllNodesDo() (in VkGraph)IDREF="Ch09_Graph124"Graph Utility FunctionsforceWidth() (in VkOptionMenu)IDREF="Ch05_Menus167"Option Menu Utility Functionsgc() (in VkTabPanel)IDREF="Ch11_Input61"Tab Panel Access FunctionsgetButton() (in VkPrefOption)IDREF="Ch08_Pref70"Dynamically Changing the Number of Option Menu ItemsgetIndex() (in VkOptionMenu)IDREF="Ch05_Menus164"Determining Selected Items in an Option MenugetItem() (in VkOptionMenu)IDREF="Ch05_Menus165"Determining Selected Items in an Option MenugetItemPosition() (in VkMenu)IDREF="Ch05_Menus125"Menu Access FunctionsgetLabel() (in VkPrefOption)IDREF="Ch08_Pref66"Setting Option Menu Preference Item LabelsgetParameters() (in VkModifiedAttachment)IDREF="Ch11_Input164"Adjusting the Modified Text Attachment's GeometrygetResources() (in VkComponent)IDREF="Ch02_Components89"Initializing Data Members Based on Resource ValuesgetState() (in VkMenuToggle)IDREF="Ch05_Menus66"Menu TogglesgetTab() (in VkTabPanel)IDREF="Ch11_Input52"Tab Panel Access FunctionsgetText() (in VkCompletionField)IDREF="Ch11_Input77"Retrieving the Text Completion Field ContentsgetTitle() (in VkSimpleWindow)IDREF="Ch04_Windows104"Window and Icon TitlesgetValue() (in VkCheckBox)IDREF="Ch11_Input16"Setting and Getting Check Box Toggle ValuesgetValue() (in VkPrefItem)IDREF="Ch08_Pref27"Getting and Setting Preference Item ValuesgetValue() (in VkPrefOption)IDREF="Ch08_Pref71"Getting and Setting Option Menu Preference Item ValuesgetValue() (in VkPrefText)IDREF="Ch08_Pref48"Text FieldsgetValue() (in VkPrefToggle)IDREF="Ch08_Pref57"Getting and Setting Toggle Preference Item ValuesgraphWidget() (in VkGraph)IDREF="Ch09_Graph135"Graph Access FunctionshandlePendingEvents() (in VkApp)IDREF="Ch03_App28"ViewKit Event HandlinghandleRawEvent() (in VkApp)IDREF="Ch03_App23"ViewKit Event HandlingnoteIDREF="Ch03_App26"ViewKit Event HandlinghandleRawEvent() (in VkSimpleWindow)IDREF="Ch04_Windows155"Handling Raw EventshandleWmDeleteMessage() (in VkSimpleWindow)IDREF="Ch04_Windows115"Window Properties and Shell ResourceshandleWmQuitMessage() (in VkSimpleWindow)IDREF="Ch04_Windows121"Window Properties and Shell ResourceshasUndo() (in VkMenuAction)IDREF="Ch05_Menus51"Menu Actionsheight() (in VkAlignmentGroup)IDREF="Ch10_Display52"Alignment Group Access FunctionshelpPane() (in VkMenuBar)IDREF="Ch05_Menus135"Menu Bar Access Functionshide() (in VkApp)IDREF="Ch03_App45"Managing Top-Level Windowshide() (in VkComponent)IDREF="Ch02_Components52"Displaying and Hiding Componentshide() (in VkMenuItem)IDREF="Ch05_Menus25"Displaying and Hiding Menu Itemshide() (in VkModifiedAttachment)IDREF="Ch11_Input146"Displaying and Hiding the Modified Text Attachmenthide() (in VkResizer)IDREF="Ch10_Display73"Displaying the Resizer Object's Geometry Controlshide() (in VkSimpleWindow)IDREF="Ch04_Windows73"Manipulating WindowshideAllChildren() (in VkGraph)IDREF="Ch09_Graph94"Indicating Which Nodes to DisplayhideNode() (in VkGraph)IDREF="Ch09_Graph88"Indicating Which Nodes to DisplayhideOverview() (in VkGraph)IDREF="Ch09_Graph116"Displaying a Graph OverviewhideParents() (in VkGraph)IDREF="Ch09_Graph98"Indicating Which Nodes to DisplayhideParentsAndChildren() (in VkGraph)IDREF="Ch09_Graph100"Indicating Which Nodes to DisplayhideWithAllChildren() (in VkGraph)IDREF="Ch09_Graph95"Indicating Which Nodes to DisplayhistoryList() (in VkMenuUndoManager)IDREF="Ch06_Undo26"Examining the Undo Stackhoriz() (in VkTabPanel)IDREF="Ch11_Input53"Tab Panel Access Functionsiconic() (in VkSimpleWindow)IDREF="Ch04_Windows98"Window Data Access Functionsiconify() (in VkApp)IDREF="Ch03_App47"Managing Top-Level Windowsiconify() (in VkSimpleWindow)IDREF="Ch04_Windows76"Manipulating WindowsinstallDestroyHandler() (in VkComponent)IDREF="Ch02_Components78"Handling Component Widget DestructionIDREF="Ch02_Components29"Component ConstructorsisComponent() (in VkComponent)IDREF="Ch02_Components59"VkComponent Utility FunctionsisContainer() (in VkMenuItem)IDREF="Ch05_Menus46"Menu Items Utility FunctionsisContainer() (in VkPrefItem)IDREF="Ch08_Pref43"Preference Item Access Functionsitem() (in VkPrefDialog)IDREF="Ch08_Pref120"Setting the Preference Items for a Preference Dialogitem() (in VkPrefGroup)IDREF="Ch08_Pref104"Adding and Deleting Preference Items from a Group Itemlabel() (in VkNode)IDREF="Ch09_Graph59"Node Access FunctionslabelBg() (in VkTabPanel)IDREF="Ch11_Input60"Tab Panel Access FunctionslabelFg() (in VkTabPanel)IDREF="Ch11_Input59"Tab Panel Access FunctionslabelHeight() (in VkPrefItem)IDREF="Ch08_Pref38"Preference Item Access FunctionslabelWidget() (in VkPrefItem)IDREF="Ch08_Pref40"Preference Item Access FunctionslastPosted() (in VkDialogManager)IDREF="Ch07_Dialogs43"Dialog Access and Utility FunctionslatestDisplay() (in VkModifiedAttachment)IDREF="Ch11_Input159"Controlling the Contents of the Text WidgetlineThickness() (in VkTabPanel)IDREF="Ch11_Input57"Tab Panel Access Functionslower() (in VkApp)IDREF="Ch03_App53"Managing Top-Level Windowslower() (in VkSimpleWindow)IDREF="Ch04_Windows85"Manipulating Windowsmain()IDREF="Ch01_Overview22"The Simplest ViewKit ProgrammainWindow() (in VkApp)IDREF="Ch03_App41"Managing Top-Level WindowsmainWindowWidget() (in VkSimpleWindow)IDREF="Ch04_Windows89"Window Data Access FunctionsIDREF="Ch04_Windows43"Creating the Window Interface in the ConstructormakeNodeVisible() (in VkGraph)IDREF="Ch09_Graph127"Graph Utility FunctionsmakeNormal() (in VkAlignmentGroup)IDREF="Ch10_Display48"Aligning Widgets and Components in an Alignment Groupmenu() (in VkWindow)IDREF="Ch04_Windows137"Menu Bar SupportmenuType() (in VkMenuItem)IDREF="Ch05_Menus44"Menu Items Utility FunctionsmessageClient() (in VkMsgApp)IDREF="ChA_ToolTalk25"Establishing a Connection to the ToolTalk ServicemessageClient() (in VkMsgComponent)IDREF="ChA_ToolTalk79"Supporting Messaging in ComponentsmessageClient() (in VkMsgWindow)IDREF="ChA_ToolTalk77"Supporting Messaging in Application Windowsmodified() (in VkModifiedAttachment)IDREF="Ch11_Input168"Other Modified Text Attachment Utility and Access FunctionsmultiLevel() (in VkMenuUndoManager)IDREF="Ch06_Undo21"Enabling and Disabling Multi-level Undo Supportname() (in VkApp)IDREF="Ch03_App107"Application Data Access Functionsname() (in VkComponent)IDREF="Ch02_Components37"VkComponent Access FunctionsnChildren() (in VkNode)IDREF="Ch09_Graph62"Node Access FunctionsneededHeight() (in VkMeter)IDREF="ChB_Contrib16"Determining the Desired Dimensions of the MeterneededWidth() (in VkMeter)IDREF="ChB_Contrib15"Determining the Desired Dimensions of the MeternormalCursor() (in VkApp)IDREF="Ch03_App60"Setting and Retrieving the Normal CursornotBusy() (in VkApp)IDREF="Ch03_App82"Entering and Exiting Busy States Using ViewKitnParents() (in VkNode)IDREF="Ch09_Graph61"Node Access FunctionsnumItems() (in VkMenu)IDREF="Ch05_Menus122"Menu Access FunctionsnumNodes() (in VkGraph)IDREF="Ch09_Graph131"Graph Access Functionsok() (in VkDialogManager)IDREF="Ch07_Dialogs125"Deriving New Dialog Classes Using the Generic DialogokToQuit() (in VkComponent)IDREF="Ch02_Components56"VkComponent Utility FunctionsokToQuit() (in VkSimpleWindow)IDREF="Ch03_App33"Quitting ViewKit ApplicationsIDREF="Ch04_Windows142"Providing a "Safe Quit" MechanismIDREF="Ch04_Windows118"Window Properties and Shell Resourcesopen() (in VkApp)IDREF="Ch03_App49"Managing Top-Level Windowsopen() (in VkSimpleWindow)IDREF="Ch04_Windows79"Manipulating WindowsoverviewWindow() (in VkGraph)IDREF="Ch09_Graph118"Displaying a Graph Overviewparent() (in VkNode)IDREF="Ch09_Graph63"Node Access FunctionsparseCommandLine() (in VkApp)IDREF="Ch03_App129"VkApp Protected Functions and Data MemberspopupMenu() (in VkGraph)IDREF="Ch09_Graph151"Subclassing VkGraphpost() (in VkDialogManager)IDREF="Ch07_Dialogs14"Methods of Posting DialogspostAndWait() (in VkDialogManager)IDREF="Ch07_Dialogs20"Methods of Posting DialogsIDREF="Ch07_Dialogs29"Methods of Posting DialogspostBlocked() (in VkDialogManager)IDREF="Ch07_Dialogs18"Methods of Posting DialogspostModal() (in VkDialogManager)IDREF="Ch07_Dialogs16"Methods of Posting DialogspreviousValue() (in VkModifiedAttachment)IDREF="Ch11_Input150"Retrieving the Current and Previous Values of the Text Widgetprogressing() (in VkApp)IDREF="Ch03_App87"Animating the Busy Cursorpulldown() (in VkSubMenu)IDREF="Ch05_Menus145"Submenu Utility and Access FunctionsquitYourself() (in VkApp)IDREF="Ch02_Components57"VkComponent Utility FunctionsIDREF="Ch03_App32"Quitting ViewKit ApplicationsIDREF="Ch04_Windows124"Window Properties and Shell ResourcesnoteIDREF="Ch03_App36"Quitting ViewKit Applicationsraise() (in VkApp)IDREF="Ch03_App51"Managing Top-Level Windowsraise() (in VkSimpleWindow)IDREF="Ch04_Windows82"Manipulating WindowsregisterPattern() (in VkMsgClient)IDREF="ChA_ToolTalk71"Creating More Detailed Message PatternsrelayButton() (in VkGraph)IDREF="Ch09_Graph138"Graph Access Functionsremove() (in VkAlignmentGroup)IDREF="Ch10_Display40"Removing Widgets and Components from an Alignment Groupremove() (in VkGangedGroup)IDREF="Ch11_Input111"Removing Scales and Scrollbars from a Ganged Groupremove() (in VkGraph)IDREF="Ch09_Graph82"Removing Nodesremove() (in VkMenuItem)IDREF="Ch05_Menus28"Displaying and Hiding Menu Itemsremove() (in VkRadioGroup)IDREF="Ch11_Input126"Removing Toggles and Buttons from a Radio GroupremoveAction() (in VkMsgClient)IDREF="ChA_ToolTalk69"Creating and Registering Simple Message PatternsremoveAllCallbacks() (in VkCallbackObject)IDREF="Ch02_Components122"Removing ViewKit CallbacksremoveCallback() (in VkCallbackObject)IDREF="Ch02_Components121"Removing ViewKit CallbacksremoveDestroyHandler() (in VkComponent)IDREF="Ch02_Components79"Handling Component Widget DestructionremoveFirst() (in VkGangedGroup)IDREF="Ch11_Input112"Removing Scales and Scrollbars from a Ganged GroupremoveFirst() (in VkRadioGroup)IDREF="Ch11_Input127"Removing Toggles and Buttons from a Radio GroupremoveItem() (in VkMenu)IDREF="Ch05_Menus118"Removing Items from a MenuremoveLast() (in VkGangedGroup)IDREF="Ch11_Input113"Removing Scales and Scrollbars from a Ganged GroupremoveLast() (in VkRadioGroup)IDREF="Ch11_Input128"Removing Toggles and Buttons from a Radio GroupremoveTab() (in VkTabPanel)IDREF="Ch11_Input39"Removing a Tab from a Tab PanelreorientButton() (in VkGraph)IDREF="Ch09_Graph139"Graph Access Functionsreplace() (in VkMenu)IDREF="Ch05_Menus121"Replacing Items in a Menureset() (in VkMenuUndoManager)IDREF="Ch06_Undo23"Clearing the Undo Stackreset() (in VkMeter)IDREF="ChB_Contrib7"Resetting the Meterresize() (in VkDoubleBuffer)IDREF="Ch10_Display14"Handling Double Buffer Component Resize Requestsrun() (in VkApp)IDREF="Ch03_App19"Running ViewKit ApplicationssaveToFile() (in VkGraph)IDREF="Ch09_Graph129"Graph Utility FunctionsselectedTab() (in VkTabPanel)IDREF="Ch11_Input51"Responding to Tab SelectionselectTab() (in VkTabPanel)IDREF="Ch11_Input50"Responding to Tab SelectionIDREF="Ch11_Input36"Adding Tabs to a Tab PanelsendFileNotice() (in VkMsgClient)IDREF="ChA_ToolTalk41"Specifying a Filename Message AttributesendFileRequest() (in VkMsgClient)IDREF="ChA_ToolTalk42"Specifying a Filename Message AttributesendIntFileNotice() (in VkMsgClient)IDREF="ChA_ToolTalk40"Specifying a Filename Message AttributesendIntNotice() (in VkMsgClient)IDREF="ChA_ToolTalk28"Sending Simple NoticessendNotice() (in VkMsgClient)IDREF="ChA_ToolTalk32"Composing and Sending MessagessendRequest() (in VkMsgClient)IDREF="ChA_ToolTalk33"Composing and Sending MessagessendStringFileNotice() (in VkMsgClient)IDREF="ChA_ToolTalk39"Specifying a Filename Message AttributesendStringNotice() (in VkMsgClient)IDREF="ChA_ToolTalk29"Sending Simple NoticessendSyncFileRequest() (in VkMsgClient)IDREF="ChA_ToolTalk43"Specifying a Filename Message AttributesendSyncRequest() (in VkMsgClient)IDREF="ChA_ToolTalk34"Sending Synchronous Requestsset() (in VkOptionMenu)IDREF="Ch05_Menus162"Selecting Items in an Option MenusetAboutDialog() (in VkApp)IDREF="Ch03_App105"Maintaining Product and Version InformationsetBaseHeight() (in VkPrefItem)IDREF="Ch08_Pref36"Preference Item Access FunctionssetBusyCursor() (in VkApp)IDREF="Ch03_App64"Setting and Retrieving a Fixed Busy CursorIDREF="Ch03_App71"Creating, Setting, and Retrieving an Animated Busy CursorsetBusyDialog() (in VkApp)IDREF="Ch03_App90"Installing Different Busy DialogssetButtonLabels() (in VkDialogManager)IDREF="Ch07_Dialogs40"Setting the Button LabelssetClassHint() (in VkSimpleWindow)IDREF="Ch04_Windows131"Window Properties and Shell ResourcessetDefaultResources() (in VkComponent)IDREF="Ch02_Components92"Setting Default Resource Values for a ComponentsetDirectory() (in VkFileSelectionDialog)IDREF="Ch07_Dialogs106"The File Selection DialogsetFilterPattern() (in VkFileSelectionDialog)IDREF="Ch07_Dialogs107"The File Selection DialogsetIconName() (in VkSimpleWindow)IDREF="Ch04_Windows107"Window and Icon TitlessetIncrements() (in VkResizer)IDREF="Ch10_Display76"Resizer Utility FunctionssetItem() (in VkPrefDialog)IDREF="Ch08_Pref119"Setting the Preference Items for a Preference DialogsetLabel() (in VkMenuItem)IDREF="Ch05_Menus39"Setting Menu Item LabelssetLabel() (in VkPrefOption)IDREF="Ch08_Pref65"Setting Option Menu Preference Item LabelssetLabelHeight() (in VkPrefItem)IDREF="Ch08_Pref37"Preference Item Access FunctionssetLayoutStyle() (in VkGraph)IDREF="Ch09_Graph111"Butterfly GraphssetMainWindow() (in VkApp)IDREF="Ch03_App39"Managing Top-Level WindowssetMargin() (in VkTickMarks)IDREF="Ch10_Display26"Configuring the Tick MarkssetMenuBar() (in VkWindow)IDREF="Ch04_Windows136"Menu Bar SupportsetModified() (in VkModifiedAttachment)IDREF="Ch11_Input169"Other Modified Text Attachment Utility and Access FunctionssetNormalCursor() (in VkApp)IDREF="Ch03_App59"Setting and Retrieving the Normal CursorsetParameters() (in VkModifiedAttachment)IDREF="Ch11_Input163"Adjusting the Modified Text Attachment's GeometrysetParameters() (in VkRepeatButton)IDREF="Ch11_Input95"Repeating Button Utility and Access FunctionssetPosition() (in VkMenuItem)IDREF="Ch05_Menus42"Setting the Position of Menu ItemssetResizePolicy() (in VkMeter)IDREF="ChB_Contrib13"Setting the Meter's Resize PolicysetScale() (in VkTickMarks)IDREF="Ch10_Display23"Configuring the Tick MarkssetSelection() (in VkFileSelectionDialog)IDREF="Ch07_Dialogs108"The File Selection DialogsetSize() (in VkGraph)IDREF="Ch09_Graph130"Graph Utility FunctionssetSize() (in VkPrefOption)IDREF="Ch08_Pref68"Dynamically Changing the Number of Option Menu ItemssetSortFunction() (in VkNode)IDREF="Ch09_Graph56"Node Utility FunctionssetStateAndNotify() (in VkMenuToggle)IDREF="Ch05_Menus65"Menu TogglessetTabPixmap() (in VkTabPanel)IDREF="Ch11_Input41"Adding a Pixmap to a TabsetTitle() (in VkDialogManager)IDREF="Ch07_Dialogs38"Setting the Title of the DialogsetTitle() (in VkSimpleWindow)IDREF="Ch04_Windows102"Window and Icon TitlessetUpInterface() (in VkSimpleWindow)IDREF="Ch04_Windows56"Creating the Window Interface in the setUpInterface() FunctionsetUpWindowProperties() (in VkSimpleWindow)IDREF="Ch04_Windows125"Window Properties and Shell ResourcessetValue() (in VkCheckBox)IDREF="Ch11_Input13"Setting and Getting Check Box Toggle ValuessetValue() (in VkModifiedAttachment)IDREF="Ch11_Input157"Controlling the Contents of the Text WidgetsetValue() (in VkPrefItem)IDREF="Ch08_Pref28"Getting and Setting Preference Item ValuessetValue() (in VkPrefOption)IDREF="Ch08_Pref72"Getting and Setting Option Menu Preference Item ValuessetValue() (in VkPrefText)IDREF="Ch08_Pref49"Text FieldssetValue() (in VkPrefToggle)IDREF="Ch08_Pref58"Getting and Setting Toggle Preference Item ValuessetValues() (in VkCheckBox)IDREF="Ch11_Input14"Setting and Getting Check Box Toggle ValuessetVersionString() (in VkApp)IDREF="Ch03_App101"Maintaining Product and Version InformationsetVisualState() (in VkMenuToggle)IDREF="Ch05_Menus64"Menu TogglessetZoomOption() (in VkGraph)IDREF="Ch09_Graph120"Graph Utility FunctionsSGIHelpIndexMsg()IDREF="ChC_Help9"ViewKit's Programmatic Interface to a Help LibrarySGIHelpInit()IDREF="ChC_Help7"ViewKit's Programmatic Interface to a Help LibrarySGIHelpMsg()IDREF="ChC_Help8"ViewKit's Programmatic Interface to a Help LibraryshellGeometry() (in VkApp)IDREF="Ch03_App116"Application Data Access Functionsshow() (in VkApp)IDREF="Ch03_App43"Managing Top-Level Windowsshow() (in VkComponent)IDREF="Ch02_Components51"Displaying and Hiding Componentsshow() (in VkMenuItem)IDREF="Ch05_Menus22"Displaying and Hiding Menu Itemsshow() (in VkModifiedAttachment)IDREF="Ch11_Input144"Displaying and Hiding the Modified Text Attachmentshow() (in VkPopupMenu)IDREF="Ch05_Menus179"Popping Up Popup Menusshow() (in VkResizer)IDREF="Ch10_Display71"Displaying the Resizer Object's Geometry Controlsshow() (in VkSimpleWindow)IDREF="Ch04_Windows58"Creating the Window Interface in the setUpInterface() FunctionIDREF="Ch04_Windows70"Manipulating WindowsshowCursor() (in VkApp)IDREF="Ch03_App74"Setting and Retrieving a Temporary Cursorshown() (in VkResizer)IDREF="Ch10_Display74"Displaying the Resizer Object's Geometry ControlsshowOverview() (in VkGraph)IDREF="Ch09_Graph114"Displaying a Graph OverviewshowTearOff() (in VkSubMenu)IDREF="Ch05_Menus143"Submenu Utility and Access Functionssize() (in VkPrefGroup)IDREF="Ch08_Pref106"Adding and Deleting Preference Items from a Group Itemsize() (in VkPrefOption)IDREF="Ch08_Pref69"Dynamically Changing the Number of Option Menu Itemssize() (in VkTabPanel)IDREF="Ch11_Input54"Tab Panel Access FunctionssortAll() (in VkGraph)IDREF="Ch09_Graph122"Graph Utility FunctionssortChildren() (in VkNode)IDREF="Ch09_Graph55"Node Utility FunctionsstartupIconified() (in VkApp)IDREF="Ch03_App55"Managing Top-Level WindowsIDREF="Ch03_App122"Application Data Access FunctionsstateChanged() (in VkSimpleWindow)IDREF="Ch04_Windows150"Determining Window StatestabBg() (in VkTabPanel)IDREF="Ch11_Input58"Tab Panel Access FunctionstabHeight() (in VkTabPanel)IDREF="Ch11_Input55"Tab Panel Access FunctionstabPixmap() (in VkTabPanel)IDREF="Ch11_Input43"Adding a Pixmap to a TabtearDownGraph() (in VkGraph)IDREF="Ch09_Graph141"Reusing a Graph Objectterminate() (in VkApp)IDREF="Ch07_Dialogs67"Fatal Error DialogsIDREF="Ch04_Windows29"Window Class DestructorsIDREF="Ch03_App35"Quitting ViewKit ApplicationsnoteIDREF="Ch03_App36"Quitting ViewKit Applicationstext() (in VkPromptDialog)IDREF="Ch07_Dialogs99"The Prompt DialogtoggleDisplay() (in VkModifiedAttachment)IDREF="Ch11_Input158"Controlling the Contents of the Text WidgettwinsButton() (in VkGraph)IDREF="Ch09_Graph137"Graph Access FunctionstwinsVisibleHook() (in VkGraph)IDREF="Ch09_Graph153"Subclassing VkGraphtype() (in VkPrefItem)IDREF="Ch08_Pref41"Preference Item Access Functionstype() (in VkRepeatButton)IDREF="Ch11_Input96"Repeating Button Utility and Access Functionsundisplay() (in VkGraph)IDREF="Ch09_Graph89"Indicating Which Nodes to Displayundo() (in VkMenuAction)IDREF="Ch05_Menus52"Menu Actionsundoit() (in VkAction)IDREF="Ch06_Undo42"Overriding Virtual Functionsundoit() (in VkMenuActionObject)IDREF="Ch06_Undo41"Overriding Virtual FunctionsuniformTabs() (in VkTabPanel)IDREF="Ch11_Input56"Tab Panel Access Functionsunpost() (in VkDialogManager)IDREF="Ch07_Dialogs35"Unposting DialogsunpostAll() (in VkDialogManager)IDREF="Ch07_Dialogs36"Unposting Dialogsunregister() (in VkMsgClient)IDREF="ChA_ToolTalk73"Creating More Detailed Message Patternsupdate() (in VkDoubleBuffer)IDREF="Ch10_Display12"Switching Buffers in the Double Buffer Componentupdate() (in VkMeter)IDREF="ChB_Contrib11"Updating the Meter DisplayupdatePatterns() (in VkMsgClient)IDREF="ChA_ToolTalk68"Creating and Registering Simple Message PatternsIDREF="ChA_ToolTalk72"Creating More Detailed Message Patternsvalue() (in VkModifiedAttachment)IDREF="Ch11_Input149"Retrieving the Current and Previous Values of the Text WidgetvalueChanged() (in VkCheckBox)IDREF="Ch11_Input21"Using SubClassing to Handle Changes in Check Box Toggle ValuesvalueChanged() (in VkRadioGroup)IDREF="Ch11_Input130"Deriving Radio Group SubclassesversionString() (in VkApp)IDREF="Ch03_App102"Maintaining Product and Version InformationviewWidget() (in VkSimpleWindow)IDREF="Ch04_Windows94"Window Data Access Functionsvisible() (in VkSimpleWindow)IDREF="Ch04_Windows96"Window Data Access FunctionsVkGetResource()IDREF="Ch02_Components97"Convenience Function for Retrieving Resource Values0IDREF="Ch02_Components98"Convenience Function for Retrieving Resource ValuesexampleIDREF="Ch02_Components100"Convenience Function for Retrieving Resource ValuesnoteIDREF="Ch02_Components99"Convenience Function for Retrieving Resource ValuesVkMsgDestroy()IDREF="ChA_ToolTalk38"Sending Synchronous RequestsVkMsgDestroyRequest()IDREF="ChA_ToolTalk53"Writing Message Action CallbacksVkMsgFail()IDREF="ChA_ToolTalk64"Useful Functions When Handling MessagesVkMsgFile()IDREF="ChA_ToolTalk61"Useful Functions When Handling MessagesVkMsgIsErr()IDREF="ChA_ToolTalk62"Useful Functions When Handling MessagesVkMsgParseArguments()IDREF="ChA_ToolTalk60"Useful Functions When Handling MessagesVkMsgPtrError()IDREF="ChA_ToolTalk63"Useful Functions When Handling MessagesVkMsgReject()IDREF="ChA_ToolTalk65"Useful Functions When Handling MessagesVkMsgReply()IDREF="ChA_ToolTalk52"Writing Message Action CallbacksVkMsgSetBVal()IDREF="ChA_ToolTalk59"Useful Functions When Handling MessagesVkMsgSetIVal()IDREF="ChA_ToolTalk57"Useful Functions When Handling MessagesVkMsgSetVal()IDREF="ChA_ToolTalk58"Useful Functions When Handling MessagesVkMsgStatusCode()IDREF="ChA_ToolTalk74"Detecting and Handling Errors in Handling RequestsVkMsgStatusString()IDREF="ChA_ToolTalk75"Detecting and Handling Errors in Handling RequestsVkMsgTypeIsBString()IDREF="ChA_ToolTalk56"Useful Functions When Handling MessagesVkMsgTypeIsInt()IDREF="ChA_ToolTalk54"Useful Functions When Handling MessagesVkMsgTypeIsString()IDREF="ChA_ToolTalk55"Useful Functions When Handling MessageswasInterrupted() (in VkInterruptDialog)IDREF="Ch07_Dialogs81"The Interruptible Busy Dialogwidget() (in VkModifiedAttachment)IDREF="Ch11_Input167"Other Modified Text Attachment Utility and Access FunctionswidgetDestroyedCallback() (in VkComponent)IDREF="Ch02_Components75"Handling Component Widget Destructionwidth() (in VkAlignmentGroup)IDREF="Ch10_Display51"Alignment Group Access FunctionsworkArea() (in VkGraph)IDREF="Ch09_Graph136"Graph Access Functionsx() (in VkAlignmentGroup)IDREF="Ch10_Display53"Alignment Group Access FunctionsXSelectInput()IDREF="Ch04_Windows157"Handling Raw EventsIDREF="Ch03_App24"ViewKit Event HandlingXtAppInitialize(), noteIDREF="Ch03_App20"Running ViewKit ApplicationsXtAppMainLoop(), noteIDREF="Ch03_App20"Running ViewKit ApplicationsXtDispatchEvent(), noteIDREF="Ch03_App25"ViewKit Event HandlingXtDisplay() cautionIDREF="Ch05_Menus14"Overview of ViewKit Menu SupportXtNextEvent(), noteIDREF="Ch03_App25"ViewKit Event HandlingXtScreen() cautionIDREF="Ch05_Menus14"Overview of ViewKit Menu SupportXtWindow() cautionIDREF="Ch05_Menus14"Overview of ViewKit Menu Supporty() (in VkAlignmentGroup)IDREF="Ch10_Display54"Alignment Group Access Functionsganged scrollbarsIDREF="Ch11_Input105"Supporting "Ganged" Scrollbar Operation0IDREF="Ch11_Input103"Supporting "Ganged" Scrollbar Operationadding scrollbarsIDREF="Ch11_Input108"Adding Scales and Scrollbars to a Ganged Groupremoving scrollbarsIDREF="Ch11_Input110"Removing Scales and Scrollbars from a Ganged Groupgeneric dialogIDREF="Ch07_Dialogs117"Deriving New Dialog Classes Using the Generic Dialog0IDREF="Ch07_Dialogs114"Deriving New Dialog Classes Using the Generic Dialoggettingcheck box toggle valuesIDREF="Ch11_Input15"Setting and Getting Check Box Toggle Valuespreference item valuesIDREF="Ch08_Pref26"Getting and Setting Preference Item ValuesgraphsIDREF="Ch09_Graph3"The ViewKit Graph Component0IDREF="Ch09_Graph2"The ViewKit Graph Componentarc attributesIDREF="Ch09_Graph78"Adding Nodes and Specifying Node ConnectivitybutterflyIDREF="Ch09_Graph108"Butterfly Graphscontrol panelIDREF="Ch09_Graph9"Interactive Viewing Features Provided by VkGraphedit modeIDREF="Ch09_Graph35"Edit Mode OperationsIDREF="Ch09_Graph7"The Graph WidgetexampleIDREF="Ch09_Graph8"Example of Building a Graphgraph widgetIDREF="Ch09_Graph6"The Graph Widgetmultiple arcsIDREF="Ch09_Graph21"Displaying Duplicate ArcsNode menuIDREF="Ch09_Graph30"Hiding and Displaying Nodesnodes0IDREF="Ch09_Graph45"The ViewKit Node ClassaddingIDREF="Ch09_Graph75"Adding Nodes and Specifying Node ConnectivityaligningIDREF="Ch09_Graph104"Laying Out the GraphIDREF="Ch09_Graph24"Realigning Nodesarc attributesIDREF="Ch09_Graph78"Adding Nodes and Specifying Node ConnectivitydeselectingIDREF="Ch09_Graph37"Edit Mode OperationsdisplayingIDREF="Ch09_Graph126"Graph Utility FunctionsIDREF="Ch09_Graph28"Hiding and Displaying NodesIDREF="Ch09_Graph43"Edit Mode OperationsIDREF="Ch09_Graph83"Indicating Which Nodes to Displayestablishing connectionsIDREF="Ch09_Graph51"Node Constructor and DestructorIDREF="Ch09_Graph77"Adding Nodes and Specifying Node ConnectivityhidingIDREF="Ch09_Graph29"Hiding and Displaying NodesIDREF="Ch09_Graph84"Indicating Which Nodes to DisplayIDREF="Ch09_Graph40"Edit Mode Operationslaying outIDREF="Ch09_Graph23"Realigning NodesIDREF="Ch09_Graph103"Laying Out the GraphmovingIDREF="Ch09_Graph38"Edit Mode Operationsperforming actionIDREF="Ch09_Graph123"Graph Utility FunctionsremovingIDREF="Ch09_Graph81"Removing NodesselectingIDREF="Ch09_Graph36"Edit Mode OperationssortingIDREF="Ch09_Graph121"Graph Utility FunctionsorientationIDREF="Ch09_Graph26"Toggling Between Horizontal and Vertical OrientationoverviewIDREF="Ch09_Graph5"Overview of ViewKit Graphsoverview windowIDREF="Ch09_Graph113"Displaying a Graph OverviewIDREF="Ch09_Graph14"Graph OverviewAdmin menuIDREF="Ch09_Graph17"Graph Overviewread-only modeIDREF="Ch09_Graph7"The Graph WidgetreusingIDREF="Ch09_Graph140"Reusing a Graph ObjectsavingIDREF="Ch09_Graph128"Graph Utility FunctionsSelected Nodes menuIDREF="Ch09_Graph39"Edit Mode OperationswidgetsIDREF="Ch09_Graph134"Graph Access FunctionsX resourcesIDREF="Ch09_Graph146"X Resources Associated with VkGraphzoomingIDREF="Ch09_Graph10"ZoomingIDREF="Ch09_Graph119"Graph Utility Functionsheader filesIRIS IMIDREF="Ch01_Overview17"Required Header FilesrequiredIDREF="Ch01_Overview16"Required Header FilesXIDREF="Ch01_Overview18"Required Header Fileshelp libraryIDREF="Ch01_Overview20"Required Librariesinterface functionsIDREF="ChC_Help6"ViewKit's Programmatic Interface to a Help LibraryViewKitIDREF="ChC_Help15"The ViewKit Help Librarydetermining help tokensIDREF="ChC_Help16"ViewKit Support for Building HelpHelp menuIDREF="ChC_Help13"Help Menu ProceduresIDREF="Ch03_App104"Maintaining Product and Version InformationIDREF="Ch05_Menus184"The ViewKit Help MenuIDREF="Ch05_Menus136"Menu Bar Access Functions0IDREF="Ch05_Menus182"The ViewKit Help MenuresourcesIDREF="Ch05_Menus191"X Resources Associated with the Help Panehelp systemIDREF="ChC_Help1"Using a Help System with ViewKitHelp button, dialogsIDREF="ChC_Help5"User Interfaces to the Help System in a ViewKit ApplicationIDREF="Ch07_Dialogs26"Methods of Posting DialogsIDREF="ChC_Help11"Dialog Help Procedurescontext-sensitive helpIDREF="ChC_Help12"Context-Sensitive Help ProceduresIDREF="ChC_Help2"User Interfaces to the Help System in a ViewKit ApplicationHelp menuIDREF="ChC_Help13"Help Menu ProceduresIDREF="Ch05_Menus184"The ViewKit Help MenuresourcesIDREF="Ch05_Menus191"X Resources Associated with the Help Paneinterface functionsIDREF="ChC_Help6"ViewKit's Programmatic Interface to a Help Library<F1\> key (Help)IDREF="ChC_Help2"User Interfaces to the Help System in a ViewKit ApplicationIDREF="ChC_Help12"Context-Sensitive Help Procedureshelp tokensdeterminingIDREF="ChC_Help16"ViewKit Support for Building HelphidingcomponentsIDREF="Ch02_Components49"Displaying and Hiding Componentsgraph overview windowIDREF="Ch09_Graph117"Displaying a Graph Overviewmenu itemsIDREF="Ch05_Menus24"Displaying and Hiding Menu Itemsmodified text attachment dogearIDREF="Ch11_Input145"Displaying and Hiding the Modified Text Attachmentnodes in graphsIDREF="Ch09_Graph40"Edit Mode OperationsIDREF="Ch09_Graph29"Hiding and Displaying NodesIDREF="Ch09_Graph84"Indicating Which Nodes to Displayresizer geometry controlsIDREF="Ch10_Display72"Displaying the Resizer Object's Geometry ControlswindowsIDREF="Ch04_Windows72"Manipulating WindowsIDREF="Ch03_App44"Managing Top-Level Windowsicon titlesIDREF="Ch04_Windows106"Window and Icon Titlesiconifying windowsIDREF="Ch04_Windows75"Manipulating WindowsIDREF="Ch03_App46"Managing Top-Level Windowsat startupIDREF="Ch03_App54"Managing Top-Level WindowsIDREF="Ch03_App123"Application Data Access FunctionsIDOIDREF="Ch01_Overview10"Required Packagesinclude files. See header filesIDREF="Ch01_Overview15"Required Header Filesinformation dialogIDREF="Ch07_Dialogs47"Information Dialogs0IDREF="Ch07_Dialogs44"Information Dialogsinheritance graphs:See also specific class namesIDREF="Intro13"Class Inheritance Graph ConventionsconventionsIDREF="Intro14"Class Inheritance Graph Conventionsinitializingdata members with X resourcesIDREF="Ch02_Components87"Initializing Data Members Based on Resource ValuesXt IntrinsicsIDREF="Ch03_App10"The VkApp Constructorinterfaces, window. See windows viewsIDREF="Ch04_Windows35"Creating the Window Interfaceinterprocess communication. See ViewKit message facilityIDREF="ChA_ToolTalk3"ViewKit Interprocess Message Facilityinterruptible busy dialogIDREF="Ch07_Dialogs77"The Interruptible Busy Dialog0IDREF="Ch07_Dialogs74"The Interruptible Busy Dialogchecking for interruptionsIDREF="Ch07_Dialogs79"The Interruptible Busy DialoginstallingIDREF="Ch03_App93"Installing Different Busy DialogsIDREF="Ch07_Dialogs87"The Interruptible Busy Dialoginvoking ViewKit callbacksIDREF="Ch02_Components125"Defining and Triggering ViewKit CallbacksIRIS Development Option (IDO)IDREF="Ch01_Overview9"Required PackagesIRIS IMheader filesIDREF="Ch01_Overview17"Required Header Filessuggested readingIDREF="Intro5"What You Should Know Before Reading This GuideViewKit, andIDREF="Ch01_Overview4"Mixing ViewKit and Standard X and IRIS IM Functionslabel widget, preference itemsIDREF="Ch08_Pref22"Preference Item LabelsIDREF="Ch08_Pref35"Preference Item Access Functionslaying out nodes in graphIDREF="Ch09_Graph23"Realigning NodesIDREF="Ch09_Graph103"Laying Out the GraphlibrarieshelpIDREF="Ch01_Overview20"Required LibrariesrequiredIDREF="Ch01_Overview19"Required LibrariesViewKitIDREF="Ch01_Overview19"Required LibrariesIDREF="Ch01_Overview13"Required Packageslicensing, networkIDREF="Ch13_NetLS4"The ViewKit NetLS Interface0IDREF="Ch13_NetLS1"The ViewKit NetLS Interfacelowering windowsIDREF="Ch03_App52"Managing Top-Level WindowsIDREF="Ch04_Windows84"Manipulating Windowsmain windowIDREF="Ch04_Windows16"Window Class ConstructorsdeterminingIDREF="Ch03_App40"Managing Top-Level Windowsduring quittingIDREF="Ch03_App34"Quitting ViewKit ApplicationsspecifyingIDREF="Ch03_App38"Managing Top-Level Windowsman pages. See reference pagesIDREF="Intro10"Typographical Conventionsmanagement classesIDREF="Ch10_Display28"Management Classes for Controlling Component and Widget Display CharacteristicsIDREF="Ch11_Input99"Management Classes for Controlling Component and Widget Operationalignment groupsIDREF="Ch10_Display29"ViewKit Support for Aligning Widgetsganged scrollbarsIDREF="Ch11_Input100"Supporting "Ganged" Scrollbar Operationmodified textIDREF="Ch11_Input131"Modified Text Attachmentradio-style togglesIDREF="Ch11_Input114"Enforcing Radio-Style Behavior on Toggle ButtonsresizersIDREF="Ch10_Display55"ViewKit Support for Resizing and Moving Widgetsmember function callbacks. See ViewKit callbacksIDREF="Ch02_Components106"ViewKit Callback Supportmenu barsIDREF="Ch05_Menus132"Menu Bar0IDREF="Ch05_Menus128"Menu BarVkWindow destructor, andIDREF="Ch04_Windows27"Window Class DestructorsVkWindow supportIDREF="Ch04_Windows135"Menu Bar Supportmenu itemsIDREF="Ch05_Menus17"The ViewKit Menu Item Classes"Undo" selectionIDREF="Ch06_Undo4"Overview of ViewKit Undo ManagementaddingIDREF="Ch06_Undo11"Adding the Undo Manager to a Menusetting labelIDREF="Ch06_Undo28"Setting the Label of the Undo Manager Menu Item0IDREF="Ch05_Menus16"The ViewKit Menu Item ClassesactionsIDREF="Ch05_Menus48"Menu Actions0IDREF="Ch05_Menus47"Menu ActionsactivatingIDREF="Ch05_Menus30"Activating and Deactivating Menu ItemsIDREF="Ch05_Menus111"Activating and Deactivating Items in a Menuadding to menusIDREF="Ch05_Menus89"Functions for Dynamically Creating Menuscommand classesIDREF="Ch06_Undo45"Using Command Classes as Menu Itemsconfirmable actionsIDREF="Ch05_Menus55"Confirmable Menu Actions0IDREF="Ch05_Menus54"Confirmable Menu ActionsdeactivatingIDREF="Ch05_Menus114"Activating and Deactivating Items in a MenuIDREF="Ch05_Menus33"Activating and Deactivating Menu Itemsdetermining position in menuIDREF="Ch05_Menus124"Menu Access FunctionsdisplayingIDREF="Ch05_Menus21"Displaying and Hiding Menu ItemsfindingIDREF="Ch05_Menus108"Finding Items in a MenuhidingIDREF="Ch05_Menus24"Displaying and Hiding Menu ItemslabelsIDREF="Ch05_Menus68"Menu LabelsIDREF="Ch05_Menus36"Setting Menu Item Labels0IDREF="Ch05_Menus67"Menu LabelsoverviewIDREF="Ch05_Menus8"Overview of ViewKit Menu SupportpositionIDREF="Ch05_Menus41"Setting the Position of Menu ItemsremovingIDREF="Ch05_Menus117"Removing Items from a MenuIDREF="Ch05_Menus27"Displaying and Hiding Menu ItemsreplacingIDREF="Ch05_Menus120"Replacing Items in a MenuseparatorsIDREF="Ch05_Menus72"Menu Separators0IDREF="Ch05_Menus71"Menu SeparatorstogglesIDREF="Ch05_Menus61"Menu Toggles0IDREF="Ch05_Menus60"Menu TogglestypeIDREF="Ch05_Menus43"Menu Items Utility Functionsundo supportIDREF="Ch05_Menus82"The VkMenuDesc StructureIDREF="Ch05_Menus92"Functions for Dynamically Creating MenusIDREF="Ch06_Undo13"Providing Undo Support for Actions That Are Menu ItemsmenusIDREF="Ch05_Menus1"Creating Menus With ViewKit"Undo" selectionIDREF="Ch06_Undo4"Overview of ViewKit Undo ManagementaddingIDREF="Ch06_Undo11"Adding the Undo Manager to a Menusetting labelIDREF="Ch06_Undo28"Setting the Label of the Undo Manager Menu Item0IDREF="Ch05_Menus75"The ViewKit Menu Base Classactivating itemsIDREF="Ch05_Menus29"Activating and Deactivating Menu ItemsIDREF="Ch05_Menus110"Activating and Deactivating Items in a Menuadding itemsIDREF="Ch05_Menus89"Functions for Dynamically Creating Menusconstructing dynamicallyIDREF="Ch05_Menus88"Constructing Menus DynamicallyexampleIDREF="Ch05_Menus106"Example of a Creating a Menu Bar Dynamicallyconstructing from static descriptionIDREF="Ch05_Menus78"Constructing Menus from a Static DescriptionexampleIDREF="Ch05_Menus87"Example of a Creating a Menu Bar Using a Static DescriptionVkMenuDesc structureIDREF="Ch05_Menus80"The VkMenuDesc StructureXt callback client dataIDREF="Ch05_Menus85"Special Considerations for Xt Callback Client Data When Using Static Menu Descriptionsdeactivating itemsIDREF="Ch05_Menus32"Activating and Deactivating Menu ItemsIDREF="Ch05_Menus113"Activating and Deactivating Items in a Menudetermining item positionIDREF="Ch05_Menus123"Menu Access Functionsdisplaying itemsIDREF="Ch05_Menus20"Displaying and Hiding Menu Itemsfinding menu itemsIDREF="Ch05_Menus109"Finding Items in a MenuXtDisplay() cautionIDREF="Ch05_Menus13"Overview of ViewKit Menu SupportXtScreen() cautionIDREF="Ch05_Menus13"Overview of ViewKit Menu SupportXtWindow() cautionIDREF="Ch05_Menus13"Overview of ViewKit Menu SupportHelp menuIDREF="Ch05_Menus184"The ViewKit Help MenuIDREF="Ch05_Menus136"Menu Bar Access FunctionsIDREF="Ch03_App104"Maintaining Product and Version InformationIDREF="ChC_Help13"Help Menu Procedures0IDREF="Ch05_Menus181"The ViewKit Help MenuresourcesIDREF="Ch05_Menus191"X Resources Associated with the Help Panehiding itemsIDREF="Ch05_Menus23"Displaying and Hiding Menu Itemsmenu barsIDREF="Ch05_Menus132"Menu Bar0IDREF="Ch05_Menus129"Menu BarVkWindow destructor, andIDREF="Ch04_Windows27"Window Class DestructorsVkWindow supportIDREF="Ch04_Windows135"Menu Bar Supportoption menusIDREF="Ch05_Menus155"Option Menus0IDREF="Ch05_Menus154"Option MenusexampleIDREF="Ch05_Menus168"Option Menu Exampleitem width, settingIDREF="Ch05_Menus166"Option Menu Utility Functionsmenu label, settingIDREF="Ch05_Menus158"Setting the Option Menu Labelselected item, settingIDREF="Ch05_Menus163"Determining Selected Items in an Option MenuIDREF="Ch05_Menus161"Selecting Items in an Option MenuoverviewIDREF="Ch05_Menus6"Overview of ViewKit Menu Supportpopup menusIDREF="Ch05_Menus172"Popup Menus0IDREF="Ch05_Menus171"Popup Menusattaching to widgetIDREF="Ch05_Menus174"Popup Menu ConstructorsexampleIDREF="Ch05_Menus180"Popup Menu Examplepopping upIDREF="Ch05_Menus177"Popping Up Popup Menusradio submenusIDREF="Ch05_Menus150"The baseWidget() function of a VkSubMenu object returns the CascadeButton widget required by IRIS IM pulldown menus.Radio Submenus0IDREF="Ch05_Menus149"The baseWidget() function of a VkSubMenu object returns the CascadeButton widget required by IRIS IM pulldown menus.Radio Submenusremoving itemsIDREF="Ch05_Menus116"Removing Items from a MenuIDREF="Ch05_Menus26"Displaying and Hiding Menu Itemsreplacing itemsIDREF="Ch05_Menus119"Replacing Items in a Menusetting item labelsIDREF="Ch05_Menus35"Setting Menu Item Labelssetting item positionsIDREF="Ch05_Menus40"Setting the Position of Menu ItemssubmenusIDREF="Ch05_Menus140"Submenus0IDREF="Ch05_Menus139"Submenustear-off behaviorIDREF="Ch05_Menus142"Submenu Utility and Access FunctionsVkMenuDesc structureIDREF="Ch05_Menus79"The VkMenuDesc StructureVkMenuItemType typeIDREF="Ch05_Menus83"The VkMenuDesc Structuremessage actionsIDREF="ChA_ToolTalk46"Writing Message Action Callbacksmessage patternsIDREF="ChA_ToolTalk66"Creating and Registering Simple Message PatternsIDREF="ChA_ToolTalk45"Overview of Message Dispatchmessage, dialogsIDREF="Ch07_Dialogs22"Methods of Posting DialogsmessagesreceivingIDREF="ChA_ToolTalk44"Receiving Notices and Handling RequestssendingIDREF="ChA_ToolTalk27"Sending Notices and Requestsmeter componentIDREF="ChB_Contrib3"The ViewKit Meter Component0IDREF="ChB_Contrib2"The ViewKit Meter Componentadding itemsIDREF="ChB_Contrib8"Adding Items to a Meterdesired dimensionsIDREF="ChB_Contrib14"Determining the Desired Dimensions of the MeterresettingIDREF="ChB_Contrib6"Resetting the Meterresize policyIDREF="ChB_Contrib12"Setting the Meter's Resize Policyupdating displayIDREF="ChB_Contrib10"Updating the Meter DisplayX resourceIDREF="ChB_Contrib17"X Resources Associated with the Meter Componentmodified text attachmentIDREF="Ch11_Input135"Modified Text Attachment0IDREF="Ch11_Input133"Modified Text Attachmentadjusting geometryIDREF="Ch11_Input161"Adjusting the Modified Text Attachment's Geometryattaching widgetsIDREF="Ch11_Input139"Attaching and Detaching the Modified Text Attachment to and from a Widgetcontrolling contentsIDREF="Ch11_Input156"Controlling the Contents of the Text WidgetIDREF="Ch11_Input165"Other Modified Text Attachment Utility and Access Functionsdetaching widgetsIDREF="Ch11_Input141"Attaching and Detaching the Modified Text Attachment to and from a Widgetdetecting changesIDREF="Ch11_Input151"Detecting Changes in the Text Widgetdisplaying dogearIDREF="Ch11_Input143"Displaying and Hiding the Modified Text Attachmenthiding dogearIDREF="Ch11_Input145"Displaying and Hiding the Modified Text AttachmentoverviewIDREF="Ch11_Input136"Modified Text Attachmentretrieving valuesIDREF="Ch11_Input148"Retrieving the Current and Previous Values of the Text WidgetMotif:See also IRIS IMIDREF="Intro1"Introductionsuggested readingIDREF="Intro4"What You Should Know Before Reading This Guidemovingnodes in graphsIDREF="Ch09_Graph38"Edit Mode OperationswidgetsIDREF="Ch10_Display62"ViewKit Support for Resizing and Moving Widgets0IDREF="Ch10_Display57"ViewKit Support for Resizing and Moving Widgetsmulti-level undo supportIDREF="Ch06_Undo5"Overview of ViewKit Undo ManagementdisablingIDREF="Ch06_Undo20"Enabling and Disabling Multi-level Undo Supportundo stackclearingIDREF="Ch06_Undo22"Clearing the Undo StackexaminingIDREF="Ch06_Undo25"Examining the Undo Stackmultiple pointers to a componentIDREF="Ch02_Components130"Predefined ViewKit CallbacksNetLS network licensingIDREF="Ch13_NetLS4"The ViewKit NetLS Interface0IDREF="Ch13_NetLS2"The ViewKit NetLS Interfacenetwork licensingIDREF="Ch13_NetLS4"The ViewKit NetLS Interface0IDREF="Ch13_NetLS3"The ViewKit NetLS InterfaceNode menu (in VkGraph)IDREF="Ch09_Graph30"Hiding and Displaying Nodesnodes (in graphs)IDREF="Ch09_Graph48"The ViewKit Node Class0IDREF="Ch09_Graph47"The ViewKit Node Classadding to graphIDREF="Ch09_Graph75"Adding Nodes and Specifying Node ConnectivityaligningIDREF="Ch09_Graph104"Laying Out the GraphIDREF="Ch09_Graph24"Realigning Nodesarc attributesIDREF="Ch09_Graph78"Adding Nodes and Specifying Node Connectivitybutterfly nodeIDREF="Ch09_Graph109"Butterfly Graphschild nodesIDREF="Ch09_Graph60"Node Access FunctionsdeselectingIDREF="Ch09_Graph37"Edit Mode OperationsdisplayingIDREF="Ch09_Graph126"Graph Utility FunctionsIDREF="Ch09_Graph43"Edit Mode OperationsIDREF="Ch09_Graph28"Hiding and Displaying NodesIDREF="Ch09_Graph83"Indicating Which Nodes to Displayestablishing connectionsIDREF="Ch09_Graph77"Adding Nodes and Specifying Node ConnectivityIDREF="Ch09_Graph51"Node Constructor and DestructorfindingIDREF="Ch09_Graph132"Graph Access FunctionsIDREF="Ch09_Graph65"Node Access FunctionshidingIDREF="Ch09_Graph29"Hiding and Displaying NodesIDREF="Ch09_Graph40"Edit Mode OperationsIDREF="Ch09_Graph84"Indicating Which Nodes to DisplaylabelIDREF="Ch09_Graph58"Node Access FunctionsIDREF="Ch09_Graph70"Creating Node SubclassesIDREF="Ch09_Graph50"Node Constructor and Destructorlaying outIDREF="Ch09_Graph23"Realigning NodesIDREF="Ch09_Graph103"Laying Out the GraphmovingIDREF="Ch09_Graph38"Edit Mode Operationsparent nodesIDREF="Ch09_Graph60"Node Access Functionsperforming actionIDREF="Ch09_Graph123"Graph Utility Functionsremoving from graphIDREF="Ch09_Graph81"Removing NodesselectingIDREF="Ch09_Graph36"Edit Mode OperationssortingIDREF="Ch09_Graph54"Node Utility FunctionsIDREF="Ch09_Graph121"Graph Utility FunctionssubclassingIDREF="Ch09_Graph68"Creating Node Subclassesnon-blocking, modal dialogsIDREF="Ch07_Dialogs17"Methods of Posting Dialogsnon-blocking, non-modal dialogsIDREF="Ch07_Dialogs15"Methods of Posting Dialogsopening windowsIDREF="Ch04_Windows78"Manipulating WindowsIDREF="Ch03_App48"Managing Top-Level Windowsoption menusIDREF="Ch05_Menus155"Option Menus0IDREF="Ch05_Menus153"Option MenusexampleIDREF="Ch05_Menus168"Option Menu Exampleitem width, settingIDREF="Ch05_Menus166"Option Menu Utility Functionsmenu label, settingIDREF="Ch05_Menus158"Setting the Option Menu Labelselected itemdeterminingIDREF="Ch05_Menus163"Determining Selected Items in an Option MenusettingIDREF="Ch05_Menus161"Selecting Items in an Option Menuoutline componentIDREF="ChB_Contrib21"The ViewKit Outline Componentoverview window, graphsIDREF="Ch09_Graph113"Displaying a Graph OverviewIDREF="Ch09_Graph14"Graph Overviewpackages, requiredIDREF="Ch01_Overview8"Required Packagesparent widgetcomponentsIDREF="Ch02_Components25"Component ConstructorsIDREF="Ch02_Components12"The VkComponent ClassdialogsIDREF="Ch07_Dialogs28"Methods of Posting DialogswindowsIDREF="Ch04_Windows14"Window Class Constructorsparsing command-line optionsIDREF="Ch03_App15"The VkApp ConstructorIDREF="Ch03_App128"VkApp Protected Functions and Data MembersexampleIDREF="Ch03_App133"Example of Subclassing VkApppending eventsIDREF="Ch03_App27"ViewKit Event Handlingpie chart componentIDREF="ChB_Contrib20"The ViewKit Pie Chart Component0IDREF="ChB_Contrib19"The ViewKit Pie Chart Componentpopup menusIDREF="Ch05_Menus172"Popup Menus0IDREF="Ch05_Menus170"Popup Menusattaching to widgetIDREF="Ch05_Menus174"Popup Menu ConstructorsexampleIDREF="Ch05_Menus180"Popup Menu Examplepopping upIDREF="Ch05_Menus177"Popping Up Popup Menusposting dialogsIDREF="Ch07_Dialogs12"Posting DialogsexamplesIDREF="Ch07_Dialogs33"Examples of Posting DialogsmethodsIDREF="Ch07_Dialogs13"Methods of Posting Dialogspreference dialogsIDREF="Ch08_Pref3"Preference Dialogs0IDREF="Ch08_Pref1"Preference Dialogsadding itemsIDREF="Ch08_Pref117"Creating a Preference DialogIDREF="Ch08_Pref118"Setting the Preference Items for a Preference DialogcreatingIDREF="Ch08_Pref115"Creating a Preference DialogexampleIDREF="Ch08_Pref16"Example of Building a ViewKit Preference DialogoverviewIDREF="Ch08_Pref8"Overview of ViewKit Preference DialogspostingIDREF="Ch08_Pref123"Posting and Dismissing Preference Dialogs0IDREF="Ch08_Pref121"Posting and Dismissing Preference Dialogsretrieving valuesIDREF="Ch08_Pref130"Using Values Set in a Preference DialogsubclassingIDREF="Ch08_Pref131"Creating Preference Dialog SubclassesunpostingIDREF="Ch08_Pref126"Posting and Dismissing Preference Dialogs0IDREF="Ch08_Pref124"Posting and Dismissing Preference Dialogsuser interaction, respondingIDREF="Ch08_Pref127"Responding When the User Clicks on a Preference Dialog Buttonpreference itemsIDREF="Ch08_Pref17"The ViewKit Preference Item Base Class0IDREF="Ch08_Pref12"The ViewKit Preference Item ClassesactivatingIDREF="Ch08_Pref30"Preference Item Access Functionsbase widgetIDREF="Ch08_Pref34"Preference Item Access FunctionsIDREF="Ch08_Pref21"Preference Item LabelsdeactivatingIDREF="Ch08_Pref31"Preference Item Access Functionsempty spaceIDREF="Ch08_Pref85""Empty" Space Preference Items0IDREF="Ch08_Pref83""Empty" Space Preference ItemsgroupsIDREF="Ch08_Pref91"Groups of Preference Items0IDREF="Ch08_Pref87"Groups of Preference Itemsadding itemsIDREF="Ch08_Pref100"Adding and Deleting Preference Items from a Group Itemchanges in item valuesIDREF="Ch08_Pref110"Monitoring the Values of Preference Items Associated with a Group Itemcomparison of group classesIDREF="Ch08_Pref92"Comparison of Group Preference ItemscreatingIDREF="Ch08_Pref96"Creating Group Preference Itemsdeleting itemsIDREF="Ch08_Pref107"Adding and Deleting Preference Items from a Group ItemlabelsIDREF="Ch08_Pref113"Setting Group Item Labelslabels, settingIDREF="Ch08_Pref114"Setting Group Item Labelslabel itemsIDREF="Ch08_Pref75"Labels0IDREF="Ch08_Pref73"Labelssetting labelsIDREF="Ch08_Pref78"Labelslabel widgetIDREF="Ch08_Pref22"Preference Item LabelsIDREF="Ch08_Pref35"Preference Item Access FunctionslabelsIDREF="Ch08_Pref20"Preference Item LabelsgroupsIDREF="Ch08_Pref113"Setting Group Item Labelslabel itemsIDREF="Ch08_Pref77"Labelsoption menusIDREF="Ch08_Pref63"Setting Option Menu Preference Item LabelstogglesIDREF="Ch08_Pref54"Setting Toggle Preference Item Labelsoption menusIDREF="Ch08_Pref61"Option Menus0IDREF="Ch08_Pref59"Option Menuslabels, settingIDREF="Ch08_Pref64"Setting Option Menu Preference Item Labelsnumber of options, settingIDREF="Ch08_Pref67"Dynamically Changing the Number of Option Menu ItemsoverviewIDREF="Ch08_Pref15"The ViewKit Preference Item ClassesIDREF="Ch08_Pref9"Overview of ViewKit Preference DialogsseparatorsIDREF="Ch08_Pref81"Separators0IDREF="Ch08_Pref79"Separatorstext fieldsIDREF="Ch08_Pref46"Text Fields0IDREF="Ch08_Pref44"Text FieldstogglesIDREF="Ch08_Pref52"Toggle Buttons0IDREF="Ch08_Pref50"Toggle Buttonssetting labelsIDREF="Ch08_Pref55"Setting Toggle Preference Item LabelsvaluesIDREF="Ch08_Pref25"Getting and Setting Preference Item Valuesproduct informationIDREF="Ch03_App100"Maintaining Product and Version InformationProduct Information dialogIDREF="Ch05_Menus190"Implementation of the Help MenuIDREF="Ch03_App103"Maintaining Product and Version Informationprogramscompiling and linkingIDREF="Ch01_Overview7"Compiling and Linking ViewKit ProgramsexampleIDREF="Ch01_Overview21"Required LibrariesdemonstrationIDREF="Ch01_Overview23"Demonstration Programsprompt dialogIDREF="Ch07_Dialogs97"The Prompt Dialog0IDREF="Ch07_Dialogs94"The Prompt DialogcautionIDREF="Ch07_Dialogs100"The Prompt Dialogquestion dialogIDREF="Ch07_Dialogs92"The Question Dialog0IDREF="Ch07_Dialogs89"The Question DialogVkMenuConfirmFirstAction useIDREF="Ch05_Menus58"Confirmable Menu Actionsquitting applicationsIDREF="Ch04_Windows120"Window Properties and Shell ResourcesIDREF="Ch04_Windows28"Window Class DestructorsIDREF="Ch07_Dialogs66"Fatal Error DialogsIDREF="Ch04_Windows141"Providing a "Safe Quit" MechanismIDREF="Ch02_Components55"VkComponent Utility FunctionsIDREF="Ch03_App31"Quitting ViewKit Applicationsradio check box componentIDREF="Ch11_Input27"The Radio Check Box Component0IDREF="Ch11_Input26"The Radio Check Box ComponentexampleIDREF="Ch11_Input28"The Radio Check Box Componentradio submenusIDREF="Ch05_Menus150"The baseWidget() function of a VkSubMenu object returns the CascadeButton widget required by IRIS IM pulldown menus.Radio Submenus0IDREF="Ch05_Menus148"The baseWidget() function of a VkSubMenu object returns the CascadeButton widget required by IRIS IM pulldown menus.Radio Submenusadding to menusIDREF="Ch05_Menus103"Functions for Dynamically Creating Menusradio-style togglesIDREF="Ch11_Input120"Enforcing Radio-Style Behavior on Toggle Buttons0IDREF="Ch11_Input118"Enforcing Radio-Style Behavior on Toggle Buttonsadding buttonsIDREF="Ch11_Input123"Adding Toggles and Buttons to a Radio Groupremoving buttonsIDREF="Ch11_Input125"Removing Toggles and Buttons from a Radio Groupraising windowsIDREF="Ch04_Windows81"Manipulating WindowsIDREF="Ch03_App50"Managing Top-Level Windowsraw eventsIDREF="Ch04_Windows154"Handling Raw EventsIDREF="Ch03_App22"ViewKit Event Handlingreceiving messagesIDREF="ChA_ToolTalk44"Receiving Notices and Handling Requestsreference pagesconventionsIDREF="Intro11"Typographical Conventionsregistering functions, ViewKit callbacksIDREF="Ch02_Components110"Registering ViewKit CallbackscautionIDREF="Ch02_Components112"Registering ViewKit CallbacksexampleIDREF="Ch02_Components113"Registering ViewKit Callbacksfunction formatIDREF="Ch02_Components116"Registering ViewKit CallbacksIDREF="Ch02_Components115"Registering ViewKit Callbacksremovingbuttons from radio groupIDREF="Ch11_Input125"Removing Toggles and Buttons from a Radio Groupfunctions, ViewKit callbacksIDREF="Ch02_Components118"Removing ViewKit Callbacksmenu itemsIDREF="Ch05_Menus27"Displaying and Hiding Menu ItemsIDREF="Ch05_Menus117"Removing Items from a Menunodes from graphsIDREF="Ch09_Graph81"Removing Nodespixmaps from tabsIDREF="Ch11_Input42"Adding a Pixmap to a Tabscrollbars from a ganged groupIDREF="Ch11_Input110"Removing Scales and Scrollbars from a Ganged Grouptabs to tab panelIDREF="Ch11_Input38"Removing a Tab from a Tab Panelwidgets from alignment groupIDREF="Ch10_Display39"Removing Widgets and Components from an Alignment Grouprepeat buttonsactivation, respondingIDREF="Ch11_Input92"Responding to Repeat Button Activationrepeating buttonsIDREF="Ch11_Input89"The Repeating Button Component0IDREF="Ch11_Input87"The Repeating Button ComponentX resourcesIDREF="Ch11_Input98"X Resources Associated with the Repeating Button Componentreplacingcompletion field expansion listIDREF="Ch11_Input75"Setting and Clearing the Text Completion Field Expansion Listmenu itemsIDREF="Ch05_Menus120"Replacing Items in a Menurequirementsheader filesIDREF="Ch01_Overview16"Required Header FileslibrariesIDREF="Ch01_Overview19"Required LibrariespackagesIDREF="Ch01_Overview8"Required PackagesresizersIDREF="Ch10_Display62"ViewKit Support for Resizing and Moving Widgets0IDREF="Ch10_Display61"ViewKit Support for Resizing and Moving Widgetsattaching widgetsIDREF="Ch10_Display66"Attaching and Detaching a Resizer Object to and from a Widgetdetaching widgetsIDREF="Ch10_Display68"Attaching and Detaching a Resizer Object to and from a Widgetdisplaying geometry controlsIDREF="Ch10_Display70"Displaying the Resizer Object's Geometry Controlsgeometry changesdetectingIDREF="Ch10_Display77"ViewKit Callbacks Associated with the ResizerrestrictingIDREF="Ch10_Display75"Resizer Utility Functionshiding geometry controlsIDREF="Ch10_Display72"Displaying the Resizer Object's Geometry ControlsoverviewIDREF="Ch10_Display63"ViewKit Support for Resizing and Moving Widgetsresizingdouble-buffer componentIDREF="Ch10_Display13"Handling Double Buffer Component Resize RequestswidgetsIDREF="Ch10_Display62"ViewKit Support for Resizing and Moving Widgets0IDREF="Ch10_Display59"ViewKit Support for Resizing and Moving Widgetsresource supportcomponentsIDREF="Ch02_Components80"Component Resource Supportdata members, initializingIDREF="Ch02_Components88"Initializing Data Members Based on Resource Valuesdefault values, settingIDREF="Ch02_Components91"Setting Default Resource Values for a Componentglobal values, settingIDREF="Ch02_Components93"Setting Default Resource Values for a ComponentrequirementsIDREF="Ch02_Components82"Component Resource Supportresource values, settingIDREF="Ch02_Components86"Setting Resource Values by Class or Individual Componentwidget resources, noteIDREF="Ch02_Components1"Componentsretrieving valuesIDREF="Ch02_Components96"Convenience Function for Retrieving Resource ValuesexampleIDREF="Ch02_Components101"Convenience Function for Retrieving Resource ValuesnoteIDREF="Ch02_Components99"Convenience Function for Retrieving Resource ValuessavinggraphsIDREF="Ch09_Graph128"Graph Utility Functionsschemesmenu bars, andIDREF="Ch05_Menus134"Menu Bar Constructorsoptions menus, andIDREF="Ch05_Menus157"Unlike many other ViewKit components, VkOptionMenu objects are automatically visible when you create them; you do not need to call show() initially to display a VkOptionMenu object.Option Menu Constructorsscrollbars, "ganging." See ganged scrollbars; VkGangedGroup classIDREF="Ch11_Input102"Supporting "Ganged" Scrollbar OperationScrolledWindow widget and windowsIDREF="Ch04_Windows51"Creating the Window Interface in the Constructorsecondary event loopsduring handlePendingEvents()IDREF="Ch03_App29"ViewKit Event Handlingduring postAndWait()IDREF="Ch07_Dialogs32"Methods of Posting Dialogsduring sendSyncRequest()IDREF="ChA_ToolTalk37"Sending Synchronous Requestsduring wasInterrupted()IDREF="Ch07_Dialogs84"The Interruptible Busy DialogSelected Nodes menu (in VkGraph)IDREF="Ch09_Graph39"Edit Mode Operationsselectingnodes in graphsIDREF="Ch09_Graph36"Edit Mode Operationssending messagesIDREF="ChA_ToolTalk27"Sending Notices and RequestssettingIDREF="Ch06_Undo28"Setting the Label of the Undo Manager Menu ItemVkAction class label for "Undo" selectionIDREF="Ch06_Undo50"Setting the Label Used by Command Classescheck box labelsIDREF="Ch11_Input10"Setting Check Box and Toggle Labelscheck box toggle valuesIDREF="Ch11_Input12"Setting and Getting Check Box Toggle Valuescommand class labelsIDREF="Ch06_Undo49"Setting the Label Used by Command Classescompletion field expansion listIDREF="Ch11_Input71"Setting and Clearing the Text Completion Field Expansion Listdefault resource valuesIDREF="Ch02_Components90"Setting Default Resource Values for a ComponentexampleIDREF="Ch02_Components95"Setting Default Resource Values for a ComponentnoteIDREF="Ch02_Components94"Setting Default Resource Values for a Componentdialog button labelsIDREF="Ch07_Dialogs39"Setting the Button Labelsdialog titlesIDREF="Ch07_Dialogs37"Setting the Title of the Dialogglobal resource valuesIDREF="Ch02_Components93"Setting Default Resource Values for a Componentpreference itemslabelsIDREF="Ch08_Pref19"Preference Item Labelslabels, groupIDREF="Ch08_Pref113"Setting Group Item Labelslabels, label itemsIDREF="Ch08_Pref77"Labelslabels, option menusIDREF="Ch08_Pref63"Setting Option Menu Preference Item Labelslabels, togglesIDREF="Ch08_Pref54"Setting Toggle Preference Item LabelsvaluesIDREF="Ch08_Pref24"Getting and Setting Preference Item Valuestick marks scaleIDREF="Ch10_Display22"Configuring the Tick MarksSgGraph widgetIDREF="Ch09_Graph6"The Graph Widgetshell geometrymain windowIDREF="Ch04_Windows19"Window Class ConstructorsIDREF="Ch04_Windows112"Window Properties and Shell Resourcesshell resourcesIDREF="Ch04_Windows111"Window Properties and Shell ResourcesIDREF="Ch04_Windows18"Window Class Constructorsshell, applicationIDREF="Ch03_App125"Application Data Access FunctionsIDREF="Ch04_Windows7"ViewKit's Multi-Window ModelIDREF="Ch03_App9"The VkApp ConstructorgeometryIDREF="Ch03_App117"Application Data Access Functionsstatic member functionsXt callbacksIDREF="Ch02_Components15"The VkComponent ClassIDREF="Ch02_Components63"Using Xt Callbacks with ComponentsexampleIDREF="Ch02_Components72"Using Xt Callbacks with Componentsnaming conventionIDREF="Ch02_Components70"Using Xt Callbacks with Componentsstatic menu descriptionsIDREF="Ch05_Menus84"Special Considerations for Xt Callback Client Data When Using Static Menu Descriptionsthis pointerIDREF="Ch02_Components66"Using Xt Callbacks with Componentssubclassing. See  components subclassingIDREF="Ch02_Components131"Deriving Subclasses to Create New ComponentsSee also specific classesIDREF="Ch02_Components131"Deriving Subclasses to Create New ComponentssubmenusIDREF="Ch05_Menus140"Submenus0IDREF="Ch05_Menus138"Submenusadding to menusIDREF="Ch05_Menus101"Functions for Dynamically Creating Menusradio-styleIDREF="Ch05_Menus150"The baseWidget() function of a VkSubMenu object returns the CascadeButton widget required by IRIS IM pulldown menus.Radio Submenustear-off behaviorIDREF="Ch05_Menus142"Submenu Utility and Access Functions[] (subscript) operator (in VkMenu)IDREF="Ch05_Menus126"Menu Access Functionssubsystems, ViewKitIDREF="Ch01_Overview12"Required Packagessuggested readingIDREF="Intro2"What You Should Know Before Reading This Guidetab panel componentIDREF="Ch11_Input31"The Tab Panel Component0IDREF="Ch11_Input29"The Tab Panel ComponentoverviewIDREF="Ch11_Input32"The Tab Panel ComponenttabsaddingIDREF="Ch11_Input34"Adding Tabs to a Tab Paneladding pixmapsIDREF="Ch11_Input40"Adding a Pixmap to a TabremovingIDREF="Ch11_Input38"Removing a Tab from a Tab Panelremoving pixmapsIDREF="Ch11_Input42"Adding a Pixmap to a Tabselection, responding toIDREF="Ch11_Input44"Responding to Tab SelectionX resourcesIDREF="Ch11_Input64"X Resources Associated with the Tab Panel Componenttear-off menusIDREF="Ch05_Menus142"Submenu Utility and Access FunctionsTerre Haute, IndianaIDREF="Ch09_Graph52"Node Constructor and Destructortext fieldscompletion. See completion fields; VkCompletionField classIDREF="Ch11_Input65"The Text Completion Field Componentmodified attachment. See modified text attachment; VkModifiedAttachment classIDREF="Ch11_Input132"Modified Text Attachmenttick marks componentIDREF="Ch10_Display19"Tick Marks for Scales0IDREF="Ch10_Display18"Tick Marks for ScaleslabelsIDREF="Ch10_Display21"Tick Marks Component ConstructorIDREF="Ch10_Display24"Configuring the Tick Marksscale, settingIDREF="Ch10_Display22"Configuring the Tick MarksX resourcesIDREF="Ch10_Display27"X Resources Associated with the Tick Marks Componenttoggles, radio-style. See radio-style toggles; VkRadioGroup classIDREF="Ch11_Input117"Enforcing Radio-Style Behavior on Toggle ButtonsToolTalk. See ViewKit message facilityIDREF="ChA_ToolTalk4"ViewKit Interprocess Message Facilitytriggering ViewKit callbacksIDREF="Ch02_Components125"Defining and Triggering ViewKit Callbackstypographical conventionsIDREF="Intro8"Typographical Conventionsundo stackclearingIDREF="Ch06_Undo22"Clearing the Undo StackexaminingIDREF="Ch06_Undo25"Examining the Undo Stackundo supportIDREF="Ch06_Undo2"Undo Managementadding "Undo" selection to menuIDREF="Ch06_Undo11"Adding the Undo Manager to a MenuVkAction classIDREF="Ch06_Undo18"Providing Undo Support for Command Class ObjectsVkMenuActionObject classIDREF="Ch06_Undo18"Providing Undo Support for Command Class Objectscommand class objectsIDREF="Ch06_Undo18"Providing Undo Support for Command Class ObjectsexampleIDREF="Ch06_Undo30"Example of Using ViewKit's Undo Managerundo() (in VkMenuAction)IDREF="Ch05_Menus53"Menu Actionsmenu itemsIDREF="Ch05_Menus92"Functions for Dynamically Creating MenusIDREF="Ch05_Menus82"The VkMenuDesc StructureIDREF="Ch06_Undo13"Providing Undo Support for Actions That Are Menu Itemsmulti-levelIDREF="Ch06_Undo20"Enabling and Disabling Multi-level Undo Supportnon-menu item actionsIDREF="Ch06_Undo14"Providing Undo Support for Actions That Are Not Menu ItemsoverviewIDREF="Ch06_Undo3"Overview of ViewKit Undo Managementsetting label, "Undo" selectionIDREF="Ch06_Undo28"Setting the Label of the Undo Manager Menu Itemundo stackclearingIDREF="Ch06_Undo22"Clearing the Undo StackexaminingIDREF="Ch06_Undo25"Examining the Undo Stackuser interfaceIDREF="Ch06_Undo4"Overview of ViewKit Undo Managementunposting dialogsIDREF="Ch07_Dialogs34"Unposting Dialogsunrecoverable errorsIDREF="Ch07_Dialogs66"Fatal Error Dialogsunregistering functions, ViewKit callbacksIDREF="Ch02_Components118"Removing ViewKit Callbacks<F1\> key (Help)IDREF="ChC_Help2"User Interfaces to the Help System in a ViewKit ApplicationIDREF="ChC_Help12"Context-Sensitive Help Procedures_allowMultipleDialogs (in VkGenericDialog)IDREF="Ch07_Dialogs123"Deriving New Dialog Classes Using the Generic Dialog_baseWidget (in VkComponent)IDREF="Ch02_Components47"VkComponent Access FunctionsIDREF="Ch02_Components22"Component ConstructorsIDREF="Ch02_Components26"Component Constructors_baseWidget (in VkSimpleWindow)IDREF="Ch04_Windows47"Creating the Window Interface in the Constructor_canvas (in VkDoubleBuffer)IDREF="Ch10_Display10"Drawing in the Double Buffer Component_clientData() (in VkMenuActionObject)IDREF="Ch06_Undo40"Command Class Constructors_currentMatchList (in VkCompletionField)IDREF="Ch11_Input83"Deriving Text Completion Field Subclasses_cursorList (in VkCursorList)IDREF="Ch03_App69"Creating, Setting, and Retrieving an Animated Busy Cursor_height (in VkDoubleBuffer)IDREF="Ch10_Display16"Handling Double Buffer Component Resize Requests_iconState (in VkSimpleWindow)IDREF="Ch04_Windows144"Determining Window States_label (in VkCheckBox)IDREF="Ch11_Input24"Using SubClassing to Handle Changes in Check Box Toggle Values_label (in VkNode)IDREF="Ch09_Graph71"Creating Node Subclasses_mainWindowWidget (in VkSimpleWindow)IDREF="Ch04_Windows158"Additional Data Members_minimizeMultipleDialogs (in VkGenericDialog)IDREF="Ch07_Dialogs124"Deriving New Dialog Classes Using the Generic Dialog_name (in VkComponent)IDREF="Ch02_Components27"Component ConstructorsIDREF="Ch02_Components38"VkComponent Access FunctionsIDREF="Ch02_Components20"Component Constructors_nameList (in VkCompletionField)IDREF="Ch11_Input84"Deriving Text Completion Field Subclasses_rc (in VkCheckBox)IDREF="Ch11_Input23"Using SubClassing to Handle Changes in Check Box Toggle Values_showApply (in VkGenericDialog)IDREF="Ch07_Dialogs122"Deriving New Dialog Classes Using the Generic Dialog_showCancel (in VkGenericDialog)IDREF="Ch07_Dialogs121"Deriving New Dialog Classes Using the Generic Dialog_showOK (in VkGenericDialog)IDREF="Ch07_Dialogs120"Deriving New Dialog Classes Using the Generic Dialog_stackingState (in VkSimpleWindow)IDREF="Ch04_Windows148"Determining Window States_visibleState (in VkSimpleWindow)IDREF="Ch04_Windows146"Determining Window States_widgetList (in VkCheckBox)IDREF="Ch11_Input22"Using SubClassing to Handle Changes in Check Box Toggle Values_width (in VkDoubleBuffer)IDREF="Ch10_Display15"Handling Double Buffer Component Resize Requests_winList (in VkApp)IDREF="Ch03_App131"VkApp Protected Functions and Data MembersarcCreatedCallback (in VkGraph)IDREF="Ch09_Graph142"ViewKit Callbacks Associated with VkGrapharcDestroyedCallback (in VkGraph)IDREF="Ch09_Graph144"ViewKit Callbacks Associated with VkGraphargc (in main())IDREF="Ch03_App16"The VkApp ConstructorIDREF="Ch03_App119"Application Data Access Functionsargv (in main())IDREF="Ch03_App121"Application Data Access FunctionsIDREF="Ch03_App16"The VkApp ConstructorbuttonCallback (in VkRepeatButton)IDREF="Ch11_Input93"Responding to Repeat Button ActivationdeleteCallback (in VkComponent)IDREF="Ch02_Components128"Predefined ViewKit CallbacksIDREF="Ch02_Components32"Component DestructorsenterCallback (in VkCompletionField)IDREF="Ch11_Input79"Responding to Text Completion Field ActivationinterruptedCallback (in VkInterruptDialog)IDREF="Ch07_Dialogs85"The Interruptible Busy DialogitemChanged (in VkCheckBox)IDREF="Ch11_Input18"Using ViewKit Callbacks to Handle Changes in Check Box Toggle ValuesmodifiedCallback (in VkModifiedAttachment)IDREF="Ch11_Input152"Detecting Changes in the Text WidgetprefCallback (in VkPrefDialog)IDREF="Ch08_Pref128"Responding When the User Clicks on a Preference Dialog ButtonstateChangedCallback (in VkResizer)IDREF="Ch10_Display78"ViewKit Callbacks Associated with the ResizertabPopupCallback (in VkTabPanel)IDREF="Ch11_Input48"Responding to Tab SelectiontabSelectCallback (in VkTabPanel)IDREF="Ch11_Input45"Responding to Tab SelectiontheApplication (in VkApp)IDREF="Ch03_App11"The VkApp ConstructortheBusyDialog (in VkBusyDialog)IDREF="Ch07_Dialogs71"The Busy Dialoginstalling as busy dialogIDREF="Ch03_App92"Installing Different Busy DialogstheErrorDialog (in VkErrorDialog)IDREF="Ch07_Dialogs57"Error DialogstheFatalErrorDialog (in VkFatalErrorDialog)IDREF="Ch07_Dialogs64"Fatal Error DialogstheFileSelectionDialog (in VkFileSelectionDialog)IDREF="Ch07_Dialogs104"The File Selection DialogcautionIDREF="Ch07_Dialogs111"The File Selection DialogtheInfoDialog (in VkInfoDialog)IDREF="Ch07_Dialogs47"Information DialogstheInterruptDialog (in VkInterruptDialog)IDREF="Ch07_Dialogs77"The Interruptible Busy Dialogchecking for interruptionsIDREF="Ch07_Dialogs80"The Interruptible Busy Dialoginstalling as busy dialogIDREF="Ch03_App95"Installing Different Busy DialogsIDREF="Ch07_Dialogs88"The Interruptible Busy DialogthePromptDialog (in VkPromptDialog)IDREF="Ch07_Dialogs97"The Prompt DialogcautionIDREF="Ch07_Dialogs100"The Prompt DialogtheQuestionDialog (in VkQuestionDialog)IDREF="Ch07_Dialogs92"The Question DialogtheUndoManager (in VkMenuUndoManager)IDREF="Ch06_Undo9"Instantiating ViewKit's Undo ManagertheWarningDialog (in VkWarningDialog)IDREF="Ch07_Dialogs52"Warning DialogsViewKitMajorRelease (in VkApp)IDREF="Ch03_App97"Maintaining Product and Version InformationViewKitMinorRelease (in VkApp)IDREF="Ch03_App98"Maintaining Product and Version InformationViewKitReleaseString (in VkApp)IDREF="Ch03_App99"Maintaining Product and Version Informationversion informationIDREF="Ch03_App96"Maintaining Product and Version InformationViewKitbenefitsIDREF="Ch01_Overview2"Overview of ViewKitcallbacks. See ViewKit callbacks; Xt callbacksIDREF="Ch02_Components105"ViewKit Callback Supportcompiling programsIDREF="Ch01_Overview7"Compiling and Linking ViewKit ProgramsexampleIDREF="Ch01_Overview21"Required Librariesdebug librariesIDREF="Ch01_Overview14"Required Packagesheader filesIDREF="Ch01_Overview16"Required Header FileslibrariesIDREF="Ch01_Overview19"Required Librarieslibraries, debugIDREF="Ch01_Overview14"Required Packagesmajor elementsIDREF="Ch01_Overview3"Major ViewKit ElementsoverviewIDREF="Ch01_Overview1"Overview of ViewKitsubsystemsIDREF="Ch01_Overview12"Required PackagesX and IRIS IM, andIDREF="Ch01_Overview4"Mixing ViewKit and Standard X and IRIS IM FunctionsViewKit callbacksIDREF="Ch02_Components107"ViewKit Callback Support0IDREF="Ch02_Components104"ViewKit Callback Supportcallback functionsformatIDREF="Ch02_Components115"Registering ViewKit CallbacksIDREF="Ch02_Components116"Registering ViewKit CallbacksregisteringIDREF="Ch02_Components110"Registering ViewKit CallbacksremovingIDREF="Ch02_Components119"Removing ViewKit CallbacksunregisteringIDREF="Ch02_Components120"Removing ViewKit CallbackscreatingIDREF="Ch02_Components123"Defining and Triggering ViewKit CallbacksdefiningIDREF="Ch02_Components123"Defining and Triggering ViewKit CallbacksinvokingIDREF="Ch02_Components125"Defining and Triggering ViewKit CallbacksoverviewIDREF="Ch02_Components108"ViewKit Callback SupportpredefinedarcCreatedCallback (in VkGraph)IDREF="Ch09_Graph143"ViewKit Callbacks Associated with VkGrapharcDestroyedCallback (in VkGraph)IDREF="Ch09_Graph145"ViewKit Callbacks Associated with VkGraphbuttonCallback (in VkRepeatButton)IDREF="Ch11_Input94"Responding to Repeat Button ActivationdeleteCallback (in VkComponent)IDREF="Ch02_Components129"Predefined ViewKit CallbacksIDREF="Ch02_Components33"Component DestructorsenterCallback (in VkCompletionField)IDREF="Ch11_Input80"Responding to Text Completion Field ActivationinterruptedCallback (in VkInterruptDialog)IDREF="Ch07_Dialogs86"The Interruptible Busy DialogitemChanged (in VkCheckBox)IDREF="Ch11_Input19"Using ViewKit Callbacks to Handle Changes in Check Box Toggle ValuesmodifiedCallback (in VkModifiedAttachment)IDREF="Ch11_Input153"Detecting Changes in the Text WidgetprefCallback (in VkPrefDialog)IDREF="Ch08_Pref129"Responding When the User Clicks on a Preference Dialog ButtonstateChangedCallback (in VkResizer)IDREF="Ch10_Display79"ViewKit Callbacks Associated with the ResizertabPopupCallback (in VkTabPanel)IDREF="Ch11_Input49"Responding to Tab SelectiontabSelectCallback (in VkTabPanel)IDREF="Ch11_Input46"Responding to Tab SelectiontriggeringIDREF="Ch02_Components125"Defining and Triggering ViewKit CallbacksViewKit help libraryIDREF="Ch01_Overview20"Required LibrariesIDREF="ChC_Help15"The ViewKit Help Librarydetermining help tokensIDREF="ChC_Help16"ViewKit Support for Building HelpViewKit librariesIDREF="Ch01_Overview13"Required PackagesViewKit message facilityIDREF="ChA_ToolTalk5"ViewKit Interprocess Message Facilityestablishing ToolTalk connectionIDREF="ChA_ToolTalk22"Establishing a Connection to the ToolTalk Servicemessage actionsIDREF="ChA_ToolTalk46"Writing Message Action Callbacksmessage patternsIDREF="ChA_ToolTalk45"Overview of Message DispatchIDREF="ChA_ToolTalk66"Creating and Registering Simple Message PatternsoverviewIDREF="ChA_ToolTalk9"Overview of ViewKit's ToolTalk SupportpoliciesIDREF="ChA_ToolTalk20"ViewKit Message Facility Policiesreceiving messagesIDREF="ChA_ToolTalk44"Receiving Notices and Handling Requestsregistering services for autostartIDREF="ChA_ToolTalk80"Registering Services for Autostartsending messagesIDREF="ChA_ToolTalk27"Sending Notices and RequestsToolTalk conceptsIDREF="ChA_ToolTalk8"Review of ToolTalk ConceptstroubleshootingIDREF="ChA_ToolTalk81"Troubleshooting Checklistviews, windowsIDREF="Ch04_Windows9"ViewKit Window ClassesIDREF="Ch04_Windows91"Window Data Access FunctionsIDREF="Ch04_Windows30"Creating the Window Interfacedirect instantiation, adding toIDREF="Ch04_Windows61"Adding a Window Interface to a Direct Instantiation of a ViewKit Window ClasssetUpInterface(), creating inIDREF="Ch04_Windows53"Creating the Window Interface in the setUpInterface() FunctionreplacingIDREF="Ch04_Windows65"Replacing a Window's Viewwindow constructor, creating inIDREF="Ch04_Windows37"Creating the Window Interface in the ConstructorVkCallbackFunction typeIDREF="Ch02_Components117"Registering ViewKit CallbacksVkCallbackMethod typeIDREF="Ch02_Components114"Registering ViewKit CallbacksVkGraphFilterProc typeIDREF="Ch09_Graph102"Indicating Which Nodes to DisplayVkGraphNodeProc typeIDREF="Ch09_Graph125"Graph Utility FunctionsVkMenuDesc structureIDREF="Ch05_Menus79"The VkMenuDesc StructureVkMenuItemType typeIDREF="Ch05_Menus83"The VkMenuDesc StructureIDREF="Ch05_Menus45"Menu Items Utility FunctionsVkModifiedCallback structureIDREF="Ch11_Input154"Detecting Changes in the Text WidgetVkModifiedReason typeIDREF="Ch11_Input155"Detecting Changes in the Text WidgetVkMsgArg structureIDREF="ChA_ToolTalk49"Writing Message Action CallbacksVkMsgClientAction typeIDREF="ChA_ToolTalk47"Writing Message Action CallbacksVkMsgFacilityReason typeIDREF="ChA_ToolTalk48"Writing Message Action CallbacksVkMsgMode typeIDREF="ChA_ToolTalk51"Writing Message Action CallbacksVkMsgValue unionIDREF="ChA_ToolTalk50"Writing Message Action CallbacksVkNodeSortFunction typeIDREF="Ch09_Graph57"Node Utility FunctionsVkPrefItemType typeIDREF="Ch08_Pref42"Preference Item Access FunctionsVkRepeatButtonType typeIDREF="Ch11_Input91"The Repeating Button ConstructorIDREF="Ch11_Input97"Repeating Button Utility and Access FunctionsVkTabCallbackStruct structureIDREF="Ch11_Input47"Responding to Tab Selectionwarning dialogIDREF="Ch07_Dialogs52"Warning Dialogs0IDREF="Ch07_Dialogs49"Warning DialogsWidget operator (in VkComponent)IDREF="Ch02_Components48"VkComponent Access FunctionswidgetsaligningIDREF="Ch10_Display34"ViewKit Support for Aligning Widgets0IDREF="Ch10_Display30"ViewKit Support for Aligning WidgetsattachmentsIDREF="Ch10_Display28"Management Classes for Controlling Component and Widget Display CharacteristicsIDREF="Ch11_Input99"Management Classes for Controlling Component and Widget Operationalignment groupsIDREF="Ch10_Display29"ViewKit Support for Aligning Widgetsganged scrollbarsIDREF="Ch11_Input100"Supporting "Ganged" Scrollbar Operationmodified textIDREF="Ch11_Input131"Modified Text Attachmentradio-style togglesIDREF="Ch11_Input114"Enforcing Radio-Style Behavior on Toggle ButtonsresizersIDREF="Ch10_Display55"ViewKit Support for Resizing and Moving Widgetsbase widget of componentIDREF="Ch02_Components35"Component DestructorsIDREF="Ch02_Components10"The VkComponent ClassIDREF="Ch02_Components46"VkComponent Access FunctionsIDREF="Ch02_Components23"Component Constructors0IDREF="Ch02_Components44"VkComponent Access Functionsdeletion, handlingIDREF="Ch02_Components76"Handling Component Widget Destructionrealization, detectingIDREF="Ch02_Components53"Displaying and Hiding Componentsbase widget of preference itemIDREF="Ch08_Pref21"Preference Item LabelsIDREF="Ch08_Pref34"Preference Item Access Functionsbase widget of windowIDREF="Ch04_Windows46"Creating the Window Interface in the ConstructorVkGraph classIDREF="Ch09_Graph134"Graph Access Functionscomponents, andIDREF="Ch02_Components9"The VkComponent ClassIDREF="Ch02_Components21"Component Constructorsdestruction in componentsIDREF="Ch02_Components74"Handling Component Widget DestructionIDREF="Ch02_Components14"The VkComponent ClassIDREF="Ch02_Components34"Component DestructorsIDREF="Ch02_Components28"Component Constructorslabel widget of preference itemIDREF="Ch08_Pref22"Preference Item LabelsIDREF="Ch08_Pref35"Preference Item Access Functionsmanagement classesIDREF="Ch10_Display28"Management Classes for Controlling Component and Widget Display CharacteristicsIDREF="Ch11_Input99"Management Classes for Controlling Component and Widget Operationalignment groupsIDREF="Ch10_Display29"ViewKit Support for Aligning Widgetsganged scrollbarsIDREF="Ch11_Input100"Supporting "Ganged" Scrollbar Operationmodified textIDREF="Ch11_Input131"Modified Text Attachmentradio-style togglesIDREF="Ch11_Input115"Enforcing Radio-Style Behavior on Toggle ButtonsresizersIDREF="Ch10_Display55"ViewKit Support for Resizing and Moving Widgetsmanagingcomponents, inIDREF="Ch02_Components30"Component ConstructorsIDREF="Ch02_Components13"The VkComponent Classwindows, inIDREF="Ch04_Windows42"Creating the Window Interface in the ConstructormovingIDREF="Ch10_Display62"ViewKit Support for Resizing and Moving Widgets0IDREF="Ch10_Display56"ViewKit Support for Resizing and Moving Widgetsparent widget of componentIDREF="Ch02_Components25"Component ConstructorsIDREF="Ch02_Components12"The VkComponent ClasswindowsIDREF="Ch04_Windows14"Window Class Constructorsparent widget of dialogsIDREF="Ch07_Dialogs28"Methods of Posting Dialogspopup menus, attachingIDREF="Ch05_Menus175"Popup Menu ConstructorsresizingIDREF="Ch10_Display62"ViewKit Support for Resizing and Moving Widgets0IDREF="Ch10_Display58"ViewKit Support for Resizing and Moving Widgetsscrollbars, "ganging." See ganged scrollbars; VkGangedGroup classIDREF="Ch11_Input101"Supporting "Ganged" Scrollbar OperationSgGraphIDREF="Ch09_Graph6"The Graph Widgetwindows, andIDREF="Ch04_Windows41"Creating the Window Interface in the ConstructorIDREF="Ch04_Windows88"Window Data Access FunctionsScrolledWindow widgetIDREF="Ch04_Windows51"Creating the Window Interface in the Constructorwindow interfaces. See windows viewsIDREF="Ch04_Windows36"Creating the Window Interfacewindow manager interactionIDREF="Ch04_Windows22"Window Class ConstructorsIDREF="Ch04_Windows100"Window Manager Interfaceicon titlesIDREF="Ch04_Windows106"Window and Icon Titleswindow propertiesIDREF="Ch04_Windows109"Window Properties and Shell Resourceswindow titlesIDREF="Ch04_Windows101"Window and Icon Titleswindows:menu bars:See alsoVkMenuBar classIDREF="Ch05_Menus131"Menu BarIDREF="Ch04_Windows4"ViewKit Windows0IDREF="Ch04_Windows3"ViewKit Windowsbase widgetIDREF="Ch04_Windows46"Creating the Window Interface in the Constructorclass hintsIDREF="Ch04_Windows130"Window Properties and Shell ResourcesdisplayingIDREF="Ch03_App42"Managing Top-Level WindowsIDREF="Ch04_Windows69"Manipulating WindowshidingIDREF="Ch04_Windows72"Manipulating WindowsIDREF="Ch03_App44"Managing Top-Level Windowsicon titlesIDREF="Ch04_Windows106"Window and Icon TitlesiconifyingIDREF="Ch03_App46"Managing Top-Level WindowsIDREF="Ch04_Windows75"Manipulating WindowsloweringIDREF="Ch04_Windows84"Manipulating WindowsIDREF="Ch03_App52"Managing Top-Level Windowsmain windowIDREF="Ch04_Windows16"Window Class ConstructorsdeterminingIDREF="Ch03_App40"Managing Top-Level Windowsduring quittingIDREF="Ch03_App34"Quitting ViewKit ApplicationsspecifyingIDREF="Ch03_App38"Managing Top-Level WindowsmanagingIDREF="Ch04_Windows68"Manipulating WindowsIDREF="Ch03_App37"Managing Top-Level Windowsmanaging widgetsIDREF="Ch04_Windows42"Creating the Window Interface in the Constructormenu barsIDREF="Ch05_Menus132"Menu BarIDREF="Ch04_Windows134"Menu Bar SupportopeningIDREF="Ch04_Windows78"Manipulating WindowsIDREF="Ch03_App48"Managing Top-Level WindowsoverviewIDREF="Ch04_Windows6"Overview of ViewKit Window Supportparent widgetIDREF="Ch04_Windows14"Window Class ConstructorspropertiesIDREF="Ch04_Windows109"Window Properties and Shell ResourcesraisingIDREF="Ch03_App50"Managing Top-Level WindowsIDREF="Ch04_Windows81"Manipulating WindowsScrolledWindow widgetIDREF="Ch04_Windows51"Creating the Window Interface in the Constructorshell resourcesIDREF="Ch04_Windows18"Window Class ConstructorsIDREF="Ch04_Windows111"Window Properties and Shell ResourcessubclassingIDREF="Ch04_Windows140"Deriving Window SubclassesexampleIDREF="Ch04_Windows161"Window Subclassing ExamplesummaryIDREF="Ch04_Windows160"Window Creation SummarytitlesIDREF="Ch04_Windows101"Window and Icon TitlesviewsIDREF="Ch04_Windows9"ViewKit Window ClassesIDREF="Ch04_Windows30"Creating the Window InterfaceIDREF="Ch04_Windows91"Window Data Access Functionsdirect instantiation, adding toIDREF="Ch04_Windows60"Adding a Window Interface to a Direct Instantiation of a ViewKit Window ClasssetUpInterface(), creating inIDREF="Ch04_Windows52"Creating the Window Interface in the setUpInterface() FunctionreplacingIDREF="Ch04_Windows64"Replacing a Window's Viewwindow constructor, creating inIDREF="Ch04_Windows37"Creating the Window Interface in the ConstructorwidgetsIDREF="Ch04_Windows88"Window Data Access FunctionsIDREF="Ch04_Windows41"Creating the Window Interface in the Constructorwindow manager interactionIDREF="Ch04_Windows22"Window Class ConstructorsIDREF="Ch04_Windows100"Window Manager Interfacework areasIDREF="Ch04_Windows9"ViewKit Window ClassesIDREF="Ch04_Windows91"Window Data Access FunctionsIDREF="Ch04_Windows30"Creating the Window Interfacedirect instantiation, adding toIDREF="Ch04_Windows60"Adding a Window Interface to a Direct Instantiation of a ViewKit Window ClasssetUpInterface(), creating inIDREF="Ch04_Windows52"Creating the Window Interface in the setUpInterface() FunctionreplacingIDREF="Ch04_Windows64"Replacing a Window's Viewwindow constructor, creating inIDREF="Ch04_Windows37"Creating the Window Interface in the ConstructorWM_DELETE_WINDOW messageIDREF="Ch04_Windows23"Window Class ConstructorsIDREF="Ch04_Windows117"Window Properties and Shell ResourcesWM_QUIT_APP messageIDREF="Ch04_Windows123"Window Properties and Shell ResourcesIDREF="Ch04_Windows24"Window Class Constructorswork areas, windowsIDREF="Ch04_Windows9"ViewKit Window ClassesIDREF="Ch04_Windows30"Creating the Window InterfaceIDREF="Ch04_Windows91"Window Data Access Functionsdirect instantiation, adding toIDREF="Ch04_Windows61"Adding a Window Interface to a Direct Instantiation of a ViewKit Window ClasssetUpInterface(), creating inIDREF="Ch04_Windows53"Creating the Window Interface in the setUpInterface() FunctionreplacingIDREF="Ch04_Windows65"Replacing a Window's Viewwindow constructor, creating inIDREF="Ch04_Windows37"Creating the Window Interface in the ConstructorXheader filesIDREF="Ch01_Overview18"Required Header Filessuggested readingIDREF="Intro6"What You Should Know Before Reading This GuideViewKit, andIDREF="Ch01_Overview4"Mixing ViewKit and Standard X and IRIS IM FunctionsX resources"Undo" selection labelIDREF="Ch06_Undo29"Setting the Label of the Undo Manager Menu Item0IDREF="Ch02_Components81"Component Resource Supportarc attributes (in graph)IDREF="Ch09_Graph80"Adding Nodes and Specifying Node ConnectivitygraphsIDREF="Ch09_Graph146"X Resources Associated with VkGraphHelp menuIDREF="Ch05_Menus192"X Resources Associated with the Help Panemenu item labelsIDREF="Ch05_Menus37"Setting Menu Item Labelsmeter componentIDREF="ChB_Contrib17"X Resources Associated with the Meter Componentmodified text attachmentIDREF="Ch11_Input170"X Resources Associated with the Modified Text Attachment network licensingIDREF="Ch13_NetLS8"X Resources Associated With the VkNLS Classoption menu labelsIDREF="Ch05_Menus159"Setting the Option Menu Labelpreference item labelsIDREF="Ch08_Pref23"Preference Item Labelsrepeating buttonsIDREF="Ch11_Input98"X Resources Associated with the Repeating Button Componenttab panelsIDREF="Ch11_Input64"X Resources Associated with the Tab Panel Componenttear-off menusIDREF="Ch05_Menus144"Submenu Utility and Access Functionstick marksIDREF="Ch10_Display27"X Resources Associated with the Tick Marks ComponentXA_WM_CLASS propertyIDREF="Ch04_Windows133"Window Properties and Shell ResourcesXmGRAPH (graph layout style)IDREF="Ch09_Graph112"Butterfly GraphsXmNargc resourceIDREF="Ch04_Windows113"Window Properties and Shell ResourcesIDREF="Ch04_Windows20"Window Class ConstructorsXmNargv resourceIDREF="Ch04_Windows21"Window Class ConstructorsIDREF="Ch04_Windows114"Window Properties and Shell ResourcesXmNhelpCallback functionsIDREF="ChC_Help3"User Interfaces to the Help System in a ViewKit ApplicationXmNlabelString resource"Undo" menu selectionIDREF="Ch06_Undo29"Setting the Label of the Undo Manager Menu Itemmenu item labelsIDREF="Ch05_Menus38"Setting Menu Item Labelsoption menu labelsIDREF="Ch05_Menus160"Setting the Option Menu Labelpreference item labelsIDREF="Ch08_Pref23"Preference Item LabelsXmNtearOffModel resourceIDREF="Ch05_Menus144"Submenu Utility and Access FunctionsXt callbackscomponentsIDREF="Ch02_Components63"Using Xt Callbacks with ComponentsIDREF="Ch02_Components15"The VkComponent ClassexampleIDREF="Ch02_Components72"Using Xt Callbacks with Componentsnaming conventionIDREF="Ch02_Components70"Using Xt Callbacks with Componentsthis pointerIDREF="Ch02_Components65"Using Xt Callbacks with Componentsstatic menu descriptionsIDREF="Ch05_Menus84"Special Considerations for Xt Callback Client Data When Using Static Menu DescriptionsXt Intrinsics, initializingIDREF="Ch03_App10"The VkApp ConstructorXtAppContext structureIDREF="Ch03_App113"Application Data Access FunctionsZoom menu (in VkGraph control panel)IDREF="Ch09_Graph11"Zoomingzooming graphsIDREF="Ch09_Graph119"Graph Utility FunctionsIDREF="Ch09_Graph10"Zooming