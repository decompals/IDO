#EDIR DATA#
LANG=CC++ Language System Product Reference ManualDocument Number 007-1618-020CONTRIBUTORSEdited by David Graves, Janiece CarricoProduction by Gloria Ackley© Copyright 1993, Silicon Graphics, Inc.name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' All Rights Reserved© Copyright 1991, AT&T and UNIX System Laboratories, Inc.name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' All Rights Reserved© Copyright 1984, 1989, 1990, AT&T. name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' All Rights ReservedThis document contains proprietary and confidential information of Silicon Graphics, Inc. The contents of this document may not be disclosed to third parties, copied, or duplicated in any form, in whole or in part, without the prior written permission of Silicon Graphics, Inc.RESTRICTED RIGHTS LEGENDUse, duplication, or disclosure of the technical data contained in this document by the Government is subject to restrictions as set forth in subdivision (c) (1) (ii) of the Rights in Technical Data and Computer Software clause at DFARS 52.227-7013 and/or in similar or successor clauses in the FAR, or in the DOD or NASA FAR Supplement. Unpublished rights reserved under the Copyright Laws of the United States. Contractor/manufacturer is Silicon Graphics, Inc., 2011 N. Shoreline Blvd., Mountain View, CA 94039-7311.NOTICEThe information in this document is subject to change without notice. UNIX System Laboratories, Inc., assumes no responsibility for any errors that may appear in this document.Silicon Graphics is a registered trademark of Silicon Graphics, Inc. UNIX is a registered trademark of UNIX System Laboratories.LBL="1"ID="18478"IntroductionID="ch11"LBL="" HELPID=""About This GuideThis manual describes the C++ programming language as of May 1991. C++ is a general-purpose programming language based on the C programming language"The C Programming Language" by Brian W. Kernighan and Dennis M. Ritchie, Prentice Hall, 1978 and 1988.
. In addition to the facilities provided by ANSI C, C++ provides classes, inline functions, operator overloading, function name overloading, constant types, references, free store management operators, and function argument checking and type conversion. These extensions to ANSI C are summarized in ID="ch12"ID="ch13"IDREF="12959" TYPE="TITLE""Extensions". The differences between C++ and ANSI CAmerican National Standard X3.159-1989.
 are summarized in IDREF="35279" TYPE="TITLE""C++ and ANSI C". The extensions to C++ since the 1985 edition of this manual are summarized in IDREF="12959" TYPE="TITLE""Extensions". The section related to exception handling in ID="ch14"IDREF="33126" TYPE="TITLE"Chapter 15, "Exception Handling," is a placeholder for planned language extensions. This reference manual is by Bjarne Stroustrup. Note
This is the May 1991 version of the C++ Reference ManualLBL="" HELPID=""AudienceThis manual assumes that you are familiar with the language as described in The C++ Programming Language (see IDREF="64793" TYPE="TITLE""Recommended Reading on C++") and that you have sufficient experience with C++ to recognize many of the problems that the features described in this manual are designed to solve or alleviate.LBL="" HELPID=""ID="40376"Document OverviewThis manual is organized like this: ID="ch15"IDREF="18478" TYPE="TITLE"Chapter 1, "Introduction," provides an overview of the organization and of the conventions used in this manual.IDREF="39061" TYPE="TITLE"Chapter 2, "Lexical Conventions," reviews the development of tokens after preprocessing including identifiers, keywords, operators, literals and other separators.IDREF="34580" TYPE="TITLE"Chapter 3, "Basic Concepts," discusses name declarations and definitions, and the use of a name within a region of program text called its scope. Program and linkage, types, and storage classes are also covered in this chapter.IDREF="31385" TYPE="TITLE"Chapter 4, "Standard Conversions," summarizes the conversions demanded by most ordinary operators and explains the result to be expected from such conversions.IDREF="28885" TYPE="TITLE"Chapter 5, "Expressions," defines the syntax, order of evaluation, and meaning of expressions.IDREF="68758" TYPE="TITLE"Chapter 6, "Statements," presents the ordered execution sequence for statements and describes the various types of statements and their usage.IDREF="35031" TYPE="TITLE"Chapter 7, "Declarations," provides a detailed look at the declaration form and shows the use of the declaration specifier to indicate the fundamental type, storage class, or other properties of the objects and functions being declared.IDREF="30155" TYPE="TITLE"Chapter 8, "Declarators," explains the use of declarators to state explictly the names of objects and functions, and to modify the type with operators.IDREF="38144" TYPE="TITLE"Chapter 9, "Classes," defines class name, class members, member functions, static members, unions, bit-fields, nested and local class declarations, and local type names.IDREF="37638" TYPE="TITLE"Chapter 10, "Derived Classes," reviews mutiple base classes, virtual functions, and abstract classes, and also provides a summary of scope rules.IDREF="40678" TYPE="TITLE"Chapter 11, "Member Access Control," explains the access rules (private, protected and public) that are available for members of a class.IDREF="10620" TYPE="TITLE"Chapter 12, "Special Member Functions," describes the way objects of a class are created, copied, and destroyed, and how values may be converted to values of other types.IDREF="18871" TYPE="TITLE"Chapter 13, "Overloading," defines and discusses overloaded operators. Operators can be overloaded, that is, given meaning when applied to expressions of class type. Addressing of overloaded functions, argument matching and declaration matching are reviewed.IDREF="18442" TYPE="TITLE"Chapter 14, "Templates," contains information about class templates, type equivalence, function templates, declarations and definitions, member function templates, friends, static members and variables.IDREF="33126" TYPE="TITLE"Chapter 15, "Exception Handling," status as a placeholder for planned language extensions is presented.IDREF="15280" TYPE="TITLE"Chapter 16, "Preprocessing," reviews the phases of preprocessing, macro definition, conditional compilation, and file inclusion.IDREF="27708" TYPE="TITLE"Appendix A, "Grammar Summary," presents a brief review of C++ syntax as an aid to comprehension.IDREF="86943" TYPE="TITLE"Appendix B, "Compatibility," provides a brief summary of extensions to ANSI C provided by C++, demonstates the differences in language features between C++ and ANSI C, and discusses ANSI C to C++ language anachronisms.LBL="" HELPID=""ID="64793"Recommended Reading on C++For a precise description of the C++ language, the following is indispensable:Ellis, Margaret A., and Stroustrup, Bjarne. The Annotated C++ Reference Manual (Reading, Mass.: Addison-Wesley, 1990)The following books are recommended reading on programming in C++:Lippman, Stanley B. C++ Primer Second Edition (Reading, Mass.: Addison-Wesley, 1991)Stroustrup, Bjarne. The C++ Programming Language Second Edition (Addison-Wesley, 1991)LBL="" HELPID=""Notation and Syntax ConventionsID="ch16"This guide uses the following notation and syntax conventions:itID="ch17"ID="ch18"alicIndicates arguments in a command line that you must replace with a valid value. In text, it is used to indicate commands, document titles, file names, glossary items, new terms, and variables.coID="ch19"ID="ch110"urierIndicates computer output and program listings.couID="ch111"ID="ch112"rier boldIndicates user input to the computer and nonprinting keys.[ ]Brackets enclose optional command arguments. (Do not enter the brackets.)ID="ch113"ID="ch114". . .An ellipsis indicates that the preceding optional items can appear more than once in succession.ID="ch115"ID="ch116"|The vertical bar separates items from which you can choose one.ID="ch117"ID="ch118"LBL="2"ID="39061"Lexical ConventionsThis chapter contains the following subsections:IDREF="25554" TYPE="TITLE""Tokens"IDREF="32339" TYPE="TITLE""Comments"IDREF="28128" TYPE="TITLE""Identifiers"IDREF="12297" TYPE="TITLE""Keywords"IDREF="32709" TYPE="TITLE""Literals"A C++ program consists of one or more ID="ch21"filesID="ch22" (IDREF="22763" TYPE="TITLE""Program and Linkage""). A file is conceptually translated in several phases. The first phase is preprocessing (ID="ch23"ID="ch24"IDREF="15280" TYPE="TITLE"Chapter 16, "Preprocessing"), which performs file inclusion and macro substitution. Preprocessing is controlled by directives introduced by lines having # as the first character other than white space ("ID="ch25"IDREF="25554" TYPE="TITLE""Tokens"). The result of preprocessing is a sequence of tokens. Such a sequence of tokens, that is, a file after preprocessing is called a ID="ch26"translation unit. ID="ch27"LBL="" HELPID=""ID="25554"TokensID="ch28"There are five kinds of tokens: identifiers, keywords, literals, operators, and other separators. Blanks, horizontal and vertical tabs, newlines, formfeeds, and comments (collectively, "white space"), as described below, are ignored except as they serve to separate tokens. Some white space is required to separate otherwise adjacent identifiers, keywords, and constants.ID="ch29"If the input stream has been parsed into tokens up to a given character, the next token is taken to be the longest string of characters that could possibly constitute a token.LBL="" HELPID=""ID="32339"CommentsID="ch210"The characters /* start a comment, which terminates with the characters */. These comments do not nest. The characters // start a comment, which terminates at the end of the line on which they occur. The comment characters //, /*, and */ have no special meaning within a // comment and are treated just like other characters. Similarly, the comment characters // and /* have no special meaning within a /* comment. ID="ch211"ID="ch212"LBL="" HELPID=""ID="28128"IdentifiersAn identifier is an arbitrarily long sequence of letters and digits. The first character must be a letter; the underscore _ counts as a letter. Upper-case  and lower-case letters are different. All characters are significant. ID="ch213"ID="ch214"ID="ch215"ID="ch216"LBL="" HELPID=""ID="12297"KeywordsThe following identifiers are reserved for use as keywords, and may not be used otherwise. ID="ch217"ID="ch218"COLUMNS="6"LEFT="0" WIDTH="50"asmLEFT="55" WIDTH="50"continueLEFT="110" WIDTH="50"floatLEFT="165" WIDTH="50"newLEFT="220" WIDTH="50"signedLEFT="275" WIDTH="72"tryLEFT="0" WIDTH="50"autoLEFT="55" WIDTH="50"defaultLEFT="110" WIDTH="50"forLEFT="165" WIDTH="50"operatorLEFT="220" WIDTH="50"sizeofLEFT="275" WIDTH="72"typedefLEFT="0" WIDTH="50"breakLEFT="55" WIDTH="50"deleteLEFT="110" WIDTH="50"friendLEFT="165" WIDTH="50"privateLEFT="220" WIDTH="50"staticLEFT="275" WIDTH="72"unionLEFT="0" WIDTH="50"caseLEFT="55" WIDTH="50"doLEFT="110" WIDTH="50"gotoLEFT="165" WIDTH="50"protectedLEFT="220" WIDTH="50"structLEFT="275" WIDTH="72"unsignedLEFT="0" WIDTH="50"catchLEFT="55" WIDTH="50"doubleLEFT="110" WIDTH="50"ifLEFT="165" WIDTH="50"publicLEFT="220" WIDTH="50"switchLEFT="275" WIDTH="72"virtualLEFT="0" WIDTH="50"charLEFT="55" WIDTH="50"elseLEFT="110" WIDTH="50"inlineLEFT="165" WIDTH="50"registerLEFT="220" WIDTH="50"templateLEFT="275" WIDTH="72"voidLEFT="0" WIDTH="50"classLEFT="55" WIDTH="50"enumLEFT="110" WIDTH="50"intLEFT="165" WIDTH="50"returnLEFT="220" WIDTH="50"thisLEFT="275" WIDTH="72"volatileLEFT="0" WIDTH="50"constLEFT="55" WIDTH="50"externLEFT="110" WIDTH="50"longLEFT="165" WIDTH="50"shortLEFT="220" WIDTH="50"throwLEFT="275" WIDTH="72"whileIn addition, identifiers containing a double underscore ( __ ) are reserved for use by C++ implementations and standard libraries and should be avoided by users. ID="ch219"ID="ch220"ID="ch221"ID="ch222"The ASCII representation of C++ programs uses the following characters as operators or for punctuation: ! % ^ & * ( ) - + = { } | ~
[ ] \ ; ' : " < > ? , . /and the following character combinations are used as operators: -> ++ -- .* ->* << >>  <=  >= == != &&
|| *= /= %= +=  -= <<= >>= &= ^= |= ::Each is a single token. ID="ch223"In addition, the following tokens are used by the preprocessor:#  ##Certain implementation-dependent properties, such as the type of a sizeof (IDREF="39049" TYPE="TITLE""Sizeof" in Chapter 5) and the ranges of fundamental types (ID="ch224"IDREF="28323" TYPE="TITLE""Types" in Chapter 3), are defined in the standard header files<ID="ch225"float.h>   <ID="ch226"limits.h>   <ID="ch227"stddef.h>These header files  are part of the ANSI C standard. In addition the headers ID="ch228"<ID="ch229"new.h>   <ID="ch230"stdarg.h>   <ID="ch231"stdlib.h>define the types of the most basic library functions. The last two headers are part of the ANSI C standard; <new.h> is C++ specific. LBL="" HELPID=""ID="32709"LiteralsID="ch232"ID="ch233"There are several kinds of literals (often referred to as "constants"). ID="ch234"literal:integer-constantcharacter-constantfloating-constantstring-literal"LBL="" HELPID=""Integer ConstantsID="ch235"ID="ch236"ID="ch237"ID="ch238"ID="ch239"An integer constant consisting of a sequence of digits is taken to be decimal (base ten) unless it begins with 0 (digit zero). A sequence of digits starting with 0 is taken to be an octal integer (base eight). The digits 8 and 9 are not octal digits. A sequence of digits preceded by 0x or 0X is taken to be a hexadecimal integer (base sixteen). The hexadecimal digits include a or A through f or F with decimal values ten through fifteen. For example, the number twelve can be written 12, 014,  or XC. ID="ch240"ID="ch241"ID="ch242"ID="ch243"ID="ch244"ID="ch245"ID="ch246"The type of an integer constant depends on its form, value, and suffix. If it is decimal and has no suffix, it has the first of these types in which its value can be represented: int, longint, unsignedlongint. If it is octal or hexadecimal and has no suffix, it has the first of these types in which its value can be represented: int, unsigned int, long int, unsigned long int. If it is suffixed by u or U, its type is the first of these types in which its value can be represented: unsigned int, unsigned long int. If it is suffixed by l or L, its type is the first of these types in which its value can be represented: long int, unsigned long int. If it is suffixed by ul, lu, uL, Lu, Ul, lU, UL, or LU, its type is unsigned long int. ID="ch247"LBL="" HELPID=""ID="12401"Character ConstantsID="ch248"A character constant is one or more characters enclosed in single quotes, as in 'x'. Single character constants have type ID="ch249"char. The value of a single character constant is the numerical value of the character in the machine's character set. Multicharacter constants have type ID="ch250"int. The value of a multicharacter constant is implementation dependent. ID="ch251"Certain non-graphic characters, the single quote ', the double quote ", the question mark ?, and the backslash \, may be represented according to the escape sequences shown in Table 2-1.ID="ch252"ID="ch253"ID="ch254"COLUMNS="3"LBL="2-1"Table 2-1 
Escape SequencesLEFT="0" WIDTH="108"Character Name LEFT="115" WIDTH="86"ASCII NameLEFT="210" WIDTH="86"Escape SequenceLEFT="0" WIDTH="108"new-lineLEFT="115" WIDTH="86"NL (LF)LEFT="210" WIDTH="86"\nLEFT="0" WIDTH="108"horizontal tabLEFT="115" WIDTH="86"HTLEFT="210" WIDTH="86"LEFT="0" WIDTH="108"vertical tabLEFT="115" WIDTH="86"VTLEFT="210" WIDTH="86"\vLEFT="0" WIDTH="108"backspaceLEFT="115" WIDTH="86"BSLEFT="210" WIDTH="86"\bLEFT="0" WIDTH="108"carriage returnLEFT="115" WIDTH="86"CRLEFT="210" WIDTH="86"\rLEFT="0" WIDTH="108"form feedLEFT="115" WIDTH="86"FFLEFT="210" WIDTH="86"\fLEFT="0" WIDTH="108"alertLEFT="115" WIDTH="86"BELLEFT="210" WIDTH="86"\aLEFT="0" WIDTH="108"backslashLEFT="115" WIDTH="86"\LEFT="210" WIDTH="86"\\LEFT="0" WIDTH="108"question markLEFT="115" WIDTH="86"?LEFT="210" WIDTH="86"\?LEFT="0" WIDTH="108"single quoteLEFT="115" WIDTH="86"'LEFT="210" WIDTH="86"\'LEFT="0" WIDTH="108"double quoteLEFT="115" WIDTH="86""LEFT="210" WIDTH="86"\"LEFT="0" WIDTH="108"octal numberLEFT="115" WIDTH="86"oooLEFT="210" WIDTH="86"\oooLEFT="0" WIDTH="108"hex numberLEFT="115" WIDTH="86"hhhLEFT="210" WIDTH="86"\xhhhIf the character following a backslash is not one of those specified, the behavior is undefined. An escape sequence specifies a single character. The escape \ooo consists of the backslash followed by one, two, or three octal digits that are taken to specify the value of the desired character. The escape ID="ch255"\xhhh consists of the backslash followed by ID="ch256"x followed by a sequence of hexadecimal digits that are taken to specify the value of the desired character. There is no limit to the number of hexadecimal digits in the sequence. A sequence of octal or hexadecimal digits is terminated by the first character that is not an octal digit or a hexadecimal digit, respectively. The value of a character constant is implementation dependent if it exceeds that of the largest ID="ch257"char. ID="ch258"ID="ch259"ID="ch260"A character constant immediately preceded by the letter L for example, L'ab', is a wide-character constant.  A wide-character constant is of type ID="ch261"wchar_t, an integral type (ID="ch262"IDREF="27802" TYPE="TITLE""Fundamental Types") defined in the standard header <stddef.h>.  Wide-characters are intended for character sets where a character does not fit into a single byte.  LBL="" HELPID=""ID="52602"Floating ConstantsID="ch263"A floating constant consists of an integer part, a decimal point, a fraction part, an e or E, an optionally signed integer exponent, and an optional type suffix.  The integer and fraction parts both consist of a sequence of decimal (base ten) digits.  Either the integer part or the fraction part (not both) may be missing; either the decimal point or the letter ID="ch264"e (or E) and the exponent (not both) may be missing.  The type of a floating constant is ID="ch265"double unless explicitly specified by a suffix.  The suffixes ID="ch266"ID="ch267"ID="ch268"ID="ch269"f and F specify float, the suffixes ID="ch270"ID="ch271"ID="ch272"l and L specify long double.  LBL="" HELPID=""ID="38768"String LiteralsID="ch273"ID="ch274"ID="ch275"A string literal is a sequence of characters (as defined in IDREF="12401" TYPE="TITLE""Character Constants") surrounded by double quotes, as in "...".  A string has type "array of ID="ch276"ID="ch277"char" and storage class static (IDREF="38359" TYPE="TITLE""Storage Classes"), and is initialized with the given characters.  Whether all string literals are distinct (that is, are stored in non-overlapping objects) is implementation dependent.  The effect of attempting to modify a string literal is undefined.  ID="ch278"ID="ch279"ID="ch280"ID="ch281"Adjacent string literals are concatenated.  Characters in concatenated strings are kept distinct.  For example, ID="ch282""\xA" "B"contains the two characters '\xA' and 'B' after concatenation (and not the single hexadecimal character '\xAB').  After any necessary concatenation, '\0' is appended so that programs that scan a string can find its end.  The size of a string is the number of its characters including this terminator.  Within a string, the double quote character " must be preceded by a ID="ch283"ID="ch284"ID="ch285"ID="ch286"\.  A string literal immediately preceded by the letter L, for example, L"asdf", is a wide-character string.  A wide-character string is of type "array of ID="ch287"ID="ch288"ID="ch289"ID="ch290"wchar_t," where wchar_t is an integral type defined in the standard header ID="ch291"<stddef.h>.  Concatenation of ordinary and wide-character string literals is undefined. ID="ch292"LBL="3"ID="34580"Basic ConceptsThis chapter contains the following subsections:IDREF="24185" TYPE="TITLE""Declarations and Definitions"IDREF="24244" TYPE="TITLE""Scopes"IDREF="22763" TYPE="TITLE""Program and Linkage"IDREF="28875" TYPE="TITLE""Start and Termination"IDREF="38359" TYPE="TITLE""Storage Classes"IDREF="28323" TYPE="TITLE""Types"IDREF="23683" TYPE="TITLE""Lvalues"A name denotes an object, a function, a set of functions, an enumerator, a type, a class member, a template, a value, or a label. A name is introduced into a program by a declaration. A name can be used only within a region of program text called its ID="ch31"ID="ch32"ID="ch33"ID="ch34"ID="ch35"ID="ch36"ID="ch37"scope. A name has a type, which determines its use. A name used in more than one translation unit may (or may not) refer to the same object, function, type, template, or value in these translation units depending on the linkage (ID="ch38"IDREF="22763" TYPE="TITLE""Program and Linkage") specified in the translation units. ID="ch39"An object is a region of storage (IDREF="23683" TYPE="TITLE""Lvalues"). A named object has a storage class (IDREF="38359" TYPE="TITLE""Storage Classes") that determines its lifetime. The meaning of the values found in an object is determined by the type of the expression used to access it. LBL="" HELPID=""ID="24185"Declarations and DefinitionsID="ch310"ID="ch311"ID="ch312"A declaration (IDREF="35031" TYPE="TITLE"Chapter 7, "Declarations") introduces one or more names into a program. A declaration is a definition unless it declares a function without specifying the body (ID="ch313"IDREF="20795" TYPE="TITLE""Function Definitions"), it contains the ID="ch314"extern specifier (IDREF="12029" TYPE="TITLE""Storage Class Specifiers") and no initializer or function body, it is the declaration of a static data member in a class declaration (ID="ch315"IDREF="17418" TYPE="TITLE""Static Members"), it is a class name declaration (ID="ch316"IDREF="12565" TYPE="TITLE""Class Names"), or it is a typedef declaration (ID="ch317"IDREF="13818" TYPE="TITLE""The typedef Specifier"). The following, for example, are definitions: ID="ch318"int a;
extern const c = 1;
int f(int x) { return x+a; }
struct S { int a; int b; };
enum { up, down };whereas these are just declarations: ID="ch319"extern int a;
extern const c;
int f(int);
struct S;
typedef int Int;
ID="ch320"ID="ch321"ID="ch322"ID="ch323"There must be exactly one definition of each object, function, class, and enumerator used in a program (IDREF="22763" TYPE="TITLE""Program and Linkage"). If a function is never called and its address is never taken, it need not be defined. Similarly, if the name of a class is used only in a way that does not require its definition to be known, it need not be defined. LBL="" HELPID=""ID="24244"ScopesID="ch324"There are four kinds of scope: local, function, file, and class. Local: A name declared in a block (ID="ch325"ID="ch326"IDREF="15195" TYPE="TITLE""Compound Statement, or Block") is local to that block and can be used only in it and in blocks enclosed by it after the point of declaration. Names of formal arguments for a function are treated as if they were declared in the outermost block of that function. ID="ch327"Function: Labels (ID="ch328"ID="ch329"IDREF="30075" TYPE="TITLE""Labeled Statement") can be used anywhere in the function in which they are declared. Only labels have function scope. File: A name declared outside all blocks (ID="ch330"IDREF="15195" TYPE="TITLE""Compound Statement, or Block") and classes (IDREF="38144" TYPE="TITLE"Chapter 9, "Classes") has file scope and can be used in the translation unit in which it is declared after the point of declaration. Names declared with file scope are said to be global. ID="ch331"Class: The name of a class member is local to its class and can be used only in a member function of that class (ID="ch332"IDREF="34481" TYPE="TITLE""Member Functions"), after the . operator applied to an object of its class (IDREF="21265" TYPE="TITLE""Class Member Access") or a class derived from (IDREF="37638" TYPE="TITLE"Chapter 10, "Derived Classes") its class, after the -> operator applied to a pointer to an object of its class (IDREF="21265" TYPE="TITLE""Class Member Access") or a class derived from its class, or after the :: scope resolution operator (IDREF="36093" TYPE="TITLE""Primary Expressions") applied to the name of its class or a class derived from its class. A name first declared by a ID="ch333"ID="ch334"friend declaration (IDREF="13398" TYPE="TITLE""Friends") belongs to the same scope as the class containing the friend declaration. A class first declared in a return or argument type belongs to the global scope. ID="ch335"ID="ch336"Special rules apply to names declared in function argument declarations (IDREF="34712" TYPE="TITLE""Functions"), and friend declarations (IDREF="13398" TYPE="TITLE""Friends"). ID="ch337"ID="ch338"A name may be hidden by an explicit declaration of that same name in an enclosed block or in a class. A hidden class member name can still be used when it is qualified by its class name using the :: operator (IDREF="36093" TYPE="TITLE""Primary Expressions",  IDREF="17418" TYPE="TITLE""Static Members", IDREF="37638" TYPE="TITLE"Chapter 10, "Derived Classes"). A hidden name of an object, function, type, or enumerator with file scope can still be used when it is qualified by the unary ID="ch339":: operator (IDREF="36093" TYPE="TITLE""Primary Expressions"). In addition, a class name (IDREF="12565" TYPE="TITLE""Class Names") may be hidden by the name of an object, function, or enumerator declared in the same scope. If a class and an object, function, or enumerator are declared in the same scope (in any order) with the same name the class name is hidden. A class name hidden by a name of an object, function, or enumerator in local or class scope can still be used when appropriately (ID="ch340"IDREF="24962" TYPE="TITLE""Type Specifiers") prefixed with class, struct, or union. Similarly, a hidden enumeration name can be used when appropriately (IDREF="24962" TYPE="TITLE""Type Specifiers") prefixed with enum. The scope rules are summarized in IDREF="28183" TYPE="TITLE""Summary of Scope Rules". The point of declaration for a name is immediately after its complete declarator (ID="ch341"IDREF="30155" TYPE="TITLE"Chapter 8, "Declarators") and before its initializer (if any). For example, int x = 12;
{ int x = x; }Here the second x is initialized with its own (unspecified) value. ID="ch342"The point of declaration for an enumerator is immediately after the identifier that names it. For example, enum { x = x };Here, again, the enumerator x is initialized to its own (uninitialized) value. LBL="" HELPID=""ID="22763"Program and LinkageID="ch343"A program consists of one or more files (IDREF="39061" TYPE="TITLE"Chapter 2, "Lexical Conventions") linked together. A file consists of a sequence of declarations. ID="ch344"ID="ch345"ID="ch346"ID="ch347"A name of file scope that is explicitly declared static is local to its translation unit and can be used as a name for other objects, functions, and so on, in other translation units. Such names are said to have internal linkage. A name of file scope that is explicitly declared ID="ch348"inline is local to its translation unit. A name of file scope that is explicitly declared ID="ch349"const and not explicitly declared extern is local to its translation unit. As is the name of a class that has not been used in the declaration of an object, function, or class that is not local to its translation unit and has no static members (ID="ch350"IDREF="17418" TYPE="TITLE""Static Members") and no non-inline member functions (IDREF="41223" TYPE="TITLE""Inline Member Functions"). Every declaration of a particular name of file scope that is not declared to have internal linkage in one of the above mentioned ways in a multifile program refers to the same object (IDREF="23683" TYPE="TITLE""Lvalues"), function (IDREF="34712" TYPE="TITLE""Functions"), or class (IDREF="38144" TYPE="TITLE"Chapter 9, "Classes"). Such names are said to be external, or to have external linkage. In particular, since it is not possible to declare a class name ID="ch351"static, every use of a particular file scope class name that has been used in the declaration of an object or function with external linkage or has a static member or a non-inline member function refers to the same class. ID="ch352"ID="ch353"ID="ch354"Typedef names (IDREF="13818" TYPE="TITLE""The typedef Specifier"), enumerators (IDREF="14398" TYPE="TITLE""Enumeration Declarations"), and template names (IDREF="18442" TYPE="TITLE"Chapter 14, "Templates") do not have external linkage. ID="ch355"Static class members (IDREF="17418" TYPE="TITLE""Static Members") have external linkage. ID="ch356"Non-inline class member functions have external linkage. Inline class member functions must have exactly one definition in a program. ID="ch357"ID="ch358"ID="ch359"Local names (IDREF="24244" TYPE="TITLE""Scopes") explicitly declared extern have external linkage unless already declared static (IDREF="12029" TYPE="TITLE""Storage Class Specifiers"). ID="ch360"ID="ch361"The types specified in all declarations of a particular external name must be identical except for the use of typedef names (IDREF="13818" TYPE="TITLE""The typedef Specifier") and unspecified array bounds (IDREF="30659" TYPE="TITLE""Arrays"). There must be exactly one definition for each function, object, class and enumerator used in a program. If, however, a function is never called and its address is never taken, it need not be defined. Similarly, if the name of a class is used only in a way that does not require its definition to be known, it need not be defined. ID="ch362"ID="ch363"ID="ch364"ID="ch365"ID="ch366"A function may be defined only in file or class scope.Linkage to non-C++ declarations can be achieved using a linkage-specification (IDREF="27890" TYPE="TITLE""Linkage Specifications"). LBL="" HELPID=""ID="28875"Start and TerminationID="ch367"ID="ch368"A program must contain a function called main(). This function is the designated start of the program. This function is not predefined by the compiler, it cannot be overloaded, and its type is implementation dependent. It is recommended that the two examples below be allowed on any implementation and that any further arguments required be added after ID="ch369"argv. The function main() may be defined as int main() { /* ... */ }
or 
int main(int argc, char* argv[]) { /* ... */ }
ID="ch370"ID="ch371"ID="ch372"ID="ch373"ID="ch374"In the latter form argc shall be the number of parameters passed to the program from an environment in which the program is run. If argc is non-zero these parameters shall be supplied as zero-terminated strings in argv0 through argvargc-1 and argv0 shall be the name used to invoke the program or "". It is guaranteed that argv[argc]==0. The function main() may not be called from within a program. The linkage (IDREF="22763" TYPE="TITLE""Program and Linkage") of main()  is implementation dependent. The address of ID="ch375"main() cannot be taken and main() may not be declared inline or static. ID="ch376"Calling the function void exit(int);declared in ID="ch377"<stdlib.h> terminates the program. The argument value is returned to the program's environment as the value of the program. ID="ch378"ID="ch379"A return statement in main() has the effect of calling exit() with the return value as the argument. ID="ch380"ID="ch381"ID="ch382"ID="ch383"ID="ch384"The initialization of non-local static objects (IDREF="38359" TYPE="TITLE""Storage Classes") in a translation unit is done before the first use of any function or object defined in that translation unit. Such initializations (IDREF="23366" TYPE="TITLE""Initializers", IDREF="17418" TYPE="TITLE""Static Members", IDREF="21970" TYPE="TITLE""Constructors", IDREF="18434" TYPE="TITLE""Explicit Initialization") may be done before the first statement of main() or deferred to any point in time before the first use of a function or object defined in that translation unit. The default initialization of all static objects to zero (IDREF="23366" TYPE="TITLE""Initializers") is performed before any dynamic (that is, run-time) initialization. No further order is imposed on the initialization of objects from different translation units. The initialization of local static objects is described in IDREF="23366" TYPE="TITLE""Initializers". ID="ch385"ID="ch386"ID="ch387"Destructors (IDREF="29867" TYPE="TITLE""Destructors") for initialized static objects are called when returning from main() and when calling exit(). Destruction is done in reverse order of initialization. The function ID="ch388"ID="ch389"atexit() from <stdlib.h> can be used to specify that a function must be called at exit. If ID="ch390"atexit() is to be called, objects initialized before an atexit() call may not be destroyed until after the function specified in the atexit() call has been called. Where a C++ implementation coexists with a C implementation, any actions specified by the C implementation to take place after the atexit() functions have been called take place after all destructors have been called. ID="ch391"ID="ch392"Calling the function void abort();declared in ID="ch393"<stdlib.h> terminates the program without executing destructors for static objects and without calling the functions passed to atexit(). LBL="" HELPID=""ID="38359"Storage ClassesID="ch394"There are two declarable storage classes: automatic and static. Automatic objects are local to each invocation of a block. ID="ch395"ID="ch396"Static objects exist and retain their values throughout the execution of the entire program. ID="ch397"ID="ch398"ID="ch399"ID="ch3100"Automatic objects are initialized (IDREF="21970" TYPE="TITLE""Constructors") each time the control flow reaches their definition and destroyed (IDREF="29867" TYPE="TITLE""Destructors") on exit from their block (IDREF="10996" TYPE="TITLE""Declaration Statement"). A named automatic object may not be destroyed before the end of its block nor may an automatic named object of a class with a constructor or a destructor with side effects be eliminated even if it appears to be unused. Similarly, a global object of a class with a constructor or a destructor with side effects may not be eliminated even if it appears to be unused. Static objects are initialized and destroyed as described in IDREF="28875" TYPE="TITLE""Start and Termination" and IDREF="10996" TYPE="TITLE""Declaration Statement". Some objects are not associated with names; see IDREF="16762" TYPE="TITLE""New" and IDREF="18236" TYPE="TITLE""Temporary Objects". All global objects have storage class ID="ch3101"static. Local objects and class members can be given static storage class by explicit use of the ID="ch3102"ID="ch3103"ID="ch3104"ID="ch3105"static storage class specifier (IDREF="12029" TYPE="TITLE""Storage Class Specifiers"). LBL="" HELPID=""ID="28323"TypesThere are two kinds of types: fundamental types and derived types. LBL="" HELPID=""ID="27802"Fundamental TypesID="ch3106"ID="ch3107"ID="ch3108"There are several fundamental types. The standard header <limits.h> specifies the largest and smallest values of each for an implementation. ID="ch3109"ID="ch3110"ID="ch3111"ID="ch3112"Objects declared as characters (char) are large enough to store any member of the implementation's basic character set. If a character from this set is stored in a character variable, its value is equivalent to the integer code of that character. Characters may be explicitly declared ID="ch3113"ID="ch3114"unsigned or signed. Plain ID="ch3115"ID="ch3116"char, signed char, and unsigned char are three distinct types. A char, a signed char, and an unsigned char consume the same amount of space. Up to three sizes of integer, declared short int, ID="ch3117"ID="ch3118"ID="ch3119"int, and long int are available. Longer integers provide no less storage than shorter ones, but the implementation may make either short integers or long integers, or both, equivalent to plain integers. Plain integers have the natural size suggested by the machine architecture; the other sizes are provided to meet special needs. ID="ch3120"ID="ch3121"For each of the types signed char, short, int, and long, there exists a corresponding unsigned type, which occupies the same amount of storage and has the same alignment requirements. An ID="ch3122"alignment requirement is an implementation-dependent restriction on the value of a pointer to an object of a given type (IDREF="14761" TYPE="TITLE""Explicit Type Conversion"). ID="ch3123"Unsigned integers, declared unsigned, obey the laws of arithmetic modulo 2n where n is the number of bits in the representation. This implies that unsigned arithmetic does not overflow. ID="ch3124"There are three floating types: ID="ch3125"float, ID="ch3126"double, and ID="ch3127"long double. The type double provides no less precision than float, and the type longdouble provides no less precision than double. An implementation will define the characteristics of the fundamental floating point types in the standard header ID="ch3128"<float.h>. Types char, int of all sizes, and enumerations (IDREF="14398" TYPE="TITLE""Enumeration Declarations") are collectively called integral types. ID="ch3129"Integral and floating types are collectively called arithmetic types.ID="ch3130"The void type specifies an empty set of values. It is used as the return type for functions that do not return a value. No object of type ID="ch3131"void may be declared. Any expression may be explicitly converted to type void (IDREF="14761" TYPE="TITLE""Explicit Type Conversion"); the resulting expression may be used only as an expression statement (IDREF="30774" TYPE="TITLE""Expression Statement"), as the left operand of a comma expression (IDREF="22590" TYPE="TITLE""Comma Operator"), or as a second or third operand of ?: (IDREF="36232" TYPE="TITLE""Conditional Operator"). LBL="" HELPID=""Derived TypesID="ch3132"There is a conceptually infinite number of derived types constructed from the fundamental types in the following ways: arrays of objects of a given type, ID="ch3133"IDREF="30659" TYPE="TITLE""Arrays"; ID="ch3134"functions, which take arguments of given types and return objects of a given type, IDREF="34712" TYPE="TITLE""Functions"; pointers to objects or functions of a given type, ID="ch3135"IDREF="13366" TYPE="TITLE""Pointers"; references to objects or functions of a given type, ID="ch3136"IDREF="22652" TYPE="TITLE""References"; constants, which are values of a given type, ID="ch3137"IDREF="24962" TYPE="TITLE""Type Specifiers"; classes containing a sequence of objects of various types (ID="ch3138"IDREF="38144" TYPE="TITLE"Chapter 9, "Classes"), a set of functions for manipulating these objects (IDREF="34481" TYPE="TITLE""Member Functions"), and a set of restrictions on the access to these objects and functions, IDREF="40678" TYPE="TITLE"Chapter 11, "Member Access Control"; structures, which are classes without default access restrictions, ID="ch3139"ID="ch3140"IDREF="40678" TYPE="TITLE"Chapter 11, "Member Access Control"; unions, which are structures capable of containing objects of different types at different times, ID="ch3141"IDREF="32100" TYPE="TITLE""Unions"; ID="ch3142"ID="ch3143"pointers to class members, which identify members of a given type within objects of a given class, IDREF="10856" TYPE="TITLE""Pointers to Members". In general, these methods of constructing objects can be applied recursively; restrictions are mentioned in IDREF="13366" TYPE="TITLE""Pointers", IDREF="30659" TYPE="TITLE""Arrays", IDREF="34712" TYPE="TITLE""Functions", and IDREF="22652" TYPE="TITLE""References". ID="ch3144"A pointer to objects of a type T is referred to as a "pointer to T". For example, a pointer to an object of type int is referred to as "pointer to int"  and a pointer to an object of class X is called a "pointer to X." Objects of type ID="ch3145"ID="ch3146"void* (pointer to void), const void*, and volatile void* can be used to point to objects of unknown type. A void* must have enough bits to hold any object pointer. Except for pointers to static members, text referring to "pointers" does not apply to pointers to members. LBL="" HELPID=""Type NamesID="ch3147"ID="ch3148"ID="ch3149"Fundamental and derived types can be given names by the typedef mechanism (IDREF="13818" TYPE="TITLE""The typedef Specifier"), and families of types and functions can be specified and named by the template mechanism (IDREF="18442" TYPE="TITLE"Chapter 14, "Templates"). LBL="" HELPID=""ID="23683"LvaluesID="ch3150"ID="ch3151"ID="ch3152"An object is a region of storage; an lvalue is an expression referring to an object or function. An obvious example of an lvalue expression is the name of an object. Some operators yield lvalues. For example, if E is an expression of pointer type, then *E is an lvalue expression referring to the object to which E points. The name "lvalue" comes from the assignment expression E1 = E2 in which the left operand E1 must be an lvalue expression. The discussion of each operator in IDREF="28885" TYPE="TITLE"Chapter 5, "Expressions", indicates whether it expects lvalue operands and whether it yields an lvalue. An lvalue is modifiable if it is not a function name, an array name, or const. LBL="4"ID="31385"Standard ConversionsThis chapter contains the following subsections:IDREF="37419" TYPE="TITLE""Integral Promotions"IDREF="34525" TYPE="TITLE""Integral Conversions"IDREF="35201" TYPE="TITLE""Float and Double"IDREF="31942" TYPE="TITLE""Floating and Integral"IDREF="13939" TYPE="TITLE""Arithmetic Conversions"IDREF="25158" TYPE="TITLE""Pointer Conversions"IDREF="29340" TYPE="TITLE""Reference Conversions"IDREF="23730" TYPE="TITLE""Pointers to Members"Some operators may, depending on their operands, cause conversion of the value of an operand from one type to another. This section summarizes the conversions demanded by most ordinary operators and explains the result to be expected from such conversions; it will be supplemented as required by the discussion of each operator. These conversions are also used in initialization (ID="ch41"ID="ch42"IDREF="23366" TYPE="TITLE""Initializers", IDREF="19032" TYPE="TITLE""References", IDREF="34465" TYPE="TITLE""Copying Class Objects", IDREF="21970" TYPE="TITLE""Constructors"). IDREF="31355" TYPE="TITLE""Conversions" and IDREF="38679" TYPE="TITLE""Argument Matching" describe user-defined conversions and their interaction with standard conversions. The result of a conversion is an ID="ch43"lvalue only if the result is a reference (IDREF="22652" TYPE="TITLE""References"). LBL="" HELPID=""ID="37419"Integral PromotionsID="ch44"ID="ch45"A char, a short int, enumerator, object of enumeration type (IDREF="14398" TYPE="TITLE""Enumeration Declarations"), or an int bit-field (IDREF="37305" TYPE="TITLE""Bit-Fields") (in both their signed and unsigned varieties) may be used wherever an integer may be used. If an int can represent all the values of the original type, the value is converted to int; otherwise it is converted to unsigned int. This process is called integral promotion. LBL="" HELPID=""ID="34525"Integral ConversionsID="ch46"When an integer is converted to an unsigned type, the value is the least unsigned integer congruent to the signed integer (modulo ID="ch47"2n where n is the number of bits used to represent the unsigned type). In a two's complement representation, this conversion is conceptual and there is no change in the bit pattern. When an integer is converted to a signed type, the value is unchanged if it can be represented in the new type; otherwise the value is implementation dependent. ID="ch48"ID="ch49"LBL="" HELPID=""ID="35201"Float and DoubleID="ch410"Single-precision floating point arithmetic may be used for float expressions. When a less precise floating value is converted to an equally or more precise floating type, the value is unchanged. When a more precise floating value is converted to a less precise floating type and the value is within representable range, the result may be either the next higher or the next lower representable value. If the result is out of range, the behavior is undefined. ID="ch411"ID="ch412"ID="ch413"LBL="" HELPID=""ID="31942"Floating and IntegralID="ch414"Conversion of a floating value to an integral type truncates; that is, the fractional part is discarded. Such conversions are machine dependent; for example, the direction of truncation of negative numbers varies from machine to machine. The result is undefined if the value cannot be represented in the integral type. ID="ch415"Conversions of integral values to floating type are as mathematically correct as the hardware allows. Loss of precision occurs if an integral value cannot be represented exactly as a value of the floating type. ID="ch416"ID="ch417"LBL="" HELPID=""ID="13939"Arithmetic ConversionsID="ch418"ID="ch419"ID="ch420"ID="ch421"Many operators cause conversions and yield result types in a similar way. This pattern will be called the "usual arithmetic conversions." If either operand is of type long double, the other is converted to long double. Otherwise, if either operand is double, the other is converted to double. Otherwise, if either operand is float, the other is converted to float. Otherwise, the integral promotions (IDREF="37419" TYPE="TITLE""Integral Promotions") are performed on both operands. Then, if either operand is unsigned long the other is converted to unsigned long. Otherwise, if one operand is a long int and the other unsigned int, then if a long int can represent all the values of an unsigned int, the unsigned int is converted to a long int; otherwise both operands are converted to unsigned long int. Otherwise, if either operand is long, the other is converted to long. Otherwise, if either operand is unsigned, the other is converted to unsigned. Otherwise, both operands are int. LBL="" HELPID=""ID="25158"Pointer ConversionsID="ch422"The following conversions may be performed wherever pointers (IDREF="13366" TYPE="TITLE""Pointers") are assigned, initialized, compared, or otherwise used: A constant expression (ID="ch423"ID="ch424"IDREF="27851" TYPE="TITLE""Constant Expressions") that evaluates to zero is converted to a pointer, commonly called the null pointer. It is guaranteed that this value will produce a pointer distinguishable from a pointer to any object or function. A pointer to any non-ID="ch425"const and non-volatile object type may be converted to a void*. A pointer to function may be converted to a void* provided a void* has sufficient bits to hold it. A pointer to a class may be converted to a pointer to an accessible base class of that class (ID="ch426"ID="ch427"IDREF="37638" TYPE="TITLE"Chapter 10, "Derived Classes") provided the conversion is unambiguous (IDREF="19879" TYPE="TITLE""Multiple Base Classes"); a base class is accessible if its public members are accessible (IDREF="38800" TYPE="TITLE""Access Specifiers"). The result of the conversion is a pointer to the base class sub-object of the derived class object. The null pointer (0) is converted into itself. ID="ch428"ID="ch429"ID="ch430"An expression with type "array of T" may be converted to a pointer to the initial element of the array. ID="ch431"An expression with type "function returning T" is converted to "pointer to function returning T" except when used as the operand of the address-of operator ID="ch432"& or the function call operator(). LBL="" HELPID=""ID="29340"Reference ConversionsID="ch433"The following conversion may be performed wherever references (IDREF="22652" TYPE="TITLE""References") are initialized (including argument passing (IDREF="27725" TYPE="TITLE""Function Call") and function value return (IDREF="11995" TYPE="TITLE""The return Statement")) or otherwise used: A reference to a class may be converted to a reference to an accessible base class (ID="ch434"ID="ch435"IDREF="37638" TYPE="TITLE"Chapter 10, "Derived Classes", IDREF="38800" TYPE="TITLE""Access Specifiers") of that class (IDREF="19032" TYPE="TITLE""References") provided this conversion can be done unambiguously (IDREF="23630" TYPE="TITLE""Ambiguities"). The result of the conversion is a reference to the base class sub-object of the derived class object. LBL="" HELPID=""ID="23730"Pointers to MembersID="ch436"The following conversion may be performed wherever pointers to members (IDREF="10856" TYPE="TITLE""Pointers to Members") are initialized, assigned, compared, or otherwise used: A constant expression (ID="ch437"ID="ch438"IDREF="27851" TYPE="TITLE""Constant Expressions") that evaluates to zero is converted to a pointer to member. It is guaranteed that this value will produce a pointer to member distinguishable from any other pointer to member. A pointer to a member of a class may be converted to a pointer to member of a class derived from that class provided the (inverse) conversion from the derived class to the base class pointer is accessible (ID="ch439"ID="ch440"IDREF="38800" TYPE="TITLE""Access Specifiers") and provided this conversion can be done unambiguously (IDREF="23630" TYPE="TITLE""Ambiguities"). The rule for conversion of pointers to members (from pointer to member of base to pointer to member of derived) appears inverted compared to the rule for pointers to objects (from pointer to derived to pointer to base) (IDREF="25158" TYPE="TITLE""Pointer Conversions", IDREF="37638" TYPE="TITLE"Chapter 10, "Derived Classes"). This inversion is necessary to ensure type safety.Note that a pointer to member is not a pointer to object or a pointer to function and the rules for conversions of such pointers do not apply to pointers to members. In particular, a pointer to member cannot be converted to a ID="ch441"void*. LBL="5"ID="28885"ExpressionsThis chapter contains the following subsections:IDREF="36093" TYPE="TITLE""Primary Expressions"IDREF="36651" TYPE="TITLE""Postfix Expressions"IDREF="16145" TYPE="TITLE""Unary Operators"IDREF="14761" TYPE="TITLE""Explicit Type Conversion"IDREF="19694" TYPE="TITLE""Pointer - to - Member Operators"IDREF="30109" TYPE="TITLE""Multiplicative Operators"IDREF="29047" TYPE="TITLE""Additive Operators"IDREF="17389" TYPE="TITLE""Shift Operators"IDREF="33364" TYPE="TITLE""Relational Operators"IDREF="33739" TYPE="TITLE""Equality Operators"IDREF="24401" TYPE="TITLE""Bitwise AND Operator"IDREF="11057" TYPE="TITLE""Bitwise Exclusive-OR Operator"IDREF="29098" TYPE="TITLE""Bitwise Inclusive-OR Operator"IDREF="36772" TYPE="TITLE""Logical AND Operator"IDREF="21104" TYPE="TITLE""Logical OR Operator"IDREF="36232" TYPE="TITLE""Conditional Operator"IDREF="32408" TYPE="TITLE""Assignment Operators"IDREF="22590" TYPE="TITLE""Comma Operator"IDREF="27851" TYPE="TITLE""Constant Expressions"This chapter defines the syntax, order of evaluation, and meaning of expressions. . An expression is a sequence of operators and operands that specifies a computation. An expression may result in a value and may cause side effects. ID="ch51"ID="ch52"Operators can be overloaded, that is, given meaning when applied to expressions of class type (IDREF="38144" TYPE="TITLE"Chapter 9, "Classes"). Uses of overloaded operators are transformed into function calls as described in IDREF="39747" TYPE="TITLE""Overloaded Operators". Overloaded operators obey the rules for syntax specified in this section, but the requirements of operand type, lvalue, and evaluation order are replaced by the rules for function call. Relations between operators, such as ++a meaning a+=1, are not guaranteed for overloaded operators (IDREF="39747" TYPE="TITLE""Overloaded Operators"). This section defines the operators when applied to types for which they have not been overloaded. Operator overloading cannot modify the rules for operators applied to types for which they are defined by the language itself. ID="ch53"ID="ch54"ID="ch55"The order of evaluation of subexpressions is determined by the precedence and grouping of the operators. The usual mathematical rules for associativity and commutativity of operators may be applied only where the operators really are associative and commutative. Except where noted, the order of evaluation of operands of individual operators is undefined. In particular, if a value is modified twice in an expression, the result of the expression is undefined except where an ordering is guaranteed by the operators involved. For example, ID="ch56"i = v[i++];      // the value of 'i' is undefined
i=7,i++,i++;     // 'i' becomes 9 
ID="ch57"The handling of overflow and divide check in expression evaluation is implementation dependent. Most existing implementations of C++ ignore integer overflows. Treatment of division by zero and all floating-point exceptions vary among machines, and is usually adjustable by a library function. ID="ch58"ID="ch59"ID="ch510"ID="ch511"Except where noted, operands of types ID="ch512"ID="ch513"ID="ch514"const T, volatile T, T& , const T&, and volatile T& can be used as if they were of the plain type T. Similarly, except where noted, operands of type T*const and T*volatile can be used as if they were of the plain type T*. Similarly, a plain T can be used where a volatileT or a constT is required. These rules apply in combination so that, except where noted, a constT*volatile can be used where a T* is required. Such uses do not count as standard conversions when considering overloading resolution (IDREF="38679" TYPE="TITLE""Argument Matching"). ID="ch515"ID="ch516"If an expression has the type "reference to T" (IDREF="22652" TYPE="TITLE""References"), the value of the expression is the object of type "T" denoted by the reference. The expression is an lvalue. A reference can be thought of as a name of an object. ID="ch517"ID="ch518"ID="ch519"User-defined conversions of class objects to and from fundamental types, pointers, and so on, can be defined (IDREF="31355" TYPE="TITLE""Conversions"). If unambiguous (IDREF="38679" TYPE="TITLE""Argument Matching"), such conversions may be applied by the compiler wherever a class object appears as an operand of an operator, as an initializer (IDREF="23366" TYPE="TITLE""Initializers"), as the controlling expression in a selection (IDREF="28691" TYPE="TITLE""Selection Statements") or iteration (IDREF="28413" TYPE="TITLE""Iteration Statements") statement, as a function return value (IDREF="11995" TYPE="TITLE""The return Statement"), or as a function argument (IDREF="27725" TYPE="TITLE""Function Call"). LBL="" HELPID=""ID="36093"Primary ExpressionsID="ch520"Primary expressions are literals, names, and names qualified by the scope resolution operator ::. primary-expression:literalthis:: identifier:: operator-function-name:: qualified-name( expression )nameID="ch521"ID="ch522"A ID="ch523"ID="ch524"literal is a primary expression. Its type depends on its form (IDREF="32709" TYPE="TITLE""Literals"). ID="ch525"In the body of a non-static member function (IDREF="34481" TYPE="TITLE""Member Functions"), the keyword this names a pointer to the object for which the function was invoked. The keyword this cannot be used outside a class member function body. ID="ch526"ID="ch527"The operator :: followed by an identifier, a qualified-name, or an operator-function-name is a primary expression. Its type is specified by the declaration of the identifier, name, or operator-function-name. The result is the identifier, name, or operator-function-name. The result is an lvalue if the identifier is of that class. The identifier or operator-function-name must be of file scope. Use of :: allows a type, an object, a function, or an enumerator to be referred to even if its identifier has been hidden (IDREF="24244" TYPE="TITLE""Scopes"). A parenthesized expression is a primary expression whose type and value are identical to those of the unadorned expression. The presence of parentheses does not affect whether the expression is an ID="ch528"lvalue. ID="ch529"A name is a restricted form of a primary-expression that can appear after . and -> (IDREF="21265" TYPE="TITLE""Class Member Access"): ID="ch530"name:identifieroperator-function-nameconversion-function-nameclass-namequalified-nameID="ch531"An identifier is a name provided it has been suitably declared (IDREF="35031" TYPE="TITLE"Chapter 7, "Declarations"). For operator-function-names, see IDREF="39747" TYPE="TITLE""Overloaded Operators". For conversion-function-names, see IDREF="37211" TYPE="TITLE""Conversion Functions". A class-name prefixed by ~ denotes a destructor; see IDREF="29867" TYPE="TITLE""Destructors". ID="ch532"qualified-name:qualified-class-name :: name ID="ch533"ID="ch534"ID="ch535"A qualified-class-name (IDREF="24962" TYPE="TITLE""Type Specifiers") followed by :: and the name of a member of that class (IDREF="18270" TYPE="TITLE""Class Members"), or a member of a base of that class (IDREF="37638" TYPE="TITLE"Chapter 10, "Derived Classes"), is a ID="ch536"qualified-name; its type is the type of the member. The result is the member. Also the result is an lvalue if the member is of that class. The class-name may be hidden by a non-type name, in which case the class-name is still found and used. Where class-name ::class-name or class-name ::~class-name is used, the two class-names must refer to the same class; this notation names constructors (IDREF="21970" TYPE="TITLE""Constructors") and destructors (IDREF="29867" TYPE="TITLE""Destructors"), respectively. Multiply qualified names, such as N1::N2::N3::n, can be used to refer to nested types (IDREF="40624" TYPE="TITLE""Nested Class Declarations"). LBL="" HELPID=""ID="36651"Postfix ExpressionsID="ch537"Postfix expressions group left-to-right. postfix-expression:primary-expressionpostfix-expression [ expression ]postfix-expression ( expression-listopt )simple-type-name ( expression-listopt )postfix-expression . namepostfix-expression -> namepostfix-expression ++postfix-expression --ID="ch538"expression-list:assignment-expressionexpression-list , assignment-expressionLBL="" HELPID=""ID="22794"SubscriptingID="ch539"ID="ch540"A postfix expression followed by an expression in square brackets is a postfix expression. The intuitive meaning is that of a subscript. One of the expressions must have the type "pointer to T " and the other must be of integral type. The type of the result is "T." The expression E1[E2] is identical (by definition) to *((E1)+(E2)). See IDREF="16145" TYPE="TITLE""Unary Operators" and IDREF="29047" TYPE="TITLE""Additive Operators" for details of * and + and IDREF="30659" TYPE="TITLE""Arrays" for details of arrays. LBL="" HELPID=""ID="27725"Function CallA function call is a postfix expression followed by parentheses containing a possibly empty, comma-separated list of expressions which constitute the actual arguments to the function. The postfix expression must be of type "function returning ID="ch541"ID="ch542"ID="ch543"T," "pointer to function returning T," or "reference to function returning T," and the result of the function call is of type "T." ID="ch544"ID="ch545"When a function is called, each formal argument is initialized (IDREF="19032" TYPE="TITLE""References", IDREF="34465" TYPE="TITLE""Copying Class Objects", IDREF="21970" TYPE="TITLE""Constructors") with its actual argument. Standard (IDREF="31385" TYPE="TITLE"Chapter 4, "Standard Conversions") and user-defined (IDREF="31355" TYPE="TITLE""Conversions") conversions are performed. A function may change the values of its non-constant formal arguments, but these changes cannot affect the values of the actual arguments except where a formal argument is of a non-ID="ch546"ID="ch547"ID="ch548"ID="ch549"ID="ch550"ID="ch551"const reference type (IDREF="22652" TYPE="TITLE""References"). Where a formal argument is of reference type a temporary variable is introduced if needed (IDREF="24962" TYPE="TITLE""Type Specifiers", IDREF="32709" TYPE="TITLE""Literals", IDREF="38768" TYPE="TITLE""String Literals", IDREF="30659" TYPE="TITLE""Arrays", IDREF="18236" TYPE="TITLE""Temporary Objects"). In addition, it is possible to modify the values of non-constant objects through pointer arguments. ID="ch552"ID="ch553"A function may be declared to accept fewer arguments (by declaring default arguments IDREF="27816" TYPE="TITLE""Default Arguments") or more arguments (by using the ellipsis, (...) IDREF="34712" TYPE="TITLE""Functions") than are specified in the function definition (IDREF="20795" TYPE="TITLE""Function Definitions"). A function can be called only if a declaration of it is accessible from the scope of the call. This implies that, except where the ellipsis (...) is used, a formal argument is available for each actual argument. Any actual argument of type float for which there is no formal argument is converted to ID="ch554"double before the call; any of char, short, enumeration, or a bit-field type for which there is no formal argument are converted to int or unsigned by integral promotion (IDREF="37419" TYPE="TITLE""Integral Promotions"). An object of a class for which no formal argument is declared is passed as a data structure. ID="ch555"An object of a class for which a formal argument is declared is passed by initializing the formal argument with the actual argument by a constructor call before the function is entered (IDREF="18236" TYPE="TITLE""Temporary Objects", IDREF="34465" TYPE="TITLE""Copying Class Objects"). ID="ch556"The order of evaluation of arguments is undefined; take note that compilers differ. All side effects of argument expressions take effect before the function is entered. The order of evaluation of the postfix expression and the argument expression list is undefined. ID="ch557"ID="ch558"Recursive calls are permitted. ID="ch559"A function call is an lvalue only if the result type is a reference. LBL="" HELPID=""ID="35361"Explicit Type ConversionID="ch560"ID="ch561"ID="ch562"ID="ch563"A simple-type-name (IDREF="24962" TYPE="TITLE""Type Specifiers") followed by a parenthesized expression-list constructs a value of the specified type given by  the expression list. If the expression list specifies more than a single value, the type must be a class with a suitably declared constructor (IDREF="23366" TYPE="TITLE""Initializers", IDREF="21970" TYPE="TITLE""Constructors"). A simple-type-name (IDREF="24962" TYPE="TITLE""Type Specifiers") followed by a (empty) pair of parentheses constructs a value of the specified type. If the type is a class with a suitably declared constructor that constructor will be called; otherwise the result is an undefined value of the specified type. See also (ID="ch564"IDREF="14761" TYPE="TITLE""Explicit Type Conversion"). LBL="" HELPID=""ID="21265"Class Member AccessA postfix expression followed by a dot " . " followed by a name is a postfix expression. The first expression must be a class object, and the ID="ch565"ID="ch566"ID="ch567"ID="ch568"ID="ch569"ID="ch570"ID="ch571"ID="ch572"ID="ch573"name must name a member of that class. The result is the named member of the object, and it is an lvalue if the member is an lvalue. A postfix expression followed by an arrow ( -> ) followed by a name is a postfix expression. The first expression must be a pointer to a class object and the name must name a member of that class. The result is the named member of the object to which the pointer points and it is an lvalue if the member is an lvalue. Thus the expression E1->MOS is the same as (*E1).MOS. Note that "class objects" can be structures (IDREF="18270" TYPE="TITLE""Class Members") and unions (IDREF="32100" TYPE="TITLE""Unions"). Classes are discussed in IDREF="38144" TYPE="TITLE"Chapter 9, "Classes". LBL="" HELPID=""Increment and DecrementThe value obtained by applying a postfix ++ is the value of the operand. The operand must be a modifiable ID="ch574"ID="ch575"ID="ch576"lvalue. The type of the operand must be an arithmetic type or a pointer type. After the result is noted, the object is incremented by 1. The type of the result is the same as the type of the operand, but it is not an lvalue. See also IDREF="29047" TYPE="TITLE""Additive Operators" and IDREF="32408" TYPE="TITLE""Assignment Operators". ID="ch577"ID="ch578"The operand of postfix -- is decremented analogously to the postfix ++ operator. LBL="" HELPID=""ID="16145"Unary OperatorsExpressions with unary operators group right-to-left. ID="ch579"unary-expression:     postfix-expression     ++  unary-expression     --  unary-expression     unary-operator cast-expression     sizeof unary-expression     sizeof ( type-name )     allocation-expression     deallocation-expressionID="ch580"ID="ch581"ID="ch582"ID="ch583"ID="ch584"ID="ch585"ID="ch586"ID="ch587"ID="ch588"ID="ch589"ID="ch590"ID="ch591"ID="ch592"ID="ch593"ID="ch594"ID="ch595"ID="ch596"ID="ch597"ID="ch598"unary-operator: one of     *  &  +  -  ! ~  The unary * operator means indirection: the expression must be a pointer, and the result is an ID="ch599"ID="ch5100"lvalue referring to the object to which the expression points. If the type of the expression is "pointer to T," the type of the result is "T." ID="ch5101"The result of the unary & operator is a pointer to its operand. The operand must be a function, an lvalue, or a qualified-name. In the first two cases, if the type of the expression is "T," the type of the result is "pointer to T." In particular, the address of an object of type constT has type const T*; volatile is handled similarly. For a qualified-name, if the member is not static and of type "T" in class "C," the type of the result is "pointer to member of C of type T." For a static member of type ID="ch5102"T, the type is plain "pointer to T." The address of an overloaded function (ID="ch5103"IDREF="18871" TYPE="TITLE"Chapter 13, "Overloading") can be taken only in an initialization or an assignment where the left side uniquely determines which version of the overloaded function is referred to (IDREF="33093" TYPE="TITLE""Address of Overloaded Function" in Chapter 13). The operand of the unary + operator must have arithmetic or pointer type and the result is the value of the argument. Integral promotion is performed on integral operands. The type of the result is the type of the promoted operand. ID="ch5104"The operand of the unary-operator must have arithmetic type and the result is the negation of its operand. Integral promotion is performed on integral operands. The negative of an unsigned quantity is computed by subtracting its value from ID="ch5105"2n, where n is the number of bits in the promoted operand. The type of the result is the type of the promoted operand. The operand of the logical negation operator ! must have arithmetic type or be a pointer; its value is 1 if the value of its operand is 0 and 0 if the value of its operand is non-zero. The type of the result is ID="ch5106"int. The operand of ~  must have integral type; the result is the one's complement of its operand. Integral promotions are performed. The type of the result is the type of the promoted operand. ID="ch5107"LBL="" HELPID=""Increment and DecrementThe operand of prefix ++ is incremented by 1 . The operand must be a modifiable ID="ch5108"ID="ch5109"lvalue. The type of the operand must be an arithmetic type or a pointer type. The value is the new value of the operand; it is an lvalue. The expression ++x is equivalent to x+=1. See the discussions of addition (ID="ch5110"IDREF="29047" TYPE="TITLE""Additive Operators") and assignment operators (IDREF="32408" TYPE="TITLE""Assignment Operators") for information on conversions. The operand of prefix -- is decremented analogously to the prefix ID="ch5111"++ operator. LBL="" HELPID=""ID="39049"SizeofID="ch5112"The sizeof operator yields the size, in bytes, of its operand. The operand is either an expression, which is not evaluated, or a parenthesized type name. The ID="ch5113"ID="ch5114"sizeof operator may not be applied to a function, a bit-field, an undefined class, the type void, or an array with an unspecified dimension. A byte is undefined by the language except in terms of the value of sizeof; sizeof(char) is 1. ID="ch5115"When applied to a reference, the result is the size of the referenced object. When applied to a clas, the result is the number of bytes in an object of that class including any padding required for placing such objects in an array. The size of any class or class object is larger than zero. When applied to an array, the result is the total number of bytes in the array. This implies that the size of an array of ID="ch5116"ID="ch5117"n elements is n times the size of an element. The sizeof operator may be applied to a pointer to a function, but not to a function. The result is a constant of type size_t, an implementation-dependent unsigned integral type defined in the standard header ID="ch5118"ID="ch5119"<stddef.h>. ID="ch5120"ID="ch5121"LBL="" HELPID=""ID="16762"NewID="ch5122"ID="ch5123"ID="ch5124"ID="ch5125"ID="ch5126"The new operator attempts to create an object of the type-name (IDREF="32393" TYPE="TITLE""Type Names") to which it is applied. This type must be an object type; functions cannot be allocated this way, though pointers to functions can. ID="ch5127"allocation-expression:::opt new placementoptnew-type-namenew-initializeropt::opt new placementopt ( type-name ) new-initializeroptID="ch5128"ID="ch5129"placement:( expression-list )  ID="ch5130"new-type-name:type-specifier-list new-declaratoroptnew-declarator:* cv-qualifier-listopt new-declaratoroptclass-name :: * cv-qualifier-listopt new-declaratoroptnew-declaratoropt [ expression ]new-initializer:( initializer-listopt ) ID="ch5131"The lifetime of an object created by new is not restricted to the scope in which it is created. The new operator returns a pointer to the object created. When that object is an array, a pointer to its initial element is returned. For example, both ID="ch5132"new int and new int[10] return an int* and the type of new int[i][10] is int (*)[10]. Where an array type (IDREF="30659" TYPE="TITLE""Arrays") is specified all array dimensions but the first must be constant expressions (IDREF="27851" TYPE="TITLE""Constant Expressions") with positive values. The first array dimension can be a general ID="ch5133"expression even when the type-name is used (despite the general restriction of array dimensions in type-names to constant-expressions (IDREF="27851" TYPE="TITLE""Constant Expressions")). This implies that an operator new() can be called with the argument zero. In this case, a pointer to an object is returned. Repeated such calls return pointers to distinct objects. ID="ch5134"The type-specifier-list may not contain const, volatile, class declarations, or enumeration declarations. The new operator will call the function operator new() to obtain storage (IDREF="36583" TYPE="TITLE""Free Store"). A first argument of sizeof(T) is supplied when allocating an object of type T. The ID="ch5135"placement syntax can be used to supply additional arguments. For example, new T results in a call of operator new(sizeof(T)) and new(2,f) T results in a call operator new(sizeof(T),2,f). The placement syntax can be used only provided an operator new() with suitable argument types (IDREF="38679" TYPE="TITLE""Argument Matching") has been declared. ID="ch5136"When an object of a non-class type (including arrays of class objects) is created with operator new, the global ::operator new() is used. When an object of a class ID="ch5137"T is created with operator new , T::operator new() is used if it exists (using the usual lookup rules for finding members of a class and its base classes; IDREF="23630" TYPE="TITLE""Ambiguities"); otherwise the global ::operator new() is used. Using ::new ensures that the global ::operator new() is used even if T::operator new() exists. ID="ch5138"ID="ch5139"A new-initializer may be supplied in an allocation-expression. For objects of classes with a constructor (IDREF="21970" TYPE="TITLE""Constructors") this argument list will be used in a constructor call; otherwise the initializer must be of the form (expression ) or (). If present, the expression will be used to initialize the object; if not, the object will start out with an undefined value. ID="ch5140"ID="ch5141"ID="ch5142"ID="ch5143"If a class has a constructor an object of that class can be created by new only if suitable arguments are provided or if the class has a default constructor (IDREF="21970" TYPE="TITLE""Constructors"). Whether ID="ch5144"operator new allocates the memory itself or leaves that up to the constructor when creating an object of a class with a constructor is implementation dependent. Access and ambiguity control are done for both operator new() and the constructor; see IDREF="10620" TYPE="TITLE"Chapter 12, "Special Member Functions". ID="ch5145"No initializers can be specified for arrays. Arrays of objects of a class with constructors can be created by operator ID="ch5146"ID="ch5147"new only if the class has a default constructor (IDREF="21970" TYPE="TITLE""Constructors"). In that case, the default constructor will be called for each element of the array. Initialization is done only if the value returned by operator new() is non-zero. If the value returned by the operator new() is 0 (the null pointer) the value of the expression is 0. ID="ch5148"The order of evaluation of the call to an operator new() to get memory and the evaluation of arguments to constructors is undefined. It is also undefined if the arguments to a constructor are evaluated if ID="ch5149"operator new() returns 0. In a new-type-name used as the operand for new, parentheses may not be used. This implies that ID="ch5150"new int(*[10])();       // erroris an error because the binding is (new int) (*[10])();    // errorObjects of general type can be expressed using the explicitly parenthesized version of the new operator. For example, new (int (*[10])());allocates an array of  pointers to functions (taking no argument and returning int). The new-type-name in an allocation-expression is the longest possible sequence of new-declarators. This prevents ambiguities between declarator operators &, *, [], and their expression counterparts. For example, new int*i;       // syntax error: parsed as '(new int*) i'
                 //               not as '(new int)*i'The * is the pointer declarator and not the multiplication operator. LBL="" HELPID=""ID="42326"DeleteID="ch5151"ID="ch5152"The delete operator destroys an object created by the new operator. ID="ch5153"deallocation-expression:::opt delete cast-expression::opt delete [ ] cast-expressionThe result has type void. The operand of delete must be a pointer returned by new. The effect of applying ID="ch5154"delete to a pointer not obtained from the new operator without a placement specification is undefined and usually harmful. Deleting a pointer with the value zero, however, is guaranteed to be harmless. ID="ch5155"ID="ch5156"The effect of accessing a deleted object is undefined and the deletion of an object may change its value. Furthermore, if the expression denoting the object in a delete expression is a modifiable ID="ch5157"lvalue, its value is undefined after the deletion. A pointer to constant cannot be deleted. ID="ch5158"The delete operator will invoke the destructor (if any, IDREF="29867" TYPE="TITLE""Destructors") for the object pointed to. To free the storage pointed to, the delete operator will call the function ID="ch5159"ID="ch5160"operatordelete(); see IDREF="36583" TYPE="TITLE""Free Store". For objects of a non-class type (including arrays of class objects), the global ::operatordelete() is used. For an object of a class T, T::operator delete() is used if it exists (using the usual lookup rules for finding members of a class and its base classes; IDREF="23630" TYPE="TITLE""Ambiguities"); otherwise the global ::operator delete() is used. Using ::delete ensures that the global ::operator delete() is used even if T::operator delete() exists. ID="ch5161"The form delete [ ] cast-expressionis used to delete arrays. The expression points to an array. The destructors (if any) for the objects pointed to will be invoked. ID="ch5162"The effect of deleting an array with the plain delete syntax is undefined, as is deleting an individual object with the delete[] syntax. LBL="" HELPID=""ID="14761"Explicit Type ConversionAn explicit type conversion can be expressed using either functional notation (IDREF="35361" TYPE="TITLE""Explicit Type Conversion") or the cast notation. ID="ch5163"cast-expression:unary-expression( type-name ) cast-expressionID="ch5164"The cast notation is needed to express conversion to a type that does not have a simple-type-name. ID="ch5165"Types may not be defined in casts. Any type conversion not mentioned below and not explicitly defined by the user (IDREF="31355" TYPE="TITLE""Conversions") is an error. Any type that can be converted to another by a standard conversion (IDREF="31385" TYPE="TITLE"Chapter 4, "Standard Conversions") can also be converted by explicit conversion and the meaning is the same. A pointer may be explicitly converted to any integral type large enough to hold it. The mapping function is implementation dependent, but is intended to be unsurprising to those who know the addressing structure of the underlying machine. ID="ch5166"ID="ch5167"A value of integral type may be explicitly converted to a pointer. A pointer converted to an integer of sufficient size (if any such exists on the implementation) and back to the same pointer type will have its original value; mappings between pointers and integers are otherwise implementation dependent. ID="ch5168"ID="ch5169"ID="ch5170"A pointer to one object type may be explicitly converted to a pointer to another object type (subject to the restrictions mentioned in this section). The resulting pointer may cause addressing exceptions on use if the subject pointer does not refer to an object suitably aligned in storage. It is guaranteed that a pointer to an object of a given size may be converted to a pointer to an object of the same or smaller size and back again without change. Different machines may differ in the number of bits in pointers and in alignment requirements for objects. Aggregates are aligned on the strictest boundary required by any of their constituents. A ID="ch5171"ID="ch5172"ID="ch5173"ID="ch5174"void* is considered a pointer to object type. ID="ch5175"ID="ch5176"A pointer to a class B may be explicitly converted to a pointer to a class D that has B as a direct or indirect base class if an unambiguous conversion from D to B exists (IDREF="25158" TYPE="TITLE""Pointer Conversions", IDREF="23630" TYPE="TITLE""Ambiguities") and if B is not a virtual base class (IDREF="19879" TYPE="TITLE""Multiple Base Classes"). Such a cast from a base to a derived class assumes that the object of the base class is a sub-object of an object of the derived class; the resulting pointer points to the enclosing object of the derived class. If the object of the base class is not a sub-object of an object of the derived class, the cast may cause an exception. The null pointer (0) is converted into itself. ID="ch5177"A yet undefined class may be used in a pointer cast, in which case no assumptions will be made about class lattices (IDREF="19879" TYPE="TITLE""Multiple Base Classes"). ID="ch5178"An object may be explicitly converted to a reference type X& if a pointer to that object may be explicitly converted to an X*. Constructors or conversion functions are not called as the result of a cast to a reference. Conversion of a reference to a base class to a reference to a derived class is handled similarly to the conversion of a pointer to a base class to a pointer to a derived class with respect to ambiguity, virtual classes, and so on. ID="ch5179"The result of a cast to a reference type is an lvalue; the results of other casts are not. Operations performed on the result of a pointer or reference cast refer to the same object as the original (uncast) expression. ID="ch5180"ID="ch5181"A pointer to function may be explicitly converted to a pointer to an object type provided the object pointer type has enough bits to hold the function pointer. A pointer to an object type may be explicitly converted to a pointer to function provided the function pointer type has enough bits to hold the object pointer. In both cases, use of the resulting pointer may cause addressing exceptions, or worse, if the subject pointer does not refer to suitable storage. ID="ch5182"A pointer to a function may be explicitly converted to a pointer to a function of a different type. The effect of calling a function through a pointer to a function type that differs from the type used in the definition of the function is undefined. See also ID="ch5183"IDREF="25158" TYPE="TITLE""Pointer Conversions". ID="ch5184"An object or a value may be converted to a class object (only) if an appropriate constructor or conversion operator has been declared (IDREF="31355" TYPE="TITLE""Conversions"). ID="ch5185"A pointer to member may be explicitly converted into a different pointer to member type when the two types are both pointers to members of the same class or when the two types are pointers to member functions of classes one of which is unambiguously derived from the other (IDREF="23730" TYPE="TITLE""Pointers to Members"). ID="ch5186"A pointer to an object of a const type can be cast into a pointer to a non-const type. The resulting pointer will refer to the original object. An object of a const type or a reference to an object of a const type can be cast into a reference to a non- const type. The resulting reference will refer to the original object. The result of attempting to modify that object through such a pointer or reference will either cause an addressing exception or be the same as if the original pointer or reference had referred a non- const object. It is implementation dependent whether the addressing exception occurs. ID="ch5187"ID="ch5188"A pointer to an object of a volatile type can be cast into a pointer to a non- volatile type. The resulting pointer will refer to the original object. An object of a volatile type or a reference to an object of a volatile type can be cast into a reference to a non-volatile type. LBL="" HELPID=""ID="19694"Pointer - to - Member OperatorsID="ch5189"ID="ch5190"ID="ch5191"ID="ch5192"ID="ch5193"The pointer-to-member operators ->* and .* group left-to-right. ID="ch5194"pm-expression:cast-expressionpm-expression .* cast-expressionpm-expression ->* cast-expressionThe binary operator .* binds its second operand, which must be of type "pointer to member of class T" to its first operand, which must be of class T or of a class of which T is an unambiguous and accessible base class. The result is an object or a function of the type specified by the second operand. The binary operator ->* binds its second operand, which must be of type "pointer to member of T" to its first operand, which must be of type "pointer to T" or "pointer to a class of which T is an unambiguous and accessible base class." The result is an object or a function of the type specified by the second operand. ID="ch5195"If the result of .* or ->* is a function, then that result can be used only as the operand for the function call operator (). For example, (ptr_to_obj->*ptr_to_mfct)(10);calls the member function denoted by ptr_to_mfct for the object pointed to by ptr_to_obj. The result of an" .*" expression or a "->*" expression is an lvalue if its second operand is an lvalue. LBL="" HELPID=""ID="30109"Multiplicative OperatorsID="ch5196"The multiplicative operators *, /, and % group left-to-right. ID="ch5197"multiplicative-expression:     pm-expression     multiplicative-expression* pm-expression     multiplicative-expression/ pm-expression     multiplicative-expression% pm-expressionID="ch5198"ID="ch5199"ID="ch5200"ID="ch5201"ID="ch5202"ID="ch5203"ID="ch5204"The operands of * and / must have arithmetic type; the operands of % must have integral type. The usual arithmetic conversions (IDREF="13939" TYPE="TITLE""Arithmetic Conversions") are performed on the operands and determine the type of the result. The binary * operator indicates multiplication.The binary / operator yields the quotient, and the binary % operator yields the remainder from the division of the first expression by the second. If the second operand of ID="ch5205"/ or % is 0 the result is undefined; otherwise (a/b)*b + a%b is equal to a. If both operands are non-negative then the remainder is non-negative; if not, the sign of the remainder is implementation dependent.ID="ch5206"ID="ch5207"LBL="" HELPID=""ID="29047"Additive OperatorsID="ch5208"The "additive operators" + and - group left-to-right. The usual arithmetic conversions (IDREF="13939" TYPE="TITLE""Arithmetic Conversions") are performed for operands of arithmetic type. ID="ch5209"additive-expression:     multiplicative-expression     additive-expression + multiplicative-expression     additive-expression - multiplicative-expressionID="ch5210"ID="ch5211"ID="ch5212"ID="ch5213"The operands must be of arithmetic or pointer type. The result of the + operator is the sum of the operands. A pointer to an object in an array and a value of any integral type may be added. The result is a pointer of the same type as the original pointer, which points to another object in the same array, appropriately offset from the original object. Thus if ID="ch5214"ID="ch5215"ID="ch5216"ID="ch5217"P is a pointer to an object in an array, the expression P+1 is a pointer to the next object in the array. If the resulting pointer points outside the bounds of the array, except at the first location beyond the high end of the array, the result is undefined. ID="ch5218"ID="ch5219"The result of the - operator is the difference of the operands. A value of any integral type may be subtracted from a pointer, and then the same conversions apply as for addition. No further type combinations are allowed for pointers. If two pointers to objects of the same type are subtracted, the result is a signed integral value representing the number of objects separating the pointed-to objects. Pointers to successive elements of an array differ by 1. The type of the result is implementation dependent, but is defined as ID="ch5220"ID="ch5221"ID="ch5222"ptrdiff_t in the standard header <stddef.h>. The value is undefined unless the pointers point to elements of the same array; however, if ID="ch5223"ID="ch5224"P points to the last element of an array then (P+1)-1 is P. LBL="" HELPID=""ID="17389"Shift OperatorsID="ch5225"ID="ch5226"ID="ch5227"ID="ch5228"The shift operators << and >> group left-to-right. ID="ch5229"shift-expression:additive-expressionshift-expression << additive-expressionshift-expression >> additive-expressionID="ch5230"ID="ch5231"ID="ch5232"ID="ch5233"The operands must be of integral type and integral promotions are performed. The type of the result is that of the promoted left operand. The result is undefined if the right operand is negative, or greater than or equal to the length in bits of the promoted left operand. The value of ID="ch5234"E1 << E2 is E1 (interpreted as a bit pattern) left-shifted E2 bits; vacated bits are 0-filled. The value of E1 >> E2 is E1 right-shifted E2 bit positions. The right shift is guaranteed to be logical (0-fill) if E1 has an unsigned type or if it has a non-negative value; otherwise, the result is implementation dependent. ID="ch5235"LBL="" HELPID=""ID="33364"Relational OperatorsID="ch5236"The relational operators group left-to-right, but this fact is not very useful; a<b<c means (a<b)<c and not (a<b)&&(b<c). ID="ch5237"relational-expression:shift-expressionrelational-expression < shift-expressionrelational-expression > shift-expressionrelational-expression <= shift-expressionrelational-expression >= shift-expressionID="ch5238"ID="ch5239"ID="ch5240"ID="ch5241"ID="ch5242"ID="ch5243"ID="ch5244"ID="ch5245"The operands must have arithmetic or pointer type. The operators < (less than), > (greater than), <= (less than or equal to), and >= (greater than or equal to) all yield  if the specified relation is false and  if it is true. The type of the result is int. The usual arithmetic conversions are performed on arithmetic operands. Pointer conversions are performed on pointer operands. This implies that any pointer may be compared to a constant expression evaluating to 0 and any pointer can be compared to a pointer of type ID="ch5246"ID="ch5247"ID="ch5248"void* (in the latter case the pointer is first converted to void*). Pointers to objects or functions of the same type (after pointer conversions) may be compared; the result depends on the relative positions of the pointed-to objects or functions in the address space. ID="ch5249"ID="ch5250"Two pointers to the same object compare equal. If two pointers point to non-static members of the same object, the pointer to the later declared member compares higher provided the two members are not separated by an access-specifier label (IDREF="38800" TYPE="TITLE""Access Specifiers") and provided their class is not a union. If two pointers point to non-static members of the same object separated by an ID="ch5251"access-specifier label (IDREF="38800" TYPE="TITLE""Access Specifiers") the result is undefined. If two pointers point to data members of the same union, they compare equal. If two pointers point to elements of the same array or one beyond the end of the array, the pointer to the object with the higher subscript compares higher. Other pointer comparisons are implementation dependent. ID="ch5252"ID="ch5253"LBL="" HELPID=""ID="33739"Equality OperatorsID="ch5254"ID="ch5255"equality-expression:relational-expressionequality-expression == relational-expressionequality-expression != relational-expressionID="ch5256"ID="ch5257"ID="ch5258"ID="ch5259"The == (equal to) and the != (not equal to) operators are exactly analogous to the relational operators except for their lower precedence. (Thus a<b == c<d is 1 whenever a<b and c<d have the same truth-value.) In addition, pointers to members of the same type may be compared. Pointer to member conversions (IDREF="23730" TYPE="TITLE""Pointers to Members") are performed. A pointer to member may be compared to a constant expression that evaluates to . LBL="" HELPID=""ID="24401"Bitwise AND OperatorID="ch5260"ID="ch5261"ID="ch5262"and-expression:equality-expressionand-expression & equality-expressionThe usual arithmetic conversions are performed; the result is the bitwise AND function of the operands. The operator applies only to integral operands. LBL="" HELPID=""ID="11057"Bitwise Exclusive-OR OperatorID="ch5263"ID="ch5264"exclusive-or-expression:and-expressionexclusive-or-expression ^ and-expressionThe usual arithmetic conversions are performed; the result is the bitwise exclusive-OR function of the operands. The operator applies only to integral operands. LBL="" HELPID=""ID="29098"Bitwise Inclusive-OR OperatorID="ch5265"ID="ch5266"inclusive-or-expression:exclusive-or-expressioninclusive-or-expression | exclusive-or-expressionThe usual arithmetic conversions are performed; the result is the bitwise inclusive-OR function of its operands. The operator applies only to integral operands. LBL="" HELPID=""ID="36772"Logical AND OperatorID="ch5267"ID="ch5268"logical-and-expression:inclusive-or-expressionlogical-and-expression && inclusive-or-expressionThe && operator groups left-to-right. It returns 1 if both its operands are non-zero,  0 otherwise. Unlike &, && guarantees left-to-right evaluation; moreover the second operand is not evaluated if the first operand evaluates to 0. The operands need not have the same type, but each must have arithmetic type or be a pointer. The result is an int. All side effects of the first expression happen before the second expression is evaluated.ID="ch5269"LBL="" HELPID=""ID="21104"Logical OR OperatorID="ch5270"ID="ch5271"logical-or-expression:logical-and-expressionlogical-or-expression || logical-and-expressionThe || operator groups left-to-right. It returns 1 if either of its operands is non-zero, and 0 otherwise. Unlike |, || guarantees left-to-right evaluation; moreover, the second operand is not evaluated if the first operand evaluates to non-zero. The operands need not have the same type, but each must have arithmetic type or be a pointer. The result is an int. All side effects of the first expression happen before the second expression is evaluated.ID="ch5272"LBL="" HELPID=""ID="36232"Conditional OperatorID="ch5273"ID="ch5274"conditional-expression:logical-or-expressionlogical-or-expression ? expression :conditional-expressionConditional expressions group right-to-left. The first expression must have arithmetic type or be a pointer type. It is evaluated and if it is non-zero, the result of the conditional expression is the value of the second expression, otherwise that of the third expression. All side effects of the first expression happen before the second or third expression is evaluated. If both the second and the third expressions are of arithmetic type, then if they are of the same type the result is of that type; otherwise the usual arithmetic conversions are performed to bring them to a common type. Otherwise, if both the second and the third expressions are either a pointer or a constant expression that evaluates to 0, pointer conversions are performed to bring them to a common type. Otherwise, if both the second and the third expressions are references, reference conversions are performed to bring them to a common type. Otherwise, if both the second and the third expressions are void, the common type is void. Otherwise, if both the second and the third expressions are of the same class T, the common type is T. Otherwise the expression is illegal. The result has the common type; only one of the second and third expressions is evaluated. The result is an lvalue if the second and the third operands are of the same type and both are lvalues. LBL="" HELPID=""ID="32408"Assignment OperatorsID="ch5275"ID="ch5276"ID="ch5277"ID="ch5278"ID="ch5279"ID="ch5280"ID="ch5281"ID="ch5282"ID="ch5283"ID="ch5284"ID="ch5285"ID="ch5286"There are several assignment operators, all of which group right-to-left. All require a modifiable lvalue as their left operand, and the type of an assignment expression is that of its left operand. The result of the assignment operation is the value stored in the left operand after the assignment has taken place; the result is an ID="ch5287"ID="ch5288"lvalue. ID="ch5289"assignment-expression:conditional-expressionunary-expression assignment-operator assignment-expressionID="ch5290"assignment-operator: one of=  *=  /=  %=   +=  -=  >>=  <<=  &=  ^=  |=In simple assignment ( =), the value of the expression replaces that of the object referred to by the left operand. If both operands have arithmetic type, the right operand is converted to the type of the left preparatory to the assignment. There is no implicit conversion to an enumeration (IDREF="14398" TYPE="TITLE""Enumeration Declarations"), so if the left operand is of an enumeration type, the right operand must be of the same type. If the left operand is of pointer type, the right operand must be of pointer type or a constant expression that evaluates to 0; the right operand is converted to the type of the left before the assignment. ID="ch5291"ID="ch5292"ID="ch5293"ID="ch5294"ID="ch5295"ID="ch5296"A pointer of type T*const can be assigned to a pointer of type T*, but the reverse assignment is illegal (IDREF="24962" TYPE="TITLE""Type Specifiers"). Objects of types const T and volatile T can be assigned to plain Tlvalues and to lvalues of type volatile T; see also (IDREF="23366" TYPE="TITLE""Initializers"). If the left operand is of pointer to member type, the right operand must be of pointer to member type or a constant expression that evaluates to 0; the right operand is converted to the type of the left before the assignment. ID="ch5297"ID="ch5298"ID="ch5299"Assignment to objects of a class (IDREF="38144" TYPE="TITLE"Chapter 9, "Classes") X is defined by the function X::operator=() (IDREF="26631" TYPE="TITLE""Assignment"). Unless the user defines an X::operator=(), the default version is used for assignment (IDREF="34465" TYPE="TITLE""Copying Class Objects"). This implies that an object of a class derived from X (directly or indirectly) by unambiguous public derivation (IDREF="25158" TYPE="TITLE""Pointer Conversions") can be assigned to an X. ID="ch5300"ID="ch5301"ID="ch5302"A pointer to a member of class B may be assigned to a pointer to a member of class D of the same type provided D is derived from B (directly or indirectly) by unambiguous public derivation (IDREF="23630" TYPE="TITLE""Ambiguities"). ID="ch5303"Assignment to an object of type "reference to T" assigns to the object of type T denoted by the reference. ID="ch5304"The behavior of an expression of the form E1op is equivalent to E1 = E1 except that E1 is evaluated only once. In += and -=, the left operand may be a pointer, in which case the (integral) right operand is converted as explained in IDREF="29047" TYPE="TITLE""Additive Operators"; all right operands and all non-pointer left operands must have arithmetic type. For class objects, assignment is not in general the same as initialization (IDREF="23366" TYPE="TITLE""Initializers", IDREF="21970" TYPE="TITLE""Constructors" in Chapter 12, IDREF="15668" TYPE="TITLE""Initialization", IDREF="34465" TYPE="TITLE""Copying Class Objects"). LBL="" HELPID=""ID="22590"Comma OperatorThe comma operator groups left-to-right. ID="ch5305"ID="ch5306"ID="ch5307"ID="ch5308"expression:assignment-expressionexpression , assignment-expressionA pair of expressions separated by a comma is evaluated left-to-right and the value of the left expression is discarded. All side effects of the left expression are performed before the evaluation of the right expression. The type and value of the result are the type and value of the right operand; the result is an ID="ch5309"lvalue if its right operand is. In contexts where comma is given a special meaning, for example, in lists of actual arguments to functions (IDREF="27725" TYPE="TITLE""Function Call") and lists of initializers (IDREF="23366" TYPE="TITLE""Initializers"), the comma operator as described in this section can appear only in parentheses; for example, f(a, (t=3, t+2), c);has three arguments, the second of which has the value 5. LBL="" HELPID=""ID="27851"Constant ExpressionsID="ch5310"In several places, C++ requires expressions that evaluate to an integral constant: as array bounds (IDREF="30659" TYPE="TITLE""Arrays"), as case expressions (IDREF="19611" TYPE="TITLE""The switch Statement"), as bit-field lengths (IDREF="37305" TYPE="TITLE""Bit-Fields"), and as enumerator initializers (IDREF="14398" TYPE="TITLE""Enumeration Declarations"). ID="ch5311"constant-expression:conditional-expressionA constant-expression can involve only literals (IDREF="32709" TYPE="TITLE""Literals"), enumerators, const values of integral types initialized with constant expressions (IDREF="23366" TYPE="TITLE""Initializers"), and sizeof expressions. Floating constants (IDREF="52602" TYPE="TITLE""Floating Constants") must be cast to integral types. Only type conversions to integral types may be used. In particular, except in sizeof expressions, functions, class objects, pointers, and references cannot be used. The comma operator and assignment-operators may not be used in a constant expression. LBL="6"ID="68758"StatementsThis chapter contains the following subsections:IDREF="30075" TYPE="TITLE""Labeled Statement"IDREF="30774" TYPE="TITLE""Expression Statement"IDREF="15195" TYPE="TITLE""Compound Statement, or Block"IDREF="28691" TYPE="TITLE""Selection Statements"IDREF="28413" TYPE="TITLE""Iteration Statements"IDREF="19934" TYPE="TITLE""Jump Statements"IDREF="10996" TYPE="TITLE""Declaration Statement"IDREF="10570" TYPE="TITLE""Ambiguity Resolution"Except as indicated, statements are executed in sequence. ID="ch61"ID="ch62"ID="ch63"statement:labeled-statementexpression-statementcompound-statementselection-statementiteration-statementjump-statementdeclaration-statementLBL="" HELPID=""ID="30075"Labeled StatementID="ch64"ID="ch65"A statement may be labeled.labeled-statement:identifier : statementcase constant-expression : statementdefault : statementAn identifier label declares the identifier. The only use of an identifier label is as the target of a goto. The scope of a label is the function in which it appears. Labels cannot be redeclared within a function. A label can be used in a ID="ch66"ID="ch67"goto statement before its definition. Labels have their own name space and do not interfere with other identifiers. ID="ch68"Case labels and default labels may occur only in switch statements. ID="ch69"ID="ch610"LBL="" HELPID=""ID="30774"Expression StatementID="ch611"Most statements are expression statements, which have the form ID="ch612"expression-statement:expressionopt ;Usually expression statements are assignments or function calls. All side effects from an expression statement are completed before the next statement is executed. An expression statement with the expression missing is called a null statement; it is useful to carry a label just before the ID="ch613"ID="ch614"} of a compound statement and to supply a null body to an iteration statement such as while (IDREF="17467" TYPE="TITLE""The while Statement"). LBL="" HELPID=""ID="15195"Compound Statement, or BlockID="ch615"ID="ch616"So that several statements can be used where one is expected, the compound statement (also, and equivalently, called "block") is provided. ID="ch617"compound-statement:{ statement-listopt }statement-list:statementstatement-list statementNote that a declaration is a statement (IDREF="10996" TYPE="TITLE""Declaration Statement"). LBL="" HELPID=""ID="28691"Selection StatementsID="ch618"Selection statements choose one of several flows of control. ID="ch619"ID="ch620"ID="ch621"ID="ch622"selection-statement:if ( expression ) statementif ( expression ) statement else statementswitch ( expression ) statementThe statement in a selection-statement may not be a declaration. ID="ch623"LBL="" HELPID=""The if StatementThe expression must be of arithmetic or pointer type or of a class type for which an unambiguous conversion to arithmetic or pointer type exists (IDREF="31355" TYPE="TITLE""Conversions"). ID="ch624"The expression is evaluated and if it is non-zero, the first substatement is executed. If else is used, the second substatement is executed if the expression is zero. The else ambiguity is resolved by connecting an ID="ch625"else with the last encountered else-less if. LBL="" HELPID=""ID="19611"The switch StatementID="ch626"The switch statement causes control to be transferred to one of several statements depending on the value of an expression. The expression must be of integral type or of a class type for which an unambiguous conversion to integral type exists (IDREF="31355" TYPE="TITLE""Conversions"). Integral promotion is performed. Any statement within the statement may be labeled with one or more case labels as follows: case constant-expression :
ID="ch627"where the constant-expression (IDREF="27851" TYPE="TITLE""Constant Expressions") is converted to the promoted type of the switch expression. No two of the case constants in the same switch may have the same value. There may be at most one label of the form default :within a switch statement. ID="ch628"Switch statements may be nested; a case or default label is associated with the smallest switch enclosing it. When the switch statement is executed, its expression is evaluated and compared with each case constant. If one of the case constants is equal to the value of the expression, control is passed to the statement following the matched case label. If no case constant matches the expression, and if there is a ID="ch629"default label, control passes to the statement labeled by the default label. If no case matches and if there is no ID="ch630"default then none of the statements in the switch is executed. case and default labels in themselves do not alter the flow of control, which continues unimpeded across such labels. To exit from a switch, see break, IDREF="27154" TYPE="TITLE""The break Statement". Usually, the statement that is the subject of a switch is compound. Declarations may appear in the ID="ch631"ID="ch632"statement of a switch-statement. It is illegal, however, to jump past a declaration with an explicit or implicit initializer unless the declaration is in an inner block that is not entered (that is, completely by passed by the transfer of control; IDREF="10996" TYPE="TITLE""Declaration Statement"). This implies that declarations that contain explicit or implicit initializers must be contained in an inner block. LBL="" HELPID=""ID="28413"Iteration StatementsID="ch633"Iteration statements specify looping. ID="ch634"ID="ch635"ID="ch636"ID="ch637"iteration-statement:while ( expression ) statementdo statement  while ( expression ) ;for ( for-init-statement expressionopt ; expressionopt ) statementfor-init-statement:expression-statementdeclaration-statementNote that a for-init-statement ends with a semicolon. The statement in an iteration-statement may not be a ID="ch638"declaration. LBL="" HELPID=""ID="17467"The while StatementID="ch639"In the while statement the substatement is executed repeatedly until the value of the expression becomes zero. The test takes place before each execution of the substatement. The expression must be of arithmetic or pointer type or of a class type for which an unambiguous conversion to arithmetic or pointer type exists (IDREF="31355" TYPE="TITLE""Conversions"). LBL="" HELPID=""Do statementID="ch640"In the do statement the substatement is executed repeatedly until the value of the expression becomes zero. The test takes place after each execution of the substatement. The expression must be of arithmetic or pointer type or of a class type for which an unambiguous conversion to arithmetic or pointer type exists (IDREF="31355" TYPE="TITLE""Conversions"). LBL="" HELPID=""The for StatementID="ch641"The for statement for ( for-init-statement expression-1opt ;expression-2opt ) statementis equivalent to for-init-statementwhile ( expression-1 ) { statementexpression-2 ;}except that a continue in statement will execute expression-2 before re-evaluating expression-1. Thus the first statement specifies initialization for the loop; the first expression specifies a test, made before each iteration, such that the loop is exited when the expression becomes zero; the second expression often specifies incrementing that is done after each iteration. The first expression must have arithmetic or pointer type or a class type for which an unambiguous conversion to arithmetic or pointer type exists (ID="ch642"IDREF="31355" TYPE="TITLE""Conversions"). Either or both of the expressions may be dropped. A missing expression-1 makes the implied while clause equivalent to while(1). ID="ch643"ID="ch644"If the for-init-statement is a declaration, the scope of the names declared extends to the end of the block enclosing the for-statement. LBL="" HELPID=""ID="19934"Jump StatementsJump statements unconditionally transfer control. ID="ch645"ID="ch646"ID="ch647"ID="ch648"ID="ch649"ID="ch650"ID="ch651"jump-statement:break ;continue ;return expressionopt ;goto identifier ;On exit from a scope (however accomplished), destructors (IDREF="29867" TYPE="TITLE""Destructors") are called for all constructed class objects in that scope that have not yet been destroyed. This applies to both explicitly declared objects and temporaries (ID="ch652"IDREF="18236" TYPE="TITLE""Temporary Objects").LBL="" HELPID=""ID="27154"The break StatementID="ch653"The break statement may occur only in an iteration-statement or a ID="ch654"ID="ch655"switch statement and causes termination of the smallest enclosing iteration-statement or switch statement; control passes to the statement following the terminated statement, if any.LBL="" HELPID=""The continue StatementID="ch656"The continue statement may occur only in an ID="ch657"iteration-statement and causes control to pass to the loop-continuation portion of the smallest enclosing iteration-statement, that is, to the end of the loop. More precisely, in each of the statements. For example,while (foo) {     do {              for (;;) {// ...          // ...             // ...contin: ;        contin: ;          contin: ;}                } while (foo);     }a continue statement not contained in an enclosed iteration statement is equivalent to goto contin. LBL="" HELPID=""ID="11995"The return StatementID="ch658"ID="ch659"A function returns to its caller by the return statement. A return statement without an expression can be used only in functions that do not return a value, that is, a function with the return value type void, a constructor (IDREF="21970" TYPE="TITLE""Constructors"), or a destructor (IDREF="29867" TYPE="TITLE""Destructors"). A return statement with an expression can be used only in functions returning a value; the value of the expression is returned to the caller of the function. If required, the expression is converted, as in an initialization, to the return type of the function in which it appears. This may involve the construction and copy of a temporary object (ID="ch660"ID="ch661"ID="ch662"IDREF="18236" TYPE="TITLE""Temporary Objects"). Flowing off the end of a function is equivalent to a return with no value; this is illegal in a value-returning function. LBL="" HELPID=""The goto StatementID="ch663"The goto statement unconditionally transfers control to the statement labeled by the identifier. The identifier must be a label (ID="ch664"IDREF="30075" TYPE="TITLE""Labeled Statement") located in the current function. LBL="" HELPID=""ID="10996"Declaration StatementID="ch665"A declaration statement introduces a new identifier into a block; it has the form ID="ch666"declaration-statement:declarationIf an identifier introduced by a declaration was previously declared in an outer block, the outer declaration is hidden for the remainder of the block, after which it resumes its force. ID="ch667"ID="ch668"ID="ch669"Any initializations of ID="ch670"ID="ch671"ID="ch672"auto or register variables are done each time their declaration-statement is executed. Destruction of local variables declared in the block is done on exit from the block (ID="ch673"IDREF="19934" TYPE="TITLE""Jump Statements"). Destruction of ID="ch674"auto variables defined in a loop is done once per iteration. For example, here the Index j is created and destroyed once each time round the i loop: for (int i = 0; i<100; i++)
   for (Index j = 0; j<100; j++) {
   // ...
   }Transfer out of a loop, out of a block, or back past an initialized auto variable involves the destruction of auto variables declared at the point transferred from but not at the point transferred to. It is possible to transfer into a block, but not in a way that causes initializations not to be done. It is illegal to jump past a declaration with an explicit or implicit initializer unless the declaration is in an inner block that is not entered (that is, completely bypassed by the transfer of control) or unless the jump is from a point where the variable has already been initialized. For example, ID="ch675"ID="ch676"void f()
{
   // ...
   goto lx;    // error: jump past initializer
   // ...
ly:
   X a = 1;
   // ...
lx:
   goto ly;    // ok, jump implies destructor
   // call for `a'
}
ID="ch677"An auto variable constructed under a condition is destroyed under that condition and cannot be accessed outside that condition. For example, ID="ch678"if (i)
   for (int j = 0; j<100; j++) {
   // ...
   }
if (j!=100)    // error: access outside condition
   // ...
;
ID="ch679"Initialization of a local object with storage class static (IDREF="12029" TYPE="TITLE""Storage Class Specifiers") is done the first time control passes through its declaration (only). Where a static variable is initialized with an expression that is not a constant-expression, default initialization to  of the appropriate type (IDREF="23366" TYPE="TITLE""Initializers") happens before its block is first entered. ID="ch680"The destructor for a local static object will be executed if and only if the variable was constructed. The destructor must be called either immediately before or as part of the calls of the atexit() functions (IDREF="28875" TYPE="TITLE""Start and Termination"). Exactly when is undefined. ID="ch681"LBL="" HELPID=""ID="10570"Ambiguity ResolutionID="ch682"There is an ambiguity in the grammar involving expression-statements and declarations: An expression-statement with a function-style explicit type conversion (IDREF="35361" TYPE="TITLE""Explicit Type Conversion") as its leftmost subexpression can be indistinguishable from a declaration where the first declarator starts with a (. In those cases the statement is a declaration.To disambiguate, the whole statement may have to be examined to determine if it is an expression-statement or a declaration. This disambiguates many examples. For example, assuming T is a simple-type-name (IDREF="24962" TYPE="TITLE""Type Specifiers"), T(a)->m = 7;       // expression-statement
T(a)++;            // expression-statement
T(a,5)<<c;         // expression-statement
T(*e)(int);        // declaration
T(f)[];            // declaration
T(g) = { 1, 2 };   // declaration
T(*d)(double(3));  // declarationThe remaining cases are declarations. For example, T(a);         // declaration
T(*b)();      // declaration
T(c)=7;       // declaration
T(d),e,f=3;   // declaration
T(g)(h,2);    // declarationThe disambiguation is purely syntactic; that is, the meaning of the names, beyond whether they are type-names or not, is not used in the disambiguation. A slightly different ambiguity between expression-statements and declarations is resolved by requiring a type-name for function declarations within a block (IDREF="15195" TYPE="TITLE""Compound Statement, or Block"). For example, void g()
{
   int f();   // declaration
   int a;     // declaration
   f();       // expression-statement
   a;         // expression-statement
}LBL="7"ID="35031"Declarations This chapter contains the following subsections:IDREF="21773" TYPE="TITLE""Specifiers"IDREF="14398" TYPE="TITLE""Enumeration Declarations"IDREF="17902" TYPE="TITLE""Asm Declarations"IDREF="27890" TYPE="TITLE""Linkage Specifications"Declarations specify the interpretation given to each identifier; they do not necessarily reserve storage associated with the identifier (ID="ch71"IDREF="24185" TYPE="TITLE""Declarations and Definitions"). Declarations have the form ID="ch72"declaration:decl-specifiersoptdeclarator-listopt ;  asm-declaration     function-definition     linkage-specificationID="ch73"ID="ch74"The declarators in the declarator-list (IDREF="30155" TYPE="TITLE"Chapter 8, "Declarators") contain the identifiers being declared. Only in function definitions (IDREF="20795" TYPE="TITLE""Function Definitions") and function declarations may the decl-specifiers be omitted. Only when declaring a class (IDREF="38144" TYPE="TITLE"Chapter 9, "Classes") or enumeration (IDREF="14398" TYPE="TITLE""Enumeration Declarations"), that is, when the decl-specifier is a class-specifier or enum-specifier, may the declarator-list be empty. asm-declarations are described in IDREF="17902" TYPE="TITLE""Asm Declarations", and linkage-specifications in IDREF="27890" TYPE="TITLE""Linkage Specifications". A declaration occurs in a scope (IDREF="24244" TYPE="TITLE""Scopes"); the scope rules are summarized in IDREF="28183" TYPE="TITLE""Summary of Scope Rules". LBL="" HELPID=""ID="21773"SpecifiersThe specifiers that can be used in a declaration are ID="ch75"ID="ch76"decl-specifier:storage-class-specifiertype-specifierfct-specifiertemplate-specifierfriendtypedefdecl-specifiers:decl-specifiersopt decl-specifierThe longest sequence of decl-specifiers that could possibly be a type name is taken as the decl-specifiers of a declaration. The sequence must be self-consistent as described below. For example, ID="ch77"typedef char* Pc;
static Pc;              // error: name missingHere, the declaration static Pc is illegal because no name was specified for the static variable of type Pc. To get a variable of type int called Pc, the type-specifierint must be present to indicate that the typedef-namePc is the name being (re)declared, rather than being part of the decl-specifier sequence. For example, void f(const Pc);       // void f(char*const)
void g(const int Pc);   // void g(const int)
ID="ch78"ID="ch79"ID="ch710"ID="ch711"Note that since signed, unsigned, long, and short by default imply int, a typedef-name appearing after one of those specifiers must be the name being (re)declared. For example, void h(unsigned Pc);       // void h(unsigned int)
void k(unsigned int Pc);   // void k(unsigned int)LBL="" HELPID=""ID="12029"Storage Class SpecifiersID="ch712"ID="ch713"The storage class specifiers are storage-class-specifier:autoregisterstaticexternID="ch714"ID="ch715"The auto or register specifiers can be applied only to names of objects declared in a block (ID="ch716"ID="ch717"IDREF="15195" TYPE="TITLE""Compound Statement, or Block") and for formal arguments (IDREF="20795" TYPE="TITLE""Function Definitions"). The auto declarator is almost always redundant and not often used; one use of auto is to distinguish a declaration-statement from an expression-statement (IDREF="30774" TYPE="TITLE""Expression Statement") explicitly. A ID="ch718"register declaration is an auto declaration, together with a hint to the compiler that the variables declared will be heavily used. The hint may be ignored and in most implementations it will be ignored if the address of the variable is taken. ID="ch719"An object declaration is a definition unless it contains the extern specifier and has no initializer (IDREF="24185" TYPE="TITLE""Declarations and Definitions"). ID="ch720"A definition causes the appropriate amount of storage to be reserved and any appropriate initialization (IDREF="23366" TYPE="TITLE""Initializers") to be done. The static and extern specifiers can be applied only to names of objects and functions and to anonymous unions. There can be no ID="ch721"ID="ch722"static function declarations within a block, nor any static or extern formal arguments. Static class members are described in (IDREF="17418" TYPE="TITLE""Static Members"); extern cannot be used for class members. ID="ch723"ID="ch724"A name specified static has internal linkage. Objects declared ID="ch725"ID="ch726"const have internal linkage unless they have previously been given external linkage. A name specified ID="ch727"ID="ch728"extern has external linkage unless it has previously been given internal linkage. A file scope name without a storage-class-specifier has external linkage unless it has previously been given internal linkage and provided it is not declared const. For a non-member function an ID="ch729"inline specifier is equivalent to a static specifier for linkage purposes (IDREF="22763" TYPE="TITLE""Program and Linkage"). All linkage specifications for a name must agree. For example, ID="ch730"static char* f(); // f() has internal linkage
* f()         // f() still has internal linkage
   { /* ... */ } 
char* g();        // g() has external linkage
static char* g()  // error: inconsistent linkage
   { /* ... */ } 
static int a;     // `a' has internal linkage
int a;            // error: two definitions
static int b;     // `b' has internal linkage
extern int b;     // `b' still has internal linkage
int c;            // `c' has external linkage
static int c;     // error: inconsistent linkage
extern int d;     // `d' has external linkage
static int d;     // error: inconsistent linkage
ID="ch731"The name of an undefined class can be used in an extern declaration. Such a declaration, however, cannot be used before the class has been defined. For example, struct S;
extern S a;
extern S f();
extern void g(S);
void h()
{
   g(a);     // error: S undefined
   f();     // error: S undefined
}LBL="" HELPID=""ID="12979"Function SpecifiersID="ch732"ID="ch733"Some specifiers can be used only in function declarations. ID="ch734"fct-specifier:inlinevirtualID="ch735"ID="ch736"The inline specifier is a hint to the compiler that inline substitution of the function body is to be preferred to the usual function call implementation. The hint may be ignored. For a non-member function inline specifier also gives the function default internal linkage (IDREF="22763" TYPE="TITLE""Program and Linkage"). A function (ID="ch737"ID="ch738"IDREF="27725" TYPE="TITLE""Function Call", IDREF="34712" TYPE="TITLE""Functions") defined within the declaration of a class is inline by default. An inline member function must have exactly the same definition in every compilation in which it appears. A class member function need not be explicitly declared inline in the class declaration to be inline. When no inline specifier is used, linkage will be external unless an inline definition appears before the first call. For example, class X {
public:
   int f();     
   inline int g();  // X::g() has internal linkage
   int h();
};
void k(X* p)
{
   int i = p->f();  // now X::f() has external linkage
   int j = p->g();
   // ...
}
inline int X::f()    // error: called before defined as inline
{
   // ...
}
inline int X::g()
{
   // ...
}
inline int X::h()   // now X::h() has internal linkage
{
   // ...
}
ID="ch739"The virtual specifier may be used only in declarations of non-static class member functions within a class declaration; see IDREF="23603" TYPE="TITLE""Virtual Functions". LBL="" HELPID=""ID="13818"The typedef SpecifierID="ch740"Declarations containing the decl-specifiertypedef declare identifiers that can be used later for naming fundamental or derived types. The typedef specifier may not be used in a function-definition (IDREF="20795" TYPE="TITLE""Function Definitions"). ID="ch741"typedef-name:identifierWithin the scope (IDREF="24244" TYPE="TITLE""Scopes") of a typedef declaration, each identifier appearing as part of any declarator therein becomes syntactically equivalent to a keyword and names the type associated with the identifier in the way described in IDREF="30155" TYPE="TITLE"Chapter 8, "Declarators". A ID="ch742"ID="ch743"ID="ch744"typedef-name is thus a synonym for another type. A typedef-name does not introduce a new type the way a class declaration (IDREF="12565" TYPE="TITLE""Class Names") does. For example, after ID="ch745"typedef int MILES, *KLICKSP;the constructions MILES distance;
extern KLICKSP metricp;are all legal declarations; the type of distance is int; that of metricp is "pointer to int." ID="ch746"A typedef may be used to redefine a name to refer to the type to which it already refers  even in the scope where the type was originally declared. For example, typedef struct s { /* ... */ } s;
typedef int I;
typedef int I;
typedef I I;
ID="ch747"An unnamed class defined in a typedef gets its typedef name as its name. For example, typedef struct { /* ... */ } S; // the struct is named SA typedef may not redefine a name of a type declared in the same scope to refer to a different type. For example, class complex { /* ... */ };
typedef int complex; // error: redefinitionSimilarly, a class may not be declared with the name of a type declared in the same scope to refer to a different type. For example, typedef int complex;
class complex { /* ... */ }; // error: redefinitionA typedef-name that names a class is a class-name (IDREF="12565" TYPE="TITLE""Class Names"). The synonym may not be used after a ID="ch748"class, struct, or union prefix and not in the names for constructors and destructors within the class declaration itself. For example, struct S {
   S();
   ~S();
};
typedef struct S T;
S a = T();    // ok
struct T * p;    // errorLBL="" HELPID=""The template SpecifierID="ch749"The template specifier is used to specify families of types or functions; see IDREF="18442" TYPE="TITLE"Chapter 14, "Templates". LBL="" HELPID=""The friend SpecifierID="ch750"The friend specifier is used to specify access to class members; see IDREF="13398" TYPE="TITLE""Friends". LBL="" HELPID=""ID="24962"Type SpecifiersID="ch751"The type-specifiers are ID="ch752"type-specifier:simple-type-nameclass-specifierenum-specifierelaborated-type-specifier:: class-nameconstvolatileID="ch753"ID="ch754"The words const and volatile may be added to any legal type-specifier in the declaration of an object. Otherwise, at most one type-specifier may be given in a declaration. A const object may be initialized, but its value may not be changed thereafter. Unless explicitly declared ID="ch755"extern, a const object does not have external linkage and must be initialized (IDREF="23366" TYPE="TITLE""Initializers"; IDREF="21970" TYPE="TITLE""Constructors"). An integer const initialized by a constant expression may be used in constant expressions (IDREF="27851" TYPE="TITLE""Constant Expressions"). Each element of a ID="ch756"ID="ch757"const array is const and each non-function, non-static member of a const class object is const (IDREF="28120" TYPE="TITLE""The this Pointer"). A const object of a type that does not have a constructor or a destructor may be placed in read-only memory. The effect of a write operation on any part of such an object is either an addressing exception or the same as if the object had been non- ID="ch758"ID="ch759"const. There are no implementation-independent semantics for ID="ch760"ID="ch761"volatile objects; volatile is a hint to the compiler to avoid aggressive optimization involving the object because the value of the object may be changed by means undetectable by a compiler. Each element of a volatile array is volatile and each non-function, non-static member of a volatile class object is volatile (IDREF="28120" TYPE="TITLE""The this Pointer"). ID="ch762"ID="ch763"If the type-specifier is missing from a declaration, it is taken to be int. ID="ch764"simple-type-name:complete-class-namequalified-type-namecharshortintlongsignedunsignedfloatdoublevoidID="ch765"ID="ch766"ID="ch767"ID="ch768"ID="ch769"ID="ch770"ID="ch771"ID="ch772"At most one of the words long or short may be specified together with int. Either may appear alone, in which case int is understood. The word long may appear together with double. At most one of the words signed and unsigned may be specified together with char, short, int, or long. Either may appear alone, in which case int is understood. The signed specifier forces char objects and bit-fields to be signed; it is redundant with other integral types. class-specifiers and enum-specifiers are discussed in IDREF="38144" TYPE="TITLE"Chapter 9, "Classes" and IDREF="14398" TYPE="TITLE""Enumeration Declarations", respectively. ID="ch773"elaborated-type-specifier:class-key class-nameclass-key identifierenum enum-nameID="ch774"ID="ch775"class-key:classstructunionID="ch776"ID="ch777"ID="ch778"ID="ch779"ID="ch780"If an identifier is specified, the elaborated-type-specifier declares it to be a class-name; see IDREF="12565" TYPE="TITLE""Class Names". If defined, a name declared using the union specifier must be defined as a union. If defined, a name declared using the class specifier must be defined using the class or struct specifier. If defined, a name declared using the struct specifier must be defined using the class or struct specifier. Names of nested types (ID="ch781"IDREF="40624" TYPE="TITLE""Nested Class Declarations") can be qualified by the name of their enclosing class: ID="ch782"qualified-type-name:typedef-nameclass-name :: qualified-type-nameID="ch783"complete-class-name:qualified-class-name:: qualified-class-nameID="ch784"qualified-class-name:class-nameclass-name :: qualified-class-nameA name qualified by a class-name must be a type defined in that class or in a base class of that class. As usual, a name declared in a derived class hides members of that name declared in base classes; see IDREF="24244" TYPE="TITLE""Scopes". LBL="" HELPID=""ID="14398"Enumeration DeclarationsID="ch785"ID="ch786"ID="ch787"An enumeration is a distinct integral type (IDREF="27802" TYPE="TITLE""Fundamental Types") with named constants. Its name becomes an enum-name, that is, a reserved word within its scope. enum-name:identifierenum-specifier:enum identifieropt { enum-listopt }enum-list:enumeratorenum-list , enumeratorID="ch788"enumerator:identifieridentifier = constant-expressionID="ch789"The identifiers in an enum-list are declared as constants, and may appear wherever constants are required. If no enumerators with ID="ch790"= appear, then the values of the corresponding constants begin at zero and increase by one as the declaration is read from left to right. An enumerator with = gives the associated identifier the value indicated; subsequent identifiers without initializers continue the progression from the assigned value. The value of an enumerator must be an int or a value that can be promoted to int by integral promotion (IDREF="37419" TYPE="TITLE""Integral Promotions"). ID="ch791"The names of enumerators must be distinct from those of ordinary variables and other enumerators in the same scope. The values of the enumerators need not be distinct. An enumerator is considered defined immediately after it and its initializer, if any, has been seen. For example, ID="ch792"ID="ch793"enum { a, b, c=0 };
enum { d, e, f=e+2 };defines a, c, and d to be 0, b and e to be 1, and f to be 3. ID="ch794"Each enumeration defines an integral type that is different from all other integral types. The type of an enumerator is its enumeration. The value of an enumerator or an object of an enumeration type is converted to an integer by integral promotion (IDREF="37419" TYPE="TITLE""Integral Promotions"). For example, ID="ch795"enum color { red, yellow, green=20, blue };
color col = red;
color* cp = &col;
if (*cp == blue) // ...makes color an integral type describing various colors, and then declares col as an object of that type, and cp as a pointer to an object of that type. The possible values of an object of type color are red, yellow, green, blue; these values can be converted to the int values 0, 1, 20,  and 21. Since enumerations are distinct types, objects of type color may be assigned only values of type color. For example, color c = 1;     // error: type mismatch,
// no conversion from int to color
int i = yellow;  // ok: yellow converted to int value 1
// integral promotionSee also IDREF="14398" TYPE="TITLE""Enumeration Declarations"ID="ch796"Enumerators defined in a class (IDREF="12565" TYPE="TITLE""Class Names") are in the scope of that class and can be referred to outside member functions of that class only by explicit qualification with the class name (IDREF="36093" TYPE="TITLE""Primary Expressions"). The name of the enumeration itself is also local to the class (IDREF="40624" TYPE="TITLE""Nested Class Declarations"). For example, ID="ch797"class X {
public:
   enum direction { left='l', right='r' };
   int f(int i)
      { return i==left ? 0 : i==right ? 1 : 2; }
};
void g(X* p)
{
   direction d;        // error: `direction' not in scope
   int i;
   i = p->f(left);     // error: `left' not in scope
   i = p->f(X::right); // ok
   // ...
}LBL="" HELPID=""ID="17902"Asm DeclarationsID="ch798"ID="ch799"ID="ch7100"An asm declaration has the form asm-declaration:   asm ( string-literal ) ;The meaning of an asm declaration is implementation dependent. Typically it is used to pass information through the compiler to an assembler. LBL="" HELPID=""ID="27890"Linkage SpecificationsID="ch7101"Linkage (IDREF="22763" TYPE="TITLE""Program and Linkage") between C++ and  non-C++ code fragments can be achieved using a linkage-specification: ID="ch7102"ID="ch7103"linkage-specification:extern string-literal { declaration-listopt }extern string-literaldeclarationID="ch7104"declaration-list:declarationdeclaration-list declarationThe string-literal indicates the required linkage. The meaning of the string-literal is implementation dependent. Linkage to a function written in the C programming language, ID="ch7105""C", and linkage to a C++ function, "C++", must be provided by every implementation. Default linkage is "C++". For example, ID="ch7106"complex sqrt(complex);    // C++ linkage by default
extern "C" {
   double sqrt(double);  // C linkage
}Linkage specifications nest. A linkage specification does not establish a scope. A linkage-specification may occur only in file scope (IDREF="24244" TYPE="TITLE""Scopes"). A ID="ch7107"linkage-specification for a class applies to non-member functions and objects declared within it. A ID="ch7108"linkage-specification for a function also applies to functions and objects declared within it. A linkage declaration with a string that is unknown to the implementation is an error. If a function has more than one linkage-specification, they must agree; that is, they must specify the same string-literal. A function declaration without a linkage specification may not precede the first linkage specification for that function. A function may be declared without a linkage specification after an explicit linkage specification has been seen; the linkage explicitly specified in the earlier declaration is not affected by such a function declaration. ID="ch7109"ID="ch7110"At most one of a set of overloaded functions (IDREF="18871" TYPE="TITLE"Chapter 13, "Overloading") with a particular name can have C linkage. See IDREF="27890" TYPE="TITLE""Linkage Specifications". ID="ch7111"Linkage can be specified for objects. For example, extern "C" {
   // ...
   _iobuf _iob[_NFILE];
// ...
   int _flsbuf(unsigned,_iobuf*);
   // ...
}
ID="ch7112"Functions and objects may be declared static within the {} of a linkage specification. The linkage directive is ignored for such a function or object. Otherwise, a function declared in a linkage specification behaves as if it was explicitly declared extern. For example, extern "C" double f();
static double f();     // erroris an error (IDREF="12029" TYPE="TITLE""Storage Class Specifiers"). An object defined within an extern "C" { /* ... */ }construct is still defined (and not just declared). ID="ch7113"Linkage from C++ to objects defined in other languages and to objects defined in C++ from other languages is implementation and language dependent. Only where the object layout strategies of two language implementations are similar enough can such linkage be achieved. ID="ch7114"When the name of a programming language is used to name a style of linkage in the string-literal in a linkage-specification, it is recommended that the spelling be taken from the document defining that language, for example, Ada (not ADA) and FORTRAN (not Fortran).LBL="8"ID="30155"DeclaratorsThis chapter conains the following subsections:IDREF="32393" TYPE="TITLE""Type Names"IDREF="26774" TYPE="TITLE""Meaning of Declarators"IDREF="20795" TYPE="TITLE""Function Definitions"IDREF="23366" TYPE="TITLE""Initializers"The ID="ch81"declarator-list appearing in a declaration is a comma-separated sequence of declarators, each of which may have an initializer. ID="ch82"declarator-list:init-declaratordeclarator-list , init-declaratorID="ch83"init-declarator:declaratorinitializeroptThe two components of a declaration are the specifiers ( decl-specifiers; IDREF="21773" TYPE="TITLE""Specifiers") and the declarators ( declarator-list). The specifiers indicate the fundamental type, storage class, or other properties of the objects and functions being declared. The declarators specify the names of these objects and functions and (optionally) modify the type with operators such as * (pointer to) and () (function returning). Initial values can also be specified in a declarator; initializers are discussed in IDREF="23366" TYPE="TITLE""Initializers" and IDREF="15668" TYPE="TITLE""Initialization". Declarators have the syntax ID="ch84"declarator:dnameptr-operator declaratordeclarator (argument-declaration-list) cv-qualifier-listoptdeclarator [ constant-expressionopt ]( declarator )ID="ch85"ptr-operator:* cv-qualifier-listopt& cv-qualifier-listoptcomplete-class-name :: * cv-qualifier-listoptcv-qualifier-list:cv-qualifiercv-qualifier-listoptID="ch86"cv-qualifier:constvolatileID="ch87"dname:nameclass-name  class-nametypedef-namequalified-type-nameID="ch88"A class-name has special meaning in a declaration of the class of that name and when qualified by that name using the scope resolution operator :: (IDREF="21970" TYPE="TITLE""Constructors", IDREF="29867" TYPE="TITLE""Destructors"). LBL="" HELPID=""ID="32393"Type NamesID="ch89"To specify type conversions explicitly, and as an argument of ID="ch810"sizeof or new, the name of a type must be specified. This is done with a type-name, which is syntactically a declaration for an object or function of that type that omits the name of the object or function. ID="ch811"type-name:     type-specifier-listabstract-declaratoropttype-specifier-list:     type-specifier type-specifier-listoptID="ch812"abstract-declarator:ptr-operator abstract-declaratoroptabstract-declaratoropt ( argument-declaration-list ) cv-qualifier-listoptabstract-declaratoropt [ constant-expressionopt ] ( abstract-declarator )It is possible to identify uniquely the location in the abstract-declarator where the identifier would appear if the construction were a declarator in a declaration. The named type is then the same as the type of the hypothetical identifier. For example, ID="ch813"ID="ch814"int                 // int i
int *               // int *pi
int *[3]            // int *p[3]
int (*)[3]          // int (*p3i)[3]
int *()             // int *f()
int (*)(double)     // int (*pf)(double)name respectively the types "integer," "pointer to integer," "array of 3 pointers to integers," "pointer to array of 3 integers," "function taking no arguments and returning pointer to integer," and "pointer to function taking a double argument and returning an integer." LBL="" HELPID=""Ambiguity ResolutionID="ch815"ID="ch816"The ambiguity arising from the similarity between a function-style cast and a declaration mentioned in IDREF="10570" TYPE="TITLE""Ambiguity Resolution" can also occur in the context of a declaration. In that context, it surfaces as a choice between a function declaration with a redundant set of parentheses around an argument name and an object declaration with a function-style cast as the initializer. Just as for statements, the resolution is to consider any construct that could possibly be a declaration a declaration. A declaration can be explicitly disambiguated by a non-function-style cast or a = to indicate initialization. For example, struct S {
   S(int);
};
void foo(double a)
{
   S x(int(a));     // function declaration
   S y((int)a);     // object declaration
   S z = int(a);     // object declaration
}LBL="" HELPID=""ID="26774"Meaning of DeclaratorsID="ch817"A list of declarators appears after a (possibly empty) list of decl-specifiers (IDREF="21773" TYPE="TITLE""Specifiers"). Each declarator contains exactly one ID="ch818"dname; it specifies the identifier that is declared. Except for the declarations of some special functions (IDREF="31355" TYPE="TITLE""Conversions", IDREF="39747" TYPE="TITLE""Overloaded Operators") a dname will be a simple identifier. An auto, static, extern, register, friend, inline, virtual, or typedef specifier applies directly to each dname in a declarator-list; the type of each dname depends on both the decl-specifiers (IDREF="21773" TYPE="TITLE""Specifiers") and its declarator. Thus, a declaration of a particular identifier has the form T Dwhere T is a type and D is a declarator. In a declaration where D is an unadorned identifier the type of this identifier is T. In a declaration where D has the form ( D1 )the type of D1 is the same as that of D. Parentheses do not alter the type of the embedded ID="ch819"dname, but they may alter the binding of complex declarators. LBL="" HELPID=""ID="13366"PointersID="ch820"In a declaration TD where D has the form * cv-qualifier-listopt D1the type of the contained identifier is "... cv-qualifier-list pointer to T." The ID="ch821"cv-qualifiers apply to the pointer and not to the object pointed to. ID="ch822"For example, the declarations ID="ch823"ID="ch824"ID="ch825"const ci = 10, *pc = &ci, *const cpc = pc;
int i, *p, *const cp = &i;declare ci , a constant integer; pc, a pointer to a constant integer; cpc, a constant pointer to a constant integer; i, an integer; p, a pointer to integer; and cp, a constant pointer to integer. The value of ci, cpc, and cp cannot be changed after initialization. The value of pc can be changed, and so can the object pointed to by cp. Examples of legal operations are i = ci;
*cp = ci;
pc++;
pc = cpc;
pc = p;Examples of illegal operations are ci = 1;      // error
ci++;        // error
*pc = 2;     // error
cp = &ci;    // error
cpc++;       // error
p = pc;      // errorEach is illegal because it would either change the value of an object declared const or allow it to be changed through an unqualified pointer later. volatile specifiers are handled similarly. See also IDREF="32408" TYPE="TITLE""Assignment Operators" and IDREF="23366" TYPE="TITLE""Initializers". There can be no pointers to references (IDREF="22652" TYPE="TITLE""References") or pointers to bit-fields (IDREF="37305" TYPE="TITLE""Bit-Fields"). LBL="" HELPID=""ID="22652"ReferencesID="ch826"In a declaration T D where D has the form & cv-qualifier-listopt D1the type of the contained identifier is "... cv-qualifier-list reference to T." The type ID="ch827"void& is not permitted. For example, ID="ch828"ID="ch829"void f(double& a) { a += 3.14; }
// ...
   double d = 0;
   f(d);declares a to be a reference argument of f so the call f(d) will add 3.14 to d. int v[20];
// ...
int& g(int i) { return v[i]; }
// ...
g(3) = 7;declares the function g() to return a reference to an integer so g(3)=7 will assign  to the fourth element of the array v. struct link {
   link* next;
};
link* first;
void h(link*& p)  // `p' is a reference to pointer
{
   p->next = first;
   first = p;
   p = 0;
}
void k()
{
link* q = new link;
h(q);
}declares p to be a reference to a pointer to link so h(q) will leave q with the value 0. See also IDREF="19032" TYPE="TITLE""References". ID="ch830"There can be no references to references, no references to bit-fields (IDREF="37305" TYPE="TITLE""Bit-Fields"), no arrays of references, and no pointers to references. The declaration of a reference must contain an ID="ch831"initializer (IDREF="10856" TYPE="TITLE""Pointers to Members") except when the declaration contains an explicit extern specifier (IDREF="12029" TYPE="TITLE""Storage Class Specifiers"), is a class member (IDREF="18270" TYPE="TITLE""Class Members") declaration within a class declaration, or is the declaration of an argument or a return type (IDREF="34712" TYPE="TITLE""Functions"); see IDREF="24185" TYPE="TITLE""Declarations and Definitions".LBL="" HELPID=""ID="10856"Pointers to MembersID="ch832"In a declaration T D where D has the form complete-class-name :: *  cv-qualifier-listopt D1the type of the contained identifier is "... cv-qualifier-list pointer to member of class complete-class-name of type T." For example, ID="ch833"class X {
public:
   void f(int);
   int a;
};
int X::* pmi = &X::a;
void (X::* pmf)(int) = &X::f;declares pmi and pmf to be a pointer to a member of X of type int and a pointer to a member of X of type void(int), respectively. They can be used like this: X obj;
//...
obj.*pmi = 7;   // assign 7 to an integer
   // member of obj
(obj.*pmf)(7);  // call a function member of obj
   // with the argument 7Note that a pointer to member cannot point to a static member of a class (IDREF="17418" TYPE="TITLE""Static Members"). See also IDREF="19694" TYPE="TITLE""Pointer - to - Member Operators" and IDREF="16145" TYPE="TITLE""Unary Operators". LBL="" HELPID=""ID="30659"ArraysID="ch834"In a declaration T D where D has the form f7D1 [constant-expressionopt]then the contained identifier has type "... array of T." If the ID="ch835"constant-expression (IDREF="27851" TYPE="TITLE"Chapter 5, "Constant Expressions") is present, it must be of integral type and have a value greater than . The constant expression specifies the number of elements in the array. If the constant expression is N, the array has N elements numbered  to N-1. An array may be constructed from one of the fundamental types (except void), from a pointer, from a pointer to member, from a class, from an enumeration, or from another array. When several "array of" specifications are adjacent, a multidimensional array is created; the constant expressions that specify the bounds of the arrays may be omitted only for the first member of the sequence. This elision is useful for function arguments of array types, and when the array is external and the definition, which allocates storage, is given elsewhere. The first constant-expression may also be omitted when the declarator is followed by an initializer-list (IDREF="23366" TYPE="TITLE""Initializers"). In this case the size is calculated from the number of initial elements supplied (ID="ch836"IDREF="32268" TYPE="TITLE""Aggregates"). The declaration ID="ch837"ID="ch838"float fa[17], *afp[17];declares an array of float numbers and an array of pointers to float numbers. The declaration ID="ch839"static int x3d[3][5][7];declares a static three-dimensional array of integers, with rank 3x5x7. In complete detail, x3d is an array of three items; each item is an array of five arrays; each of the latter arrays is an array of seven integers. Any of the expressions x3d, x3d[i], x3d[i][j], x3d[i][j][k] may reasonably appear in an expression. ID="ch840"When an identifier of array type appears in an expression, except as the operand of sizeof or & or used to initialize a reference (IDREF="19032" TYPE="TITLE""References"), it is converted into a pointer to the first member of the array. Because of this conversion, arrays are not modifiable lvalues. Except where it has been declared for a class (IDREF="16865" TYPE="TITLE""Subscripting"), the subscript operator [] is interpreted in such a way that E1[E2] is identical to *((E1)+(E2)). Because of the conversion rules that apply to +, if E1 is an array and E2 an integer, then E1[E2] refers to the E2-th member of E1. Therefore, despite its asymmetric appearance, subscripting is a commutative operation. A consistent rule is followed for multidimensional arrays. If ID="ch841"E is an n-dimensional array of rank ixjx...xk, then E appearing in an expression is converted to a pointer to an (n-1)-dimensional array with rank jx...xk. If the * operator, either explicitly or implicitly as a result of subscripting, is applied to this pointer, the result is the pointed-to (n-1)-dimensional array, which itself is immediately converted into a pointer. For example, consider int x[3][5];Here x is a 3x5 array of integers. When x appears in an expression, it is converted to a pointer to (the first of three) five-membered arrays of integers. In the expression x[i], which is equivalent to *(x+i), x is first converted to a pointer as described; then x+i is converted to the type of x, which involves multiplying i by the length of the object to which the pointer points, namely five integer objects. The results are added and indirection applied to yield an array (of five integers), which in turn is converted to a pointer to the first of the integers. If there is another subscript the same argument applies again; this time the result is an integer. It follows from all this that arrays in C++ are stored row-wise (last subscript varies fastest) and that the first subscript in the declaration helps determine the amount of storage consumed by an array but plays no other part in subscript calculations. ID="ch842"LBL="" HELPID=""ID="34712"FunctionsID="ch843"In a declaration TD where D has the form D1 ( argument-declaration-list ) cv-qualifier-listoptthe contained identifier has the type "... cv-qualifier-listopt function taking arguments of type argument-declaration-list and returning T." ID="ch844"argument-declaration-list:arg-declaration-listopt ...optarg-declaration-list , ...arg-declaration-list:argument-declarationarg-declaration-list , argument-declarationID="ch845"argument-declaration:decl-specifiers declaratordecl-specifiers declarator = expressiondecl-specifiers abstract-declaratoroptdecl-specifiers abstract-declaratoropt = expressionID="ch846"If the argument-declaration-list terminates with an ellipsis, the number of arguments is known only to be equal to or greater than the number of argument types specified; if it is empty, the function takes no arguments. The argument list ID="ch847"ID="ch848"ID="ch849"ID="ch850"ID="ch851"(void) is equivalent to the empty argument list. Except for this special case ID="ch852"void may not be an argument type (though types derived from void, such as void*, may). Where legal, ", ..." is synonymous with "...". The standard header <stdarg.h> contains a mechanism for accessing arguments passed using the ellipsis. See ID="ch853"IDREF="21970" TYPE="TITLE""Constructors" for the treatment of array arguments. ID="ch854"A single name may be used for several different functions in a single scope; this is function overloading (IDREF="18871" TYPE="TITLE"Chapter 13, "Overloading"). All declarations for a function taking a given set of arguments must agree exactly both in the type of the value returned and in the number and type of arguments; the presence or absence of the ellipsis is considered part of the function type. Argument types that differ only in the use of typedef names or unspecified argument array bounds agree exactly. The return type and the argument types, but not the default arguments (ID="ch855"IDREF="27816" TYPE="TITLE""Default Arguments"), are part of the function type. A cv-qualifier-list can be part of a declaration or definition of a non-static member function, and of a pointer to a member function; see IDREF="28120" TYPE="TITLE""The this Pointer". It is part of the function type. ID="ch856"ID="ch857"Functions cannot return arrays or functions, although they can return pointers and references to such things. There are no arrays of functions, although there may be arrays of pointers to functions. Types may not be defined in return or argument types. ID="ch858"The argument-declaration-list is used to check and convert actual arguments in calls and to check pointer-to-function and reference-to-function assignments and initializations. ID="ch859"An identifier can optionally be provided as an argument name; if present in a function declaration, it cannot be used since it immediately goes out of scope; if present in a function definition (IDREF="20795" TYPE="TITLE""Function Definitions"), it names a formal argument. In particular, argument names are also optional in function definitions and names used for an argument in different declarations and the definition of a function need not be the same. The declaration ID="ch860"int i,
   *pi,
   f(),
   *fpi(int),
   (*pif)(const char*, const char*);declares an integer i, a pointer pi to an integer, a function f taking no arguments and returning an integer, a function fpi taking an integer argument and returning a pointer to an integer, and a pointer pif to a function which takes  two pointers to constant characters and returns an integer. It is especially useful to compare the last two. The binding of *fpi(int) is *(fpi(int)), so the declaration suggests, and the same construction in an expression requires, the calling of a function fpi, and then using indirection through the (pointer) result to yield an integer. In the declarator (*pif)(const char*, const char*), the extra parentheses are necessary to indicate that indirection through a pointer to a function yields a function, which is then called. ID="ch861"The declaration fseek(FILE*, long, int);declares a function taking three arguments of the specified types. Since no return value type is specified it is taken to be int (IDREF="24962" TYPE="TITLE""Type Specifiers"). The declaration ID="ch862"ID="ch863"printf(const char* ...);declares a function that can be called with varying number and types of arguments. For example, printf("hello world");
printf("a=%d b=%d", a, b);It must always have a value, however, that can be converted to a const char* as its first argument. LBL="" HELPID=""ID="27816"Default ArgumentsID="ch864"ID="ch865"If an expression is specified in an argument declaration this expression is used as a default argument. All subsequent arguments must have default arguments supplied in this or previous declarations of this function. Default arguments will be used in calls where trailing arguments are missing. A default argument cannot be redefined by a later declaration (not even to the same value). A declaration may add default arguments, however, not given in previous declarations. ID="ch866"The declaration point(int = 3, int = 4);declares a function that can be called with zero, one, or two arguments of type int. It may be called in any of these ways: point(1,2);  point(1);  point();The last two calls are equivalent to point(1,4) and point(3,4), respectively. ID="ch867"ID="ch868"ID="ch869"Default argument expressions have their names bound and their types checked at the point of declaration, and are evaluated at each point of call. In the following example, ID="ch870"g will be called with the value f(2): int a = 1;
int f(int);
int g(int x = f(a)); // default argument: f(::a)
void h() {
   a = 2;
   {
      int a = 3;
   g();        // g(f(::a))
   }
}Local variables may not be used in default argument expressions. For example, void f()
{
   int i;
   extern void g(int x = i);     // error
   // ...
}
ID="ch871"Note that default arguments are evaluated before entry into a function and that the order of evaluation of function arguments is implementation dependent. Consequently, formal arguments of a function may not be used in default argument expressions. Formal arguments of a function declared before a default argument expression are in scope and may hide global and class member names. For example, ID="ch872"ID="ch873"int a;
int f(int a, int b = a);    // error: argument 'a'
   // used as default argument
typedef int I;
int g(int I, int b = I(2)); // error: 'int' calledSimilarly, the declaration of X::mem1() in the following example is illegal because no object is supplied for the non-static member X::a used as an initializer. class X {
   int a;
   static b;
   mem1(int i = a); // error: non-static member 'a'
      // used as default argument
   mem2(int i = b); // ok
};The declaration of X::mem2() is legal, however, since no object is needed to access the static member X::b. Classes, objects, and members are described in IDREF="38144" TYPE="TITLE"Chapter 9, "Classes". A default argument is not part of the type of a function. int f(int = 0);
void h()
{
   int j = f(1);
   int k = f();          // fine, means f(0)
}
int (*p1)(int) = &f;
int (*p2)() = &f;     // error: type mismatch
ID="ch874"An overloaded operator (IDREF="39747" TYPE="TITLE""Overloaded Operators") cannot have default arguments. LBL="" HELPID=""ID="20795"Function DefinitionsID="ch875"ID="ch876"Function definitions have the form ID="ch877"ID="ch878"function-definition:decl-specifiersoptdeclaratorctor-initializeroptfct-bodyfct-body:compound-statementThe declarator in a function-definition must contain a declarator with the form D1 ( argument-declaration-list ) cv-qualifier-listoptas described in IDREF="34712" TYPE="TITLE""Functions". ID="ch879"ID="ch880"The formal arguments are in the scope of the outermost block of the fct-body. A simple example of a complete function definition is ID="ch881"int max(int a, int b, int c)
{
   int m = (a > b) ? a : b;
   return (m > c) ? m : c;
}Here int is the decl-specifiers; max(inta, intb, intc) is the declarator; "{ /* ... */ }" is the fct-body. ID="ch882"ID="ch883"ID="ch884"A ctor-initializer is used only in a constructor; see IDREF="21970" TYPE="TITLE""Constructors" and IDREF="15668" TYPE="TITLE""Initialization". A cv-qualifier-list can be part of a non-static member function declaration, non-static member function definition, or pointer to member function only; see IDREF="28120" TYPE="TITLE""The this Pointer". It is part of the function type. Note that unused formal arguments need not be named. For example, ID="ch885"void print(int a, int)
{
   printf("a = %d\n",a);
}LBL="" HELPID=""ID="23366"InitializersID="ch886"A declarator may specify an initial value for the identifier being declared. ID="ch887"initializer:= assignment-expression= { initializer-list ,opt }( expression-list )ID="ch888"initializer-list:assignment-expressioninitializer-list , assignment-expression{ initializer-list ,opt }ID="ch889"Automatic, register, static, and external variables may be initialized by arbitrary expressions involving constants and previously declared variables and functions. ID="ch890"ID="ch891"int f(int);
int a = 2;
int b = f(a);
int c(b);
ID="ch892"ID="ch893"ID="ch894"ID="ch895"ID="ch896"A pointer of type const T*, that is, a pointer to constant T, can be initialized with a pointer of type T*, but the reverse initialization is illegal. Objects of type T can be initialized with objects of type T independently of const and volatile modifiers on both the initialized variable and on the initializer. For example, int a;
const int b = a;
int c = b;
const int* p0 = &a;
const int* p1 = &b;
int* p2 = &b;        // error: makes a pointer to
   // non-const point to a const 
int *const p3 = p2;
int *const p4 = p1;  // error: makes a pointer to
   // non-const point to a const 
const int* p5 = p1;The reason for the two errors is the same: had those initializations been allowed they would have allowed the value of something declared const to be changed through an unqualified pointer. Default argument expressions are more restricted; see IDREF="27816" TYPE="TITLE""Default Arguments". Initialization of objects of classes with constructors is described in IDREF="18434" TYPE="TITLE""Explicit Initialization". Copying of class objects is described in IDREF="34465" TYPE="TITLE""Copying Class Objects". The order of initialization of static objects is described in IDREF="28875" TYPE="TITLE""Start and Termination" and IDREF="10996" TYPE="TITLE""Declaration Statement". Variables with storage class static (IDREF="38359" TYPE="TITLE""Storage Classes") that are not initialized are guaranteed to start off as  converted to the appropriate type. So are members of static class objects. The initial values of automatic and register variables that are not initialized are undefined. ID="ch897"ID="ch898"ID="ch899"When an initializer applies to a pointer or an object of arithmetic type, it consists of a single expression, perhaps in braces. The initial value of the object is taken from the expression; the same conversions as for assignment are performed. ID="ch8100"Note that since () is not an initializer, X a();is not the declaration of an object of class X, but the declaration of a function taking no argument and returning an X. ID="ch8101"An initializer for a static member is in the scope of the member's class. For example, int a;
struct X {
   static int a;
   static int b;
};
int X::a = 1;
int X::b = a;     // X::b = X::aSee IDREF="27816" TYPE="TITLE""Default Arguments" for initializers used as default arguments. LBL="" HELPID=""ID="32268"AggregatesID="ch8102"ID="ch8103"ID="ch8104"ID="ch8105"ID="ch8106"ID="ch8107"ID="ch8108"An aggregate is an array or an object of a class (IDREF="38144" TYPE="TITLE"Chapter 9, "Classes") with no constructors (IDREF="21970" TYPE="TITLE""Constructors"), no private or protected members (IDREF="40678" TYPE="TITLE"Chapter 11, "Member Access Control"), no base classes (IDREF="37638" TYPE="TITLE"Chapter 10, "Derived Classes"), and no virtual functions (IDREF="23603" TYPE="TITLE""Virtual Functions"). When an aggregate is initialized the initializer may be an initializer-list consisting of a brace-enclosed, comma-separated list of initializers for the members of the aggregate, written in increasing subscript or member order. If the aggregate contains subaggregates, this rule applies recursively to the members of the subaggregate. If there are fewer initializers in the list than there are members of the aggregate, then the aggregate is padded with zeros of the appropriate types. For example, struct S { int a; char* b; int c; };
S ss = { 1, "asdf" };initializes ss.a with , ss.b with "asdf", and ss.c with 0. An aggregate that is a class may also be initialized with an object of its class or of a class publicly derived from it (IDREF="34465" TYPE="TITLE""Copying Class Objects"). Braces may be elided as follows. If the initializer-list begins with a left brace, then the succeeding comma-separated list of initializers initializes the members of the aggregate; it is erroneous for there to be more initializers than members. If, however, the initializer-list or a subaggregate does not begin with a left brace, then only enough elements from the list are taken to account for the members of the aggregate; any remaining members are left to initialize the next member of the aggregate of which the current aggregate is a part. For example, int x[] = { 1, 3, 5 };declares and initializes x as a one-dimensional array that has three members, since no size was specified and there are three initializers. float y[4][3] = {
   { 1, 3, 5 },
   { 2, 4, 6 },
   { 3, 5, 7 },
};is a completely-bracketed initialization: 1, 3, and 5 initialize the first row of the array y[0], namely y[0][0], y[0][1], and y[0][2]. Likewise the next two lines initialize y[1] and y[2]. The initializer ends early and therefore y[3] is initialized with zeros. Precisely the same effect could have been achieved by float y[4][3] = {
   1, 3, 5, 2, 4, 6, 3, 5, 7
};The last (rightmost) index varies fastest (IDREF="30659" TYPE="TITLE""Arrays"). The initializer for y begins with a left brace, but the one for y[0] does not, therefore three elements from the list are used. Likewise the next three are taken successively for y[1] and y[2]. Also, float y[4][3] = {
   { 1 }, { 2 }, { 3 }, { 4 }
};initializes the first column of y (regarded as a two-dimensional array) and leaves the rest 0. ID="ch8109"Initialization of arrays of objects of a class with constructors is described in IDREF="18434" TYPE="TITLE""Explicit Initialization". ID="ch8110"The initializer for a union with no constructor is either a single expression of the same type, or a brace-enclosed initializer for the first member of the union. For example, union u { int a; char* b; };
u a = { 1 };
u b = a;
u c = 1;              // error
u d = { 0, "asdf" };  // error
u e = { "asdf" };     // errorThere may not be more initializers than there are members or elements to initialize. For example, char cv[4] = { 'a', 's', 'd', 'f', 0 };  // erroris an error. LBL="" HELPID=""ID="18600"Character ArraysA char array (whether signed or unsigned) may be initialized by a string-literal; successive characters of the string initialize the members of the array. For example, ID="ch8111"char msg[] = "Syntax error on line %s\n";shows a character array whose members are initialized with a string. Note that because ´\n' is a single character and because a trailing ´\0' is appended, sizeof(msg) is 25. There may not be more initializers than there are array elements. For example, char cv[4] = "asdf";  // erroris an error since there is no space for the implied trailing ´\0'. LBL="" HELPID=""ID="19032"ReferencesID="ch8112"A variable declared to be a T&, that is "reference to type T" (IDREF="22652" TYPE="TITLE""References"), must be initialized by an object of type T or by an object that can be converted into a T. For example, void f()
{
   int i;
   int& r = i;  // `r' refers to `i'
   r = 1;       // the value of `i' becomes 1
   int* p = &r; // `p' points to `i'
   int& rr = r; // `rr' refers to what `r' refers to,
   // that is, to `i'
}A reference cannot be changed to refer to another object after initialization. Note that initialization of a reference is treated very differently from assignment to it. Argument passing (ID="ch8113"ID="ch8114"IDREF="27725" TYPE="TITLE""Function Call") and function value return (ID="ch8115"IDREF="11995" TYPE="TITLE""The return Statement") are initializations. The initializer may be omitted for a reference only in an argument declaration (IDREF="34712" TYPE="TITLE""Functions"), in the declaration of a function return type, in the declaration of a class member within its class declaration (IDREF="18270" TYPE="TITLE""Class Members"), and where the extern specifier is explicitly used. For example, ID="ch8116"int& r1;         // error: initializer missing
extern int& r2;  // okIf the initializer for a reference to type T is an lvalue of type T or of a type derived (IDREF="37638" TYPE="TITLE"Chapter 10, "Derived Classes") from T for which T is an accessible base (IDREF="25158" TYPE="TITLE""Pointer Conversions"), the reference will refer to the initializer; otherwise, if and only if the reference is to a ID="ch8117"const an object of type T will be created and initialized with the initializer. The reference then becomes a name for that object. For example, ID="ch8118"double d = 1.0;
double& rd = d;         // rd refers to 'd'
const double& rcd = d;  // rcd refers to 'd'
double& rd2 = 1;        // error: type mismatch
const double& rcd2 = 1; // rcd2 refers to temporary
   // with value '1'
ID="ch8119"A reference to a volatileT can be initialized with a volatileT or a plain T but not a const T. A reference to a const T can be initialized with a const T or a plain T or something that can be converted into a plain T but not a volatile T. A reference to a plain T can be initialized only with a plain T. ID="ch8120"The lifetime of a temporary object created in this way is the scope in which it is created (IDREF="38359" TYPE="TITLE""Storage Classes"). Note that a reference to a class B can be initialized by an object of a class D provided B is an accessible and unambiguous base class of D (in that case a D is a B); see IDREF="29340" TYPE="TITLE""Reference Conversions".LBL="9"ID="38144"ClassesThis chapter contains the following subsections:IDREF="12565" TYPE="TITLE""Class Names"IDREF="18270" TYPE="TITLE""Class Members"IDREF="34481" TYPE="TITLE""Member Functions"IDREF="17418" TYPE="TITLE""Static Members"IDREF="32100" TYPE="TITLE""Unions"IDREF="37305" TYPE="TITLE""Bit-Fields"IDREF="40624" TYPE="TITLE""Nested Class Declarations"IDREF="40458" TYPE="TITLE""Local Class Declarations"IDREF="24733" TYPE="TITLE""Local Type Names"A class is a type. Its name becomes a ID="ch91"ID="ch92"ID="ch93"ID="ch94"ID="ch95"class-name (IDREF="12565" TYPE="TITLE""Class Names"), that is, a reserved word within its scope. ID="ch96"class-name:identifierClass-specifiers and elaborated-type-specifiers (IDREF="24962" TYPE="TITLE""Type Specifiers") are used to make class-names. An object of a class consists of a (possibly empty) sequence of members. ID="ch97"class-specifier:     class-head { member-listopt }class-head:     class-key identifieropt base-specopt     class-key class-name base-specoptID="ch98"class-key:     class     struct     unionThe name of a class can be used as a class-name even within the member-list of the class specifier itself. A ID="ch99"class-specifier is commonly referred to as a class declaration. A class is considered defined when its ID="ch910"class-specifier has been seen even though its member functions are in general not yet defined. ID="ch911"ID="ch912"Objects of an empty class have a non-zero size.Class objects may be assigned, passed as arguments to functions, and returned by functions (except objects of classes for which copying has been restricted; see IDREF="34465" TYPE="TITLE""Copying Class Objects"). Other plausible operators, such as equality comparison, can be defined by the user; see IDREF="39747" TYPE="TITLE""Overloaded Operators". ID="ch913"A structure is a class declared with the class-key struct; its members and base classes (ID="ch914"IDREF="37638" TYPE="TITLE"Chapter 10, "Derived Classes") are public by default (IDREF="40678" TYPE="TITLE"Chapter 11, "Member Access Control"). A union is a class declared with the ID="ch915"class-key union; its members are public by default and it holds only one member at a time (ID="ch916"IDREF="32100" TYPE="TITLE""Unions"). LBL="" HELPID=""ID="12565"Class NamesID="ch917"ID="ch918"ID="ch919"A class declaration introduces a new type. For example, struct X { int a; };
struct Y { int a; };
X a1;
Y a2;
int a3;declares three variables of three different types. This implies that a1 = a2;     // error: Y assigned to X
a1 = a3;     // error: int assigned to Xare type mismatches, and that int f(X);
int f(Y);
ID="ch920"declare an overloaded (IDREF="18871" TYPE="TITLE"Chapter 13, "Overloading") function f() and not simply a single function f() twice. For the same reason, struct S { int a; };
struct S { int a; };  // error, double definitionis an error because it defines S twice. ID="ch921"ID="ch922"A class declaration introduces the class name into the scope where it is declared and hides any class, object, function, or other declaration of that name in an enclosing scope (ID="ch923"IDREF="24244" TYPE="TITLE""Scopes"). If a class name is declared in a scope where an object, function, or enumerator of the same name is also declared the class can be referred to only using an elaborated-type-specifier (IDREF="24962" TYPE="TITLE""Type Specifiers"). For example, struct stat {
   // ...
};
stat gstat;             // use plain `stat' to
   // define variable
int stat(struct stat*); // redefine `stat' as function
void f()
{
   struct stat* ps;    // `struct' prefix needed
   // to name struct stat
   // ...
   stat(ps);           // call stat()
   // ...
}
ID="ch924"ID="ch925"An elaborated-type-specifier with a class-key used without declaring an object or function introduces a class name exactly like a class declaration but without defining a class. For example, struct s { int a; };
void g()
{
   struct s;  // hide global struct `s'
   s* p;      // refer to local struct `s'
   struct s { char* p; };  // declare local struct `s'
}Such declarations allow declaration of classes that refer to each other. For example, ID="ch926"class vector;
class matrix {
   // ...
   friend vector operator*(matrix&, vector&);
};
class vector {
   // ...
   friend vector operator*(matrix&, vector&);
};Declaration of friends is described in IDREF="13398" TYPE="TITLE""Friends", operator functions in IDREF="39747" TYPE="TITLE""Overloaded Operators". If a class mentioned as a ID="ch927"friend has not been declared its name is entered in the same scope as the name of the class containing the friend declaration (IDREF="13398" TYPE="TITLE""Friends"). ID="ch928"ID="ch929"ID="ch930"An elaborated-type-specifier (IDREF="24962" TYPE="TITLE""Type Specifiers") can also be used in the declarations of objects and functions. It differs from a class declaration in that if a class of the elaborated name is in scope the elaborated name will refer to it. For example, struct s { int a; };
void g()
{
   struct s* p = new s;    // refer to global `s'
   p->a = 1;
}
ID="ch931"A name declaration takes effect immediately after the identifier is seen. For example, class A * A;first specifies A to be the name of a class and then redefines it as the name of a pointer to an object of that class. This means that the elaborated form class A must be used to refer to the class. Such artistry with names can be confusing and is best avoided. ID="ch932"A typedef-name (IDREF="13818" TYPE="TITLE""The typedef Specifier") that names a class is a class-name; see also IDREF="24962" TYPE="TITLE""Type Specifiers"LBL="" HELPID=""ID="18270"Class MembersID="ch933"ID="ch934"ID="ch935"ID="ch936"ID="ch937"member-list:     member-declaration member-listopt     access-specifier : member-listoptID="ch938"ID="ch939"member-declaration:     decl-specifiersoptmember-declarator-listopt ;function-definition ;opt     qualified-name ;member-declarator-list:     member-declarator     member-declarator-list , member-declaratorID="ch940"member-declarator:     declarator pure-specifieropt     identifieropt : constant-expressionID="ch941"ID="ch942"pure-specifier:      = 0ID="ch943"A member-list may declare data, functions, classes, enumerations (IDREF="14398" TYPE="TITLE""Enumeration Declarations"), bit-fields (IDREF="37305" TYPE="TITLE""Bit-Fields"), friends (IDREF="13398" TYPE="TITLE""Friends"), and type names (IDREF="13818" TYPE="TITLE""The typedef Specifier", IDREF="12565" TYPE="TITLE""Class Names"). A member-list may also contain declarations adjusting the access to member names; see IDREF="23067" TYPE="TITLE""Access Declarations". A member may not be declared twice in the member-list. The member-list defines the full set of members of the class. No member can be added elsewhere. ID="ch944"Note that a single name can denote several function members provided their types are sufficiently different (IDREF="18871" TYPE="TITLE"Chapter 13, "Overloading"). Note that a member-declarator cannot contain an initializer (IDREF="23366" TYPE="TITLE""Initializers"). A member can be initialized using a constructor; see IDREF="21970" TYPE="TITLE""Constructors". A member may not be auto, extern, or register. The decl-specifiers can be omitted in function declarations only. The member-declarator-list can be omitted only after a class-specifier, an enum-specifier, or decl-specifiers of the form friendelaborated-type-specifier. A pure-specifier may be used only in the declaration of a virtual function (IDREF="23603" TYPE="TITLE""Virtual Functions"). ID="ch945"Members that are class objects must be objects of previously declared classes. In particular, a class cl may not contain an object of class cl, but it may contain a pointer or reference to an object of class cl. When an array is used as the type of a non-static member all dimensions must be specified. ID="ch946"ID="ch947"A simple example of a class declaration is struct tnode {
   char tword[20];
   int count;
   tnode *left;
   tnode *right;
};which contains an array of twenty characters, an integer, and two pointers to similar structures. Once this class declaration has been given, the declaration tnode s, *sp;declares s to be a tnode and sp to be a pointer to a tnode. With these declarations, sp->count refers to the count member of the structure to which sp points; s.left refers to the left subtree pointer of the structure s; and s.right->tword[0] refers to the initial character of the tword member of the right subtree of s. ID="ch948"Non-static data members of a class declared without an intervening access-specifier are allocated so that later members have higher addresses within a class object. The order of allocation of non-static data members separated by an ID="ch949"access-specifier is implementation dependent (IDREF="38800" TYPE="TITLE""Access Specifiers"). Implementation alignment requirements may cause two adjacent members not to be allocated immediately after each other; so may requirements for space for managing virtual functions (IDREF="23603" TYPE="TITLE""Virtual Functions") and virtual base classes (IDREF="19879" TYPE="TITLE""Multiple Base Classes"); see also IDREF="14761" TYPE="TITLE""Explicit Type Conversion". A function member (IDREF="34481" TYPE="TITLE""Member Functions") with the same name as its class is a constructor (IDREF="21970" TYPE="TITLE""Constructors"). A static data member, enumerator, member of an anonymous union, or nested type may not have the same name as its class. LBL="" HELPID=""ID="34481"Member FunctionsID="ch950"ID="ch951"ID="ch952"A function declared as a member (without the friend specifier; IDREF="13398" TYPE="TITLE""Friends") is called a member function, and is called using the class member syntax (IDREF="21265" TYPE="TITLE""Class Member Access"). For example, ID="ch953"struct tnode {
   char tword[20];
   int count;
   tnode *left;
   tnode *right;
   void set(char*, tnode* l, tnode* r);
};Here set is a member function and can be called like this: void f(tnode n1, tnode n2)
{
   n1.set("abc",&n2,0);
   n2.set("def",0,0);
}
ID="ch954"The definition of a member function is considered to be within the scope of its class. This means that (provided it is non-static IDREF="17418" TYPE="TITLE""Static Members") it can use names of members of its class directly. A static member function can use only the names of static members, enumerators, and nested types directly. If the definition of a member function is lexically outside the class declaration, the member function name must be qualified by the class name using the ID="ch955":: operator. For example, ID="ch956"void tnode::set(char* w, tnode* l, tnode* r)
{
   count = strlen(w)+1;
   if (sizeof(tword)<=count)
      error("tnode string too long");
   strcpy(tword,w);
   left = l;
   right = r;
}The notation tnode::set specifies that the function set is a member of and in the scope of class tnode. The member names tword, count, left, and right refer to members of the object for which the function was called. Thus, in the call n1.set(abc",&n2,0)" tword refers to n1.tword, and in the call n2.set(def",0,0)" it refers to n2.tword. The functions strlen, error, and strcpy must be declared elsewhere. ID="ch957"Members may be defined (IDREF="24185" TYPE="TITLE""Declarations and Definitions") outside their class declaration if they have already been declared but not defined in the class declaration; they may not be redeclared. See also IDREF="22763" TYPE="TITLE""Program and Linkage". Function members may be mentioned in friend declarations after their class has been defined. Each member function that is called must have exactly one definition in a program. ID="ch958"ID="ch959"ID="ch960"The effect of calling a non-static member function (IDREF="17418" TYPE="TITLE""Static Members") of a class X for something that is not an object of class X is undefined. LBL="" HELPID=""ID="28120"The this PointerID="ch961"In a non-static (IDREF="34481" TYPE="TITLE""Member Functions") member function, the keyword this is a pointer to the object for which the function is called. The type of ID="ch962"this in a member function of a class X is X*const unless the member function is declared ID="ch963"const or ID="ch964"volatile; in those cases, the type of this is constX*const and volatile X *const, respectively. A function declared const and volatile has a this with the type const volatile X *const. See alsoIDREF="28494" TYPE="TITLE""Assignment to this" in Appendix B. For example, struct s {
   int a;
   int f() const;
   int g() { return a++; }
   int h() const { return a++; } // error
};
int s::f() const { return a; }The a++ in the body of s::h is an error because it tries to modify (a part of) the object for which s::h() is called. This is not allowed in a const member function where this is a pointer to const, that is, *this is a const. ID="ch965"A const member function (that is, a member function declared with the const qualifier) may be called for const and non-const objects, whereas a non-const member function may be called only for a non- const object. For example, ID="ch966"void k(s& x, const s& y)
{
   x.f();
   x.g();
   y.f();
   y.g();     // error
}The call y.g() is an error because y is const and s::g() is a non-const member function that could (and does) modify the object for which it was called. ID="ch967"Similarly, only volatile member functions (that is, a member function declared with the volatile specifier) may be invoked for volatile objects. A member function can be both const and volatile. ID="ch968"ID="ch969"ID="ch970"ID="ch971"Constructors (IDREF="21970" TYPE="TITLE""Constructors") and destructors (IDREF="29867" TYPE="TITLE""Destructors") may be invoked for a const or volatile object. Constructors (IDREF="21970" TYPE="TITLE""Constructors") and destructors (IDREF="29867" TYPE="TITLE""Destructors") cannot be declared const or volatile. LBL="" HELPID=""ID="41223"Inline Member FunctionsID="ch972"ID="ch973"A member function may be defined (IDREF="20795" TYPE="TITLE""Function Definitions") in the class declaration, in which case it is inline (IDREF="12979" TYPE="TITLE""Function Specifiers"). Defining a function within a class declaration is equivalent to declaring it inline and defining it immediately after the class declaration; this rewriting is considered to be done after preprocessing but before syntax analysis and type checking of the function definition. Thus ID="ch974"int b;
struct x {
   char* f() { return b; }
   char* b;
};is equivalent to int b;
struct x {
   char* f();
   char* b;
};
inline char* x::f() { return b; } // movedThus the b used in x::f() is X::b and not the global b. ID="ch975"ID="ch976"Member functions can be defined even in local or nested class declarations where this rewriting would be syntactically illegal. See IDREF="40458" TYPE="TITLE""Local Class Declarations" for a discussion of local classes and IDREF="40624" TYPE="TITLE""Nested Class Declarations" for a discussion of nested classes. LBL="" HELPID=""ID="17418"Static MembersID="ch977"ID="ch978"A data or function member of a class may be declared static in the class declaration. There is only one copy of a static data member, shared by all objects of the class in a program. A static member is not part of objects of a class. Static members of a global class have external linkage (IDREF="22763" TYPE="TITLE""Program and Linkage"). The declaration of a static data member in its class declaration is not a definition. A definition is required elsewhere; see also IDREF="12625" TYPE="TITLE""Anachronisms". ID="ch979"A static member function does not have a this pointer so it can access non-static members of its class only by using . or ->. A static member function cannot be virtual. There cannot be a static and a non-static member function with the same name and the same argument types. ID="ch980"Static members of a local class (IDREF="40458" TYPE="TITLE""Local Class Declarations") have no linkage and cannot be defined outside the class declaration. It follows that a local class cannot have static data members. ID="ch981"ID="ch982"A static member mem of class cl can be referred to as cl::mem (IDREF="36093" TYPE="TITLE""Primary Expressions" in Chapter 5), that is, independently of any object. It can also be referred to using the . and -> member access operators (IDREF="21265" TYPE="TITLE""Class Member Access"). When a static member is accessed through a member access operator, the expression on the left side of the . or -> is not evaluated. The static member mem exists even if no objects of class cl have been created. For example, in the following, run_chain, idle, and so on exist even if no process objects have been created: ID="ch983"class process {
   static int no_of_processes;
   static process* run_chain;
   static process* running;
   static process* idle;
   // ...
public:
   // ...
   int state();
   static void reschedule();
   // ...
};and reschedule can be used without reference to a process object, as follows: void f()
{
   process::reschedule();
}
ID="ch984"ID="ch985"Static members of a global class are initialized exactly like global objects and only in file scope. For example, void process::reschedule() { /* ... */ };
int process::no_of_processes = 1;
process* process::running = get_main();
process* process::run_chain = process::running;Static members obey the usual class member access rules (IDREF="40678" TYPE="TITLE"Chapter 11, "Member Access Control") except that they can be initialized (in file scope). ID="ch986"The type of a static member does not involve its class name; thus the type of process :: no_of_processes is int and the type of &process :: reschedule is void(*)(). LBL="" HELPID=""ID="32100"UnionsID="ch987"A union may be thought of as a structure whose member objects all begin at offset zero and whose size is sufficient to contain any of its member objects. At most one of the member objects can be stored in a union at any time. A union may have member functions (including constructors and destructors), but not virtual (ID="ch988"ID="ch989"ID="ch990"ID="ch991"IDREF="23603" TYPE="TITLE""Virtual Functions") functions. A union may not have base classes. A union may not be used as a base class. An object of a class with a constructor or a destructor or a user-defined assignment operator (ID="ch992"IDREF="26631" TYPE="TITLE""Assignment") cannot be a member of a union. A union can have no ID="ch993"static data members. ID="ch994"A union of the form union { member-list } ;is called an anonymous union; it defines an unnamed object (and not a type). The names of the members of an anonymous union must be distinct from other names in the scope in which the union is declared; they are used directly in that scope without the usual member access syntax (IDREF="21265" TYPE="TITLE""Class Member Access"). ID="ch995"For example, ID="ch996"void f()
{
   union { int a; char* p; };
   a = 1;
   // ...
   p = "Jennifer";
   // ...
}Here a and p are used like ordinary (non-member) variables, but since they are union members they have the same address. ID="ch997"A global anonymous union must be declared static. An anonymous union may not have ID="ch998"ID="ch999"private or protected members (IDREF="40678" TYPE="TITLE"Chapter 11, "Member Access Control"). An anonymous union may not have function members. A union for which objects or pointers are declared is not an anonymous union. For example, union { int aa; char* p; } obj, *ptr = &obj;
aa = 1;       // error
ptr->aa = 1;  // okThe assignment to plain aa is illegal since the member name is not associated with any particular object. Initialization of unions that do not have constructors is described in IDREF="32268" TYPE="TITLE""Aggregates". LBL="" HELPID=""ID="37305"Bit-FieldsID="ch9100"A member-declarator of the form identifieropt : constant-expressionspecifies a bit-field; its length is set off from the bit-field name by a colon. Allocation of bit-fields within a class object is implementation dependent. Fields are packed into some addressable allocation unit. Fields straddle allocation units on some machines and not on others. Alignment of bit-fields is implementation dependent. Fields are assigned right-to-left on some machines, left-to-right on others. ID="ch9101"ID="ch9102"ID="ch9103"ID="ch9104"ID="ch9105"ID="ch9106"An unnamed bit-field is useful for padding to conform to externally-imposed layouts. As a special case, an unnamed bit-field with a width of zero specifies alignment of the next bit-field at an allocation unit boundary. ID="ch9107"ID="ch9108"An unnamed field is not a member and cannot be initialized. ID="ch9109"A bit-field must have integral type (IDREF="27802" TYPE="TITLE""Fundamental Types"). It is implementation dependent whether a plain (neither explicitly signed nor unsigned) ID="ch9110"int field is signed or unsigned. The "address-of operator" ID="ch9111"& may not be applied to a bit-field, so there are no pointers to bit-fields. Nor are there references to bit-fields. ID="ch9112"ID="ch9113"ID="ch9114"LBL="" HELPID=""ID="40624"Nested Class DeclarationsID="ch9115"ID="ch9116"ID="ch9117"A class may be declared within another class. A class declared within another is called a nested class. The name of a nested class is local to its enclosing class. The nested class is in the scope of its enclosing class. Except by using explicit pointers, references, and object names, declarations in a nested class can use only type names, static members, and enumerators from the enclosing class. ID="ch9118"ID="ch9119"int x;
int y;
class enclose {
public:
   int x;
   static int s;
   class inner {
      void f(int i)
      {
            x = i;   // error: assign to enclose::x
            s = i;   // ok: assign to enclose::s
            ::x = i; // ok: assign to global x
            y = i;   // ok: assign to global y
      }
      void g(enclose* p, int i)
      {
            p->x = i;   // ok: assign to enclose::x
      }
   };
};
inner* p = 0;     // error `inner' not in scope
ID="ch9120"Member functions of a nested class have no special access to members of an enclosing class; they obey the usual access rules (IDREF="40678" TYPE="TITLE"Chapter 11, "Member Access Control"). Member functions of an enclosing class have no special access to members of a nested class; they obey the usual access rules. For example, ID="ch9121"class E {
   int x;
   class I {
      int y;
      void f(E* p, int i)
      {
         p->x = i;   // error: E::x is private
      }
   };
   int g(I* p)
   {
      return p->y;    // error: I::y is private
   }
};Member functions and static data members of a nested class can be defined in the global scope. For example, ID="ch9122"class enclose {
   class inner {
      static int x;
      void f(int i);
   };
};
typedef enclose::inner ei;
int ei::x = 1;
void enclose::inner::f(int i) { /* ... */ }
ID="ch9123"Like a member function, a friend function defined within a class is in the lexical scope of that class; it obeys the same rules for name binding as the member functions (described above and in IDREF="28183" TYPE="TITLE""Summary of Scope Rules") and like them has no special access rights to members of an enclosing class or local variables of an enclosing function (IDREF="40678" TYPE="TITLE"Chapter 11, "Member Access Control"). LBL="" HELPID=""ID="40458"Local Class DeclarationsID="ch9124"A class can be declared within a function definition; such a class is called a local class. The name of a local class is local to its enclosing scope. The local class is in the scope of the enclosing scope. Declarations in a local class can use only type names, static variables, ID="ch9125"extern variables and functions, and enumerators from the enclosing scope. For example, ID="ch9126"int x;
void f()
{
   static int s ;
   int x;
   extern int g();
   struct local {
      int h() { return x; }    // error: `x' is auto
      int j() { return s; }    // ok
      int k() { return ::x; }  // ok
      int l() { return g(); }  // ok
   };
   // ...
}
local* p = 0;     // error: `local' not in scope     An enclosing function has no special access to members of the local class; it obeys the usual access rules (IDREF="40678" TYPE="TITLE"Chapter 11, "Member Access Control"). Member functions of a local class must be defined within their class definition. A local class may not have static data members. ID="ch9127"ID="ch9128"LBL="" HELPID=""ID="24733"Local Type NamesID="ch9129"ID="ch9130"Type names obey exactly the same scope rules as other names. In particular, type names defined within a class declaration cannot be used outside their class without qualification. For example, ID="ch9131"class X {
public:
   typedef int I;
   class Y { /* ... */ };
   I a;
};
I b;     // error
Y c;     // error
X::Y d;  // okThe following rule limits the context sensitivity of the rewrite rules for inline functions and for class member declarations in general. A ID="ch9132"ID="ch9133"class-name or a typedef-name or the name of a constant used in a type name may not be redefined in a class declaration after being used in the class declaration, nor may a name that is not a class-name or a typedef-name be redefined to a class-name or a typedef-name in a class declaration after being used in the class declaration. For example, typedef int c;
enum { i = 1 };
class X {
   char v[i];
   int f() { return sizeof(c); }
   char c;         // error: typedef name
      // redefined after use
   enum { i = 2 }; // error: `i' redefined after
      // use in type name `char[i]'
};
typedef char* T;
struct Y {
   T a;
   typedef long T; // error: T already used
   T b;
};LBL="10"ID="37638"Derived ClassesThis Chapter contains the following subsections:IDREF="19879" TYPE="TITLE""Multiple Base Classes"IDREF="23603" TYPE="TITLE""Virtual Functions"IDREF="42103" TYPE="TITLE""Abstract Classes"IDREF="28183" TYPE="TITLE""Summary of Scope Rules"A list of base classes may be specified in a class declaration using the notation: ID="ch101"ID="ch102"ID="ch103"ID="ch104"ID="ch105"ID="ch106"base-spec:base-listID="ch107"base-list:base-specifierbase-list , base-specifierID="ch108"base-specifier:complete-class-namevirtual access-specifieroptcomplete-class-nameaccess-specifier virtualopt complete-class-nameID="ch109"ID="ch1010"access-specifier:privateprotectedpublicThe class-name in a base-specifier must denote a previously declared class (IDREF="12565" TYPE="TITLE""Class Names"), which is called a base class for the class being declared. A class is said to be derived from its base classes. For the meaning of ID="ch1011"ID="ch1012"ID="ch1013"access-specifier see IDREF="38800" TYPE="TITLE""Access Specifiers". Unless redefined in the derived class, members of a base class can be referred to as if they were members of the derived class. The base class members are said to be ID="ch1014"inherited by the derived class. The scope resolution operator ID="ch1015"ID="ch1016"ID="ch1017":: (IDREF="36093" TYPE="TITLE""Primary Expressions") may be used to refer to a base member explicitly. This allows access to a name that has been redefined in the derived class. A derived class can itself serve as a base class subject to access control; see IDREF="32027" TYPE="TITLE""Access Specifiers for Base Classes". A pointer to a derived class may be implicitly converted to a pointer to an accessible unambiguous base class (IDREF="25158" TYPE="TITLE""Pointer Conversions"). A reference to a derived class may be implicitly converted to a reference to an accessible unambiguous base class (IDREF="29340" TYPE="TITLE""Reference Conversions"). For example, ID="ch1018"class base {
public:
   int a, b;
};
class derived : public base {
public:
   int b, c;
};
void f()
{
   derived d;
   d.a = 1;
   d.base::b = 2;
   d.b = 3;
   d.c = 4;
   base* bp = &d;  // standard conversion:
      // derived* to base*
}assigns to the four members of d and makes bp point to d. ID="ch1019"ID="ch1020"A class is called a direct base if it is mentioned in the base-list and an indirect base if it is not a direct base but is a base class of one of the classes mentioned in the base-list. Note that in the class-name ::name notation, name may be a name of a member of an indirect base class; the notation simply specifies a class in which to start looking for name. For example, class A { public: void f(); };
class B : public A { };
class C : public B { public: void f(); };
void C::f()
{
   f();    // Call C's f()
   A::f(); // call A's f()
   B::f(); // call A's f()
}Here, A::f() is called twice since it is the only f() in B. Initialization of objects representing base classes can be specified in constructors; see IDREF="36383" TYPE="TITLE""Initializing Bases and Members".LBL="" HELPID=""ID="19879"Multiple Base ClassesID="ch1021"ID="ch1022"ID="ch1023"A class may be derived from any number of base classes. For example, class A { /* ... */ };
class B { /* ... */ };
class C { /* ... */ };
class D : public A, public B, public C { /* ... */ };The use of more than one direct base class is often called multiple inheritance. ID="ch1024"ID="ch1025"The order of derivation is not significant except possibly for default initialization by constructor (IDREF="21970" TYPE="TITLE""Constructors"), for cleanup (IDREF="29867" TYPE="TITLE""Destructors"), and for storage layout (IDREF="14761" TYPE="TITLE""Explicit Type Conversion", IDREF="18270" TYPE="TITLE""Class Members", IDREF="38800" TYPE="TITLE""Access Specifiers"). The order in which storage is allocated for base classes is implementation dependent. ID="ch1026"ID="ch1027"ID="ch1028"A class may not be specified as a direct base class of a derived class more than once but it may be an indirect base class more than once. class B { /* ... */ };class D : public B, public B { /* ... */ };  // illegalclass L { /* ... */ };
class A : public L { /* ... */ };
class B : public L { /* ... */ };
class C : public A, public B { /* ... */ };   // legalHere, an object of class C will have two sub-objects of class L. ID="ch1029"The keyword virtual may be added to a base class specifier. A single sub-object of the virtual base class is shared by every base class that specified the base class to be virtual. For example, class V { /* ... */ };
class A : virtual public V { /* ... */ };
class B : virtual public V { /* ... */ };
class C : public A, public B { /* ... */ };Here class C has only one sub-object of class V. A class may have both virtual and non-virtual base classes of a given type. class B { /* ... */ };
class X : virtual public B { /* ... */ };
class Y : virtual public B { /* ... */ };
class Z : public B { /* ... */ };
class AA : public X, public Y, public Z { /* ... */ };Here class AA has two sub-objects of class B: Z's B and the virtual B shared by X and Y. LBL="" HELPID=""ID="23630"AmbiguitiesID="ch1030"ID="ch1031"Access to base class members must be unambiguous. Access to a base class member is ambiguous if the expression used refers to more than one function, object, type, or enumerator. The check for ambiguity takes place before access control (IDREF="40678" TYPE="TITLE"Chapter 11, "Member Access Control"). For example, class A {
public:
   int a;
   int (*b)();
   int f();
   int f(int);
   int g();
};
class B {
   int a;
   int b();
public:
   int f();
   int g;
   int h();
   int h(int);
};
class C : public A, public B {};
void g(C* pc)
{
   pc->a = 1;  // error: ambiguous: A::a or B::a
   pc->b();    // error: ambiguous: A::b or B::b
   pc->f();    // error: ambiguous: A::f or B::f
   pc->f(1);   // error: ambiguous: A::f or B::f
   pc->g();    // error: ambiguous: A::g or B::g
   pc->g = 1;  // error: ambiguous: A::g or B::g
   pc->h();    // ok
   pc->h(1);   // ok
}
ID="ch1032"If the name of an overloaded function is unambiguously found overloading resolution also takes place before access control. Ambiguities can be resolved by qualifying a name with its class name. For example, ID="ch1033"ID="ch1034"ID="ch1035"class A {
public:
   int f();
};
class B {
public:
   int f();
};
class C : public A, public B {
   int f() { return A::f() + B::f(); }
};When virtual base classes are used, a single function, object, type, or enumerator may be reached through more than one path through the directed acyclic graph of base classes. This is not an ambiguity. The identical use with non-virtual base classes is an ambiguity; in that case more than one sub-object is involved. For example, class V { public: int v; };
class A { public: int a; };
class B : public A, public virtual V {};
class C : public A, public virtual V {};
class D : public B, public C { public: void f(); };
void D::f()
{
   v++;     // ok: only one `v' in `D'
   a++;     // error, ambiguous: two `a's in `D'
}     When virtual base classes are used, more than one function, object, or enumerator may be reached through paths through the directed acyclic graph of base classes. This is an ambiguity unless one of the names found ID="ch1036"dominates the others. The identical use with non-virtual base classes is an ambiguity; in that case more than one sub-object is involved. A name B::fdominates a name A::f if its class B has A as a base. If a name dominates another no ambiguity exists between the two; the dominant name is used when there is a choice. For example, class V { public: int f(); int x; };
class B : public virtual V { public: int f(); int x; };
class C : public virtual V { };class D : public B, public C { void g(); };void D::g()
{
   x++;     // ok: B::x dominates V::x
   f();     // ok: B::f() dominates V::f()
}     
ID="ch1037"An explicit or implicit conversion from a pointer or reference to a derived class to a pointer or reference to one of its base classes must unambiguously refer to the same object representing the base class. For example, class V { };
class A { };
class B : public A, public virtual V { };
class C : public A, public virtual V { };
class D : public B, public C { };
void g()
{
   D d;
   B* pb = &d;
   A* pa = &d;  // error, ambiguous: C's A or B's A ?
   V* pv = &d;  // fine: only one V sub-object
}LBL="" HELPID=""ID="23603"Virtual FunctionsID="ch1038"ID="ch1039"ID="ch1040"If a class base contains a virtual (IDREF="12979" TYPE="TITLE""Function Specifiers") function vf, and a class derived derived from it also contains a function vf of the same type, then a call of ID="ch1041"vf for an object of class derived invokes derived::vf (even if the access is through a pointer or reference to base). The derived class function is said to ID="ch1042"override the base class function. If the function types (IDREF="34712" TYPE="TITLE""Functions") are different, however, the functions are considered different and the virtual mechanism is not invoked (see also IDREF="13407" TYPE="TITLE""Declaration Matching"). It is an error for a derived class function to differ from a base class' virtual function in the return type only. For example, ID="ch1043"struct base {
   virtual void vf1();
   virtual void vf2();
   virtual void vf3();
   void f();
};
class derived : public base {
public:
   void vf1();
   void vf2(int);     // hides base::vf2()
   char vf3();  // error: differs in return type only
   void f();
};
void g()
{
   derived d;
   base* bp = &d;  // standard conversion:
      // derived* to base*
   bp->vf1();      // calls derived::vf1
   bp->vf2();      // calls base::vf2
   bp->f();        // calls base::f
}The calls invoke derived::vf1, base::vf2, and base::f, respectively, for the class derived object named d. That is, the interpretation of the call of a virtual function depends on the type of the object for which it is called, whereas the interpretation of a call of a non-virtual member function depends only on the type of the pointer or reference denoting that object. For example, bp->vf1() calls derived::vf1() because bp points to an object of class derived in which derived::vf1() has overridden the virtual function base::vf1(). The virtual specifier implies membership, so a virtual function cannot be a global (non-member) (IDREF="12979" TYPE="TITLE""Function Specifiers") function. Nor can a virtual function be a static member, since a virtual function call relies on a specific object for determining which function to invoke. A virtual function can be declared a friend in another class. An overriding function is itself considered virtual. The ID="ch1044"virtual specifier may be used for an overriding function in the derived class, but such use is redundant. A virtual function in a base class must be defined or declared pure (ID="ch1045"IDREF="42103" TYPE="TITLE""Abstract Classes"). A virtual function that has been defined in a base class need not be defined in a derived class. If it is not, the function defined for the base class is used in all calls. ID="ch1046"ID="ch1047"Explicit qualification with the scope operator (IDREF="36093" TYPE="TITLE""Primary Expressions") suppresses the virtual call mechanism. For example, class B { public: virtual void f(); };
class D : public B { public: void f(); };
void D::f() { /* ... */ B::f(); }Here, the call of f in D really does call B::f and not D::f. LBL="" HELPID=""ID="42103"Abstract ClassesID="ch1048"The abstract class mechanism supports the notion of a general concept, such as a shape, of which only more concrete variants, such as circle and square, can actually be used. An abstract class can also be used to define an interface for which derived classes provide a variety of implementations. An abstract class is a class that can be used only as a base class of some other class; no objects of an abstract class may be created except as objects representing a base class of a class derived from it. A class is abstract if it has at least one pure virtual function. A virtual function is specified ID="ch1049"pure by using a pure-specifier (IDREF="18270" TYPE="TITLE""Class Members") in the function declaration in the class declaration. ID="ch1050"A pure virtual function need be defined only if explicitly called with the qualified-name syntax (IDREF="36093" TYPE="TITLE""Primary Expressions"). For example, ID="ch1051"class point { /* ... */ };
class shape {           // abstract class
   point center;
// ...
public:
   point where() { return center; }
   void move(point p) { center=p; draw(); }
   virtual void rotate(int) = 0;  // pure virtual
   virtual void draw() = 0;       // pure virtual 
   // ...
};
ID="ch1052"An abstract class may not be used as an argument type, as a function return type, or as the type of an explicit conversion. Pointers and references to an abstract class may be declared. For example, shape x;           // error: object of abstract class
shape* p;          // ok
shape f();         // error
void g(shape);     // error
shape& h(shape&);  // ok
ID="ch1053"Pure virtual functions are inherited as pure virtual functions. For example, class ab_circle : public shape {
   int radius;
public:
   void rotate(int) {}
   // ab_circle::draw() is a pure virtual
};Since shape::draw() is a pure virtual function ab_circle::draw() is a pure virtual by default. The alternative declaration, class circle : public shape {
   int radius;
public:
   void rotate(int) {}
   void draw(); // must be defined somewhere
};would make class circle non-abstract and a definition of circle::draw() must be provided somewhere. ID="ch1054"Member functions can be called from a constructor of an abstract class; the effect of calling a pure virtual function directly or indirectly for the object being created from such a constructor is undefined. ID="ch1055"LBL="" HELPID=""ID="28183"Summary of Scope RulesID="ch1056"The scope rules for C++ programs can now be summarized. These rules apply uniformly for all names (including typedef-names (IDREF="13818" TYPE="TITLE""The typedef Specifier") and class-names (IDREF="12565" TYPE="TITLE""Class Names")) wherever the grammar allows such names in the context discussed by a particular rule. This section discusses lexical scope only; see IDREF="22763" TYPE="TITLE""Program and Linkage" for an explanation of linkage issues. The notion of point of declaration is discussed in (IDREF="24244" TYPE="TITLE""Scopes"). Any use of a name must be unambiguous (up to overloading) in its scope (IDREF="23630" TYPE="TITLE""Ambiguities"). Only if the name is found to be unambiguous in its scope are access rules considered (IDREF="40678" TYPE="TITLE"Chapter 11, "Member Access Control"). Only if no access control errors are found is the type of the object, function, or enumerator named considered. A name used outside any function and class or prefixed by the unary scope operator :: (and not qualified by the binary :: operator or the -> or . operators) must be the name of a global object, function, enumerator, or type. A name specified after X::, after obj., where obj is an X or a reference to X, or after ptr->, where ptr is a pointer to X must be the name of a member of class X or be a member of a base class of X. In addition, ptr in ptr-> may be an object of a class Y that has operator->() declared so ptr->operator->() eventually resolves to a pointer to X (IDREF="20121" TYPE="TITLE""Class Member Access").A name that is not qualified in any of the ways described above and that is used in a function that is not a class member must be declared in the block in which it occurs or in an enclosing block or be a global name. The declaration of a local name hides declarations of the same name in enclosing blocks and global names. In particular, no overloading occurs of names in different scopes (IDREF="39747" TYPE="TITLE""Overloaded Operators"). A name that is not qualified in any of the ways described above and that is used in a function that is a non-static member of class X must be declared in the block in which it occurs or in an enclosing block, be a member of class X or a base class of class X, or be a global name. The declaration of a local name hides declarations of the same name in enclosing blocks, members of the function's class, and global names. The declaration of a member name hides declarations of the same name in base classes and global names. A name that is not qualified in one of the ways described above and is used in a static member function of a class X must be declared in the block in which it occurs, in an enclosing block, be a static member of class X, or a base class of class X, or be a global name. A function argument name in a function definition (IDREF="20795" TYPE="TITLE""Function Definitions") is in the scope of the outermost block of the function (in particular, it is a local name). A function argument name in a function declaration (IDREF="34712" TYPE="TITLE""Functions") that is not a function definition is in a local scope that disappears immediately after the function declaration. A default argument is in the scope determined by the point of declaration (IDREF="24244" TYPE="TITLE""Scopes") of its formal argument, but may not access local variables or non-static class members; it is evaluated at each point of call (IDREF="27816" TYPE="TITLE""Default Arguments"). A ctor-initializer (IDREF="36383" TYPE="TITLE""Initializing Bases and Members") is evaluated in the scope of the outermost block of the constructor it is specified for. In particular, it can refer to the constructor's argument names. LBL="11"ID="40678"Member Access ControlThis Chapter contains the following subsections:IDREF="38800" TYPE="TITLE""Access Specifiers"IDREF="32027" TYPE="TITLE""Access Specifiers for Base Classes"IDREF="23067" TYPE="TITLE""Access Declarations"IDREF="13398" TYPE="TITLE""Friends"IDREF="31696" TYPE="TITLE""Protected Member Access"IDREF="40260" TYPE="TITLE""Access to Virtual Functions"IDREF="21278" TYPE="TITLE""Multiple Access"A member of a class can be ID="ch111"ID="ch112"ID="ch113"private; that is, its name can be used only by member functions and friends of the class in which it is declared. ID="ch114"protected; that is, its name can be used only by member functions and friends of the class in which it is declared and by member functions and friends of classes derived from this class (see IDREF="31696" TYPE="TITLE""Protected Member Access"). ID="ch115"public; that is, its name can be used by any function. ID="ch116"ID="ch117"Members of a class declared with the keyword class are private by default. Members of a class declared with the keywords struct or union are public by default. For example, class X {
   int a;  // X::a is private by default
};
struct S {
   int a;  // S::a is public by default
};LBL="" HELPID=""ID="38800"Access SpecifiersID="ch118"Member declarations may be labeled by an access-specifier (IDREF="37638" TYPE="TITLE"Chapter 10, "Derived Classes"): access-specifier : member-listoptAn access-specifier specifies the access rules for members following it until the end of the class or until another access-specifier is encountered. For example, class X {
   int a;  // X::a is private by default: 'class' used
public:
   int b;  // X::b is public
   int c;  // X::c is public
};Any number of access specifiers is allowed and no particular order is required. For example, struct S {
   int a;  // S::a is public by default: 'struct' used
protected:
   int b;  // S::b is protected
private:
   int c;  // S::c is private
public:
   int d;  // S::d is public
};
ID="ch119"The order of allocation of data members with separate access-specifier labels is implementation dependent (IDREF="18270" TYPE="TITLE""Class Members"). ID="ch1110"LBL="" HELPID=""ID="32027"Access Specifiers for Base ClassesID="ch1111"ID="ch1112"ID="ch1113"ID="ch1114"If a class is declared to be a base class (IDREF="37638" TYPE="TITLE"Chapter 10, "Derived Classes") for another class using the public access specifier, the public members of the base class are public members of the derived class and protected members of the base class are protected members of the derived class. If a class is declared to be a base class for another class using the private access specifier, the public and protected members of the base class are private members of the derived class. Private members of a base class remain inaccessible even to derived classes unless friend declarations within the base class declaration are used to grant access explicitly. In the absence of an access-specifier for a base class, public is assumed when the derived class is declared struct and private is assumed when the class is declared class. For example, class B { /* ... */ };
class D1 : private B { /* ... */ };
class D2 : public B { /* ... */ };
class D3 : B { /* ... */ };    // 'B' private by default
struct D4 : public B { /* ... */ };
struct D5 : private B { /* ... */ };
struct D6 : B { /* ... */ };   // 'B' public by defaultHere B is a public base of D2, D4, and D6, and a private base of D1, D3, and D5. Specifying a base class private does not affect access to static members of the base class. If, however, an object or a pointer requiring conversion is used to select the static member the usual rules for pointer conversions apply. Members and friends of a class X can implicitly convert an X* to a pointer to a private immediate base class of X. LBL="" HELPID=""ID="23067"Access DeclarationsID="ch1115"ID="ch1116"The access to a member of a base class in a derived class can be adjusted by mentioning its qualified-name in the public or protected part of a derived class declaration. Such mention is called an access declaration. For example, ID="ch1117"class B {
   int a;
public:
   int b, c;
   int bf();
};
class D : private B {
   int d;
public:
   B::c;  // adjust access to `B::c'
   int e;
   int df();
};
int ef(D&);The external function ef can use only the names c, e, and df. Being a member of D, the function df can use the names b, c, bf, d, e, and df, but not a. Being a member of B, the function bf can use the members a, b, c, and bf. An access declaration may not be used to restrict access to a member that is accessible in the base class, nor may it be used to enable access to a member that is not accessible in the base class. For example, class B {
public:
   int a;
private:
   int b;
protected:
   int c;
};
class D : private B {
public:
   B::a;  // make 'a' a public member of D
   B::b;  // error: attempt to grant access
          // can't make 'b' a public member of D
protected:
   B::c;  // make 'c' a protected member of D
   B::a;  // error: attempt to reduce access
          // can't make 'a' a protected member of D
};
ID="ch1118"An access declaration for the name of an overloaded function adjusts the access to all functions of that name in the base class. For example, class X {
public:
   f();
   f(int);
};
class Y : private X {
public:
   X::f;  // makes X::f() and X::f(int) public in Y
};     The access to a base class member cannot be adjusted in a derived class that also defines a member of that name. For example, class X {
public:
   void f();
};
class Y : private X {
public:
   void f(int);
   X::f;  // error: two declarations of f
};LBL="" HELPID=""ID="13398"FriendsID="ch1119"A friend of a class is a function that is not a member of the class but is permitted to use the private and protected member names from the class. The name of a friend is not in the scope of the class, and the friend is not called with the member access operators (IDREF="21265" TYPE="TITLE""Class Member Access") unless it is a member of another class. The following example illustrates the differences between members and friends: ID="ch1120"ID="ch1121"ID="ch1122"class X {
   int a;
   friend void friend_set(X*, int);
public:
   void member_set(int);
};void friend_set(X* p, int i) { p->a = i; }void X::member_set(int i) { a = i; }void f()
{
   X obj;
   friend_set(&obj,10);
   obj.member_set(10);
}
ID="ch1123"When a friend declaration refers to an overloaded name or operator, only the function specified by the argument types becomes a friend. A member function of a class X can be a friend of a class Y. For example, ID="ch1124"class Y {
   friend char* X::foo(int);
   // ...
};All the functions of a class X can be made friends of a class Y by a single declaration using an elaborated-type-specifier (IDREF="12565" TYPE="TITLE""Class Names"): ID="ch1125"class Y {
   friend class X;
   // ...
};
ID="ch1126"Declaring a class to be a friend also implies that private and protected names from the class granting friendship can be used in the class receiving it. For example, class X {
   enum { a=100 };
   friend class Y;
};
class Y {
   int v[X::a];  // ok, Y is a friend of X
};
class Z {
   int v[X::a];  // error: X::a is private
};If a class or a function mentioned as a friend has not been declared its name is entered in the same scope as the name of the class containing the friend declaration (IDREF="12565" TYPE="TITLE""Class Names"). ID="ch1127"A function first declared in a friend declaration is equivalent to an extern declaration (IDREF="22763" TYPE="TITLE""Program and Linkage", IDREF="12029" TYPE="TITLE""Storage Class Specifiers"). ID="ch1128"A friend function defined in a class declaration is inline and the rewriting rule specified for member functions (IDREF="41223" TYPE="TITLE""Inline Member Functions") is applied. A friend function defined in a class is in the (lexical) scope of the class in which it is defined. A friend function defined outside the class is not.ID="ch1129"Friend declarations are not affected by access-specifiers (IDREF="18270" TYPE="TITLE""Class Members"). ID="ch1130"Friendship is neither inherited nor transitive. For example, class A {
   friend class B;
   int a;
};
class B {
   friend class C;
};
class C  {
   void f(A* p)
   {
      p->a++;  // error: C is not a friend of A
               // despite being a friend of a friend
   } 
};
class D : public B  {
   void f(A* p)
   {
      p->a++;  // error: D is not a friend of A
               // despite being derived from a friend
   }
};LBL="" HELPID=""ID="31696"Protected Member AccessID="ch1131"A friend or a member function of a derived class can access a protected static member of a base class. A friend or a member function of a derived class can access a protected non-static member of one of its base classes only through a pointer to, reference to, or object of the derived class (or any class derived from that class). For example, class B {
protected:
   int i;
};
class D1 : public B {
};
class D2 : public B {
   friend void fr(B*,D1*,D2*);
   void mem(B*,D1*);
};
void fr(B* pb, D1* p1, D2* p2)
{
   pb->i = 1;  // illegal
   p1->i = 2;  // illegal
   p2->i = 3;  // ok (access through a D2)
}
void D2::mem(B* pb, D1* p1)
{
   pb->i = 1;  // illegal
   p1->i = 2;  // illegal
   i = 3;      // ok (access through `this')
}
void g(B* pb, D1* p1, D2* p2)
{
   pb->i = 1;  // illegal
   p1->i = 2;  // illegal
   p2->i = 3;  // illegal
}LBL="" HELPID=""ID="40260"Access to Virtual FunctionsID="ch1132"The access rules (IDREF="40678" TYPE="TITLE"Chapter 11, "Member Access Control") for a virtual function are determined by its declaration and are not affected by the rules for a function that later overrides it. For example, class B {
public:
   virtual f();
};
class D : public B {
private:
   f();
};
void f()
{
   D d;
   B* pb = &d;
   D* pd = &d;
   pb->f();  // ok: B::f() is public,
             // D::f() is invoked
   pd->f();  // error: D::f() is private 
}Access is checked at the call point using the type of the expression used to denote the object for which the member function is called ( B* in the example above). The access of the member function in the class in which it was defined ( D in the example above) is in general not known. LBL="" HELPID=""ID="21278"Multiple AccessIf a name can be reached by several paths through a multiple inheritance graph, the access is that of the path that gives most access. For example, class W { public: void f(); }; class A : private virtual W { };
class B : public virtual W { }; class C : public A, public B {
          void f() { W::f(); }  // ok };Since W::f() is available to C::f() along the public path through B, access is legal. LBL="12"ID="10620"Special Member FunctionsThis chapter contains the following subsections:IDREF="21970" TYPE="TITLE""Constructors"IDREF="18236" TYPE="TITLE""Temporary Objects"IDREF="31355" TYPE="TITLE""Conversions"IDREF="29867" TYPE="TITLE""Destructors"IDREF="36583" TYPE="TITLE""Free Store"IDREF="15668" TYPE="TITLE""Initialization"IDREF="11773" TYPE="TITLE""Constructors and Destructors"IDREF="34465" TYPE="TITLE""Copying Class Objects"Some member functions are special in that they affect the way objects of a class are created, copied, and destroyed, and how values may be converted to values of other types. Often such special functions are called implicitly. ID="ch121"ID="ch122"These member functions obey the usual access rules (IDREF="40678" TYPE="TITLE"Chapter 11, "Member Access Control"). For example, declaring a constructor protected ensures that only derived classes and friends can create objects using it. LBL="" HELPID=""ID="21970"ConstructorsID="ch123"A member function with the same name as its class is called a constructor; it is used to construct values of its class type. If a class has a constructor, each object of that class will be initialized before any use is made of the object; see IDREF="15668" TYPE="TITLE""Initialization". ID="ch124"ID="ch125"A constructor can be invoked for a const or volatile object. A constructor may not be declared ID="ch126"const or volatile (IDREF="28120" TYPE="TITLE""The this Pointer"). A constructor may not be virtual. A constructor may not be static. Constructors are not inherited. Default constructors and copy constructors, however, are generated (by the compiler) where needed (ID="ch127"ID="ch128"ID="ch129"IDREF="34465" TYPE="TITLE""Copying Class Objects"). Generated constructors are public. ID="ch1210"A default constructor for a class X is a constructor of class X that can be called without an argument. A default constructor will be generated for a class ID="ch1211"X only if no constructor has been declared for class X. ID="ch1212"ID="ch1213"A copy constructor for a class X is a constructor that can be called to copy an object of class X; that is, one that can be called with a single argument of type X. For example, X::X(constX&) and X::X(X&,int=0) are copy constructors. A copy constructor is generated only if no copy constructor is declared. A copy constructor for a class X may not take an argument of type X. For example, X::X(X) is illegal. ID="ch1214"Constructors for array elements are called in order of increasing addresses (IDREF="30659" TYPE="TITLE""Arrays"). ID="ch1215"ID="ch1216"If a class has base classes or member objects with constructors, their constructors are called before the constructor for the derived class. The constructors for base classes are called first. See IDREF="36383" TYPE="TITLE""Initializing Bases and Members" for an explanation of how arguments can be specified for such constructors and how the order of constructor calls is determined. ID="ch1217"An object of a class with a constructor cannot be a member of a union. ID="ch1218"ID="ch1219"No return type (not even void) can be specified for a constructor. A return statement in the body of a constructor may not specify a return value. It is not possible to take the address of a constructor. ID="ch1220"ID="ch1221"ID="ch1222"A constructor can be used explicitly to create new objects of its type, using the syntax class-name( expression-listopt )For example,  ID="ch1223"complex zz = complex(1,2.3);
cprint( complex(7.8,1.2) );An object created in this way is unnamed (unless the constructor was used as an initializer for a named variable as for zz above), with its lifetime limited to the expression in which it is created; see IDREF="18236" TYPE="TITLE""Temporary Objects". ID="ch1224"Member functions may be called from within a constructor; see IDREF="11773" TYPE="TITLE""Constructors and Destructors". LBL="" HELPID=""ID="18236"Temporary ObjectsID="ch1225"ID="ch1226"ID="ch1227"ID="ch1228"In some circumstances it may be necessary or convenient for the compiler to generate a temporary object. Such introduction of temporaries is implementation dependent. When a compiler introduces a temporary object of a class that has a constructor it must ensure that a constructor is called for the temporary object. ID="ch1229"ID="ch1230"ID="ch1231"Similarly, the destructor must be called for a temporary object of a class where a destructor is declared. For example, class X {
   // ...
public:
   // ...
   X(int);
   X(X&);
   ~X();
};
X f(X);
void g()
{
   X a(1);
   X b = f(X(2));
   a = f(a);
}Here, one might use a temporary in which to construct ID="ch1232"ID="ch1233"X(2) before passing it to f() by X(X&); alternatively, X(2) might be constructed in the space used to hold the argument for the first call of f(). Also, a temporary might be used to hold the result of f(X(2)) before copying it to b by X(X&); alternatively, f()'s result might be constructed in b. On the other hand, for many functions , the expression a=f(a) requires a temporary for either the argument a or the result of f(a) to avoid undesired aliasing of a. ID="ch1234"The compiler must ensure that a temporary object is destroyed. The exact point of destruction is implementation dependent. There are only two things that can be done with a temporary: fetch its value (implicitly copying it) to use in some other expression, or bind a reference to it. If the value of a temporary is fetched, that temporary is then dead and can be destroyed immediately. If a reference is bound to a temporary, the temporary must not be destroyed until the reference is. This destruction must take place before exit from the scope in which the temporary is created. Another form of temporaries is discussed in IDREF="19032" TYPE="TITLE""References". LBL="" HELPID=""ID="31355"ConversionsID="ch1235"ID="ch1236"ID="ch1237"ID="ch1238"ID="ch1239"Type conversions of class objects can be specified by constructors and by conversion functions. Such conversions, often called user-defined conversions, are used implicitly in addition to standard conversions (IDREF="31385" TYPE="TITLE"Chapter 4, "Standard Conversions"). For example, a function expecting an argument of type X can be called not only with an argument of type X but also with an argument of type T where a conversion from T to X exists. User-defined conversions are used similarly for conversion of initializers (ID="ch1240"IDREF="23366" TYPE="TITLE""Initializers"), function arguments (IDREF="27725" TYPE="TITLE""Function Call", IDREF="34712" TYPE="TITLE""Functions"), function return values (IDREF="11995" TYPE="TITLE""The return Statement", IDREF="34712" TYPE="TITLE""Functions"), expression operands (IDREF="28885" TYPE="TITLE"Chapter 5, "Expressions"), expressions controlling iteration and selection statements (IDREF="28691" TYPE="TITLE""Selection Statements",IDREF="28413" TYPE="TITLE""Iteration Statements"), and explicit type conversions (IDREF="35361" TYPE="TITLE""Explicit Type Conversion", IDREF="14761" TYPE="TITLE""Explicit Type Conversion"). User-defined conversions are applied only where they are unambiguous (IDREF="23630" TYPE="TITLE""Ambiguities", IDREF="37211" TYPE="TITLE""Conversion Functions"). Conversions obey the access control rules (IDREF="40678" TYPE="TITLE"Chapter 11, "Member Access Control"). As ever access control is applied after ambiguity resolution (IDREF="28183" TYPE="TITLE""Summary of Scope Rules"). See IDREF="38679" TYPE="TITLE""Argument Matching" for a discussion of the use of conversions in function calls as well as examples below. LBL="" HELPID=""Conversion by ConstructorID="ch1241"ID="ch1242"A constructor accepting a single argument specifies a conversion from its argument type to the type of its class. For example, class X {
   // ...
public:
   X(int);
   X(const char*, int = 0);
};
void f(X arg) {
   X a = 1;         // a = X(1)
   X b = "Jessie";  // b = X("Jessie",0)
   a = 2;           // a = X(2)
   f(3);            // f(X(3))
}
ID="ch1243"When no constructor for class X accepts the given type, no attempt is made to find other constructors or conversion functions to convert the assigned value into a type acceptable to a constructor for class X. For example, class X { /* ... */ X(int); };
class Y { /* ... */ Y(X); };
Y a = 1;              // illegal: Y(X(1)) not triedLBL="" HELPID=""ID="37211"Conversion FunctionsID="ch1244"ID="ch1245"ID="ch1246"A member function of a class X with a name of the form ID="ch1247"conversion-function-name:operator conversion-type-nameconversion-type-name:type-specifier-list ptr-operatoroptspecifies a conversion from X to the type specified by the conversion-type-name.Such member functions are called conversion functions. Classes, enumerations, and typedef-names may not be declared in the type-specifier-list. Neither argument types nor return type may be specified. For example,  ID="ch1248"class X {
   // ...
public:
   operator int();
};
void f(X a)
{
   int i = int(a);
   i = (int)a;
   i = a;
}In all three cases the value assigned will be converted by X::operator int(). User-defined conversions are not restricted to use in assignments and initializations. For example, void g(X a, X b)
{
   int i = (a) ? 1+a : 0;
   int j = (a&&b) ? a+b : i;
   if (a) { // ...
   }
}
ID="ch1249"Conversion operators are inherited. ID="ch1250"Conversion functions can be virtual. ID="ch1251"At most one user-defined conversion (constructor or conversion function) is implicitly applied to a single value. For example, class X {
   // ...
public:
   operator int();
};
class Y {
   // ...
public:
   operator X();
};
Y a;
int b = a;    // illegal:
              // a.operator X().operator int() not tried
int c = X(a); // ok: a.operator X().operator int()User-defined conversions are used implicitly only if they are unambiguous. A conversion function in a derived class does not hide a conversion function in a base class unless the two functions convert to the same type. For example, ID="ch1252"class X {
public:
   // ...
   operator int();
};
class Y : public X {
public:
   // ...
   operator void*();
};
void f(Y& a)
{
   if (a) {     // error: ambiguous
   // ...
   }
}LBL="" HELPID=""ID="29867"DestructorsID="ch1253"ID="ch1254"A member function of class cl named ~cl is called a destructor; it is used to destroy values of type cl immediately before the object containing them is destroyed. A destructor takes no arguments, and no return type can be specified for it (not even ID="ch1255"void). It is not possible to take the address of a destructor. A destructor can be invoked for a ID="ch1256"ID="ch1257"const or volatile object. A destructor may not be declared const or volatile (IDREF="28120" TYPE="TITLE""The this Pointer"). A destructor may not be static. ID="ch1258"Destructors are not inherited. If a base or a member has a destructor and no destructor is declared for its derived class a default destructor is generated. This generated destructor calls the destructors for bases and members of the derived class. Generated destructors are ID="ch1259"ID="ch1260"public. ID="ch1261"ID="ch1262"ID="ch1263"The body of a destructor is executed before the destructors for member objects. Destructors for non-static member objects are executed before the destructors for base classes. Destructors for non-virtual base classes are executed before destructors for virtual base classes. Destructors for non-virtual base classes are executed in reverse order of their declaration in the derived class. Destructors for virtual base classes are executed in the reverse order of their appearance in a depth-first left-to-right traversal of the directed acyclic graph of base classes; "left-to-right" is the order of appearance of the base class names in the declaration of the derived class. ID="ch1264"Destructors for elements of an array are called in reverse order of their construction. ID="ch1265"A destructor may be virtual. ID="ch1266"Member functions may be called from within a destructor; see IDREF="11773" TYPE="TITLE""Constructors and Destructors". ID="ch1267"An object of a class with a destructor cannot be a member of a union. ID="ch1268"Destructors are invoked implicitly;When an auto (IDREF="38359" TYPE="TITLE""Storage Classes") or temporary (IDREF="18236" TYPE="TITLE""Temporary Objects", IDREF="19032" TYPE="TITLE""References") object goes out of scope. For constructed static (ID="ch1269"IDREF="38359" TYPE="TITLE""Storage Classes") objects at program termination (IDREF="28875" TYPE="TITLE""Start and Termination"). Through use of the ID="ch1270"delete operator (IDREF="42326" TYPE="TITLE""Delete") for objects allocated by the new operator (IDREF="16762" TYPE="TITLE""New"). Explicitly called, when invoked by the ID="ch1271"delete operator, memory is freed by the destructor for the most derived class (IDREF="36383" TYPE="TITLE""Initializing Bases and Members") of the object using an operatordelete() (IDREF="42326" TYPE="TITLE""Delete"). For example, ID="ch1272"class X {
   // ...
public:
   X(int);
   ~X();
};void g(X*);void f()     // common use:
{
   X* p = new X(111);  // allocate and initialize
   g(p);
   delete p;           // cleanup and deallocate
}
ID="ch1273"ID="ch1274"Explicit calls of destructors are rarely needed. One use of such calls is for objects placed at specific addresses using a new operator. Such use of explicit placement and destruction of objects can be necessary to cope with dedicated hardware resources and for writing memory management facilities. For example, void* operator new(size_t, void* p) { return p; }
void f(X* p);
static char buf[sizeof(X)];
void g()     // rare, specialized use:
{
   X* p = new(buf) X(222);  // use buf[]
             // and initialize
   f(p);
   p->X::~X();              // cleanup
}
ID="ch1275"The notation for explicit call of a destructor may be used for any simple type name. For example, int* p;
// ...
p->int::~int();Using the notation for a type that does not have a destructor has no effect. Allowing this enables people to write code without having to know if a destructor exists for a given type. LBL="" HELPID=""ID="36583"Free StoreID="ch1276"When an object is created with the new operator, an operatornew() function is (implicitly) used to obtain the store needed (IDREF="16762" TYPE="TITLE""New"). If operatornew() cannot allocate storage it will return 0. ID="ch1277"An X::operatornew() for a class X is a static member (even if not explicitly declared static). Its first argument must be of type size_t, an implementation-dependent integral type defined in the standard header <stddef.h>; it must return void*. For example, class X {
   // ...
   void* operator new(size_t);
   void* operator new(size_t, Arena*);
};
ID="ch1278"See IDREF="16762" TYPE="TITLE""New" for the rules for selecting an operatornew(). ID="ch1279"An X::operatordelete() for a class X is a static member (even if not explicitly declared static) and must have its first argument of type void*; a second argument of type size_t may be added. It cannot return a value; its return type must be void. For example, ID="ch1280"class X {
   // ...
   void operator delete(void*);
};
class Y {
   // ...
   void operator delete(void*, size_t);
};
ID="ch1281"ID="ch1282"Only one operatordelete() may be declared for a single class; thus operatordelete() cannot be overloaded. The global operatordelete() takes a single argument of type void*. If the two argument style is used, operatordelete() will be called with a second argument indicating the size of the object being deleted. The size passed is determined by the destructor (if any) or by the (static) type of the pointer being deleted; that is, it will be correct either if the type of the pointer argument to the delete operator is the exact type of the object (and not, for example, just the type of base class) or if the type is that of a base class with a virtual destructor. ID="ch1283"ID="ch1284"The global operatornew() and operatordelete() are used for arrays of class objects (IDREF="16762" TYPE="TITLE""New", IDREF="42326" TYPE="TITLE""Delete"). Since X::operatornew() and X::operatordelete() are static they cannot be virtual. A destructor finds the ID="ch1285"ID="ch1286"operatordelete() to use for freeing store using the usual scope rules. For example, struct B {
   virtual ~B();
   void* operator new(size_t);
   void operator delete(void*);
};
struct D : B {
   ~D();
   void* operator new(size_t);
   void operator delete(void*);
};
void f()
{
   B* p = new D;
   delete p;
}Here, storage for the object of class D is allocated by D::operatornew() and, thanks to the virtual destructor, deallocated by D::operatordelete(). LBL="" HELPID=""ID="15668"InitializationID="ch1287"An object of a class with no constructors, no private or protected members, no virtual functions, and no base classes can be initialized using an initializer list; see IDREF="32268" TYPE="TITLE""Aggregates". An object of a class with a constructor must either be initialized or have a default constructor (ID="ch1288"ID="ch1289"IDREF="21970" TYPE="TITLE""Constructors"). The default constructor is used for objects that are not explicitly initialized. LBL="" HELPID=""ID="18434"Explicit InitializationID="ch1290"ID="ch1291"Objects of classes with constructors (IDREF="21970" TYPE="TITLE""Constructors") can be initialized with a parenthesized expression list. This list is taken as the argument list for a call of a constructor doing the initialization. Alternatively a single value is specified as the initializer using the = operator. This value is used as the argument to a copy constructor. Typically, that call of a copy constructor can be eliminated. For example, ID="ch1292"class complex {
   // ...
public:
   complex();
   complex(double);
   complex(double,double);
   // ...
};
complex sqrt(complex,complex);     
complex a(1);             // initialize by a call of
   // complex(double)
complex b = a;            // initialize by a copy of 'a'
complex c = complex(1,2); // construct complex(1,2)
   // using complex(double,double)
   // copy it into 'c'
complex d = sqrt(b,c);    // call sqrt(complex,complex)
   // and copy the result into 'd'
complex e;                // initialize by a call of
   // complex()
complex f = 3;            // construct complex(3) using
   // complex(double)
   // copy it into 'f'
ID="ch1293"Overloading of the assignment operator = has no effect on initialization. ID="ch1294"ID="ch1295"The initialization that occurs in argument passing and function return is equivalent to the form T x = a;
ID="ch1296"The initialization that occurs in new expressions (IDREF="16762" TYPE="TITLE""New") and in base and member initializers (IDREF="36383" TYPE="TITLE""Initializing Bases and Members") is equivalent to the form T x(a);
ID="ch1297"ID="ch1298"Arrays of objects of a class with constructors use constructors in initialization  (IDREF="21970" TYPE="TITLE""Constructors") just like individual objects. If there are fewer initializers in the list than elements in the array, the default constructor (IDREF="21970" TYPE="TITLE""Constructors") is used. If there is no default constructor the ID="ch1299"initializer-list must be complete. For example, complex cc = { 1, 2 }; // error; use constructor
complex v[6] = { 1,complex(1,2),complex(),2 };Here, v[0] and v[3] are initialized with complex::complex(double), v[1] is initialized with complex::complex(double,double), and v[2], v[4], and v[5] are initialized with complex::complex(). ID="ch12100"An object of class M can be a member of a class X only if (1) M does not have a constructor, or (2) M has a default constructor, or (3) X has a constructor and if every constructor of class X specifies a ctor-initializer (IDREF="36383" TYPE="TITLE""Initializing Bases and Members") for that member. In case 2 the default constructor is called when the aggregate is created. If a member of an aggregate has a destructor, then that destructor is called when the aggregate is destroyed. ID="ch12101"ID="ch12102"Constructors for non-local static objects are called in the order they occur in a file; destructors are called in reverse order. See also ID="ch12103"IDREF="28875" TYPE="TITLE""Start and Termination", IDREF="10996" TYPE="TITLE""Declaration Statement", IDREF="17418" TYPE="TITLE""Static Members". LBL="" HELPID=""ID="36383"Initializing Bases and MembersID="ch12104"ID="ch12105"Initializers for immediate base classes and for members not inherited from a base class may be specified in the definition of a constructor. This is most useful for class objects, constants, and references where the semantics of initialization and assignment differ. A ctor-initializer has the form ID="ch12106"ctor-initializer:: mem-initializer-listmem-initializer-list:mem-initializermem-initializer , mem-initializer-listID="ch12107"mem-initializer:complete-class-name ( expression-listopt )identifier ( expression-listopt )ID="ch12108"ID="ch12109"The argument list is used to initialize the named non-static member or base class object. This is the only way to initialize non-static ID="ch12110"ID="ch12111"const and reference members. For example, struct B1 { B1(int); /* ... */ };
struct B2 { B2(int); /* ... */ };
struct D : B1, B2 {
   D(int);
   B1 b;
   const c;
};
D::D(int a) : B2(a+1), B1(a+2), c(a+3), b(a+4)
{ /* ... */ }
D d(10);
ID="ch12112"First, the base classes are initialized in declaration order (independent of the order of mem-initializers), then the members are initialized in declaration order (independent of the order of ID="ch12113"mem-initializers), then the body of D::D() is executed (IDREF="21970" TYPE="TITLE""Constructors"). The declaration order is used to ensure that sub-objects and members are destroyed in the reverse order of initialization. ID="ch12114"Virtual base classes constitute a special case. Virtual bases are constructed before any non-virtual bases and in the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes; "left-to-right" is the order of appearance of the base class names in the declaration of the derived class. ID="ch12115"ID="ch12116"ID="ch12117"A complete object is an object that is not a sub-object representing a base class. Its class is said to be the most derived class for the object. All sub-objects for virtual base classes are initialized by the constructor of the most derived class. If a constructor of the most derived class does not specify a mem-initializer for a virtual base class then that virtual base class must have a default constructor or no constructors. Any mem-initializers for virtual classes specified in a constructor for a class that is not the class of the complete object are ignored. For example, class V {
public:
   V();
   V(int);
   // ...
};
class A : public virtual V {
public:
   A();
   A(int);
   // ...
};
class B : public virtual V {
public:
   B();
   B(int);
   // ...
};
class C : public A, public B, private virtual V {
public:
   C();
   C(int);
   // ...
};
A::A(int i) : V(i) { /* ... */ }
B::B(int i) { /* ... */ }
C::C(int i) { /* ... */ }
   V v(1);     // use V(int)
   A a(2);     // use V(int)
   B b(3);     // use V()
   C c(4);     // use V()
ID="ch12118"A mem-initializer is evaluated in the scope of the constructor in which it appears. For example, class X {
   int a;
public:
   const int& r;
   X(): r(a) {}
};initializes X::r to refer to X::a for each object of class X. LBL="" HELPID=""ID="11773"Constructors and DestructorsID="ch12119"ID="ch12120"Member functions may be called in constructors and destructors. This implies that virtual functions may be called (directly or indirectly). The function called will be the one defined in the constructor's (or destructor's) own class or its bases, but ID="ch12121"ID="ch12122"not any function overriding it in a derived class. This ensures that unconstructed objects will not be accessed during construction or destruction. For example, class X {
public:
   virtual void f();
   X() { f(); }   // calls X::f()
   ~X() { f(); }  // calls X::f()
};
class Y : public X {
   int& r;
public:
   void f()
   {
      r++;  // disaster if `r' is uninitialized
   }
   Y(int& rr) :r(rr) {}
};
ID="ch12123"The effect of calling a pure virtual function directly or indirectly for the object being constructed from a constructor, except using explicit qualification, is undefined (IDREF="42103" TYPE="TITLE""Abstract Classes"). LBL="" HELPID=""ID="34465"Copying Class ObjectsID="ch12124"ID="ch12125"ID="ch12126"A class object can be copied in two ways, by assignment (IDREF="32408" TYPE="TITLE""Assignment Operators") and by initialization (IDREF="21970" TYPE="TITLE""Constructors", IDREF="23366" TYPE="TITLE""Initializers") including function argument passing (IDREF="27725" TYPE="TITLE""Function Call") and function value return (IDREF="11995" TYPE="TITLE""The return Statement"). Conceptually, for a class X these two operations are implemented by an assignment operator and a copy constructor (IDREF="21970" TYPE="TITLE""Constructors"). The programmer may define either or both  the assignment operator and/or copy constructor. If not defined by the programmer, they will be defined as memberwise assignment and memberwise initialization of the members of ID="ch12127"ID="ch12128"X, respectively. ID="ch12129"If all bases and members of a class X have copy constructors accepting const arguments, the generated copy constructor for X will take a single argument of type constX&, as follows: X::X(const X&)Otherwise it will take a single argument of type  X& : X::X(X&)and initialization by copying of const X objects will not be possible. ID="ch12130"Similarly, if all bases and members of a class X have assignment operators accepting const arguments, the generated assignment operator for X will take a single argument of type constX&, as follows: X& X::operator=(const X&)Otherwise it will take a single argument of type X&: X& X::operator=(X&)and assignment by copying of constX objects will not be possible. The default assignment operator will return a reference to the object for which is invoked. ID="ch12131"Objects representing virtual base classes will be initialized only once by a generated copy constructor. Objects representing virtual base classes will be assigned only once by a generated assignment operator. ID="ch12132"ID="ch12133"Memberwise assignment and memberwise initialization implies that if a class X has a member of a class M, M's assignment operator and M's copy constructor are used to implement assignment and initialization of the member, respectively. If a class has a ID="ch12134"ID="ch12135"const member, a reference member, or a member or a base of a class with a private operator=(), the default assignment operation cannot be generated. Similarly, if a member or a base of a class M has a private copy constructor then the default copy constructor cannot be generated. ID="ch12136"ID="ch12137"The default assignment and copy constructor will be declared, but they will not be defined (that is, a function body generated) unless needed. That is, X::operator=() will be generated only if no assignment operation is explicitly declared and an object of class X is assigned an object of class X or an object of a class derived from X or if the address of X::operator= is taken. Initialization is handled similarly. ID="ch12138"ID="ch12139"If implicitly declared, the assignment and the copy constructor will be public members and the assignment operator for a class X will be defined to return a reference of type X& referring to the object assigned. ID="ch12140"If a class X has any X::operator=() that takes an argument of class X, the default assignment will not be generated. If a class has any copy constructor defined, the default copy constructor will not be generated. For example, ID="ch12141"class X {
   // ...
public:
   X(int);
   X(const X&, int = 1);
};
X a(1);         // calls X(int);
X b(a,0);       // calls X(const X&,int);
X c = b;        // calls X(const X&,int);
ID="ch12142"Assignment of class X objects is defined in terms of X::operator=(const X&). This implies (ID="ch12143"IDREF="31355" TYPE="TITLE""Conversions") that objects of a derived class can be assigned to objects of a public base class. For example, class X {
public:
   int b;
};
class Y : public X {
public:
   int c;
};
void f()
{
   X x1;
   Y y1;
   x1 = y1;     // ok
   y1 = x1;     // error
}Here y1.b is assigned to x1.b and y1.c is not copied. ID="ch12144"ID="ch12145"ID="ch12146"Copying one object into another using the default copy constructor or the default assignment operator does not change the structure of either object. For example, struct s {
   virtual f();
   // ...
};
struct ss : public s {
   f();
   // ...
};
void f()
{
   s a;
   ss b;
   a = b;      // really a.s::operator=(b)
   b = a;      // error
   a.f();      // calls s::f
   b.f();      // calls ss::f
   (s&)b = a;  // assign to b's s part
               // really ((s&)b).s::operator=(a)
   b.f();      // still calls ss::f
}The call a.f() will invoke s::f() (as is suitable for an object of class s (IDREF="23603" TYPE="TITLE""Virtual Functions")) and the call b.f() will call ss::f() (as is suitable for an object of class ss). LBL="13"ID="18871"OverloadingThis chapter contains the following subsections:IDREF="13407" TYPE="TITLE""Declaration Matching" in Chapter 13IDREF="38679" TYPE="TITLE""Argument Matching"IDREF="33093" TYPE="TITLE""Address of Overloaded Function"IDREF="39747" TYPE="TITLE""Overloaded Operators"When several different function declarations are specified for a single name in the same scope, that name is said to be overloaded. When that name is used, the correct function is selected by comparing the types of the actual arguments with the types of the formal arguments. For example, ID="ch131"ID="ch132"ID="ch133"ID="ch134"double abs(double);
int abs(int);
abs(1);       // call abs(int);
abs(1.0);     // call abs(double);Since for any type T, a T and a T& accept the same set of initializer values, functions with argument types differing only in this respect may not have the same name. For example, ID="ch135"int f(int i)
{
   // ...
}
int f(int& r)  // error: function types
               // not sufficiently different
{
   // ...
}
ID="ch136"ID="ch137"Similarly, since for any type T, a T, a const T, and a volatile T accept the same set of initializer values, functions with argument types differing only in this respect may not have the same name. It is, however, possible to distinguish between const T&, volatile T&, and plain T& so functions that differ only in this respect may be defined. Similarly, it is possible to distinguish between ID="ch138"const T*, volatile T*, and plain T* so functions that differ only in this respect may be defined. ID="ch139"Functions that differ only in the return type may not have the same name. ID="ch1310"Member functions that differ only in that one is a static member and the other isn't may not have the same name (IDREF="17418" TYPE="TITLE""Static Members"). A typedef is not a separate type, but only a synonym for another type (IDREF="13818" TYPE="TITLE""The typedef Specifier"). Therefore, functions that differ by typedef "types" only may not have the same name. For example, ID="ch1311"typedef int Int;
void f(int i) { /* ... */ }
void f(Int i) { /* ... */ } // error: redefinition of f
ID="ch1312"Enumerations, on the other hand, are distinct types and can be used to distinguish overloaded functions. For example, enum E { a };
void f(int i) { /* ... */ }
void f(E i)   { /* ... */ }
ID="ch1313"Argument types that differ only in a pointer * versus an array [] are identical. Note that only the second and subsequent array dimensions are significant in argument types (IDREF="30659" TYPE="TITLE""Arrays"). f(char*);
f(char[]);  // same as f(char*);
f(char[7]); // same as f(char*);
f(char[9]); // same as f(char*);
g(char(*)[10]);
g(char[5][10]);  // same as g(char(*)[10]);
g(char[7][10]);  // same as g(char(*)[10]);
g(char(*)[20]);  // different from g(char(*)[10]);LBL="" HELPID=""ID="13407"Declaration MatchingID="ch1314"ID="ch1315"ID="ch1316"Two function declarations of the same name refer to the same function if they are in the same scope and have identical argument types (IDREF="18871" TYPE="TITLE"Chapter 13, "Overloading"). A function member of a derived class is not in the same scope as a function member of the same name in a base class. For example, class B {
public:
   int f(int);
};
class D : public B {
public:
   int f(char*);
};
ID="ch1317"ID="ch1318"Here D::f(char*) hides B::f(int) rather than overloading it. ID="ch1319"void h(D* pd)
{
   pd->f(1);      // error:
                  // D::f(char*) hides B::f(int)
   pd->B::f(1);   // ok
   pd->f("Ben");  // ok, calls D::f
}A locally declared function is not in the same scope as a function in file scope. int f(char*);
void g()
{
   extern f(int);
   f("asdf");  // error: f(int) hides f(char*)
               // so there is no f(char*) in this scope
}Different versions of an overloaded member function may be given different access rules. For example, ID="ch1320"class buffer {
private:
   char* p;
   int size;
protected:
   buffer(int s, char* store) { size = s; p = store; }
   // ...
public:
   buffer(int s) { p = new char[size = s]; }
   // ...
};LBL="" HELPID=""ID="38679"Argument MatchingID="ch1321"ID="ch1322"ID="ch1323"ID="ch1324"ID="ch1325"A call of a given function name chooses, from among all functions by that name that are in scope and for which a set of conversions exists so that the function could possibly be called, the function that best matches the actual arguments. The best-matching function is the intersection of sets of functions that best match on each argument. Unless this intersection has exactly one member, the call is illegal. The function thus selected must be a strictly better match for at least one argument than every other possible function (but not necessarily the same argument for each function). Otherwise, the call is illegal. ID="ch1326"For purposes of argument matching, a function with n default arguments (IDREF="27816" TYPE="TITLE""Default Arguments") is considered to be n+1 functions with different numbers of arguments. ID="ch1327"For purposes of argument matching, a non-static member function is considered to have an extra argument specifying the object for which it is called. This extra argument requires a match either by the object or pointer specified in the explicit member function call notation (IDREF="21265" TYPE="TITLE""Class Member Access") or by the first operand of an overloaded operator (IDREF="39747" TYPE="TITLE""Overloaded Operators"). No temporaries will be introduced for this extra argument and no user-defined conversions will be applied to achieve a type match. Where a member of a class X is explicitly called for a pointer using the -> operator, this extra argument is assumed to have type constX* for const members, volatileX* for volatile members, and X* for others. Where the member function is explicitly called for an object using the . operator or the function is invoked for the first operand of an overloaded operator (IDREF="39747" TYPE="TITLE""Overloaded Operators"), this extra argument is assumed to have type const X& for const members, volatile X& for volatile members, and X& for others. The first operand of ->* and .* is treated in the same way as the first operand of -> and . , respectively. ID="ch1328"An ellipsis in a formal argument list (IDREF="34712" TYPE="TITLE""Functions") is a match for an actual argument of any type. ID="ch1329"For a given actual argument, no sequence of conversions will be considered that contains more than one user-defined conversion or that can be shortened by deleting one or more conversions into another sequence that leads to the type of the corresponding formal argument of any function in consideration. Such a sequence is called a best-matching sequence. For example, int->float->double is a sequence of conversions from int to double, but it is not a best-matching sequence because it contains the shorter sequence int->double. ID="ch1330"Except as mentioned below, the following trivial conversions involving a type T do not affect which of two conversion sequences is better: From:To:TT&T&TT[]T*T(args)T(*)(args)Tconst TTvolatile TT*const T*T*volatile T*Sequences of trivial conversions that differ only in order are indistinguishable. Note that functions with arguments of type T, const T, volatile T, T&, const T&, and volatile T& accept exactly the same set of values. Where necessary, const and volatile are used as tie-breakers as described in rule [1] below. A temporary variable is needed for a formal argument of type T& if the actual argument is not an lvalue, has a type different from T, or is a volatile and T is not. This does not affect argument matching. It may, however, affect the legality of the resulting match since a temporary may not be used to initialize a non- const reference (IDREF="19032" TYPE="TITLE""References"). Sequences of conversions are considered according to these rules: ID="ch1331"[1] Exact match: Sequences of zero or more trivial conversions are better than all other sequences. Of these, those that do not convert ID="ch1332"T* to const T*, T* to volatile T*, T& to const T&, or T& to volatile T& are better than those that do. [2] Match with promotions: Of sequences not mentioned in [1], those that contain only integral promotions (ID="ch1333"IDREF="37419" TYPE="TITLE""Integral Promotions"), conversions from float to double, and trivial conversions are better than all others. [3] Match with standard conversions: Of sequences not mentioned in [2], those with only standard (ID="ch1334"IDREF="37419" TYPE="TITLE""Integral Promotions", IDREF="34525" TYPE="TITLE""Integral Conversions", IDREF="35201" TYPE="TITLE""Float and Double", IDREF="31942" TYPE="TITLE""Floating and Integral", IDREF="13939" TYPE="TITLE""Arithmetic Conversions", IDREF="25158" TYPE="TITLE""Pointer Conversions", IDREF="29340" TYPE="TITLE""Reference Conversions", IDREF="23730" TYPE="TITLE""Pointers to Members") and trivial conversions are better than all others. Of these, if B is publicly derived directly or indirectly from A, converting a B* to A* is better than converting to void* or constvoid*; further, if C is publicly derived directly or indirectly from B, converting a C* to B* is better than converting to A* and converting a C& to B& is better than converting to A&. The class hierarchy acts similarly as a selection mechanism for pointer to member conversions (IDREF="23730" TYPE="TITLE""Pointers to Members"). [4] Match with user-defined conversions: Of sequences not mentioned in [3], those that involve only user-defined conversions (ID="ch1335"IDREF="31355" TYPE="TITLE""Conversions"), standard (IDREF="31385" TYPE="TITLE"Chapter 4, "Standard Conversions,") and trivial conversions are better than all other sequences. [5] Match with ellipsis: Sequences that involve matches with the ellipsis are worse than all others. ID="ch1336"ID="ch1337"User-defined conversions are selected based on the type of variable being initialized or assigned. class Y {
   // ...
public:
   operator int();
   operator double();
};
void f(Y y)
{
   int i = y;    // call Y::operator int()
   double d;
   d = y;        // call Y::operator double()
   float f = y;  // error: ambiguous
}
ID="ch1338"Standard conversions (IDREF="31385" TYPE="TITLE"Chapter 4, "Standard Conversions") may be applied to the argument for a user-defined conversion, and to the result of a user-defined conversion. struct S {  S(long); operator int(); };
void f(long), f(char*);
void g(S), g(char*);
void h(const S&), h(char*);
void k(S& a)
{
   f(a);     // f(long(a.operator int()))
   g(1);     // g(S(long(1)))
   h(1);     // h(S(long(1)))
}
ID="ch1339"If user-defined coercions are needed for an argument, no account is taken of any standard coercions that might also be involved. For example, class x { 
public:
   x(int);
};
class y {
public:
   y(long);
};
void f(x);
void f(y);
void g()
{
   f(1);     // ambiguous
}The call f(1) is ambiguous despite f(y(long(1))) needing one more standard conversion than f(x(1)). No preference is given to conversion by constructor (IDREF="21970" TYPE="TITLE""Constructors") over conversion by conversion function (IDREF="37211" TYPE="TITLE""Conversion Functions") or vice versa. struct X {
   operator int();
};
struct Y {
   Y(X);
};
Y operator+(Y,Y);
void f(X a, X b)
{
   a+b;  // error, ambiguous:
         // operator+(Y(a), Y(b)) or
         // a.operator int() + b.operator int()
}LBL="" HELPID=""ID="33093"Address of Overloaded FunctionID="ch1340"A use of a function name without arguments selects, among all functions of that name that are in scope, the (only) function that exactly matches the target. The target may be an object being initialized (IDREF="23366" TYPE="TITLE""Initializers") the left side of an assignment (IDREF="32408" TYPE="TITLE""Assignment Operators") a formal argument of a function (IDREF="27725" TYPE="TITLE""Function Call") a formal argument of a user-defined operator (IDREF="39747" TYPE="TITLE""Overloaded Operators") a function return type (IDREF="34712" TYPE="TITLE""Functions") Note that if f() and g() are both overloaded functions, the cross product of possibilities must be considered to resolve f(&g), or the equivalent expression f(g). For example, int f(double);
int f(int);
int (*pfd)(double) = &f; 
int (*pfi)(int) = &f;
int (*pfe)(...) = &f; // error: type mismatchThe last initialization is an error because no f() with type int(...) has been defined, and not because of any ambiguity. ID="ch1341"Note also that there are no standard conversions (IDREF="31385" TYPE="TITLE"Chapter 4, "Standard Conversions") of one pointer to function type into another (IDREF="25158" TYPE="TITLE""Pointer Conversions"). In particular, even if B is a public base of D we haveD* f();
B* (*p1)() = &f;       // error
void g(D*);
void (*p2)(B*) = &g;   // errorLBL="" HELPID=""ID="39747"Overloaded OperatorsID="ch1342"ID="ch1343"ID="ch1344"Most operators can be overloaded. The complier recognizes various functions through the context in which the function call is used. The  operands or arguments are different in types and number. This ability to recognize function calls in context allows most operators to be redefined for special-purpose overload functions.The  operator-function-name ID="ch1345"ID="ch1346"ID="ch1347"is the keyword operator followed by the operator symbol. When defining the operator's new overload action, the  operator-function-nameID="ch1348"ID="ch1349"ID="ch1350" is used, just as a regular function name would be used. For example,operatorID="ch1351"s: one ofnew  delete+    -    *    /    %    ^    &    |    ~!    =    <    >    +=   -=   *=   /=   %=^=   &=   |=   <<   >>   >>=  <<=  ==   !=<=   >=   &&   ||   ++   --   ,    ->*  ->()   []The last two operators are function call (IDREF="27725" TYPE="TITLE""Function Call") and subscripting (IDREF="22794" TYPE="TITLE""Subscripting"). ID="ch1352"ID="ch1353"Both the unary and binary forms of +    -    *     &can be overloaded. ID="ch1354"The following operators cannot be overloaded: .   .*   ::    ?:    sizeofnor can the preprocessing symbols # and ## (IDREF="15280" TYPE="TITLE"Chapter 16, "Preprocessing"). ID="ch1355"Operator functions are usually not called directly; instead they are invoked to implement operators (IDREF="19295" TYPE="TITLE""Unary Operators", IDREF="37473" TYPE="TITLE""Binary Operators"). They can be explicitly called, though. For example, complex z = a.operator+(b);  // complex z = a+b;
void* p = operator new(sizeof(int)*n);The operators new and delete are described in IDREF="16762" TYPE="TITLE""New" and IDREF="42326" TYPE="TITLE""Delete" and the rules described below in this section do not apply to them. ID="ch1356"An operator function must either be a member function or take at least one argument of a class or a reference to a class. It is not possible to change the precedence, grouping, or number of operands of operators. The predefined meaning of the operators =, (unary) &, and , (comma) applied to class objects may be changed. Except for ID="ch1357"operator=(), operator functions are inherited; see IDREF="34465" TYPE="TITLE""Copying Class Objects" for the rules for operator=(). ID="ch1358"Identities among operators applied to basic types (for example, ++a name='equiv' font=symbol charset=fontspecific code=186
			descr='[equiv]'\xba \xba  a+=1) need not hold for operators applied to class types. Some operators, for example, +=, require an operand to be an lvalue when applied to basic types; this is not required when the operators are declared for class types. ID="ch1359"An overloaded operator cannot have default arguments (IDREF="27816" TYPE="TITLE""Default Arguments"). Operators not mentioned explicitly below in IDREF="26631" TYPE="TITLE""Assignment" to IDREF="28106" TYPE="TITLE""Increment and Decrement" act as ordinary unary and binary operators obeying the rules of section IDREF="19295" TYPE="TITLE""Unary Operators" or IDREF="37473" TYPE="TITLE""Binary Operators". LBL="" HELPID=""ID="19295"Unary OperatorsID="ch1360"A prefix unary operator may be declared by a non-static member function (IDREF="34481" TYPE="TITLE""Member Functions") taking no arguments or a non-member function taking one argument. Thus, for any prefix unary operator ID="ch1361"@, @x can be interpreted as either x.operator@() or operator@(x). If both forms of the operator function have been declared, argument matching (IDREF="38679" TYPE="TITLE""Argument Matching") determines which, if any, interpretation is used. See IDREF="28106" TYPE="TITLE""Increment and Decrement" for an explanation of postfix unary operators, that is, ++ and --. LBL="" HELPID=""ID="37473"Binary OperatorsID="ch1362"A binary operator may be declared either by a non-static member function (IDREF="34481" TYPE="TITLE""Member Functions") taking one argument or by a non-member function taking two arguments. Thus, for any binary operator ID="ch1363"@, x@y can be interpreted as either x.operator@(y) or operator@(x,y). If both forms of the operator function have been declared, argument matching (IDREF="38679" TYPE="TITLE""Argument Matching") determines which, if any, interpretation is used. LBL="" HELPID=""ID="26631"AssignmentThe assignment function ID="ch1364"operator=() must be a non-static member function; it is not inherited (IDREF="34465" TYPE="TITLE""Copying Class Objects"). Instead, unless the user defines ID="ch1365"ID="ch1366"operator= for a class X, operator= is defined, by default, as memberwise assignment of the members of class X. X& X::operator=(const X& from)
{
   // copy members of X
}LBL="" HELPID=""Function CallID="ch1367"Function call primary-expression ( expression-listopt )is considered a binary operator with the primary-expression as the first operand and the possibly empty expression-list as the second. The name of the defining function is operator(). Thus, a call x(arg1,arg2,arg3) is interpreted as x.operator()(arg1,arg2,arg3) for a class object x. operator() must be a non-static member function. LBL="" HELPID=""ID="16865"SubscriptingID="ch1368"Subscripting primary-expression [ expression ]is considered a binary operator. A subscripting expression x[y] is interpreted as x.operator[](y) for a class object x. operator[] must be a non-static member function. LBL="" HELPID=""ID="20121"Class Member AccessID="ch1369"Class member access using ->primary-expression -> primary-expressionis considered a unary operator. An expression x->m is interpreted as (x.operator->())->m for a class object x. It follows that operator->() must return either a pointer to a class or an object of or a reference to a class for which operator->() is defined. operator-> must be a non-static member function. LBL="" HELPID=""ID="28106"Increment and DecrementID="ch1370"ID="ch1371"ID="ch1372"ID="ch1373"A function called operator++ taking one argument defines the prefix increment operator ++ for objects of some class. A function called operator++ taking two arguments defines the postfix increment operator ++ for objects of some class. For postfix operator++, the second argument must be of type int and the operator++() will be called with the second argument 0 when invoked by a postfix increment expression. For example, class X {
public:
   X operator++();     // prefix ++a
   X operator++(int);  // postfix a++
};
void f(X a)
{
   ++a;     // a.operator++();
   a++;     // a.operator++(0);
   a.operator++();   // explicit call: like ++a;
   a.operator++(0);  // explicit call: like a++;
}The prefix and postfix decrement operators -- are handled similarly. LBL="14"ID="18442"TemplatesThis chapter contains the following subsections:IDREF="19584" TYPE="TITLE""Class Templates"IDREF="23560" TYPE="TITLE""Type Equivalence"IDREF="28306" TYPE="TITLE""Function Templates"IDREF="32960" TYPE="TITLE""Declarations and Definitions"IDREF="34117" TYPE="TITLE""Member Function Templates"IDREF="15676" TYPE="TITLE""Friends"IDREF="41138" TYPE="TITLE""Static Members and Variables"A template defines a family of types or functions. ID="ch141"ID="ch142"template-declaration:template < template-argument-list > declarationID="ch143"template-argument-list: template-argumenttemplate-argument-list , template argumentID="ch144"template-argument:type-argumentargument-declarationID="ch145"type-argument:class identifierThe declaration in a template-declaration must declare or define a function or a class. A type-argument defines its identifier to be a type-name in the scope of the template declaration. Template names obey the usual scope and access control rules. A template-declaration is a declaration. A template-declaration may appear only as a global declaration. LBL="" HELPID=""ID="19584"Class TemplatesA class template specifies how individual classes can be constructed much as a class declaration specifies how individual objects can be constructed. A vector class template might be declared like this: template<class T> class vector {
   T* v;
   int sz;
public:
   vector(int);
   T& operator[](int);
   T& elem(int i) { return v[i]; }
   // ...
};The prefix template <class T> specifies that a template is being declared and that a type-name T will be used in the declaration. In other words, vector is a parameterized type with T as its parameter. A class can be specified by a template-class-name: ID="ch146"template-class-name:template-name < template-arg-list >ID="ch147"template-arg-list:template-argtemplate-arg-list , template-argID="ch148"template-arg:expressiontype-nameID="ch149"A template-class-name is a class-name (IDREF="12565" TYPE="TITLE""Class Names"). A class generated from a class template is called a template class, as is a class specifically defined with a template-class-name as its name; see IDREF="34117" TYPE="TITLE""Member Function Templates". A template-class-name where the template-name is not defined names an undefined class. A class template name must be unique in a program and may not be declared to refer to any other template, class, function, object, value, or type in the same scope. The types of the template-args specified in a template-class-name must match the types specified for the template in its template-argument-list. Other template-args must be constant-expressions, addresses of objects or functions with external linkage, or of static class members. An exact match (IDREF="38679" TYPE="TITLE""Argument Matching") is required for non-type arguments. For example, vectors can be used like this: vector<int> v1(20);
vector<complex> v2(30);
typedef vector<complex> cvec;  // make cvec a synonym
   // for vector<complex>
cvec v3(40); // v2 and v3 are of the same type
v1[3] = 7;
v2[3] = v3.elem(4) = complex(7,8);Here, vector<int> and vector<complex> are template classes, and their definitions will by default be generated from the vector template. Since a template-class-name is a class-name, it can be used wherever a class-name can be used. For example, class vector<Shape*>;
vector<Window>* current_window;
class svector : public vector<Shape*> { /* ... */ };Definition of class template member functions is described in IDREF="15676" TYPE="TITLE""Friends". LBL="" HELPID=""ID="23560"Type EquivalenceID="ch1410"Two template-class-names refer to the same class if their template names are identical and their arguments have identical values. For example, template<class E, int size> class buffer;
buffer<char,2*512> x;
buffer<char,1024> y;
buffer<char,512> z;declares x and y to be of the same type and z of a different type, and template<class T, void(*err_fct)()>
   class list { /* ... */ };
list<int,&error_handler1> x1;
list<int,&error_handler2> x2;
list<int,&error_handler2> x3;
list<char,&error_handler2> x4;declares x2 and x3 to be of the same type. Their type differs from the types of x1 and x4. LBL="" HELPID=""ID="28306"Function TemplatesID="ch1411"A function template specifies how individual functions can be constructed. A family of sort functions, for example, might be declared like this: template<class T> void sort(vector<T>);A function template specifies an unbounded set of (overloaded) functions. A function generated from a function template is called a template function, as is a function defined with a type that matches a function template; see IDREF="34117" TYPE="TITLE""Member Function Templates". Template arguments are not explicitly specified when calling a function template; instead, overloading resolution is used. For example, ID="ch1412"vector<complex> cv(100);
vector<int> ci(200);
void f(vector<complex>& cv, vector<int>& ci)
{
   sort(cv);     // invoke sort(vector<complex>)
   sort(ci);     // invoke sort(vector<int>)
}A template function may be overloaded either by (other) functions of its name or by (other) template functions of that same name. Overloading resolution for template functions and other functions of the same name is done in three steps: [1] Look for an exact match (IDREF="38679" TYPE="TITLE""Argument Matching") on functions; if found, call it. [2] Look for a function template from which a function that can be called with an exact match can be generated; if found, call it. [3] Try ordinary overloading resolution (IDREF="38679" TYPE="TITLE""Argument Matching") for the functions; if a function is found, call it. If no match is found the call is an error. In each case, if there is more than one alternative in the first step that finds a match, the call is ambiguous and is an error. A match on a template (step [2]) implies that a specific template function with arguments that exactly matches the types of the arguments will be generated (IDREF="34117" TYPE="TITLE""Member Function Templates"). Not even trivial conversions (IDREF="38679" TYPE="TITLE""Argument Matching") will be applied in this case. The same process is used for type matching for pointers to functions (IDREF="33093" TYPE="TITLE""Address of Overloaded Function"). Here is an example, template<class T> T max(T a, T b) { return a>b?a:b; };
void f(int a, int b, char c, char d)
{
   int m1 = max(a,b);    // max(int a, int b)
   char m2 = max(c,d);   // max(char a, char b)
   int m3 = max(a,c);    // error: cannot generate
                         // max(int,char)
}For example, adding int max(int,int);to the example above would resolve the third call, by providing a function that could be called for max(a,c) after using the standard conversion of char to int for c. ID="ch1413"A function template definition is needed to generate specific versions of the template; only a function template declaration is needed to generate calls to specific versions. ID="ch1414"Every template-argument specified in the template-argument-list must be used in the argument types of a function template. template<class T> T* create();    // error
template<class T>
   void f() {    // error
      T a;
      // ...
}All template-arguments for a function template must be type-arguments. LBL="" HELPID=""ID="32960"Declarations and DefinitionsID="ch1415"There must be exactly one definition for each template of a given name in a program. There can be many declarations. The definition is used to generate specific template classes and template functions to match the uses of the template. ID="ch1416"Using a template-class-name constitutes a declaration of a template class. ID="ch1417"Calling a function template or taking its address constitutes a declaration of a template function. There is no special syntax for calling or taking the address of a template function; the name of a function template is used exactly as is a function name. Declaring a function with the same name as a function template with a matching type constitutes a declaration of a specific template function. ID="ch1418"ID="ch1419"If the definition of a specific template function or specific template class is needed to perform some operation and if no explicit definition of that specific template function or class is found in the program, a definition is generated. ID="ch1420"The definition of a (non-template) function with a type that exactly matches the type of a function template declaration is a definition of that specific template function. For example, template<class T> void sort(vector<T>& v) { /* ... */ }
void sort(vector<char*>& v)  { /* ... */ }Here, the function definition will be used as the sort function for arguments of type vector<char*>. For other vector types the appropriate function definition is generated from the template. ID="ch1421"A class can be defined as the definition of a template class. For example, template<class T> class stream { /* ... */ };
class stream<char> { /* ... */ };Here, the class declaration will be used as the definition of streams of characters ( stream<char>). Other streams will be handled by template functions generated from the function template. No operation that requires a defined class can be performed on a template class until the class template has been seen. After that, a specific template class is considered defined immediately before the first global declaration that names it. LBL="" HELPID=""ID="34117"Member Function TemplatesID="ch1422"A member function of a template class is implicitly a template function with the template arguments of its class as its template arguments. For example, template<class T> class vector {
   T* v;
   int sz;
public:
   vector(int);
   T& operator[](int);
   T& elem(int i) { return v[i]; }
   // ...
};declares three function templates. The subscript function might be defined like this: template<class T> T& vector<T>::operator[](int i)
{
   if (i<0 || sz<=i) error("vector: range error");
   return v[i];
}The template argument for vector<T>::operator[]() will be determined by the vector to which the subscripting operation is applied. vector<int> v1(20);
vector<complex> v2(30);
v1[3] = 7;            // vector<int>::operator[]()
v2[3] = complex(7,8); // vector<complex>::operator[]()LBL="" HELPID=""ID="15676"FriendsID="ch1423"A friend function of a template is not implicitly a template function. For example, template<class T> class task {
   // ...
   friend void next_time();
   friend task<T>* preempt(task<T>*);
   friend task* prmt(task*);     // error
   // ...
};Here, next_time() becomes the friend of all task classes, and each task has an appropriately typed function called preempt() as a friend. The preempt functions might be defined as a template.template<class T>
   task<T>* preempt(task<T>* t) { /* ... */ }The declaration of prmt() is an error because there is no type task , only specific template types, task<int>, task<record>, and so on.LBL="" HELPID=""ID="41138"Static Members and VariablesID="ch1424"ID="ch1425"Each template class or function generated from a template has its own copies of any static variables or members. For example,template<class T> class X {
   static T s;
   // ...
};
X<int> aa;
X<char*> bb;Here X<int> has a static member s of type int and X<char*> has a static member s of type char*. Similarly, template<class T> f(T* p)
{
   static T s;
   // ...
};
void g(int a, char* b)
{
   f(&a);
   f(&b);
}Here f(int*) has a static member s of type int and f(char**) has a static member s of type char**. LBL="15"ID="33126"Exception HandlingException handling, as described in Ellis and Stroustrup: The Annotated C++ Reference Manual (Addison-Wesley 1990) and in Stroustrup: The C++ Programming Language (2nd edition) (Addison-Wesley 1991), has been adopted into the working drafts of the ANSI and ISO C++ standards committies. It is not supported by this release, but will be supported in some future release. LBL="16"ID="15280"PreprocessingThis chapter contains the following subsections:IDREF="29435" TYPE="TITLE""Phases of Preprocessing"IDREF="24851" TYPE="TITLE""Trigraph Sequences"IDREF="11378" TYPE="TITLE""Macro Definition and Expansion"IDREF="27292" TYPE="TITLE""File Inclusion"IDREF="31954" TYPE="TITLE""Conditional Compilation"IDREF="23017" TYPE="TITLE""Line Control"IDREF="26350" TYPE="TITLE""Error Directive"IDREF="26160" TYPE="TITLE""Pragmas"IDREF="31724" TYPE="TITLE""Null Directive"IDREF="11485" TYPE="TITLE""Predefined Names"A C++ implementation contains a preprocessor capable of macro substitution, conditional compilation, and inclusion of named files. ID="ch161"ID="ch162"ID="ch163"ID="ch164"ID="ch165"Lines beginning with #, optionally preceded by space and horizontal tab characters, (also called "directives") communicate with this preprocessor. These lines have syntax independent of the rest of the language; they may appear anywhere and have effects that last (independent of the scoping rules of C++) until the end of the translation unit (IDREF="39061" TYPE="TITLE"Chapter 2, "Lexical Conventions"). ID="ch166"A preprocessing directive (or any other line) may be continued on the next line in a source file by placing a backslash character, \, immediately before the new-line at the end of the line to be continued. The preprocessor effects the continuation by deleting the backslash and the new-line before the input sequence is divided into tokens. A backslash character may not be the last character in a source file. A preprocessing token is a language token (IDREF="25554" TYPE="TITLE""Tokens"), a file name as in a ID="ch167"#include directive, or any single character, other than white space, that does not match another preprocessing token. LBL="" HELPID=""ID="29435"Phases of PreprocessingID="ch168"Preprocessing is defined to occur in several phases. An implementation may collapse these phases, but the effect must be as though they had been executed. If needed, new-line characters are introduced to replace system-dependent end-of-line indicators. Any other necessary system-dependent character set translations are done. Trigraph sequences are replaced by their single character equivalents (ID="ch169"IDREF="24851" TYPE="TITLE""Trigraph Sequences"). Each pair of a backslash character ID="ch1610"\ immediately followed by a new-line is deleted, with the effect that the next source line is appended to the line that contained the sequence. ID="ch1611"The source text is decomposed into preprocessing tokens and sequences of white space. A single white space replaces each comment. A source file may not end with a partial token or comment. ID="ch1612"Preprocessing directives are executed and macros are expanded (ID="ch1613"ID="ch1614"IDREF="11378" TYPE="TITLE""Macro Definition and Expansion", IDREF="27292" TYPE="TITLE""File Inclusion", IDREF="31954" TYPE="TITLE""Conditional Compilation", IDREF="23017" TYPE="TITLE""Line Control", IDREF="26350" TYPE="TITLE""Error Directive", and IDREF="26160" TYPE="TITLE""Pragmas"). Escape sequences in character constants and string literals are replaced by their equivalents (IDREF="12401" TYPE="TITLE""Character Constants"). Adjacent string literals are concatenated. ID="ch1615"The result of preprocessing is syntactically and semantically analyzed and translated, then linked together as necessary with other programs and libraries. LBL="" HELPID=""ID="24851"Trigraph SequencesBefore any other processing takes place, each occurrence of one of the following sequences of three characters ("trigraph sequences") is replaced by the single character indicated in the following list. ID="ch1616"??=# ??/\??'^??([??)]??!|??<{??>}??-~For example, ??=define arraycheck(a,b) a??(b??) ??!??! b??(a??)becomes #define arraycheck(a,b) a[b] || b[a]LBL="" HELPID=""ID="11378"Macro Definition and ExpansionID="ch1617"ID="ch1618"ID="ch1619"A preprocessing directive of the form #define identifier token-string
ID="ch1620"causes the preprocessor to replace subsequent instances of the identifier with the given sequence of tokens. White space surrounding the replacement token sequence is discarded. Given, for example, #define SIDE 8the declaration char chessboard[SIDE][SIDE];after macro expansion becomes char chessboard[8][8];An identifier defined in this form may be redefined only by another #define directive of this form provided the replacement list of the second definition is identical to that of the first. All white space separations are considered identical. A line of the form #define identifier( identifier, ... , identifier ) token-string
ID="ch1621"where there is no space between the first identifier and the ( is a macro definition with parameters, or a "ID="ch1622"function-lik"" macro definition. An identifier defined as a function-like macro may be redefined by another function-like macro definition provided the second definition has the same number and spelling of parameters and the two replacement lists are identical. White space separations are considered identical. Subsequent appearances of an identifier defined as a function-like macro followed by a (, a sequence of tokens delimited by commas, and a ) are replaced by the token string in the definition. White space surrounding the replacement token sequence is discarded. Each occurrence of an identifier mentioned in the parameter list of the definition is replaced by the tokens representing the corresponding actual argument in the call. The actual arguments are token strings separated by commas; commas in quoted strings, in character constants, or within nested parentheses do not separate arguments. The number of arguments in a macro invocation must be the same as the number of parameters in the macro definition. Once the arguments to a function-like macro have been identified, argument substitution occurs. Unless it is preceded by a # token (IDREF="41174" TYPE="TITLE""The # Operator") or is adjacent to a ## token (IDREF="19403" TYPE="TITLE""The ## Operator"), a parameter in the replacement list is replaced by the corresponding argument after any macros in the argument have been expanded (IDREF="14160" TYPE="TITLE""Rescanning and Further Replacement"). For example, given the macro definitions #define index_mask     0XFF00
#define extract(word,mask)     word & mask the call index = extract(packed_data,index_mask);expands to index = packed_data & 0XFF00;In both forms the replacement string is rescanned for more defined identifiers (IDREF="14160" TYPE="TITLE""Rescanning and Further Replacement"). LBL="" HELPID=""ID="41174"The # OperatorID="ch1623"If an occurrence of a parameter in a replacement token sequence is immediately preceded by a # token, the parameter and the # operator will be replaced in the expansion by a string literal containing the spelling of the corresponding argument. A \ character is inserted in the string literal before each occurrence of a \ or a " " within or delimiting a character constant or string literal in the argument. For example, #define path(logid,cmd)   "/usr/" #logid "/bin/" #cmd
#define joe               joseph
ID="ch1624"the call char* mytool=path(joe,readmail);yields char* mytool="/usr/" "joe" "/bin/" "readmail";which is later concatenated (IDREF="29435" TYPE="TITLE""Phases of Preprocessing") to become char* mytool="/usr/joe/bin/readmail";LBL="" HELPID=""ID="19403"The ## OperatorID="ch1625"If a ## operator appears in a replacement token sequence between two tokens, first if either of the adjacent tokens is a parameter it is replaced, then the ## operator and any white space surrounding it are deleted. The effect of the ## operator, therefore, is concatenation. For example,#define inherit(basenum) public Pubbase ## basenum, \ 
private Privbase ## basenum     
ID="ch1626"the call class D : inherit(1) { };yields class D : public Pubbase1, private Privbase1 { };Any macros in the replaced tokens adjacent to the ## are not available for further expansion, but the result of the concatenation is. For example, #define concat(a)     a ## ball 
#define base          B 
#define baseball      sport 
ID="ch1627"the call concat(base)yields sportand notBballLBL="" HELPID=""ID="14160"Rescanning and Further ReplacementID="ch1628"ID="ch1629"After all parameters in the replacement list have been replaced, the resulting list is rescanned for more macros to replace. If the name of the macro being replaced is found during this scan or during subsequent rescanning, it is not replaced. A completely replaced macro expansion is not interpreted as a preprocessing directive, even if it appears to be one.LBL="" HELPID=""Scope of Macro Names and #undefOnce defined, a preprocessor identifier remains defined and in scope (independent of the scoping rules of C++) until the end of the translation unit or until it is undefined in a ID="ch1630"ID="ch1631"#undef directive. A #undef directive has the form #undef identifier
ID="ch1632"and causes the identifier's preprocessor definition to be forgotten. If the specified identifier is not currently defined as a macro name, the #undef is ignored. LBL="" HELPID=""ID="27292"File InclusionID="ch1633"ID="ch1634"ID="ch1635"A control line of the form #include <filename>causes the replacement of that line by the entire contents of the file filename. The named file is searched for in an implementation-dependent sequence of places. ID="ch1636"Similarly, a control line of the form #include "filename"causes the replacement of that line by the contents of the file filename, which is searched for first in an implementation-dependent manner. If this search fails, the file is searched for as if the directive had been of the form ID="ch1637"#include <filename>
ID="ch1638"ID="ch1639"Neither the new-line character nor > may appear in filename delimited by < and >. If any of the characters ID="ch1640"´, \, or ", or either of the sequences /* or // appear in such a filename the behavior is undefined. ID="ch1641"ID="ch1642"Neither the new-line character nor " " may appear in a filename delimited by a " " pair, although > may appear. If either of the characters ID="ch1643"´ or \ or either of the sequences /* or // appear in such a filename the behavior is undefined. ID="ch1644"ID="ch1645"ID="ch1646"If a directive appears of the form #include token-stringnot matching either of the forms given above, the preprocessing tokens within token-string will be processed as normal text. The resulting directive must match one of the forms defined above and will be treated as such. ID="ch1647"ID="ch1648"A #include directive may appear within a file that is being processed as a result of another #include directive. ID="ch1649"ID="ch1650"ID="ch1651"An implementation may impose a limit on the depth of nesting of #include directives within source files that have been read while processing a #include directive in another source file. LBL="" HELPID=""ID="31954"Conditional CompilationID="ch1652"The preprocessor allows conditional compilation of source code. The syntax for conditional compilation follows: ID="ch1653"conditional:if-part elif-partsopt else-partopt endif-lineID="ch1654"if-part:if-line textID="ch1655"if-line:if constant-expression#ifdef identifier#ifndef identifierID="ch1656"elif-parts:elif-line textelif-parts elif-line textID="ch1657"elif-line:#elif constant-expressionID="ch1658"else-part:else-line textelse-line:# elseID="ch1659"ID="ch1660"endif-line:# endifThe constant expression in the #if and ID="ch1661"#elif's (if any) are evaluated in the order in which they appear until one of the expressions evaluates to a non-zero value. C++ statements following a line with a zero value are not compiled, nor do preprocessor directives following such a line have any effect. When a directive with a non-zero value is found, the succeeding ID="ch1662"#elif's, and ID="ch1663"#else's, together with their associated text (C++ statements and preprocessor directives) are ignored. The text associated with the successful directive (the first whose constant expression is non-zero) is preprocessed and compiled normally. If the expressions associated with the #if and all #elif's evaluate to zero, then the text associated with the #else (if any) is treated normally. Within the constant-expression in a #if or ID="ch1664"#elif, a unary operator defined can be used in either of the forms ID="ch1665"defined identifieror defined (identifier)When applied to an identifier, its value is 1 if that identifier has been defined with a #define directive and not later undefined using ID="ch1666"#undef; otherwise its value is 0. The identifier defined itself may not be undefined or redefined. After any defined operators are evaluated, any remaining preprocessor macros appearing in the constant expression will be replaced as described in IDREF="11378" TYPE="TITLE""Macro Definition and Expansion". The resulting expression must be an integral constant expression as defined in IDREF="27851" TYPE="TITLE""Constant Expressions", except that types int and unsigned int are treated as long and unsigned long respectively, and it may not contain a cast, a sizeof operator, or an enumeration constant. A control line of the form #ifdef identifier
ID="ch1667"is equivalent to #if defined identifierA line of the form #ifndef identifier
ID="ch1668"is equivalent to #if !defined identifierConditional compilation constructs may be nested. An implementation may impose a limit on the depth of nesting of conditional compilation constructs. ID="ch1669"ID="ch1670"LBL="" HELPID=""ID="23017"Line ControlFor the benefit of programs that generate C++ code, a line of the form #line constant "filename"opt
ID="ch1671"sets the predefined macro __LINE__ (IDREF="11485" TYPE="TITLE""Predefined Names"), for purposes of error diagnostics or symbolic debugging, such that the line number of the next source line is considered to be the given constant, which must be a decimal integer. If ID="ch1672""filename" appears, __FILE__ (IDREF="11485" TYPE="TITLE""Predefined Names"), is set to the file named. If ID="ch1673""filename" is absent the remembered file name does not change. Macros appearing on the line are replaced before the line is processed. LBL="" HELPID=""ID="26350"Error DirectiveA line of the form #error token-string
ID="ch1674"ID="ch1675"causes the implementation to generate a diagnostic message that includes the given token sequence. LBL="" HELPID=""ID="26160"PragmasID="ch1676"A line of the form #pragma token-string
ID="ch1677"ID="ch1678"causes an implementation-dependent behavior when the token sequence is of a form recognized by the implementation. An unrecognized pragma will be ignored. LBL="" HELPID=""ID="31724"Null DirectiveThe null preprocessor directive, which has the form #
ID="ch1679"has no effect. LBL="" HELPID=""ID="11485"Predefined NamesID="ch1680"Certain information is available during compilation through predefined macros. __LINE__A decimal constant containing the current line number in the C++ source file. ID="ch1681"__FILE__A string literal containing the name of the source file being compiled. ID="ch1682"__DATE__A string literal containing the date of the translation, in the form ID="ch1683""Mmm dd yyyy", or "Mmm  d yyyy" if the value of the date is less than 10 . __TIME__A string literal containing the time of the translation, in the form ID="ch1684""hh:mm:ss". In addition, the name __cplusplus is defined when compiling a C++ program. ID="ch1685"These names may not be undefined or redefined. __LINE__ and __FILE__ can be set by the #line directive (IDREF="23017" TYPE="TITLE""Line Control"). ID="ch1686"ID="ch1687"Whether __STDC__ is defined and, if so, what its value is are implementation dependent. LBL="A"ID="27708"Grammar SummaryThis Appendix contains the following subsections:IDREF="29493" TYPE="TITLE""Keywords"IDREF="25739" TYPE="TITLE""Expressions"IDREF="15673" TYPE="TITLE""Declarations"IDREF="33293" TYPE="TITLE""Declarators"IDREF="34854" TYPE="TITLE""Class Declarations"IDREF="29839" TYPE="TITLE""Statements"IDREF="32233" TYPE="TITLE""Preprocessor"IDREF="22023" TYPE="TITLE""Templates"IDREF="37215" TYPE="TITLE""Exception Handling"This appendix is not part of the C++ reference manual proper and does not define C++ language features. ID="cha1"ID="cha2"This summary of C++ syntax is intended to be an aid to comprehension. It is not an exact statement of the language. In particular, the grammar described here accepts a superset of valid C++ constructs. Disambiguation rules (IDREF="10570" TYPE="TITLE""Ambiguity Resolution", IDREF="21773" TYPE="TITLE""Specifiers", IDREF="23630" TYPE="TITLE""Ambiguities") must be applied to distinguish expressions from declarations. Further, access control, ambiguity, and type rules must be used to weed out syntactically valid but meaningless constructs.LBL="" HELPID=""ID="29493"KeywordsID="cha3"New context-dependent keywords are introduced into a program by typedef (IDREF="13818" TYPE="TITLE""The typedef Specifier"), class (IDREF="38144" TYPE="TITLE"Chapter 9, "Classes"), enumeration (IDREF="14398" TYPE="TITLE""Enumeration Declarations"), and template (IDREF="18442" TYPE="TITLE"Chapter 14, "Templates") declarations. class-name:identifierenum-name:identifiertypedef-name:identifierNote that a typedef-name naming a class is also a class-name (IDREF="12565" TYPE="TITLE""Class Names").LBL="" HELPID=""ID="25739"ExpressionsID="cha4"expression:assignment-expressionexpression , assignment-expressionassignment-expression:conditional-expressionunary-expression assignment-operator assignment-expressionassignment-operator: one of=  *=  /=  %=   +=  -=  >>=  <<=  &=  ^=  |=conditional-expression:logical-or-expressionlogical-or-expression ? expression :conditional-expressionlogical-or-expression:logical-and-expressionlogical-or-expression || logical-and-expressionlogical-and-expression:inclusive-or-expressionlogical-and-expression && inclusive-or-expressioninclusive-or-expression:exclusive-or-expressioninclusive-or-expression | exclusive-or-expressionexclusive-or-expression:and-expressionexclusive-or-expression ^ and-expressionand-expression:equality-expressionand-expression & equality-expressionequality-expression:relational-expressionequality-expression == relational-expressionequality-expression != relational-expressionrelational-expression:shift-expressionrelational-expression < shift-expressionrelational-expression > shift-expressionrelational-expression <= shift-expressionrelational-expression >= shift-expressionshift-expression:additive-expressionshift-expression << additive-expressionshift-expression >> additive-expressionadditive-expression:multiplicative-expressionadditive-expression + multiplicative-expressionadditive-expression - multiplicative-expressionmultiplicative-expression:pm-expressionmultiplicative-expression * pm-expressionmultiplicative-expression / pm-expressionmultiplicative-expression % pm-expressionpm-expression:cast-expressionpm-expression .* cast-expressionpm-expression ->* cast-expressioncast-expression:unary-expression( type-name ) cast-expressionunary-expression:postfix-expression++  unary-expression--  unary-expressionunary-operator cast-expressionsizeof unary-expressionsizeof ( type-name )allocation-expressiondeallocation-expressionunary-operator: one of*  &  +  -  ! ~ allocation-expression:::opt new placementopt new-type-name new-initializeropt ::opt new placementopt ( type-name ) new-initializeroptplacement:( expression-list )new-type-name:type-specifier-list new-declaratoroptnew-declarator:* cv-qualifier-listopt new-declaratoroptcomplete-class-name :: * cv-qualifier-listopt new-declaratoroptnew-declaratoropt [ expression ]new-initializer:( initializer-listopt )deallocation-expression: ::opt delete cast-expression::opt delete [ ] cast-expressionpostfix-expression:primary-expressionpostfix-expression [ expression ]postfix-expression ( expression-listopt )simple-type-name ( expression-listopt )postfix-expression . namepostfix-expression -> namepostfix-expression ++postfix-expression --expression-list:assignment-expressionexpression-list , assignment-expressionprimary-expression:literalthis:: identifier:: operator-function-name:: qualified-name( expression )namename:identifieroperator-function-nameconversion-function-name~ class-namequalified-namequalified-name:qualified-class-name :: nameliteral:integer-constantcharacter-constantfloating-constantstring-literalLBL="" HELPID=""ID="15673"DeclarationsID="cha5"declaration:decl-specifiersopt declarator-listopt ;asm-declarationfunction-definitiontemplate-declarationlinkage-specificationdecl-specifier:storage-class-specifiertype-specifierfct-specifierfriendtypedefdecl-specifiers:decl-specifiersopt decl-specifierstorage-class-specifier:autoregisterstaticexternfct-specifier:inlinevirtualtype-specifier:simple-type-nameclass-specifierenum-specifierelaborated-type-specifierconstvolatilesimple-type-name:complete-class-namequalified-type-namecharshortintlongsignedunsignedfloatdoublevoidelaborated-type-specifier:class-key identifierclass-key class-nameenum\ enum-nameclass-key:classstructunionqualified-type-name:typedef-nameclass-name :: qualified-type-namecomplete-class-name:qualified-class-name:: qualified-class-namequalified-class-name:class-nameclass-name :: qualified-class-nameenum-specifier:enum identifieropt { enum-listopt }enum-list:enumeratorenum-list , enumeratorenumerator:identifieridentifier = constant-expressionconstant-expression:conditional-expressionlinkage-specification:extern string-literal { declaration-listopt }extern string-literaldeclarationdeclaration-list:declarationdeclaration-list declarationasm-declaration:asm ( string-literal ) ;LBL="" HELPID=""ID="33293"DeclaratorsID="cha6"declarator-list:init-declaratordeclarator-list , init-declaratorinit-declarator:declarator initializeroptdeclarator:dnameptr-operator declaratordeclarator (argument-declaration-list) cv-qualifier-listoptdeclarator [ constant-expressionopt ]( declarator )ptr-operator:* cv-qualifier-listopt& cv-qualifier-listoptcomplete-class-name :: * cv-qualifier-listoptcv-qualifier-list:cv-qualifier cv-qualifier-listoptcv-qualifier:constvolatiledname:nameclass-name~ class-nametypedef-namequalified-type-nametype-name:type-specifier-listabstract-declaratoropttype-specifier-list:type-specifier type-specifier-listoptabstract-declarator:ptr-operator abstract-declaratoroptabstract-declaratoropt ( argument-declaration-list )cv-qualifier-listoptabstract-declaratoropt [ constant-expressionopt ]( abstract-declarator )argument-declaration-list:arg-declaration-listopt ...optarg-declaration-list , ...arg-declaration-list:argument-declarationarg-declaration-list , argument-declarationargument-declaration:decl-specifiers declaratordecl-specifiers declarator = expressiondecl-specifiers abstract-declaratoroptdecl-specifiers abstract-declaratoropt = expressionfunction-definition:decl-specifiersoptdeclaratorctor-initializeroptfct-bodyfct-body:compound-statementinitializer:= assignment-expression= { initializer-list ,opt }( expression-list )initializer-list:assignment-expressioninitializer-list , assignment-expression{ initializer-list ,opt }LBL="" HELPID=""ID="34854"Class DeclarationsID="cha7"class-specifier:class-head { member-listopt }class-head:class-key identifieropt base-specoptclass-key class-name base-specoptmember-list:member-declaration member-listoptaccess-specifier : member-listoptmember-declaration:decl-specifiersopt member-declarator-listopt ;function-definition ;optqualified-name ;member-declarator-list:member-declaratormember-declarator-list , member-declaratormember-declarator:declarator pure-specifieroptidentifieropt : constant-expressionpure-specifier:= 0base-spec:: base-listbase-list:base-specifierbase-list , base-specifierbase-specifier:complete-class-name     virtual access-specifieropt complete-class-name     access-specifier virtualopt complete-class-nameaccess-specifier:privateprotectedpublicconversion-function-name:operator conversion-type-nameconversion-type-name:type-specifier-list ptr-operatoroptctor-initializer:: mem-initializer-listmem-initializer-list:mem-initializermem-initializer , mem-initializer-listmem-initializer:complete-class-name ( expression-listopt )identifier ( expression-listopt )operator-function-name:operator operatoroperator: one ofnew  delete+    -    *    /    %    ^    &    |    ~!    =    <    >    +=   -=   *=   /=   %=^=   &=   |=   <<   >>   >>=  <<=  ==   !=<=   >=   &&   ||   ++   --   ,    ->*  ->()   []LBL="" HELPID=""ID="29839"StatementsID="cha8"statement:labeled-statementexpression-statementcompound-statementselection-statementiteration-statementjump-statementdeclaration-statementlabeled-statement:identifier : statementcase constant-expression : statementdefault : statementexpression-statement:expressionopt ;compound-statement:{ statement-listopt }statement-list:statementstatement-list statementselection-statement:if ( expression ) statementif ( expression ) statement else statementswitch ( expression ) statementiteration-statement:while ( expression ) statementdo statement  while ( expression ) ;for ( for-init-statementexpressionopt ; expressionopt ) statementfor-init-statement:expression-statementdeclaration-statementjump-statement:break ;continue ;return expressionopt ;goto identifier ;declaration-statement:declarationLBL="" HELPID=""ID="32233"PreprocessorID="cha9"ID="cha10"#define identifier token-string
#define identifier( identifier , ... , identifier ) token-string
#include "filename"
#include <filename>
#line constant "filename"opt
#undef identifierconditional:if-part elif-partsopt else-partopt endif-lineif-part:if-line textif-line:# if constant-expression# ifdef identifier# ifndef identifierelif-parts:elif-line textelif-parts elif-line textelif-line:# elif constant-expressionelse-part:else-line textelse-line:# elseendif-line:# endifLBL="" HELPID=""ID="22023"TemplatesID="cha11"template-declaration:template < template-argument-list > declarationtemplate-argument-list:template-argumenttemplate-argument-list , template argumenttemplate-argument:type-argumentargument-declarationtype-argument:class identifiertemplate-class-name:template-name < template-arg-list >template-arg-list:template-argtemplate-arg-list , template-argtemplate-arg:expressiontype-nameLBL="" HELPID=""ID="37215"Exception HandlingID="cha12"try-block:try compound-statement handler-listhandler-list:handler handler-listopthandler:catch ( exception-declaration ) compound-statementexception-declaration:type-specifier-list declaratortype-specifier-list abstract-declaratortype-specifier-list...throw-expression:throw expressionoptexception-specification:throw ( type-listopt )type-list:type-nametype-list , type-nameLBL="B"ID="86943"CompatibilityThis Appendix contains the following subsections:IDREF="12959" TYPE="TITLE""Extensions"IDREF="35279" TYPE="TITLE""C++ and ANSI C"IDREF="12625" TYPE="TITLE""Anachronisms"This appendix is not part of the C++ reference manual proper and does not define C++ language features. ID="chb1"C++ is based on C (K&R78) and adopts most of the changes specified by the ANSI C standard. Converting programs among C++, K&R C, and ANSI C may be subject to vicissitudes of expression evaluation. All differences between C++ and ANSI C can be diagnosed by a compiler. With the following three exceptions, programs that are both C++ and ANSI C have the same meaning in both languages: ID="chb2"ID="chb3"In C, sizeof('a') equals sizeof(int); in C++, it equals sizeof(char). In C, given enum e { A };sizeof(A) equals sizeof(int); in C++, it equals sizeof(e), which need not equal sizeof(int). ID="chb4"A structure name declared in an inner scope can hide the name of an object, function, enumerator, or type in an outer scope. For example, int x[99];
void f()
{
   struct x { int a; };
   sizeof(x);  /* size of the array in C */
   /* size of the struct in C++ */
}LBL="" HELPID=""ID="12959"ExtensionsID="chb5"This section summarizes the major extensions to C provided by C++. LBL="" HELPID=""C++ Features Available in 1985ID="chb6"This subsection summarizes the extensions to C provided by C++ in the 1985 version of this manual: ID="chb7"The types of function arguments can be specified (IDREF="34712" TYPE="TITLE""Functions") and will be checked (IDREF="27725" TYPE="TITLE""Function Call"). Type conversions will be performed (IDREF="35361" TYPE="TITLE""Explicit Type Conversion"). This is also in ANSI C. ID="chb8"Single-precision floating point arithmetic may be used for float expressions; IDREF="27802" TYPE="TITLE""Fundamental Types" and IDREF="35201" TYPE="TITLE""Float and Double". This is also in ANSI C. ID="chb9"Function names can be overloaded; IDREF="18871" TYPE="TITLE"Chapter 13, "Overloading". Operators can be overloaded; IDREF="39747" TYPE="TITLE""Overloaded Operators". ID="chb10"Functions can be inline substituted; IDREF="12979" TYPE="TITLE""Function Specifiers". ID="chb11"Data objects can be const; IDREF="24962" TYPE="TITLE""Type Specifiers". This is also in ANSI C. ID="chb12"Objects of reference type can be declared; IDREF="22652" TYPE="TITLE""References"IDREF="19032" TYPE="TITLE""References". ID="chb13"ID="chb14"A free store is provided by the new and delete operators; IDREF="16762" TYPE="TITLE""New", IDREF="42326" TYPE="TITLE""Delete". ID="chb15"ID="chb16"Classes can provide data hiding (IDREF="40678" TYPE="TITLE"Chapter 11, "Member Access Control"), guaranteed initialization (IDREF="21970" TYPE="TITLE""Constructors"), user-defined conversions (IDREF="31355" TYPE="TITLE""Conversions"), and dynamic typing through use of virtual functions (IDREF="23603" TYPE="TITLE""Virtual Functions"). The name of a class or enumeration is a type name; IDREF="12565" TYPE="TITLE""Class Names". ID="chb17"A pointer to any non- const and non-volatile object type can be assigned to a void*; IDREF="25158" TYPE="TITLE""Pointer Conversions". This is also in ANSI C. A pointer to function can be assigned to a void*; IDREF="25158" TYPE="TITLE""Pointer Conversions". ID="chb18"A declaration within a block is a statement; IDREF="10996" TYPE="TITLE""Declaration Statement". ID="chb19"Anonymous unions can be declared; IDREF="32100" TYPE="TITLE""Unions". LBL="" HELPID=""ID="33034"C++ Features Added Since 1985ID="chb20"This subsection summarizes the major extensions of C++ since the 1985 version of this manual: ID="chb21"A class can have more than one direct base class (multiple inheritance); IDREF="19879" TYPE="TITLE""Multiple Base Classes". ID="chb22"Class members can be protected; IDREF="40678" TYPE="TITLE"Chapter 11, "Member Access Control" . ID="chb23"Pointers to class members can be declared and used; IDREF="10856" TYPE="TITLE""Pointers to Members", IDREF="19694" TYPE="TITLE""Pointer - to - Member Operators". ID="chb24"ID="chb25"Operators new and delete can be overloaded and declared for a class; IDREF="16762" TYPE="TITLE""New", IDREF="42326" TYPE="TITLE""Delete", IDREF="36583" TYPE="TITLE""Free Store". This allows the "assignment to this" technique for class specific storage management to be removed to the anachronism section; IDREF="12625" TYPE="TITLE""Anachronisms". ID="chb26"Objects can be explicitly destroyed; IDREF="29867" TYPE="TITLE""Destructors". ID="chb27"ID="chb28"Assignment and initialization are defined as memberwise assignment and initialization; IDREF="34465" TYPE="TITLE""Copying Class Objects". The overload keyword was made redundant and moved to the anachronism section; IDREF="12625" TYPE="TITLE""Anachronisms". General expressions are allowed as initializers for static objects; IDREF="23366" TYPE="TITLE""Initializers". ID="chb29"Data objects can be volatile; IDREF="24962" TYPE="TITLE""Type Specifiers". Also in ANSI C. Initializers are allowed for static class members; IDREF="17418" TYPE="TITLE""Static Members". Member functions can be static; IDREF="17418" TYPE="TITLE""Static Members". Member functions can be const and volatile; IDREF="28120" TYPE="TITLE""The this Pointer". Linkage to non-C++ program fragments can be explicitly declared; IDREF="27890" TYPE="TITLE""Linkage Specifications". Operators ->, ->*, and , can be overloaded; IDREF="39747" TYPE="TITLE""Overloaded Operators". Classes can be abstract; IDREF="42103" TYPE="TITLE""Abstract Classes". Prefix and postfix application of ++ and -- on a user-defined type can be distinguished. Templates; IDREF="18442" TYPE="TITLE"Chapter 14, "Templates". Exception handling; IDREF="33126" TYPE="TITLE"Chapter 15, "Exception Handling". LBL="" HELPID=""ID="35279"C++ and ANSI CID="chb30"In general, C++ provides more language features and fewer restrictions than ANSI C so most constructs in ANSI C are legal in C++ with their meanings unchanged. The exceptions are: ANSI C programs using any of the C++ keywords asm       catch      class     delete     friend 
inline    new        operator  private    protected
public    template   try       this       virtual
throwas identifiers are not C++ programs; IDREF="12297" TYPE="TITLE""Keywords". Though deemed obsolescent in ANSI C, a C implementation may impose Draconian limits on the length of identifiers; a C++ implementation is not permitted to; IDREF="28128" TYPE="TITLE""Identifiers". In C++, a function must be declared before it can be called; IDREF="27725" TYPE="TITLE""Function Call". ID="chb31"The function declaration f(); means that f takes no arguments (IDREF="34712" TYPE="TITLE""Functions"); in C it means that f can take any number of arguments of any type at all. Such use is deemed obsolescent in ANSI C. In ANSI C a global data object may be declared several times without using the extern specifier; in C++ it must be defined exactly once; IDREF="22763" TYPE="TITLE""Program and Linkage". ID="chb32"In C++, a class may not have the same name as a typedef declared to refer to a different type in the same scope; IDREF="12565" TYPE="TITLE""Class Names". In ANSI C a void* may be used as the right-hand operand of an assignment to or initialization of a variable of any pointer type; in C++ it may not; IDREF="24962" TYPE="TITLE""Type Specifiers". ID="chb33"ID="chb34"C allows jumps to bypass an initialization; C++ does not. In ANSI C, a global const by default has external linkage; in C++ it does not; IDREF="22763" TYPE="TITLE""Program and Linkage". "Old style" C function definitions and calls of undeclared functions are considered anachronisms in C++ and may not be supported by all implementations;IDREF="64303" TYPE="TITLE""Old Style Function Definitions". This is deemed obsolescent in ANSI C. A struct is a scope in C++ (IDREF="24244" TYPE="TITLE""Scopes"); in ANSI C a struct, an enumeration, or an enumerator declared in a struct is exported to scope enclosing the struct. Assignment to an object of enumeration type with a value that is not of that enumeration type is considered an anachronism in C++ and may not be supported by all implementations; IDREF="14398" TYPE="TITLE""Enumeration Declarations". ANSI C recommends a warning for such assignments. Surplus characters are not allowed in strings used to initialize character arrays; IDREF="18600" TYPE="TITLE""Character Arrays". The type of a character constant is char in C++ (IDREF="12401" TYPE="TITLE""Character Constants") and int in C. The type of an enumerator is the type of its enumeration in C++ (IDREF="14398" TYPE="TITLE""Enumeration Declarations") and int in C. ID="chb35"ID="chb36"In addition, the ANSI C standard allows conforming implementations to differ considerably; this may lead to further incompatibilities between C and C++ implementations. In particular, some C implementations may consider certain incompatible declarations legal. C++ requires consistency even across compilation boundaries; ID="chb37"IDREF="24185" TYPE="TITLE""Declarations and Definitions". LBL="" HELPID=""How to CopeIn general, a C++ program uses many features not provided by ANSI C. For such a program, the minor differences ofIDREF="35279" TYPE="TITLE""C++ and ANSI C" don't matter since they are dwarfed by the C++ extensions. Where ANSI C and C++ need to share header files, care must be taken so that such headers are written in the common subset of the two languages. ID="chb38"No advantage must be taken of C++ specific features such as classes, overloading, and so on. A name should not be used both as a structure tag and as the name of a different type. A function f taking no arguments should be declared f(void) and not simply f(). Global consts must be declared explicitly static or extern. ID="chb39"Conditional compilation using the C++ predefined name __cplusplus may be used to distinguish information to be used by an ANSI C program from information to be used by a C++ program. Functions that are to be callable from both languages must be explicitly declared to have C linkage. LBL="" HELPID=""ID="12625"AnachronismsID="chb40"ID="chb41"The extensions presented here may be provided by an implementation to ease the use of C programs as C++ programs or to provide continuity from earlier C++ implementations. Note that each of these features has undesirable aspects. An implementation providing them should also provide a way for the user to ensure that they do not occur in a source file. A C++ implementation is not obliged to provide these features. ID="chb42"ID="chb43"The word overload may be used as a decl-specifier (IDREF="35031" TYPE="TITLE"Chapter 7, "Declarations") in a function declaration or a function definition. When used as a decl-specifier, overload is a reserved word and cannot also be used as an identifier. The definition of a static data member of a class for which initialization by default to all zeros applies (IDREF="23366" TYPE="TITLE""Initializers", IDREF="17418" TYPE="TITLE""Static Members") may be omitted. An old style (that is, pre-ANSI C) C preprocessor may be used. An int may be assigned to an object of enumeration type. The number of elements in an array may be specified when deleting an array of a type for which there is no destructor; IDREF="42326" TYPE="TITLE""Delete". A single function operator++() may be used to overload both prefix and postfix ++ and a single function operator--() may be used to overload both prefix and postfix --;IDREF="20121" TYPE="TITLE""Class Member Access". LBL="" HELPID=""ID="64303"Old Style Function DefinitionsID="chb44"ID="chb45"The C function definition syntax old-function-definition:decl-specifiersoptold-function-declarator declaration-listoptfct-bodyold-function-declarator:     declarator ( parameter-listopt )parameter-list:identifier     parameter-list , identifierFor example, max(a,b) int b; { return (a<b) ? b : a; }may be used. If a function defined like this has not been previously declared its argument type will be taken to be (...), that is, unchecked. If it has been declared its type must agree with that of the declaration. Class member functions may not be defined with this syntax. LBL="" HELPID=""Old Style Base Class InitializerID="chb46"In a mem-initializer (IDREF="36383" TYPE="TITLE""Initializing Bases and Members"), the class-name naming a base class may be left out provided there is exactly one immediate base class. For example, class B {
   // ...
public:
   B (int);
};
class D : public B {
   // ...
   D(int i) : (i) { /* ... */ }
};causes the B constructor to be called with the argument i. LBL="" HELPID=""ID="28494"Assignment to thisID="chb47"ID="chb48"Memory management for objects of a specific class can be controlled by the user by suitable assignments to the this pointer. By assigning to the this pointer before any use of a member, a constructor can implement its own storage allocation. By assigning a zero value to this, a destructor can avoid the standard deallocation operation for objects of its class. Assigning a zero value to this in a destructor also suppressed the implicit calls of destructors for bases and members. For example, ID="chb49"ID="chb50"ID="chb51"ID="chb52"ID="chb53"class Z {
   int z[10];
   Z()  { this = my_allocator( sizeof(Z) ); }
   ~Z() { my_deallocator( this ); this = 0; }
};On entry into a constructor, this is non-zero if allocation has already taken place (as it will have for auto, static, and member objects) and zero otherwise.Calls to constructors for a base class and for member objects will take place (only) after an assignment to this. If a base class's constructor assigns to this, the new value will also be used by the derived class's constructor (if any).Note that if this anachronism exists either the type of the this pointer cannot be a *const or the enforcement of the rules for assignment to a constant pointer must be subverted for the this pointer. LBL="" HELPID=""Cast of Bound PointerID="chb54"ID="chb55"A pointer to member function for a particular object may be cast into a pointer to function, for example, (int(*)())p->f. The result is a pointer to the function that would have been called using that member function for that particular object. Any use of the resulting pointer is  as ever  undefined. ID="chb56"LBL="" HELPID=""Non­nested ClassesID="chb57"ID="chb58"Where a class is declared within another class and no other class of that name is declared in the program that class can be used as if it was declared outside its enclosing class (exactly as a C struct). For example, struct S {
   struct T {
      int a;
   };
   int b;
};
struct T x;     // meaning `S::T x;'; see scope resolution operatorIDREF="ch522"Primary Expressions!; see logical negation operatorIDREF="ch593"Unary Operators!=; see inequality operatorIDREF="ch5259"Equality Operators# preprocessing operatorIDREF="ch1624"The # OperatorIDREF="ch1623"The # Operator## preprocessing operatorIDREF="ch1625"The ## OperatorIDREF="ch1627"The ## Operator#defineIDREF="ch1620"Macro Definition and ExpansionIDREF="ch1621"Macro Definition and Expansion#elifIDREF="ch1662"Conditional Compilation#elseIDREF="ch1663"Conditional Compilation#endifIDREF="ch1659"Conditional Compilation#errorIDREF="ch1674"Error Directive#ifIDREF="ch1661"Conditional CompilationIDREF="ch1664"Conditional Compilation#ifdefIDREF="ch1667"Conditional Compilation#ifndefIDREF="ch1668"Conditional Compilation#includeIDREF="ch1646"File InclusionIDREF="ch1638"File InclusionIDREF="ch1641"File InclusionIDREF="ch1633"File Inclusion#lineIDREF="ch1671"Line Control#pragmaIDREF="ch1677"Pragmas#undefIDREF="ch1631"Scope of Macro Names and #undefIDREF="ch1632"Scope of Macro Names and #undefIDREF="ch1666"Conditional Compilation%; see modulus operatorIDREF="ch5203"Multiplicative Operators%= operatorIDREF="ch5281"Assignment Operators&&; see logical AND operatorIDREF="ch5268"Logical AND Operator&; see address-of operatorIDREF="ch587"Unary Operators&; see bitwise AND operatorIDREF="ch5262"Bitwise AND Operator&= operatorIDREF="ch5284"Assignment Operators&minusIDREF="ch576"Increment and DecrementIDREF="ch1373"Increment and DecrementIDREF="ch578"Increment and DecrementIDREF="ch578"Increment and DecrementIDREF="ch5109"Increment and DecrementIDREF="ch1372"Increment and Decrement<<; see left shift operatorIDREF="ch5231"Shift Operators<<= operatorIDREF="ch5283"Assignment Operators<; see less than operatorIDREF="ch5239"Relational Operators<=; see less than or equal to operatorIDREF="ch5243"Relational Operators<float.h\>IDREF="ch225"Keywords<limits.h\>IDREF="ch3108"Fundamental TypesIDREF="ch226"Keywords<new.h\>IDREF="ch229"Keywords<stdarg.h\>IDREF="ch853"FunctionsIDREF="ch230"Keywords<stddef.h\>IDREF="ch5120"SizeofIDREF="ch227"KeywordsIDREF="ch287"String LiteralsIDREF="ch259"Character Constants<stdlib.h\>IDREF="ch377"Start and TerminationIDREF="ch393"Start and TerminationIDREF="ch390"Start and TerminationIDREF="ch231"Keywords(); see function call operatorIDREF="ch542"Function Call/* commentIDREF="ch210"Comments*/ commentIDREF="ch211"Comments*; see indirection operatorIDREF="ch585"Unary Operators*; see multiplication operatorIDREF="ch5199"Multiplicative Operators.*; see pointer to member operatorIDREF="ch5191"Pointer - to - Member Operators*= operatorIDREF="ch5279"Assignment Operators*const exampleIDREF="ch824"Pointers++; see increment operatorIDREF="ch575"Increment and Decrement+; see addition operatorIDREF="ch5211"Additive Operators+; see unary plus operatorIDREF="ch591"Unary Operators+= operatorIDREF="ch5277"Assignment OperatorsIDREF="ch5110"Increment and Decrement,; see comma operatorIDREF="ch5306"Comma Operator-; see subtraction operatorIDREF="ch5213"Additive Operators-; see unary minus operatorIDREF="ch589"Unary Operators-= operatorIDREF="ch5278"Assignment Operators-\>*; see pointer to member operatorIDREF="ch5193"Pointer - to - Member Operators-\>; see class member access operatorIDREF="ch572"Class Member Access.; see class member access operatorIDREF="ch569"Class Member Access; see decrement operatorIDREF="ch578"Increment and Decrement/; see division operatorIDREF="ch5201"Multiplicative Operators...; see ellipsisIDREF="ch848"Functions/= operatorIDREF="ch5280"Assignment Operators=; see assignment operatorIDREF="ch5276"Assignment Operators==; see equality operatorIDREF="ch5257"Equality Operators?; see conditional expression operatorIDREF="ch5274"Conditional Operator\>; see greater than operatorIDREF="ch5241"Relational Operators\>=; see greater than or equal operatorIDREF="ch5245"Relational Operators\>\>; see right shift operatorIDREF="ch5233"Shift Operators\>\>= operatorIDREF="ch5282"Assignment Operators^; see bitwise exclusive OR operatorIDREF="ch5264"Bitwise Exclusive-OR Operator^= operatorIDREF="ch5285"Assignment Operators_ ; see onescomplementoperator'IDREF="ch595"Unary Operators_[_]; see subscripting operatorIDREF="ch540"Subscripting____cplusplusIDREF="chb39"How to CopeIDREF="ch1685"Predefined Names____DATE____IDREF="ch1683"Predefined Names____FILE____IDREF="ch1682"Predefined NamesIDREF="ch1673"Line Control____LINE____IDREF="ch1681"Predefined NamesIDREF="ch1672"Line Control____STDC____IDREF="ch1686"Predefined Names____TIME____IDREF="ch1684"Predefined Names_e; see backslashIDREF="ch253"Character Constants_~; see destructorIDREF="ch1253"Destructorsabort()IDREF="ch391"Start and Terminationabstract classIDREF="ch1048"Abstract Classesabstract-declaratorIDREF="ch812"Type Namesaccess and friend functionIDREF="ch1119"Friendsaccess controlIDREF="ch111"Member Access Controlaccess control defaultIDREF="ch117"Member Access Controlaccess declarationIDREF="ch1116"Access Declarationsaccess specifierIDREF="ch1111"Access Specifiers for Base ClassesIDREF="ch118"Access Specifiersaccess specifier and friendIDREF="ch1129"Friendsaccess specifier and object layoutIDREF="ch119"Access Specifiersaccess-specifierIDREF="ch1010"Derived Classesaddition operatorIDREF="ch5210"Additive Operatorsadditive operatorIDREF="ch5208"Additive Operatorsadditive-expressionIDREF="ch5209"Additive Operatorsaddress of bit-fieldIDREF="ch9111"Bit-Fieldsaddress of bit-field restrictionIDREF="ch9113"Bit-Fieldsaddress of constructorIDREF="ch1220"Constructorsaddress of overloaded functionIDREF="ch5103"Unary OperatorsIDREF="ch1340"Address of Overloaded Functionaddress of qualified nameIDREF="ch5101"Unary Operatorsaddress-of operatorIDREF="ch586"Unary Operatorsadjusting base class member accessIDREF="ch1115"Access DeclarationsaggregateIDREF="ch8102"Aggregatesalignment of arrayIDREF="ch5174"Explicit Type Conversionalignment of bit-fieldIDREF="ch9108"Bit-Fieldsalignment of classIDREF="ch5172"Explicit Type Conversionalignment of class memberIDREF="ch5173"Explicit Type Conversionalignment restrictionIDREF="ch5171"Explicit Type Conversionallocation-expressionIDREF="ch5127"NewanachronismIDREF="chb40"Anachronismsanonymous unionIDREF="ch994"Unionsanonymous union access controlIDREF="ch998"Unionsanonymous union restrictionIDREF="ch999"UnionsANSI_ C and shared headersIDREF="chb38"How to CopeargcIDREF="ch370"Start and TerminationargumentIDREF="ch880"Function Definitionsargument conversionIDREF="ch859"FunctionsIDREF="ch554"Function Callargument declarationIDREF="ch858"FunctionsIDREF="ch846"Functionsargument default; see default argumentIDREF="ch865"Default Argumentsargument matching; see overloading resolutionIDREF="ch1322"Argument Matchingargument passingIDREF="ch548"Function Callargument type checkingIDREF="ch546"Function Callargument type conversionIDREF="ch1240"Conversionsargument-declarationIDREF="ch845"Functionsarguments to main()IDREF="ch373"Start and Terminationargv_[_]IDREF="ch371"Start and Terminationarithmetic conversionIDREF="ch418"Arithmetic Conversionsarithmetic exceptionIDREF="ch57"Expressionsarithmetic typeIDREF="ch3130"Fundamental Typesarray declarationIDREF="ch835"Arraysarray declarator _[_]IDREF="ch834"Arraysarray exampleIDREF="ch838"Arraysarray initializationIDREF="ch8103"Aggregatesarray memberIDREF="ch946"Class Membersarray of class objects and constructorIDREF="ch1298"Explicit Initializationarray of class objects and default constructorIDREF="ch1299"Explicit Initializationarray of class objects and newIDREF="ch5136"Newarray of class objects initializationIDREF="ch1297"Explicit InitializationIDREF="ch8109"Aggregatesarray pointer conversionIDREF="ch431"Pointer Conversionsarray typeIDREF="ch3133"Derived Typesarrow operator; see class member access operatorIDREF="ch573"Class Member Accessasm declarationIDREF="ch798"Asm DeclarationsassemblerIDREF="ch799"Asm Declarationsassignment and lvalueIDREF="ch5288"Assignment Operatorsassignment base class objectIDREF="ch5300"Assignment Operatorsassignment derived class objectIDREF="ch5301"Assignment Operatorsassignment expressionIDREF="ch5287"Assignment Operatorsassignment of class objectIDREF="ch12142"Copying Class Objectsassignment of derived class to base classIDREF="ch12143"Copying Class Objectsassignment operatorIDREF="ch12126"Copying Class ObjectsIDREF="ch5275"Assignment Operatorsassignment pointer to memberIDREF="ch5302"Assignment Operatorsassignment to class objectIDREF="ch5299"Assignment Operatorsassignment to pointerIDREF="ch5291"Assignment Operatorsassignment to pointer to memberIDREF="ch5297"Assignment Operatorsassignment to referenceIDREF="ch5303"Assignment Operatorsassignment to this anachronismIDREF="chb47"Assignment to thisIDREF="chb53"Assignment to thisassignment-expressionIDREF="ch5289"Assignment Operatorsassignment-operatorIDREF="ch5290"Assignment Operatorsatexit()IDREF="ch389"Start and Terminationauto initializationIDREF="ch671"Declaration StatementIDREF="ch677"Declaration Statementauto object initializationIDREF="ch890"Initializersauto restrictionIDREF="ch716"Storage Class Specifiersauto specifierIDREF="ch714"Storage Class Specifiersauto storage classIDREF="ch395"Storage Classesauto storage class; see also localIDREF="ch396"Storage Classesbackslash and line continuationIDREF="ch166"PreprocessingIDREF="ch1610"Phases of Preprocessingbackslash characterIDREF="ch252"Character Constantsbase classIDREF="ch103"Derived ClassesIDREF="ch1022"Multiple Base ClassesIDREF="ch1012"Derived Classesbase class accessIDREF="ch1112"Access Specifiers for Base Classesbase class castIDREF="ch5175"Explicit Type Conversionbase class constructor order of executionIDREF="ch1215"Constructorsbase class destructor order of executionIDREF="ch1262"Destructorsbase class initializationIDREF="ch12108"Initializing Bases and MembersIDREF="ch12104"Initializing Bases and Membersbase class initializerIDREF="ch882"Function Definitionsbase class member accessIDREF="ch1014"Derived Classesbase class member ambiguityIDREF="ch1030"Ambiguitiesbase class pointer conversionIDREF="ch426"Pointer Conversionsbase class virtual; see virtual base classIDREF="ch104"Derived Classesbase of integer constantIDREF="ch239"Integer Constantsbase-listIDREF="ch107"Derived Classesbase-specifierIDREF="ch108"Derived ClassesBenIDREF="ch1319"Declaration Matchingbit-fieldIDREF="ch9100"Bit-Fieldsbit-field declarationIDREF="ch9102"Bit-Fieldsbit-field layoutIDREF="ch9104"Bit-Fieldsbit-field restrictionIDREF="ch9112"Bit-Fieldsbitwise AND operatorIDREF="ch5261"Bitwise AND Operatorbitwise exclusive OR operatorIDREF="ch5263"Bitwise Exclusive-OR Operatorbitwise inclusive OR operatorIDREF="ch5265"Bitwise Inclusive-OR Operatorbitwise operatorIDREF="ch5260"Bitwise AND Operatorblock scope; see local scopeIDREF="ch326"Scopesblock statement _[_]IDREF="ch616"Compound Statement, or Blockblock structureIDREF="ch669"Declaration StatementbracketsIDREF="ch113"Notation and Syntax Conventionsbreak statementIDREF="ch653"The break StatementIDREF="ch647"Jump Statementsbuilt-in type; see fundamental typeIDREF="ch3107"Fundamental TypesbyteIDREF="ch5114"SizeofC function definition anachronismIDREF="chb44"Old Style Function Definitionscall by referenceIDREF="ch550"Function Callcall by valueIDREF="ch549"Function Callcall; see also function call, member function call, overloaded function call, virtual function callIDREF="ch543"Function Callcase labelIDREF="ch69"Labeled StatementIDREF="ch629"The switch StatementIDREF="ch627"The switch Statementcast of pointer to member anachronismIDREF="chb54"Cast of Bound Pointercast operatorIDREF="ch583"Unary OperatorsIDREF="ch810"Type NamesIDREF="ch5165"Explicit Type Conversioncast to undefined classIDREF="ch5177"Explicit Type Conversioncast-expressionIDREF="ch5163"Explicit Type ConversioncastingIDREF="ch563"Explicit Type ConversionIDREF="ch5164"Explicit Type Conversionchar integer conversionIDREF="ch45"Integral Promotionschar typeIDREF="ch3112"Fundamental Typeschar type specifierIDREF="ch765"Type Specifierscharacter array initializationIDREF="ch8111"Character Arrayscharacter constantIDREF="ch248"Character Constantscharacter stringIDREF="ch275"String LiteralsclassIDREF="ch91"ClassesIDREF="ch3138"Derived Typesclass access and friendIDREF="ch1126"Friendsclass and typeIDREF="ch93"Classesclass base; see base classIDREF="ch1023"Multiple Base Classesclass conversionIDREF="ch1235"Conversionsclass conversion ambiguityIDREF="ch1037"Ambiguitiesclass declarationIDREF="ch99"ClassesIDREF="ch943"Class Membersclass declaration CW_[_]IDREF="ch92"Classesclass declaration exampleIDREF="ch947"Class Membersclass declaration name hidingIDREF="ch923"Class Namesclass declaration syntax summaryIDREF="cha7"Class Declarationsclass definitionIDREF="ch910"Classesclass derived; see derived classIDREF="ch102"Derived Classesclass local; see local classIDREF="ch9115"Nested Class Declarationsclass member accessIDREF="ch565"Class Member Accessclass member access operatorIDREF="ch568"Class Member AccessIDREF="ch571"Class Member Accessclass member declarationIDREF="ch939"Class Membersclass member functionIDREF="ch952"Member Functionsclass member initializationIDREF="ch8101"Initializersclass member semanticsIDREF="ch567"Class Member Accessclass member storage classIDREF="ch3103"Storage Classesclass member syntaxIDREF="ch566"Class Member Accessclass member; see also memberIDREF="ch934"Class Membersclass nameIDREF="ch88"Declaratorsclass name as type declarationIDREF="ch917"Class Namesclass name declarationIDREF="ch316"Declarations and Definitionsclass name redefinitionIDREF="ch9132"Local Type Namesclass nested; see nested classIDREF="ch9116"Nested Class Declarationsclass object as argumentIDREF="ch1294"Explicit Initializationclass object castIDREF="ch5184"Explicit Type Conversionclass object copyIDREF="ch12124"Copying Class Objectsclass object copy exampleIDREF="ch12144"Copying Class Objectsclass object copy; see also copy constructorIDREF="ch1232"Temporary Objectsclass object initializationIDREF="ch8104"AggregatesIDREF="ch1287"InitializationIDREF="ch1290"Explicit Initializationclass object initialization; see also constructorIDREF="ch8105"Aggregatesclass object layoutIDREF="ch948"Class MembersIDREF="ch1024"Multiple Base Classesclass object return typeIDREF="ch1295"Explicit Initializationclass scopeIDREF="ch332"Scopesclass type specifierIDREF="ch776"Type Specifiersclass versus structIDREF="ch913"Classesclass versus unionIDREF="ch915"Classesclass-keyIDREF="ch775"Type SpecifiersIDREF="ch98"Classesclass-nameIDREF="ch96"Classesclass-specifierIDREF="ch97"Classes// commentIDREF="ch212"Commentscomma operatorIDREF="ch5305"Comma Operatorcompatibility with ANSI_ C summaryIDREF="chb30"C++ and ANSI Ccompatibility with C summaryIDREF="chb1"Compatibilitycompiler control line; see preprocessing directiveIDREF="ch162"Preprocessingcomplete objectIDREF="ch12116"Initializing Bases and Memberscomplete-class-nameIDREF="ch783"Type Specifierscompound statementIDREF="ch615"Compound Statement, or Blockcompound-statementIDREF="ch617"Compound Statement, or BlockconditionalIDREF="ch1653"Conditional Compilationconditional compilationIDREF="ch1652"Conditional Compilationconditional expression operatorIDREF="ch5273"Conditional Operatorconst arrayIDREF="ch756"Type Specifiersconst castIDREF="ch5186"Explicit Type Conversionconst class objectIDREF="ch966"The this PointerIDREF="ch757"Type Specifiersconst exampleIDREF="ch823"Pointersconst initializationIDREF="ch896"InitializersIDREF="ch755"Type Specifiersconst member functionIDREF="ch963"The this PointerIDREF="ch965"The this Pointerconst member initializationIDREF="ch12110"Initializing Bases and Membersconst operandIDREF="ch513"Expressionsconst pointer assignmentIDREF="ch5293"Assignment Operatorsconst pointer initializationIDREF="ch892"Initializersconst referenceIDREF="ch8118"Referencesconst typeIDREF="ch753"Type SpecifiersconstantIDREF="ch3137"Derived TypesIDREF="ch232"LiteralsIDREF="ch524"Primary Expressionsconstant expressionIDREF="ch5310"Constant Expressionsconstant pointer declarationIDREF="ch822"Pointersconstant pointer exampleIDREF="ch825"Pointersconstant-expressionIDREF="ch5311"Constant ExpressionsconstructorIDREF="ch123"Constructorsconstructor and abstract classIDREF="ch1054"Abstract Classesconstructor and arrayIDREF="ch5145"Newconstructor and array order of executionIDREF="ch1214"Constructorsconstructor and constIDREF="ch968"The this Pointerconstructor and CWconstIDREF="ch124"Constructorsconstructor and CWvolatileIDREF="ch125"Constructorsconstructor and initializationIDREF="ch1289"InitializationIDREF="ch1291"Explicit Initializationconstructor and initialization exampleIDREF="ch1292"Explicit Initializationconstructor and member functionIDREF="ch1224"Constructorsconstructor and member function callIDREF="ch12119"Constructors and Destructorsconstructor and newIDREF="ch5143"NewIDREF="ch5139"Newconstructor and returnIDREF="ch661"The return StatementIDREF="ch660"The return Statementconstructor and static objects order of executionIDREF="ch12102"Explicit Initializationconstructor and virtual function callIDREF="ch12121"Constructors and Destructorsconstructor and volatileIDREF="ch970"The this Pointerconstructor conversion by; see also user-defined conversionIDREF="ch1237"Conversionsconstructor default; see default constructorIDREF="ch5142"Newconstructor definitionIDREF="ch884"Function Definitionsconstructor exampleIDREF="ch1223"Constructorsconstructor for temporaryIDREF="ch1227"Temporary Objectsconstructor restrictionIDREF="ch126"ConstructorsIDREF="ch1218"Constructorscontinue in for statementIDREF="ch642"The for Statementcontinue statementIDREF="ch648"Jump StatementsIDREF="ch656"The continue Statementcontrol line; see preprocessing directiveIDREF="ch163"Preprocessingconversion by assignmentIDREF="ch5304"Assignment Operatorsconversion by constructorIDREF="ch1241"Conversion by Constructorconversion explicit type; see castingIDREF="ch562"Explicit Type Conversionconversion function; see also user-defined conversionIDREF="ch1238"Conversionsconversion operatorIDREF="ch1246"Conversion FunctionsIDREF="ch518"Expressionsconversion-function-nameIDREF="ch1247"Conversion Functionsconversion; see also type conversionIDREF="ch419"Arithmetic Conversionscopy constructorIDREF="ch12125"Copying Class ObjectsIDREF="ch1212"ConstructorsIDREF="ch1233"Temporary ObjectscourierIDREF="ch19"Notation and Syntax Conventionscourier boldIDREF="ch111"Notation and Syntax Conventionsctor-initializerIDREF="ch12106"Initializing Bases and Memberscv-qualifierIDREF="ch86"Declaratorsdangerous extension to CIDREF="chb41"Anachronismsdata member; see memberIDREF="ch935"Class Membersdeallocation-expressionIDREF="ch5153"Deletedeallocation; see deleteIDREF="ch5159"Deletedecimal constantIDREF="ch238"Integer Constantsdecl-specifierIDREF="ch76"SpecifiersdeclarationIDREF="ch71"Declarations IDREF="ch72"Declarations IDREF="ch32"Basic ConceptsIDREF="ch311"Declarations and Definitionsdeclaration as definitionIDREF="ch719"Storage Class Specifiersdeclaration exampleIDREF="ch860"FunctionsIDREF="ch319"Declarations and Definitionsdeclaration hiding; see name hidingIDREF="ch667"Declaration Statementdeclaration in for statementIDREF="ch643"The for Statementdeclaration in switch statementIDREF="ch631"The switch Statementdeclaration specifierIDREF="ch75"Specifiersdeclaration statementIDREF="ch665"Declaration Statementdeclaration statement restrictionIDREF="ch623"Selection StatementsIDREF="ch638"Iteration Statementsdeclaration syntax summaryIDREF="cha5"Declarationsdeclaration type ambiguityIDREF="ch77"Specifiersdeclaration versus cast ambiguityIDREF="ch815"Ambiguity Resolutiondeclaration versus expression ambiguityIDREF="ch682"Ambiguity Resolutiondeclaration-listIDREF="ch7104"Linkage Specificationsdeclaration-statementIDREF="ch666"Declaration StatementdeclaratorIDREF="ch74"Declarations IDREF="ch81"DeclaratorsIDREF="ch84"Declaratorsdeclarator exampleIDREF="ch814"Type Namesdeclarator syntax summaryIDREF="cha6"Declaratorsdeclarator-listIDREF="ch82"Declaratorsdecrement operatorIDREF="ch577"Increment and DecrementIDREF="ch597"Unary OperatorsIDREF="ch5111"Increment and Decrementdefault argument and name hidingIDREF="ch873"Default Argumentsdefault argument bindingIDREF="ch868"Default Argumentsdefault argument declarationIDREF="ch864"Default Argumentsdefault argument evaluationIDREF="ch871"Default ArgumentsIDREF="ch869"Default Argumentsdefault argument exampleIDREF="ch870"Default ArgumentsIDREF="ch866"Default Argumentsdefault argument type checkingIDREF="ch867"Default Argumentsdefault array sizeIDREF="ch836"Arraysdefault assignment operatorIDREF="ch12146"Copying Class ObjectsIDREF="ch12137"Copying Class ObjectsIDREF="ch12127"Copying Class ObjectsIDREF="ch1366"Assignmentdefault assignment operator accessIDREF="ch12139"Copying Class Objectsdefault assignment operator restrictionIDREF="ch12140"Copying Class ObjectsIDREF="ch12135"Copying Class Objectsdefault constructorIDREF="ch1210"ConstructorsIDREF="ch12128"Copying Class ObjectsIDREF="ch1211"ConstructorsIDREF="ch12101"Explicit InitializationIDREF="ch128"Constructorsdefault constructor and arrayIDREF="ch5147"Newdefault constructor and initializationIDREF="ch1288"Initializationdefault constructor and newIDREF="ch5141"NewIDREF="ch5146"Newdefault copy constructorIDREF="ch12130"Copying Class ObjectsIDREF="ch12145"Copying Class ObjectsIDREF="ch12136"Copying Class ObjectsIDREF="ch12129"Copying Class Objectsdefault copy constructor accessIDREF="ch12138"Copying Class Objectsdefault copy constructor restrictionIDREF="ch12141"Copying Class ObjectsIDREF="ch12134"Copying Class Objectsdefault destructorIDREF="ch1260"Destructorsdefault initializationIDREF="ch898"Initializersdefault labelIDREF="ch630"The switch StatementIDREF="ch610"Labeled StatementIDREF="ch628"The switch Statementdefault type intIDREF="ch763"Type Specifiersdefined operatorIDREF="ch1665"Conditional Compilationdefinition and initializationIDREF="ch720"Storage Class Specifiersdefinition classIDREF="ch364"Program and LinkageIDREF="ch322"Declarations and Definitionsdefinition enumeratorIDREF="ch323"Declarations and DefinitionsIDREF="ch365"Program and Linkagedefinition exampleIDREF="ch318"Declarations and Definitionsdefinition functionIDREF="ch363"Program and LinkageIDREF="ch321"Declarations and Definitionsdefinition objectIDREF="ch362"Program and LinkageIDREF="ch320"Declarations and Definitionsdefinition versus declarationIDREF="ch310"Declarations and DefinitionsdeleteIDREF="ch5160"DeleteIDREF="ch5152"Deletedelete and arrayIDREF="ch1284"Free Storedelete arrayIDREF="ch5161"Deletedelete exampleIDREF="ch1280"Free Storedelete zero pointerIDREF="ch5155"DeletedereferencingIDREF="ch516"Expressionsdereferencing; see also indirectionIDREF="ch599"Unary Operatorsderivation; see inheritanceIDREF="ch1013"Derived Classesderived classIDREF="ch101"Derived Classesderived class castIDREF="ch5176"Explicit Type Conversionderived class exampleIDREF="ch1018"Derived Classesderived class pointer conversionIDREF="ch427"Pointer Conversionsderived typeIDREF="ch3132"Derived Typesdestruction of autoIDREF="ch674"Declaration Statementdestruction of local staticIDREF="ch680"Declaration Statementdestruction of local variableIDREF="ch673"Declaration StatementdestructorIDREF="ch1254"Destructorsdestructor and array order of executionIDREF="ch1264"Destructorsdestructor and constIDREF="ch969"The this PointerIDREF="ch1256"Destructorsdestructor and deleteIDREF="ch1270"DestructorsIDREF="ch5158"Deletedestructor and delete exampleIDREF="ch1285"Free Storedestructor and exit from scopeIDREF="ch652"Jump Statementsdestructor and fundamental typeIDREF="ch1275"Destructorsdestructor and member functionIDREF="ch1266"Destructorsdestructor and member function callIDREF="ch12120"Constructors and Destructorsdestructor and placement of objectIDREF="ch1274"Destructorsdestructor and static objects order of executionIDREF="ch12103"Explicit Initializationdestructor and virtual function callIDREF="ch12122"Constructors and Destructorsdestructor and volatileIDREF="ch1257"DestructorsIDREF="ch971"The this Pointerdestructor for temporaryIDREF="ch1228"Temporary Objectsdestructor order of executionIDREF="ch1261"Destructorsdestructor restrictionIDREF="ch1267"DestructorsIDREF="ch1255"Destructorsdestructor static objectIDREF="ch385"Start and Terminationdifference from ANSI_ C implementation dependencyIDREF="chb37"C++ and ANSI Cdifference from C expression evaluationIDREF="chb2"Compatibilitydifference from C function declarationIDREF="chb31"C++ and ANSI Cdifference from C initialization and gotoIDREF="chb33"C++ and ANSI Cdifference from C jump past initializationIDREF="chb34"C++ and ANSI Cdifference from C linkageIDREF="chb35"C++ and ANSI Cdifference from C name spaceIDREF="chb32"C++ and ANSI Cdifference from C scopeIDREF="chb4"Compatibilitydifference from C sizeofIDREF="chb3"Compatibilitydirect base classIDREF="ch1027"Multiple Base ClassesIDREF="ch1019"Derived Classesdistinct stringIDREF="ch279"String Literalsdivision operatorIDREF="ch5200"Multiplicative OperatorsdnameIDREF="ch87"Declaratorsdo statementIDREF="ch636"Iteration StatementsIDREF="ch640"Do statementdot operator; see class member access operatorIDREF="ch570"Class Member Accessdouble constantIDREF="ch265"Floating Constantsdouble typeIDREF="ch3126"Fundamental Typesdouble type specifierIDREF="ch771"Type Specifiersdynamic binding; see virtual functionIDREF="ch1040"Virtual Functionsdynamic initializationIDREF="ch381"Start and TerminationE suffixIDREF="ch264"Floating Constantselaborated class nameIDREF="ch929"Class NamesIDREF="ch779"Type SpecifiersIDREF="ch924"Class Nameselaborated enum nameIDREF="ch780"Type Specifierselaborated type specifier; see elaborated class nameIDREF="ch930"Class Nameselaborated-type-specifierIDREF="ch773"Type Specifierselif-lineIDREF="ch1657"Conditional Compilationelif-partsIDREF="ch1656"Conditional Compilationelimination of temporaryIDREF="ch1230"Temporary ObjectsellipsisIDREF="ch115"Notation and Syntax Conventionsellipsis exampleIDREF="ch862"Functionsellipsis in function declarationIDREF="ch849"FunctionsIDREF="ch552"Function CallelseIDREF="ch621"Selection Statementselse-partIDREF="ch1658"Conditional Compilationempty argument listIDREF="ch851"Functionsempty class sizeofIDREF="ch912"Classesempty statementIDREF="ch614"Expression Statementendif-lineIDREF="ch1660"Conditional Compilationenum declaration _[_]IDREF="ch786"Enumeration Declarationsenum type specifierIDREF="ch774"Type SpecifiersenumerationIDREF="ch785"Enumeration Declarationsenumeration constantIDREF="ch789"Enumeration Declarationsenumeration exampleIDREF="ch795"Enumeration DeclarationsenumeratorIDREF="ch788"Enumeration Declarationsenumerator memberIDREF="ch797"Enumeration Declarationsenumerator point of definitionIDREF="ch793"Enumeration Declarationsenumerator redefinitionIDREF="ch792"Enumeration Declarationsenumerator restrictionIDREF="ch791"Enumeration Declarationsequality operatorIDREF="ch5256"Equality OperatorsIDREF="ch5254"Equality Operatorsequality-expressionIDREF="ch5255"Equality Operatorserror preprocessing directiveIDREF="ch1675"Error Directiveescape character; see backslashIDREF="ch254"Character Constantsevolution of C++IDREF="ch12"About This Guideexception handling syntax summaryIDREF="cha12"Exception Handlingexit() IDREF="ch388"Start and Terminationexpansion macro; see macro expansionIDREF="ch1613"Phases of Preprocessingexplicit constructor callIDREF="ch1222"Constructorsexplicit destructor callIDREF="ch1273"DestructorsIDREF="ch1271"Destructorsexplicit destructor call exampleIDREF="ch1272"Destructorsexplicit qualification exampleIDREF="ch1034"Ambiguitiesexplicit type conversion; see castingIDREF="ch560"Explicit Type ConversionexpressionIDREF="ch5308"Comma OperatorIDREF="ch51"Expressionsexpression statementIDREF="ch611"Expression Statementexpression syntax summaryIDREF="cha4"Expressionsexpression-listIDREF="ch538"Postfix Expressionsexpression-statementIDREF="ch612"Expression Statementextension to CIDREF="chb5"ExtensionsIDREF="chb6"C++ Features Available in 1985IDREF="ch13"About This GuideIDREF="chb20"C++ Features Added Since 1985extension to C anonymous unionIDREF="chb19"C++ Features Available in 1985extension to C classIDREF="chb15"C++ Features Available in 1985extension to C constIDREF="chb11"C++ Features Available in 1985extension to C declaration statementIDREF="chb18"C++ Features Available in 1985extension to C deleteIDREF="chb14"C++ Features Available in 1985extension to C destructorIDREF="chb26"C++ Features Added Since 1985extension to C inline functionIDREF="chb10"C++ Features Available in 1985extension to C memberwise assignmentIDREF="chb27"C++ Features Added Since 1985extension to C memberwise initializationIDREF="chb28"C++ Features Added Since 1985extension to C multiple inheritanceIDREF="chb21"C++ Features Added Since 1985extension to C newIDREF="chb13"C++ Features Available in 1985extension to C overloadingIDREF="chb9"C++ Features Available in 1985extension to C overloading deleteIDREF="chb25"C++ Features Added Since 1985extension to C overloading newIDREF="chb24"C++ Features Added Since 1985extension to C pointer to memberIDREF="chb23"C++ Features Added Since 1985extension to C protectedIDREF="chb22"C++ Features Added Since 1985extension to C reference typeIDREF="chb12"C++ Features Available in 1985extension to C single precision arithmeticIDREF="chb8"C++ Features Available in 1985extension to C type checkingIDREF="chb7"C++ Features Available in 1985extension to C user-defined typeIDREF="chb16"C++ Features Available in 1985extension to C volatileIDREF="chb29"C++ Features Added Since 1985extern declarationIDREF="ch314"Declarations and Definitionsextern linkage specificationIDREF="ch7103"Linkage Specificationsextern reference declarationIDREF="ch8116"Referencesextern restrictionIDREF="ch721"Storage Class Specifiersexternal linkageIDREF="ch351"Program and LinkageF suffixIDREF="ch268"Floating ConstantsIDREF="ch269"Floating Constantsf7## preprocessing operatorIDREF="ch1626"The ## Operatorfct-bodyIDREF="ch878"Function Definitionsfct-specifierIDREF="ch734"Function Specifiersfield declaration IDREF="ch9101"Bit-FieldsfileIDREF="ch23"Lexical ConventionsIDREF="ch345"Program and Linkagefile inclusionIDREF="ch1634"File InclusionIDREF="ch1647"File InclusionIDREF="ch1644"File InclusionIDREF="ch1649"File Inclusionfile scopeIDREF="ch330"Scopesfilename includedIDREF="ch1639"File InclusionIDREF="ch1642"File Inclusionfloat constantIDREF="ch267"Floating Constantsfloat typeIDREF="ch3125"Fundamental Typesfloat type specifierIDREF="ch770"Type Specifiersfloating point constantIDREF="ch263"Floating Constantsfloating point integer conversionIDREF="ch414"Floating and Integralfloating point typeIDREF="ch3124"Fundamental Typesfor statementIDREF="ch641"The for StatementIDREF="ch637"Iteration Statementsformal argument initializationIDREF="ch545"Function Callformal argument; see also argumentIDREF="ch879"Function Definitionsforward class declarationIDREF="ch1011"Derived ClassesIDREF="ch925"Class Namesforward declarationIDREF="ch731"Storage Class Specifiersfree store and constructor anachronismIDREF="chb49"Assignment to thisfree store and destructor anachronismIDREF="chb50"Assignment to thisfree store; see also new, deleteIDREF="ch5123"Newfriend classIDREF="ch1125"Friendsfriend class declarationIDREF="ch927"Class Namesfriend exampleIDREF="ch926"Class Namesfriend function exampleIDREF="ch1121"Friendsfriend member functionIDREF="ch1124"Friendsfriend specifierIDREF="ch750"The friend Specifierfunction argument; see argumentIDREF="ch544"Function Callfunction bodyIDREF="ch876"Function Definitionsfunction callIDREF="ch547"Function Callfunction call operatorIDREF="ch1353"Overloaded OperatorsIDREF="ch541"Function Callfunction declarationIDREF="ch313"Declarations and DefinitionsIDREF="ch844"Functionsfunction declaration ambiguityIDREF="ch8100"Initializersfunction declaration exampleIDREF="ch861"Functionsfunction declarator ()IDREF="ch843"Functionsfunction definitionIDREF="ch875"Function Definitionsfunction definition exampleIDREF="ch881"Function Definitionsfunction member declarationIDREF="ch951"Member Functionsfunction member; see member functionIDREF="ch950"Member Functionsfunction name hidingIDREF="ch1317"Declaration Matchingfunction overloaded; see also overloadingIDREF="ch133"Overloadingfunction return type; see return typeIDREF="ch856"Functionsfunction return; see returnIDREF="ch659"The return Statementfunction scopeIDREF="ch328"Scopesfunction specifierIDREF="ch732"Function Specifiersfunction templateIDREF="ch1411"Function Templatesfunction template declarationIDREF="ch1414"Function Templatesfunction template definitionIDREF="ch1413"Function Templatesfunction typeIDREF="ch855"FunctionsIDREF="ch3134"Derived Typesfunction virtual; see virtual functionIDREF="ch1039"Virtual Functionsfunction-definitionIDREF="ch877"Function Definitionsfunction-like macroIDREF="ch1622"Macro Definition and Expansionfunction; see also friend function, member function, inline function, virtual functionIDREF="ch733"Function Specifiersfundamental typeIDREF="ch3106"Fundamental Typesfundamental type conversion; see conversion, user-defined conversionIDREF="ch1244"Conversion Functionsgenerated constructor; see default constructorIDREF="ch127"Constructorsgenerated destructor; see default destructorIDREF="ch1259"Destructorsglobal anonymous unionIDREF="ch997"Unionsglobal nameIDREF="ch331"Scopesglobal newIDREF="ch5137"Newglobal object storage classIDREF="ch3101"Storage Classesgoto statementIDREF="ch651"Jump StatementsIDREF="ch66"Labeled StatementIDREF="ch663"The goto StatementgrammarIDREF="cha1"Grammar Summarygreater than operatorIDREF="ch5240"Relational Operatorsgreater than or equal to operatorIDREF="ch5244"Relational Operatorshex numberIDREF="ch256"Character Constantshexadecimal constantIDREF="ch236"Integer Constantshiding; see name hidingIDREF="ch338"ScopesidentifierIDREF="ch213"IdentifiersIDREF="ch73"Declarations IDREF="ch531"Primary Expressionsif statementIDREF="ch620"Selection StatementsIDREF="ch624"The if Statementif-else ambiguityIDREF="ch625"The if Statementif-lineIDREF="ch1655"Conditional Compilationif-partIDREF="ch1654"Conditional Compilationimplementation dependency #ifdef nesting limitIDREF="ch1669"Conditional Compilationimplementation dependency #includeIDREF="ch1636"File InclusionIDREF="ch1637"File Inclusionimplementation dependency #include nesting limitIDREF="ch1651"File Inclusionimplementation dependency ____STDC____IDREF="ch1687"Predefined Namesimplementation dependency alignment of bit-fieldIDREF="ch9105"Bit-Fieldsimplementation dependency alignment requirementIDREF="ch3122"Fundamental Typesimplementation dependency allocationIDREF="ch1110"Access SpecifiersIDREF="ch949"Class Membersimplementation dependency arguments to main()IDREF="ch369"Start and Terminationimplementation dependency arithmetic exceptionIDREF="ch58"Expressionsimplementation dependency asmIDREF="ch7100"Asm Declarationsimplementation dependency base class allocationIDREF="ch1026"Multiple Base Classesimplementation dependency bit-field allocationIDREF="ch9103"Bit-Fieldsimplementation dependency change to const objectIDREF="ch5187"Explicit Type Conversionimplementation dependency conditional compilation nesting limitIDREF="ch1670"Conditional Compilationimplementation dependency constructor and newIDREF="ch5144"Newimplementation dependency destruction of temporaryIDREF="ch1234"Temporary Objectsimplementation dependency divisionIDREF="ch5206"Multiplicative Operatorsimplementation dependency extension to CIDREF="chb42"Anachronismsimplementation dependency floating point conversionIDREF="ch411"Float and Doubleimplementation dependency floating point typeIDREF="ch3128"Fundamental Typesimplementation dependency generation of temporaryIDREF="ch1231"Temporary Objectsimplementation dependency integer conversionIDREF="ch49"Integral Conversionsimplementation dependency left shiftIDREF="ch5235"Shift Operatorsimplementation dependency linkage of main()IDREF="ch375"Start and Terminationimplementation dependency linkage specificationIDREF="ch7105"Linkage Specificationsimplementation dependency modulusIDREF="ch5207"Multiplicative Operatorsimplementation dependency object linkageIDREF="ch7114"Linkage Specificationsimplementation dependency overflowIDREF="ch59"Expressionsimplementation dependency pointer comparisonIDREF="ch5252"Relational Operatorsimplementation dependency pointer integer conversionIDREF="ch5167"Explicit Type ConversionIDREF="ch5169"Explicit Type Conversionimplementation dependency pointer subtractionIDREF="ch5221"Additive Operatorsimplementation dependency pointer to function castIDREF="ch5181"Explicit Type ConversionIDREF="ch5182"Explicit Type Conversionimplementation dependency pragmaIDREF="ch1676"Pragmasimplementation dependency range of typesIDREF="ch224"Keywordsimplementation dependency sign of bit-fieldIDREF="ch9110"Bit-Fieldsimplementation dependency sign of charIDREF="ch3116"Fundamental Typesimplementation dependency signed unsignedIDREF="ch48"Integral Conversionsimplementation dependency sizeof expressionIDREF="ch5119"Sizeofimplementation dependency sizeof integral typeIDREF="ch3120"Fundamental Typesimplementation dependency sizeof typeIDREF="ch3111"Fundamental Typesimplementation dependency string literalIDREF="ch278"String Literalsimplementation dependency type of integer constantIDREF="ch247"Integer Constantsimplementation dependency type of ptrdiff__tIDREF="ch5220"Additive Operatorsimplementation dependency type of size__tIDREF="ch5118"Sizeofimplementation dependency type of wchar__tIDREF="ch262"Character ConstantsIDREF="ch291"String Literalsimplementation dependency value of char constantIDREF="ch257"Character Constantsimplementation dependency value of multicharacter constantIDREF="ch251"Character Constantsimplementation dependency volatileIDREF="ch761"Type Specifiersimplicit conversionIDREF="ch519"ExpressionsIDREF="ch42"Standard ConversionsIDREF="ch1239"Conversionsimplicit destructor callIDREF="ch1268"Destructorsimplicit user-defined conversionIDREF="ch1251"Conversion Functionsinclusion source fileIDREF="ch1645"File InclusionIDREF="ch1648"File InclusionIDREF="ch1650"File InclusionIDREF="ch1635"File Inclusionincrement operatorIDREF="ch574"Increment and DecrementIDREF="ch5108"Increment and DecrementIDREF="ch596"Unary Operatorsindirect base classIDREF="ch1028"Multiple Base ClassesIDREF="ch1020"Derived ClassesindirectionIDREF="ch5100"Unary Operatorsindirection operatorIDREF="ch584"Unary Operatorsinequality operatorIDREF="ch5258"Equality OperatorsinheritanceIDREF="ch105"Derived ClassesIDREF="ch1015"Derived Classesinheritance and friendIDREF="ch1130"Friendsinheritance of constructorIDREF="ch129"Constructorsinheritance of destructorIDREF="ch1258"Destructorsinheritance of overloaded operatorIDREF="ch1357"Overloaded Operatorsinheritance of user-defined conversionIDREF="ch1249"Conversion Functionsinheritance; see also multiple inheritanceIDREF="ch1016"Derived Classesinit-declaratorIDREF="ch83"DeclaratorsinitializationIDREF="ch886"Initializersinitialization and gotoIDREF="ch676"Declaration Statementinitialization and newIDREF="ch1296"Explicit InitializationIDREF="ch5138"Newinitialization class object; see also constructorIDREF="ch8106"Aggregatesinitialization in blockIDREF="ch670"Declaration StatementinitializerIDREF="ch887"InitializersIDREF="ch889"Initializersinitializer list _[_]IDREF="ch8108"Aggregatesinitializer-listIDREF="ch888"Initializersinline friend functionIDREF="ch1128"Friendsinline functionIDREF="ch736"Function Specifiersinline member functionIDREF="ch738"Function SpecifiersIDREF="ch972"Inline Member Functionsinline member function definitionIDREF="ch357"Program and Linkageinline member function rewriting rulesIDREF="ch974"Inline Member Functionsinline specifierIDREF="ch735"Function Specifiersint typeIDREF="ch3118"Fundamental Typesint type specifierIDREF="ch767"Type Specifiersinteger constantIDREF="ch235"Integer Constantsinteger conversionIDREF="ch46"Integral Conversionsinteger to pointer castIDREF="ch5168"Explicit Type Conversioninteger to pointer conversionIDREF="ch5215"Additive Operatorsintegral promotionIDREF="ch44"Integral PromotionsIDREF="ch555"Function Callintegral typeIDREF="ch3129"Fundamental Typesinternal linkageIDREF="ch347"Program and Linkageinterpretation of binary operatorIDREF="ch1363"Binary Operatorsinterpretation of unary operatorIDREF="ch1361"Unary OperatorsintroductionIDREF="ch11"IntroductionitalicIDREF="ch17"Notation and Syntax Conventionsiteration statementIDREF="ch633"Iteration Statementsiteration-statementIDREF="ch634"Iteration StatementsIDREF="ch657"The continue StatementIDREF="ch654"The break StatementJenniferIDREF="ch996"UnionsJessieIDREF="ch1243"Conversion by Constructorjump past initializationIDREF="ch632"The switch StatementIDREF="ch675"Declaration Statementjump past initialization exampleIDREF="ch678"Declaration Statementjump statementIDREF="ch645"Jump Statementsjump-statementIDREF="ch646"Jump StatementsKernighan and RitchieIDREF="ch14"About This GuidekeywordIDREF="cha3"Keywordskeyword listIDREF="ch217"KeywordsL prefixIDREF="ch290"String LiteralsIDREF="ch261"Character Constantsl suffixIDREF="ch244"Integer ConstantsIDREF="ch270"Floating ConstantsIDREF="ch271"Floating ConstantsIDREF="ch242"Integer ConstantslabelIDREF="ch664"The goto Statementlabel name spaceIDREF="ch68"Labeled Statementlabel specifier IDREF="ch65"Labeled Statementlabeled statementIDREF="ch64"Labeled Statementleft shift operatorIDREF="ch5230"Shift Operatorslength of nameIDREF="ch214"Identifiersless than operatorIDREF="ch5238"Relational Operatorsless than or equal to operatorIDREF="ch5242"Relational Operatorslexical conventionsIDREF="ch21"Lexical Conventionslibrary headersIDREF="ch228"KeywordslinkageIDREF="ch344"Program and LinkageIDREF="ch37"Basic Conceptslinkage consistencyIDREF="ch727"Storage Class SpecifiersIDREF="ch359"Program and LinkageIDREF="ch726"Storage Class Specifierslinkage consistency exampleIDREF="ch730"Storage Class Specifierslinkage of classIDREF="ch350"Program and Linkagelinkage of constIDREF="ch725"Storage Class SpecifiersIDREF="ch349"Program and Linkagelinkage of enumeratorIDREF="ch353"Program and Linkagelinkage of externIDREF="ch728"Storage Class Specifierslinkage of friend functionIDREF="ch1127"Friendslinkage of inline functionIDREF="ch729"Storage Class SpecifiersIDREF="ch737"Function SpecifiersIDREF="ch348"Program and Linkagelinkage of local nameIDREF="ch358"Program and Linkagelinkage of member functionIDREF="ch356"Program and Linkagelinkage of staticIDREF="ch724"Storage Class SpecifiersIDREF="ch7112"Linkage SpecificationsIDREF="ch346"Program and Linkagelinkage of static memberIDREF="ch355"Program and Linkagelinkage of templateIDREF="ch354"Program and Linkagelinkage of typedefIDREF="ch352"Program and Linkagelinkage specificationIDREF="ch7101"Linkage Specificationslinkage specification classIDREF="ch7107"Linkage Specificationslinkage specification consistencyIDREF="ch7109"Linkage Specificationslinkage specification functionIDREF="ch7108"Linkage Specificationslinkage specification objectIDREF="ch7113"Linkage SpecificationsIDREF="ch7111"Linkage Specificationslinkage specification overloaded functionIDREF="ch7110"Linkage Specificationslinkage to CIDREF="ch7106"Linkage Specificationslinkage-specificationIDREF="ch7102"Linkage SpecificationsliteralIDREF="ch234"LiteralsIDREF="ch523"Primary ExpressionsIDREF="ch233"Literalslocal class declarationIDREF="ch9124"Local Class Declarationslocal class exampleIDREF="ch9126"Local Class Declarationslocal class member functionIDREF="ch9127"Local Class Declarationslocal class restrictionIDREF="ch9128"Local Class Declarationslocal object constructorIDREF="ch399"Storage Classeslocal object destructorIDREF="ch3100"Storage Classeslocal object initializationIDREF="ch398"Storage Classeslocal object storage classIDREF="ch3102"Storage Classeslocal scopeIDREF="ch325"Scopeslocal static initializationIDREF="ch679"Declaration Statementlocal type nameIDREF="ch9129"Local Type Nameslocal type name exampleIDREF="ch9131"Local Type Nameslogical AND operatorIDREF="ch5267"Logical AND Operatorlogical negation operatorIDREF="ch592"Unary OperatorsIDREF="ch5106"Unary Operatorslogical OR operatorIDREF="ch5270"Logical OR Operatorlong constantIDREF="ch240"Integer Constantslong double constantIDREF="ch272"Floating Constantslong double typeIDREF="ch3127"Fundamental Typeslong typeIDREF="ch3119"Fundamental Typeslong type specifierIDREF="ch768"Type SpecifierslvalueIDREF="ch3150"Lvalueslvalue castIDREF="ch5179"Explicit Type Conversionlvalue conversionIDREF="ch43"Standard Conversionsmacro expansion preprocessingIDREF="ch1614"Phases of Preprocessingmacro preprocessingIDREF="ch165"Preprocessingmacro syntax summaryIDREF="cha10"Preprocessormain()IDREF="ch368"Start and Terminationmanual organizationIDREF="ch15"Document Overviewmeaning of declaratorIDREF="ch817"Meaning of Declaratorsmem-initializerIDREF="ch12107"Initializing Bases and Membersmember access ambiguityIDREF="ch1031"Ambiguitiesmember assignmentIDREF="ch12133"Copying Class Objectsmember class objectIDREF="ch945"Class Membersmember constructor order of executionIDREF="ch1216"Constructorsmember declarationIDREF="ch936"Class Membersmember definitionIDREF="ch957"Member Functionsmember destructor order of executionIDREF="ch1263"Destructorsmember function and access controlIDREF="ch122"Special Member Functionsmember function and friend functionIDREF="ch1120"Friendsmember function definitionIDREF="ch959"Member FunctionsIDREF="ch954"Member FunctionsIDREF="ch958"Member FunctionsIDREF="ch973"Inline Member Functionsmember function exampleIDREF="ch1122"FriendsIDREF="ch953"Member Functionsmember function in local classIDREF="ch976"Inline Member Functionsmember function in nested classIDREF="ch975"Inline Member Functionsmember function templateIDREF="ch1422"Member Function Templatesmember initializationIDREF="ch12105"Initializing Bases and MembersIDREF="ch12132"Copying Class Objectsmember initializerIDREF="ch883"Function Definitionsmember name accessIDREF="ch116"Member Access Controlmember name access exampleIDREF="ch1117"Access Declarationsmember object initializationIDREF="ch12109"Initializing Bases and Membersmember of class type restrictionIDREF="ch12100"Explicit Initializationmember pointer to; see pointer to memberIDREF="ch3142"Derived Typesmember-declarationIDREF="ch938"Class Membersmember-declaratorIDREF="ch940"Class Membersmember-listIDREF="ch937"Class Membersmember; see also base class memberIDREF="ch933"Class Membersmemberwise assignmentIDREF="ch1365"Assignmentmemory management anachronismIDREF="chb48"Assignment to thismemory management; see also new, deleteIDREF="ch5124"Newmissing storage class specifierIDREF="ch723"Storage Class Specifiersmissing type specifierIDREF="ch762"Type Specifiersmodifiable lvalueIDREF="ch3152"Lvaluesmodulus operatorIDREF="ch5202"Multiplicative Operatorsmost derived classIDREF="ch12117"Initializing Bases and Membersmulticharacter constantIDREF="ch250"Character Constantsmultidimensional arrayIDREF="ch841"Arraysmultidimensional array declaratorIDREF="ch839"Arraysmultiple declarationIDREF="ch361"Program and Linkagemultiple inheritanceIDREF="ch106"Derived ClassesIDREF="ch1021"Multiple Base Classesmultiplication operatorIDREF="ch5198"Multiplicative Operatorsmultiplicative operatorIDREF="ch5196"Multiplicative Operatorsmultiplicative-expressionIDREF="ch5197"Multiplicative OperatorsnameIDREF="ch215"IdentifiersIDREF="ch529"Primary ExpressionsIDREF="ch530"Primary ExpressionsIDREF="ch31"Basic Conceptsname and translation unitIDREF="ch38"Basic Conceptsname class; see class nameIDREF="ch95"Classesname declarationIDREF="ch312"Declarations and Definitionsname hidingIDREF="ch337"ScopesIDREF="ch535"Primary ExpressionsIDREF="ch668"Declaration StatementIDREF="ch340"ScopesIDREF="ch527"Primary Expressionsname type; see type nameIDREF="ch3147"Type Namesnested class declarationIDREF="ch9117"Nested Class Declarationsnested class declaration exampleIDREF="ch9122"Nested Class DeclarationsIDREF="ch9121"Nested Class Declarationsnested class exampleIDREF="ch9119"Nested Class Declarationsnested class friend functionIDREF="ch9123"Nested Class Declarationsnested class member functionIDREF="ch9120"Nested Class Declarationsnested class qualified nameIDREF="ch781"Type SpecifiersnewIDREF="ch1278"Free StoreIDREF="ch5133"NewIDREF="ch1276"Free StoreIDREF="ch5126"Newnew and arrayIDREF="ch1283"Free Storenew arrayIDREF="ch5132"Newnew placement syntaxIDREF="ch5135"Newnew-type-nameIDREF="ch5130"Newnonnested class anachronismIDREF="chb57"Non­nested Classesnotation and syntax conventionsIDREF="ch16"Notation and Syntax Conventionsnull character IDREF="ch285"String Literalsnull pointerIDREF="ch424"Pointer ConversionsIDREF="ch438"Pointers to MembersIDREF="ch5247"Relational Operatorsnull pointer conversionIDREF="ch430"Pointer Conversionsnull preprocessing directiveIDREF="ch1679"Null Directivenull statementIDREF="ch613"Expression StatementobjectIDREF="ch39"Basic ConceptsIDREF="ch3151"LvaluesIDREF="ch34"Basic Conceptsobject class; see also class objectIDREF="ch94"Classesobject temporary; see temporaryIDREF="ch1225"Temporary Objectsoctal constantIDREF="ch237"Integer Constantsoctal numberIDREF="ch255"Character Constantsold style base class initializer anachronismIDREF="chb46"Old Style Base Class Initializerold style function definition anachronismIDREF="chb45"Old Style Function Definitionsonescomplementoperator'IDREF="ch594"Unary OperatorsIDREF="ch5107"Unary Operatorsoperations on class objectIDREF="ch911"Classesoperator deleteIDREF="ch1282"Free Storeoperator delete; see deleteIDREF="ch5151"Deleteoperator functionIDREF="ch1346"Overloaded OperatorsIDREF="ch1349"Overloaded Operatorsoperator function callIDREF="ch1355"Overloaded Operatorsoperator identities and overloadingIDREF="ch1358"Overloaded Operatorsoperator left shift; see left shift operatorIDREF="ch5228"Shift Operatorsoperator listIDREF="ch221"KeywordsIDREF="ch1344"Overloaded Operatorsoperator new; see newIDREF="ch5122"Newoperator overloading restrictionsIDREF="ch1354"Overloaded Operatorsoperator overloading; see also overloaded operatorIDREF="ch1343"Overloaded Operatorsoperator right shiftIDREF="ch5227"Shift Operatorsoperator shift; see left shift operator, right shift operatorIDREF="ch5226"Shift Operatorsoperator-function-nameIDREF="ch1347"Overloaded OperatorsIDREF="ch1350"Overloaded Operatorsoperators one ofIDREF="ch1351"Overloaded Operatorsoptimization of temporary; see elimination of temporaryIDREF="ch1229"Temporary Objectsorder of argument evaluationIDREF="ch556"Function Callorder of base class initializationIDREF="ch12112"Initializing Bases and Membersorder of evaluation of expressionIDREF="ch54"Expressionsorder of initializationIDREF="ch1025"Multiple Base ClassesIDREF="ch384"Start and Terminationorder of member initializationIDREF="ch12113"Initializing Bases and Membersorder of virtual base class initializationIDREF="ch12114"Initializing Bases and MembersoverflowIDREF="ch511"Expressionsoverload keyword anachronismIDREF="chb43"Anachronismsoverloaded assignment and initializationIDREF="ch1293"Explicit Initializationoverloaded assignment operatorIDREF="ch1364"Assignmentoverloaded binary operatorIDREF="ch1362"Binary Operatorsoverloaded decrement operatorIDREF="ch1371"Increment and Decrementoverloaded function ambiguity detectionIDREF="ch1325"Argument Matchingoverloaded function and standard conversionIDREF="ch1338"Argument Matchingoverloaded function call operatorIDREF="ch1367"Function Calloverloaded function call resolution; see also argument matching, overloading resolutionIDREF="ch1323"Argument Matchingoverloaded function declaration matchingIDREF="ch1314"Declaration Matchingoverloaded function nameIDREF="ch132"Overloadingoverloaded increment operatorIDREF="ch1370"Increment and Decrementoverloaded member access operatorIDREF="ch1369"Class Member Accessoverloaded member nameIDREF="ch944"Class Membersoverloaded name and access declarationIDREF="ch1118"Access Declarationsoverloaded name and friend declarationIDREF="ch1123"Friendsoverloaded operatorIDREF="ch52"ExpressionsIDREF="ch1342"Overloaded OperatorsIDREF="ch1345"Overloaded OperatorsIDREF="ch1348"Overloaded Operatorsoverloaded operator and default argumentIDREF="ch1359"Overloaded Operatorsoverloaded subscripting operatorIDREF="ch1368"Subscriptingoverloaded unary operatorIDREF="ch1360"Unary OperatorsoverloadingIDREF="ch920"Class NamesIDREF="ch854"FunctionsIDREF="ch131"Overloadingoverloading and accessIDREF="ch1320"Declaration Matchingoverloading and CWconstIDREF="ch136"Overloadingoverloading and CWenumIDREF="ch1312"Overloadingoverloading and CWstaticIDREF="ch1310"Overloadingoverloading and CWtypedefIDREF="ch1311"Overloadingoverloading and CWvolatileIDREF="ch137"Overloadingoverloading and default argumentIDREF="ch874"Default Argumentsoverloading and deleteIDREF="ch1281"Free Storeoverloading and derived classIDREF="ch1316"Declaration Matchingoverloading and pointerIDREF="ch138"Overloadingoverloading and pointer versus arrayIDREF="ch1313"Overloadingoverloading and referenceIDREF="ch135"Overloadingoverloading and return typeIDREF="ch139"Overloadingoverloading and scopeIDREF="ch1315"Declaration Matchingoverloading exampleIDREF="ch134"Overloadingoverloading postfix ++ and &minusIDREF="ch1373"Increment and Decrementoverloading prefix ++ and &minusIDREF="ch1372"Increment and Decrementoverloading resolutionIDREF="ch1321"Argument Matchingoverloading resolution and access controlIDREF="ch1032"Ambiguitiesoverloading resolution and conversionIDREF="ch1329"Argument Matchingoverloading resolution and default argumentIDREF="ch1326"Argument Matchingoverloading resolution and ellipsisIDREF="ch1336"Argument MatchingIDREF="ch1328"Argument Matchingoverloading resolution and member functionIDREF="ch1327"Argument Matchingoverloading resolution and pointer conversionIDREF="ch1341"Address of Overloaded Functionoverloading resolution and promotionIDREF="ch1333"Argument Matchingoverloading resolution and standard conversionIDREF="ch1334"Argument Matchingoverloading resolution and user-defined conversionIDREF="ch1337"Argument MatchingIDREF="ch1339"Argument MatchingIDREF="ch1335"Argument Matchingoverloading resolution exact matchIDREF="ch1332"Argument Matchingoverloading resolution rulesIDREF="ch1331"Argument Matchingoverloading resolution trivial conversionsIDREF="ch1330"Argument Matchingoverloading restrictionIDREF="ch1356"Overloaded Operatorsoverloading versus name hidingIDREF="ch1318"Declaration Matchingoverriding virtual functionIDREF="ch1042"Virtual Functionsparameter; see argumentIDREF="ch372"Start and Terminationparentheses and ambiguityIDREF="ch5150"Newparentheses in declarationIDREF="ch816"Ambiguity ResolutionIDREF="ch819"Meaning of Declaratorsparenthesized expressionIDREF="ch528"Primary ExpressionsplacementIDREF="ch5129"Newpm-expressionIDREF="ch5194"Pointer - to - Member Operatorspoint of declaration class nameIDREF="ch931"Class Namespoint of declaration enumeratorIDREF="ch342"Scopespoint of declaration nameIDREF="ch341"Scopespointer arithmeticIDREF="ch5217"Additive Operatorspointer comparisonIDREF="ch5249"Relational OperatorsIDREF="ch5253"Relational Operatorspointer conversionIDREF="ch422"Pointer Conversionspointer conversion ambiguityIDREF="ch428"Pointer Conversionspointer declarationIDREF="ch821"Pointerspointer declarator *IDREF="ch820"Pointerspointer subtractionIDREF="ch5219"Additive Operatorspointer terminologyIDREF="ch3144"Derived Typespointer to abstract classIDREF="ch1052"Abstract Classespointer to bit-field restrictionIDREF="ch9114"Bit-Fieldspointer to const assignmentIDREF="ch5294"Assignment Operatorspointer to const initializationIDREF="ch893"Initializerspointer to function castIDREF="ch5180"Explicit Type Conversionpointer to function comparisonIDREF="ch5250"Relational Operatorspointer to function conversionIDREF="ch432"Pointer Conversionspointer to integer castIDREF="ch5166"Explicit Type Conversionpointer to integer conversionIDREF="ch5214"Additive Operatorspointer to memberIDREF="ch3143"Derived TypesIDREF="ch5189"Pointer - to - Member Operatorspointer to member castIDREF="ch5185"Explicit Type Conversionpointer to member conversionIDREF="ch439"Pointers to MembersIDREF="ch436"Pointers to Memberspointer to member conversion ambiguityIDREF="ch440"Pointers to Memberspointer to member conversion anachronismIDREF="chb55"Cast of Bound Pointerpointer to member declaratorIDREF="ch832"Pointers to Memberspointer to member exampleIDREF="ch833"Pointers to Memberspointer to member functionIDREF="ch5195"Pointer - to - Member Operatorspointer to member operatorIDREF="ch5190"Pointer - to - Member OperatorsIDREF="ch5192"Pointer - to - Member Operatorspointer to member void* conversionIDREF="ch441"Pointers to Memberspointer to pointer castIDREF="ch5170"Explicit Type Conversionpointer to pointer conversionIDREF="ch5216"Additive Operatorspointer to volatile assignmentIDREF="ch5296"Assignment Operatorspointer to volatile castingIDREF="ch5188"Explicit Type Conversionpointer to volatile initializationIDREF="ch895"Initializerspointer typeIDREF="ch3135"Derived Typespointer; see also void*IDREF="ch3145"Derived Typespostfix ++ and &minusIDREF="ch576"Increment and Decrementpostfix expressionIDREF="ch537"Postfix Expressionspragma preprocessing directiveIDREF="ch1678"Pragmasprecedence of operatorIDREF="ch53"Expressionspredefined macro namesIDREF="ch1680"Predefined Namesprefix ++ and &minusIDREF="ch5109"Increment and DecrementpreprocessingIDREF="ch25"Lexical ConventionsIDREF="ch161"Preprocessingpreprocessing directiveIDREF="ch164"Preprocessingpreprocessing line continuationIDREF="ch1611"Phases of Preprocessingpreprocessing macro definitionIDREF="ch1618"Macro Definition and Expansionpreprocessing macro expansionIDREF="ch1628"Rescanning and Further ReplacementIDREF="ch1619"Macro Definition and Expansionpreprocessing phasesIDREF="ch168"Phases of Preprocessingpreprocessing rescanning macro replacementIDREF="ch1629"Rescanning and Further Replacementpreprocessing syntax summaryIDREF="cha9"Preprocessorpreprocessing tokenIDREF="ch1612"Phases of Preprocessingprimary expressionIDREF="ch520"Primary ExpressionsprivateIDREF="ch113"Member Access Controlprivate base classIDREF="ch1113"Access Specifiers for Base ClassesprogramIDREF="ch22"Lexical ConventionsIDREF="ch343"Program and Linkageprogram environmentIDREF="ch374"Start and Terminationprogram startIDREF="ch383"Start and TerminationIDREF="ch367"Start and Terminationprogram terminationIDREF="ch376"Start and TerminationIDREF="ch386"Start and TerminationIDREF="ch378"Start and TerminationIDREF="ch392"Start and Terminationprogram termination and destructorIDREF="ch1269"DestructorsprotectedIDREF="ch114"Member Access Controlprotected member accessIDREF="ch1131"Protected Member Accessprotection; see access controlIDREF="ch112"Member Access Controlptr-operatorIDREF="ch85"Declaratorsptrdiff__tIDREF="ch5222"Additive OperatorspublicIDREF="ch115"Member Access Controlpublic base classIDREF="ch1114"Access Specifiers for Base ClassespunctuatorsIDREF="ch222"Keywordspure specifierIDREF="ch941"Class Memberspure virtual functionIDREF="ch1053"Abstract ClassesIDREF="ch1049"Abstract Classespure virtual function definitionIDREF="ch1050"Abstract Classespure virtual function exampleIDREF="ch1051"Abstract Classespure-specifierIDREF="ch942"Class Membersqualified nameIDREF="ch536"Primary Expressionsqualified-class-nameIDREF="ch784"Type Specifiersqualified-nameIDREF="ch532"Primary Expressionsqualified-type-nameIDREF="ch782"Type Specifiersrecursive function callIDREF="ch559"Function CallreferenceIDREF="ch3136"Derived Typesreference and argument passingIDREF="ch8114"Referencesreference and returnIDREF="ch8115"Referencesreference and temporaryIDREF="ch8117"Referencesreference argumentIDREF="ch551"Function CallIDREF="ch829"Referencesreference assignmentIDREF="ch8113"Referencesreference castIDREF="ch5178"Explicit Type Conversionreference conversionIDREF="ch433"Reference Conversionsreference conversion ambiguityIDREF="ch435"Reference Conversionsreference declarationIDREF="ch828"Referencesreference declarator &IDREF="ch826"Referencesreference expressionIDREF="ch515"Expressionsreference initializationIDREF="ch8112"ReferencesIDREF="ch831"Referencesreference member initializationIDREF="ch12111"Initializing Bases and Membersreference operandIDREF="ch512"Expressionsreference restrictionIDREF="ch830"Referencesreference to base classIDREF="ch434"Reference Conversionsregister declarationIDREF="ch718"Storage Class Specifiersregister initializationIDREF="ch672"Declaration Statementregister restrictionIDREF="ch717"Storage Class Specifiersrelational operatorIDREF="ch5236"Relational Operatorsrelational-expressionIDREF="ch5237"Relational Operatorsremainder operator; see modulus operatorIDREF="ch5204"Multiplicative Operatorsreserved identifierIDREF="ch220"Keywordsreserved word; see keywordIDREF="ch218"Keywordsresolution overloading; see overloading resolutionIDREF="ch1324"Argument MatchingreturnIDREF="ch650"Jump StatementsIDREF="ch658"The return Statementreturn from main()IDREF="ch387"Start and TerminationIDREF="ch379"Start and Terminationreturn statement; see also returnIDREF="ch649"Jump Statementsreturn typeIDREF="ch857"Functionsreturn type conversionIDREF="ch662"The return Statement right shift operatorIDREF="ch5227"Shift Operatorsright shift operatorIDREF="ch5232"Shift OperatorsroundingIDREF="ch417"Floating and Integralrun-time initializationIDREF="ch382"Start and Terminationsafe floating point conversionIDREF="ch412"Float and DoublescopeIDREF="ch36"Basic Conceptsscope of class declarationIDREF="ch921"Class Namesscope of class nameIDREF="ch922"Class Namesscope of declaration in forIDREF="ch644"The for Statementscope of default argumentIDREF="ch872"Default Argumentsscope of delete exampleIDREF="ch1286"Free Storescope of enumerator classIDREF="ch796"Enumeration Declarationsscope of formal argumentIDREF="ch327"ScopesIDREF="ch335"Scopesscope of friendIDREF="ch336"ScopesIDREF="ch334"Scopesscope of friend classIDREF="ch928"Class Namesscope of function definitionIDREF="ch366"Program and Linkagescope of labelIDREF="ch329"ScopesIDREF="ch67"Labeled Statementscope of local classIDREF="ch9125"Local Class Declarationsscope of local type nameIDREF="ch9130"Local Type Namesscope of macro nameIDREF="ch1630"Scope of Macro Names and #undefscope of member initializerIDREF="ch12118"Initializing Bases and Membersscope of nameIDREF="ch324"Scopesscope of nested classIDREF="ch9118"Nested Class Declarationsscope of nested class anachronismIDREF="chb58"Non­nested Classesscope of reference temporaryIDREF="ch8120"Referencesscope resolution operatorIDREF="ch526"Primary ExpressionsIDREF="ch533"Primary ExpressionsIDREF="ch534"Primary ExpressionsIDREF="ch956"Member FunctionsIDREF="ch1017"Derived ClassesIDREF="ch339"ScopesIDREF="ch1046"Virtual FunctionsIDREF="ch521"Primary ExpressionsIDREF="ch333"Scopesscope resolution operator exampleIDREF="ch1033"Ambiguitiesscope resolution operator useIDREF="ch981"Static Membersscope rules summaryIDREF="ch1056"Summary of Scope Rulesscoping ambiguity resolutionIDREF="ch1035"Ambiguitiesscoping and newIDREF="ch5131"Newselection statementIDREF="ch618"Selection Statementsselection-statementIDREF="ch619"Selection Statementssequencing operator; see comma operatorIDREF="ch5307"Comma Operatorshift operator; see left shift operator, right shift operatorIDREF="ch5225"Shift Operatorsshift-expressionIDREF="ch5229"Shift Operatorsshort typeIDREF="ch3117"Fundamental Typesshort type specifierIDREF="ch766"Type Specifiersside effectsIDREF="ch55"Expressionsside effects and comma operatorIDREF="ch5309"Comma Operatorside effects and logical AND operatorIDREF="ch5269"Logical AND Operatorside effects and logical OR operatorIDREF="ch5272"Logical OR Operatorsigned char typeIDREF="ch3113"Fundamental Typessigned characterIDREF="ch3115"Fundamental Typessigned unsigned integer conversionIDREF="ch47"Integral Conversionssimple-type-nameIDREF="ch764"Type Specifierssingle precision floating point arithmeticIDREF="ch410"Float and Doublesize__tIDREF="ch5121"Sizeofsizeof arrayIDREF="ch5117"Sizeofsizeof class objectIDREF="ch5116"Sizeofsizeof operatorIDREF="ch582"Unary OperatorsIDREF="ch5112"SizeofIDREF="ch5113"Sizeofsizeof reference exampleIDREF="ch5115"Sizeofsizeof stringIDREF="ch286"String Literalsspecial member function; see also constructor, destructor, inline function, user-defined conversion, virtual functionIDREF="ch121"Special Member Functionsspecifier access; see access specifierIDREF="ch109"Derived Classesspecifier type; see type specifierIDREF="ch751"Type Specifiersstandard conversionIDREF="ch41"Standard ConversionsstatementIDREF="ch63"StatementsIDREF="ch61"Statementsstatement sequenceIDREF="ch62"Statementsstatement syntax summaryIDREF="cha8"Statementsstatic class memberIDREF="ch3105"Storage Classesstatic local objectIDREF="ch3104"Storage Classesstatic memberIDREF="ch977"Static Membersstatic member declarationIDREF="ch315"Declarations and Definitionsstatic member definitionIDREF="ch985"Static Membersstatic member exampleIDREF="ch983"Static Membersstatic member functionIDREF="ch979"Static MembersIDREF="ch955"Member FunctionsIDREF="ch978"Static Membersstatic member initializationIDREF="ch984"Static Membersstatic member local class restrictionIDREF="ch980"Static Membersstatic member useIDREF="ch982"Static Membersstatic object initializationIDREF="ch380"Start and TerminationIDREF="ch897"InitializersIDREF="ch891"Initializersstatic restrictionIDREF="ch722"Storage Class Specifiersstatic specifierIDREF="ch715"Storage Class Specifiersstatic storage classIDREF="ch397"Storage Classesstorage allocation newIDREF="ch5128"Newstorage classIDREF="ch35"Basic ConceptsIDREF="ch394"Storage Classesstorage class declarationIDREF="ch713"Storage Class Specifiersstorage class specifierIDREF="ch712"Storage Class Specifiersstorage management; see new, deleteIDREF="ch5125"Newstorage of arrayIDREF="ch842"Arraysstring concatenationIDREF="ch281"String LiteralsIDREF="ch282"String Literalsstring constantIDREF="ch273"String Literalsstring literalIDREF="ch274"String Literalsstring literal concatenationIDREF="ch1615"Phases of Preprocessingstring terminator IDREF="ch284"String LiteralsstructIDREF="ch3140"Derived Typesstruct default member accessIDREF="ch914"Classesstruct initializationIDREF="ch8107"Aggregatesstruct type specifierIDREF="ch777"Type SpecifiersstructureIDREF="ch3139"Derived Typesstructure tag; see class nameIDREF="ch918"Class Namessubscripting exampleIDREF="ch837"Arrayssubscripting explanationIDREF="ch840"Arrayssubscripting operatorIDREF="ch1352"Overloaded OperatorsIDREF="ch539"Subscriptingsubtraction operatorIDREF="ch5212"Additive Operatorsswitch statementIDREF="ch626"The switch StatementIDREF="ch655"The break StatementIDREF="ch622"Selection Statementssyntax conventionbracketsIDREF="ch114"Notation and Syntax ConventionscourierIDREF="ch110"Notation and Syntax Conventionscourier boldIDREF="ch112"Notation and Syntax ConventionsellipsisIDREF="ch116"Notation and Syntax ConventionsitalicsIDREF="ch18"Notation and Syntax Conventionsvertical barIDREF="ch118"Notation and Syntax Conventionssyntax summaryIDREF="cha2"Grammar SummarytemplateIDREF="ch142"Templatestemplate and friendIDREF="ch1423"Friendstemplate and static memberIDREF="ch1424"Static Members and Variablestemplate and static variableIDREF="ch1425"Static Members and Variablestemplate classIDREF="ch149"Class Templatestemplate class declarationIDREF="ch1416"Declarations and Definitionstemplate class definitionIDREF="ch1418"Declarations and DefinitionsIDREF="ch1421"Declarations and Definitionstemplate declarationIDREF="ch1415"Declarations and Definitionstemplate function declarationIDREF="ch1417"Declarations and Definitionstemplate function definitionIDREF="ch1419"Declarations and DefinitionsIDREF="ch1420"Declarations and Definitionstemplate function overloading resolutionIDREF="ch1412"Function Templatestemplate specifierIDREF="ch749"The template Specifiertemplate syntax summaryIDREF="cha11"Templatestemplate type equivalenceIDREF="ch1410"Type Equivalencetemplate-argIDREF="ch148"Class Templatestemplate-arg-listIDREF="ch147"Class Templatestemplate-argumentIDREF="ch144"Templatestemplate-argument-listIDREF="ch143"Templatestemplate-class-nameIDREF="ch146"Class Templatestemplate-declarationIDREF="ch141"TemplatestemporaryIDREF="ch1226"Temporary ObjectsthisIDREF="ch525"Primary Expressionsthis and constructor anachronismIDREF="chb51"Assignment to thisthis and destructor anachronismIDREF="chb52"Assignment to thisthis pointer; see thisIDREF="ch961"The this PointertokenIDREF="ch26"Lexical ConventionsIDREF="ch223"KeywordsIDREF="ch28"Tokenstoken preprocessingIDREF="ch167"Preprocessingtoken replacement; see macro expansionIDREF="ch1617"Macro Definition and Expansiontranslation phasesIDREF="ch24"Lexical Conventionstranslation unitIDREF="ch27"Lexical Conventionstranslation unit and consistencyIDREF="chb36"C++ and ANSI CtrigraphIDREF="ch1616"Trigraph SequencesIDREF="ch169"Phases of PreprocessingtruncationIDREF="ch416"Floating and IntegraltypeIDREF="ch33"Basic Conceptstype conversion rulesIDREF="ch421"Arithmetic Conversionstype conversion, explicit; see castingIDREF="ch561"Explicit Type Conversiontype conversion; see also conversionIDREF="ch420"Arithmetic Conversionstype declarationIDREF="ch818"Meaning of Declaratorstype declaration consistencyIDREF="ch360"Program and Linkagetype equivalenceIDREF="ch919"Class NamesIDREF="ch743"The typedef Specifiertype nameIDREF="ch3148"Type NamesIDREF="ch89"Type Namestype name as synonymIDREF="ch744"The typedef Specifiertype name exampleIDREF="ch813"Type Namestype of bit-fieldIDREF="ch9109"Bit-Fieldstype of character constantIDREF="ch249"Character Constantstype of constructorIDREF="ch1219"Constructorstype of conversionIDREF="ch1248"Conversion Functionstype of deleteIDREF="ch1279"Free Storetype of enumIDREF="ch787"Enumeration DeclarationsIDREF="ch794"Enumeration Declarationstype of floating point constantIDREF="ch266"Floating Constantstype of integer constantIDREF="ch246"Integer Constantstype of newIDREF="ch1277"Free Storetype of static memberIDREF="ch5102"Unary OperatorsIDREF="ch986"Static Memberstype of stringIDREF="ch276"String Literalstype of string literalIDREF="ch277"String Literalstype of thisIDREF="ch962"The this Pointertype of virtual functionIDREF="ch1041"Virtual Functionstype void*IDREF="ch3146"Derived Typestype-argumentIDREF="ch145"Templatestype-nameIDREF="ch811"Type Namestype-specifierIDREF="ch752"Type SpecifierstypedefIDREF="ch3149"Type Namestypedef and longIDREF="ch710"Specifierstypedef and shortIDREF="ch711"Specifierstypedef and signedIDREF="ch78"Specifierstypedef and unsignedIDREF="ch79"Specifierstypedef as type declarationIDREF="ch742"The typedef Specifiertypedef class nameIDREF="ch748"The typedef SpecifierIDREF="ch747"The typedef SpecifierIDREF="ch932"Class Namestypedef declarationIDREF="ch317"Declarations and Definitionstypedef exampleIDREF="ch745"The typedef Specifiertypedef redefinitionIDREF="ch746"The typedef SpecifierIDREF="ch9133"Local Type Namestypedef specifierIDREF="ch740"The typedef Specifiertypedef-nameIDREF="ch741"The typedef Specifiertypes floating; see floating point typeIDREF="ch3110"Fundamental Typestypes integral; see integral typeIDREF="ch3109"Fundamental Typesu suffixIDREF="ch245"Integer ConstantsIDREF="ch243"Integer Constantsunary expressionIDREF="ch580"Unary Operatorsunary minus operatorIDREF="ch588"Unary OperatorsIDREF="ch5105"Unary Operatorsunary operatorIDREF="ch581"Unary Operatorsunary plus operatorIDREF="ch5104"Unary OperatorsIDREF="ch590"Unary Operatorsunary-expressionIDREF="ch579"Unary Operatorsunary-operatorIDREF="ch598"Unary Operatorsundefined access outside array boundIDREF="ch5218"Additive Operatorsundefined argument to constructorIDREF="ch5149"Newundefined bound pointer to member functionIDREF="chb56"Cast of Bound Pointerundefined change to const objectIDREF="ch759"Type Specifiersundefined change to string literalIDREF="ch280"String Literalsundefined conversion out of range valueIDREF="ch413"Float and Doubleundefined deleteIDREF="ch5154"DeleteIDREF="ch5162"Deleteundefined deleted objectIDREF="ch5156"Deleteundefined destructor callIDREF="ch681"Declaration Statementundefined division by zeroIDREF="ch5205"Multiplicative OperatorsIDREF="ch510"Expressionsundefined expressionIDREF="ch564"Explicit Type Conversionundefined file name #includeIDREF="ch1643"File InclusionIDREF="ch1640"File Inclusionundefined function callIDREF="ch5183"Explicit Type Conversionundefined left shiftIDREF="ch5234"Shift Operatorsundefined member function callIDREF="ch960"Member Functionsundefined order of argument evaluationIDREF="ch557"Function Callundefined order of evaluationIDREF="ch56"Expressionsundefined order of evaluation newIDREF="ch5148"Newundefined order of function call evaluationIDREF="ch558"Function Callundefined pointer comparisonIDREF="ch5223"Additive OperatorsIDREF="ch5251"Relational Operatorsundefined pure virtual function callIDREF="ch12123"Constructors and DestructorsIDREF="ch1055"Abstract Classesundefined readonly memoryIDREF="ch758"Type Specifiersundefined string literal concatenationIDREF="ch292"String Literalsundefined uninitialized variableIDREF="ch899"Initializersundefined unrepresentable integral valueIDREF="ch415"Floating and Integralundefined valueIDREF="ch5224"Additive Operatorsundefined value deleteIDREF="ch5157"Deleteundefined value newIDREF="ch5140"Newunderscore characterIDREF="ch216"Identifiersunderscore in identifier __IDREF="ch219"KeywordsunionIDREF="ch987"UnionsIDREF="ch3141"Derived Typesunion constructorIDREF="ch989"Unionsunion default member accessIDREF="ch916"Classesunion destructorIDREF="ch990"Unionsunion initializationIDREF="ch995"UnionsIDREF="ch8110"Aggregatesunion member functionIDREF="ch988"Unionsunion restrictionIDREF="ch993"UnionsIDREF="ch991"UnionsIDREF="ch992"UnionsIDREF="ch1217"Constructorsunion type specifierIDREF="ch778"Type Specifiersunknown argument typeIDREF="ch847"Functionsunnamed argument exampleIDREF="ch885"Function Definitionsunnamed bit-fieldIDREF="ch9106"Bit-Fieldsunnamed objectIDREF="ch1221"Constructorsunsigned arithmeticIDREF="ch3123"Fundamental Typesunsigned char typeIDREF="ch3114"Fundamental Typesunsigned constantIDREF="ch241"Integer Constantsunsigned typeIDREF="ch3121"Fundamental Typesunsigned type specifierIDREF="ch769"Type Specifiersuser-defined conversionIDREF="ch1242"Conversion by ConstructorIDREF="ch1245"Conversion FunctionsIDREF="ch517"ExpressionsIDREF="ch1236"Conversionsuser-defined conversion and name hidingIDREF="ch1252"Conversion Functionsvalue of enumeratorIDREF="ch790"Enumeration Declarationsvariable argument listIDREF="ch850"FunctionsIDREF="ch553"Function Callvariable argument list exampleIDREF="ch863"Functionsvertical barIDREF="ch117"Notation and Syntax Conventionsvirtual and friendIDREF="ch1044"Virtual Functionsvirtual base classIDREF="ch1029"Multiple Base Classesvirtual base class dominanceIDREF="ch1036"Ambiguitiesvirtual base class initializationIDREF="ch12115"Initializing Bases and MembersIDREF="ch12131"Copying Class Objectsvirtual destructorIDREF="ch1265"Destructorsvirtual functionIDREF="ch1038"Virtual Functionsvirtual function accessIDREF="ch1132"Access to Virtual Functionsvirtual function callIDREF="ch1047"Virtual Functionsvirtual function definitionIDREF="ch1045"Virtual Functionsvirtual function exampleIDREF="ch1043"Virtual Functionsvirtual specifierIDREF="ch739"Function Specifiersvirtual user-defined conversionIDREF="ch1250"Conversion Functionsvoid argumentIDREF="ch852"Functionsvoid typeIDREF="ch3131"Fundamental Typesvoid type specifierIDREF="ch772"Type Specifiersvoid&IDREF="ch827"Referencesvoid* pointer comparisonIDREF="ch5248"Relational Operatorsvoid* pointer conversionIDREF="ch425"Pointer Conversionsvoid* pointer type extension to CIDREF="chb17"C++ Features Available in 1985volatile member functionIDREF="ch964"The this PointerIDREF="ch967"The this Pointervolatile operandIDREF="ch514"Expressionsvolatile pointer assignmentIDREF="ch5295"Assignment Operatorsvolatile pointer initializationIDREF="ch894"Initializersvolatile referenceIDREF="ch8119"Referencesvolatile typeIDREF="ch754"Type Specifiersvolatile type specifierIDREF="ch760"Type Specifierswchar__tIDREF="ch288"String LiteralsIDREF="ch260"Character Constantswhile statementIDREF="ch635"Iteration StatementsIDREF="ch639"The while Statementwhite spaceIDREF="ch29"Tokenswide-characterIDREF="ch258"Character Constantswide-character stringIDREF="ch289"String LiteralsX(X&); see copy constructorIDREF="ch1213"Constructorszero argument to newIDREF="ch5134"Newzero assignment to pointerIDREF="ch5292"Assignment Operatorszero assignment to pointer to memberIDREF="ch5298"Assignment Operatorszero pointerIDREF="ch5246"Relational OperatorsIDREF="ch423"Pointer ConversionsIDREF="ch437"Pointers to Memberszero pointer conversionIDREF="ch429"Pointer Conversionszero width of bit-fieldIDREF="ch9107"Bit-Fieldszero, null ()IDREF="ch283"String Literals|; see bitwise inclusive OR operatorIDREF="ch5266"Bitwise Inclusive-OR Operator|= operatorIDREF="ch5286"Assignment Operators||; see logical OR operatorIDREF="ch5271"Logical OR Operator