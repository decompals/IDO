#EDIR DATA#
LANG="C"ID="19627"MIPSproname='trade' font=symbol charset=fontspecific code=228 
	descr='[trade]' Compiling and Performance Tuning GuideDocument Number 007-2360-006ContributorsWritten by Arthur Evans, Wendy Ferguson, Jed Hartman, Jackie NeiderEdited by Christina CaryProduction by Lorrie WilliamsEngineering contributions by Dave Anderson, Zaineb Asaf, Dave Babcock, Greg Boyd, Jack Carter, Ann Mei Chang, Wei-Chau Chang, David Ciemiewicz, Rune Dahl, Jim Dehnert, David Frederick, Sanjoy Ghosh, Jay Gischer, Bob Green, Seema Hiranandani, W. Wilson Ho, Marty Itzkowitz, Bhaskar Janakiraman, Woody Lichtenstein, Dror Maydan, Ajit Mayya, Ray Milkey, Michael Murphy, Bron Nelson, Andy Palay, Ron Price, John Wilkinson© Copyright 1996 Silicon Graphics, Inc.name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' All Rights ReservedThis document contains proprietary and confidential information of Silicon Graphics, Inc. The contents of this document may not be disclosed to third parties, copied, or duplicated in any form, in whole or in part, without the prior written permission of Silicon Graphics, Inc.Restricted Rights LegendUse, duplication, or disclosure of the technical data contained in this document by the Government is subject to restrictions as set forth in subdivision (c) (1) (ii) of the Rights in Technical Data and Computer Software clause at DFARS 52.227-7013 and/or in similar or successor clauses in the FAR, or in the DOD or NASA FAR Supplement. Unpublished rights reserved under the Copyright Laws of the United States. Contractor/manufacturer is Silicon Graphics, Inc., 2011 N. Shoreline Blvd., Mountain View, CA 94039-7311.Silicon Graphics, the Silicon Graphics logo, and IRIS are registered trademarks and IRIX, CASEVision, IRIS IM, IRIS Showcase, Impressario, Indigo Magic, Inventor, IRIS-4D, POWER Series, RealityEngine, CHALLENGE, Onyx, Origin2000, and WorkShop are trademarks of Silicon Graphics, Inc. MIPS, R4000, and R8000 are registered trademarks and MIPSpro, R5000, and R10000 are trademarks of MIPS Technologies, Inc. OSF/Motif is a trademark of Open Software Foundation, Inc. PostScript is a registered trademark and Display PostScript is a trademark of Adobe Systems, Inc. UNIX is a registered trademark in the United States and other countries, licensed exclusively through X/Open Company, Ltd. X Window System is a trademark of the Massachusetts Institute of Technology. ID="28341"About This GuideThis guide describes the components of MIPSproname='trade' font=symbol charset=fontspecific code=228 
	descr='[trade]' compiler system, other programming tools and interfaces, and dynamic shared objects. It also explains ways to improve program performance. The compiler system produces either new 32-bit (n32) object code, 64-bit object code, or 32-bit object code. This guide describes the MIPSpro compilers that produce n32-bit and 64-bit object code. For additional information about n32 and 64-bit compilation, see the MIPSpro N32 ABI Handbook and MIPSpro Porting and Transition Guide, respectively. For information about compilers that produce old 32-bit objects, refer to the MIPS Compiling and Performance Tuning Guide.LBL="" HELPID=""What This Guide ContainsThis guide contains the following chapters:IDREF="44226" TYPE="TITLE"Chapter 1, "About the MIPSpro Compiler System," provides an overview of the MIPSpro compiler system.IDREF="48687" TYPE="TITLE"Chapter 2, "Using the MIPSpro Compiler System," describes the components and related tools of the MIPSpro compiler system and explains how to use them.IDREF="92826" TYPE="TITLE"Chapter 3, "Using Dynamic Shared Objects," explains how to build and use dynamic shared objects.IDREF="15323" TYPE="TITLE"Chapter 4, "Optimizing Program Performance," explains how to reduce program execution time by using optimization options and techniques.IDREF="67459" TYPE="TITLE"Chapter 5, "Coding for 64-Bit Programs" describes how to write or update code that is portable to 64-bit systems.IDREF="72950" TYPE="TITLE"Chapter 6, "Porting Code to N32 and 64-Bit Silicon Graphics Systems" explains how to port code from the old 32-bit mode to the new 32-bit mode (n32).For an overview of the IRIX programming environment and tools available for application programming, see Programming on Silicon Graphics Computer Systems: An Overview.LBL="" HELPID=""What You Should Know Before Reading This GuideThis guide is for anyone who wants to program effectively using the MIPSpro compilers. We assume you are familiar with the IRIX (or UNIX®) operating system and a programming language such as C or Fortran. This guide does not explain how to write and compile programs.This guide does not cover the differences between n32-bit, 64-bit, and 32-bit compilation modes. Refer to MIPSpro Application Porting and Transition Guide and MIPSpro N32 ABI Handbook for information about the differences between these modes, language implementation differences, source code porting, compilation issues, and run-time execution. Be sure to read the Release Notes for your compiler, which contain important information about this release of the MIPSpro compiler system.LBL="" HELPID=""Suggestions for Further ReadingThis guide is part of the IRIS Developer Option (IDO), which provides the software and documentation that you can use to write applications for Silicon Graphics platforms. Some IDO online and printed documents that may be of interest to you are listed in IDREF="65684" TYPE="TEXT"Table Intro-1. COLUMNS="2"LBL="Intro-1"Table Intro-1 ID="65684"  (continued)        IDO Topics and ManualsLEFT="0" WIDTH="111"TopicLEFT="120" WIDTH="221"DocumentLEFT="0" WIDTH="111"Compiler informationLEFT="120" WIDTH="221"Release Notes LEFT="0" WIDTH="111"IRIX programmingLEFT="120" WIDTH="221"Programming on Silicon Graphics Systems: An OverviewLEFT="0" WIDTH="111"LEFT="120" WIDTH="221"Topics in IRIX ProgrammingLEFT="0" WIDTH="111"Debugging a programLEFT="120" WIDTH="221"dbx User's GuideLEFT="0" WIDTH="111"prof, pixie, and ssrunLEFT="120" WIDTH="221"SpeedShop User's GuideLEFT="0" WIDTH="111"N32 ABILEFT="120" WIDTH="221"MIPSpro N32 ABI HandbookLEFT="0" WIDTH="111"Porting codeLEFT="120" WIDTH="221"MIPSpro Porting and Transition GuideLEFT="0" WIDTH="111"Assembly languageLEFT="120" WIDTH="221"MIPSpro Assembly Language Programmer's GuideLEFT="0" WIDTH="111"C languageLEFT="120" WIDTH="221"C Language Reference ManualLEFT="0" WIDTH="111"C++ languageLEFT="120" WIDTH="221"C++ Programming GuideLEFT="0" WIDTH="111"Fortran languageLEFT="120" WIDTH="221"Fortran 77 Programmer's Guide
Fortran 90 Programmer's GuideLEFT="0" WIDTH="111"Parallel programmingLEFT="120" WIDTH="221"Appropriate language manual (for example, Fortran 77 
Programmer's Guide) LEFT="0" WIDTH="111"Pascal languageLEFT="120" WIDTH="221"Pascal Programming GuideLEFT="0" WIDTH="111"Real-time programmingLEFT="120" WIDTH="221"REACT Real-Time Programmer's GuideSilicon Graphics also provides manuals online. To read an online manual after installing it, type insight or double-click the InSight icon. It's easy to print sections and chapters of the online manuals from InSight. You can also order printed manuals from Silicon Graphics by calling SGI Direct at 1-800-800-7441. Outside the U.S. and Canada, contact your local sales office or distributor.Silicon Graphics offers software options to assist in your software development. The compiler options include languages such as Fortran77, Power Fortran, and C++. CASEVision/Workshop provides the WorkShop toolset: the Debugger, Static Analyzer, Performance Analyzer, Tester, and Build Manager. As a developer, you are eligible to become a member of the Silicon Graphics Developer Program at SGI. Call 1-800 -770-3033 for details. If you are developing a MIPS ABI-compliant application, you may want to consult the MIPS ABI Frequently Asked Questions. You may also want to learn more about standard UNIX and ANSI C topics. For this information, consult a computer bookstore or manuals such as:AT&T. UNIX System V Release 4 Programmer's Guide: ANSI C and Programming Support Tools. Englewood Cliffs, NJ: Prentice Hall, 1990.Levine, Mason, and Brown. lex & yacc. Sebastopol. CA: O'Reilly & Associates, Inc., 1992.Oram and Talbott. Managing Projects with make. Sebastopol. CA: O'Reilly & Associates, Inc., 1991.American National Standards Institute, Inc. American National Standard, Programming Languagename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'C, ANSI C Standard. ANSI X3.159-1989.International Standard ISO/IEC. Programming languagesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'C, 9899. 1990(E).LBL="" HELPID=""Conventions Used in This GuideThis guide uses these conventions and symbols:ID="intro1"LinksLinks to other sections and chapters in this guide appear in blue. For example, IDREF="44226" TYPE="TITLE"Chapter 1 describes the components of the compiler system. Links to applications, files, and reference pages appear in red. For example, for information about the cc compiler, see the cc(1) reference page.CourierIn text, the Courier font represents function names, file names, and keywords. It is also used for command syntax, output, and program listings.boldBoldface is used along with Courier font to represent user input.italicsWords in italics represent characters or numerical values that you define. Replace the abbreviation with the defined value. Also, italics are used for manual titles, manual page names, and commands. The section number, in parentheses, follows the name. _ _A double underline appears as __ in text.[ ]Brackets enclose optional items.{ }Braces enclose two or more items; you must specify at least one of the items.|The OR symbol separates two or more optional items.name='hellip' font=symbol charset=fontspecific code=188A horizontal ellipsis in a syntax statement indicates that the preceding optional items can appear more than once in succession.( )Parentheses enclose entities and must be typed.The following two examples illustrate the syntax conventions:DIMENSION a(d) [,a(d)] name='hellip' font=symbol charset=fontspecific code=188indicates that you must type the Fortran keyword DIMENSION as shown, that the user-defined entity a(d) is required, and that you can specify one or more of a(d). The parentheses ( ) enclosing d are required. The following example:{STATIC | AUTOMATIC} v [,v] name='hellip' font=symbol charset=fontspecific code=188indicates that you must type either the STATIC or AUTOMATIC keyword as shown, that the user-defined entity v is required, and that you can specify one or more v items.LBL="1"ID="44226"About the MIPSpro Compiler SystemThe MIPSpro compiler system consists of a set of components that enable you to create new 32-bit and 64-bit executable programs (as well as 32-bit executables) using languages such as C, C++, and Fortran. A new 32-bit mode, n32, was introduced with the IRIX 6.1 operating system. This new 32-bit mode has the following features:full access to all features of the hardwareMIPSIII and MIPSIV instruction set architecture (ISA)improved calling convention32 64-bit floating point registers32 64-bit general purpose registersdwarf debugging formatThe new 32-bit mode (n32) provides higher performance than the old 32-bit mode available in IRIX releases prior to 6.1. When you compile ­n32, the chip executes in 64-bit mode and the software restricts addresses to 32-bits. For more information about n32, refer to the MIPSpro N32 ABI Handbook. In addition, the MIPSpro compiler system:uses ID="01.oview1"Executable and Linking Format (ELF) for object files. ELF is the format specified by System V Release 4 Applications Binary Interface (SVR4 ABI). Refer to IDREF="60325" TYPE="TITLE""Executable and Linking Format" for additional information.uses shared libraries, called ID="01.oview2"Dynamic Shared Objects (DSOs). DSOs are loaded at run time instead of at link time, by the run-time linker, rld. The code for DSOs is not included in executable files; thus, executables built with DSOs are smaller than those built with non-shared libraries, and multiple programs can use the same DSO at the same time. For more information, see IDREF="92826" TYPE="TITLE"Chapter 3, "Using Dynamic Shared Objects."creates ID="01.oview3"Position-Independent Code, (PIC) by default, to support dynamic linking. See IDREF="95878" TYPE="TITLE""Position-Independent Code,"for additional information. ID="01.oview4"ID="01.oview5"IDREF="85855" TYPE="TABLE"Table 1-1 summarizes the compiler system components and the task each performs.COLUMNS="3"LBL="1-1"Table 1-1  (continued)        Compiler System Functional ComponentsID="85855"LEFT="0" WIDTH="93"ToolLEFT="100" WIDTH="144"TaskLEFT="250" WIDTH="90"ExamplesLEFT="0" WIDTH="93"Text editorLEFT="100" WIDTH="144"Write and edit programsLEFT="250" WIDTH="90"vi, jot, emacsLEFT="0" WIDTH="93"Compiler driverLEFT="100" WIDTH="144"Compile, link, and load programsLEFT="250" WIDTH="90"cc, CC, f77, f90, pc, asLEFT="0" WIDTH="93"Object file analyzerLEFT="100" WIDTH="144"Analyze object filesLEFT="250" WIDTH="90"dis, dwarfdump, 
elfdump, file, nm, sizeLEFT="0" WIDTH="93"ProfilerLEFT="100" WIDTH="144"Analyze program performanceLEFT="250" WIDTH="90"prof, pixie, ssrunLEFT="0" WIDTH="93"ArchiverLEFT="100" WIDTH="144"Produce object-file librariesLEFT="250" WIDTH="90"arLEFT="0" WIDTH="93"LinkerLEFT="100" WIDTH="144"Link object filesLEFT="250" WIDTH="90"ldLEFT="0" WIDTH="93"Runtime linkerLEFT="100" WIDTH="144"Link Dynamic Shared Objects at 
runtimeLEFT="250" WIDTH="90"rldLEFT="0" WIDTH="93"DebuggerLEFT="100" WIDTH="144"Debug programsLEFT="250" WIDTH="90"dbxA single program called a compiler driver (such as ID="01.oview6"ID="01.oview7"cc, CC, or f77) invokes the following major components of the compiler system (refer to IDREF="69332" TYPE="GRAPHIC"Figure 1-1).Macro preprocessor (ID="01.oview8"ID="01.oview9"cpp)Parallel analyzer (ID="01.oview10"pca, fef77p, fef90p)Scalar optimizer (ID="01.oview11"copt)Compiler front end (ID="01.oview12"fec, fecc, fef77, fef77p, fef90, fef90p)Compiler back endID="01.oview13"Linker (ID="01.oview14"ld)You can invoke a compiler driver with various options (described later in this chapter) and with one or more source files as arguments. All specified source files are automatically sent to the macro preprocessor.Although the macro preprocessor was originally designed for C programs, it is now run by default as part of most compilations. To prevent running the preprocessor, use the ­nocpp option on the driver command line. For C and C++ compilations, preprocessing and front-end compilation is done by ID="01.oview15"fec and fecc. For all other compilations, preprocessing is done by invocation of a separate executable named cpp.If available, the parallel analyzers ID="01.oview16"pca,fef77p, or fef90p produce parallelized source code from standard source code. fec takes the output from pca and produces parallel C code (part of Power C). The result takes advantage of multiple CPUs (when present) to achieve higher computation rates. pca is part of Power C. Power Fortran automatically uses the parallel Fortran compiler, fef77p or fef90p, to produce parallel code. For more information about these packages and how to obtain them, contact your dealer/sales representative. The compiler front ends (fec, fecc, fef77, fef90) translate the source code into an intermediate tree representation. The compiler back end (be) translates the intermediate code into object code. The language compilers share the same back end (be), which combines optimization and code generation in one phase. (For more information about optimization, see IDREF="15323" TYPE="TITLE"Chapter 4, "Optimizing Program Performance.")The linker ID="01.oview17"ld combines several object files into one, performs relocation, and resolves external symbols. The driver automatically runs ld unless you specify the ­c option to skip the linking step.When you compile or link programs, by default, the compiler searches /usr/lib, /lib, and /usr/local/lib. Certain default libraries are automatically linked. Drivers and their respective libraries are listed in IDREF="35274" TYPE="TABLE"Table 1-2.COLUMNS="2"LBL="1-2"Table 1-2 ID="35274"Compilers and Default Libraries LEFT="0" WIDTH="166"CompilerLEFT="175" WIDTH="166"Default LibrariesLEFT="0" WIDTH="166"ccLEFT="175" WIDTH="166"libc.soLEFT="0" WIDTH="166"CCLEFT="175" WIDTH="166"libC.so, libc.so, libCsup.soLEFT="0" WIDTH="166"f77, f90LEFT="175" WIDTH="166"libftn.so, libftn90.so, libc.so, libm.soTo see the various utilities a program passes through during compilation, invoke the appropriate driver with the ID="01.oview18"­show option.IDREF="69332" TYPE="GRAPHIC"Figure 1-1 shows compilation flow from source file to executable file (a.out). FILE="1.1.cmplr.sys.gif" POSITION="INLINE" SCALE="FALSE"LBL="1-1"Figure 1-1 ID="69332"Compiler System FlowchartLBL="2"ID="48687"Using the MIPSpro Compiler SystemThis chapter provides information about the MIPSpro compiler system, and describes the object file format and dynamic linking. Specifically, this chapter covers the topics listed below:IDREF="90405" TYPE="TITLE""Selecting a Compiler" explains how to specify n32-bit, 64-bit, or 32-bit compilation mode and how to set up a compiler.defaults file.IDREF="37532" TYPE="TITLE""Object File Format and Dynamic Linking" discusses object files including executable and linking format, dynamic shared objects, and position-independent code.IDREF="67353" TYPE="TITLE""Source File Considerations" explains source file naming conventions, and the procedure for including header files.IDREF="24853" TYPE="TITLE""Using Precompiled Headers in C and C++" describes automatic and manual precompiled header processing.IDREF="39676" TYPE="TITLE""Compiler Drivers" lists and explains general compiler-driver options.IDREF="72868" TYPE="TITLE""Linking" explains how to link programs manually (using ld or a compiler) and how to compile multilanguage programs. It also covers Dynamic Shared Objects (DSOs) and how to link them into a program.IDREF="41684" TYPE="TITLE""Debugging" describes the compiler-driver options for debugging.IDREF="65767" TYPE="TITLE""Getting Information About Object Files" provides information on how to use the object file tools to analyze object files.IDREF="94723" TYPE="TITLE""Using the Archiver to Create Libraries" explains how to use the archiver, ar.For information about DSOs, see IDREF="92826" TYPE="TITLE"Chapter 3, "Using Dynamic Shared Objects." For information on optimizing your program, see IDREF="15323" TYPE="TITLE"Chapter 4, "Optimizing Program Performance."LBL="" HELPID=""ID="90405"Selecting a CompilerYou can select a compiler by explicitly specifying a command-line option, an environment variable, and by specifying the defaults in a specification file. ID="02.compiler1"ID="02.compiler2"LBL="" HELPID=""Using a Defaults Specification FileYou can set the Application Binary Interface (ABI), instruction set architecture (ISA), and processor type without explicitly specifying them. Just set the environment variable COMPILER_DEFAULTS_PATH to a colon separated list of paths designating where the compiler is to look for a ID="02.compiler3"ID="02.compiler4"ID="02.compiler5"compiler.defaults file. If no compiler.defaults file is found or if the environment variable is not set, the compiler looks for ID="02.compiler6"/etc/compiler.defaults. If this file is not found, the compiler resorts to the built-in defaults. The compiler.defaults file contains a ­DEFAULT:option group specifier that specifies the default ABI, ISA, and processor. The compiler issues a warning if you specify anything other than ­DEFAULT:option in the compiler.defaults file.The format of the ­DEFAULT: option group specifier is as follows:­DEFAULT:[abi={32|n32|64}]:[isa=mipsn]:[proc={r4k|r5k|r8k|r10k}]This format is explained below in IDREF="21183" TYPE="TABLE"Table 2-1. COLUMNS="2"LBL="2-1"Table 2-1 ID="21183" (continued)        The compiler.defaults File SpecificationsLEFT="0" WIDTH="49"SpecifierLEFT="55" WIDTH="288"DescriptionLEFT="0" WIDTH="49"abi=32LEFT="55" WIDTH="288"Compiles 32-bit objects.ID="02.compiler7"LEFT="0" WIDTH="49"abi=n32LEFT="55" WIDTH="288"Compiles "new" 32-bit objects (high performance).LEFT="0" WIDTH="49"abi=64LEFT="55" WIDTH="288"Compiles 64-bit objects.LEFT="0" WIDTH="49"isa=mips1LEFT="55" WIDTH="288"Generates code using the MIPS I instruction set (for R3000 and above).ID="02.compiler8"LEFT="0" WIDTH="49"isa=mips2LEFT="55" WIDTH="288"Generates code using the MIPS II instruction set (MIPS I plus R4000 
extensions, for R4000 and above).LEFT="0" WIDTH="49"isa=mips3LEFT="55" WIDTH="288"Generates code using the full MIPS III instruction set (for R4000 and 
above).LEFT="0" WIDTH="49"isa=mips4LEFT="55" WIDTH="288"Generates code using the MIPS IV instruction set (for R5000, R8000, and 
R10000).LEFT="0" WIDTH="49"proc=r4kLEFT="55" WIDTH="288"Schedules code for the R4000 processor and adds the appropriate paths 
to the head of the library search path. ID="02.compiler9"LEFT="0" WIDTH="49"proc=r5kLEFT="55" WIDTH="288"Schedules code for the R5000 processor and adds the appropriate paths 
to the head of the library search path. LEFT="0" WIDTH="49"proc=r8kLEFT="55" WIDTH="288"Schedules code for the R8000 processor and adds the appropriate paths 
to the head of the library search path. LEFT="0" WIDTH="49"proc=r10kLEFT="55" WIDTH="288"Schedules code for the R10000 processor and adds the appropriate 
paths to the head of the library search path. Use the ID="02.compiler10"­show_defaults option to print the compiler.defaults being used (if any) and the values. This option is for diagnostic purposes and does not compile your code. Explicit command-line options override all compiler default settings, and the SGI_ABI environment variable overrides the ABI setting in the compiler.defaults file. The command:%cc ­64 foo.coverrides a compiler.defaults file that sets ­DEFAULT:abi=n32:isa=mips4:proc=r10k. and compiles ­64­mips4­r10000.The following command overrides the compiler.defaults file and sets the ABI to ­32 and the ISA to ­mips2 (­32 supports only ­mips2 (the default) and ­mips1 compilations). %cc ­32 foo.cThe processor type is ignored by ­32 compilations. Refer to the release notes and reference pages for your compiler for information about default settings. LBL="" HELPID=""Using Command-Line Options ID="02.compiler11"You can specify command-line options to override a compiler.defaults file. IDREF="91547" TYPE="TABLE"Table 2-2 lists the compilation mode options. COLUMNS="2"LBL="2-2"Table 2-2 ID="91547"Compilation Mode Command-Line OptionsLEFT="0" WIDTH="49"OptionLEFT="55" WIDTH="324"DescriptionLEFT="0" WIDTH="49"­n32LEFT="55" WIDTH="324"Compiles the source code to new 32-bit mode (high performance). The default is 
­mips3, if you do not specify ­mips4. LEFT="0" WIDTH="49"­64LEFT="55" WIDTH="324"Compiles the source code to 64-bit mode (the default is ­mips4 if you do not 
specify ­mips3. LEFT="0" WIDTH="49"­32LEFT="55" WIDTH="324"Compiles the source code to 32-bit mode (the default is ­mips2, if you do not 
specify ­mips1).LBL="" HELPID=""Setting an Environment VariableYou can set an environment variable (shown in ID="02.compiler12"IDREF="14506" TYPE="TABLE"Table 2-3) to specify the compilation mode to use. COLUMNS="2"LBL="2-3"Table 2-3 ID="14506"Compilation Mode Environment Variable SpecificationsLEFT="0" WIDTH="108"Environment VariableLEFT="115" WIDTH="252"DescriptionLEFT="0" WIDTH="108"setenv SGI_ABI ­n32 LEFT="115" WIDTH="252"Sets the environment for "new" 32-bit compilation. LEFT="0" WIDTH="108"setenv SGI_ABI ­64 LEFT="115" WIDTH="252"Sets the environment for 64-bit compilation. LEFT="0" WIDTH="108"setenv SGI_ABI ­32 LEFT="115" WIDTH="252"Sets the environment for 32-bit compilation. LBL="" HELPID=""ID="37532"Object File Format and Dynamic LinkingThis section describes how the compiler systemuses ID="02.compiler13"IDREF="60325" TYPE="TITLE""Executable and Linking Format" (ELF) for object filesuses shared libraries called ID="02.compiler14"IDREF="79120" TYPE="TITLE""Dynamic Shared Objects" (DSOs)creates ID="02.compiler15"IDREF="95878" TYPE="TITLE""Position-Independent Code" (PIC), by default, to support dynamic linking ID="02.compiler16"LBL="" HELPID=""ID="60325"Executable and Linking FormatThe compiler system produces ELF object files. ELF is the format specified by the System V Release 4 Applications Binary Interface (the SVR4 ABI). ELF provides support for Dynamic Shared Objects, described below.ID="02.compiler17"Types of ELF object files are as follows:ID="02.compiler18"Relocatable files contain code and data in a format suitable for linking with other object files to make a shared object or executable.ID="02.compiler19"Dynamic Shared Objects contain code and data suitable for dynamic linking. Relocatable files may be linked with DSOs to create a dynamic executable. At run time, the run-time linker combines the executable and DSOs to produce a process image.Executable files are programs ready for execution. They may or may not be dynamically linked.ID="02.compiler20"NoteThe current compiler system has no facility for creating or linking COFF executables; therefore, you must recompile COFF executables. You can use this version of the compiler system to construct ABI-compliant executables that run on any operating system supporting the MIPS ABI. Be careful to avoid referencing symbols that are not defined as part of the MIPS ABI specification. For more information, see System V Applications Binary Interfacename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Revised First Edition. Prentice Hall, ISBN 0-13-880410-9 System V Application Binary Interface MIPS Processor Supplement. Prentice Hall, ISBN 0-13-880170-3.LBL="" HELPID=""ID="79120"Dynamic Shared ObjectsIRIX uses shared objects called ID="02.compiler21"Dynamic Shared Objects, or DSOs. The object code of a DSO is position-independent code (PIC), which can be mapped into the virtual address space of several different processes at once. DSOs are loaded at run time instead of at linking time, by the run-time loader, rld. As is true for static shared libraries, the code for DSOs is not included in executable files; thus, executables built with DSOs are smaller than those built with non-shared libraries, and multiple programs may use the same DSO at the same time. For more information on DSOs, see IDREF="92826" TYPE="TITLE"Chapter 3, "Using Dynamic Shared Objects."NoteStatic shared libraries are not supported under this release. The current compiler system has no facilities for generating static shared libraries.ID="02.compiler22"LBL="" HELPID=""ID="95878"Position-Independent CodeDynamic linking requires that all object code used in the executable be position-independent code. For source files in high-level languages, you just need to recompile to produce PIC. Assembly language files must be modified to produce PIC; see the ID="02.compiler23"MIPSpro Assembly Language Programmer's Guide for details.Position-independent code satisfies references indirectly by using a ID="02.compiler24"global offset table (GOT), which allows code to be relocated simply by updating the GOT. Each executable and each DSO has its own GOT. For more information on DSOs, see IDREF="92826" TYPE="TITLE"Chapter 3, "Using Dynamic Shared Objects."The compiler system produces PIC by default when compiling higher-level language files. All of the standard libraries are provided as DSOs, and therefore contain PIC code; if you compile a program into non-PIC, you will be unable to use those DSOs. One of the few reasons to compile non-PIC is to build a device driver, which doesn't rely on standard libraries. In this case, you should use the ID="02.compiler25"­non_shared option to the compiler to negate the default option, ­KPIC. For convenience, the C library and math library are provided in non-shared format as well as in DSO format (although the non-shared versions are not installed by default). You can link these libraries ­non_shared with other non-PIC files.LBL="" HELPID=""ID="67353"Source File ConsiderationsThis section describes conventions for naming source files and including header files. Topics covered include:IDREF="76478" TYPE="TITLE""Source File Naming Conventions"IDREF="17534" TYPE="TITLE""Header Files"IDREF="24853" TYPE="TITLE""Using Precompiled Headers in C and C++"LBL="" HELPID=""ID="76478"Source File Naming ConventionsEach compiler driver recognizes the type of an input file by the suffix assigned to the filename. ID="02.compiler26"IDREF="24314" TYPE="TABLE"Table 2-4 describes the possible filename suffixes.ID="02.compiler27"COLUMNS="2"LBL="2-4"Table 2-4  (continued)        Driver Input File SuffixesID="24314"LEFT="0" WIDTH="66" SuffixLEFT="75" WIDTH="266"DescriptionLEFT="0" WIDTH="66".sLEFT="75" WIDTH="266"Assembly sourceLEFT="0" WIDTH="66".iLEFT="75" WIDTH="266"Preprocessed source code in the language of the processing driverLEFT="0" WIDTH="66".cLEFT="75" WIDTH="266"C sourceLEFT="0" WIDTH="66".C, .c++, .CC, 
.cc, .CPP, .cpp, 
.CXX, .cxxLEFT="75" WIDTH="266"C++ sourceLEFT="0" WIDTH="66".f, .F, .for, .FOR
.f, .f90, .F90LEFT="75" WIDTH="266"Fortran 77 sourceFortran 90 sourceLEFT="0" WIDTH="66".pLEFT="75" WIDTH="266"Pascal sourceLEFT="0" WIDTH="66".oLEFT="75" WIDTH="266"Object fileLEFT="0" WIDTH="66".aLEFT="75" WIDTH="266"Object library archiveLEFT="0" WIDTH="66".soLEFT="75" WIDTH="266"Dynamic shared object libraryThe following example compiles preprocessed source code:f77 -c tickle.iThe Fortran 77 compiler, f77, assumes the file tickle.i contains Fortran statements (because the Fortran driver is specified). f77 also assumes the file has already been preprocessed (because the suffix is .i), and therefore does not invoke the preprocessor.LBL="" HELPID=""ID="17534"Header FilesID="02.compiler28"Header files, also called include files, contain information about the libraries with which they're associated. They define such things as data types, data structures, symbolic constants, and prototypes for functions exported by the library. To use those definitions without having to type them into each of your source files, you can use the #include directive to tell the macro preprocessor to include the complete text of the given header file in the current source file. When you include header files in your source files you can specify such definitions conveniently and consistently in each source file that uses any of the library routines.By convention, header filenames have a .h suffix. Each programming language handles these files the same way, via the macro preprocessor. For example, the ID="02.compiler29"stdio.h header file describes, among other things, the data types of the parameters required by printf(). For detailed information about standard header files and libraries, see the International Standard ISO/IEC. Programming languagesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'C, 9899. 1990. Also see IDREF="41961" TYPE="TITLE""Using Typedefs" for information about the inttypes.h header file.LBL="" HELPID=""Specifying a Header FileThe ID="02.compiler30"#include directive tells the preprocessor to replace the #include line with the text of the indicated header file. The usual way to specify a header file is with the line#include <filename>where filename is the name of the header file to be included. The angle brackets (< >) surrounding the filename tell the macro preprocessor to search for the specified file only in directories specified by command-line options and in the default header-file directory (/usr/include and /usr/include/CC for C++).Another specification format exists, in which the filename is given between double quotation marks. In this case, the macro preprocessor searches for the specified header file in the current directory first (that is, the directory containing the including file). Then, if the preprocessor doesn't find the requested file, it searches in the other directories as in the angle-bracket specification.LBL="" HELPID=""Creating a Header File for Multiple LanguagesID="02.compiler31"ID="02.compiler32"A single header file can contain definitions for multiple languages; this setup allows you to use the same header file for all programs that use a given library, no matter what language those programs are in. To set up a shareable header file, create a .h file and enter the definitions for the various languages as follows:#ifdef _LANGUAGE_C

C definitions

#endif

#ifdef _LANGUAGE_C_PLUS_PLUS

C++ definitions

#endif

#ifdef _LANGUAGE_FORTRAN

Fortran definitions

#endif
NoteYou must specify _LANGUAGE_ before the language name. To indicate C++ definitions, you must use _LANGUAGE_C_PLUS_PLUS, not _LANGUAGE_C++. ID="02.compiler33"You can specify the various language definitions in any order. LBL="" HELPID=""ID="24853"Using Precompiled Headers in C and C++This section describes the precompiled header mechanism that is available with the n32-bit and 64-bit C and C++ compilers. This mechanism is also available for C++ (but not C) in 32-bit mode. ID="02.compiler34"ID="02.compiler35"This section contains the following topics:IDREF="26822" TYPE="TITLE""About Precompiled Headers"IDREF="62548" TYPE="TITLE""Automatic Precompiled Header Processing"IDREF="41425" TYPE="TITLE""Other Ways to Control Precompiled Headers"IDREF="80631" TYPE="TITLE""PCH Performance Issues"LBL="" HELPID=""ID="26822"About Precompiled HeadersThe precompiled header (PCH) file mechanism is available through the compiler front end:  fec and fecc. Use PCH to avoid recompiling a set of header files. This is particularly useful when your header files introduce many lines of code, and the primary source files that included them are relatively small.In effect, fec/fecc takes a snapshot of the state of the compilation at a particular point and writes it to a file before completing the compilation. When you recompile the same source file or another file with the same set of header files, the PCH mechanism recognizes the snapshot point, verifies that the corresponding PCH file is usable, and reads it back in. The PCH mechanism can give you a dramatic improvement in compile-time performance. The trade-off is that PCH files may take a lot of disk space.LBL="" HELPID=""ID="62548"Automatic Precompiled Header ProcessingThis section covers the following topics:ID="02.compiler36"PCH File RequirementsReusing PCH filesObsolete File Deletion MechanismYou can enable the precompiled header processing by using the ­pch option (­Wf, ­ ­pch in 32-bit mode) on the command line. With the PCH mechanism enabled, fec/fecc searches for a qualifying PCH file to read in and/or creates one for use on a subsequent compilation.The PCH file contains a snapshot of all the code preceding the header stop point. The header stop point is typically the first token in the primary source file that does not belong to a preprocessing directive. The header stop point can also be specified directly by inserting a #pragma hdrstop. For example, consider the following C++ code:#include "xxx.h"
#include "yyy.h"
int i;In this case, the header stop point is int i (the first non-preprocessor token) and the PCH file will contain a snapshot reflecting the inclusion of xxx.h and yyy.h. If the first non-preprocessor token or the #pragma hdrstop appears within a #if block, the header stop point is the outermost enclosing #if. For example, consider the following C++ code:#include "xxx.h"
#ifndef YYY_H
#define YYY_H 1
#include "yyy.h"
#endif
#if TEST
int i;
#endifIn this case, the first token that does not belong to a preprocessing directive is again int i, but the header stop point is the start of the #if block containing the int. The PCH file reflects the inclusion of xxx.h and conditionally the definition of YYY_H and inclusion of yyy.h. The file does not contain the state produced by #if TEST.PCH File RequirementsA PCH file is produced only if the header stop point and the code preceding it (generally the header files themselves) meet the following requirements:ID="02.compiler37"The header stop point must appear at file scope; it may not be within an unclosed scope established by a header file. For example, a PCH file is not created in the following case:// xxx.h 
class A {

// xxx.C 
#include "xxx.h" 
int i; };The header stop point can not be inside a declaration started within a header file, and it can not be part of a declaration list of a linkage specification. For example, a PCH file is not created in the following case:// yyy.h 
static

// yyy.C 
#include "yyy.h" 
int i;In this case, the header stop point is int i, but since it is not the start of a new declaration, a PCH file is not createdThe header stop point can not be inside a #if block or a #define started within a header file.The processing preceding the header stop must not have produced any errors. (Note that warnings and other diagnostics are not reproduced when the PCH file is reused.)References to predefined macros __DATE__ or __TIME__ must not have appeared.Use of the #line preprocessing directive must not have appeared.#pragma no_pch must not have appeared.Reusing PCH FilesWhen a precompiled header file is produced, in addition to the snapshot of the compiler state, it contains some information that can be checked to determine under what circumstances it can be reused. This information includes the following:ID="02.compiler38"The compiler version, including the date and time the compiler was built.The current directory (in other words, the directory in which the compilation is occurring).The command line options.The initial sequence of preprocessing directives from the primary source file, including #include directives.The date and time of the header files specified in #include directives.This information comprises the PCH prefix. The prefix information of a given source file can be compared to the prefix information of a PCH file to determine whether or not the latter is applicable to the current compilation.For example, consider the following C++ code:// a.C 
#include "xxx.h" 

...              // Start of code

// b.C 
#include "xxx.h" 

...              // Start of codeWhen you compiled a.C with the ­pch option, the PCH file a.pch is created. When you compile b.C (or recompile a.C), the prefix section of a.pch is read in for comparison with the current source file. If the command line options are identical and xxx.h has not been modified, fec/fecc reads in the rest of a.pch rather than opening xxx.h and processing it line by line. This establishes the state for the rest of the compilation.It may be that more than one PCH file is applicable to a given compilation. If so, the largest (in other words, the one representing the most preprocessing directives from the primary source file) is used. For instance, consider a primary source file that begins with the following code:#include "xxx.h" 
#include "yyy.h" 
#include "zzz.h"If one PCH file exists for xxx.h and a second for xxx.h and yyy.h, the latter will be selected (assuming both are applicable to the current compilation). After the PCH file for the first two headers is read in and the third is compiled, a new PCH file for all three headers may be created.When a precompiled header file is created, it takes the name of the primary source file, with the suffix replaced by "pch." Unless ­pch_dir is specified, the PCH file is created in the directory of the primary source file.When a precompiled header file is created or used, a message similar to the following is issued:"test.C": creating precompiled header file "test.pch"Obsolete File Deletion MechanismIn automatic mode (when ID="02.compiler39"­pch is used), fec/fecc considers a PCH file obsolete and deletes it under the following circumstances:The file is based on at least one out-of-date header file but is otherwise applicable for the current compilation.The file has the same base name as the source file being compiled (for example, xxx.pch and xxx.C) but is not applicable for the current compilation (for example, because of different command-line options).You must manually clean up any other PCH file.Support for PCH processing is not available when multiple source files are specified in a single compilation. If the command line includes a request for precompiled header processing and specifies more than one primary source file, an error is issued and the compilation is aborted.LBL="" HELPID=""ID="41425"Other Ways to Control Precompiled HeadersYou can use the following ways to control and/or tune how precompiled headers are created and used:ID="02.compiler40"You can insert a #pragma hdrstop in the primary source file at a point prior to the first token that does not belong to a preprocessing directive. Thus you can specify where the set of header files subject to precompilation ends. For example,#include "xxx.h" 
#include "yyy.h" 
#pragma hdrstop 
#include "zzz.h"In this case, the precompiled header file includes the processing state for xxx.h and yyy.h but not zzz.h. (This is useful if you decide that the information added by what follows the #pragma hdrstop does not justify the creation of another PCH file.)You can use a #pragma no_pch to suppress the precompiled header processing for a given source file.You can use the command-line option ­pch_dirdirectoryname to specify the directory in which to search for and/or create a PCH file.LBL="" HELPID=""ID="80631"PCH Performance IssuesThe relative overhead incurred in writing out and reading back in a precompiled header file is quite small for reasonably large header files. ID="02.compiler41"In general, writing out a precompiled header file doesn't cost much, even if it does not end up being used, and if it is used it almost always produces a significant speedup in compilation. The problem is that the precompiled header files can be quite large (from a minimum of about 250K bytes to several megabytes or more), and so you probably don't want many of them sitting around.You can see that, despite the faster recompilations, precompiled header processing is not likely to be justified for an arbitrary set of files with nonuniform initial sequences of preprocessing directives. The greatest benefit occurs when a number of source files can share the same PCH file. The more sharing, the less disk space is consumed. With sharing, the disadvantage of large precompiled header files can be minimized without giving up the advantage of a significant speedup in compilation times.To take full advantage of header file precompilation, you should reorder the #include sections of your source files and/or group the #include directives within a commonly used header file.The fecc source provides an example of how this can be done. A common idiom is the following:#include "fe_common.h" 
#pragma hdrstop 
#include ...In this example, fe_common.h pulls in (directly and indirectly) a few dozen header files. The #pragma hdrstop is inserted to get better sharing with fewer PCH files. The PCH file produced for fe_common.h is slightly over a megabyte in size. Another example, used by the source files involved in declaration processing, is the following:#include "fe_common.h" 
#include "decl_hdrs.h"
#pragma hdrstop 
#include ...decl_hdrs.h pulls in another dozen header files, and a second, somewhat larger, PCH file is created. In all, the fifty-odd source files of fecc share just six precompiled header files. If disk space is at a premium, you can decide to make fe_common.h pull in all the header files used. In that case, a single PCH file can be used in building fecc. Different environments and different projects have different needs. You should, however, be aware that making the best use of the precompiled header support will require some experimentation and probably some minor changes to your source code. LBL="" HELPID=""ID="39676"Compiler DriversThe driver commands, such as cc and f77 call subsystems that compile, optimize, assemble, and link your programs. This section describes:IDREF="12643" TYPE="TITLE""Default Behavior for Compiler Drivers"IDREF="10465" TYPE="TITLE""General Options for Compiler Drivers"LBL="" HELPID=""ID="12643"Default Behavior for Compiler DriversAt compilation time, you can select one or more options that affect a variety of program development functions, including debugging, profiling, and optimizing. You can also specify the names assigned to output files. Note that some options have default values that apply if you do not specify them.ID="02.compiler42"When you invoke a compiler driver with source files as arguments, the driver calls other commands that compile your source code into object code. It then optimizes the object code (if requested to do so) and links together the object files, the default libraries, and any other libraries you specify.Given a source file foo.c, the default name for the object file is foo.o. The default name for an executable file is a.out. The following example compiles source files foo.c and bar.c with the default options:cc foo.c bar.cThis example produces two object files (foo.o and bar.o), then links them with the default C library libc to produce an executable called a.out.NoteIf you compile a single source directly to an executable, the compiler does not create an object file.LBL="" HELPID=""ID="10465"General Options for Compiler DriversThe command-line options for MIPSpro compiler drivers are listed and explained in ID="02.compiler43"IDREF="90644" TYPE="TABLE"Table 2-5. The table lists only the most frequently used options, not all available options. See the appropriate compiler reference (manual) page for additional details. In addition to the general options in IDREF="90644" TYPE="TABLE"Table 2-5, each driver has options that you typically won't use. These options primarily aid compiler development work. For information about nonstandard driver options, consult the appropriate driver reference page. Click the word cc to view the cc(1) and CC(1) reference pages. You can use the compiler system to generate profiled programs that, when executed, provide operational statistics. To perform this procedure, use the ­p compiler option (for pc sampling information) and the prof command (for profiles of basic block counts). Refer to IDREF="15323" TYPE="TITLE"Chapter 4, "Optimizing Program Performance," for details.COLUMNS="2"LBL="2-5"Table 2-5  (continued)        General Driver OptionsID="90644" LEFT="0" WIDTH="129"Option LEFT="135" WIDTH="254"PurposeLEFT="0" WIDTH="129"­32 LEFT="135" WIDTH="254"Generates a 32-bit object. This is the default for any non-R8000 
RISC architecture.ID="02.compiler44"LEFT="0" WIDTH="129"­n32LEFT="135" WIDTH="254"Generates an n32-bit object.ID="02.compiler45"LEFT="0" WIDTH="129"­64 LEFT="135" WIDTH="254"Generates a 64-bit object. This is the default for the R8000.ID="02.compiler46"LEFT="0" WIDTH="129"­ansiLEFT="135" WIDTH="254"Compiles strict ANSI/ISO C. Preprocessing adds only 
standard predefined symbols to the name space, and standard 
include files declare only standard symbols.ID="02.compiler47"LEFT="0" WIDTH="129"­avoid_gp_overflowLEFT="135" WIDTH="254"Asserts flags that are intended to avoid GOT overflow. See 
­multigot option, below.LEFT="0" WIDTH="129"­cLEFT="135" WIDTH="254"Prevents the linker from linking your program after code 
generation. This option forces the driver to produce a ID="02.compiler48".o file 
after the back-end phase, and prevents the driver from 
producing an executable file.LEFT="0" WIDTH="129"­CLEFT="135" WIDTH="254"Used with the ID="02.compiler49"­P or ­E option. Prevents the macro 
preprocessor from stripping comments. Use this option when 
you suspect the preprocessor is not producing the intended 
code and you want to examine the code with its comments. For 
C and C++ compiles only.LEFT="0" WIDTH="129"­cordLEFT="135" WIDTH="254"Runs the procedure rearranger, ID="02.compiler50"cord(1) on the resulting file after 
linking. Rearranging improves the paging and caching 
performance of the program's text. The output of cord is placed 
in a.out, by default, or a file specified by the ­o option. If you 
don't specify ­feedback, then outfile.fb is used as the default.LEFT="0" WIDTH="129"­cckr LEFT="135" WIDTH="254"K&R/Version7 C compatibility compilation mode. 
Preprocessing may add more predefined symbols to the name 
space than in ID="02.compiler51"­ansi mode. Compilation adheres to the K&R 
language semantics.LEFT="0" WIDTH="129"­Dname[=def]LEFT="135" WIDTH="254"Defines a macro ID="02.compiler52"name as if you had specified a #define in your 
program. If you do not specify a definition with =def, name is set 
to 1.LEFT="0" WIDTH="129"­E LEFT="135" WIDTH="254"Runs only the macro preprocessor and sends results to the 
standard output. To retain comments, use the ID="02.compiler53"­C option as 
well. Use ­E when you suspect the preprocessor is not 
producing the intended code.LEFT="0" WIDTH="129"­elspecfilenameLEFT="135" WIDTH="254"Specifies an ELF layout specification file (specifies the layout of 
object files, programs, and shared objects). See ID="02.compiler54"elspec(5) for 
details.LEFT="0" WIDTH="129"­feedbackLEFT="135" WIDTH="254"Use with the ID="02.compiler55"­cord option to specify feedback file(s). You can 
produce this file by using prof with its ­feedback option from 
an execution of the instrumented program produced by 
pixie(1). Specify multiple feedback files with multiple 
­feedback options.LEFT="0" WIDTH="129"­fullwarnLEFT="135" WIDTH="254"Checks code and produces additional warnings that are 
normally suppressed. This option is recommended for all 
compiles during software development. You can turn off 
warnings selectively by using the ID="02.compiler56"­woff option.LEFT="0" WIDTH="129"­g[num]LEFT="135" WIDTH="254"Produces debugging information. The default is ID="02.compiler57"­g0: do not 
produce debugging information.LEFT="0" WIDTH="129"­G[num]LEFT="135" WIDTH="254"Specifies the maximum size, in bytes, of a data item that is 
accessed from the global pointer. The default is ID="02.compiler58"­G8.LEFT="0" WIDTH="129"­helpLEFT="135" WIDTH="254"Lists the available compiler options (available only with ID="02.compiler59"­n32 
and ­64).LEFT="0" WIDTH="129"­IdirnameLEFT="135" WIDTH="254"Adds ID="02.compiler60"dirname to the list of directories to be searched for 
specified header files. These directories are always searched 
before the default directory, /usr/include and /usr/include/CC for 
C++.LEFT="0" WIDTH="129"­KPICLEFT="135" WIDTH="254"Generates position-independent code. This is the default and is 
required for programs linking with dynamic shared objects. 
Specify ID="02.compiler61"­non_shared if you don't want to generate PIC code.LEFT="0" WIDTH="129"­mips1LEFT="135" WIDTH="254"Generates code using the instruction set of the MIPS 
R2000/R3000 RISC architecture. This option implies ID="02.compiler62"­32.LEFT="0" WIDTH="129"­mips2LEFT="135" WIDTH="254"Generates code using the MIPS II instruction set (MIPS I + 
R4000 specific extensions). Note that code compiled with 
ID="02.compiler63"­mips2 does not run on R2000/R3000-based machines. This 
option implies ­32.LEFT="0" WIDTH="129"­mips3LEFT="135" WIDTH="254"Generates code using the full MIPS R4000 instruction set, 
including 64-bit code. ID="02.compiler64"LEFT="0" WIDTH="129"­mips4LEFT="135" WIDTH="254"Generates code using the MIPS R8000 instruction set.ID="02.compiler65"LEFT="0" WIDTH="129"­multigotLEFT="135" WIDTH="254"Creates multiple Global Offset Tables (GOT). All entries in the 
GOT need to be accessible from a 16-bit offset from a common 
Global Pointer (GP). If the GOT grows too big you may get a 
"gp out of range" error at link time. This option allows the 
linker to create multiple GOTs and GPs, thus avoiding the error. 
This option should appear before any objects on the command 
line. Having multiple GOTs neither increases code size nor 
affects performance.ID="02.compiler66"LEFT="0" WIDTH="129"­nocppLEFT="135" WIDTH="254"Suppresses running of the macro preprocessor on the source 
files prior to processing.ID="02.compiler67"LEFT="0" WIDTH="129"­non_sharedLEFT="135" WIDTH="254"Turns off the default option, ID="02.compiler68"­KPIC, to produce non-shared 
code. This code can be linked to only a few standard libraries 
(such as libc.a and libm.a) that are provided in non-shared 
format in the directory /usr/lib/nonshared. You should use this 
option only when building device drivers.LEFT="0" WIDTH="129"­nostdincLEFT="135" WIDTH="254"Suppresses searching of ID="02.compiler69"/usr/include for the specified header 
files.LEFT="0" WIDTH="129"­ofilenameLEFT="135" WIDTH="254"Names the result of the compilation ID="02.compiler70"filename. If an executable is 
being generated, it is named filename rather than the default 
name, a.out.LEFT="0" WIDTH="129"­OnumLEFT="135" WIDTH="254"Specifies optimization options. ID="02.compiler71"­O0 turns off optimizations. ­O1 turns on local optimizations that can be done quickly. ­O2 (­O) turns on global optimizations. This is the default. ­O3 turns on all optimizations. For more information, see IDREF="15323" TYPE="TITLE"Chapter 4, "Optimizing Program 
Performance."LEFT="0" WIDTH="129"­OPT:optionsLEFT="135" WIDTH="254"Controls optimization options. For more information, see 
ID="02.compiler72"IDREF="15323" TYPE="TITLE"Chapter 4, "Optimizing Program Performance."LEFT="0" WIDTH="129"­pLEFT="135" WIDTH="254"Sets up for profiling by periodically sampling the value of the 
program counter (only effects the loading).ID="02.compiler73"LEFT="0" WIDTH="129"­PLEFT="135" WIDTH="254"Runs only the macro preprocessor on the files and puts the 
result of each file in a ID="02.compiler74".i file. Specify both ­P and ­C to retain 
comments.LEFT="0" WIDTH="129"­pchLEFT="135" WIDTH="254"Enables the precompiled header processing; ID="02.compiler75"fec/fecc searches for 
a qualifying PCH file to read in and/or creates one for use on a 
subsequent compilation. (For ­32, use ­Wf, ­ ­pch.)LEFT="0" WIDTH="129"­SLEFT="135" WIDTH="254"Similar to ID="02.compiler76"­c, except that it produces assembly code in a .s file 
instead of object code in a .o file. ­S provides information about 
the code and comments about such things as software 
pipelining, the loops it works on, and the results.LEFT="0" WIDTH="129"­showLEFT="135" WIDTH="254"Lists compiler phases as they are executed. Use this option to 
see the default options for each compiler phase along with the 
options you've specified.ID="02.compiler77"LEFT="0" WIDTH="129"­TARG:optionsLEFT="135" WIDTH="254"Controls the target architecture and machine for which code is 
generated. For more information, see ID="02.compiler78"IDREF="15323" TYPE="TITLE"Chapter 4, "Optimizing 
Program Performance."LEFT="0" WIDTH="129"­TENV:optionsLEFT="135" WIDTH="254"Controls the target environment assumed by the compiler. For 
more information, see ID="02.compiler79"IDREF="15323" TYPE="TITLE"Chapter 4, "Optimizing Program 
Performance."LEFT="0" WIDTH="129"­UnameLEFT="135" WIDTH="254"Overrides a definition of the macro ID="02.compiler80"name that you specified 
with the ­D option, or that is defined automatically by the 
driver. Note that this option does not override a macro 
definition in a source file, only on the command line.LEFT="0" WIDTH="129"­woff nLEFT="135" WIDTH="254"Suppresses ANSI/ISO warning message number ID="02.compiler81"n. Suppress 
multiple warning numbers by using a comma-separated list 
(­woff n1,n2...), a range of warning numbers by using a 
hyphen-separated list (­woff n1-n5), or any combination 
thereof. You can suppress all warning messages via ­woff all.LEFT="0" WIDTH="129"­xansiLEFT="135" WIDTH="254"Compilation follows an extended ANSI/ISO C language 
semantics, which is more lenient in terms of the forms of 
expressions it allows. Preprocessing combines predefined 
macros. This is the default C compilation mode.ID="02.compiler82"NoteTo use 4.3 BSD extensions in C, compile using the ID="02.compiler83"­xansi or the ­D__EXTENSIONS__ option on the command line. For example:cc prog.c -ansi -prototypes -fullwarn -lm -D__EXTENSIONS__LBL="" HELPID=""ID="72868"LinkingThe linker, ld, combines one or more object files and libraries (in the order specified) into one executable file, performing relocation, external symbol resolutions, and all other required processing. Unless directed otherwise, the linker names the executable file ID="02.compiler84"a.out. See the ld(1) reference page for complete information on the linker. This section summarizes the functions of the linker. It also covers how to link a program manually (without using a compiler driver) and how to compile multilanguage programs. Specifically, this section describes:IDREF="89533" TYPE="TITLE""Invoking the Linker Manually"IDREF="20833" TYPE="TITLE""Linking Assembly Language Programs"IDREF="98015" TYPE="TITLE""Linking Libraries"IDREF="65412" TYPE="TITLE""Linking to Previously Built Dynamic Shared Objects"IDREF="71272" TYPE="TITLE""Linking Multilanguage Programs"LBL="" HELPID=""ID="89533"Invoking the Linker ManuallyUsually the compiler invokes the linker as the final step in compilation (as explained in IDREF="39676" TYPE="TITLE""Compiler Drivers"). If object files exist that were produced by previous compilations, and you want to link them, invoke the linker by using a compiler driver instead of calling ld directly. Just pass the object filenames to the compiler driver in place of source filenames. If the original source files are in a single language, simply invoke the associated driver and specify the list of object files. (For information about linking objects derived from several languages, see IDREF="71272" TYPE="TITLE""Linking Multilanguage Programs.")A few command-line options to ID="02.compiler85"ld, such as ­p, have different meanings when used as command-line options to cc. To pass such options to ld through an invocation of a compiler driver, use the ­Wl option to the driver (see the reference page for details).Typically, the compiler driver invokes ld as necessary. Circumstances exist under which you may need to invoke ld directly, such as when you're building a shared object or doing special linking not supported by compiler drivers (such as building an embedded system). To build C++ shared objects, use the CC driver. LBL="" HELPID=""Linker SyntaxID="02.compiler86"A summary of ld syntax follows.ld options object1 [object2...objectn]optionsOne or more of the options listed in IDREF="81521" TYPE="TABLE"Table 2-6.object Specifies the name of the object file to be linked.ID="02.compiler87"IDREF="81521" TYPE="TABLE"Table 2-6 contains only a partial list of linker options. Many options that apply only to creating shared objects are discussed in IDREF="92826" TYPE="TITLE"Chapter 3, "Using Dynamic Shared Objects." For complete information on options and libraries that affect linker processing, refer to the ld(1) reference page.COLUMNS="2"LBL="2-6"Table 2-6  (continued)        Linker OptionsID="81521" LEFT="0" WIDTH="73"Option LEFT="80" WIDTH="258"PurposeLEFT="0" WIDTH="73"­32LEFT="80" WIDTH="258"Links 32-bit programs and DSOs.LEFT="0" WIDTH="73"­n32LEFT="80" WIDTH="258"Links n32-bit programs and DSOs.LEFT="0" WIDTH="73"­64LEFT="80" WIDTH="258"Links 64-bit programs and DSOs.LEFT="0" WIDTH="73"­ivpadLEFT="80" WIDTH="258"Improves cache behavior by causing the linker to perform 
intervariable padding of some large variables.LEFT="0" WIDTH="73"­lnameLEFT="80" WIDTH="258"Specifies the name of a library, where lname is the library name. 
The linker searches for lname.so (and then lname.a) first in any 
directories specified by ­Ldirname options, and then in the 
standard directories: /usr/lib, /lib, and /usr/local/lib.LEFT="0" WIDTH="73"­LdirnameLEFT="80" WIDTH="258"Adds dirname to the list of directories to be searched for (as well 
as libraries searched for) as specified by subsequent ­lname 
options.LEFT="0" WIDTH="73"­mLEFT="80" WIDTH="258"Produces a linker memory map, listing input and output 
sections of the code, in System V format.LEFT="0" WIDTH="73"­MLEFT="80" WIDTH="258"Produces a link map in BSD format, listing the names of files to 
be loaded.LEFT="0" WIDTH="73"­multigotLEFT="80" WIDTH="258"Creates multiple Global Offset Tables (GOT). All entries in the 
GOT need to be accessible from a 16-bit offset from a common 
Global Pointer (GP). If the GOT grows too big you may get a "gp 
out of range" error at link time. This option allows the linker to 
create multiple GOTs and GPs, thus avoiding the error. This is 
position dependent and should appear before any objects on the 
command line. Having multiple GOTs will neither increase code 
size nor affect performance.ID="02.compiler88"LEFT="0" WIDTH="73"­nostdlibLEFT="80" WIDTH="258"This option must be accompanied by the ­Ldirname option. If 
the linker does not find the library in dirname list, then it does not 
search any of the standard library directories.LEFT="0" WIDTH="73"­ofilenameLEFT="80" WIDTH="258"Specifies a name for your executable. If you do not specify 
filename, the linker names the executable a.out.LEFT="0" WIDTH="73"­sLEFT="80" WIDTH="258"Strips debugging information from the program object, 
reducing its size. This option is useful for linking routines that 
are frequently linked into other program objects, but may 
hamper debugging.LEFT="0" WIDTH="73"­vLEFT="80" WIDTH="258"Produces verbose linker output providing information about 
various linker passes.LEFT="0" WIDTH="73"­ysymnameLEFT="80" WIDTH="258"Reports all references to, and definitions of, the symbol symname. 
Useful for locating references to undefined symbols.LBL="" HELPID=""Linker ExampleThe following command tells the linker to search for the DSO ID="02.compiler89"libcurses.so in the directory /usr/lib. If it does not find that DSO, the linker then looks for libcurses.a in /lib.ld foiled.o again.o -lcursesIf the linker doesn't find an appropriate library, it looks in /usr/local/lib for libcurses.a. (Note that the linker does not look for DSOs in /usr/local/lib, so don't put shared objects there.) If found in any of these places, the DSO or library is linked with the objects foiled.o and again.o; otherwise an error is generated.NoteIf the linker reports GOT overflow, GOT unreachable, or GP-related errors, see the ­multigot option. Also see the gp_overflow(5) reference page, which describes some causes of and possible solutions for overflowing the GP-relative area in the linker.LBL="" HELPID=""ID="20833"Linking Assembly Language ProgramsThe assembler driver (ID="02.compiler90"as) does not run the linker. To link a program written in assembly language, use one of these procedures:Assemble and link using one of the other driver commands (ID="02.compiler91"cc, for example). The .s suffix of the assembly language source file causes the driver to invoke the assembler.Assemble the file using as; then link the resulting object file with the ld command.LBL="" HELPID=""ID="98015"Linking LibrariesID="02.compiler92"The linker processes its arguments from left to right as they appear on the command line. Arguments to ID="02.compiler93"ld can be DSOs, object files, or libraries.When ld reads a DSO, it adds all the symbols from that DSO to a cumulative symbol table. If it encounters a symbol that's already in the symbol table, it does not change the symbol table entry. If you define the same symbol in more than one DSO, only the first definition is used.When ld reads an archive, usually denoted by a filename ending in .a, it uses only the object files from that archive that can resolve currently unresolved symbol references. (When a symbol is referred to but not defined in any of the object files that have been loaded so far, it's called unresolved.) Once a library has been searched in this way, it is never searched again. Therefore, libraries should come after object files on the command line in order to resolve as many references as possible. Note that if a symbol is already in the cumulative symbol table from having been encountered in a DSO, its definition in any subsequent archive or DSO is ignored.LBL="" HELPID=""Specifying Libraries and DSOsYou can specify libraries and DSOs either by explicitly stating a pathname or by use of the library search rules. To specify a library or DSO by path, simply include that path on the command line (relative to the current directory, or else absolute):ld myprog.o /usr/lib/libc.so.1 mylib.soNotelibc.so.1 is the name of the standard C DSO, replacing the older libc.a. Similarly, libX11.so.1 is the X11 DSO. Most other DSOs are simply named name.so, without a .1 extension. To use the linker's library search rules, specify the library with the ­lname option:ld myprog.o -lmylibWhen the ­lmylib argument is processed, ld searches for a file called libmylib.so. If it can't find libmylib.so in a given directory, it tries to find libmylib.a there; if it can't find that either, it moves on to the next directory in its search order. The default search order is to look first in ID="02.compiler94"/usr/lib, then in /lib. If ld is invoked from one of the compiler drivers, all ­L and ­nostdlib options are moved up on the command line so that they appear before any ­lname option. For example, consider the command:cc file1.o -lm -L mydirThis command invokes, at the linking stage of compilation, the following:ld -L mydir file1.o -lmNoteThere are three different kinds of files that contain object code files: non-shared libraries, PIC archives, and DSOs. Non-shared libraries are the old-style library, built using ar from .o files that were compiled with ­non_shared. These archives must also be linked ­non_shared. PIC archives are the default, built using ar from .o files compiled with ­KPIC (the default option); they can be linked with other PIC files. DSOs are built from PIC .o files by using ld ­shared; see IDREF="92826" TYPE="TITLE"Chapter 3 for details.If the linker tells you that a reference to a certain function is unresolved, check that function's reference page to find out which library the function is in. If it isn't in one of the standard libraries (which ld links in by default), you may need to specify the appropriate library on the command line. For an alternative method of finding out where a function is defined, see IDREF="26263" TYPE="TITLE""Finding an Unresolved Symbol With ld."NoteSimply including the header file associated with a library routine is not enough; you also must specify the library itself when linking (unless it's a standard library). No automatic connection exists between header files and libraries; header files only give prototypes for library routines, not the library code itself.LBL="" HELPID=""Examples of Linking DSOsTo link a sample program foo.c with the math DSO, libm.so, enter:cc foo.c -lmTo specify the appropriate DSOs for a graphics program foogl.c, enter:cc foogl.c -lgl -lX11LBL="" HELPID=""ID="65412"Linking to Previously Built Dynamic Shared ObjectsID="02.compiler95"This section describes how to link your source files with previously built DSOs; for more information about how to build your own DSOs, see IDREF="92826" TYPE="TITLE"Chapter 3, "Using Dynamic Shared Objects."To build an executable that uses a DSO, call a compiler driver just as you would for a non-shared library. For instance,cc needle.c -lthreadThis command links the resulting object file (needle.o) with the previously built DSO libthread.so (and the standard C DSO, libc.so.1), if available. If no libthread.so exists, but a PIC archive named libthread.a exists, that archive is used with libc.so.1, so you still get dynamic (run time) linking. Note that even .a libraries now contain position-independent code by default, though it is also possible to build non-shared .a libraries that do not contain PIC.LBL="" HELPID=""ID="71272"Linking Multilanguage ProgramsThe source language of the main program may differ from that of a subprogram. In this case, you can link multilanguage programs.Follow the steps below to link multilanguage programs. (Refer to ID="02.compiler96"IDREF="77503" TYPE="GRAPHIC"Figure 2-1 for an illustration of the process.)Compile object files from the source files of each language separately by using the ­c option. For example, if the source consists of a Fortran main program (main.f) and two files of C functions (more.c and rest.c), use the commands:cc -c more.c rest.cf77 -c main.fThese commands produce the object files main.o, more.o, and rest.o.Use the compiler associated with the language of the main program to link the objects:f77 main.o more.o rest.oThe compiler drivers supply the default set of libraries necessary to produce an executable from the source of the associated language. However, when producing executables from source code in several languages, you may need to specify the default libraries explicitly for one or more of the languages used. For instructions on specifying libraries, see IDREF="98015" TYPE="TITLE""Linking Libraries."FILE="2.1.cmplr.ctlflw.gif" POSITION="INLINE" SCALE="FALSE"LBL="2-1"Figure 2-1 ID="77503"Compilation Control Flow for Multilanguage ProgramsNoteUse caution when passing pointers and longs between languages as some languages use different type sizes and structures for data types.For specific details about compiling multilanguage programs, refer to the programming guides for the appropriate languages.LBL="" HELPID=""ID="26263"Finding an Unresolved Symbol With ldYou can use ID="02.compiler97"ld to locate unresolved symbols. For example, suppose you're compiling a program, and ID="02.compiler98"ld tells you that you're using an unresolved symbol. However, you don't know where the unresolved symbol is referenced. To find the unresolved symbol, enter:ld -ysymbol file1... filenYou can also enter:cc prog.o -Wl,-ysymbolThe output lists the source file that references symbol.LBL="" HELPID=""ID="41684"DebuggingThe compiler system provides a debugging tool, dbx (described in detail in the dbx User's Guide). In addition, CASEVision/WorkShopname='trade' font=symbol charset=fontspecific code=228 
	descr='[trade]' contains debugging tools. For information about obtaining WorkShop for your computer, contact your dealer or sales representative.Before using ID="02.compiler99"dbx, specify the ­g driver option (see IDREF="42043" TYPE="TABLE"Table 2-7) to produce executables containing information that the debugger can use. Click the word dbx to view the dbx(1) reference page.COLUMNS="2"LBL="2-7"Table 2-7  (continued)        Driver Options for DebuggingID="42043"LEFT="0" WIDTH="54"Option LEFT="60" WIDTH="280"PurposeLEFT="0" WIDTH="54"­g0LEFT="60" WIDTH="280"Produces a program object with a minimum of source-level 
debugging information. This is the default. Reduces the size of the 
program object but allows optimizations. Use this option with the ­O 
option after you finish debugging.LEFT="0" WIDTH="54"­g, ­g2LEFT="60" WIDTH="280"Produces additional debugging information for full symbolic 
debugging. This option overrides the optimization options (­Onum).LEFT="0" WIDTH="54"­g3LEFT="60" WIDTH="280"Produces additional debugging information for full symbolic 
debugging of fully optimized code. This option makes the debugger 
less accurate. You can use ­g3 with an optimization option (­Onum).LBL="" HELPID=""ID="65767"Getting Information About Object FilesThe following tools provide information on object files:ID="02.compiler100"ID="02.compiler101"dis disassembles an object file into machine instructions.dwarfdump lists headers, tables, and other selected parts of a DWARF-format object file or archive file.ID="02.compiler102"elfdump lists the contents (including the symbol table and header information) of an ELF-format object file.ID="02.compiler103"file provides descriptive information on the properties of a file.ID="02.compiler104"nmID="02.compiler105" lists symbol table information.size prints the size of each section of an object file (some such sections are named ID="02.compiler106"text, data, and sbss). ID="02.compiler107"strip removes symbol table and relocation bits.Note that you can trace system call and scheduling activity by using the par command. For more information, see the par(1) reference page.LBL="" HELPID=""Disassembling Object Files with disThe ID="02.compiler108"dis tool disassembles object files into machine instructions. You can disassemble an object, archive library, or executable file. ID="02.compiler109"LBL="" HELPID=""dis SyntaxThe syntax for dis is:dis options filename1 [filename2...filenamen]options  One or more of the options listed in IDREF="18629" TYPE="TABLE"Table 2-8.filename Specifies the name of one or more files to disassemble.LBL="" HELPID=""dis OptionsIDREF="18629" TYPE="TABLE"Table 2-8 lists dis options. For more information, see the ID="02.compiler110"dis(1) reference page.COLUMNS="2"LBL="2-8"Table 2-8  (continued)        ID="18629"  dis OptionsLEFT="0" WIDTH="81"OptionLEFT="90" WIDTH="241"DescriptionLEFT="0" WIDTH="81"­b begin_addrLEFT="90" WIDTH="241"Starts disassembly at begin_address. You can specify the 
address as decimal, octal (with a leading 0), or hexadecimal 
(with a leading 0x).LEFT="0" WIDTH="81"­d sectionLEFT="90" WIDTH="241"Disassembles the named section as data, and prints the offset 
of the data from the beginning of the section.LEFT="0" WIDTH="81"­D sectionLEFT="90" WIDTH="241"Disassembles the named section as data, and prints the 
address of the data.LEFT="0" WIDTH="81"­e end_addressLEFT="90" WIDTH="241"Stops disassembly at end_address. You can specify the 
address as decimal, octal (with a leading 0), or hexadecimal 
(with a leading 0x).LEFT="0" WIDTH="81"­FfunctionLEFT="90" WIDTH="241"Disassembles the named function in each object file you 
specify on the command line. LEFT="0" WIDTH="81"­hLEFT="90" WIDTH="241"Substitutes the hardware register names for the software 
register names in the output.LEFT="0" WIDTH="81"­HLEFT="90" WIDTH="241"Removes the leading source line, and leaves the hex value 
and the instructions.LEFT="0" WIDTH="81"­iLEFT="90" WIDTH="241"Removes the leading source line and hexadecimal value of 
disassembly, and leaves only the instructions.LEFT="0" WIDTH="81"­I directoryLEFT="90" WIDTH="241"Uses directory to help locate source code.LEFT="0" WIDTH="81"­l stringLEFT="90" WIDTH="241"Disassembles the archive file specified by string.LEFT="0" WIDTH="81"­LLEFT="90" WIDTH="241"Looks up source labels for subsequent printing.LEFT="0" WIDTH="81"­oLEFT="90" WIDTH="241"Prints numbers in octal. The default is hexadecimal.LEFT="0" WIDTH="81"­sLEFT="90" WIDTH="241"Performs symbolic disassembly where possible. Prints 
(using C syntax) symbol names on the line following the 
instruction. Displays source code mixed with assembly 
codeLEFT="0" WIDTH="81"­t sectionLEFT="90" WIDTH="241"Disassembles the named section as text.LEFT="0" WIDTH="81"­TLEFT="90" WIDTH="241"Specifies the trace flag for debugging the disassembler.LEFT="0" WIDTH="81"­VLEFT="90" WIDTH="241"Prints (on stderr) the version number of the disassembler 
being executed.LEFT="0" WIDTH="81"­wLEFT="90" WIDTH="241"Prints source code to the right of assembly code (produces 
wide output). Use this option with the ­s option.LEFT="0" WIDTH="81"­xLEFT="90" WIDTH="241"Prints offsets in hexadecimal (the default).LBL="" HELPID=""Listing Parts of DWARF Object Files With dwarfdumpThe ID="02.compiler111"dwarfdump tool provides debugging information from selected parts of DWARF symbolic information in an ELF object file. For more information on DWARF, see files in the 4Dgifts directory. LBL="" HELPID=""dwarfdump SyntaxThe syntax for dwarfdump is:dwarfdump options filenameoptions One or more of the options listed in IDREF="85722" TYPE="TABLE"Table 2-9. filename Specifies the name of the object file whose contents are to be dumped.LBL="" HELPID=""dwarfdump OptionsIDREF="85722" TYPE="TABLE"Table 2-9 lists dwarfdump options. For more information, see the ID="02.compiler112"dwarfdump(1) reference page. COLUMNS="2"LBL="2-9"Table 2-9  (continued)        ID="85722"dwarfdump OptionsLEFT="0" WIDTH="81"OptionLEFT="90" WIDTH="253"DumpsLEFT="0" WIDTH="81"­aLEFT="90" WIDTH="253"All sections.LEFT="0" WIDTH="81"­bLEFT="90" WIDTH="253"The .debug_abbrev section.LEFT="0" WIDTH="81"­cLEFT="90" WIDTH="253"The .debug_loc section.LEFT="0" WIDTH="81"­dLEFT="90" WIDTH="253"Uses dense mode. Prints die information of the .debug_info 
section. Does not imply the ­i option.LEFT="0" WIDTH="81"­eLEFT="90" WIDTH="253"Uses ellipsis mode. Uses the short names for DW_TAG_* and 
DW_ATTR_* in the output for the .debug_info section.LEFT="0" WIDTH="81"­fLEFT="90" WIDTH="253"The .debug_frame section.LEFT="0" WIDTH="81"­iLEFT="90" WIDTH="253"The .debug_info section.LEFT="0" WIDTH="81"­lLEFT="90" WIDTH="253"The .debug_line section.LEFT="0" WIDTH="81"­mLEFT="90" WIDTH="253"The .debug_macinfo section.LEFT="0" WIDTH="81"­oLEFT="90" WIDTH="253"The .rel.debug_* sections.LEFT="0" WIDTH="81"­pLEFT="90" WIDTH="253"The .debug_pubnames section.LEFT="0" WIDTH="81"­rLEFT="90" WIDTH="253"The .debug_aranges section.LEFT="0" WIDTH="81"­sLEFT="90" WIDTH="253"The .debug_string section.LEFT="0" WIDTH="81"­taLEFT="90" WIDTH="253"The .debug_static_funcs and .debug_static_vars sections 
(same as ­tfv).LEFT="0" WIDTH="81"­tfLEFT="90" WIDTH="253"The .debug_static_funcs section.LEFT="0" WIDTH="81"­tvLEFT="90" WIDTH="253"The .debug_static_vars section.LEFT="0" WIDTH="81"­u fileLEFT="90" WIDTH="253"Sections to the named file.LEFT="0" WIDTH="81"­vLEFT="90" WIDTH="253"Prints detailed information (verbose mode).LEFT="0" WIDTH="81"­wLEFT="90" WIDTH="253"The .debug_weaknames section.LEFT="0" WIDTH="81"­yLEFT="90" WIDTH="253"The .debug_types section.LBL="" HELPID=""Listing Parts of ELF Object Files and Libraries with elfdumpID="02.compiler113"The ID="02.compiler114"elfdump tool lists headers, tables, and other selected parts of an ELF-format object file or archive file. ID="02.compiler115"LBL="" HELPID=""elfdump SyntaxThe syntax for elfdump is:elfdump options filename1 [filename2...filenamen]options One or more of the options listed in IDREF="81698" TYPE="TABLE"Table 2-10.filename Specifies the name of one or more object files whose contents are to be dumped.LBL="" HELPID=""elfump OptionsIDREF="81698" TYPE="TABLE"Table 2-10 lists elfdump options. For more information, see the ID="02.compiler116"elfdump(1) reference page.COLUMNS="2"LBL="2-10"Table 2-10 ID="81698" (continued)        elfdump OptionsLEFT="0" WIDTH="81" OptionLEFT="90" WIDTH="253"DumpsLEFT="0" WIDTH="81"­aLEFT="90" WIDTH="253"Archive header of each member of the archive.LEFT="0" WIDTH="81"­ALEFT="90" WIDTH="253"Beginning address of a section.LEFT="0" WIDTH="81"­cLEFT="90" WIDTH="253"String table.LEFT="0" WIDTH="81"­CLEFT="90" WIDTH="253"Decoded C++ symbol names.LEFT="0" WIDTH="81"­cmtLEFT="90" WIDTH="253"The .comment sections.LEFT="0" WIDTH="81"­cntLEFT="90" WIDTH="253"The .content sections.LEFT="0" WIDTH="81"­dLEFT="90" WIDTH="253"Range of sections.LEFT="0" WIDTH="81"­DcLEFT="90" WIDTH="253"Conflict list in Dynamic Shared Objects.LEFT="0" WIDTH="81"­DgLEFT="90" WIDTH="253"Global Offset Table in Dynamic Shared Objects.LEFT="0" WIDTH="81"­DinfoLEFT="90" WIDTH="253"The .MIPS.dclass section.LEFT="0" WIDTH="81"­DinstLEFT="90" WIDTH="253"The .MIPS.inst section.LEFT="0" WIDTH="81"­DlLEFT="90" WIDTH="253"Library list in Dynamic Shared Objects.LEFT="0" WIDTH="81"­DsymLEFT="90" WIDTH="253"The .MIPS.sym section.LEFT="0" WIDTH="81"­DsymlibLEFT="90" WIDTH="253"Symbol library table (.MIPS.symlib).LEFT="0" WIDTH="81"­DtLEFT="90" WIDTH="253"String table entries of the dynamic symbol table in Dynamic 
Shared Objects.LEFT="0" WIDTH="81"­eLEFT="90" WIDTH="253"Events sections.LEFT="0" WIDTH="81"­fLEFT="90" WIDTH="253"Each file header.LEFT="0" WIDTH="81"­FLEFT="90" WIDTH="253"Literal tables (.lit4 and .lit8 sections).LEFT="0" WIDTH="81"­gLEFT="90" WIDTH="253"Archive symbol table.LEFT="0" WIDTH="81"­GLEFT="90" WIDTH="253"The global pointer table information.LEFT="0" WIDTH="81"­hLEFT="90" WIDTH="253"All section headers in the file.LEFT="0" WIDTH="81"­hashLEFT="90" WIDTH="253"Hash table entries.LEFT="0" WIDTH="81"­iLEFT="90" WIDTH="253"The .interp section, which lists the path name of the program 
interpreter.LEFT="0" WIDTH="81"­infoLEFT="90" WIDTH="253"Prints whether the object is marked quickstart, or is corded and 
is marked requickstart.LEFT="0" WIDTH="81"­lLEFT="90" WIDTH="253"The .line section.LEFT="0" WIDTH="81"­LLEFT="90" WIDTH="253"Dynamic linking information in Dynamic Shared Objects.LEFT="0" WIDTH="81"­nLEFT="90" WIDTH="253"The specified section (such as .MIPS.content, .dynamic, .got, 
MIPS.sym, .liblist, .conflict, .reginfo, and so forth).LEFT="0" WIDTH="81"­oLEFT="90" WIDTH="253"Each program execution header.LEFT="0" WIDTH="81"­opLEFT="90" WIDTH="253"Options section.LEFT="0" WIDTH="81"­pLEFT="90" WIDTH="253"Suppresses the printing of headings.LEFT="0" WIDTH="81"­rLEFT="90" WIDTH="253"Relocation information.LEFT="0" WIDTH="81"­RLEFT="90" WIDTH="253"Register information.LEFT="0" WIDTH="81"­regLEFT="90" WIDTH="253"The .reginfo section.LEFT="0" WIDTH="81"­rptLEFT="90" WIDTH="253"The run-time procedure table.LEFT="0" WIDTH="81"­sLEFT="90" WIDTH="253"Section contents.LEFT="0" WIDTH="81"­svr4LEFT="90" WIDTH="253"Information in SVR4-style format.LEFT="0" WIDTH="81"­tLEFT="90" WIDTH="253"Symbol table entries.LEFT="0" WIDTH="81"­TLEFT="90" WIDTH="253"Symbol table range.LEFT="0" WIDTH="81"­uLEFT="90" WIDTH="253"Updates a COFF file to an ELF file.LEFT="0" WIDTH="81"­VLEFT="90" WIDTH="253"Version information only.LBL="" HELPID=""Determining File Type with fileID="02.compiler117"The ID="02.compiler118"file tool lists the properties of program source, text, object, and other files. This tool attempts to identify the contents of files using various heuristics. It is not exact and often erroneously recognizes command files as C programs. For more information, see the file(1) reference page.LBL="" HELPID=""file SyntaxThe syntax for file is:file filename1 [filename2...filenamen]Each filename is the name of a file to be examined.LBL="" HELPID=""file ExampleInformation given by ID="02.compiler119"file is self-explanatory for most kinds of files, but using file on object files and executables gives somewhat cryptic output.file test.o a.out /lib/libc.so.1test.o:        ELF 64-bit MSB relocatable MIPS - version 1
a.out:         ELF 64-bit MSB executable MIPS - version 1
/lib/libc.so.1:   ELF 64-bit MSB dynamic lib MIPS - version 1In this example, MSB indicates Most Significant Byte, also called Big-Endian; relocatable means the object contains relocation information that allows it to be linked with other objects to form an executable; executable means an executable file; and dynamiclib indicates a DSO.LBL="" HELPID=""ID="38022"Listing Symbol Table Information: nmID="02.compiler120"The ID="02.compiler121"nm tool lists symbol table information for object files and archive files.LBL="" HELPID=""nm SyntaxThe syntax for nm is:nm options filename1 [filename2...filenamen]optionsOne or more of the options listed in IDREF="46733" TYPE="TABLE"Table 2-11.filename Specifies the object files or archive files from which symbol table information is to be extracted. If you do not specify a filename, nm assumes the file is named ID="02.compiler122"a.out.LBL="" HELPID=""nm Symbol Table OptionsIDREF="46733" TYPE="TABLE"Table 2-11 lists nm symbol table options. For more information, see the nm(1) reference page.COLUMNS="2"LBL="2-11"Table 2-11  (continued)        Symbol Table nm OptionsID="46733"LEFT="0" WIDTH="46"Option LEFT="55" WIDTH="288"PurposeLEFT="0" WIDTH="46"­aLEFT="55" WIDTH="288"Prints debugging information.LEFT="0" WIDTH="46"­ALEFT="55" WIDTH="288"Prints the listing in System V format (default).LEFT="0" WIDTH="46"­bLEFT="55" WIDTH="288"Prints the value field in octal.LEFT="0" WIDTH="46"­BLEFT="55" WIDTH="288"Prints the listing in BSD format.LEFT="0" WIDTH="46"­CLEFT="55" WIDTH="288"Prints decoded C++ names.LEFT="0" WIDTH="46"­dLEFT="55" WIDTH="288"Prints the value field in decimal (the default for System V output).LEFT="0" WIDTH="46"­gLEFT="55" WIDTH="288"Prints globally visible names.LEFT="0" WIDTH="46"­hLEFT="55" WIDTH="288"Suppresses printing of headers.LEFT="0" WIDTH="46"­lLEFT="55" WIDTH="288"Produces a long listing.LEFT="0" WIDTH="46"­nLEFT="55" WIDTH="288"Sorts external symbols by name for System V format. Sorts all symbols 
by value for BSD format (by name is the BSD default output).LEFT="0" WIDTH="46"­oLEFT="55" WIDTH="288"Prints value field in octal (System V output). Prints the filename 
immediately before each symbol name (BSD output).LEFT="0" WIDTH="46"­pLEFT="55" WIDTH="288"Produces easily parsible, terse output similar to the BSD format.LEFT="0" WIDTH="46"­rLEFT="55" WIDTH="288"Prepends the name of the object file or archive to each output line.LEFT="0" WIDTH="46"­TLEFT="55" WIDTH="288"Truncates characters in exceedingly long symbol names; inserts an 
asterisk as the last character of the truncated name. This option may 
make the listing easier to read.LEFT="0" WIDTH="46"­uLEFT="55" WIDTH="288"Prints only undefined symbols.LEFT="0" WIDTH="46"­vLEFT="55" WIDTH="288"Sorts external symbols by value (default for BSD format).LEFT="0" WIDTH="46"­VLEFT="55" WIDTH="288"Prints the version number of nm.LEFT="0" WIDTH="46"­xLEFT="55" WIDTH="288"Prints the value field in hexadecimal.IDREF="19204" TYPE="TABLE"Table 2-12 defines the one-character codes shown in an ID="02.compiler123"nm listing. Refer to the example that follows the table for a sample listing.COLUMNS="2"LBL="2-12"Table 2-12  (continued)        Character Code MeaningsID="19204"LEFT="0" WIDTH="37"KeyLEFT="45" WIDTH="297"DescriptionLEFT="0" WIDTH="37"aLEFT="45" WIDTH="297"Local absolute dataLEFT="0" WIDTH="37"ALEFT="45" WIDTH="297"External absolute dataLEFT="0" WIDTH="37"bLEFT="45" WIDTH="297"Local zeroed dataLEFT="0" WIDTH="37"BLEFT="45" WIDTH="297"External zeroed dataLEFT="0" WIDTH="37"CLEFT="45" WIDTH="297"Common dataLEFT="0" WIDTH="37"dLEFT="45" WIDTH="297"Local initialized dataLEFT="0" WIDTH="37"DLEFT="45" WIDTH="297"External initialized dataLEFT="0" WIDTH="37"ELEFT="45" WIDTH="297"Small common dataLEFT="0" WIDTH="37"GLEFT="45" WIDTH="297"External small initialized dataLEFT="0" WIDTH="37"NLEFT="45" WIDTH="297"Nil storage class (unused external reference)LEFT="0" WIDTH="37"rLEFT="45" WIDTH="297"Local read-only dataLEFT="0" WIDTH="37"RLEFT="45" WIDTH="297"External read-only dataLEFT="0" WIDTH="37"sLEFT="45" WIDTH="297"Local small zeroed dataLEFT="0" WIDTH="37"SLEFT="45" WIDTH="297"External small zeroed dataLEFT="0" WIDTH="37"tLEFT="45" WIDTH="297"Local textLEFT="0" WIDTH="37"TLEFT="45" WIDTH="297"External textLEFT="0" WIDTH="37"ULEFT="45" WIDTH="297"External undefined dataLEFT="0" WIDTH="37"VLEFT="45" WIDTH="297"External small undefined dataLBL="" HELPID=""nm Example of Obtaining a Symbol Table ListingThis example demonstrates how to obtain a symbol table listing. Consider the following program, ID="02.compiler124"tnm.c: #include <stdio.h>
#include <math.h>
#define LIMIT 12
int unused_item = 14;
double mydata[LIMIT];

main()
{
    int i;
    for(i = 0; i < LIMIT; i++) {
        mydata[i] = sqrt((double)i);
    }
    return 0;
}Compile the program into an object file by entering:cc -c tnm.cTo obtain symbol table information for the object file tnm.o in BSD format, use the nm ­B command:0000000000 T main
0000000000 B mydata
0000000000 U sqrt
0000000000 D unused_item
00000000 N _bufendtabTo obtain symbol table information for the object file tnm.o in SVR4 format, use the nm command without any options:Symbols from tnm.o:

[Index]   Value     Size    Class    Type         Section    Name

[0]     |        0|        |File    |ref=4       |Text     | tnm.c
[1]     |        0|        |Proc    |end=3 int   |Text     | main
[2]     |      116|        |End     |ref=1       |Text     | main
[3]     |        0|        |End     |ref=0       |Text     | tnm.c
[4]     |        0|        |File    |ref=6       |Text     | /usr/include/math.h
[5]     |        0|        |End     |ref=4       |Text     | /usr/include/math.h
[6]     |        0|        |Global  |            |Data     | unused_item
[7]     |        0|        |Global  |            |Bss      | mydata
[8]     |        0|        |Proc    |ref=1       |Text     | main
[9]     |        0|        |Proc    |            |Undefined| sqrt
[10]    |        0|        |Global  |            |Undefined| _gp_dispLBL="" HELPID=""Determining Section Sizes with sizeID="02.compiler125"The ID="02.compiler126"size tool prints information about the sections (such as text, rdata, and sbss) of the specified object or archive files. The elf(4) reference page describes the format of these sections. ID="02.compiler127"LBL="" HELPID=""size SyntaxThe syntax for size is:size options [filename1 filename2...filenamen]optionsSpecifies the format of the listing (see IDREF="34039" TYPE="TABLE"Table 2-13).filenameSpecifies the object or archive files whose properties are to be listed. If you do not specify a filename, the default is a.out.LBL="" HELPID=""size OptionsIDREF="34039" TYPE="TABLE"Table 2-13 lists size options. For more information, see the size(1) reference page.COLUMNS="2"LBL="2-13"Table 2-13  (continued)        size OptionsID="34039"LEFT="0" WIDTH="46"OptionLEFT="55" WIDTH="288"ActionLEFT="0" WIDTH="46"­ALEFT="55" WIDTH="288"Prints data section headers in System V format (default). LEFT="0" WIDTH="46"­BLEFT="55" WIDTH="288"Prints output in BSD-style format.LEFT="0" WIDTH="46"­dLEFT="55" WIDTH="288"Prints sizes in decimal (default).LEFT="0" WIDTH="46"­fLEFT="55" WIDTH="288"Prints data on allocatable sections including the size, permission flags, 
and the total of the loadable sizes.LEFT="0" WIDTH="46"­FLEFT="55" WIDTH="288"Prints data on loadable segments including the name and the total of the 
section sizes.LEFT="0" WIDTH="46"­nLEFT="55" WIDTH="288"Prints nonloadable and nonallocatable section sizes.LEFT="0" WIDTH="46"­oLEFT="55" WIDTH="288"Prints sizes in octal.LEFT="0" WIDTH="46"­svr4LEFT="55" WIDTH="288"Prints output in SVR4-style format.LEFT="0" WIDTH="46"­VLEFT="55" WIDTH="288"Prints the version of size that you are using.LEFT="0" WIDTH="46"­xLEFT="55" WIDTH="288"Prints sizes in hexadecimal.LBL="" HELPID=""size ExampleAn example of the ID="02.compiler128"size command and the listings produced follows.size a.out Section         Size           Physical              Virtual
                                 Address              Address
       .interp     21          268435856            268435856 
 .MIPS.options    104          268435880            268435880 
      .dynamic    464          268435984            268435984 
      .liblist     20          268436448            268436448 
  .MIPS.symlib     30          268436468            268436468 
         .msym    240          268436500            268436500 
       .dynstr    312          268436744            268436744 
       .dynsym    720          268437056            268437056 
         .hash    256          268437776            268437776 
   .MIPS.stubs     56          268438032            268438032 
         .text    460          268438088            268438088 
         .init     24          268438548            268438548 
         .data     17          268505088            268505088 
        .sdata      8          268505108            268505108 
          .got    112          268505120            268505120 
          .bss     36          268505232            268505232 LBL="" HELPID=""Removing Symbol Table and Relocation Bits with stripThe ID="02.compiler129"strip tool removes symbol table and relocation bits that are attached to the assembler and loader. Use strip to save space after you debug a program. The effect of strip is the same as that of using the -s option to ld. ID="02.compiler130"LBL="" HELPID=""strip SyntaxThe syntax for strip is:strip options filename1 [filename2...filenamen]options One or more of the options listed in IDREF="45810" TYPE="TABLE"Table 2-14.filename Specifies the name of one or more object files whose contents are to be stripped.For more information, see the ID="02.compiler131"strip(1) reference page. COLUMNS="2"LBL="2-14"Table 2-14 ID="45810"strip OptionsLEFT="0" WIDTH="81"OptionLEFT="90" WIDTH="253"DescriptionLEFT="0" WIDTH="81"­lLEFT="90" WIDTH="253"Strips line number information, and keeps the symbol table 
and debugging information.LEFT="0" WIDTH="81"­ofilenameLEFT="90" WIDTH="253"Puts the stripped information in the filename that you specify.LEFT="0" WIDTH="81"­VLEFT="90" WIDTH="253"Prints the version number of strip.LEFT="0" WIDTH="81"­xLEFT="90" WIDTH="253"Keeps symbol table information, but may strip debugging and 
line number information.LBL="" HELPID=""ID="94723"Using the Archiver to Create LibrariesID="02.compiler132"An archive library is a file that includes the contents of one or more object (.o) files. When the linker (ld) searches for a symbol in an archive library, it loads only the code from the object file where that symbol was defined (not the entire library) and links it with the calling program.The archiver (ar) creates and maintains archive libraries and has these main functions:Copying new objects into the libraryReplacing existing objects in the libraryMoving objects around within the libraryExtracting individual objects from the libraryCreating a symbol table for the linker to search symbolsThe following section explains the syntax of the ar command and lists some options and examples of how to use it. See the ar(1) reference page for details.Notear simply strings together whatever object files you tell it to archive. Therefore you can use ar to build either non-shared or PIC libraries, depending on how the included .o files were built in the first place. If you do create a non-shared library with ar, remember to link it ­non_shared with your other code. For information about building DSOs and converting libraries to DSOs, see IDREF="92826" TYPE="TITLE"Chapter 3. LBL="" HELPID=""arID="02.compiler133" SyntaxThe syntax for ar is:ar options [posObject] libName [object1...objectn]options Specifies the action that the archiver is to take. IDREF="68022" TYPE="TABLE"Table 2-15 and IDREF="94696" TYPE="TABLE"Table 2-16 list some of the options. posObject Specifies the name of an object within an archive library. It specifies the relative placement (either before or after posObject) of an object that is to be copied into the library or moved within the library. This parameter is required when the a, b, or i suboptions are specified with the m or r option. The last example in IDREF="99984" TYPE="TITLE""ar Examples," shows the use of a posObject parameter.libName Specifies the name of the archive library you are creating, updating, or extracting information from.object Specifies the name(s) of the object file(s) to manipulate.LBL="" HELPID=""ar OptionsID="02.compiler134"When running the archiver, specify exactly one of the options d, m, p, q, r, t, or x (listed in IDREF="68022" TYPE="TABLE"Table 2-15). In addition, you can optionally specify any of the modifiers in IDREF="94696" TYPE="TABLE"Table 2-16.COLUMNS="2"LBL="2-15"Table 2-15  (continued)        ID="68022"Archiver OptionsLEFT="0" WIDTH="37"Option LEFT="45" WIDTH="297"PurposeLEFT="0" WIDTH="37"dLEFT="45" WIDTH="297"Deletes the specified objects from the archive.LEFT="0" WIDTH="37"fLEFT="45" WIDTH="297"Adds padding to the end of each object file archived, using the character 
\n. This enables the loader to have faster access to members in the archive 
while performing static linking. Warning: This option results in a 
permanent change in the size of object files.LEFT="0" WIDTH="37"pLEFT="45" WIDTH="297"Prints the specified objects in the archive on the standard output device 
(usually the terminal screen).LEFT="0" WIDTH="37"qLEFT="45" WIDTH="297"Adds the specified object files to the end of the archive. This option is 
similar to the r option (described below), but is faster and does not remove 
any older versions of the object files that may already be in the archive. 
Use the q option when creating a new library.LEFT="0" WIDTH="37"rLEFT="45" WIDTH="297"Adds the specified object files to the end of the archive file. If an object file 
with the same name already exists in the archive, the new object file 
overwrites it. Use the r option when updating existing libraries.LEFT="0" WIDTH="37"tLEFT="45" WIDTH="297"Prints a table of contents on the standard output (usually the screen) for 
the specified object or archive file.LEFT="0" WIDTH="37"xLEFT="45" WIDTH="297"Copies the specified objects from the archive and places them in the 
current directory. Duplicate files are overwritten. The last modified date is 
the current date (unless you specify the o suboption, in which case the 
date stamp on the archive file is the last modified date). If no objects are 
specified, x copies all the library objects into the current directory.COLUMNS="2"LBL="2-16"Table 2-16 ID="94696" (continued)        Archiver ModifiersLEFT="0" WIDTH="37"Option LEFT="45" WIDTH="297"PurposeLEFT="0" WIDTH="37"cLEFT="45" WIDTH="297"Suppresses the warning message that the archiver issues when it 
discovers that the archive you specified does not already exist.LEFT="0" WIDTH="37"lLEFT="45" WIDTH="297"Puts the archiver's temporary files in the current working directory. 
Ordinarily, the archiver puts those files in /tmp (unless the STMDIR 
environment variable is set, in which case ar stores temporary files in the 
directory indicated by that variable). This option is useful when /tmp (or 
STMDIR) is full.LEFT="0" WIDTH="37"sLEFT="45" WIDTH="297"Creates a symbol table in the archive. This modifier is rarely necessary 
since the archiver updates the symbol table of the archive library 
automatically. Options p, q, and r, in particular, create a symbol table by 
default and thus do not require s to be specified.LEFT="0" WIDTH="37"vLEFT="45" WIDTH="297"Lists descriptive information during the process of creating or modifying 
the archive. When specified with the t option, produces a verbose table of 
contents.LBL="" HELPID=""ID="99984"ar ExamplesTo create a new library, libtest.a, and add object files to it, enter:ar cq libtest.a mcount.o mon1.o string.oThe c option suppresses an archiver message during the creation process. The q option creates the library and puts mcount.o, mon1.o, and string.o into it.To replace an object file in an existing library, enter:ar r libtest.a mon1.oThe r option replaces mon1.o in the library libtest.a. If mon1.o does not already exist in the library libtest.a, it is added.NoteIf you specify the same file twice in an argument list of files to be added to an archive, that file appears twice in the archive.LBL="3"ID="92826"Using Dynamic Shared ObjectsID="03.dso1"A dynamic shared object (DSO) is an object file that's meant to be used simultaneouslyname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'or ID="03.dso2"sharedname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'by multiple applications (a.out files) while they're executing. As you read this chapter, you will learn how to build and use DSOs. This chapter covers the following topics:IDREF="28045" TYPE="TITLE""Benefits of Using DSOs" explains the benefits of DSOs.IDREF="65605" TYPE="TITLE""Using DSOs" tells you how to obtain the most benefit from using DSOs when creating your executable.IDREF="51258" TYPE="TITLE""Taking Advantage of QuickStart" discusses an optimization you can use to make sure that the DSOs you build load as quickly as possible.IDREF="86160" TYPE="TITLE""Building DSOs" describes how to build a DSO.IDREF="17473" TYPE="TITLE""Run-Time Linking" discusses the run-time linker, and how it locates DSOs at run time.IDREF="92334" TYPE="TITLE""Dynamic Loading Under Program Control" explains the use of dlopen()and dlsym() to control run-time linking.IDREF="50766" TYPE="TITLE""Versioning of DSOs" discusses a versioning mechanism for DSOs that allows binaries linked against different, incompatible versions of the same DSO to run correctly.You can use DSOs in place of archive libraries (they replace static shared libraries provided with earlier releases of IRIX). ID="03.dso3"LBL="" HELPID=""ID="28045"Benefits of Using DSOsSince DSOs contain shared components, using them provides several substantial benefits. These include:DSOs minimize overall memory usage because code is shared. Two executables that use the same DSO and that run simultaneously have only one copy of the instruction from the shared component loaded into memory. For example, if executable A and executable B both link with the same DSO C, and if A and B are both running at the same time, the total memory used is what's required for A, B, and C, plus some small overhead. If C was an unshared library, the memory used would be what's required for A, B, and two copies of C. Executables linked with DSOs are smaller than those linked with unshared libraries because the shared objects aren't part of the executable file image, so disk usage is minimized. DSOs are much easier to use, build, and debug than static shared libraries. Most of the libraries supplied by Silicon Graphics are available as DSOs. In the past, only a few static shared libraries have been available; most libraries were unshared. Executables that use a DSO don't have to be relinked if the DSO changes; when the new DSO is installed, the executable automatically starts using it. This feature makes it easier to update end users with new software versions. It also allows you to create hardware-independent software packages more easily. Suppose, for example, you want to build both MipsIV and a MipsIII versions of a shared object. You want your program to use the MipsIV version when it is running on a Power Challenge (R8000) system, and also run correctly on another 64-bit platform. Suppose you want to do the above with the routines in as library named libchange.so. To do this, build one version of the routines in libchange using the ­mips4 option, and place it in /usr/lib64/mips4 on a Power Challenge system. Next, build another version using the ­mips3 option, and place it in /usr/lib64. Then, when you build an executable that uses libchange, use the ­rpath option to tell the run-time linker to look first for MipsIV versions of the libraries. For example:cc -mips3 -o prog prog.o -rpath /usr/lib64/mips4 -lchangeAs a result, prog runs on any IRIX 6.0 system, and it automatically takes advantage of any MipsIV libraries whenever it runs on a Power Challenge system.DSOs and the executables that use them are mapped into memory by a run-time loader, ID="03.dso4"rld, which resolves external references between objects and relocates objects at run time. (DSOs contain only position-independent code [PIC], so they can be loaded at any virtual address at run time.) With rld, the binding of symbols can be changed at run time at the request of the executing program. You could use this feature to dynamically change the feature set presented to a user of your application, for example, while minimizing start-up time. The application could be started quickly, with a subset of the features available and then, if the user needs other features, those can be loaded in under programmatic control. Naturally, some costs are involved with using DSOs, and these are explained in the next section, IDREF="65605" TYPE="TITLE""Using DSOs." The sections after that explain how to build and optimize DSOs and how rld works. The dso(5) reference page also contains more information about DSOs. Click the word APP="/usr/sbin/xwsh" PARMS="-title man_5_dso -geom 80x40 -hold -e man 5 dso"dso
 to view the page.LBL="" HELPID=""ID="65605"Using DSOsUsing DSOs is easyname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the syntax is the same as for an archive (.a) library. This section explains how to use DSOs. Specific topics include:IDREF="47959" TYPE="TITLE""DSOs vs. Archive Libraries," which describes differences between DSOs and archive libraries.IDREF="13510" TYPE="TITLE""Using QuickStart," which briefly explains how QuickStart minimizes start-up times for executables.IDREF="94780" TYPE="TITLE""Guidelines for Using Shared Libraries," which lists points to consider when you choose library members and tune shared library code.LBL="" HELPID=""ID="47959"DSOs vs. Archive LibrariesThe following compile line creates the executable yourApp by linking with the DSOs libyours.so and with libc.so.1: cc yourApp.c -o yourApp -lyoursIf libyours.so isn't available, but the archive version libyours.a is available, that archive version is used along with libc.so.1. A significant difference exists between DSOs and archive libraries in terms of what is mapped into the address space when an application is executing. With an archive library, only the text portion of the library that the application actually requires (and the data associated with that text) is mapped, not the entire library. In contrast, the entire DSO that's linked is mapped; in many cases, however, the DSO is shared and already mapped into the address space. Thus, to conserve address space and save time at startup, don't link with DSOs unless your application actually needs them.Avoid listing any archive libraries on the compile line after you list shared libraries; instead, list the archive libraries first and then the DSOs. LBL="" HELPID=""ID="13510"Using QuickStartYou may want to take advantage of the QuickStart optimization that minimizes start-up times for executables. You can use QuickStart when using or building DSOs. At link time, when an executable or a DSO is being created, the linker ld assigns initial addresses to the object and attempts to resolve all references. Since DSOs are relocatable, these initial address assignments are really only guesses about where the object will be really loaded. At run time, rld verifies that the DSO being used is the same one that was linked with and what the real addresses are. If the DSOs are the same and if the addresses match the initial assignments, rld doesn't have to perform any relocation work, and the application starts up very quickly (or QuickStarts). When an application QuickStarts, memory use is less since rld doesn't have to read in the information necessary to perform relocations. To determine whether your application (or DSO) is able to do a QuickStart, use the ­quickstart_info flag when building the executable (or DSO). If the application or DSO can't do a QuickStart, you'll be given information about what to do. The next section goes into more detail about why an executable may not be able to use QuickStart. In summary, when you use DSOs to build an executable,link with only the DSOs that you needmake sure that unshared libraries precede DSOs on the compile lineuse the ­quickstart_info flagLBL="" HELPID=""ID="94780"Guidelines for Using Shared LibrariesWhen you're working with DSOs, you can avoid some common pitfalls if you adhere to the guidelines described in this section:ID="03.dso5"IDREF="36216" TYPE="TITLE""Choosing Library Members" explains what routines to include and exclude when you choose library members.IDREF="68504" TYPE="TITLE""Tuning Shared Library Code" covers how to tune shared library code by minimizing global data, improving locality, and aligning for paging.LBL="" HELPID=""ID="36216"Choosing Library MembersThis section covers some important considerations for choosing library members. Specifically, it explains the following topics:ID="03.dso6"Include large, frequently used routinesExclude infrequently used routinesExclude routines that use much static dataMake libraries self-containedInclude Large, Frequently Used Routines. These routines are prime candidates for sharing. Placing them in a shared library saves code space for individual a.out files and saves memory, too, when several concurrent processes need the same code. printf(3S) and related C library routines are good examples of large, frequently used routines.Exclude Infrequently Used Routines. Putting these routines in a shared library can degrade performance, particularly on paging systems. Traditional a.out files contain all code they need at run time. By definition, the code in an a.out file is (at least distantly) related to the process. Therefore, if a process calls a function, it may already be in memory because of its proximity to other text in the process.If the function is in the shared library, a page fault may be more likely to occur, because the surrounding library code may be unrelated to the calling process. Only rarely will any single a.out file use everything in the shared C library. If a shared library has unrelated functions, and unrelated processes make random calls to those functions, the locality of reference may be decreased. The decreased locality may cause more paging activity and, thereby, decrease performance. Exclude Routines that Use Much Static Data. These modules increase the size of processes. Every process that uses a shared library gets its own private copy of the library's data, regardless of how much of the data is needed. Library data is static: it isn't shared and can't be loaded selectively with the provision that unreferenced pages may be removed from the working set.For example, getgrent(3C) is not used by many standard UNIX commands. Some versions of the module define over 1400 bytes of unshared, static data. So, do not include it in a shared library. You can import global data, if necessary, but not local, static data.Make Libraries Self-Contained. It's best to make the library self-contained. You can do this by including routines in the shared object. For example, printf(3S) requires much of the standard I/O library. A shared library containing printf(3S), should also contain the rest of the standard I/O routines. This is done with libc.so.1.If your shared object calls routines from a different shared object, it is best to build in this dependency by naming the needed shared objects on the link line in the usual way. For example:ld -shared -all mylib.a -o mylib.so -lfooThis command line specifies that libfoo.so is needed by mylib.so. Thus, when an application is linked against mylib.so, it is not necessary to specify -lfoo.This guideline should not take priority over the others in this section. If you exclude some routine that the library itself needs based on a previous guideline, consider leaving the symbol out of the library and importing it.LBL="" HELPID=""ID="68504"Tuning Shared Library CodeThis section explains a few things to consider in tuning shared library code:ID="03.dso7"Minimize global dataOrganize to Improve localityAlign for pagingMinimize Global Data. All external data symbols are, of course, visible to applications. This can make maintenance difficult. Therefore, you should try to reduce global data.Try to use automatic (stack) variables. Don't use permanent storage if automatic variables work. Using automatic variables saves static data space and reduces the number of symbols visible to application processes.Determine whether variables really must be external. Static symbols are not visible outside the library, so they may change addresses between library versions. Only external variables must remain constant.Allocate buffers at run time instead of defining them at compile time. Allocating buffers at run time reduces the size of the library's data region for all processes and, thus, saves memory. Only processes that actually need the buffers get them. It also allows the size of the buffer to change from one release to the next without affecting compatibility. Statically allocated buffers cannot change size without affecting the addresses of other symbols and, perhaps, breaking compatibility.Organize to Improve Locality. When a function is in a.out files, it typically resides in a page with other code that is used more often (see "Exclude Infrequently Used Routines"). Try to improve locality of reference by grouping dynamically related functions. If every call of funcA generates calls to funcB and funcC, try to put them in the same page. The cord(1) command rearranges procedures to reduce paging and achieve better instruction cache mapping. You can use cord to see the number of cycles spent in a procedure and the number of times the procedure was executed. The cflow(1) command generates static dependency information. You can combine it with profiling to see what is actually called, as opposed to what may be called.Align for Paging. The key is to arrange the shared library target's object files so that frequently used functions don't unnecessarily cross page boundaries. When arranging object files within the target library, be sure to keep the text and data files separate. You can reorder text object files without breaking compatibility; the same is not true for object files that define global data. For example, the IRIX 5.x operating system currently uses 4Kb pages. Using name lists and disassemblies of the shared library target file, the library developers determined where the page boundaries fell.After grouping related functions, they broke them into page-sized chunks. Although some object files and functions are larger than a single page, most of them are smaller. Then the developers used the infrequently called functions as glue between the chunks. Because the glue between pages is referenced less frequently than the page contents, the probability of a page fault decreased.After determining the branch table, they rearranged the library's object files without breaking compatibility. The developers put frequently used, unrelated functions together, because they would be called randomly enough to keep the pages in memory. System calls went into another page as a group, and so on. For example, the order of the library's object files became: Before                        After#objects        #objects    ...   .          ...   printf.o         trcmp.o   fopen.o          malloc.o    malloc.o         printf.o   strcmp.o         fopen.o   ...  .           ...LBL="" HELPID=""ID="51258"Taking Advantage of QuickStartQuickStart is an optimization designed to reduce start-up times for applications that link with DSOs. Each time ID="03.dso8"ld builds a DSO, it updates a registry of shared objects. The registry contains the preassigned QuickStart addresses of a group of DSOs that typically cooperate by having nonoverlapping locations. (See ID="03.dso9"IDREF="28419" TYPE="TITLE""Using Registry Files" for more information about how to use the registry when you're building a DSO.) If you compile your application by linking with registered DSOs, your application takes advantage of QuickStart: all the DSOs are mapped at their QuickStart addresses, and rld won't need to move any of them to an unused address and perform a relocation pass to resolve all references. Suppose you compile your application using the ­quickstart_info flag, and Quickstart fails. It may fail because:Your application has directly or indirectly linked with two different versions of the same DSO, as shown in IDREF="10676" TYPE="GRAPHIC"Figure 3-1. In this example, yourApp links with libyours.so, libmotif.so, and libc.so.1 on the compile line. When the DSO libyours.so was built, however, it linked with libmalloc.so, which in turn linked with libc.so.1 when it was created. If the two versions of libc.so.1 weren't identical, yourApp won't be able to use QuickStart. FILE="3.1.link.dso.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-1"Figure 3-1 ID="10676"An Application Linked with DSOsYou link with a DSO that can't use QuickStart. This may occur because the DSO wasn't registered and therefore was assigned a location that overlaps with the location assigned to another DSO. Your application pulls in incompatible shared objects (in a manner similar to the example shown in IDREF="10676" TYPE="GRAPHIC"Figure 3-1).Your application contains an unresolved reference to a function (where it takes the address of the function).The DSO links with another DSO that can't use QuickStart.Even if QuickStart officially succeeds, your application may have name space collisions and therefore may not start up as fast as it should. This is because rld has to bring in more information to resolve the conflicts. In general, you should avoid having conflicts both because of the detrimental effect on start-up time and because conflicts make it difficult to ensure the correctness of an application over time. In the example shown in IDREF="10676" TYPE="GRAPHIC"Figure 3-1, you may have written your own functions to allocate memory in libmalloc.so for libyours.so to use. If you didn't use unique names for those functions (instead of malloc(), for example) the way this particular compile and link hierarchy is set up, the standard malloc() function defined in libc.so.1 is used instead of the one defined in libmalloc.so. For example, suppose the diagram in Figure 3-3 corresponds to the following command:cc -lyours -lmotif -lcSince shared objects mentioned on the command line always take precedence over those that are not mentioned, the command above uses the standard malloc() defined in libc.so.1. To get your own version of malloc() defined in libmalloc.so for libyours.so to use, enter:cc -lyours -motif -malloc -lcHowever, in both of the above examples, if lyours contains malloc(), you'll get that malloc(). (In the examples above, you do not need to specify ­lc; it was added for clarity). Note that conflicts are resolved by proceeding through the hierarchy from left to right and then moving to the next level. See IDREF="38618" TYPE="TITLE""Searching for DSOs at Run Time" for more information about how the run-time linker searches for DSOs.Thus, it's not a good idea to allow more than one DSO to define the same function. Even if the DSOs are synchronized for their first release, one of them may change the definition of the function in a subsequent release. Of course, you can use conflicts to intentionally override function definitions; however, make sure you control what is overriding what. If you use theID="03.dso10" ­quickstart_info option, ld tells you if conflicts arise. It also tells you to run elfdump with the ­Dc option to find the conflicts. See the elfdump(5) reference page for more information about how to read the output produced by elfdump. LBL="" HELPID=""ID="86160"Building DSOsID="03.dso11"In most cases, you can build DSOs as easily as archive libraries. If your library is written in a high-level language, such as C or Fortran, you won't have to make any changes to the source code. If your code is written in assembly language, you must modify it to produce PIC. This is described in "Position-Independent Coding in Assembly Language" in the ID="03.dso12"MIPSpro Assembly Language Programmer's Guide.This section covers procedures to use when you build DSOs, and includes these topics:IDREF="71475" TYPE="TITLE""Creating DSOs"IDREF="59518" TYPE="TITLE""Making DSOs Self-Contained"IDREF="17680" TYPE="TITLE""Controlling Symbols to Be Exported or Loaded"IDREF="82974" TYPE="TITLE""Using DSOs With C++"IDREF="28419" TYPE="TITLE""Using Registry Files"LBL="" HELPID=""ID="71475"Creating DSOsTo create a DSO from a set of object files, use ID="03.dso13"ld with the ­shared option:ld ­shared stuff.o nonsense.o ­o libdada.so The above example creates a DSO, libdada.so, from two object files, stuff.o and nonsense.o. Note that DSO names should begin with "ID="03.dso14"lib" and end with ".so", for ease of use with the compiler driver's ­llib argument. If you're already building an archive library (.a file), you can create a DSO from the library by using the ­shared and ­all arguments to ld:ld ­shared ­all libdada.a ­o libdada.soThe ­all argument specifies that all of the object files from the library, libdada.a, should be included in the DSO.LBL="" HELPID=""ID="59518"Making DSOs Self-ContainedWhen building a DSO, be sure to include any archives required by the DSO on the link line so that the DSO is self-contained (that is, it has no unresolved symbols). If the DSO depends on libraries not explicitly named on the link line, subsequent changes to any of those libraries may result in name space collisions or other incompatibilities that can prevent any applications that use the DSO from doing a QuickStart. Such incompatibilities can also lead to unpredictable results over time as the libraries change asynchronously. Suppose you want to make the archive libmine.a into a DSO, and libmine.a depends on routines in another archive, libutil.a. In this case, include libutil.a on the link line:ld ­shared ­all -no_unresolved libmine.a ­o libmine.so -none libutil.aThis causes the modules in libutil.a that are referenced in libmine.a to be included in the DSO, but these modules won't be exported. (For more information about exported symbols, see IDREF="17680" TYPE="TITLE""Controlling Symbols to Be Exported or Loaded.") The ­no_unresolved option causes a list of unresolved symbols to be created; generally, this list should be empty to enable using QuickStart. Similarly, if a DSO relies on another DSO, be sure to include that DSO on the link line. For example:ld ­shared ­all -no_unresolved libbtree.a ­o libtree.so ­lyoursThis example places libyours.so in the liblist of the new DSO, libtree.so. This ensures that libyours.so is loaded whenever an executable that uses libtree.so is launched. Again, symbols from libyours.so won't be exported for use by other libraries. (You can use the ­exports flag to reverse this exporting behavior; the ­hides flag specifies the default exporting behavior.)LBL="" HELPID=""ID="17680"Controlling Symbols to Be Exported or LoadedBy default, to help avoid conflicts, symbols defined in an archive or a DSO that's used to build another DSO aren't externally visible. You can explicitly export or hide symbols with the ID="03.dso15"ID="03.dso16"­exported_symbol and ­hidden_symbol options:-exported_symbol name1, name2, name3 
-hidden_symbol name4, name5By default, if you explicitly export any symbols, all other symbols are hidden. If you both explicitly export and explicitly hide the same symbol on the link line, the first occurrence determines the behavior. You can also create a file of symbol names (delimited by white space) that you want explicitly exported or hidden, and then refer to the file on the link line with either the -exports_file or -hiddens_file option:-exports_file yourFile 
-hiddens_file anotherFileThese files can be used in addition to explicitly naming symbols on the link line.Another useful option, ­delay_load, prevents a library from being loaded until it's actually referenced. Suppose, for example, that your DSO contains several functions that are likely to be used in only a few instances. Furthermore, those functions rely on another library (archive or DSO). If you specify ­delay_load for this other library when you build your DSO, the run-time linker loads that library only when those few functions that require it are used. Note that if you explicitly export any symbols defined in a library that the run-time linker is supposed to delay loading, the export behavior takes precedence and the library is automatically loaded at run time. Delay-loaded shared objects do not function properly if direct references to data symbols exist in the delay-loaded object, or if the address of the function in the delay-loaded object is used. Therefore, only use ­delay_load to load shared objects that have a purely functional interface.NoteYou can build DSOs using cc. However, if you want to export symbols/files or use ­delay_load, use ld to build DSOs. LBL="" HELPID=""ID="82974"Using DSOs With C++To make a DSO, build the C++ objects as you would normally:ID="03.dso17"CC -cThen type:CC -shared -o libmylib.so <list your objects here>For example:CC -shared -o libmylib.so a.o b.o c.oThe CC driver passes the ID="03.dso18"­l and ­L options to ld. However, the CC driver doesn't pass most ld options. If you want to specify other options, first determine the options that you must pass to ld via a direct invocation. These options include:-init _main
-fini _fini
-hidden_symbol _main
-hidden_symbol _fini
-hidden_symbol __head
-hidden_symbol __endlinkAlso, you must link /usr/lib/c++init.o. To add ­delay_load ­lbother, for example, the result is similar to the following:ld -shared
-o libmylib.so
a.o b.o c.o
/usr/lib/c++init.o
-fini _fini
-hidden_symbol _main
-hidden_symbol _fini
-hidden_symbol __head
-hidden_symbol __endlink
-delay_load
-delay_load -lbotherLBL="" HELPID=""ID="28419"Using Registry FilesYou can make sure that your DSOs don't conflict with each other by using a QuickStart registry file. The registry files contain location information for shared objects. When creating a shared object, you can specify a registry file to ID="03.dso19"ID="03.dso20"ld, and ld ensures that your shared object doesn't conflict with any of the shared objects listed in the registry. A registry file containing the locations of all the shared objects provided with the system is supplied in /usr/lib/so_locations.You can use two options to ID="03.dso21"ld to specify a registry file: ­check_registry and ­update_registry. When you invoke ld to build a shared object, with the argument ­check_registryfile, ld makes sure that the new shared object doesn't conflict with any of the shared objects listed in file. When invoked with ­update_registryfile, ld checks the registry in the same way, but when it's done, it writes an entry in file for the DSO being built. If file isn't writable, ­update_registry acts like ­check_registry. If file isn't readable, both ­update_registry and ­check_registry are ignored.By exchanging registry files, providers of DSOs can avoid collisions between their shared objects. It's best to start with a copy of /usr/lib/so_locations, so that your shared objects don't conflict with any of the standard DSOs. However, remember that when collisions occur between shared objects, the only effect is slowing program startup.LBL="" HELPID=""Registry File FormatThree types of lines in the registry file include:comment lines, which begin with a pound sign (#)directive lines, which begin with a dollar sign ($)shared object specification lines, which begin with the name of a shared objectComment lines are ignored by ld. Directive lines and shared object specification lines are described below.LBL="" HELPID=""Directive LinesDirective lines specify global parameters that apply to all the DSOs listed in the registry.$text_align_size=align padding=pad-size
$data_align_size=align padding=pad-sizeThese two directives specify the alignment and padding requirements for text and data segments, respectively. The current default segment alignment is 64K, which is the minimum permissible. The size value of a segment of a DSO appearing in the registry file is calculated based on the actual section size plus padding, and is aligned to the section align size (either the default or the one specified by the above directive). The align values for text and data as well as the padding values must be aligned to the minimum alignment size (64K). If not, ld generates a warning message and aligns these values to the minimum alignment.$start_address=addrThis directive specifies where to start looking for addresses to put shared objects. The default start_address is 0x6000000.$data_after_text={ 1 | 0 }In this directive, a value of one instructs the linker to place data immediately after the text at specified text and data alignment requirements. A value of zero (the default) allows the linker to place these segments in different portions of the address space.LBL="" HELPID=""Shared Object Specification LinesShared object specification lines have the following format:so_name [ :st = {.text | .data | $range} base_addr,padded_size : ] *where:so_namefull path name (or trailing component) of a shared object:st =literal string indicating the beginning of the segment description.text, .datasegment types: text or data$rangerange of addresses that can be usedbase_addraddress where the segment startspadded_sizepadded size of the segment:literal string indicating the end of the segment descriptionA shared object specification can span several lines by "escaping" the newline character (using "\" as the last character on the line that is being continued). The following is an example of a shared object specification line:libc.so.1 \
           :st = $range 0x5fc00000, 0x00400000:\
           :st = .text 0x5fe40000, 0x000a0000:\
           :st = .data 0x5fee0000, 0x00030000:This specification instructs ld to relocate all segments of libc.so.1 in the range 0x5fc00000 to 0x5fc00000+0x0040000, and, if possible, to place the text segment at 0x5fe40000 and the data segment at 0x5fee0000. The text segment should be padded to 0xa0000 bytes and the data segment to 0x3000 bytes. See /usr/lib/so_locations for examples of shared object specifications.When building a DSO with the ­check_registry or ­update_registry flag, if an entry corresponding to this DSO exists in the registry file, the linker tries to assign the indicated addresses for text and data. However, if the size of the DSO changes and no longer fits in the specified location, the linker searches for another location that fits. If the $range option is specified, the linker places the DSO only in the specified range of addresses. If there isn't enough room, an error is returned. LBL="" HELPID=""ID="17473"Run-Time LinkingThis section explains the search path followed by the run-time linker and how you can cause symbols to be resolved at run time rather than link time. Specifically, this section describes:IDREF="38618" TYPE="TITLE""Searching for DSOs at Run Time"IDREF="88104" TYPE="TITLE""Run-Time Symbol Resolution"LBL="" HELPID=""ID="38618"Searching for DSOs at Run TimeWhen you run a dynamically linked executable, the run-time linker, rld, identifies the DSOs required by the executable, loads the required DSOs, and if necessary relocates DSOs within the process's virtual address space, so that no two DSOs occupy the same location.The program header of a dynamically linked executable contains a field, the liblist, which lists the DSOs required by the executable. When looking for a DSO, ID="03.dso22"rld searches directories in the following sequence:the path of the DSO in the liblist (if an explicit path is given)RPATH if it's defined in the main executableLD_LIBRARY_PATH if definedthe default path (/usr/lib:/lib)RPATH is a colon-separated list of directories stored in the main executable. You can set RPATH by using the ­rpath argument to ld:ld ­o myprog myprog.c ­rpath /d/src/mylib libmylib.so ­lcThis example links the program against libmylib.so in the current directory, and configures the executable such that rld searches the directory /d/src/mylib when searching for DSOs.The LD_LIBRARY_PATH environment variable is a colon-separated list of directories to search for DSOs. This can be very useful for testing new versions of DSOs before installing them in their final location. You can set the environment variable _RLD_ROOT to a colon-separated list of directories. The run-time linker prepends these to the paths in RPATH and the paths in the default search path. In all of the colon-separated directory lists, an empty field is interpreted as the current directory. A leading or trailing colon counts as an empty field. Thus, if you set LD_LIBRARY_PATH to:/d/src/lib1:/d/src/lib2:the run-time linker searches the directory /d/src/lib1, then the directory /d/src/lib2, and then the current directory. NoteFor security reasons, if an executable has its set-user-ID or set-group-ID bits set, the run-time linker ignores the environment variables LD_LIBRARY_PATH and _RLD_ROOT. However, it still searches the directories in RPATH and the default path. LBL="" HELPID=""ID="88104"Run-Time Symbol ResolutionDynamically linked executables can contain symbol references that aren't resolved before run time. Any symbol references in your main program or in an archive must be resolved at link time, unless you specify the ­ignore_unresolved argument to cc. DSOs may contain references that aren't resolved at link time. All data symbols must be resolved at run time. If rld finds an unresolvable data symbol at run time, it will cause the executable to exit with an error. Text symbols are resolved only when they're used, so a program can run with unresolved text symbols, as long as the unresolved symbols aren't used.You can force rld to resolve text symbols at run time by setting the environment variable LD_BIND_NOW. If unresolvable text symbols exist in your executable and LD_BIND_NOW is set, the executable will exit with an error, just as if there were unresolvable data symbols.ID="03.dso23"ID="03.dso24"LBL="" HELPID=""Compiling with ­BsymbolicWhen you compile a DSO with ID="03.dso25"­Bsymbolic, the dynamic linker resolves referenced symbols from itself first. If the shared object fails to supply the referenced symbol, then the dynamic linker searches the executable file and other shared objects. For example:mainname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'defines xx.soname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'defines and uses xIf you compile x.so with ­Bsymbolic on, the linker tries to resolve the use of x by looking first for the definition in x.so and then by looking in main.In FORTRAN programs, the linker allocates space for ID="03.dso26"COMMON symbols and the compiler allocates space for ID="03.dso27"BLOCK DATA. The first kind of symbol (with COMMON blocks present) appears in the symbol table as SHN_MIPS_ACOMMON (uninitialized DATA) whereas the second kind of symbol (with BLOCK DATA present) appears as SHN_DATA (initialized DATA). In general, initialized data takes precedence when the dynamic linker tries to resolve a symbol. However, with ­Bsymbolic, whatever is defined in the current object takes precedence, whether it is initialized or uninitialized. Variables that are declared at file scope in C with ­cckr are also treated this way. For example:int foo[100];is COMMON if ­cckr is used and DATA if ­xansi or ­ansi is used.For example:In main:COMMON i, j /* definition of i, j with initial values */
DATA i/1/, j/1/
CALL junk
END
In x.so:SUBROUTINE junk
COMMON i, j
/* definition of i, j with NO initial values */
/* initialized by kernel to all zeros */
PRINT *, i, j
ENDWhen you build x.so using ­Bsymbolic, this program prints 0 0. When you build x.so without ­Bsymbolic, the program prints 11.LBL="" HELPID=""Converting Libraries to DSOsWhen you link a program with a DSO, all of the symbols in the DSO become associated with the executable. This can cause unexpected results if archives that contain unresolved externals are converted to DSOs. When linking with a PIC archive, the linker links in only those object files that satisfy unresolved references. ID="03.dso28"If an object file in an archive contains an unresolved external reference, the linker tries to resolve the reference only when that object file is linked in to your program. In contrast, a DSO containing an external data reference that cannot be resolved at run time causes the program to fail. Therefore, use caution when converting archives with external data references to DSOs.For example, suppose you have an archive, mylib.a, and one of the object files in the archive, has_extern.o, references an external variable, foo. As long as your program doesn't reference any symbols in has_extern.o, the program will link and run properly. If your program references a symbol in has_extern.o and doesn't define foo, then the link will fail. However, if you convert mylib.a to a DSO, then any program that uses the DSO and doesn't define foo will fail at run time, regardless of whether the program references any symbols from has_extern.o.Two possible solutions exist for this problem. Add a "dummy" definition of the data to the DSO. A data definition appearing in the main executable preempts one appearing in the DSO itself. This may, however, be misleading for executables that use the portion of the DSO that needs the data, but that failed to define it in the main program. Separate the routines that use the data definition into a second DSO, and place dummy functions for them in the first DSO. The second DSO can then be loaded dynamically the first time any of the dummy functions is accessed. Each of the dummy functions must verify that the second DSO was loaded before calling the real function (which must have a unique name). This way, programs run whether or not they supply the missing external data, as long as they don't call any of the functions that require the data. The first time one of the dummy functions is called, it tries to dynamically load the second DSO. Programs that do not supply the missing data fail at this point. For more information on dynamic loading, see IDREF="92334" TYPE="TITLE""Dynamic Loading Under Program Control" below.LBL="" HELPID=""ID="92334"Dynamic Loading Under Program ControlIRIX provides a library interface to the run-time linker that allows programs to load and unload DSOs dynamically. The functions in this interface are part of ID="03.dso29"libc (see IDREF="60563" TYPE="TABLE"Table 3-1).COLUMNS="2"LBL="3-1"Table 3-1 ID="60563" Functions to Load/Unload DSOsLEFT="0" WIDTH="54"dlopen()LEFT="60" WIDTH="127"Load a DSOLEFT="0" WIDTH="54"dlsym()LEFT="60" WIDTH="127"Find a symbol in a loaded DSOLEFT="0" WIDTH="54"dlclose()LEFT="60" WIDTH="127"Unload a DSOLEFT="0" WIDTH="54"dlerror()LEFT="60" WIDTH="127"Report errorsTo load a DSO, call ID="03.dso30"dlopen():include <dlfcn.h>
void *dlhandle;
   ..
dlhandle = dlopen("/usr/lib/mylib.so", RTLD_LAZY);
if (dlhandle == NULL) {
   /* couldn't open DSO */
   printf("Error: %s\n", dlerror());
}The first argument to dlopen() is the pathname of the DSO to be loaded. This may be either an absolute or a relative pathname. When you call this routine, the run-time linker tries to load the specified DSO. If any unresolved references exist in the executable that are defined in the DSO, the run-time linker resolves these references on demand. You can also use dlsym() to access symbols in the DSO, whether or not the symbols are referenced in your executable.When a DSO is brought into the address space of a process, it may contain references to symbols whose addresses are not known until the object is loaded. These references must be relocated before the symbols can be accessed. The second argument to dlopen() governs when these relocations take place. This argument can have the following values: RTLD_LAZY Under this mode, only references to data symbols are relocated when the object is loaded. References to functions are not relocated until a given function is invoked for the first time. This mode may result in better performance, since a process may not reference all of the functions in any given shared object. RTLD_NOW Under this mode, all necessary relocations are performed when the object is first loaded. This may result in some wasted effort if relocations are performed for functions that are never referenced. However, this option is useful for applications that need to know as soon as an object is loaded that all symbols referenced during execution will be available.You can also dynamically load shared objects by using ID="03.dso31"sgidladd(), which is similar to dlopen(). However, unlike dlopen(), all the names in the shared object become available to satisfy references in shared objects during lazy text resolution. Furthermore, it's not necessary to use dlsym() to gain access to the symbols in the shared object. sgidladd() is available as part of libc. For more information, see the sgidladd(3) reference page.To access symbols that are not referenced in your program, use ID="03.dso32"dlsym():#include <dlfcn.h>
void *dlhandle;
int (*funcptr)(int);
int i,j;
   .. load DSO ... 
funcptr = (int (*)(int)) dlsym(dlhandle, "factorial");
if (funcptr == NULL) {
   /* couldn't locate the symbol */
   exit();
}
i = (*funcptr)(j);This example looks up the address of the function factorial() and assigns it to the function pointer funcptr.If you encounter an error (ID="03.dso33"dlopen() or dlsym() returns NULL), you can get diagnostic information by calling dlerror(). The dlerror() function returns a string describing the cause of the latest error. You should call dlerror() only after an error has occurred; at other times, its return value is undefined.To unload a DSO, call ID="03.dso34"dlclose():#include <dlfcn.h>
void *dlhandle;
... load DSO, use DSO symbols ...
dlclose(dlhandle);The ID="03.dso35"dlclose function frees up the virtual address space that has been ID="03.dso36"mmaped by the dlopen call of that file (similar to a munmap call). The difference, however, is that a dlclose on a file that has been opened multiple times (either through dlopen or program startup) does not cause the file to be munmaped until the file is no longer needed by the process. LBL="" HELPID=""ID="50766"Versioning of DSOsThis section describes the DSO versioning mechanism of Silicon Graphics and includes the following topics:IDREF="69072" TYPE="TITLE""The Versioning Mechanism"IDREF="53034" TYPE="TITLE""What Is a Version?"IDREF="42164" TYPE="TITLE""Building a Shared Library Using Versioning"IDREF="33711" TYPE="TITLE""Example of Versioning"LBL="" HELPID=""ID="69072"The Versioning MechanismIn the IRIX 5.0.1 release, a mechanism for the versioning of shared objects was introduced for the Silicon Graphics shared objects and executables. Note that this mechanism is outside the scope of the MIPS ABI, and, thus, must not be relied on for code that must be MIPS ABI-compliant and run on other vendors' platforms. Currently, all executables produced on Silicon Graphics systems are marked SGI_ONLY to allow use of the versioning mechanism.ID="03.dso37"Versioning is of interest mainly to developers of shared objects. It may not be of interest to you if you simply use shared objects. Versioning allows a developer to update a shared object in a way that may be incompatible with executables previously linked against the shared object. You can accomplish this by renaming the original shared object and providing it along with the (incompatible) new version.LBL="" HELPID=""ID="53034"What Is a Version?A version is part or all of an identifying version_string that can be associated with a shared object by using the ­set_versionversion_string option to ld(1) when the shared object is created. A version_string consists of one or more versions separated by colons (:). A single version has the form:[comment#]sgimajor.minorwhere:commentis a comment string, which is ignored by the versioning mechanism. It consists of any sequence of characters followed by a pound sign (#). The comment is optional.sgiis the literal string sgi.majoris the major version number, which is a string of digits [0-9]. .is a literal period.minoris the minor version number, which is a string of digits [0-9]. LBL="" HELPID=""ID="42164"Building a Shared Library Using VersioningFollow these instructions when building your shared library:When you first build your shared library, give it an initial version, for example, sgi1.0. Add the option ­set_version sgi1.0 to the command to build your shared library (cc­shared, ld­shared).Whenever you make a compatible change to the shared object, create another version by changing the minor version number (for example, sgi1.1) and add it to the end of the version_string. The command to set the version of the shared library now looks like ­set_version "sgi1.0:sgi1.1".When you make an incompatible change to the shared object:Change the filename of the old shared object by adding a dot followed by the major number of one of the versions to the filename of the shared object. Do not change the soname of the shared object or its contents. Simply rename the file.Update the major version number and set the version_string of the shared object (when you create it) to this new version; for example, ­set_version sgi2.0. This versioning mechanism affects executables in the following ways:When an executable is linked against a shared object, the last version in the shared object's version_string is recorded in the executable as part of the liblist. You can examine this using elfdump­Dl.When you run an executable, rld looks for the proper filename in its usual search routine.If a file is found with the correct name, the version specified in the executable for this shared object is compared to each of the versions in the version_string in the shared object. If one of the versions in the version_string matches the executable's version exactly (ignoring comments), then that library is used.If no proper match is found, a new filename for the shared object is built by combining the soname specified in the executable for this shared object and the major number found in the version specified in the executable for this shared object (soname.major). Remember that you did not change the soname of the object, only the filename. The new file is searched for using rld's usual search procedure.LBL="" HELPID=""ID="33711"Example of VersioningFor example, suppose you have a shared object foo.so with initial version sgi10.0. Over time, you make two compatible changes for foo.so that result in the following final version_string for foo.so:initial_version#sgi10.0:upgrade#sgi10.1:new_devices#sgi10.2You then link an executable that uses this shared object, useoldfoo. This executable specifies version sgi10.2 for sonamefoo.so. (Remember that the executable inherits the last version in the version_string of the shared object.) The time comes to upgrade foo.so in an incompatible way. Note that the major version of foo.so is 10, so you move the existing foo.so to the filename foo.so.10 and create a new foo.so with the version_string:efficient_interfaces#sgi11.0New executables linked with foo.so use it directly. Older executables, like useoldfoo, attempt to use foo.so, but find that its version (sgi11.0) is not the version they need (sgi10.2). They then attempt to find a foo.so in the filename foo.so.10 with version sgi10.2.NoteWhen a needed DSO has its interface changed, then a new version is created. If the interface change is not compatible with older versions, then a consuming shared object needs incompatible versions in order to use the new version, even if it doesn't use that part of the interface that is changed.LBL="4"ID="15323"Optimizing Program PerformanceThis chapter describes the compiler optimization facilities and their benefits, and explains the major optimizing techniques. Topics covered include:ID="04.optimize1"IDREF="25697" TYPE="TITLE""Optimization Overview"IDREF="12257" TYPE="TITLE""Using the Optimization Options"IDREF="70781" TYPE="TITLE""Performance Tuning with Interprocedural Analysis"IDREF="72831" TYPE="TITLE""Controlling Loop Nest Optimizations"IDREF="71027" TYPE="TITLE""Controlling Floating Point Optimization"IDREF="43553" TYPE="TITLE""The Code Generator"IDREF="76821" TYPE="TITLE""Controlling the Target Architecture"IDREF="20051" TYPE="TITLE""Controlling the Target Environment"IDREF="88275" TYPE="TITLE""Improving Global Optimization"NotePlease see the Release Notes and reference page for your compiler for a complete list of options that you can use to optimize and tune your program.You can find additional information about optimization in MIPSpro 64-Bit Porting and Transition Guide, Chapter 6, "Performance Tuning." For information about writing code for 64-bit programs, see IDREF="67459" TYPE="TITLE"Chapter 5, "Coding for 64-Bit Programs." For information about porting code to N32 and 64-bit systems, see IDREF="72950" TYPE="TITLE"Chapter 6, "Porting Code to N32 and 64-Bit Silicon Graphics Systems."LBL="" HELPID=""ID="25697"Optimization OverviewThis section covers optimization benefits and debugging.LBL="" HELPID=""Benefits of OptimizationThe primary benefits of optimization are faster running programs and often smaller object code size. However, the optimizer can also speed up development time. For example, you can reduce coding time by leaving it up to the optimizer to relate programming details to execution time efficiency. You can focus on the more crucial global structure of your program. Moreover, programs often yield optimizable code sequences regardless of how well you write your source program.ID="04.optimize2"LBL="" HELPID=""Optimization and DebuggingOptimize your programs only when they are fully developed and debugged. The optimizer may move operations around so that the object code does not correspond in an obvious way to the source code. These changed sequences of code can create confusion when using a debugger. For information on the debugger, see ID="04.optimize3"dbx User's Guide. LBL="" HELPID=""ID="12257"Using the Optimization OptionsThis section lists and briefly describes the optimization options, ­O0 through ­O3.Invoke the optimizer by specifying a compiler, such as ID="04.optimize4"cc(1), with any of the options listed in IDREF="40504" TYPE="TABLE"Table 4-1.COLUMNS="2"LBL="4-1"Table 4-1  (continued)        Optimization OptionsID="40504"LEFT="0" WIDTH="61" OptionLEFT="70" WIDTH="270"ResultLEFT="0" WIDTH="61"­O0LEFT="70" WIDTH="270"Performs no optimization that may complicate debugging. No 
attempt is made to minimize memory access by keeping values in 
registers, and little or no attempt is made to eliminate redundant 
code. This is the default.ID="04.optimize5"LEFT="0" WIDTH="61"­O1LEFT="70" WIDTH="270"Performs as many local optimizations as possible without affecting 
compile-time performance. No attempt is made to minimize 
memory access by keeping values in registers, but much of the 
locally redundant code is removed.ID="04.optimize6"LEFT="0" WIDTH="61"­O2, ­OLEFT="70" WIDTH="270"Performs extensive global optimization. The optimizations at this 
level are generally conservative in the sense that they:(1) provide code improvements commensurate with the compile 
time spent(2) are almost always beneficial(3) avoid changes that affect such things as floating point resultsID="04.optimize7"LEFT="0" WIDTH="61"­O3LEFT="70" WIDTH="270"Performs aggressive optimization. The additional optimization at 
this level focuses on maximizing code quality even if that requires 
extensive compile time or relaxing language rules. ID="04.optimize8"­O3 is more 
likely to use transformations that are usually beneficial but can hurt 
performance in isolated cases. This level may cause noticeable 
changes in floating point results due to relaxing expression 
evaluation rules (see the discussion of floating point optimization 
and the ­OPT:roundoff=2 option below).Refer to your compiler's reference page and Release Notes for details on the optimization options and all other options. LBL="" HELPID=""ID="70781"Performance Tuning with Interprocedural AnalysisInterprocedural Analysis (IPA) performs program optimizations that can only be done in the presence of the whole program. Some of the optimizations it performs also allow downstream phases to perform better code transformations. ID="04.optimize9"ID="04.optimize10"Currently IPA optimizes code by performing: procedure inlininginterprocedural constant propagation of formal parametersdead function eliminationidentification of global constantsdead variable eliminationpic optimizationautomatic selection of candidates for the gp-relative area (autognum)dead call eliminationautomatic internal padding of COMMON arrays in Fortraninterprocedural alias analysisIDREF="51694" TYPE="GRAPHIC"Figure 4-1 shows interprocedural analysis and interprocedural optimization phase of the compilation process. FILE="4.1.ipa.diagram.gif" POSITION="INLINE" SCALE="FALSE"LBL="4-1"Figure 4-1 ID="51694"Compilation Process Showing Interprocedural Analysis Typically, you invoke IPA with the ­IPA: option group to f77, cc, CC, and ld. Its inlining decisions are also controlled by the ­INLINE: option group. Up-to-date information on IPA and its options is in the ipa(5) reference page.This section covers some IPA options including:IDREF="60481" TYPE="TITLE""Inlining"IDREF="17185" TYPE="TITLE""Common Block Padding"IDREF="77214" TYPE="TITLE""Alias and Address Taken Analysis"LBL="" HELPID=""ID="60481"InliningIPA performs across and within file inlining. A default inlining heuristic determines which calls to inline. This section covers the following information:IDREF="64495" TYPE="TITLE""Benefits of Inlining"IDREF="41630" TYPE="TITLE""Inlining Options for Routines"IDREF="83184" TYPE="TITLE""Options To Control Inlining Heuristics"LBL="" HELPID=""ID="64495"Benefits of InliningYour code may benefit from inlining for the following reasons:ID="04.optimize11"Inlining exposes a larger context to the scalar and loop-nest optimizers, thereby allowing more optimizations to occur.Inlining eliminates overhead resulting from the call (for example, register save and restore, the call and return instructions, and so forth). Instances occur, however, when inlining may hurt run-time performance due to increased demand for registers, or compile-time performance due to code expansion. Hence extensive inlining is not always useful. You must select callsites for inlining based on certain criteria such as frequency of execution and size of the called procedure. Often it is not possible to get an accurate determination of frequency information based on compile-time analysis. As a result, inlining decisions may benefit from generating feedback and providing the feedback file to IPA. The inlining heuristic will perform better since it is able to take advantage of the available frequency information in its inlining decision. LBL="" HELPID=""ID="41630"Inlining Options for RoutinesYou may wish to select certain procedures to be inlined or not to be inlined by using any of the options listed in ID="04.optimize12"IDREF="60085" TYPE="TABLE"Table 4-2. COLUMNS="2"LBL="4-2"Table 4-2 ID="60085"Inlining Options for RoutinesLEFT="0" WIDTH="180"Inline OptionLEFT="185" WIDTH="180"DescriptionLEFT="0" WIDTH="180"­INLINE:=OFFLEFT="185" WIDTH="180"Suppresses inlining. ­IPA:inline=OFF 
also suppresses inlining. LEFT="0" WIDTH="180"­INLINE:must=... ­INLINE:never=...LEFT="185" WIDTH="180"Allows you to specify the desired action for 
specific routines.LEFT="0" WIDTH="180"­INLINE:none
­INLINE:allLEFT="185" WIDTH="180"Inlines all (or none) of the routines not 
covered by the above options.LEFT="0" WIDTH="180"­INLINE:file=<filename> LEFT="185" WIDTH="180"Provides cross-file inlining.These options are covered in more detail in the subsections below.NoteYou can use the inline keyword and pragmas in C++ or C to specifically identify routines to callsites to inline. The inliner's heuristics decides whether or not to inline any cases not covered by the ­INLINE options in the preceding table.In all cases, once a call is selected for inlining, a number of tests are applied to verify its suitability. These tests may prevent its inlining regardless of user specification, for instance if the callee is a C varargs routine, or parameter types don't match.ID="73632"The ­INLINE:none and ­INLINE:all OptionsAt call sites not marked by inlining pragmas, the compiler does not attempt to inline routines not specified with the ID="04.optimize13"must option or a routine pragma requesting inlining; it observes site inlining pragmas. At call sites not marked by inlining pragmas, the compiler attempts to inline all routines not specified with the never option or a routine pragma requesting no inlining; it observes site inlining pragmas. If you specify both all and none, none is ignored with a warning.ID="71230"The ­INLINE:must and ­INLINE:never OptionsIf ID="04.optimize14"­INLINE:must=routine_name<,routine_name>* is specified, the compiler attempts to inline the associated routines at call sites not marked by inlining pragmas, but does not inline if varargs or similar complications prevent it. It observes site inlining pragmas. Equivalently, you can mark a routine definition with a pragma requesting inlining.If ­INLINE:never=routine_name<,routine_name>* is specified, the compiler does not inline the associated routines at call sites not marked by inlining pragmas; it observes site inlining pragmas. NoteFor C++, you must provide mangled routine names.The ­INLINE:file=<filename> Option This option invokes the standalone inliner, which provides cross-file inlining. The option ID="04.optimize15"­INLINE:file=<filename> searches for routines provided via the ­INLINE:must list option in the file specified by the ­INLINE:file option. The file provided in this option must be generated using the ­IPA­c options. The file generated contains information used to perform the cross file inlining.For example, suppose two files exist: foo.f and bar.f.The file, foo.f, looks like this:program main
  ...
  call bar()
endThe file, bar.f, looks like this:subroutine bar()
...
endTo inline bar into main, using the standalone inliner, compile with ­IPA and ­c options:f77 -n32 -IPA -c bar.fThis produces the file, bar.o. To inline bar into foo.f, enter:f77 -n32 foo.f -INLINE:must=bar:file=bar.oLBL="" HELPID=""ID="83184"Options To Control Inlining HeuristicsGroup options control the inlining heuristics used by IPA are listed in ID="04.optimize16"IDREF="46613" TYPE="TABLE"Table 4-3. COLUMNS="2"LBL="4-3"Table 4-3 ID="46613"  (continued)        Options to Control Inlining HeuristicsLEFT="0" WIDTH="97"OptionLEFT="105" WIDTH="288"Description LEFT="0" WIDTH="97"­IPA:maxdepth=nLEFT="105" WIDTH="288"Inline nodes at a depth less than or equal to ID="04.optimize17"n in the call graph. Leaf 
nodes are at depth 0. Inlining is still subject to space limit (see space and 
Olimit below). LEFT="0" WIDTH="97"­IPA:forcedepth=nLEFT="105" WIDTH="288"Inline nodes at a depth less than or equal to in the call graph regardless 
of the size of the procedures and total program size. Leaf nodes are at 
depth 0. You may use this option to force the inlining of, for example, 
leaf routines. ID="04.optimize18"LEFT="0" WIDTH="97"­IPA:space=nLEFT="105" WIDTH="288"Inline until the program expands by a factor of ID="04.optimize19"n% is reached. For 
example, n=20 causes inlining to stop once the program has grown in 
size by 20%. You may use this option to limit the growth in program 
size.LEFT="0" WIDTH="97"­IPA:plimit=nLEFT="105" WIDTH="288"Inline calls into a procedure until the procedure has grown to a size of 
ID="04.optimize20"n, where n is a measure of the size of the procedure. This may be used 
to control the size of each program unit. The current default procedure 
limit is 2000.LEFT="0" WIDTH="97"­OPT:Olimit=nLEFT="105" WIDTH="288"Controls the size of procedures that the global optimizer will process, 
measured as for plimit. IPA will avoid inlining that makes a procedure 
larger than this limit as well. Unlike plimit, a value of ID="04.optimize21"n=0 specifies 
unlimited. LBL="" HELPID=""ID="17185"Common Block PaddingPadding global arrays (in Fortran) reduces cache conflicts and can significantly improve performance. Several current restrictions exist which limits IPA padding of common arrays. The current restrictions are as follows:ID="04.optimize22"ID="04.optimize23"ID="04.optimize24"The shape of the common block to which the global array belongs must be consistent across procedures. That is, the declaration of the common block must be the same in every subroutine that declares it.In the example below, IPA can not pad any of the arrays in the common block because the shape is not consistent. program main
    common /a/ x(1024,1024), y(1024, 1024), z(1024,1024) 
    .... 
    .... 
end

subroutine foo 
    common /a/ xx(100,100), yy(1000,1000), zz(1000,1000) 
    .... 
    .... 
endThe common block variables must not initialize data associated with them. In this example, IPA can not pad any of the arrays in common block /a/:block data inidata 
    common /a/ x(1024,1024), y(1024,1024), z(1024,1024), b(2)
     DATA b /0.0, 0.0/ 
end

program main 
    common /a/ x(1024,1024), y(1024,1024), z(1024,1024), b(2) 
    .... 
    .... 
end The array to be padded may be passed as a parameter to a routine only if it declared as a one dimensional array, since passing multi-dimensional arrays that may be padded can cause the array to be re-shaped in the callee.Restricted types of equivalences to arrays that may be padded are allowed. Equivalences that do not intersect with any column of the array are allowed. This implies an equivalencing that will not cause the equivalenced array to access invalid locations. In the example below, the arrays in common /a/ will not be padded since z is equivalenced to x(2,1), and hence z(1024) is equivalenced to x(1,2).program main 
    real z(1024) 
    common /a/ x(1024,1024), y(1024,1024) equivalence (z, x(2,1))
    .... 
    .... 
endThe common block symbol must have an INTERNAL or HIDDEN attribute, which implies that the symbol may not be referenced within a DSO that has been linked with this program.The common block symbol can not be referenced by regular object files that have been linked with the program. LBL="" HELPID=""ID="77214"Alias and Address Taken AnalysisThe optimizations that are performed later in the compiler are often constrained by the possibility that two variable references may be "aliased." That is, they may be aliased to the same address. This possibility is increased by calls to procedures that aren't visible to the optimizer, and by taking the addresses of variables and saving them for possible use later (for example, in pointers). Furthermore, the compiler must normally assume that a global (extern) datum may have its address taken in another file, or may be referenced or modified by any procedure call. The IPA alias and address-taken analyses are designed to identify the actual global variable addressing and reference behavior so that such worst-case assumptions are not necessary.ID="04.optimize25"The options (described below) that control these analyses are:ID="04.optimize26"IDREF="19318" TYPE="TITLE""The ­IPA:alias=ON Option"IDREF="25944" TYPE="TITLE""The ­IPA:addressing=ON Option"IDREF="30944" TYPE="TITLE""The ­IPA:opt_alias=ON Option"LBL="" HELPID=""ID="19318"The ­IPA:alias=ON OptionThis option performs IPA alias analysis. That is, it determines which global variables and formal parameters are referenced or modified by each call, and which global variables are passed to reference formal parameters. This analysis is used for other IPA analyses, including constant propagation and address-taken analysis. This option is OFF by default.ID="04.optimize27"LBL="" HELPID=""ID="25944"The ­IPA:addressing=ON OptionThis option performs IPA address-taken analysis. That is, it determines which global variables and formal parameters have their addresses taken in ways that may produce aliases. This analysis is used for other IPA analyses, especially constant propagation. Its effectiveness is very limited without ID="04.optimize28"­IPA:alias=ON. This option is OFF by default.LBL="" HELPID=""ID="30944"The ­IPA:opt_alias=ON Option ID="04.optimize29"This options performs IPA alias analysis (implying ­IPA:alias=ON), and passes the results to the global optimizer. This option is OFF by default. LBL="" HELPID=""ID="72831"Controlling Loop Nest OptimizationsNumerical programs often spend most of their time executing loops. The loop nest optimizer (LNO) performs high-level loop optimizations that can greatly improve program performance by better exploiting caches and instruction-level parallelism. ID="04.optimize30"ID="04.optimize31"ID="04.optimize32"This section covers the following topics:ID="04.optimize33"IDREF="89177" TYPE="TITLE""Running LNO"IDREF="34430" TYPE="TITLE""LNO Optimizations"IDREF="39341" TYPE="TITLE""Compiler Options for LNO"IDREF="35834" TYPE="TITLE""Pragmas and Directives for LNO"LBL="" HELPID=""ID="89177"Running LNOLNO is run by default when you use the ID="04.optimize34"­O3 option for all Fortran, C, and C++ programs. LNO is an integrated part of the compiler back end and is not a preprocessor. Therefore, the same optimizations (with the same control options) apply to Fortran, C, and C++ programs. Note that this does not imply that LNO will optimize numeric C++ programs as well as Fortran programs. C and C++ programs often include features that make them inherently harder to optimize than Fortran programs.After LNO performs high-level transformations, it may be desirable to view the transformed code in the original source language. Two translators that are integrated into the back end translate the compiler internal code representation back into the original source language after the LNO transformation (and IPA inlining). You can invoke either one of these translators by using the ID="04.optimize35"ID="04.optimize36"ID="04.optimize37"f77 option ­FLIST:=on or the cc option ­CLIST:=on. For example, f77 -O3 -FLIST:=on x.f creates an a.out as well as a Fortran file x.w2f.f. The .w2f.f file is a readable and compilable Silicon Graphics Fortran representation of the original program after the LNO phase (see IDREF="79325" TYPE="GRAPHIC"Figure 4-2). LNO is not a preprocessor, which means that recompiling the .w2f.f file directly may result in an executable that is different from the original compilation of the .f file. The ­CLIST:=on option may be applied to CC to translate compiler internal code to C. No translator exists to translate compiler internal code to C++. When the original source language is C++, the generated C code may not be compilable. FILE="4.1.lno.trans.gif" POSITION="INLINE" SCALE="FALSE"LBL="4-2"Figure 4-2 ID="79325"Compilation Process Showing LNO Transformations LBL="" HELPID=""ID="34430"LNO Optimizations This section describes some important optimizations performed by LNO. For a complete listing, see your compiler's reference page. Optimizations include:IDREF="88775" TYPE="TITLE""Loop Interchange"IDREF="47378" TYPE="TITLE""Blocking and Outer Loop Unrolling"IDREF="18495" TYPE="TITLE""Loop Fusion"IDREF="71656" TYPE="TITLE""Loop Fission/Distribution"IDREF="49483" TYPE="TITLE""Prefetching"IDREF="23886" TYPE="TITLE""Gather-Scatter Optimization"LBL="" HELPID=""ID="88775"Loop Interchange ID="04.optimize38"The order of loops in a nest can affect the number of cache misses, the number of instructions in the inner loop, and the ability to schedule an inner loop. Consider the following loop nest example.ID="04.optimize39"ID="04.optimize40"do i   
  do j    
    do k      
      a(j,k) = a(j,k) + b(i,k)As written, the loop suffers from several possible performance problems. First, each iteration of the k loop requires two loads and one store. Second, if the loop bounds are sufficiently large, every memory reference will result in a cache miss.Interchanging the loops improves performance.do k
   do j
     do i
       a(j,k) = a(j,k) + b(i,k)Since a(j,k) is loop invariant, only one load is needed in every iteration. Also, b(i,k) is "stride-1," successive loads of b(i,k) come from successive memory locations. Since each cache miss brings in a contiguous cache line of data, typically 4-16 elements, stride-1 references incur a cache miss every 4-16 iterations. In contrast, the references in the original loop are not in stride-1 order. Each iteration of the inner loop causes two cache misses; one for a(j,k) and one for b(i,k).In a real loop, different factors may affect different loop ordering. For example, choosing i for the inner loop may improve cache behavior while choosing j may eliminate a recurrence. LNO uses a performance model that considers these factors. It then orders the loops to minimize the overall execution time estimate. LBL="" HELPID=""ID="47378"Blocking and Outer Loop Unrolling ID="04.optimize41"Cache blocking and outer loop unrolling are two closely related optimizations used to improve cache reuse, register reuse, and minimize recurrences. Consider matrix multiplication in the following example.ID="04.optimize42"ID="04.optimize43"do i=1,10000
   do j=1,10000
    do k=1,10000
      c(i,j) = c(i,j) + a(i,k)*b(k,j)Given the original loop ordering, each iteration of the inner loop requires two loads. The compiler uses loop unrolling, that is, register blocking, to minimize the number of loads.ID="04.optimize44"do i=1,10000
   do j=1,10000,2
    do k=1,10000
      c(i,j) = c(i,j) + a(i,k)*b(k,j)
      c(i,j+1) = c(i,j+1) + a(i,k)*b(k,j+1)Storing the value of a(i,k) in a register avoids the second load of a(i,k). Now the inner loop only requires three loads for two iterations. Unrolling the j loop even further, or unrolling the i loop as well, further decrease the amount of loads required. How much is the ideal amount to unroll? Unrolling more decreases the amount of loads but not the amount of floating point operations. At some point, the execution time of each iteration is limited by the floating point operations. There is no point in unrolling further. LNO uses its performance model to choose a set of unrolling factors that minimizes the overall execution time estimate.Given the original matrix multiply loop, each iteration of the i loop reuses the entire b matrix. However, with sufficiently large loop limits, the matrix b will not remain in the cache across iterations of the i loop. Thus in each iteration, you have to bring the entire matrix into the cache. You can "cache block" the loop to improve cache behavior.do tilej=1,10000,Bj
  do tilek=1,10000,Bk
   do i=1,10000
    do j=tilej,MIN(tilej+Bj-1,10000)
      do k=tilek,MIN(tilek+Bk-1,10000)
        c(i,j) = c(i,j) + a(i,k)*b(k,j)By appropriately choosing Bi and Bk, b remains in the cache across iterations of i, and the total number of cache misses is greatly reduced.LNO automatically caches tile loops with block sizes appropriate for the target machine. When compiling for a Silicon Graphics R8000, LNO uses a single level of blocking. When compiling for a Silicon Graphics systems (such as R4000, R5000, or R10000) that contain multi-level caches, LNO uses multiple levels of blocking where appropriate. LBL="" HELPID=""ID="18495"Loop FusionLNO attempts to fuse multiple loop nests to improve cache behavior, to lower the number of memory references, and to enable other optimizations. Consider the following example.ID="04.optimize45"ID="04.optimize46"do i=1,n
  do j=1,n
    a(i,j) = b(i,j) + b(i,j-1) + b(i,j+1)

do i=1,n
  do j=1,n
    b(i,j) = a(i,j) + a(i,j-1) + a(i,j+1)In each loop, you need to do one store and one load in every iteration (the remaining loads are eliminated by the software pipeliner). If n is sufficiently large, in each loop you need to bring the entire a and b matrices into the cache.LNO fuses the two nests and creates the following single nest:do i=1,n
  a(i,1) = b(i,0) + b(i,1) + b(i,2)
  do j=2,n
    a(i,j) = b(i,j) + b(i,j-1) + b(i,j+1)
    b(i,j-1) = a(i,j-2) + a(i,j-1) + a(i,j)
  end do
  b(i,n) = a(i,n-1) + a(i,n) + a(i,n+1)
end doFusing the loops eliminates half of the cache misses and half of the memory references. Fusion can also enable other optimizations. Consider the following example:do i
   do j1
     S1
   end do
   do j2
     S2
   end do
 end doBy fusing the two inner loops, other transformations are enabled such as loop interchange and cache blocking.do j
   do i
     S1
     S2
   end do
end doAs an enabling transformation, LNO always tries to use loop fusion (or fission, discussed below) to create larger perfectly nested loops. In other cases, LNO decides whether or not to fuse two loops by using a heuristic based on loop sizes and the number of variables common to both loops.LBL="" HELPID=""ID="71656"Loop Fission/DistributionThe opposite of fusing loops is distributing loops into multiple pieces, or loop fission. As with fusion, fission is useful as an enabling transformation. Consider this example again:ID="04.optimize47"ID="04.optimize48"do i
   do j1
     S1   
   end do
   do j2
     S2
   end do
end doUsing loop fission, as shown below, also enables loop interchange and blocking.do i1
   do j1
     S1
   end do
end do
do i2
   do j2
     S2
   end do
end doLoop fission is also useful to reduce register pressure in large inner loops. LNO uses a model to estimate whether or not an inner loop is suffering from register pressure. If it decides that register pressure is a problem, fission is attempted. LNO uses a heuristic to decide on how to divide the statements among the resultant loops.Loop fission can potentially lead to the introduction of temporary arrays. Consider the following loop.do i=1,n
   s = ..
   .. = s
end doIf you want to split the loop so that the two statements are in different loops, you need to scalar expand s.do i=1,n
   tmp_s(i) = ..
end do
do i=1,n
   .. = tmp_s(i)
end doSpace for tmp_s is allocated on the stack to minimize allocation time. If n is very large, scalar expansion can lead to increased memory usage, so the compiler blocks scalar expanded loops. Consider the following example:do se_tile=1,n,b
   do i=se_tile,MIN(se_tile+b-1,n)
     tmp_s(i) = ..
   end do
   do i=se_tile,MIN(se_tile+b-1,n)
     .. = tmp_s(i)
   end do
end doRelated to loop fission is vectorization of intrinsics. The Silicon Graphics math libraries support vector versions of many intrinsic functions that are faster than the regular versions. That is, it is faster, per element, to compute n cosines than to compute a single cosine. LNO attempts to split vectorizable intrinsics into their own loops. If successful, each such loop is collapsed into a single call to the corresponding vector intrinsic.LBL="" HELPID=""ID="49483"PrefetchingThe MIPS IV instruction set supports a data prefetch instruction that initiates a fetch of the specified data item into the cache. By prefetching a likely cache miss sufficiently ahead of the actual reference, you can increase the tolerance for cache misses. In programs limited by memory latency, prefetching can change the bottleneck from hardware latency time to the hardware bandwidth. By default, prefetching is enabled at ID="04.optimize49"ID="04.optimize50"ID="04.optimize51"­O3 for the R10000.LNO runs a pass that estimates which references will be cache misses and inserts prefetches for those misses. Based on the miss latency, the code generator later schedules the prefetches ahead of their corresponding references. By default, for misses in the primary cache, the code generator moves loads early in the schedule ahead of their use, exploiting the out-of-order execution feature of the R10000 to hide the latency of the primary miss. For misses in the secondary cache, explicit prefetch instructions are generated.Prefetching is limited to array references in well behaved loops. As loop bounds are frequently unknown at compile time, it is usually not possible to know for certain whether a reference will miss. The algorithm therefore uses heuristics to guess.LBL="" HELPID=""ID="23886"Gather-Scatter OptimizationSoftware pipelining attempts to improve performance by executing statements from multiple iterations of a loop in parallel. This is difficult when loops contain conditional statements. Consider the following example:ID="04.optimize52"ID="04.optimize53"do i = 1,n
   if (t(i) .gt. 0.0) then
     a(i) = 2.0*b(i-1)
   end do
end doIgnoring the IF statement, software pipelining may move up the load of b(i-1), effectively executing it in parallel with earlier iterations of the multiply. Given the conditional, this is not strictly possible. The code generator will often IF convert such loops, essentially executing the body of the IF on every iteration. IF conversion does not work well when the `if' is frequently not taken. An alternative is to gather-scatter the loop, so the loop is divided as follows:inc = 0 do i = 1,n
   tmp(inc) = i
   if (t(i) .gt. 0.0) then
     inc = inc + 1
   end do
end do
do i = 1,inc
   a(tmp(i)) = 2.0*b((tmp(i)-1)
end doThe code generator will IF convert the first loop; however, no need exists to IF convert the second one. The second loop can be effectively software pipelined without having to execute unnecessary multiplies.LBL="" HELPID=""ID="39341"Compiler Options for LNO The next sections describe the compiler options for LNO. Specifically, topics include:IDREF="18895" TYPE="TITLE""Controlling LNO Optimization Levels"IDREF="47296" TYPE="TITLE""Controlling Fission and Fusion"IDREF="62443" TYPE="TITLE""Controlling Gather-Scatter"IDREF="70250" TYPE="TITLE""Controlling Cache Parameters"IDREF="12967" TYPE="TITLE""Controlling Blocking and Permutation Transformations"IDREF="62455" TYPE="TITLE""Controlling Prefetch"All of the LNO optimizations are on by default when you use the ­O3 compiler option. To turn off LNO at ­O3, use ­LNO:opt=0. If you want direct control, you can specify options and pragmas to turn on and off optimizations that you require. LBL="" HELPID=""ID="18895"Controlling LNO Optimization Levels ID="04.optimize54"ID="04.optimize55"IDREF="67441" TYPE="TABLE"Table 4-4 lists LNO options that control optimization levels. COLUMNS="2"LBL="4-4"Table 4-4 ID="67441"  (continued)        LNO Options to Control Optimization LevelsLEFT="0" WIDTH="126"OptionLEFT="135" WIDTH="259"DescriptionLEFT="0" WIDTH="126"­LNO:opt={0,1} LEFT="135" WIDTH="259"Provides general control over the LNO optimization level. 0  Computes dependence graph to be used by later passes. 
Removes inexecutable loops and IF statements. Guards DO 
loops so that every DO loop is guaranteed to have at least one 
iteration. 1  Provides full LNO transformations.LEFT="0" WIDTH="126"­LNO:ignore_pragmas LEFT="135" WIDTH="259"By default, pragmas within a file override the command-line 
options. This option allows command-line options to override 
the pragmas in the file.ID="04.optimize56"LBL="" HELPID=""ID="47296"Controlling Fission and Fusion ID="04.optimize57"IDREF="70698" TYPE="TABLE"Table 4-5 lists LNO options that control fission and fusion. ID="04.optimize58"COLUMNS="2"LBL="4-5"Table 4-5 ID="70698"  (continued)        LNO Options to Control Fission and FusionLEFT="0" WIDTH="180"OptionLEFT="185" WIDTH="201"DescriptionLEFT="0" WIDTH="180"­LNO:fission={0,1,2}LEFT="185" WIDTH="201"0  Performs no fission. 1  Uses normal heuristics when deciding on loop 
fission (the default). 2  Tries fission before fusion when trying to 
create perfect nests, and fissions inner loops as 
much as possible.LEFT="0" WIDTH="180"­LNO:fusion={0,1,2}LEFT="185" WIDTH="201"0  Performs no fusion. 1  Uses normal heuristics when deciding on loop 
fusion (the default). 2  Fuses outer loops even if fusing destroys 
perfect nests; tries fusion before fission when 
trying to create perfect nests.LEFT="0" WIDTH="180"­LNO:fusion_peeling_limit=nLEFT="185" WIDTH="201"Sets the limit (n>=0) for number of iterations 
allowed to be peeled in fusion. The default is 5.LEFT="0" WIDTH="180"­LNO:fission_inner_register_limit=nLEFT="185" WIDTH="201"Sets the limit (n>=0) for estimated register usage 
of loop bodies after inner loop fission. The default 
is processor specific.NoteIf both ­LNO:fission and ­LNO:fusion are set to 1 or 2, fusion is preferred. LBL="" HELPID=""ID="62443"Controlling Gather-Scatter ID="04.optimize59"IDREF="17819" TYPE="TABLE"Table 4-6 lists the LNO option that controls gather-scatter. ID="04.optimize60"COLUMNS="2"LBL="4-6"Table 4-6 ID="17819"LNO Option to Control Gather-ScatterLEFT="0" WIDTH="126"OptionLEFT="135" WIDTH="259"DescriptionLEFT="0" WIDTH="126"­LNO:gather_scatter={0,1,2}LEFT="135" WIDTH="259"Controls gather-scatter. 0  Does not perform the gather-scatter optimization.  1  Gather-scatters non-nested IF statements. The default is 1. 2  Performs multi-level gather-scatter.  LBL="" HELPID=""ID="70250"Controlling Cache Parameters The options ID="04.optimize61"­r5000, ­r8000, ­r10000 set a series of default cache characteristics. To override a default setting, use one or more of the options below.ID="04.optimize62"To define a cache entirely, you must specify all options immediately following the ­LNO:cache_size option. For example, if the processor is an R4000 (r4k), which has no secondary cache, then specifying ­LNO:cache_size2=4m is not valid unless you supply the options necessary to specify the other characteristics of the cache. (Setting ­LNO:cache_size2=0 is adequate to turn off the second level cache; you don't have to specify other second-level parameters.) Options are available for third and fourth level caches. Currently none of the Silicon Graphics machines have such caches. However, you can also use those options to block other levels of the memory hierarchy. For example, on a machine with 128Mb of main memory, you can block for it by using the parameters below, for example, ­LNO:cs3=128M:ls3=.... In this case, assoc3 is ignored and doesn't have to be specified. Instead, you must specify is_mem3.., since virtual memory is fully associative. IDREF="34919" TYPE="TABLE"Table 4-7 lists LNO options that control cache parameters. COLUMNS="2"LBL="4-7"Table 4-7 ID="34919"  (continued)        LNO Options to Control Cache ParametersLEFT="0" WIDTH="183"OptionLEFT="190" WIDTH="201"DescriptionLEFT="0" WIDTH="183"­LNO:{cache_size1,cs1}=n ­LNO:{cache_size2,cs2}=n ­LNO:{cache_size3,cs3}=n ­LNO:{cache_size4,cs4}=n LEFT="190" WIDTH="201"The size of the cache. The value n can either be 0, 
or it must be a positive integer followed by only 
one of the letters k, K, m, or M. This specifies the 
cache size in kilobytes or megabytes. A value of 
zero indicates that no cache exists at that level.LEFT="0" WIDTH="183"­LNO:{line_size1,ls1}=n ­LNO:{line_size2,ls2}=n ­LNO:{line_size3,ls3}=n ­LNO:{line_size4,ls4}=n LEFT="190" WIDTH="201"The line size in bytes. This is the number of bytes 
that are moved from the memory hierarchy level 
further out to this level on a miss. A value of zero 
indicates that no cache exists at that level. LEFT="0" WIDTH="183"­LNO:{associativity1,assoc1}=n ­LNO:{associativity2,assoc2}=n ­LNO:{associativity3,assoc3}=n ­LNO:{associativity4,assoc4}=nLEFT="190" WIDTH="201"The cache set associativity. Large values are 
equivalent. For example, when blocking for main 
memory, it's adequate to set assoc3=128. A value 
of zero indicates that no cache exists at that level.LEFT="0" WIDTH="183"­LNO:{miss_penalty1,mp1}=n ­LNO:{miss_penalty2,mp2}=n ­LNO:{miss_penalty3,mp3}=n ­LNO:{miss_penalty4,mp4}=nLEFT="190" WIDTH="201"In processor cycles, the time for a miss to the next 
outer level of the memory hierarchy. This number 
is approximate, since it depends on a clean or 
dirty line, read or write miss, etc. A value of zero 
indicates that no cache exists at that level.LEFT="0" WIDTH="183"­LNO:{is_memory_leve1,is_mem1}={on,off} ­LNO:{is_memory_leve2,is_mem2}={on,off} ­LNO:{is_memory_leve3,is_mem3}={on,off} ­LNO:{is_memory_leve4,is_mem4}={on,off}LEFT="190" WIDTH="201"Optional; the default is off. If specified, the 
corresponding associativity is ignored and 
needn't be specified. Model this memory 
hierarchy level as a memory, not a cache. This 
means that blocking may be attempted for this 
memory hierarchy level, and that blocking 
appropriate for a memory rather than cache will 
be applied (for example, no prefetching, and no 
concern about conflict misses).LBL="" HELPID=""ID="12967"Controlling Blocking and Permutation Transformations ID="04.optimize63"ID="04.optimize64"IDREF="52429" TYPE="TABLE"Table 4-8 lists an option that aides in modeling. The default depends on the target processor. ID="04.optimize65"COLUMNS="2"LBL="4-8"Table 4-8 ID="52429"LNO Option to Control ModelingLEFT="0" WIDTH="172"OptionLEFT="180" WIDTH="208"DescriptionLEFT="0" WIDTH="172"­LNO:{non_blocking_loads,nbl}=n1LEFT="180" WIDTH="208"Optional; specify FALSE if the processor blocks on 
loads. If not set, takes the default of the current 
processor (not associated with a cache level).IDREF="65981" TYPE="TABLE"Table 4-9 lists options that control transformations. ID="04.optimize66"COLUMNS="2"LBL="4-9"Table 4-9 ID="65981"  (continued)        LNO Options to Control TransformationsLEFT="0" WIDTH="162"OptionLEFT="170" WIDTH="223"DescriptionLEFT="0" WIDTH="162"­LNO:interchange={ON,OFF}LEFT="170" WIDTH="223"Specify OFF to disable the interchange transformation. 
The default is ON.LEFT="0" WIDTH="162"­LNO:blocking={ON,OFF}LEFT="170" WIDTH="223"Specify OFF to disable the cache blocking 
transformation. Note that loop interchange to improve 
cache performance can still be applied. The default is 
ON.LEFT="0" WIDTH="162"­LNO:blocking_size=[n1][,n2]LEFT="170" WIDTH="223"Specifies a blocksize that the compiler must use when 
performing any blocking. No default exists.LEFT="0" WIDTH="162"­LNO:outer_unroll=n ­LNO:ou=n ­LNO:outer_unroll_max=n[no default] ­LNO:ou_max=n ­LNO:outer_unroll_prod_max=nLEFT="170" WIDTH="223"Specifies how far to unroll outer loops.outer_unroll (ou) indicates that every outer loop for 
which unrolling is valid should be unrolled by exactly 
n. The compiler either unrolls by this amount or not at 
all.   No default exists. If you specify outer_unroll, 
neither outer_unroll_max nor outer_unroll_prod_max 
can be specified. outer_unroll_max tells the compiler to unroll as 
many as n per loop, but no more.outer_unroll_prod_max indicates that the product 
of unrolling of the various outer loops in a given loop 
nest is not to exceed outer_unroll_prod_max. The 
default is 16.IDREF="26719" TYPE="TABLE"Table 4-10 lists the LNO option that indicates how hard to try to optimize for the cache. ID="04.optimize67"COLUMNS="2"LBL="4-10"Table 4-10 ID="26719"LNO Option to Control Cache OptimizationLEFT="0" WIDTH="154"OptionLEFT="160" WIDTH="180"DescriptionLEFT="0" WIDTH="154"­LNO:optimize_cache=nLEFT="160" WIDTH="180"0  Does not model any cache. 1  Models square blocks (fast). 2  Models rectangular blocks (the default).IDREF="15620" TYPE="TABLE"Table 4-11 lists the LNO option to control illegal transformation. ID="04.optimize68"COLUMNS="2"LBL="4-11"Table 4-11 ID="15620"LNO Option to Control Illegal TransformationLEFT="0" WIDTH="198"OptionLEFT="205" WIDTH="183"DescriptionLEFT="0" WIDTH="198"­LNO:apply_illegal_transformation_directives
={on,off}LEFT="205" WIDTH="183"Issues a warning if the compiler sees a 
directive to perform a transformation that it 
considers illegal. on  May attempt to perform the 
transformation. off  Does not attempt to perform the 
transformation. LBL="" HELPID=""ID="62455"Controlling PrefetchID="04.optimize69"IDREF="30359" TYPE="TABLE"Table 4-12 lists LNO options that control prefetch operations. COLUMNS="2"LBL="4-12"Table 4-12 ID="30359"  (continued)        LNO Options to Control Prefetch LEFT="0" WIDTH="136"OptionLEFT="145" WIDTH="244"DescriptionLEFT="0" WIDTH="136"­LNO:prefetch=[0,1,2]LEFT="145" WIDTH="244"Enables or disables prefetching. 0  Disables prefetch. 1  Enables prefetch but is conservative. 2  Enables prefetch and is aggressive. The default is enabled and conservative for the 
R5000/R10000, and disabled for all previous processors.LEFT="0" WIDTH="136"­LNO:prefetch_ahead=[n]LEFT="145" WIDTH="244"Prefetches the specified number of cache lines ahead of the 
reference. The default is 2.LEFT="0" WIDTH="136"­LNO:prefetch_leveln=[on,off] ­LNO:pfn=[on,off]LEFT="145" WIDTH="244"Selectively enables/disables prefetching for cache level n 
where n ranges from [1..4].LEFT="0" WIDTH="136"­LNO:prefetch_manual=[on,off]LEFT="145" WIDTH="244"Ignores or respects manual prefetches (through pragmas). on  Respects manual prefetches (the default for R10000). off  Ignores manual prefetches (the default for all processors 
except R10000). LBL="" HELPID=""Dependence Analysis ID="04.optimize70"IDREF="47098" TYPE="TABLE"Table 4-13 lists options that control dependence analysis. COLUMNS="2"LBL="4-13"Table 4-13 ID="47098"Options to Control Dependence AnalysisLEFT="0" WIDTH="136"OptionLEFT="145" WIDTH="252"DescriptionLEFT="0" WIDTH="136"­OPT:cray_ivdep={false/true}LEFT="145" WIDTH="252"Interprets any ivdep pragma using Cray semantics. The 
default is false. See IDREF="35834" TYPE="TITLE""Pragmas and Directives for LNO" for a 
definition. LEFT="0" WIDTH="136"­OPT:liberal_ivdep={false/true}LEFT="145" WIDTH="252"Interprets any ivdep pragma using liberal semantics. The 
default is false. See IDREF="35834" TYPE="TITLE""Pragmas and Directives for LNO" for a 
definition. LBL="" HELPID=""ID="35834"Pragmas and Directives for LNO ID="04.optimize71"Fortran ID="04.optimize72"directives and C and C++ pragmas enable, disable, or modify a feature of the compiler. This section uses the term ID="04.optimize73"pragma when describing either a pragma or a directive. Pragmas within a procedure apply only to that particular procedure, and revert to the default values upon the end of the procedure. Pragmas that occur outside of a procedure alter the default value, and therefore apply to the rest of the file from that point on, until overridden by a subsequent pragma.By default, pragmas within a file override the command-line options. Use the ­LNO:ignore_pragmas option to allow command-line options to override the pragmas in the file.This section covers:IDREF="67481" TYPE="TITLE""Fission/Fusion"IDREF="65621" TYPE="TITLE""Blocking and Permutation Transformations"IDREF="37792" TYPE="TITLE""Prefetch"IDREF="42916" TYPE="TITLE""Dependence Analysis"LBL="" HELPID=""ID="67481"Fission/Fusion ID="04.optimize74"The following pragmas/directives control fission and fusion.ID="04.optimize75"C*$* AGGRESSIVE INNER LOOP FISSION#pragma aggressive inner loop fissionFission inner loops into as many loops as possible. It can only be followed by a inner loop and has no effect if that loop is not inner any more after loop interchange.C*$* FISSION [(n)]#pragma fission [(n)]C*$* FISSIONABLE #pragma fissionableFission the enclosing n level of loops after this pragma. The default is 1. Performs validity test unless a FISSIONABLE pragma is also specified. Does not reorder statements.C*$* FUSE [(n,level)]#pragma fuse [(n,level)]C*$* FUSABLE#pragma fusableFuse the following n loops, which must be immediately adjacent. The default is 2,level. Fusion is attempted on each pair of adjacent loops and the level, by default, is the determined by the maximal perfectly nested loop levels of the fused loops although partial fusion is allowed. Iterations may be peeled as needed during fusion and the limit of this peeling is 5 or the number specified by the ­LNO:fusion_peeling_limit option. No fusion is done for non-adjacent outer loops. When the FUSABLE pragma is present, no validity test is done and the fusion is done up to the maximal common levels.C*$* NO FISSION #pragma no fissionThe loop following this pragma should not be fissioned. Its innermost loops, however, are allowed to be fissioned.C*$* NO FUSION#pragma no fusionThe loop following this pragma should not be fused with other loops.LBL="" HELPID=""ID="65621"Blocking and Permutation Transformations The following pragmas/directives control blocking and permutation transformations.ID="04.optimize76"NoteThe parallelizing preprocessor may decide to do some transformation for parallelism that violates some of these pragmas. C*$* INTERCHANGE (I, J, K)#pragma interchange (i,j,k)Loops I, J and K (in any order) must directly follow this pragma and be perfectly nested one inside the other. If they are not perfectly nested, the compiler may choose to perform loop distribution to make them so, or may choose to ignore the annotation, or even apply imperfect interchange. Attempts to reorder loops so that I is outermost, then J, then K. The compiler may choose to ignore this pragma.C*$* NO INTERCHANGE#pragma no interchangePrevent the compiler from involving the loop directly following this pragma in an interchange, or any loop nested within this loop.C*$* BLOCKING SIZE [(n1,n2)]#pragma blocking size (n1,n2)The loop specified, if it is involved in a blocking for the primary (secondary) cache, will have a blocksize of n1 {n2}. The compiler tries to include this loop within such a block. If a 0 blocking size is specified, then the loop is not stripped, but the entire loop is inside the block.For example:          subroutine amat(x,y,z,n,m,mm)
          real*8 x(100,100), y(100,100), z(100,100)
          do k = 1, n
        C*$* BLOCKING SIZE 20
             do j = 1, m
        C*$* BLOCKING SIZE 20
               do i = 1, mm
                 z(i,k) = z(i,k) + x(i,j)*y(j,k)
               enddo
             enddo
           enddo
           endIn this example, the compiler makes 20x20 blocks when blocking. However, the compiler can block the loop nest such that loop k is not included in the tile. If it didn't, add the following pragma just before the k loop.          C*$* BLOCKING SIZE (0)This pragma suggests that the compiler generates a nest like:          subroutine amat(x,y,z,n,m,mm)
           real*8 x(100,100), y(100,100), z(100,100)
           do jj = 1, m, 20
             do ii = 1, mm, 20
               do k = 1, n
                 do j = jj, MIN(m, jj+19)
                   do i = ii, MIN(mm, ii+19)
                     z(i,k) = z(i,k) + x(i,j)*y(j,k)
                   enddo 
                enddo
               enddo
             enddo
           enddo
           endFinally, you can apply a INTERCHANGE pragma to the same nest as a BLOCKING SIZE pragma. The BLOCKING SIZE applies to the loop it directly precedes only, and moves with that loop when an interchange is applied.C*$* NO BLOCKING#pragma no blockingPrevent the compiler from involving this loop in cache blocking.C*$* UNROLL (n) #pragma unroll (n)This pragma suggests to the compiler that n-1 copies of the loop body be added to the inner loop. If the loop that this pragma directly precedes is an inner loop, then it indicates standard unrolling. If the loop that this pragma directly precedes is not innermost, then outer loop unrolling (unroll and jam) is performed. The value of n must be at least 1. If it is exactly 1, then no unrolling is performed.For example, the following code:          C*$* UNROLL (2)
             DO i = 1, 10
              DO j = 1, 10
               a(i,j) = a(i,j) + b(i,j)
              END DO
             END DObecomes:            DO i = 1, 10, 2
              DO j = 1, 10
               a(i,j) = a(i,j) + b(i,j)
               a(i+1,j) = a(i+1,j) + b(i+1,j)
              END DO
             END DOand not:            DO i = 1, 10, 2
              DO j = 1, 10
               a(i,j) = a(i,j) + b(i,j)
              END DO
              DO j = 1, 10
               a(i+1,j) = a(i+1,j) + b(i+1,j)
              END DO
             END DOThe UNROLL pragma again is attached to the given loop, so that if an INTERCHANGE is performed, the corresponding loop is still unrolled. That is, the example above is equivalent to:          C*$* INTERCHANGE i,j
             DO j = 1, 10
          C*$* UNROLL 2
              DO i = 1, 10
               a(i,j) = a(i,j) + b(i,j)
              END DO
             END DOC*$* BLOCKABLE(I,J,K)#pragma blockable (i,j,k)The loops I, J and K must be adjacent and nested within each other, although not necessarily perfectly nested. This pragma informs the compiler that these loops may validly be involved in a blocking with each other, even if the compiler considers such a transformation invalid. The loops are also interchangeable and unrollable. This pragma does not tell the compiler which of these transformations to apply.LBL="" HELPID=""ID="37792"Prefetch The following pragmas/directives control prefetch operations.ID="04.optimize77"C*$* PREFETCH [(n1,n2)]#pragma prefetch [(n1,n2)] Specify prefetching for each level of the cache. Scope: entire function containing the pragma. 0  prefetching off (default for all processors except R10000) 1  prefetching on, but conservative (default at ­03 when prefetch is on) 2  prefetching on, and aggressive C*$* PREFETCH_MANUAL[(n)]  #pragma prefetch_manual[(n)]Specify whether manual prefetches (through pragmas) should be respected or ignored. Scope: entire function containing the pragma. 0  ignore manual prefetches (default for all processors except R10000) 1  respect manual prefetches (default at ­03 for R10000 and beyond)C*$* PREFETCH_REF=[array-ref], stride=[str][,str], level=[lev][,lev], & kind=[rd/wr], size=[sz]#pragma prefetch_ref =[array-ref], stride=[str][,str], level=[lev][,lev], & kind=[rd/wr], size=[sz] array-ref  specifies the reference itself, for example, A(i, j). Must be specified.stride  prefetches every stride iterations of this loop. Optional, the default is 1.level  specifies the level in memory hierarchy to prefetch. Optional, the default is 2. lev=1: prefetch from L2 to L1 cache. lev=2: prefetch from memory to L1 cache.kind  specifies read/write. Optional, the default is write.size  specifies the size (in Kbytes) of this array referenced in this loop. Must be a constant. Optional. The effect of this pragma is:generate a prefetch and connect to the specified reference (if possible). search for array references that match the supplied reference in the current loop-nest. If such a reference is found, then that reference is connected to this prefetch node with the specified latency. If no such reference is found, then this prefetch node stays free-floating and is scheduled "loosely." ignore all references to this array in this loop-nest by the automatic prefetcher (if enabled).if the size is specified, then the auto-prefetcher (if enabled) uses that number in its volume analysis for this array.No scope, just generate a prefetch. C*$* PREFETCH_REF_DISABLE=A, size=[num]#pragma prefetch_ref_disable=A,size=[num]size specifies the size (in Kbytes) of this array referenced in this loop (optional). The size must be a constant. This explicitly disables prefetching all references to array A in the current loop nest. The auto-prefetcher runs (if enabled) ignoring array A. The size is used for volume analysis. Scope: entire function containing the pragma. LBL="" HELPID=""ID="42916"Dependence Analysis The following pragmas/directives control dependence analysis.ID="04.optimize78"CDIR$  IVDEP#pragma ivdepLiberalize dependence analysis. This applies only to inner loops. Given two memory references, where at least one is loop variant, ignore any loop-carried dependences between the two references. For example:      CDIR$ IVDEP
        do i = 1,n
           b(k) = b(k) + a(i)
        enddoivdep does not break the dependence since b(k) is not loop variant.     CDIR$ IVDEP
        do i=1,n
           a(i) = a(i-1) + 3.0
        enddoivdep does break the dependence, but the compiler warns the user that it's breaking an obvious dependence.     CDIR$ IVDEP
        do i=1,n
           a(b(i)) = a(b(i)) + 3.0
        enddoivdep does break the dependence.      CDIR$ IVDEP
        do i = 1,n
           a(i) = b(i)
           c(i) = a(i) + 3.0
        enddoivdep does not break the dependence on a(i) since it is within an iteration.If ­OPT:cray_ivdep=TRUE, use Cray semantics. Break all lexically backwards dependences. For example:      CDIR$ IVDEP
        do i=1,n
           a(i) = a(i-1) + 3.0
        enddoivdep does break the dependence but the compiler warns the user that it's breaking an obvious dependence.      CDIR$ IVDEP
        do i=1,n
           a(i) = a(i+1) + 3.0
        enddoivdep does not break the dependence since the dependence is from the load to the store, and the load comes lexically before the store.To break all dependencies, specify ­OPT:liberal_ivdep=TRUE. LBL="" HELPID=""ID="71027"Controlling Floating Point OptimizationFloating point numbers (the Fortran REAL*n, DOUBLE PRECISION, and COMPLEX*n, and the C float, double, and long double) are inexact representations of ideal real numbers. The operations performed on them are also necessarily inexact. However, the MIPS processors conform to the IEEE 754 floating point standard, producing results as precise as possible given the constraints of the IEEE 754 representations, and the MIPSpro compilers generally preserve this conformance. Note, however, that 128-bit floating point (that is, the Fortran REAL*16 and the C long double) is not precisely IEEE-compliant. In addition, the source language standards imply rules about how expressions are evaluated. ID="04.optimize79"ID="04.optimize80"ID="04.optimize81"Most code that has not been written with careful attention to floating point behavior does not require precise conformance to either the source language expression evaluation standards or to IEEE 754 arithmetic standards. Therefore, the MIPSpro compilers provide a number of options that trade off source language expression evaluation rules and IEEE 754 conformance against better performance of generated code. These options allow transformations of calculations specified by the source code that may not produce precisely the same floating point result, although they involve a mathematically equivalent calculation. Two of these options (described below) are the preferred controls:ID="04.optimize82"IDREF="28381" TYPE="TITLE""­OPT:roundoff=n" deals with the extent to which language expression evaluation rules are observed, generally affecting the transformation of expressions involving multiple operations. IDREF="82770" TYPE="TITLE""­OPT:IEEE_arithmetic=n" deals with the extent to which the generated code conforms to IEEE 754 standards for discrete IEEE-specified operations (for example, a divide or a square root). LBL="" HELPID=""ID="28381"­OPT:roundoff=nThe ID="04.optimize83"­OPT:roundoff option provides control over floating point accuracy and overflow/underflow exception behavior relative to the source language rules.The ID="04.optimize84"roundoff option specifies the extent to that optimizations are allowed to affect floating point results, in terms of both accuracy and overflow/underflow behavior. The roundoff value, n, has a value in the range 0...3. Roundoff values are described below. roundoff=0Do no transformations that could affect floating point results. This is the default for optimization levels ­O0 to ­O2. roundoff=1Allow transformations with limited effects on floating point results. For roundoff, limited means that only the last bit or two of the mantissa is affected. For overflow (underflow), it means that intermediate results of the transformed calculation may overflow within a factor of two of where the original expression may have overflowed (underflowed). Note that effects may be less limited when compounded by multiple transformations.  roundoff=2Allow transformations with more extensive effects on floating point results. Allow associative rearrangement, even across loop iterations, and distribution of multiplication over addition/subtraction. Disallow only transformations known to cause cumulative roundoff errors or overflow/underflow for operands in a large range of valid floating point values. Reassociation can have a substantial effect on the performance of software pipelined loops by breaking recurrences. This is therefore the default for optimization level ­O3. roundoff=3Allow any mathematically valid transformation of floating point expressions. This allows floating point induction variables in loops, even when they are known to cause cumulative roundoff errors, and fast algorithms for complex absolute value and divide, which overflow (underflow) for operands beyond the square root of the representable extremes. LBL="" HELPID=""ID="82770"­OPT:IEEE_arithmetic=nThe ID="04.optimize85"­OPT:IEEE_arithmetic option controls conformance to IEEE 754 arithmetic standards for discrete operators.The ID="04.optimize86"­OPT:IEEE_arithmetic option specifies the extent to which optimizations must preserve IEEE floating point arithmetic. The value n must be in the range 1...3. Values are described below.­OPT:IEEE_arithmetic=1No degradation: do no transformations that degrade floating point accuracy from IEEE requirements. The generated code may use instructions like madds, which provide greater accuracy than required by IEEE 754. This is the default. ­OPT:IEEE_arithmetic=2Minor degradation: allow transformations with limited effects on floating point results, as long as exact results remain exact. This option allows use of the mips4 recip and rsqrt operations. ­OPT:IEEE_arithmetic=3Conformance not required: allow any mathematically valid transformations. For instance, this allows implementation of x/y as x*recip(y), or sqrt(x) as x*rsqrt(x). As an example, consider optimizing the Fortran code fragment: INTEGER i, n
REAL sum, divisor, a(n)
sum = 0.0
DO i = 1,n
    sum = sum + a(i)/divisor
END DOAt roundoff=0 and IEEE_arithmetic=1, the generated code must do the n loop iterations in order, with a divide and an add in each. Using IEEE_arithmetic=3, the divide can be treated like a(i)*(1.0/divisor). On the MIPS R8000, the reciprocal can be done with a recip instruction. But more importantly, the reciprocal can be calculated once before the loop is entered, reducing the loop body to a much faster multiply and add per iteration, which can be a single madd instruction on the R8000. Using roundoff=2, the loop may be reordered. The original loop takes at least 4 cycles per iteration on the R8000 (the latency of the add or madd instruction). Reordering allows the calculation of several partial sums in parallel, adding them together after loop exit. With software pipelining, a throughput of nearly 2 iterations per cycle is possible on the R8000, a factor of 8 improvement. Consider another example:INTEGER i,n
COMPLEX c(n)
REAL r
DO i = 1,n
     r = 0.1 * i
     c(i) = CABS ( CMPLX(r,r) )
END DOMathematically, r can be calculated by initializing it to 0.0 before entering the loop and adding 0.1 on each iteration. But doing so causes significant cumulative errors because the representation of 0.1is not exact. The complex absolute value is mathematically equal to SQRT(r*r + r*r). However, calculating it this way causes an overflow if 2*r*r is greater than the maximum REAL value, even though a representable result can be calculated for a much wider range of values of r (at greater cost). Both of these transformations are forbidden for roundoff=2, but enabled for roundoff=3. LBL="" HELPID=""Other Options to Control Floating Point BehaviorOther options exist that allow finer control of floating point behavior than is provided by ­OPT:roundoff. The options may be used to obtain finer control, but they may disappear or change in future compiler releases. ­OPT:div_split[=(ON|OFF)]Enable/disable the calculation of ID="04.optimize87"x/y as x*(1.0/y), normally enabled by IEEE_arithmetic=3. See ­OPT:recip.­OPT:fast_complex[=(ON|OFF)]Enable/disable the fast algorithms for complex absolute value and division, normally enabled by ID="04.optimize88"roundoff=3.­OPT:fast_exp[=(ON|OFF)]Enable/disable the translation of exponentiation by integers or halves to sequences of multiplies and square roots. This can change ID="04.optimize89"roundoff, and can make these functions produce minor discontinuities at the exponents where it applies. Normally enabled by roundoff>0 for Fortran, or for C if the function exp() is labelled intrinsic in <math.h> (the default in ­xansi and ­cckr modes).­OPT:fast_io[=(ON|OFF)]Enable/disable inlining of ID="04.optimize90"printf(), fprintf(), sprintf(), scanf(), fscanf(), sscanf(), and printw() for more specialized lower-level subroutines. This option applies only if the candidates for inlining are marked as intrinsic (­D__INLINE_INTRINSICS) in the respective header files (<stdio.h> and <curses.h>); otherwise they are not inlined. Programs that use functions such as printf() or scanf() heavily generally have improved I/O performance when this switch is used. Since this option may cause substantial code expansion, it is OFF by default.­OPT:fast_sqrt[=(ON|OFF)]Enable/disable the calculation of square root as ID="04.optimize91"x*rsqrt(x) for ­mips4, normally enabled by IEEE_arithmetic=3.­OPT:fold_reassociate[=(ON|OFF)]Enable/disable transformations that reassociate or distribute floating point expressions, normally enabled by ID="04.optimize92"roundoff>1.­OPT:IEEE_comparisons[=ON]Force comparisons to yield results conforming to the IEEE 754 standard for NaN and Inf operands, normally disabled. Setting this option disables certain optimizations like assuming that a comparison x==x is always TRUE (since it is FALSE if x is a NaN). It also disables optimizations that reverse the sense of a comparison, for example, turning "x < y" into "! (x >= y)", since both "x<y" and "x>=y" may be FALSE if one of the operands is a NaN.­OPT:recip[=(ON|OFF)]Allow use of the mips4 reciprocal instruction for ID="04.optimize93"1.0/y, normally enabled by IEEE_arithmetic>=2. See ­OPT:div_split.­OPT:rsqrt[=(ON|OFF)]Allow use of the mips4 reciprocal square root instruction for ID="04.optimize94"1.0/sqrt(y), normally enabled by IEEE_arithmetic>=2.­TARG:madd[=(ON|OFF)]The MIPS IV architecture supports fused multiply-add instructions, which add the product of two operands to a third, with a single roundoff step at the end. Because the product is not separately rounded, this can produce slightly different (but more accurate) results than a separate multiply and add pair of instructions. This is normally enabled for ID="04.optimize95"­mips4.LBL="" HELPID=""Debugging Floating-Point ProblemsThe options above can change the results of floating point calculations, causing less accuracy (especially ID="04.optimize96"­OPT:IEEE_arithmetic), different results due to expression rearrangement (­OPT:roundoff), or NaN/Inf results in new cases. Note that in some such cases, the new results may not be worse (that is, less accurate) than the old, they just may be different. For instance, doing a sum reduction by adding the terms in a different order is likely to produce a different result. Typically, that result is not less accurate, unless the original order was carefully chosen to minimize roundoff. If you encounter such effects when using these options (including ­O3, which enables ­OPT:roundoff=2 by default), first attempt to identify the cause by forcing the safe levels of the options: ­OPT:IEEE_arithmetic=1:roundoff=0. When you do this, do not have the following options explicitly enabled:  ­OPT:div_split  ­OPT:fast_complex ­OPT:fast_exp ­OPT:fast_sqrt ­OPT:fold_reassociate ­OPT:recip­OPT:rsqrtIf using the safe levels works, you can either use the safe levels or, if you are dealing with performance-critical code, you can use the more specific options (for example, div_split, fast_complex, and so forth) to selectively disable optimizations. Then you can identify the source code that is sensitive and eliminate the problem. Or, you can avoid the problematic optimizations.LBL="" HELPID=""Controlling Miscellaneous Optimizations With the ­OPT OptionThe following ­OPT options allow control over a variety of optimizations. These include:IDREF="69521" TYPE="TITLE""Using the ­OPT:space Option"IDREF="85941" TYPE="TITLE""Using the ­OPT:Olimit=n Option"IDREF="56228" TYPE="TITLE""Using the ­OPT:alias Option"IDREF="33592" TYPE="TITLE""Simplifying Code With the ­OPT Option"LBL="" HELPID=""ID="69521"Using the ­OPT:space Option­OPT:spaceThe MIPSpro compilers normally make optimization decisions based strictly on the expected execution time effects. If code size is more important, use this option. One of its effects is to cause most subprogram exits to go though a single exit path, with a single copy of register restores, result loads, and so forth. ID="04.optimize97"LBL="" HELPID=""ID="85941"Using the ­OPT:Olimit=n Option­OPT:Olimit=n This option controls the size of procedures to be optimized. Procedures above the cut-off limit are not optimized. A value of 0 means "infinite Olimit," and causes all procedures to be optimized. If you compile at ­O2 or above, and a routine is so large that the compile speed may be slow, then the compiler prints a message telling you the Olimit value needed to optimize your program.LBL="" HELPID=""ID="56228"Using the ­OPT:alias Option­OPT:alias=nameThe compilers must normally be very conservative in optimization of memory references involving pointers (especially in C), since aliases (that is, different ways of accessing the same memory) may be very hard to detect. This option may be used to specify that the program being compiled avoids aliasing in various ways. The ID="04.optimize98"­OPT:alias options are listed below.­OPT:alias=anyThe compiler assumes that any pair of memory references may be aliased unless it can prove otherwise. This is the default.ID="04.optimize99"­OPT:alias=typedThe compiler assumes that any pair of memory references that reference distinct types in fact reference distinct data. For example, consider the code:ID="04.optimize100"void dbl ( int *i, float *f ) {
     *i = *i + *i;
     *f = *f + *f;
}The compiler assumes that i and f point to different memory, and produces an overlapped schedule for the two calculations. ­OPT:alias=unnamedThe compiler assumes that pointers never point to named objects. For example, consider the code: ID="04.optimize101"float g;
void dbl ( float *f ) {
     g = g + g; 
     *f = *f + *f;
}The compiler assumes that f cannot point to g, and produces an overlapped schedule for the two calculations. This option also implies the alias=typed assumption. Note that this is the default assumption for the pointers implicit in Fortran dummy arguments according to the ANSI standard. ­OPT:alias=restrictThe compiler assumes a very restrictive model of aliasing, where no two pointers ever point to the same memory area. For example, consider the code:ID="04.optimize102"void dbl ( int *i, int *j ) {
     *i = *i + *i;
     *j = *j + *j;
}The compiler assumes that i and j point to different memory, and produces an overlapped schedule for the two calculations. Although this is a very dangerous option to use in general, it may produce significantly better code when used for specific well-controlled cases where it is known to be valid. LBL="" HELPID=""ID="33592"Simplifying Code With the ­OPT OptionThe following ­OPT options perform algebraic simplifications of expressions, such as turning x + 0 into x. ­OPT:div_split Simplifies expressions by determining if ID="04.optimize103"(A/B) should be turned into (1/B)*A. This can be useful if B is a loop-invariant, as it replaces the divide with a multiply. For example, X = A/B becomes X = A*(1/B).­OPT:fold_reassociate Determines if optimization involving reassociation of floating point quantities is allowed. This option is on at ID="04.optimize104"­O3, or if roundoff >= 2. For example, X + 1. X can be turned into X - X + 1.0, which will then simplify to 1. This can cause problems is X is large compared to 1, so that X+1 is X due to roundoff. ­OPT:fold_unsafe_relops Controls folding of relational operators in the presence of possible integer overflow. On by default. For example, ID="04.optimize105"X + Y < 0 may turn into X < Y. If X + Y overflows, it is possible to get different answers.­OPT:fold_unsigned_relopsDetermines if simplifications are performed of unsigned relational operations that may result in wrong answers in the event of integer overflow. Off by default. The example is the same as above, only for unsigned integers. ID="04.optimize106"ID="04.optimize107"­OPT:recip Allows the generation of the mips4 ID="04.optimize108"recip instruction. On at ­O3 or IEEE_Arithmetic >= 2. For example, X = 1./Y generates the recip instruction instead of a divide instruction. This may change the results slightly.­OPT:rsqrt Allows the generation of the mips4 ID="04.optimize109"rsqrt instruction. On at ­O3 or IEEE_Arithmetic >= 2. For example, X = 1./SQRT(Y) generates the rsqrt instruction instead of a divide and a square root. This may change the results slightly. LBL="" HELPID=""ID="43553"The Code Generator ID="04.optimize110"This section describes the code generator and covers the following topics:ID="04.optimize111"IDREF="49450" TYPE="TITLE""Overview of the Code Generator"IDREF="62024" TYPE="TITLE""Code Generator and Optimization Levels ­02 and ­03"IDREF="12119" TYPE="TITLE""Modifying Code Generator Defaults"IDREF="69298" TYPE="TITLE""Miscellaneous Code Generator Performance Topics"LBL="" HELPID=""ID="49450"Overview of the Code Generator ID="04.optimize112"The Code Generator (CG) processes an input program unit (PU) in intermediate representation form to produce an output object file (ID="04.optimize113".o) and/or assembly file (.s). Program units are partitioned into basic blocks (BBs). A new BB is started at each branch target. BBs are also ended by CALLs or branches. Large BBs are arbitrarily ended after a certain number of OPs, because some algorithms in CG work on one BB at a time ("local" algorithms) and have a complexity that is nonlinear in the number of operations in the BB.This section covers the following topics:IDREF="76426" TYPE="TITLE""Code Generator and Optimization Levels"IDREF="77036" TYPE="TITLE""An Example of Local Optimization for Fortran"LBL="" HELPID=""ID="76426"Code Generator and Optimization Levels At optimization levels ID="04.optimize114"­O0 and ­O1, the CG only uses local algorithms that operate individually on each BB. At ­O0, no optimization is done. References to global objects are spilled and restored from memory at BB boundaries. At ­O1, CG performs standard local optimizations on each BB (for example, copy propagation, dead code elimination) as well as some elimination of useless memory operations. At optimization levels ­O2 and ­O3, CG includes global register allocation and a large number of special optimizations for innermost loops, including software pipelining at ­O3. LBL="" HELPID=""ID="77036"An Example of Local Optimization for Fortran Consider the Fortran statement, ID="04.optimize115"a(i) = b(i). At ­O0, the value of i is kept in memory and is loaded before each use. This statement uses two loads of i. The CG local optimizer replaces the second load of i with a copy of the first load, and then it uses copy-propagation and dead code removal to eliminate the copy. Comparing .s files for the ­O0 and ­O1 versions shows:The .s file for ­O0:lw $3,20($sp)                   #  load address of i
lw $3,0($3)                     #  load i
addiu $3,$3,-1                  #  i - 1
sll $3,$3,3                     #  8 * (i-1)
lw $4,12($sp)                   #  load base address for b
addu $3,$3,$4                   #  address for b(i)
ldc1 $f0,0($3)                  #  load b
lw $1,20($sp)                   #  load address of i
lw $1,0($1)                     #  load i
addiu $1,$1,-1                  #  i - 1
sll $1,$1,3                     #  8 * (i-1)
lw $2,4($sp)                    #  load base address for a
addu $1,$1,$2                   #  address for a(i)
sdc1 $f0,0($1)                  #  store aThe .s file for ­O1:lw $1,0($6)                     #  load i
lw $4,12($sp)                   #  load base address for b
addiu $3,$1,-1                  #  i - 1
sll $3,$3,3                     #  8 * (i-1)
lw $2,4($sp)                    #  load base address for a
addu $3,$3,$4                   #  address for b(i)
addiu $1,$1,-1                  #  i - 1
ldc1 $f0,0($3)                  #  load b
sll $1,$1,3                     #  8 * (i-1)
addu $1,$1,$2                   #  address for a(i)
sdc1 $f0,0($1)                  #  store aThe .s file for ­O2 (using OPT to perform scalar optimization) produces optimized code: lw $1,0($6)                     # load i
sll $1,$1,3                     # 8 * i
addu $2,$1,$5                   # address of b(i+1)
ldc1 $f0,-8($2)                 # load b(i)
addu $1,$1,$4                   # address of a(i+1)
sdc1 $f0,-8($1)                 # store a(i)LBL="" HELPID=""ID="62024"Code Generator and Optimization Levels ­02 and ­03This section provides additional information about the ID="04.optimize116"­O2 and ­O3 optimization levels. Topics include:IDREF="19450" TYPE="TITLE""If Conversion"IDREF="68173" TYPE="TITLE""Cross-Iteration Optimizations"IDREF="66644" TYPE="TITLE""Loop Unrolling"IDREF="26706" TYPE="TITLE""Recurrence Breaking"IDREF="46324" TYPE="TITLE""Software Pipelining"IDREF="41563" TYPE="TITLE""Steps Performed By the Code Generator at Levels ­O2 and ­O3"LBL="" HELPID=""ID="19450"If ConversionID="04.optimize117"If conversion is a transformation that converts control-flow into conditional assignments. For example, consider the following code before if conversion. Note that expr1 and expr2 are arbitrary expressions without calls. if ( cond )
    a = expr1;
else
    a = expr2;After if conversion, the code looks like this:tmp1 = expr1;
tmp2 = expr2;
a = (cond) ? tmp1 : tmp2;Benefits of if ConversionPerforming ID="04.optimize118"if conversion:Exposes more instruction-level parallelism. This is almost always valuable on hardware platforms such as R10000.Eliminates branches. Some platforms (for example, the R10000) have a penalty for taken branches. There can be substantial costs associated with branches that are not correctly predicted by branch prediction hardware. For example, a mispredicted branch on R10000 has an average cost of about 8 cycles. ID="04.optimize119"Enables other compiler optimizations. Currently, cross-iteration optimizations and software pipelining both require single basic block loops. If conversion changes multiple BB innermost loops into single BB innermost loops.Interaction of if Conversion With Floating Point and Memory ExceptionsIn the code above that was ID="04.optimize120"if converted, the expressions, expr1 and expr2, are UNCONDITIONALLY evaluated. This can conceivably result in generation of exceptions that do not occur without if conversion. An operation that is conditionalized in the source, but is unconditionally executed in the object, is called a speculated operation. Even if the ­TENV:X level prohibits speculating an operation, it may be possible to if convert. For information about the ­TENV option, see IDREF="20051" TYPE="TITLE""Controlling the Target Environment" and the appropriate compiler reference page.For example, suppose expr1 = x + y; is a floating point add, and X=1. Speculating flops is not allowed (to avoid false overflow exceptions). Define x_safe and y_safe by x_safe = (cond)? x : 1.0; y_safe = (cond) ? y : 1.0;. Then unconditionally evaluating tmp1 = x_safe + y_safe; cannot generate any spurious exception. Similarly, if X < 4, and expr1 contains a load (for example, expr1 = *p), it is illegal to speculate the dereference of p. But, define p_safe = (cond) ? p : known_safe_address; and then tmp1 = *p_safe; cannot generate a spurious memory exception. Notice that with ­TENV:X=2, it is legal to speculate flops, but not legal to speculate memory references. So expr1 = *p + y; can be speculated to tmp1 = *p_safe + y;. If *known_safe_address is uninitialized, there can be spurious floating point exceptions associated with this code. In particular, on some MIPS platforms (for example, R10000) if the input to a flop is a denormalized number, then a trap will occur. Therefore, by default, CG initializes *known_safe_address to 1.0.LBL="" HELPID=""ID="68173"Cross-Iteration OptimizationsFour main types of cross-iteration optimizations include:ID="04.optimize121"IDREF="61422" TYPE="TITLE""Read-Read Elimination"IDREF="69145" TYPE="TITLE""Read-Write Elimination"IDREF="13692" TYPE="TITLE""Write-Write Elimination"IDREF="60409" TYPE="TITLE""Common Sub-expression Elimination"LBL="" HELPID=""ID="61422"Read-Read EliminationConsider the example below:ID="04.optimize122"DO i = 1,n 
   B(i) = A(i+1) - A(i) 
END DOThe load of A(i+1) in iteration i can be reused (in the role of A(i)) in iteration i+1. This reduces the memory requirements of the loop from 3 references per iteration to 2 references per iteration.LBL="" HELPID=""ID="69145"Read-Write EliminationSometimes a write in one iteration is read in a later iteration. For example:ID="04.optimize123"DO i = 1,n 
   B(i+1) = A(i+1) - A(i) 
   C(i) = B(i) 
END DOIn this example, the load of B(i) can be eliminated by reusing the value that was stored to B in the previous iteration.LBL="" HELPID=""ID="13692"Write-Write EliminationConsider the example below:ID="04.optimize124"DO i = 1,n 
   B(i+1) = A(i+1) - A(i) 
   B(i) = C(i) - B(i) 
END DOEach element of B is written twice. Only the second write is required, assuming read-write elimination is done.LBL="" HELPID=""ID="60409"Common Sub-expression EliminationConsider the example below:ID="04.optimize125"DO i = 1,n 
   B(i) = A(i+1) - A(i) 
   C(i) = A(i+2) - A(i+1) 
END DOThe value computed for C in iteration i may be used for B in iteration i+1. Thus only one subtract per iteration is required.LBL="" HELPID=""ID="66644"Loop UnrollingIn this example, unrolling 4 times converts this code:ID="04.optimize126"for( i = 0; i < n; i++ ) { 
   a[i] = b[i]; 
}After unrolling, the code looks like this:for ( i = 0; i < (n % 4); i++ ) { 
   a[i] = b[i]; 
} 
for ( j = 0; j < (n / 4); j++ ) { 
   a[i+0] = b[i+0]; 
   a[i+1] = b[i+1]; 
   a[i+2] = b[i+2]; 
   a[i+3] = b[i+3]; 
   i += 4; 
}Loop unrolling:Exposes more instruction-level parallelism. This may be valuable even on execution platforms such as R10000.Eliminates branches.Amortizes loop overhead. For example, unrolling replaces four increments i+=1 with one increment i+=4.LBL="" HELPID=""ID="26706"Recurrence BreakingThere are two types of recurrence breaking:ID="04.optimize127"Reduction interleaving. For example, interleaving by 4 transforms this code:sum = 0 
DO i = 1,n 
   sum = sum + A(i) 
END DO After reduction interleaving, the code looks like this (omitting the cleanup code):sum1 = 0 
sum2 = 0 
sum3 = 0 
sum4 = 0 
DO i = 1,n,4 
   sum1 = sum1 + A(i+0) 
   sum2 = sum2 + A(i+1) 
   sum3 = sum3 + A(i+2) 
   sum4 = sum4 + A(i+3) 
END DO 
sum = sum1 + sum2 + sum3 + sum4Back substitution. For example:ID="04.optimize128"DO i = 1,n 
   B(i+1) = B(i) + k 
END DOThe code is converted to:k2 = k + k
B(2) = B(1) + k
DO i = 2,n
   B(i+1) = B(i-1) + k2
END DOLBL="" HELPID=""ID="46324"Software PipeliningSoftware pipelining (SWP) schedules innermost loops to keep the hardware pipeline full. For information about software pipelining, see ID="04.optimize129"MIPSpro 64-Bit Porting and Transition Guide, Chapter 6, "Performance Tuning." Also, for information on instruction level parallelism, refer to B.R.Rau and J.A.Fisher, "Instruction Level Parallelism," Kluwer Academic Publishers, 1993 (reprinted from the Journal of Supercomputing, Volume 7, Number 1/2).LBL="" HELPID=""ID="41563"Steps Performed By the Code Generator at Levels ­O2 and ­O3The steps performed by the code generator at ID="04.optimize130"­O2 and ­O3 include:Non-loop if conversion.Find innermost loop candidates for further optimization. Loops are rejected for any of the following reasons:marked UNIMPORTANT (for example, LNO cleanup loop)strange control flow (for example, branch into the middle)If convert. This transforms a multi-BB loop into a single "BB" containing OPs with "guards." If a loop has multiple BBs and is not if converted it is not a candidate for any further optimization) If conversion can fail for any of the following reasons:loop contains a CALLloop has too many BBsloop has too many instructionsPerform cross-iteration optimizations (these optimizations are only attempted for trip-count loops).Unroll (only done for trip count loops; may unroll fully so that the loop is no longer a loop)Fix recurrences.If still a loop, and there is a trip count, and ­O3, invoke software pipelining (SWP).If not software pipelined, reverse if convert.Reorder BBs to minimize (dynamically) the number of taken branches. Also eliminate branches to branches when possible, and remove unreachable BBs. This step also happens at ­O1. At several points in this process local optimizations are performed, since many of the transformations performed can expose additional opportunities. It is also important to note that many transformations require legality checks that depend on alias information. There are three sources of alias information:At ­O3, the loop nest optimizer, LNO, provides a dependence graph for each innermost loop.The scalar optimizer provides information on aliasing at the level of symbols. That is, it can tell whether arrays A and B are independent, but it does not have information about the relationship of different references to a single array.CG can sometimes tell that two memory references are identical or distinct. For example, if two references use the same address, and there are no definitions of that address between the two references, then the two references are identical. LBL="" HELPID=""ID="12119"Modifying Code Generator DefaultsCG makes many choices, for example, what conditional constructs to ID="04.optimize131"if convert, or how much to unroll a loop. In most cases, the compiler makes reasonable decisions. Occasionally, however, you can improve performance by modifying the default behavior. You can control the code generator by:Increasing or decreasing the unroll amount.A heuristic is controlled by ­OPT:unroll_analysis (on by default), which generally tries to minimize unrolling. Less unrolling leads to smaller code size and faster compilation. You can change the upper bound for the amount of unrolling with ­OPT:unroll_times (default is 8) or ­OPT:unroll_size (the number of instructions in the unrolled body, current default is 80). Disabling software pipelining with ­OPT:swp=off. As far as CG is concerned, ­O3 ­OPT:swp=off is the same as ­O2. Since OPT does not run at ­O2, however, the input to CG can be very different, and the available aliasing information can be very different.LBL="" HELPID=""ID="69298"Miscellaneous Code Generator Performance TopicsThis section explains a few miscellaneous topics including:IDREF="92461" TYPE="TITLE""Prefetch and Load Latency"IDREF="26139" TYPE="TITLE""Frequency and Feedback"LBL="" HELPID=""ID="92461"Prefetch and Load LatencyAt ID="04.optimize132"­O3, with ­10000, LNO generates prefetches for memory references that are likely to miss either the L1 or the L2 cache. By default, CG generates prefetch operations for L2 prefetches, but discards L1 prefetches. It also makes sure that loads that had associated L1 prefetches are issued at least 8 cycles before their results are used. You can adjust all these default behaviors, but in most cases such fine control is not necessary. In general, two common situations exist: Prefetch is a good thing, and the default settings of the detailed controls are reasonable (the most common situation).Performance improves when all prefetches are disabled. The best way to do this is with ­LNO:prefetch=0.There is a possibly confusing interaction between prefetching and SWP notes in the .s file. Typically several replications of a software pipelined loop that differ only in the registers used for corresponding values. (This is necessary because values may have to survive in registers across multiple iterations of the loop.) It is often possible to reduce prefetch overhead by eliminating some of the corresponding prefetches from different replications. For example, suppose a prefetch is only required on every 4th iteration of a loop, because 4 consecutive iterations will load from the same cache line. If the loop is replicated 4 times by SWP, then there is no need for a prefetch in each replication, so 3 of the 4 corresponding prefetches are pruned away. The original SWP schedule has room for a prefetch in each replication, and the number of cycles for this schedule is what is described in the SWP notes as "cycles per iteration." The number of memory references listed in the SWP notes ("mem refs") is the number of memory references including prefetches in Replication 0. If some of the prefetches have been pruned away from replication 0, the notes will overstate the number of cycles per iteration while understating the number of memory references per iteration.LBL="" HELPID=""ID="26139"Frequency and FeedbackSome choices that CG makes are decided based on information about the frequency with which different BBs are executed. By default, CG makes guesses about these frequencies based on the program structure. This information is available in the ID="04.optimize133".s file. The frequency printed for each block is the predicted number of times that block will be executed each time the PU is entered. If compilation uses a feedback file, the frequency guesses are replaced with the measured frequencies derived from the feedback data. Currently feedback information guides control flow optimizations, global spill and restore placement, instruction alignment, and delay slot filling. Average loop trip-counts can be derived from feedback information. Trip count estimates are used to guide decisions about how much to unroll and whether or not to software pipelining.LBL="" HELPID=""ID="76821"Controlling the Target Architecture ID="04.optimize134"Some options control the target architecture for which code is generated. The options are described below.ID="04.optimize135"ID="04.optimize136"­32 ­n32 or ­64 This option determines the base ABI to be assumed, either the 32-bit ABI for mips1/2 targets, or the new 32-bit (n32) and 64-bit ABI for mips3/4 targets. ­mips[1 2 3 4] This option identifies the instruction set architecture (ISA) to be used for generated code. It defaults to ID="04.optimize137"mips2 for 32-bit compilations, mips3 for n32 compilations, and mips4 for 64-bit compilations. ­TARG:madd[=(ON|OFF)]This option enables/disables use of the multiply/add instructions for mips4 targets. These instructions multiply two floating point operands and then add (or subtract) a third with a single roundoff of the final result. They are therefore slightly more accurate than the usual discrete operations, and may cause results not to match baselines from other targets. This option may be used to determine whether observed differences are due to ID="04.optimize138"madds. This option is ON by default for mips4 targets; otherwise, it is ignored. ­r[5000 8000 10000] This option identifies the probable execution target of the code to be generated; it will be scheduled for optimal execution on that target. This option does not affect the ABI and/or ISA selected by the options described above (that is, it has no effect on which target processors can correctly execute the program, but just on how well they do so). The command below produces MIPS III code conforming to the 64-bit ABI (and therefore executable on any MIPS III or above processor), which is optimized to run on the R8000. ID="04.optimize139"ID="04.optimize140"cc -64 -mips3 -r8000 ...LBL="" HELPID=""ID="20051"Controlling the Target EnvironmentGenerated code is affected by a number of assumptions about the target software environment. The ID="04.optimize141"ID="04.optimize142"­TENV options tell the compiler what assumptions it can make, and sometimes what assumptions it should enforce. Executing instructions speculatively can make a significant difference in the quality of generated code. What instructions can be executed speculatively depends on the trap enable state at run time.ID="04.optimize143"­TENV:X=nSpecify the level, from 0 to 5, of enabled traps that are assumed (and enforced) for purposes of performing speculative code motion. At level 0, no speculation is done. At level 1, only safe speculative motion may be done, assuming that the IEEE 754 underflow and inexact traps are disabled. At level 2, all IEEE 754 floating point traps are disabled except divide by zero. At level 3, divide by zero traps are disabled. At level 4, memory traps may be disabled or dismissed by the operating system. At level 5, traps may be disabled or ignored. The default is 1 at ID="04.optimize144"­O0 through ­O2 and 2 at ­O3. Use nondefault levels with great care. Disabling traps eliminates a useful debugging tool, since the problems that cause them are detected later (often much later) in the execution of the program. In addition, many memory traps can't be avoided outright, but must be dismissed by the operating system after they occur. As a result, level 4 or 5 speculation can actually slow down a program significantly if it causes frequent traps. Disabling traps in one module requires disabling them for the entire program. Programs that make use of level 2 or above should not attempt explicit manipulation of the hardware trap enable flags. Furthermore, libraries (including DSOs) being built for incorporation in many client programs should generally avoid using this option, since using it makes debugging of the client programs difficult, and can prevent them from safely making use of the hardware trap enables. ID="04.optimize145"­TENV:align_aggregates=nThe ABI specifies that aggregates (that is, ID="04.optimize146"structs and arrays) be aligned according to the strictest requirements of their components (fields or elements). Thus, an array of short ints (or a struct containing only short ints or chars) normally is 2-byte aligned. However, some code (non-ANSI conforming) may reference such objects assuming greater alignment, and some code (for example, struct assignments) may be more efficient if the objects are better aligned. This option specifies that any aggregate of size at least n is at least n-byte aligned. It does not affect the alignment of aggregates, which are themselves components of larger aggregates. LBL="" HELPID=""ID="88275"Improving Global OptimizationID="04.optimize147"This section describes the global optimizer and contains coding hints. Specifically this section includes:IDREF="16943" TYPE="TITLE""Overview of the Global Optimizer"IDREF="98233" TYPE="TITLE""Optimizing C, C++, and Fortran Programs"IDREF="34986" TYPE="TITLE""Improving Other Optimization"IDREF="78061" TYPE="TITLE""Register Allocation"LBL="" HELPID=""ID="16943"Overview of the Global OptimizerThe global optimizer is part of the compiler back end. It improves the performance of object programs by transforming existing code into more efficient coding sequences. The optimizer distinguishes between C, C++, and Fortran programs to take advantage of the various language semantics.ID="04.optimize148"LBL="" HELPID=""ID="98233"Optimizing C, C++, and Fortran ProgramsThe following suggestion applies to C, C++, and Fortran programs.ID="04.optimize149"ID="04.optimize150"Do not use indirect calls (that is, calls via function pointers, including those passed as subprogram arguments). Indirect calls may cause unknown side effects (for instance, changing global variables) reducing the amount of optimization possible.LBL="" HELPID=""Optimizing C and C++ ProgramsThe following suggestions apply to C and C++ programs.ID="04.optimize151"Return values. Use functions that return values instead of pointer parameters.ID="04.optimize152"Unions. Avoid unions that cause overlap between integer and floating point data types. The optimizer can not assign such fields to registers.ID="04.optimize153"Local variables. Use local variables and avoid global variables. In C and C++ programs, declare any variable outside of a function as static, unless that variable is referenced by another source file. Minimizing the use of global variables increases optimization opportunities for the compiler.Const parameters. Declare pointer parameters as const in prototypes whenever possible, that is, when there is no path through the routine that modifies the pointee. This allows the compiler to avoid some of the negative assumptions normally required for pointer and reference parameters (see below).ID="04.optimize154"Value parameters. Pass parameters by value instead of passing by reference (pointers) or using global variables. Reference parameters have the same performance-degrading effects as the use of pointers (see below).ID="04.optimize155"Pointers and aliasing.Aliases occur when there are multiple ways to reference the same data object. For instance, when the address of a global variable is passed as a subprogram argument, it may be referenced either using its global name, or via the pointer. The compiler must be conservative when dealing with objects that may be aliased, for instance keeping them in memory instead of in registers, and carefully retaining the original source program order for possibly aliased references. Pointers in particular tend to cause aliasing problems, since it is often impossible for the compiler to identify their target objects. Therefore, you can help the compiler avoid possible aliases by introducing local variables to store the values obtained from dereferenced pointers. Indirect operations and calls affect dereferenced values, but do not affect local variables. Therefore, local variables can be kept in registers. The following example shows how the proper placement of pointers and the elimination of aliasing produces better code.LBL="" HELPID=""Example of Pointer Placement and AliasingIn the example below, if len>10 (for instance because it is changed in another function before calling zero), *p++ = 0 will eventually modify len. Therefore, the compiler cannot place len in a register for optimal performance. Instead, the compiler must load it from memory on each pass through the loop. For example:char a[10];
int len = 10;
void
zero()
{
   char *p;
   for (p= a; p != a + len; ) *p++ = 0;
}You can increase the efficiency of this example by using subscripts instead of pointers, or by using local variables to store unchanging values.ID="04.optimize156"Using subscripts instead of pointers. Using subscripts in the procedure ID="04.optimize157"azero (as shown below) eliminates aliasing. The compiler keeps the value of ID="04.optimize158"len in a register, saving two instructions. It still uses a pointer to access a efficiently, even though a pointer is not specified in the source code. For example:ID="04.optimize159"char a[10];
int len = 10;
void azero()
{
    int i;
    for ( i = 0; i != len; i++ )
    a[i] = 0; 
}Using local variables. Using local (automatic) variables or formal arguments instead of static or global prevents aliasing and allows the compiler to allocated them in registers. For example, in the following code fragment, the variables loc and form are likely to be more efficient than ext* and stat*.extern int ext1; 
static int stat1; 

void p ( int form ) 
{
   extern int ext2; 
   static int stat2; 
   int loc; 
   ...
}Write straightforward code. For example, do not use ++ and - - operators within an expression. Using these operators for their values, rather than for their side-effects, often produces bad code.ID="04.optimize160"Addresses. Avoid taking and passing addresses (and values). Using addresses creates aliases, makes the optimizer store variables from registers to their home storage locations, and significantly reduces optimization opportunities that would otherwise be performed by the compiler.ID="04.optimize161"VARARG/STDARG. Avoid functions that take a variable number of arguments. The optimizer saves all parameter registers on entry to VARARG or STDARG functions. If you must use these functions, use the ANSI standard facilities of ID="04.optimize162"ID="04.optimize163"stdarg.h. These produce simpler code than the older version of varargs.hLBL="" HELPID=""ID="34986"Improving Other OptimizationThe global optimizer processes programs only when you specify the ­O2 or ­O3 option at compilation. However, the code generator phase of the compiler always perform certain optimizations.This section contains coding hints that increase optimization for the other passes of the compiler.LBL="" HELPID=""C, C++, and Fortran ProgramsThe following suggestions apply to both C, C++, and Fortran programs:Use tables rather than ID="04.optimize164"if-then-else or switch statements. For example:typedef enum { BLUE, GREEN, RED, NCOLORS } COLOR;Instead of:switch ( c ) {
   case CASE0: x = 5; break;
   case CASE1: x = 10; break;
   case CASE2: x = 1; break;
}Use:static int Mapping[NCOLORS] = { 5, 10, 1 };
...
x = Mapping[c];As an optimizing technique, the compiler puts the first eight parameters of a parameter list into registers where they may remain during execution of the called routine. Therefore, always declare, as the first eight parameters, those variables that are most frequently manipulated in the called routine.Use 32-bit or 64-bit scalar variables instead of smaller ones. This practice can take more data space, but produces more efficient code.ID="04.optimize165"LBL="" HELPID=""C and C++ ProgramsThe following suggestions apply to C and C++ programs:Rely on ID="04.optimize166"libc.so functions (for example, strcpy, strlen, strcmp, bcopy, bzero, memset, and memcpy). These functions are carefully coded for efficiency.Use a signed data type, or cast to a signed data type, for any variable that does not require the full unsigned range and must be converted to floating-point. For example:ID="04.optimize167"double d;
unsigned int u;
int i;
/* fast */ d = i;
/* fast */ d = (int)u;
/* slow */ d = u;Converting an unsigned type to floating-point takes significantly longer than converting signed types to floating-point; additional software support must be generated in the instruction stream for the former case. Use signed ID="04.optimize168"ints in 64-bit code if they may appear in mixed type expressions with longints (or with long long ints in either 32-bit or 64-bit code). Since the hardware automatically sign-extends the results of most 32-bit operations, this may avoid explicit zero-extension code. For example:unsigned int ui;
signed int i;
long int li;
/* fast */ li += i;
/* fast */ li += (int)ui;
/* slow */ li += ui;LBL="" HELPID=""C++ Programs OnlyThe following suggestions apply to C++ programs:Inline whenever possible. Inline calls inside loops since functions calls that are not inlined prevent loop-nest optimizations and software pipelining.Use pre-increment (for example, increment i as ++i) instead of post-increment (i++) to avoid generating copy.Avoid using virtual functions. The penalty is in method lookup and the inability to inline them.Pass by value rather than const ref (to ameliorate aliasing problems).Avoid the creation of temporaries, that is, Aa = 1 is better than Aa = A(1).If your code does not use exception handing, use ­LANG:exceptions=off when compiling.LBL="" HELPID=""ID="78061"Register AllocationID="04.optimize169"The MIPS architecture emphasizes the use of registers. Therefore, register usage has a significant impact on program performance.The optimizer allocates registers for the most suitable data items, taking into account their frequency of use and their locations in the program structure. In addition, the optimizer assigns values to registers in such a way as to minimize shifting around within loops and during procedure invocations.LBL="" HELPID=""ID="58823"Using SpeedShop SpeedShop is an integrated package of performance tools that you can use to gather performance data and generate reports. To record the experiments, use the ID="04.optimize170"ID="04.optimize171"ssrun(1) command, which runs the experiment and captures data from an executable (or instrumented version). You can examine the data using prof. Speedshop also lets you start a process and attach a debugger to it.For detailed information about SpeedShop, ssrun, prof, and pixie, see the SpeedShop User's Guide. In particular, refer to:"Setting Up and Running Experiments: ssrun""Analyzing Experiment Results: prof"LBL="5"ID="67459"Coding for 64-Bit ProgramsThis chapter provides information about ways to write/update your code so that you can take advantage of the Silicon Graphics implementation of the IRIX 64-bit operating system. Specifically, this chapter describes:ID="05.64bit1"ID="05.64bit2"ID="05.64bit3"IDREF="78134" TYPE="TITLE""Coding Assumptions to Avoid"IDREF="20481" TYPE="TITLE""Guidelines for Writing Code for 64-Bit Silicon Graphics Platforms"Also, refer to IDREF="72950" TYPE="TITLE"Chapter 6, "Porting Code to N32 and 64-Bit Silicon Graphics Systems," for information about compatibility, porting guidelines, and details on data types, predefined types, typedefs, memory allocation, and so forth.LBL="" HELPID=""ID="78134"Coding Assumptions to AvoidMost porting problems come from assumptions, implicit or explicit, about either absolute or relative sizes of the ID="05.64bit4"int, long int, or pointer types in code. To avoid porting problems, examine code that assumes: IDREF="85000" TYPE="TITLE""sizeof(int) == sizeof(void *)"IDREF="93007" TYPE="TITLE""sizeof(int) == sizeof(long)"IDREF="57694" TYPE="TITLE""sizeof(long) == 4"IDREF="80275" TYPE="TITLE""sizeof(void *) == 4"IDREF="30242" TYPE="TITLE""Implicitly Declared Functions"IDREF="50854" TYPE="TITLE""Constants With the High-Order Bit Set"IDREF="60427" TYPE="TITLE""Arithmetic with long Types" (including shifts involving mixed types and code that may overflow 32 bits) LBL="" HELPID=""ID="85000"sizeof(int) == sizeof(void *)An assumption may arise from casting pointers to ID="05.64bit5"ints to do arithmetic, from unions that implicitly identify ID="05.64bit6"ints and pointers, or from passing pointers as actual arguments to functions where the corresponding formal arguments are declared as ints. Any of these practices may result in inadvertently truncating the high-order part of an address. ID="05.64bit7"The compilers generally detect the first case and provide warnings. Also given ANSI C function prototypes, the compilers generally detect the last case. No diagnostic messages are provided for unions that implicitly identify ints and pointers.You can declare an integer variable that is required to be the size of a pointer with the type ID="05.64bit8"ptrdiff_t in the standard header file stddef.h, or with the types __psint_t and __psunsigned_t in the header file inttypes.h.Also note that a cast of an ID="05.64bit9"int to a pointer may result in sign-extension, if the sign bit of the int is set when a ­64 compilation occurs.LBL="" HELPID=""ID="93007"sizeof(int) == sizeof(long)Data that fits in an ID="05.64bit10"int or long on 32-bit systems will fit in an int on 64-bit systems. Expansion, in this case, has no visible effect. Problems may occur, however, where an unsigned ID="05.64bit11"int actual parameter is passed to a long (signed or unsigned) formal parameter without benefit of an ANSI prototype. In this case, the unsigned value is implicitly sign-extended in the register, and therefore is misinterpreted in the callee if the sign bit was set. ID="05.64bit12"LBL="" HELPID=""ID="57694"sizeof(long) == 4A problem may occur in cases where long ID="05.64bit13"ints are used to map fields in data structures defined externally to be 32 bits, or where unions attempt to identify a long with four chars. ID="05.64bit14"LBL="" HELPID=""ID="80275"sizeof(void *) == 4Problems with this code are similar to those encountered with ID="05.64bit15"sizeof(long)==4. However, mappings to external data structures are seldom a problem, since the external definition also assumes 64-bit pointers.ID="05.64bit16"LBL="" HELPID=""ID="30242"Implicitly Declared FunctionsIt is always risky to call a function without an explicit declaration in scope. Furthermore, be sure to declare with a compatible prototype any function defined with a prototype. Problems arise when mixing prototype and nonprototype declarations for the same function. For example, suppose you call a function (defined with a prototype to take a variable number of arguments) in a scope without a prototyped declaration. You may get unexpected results if a floating point argument is passed to it. This is a typical problem with calls to ID="05.64bit17"printf and after stdio.h routines. Therefore, always include stdio.h in any context where you use stdio.h facilities.LBL="" HELPID=""ID="50854"Constants With the High-Order Bit SetA change in type sizes may yield some problems related to constants. Be careful about using constants with the high-order (ID="05.64bit18"sign) bit set. For instance, the hex constant 0xffffffff yields different results in the expression:long x;
... ( (long) ( x + 0xffffffff ) ) ...In both modes, the constant is interpreted as a 32-bit unsigned int, with value 4,294,967,295. In 32-bit mode, the addition results in a 32-bit unsigned long, which is cast to type long and has value x-1 because of the truncation to 32 bits. In 64-bit mode, the addition results in a 64-bit long with value x+4,294,967,295, and the cast is redundant.LBL="" HELPID=""ID="60427"Arithmetic with long TypesCode that does arithmetic (including shifting), and code that may overflow 32 bits and assumes particular treatment of the overflow (for example, truncation), can exhibit different behavior, depending on the mix of types involved (including signedness).ID="05.64bit19"Similarly, implicit casting in expressions that mix ID="05.64bit20"int and long values may produce unexpected results due to sign/zero extension. An int constant is sign- or zero-extended when it occurs in an expression with long values.LBL="" HELPID=""ID="16890"Solving Porting ProblemsOnce you identify porting problems, solve them by:ID="05.64bit21"changing the relevant declaration to one that has the desired characteristics in both target environmentsadding explicit type casts to force the correct conversionsusing function prototypes or using type suffixes (such as l or u) on constants to force the correct typeLBL="" HELPID=""ID="20481"Guidelines for Writing Code for 64-Bit Silicon Graphics PlatformsThe key to revising existing code and writing new code that is compatible with all of the major C data models is to avoid the assumptions described above in ID="05.64bit22"IDREF="78134" TYPE="TITLE""Coding Assumptions to Avoid." Since all of the assumptions described sometimes represent legitimate attributes of data objects, you need to tailor declarations to the target machines' data models.The following guidelines help you to produce portable code. Use these guidelines when you are developing new code or as you identify portability problems in existing code.ID="05.64bit23"ID="49403"In a header file that you include in each of the program's source files, define (typedef) a type for each of the following functions:For each specific integer data size required, that is, where exactly the same number of bits is required on each target, define a signed and unsigned type. For example:typedef signed char int8_t
typedef unsigned char uint8_t 
...
typedef unsigned long long uint64_tIf you require a large scaling integer type, that is, one that is as large as possible while remaining efficiently supported by the target, define another pair of types. For example:typedef signed long intscaled_t
typedef unsigned long uintscaled_tIf you require integer types of at least a particular size, but chosen for maximally efficient implementation on the target, define another set of types, similar to the first but defined as larger standard types where appropriate for efficiency. The typedefs referred to above exist in the file inttypes.h (see IDREF="41961" TYPE="TITLE""Using Typedefs").After you construct the above header file, use the new ID="05.64bit24"typedef types instead of the standard C type names. You may need a distinct copy of this header file (or conditional code) for each target platform supported.If you provide libraries or interfaces to be used by others, be careful to use these types (or similar application-specific types) chosen to match the specific requirements of the interface. Also, carefully choose the actual names used to avoid namespace conflicts with other libraries. Thus, your clients should be able to use a single set of header files on all targets. However, you will always need to provide distinct libraries (binaries) for the 32-bit compatibility mode and the 64-bit native mode on 64-bit Silicon Graphics platforms, although the sources can be identical.Be sure to specify constants with an appropriate type specifier so that they will have the size required by the context with the values expected. Bit masks can be particularly troublesome in this regard: avoid using constants for negative values. For example, 0xffffffff may be equivalent to a -1 on 32-bit systems, but may be interpreted as 4,294,967,295 (signed or unsigned, depending on the mode and context) on most 64-bit systems. The ID="05.64bit25"inttypes.h header file provides cpp macros to facilitate this conversion. Defining constants that are sensitive to type sizes in a central header file may help in modifying them when a new port is done. Where ID="05.64bit26"printf/scanf are used for objects whose types are typedefed differently among the targets you must support, you may need to define constant format strings for each of the types defined in step 1. For example:ID="05.64bit27"#define _fmt32 "%d" 
#define _fmt32u "%u"
#define _fmt64 "%lld"
#define _fmt64u "%llu"The inttypes.h header file also defines printf/scanf format extensions to standardize these practices. They are implemented by the first release of the 64-bit compilers and related tools. LBL="6"ID="72950"Porting Code to N32 and 64-Bit Silicon Graphics SystemsThis section explains the levels of compatibility between the new 32-bit compilation mode (n32), the old 32-bit mode, and 64-bit programs. It also describes the porting procedure to follow and the changes you must make to port your application from old 32-bit mode to n32-bit mode. ID="06.porting1"Specifically, this chapter discusses the following topics:ID="06.porting2"IDREF="70233" TYPE="TITLE""Compatibility," which describes compatibility between o32, n32, and 64-bit programs.IDREF="35006" TYPE="TITLE""N32 Porting Guidelines," which explains guidelines for porting high-level languages.IDREF="56873" TYPE="TITLE""Porting Code to 64-Bit Silicon Graphics Systems," which describes data types, typedefs, maximum memory allocation, and use of large files on XFS.This chapter uses the following terminology:o32The current 32-bit ABI generated by the ucode compiler, that is, 32-bit compilers prior to IRIX 6.1 operating system.ID="06.porting3"n32The new 32-bit ABI generated by the MIPSpro 64-bit compiler (for a list of n32 features, see ID="06.porting4"IDREF="44226" TYPE="TITLE"Chapter 1).For information about the n32 ABI, see MIPSpro N32 ABI Handbook.LBL="" HELPID=""ID="70233"CompatibilityIn order to execute different ABIs, support must exist at three levels:ID="06.porting5"The operating system must support the ABIThe libraries must support the ABIThe application must be recompiled with a compiler that supports the ABIID="06.porting6"IDREF="46397" TYPE="GRAPHIC"Figure 6-1 shows how applications rely on library support to use the operating system resources that they need. NoteEach o32, n32, and n64 application must be linked against unique libraries that conform to its respective ABI. As a result, you CANNOT mix and match objects files or libraries from any of the different ABIs.FILE="6.1.apps.diffABIs.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-1"Figure 6-1 ID="46397"Application Support Under Different ABIsIDREF="50359" TYPE="GRAPHIC"Figure 6-2 illustrates the library locations for different ABIs.FILE="6.2.lib.loc.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-2"Figure 6-2 ID="50359"Library Locations for Different ABIsAn operating system that supports all three ABIs is also needed for running the application. Consequently, all applications that want to use the features of n32 must be ported. The next section covers the steps in porting an application to the N32 ABI.LBL="" HELPID=""ID="35006"N32 Porting GuidelinesThis section describes the guidelines/steps necessary to port IRIX 5.ID="06.porting7"x 32-bit applications to n32. Typically, any porting project can be divided into the following tasks:Identifying and creating the necessary porting environment (see IDREF="84761" TYPE="TITLE""Porting Environment")Identifying and making the necessary source code changes (see IDREF="70778" TYPE="TITLE""Source Code Changes") Rebuilding the application for the target machine (see IDREF="45564" TYPE="TITLE""Build Procedure") Analyzing and debugging runtime issues (see IDREF="81693" TYPE="TITLE""Runtime Issues") Each of these tasks is described below. You can also find additional information about n32 in the MIPSpro N32 ABI Handbook.LBL="" HELPID=""ID="84761"Porting EnvironmentThe porting environment consists of a compiler and associated tools, ID="06.porting8"include files, libraries, and makefiles, all of which are necessary to compile and build your application. Version 6.1 of the MIPSpro (ragnarok) compiler supports the generation of n32 code. To generate this code, you must:Check all libraries needed by your application to make sure they are recompiled n32. The default root location for n32 libraries is /usr/lib32. If the n32 library needed by your application does not exist, recompile the library for n32.Modify existing makefiles (or set environment variables) to reflect the locations of these n32 libraries.LBL="" HELPID=""ID="70778"Source Code ChangesSince no differences exist in the sizes of fundamental types between the old 32-bit mode and n32, porting to n32 requires no source code changes for applications written in high-level languages such as C, C++, and Fortran. The only exception to this is that C functions that accept variable numbers of floating point arguments must be prototyped.ID="06.porting9"Assembly language code, however, must be modified to reflect the new subprogram interface. Guidelines for following this interface are described in Chapter 3 of the ID="06.porting10"MIPSpro N32 ABI Handbook in the section titled "Assembly Language Programming Guidelines."LBL="" HELPID=""ID="45564"Build ProcedureRecompiling for n32 involves either setting theID="06.porting11" -n32 argument in the compiler invocation or running the compiler with the environment variable SGI_ABI set to -n32. That's all you must do after you set up a native n32 compilation environment (that is, all necessary libraries and include files reside on the host system).LBL="" HELPID=""ID="81693"Runtime IssuesApplications that are ported to n32 may get different results than their o32 counterparts. Reasons for this include:ID="06.porting12"Differences in algorithms used by n32 libraries and o32 librariesOperand reassociation or reduction performed by the optimizer for n32.Hardware differences of the R8000 (madd instructions round slightly differently than a multiply instruction followed by an add instruction).For more information refer to Chapter 5 of the MIPSpro 64-bit Porting and Transition Guide.LBL="" HELPID=""ID="56873"Porting Code to 64-Bit Silicon Graphics SystemsThis section covers porting code to 64-bit Silicon Graphics systems, including:ID="06.porting13"IDREF="93275" TYPE="TITLE""Using Data Types"IDREF="85284" TYPE="TITLE""Using Predefined Types"IDREF="41961" TYPE="TITLE""Using Typedefs"IDREF="58456" TYPE="TITLE""Maximum Memory Allocation"IDREF="23940" TYPE="TITLE""Using Large Files With XFS"You can find additional information about porting to 64-bit Silicon Graphics systems in the MIPSpro Application Porting and Transition Guide.LBL="" HELPID=""ID="93275"Using Data TypesData types and sizes are listed in ID="06.porting14"IDREF="51702" TYPE="TABLE"Table 6-1. COLUMNS="3"LBL="6-1"Table 6-1 ID="51702" (continued)        Data Types and SizesLEFT="0" WIDTH="110"Data TypeLEFT="115" WIDTH="72"32 BitLEFT="195" WIDTH="72"64 BitLEFT="0" WIDTH="110"char ID="06.porting15"LEFT="115" WIDTH="72"8LEFT="195" WIDTH="72"8LEFT="0" WIDTH="110"short ID="06.porting16"LEFT="115" WIDTH="72"16LEFT="195" WIDTH="72"16LEFT="0" WIDTH="110"intID="06.porting17"LEFT="115" WIDTH="72"32LEFT="195" WIDTH="72"32LEFT="0" WIDTH="110"longID="06.porting18"LEFT="115" WIDTH="72"32LEFT="195" WIDTH="72"64LEFT="0" WIDTH="110"long long ID="06.porting19"LEFT="115" WIDTH="72"64LEFT="195" WIDTH="72"64LEFT="0" WIDTH="110"pointerID="06.porting20"LEFT="115" WIDTH="72"32LEFT="195" WIDTH="72"64LEFT="0" WIDTH="110"floatID="06.porting21"LEFT="115" WIDTH="72"32LEFT="195" WIDTH="72"32LEFT="0" WIDTH="110"doubleID="06.porting22"LEFT="115" WIDTH="72"64LEFT="195" WIDTH="72"64LEFT="0" WIDTH="110"long double*ID="06.porting23"LEFT="115" WIDTH="72"64LEFT="195" WIDTH="72"128LEFT="0" WIDTH="110"void*LEFT="115" WIDTH="72"32LEFT="195" WIDTH="72"64Note that in 64-bit mode, types long and int have different sizes and ranges; a long always has the same size as a pointer. A pointer (or address) has 64-bit representation in 64-bit mode and 32-bit representation in 32-bit mode. An int has a smaller range than a pointer in 64-bit mode.Characteristics of integral types and floating point types are defined in the standard files ID="06.porting24"limits.h and float.h.LBL="" HELPID=""ID="85284"Using Predefined TypesThe ID="06.porting25"cc, CC, and as compiler drivers produce predefined macros listed in IDREF="18474" TYPE="TABLE"Table 6-2. These macros are used in sys/asm.h, sys/regdef.h, and sys/fpregdef.h.COLUMNS="2"LBL="6-2"Table 6-2 ID="18474"Predefined MacrosLEFT="0" WIDTH="166"32-Bit ExecutablesLEFT="175" WIDTH="166"64-Bit ExecutablesLEFT="0" WIDTH="166"­D_MIPS_FPSET=16ID="06.porting26"LEFT="175" WIDTH="166"­D_MIPS_FPSET=32LEFT="0" WIDTH="166"­D_MIPS_ISA=_MIPS_ISA_MIPS1ID="06.porting27"LEFT="175" WIDTH="166"­D_MIPS_ISA=_MIPS_ISA_MIPS3LEFT="0" WIDTH="166"­D_MIPS_SIM=_MIPS_SIM_ABI32ID="06.porting28"LEFT="175" WIDTH="166"­D_MIPS_SIM=_MIPS_SIM_ABI64LEFT="0" WIDTH="166"­D_MIPS_SZINT=32ID="06.porting29"LEFT="175" WIDTH="166"­D_MIPS_SZINT=32LEFT="0" WIDTH="166"­D_MIPS_SZLONG=32ID="06.porting30"LEFT="175" WIDTH="166"­D_MIPS_SZLONG=64LEFT="0" WIDTH="166"­D_MIPS_SZPTR=32ID="06.porting31"LEFT="175" WIDTH="166"­D_MIPS_SZPTR=64_MIPS_FPSET describes the number of floating point registers. The 64-bit compilation mode makes use of the extended floating point registers.MIPS_ISA determines the MIPS Instruction Set Architecture. MIPS_ISA_MIPS1 and MIPS_ISA_MIPS3 are the defaults for 32 bits and 64 bits, respectively. For example:ID="06.porting32"/* Define a parameter for the integer register size: */
#if (_MIPS_ISA == _MIPS_ISA_MIPS1 || _MIPS_ISA == _MIPS_ISA_MIPS2)
#define SZREG           4
#else
#define SZREG           8
#endifMIPS_SIM determines the MIPS Subprogram Interface Model, which describes the subroutine linkage convention and register naming/usage convention._MIPS_SZINT, _MIPS_SZLONG, and _MIPS_SZPTR define the size of types int, long, and pointer, respectively.The 64-bit MIPSpro compiler drivers generate 64-bit pointers and longs and 32-bit ints. Therefore, assembler code that uses either pointer or long types must be converted to use double-word instructions for MIPS III code(­64), and must continue to use word instructions for MIPS I and MIPS II code (­32).Also, new subroutine linkage conventions and register naming conventions exist. The compiler predefined macro _MIPS_SIM enables macros in sys/asm.h and sys/regdef.h. Eight argument registers exist: ID="06.porting33"$4 through $11. Four additional argument registers replace the temp registers in sys/regdef.h. These temp registers are not lost, however, as the argument registers can serve also as scratch registers, with certain constraints. In the _MIPS_SIM_ABI64 model, registers t4 through t7 are not available, so any code using these registers does not compile. Similarly, registers a4 through a7 are not available under the _MIPS_SIM_ABI32 model. If you are converting assembler code, the new registers ta0, ta1, ta2, and ta3 are available under both _MIPS_SIM models. These alias with registers t4 through t7 in 32-bit mode, and with registers a4 through a7 in 64-bit mode.Note that the caller no longer has to reserve space for a called function in which to store its arguments. The called routine allocates space for storing its arguments on its own stack, if desired. The NARGSAVE macro in ID="06.porting34"sys/asm.h facilitates this.LBL="" HELPID=""ID="41961"Using Typedefs This section describes ID="06.porting35"typedefs that you can use to write portable code for a range of target environments, including 32- and 64-bit workstations as well as 16- and 32-bit PCs. These typedefs are enabled by compiler-predefined macros (listed in IDREF="18474" TYPE="TABLE"Table 6-2), and are in the file inttypes.h. (This discussion applies to C, although the same macros are predefined by the C++ compiler.)Portability problems exist because an ID="06.porting36"int (32 bits) is no longer the same size as a pointer (64 bits) and a long (64 bits) in 64-bit programs. Typedefs free you from having to know the underlying compilation model or worry about type sizes. In the future, if that model changes, the code should still work. Typically, you want source code that you can compile either in 32- or 64-bit mode. (In this discussion, 32-bit mode implies­mips1/2; 64-bit mode implies ­mips3/4.)The following typedefs are defined in inttypes.h:typedef signed char   int8_t;
typedef unsigned char   uint8_t;
typedef signed short  int16_t;
typedef unsigned short  uint16_t;
typedef signed int  int32_t;
typedef unsigned int  uint32_t;
typedef signed long long int  int64_t;
typedef unsigned long long int  uint64_t;
typedef signed long long int  intmax_t;
typedef unsigned long long int  uintmax_t;
typedef signed long int  intptr_t;
typedef unsigned long int  uintptr_t;intmax_t and uintmax_t are guaranteed to be the largest integer type supported by this implementation. Use them in code that must be able to deal with any integer value. ID="06.porting37"intptr_t and uintptr_t are guaranteed to be exactly the size of a pointer. LBL="" HELPID=""ID="58456"Maximum Memory Allocation The total memory allocation for a program, and individual arrays, can exceed 2 gigabytes (2 Gb, or 2,048 Mb). ID="06.porting38"Previous implementations of Fortran 77, C, and C++ limited the total program size, as well as the size of any single array, to 2 GB. The current release allows the total memory in use by the program to exceed 2 gigabytes. LBL="" HELPID=""Arrays Larger Than 2 GigabytesThe MIPSPro 7.1 compilers support arrays that are larger than 2 gigabytes for programs compiled under the ­64 ABI. The arrays can be local, global, and dynamically created as the following example demonstrates. (Note: Initializers are not provided for these arrays.) Large array support is limited to Fortran77, C, and C++. LBL="" HELPID=""Example of Arrays Larger Than 2 GigabytesThe following code shows an example of arrays larger than 2 gigabytes. $cat a2.c

#include <stdlib.h>

int i[0x100000008];

void foo()
{
int k[0x100000008];
 k[0x100000007] = 9;
 printf("%d \n", k[0x100000007]);
}

main()
{
char *j;
j = malloc(0x100000008);
 i[0x100000007] = 7;
 j[0x100000007] = 8;
 printf("%d \n", i[0x100000007]);
 printf("%d \n", j[0x100000007]);
 foo();

}You must run this program on a 64-bit operating system with IRIX version 6.2 (or higher). You can verify the system you have by typing uname -a. You must have enough swap space to support the working set size and you must have your shell limit datasize, stacksize, and vmemoryuse variables set to values large enough to support the sizes of the arrays (see sh(1) reference page). The following example compiles and runs the above code after setting the stacksize to a correct value:$uname -a
IRIX64 cydrome 6.2 03131016 IP19
$cc -64 -mips3 a2.c
$limit
cputime         unlimited
filesize        unlimited
datasize        unlimited
stacksize       65536 kbytesn
coredumpsize    unlimited
memoryuse       
descriptors     200 
vmemoryuse      unlimited
$limit stacksize unlimited
$limit
cputime         unlimited
filesize        unlimited
datasize        unlimited
stacksize       unlimited
coredumpsize    unlimited
memoryuse       754544 kbytes
descriptors     200 
vmemoryuse      unlimited
$a.out
7 
8 
9LBL="" HELPID=""ID="23940"Using Large Files With XFSAn application may create or encounter files greater than 2 gigabytes with XFS. If a program is doing sequential I/O and does not maintain internal byte counters, files greater than 2 Gb won't encounter problems. ID="06.porting39"However, if an application uses internal byte counters, then modifications are required.IDREF="42118" TYPE="TABLE"Table 6-3 lists potential problems and modifications required to enable files greater than 2 Gb to run on XFS. COLUMNS="2"LBL="6-3"Table 6-3 ID="42118"Modifications for Applications on XFSLEFT="0" WIDTH="166"ApplicationLEFT="175" WIDTH="166"ModificationLEFT="0" WIDTH="166"Uses an internal byte counter while 
readingLEFT="175" WIDTH="166"Change to type long longLEFT="0" WIDTH="166"Uses certain system calls such as lseek() 
and stat() that use 32-bit off_tLEFT="175" WIDTH="166"Use lseek64(), stat64(), and so forthLEFT="0" WIDTH="166"Relies on internal features of EFS (such 
as reads the raw disk)LEFT="175" WIDTH="166"Rewrite the application (so it doesn't 
read the raw disk)For more information about XFS, see Getting Started With XFS Filesystems.­32 optionIDREF="02.compiler44"General Options for Compiler DriversIDREF="02.compiler11"Using Command-Line Options ­64 optionIDREF="02.compiler46"General Options for Compiler DriversIDREF="02.compiler11"Using Command-Line Options ­ansi optionIDREF="02.compiler47"General Options for Compiler Drivers­Bsymbolic, compilingIDREF="03.dso25"Compiling with ­Bsymbolic­c optionIDREF="02.compiler48"General Options for Compiler DriversIDREF="02.compiler49"General Options for Compiler DriversIDREF="01.oview17"About the MIPSpro Compiler System­cckr optionIDREF="02.compiler51"General Options for Compiler Drivers­clist optionIDREF="04.optimize35"Running LNO­cord optionIDREF="02.compiler50"General Options for Compiler Drivers­D__EXTENSIONS__ optionIDREF="02.compiler83"General Options for Compiler Drivers­D_MIPS_FPSETIDREF="06.porting26"Using Predefined Types­D_MIPS_ISAIDREF="06.porting27"Using Predefined Types­D_MIPS_SIMIDREF="06.porting28"Using Predefined Types­D_MIPS_SZINTIDREF="06.porting29"Using Predefined Types­D_MIPS_SZLONGIDREF="06.porting30"Using Predefined Types­D_MIPS_SZPTRIDREF="06.porting31"Using Predefined Types­Dname optionIDREF="02.compiler52"General Options for Compiler Drivers­E optionIDREF="02.compiler53"General Options for Compiler Drivers­elspec optionIDREF="02.compiler54"General Options for Compiler Drivers­feedback optionIDREF="02.compiler55"General Options for Compiler Drivers­flist optionIDREF="04.optimize35"Running LNO­fullwarn optionIDREF="02.compiler56"General Options for Compiler Drivers­g optionIDREF="02.compiler57"General Options for Compiler DriversIDREF="02.compiler58"General Options for Compiler DriversIDREF="02.compiler99"Debugging­help optionIDREF="02.compiler59"General Options for Compiler Drivers­Idirname optionIDREF="02.compiler60"General Options for Compiler Drivers­INLINEIDREF="04.optimize12"Inlining Options for Routinesall optionIDREF="04.optimize13"Inlining Options for Routinesfile optionIDREF="04.optimize15"Inlining Options for Routinesmust optionIDREF="04.optimize14"Inlining Options for Routinesnever optionIDREF="04.optimize14"Inlining Options for Routinesnone optionIDREF="04.optimize13"Inlining Options for Routines­IPAIDREF="04.optimize16"Options To Control Inlining Heuristicsaddressing=ON optionIDREF="04.optimize28"The ­IPA:addressing=ON Optionalias=ON optionIDREF="04.optimize27"The ­IPA:alias=ON Optionforcedepth optionIDREF="04.optimize18"Options To Control Inlining Heuristicsmaxdepth optionIDREF="04.optimize17"Options To Control Inlining HeuristicsOlimit optionIDREF="04.optimize21"Options To Control Inlining Heuristicsopt_alias=ON optionIDREF="04.optimize29"The ­IPA:opt_alias=ON Option plimit optionIDREF="04.optimize20"Options To Control Inlining Heuristicsspace optionIDREF="04.optimize19"Options To Control Inlining Heuristics­KPIC optionIDREF="02.compiler61"General Options for Compiler DriversIDREF="02.compiler25"Position-Independent Code­mips1 optionIDREF="02.compiler62"General Options for Compiler Drivers­mips2 optionIDREF="02.compiler63"General Options for Compiler Drivers­mips3 optionIDREF="02.compiler64"General Options for Compiler Drivers­mips4 optionIDREF="02.compiler65"General Options for Compiler Drivers­multigot optionIDREF="02.compiler88"Linker SyntaxIDREF="02.compiler66"General Options for Compiler Drivers­n32 optionIDREF="02.compiler45"General Options for Compiler DriversIDREF="02.compiler11"Using Command-Line Options ­nocpp optionIDREF="02.compiler67"General Options for Compiler Drivers­non_shared optionIDREF="02.compiler68"General Options for Compiler Drivers­nostdinc optionIDREF="02.compiler69"General Options for Compiler Drivers­o filename optionIDREF="02.compiler70"General Options for Compiler Drivers­Onum optionIDREF="02.compiler71"General Options for Compiler Drivers­OPT optionIDREF="02.compiler72"General Options for Compiler Driversdiv_split optionIDREF="04.optimize103"Simplifying Code With the ­OPT Optionfold_reassociate optionIDREF="04.optimize104"Simplifying Code With the ­OPT Optionfold_unsafe_relops<DeIDREF="04.optimize105"Simplifying Code With the ­OPT Optionfold_unsigned_relops optionIDREF="04.optimize106"Simplifying Code With the ­OPT Optionrecip optionIDREF="04.optimize108"Simplifying Code With the ­OPT Optionrsqrt optionIDREF="04.optimize109"Simplifying Code With the ­OPT Option­P optionIDREF="02.compiler74"General Options for Compiler DriversIDREF="02.compiler73"General Options for Compiler Drivers­pch optionIDREF="02.compiler75"General Options for Compiler Drivers­r10000 optionIDREF="04.optimize139"Controlling the Target Architecture ­r5000 optionIDREF="04.optimize139"Controlling the Target Architecture ­r8000 optionIDREF="04.optimize140"Controlling the Target Architecture ­S optionIDREF="02.compiler76"General Options for Compiler Drivers­show optionIDREF="01.oview18"About the MIPSpro Compiler SystemIDREF="02.compiler77"General Options for Compiler Drivers­show_defaults optionIDREF="02.compiler10"Using a Defaults Specification File­TARG optionIDREF="02.compiler78"General Options for Compiler Drivers­TENV optionIDREF="02.compiler79"General Options for Compiler Drivers­Uname optionIDREF="02.compiler80"General Options for Compiler Drivers­woff optionIDREF="02.compiler81"General Options for Compiler Drivers­xansi optionIDREF="02.compiler82"General Options for Compiler Drivers­xgot option. See­multigot optionIDREF="02.compiler66"General Options for Compiler Drivers32-bit modeIDREF="02.compiler1"Selecting a CompilerIDREF="06.porting36"Using Typedefs Also see n32IDREF="06.porting2"Porting Code to N32 and 64-Bit Silicon Graphics SystemscompatibilityIDREF="06.porting5"Compatibilitydata typesIDREF="06.porting14"Using Data TypesdefinitionIDREF="06.porting3"Porting Code to N32 and 64-Bit Silicon Graphics SystemslibrariesIDREF="06.porting6"Compatibilityn32 definitionIDREF="06.porting4"Porting Code to N32 and 64-Bit Silicon Graphics SystemsoverflowIDREF="05.64bit19"Arithmetic with long Types porting to n32IDREF="06.porting7"N32 Porting Guidelines4.3 BSD extensionsIDREF="02.compiler83"General Options for Compiler Drivers64-bit modeIDREF="02.compiler1"Selecting a Compilerdata typesIDREF="06.porting14"Using Data TypeslibrariesIDREF="06.porting6"Compatibility64-bit mode IDREF="05.64bit1"Coding for 64-Bit Programsa.out filesIDREF="02.compiler84"LinkingABIoptionsIDREF="04.optimize134"Controlling the Target Architecture abi optionsIDREF="02.compiler7"Using a Defaults Specification FileABI specificationIDREF="02.compiler5"Using a Defaults Specification FileIDREF="02.compiler4"Using a Defaults Specification Fileaddress aliasesIDREF="04.optimize25"Alias and Address Taken Analysisaddress spaceIDREF="03.dso35"Dynamic Loading Under Program Controladdresses, optimizationIDREF="04.optimize160"Example of Pointer Placement and Aliasingalias analysisIDREF="04.optimize25"Alias and Address Taken Analysisaliasingand pointer placementIDREF="04.optimize155"Optimizing C and C++ ProgramsmemoryIDREF="04.optimize98"Using the ­OPT:alias OptionoptimizationIDREF="04.optimize155"Optimizing C and C++ Programsanalysis, dependenceIDREF="04.optimize78"Dependence Analysis analyzer, parallelIDREF="01.oview16"About the MIPSpro Compiler SystemIDREF="01.oview10"About the MIPSpro Compiler Systemar commandcommand syntaxIDREF="02.compiler133"ar SyntaxoptionsIDREF="02.compiler134"ar Optionsar command IDREF="02.compiler132"Using the Archiver to Create Librariesarchitectureinstruction setIDREF="04.optimize137"Controlling the Target Architecture optimizing programsIDREF="04.optimize135"Controlling the Target Architecture optionsIDREF="04.optimize134"Controlling the Target Architecture archive librariesIDREF="03.dso3"Using Dynamic Shared Objectsarchiver. See ar commandIDREF="02.compiler132"Using the Archiver to Create Librariesargument registersIDREF="06.porting33"Using Predefined TypesargumentsstoreIDREF="06.porting34"Using Predefined Typesarrays2 gigabyteIDREF="06.porting38"Maximum Memory Allocation as assemblerIDREF="02.compiler90"Linking Assembly Language Programsassembly language programsporting to n32IDREF="06.porting10"Source Code Changesassembly language programs, linkingIDREF="02.compiler91"Linking Assembly Language Programsback substitutionIDREF="04.optimize128"Recurrence Breakingbit masksIDREF="05.64bit25"Guidelines for Writing Code for 64-Bit Silicon Graphics PlatformsBLOCK DATAIDREF="03.dso27"Compiling with ­Bsymbolicblock paddingIDREF="04.optimize22"Common Block PaddingrestrictionsIDREF="04.optimize24"Common Block Paddingblocking and permutation transformationsIDREF="04.optimize76"Blocking and Permutation Transformations controllingIDREF="04.optimize63"Controlling Blocking and Permutation Transformations branch eliminationIDREF="04.optimize119"If ConversionBSD 4.3 extensionsIDREF="02.compiler83"General Options for Compiler Driversbuild proceduren32IDREF="06.porting11"Build Procedurebyte countersand file sizeIDREF="06.porting39"Using Large Files With XFSC languagefloating pointIDREF="04.optimize80"Controlling Floating Point Optimizationprecompiled headersIDREF="02.compiler34"Using Precompiled Headers in C and C++C programsoptimizationIDREF="04.optimize149"Optimizing C, C++, and Fortran ProgramsC++ building DSOsIDREF="03.dso17"Using DSOs With C++language definitionsIDREF="02.compiler33"Creating a Header File for Multiple Languagesld optionsIDREF="03.dso18"Using DSOs With C++precompiled headersIDREF="02.compiler34"Using Precompiled Headers in C and C++C++ programsoptimizationIDREF="04.optimize149"Optimizing C, C++, and Fortran Programscacheconflicts and paddingIDREF="04.optimize23"Common Block PaddingmissesIDREF="04.optimize51"Prefetchingcache optimization­LNO optionIDREF="04.optimize67"Controlling Blocking and Permutation Transformations cache parameterscontrolling with LNOIDREF="04.optimize62"Controlling Cache Parameters CC compiler. See driversIDREF="01.oview8"About the MIPSpro Compiler SystemcharIDREF="06.porting15"Using Data TypescodearithmeticIDREF="05.64bit19"Arithmetic with long TypesassumptionsIDREF="05.64bit4"Coding Assumptions to AvoidconversionIDREF="04.optimize117"If ConversionhintsIDREF="05.64bit4"Coding Assumptions to Avoidoverflow 32 bitsIDREF="05.64bit19"Arithmetic with long TypesportableIDREF="05.64bit22"Guidelines for Writing Code for 64-Bit Silicon Graphics Platformsporting to 64-bit systemIDREF="06.porting13"Porting Code to 64-Bit Silicon Graphics Systemsporting to n32-bit systemsIDREF="06.porting1"Porting Code to N32 and 64-Bit Silicon Graphics SystemsshiftsIDREF="05.64bit19"Arithmetic with long Typessigned intsIDREF="04.optimize168"C and C++ Programssizeof(int)==sizeof(long)IDREF="05.64bit10"sizeof(int) == sizeof(long)sizeof(int)==sizeof(void*)IDREF="05.64bit5"sizeof(int) == sizeof(void *)sizeof(long)==4IDREF="05.64bit13"sizeof(long) == 4sizeof(void*)==4IDREF="05.64bit15"sizeof(void *) == 4transformationIDREF="04.optimize117"If ConversiontypedefsIDREF="06.porting35"Using Typedefs view transformationsIDREF="04.optimize37"Running LNOwriting for 64-bit applicationsIDREF="05.64bit2"Coding for 64-Bit Programszero-extensionIDREF="04.optimize168"C and C++ Programscode generatorIDREF="04.optimize111"The Code Generator ­O0 optionIDREF="04.optimize114"Code Generator and Optimization Levels ­O1 optionIDREF="04.optimize114"Code Generator and Optimization Levels ­O2 optionIDREF="04.optimize116"Code Generator and Optimization Levels ­02 and ­03­O3 optionIDREF="04.optimize116"Code Generator and Optimization Levels ­02 and ­03Also see optimizing programsIDREF="04.optimize113"Overview of the Code Generator and optimization levelsIDREF="04.optimize114"Code Generator and Optimization Levels IDREF="04.optimize116"Code Generator and Optimization Levels ­02 and ­03back substitutionIDREF="04.optimize128"Recurrence Breakingbranch eliminationIDREF="04.optimize119"If Conversioncross-iteration optimizationIDREF="04.optimize121"Cross-Iteration Optimizationsread-read eliminationIDREF="04.optimize122"Read-Read Eliminationread-write eliminationIDREF="04.optimize123"Read-Write Eliminationsub-expression eliminationIDREF="04.optimize125"Common Sub-expression Eliminationwrite-write eliminationIDREF="04.optimize124"Write-Write EliminationfeedbackIDREF="04.optimize133"Frequency and Feedbackfrequency of executionIDREF="04.optimize133"Frequency and Feedbackif conversionIDREF="04.optimize117"If Conversionif conversion and floating pointsIDREF="04.optimize120"If Conversioninstruction-level parallelismIDREF="04.optimize118"If ConversionlatencyIDREF="04.optimize132"Prefetch and Load Latencyloop unrollingIDREF="04.optimize131"Modifying Code Generator DefaultsIDREF="04.optimize126"Loop Unrollingmemory exceptionsIDREF="04.optimize120"If Conversionmodify defaultIDREF="04.optimize131"Modifying Code Generator DefaultsprefetchIDREF="04.optimize132"Prefetch and Load LatencyR10000 optimizationIDREF="04.optimize118"If Conversionrecurrence breakingIDREF="04.optimize127"Recurrence Breakingsoftware pipeliningIDREF="04.optimize129"Software PipeliningIDREF="04.optimize131"Modifying Code Generator Defaultssteps at ­O2 and ­O3IDREF="04.optimize130"Steps Performed By the Code Generator at Levels ­O2 and ­O3 COFFIDREF="02.compiler17"Executable and Linking Formatcommon block paddingIDREF="04.optimize22"Common Block PaddingrestrictionsIDREF="04.optimize24"Common Block PaddingCommon Object File FormatIDREF="02.compiler17"Executable and Linking FormatCOMMON symbolsIDREF="03.dso26"Compiling with ­Bsymboliccompiler back endIDREF="01.oview13"About the MIPSpro Compiler Systemcompiler drivers. See drivers<$nopaIDREF="01.oview6"About the MIPSpro Compiler Systemcompiler front endIDREF="01.oview12"About the MIPSpro Compiler Systemcompiler options. See driversIDREF="02.compiler43"General Options for Compiler Driverscompiler system32-bit modeIDREF="02.compiler11"Using Command-Line Options 64-bit modeIDREF="02.compiler11"Using Command-Line Options componentsIDREF="01.oview5"About the MIPSpro Compiler SystemmacrosIDREF="06.porting25"Using Predefined Typesn32-bit modeIDREF="02.compiler11"Using Command-Line Options overviewIDREF="01.oview5"About the MIPSpro Compiler Systempredefined typesIDREF="06.porting25"Using Predefined Typescompiler.defaults fileIDREF="02.compiler3"Using a Defaults Specification FileCOMPILER_DEFAULTS_PATH environment variableIDREF="02.compiler4"Using a Defaults Specification Filecompiling with ­BsymbolicIDREF="03.dso25"Compiling with ­Bsymbolicconstant format stringsIDREF="05.64bit26"Guidelines for Writing Code for 64-Bit Silicon Graphics PlatformsconstantsIDREF="05.64bit18"Constants With the High-Order Bit Setnegative valuesIDREF="05.64bit25"Guidelines for Writing Code for 64-Bit Silicon Graphics Platformsconventions, syntaxIDREF="intro1"Conventions Used in This Guideconversion of codeIDREF="04.optimize117"If Conversioncopt optimizerIDREF="01.oview11"About the MIPSpro Compiler Systemcounters, internal byteIDREF="06.porting39"Using Large Files With XFScpp preprocessorIDREF="01.oview9"About the MIPSpro Compiler Systemcross-file inliningIDREF="04.optimize15"Inlining Options for Routinescross-iteration optimizationIDREF="04.optimize121"Cross-Iteration Optimizationsread-read eliminationIDREF="04.optimize122"Read-Read Eliminationread-write eliminationIDREF="04.optimize123"Read-Write Eliminationsub-expression eliminationIDREF="04.optimize125"Common Sub-expression Eliminationwrite-write eliminationIDREF="04.optimize124"Write-Write EliminationdataprefetchingIDREF="04.optimize50"Prefetchingdata alignmentoptimizingIDREF="04.optimize145"Controlling the Target Environmentdata typesignedIDREF="04.optimize167"C and C++ Programsdata typessizesIDREF="06.porting14"Using Data Typesdebuggingdriver optionsIDREF="02.compiler99"Debuggingfloating pointsIDREF="04.optimize96"Debugging Floating-Point Problemsdefaultscompilation modesIDREF="02.compiler2"Selecting a Compilerspecification fileIDREF="02.compiler3"Using a Defaults Specification Filedependence analysisIDREF="04.optimize70"Dependence Analysis IDREF="04.optimize78"Dependence Analysis directivesLNOIDREF="04.optimize71"Pragmas and Directives for LNO dis commandIDREF="02.compiler108"Disassembling Object Files with disIDREF="02.compiler101"Getting Information About Object Filescommand syntaxIDREF="02.compiler109"Disassembling Object Files with disoptionsIDREF="02.compiler110"dis Optionsdisabling trapsIDREF="04.optimize144"Controlling the Target Environmentdisassemble object fileIDREF="02.compiler101"Getting Information About Object Filesdlclose()IDREF="03.dso34"Dynamic Loading Under Program Controldlerror()IDREF="03.dso33"Dynamic Loading Under Program Controldlopen()IDREF="03.dso30"Dynamic Loading Under Program Controldlsym()IDREF="03.dso32"Dynamic Loading Under Program ControldoubleIDREF="06.porting22"Using Data Typesdrivers­c optionIDREF="01.oview17"About the MIPSpro Compiler System­KPICIDREF="02.compiler25"Position-Independent Code­non_sharedIDREF="02.compiler25"Position-Independent Code­show optionIDREF="01.oview18"About the MIPSpro Compiler Systemas assemblerIDREF="02.compiler90"Linking Assembly Language ProgramsbypassingIDREF="01.oview15"About the MIPSpro Compiler Systemcc compilerIDREF="01.oview6"About the MIPSpro Compiler SystemIDREF="01.oview6"About the MIPSpro Compiler SystemdefaultsIDREF="02.compiler6"Using a Defaults Specification FileIDREF="02.compiler42"Default Behavior for Compiler Driversf77/90 compilerIDREF="01.oview6"About the MIPSpro Compiler Systemfec preprocessorIDREF="01.oview15"About the MIPSpro Compiler Systemfile name suffixesIDREF="02.compiler27"Source File Naming Conventionsinput file suffixesIDREF="02.compiler27"Source File Naming ConventionslinkingIDREF="01.oview17"About the MIPSpro Compiler Systemomit linkingIDREF="01.oview17"About the MIPSpro Compiler Systemoptimizing programsIDREF="04.optimize82"Controlling Floating Point OptimizationoptionsIDREF="02.compiler43"General Options for Compiler DriversIDREF="02.compiler99"Debuggingoptions to ldIDREF="02.compiler85"Invoking the Linker Manuallystages of compilationIDREF="01.oview18"About the MIPSpro Compiler SystemDSOsIDREF="02.compiler21"Dynamic Shared ObjectsIDREF="01.oview2"About the MIPSpro Compiler SystemIDREF="02.compiler14"Object File Format and Dynamic Linkingbuilding new DSOsIDREF="03.dso11"Building DSOsC++IDREF="03.dso17"Using DSOs With C++converting librariesIDREF="03.dso28"Converting Libraries to DSOscreating DSOsIDREF="03.dso11"Building DSOsdlclose()IDREF="03.dso34"Dynamic Loading Under Program Controldlerror()IDREF="03.dso33"Dynamic Loading Under Program Controldlopen()IDREF="03.dso30"Dynamic Loading Under Program Controldlsym()IDREF="03.dso32"Dynamic Loading Under Program Controldynamic loading diagnosticsIDREF="03.dso33"Dynamic Loading Under Program Controlexporting symbolsIDREF="03.dso16"Controlling Symbols to Be Exported or LoadedguidelinesIDREF="03.dso5"Guidelines for Using Shared Librarieshiding symbolsIDREF="03.dso16"Controlling Symbols to Be Exported or Loadedlibraries, sharedIDREF="03.dso5"Guidelines for Using Shared LibrarieslinkingIDREF="02.compiler95"Linking to Previously Built Dynamic Shared Objectsloading dynamicallyIDREF="03.dso30"Dynamic Loading Under Program Controlmmap() system callIDREF="03.dso36"Dynamic Loading Under Program Controlmunmap() system callIDREF="03.dso35"Dynamic Loading Under Program Controlnaming conventionsIDREF="03.dso14"Creating DSOsQuickStartIDREF="03.dso8"Taking Advantage of QuickStartQuickStart registry fileIDREF="03.dso20"Using Registry Filesregistry filesIDREF="03.dso19"Using Registry Filessearch pathIDREF="03.dso22"Searching for DSOs at Run Timesgidladd()IDREF="03.dso31"Dynamic Loading Under Program Controlshared librariesIDREF="03.dso5"Guidelines for Using Shared Librariesstarting quicklyIDREF="03.dso9"Taking Advantage of QuickStartunloading dynamicallyIDREF="03.dso34"Dynamic Loading Under Program ControlversioningIDREF="03.dso37"The Versioning MechanismDSOs IDREF="03.dso1"Using Dynamic Shared Objectsdump command. See elfdumpIDREF="02.compiler114"Listing Parts of ELF Object Files and Libraries with elfdumpDWARF symbolic informationIDREF="02.compiler111"Listing Parts of DWARF Object Files With dwarfdump dwarfdump commandIDREF="02.compiler102"Getting Information About Object FilesIDREF="02.compiler111"Listing Parts of DWARF Object Files With dwarfdump optionsIDREF="02.compiler112"dwarfdump Optionsdynamic linkingIDREF="03.dso29"Dynamic Loading Under Program ControlIDREF="02.compiler15"Object File Format and Dynamic LinkingIDREF="01.oview3"About the MIPSpro Compiler SystemDynamic Shared Objects. See DSOsIDREF="02.compiler95"Linking to Previously Built Dynamic Shared ObjectsElf object fileIDREF="02.compiler111"Listing Parts of DWARF Object Files With dwarfdump ELF. See executable and linking formatIDREF="02.compiler18"Executable and Linking Formatelfdump commandIDREF="02.compiler113"Listing Parts of ELF Object Files and Libraries with elfdumpIDREF="02.compiler114"Listing Parts of ELF Object Files and Libraries with elfdumpIDREF="02.compiler103"Getting Information About Object Filescommand syntaxIDREF="02.compiler115"Listing Parts of ELF Object Files and Libraries with elfdumpoptionsIDREF="02.compiler116"elfump OptionseliminationbranchesIDREF="04.optimize119"If Conversionread-readIDREF="04.optimize122"Read-Read Eliminationread-writeIDREF="04.optimize123"Read-Write Eliminationsub-expressionIDREF="04.optimize125"Common Sub-expression Eliminationwrite-writeIDREF="04.optimize124"Write-Write Eliminationenvironmentoptimizing programsIDREF="04.optimize141"Controlling the Target Environmentenvironment variableCOMPILER_DEFAULTS_PATHIDREF="02.compiler4"Using a Defaults Specification Fileenvironment variables32-bit compilationIDREF="02.compiler12"Setting an Environment Variable64-bit compilationIDREF="02.compiler12"Setting an Environment Variablen32-bit compilationIDREF="02.compiler12"Setting an Environment Variableexecutable and linking formatIDREF="02.compiler13"Object File Format and Dynamic LinkingIDREF="02.compiler17"Executable and Linking FormatIDREF="01.oview1"About the MIPSpro Compiler Systemexecutable filesIDREF="02.compiler20"Executable and Linking Formatexporting symbolsIDREF="03.dso15"Controlling Symbols to Be Exported or LoadedexpressionsoptimizingIDREF="04.optimize103"Simplifying Code With the ­OPT OptionextensionsignIDREF="05.64bit20"Arithmetic with long TypeszeroIDREF="05.64bit20"Arithmetic with long Typesf77/90 compilerIDREF="01.oview6"About the MIPSpro Compiler Systemfec preprocessorIDREF="01.oview12"About the MIPSpro Compiler SystembypassingIDREF="01.oview15"About the MIPSpro Compiler Systemfecc preprocessorIDREF="01.oview12"About the MIPSpro Compiler Systemfeedbackand code generatorIDREF="04.optimize133"Frequency and Feedbackfef77/90 preprocessorIDREF="01.oview12"About the MIPSpro Compiler Systemfef77/90p analyzerIDREF="01.oview16"About the MIPSpro Compiler SystemIDREF="01.oview10"About the MIPSpro Compiler Systemfile commandIDREF="02.compiler104"Getting Information About Object FilesIDREF="02.compiler117"Determining File Type with file command syntaxIDREF="02.compiler118"Determining File Type with file exampleIDREF="02.compiler119"file ExampleoptionsIDREF="02.compiler118"Determining File Type with file file inliningIDREF="04.optimize10"Performance Tuning with Interprocedural Analysisfile type, determiningIDREF="02.compiler117"Determining File Type with file files2 gigabyte sizeIDREF="06.porting39"Using Large Files With XFScompilation specificationIDREF="02.compiler3"Using a Defaults Specification FileexecutableIDREF="02.compiler20"Executable and Linking FormatheaderIDREF="02.compiler28"Header FilesincludeIDREF="02.compiler28"Header Filesinternal byte countersIDREF="06.porting39"Using Large Files With XFSlisting propertiesIDREF="02.compiler104"Getting Information About Object Filesnaming conventionsIDREF="02.compiler26"Source File Naming Conventionsprecompiled headerIDREF="02.compiler34"Using Precompiled Headers in C and C++relocatableIDREF="02.compiler19"Executable and Linking FormatsizeIDREF="06.porting39"Using Large Files With XFSfission controllingIDREF="04.optimize58"Controlling Fission and Fusion LNOIDREF="04.optimize74"Fission/Fusion loopsIDREF="04.optimize48"Loop Fission/DistributionfloatIDREF="06.porting21"Using Data Typesfloat.h include fileIDREF="06.porting24"Using Data Typesfloating pointsdebuggingIDREF="04.optimize96"Debugging Floating-Point Problemsif conversionIDREF="04.optimize120"If ConversionoptimizationIDREF="04.optimize81"Controlling Floating Point OptimizationoptimizingIDREF="04.optimize104"Simplifying Code With the ­OPT OptionreassociationIDREF="04.optimize104"Simplifying Code With the ­OPT Optionformatobject fileIDREF="01.oview1"About the MIPSpro Compiler SystemIDREF="02.compiler13"Object File Format and Dynamic LinkingFortranfloating pointIDREF="04.optimize80"Controlling Floating Point Optimizationpadding global arraysIDREF="04.optimize23"Common Block Paddingprogram optimizationIDREF="04.optimize115"An Example of Local Optimization for Fortran Fortran programsoptimizationIDREF="04.optimize149"Optimizing C, C++, and Fortran Programsfunctionsimplicitly declaredIDREF="05.64bit17"Implicitly Declared FunctionsfusioncontrollingIDREF="04.optimize58"Controlling Fission and Fusion LNOIDREF="04.optimize74"Fission/Fusion loopIDREF="04.optimize46"Loop Fusiongather-scatterIDREF="04.optimize53"Gather-Scatter OptimizationcontrollingIDREF="04.optimize60"Controlling Gather-Scatter global arrayspaddingIDREF="04.optimize23"Common Block Paddingglobal offset tableIDREF="02.compiler24"Position-Independent Codeglobal offset table overflowIDREF="02.compiler66"General Options for Compiler Driversglobal optimizerIDREF="04.optimize148"Overview of the Global OptimizerGOTIDREF="02.compiler24"Position-Independent CodeGOT overflowIDREF="02.compiler66"General Options for Compiler DriversguidelinesportingIDREF="06.porting7"N32 Porting Guidelinesheader filesIDREF="02.compiler28"Header Filesmultiple languagesIDREF="02.compiler31"Creating a Header File for Multiple LanguagesportableIDREF="05.64bit23"Guidelines for Writing Code for 64-Bit Silicon Graphics PlatformsprecompiledIDREF="02.compiler34"Using Precompiled Headers in C and C++specificationIDREF="02.compiler30"Specifying a Header Filehigh-order bitIDREF="05.64bit18"Constants With the High-Order Bit SetIEEEfloating pointsIDREF="04.optimize85"­OPT:IEEE_arithmetic=noptimizationIDREF="04.optimize85"­OPT:IEEE_arithmetic=nif conversionIDREF="04.optimize117"If Conversionif-then-else statementsoptimizationIDREF="04.optimize164"C, C++, and Fortran Programsimplicitly declared functionIDREF="05.64bit17"Implicitly Declared Functionsinclude filesIDREF="02.compiler28"Header Filesfloat.hIDREF="06.porting24"Using Data Typesinttypes.hIDREF="06.porting35"Using Typedefs limits.hIDREF="06.porting24"Using Data Typesmultiple languagesIDREF="02.compiler32"Creating a Header File for Multiple Languagesn32IDREF="06.porting8"Porting Environmentindirectcalls, usingIDREF="04.optimize150"Optimizing C, C++, and Fortran ProgramsinlinerstandaloneIDREF="04.optimize15"Inlining Options for RoutinesinliningIDREF="04.optimize10"Performance Tuning with Interprocedural AnalysisbenefitsIDREF="04.optimize11"Benefits of Inlininginput file namesIDREF="02.compiler26"Source File Naming Conventionsinstructionmips4 recipIDREF="04.optimize108"Simplifying Code With the ­OPT Optionmips4 rsqrtIDREF="04.optimize109"Simplifying Code With the ­OPT OptionprefetchingIDREF="04.optimize50"Prefetchinginstruction-level parallelismIDREF="04.optimize118"If ConversionintIDREF="06.porting36"Using Typedefs IDREF="06.porting17"Using Data TypesIDREF="05.64bit8"sizeof(int) == sizeof(void *)integeroverflowIDREF="04.optimize107"Simplifying Code With the ­OPT OptionscalingIDREF="05.64bit23"Guidelines for Writing Code for 64-Bit Silicon Graphics PlatformsinterleavingreductionIDREF="04.optimize127"Recurrence Breakinginternal byte countersand file sizeIDREF="06.porting39"Using Large Files With XFSinttypes.h include fileIDREF="06.porting35"Using Typedefs ISAoptionsIDREF="04.optimize134"Controlling the Target Architecture isa optionsIDREF="02.compiler8"Using a Defaults Specification FileISA specificationIDREF="02.compiler4"Using a Defaults Specification FileIDREF="02.compiler5"Using a Defaults Specification Filelatencyand code generatorIDREF="04.optimize132"Prefetch and Load Latencyld­shared optionIDREF="03.dso13"Creating DSOsand assembly language programsIDREF="02.compiler91"Linking Assembly Language Programs C++IDREF="03.dso17"Using DSOs With C++command syntaxIDREF="02.compiler86"Linker SyntaxDSOsIDREF="03.dso17"Using DSOs With C++dynamic linkingIDREF="01.oview3"About the MIPSpro Compiler SystemIDREF="02.compiler15"Object File Format and Dynamic LinkingexampleIDREF="02.compiler89"Linker Examplelibraries, default search pathIDREF="02.compiler94"Specifying Libraries and DSOslibraries, specifyingIDREF="02.compiler93"Linking Librarieslink editorIDREF="01.oview14"About the MIPSpro Compiler Systemmultilanguage programsIDREF="02.compiler96"Linking Multilanguage ProgramsoptionsIDREF="02.compiler87"Linker SyntaxIDREF="03.dso18"Using DSOs With C++registry filesIDREF="03.dso21"Using Registry FilesLD_BIND_NOWIDREF="03.dso24"Run-Time Symbol Resolutionlib.so functionsoptimizationIDREF="04.optimize166"C and C++ ProgramslibdlIDREF="03.dso29"Dynamic Loading Under Program ControllibrariesarchiveIDREF="03.dso3"Using Dynamic Shared Objectsglobal dataIDREF="03.dso7"Tuning Shared Library Codeheader filesIDREF="02.compiler28"Header FileslibdlIDREF="03.dso29"Dynamic Loading Under Program ControllocalityIDREF="03.dso7"Tuning Shared Library Codenon-shared, converting to DSOsIDREF="03.dso28"Converting Libraries to DSOspagingIDREF="03.dso7"Tuning Shared Library CodepathIDREF="02.compiler9"Using a Defaults Specification Fileroutines to excludeIDREF="03.dso6"Choosing Library Membersroutines to includeIDREF="03.dso6"Choosing Library Membersself-containedIDREF="03.dso6"Choosing Library MemberssharedIDREF="01.oview2"About the MIPSpro Compiler SystemIDREF="02.compiler14"Object File Format and Dynamic Linkingshared, staticIDREF="03.dso3"Using Dynamic Shared ObjectsIDREF="02.compiler22"Dynamic Shared ObjectsspecifyingIDREF="02.compiler92"Linking Librariesstatic dataIDREF="03.dso6"Choosing Library MemberstuningIDREF="03.dso7"Tuning Shared Library Codelimits.h include fileIDREF="06.porting24"Using Data Typeslinkingdynamic. See ldIDREF="02.compiler15"Object File Format and Dynamic LinkingIDREF="01.oview3"About the MIPSpro Compiler SystemomitIDREF="01.oview17"About the MIPSpro Compiler Systemlinking. See ldIDREF="02.compiler96"Linking Multilanguage ProgramsLNO. See optimizing programs, ­LNO optionIDREF="04.optimize31"Controlling Loop Nest Optimizationsloaderruntime. See rldIDREF="03.dso4"Benefits of Using DSOsloadingsymbolsIDREF="03.dso15"Controlling Symbols to Be Exported or Loadedlocal variablesoptimizationIDREF="04.optimize153"Optimizing C and C++ ProgramslongIDREF="06.porting36"Using Typedefs IDREF="06.porting18"Using Data Typeslong doubleIDREF="06.porting23"Using Data Typeslong longIDREF="06.porting19"Using Data Typesloop interchangeIDREF="04.optimize40"Loop Interchange loop unrollingcode generatorIDREF="04.optimize126"Loop Unrollingloop-nest optimization. See optimizing programs, ­LNO optionIDREF="04.optimize32"Controlling Loop Nest OptimizationsloopsblockingIDREF="04.optimize41"Blocking and Outer Loop Unrolling fissionIDREF="04.optimize48"Loop Fission/DistributionfusionIDREF="04.optimize46"Loop FusioninterchangingIDREF="04.optimize38"Loop Interchange optimizingIDREF="04.optimize54"Controlling LNO Optimization Levels parallelIDREF="04.optimize53"Gather-Scatter OptimizationunrollingIDREF="04.optimize41"Blocking and Outer Loop Unrolling machine instructionsIDREF="02.compiler101"Getting Information About Object Filesmacro preprocessorsIDREF="01.oview9"About the MIPSpro Compiler SystemmacrosNARGSAVEIDREF="06.porting34"Using Predefined TypespredefinedIDREF="06.porting25"Using Predefined TypestypedefsIDREF="06.porting35"Using Typedefs makefilesIDREF="06.porting8"Porting Environmentmaximum integer typeIDREF="06.porting37"Using Typedefs memory2 gigabyte arraysIDREF="06.porting38"Maximum Memory Allocation referencingIDREF="04.optimize145"Controlling the Target EnvironmentIDREF="04.optimize98"Using the ­OPT:alias Optionmemory allocationarraysIDREF="06.porting38"Maximum Memory Allocation memory exceptionsif conversionIDREF="04.optimize120"If ConversionMIPS Instruction Set ArchitectureIDREF="06.porting32"Using Predefined Typesmips optionsIDREF="02.compiler8"Using a Defaults Specification Filemips4 recip instructionIDREF="04.optimize108"Simplifying Code With the ­OPT Optionmips4 rsqrt instructionIDREF="04.optimize109"Simplifying Code With the ­OPT Optionmmap() system callIDREF="03.dso36"Dynamic Loading Under Program Controlmode32-bitIDREF="02.compiler1"Selecting a Compiler64-bitIDREF="02.compiler1"Selecting a Compilern32-bitIDREF="02.compiler1"Selecting a CompilermodelingcontrollingIDREF="04.optimize65"Controlling Blocking and Permutation Transformations multilanguage programsand ldIDREF="02.compiler96"Linking Multilanguage Programsheader filesIDREF="02.compiler31"Creating a Header File for Multiple Languagesmunmap() system callIDREF="03.dso35"Dynamic Loading Under Program Controln32IDREF="06.porting8"Porting Environmentassembly language programsIDREF="06.porting10"Source Code Changesbuild procedureIDREF="06.porting11"Build Procedureinclude filesIDREF="06.porting8"Porting EnvironmentlibrariesIDREF="06.porting6"CompatibilityIDREF="06.porting8"Porting Environmentporting environmentIDREF="06.porting8"Porting Environmentporting guidelinesIDREF="06.porting7"N32 Porting Guidelinesruntime issuesIDREF="06.porting12"Runtime Issuessource code changesIDREF="06.porting9"Source Code Changesn32-bit modeIDREF="02.compiler1"Selecting a Compilernaming source filesIDREF="02.compiler26"Source File Naming ConventionsNARGSAVE macroIDREF="06.porting34"Using Predefined Typesnegative valuesproblemsIDREF="05.64bit25"Guidelines for Writing Code for 64-Bit Silicon Graphics Platformsnm commandIDREF="02.compiler105"Getting Information About Object Filescharacter codesIDREF="02.compiler123"nm Symbol Table Optionscommand syntaxIDREF="02.compiler121"Listing Symbol Table Information: nmexampleIDREF="02.compiler124"nm Example of Obtaining a Symbol Table Listingexample of undefined symbolIDREF="02.compiler98"Finding an Unresolved Symbol With ldoptionsIDREF="02.compiler122"nm Syntaxundefined symbolIDREF="02.compiler97"Finding an Unresolved Symbol With ldnm command IDREF="02.compiler121"Listing Symbol Table Information: nmobject file informationdisassembleIDREF="02.compiler101"Getting Information About Object FilesformatIDREF="02.compiler13"Object File Format and Dynamic LinkingIDREF="01.oview1"About the MIPSpro Compiler Systemlisting file propertiesIDREF="02.compiler104"Getting Information About Object Fileslisting section sizesIDREF="02.compiler125"Determining Section Sizes with sizeIDREF="02.compiler106"Getting Information About Object Filessymbol table informationIDREF="02.compiler120"Listing Symbol Table Information: nmIDREF="02.compiler105"Getting Information About Object FilestoolsIDREF="02.compiler100"Getting Information About Object FilesusingIDREF="02.compiler100"Getting Information About Object Filesusing dwarfdumpIDREF="02.compiler102"Getting Information About Object Filesusing elfdumpIDREF="02.compiler113"Listing Parts of ELF Object Files and Libraries with elfdumpIDREF="02.compiler103"Getting Information About Object Filesoperating system64 bitIDREF="05.64bit3"Coding for 64-Bit ProgramsoperationsrelationalIDREF="04.optimize105"Simplifying Code With the ­OPT Optionunsigned relationalIDREF="04.optimize107"Simplifying Code With the ­OPT OptionoptimizationIDREF="04.optimize1"Optimizing Program Performance­O0 compiler optionIDREF="04.optimize5"Using the Optimization Options­O1 compiler optionIDREF="04.optimize6"Using the Optimization Options­O2 compiler optionIDREF="04.optimize7"Using the Optimization Options­O3 compiler optionIDREF="04.optimize8"Using the Optimization OptionsaddressesIDREF="04.optimize160"Example of Pointer Placement and AliasingAlso see optimizing programsIDREF="04.optimize33"Controlling Loop Nest Optimizationsand register allocationIDREF="04.optimize169"Register AllocationC programsIDREF="04.optimize149"Optimizing C, C++, and Fortran ProgramsC++ programsIDREF="04.optimize149"Optimizing C, C++, and Fortran ProgramsFortranIDREF="04.optimize149"Optimizing C, C++, and Fortran Programsfunction return valuesIDREF="04.optimize151"Optimizing C and C++ ProgramsglobalIDREF="04.optimize148"Overview of the Global Optimizerif-then-else statementsIDREF="04.optimize164"C, C++, and Fortran Programslibc.so functionsIDREF="04.optimize166"C and C++ ProgramsoptionsIDREF="04.optimize4"Using the Optimization Optionspointer placementIDREF="04.optimize155"Optimizing C and C++ ProgramspointersIDREF="04.optimize158"Example of Pointer Placement and Aliasingsigned data typesIDREF="04.optimize167"C and C++ ProgramsSTDARGIDREF="04.optimize161"Example of Pointer Placement and Aliasingstdarg.hIDREF="04.optimize162"Example of Pointer Placement and AliasingsubscriptsIDREF="04.optimize159"Example of Pointer Placement and AliasingIDREF="04.optimize156"Example of Pointer Placement and Aliasingswitch statementsIDREF="04.optimize164"C, C++, and Fortran ProgramstablesIDREF="04.optimize164"C, C++, and Fortran Programstips for improvingIDREF="04.optimize147"Improving Global OptimizationunionsIDREF="04.optimize152"Optimizing C and C++ Programsvalue parametersIDREF="04.optimize154"Optimizing C and C++ ProgramsVARARGIDREF="04.optimize161"Example of Pointer Placement and Aliasingvarargs.hIDREF="04.optimize162"Example of Pointer Placement and Aliasingvariables, global vs. localIDREF="04.optimize153"Optimizing C and C++ ProgramsoptimizerIDREF="01.oview13"About the MIPSpro Compiler Systemcopt optimizerIDREF="01.oview11"About the MIPSpro Compiler Systemoptimizing programs­32 optionIDREF="04.optimize135"Controlling the Target Architecture ­64 optionIDREF="04.optimize135"Controlling the Target Architecture ­align optionIDREF="04.optimize145"Controlling the Target Environment­INLINE optionIDREF="04.optimize12"Inlining Options for Routines­IPA optionIDREF="04.optimize16"Options To Control Inlining HeuristicsIDREF="04.optimize26"Alias and Address Taken Analysis­LNO optionIDREF="04.optimize30"Controlling Loop Nest OptimizationsblockingIDREF="04.optimize42"Blocking and Outer Loop Unrolling blocking and permutation transformationsIDREF="04.optimize64"Controlling Blocking and Permutation Transformations cache optimizationIDREF="04.optimize67"Controlling Blocking and Permutation Transformations code transformationIDREF="04.optimize36"Running LNOcontrolling cache parametersIDREF="04.optimize61"Controlling Cache Parameters controlling dependence analysisIDREF="04.optimize70"Dependence Analysis controlling fission and fusionIDREF="04.optimize57"Controlling Fission and Fusion controlling gather-scatterIDREF="04.optimize59"Controlling Gather-Scatter controlling illegal transformationsIDREF="04.optimize68"Controlling Blocking and Permutation Transformations controlling prefetchIDREF="04.optimize69"Controlling Prefetchcontrolling transformationsIDREF="04.optimize66"Controlling Blocking and Permutation Transformations directivesIDREF="04.optimize73"Pragmas and Directives for LNO fissionIDREF="04.optimize75"Fission/Fusion fusionIDREF="04.optimize75"Fission/Fusion gather-scatter IDREF="04.optimize52"Gather-Scatter Optimizationloop fissionIDREF="04.optimize47"Loop Fission/Distributionloop fusionIDREF="04.optimize45"Loop Fusionloop interchangeIDREF="04.optimize39"Loop Interchange optimization levelsIDREF="04.optimize55"Controlling LNO Optimization Levels outter loop unrollingIDREF="04.optimize43"Blocking and Outer Loop Unrolling pragmasIDREF="04.optimize72"Pragmas and Directives for LNO prefetching IDREF="04.optimize49"Prefetchingrunning LNOIDREF="04.optimize34"Running LNO­mips optionIDREF="04.optimize137"Controlling the Target Architecture ­n32 optionIDREF="04.optimize135"Controlling the Target Architecture ­OPT optionIDREF="04.optimize83"­OPT:roundoff=nalias=any optionIDREF="04.optimize99"Using the ­OPT:alias Optionalias=name optionIDREF="04.optimize98"Using the ­OPT:alias Optionalias=restrict optionIDREF="04.optimize102"Using the ­OPT:alias Optionalias=typed optionIDREF="04.optimize100"Using the ­OPT:alias Optionalias=unnamed optionIDREF="04.optimize101"Using the ­OPT:alias Optiondiv_splitIDREF="04.optimize103"Simplifying Code With the ­OPT Optiondiv_split optionIDREF="04.optimize87"Other Options to Control Floating Point Behaviorfast_complex optionIDREF="04.optimize88"Other Options to Control Floating Point Behaviorfast_exp optionIDREF="04.optimize89"Other Options to Control Floating Point Behaviorfast_io optionIDREF="04.optimize90"Other Options to Control Floating Point Behaviorfast_sqrt optionIDREF="04.optimize91"Other Options to Control Floating Point Behaviorfold_reassociateIDREF="04.optimize104"Simplifying Code With the ­OPT Optionfold_reassociate optionIDREF="04.optimize92"Other Options to Control Floating Point Behaviorfold_unsafe_relopsIDREF="04.optimize105"Simplifying Code With the ­OPT Optionfold_unsigned_relopsIDREF="04.optimize106"Simplifying Code With the ­OPT OptionIEEE optionIDREF="04.optimize82"Controlling Floating Point OptimizationIEEE_arithmetic optionIDREF="04.optimize86"­OPT:IEEE_arithmetic=nrecipIDREF="04.optimize108"Simplifying Code With the ­OPT Optionrecip optionIDREF="04.optimize93"Other Options to Control Floating Point Behaviorroundoff optionIDREF="04.optimize82"Controlling Floating Point OptimizationIDREF="04.optimize84"­OPT:roundoff=nrsqrtIDREF="04.optimize109"Simplifying Code With the ­OPT Optionrsqrt optionIDREF="04.optimize94"Other Options to Control Floating Point Behaviorspace optionIDREF="04.optimize97"Using the ­OPT:space Option­TARG optionisa=mips optionIDREF="04.optimize137"Controlling the Target Architecture madd optionIDREF="04.optimize95"Other Options to Control Floating Point BehaviorIDREF="04.optimize138"Controlling the Target Architecture ­TENV optionIDREF="04.optimize142"Controlling the Target Environmentalign_aggregates optionIDREF="04.optimize146"Controlling the Target EnvironmentX optionIDREF="04.optimize144"Controlling the Target Environmentalias analysisIDREF="04.optimize25"Alias and Address Taken AnalysisAlso see code generatorIDREF="04.optimize110"The Code Generator benefitsIDREF="04.optimize2"Benefits of OptimizationcacheIDREF="04.optimize51"Prefetchingcode generatorIDREF="04.optimize111"The Code Generator overviewIDREF="04.optimize112"Overview of the Code Generator common block paddingIDREF="04.optimize22"Common Block PaddingrestrictionsIDREF="04.optimize24"Common Block Paddingdata alignmentIDREF="04.optimize145"Controlling the Target EnvironmentdebuggingIDREF="04.optimize3"Optimization and Debuggingdependence analysisIDREF="04.optimize78"Dependence Analysis floating pointsIDREF="04.optimize79"Controlling Floating Point OptimizationFortran optimizationIDREF="04.optimize115"An Example of Local Optimization for Fortran IEEE floating pointsIDREF="04.optimize85"­OPT:IEEE_arithmetic=nignoring pragmasIDREF="04.optimize56"Controlling LNO Optimization Levels inlining benefitsIDREF="04.optimize11"Benefits of Inlininginterprocedural analysisIDREF="04.optimize9"Performance Tuning with Interprocedural Analysispragmas, ignoreIDREF="04.optimize56"Controlling LNO Optimization Levels prefetch pragmasIDREF="04.optimize77"Prefetch shared codeIDREF="04.optimize143"Controlling the Target Environmenttarget architectureIDREF="04.optimize135"Controlling the Target Architecture target architecture optionsIDREF="04.optimize136"Controlling the Target Architecture target environmentIDREF="04.optimize141"Controlling the Target Environmenttransformation pragmasIDREF="04.optimize76"Blocking and Permutation Transformations transformationsIDREF="04.optimize84"­OPT:roundoff=noverflowintegerIDREF="04.optimize107"Simplifying Code With the ­OPT OptionintegersIDREF="04.optimize105"Simplifying Code With the ­OPT Optionoverflow of codeIDREF="05.64bit19"Arithmetic with long Typesoverflow of global offset tableIDREF="02.compiler66"General Options for Compiler Driverspadding, blocksIDREF="04.optimize22"Common Block PaddingrestrictionsIDREF="04.optimize24"Common Block Paddingpage sizeIDREF="03.dso7"Tuning Shared Library CodepagingalignmentIDREF="03.dso7"Tuning Shared Library Codeparallel analyzerIDREF="01.oview16"About the MIPSpro Compiler SystemIDREF="01.oview10"About the MIPSpro Compiler Systemparallel loopsIDREF="04.optimize53"Gather-Scatter OptimizationparametersoptimizationIDREF="04.optimize154"Optimizing C and C++ Programspc compiler. See driversIDREF="01.oview7"About the MIPSpro Compiler Systempca analyzerIDREF="01.oview16"About the MIPSpro Compiler SystemIDREF="01.oview10"About the MIPSpro Compiler SystemPIC. See position-independent codeIDREF="02.compiler16"Object File Format and Dynamic LinkingIDREF="01.oview4"About the MIPSpro Compiler SystemIDREF="03.dso12"Building DSOspixieand SpeedShopIDREF="04.optimize170"Using SpeedShop pointerIDREF="05.64bit8"sizeof(int) == sizeof(void *)IDREF="06.porting20"Using Data TypesIDREF="06.porting36"Using Typedefs pointer placementand aliasingIDREF="04.optimize155"Optimizing C and C++ ProgramsexampleIDREF="04.optimize155"Optimizing C and C++ ProgramsIDREF="04.optimize155"Optimizing C and C++ ProgramspointersexampleIDREF="04.optimize157"Example of Pointer Placement and AliasingoptimizationIDREF="04.optimize159"Example of Pointer Placement and Aliasingreferencing memoryIDREF="04.optimize98"Using the ­OPT:alias Optionporting codeIDREF="06.porting13"Porting Code to 64-Bit Silicon Graphics Systemsporting guidelinesIDREF="06.porting7"N32 Porting Guidelinesposition-independent codeIDREF="01.oview4"About the MIPSpro Compiler SystemIDREF="02.compiler23"Position-Independent CodeIDREF="02.compiler16"Object File Format and Dynamic LinkingIDREF="03.dso12"Building DSOspragmasignoreIDREF="04.optimize56"Controlling LNO Optimization Levels LNOIDREF="04.optimize71"Pragmas and Directives for LNO precompiled header filesIDREF="02.compiler35"Using Precompiled Headers in C and C++automaticIDREF="02.compiler36"Automatic Precompiled Header ProcessingcontrollingIDREF="02.compiler40"Other Ways to Control Precompiled HeadersdeletionIDREF="02.compiler39"Automatic Precompiled Header ProcessingperformanceIDREF="02.compiler41"PCH Performance IssuesrequirementsIDREF="02.compiler37"Automatic Precompiled Header ProcessingreuseIDREF="02.compiler38"Automatic Precompiled Header Processingprefetchand code generatorIDREF="04.optimize132"Prefetch and Load LatencycontrollingIDREF="04.optimize69"Controlling Prefetchprefetch pragmasIDREF="04.optimize77"Prefetch prefetching instructionsIDREF="04.optimize50"PrefetchingpreprocessingIDREF="01.oview12"About the MIPSpro Compiler SystempreprocessorsmacroIDREF="01.oview9"About the MIPSpro Compiler Systemprintf commandIDREF="05.64bit26"Guidelines for Writing Code for 64-Bit Silicon Graphics PlatformsproblemsIDREF="05.64bit15"sizeof(void *) == 4constantsIDREF="05.64bit18"Constants With the High-Order Bit Setfloating pointsIDREF="04.optimize96"Debugging Floating-Point Problemsimplicitly declared functionsIDREF="05.64bit17"Implicitly Declared Functionsnegative valuesIDREF="05.64bit25"Guidelines for Writing Code for 64-Bit Silicon Graphics Platformsporting codeIDREF="05.64bit4"Coding Assumptions to AvoidprintfIDREF="05.64bit27"Guidelines for Writing Code for 64-Bit Silicon Graphics PlatformsscanfIDREF="05.64bit27"Guidelines for Writing Code for 64-Bit Silicon Graphics Platformssizeof(int)==sizeof(long)IDREF="05.64bit10"sizeof(int) == sizeof(long)sizeof(int)==sizeof(void*)IDREF="05.64bit5"sizeof(int) == sizeof(void *)sizeof(long)==4IDREF="05.64bit13"sizeof(long) == 4solvingIDREF="05.64bit21"Solving Porting ProblemstypesIDREF="05.64bit4"Coding Assumptions to Avoidproc optionsIDREF="02.compiler9"Using a Defaults Specification Fileprocessor specificationIDREF="02.compiler5"Using a Defaults Specification Fileprofand SpeedShopIDREF="04.optimize170"Using SpeedShop QuickStart DSOs. See DSOs, QuickStartIDREF="03.dso10"Taking Advantage of QuickStartIDREF="03.dso9"Taking Advantage of QuickStartread-read eliminationIDREF="04.optimize122"Read-Read Eliminationread-write eliminationIDREF="04.optimize123"Read-Write Eliminationrecip instructionIDREF="04.optimize108"Simplifying Code With the ­OPT Optionrecurrence breakingback substitutionIDREF="04.optimize128"Recurrence Breakingcode generatorIDREF="04.optimize127"Recurrence Breakingreduction interleavingIDREF="04.optimize127"Recurrence Breakingreduction interleavingIDREF="04.optimize127"Recurrence BreakingregistersallocationIDREF="04.optimize169"Register AllocationargumentIDREF="06.porting33"Using Predefined TypesblockingIDREF="04.optimize44"Blocking and Outer Loop Unrolling tempIDREF="06.porting33"Using Predefined Typesregistry file. See DSOsIDREF="03.dso20"Using Registry Filesrelational operationsunsignedIDREF="04.optimize107"Simplifying Code With the ­OPT Optionrelational operatorsinteger overflowIDREF="04.optimize105"Simplifying Code With the ­OPT Optionrelocatable filesIDREF="02.compiler19"Executable and Linking Formatrelocation bits, removingIDREF="02.compiler107"Getting Information About Object Filesremoverelocation bitsIDREF="02.compiler107"Getting Information About Object Filessymbol tableIDREF="02.compiler107"Getting Information About Object Filesresolve text symbolsIDREF="03.dso23"Run-Time Symbol Resolutionreturn values, optimizationIDREF="04.optimize151"Optimizing C and C++ ProgramsrldIDREF="03.dso4"Benefits of Using DSOsdynamic linkingIDREF="03.dso29"Dynamic Loading Under Program ControllibdlIDREF="03.dso29"Dynamic Loading Under Program Controlsearch pathIDREF="03.dso22"Searching for DSOs at Run Timeroundofffloating pointsIDREF="04.optimize84"­OPT:roundoff=noptimizationIDREF="04.optimize84"­OPT:roundoff=nrsqrt instructionIDREF="04.optimize109"Simplifying Code With the ­OPT Optionruntime issuesn32IDREF="06.porting12"Runtime Issuesruntime linker. See rldIDREF="03.dso4"Benefits of Using DSOsscalar optimizer, coptIDREF="01.oview11"About the MIPSpro Compiler Systemscalar variablesword sizeIDREF="04.optimize165"C, C++, and Fortran Programsscanf functionIDREF="05.64bit26"Guidelines for Writing Code for 64-Bit Silicon Graphics Platformssearch pathrldIDREF="03.dso22"Searching for DSOs at Run Timeselecting compilation modeIDREF="02.compiler1"Selecting a Compilerinstruction setIDREF="02.compiler1"Selecting a CompilerISAIDREF="02.compiler1"Selecting a CompilerprocessorIDREF="02.compiler1"Selecting a Compilersgidladd()IDREF="03.dso31"Dynamic Loading Under Program Controlshared codeoptimizingIDREF="04.optimize143"Controlling the Target Environmentshared libraries, staticIDREF="03.dso3"Using Dynamic Shared Objectsshared libraryIDREF="01.oview2"About the MIPSpro Compiler SystemIDREF="02.compiler14"Object File Format and Dynamic Linkingshared objects, dynamicIDREF="03.dso2"Using Dynamic Shared ObjectsshortIDREF="06.porting16"Using Data Typessign bit setIDREF="05.64bit18"Constants With the High-Order Bit Setsign extensionIDREF="05.64bit20"Arithmetic with long TypesIDREF="05.64bit9"sizeof(int) == sizeof(void *)signed data typeoptimizationIDREF="04.optimize167"C and C++ Programssigned ints64-bit codeIDREF="04.optimize168"C and C++ Programssize commandIDREF="02.compiler125"Determining Section Sizes with sizeIDREF="02.compiler126"Determining Section Sizes with sizeIDREF="02.compiler106"Getting Information About Object Filescommand syntaxIDREF="02.compiler127"Determining Section Sizes with sizeexampleIDREF="02.compiler128"size Examplesize of object fileIDREF="02.compiler106"Getting Information About Object Filessizeof(int)==sizeof(long)IDREF="05.64bit11"sizeof(int) == sizeof(long)sizeof(int)==sizeof(void*)IDREF="05.64bit7"sizeof(int) == sizeof(void *)sizeof(long)==4IDREF="05.64bit13"sizeof(long) == 4sizeof(void*)==4IDREF="05.64bit15"sizeof(void *) == 4IDREF="05.64bit16"sizeof(void *) == 4software pipeliningand code generatorIDREF="04.optimize129"Software Pipeliningsource coden32IDREF="06.porting9"Source Code Changessource file namesIDREF="02.compiler26"Source File Naming Conventionsspecifying compilation modeIDREF="02.compiler3"Using a Defaults Specification FileSpeedShopIDREF="04.optimize170"Using SpeedShop pixie commandIDREF="04.optimize171"Using SpeedShop prof commandIDREF="04.optimize170"Using SpeedShop ssrun commandIDREF="04.optimize170"Using SpeedShop standalone inlinerIDREF="04.optimize15"Inlining Options for RoutinesSTDARG. See optimization IDREF="04.optimize163"Example of Pointer Placement and Aliasingstdarg.hIDREF="04.optimize162"Example of Pointer Placement and Aliasingstdio.h header fileIDREF="02.compiler29"Header Filesstoring argumentsIDREF="06.porting34"Using Predefined TypesstringsprintfIDREF="05.64bit26"Guidelines for Writing Code for 64-Bit Silicon Graphics PlatformsscanfIDREF="05.64bit26"Guidelines for Writing Code for 64-Bit Silicon Graphics Platformsstrip commandIDREF="02.compiler129"Removing Symbol Table and Relocation Bits with stripIDREF="02.compiler107"Getting Information About Object Filescommand optionsIDREF="02.compiler131"strip Syntaxcommand syntaxIDREF="02.compiler130"Removing Symbol Table and Relocation Bits with stripsub-expression eliminationIDREF="04.optimize125"Common Sub-expression EliminationsubscriptsexampleIDREF="04.optimize157"Example of Pointer Placement and AliasingoptimizationIDREF="04.optimize156"Example of Pointer Placement and AliasingIDREF="04.optimize157"Example of Pointer Placement and Aliasingsuffixesinput filesIDREF="02.compiler27"Source File Naming Conventionsswitch statementsoptimizationIDREF="04.optimize164"C, C++, and Fortran Programssymbol resolutionIDREF="03.dso23"Run-Time Symbol Resolutionsymbol tabledataIDREF="02.compiler105"Getting Information About Object Filesdumping dataIDREF="02.compiler122"nm Syntaxget listingIDREF="02.compiler124"nm Example of Obtaining a Symbol Table ListingremovingIDREF="02.compiler107"Getting Information About Object FilessymbolsexportingIDREF="03.dso15"Controlling Symbols to Be Exported or LoadedloadingIDREF="03.dso15"Controlling Symbols to Be Exported or Loadedsyntax, conventionsIDREF="intro1"Conventions Used in This Guidetemp registersIDREF="06.porting33"Using Predefined Typestransformationof codeIDREF="04.optimize117"If Conversiontransformation pragmasIDREF="04.optimize76"Blocking and Permutation Transformations transformationscontrolling illegalIDREF="04.optimize68"Controlling Blocking and Permutation Transformations controlling with LNOIDREF="04.optimize66"Controlling Blocking and Permutation Transformations view codeIDREF="04.optimize37"Running LNOtrapsdisableIDREF="04.optimize144"Controlling the Target EnvironmenttroubleshootingconstantsIDREF="05.64bit18"Constants With the High-Order Bit Setimplicitly declared functionsIDREF="05.64bit17"Implicitly Declared Functionsnegative valuesIDREF="05.64bit25"Guidelines for Writing Code for 64-Bit Silicon Graphics PlatformsprintfIDREF="05.64bit27"Guidelines for Writing Code for 64-Bit Silicon Graphics PlatformsscanfIDREF="05.64bit27"Guidelines for Writing Code for 64-Bit Silicon Graphics Platformssizeof(int)==sizeof(long)IDREF="05.64bit12"sizeof(int) == sizeof(long)sizeof(int)==sizeof(void*)IDREF="05.64bit6"sizeof(int) == sizeof(void *)sizeof(long)==4IDREF="05.64bit14"sizeof(long) == 4sizeof(void*)==4IDREF="05.64bit16"sizeof(void *) == 4solving problemsIDREF="05.64bit21"Solving Porting Problemstruncation of codeIDREF="05.64bit19"Arithmetic with long Typestype, determining for filesIDREF="02.compiler117"Determining File Type with file typedefsIDREF="06.porting35"Using Typedefs IDREF="05.64bit24"Guidelines for Writing Code for 64-Bit Silicon Graphics PlatformstypesassumptionsIDREF="05.64bit4"Coding Assumptions to Avoidchange in sizeIDREF="05.64bit18"Constants With the High-Order Bit SetcharIDREF="06.porting15"Using Data TypesconstantsIDREF="05.64bit18"Constants With the High-Order Bit SetdoubleIDREF="06.porting22"Using Data TypesfloatIDREF="06.porting21"Using Data TypesintIDREF="05.64bit8"sizeof(int) == sizeof(void *)IDREF="06.porting17"Using Data TypesIDREF="06.porting36"Using Typedefs largest integer typeIDREF="06.porting37"Using Typedefs longIDREF="06.porting36"Using Typedefs IDREF="06.porting18"Using Data Typeslong doubleIDREF="06.porting23"Using Data Typeslong longIDREF="06.porting19"Using Data TypespointerIDREF="06.porting36"Using Typedefs IDREF="05.64bit8"sizeof(int) == sizeof(void *)IDREF="06.porting20"Using Data TypesproblemsIDREF="05.64bit4"Coding Assumptions to Avoidscaling integerIDREF="05.64bit23"Guidelines for Writing Code for 64-Bit Silicon Graphics PlatformsshortIDREF="06.porting16"Using Data TypessizesIDREF="06.porting14"Using Data Typestypographical conventionsIDREF="intro1"Conventions Used in This GuideunionsoptimizationIDREF="04.optimize152"Optimizing C and C++ Programsunsigned relational operationsIDREF="04.optimize107"Simplifying Code With the ­OPT Option VARARG. See optimization IDREF="04.optimize163"Example of Pointer Placement and Aliasingvarargs.hIDREF="04.optimize162"Example of Pointer Placement and AliasingvariablesscalarIDREF="04.optimize165"C, C++, and Fortran Programsvirtual address spaceIDREF="03.dso35"Dynamic Loading Under Program Controlword-size scalar variablesIDREF="04.optimize165"C, C++, and Fortran Programswrite-write eliminationIDREF="04.optimize124"Write-Write EliminationXFSfile sizeIDREF="06.porting39"Using Large Files With XFSzero extensionIDREF="05.64bit20"Arithmetic with long Typeszero-extension codeIDREF="04.optimize168"C and C++ Programs