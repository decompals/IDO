#EDIR DATA#
LANG="C"MIPSproname='trade' font=symbol charset=fontspecific code=228 
	descr='[trade]' Assembly LanguageProgrammer's GuideDocument Number 007-2418-002CONTRIBUTORSWritten by Larry Huffman, David GravesEdited by Larry Huffman, Cindy KleinfeldProduction by Chris Glazek and David ClarkeEngineering contributions by Bean Anderson, Jim Dehnert, Suneel Jain, Michael Murphy© Copyright 1996 Silicon Graphics, Inc.name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' All Rights ReservedThe contents of this document may not be copied or duplicated in any form, in whole or in part, without the prior written permission of Silicon Graphics, Inc.RESTRICTED RIGHTS LEGENDUse, duplication, or disclosure of the technical data contained in this document by the Government is subject to restrictions as set forth in subdivision (c) (1) (ii) of the Rights in Technical Data and Computer Software clause at DFARS 52.227-7013 and/or in similar or successor clauses in the FAR, or in the DOD or NASA FAR Supplement. Unpublished rights reserved under the Copyright Laws of the United States. Contractor/manufacturer is Silicon Graphics, Inc., 2011 N. Shoreline Blvd., Mountain View, CA 94039-7311.Silicon Graphics and IRIS are registered trademarks and IRIX, CASEVision, IRIS IM, IRIS Showcase, Impressario, Indigo Magic, Inventor, IRIS-4D, POWER Series, RealityEngine, CHALLENGE, Onyx, and WorkShop are trademarks of Silicon Graphics, Inc. UNIX is a registered trademark of UNIX System Laboratories. OSF/Motif is a trademark of Open Software Foundation, Inc. The X Window System is a trademark of the Massachusetts Institute of Technology. PostScript is a registered trademark and Display PostScript is a trademark of Adobe Systems, Inc.About This GuideThis book describes the assembly language supported by the RISCompiler system, its syntax rules, and how to write assembly programs. For information on assembling and linking an assembly language program, see the MIPSpro Compiling, Debugging and Performance Tuning Guide.The assembler converts assembly language statements into machine code. In most assembly languages, each instruction corresponds to a single machine instruction; however, some assembly language instructions can generate several machine instructions. This feature results in assembly programs that can run without modification on future machines, which might have different machine instructions.In this release of O/S and compiler software, the assembler supports compilations in both 32-bit and 64-bit mode. Some of the implications of these different data sizes are explained in this book. For more information, please refer to the MIPSpro 64-Bit Porting and Transition Guide.Many assembly language instructions have direct equivalents to machine instructions. For more information about the operations of a specific arhcitecture, see book that is appropriate for your machine, for instance, the MIPS R4000 Microprocessor User's Manual or the MIPS R8000 Microprocessor User's Manual.LBL="" HELPID=""AudienceThis book assumes that you are an experienced assembly language programmer. The assembler produces object modules from the assembly instructions that the C, and Fortran 77 compilers generate. It therefore lacks many functions normally present in assemblers. You should use the assembler only when you need to:Maximize the efficiency of a routine, which might not be possible in C, Fortran 77,, or another high-level language; for example, to write low-level I/O drivers.Access machine functions unavailable in high-level languages or satisfy special constraints such as restricted register usage.Change the operating system.Change the compiler system.Further system information can be obtained from the manuals listed at the end of this section.LBL="" HELPID=""Topics CoveredThis book has these chapters: Chapter 1: Registers describes the format for the general registers, the special registers, and the floating point registers.Chapter 2: Addressing describes how addressing works.Chapter 3: Exceptions describes exceptions you might encounter with assembly programs.Chapter 4: Lexical Conventions describes the lexical conventions that the assembler follows.Chapter 5: Instruction Set describes the main processor's instruction set, including notation, load and store instructions, computational instructions, and jump and branch instructions.Chapter 6: Coprocessor Instruction Set describes the coprocessor instruction sets.Chapter 7: Linkage Conventions describes linkage conventions for all supported high-level languages. It also discusses memory allocation and register use.Chapter 8: Pseudo-Op-Codes describes the assembler's pseudo-operations (directives).Index. Contains index entries for this publication.LBL="1"RegistersID="01.reg1"This chapter describes the organization of data in memory, and the naming and usage conventions that the assembler applies to the CPU and FPU registers.  See Chapter 7 for information regarding register use and linkage.LBL="" HELPID="" Register Format    ID="01.reg2"ID="01.reg3"ID="01.reg4"The CPU uses four data formats: a 64-bit doubleword, a 32-bit word, a 16-bit halfword and an 8-bit byte.  Byte ordering within each of the larger data formats ­ doubleword, word or halfword ­ the CPU's byte ordering scheme (or endian issues), affects memory organization and defines the relationship between address and byte position of data in memory.For R4000 and earlier systems, byte ordering is configurable  into either big-endian or little-endian byte ordering (configuration occurs during hardware reset). When configured as a big-endian system, byte 0 is always the most-significant (leftmost) byte. When configured as a little-endian system, byte 0 is always the least-significant (rightmost byte).The R8000 CPU, at present, supports big-endian only.LBL="" HELPID=""General Registers ID="01.reg5"ID="01.reg6"For the MIPS1 and MIPS2 architectures, the CPU has thirty-two 32-bit registers.  In the MIPS3 architecture and above, the size of each of the thirty-two integer registers is 64-bit.IDREF="19384" TYPE="TABLE"Table 1-1and IDREF="10891" TYPE="TABLE"Table 1-2 summarize the assembler's usage, conventions and restrictions for these registers. The assembler reserves all register names; you must use lowercase for the names. All register names start with a dollar sign($).The general registers have the names $0..$31. By including the file regdef.h (use #include <regdef.h>) in your program, you can use software names for some general registers.The operating system and the assembler use the general registers $1, $26, $27, $28, and $29 for specific purposes.  Attempts to use these general registers in other ways can produce unexpected results.COLUMNS="3"LBL="1-1"Table 1-1 ID="19384"General (Integer) Registers (32-Bit)LEFT="0" WIDTH="72"Register NameLEFT="80" WIDTH="79"Software Name(from regdef.h)LEFT="165" WIDTH="198"Use and LinkageLEFT="0" WIDTH="72"$0LEFT="80" WIDTH="79"LEFT="165" WIDTH="198"Always has the value 0.LEFT="0" WIDTH="72"$1 or $atLEFT="80" WIDTH="79"LEFT="165" WIDTH="198"Reserved for the assembler.LEFT="0" WIDTH="72"$2..$3LEFT="80" WIDTH="79"v0-v1LEFT="165" WIDTH="198"Used for expression evaluations and to hold the 
integer type function results. Also used to pass 
the static link when calling nested procedures.LEFT="0" WIDTH="72"$4..$7LEFT="80" WIDTH="79"a0-a3LEFT="165" WIDTH="198"Pass the first 4 words of  actual integer type 
arguments; their values are not preserved across 
procedure calls.LEFT="0" WIDTH="72"$8..$11$11..$15LEFT="80" WIDTH="79"t0-t7t4-t7 orta0-ta3LEFT="165" WIDTH="198"Temporary registers used for expression 
evaluations; their values aren't preserved across 
procedure calls.LEFT="0" WIDTH="72"$16..$23LEFT="80" WIDTH="79"s0-s7LEFT="165" WIDTH="198"Saved registers. Their values must be preserved 
across procedure calls.LEFT="0" WIDTH="72"$24..$25LEFT="80" WIDTH="79"t8-t9LEFT="165" WIDTH="198"Temporary registers used for expression 
evaluations; their values aren't preserved across 
procedure calls.LEFT="0" WIDTH="72"$26..27 or 
$kt0..$kt1LEFT="80" WIDTH="79"k0-k1LEFT="165" WIDTH="198"Reserved for the operating system kernel.LEFT="0" WIDTH="72"$28 or $gpLEFT="80" WIDTH="79"gpLEFT="165" WIDTH="198"Contains the global pointer.LEFT="0" WIDTH="72"$29 or $spLEFT="80" WIDTH="79"spLEFT="165" WIDTH="198"Contains the stack pointer.LEFT="0" WIDTH="72"$30 or $fpLEFT="80" WIDTH="79"fp or s8LEFT="165" WIDTH="198"Contains the frame pointer (if needed);  
otherwise a saved register (like s0-s7).LEFT="0" WIDTH="72"$31LEFT="80" WIDTH="79"raLEFT="165" WIDTH="198"Contains the return address and is used for 
expression evaluation.NoteGeneral register $0 always contains the value 0. All other general registers are equivalent, except that general register $31 also serves as the implicit link register for jump and link instructions. See Chapter 7 for a description of register assignments.COLUMNS="3"LBL="1-2"Table 1-2 ID="10891"General (Integer) Registers (64-Bit)LEFT="0" WIDTH="72"Register NameLEFT="80" WIDTH="79"Software Name(from regdef.h)LEFT="165" WIDTH="198"Use and LinkageLEFT="0" WIDTH="72"$0LEFT="80" WIDTH="79"LEFT="165" WIDTH="198"Always has the value 0.LEFT="0" WIDTH="72"$1 or $atLEFT="80" WIDTH="79"LEFT="165" WIDTH="198"Reserved for the assembler.LEFT="0" WIDTH="72"$2..$3LEFT="80" WIDTH="79"v0-v1LEFT="165" WIDTH="198"Used for expression evaluations and to hold the 
integer type function results. Also used to pass 
the static link when calling nested procedures.LEFT="0" WIDTH="72"$4..$7$8..$11LEFT="80" WIDTH="79"a0-a3a4-a7 orta0-ta3LEFT="165" WIDTH="198"Pass up to 8 words of actual  integer type 
arguments; their values are not preserved across 
procedure calls.LEFT="0" WIDTH="72"$12..$15LEFT="80" WIDTH="79"t0-t3LEFT="165" WIDTH="198"Temporary registers used for expression 
evaluations; their values aren't preserved across 
procedure calls.LEFT="0" WIDTH="72"$16..$23LEFT="80" WIDTH="79"s0-s7LEFT="165" WIDTH="198"Saved registers. Their values must be preserved 
across procedure calls.LEFT="0" WIDTH="72"$24..$25LEFT="80" WIDTH="79"t8-t9LEFT="165" WIDTH="198"Temporary registers used for expression 
evaluations; their values aren't preserved across 
procedure calls.LEFT="0" WIDTH="72"$26..27 or 
$kt0..$kt1LEFT="80" WIDTH="79"k0-k1LEFT="165" WIDTH="198"Reserved for the operating system kernel.LEFT="0" WIDTH="72"$28 or $gpLEFT="80" WIDTH="79"gpLEFT="165" WIDTH="198"Contains the global pointer.LEFT="0" WIDTH="72"$29 or $spLEFT="80" WIDTH="79"spLEFT="165" WIDTH="198"Contains the stack pointer.LEFT="0" WIDTH="72"$30 or $fpLEFT="80" WIDTH="79"fp or s8LEFT="165" WIDTH="198"Contains the frame pointer (if needed);  
otherwise a saved register (such as s0-s7).LEFT="0" WIDTH="72"$31LEFT="80" WIDTH="79"raLEFT="165" WIDTH="198"Contains the return address and is used for 
expression evaluation.LBL="" HELPID=""Special Registers ID="01.reg7"ID="01.reg8"The CPU defines three special registers: PC (program counter), HI and LO, as shown in IDREF="22783" TYPE="TABLE"Table 1-3. The HI and LO special registers hold the results of the multiplication (mult and multu) and division (div and divu) instructions.You usually do not need to refer explicitly to these special registers; instructions that use the special registers refer to them automatically.COLUMNS="2"LBL="1-3"Table 1-3 ID="22783"Special RegistersLEFT="0" WIDTH="54"NameLEFT="60" WIDTH="252"DescriptionLEFT="0" WIDTH="54"PCLEFT="60" WIDTH="252"Program CounterLEFT="0" WIDTH="54"HILEFT="60" WIDTH="252"Multiply/Divide special register holds the most-significant 32 
bits of multiply, remainder of divideLEFT="0" WIDTH="54"LOLEFT="60" WIDTH="252"Multiply/Divide special register holds the least-significant 32 
bits of multiply, quotient of divideNoteIn MIPS3 architecture and later, the HI and Lo registers hold 64-bits.LBL="" HELPID=""Floating Point Registers ID="01.reg9"ID="01.reg10"The FPU has sixteen floating-point registers. Each register can hold either a single-precision (32-bit) or double-precision (64-bit) value. In case of a double-precision value, $f0 holds the least-significant half, and $f1 holds the most-significant half.  For 32-bit systems, all references to these registers use an even register number (for example, $f4).   64-bit systems can reference all 32 registers directly.   IDREF="98599" TYPE="TABLE"Table 1-4 and  IDREF="84436" TYPE="TABLE"Table 1-5 summarize the assembler's usage conventions and restrictions for these registers.COLUMNS="3"LBL="1-4"Table 1-4 ID="98599"Floating-Point Registers (32-bit)LEFT="0" WIDTH="54"Register 
NameLEFT="60" WIDTH="79"Software Name(from fgregdef.h)LEFT="145" WIDTH="199"Use and LinkageLEFT="0" WIDTH="54"$f0..$f2LEFT="60" WIDTH="79"fv0-fv1LEFT="145" WIDTH="199"Hold results of floating-point type function  ($f0) 
and complex type function ($f0 has the real part, 
$f2 has the imaginary part.LEFT="0" WIDTH="54" $f4..$f10LEFT="60" WIDTH="79"ft0-ft3LEFT="145" WIDTH="199"Temporary registers, used for expression 
evaluation whose values are not preserved across 
procedure calls.LEFT="0" WIDTH="54"$f12..$f14LEFT="60" WIDTH="79"fa0-fa1LEFT="145" WIDTH="199"Pass the first two single or double precision 
actual arguments; their values are not preserved 
across procedure calls.LEFT="0" WIDTH="54"$f16..$f18LEFT="60" WIDTH="79"ft4-ft5LEFT="145" WIDTH="199"Temporary registers, used for expression 
evaluation, whose values are not preserved 
across procedure calls.LEFT="0" WIDTH="54"$f20..$f30LEFT="60" WIDTH="79"fs0-fs5LEFT="145" WIDTH="199"Saved registers, whose values must be preserved 
across  procedure calls.COLUMNS="3"LBL="1-5"Table 1-5 ID="84436"Floating-Point Registers (64-bit)LEFT="0" WIDTH="54"Register 
NameLEFT="60" WIDTH="79"Software Name(from fgregdef.h)LEFT="145" WIDTH="199"Use and LinkageLEFT="0" WIDTH="54"$f0, $f2LEFT="60" WIDTH="79"fv0,fv1LEFT="145" WIDTH="199"Hold results of floating-point type function ($f0) 
and complex type function ($f0 has the real part, 
$f2 has the imaginary part.LEFT="0" WIDTH="54"$f1, $f3$f4..$f11LEFT="60" WIDTH="79"ft1,ft3ft0-ft7LEFT="145" WIDTH="199"Temporary registers, used for expression 
evaluation; their  values are not preserved across 
procedure calls.LEFT="0" WIDTH="54"$f12..$f19LEFT="60" WIDTH="79"fa0-fa7LEFT="145" WIDTH="199"Pass  single or double precision actual 
arguments, whose values are not preserved 
across procedure calls.LEFT="0" WIDTH="54"$f20..$f23LEFT="60" WIDTH="79"ft8-ft11LEFT="145" WIDTH="199"Temporary registers, used for expression 
evaluation; their values are not preserved across 
proceadure calls.LEFT="0" WIDTH="54"$f24..$f31LEFT="60" WIDTH="79"fs0-fs7LEFT="145" WIDTH="199"Saved registers, whose values must be preserved 
across  procedure calls.LBL="2"Addressing ID="02.address1"ID="02.address2"This chapter describes the formats that you can use to specify addresses.  SGI CPUs use a byte addressing scheme. Access to halfwords requires alignment on even byte boundaries, and access to words requires alignment on byte boundaries that are divisible by four. Access to doublewords (for 64-bit systems) requires alignment on byte boundaries that are divisible by eight.  Any attempt to address a data item that does not have the proper alignment causes an alignment exception.ID="02.address3"The unaligned assembler load and store instructions may generate multiple machine language instructions. They do not raise alignment exceptions.ID="02.address4"These instructions load and store unaligned data:ID="02.address5"Load doubleword left (LDL)ID="02.address6"Load word left (LWL)ID="02.address7"Load doubleword right (LDR)ID="02.address8"Load word right (LWR)ID="02.address9"Store doubleword left (SDL)ID="02.address10"Store word left (SWL)ID="02.address11"Store doubleword right (SDR)ID="02.address12"Store word right (SWR)ID="02.address13"Unaligned load doubleword (ULD)ID="02.address14"Unaligned load word (ULW)ID="02.address15"Unaligned load halfword (ULH)ID="02.address16"Unaligned load halfword unsigned (ULHU)ID="02.address17"Unaligned store doubleword (USD) ID="02.address18"Unaligned store word (USW) ID="02.address19"Unaligned store halfword (USH)ID="02.address20"These instructions load and store aligned dataID="02.address21"Load doubleword (LD)ID="02.address22"Load word (LW)ID="02.address23"Load halfword (LH)ID="02.address24"Load halfword unsigned (LHU)ID="02.address25"Load byte (LB)ID="02.address26"Load byte unsigned (LBU)ID="02.address27"Store doubleword (SD)ID="02.address28"Store word (SW)ID="02.address29"Store halfword (SH)ID="02.address30"Store byte (SB)ID="02.address31"LBL="" HELPID=""Address FormatsID="02.address32"The assembler accepts these formats shown in ID="02.address33"IDREF="41417" TYPE="TABLE"Table 2-1 for addresses. IDREF="10681" TYPE="TABLE"Table 2-2 explains these formats in more detail.COLUMNS="2"LBL="2-1"Table 2-1 ID="41417"Address FormatsLEFT="0" WIDTH="144"FormatLEFT="150" WIDTH="162"AddressLEFT="0" WIDTH="144"(base register)LEFT="150" WIDTH="162"Base address (zero  offset assumed)LEFT="0" WIDTH="144"expressionLEFT="150" WIDTH="162"Absolute addressLEFT="0" WIDTH="144"expression (base register)LEFT="150" WIDTH="162"Based addressLEFT="0" WIDTH="144"index-register (base register)LEFT="150" WIDTH="162"Based addressLEFT="0" WIDTH="144"relocatable-symbolLEFT="150" WIDTH="162"Relocatable addressLEFT="0" WIDTH="144"relocatable-symbol + expressionLEFT="150" WIDTH="162"Relocatable addressLEFT="0" WIDTH="144"relocatable-symbol + expression 
(index register)LEFT="150" WIDTH="162"Indexed relocatable addressLBL="" HELPID=""Address DescriptionsID="02.address34"ID="02.address35"ID="02.address36"The assembler accepts any combination of the constants and operations described in this chapter for expressions in address descriptions.COLUMNS="2"LBL="2-2"Table 2-2 ID="10681"Assembler AddressesLEFT="0" WIDTH="153"ExpressionLEFT="160" WIDTH="180"Address DescriptionLEFT="0" WIDTH="153"( base-register )LEFT="160" WIDTH="180"Specifies an indexed address, which 
assumes a zero offset. The base-register 
contents specify the address.LEFT="0" WIDTH="153"expressionLEFT="160" WIDTH="180"Specifies an absolute address. The 
assembler generates the most locally 
efficient code for  referencing a value at the 
specified address.LEFT="0" WIDTH="153"expression (base-register)LEFT="160" WIDTH="180"Specifies a based address. To get the 
address, the CPU adds the value of the 
expression to the contents of the 
base-register.LEFT="0" WIDTH="153"index-register(base-register)LEFT="160" WIDTH="180"Same as expression(base-register), except that 
the index register is used as the offset.LEFT="0" WIDTH="153"relocatable-symbolLEFT="160" WIDTH="180"Specifies a relocatable address. The 
assembler generates the necessary 
instruction(s) to address the item and 
generates relocatable information for the 
link editor.LEFT="0" WIDTH="153"relocatable-symbol  +  expressionLEFT="160" WIDTH="180"Specifies a relocatable address. To get the 
address, the assembler adds or subtracts the 
value of the expression, which has an 
absolute value, from the relocatable symbol. 
The assembler generates the necessary 
instruction(s) to address the item and 
generates relocatable information for the 
link editor.  If the symbol name does not 
appear as a label anywhere in the assembly, 
the assembler assumes that the symbol is 
external.LEFT="0" WIDTH="153"relocatable-symbol (index register)LEFT="160" WIDTH="180"Specifies an indexed relocatable address. To 
get the address, the CPU adds the index 
registerto the relocatable symbol's address. 
The assembler generates the necessary 
instruction(s) to address the item and 
generates relocatable information for the 
link editor. If the symbol name does not 
appear as a label anywhere in the assembly, 
the assembler assumes that the symbol is 
external.LEFT="0" WIDTH="153"relocatable + expressionLEFT="160" WIDTH="180"Specifies an indexed relocatable address. To 
get the address, the assembler adds or 
subtracts the relocatable symbol, the 
expression, and the contents of the index 
register. The assembler generates the 
necessary instruction(s) to address the item 
and generates relocation information for the 
link editor. If the symbol does not appear as 
a label anywhere in the assembly, the 
assembler assumes that the symbol is 
external. LBL="3"ExceptionsID="03.except1"This chapter describes the exceptions that you can encounter while running assembly programs. The system detects some exceptions directly, and the assembler inserts specific tests that signal other exceptions. This chapter lists only those exceptions that occur frequently.LBL="" HELPID=""Main Processor ExceptionsID="03.except2"The following exceptions are the most common to the main processor: Address error exceptions, which occur when a data item is referenced that is not on its proper memory alignment or when an address is invalid for the executing process.Overflow exceptions, which occur when arithmetic operations compute signed values and the destination lacks the precision to store the result.Bus exceptions, which occur when an address is invalid for the executing process.Divide-by-zero exceptions, which occur when a divisor is zero. LBL="" HELPID=""Floating Point Exceptions ID="03.except3"ID="03.except4"The following are the most common floating point exceptions: Invalid operation exceptions which include:Magnitude subtraction of infinities, for example: \xb1 -1.Multiplication of 0 by 1 with any signs.Division of 0/0 or 1/1 with any signs.Conversion of a binary floating point number to an integer format when an overflow or the operand value for the infinity or NaN precludes a faithful representation in the format (see Chapter 4).Comparison of predicates that have unordered operands, and that involve Greater Than or Less Than without Unordered.Any operation on a signaling NaN. Divide-by-zero exceptions.Overflow exceptions occur when a rounded floating-point result exceeds the destination format's largest finite number.Underflow exceptions these occur when a result has lost accuracy and also when a nonzero result is between 2Emin (2 to the minimum expressible exponent).Inexact exceptions.LBL="4"Lexical ConventionsID="04.lex1"ID="04.lex2"This chapter discusses lexical conventions for these topics:TokensCommentsIdentifiersConstantsMultiple lines per physical lineSections and location countersStatementsExpressionsThis chapter uses the following notation to describe syntax:| (vertical bar) means "or"[ ] (square brackets) enclose options+ indicates both addition and subtraction operationsLBL="" HELPID=""TokensID="04.lex3"The assembler has these tokens:IdentifiersConstantsOperatorsThe assembler lets you put blank characters and tab characters anywhere between tokens; however, it does not allow these characters within tokens (except for character constants). A blank or tab must separate adjacent identifiers or constants that are not otherwise separated.LBL="" HELPID=""CommentsID="04.lex4"ID="04.lex5"The pound sign character (#) introduces a comment. Comments that start with a # extend through the end of the line on which they appear. You can also use C-language notation /*...*/ to delimit comments.The assembler uses cpp (the C language preprocessor) to preprocess assembler code. Because cpp interprets #s in the first column as pragmas (compiler directives), do not start a # comment in the first column.LBL="" HELPID=""IdentifiersID="04.lex6"ID="04.lex7"An identifier consists of a case-sensitive sequence of alphanumeric characters, including these:.   (period) _  (underscore)$  (dollar sign)The first character of an identifier cannot be numeric.If an identifier is not defined to the assembler (only referenced), the assembler assumes that the identifier is an external symbol.  The assembler treats the identifier like a .globl pseudo-operation (see Chapter 8).  If the identifier is defined to the assembler and the identifier has not been specified as global, the assembler assumes that the identifier is a local symbol.LBL="" HELPID=""ConstantsID="04.lex8"ID="04.lex9"The assembler has these constants:Scalar constantsFloating point constantsString constantsLBL="" HELPID=""Scalar ConstantsID="04.lex10"ID="04.lex11"The assembler interprets all scalar constants as twos-complement numbers.  In 32-bit mode, a scalar constant is 32 bits. 64 bits is the size of a scalar constant in 64-bit mode. Scalar constants can be any of the alphanumeric characters  0123456789abcdefABCDEF.Scalar constants can be one of these constants:Decimal constants, which consist of a sequence of decimal digits without a leading zero.Hexadecimal constants, which consist of the characters 0x (or 0X) followed by a sequence of digits.Octal constants, which consist of a leading zero followed by a sequence of digits in the range 0..7.LBL="" HELPID=""Floating Point ConstantsID="04.lex12"ID="04.lex13"Floating point constants can appear only in .float and .double pseudo-operations (directives),  see Chapter 8,  and in the floating point Load Immediate instructions,  see Chapter 6.   Floating point constants have this format:+d1[.d2][e|E+d3]where:d1 is written as a decimal integer and denotes the integral part of the floating point value.d2 is written as a decimal integer and denotes the fractional part of the floating point value.d3 is written as a decimal integer and denotes a power of 10.The "+" symbol is optional.For example:21.73E­3represents the number .02173.Optionally, .float and .double directives  may use hexadecimal floating point constants instead of decimal ones.  A hexadecimal floating point constant consists of:<+ or ­> 0x <1 or 0 or nothing> . <hex digits> H 0x <hex digits>The assembler places the first set of hex digits (excluding the 0 or 1 preceding the decimal point) in the mantissa field of the floating point format without attempting to normalize it.  It stores the second set of hex digits into the exponent field without biasing them.  It checks that the exponent is appropriate if the mantissa appears to be denormalized.  Hexadecimal floating point constants are useful for generating IEEE special symbols, and for writing hardware diagnostics.For example, either of the following generates a single-precision "1.0":.float 1.0e+0
.float 0x1.0h0x7fLBL="" HELPID=""String ConstantsID="04.lex14"ID="04.lex15"String constants begin and end with double quotation marks (").The assembler observes C language backslash conventions.  For octal notation, the backslash conventions require three characters when the next character can be confused with the octal number.  For hexadecimal notation, the backslash conventions require two characters when the next character can  be confused with the hexadecimal number (that is,, use a 0 for the first character of a single character hex number).The assembler follows the backslash conventions shown in IDREF="20018" TYPE="TABLE"Table 4-1.COLUMNS="2"LBL="4-1"Table 4-1 ID="20018"Backslash ConventionsLEFT="0" WIDTH="61"ConventionLEFT="70" WIDTH="245"MeaningLEFT="0" WIDTH="61"\aLEFT="70" WIDTH="245"Alert (0x07)LEFT="0" WIDTH="61"\bLEFT="70" WIDTH="245"Backspace (0x08)LEFT="0" WIDTH="61"\fLEFT="70" WIDTH="245"Form feed (0x0c)LEFT="0" WIDTH="61"\nLEFT="70" WIDTH="245"Newline (0x0a)LEFT="0" WIDTH="61"\rLEFT="70" WIDTH="245"Carriage return (0x0d)LEFT="0" WIDTH="61"\tLEFT="70" WIDTH="245"horizontal tab (0x09)LEFT="0" WIDTH="61"\vLEFT="70" WIDTH="245"Vertical feed (0x0b)LEFT="0" WIDTH="61"\\LEFT="70" WIDTH="245"Backslash (0x5c)LEFT="0" WIDTH="61"\"LEFT="70" WIDTH="245"Double quotation mark (0x22)LEFT="0" WIDTH="61"\'LEFT="70" WIDTH="245"Single quotation mark (0x27)LEFT="0" WIDTH="61"\000LEFT="70" WIDTH="245"Character whose octal value is 000LEFT="0" WIDTH="61"\XnnLEFT="70" WIDTH="245"Character whose hexadecimal value is nnLBL="" HELPID=""Multiple Lines Per Physical LineYou can include multiple statements on the same line by separating the statements with semicolons.  The assembler does not recognize semicolons as separators when they follow comment symbols  (# or /*).LBL="" HELPID=""Section and Location CountersID="04.lex16"Assembled code and data fall in one of the sections shown in IDREF="14949" TYPE="GRAPHIC"Figure 4-1.FILE="fig4-1.gif" POSITION="INLINE" SCALE="FALSE"LBL="4-1"Figure 4-1 ID="14949"Section and Location CountersThe assembler always generates the text section before other sections.  Additions to the text section happen in four-byte units.  Each section has an implicit location counter, which begins at zero and increments by one for each byte assembled in the section.The bss section holds zero-initialized data.  If a .lcomm pseudo-op defines a variable (see Chapter 8), the assembler assigns that variable to the bss (block started by storage) section or to the sbss (short block started by storage) section depending on the variable's size.  The default variable size for sbss is 8 or fewer bytes.The command line option ­G for each compiler (C, Pascal, Fortran 77, or the assembler), can increase the size of sbss to cover all but extremely large data items.  The link editor issues an error message when the ­ID="04.lex17"G value gets too large.  If a ­G value is not specified to the compiler, 8 is the default.  Items smaller than, or equal to, the specified size go inID="04.lex18" sbss.  Items greater than the specified size go in bss.Because you can address items much more quickly through $gp than through a more general method, put as many items as possible in sdata or sbss.  The size of sdata and sbss combined must not exceed 64K bytes.LBL="" HELPID=""StatementsID="04.lex19"Each statement consists of an optional label, an operation code, and the operand(s).  The system  allows these statements:Null statementsKeyword statementsLBL="" HELPID=""Label DefinitionsID="04.lex20"ID="04.lex21"A label definition consists of an identifier followed by a colon. Label definitions assign the current value and type of the location counter to the name. An error results when the name is already defined, the assigned value changes the label definition, or both conditions exist.Label definitions always end with a colon.  You can put a label definition on a line by itself.A generated label is a single numeric value (1...255). To reference a generated label, put an f (forward) or a b (backward) immediately after the digit. The reference tells the assembler to look for the nearest generated label that corresponds to the number in the lexically forward or backward direction.LBL="" HELPID=""Null StatementsID="04.lex22"ID="04.lex23"A null statement is an empty statement that the assembler ignores. Null statements can have label definitions. For example, this line has three null statements in it:label: ; ;LBL="" HELPID=""Keyword StatementsID="04.lex24"ID="04.lex25"A keyword statement begins with a predefined keyword. The syntax for the rest of the statement depends on the keyword. All instruction opcodes are keywords. All other keywords are assembler pseudo-operations (directives).LBL="" HELPID=""ExpressionsID="04.lex26"ID="04.lex27"An expression is a sequence of symbols that represent a value. Each expression and its result have data types. The assembler does arithmetic in twos-complemet integers (32 bits of precision in 32-bit mode; 64 bits of precision in 64-bit mode). Expressions follow precedence rules and consist of:OperatorsIdentifiersConstantsAlso, you may use a single character string in place of an integer within an expression. Thus:.byte "a" ; .word "a"+0x19is equivalent to:.byte 0x61 ; .word 0x7aLBL="" HELPID=""PrecedenceID="04.lex28"ID="04.lex29"ID="04.lex30"ID="04.lex31"Unless parentheses enforce precedence, the assembler evaluates all operators of the same precedence strictly from left to right. Because parentheses also designate index-registers, ambiguity can arise from parentheses in expressions. To resolve this ambiguity, put a unary + in front of parentheses in expressions.The assembler has three precedence levels, which are listed here from lowest to highest precedenceCOLUMNS="3"LEFT="0" WIDTH="99"least binding,lowest precedenceLEFT="105" WIDTH="72"binaryLEFT="185" WIDTH="162"+,-LEFT="0" WIDTH="99"...LEFT="105" WIDTH="72"binaryLEFT="185" WIDTH="162"*,/,5,<<,>>,^,&, |LEFT="0" WIDTH="99"most binding,highest precedenceLEFT="105" WIDTH="72"unaryLEFT="185" WIDTH="162"-,+,~NoteThe assembler's precedence scheme differs from that of the C language.LBL="" HELPID=""Expression OperatorsID="04.lex32"ID="04.lex33"ID="04.lex34"For expressions, you can rely on the precedence rules, or you can group expressions with parentheses. The assembler recognizes the operators listed in IDREF="29294" TYPE="TABLE"Table 4-2.COLUMNS="2"LBL="4-2"Table 4-2 ID="29294"Expression OperatorsLEFT="0" WIDTH="63"OperatorLEFT="70" WIDTH="243"MeaningLEFT="0" WIDTH="63"    +LEFT="70" WIDTH="243"AdditionLEFT="0" WIDTH="63"    -LEFT="70" WIDTH="243"SubtractionLEFT="0" WIDTH="63"    *LEFT="70" WIDTH="243"MultiplicationLEFT="0" WIDTH="63"    /LEFT="70" WIDTH="243"DivisionLEFT="0" WIDTH="63"    %LEFT="70" WIDTH="243"RemainderLEFT="0" WIDTH="63"    <<LEFT="70" WIDTH="243"Shift LeftLEFT="0" WIDTH="63"    >>LEFT="70" WIDTH="243"Shift Right (sign NOT extended)LEFT="0" WIDTH="63"    ^LEFT="70" WIDTH="243"Bitwise Exclusive-ORLEFT="0" WIDTH="63"    &LEFT="70" WIDTH="243"Bitwise ANDLEFT="0" WIDTH="63"    |LEFT="70" WIDTH="243"Bitwise ORLEFT="0" WIDTH="63"    -LEFT="70" WIDTH="243"Minus (unary)LEFT="0" WIDTH="63"    +LEFT="70" WIDTH="243"Identity (unary)LEFT="0" WIDTH="63"    ~LEFT="70" WIDTH="243"ComplementLBL="" HELPID=""Data TypesID="04.lex35"ID="04.lex36"The assembler manipulates several types of expressions. Each symbol you reference or define belongs to one of the categories shown in IDREF="15316" TYPE="TABLE"Table 4-3.COLUMNS="2"LBL="4-3"Table 4-3 ID="15316"Data TypesLEFT="0" WIDTH="72"TypeLEFT="80" WIDTH="261"DescriptionLEFT="0" WIDTH="72"undefinedLEFT="80" WIDTH="261"Any symbol that is referenced but not defined becomes global 
undefined, and this module will attempt to import it. The 
assembler uses 32-bit addressing to access these symbols. 
(Declaring such a symbol in a. globl pseudo-op merely makes its 
status clearer).LEFT="0" WIDTH="72"sundefinedLEFT="80" WIDTH="261"A symbol defined by a .extern pseudo-op becomes global small  
undefined if its size is greater than zero but less than the number 
of bytes specified by the ­G option on the command line (which 
defaults to 8). The linker places these symbols within a 64KB  
region pointed to by the $gp register, so that the assembler can 
use economical 16-bit addressing to access them.LEFT="0" WIDTH="72"absoluteLEFT="80" WIDTH="261"A constant defined in an "=" expression.LEFT="0" WIDTH="72"textLEFT="80" WIDTH="261"The text section contains the program's instructions, which are 
not modifiable during execution. Any symbol defined while the 
.text pseudo-op is in effect belongs to the text section.LEFT="0" WIDTH="72"dataLEFT="80" WIDTH="261"The data section contains memory that the linker can initialize to  
nonzero values before your program begins to execute. Any 
symbol defined while the .data pseudo-op is in effect belongs to 
the data section. The assembler uses 32-bit or 64-bit addressing to 
access these symbols (depending on whether you are in 32-bit or 
64-bit mode).LEFT="0" WIDTH="72"sdataLEFT="80" WIDTH="261"This category is similar to data, except that defining a symbol 
while the .sdata ("small data") pseudo-op is in effect causes the 
linker to place it within a 64KB region pointed to by the $gp register, so that the assembler can use economical 16-bit 
addressing to access it.LEFT="0" WIDTH="72"rdataLEFT="80" WIDTH="261"Any symbol defined while the .rdata pseudo-op is in effect 
belongs to this category, which is similar to data, but may not be 
modified during execution.LEFT="0" WIDTH="72"bss and sbssLEFT="80" WIDTH="261"The bss and sbss sections consist of memory which the kernel 
loader initializes to zero before your program begins to execute. 
Any symbol defined in a .comm or .lcomm pseudo-op belongs to 
these sections (except that a .data, .sdata, or .rdata pseudo-op can 
override a .comm directive). If its size is less than the number of 
bytes specified by the ­G option on the command line (which 
defaults to 8), it belongs to sbss ("small bss"), and the linker 
places it within a 64k byte region pointed to by the $gp register so 
that the assembler can use economical 16-bit addressing to access 
it.  Otherwise, it belongs to bss and the assembler uses 32-bit or 
64-bit  addressing (depending on whether you are in 32-bit or 
64-bit mode). Local symbols in bss or sbss defined by .lcomm are 
allocated memory by the assembler; global symbols are allocated 
memory by the link editor; and symbols defined by .comm are 
overlaid upon like-named symbols (in the fashion of Fortran 
"COMMON" blocks) by the link editor.Symbols in the undefined and small undefined categories are always global (that is, they are visible to the link editor and can be shared with other modules of your program). Symbols in the absolute, text, data, sdata, rdata, bss, and sbss categories are local unless declared in a .globl pseudo-op.LBL="" HELPID=""Type Propagation in ExpressionsID="04.lex37"ID="04.lex38"When expression operators combine expression operands, the result's type depends on the types of the operands and on the operator. Expressions follow these type propagation rules:If an operand is undefined, the result is undefined.If both operands are absolute, the result is absolute.If the operator is + and the first operand refers to a relocatable text-section, data-section, bss-section, or an undefined external, the result has the postulated type and the other operand must be absolute.If the operator is ­ and the first operand refers to a relocatable text-section, data-section, or bss-section symbol, the second operand can be absolute (if it previously defined) and the result has the first operand's type; or the second operand can have the same type as the first operand and the result is absolute. If the first operand is external undefined, the second operand must be absolute.The operators * , /, % , << , >> , ~, ^ , & , and | apply only to absolute symbols.LBL="5"The Instruction SetID="05.instruct1"This chapter describes instruction notation and discusses assembler instructions for the main processor. Chapter 6 describes coprocessor notation and instructions.LBL="" HELPID=""Instruction ClassesID="05.instruct2"The assembler has these classes of instructions for the main processor: Load and Store Instructions. These instructions load immediate values and move data between memory and general registers.ID="05.instruct3"Computational Instructions. These instructions do arithmetic and logical operations for values in registers.ID="05.instruct4"Jump and Branch Instructions. These instructions change program control flow.ID="05.instruct5"ID="05.instruct6"ID="05.instruct7"In addition, there are two other classes of instruction:Coprocessor Interface. These instructions provide standard interfaces to the coprocessors.Special Instructions. These instructions do miscellaneous tasks.ID="05.instruct8"LBL="" HELPID=""Reorganization Constraints and Rules ID="05.instruct9"ID="05.instruct10"ID="05.instruct11"To maximize performance, the goal of RISC designs is to achieve an execution rate of one machine cycle per instruction. When writing assembly language instructions, you must be aware of the rules to achieve this goal. This information is given in the ID="05.instruct12"MIPS R4000 Microprocessor User's Manual (published by Prentice Hall) or the MIPS R8000 Microprocessor User's Manual, depending on which architecture you are using.LBL="" HELPID=""Instruction Notation ID="05.instruct13"The tables in this chapter list the assembler format for each load, store, computational, jump, branch, coprocessor, and special instruction. The format consists of an op-code and a list of operand formats. The tables list groups of closely related instructions; for those instructions, you can use any op-code with any specified operand. Operands can take any of these formats:Memory references. For example, a relocatable symbol +/­ an expression(register). Expressions (for immediate values). Two or three operands. For example, ADD $3,$4 is the same as ADD $3,$3,$4. The operands in the table in this chapter have the following meaningsCOLUMNS="2"LEFT="0" WIDTH="81"OperandLEFT="90" WIDTH="244"DescriptionLEFT="0" WIDTH="81"addressLEFT="90" WIDTH="244"Symbolic expression (see Chapter2)LEFT="0" WIDTH="81"breakcodeLEFT="90" WIDTH="244"Value that determines the breakLEFT="0" WIDTH="81"destinationLEFT="90" WIDTH="244"Destination registerLEFT="0" WIDTH="81"destination/src1LEFT="90" WIDTH="244"Destination register is also source register 1LEFT="0" WIDTH="81"dest-coprLEFT="90" WIDTH="244"Destination coprocessor registerLEFT="0" WIDTH="81"dest-gprLEFT="90" WIDTH="244"Destination general registerLEFT="0" WIDTH="81"expressionLEFT="90" WIDTH="244"Absolute valueLEFT="0" WIDTH="81"immediateLEFT="90" WIDTH="244"Expression with an immediate valueLEFT="0" WIDTH="81"labelLEFT="90" WIDTH="244"Symbolic labelLEFT="0" WIDTH="81"operationLEFT="90" WIDTH="244"Coprocessor-specific operationLEFT="0" WIDTH="81"returnLEFT="90" WIDTH="244"Register containing the return addressLEFT="0" WIDTH="81"sourceLEFT="90" WIDTH="244"Source registerLEFT="0" WIDTH="81"src1, src2LEFT="90" WIDTH="244"Source registersLEFT="0" WIDTH="81"src-coprLEFT="90" WIDTH="244"Coprocessor register from which values are assignedLEFT="0" WIDTH="81"src-gprLEFT="90" WIDTH="244"General register from which values are assignedLEFT="0" WIDTH="81"targetLEFT="90" WIDTH="244"Register containing the targetLEFT="0" WIDTH="81"zLEFT="90" WIDTH="244"Coprocessor number in the range 0..2LBL="" HELPID=""Instruction SetThe tables in this section summarize the assembly language instruction set. Most of the assembly language instructions have direct machine equivalents.LBL="" HELPID=""Load and Store InstructionsLoad and store are immediate type intructions that move data between memory and the general registers. IDREF="78915" TYPE="TABLE"Table 5-1 summarizes the load and store instruction format, and IDREF="51991" TYPE="TABLE"Table 5-2  and IDREF="88275" TYPE="TABLE"Table 5-3 provide more detailed descriptions for each load instruction. IDREF="16676" TYPE="TABLE"Table 5-4 and IDREF="88873" TYPE="TABLE"Table 5-5  provide details of each store instruction.ID="05.instruct14"ID="05.instruct15"ID="05.instruct16"COLUMNS="3"LBL="5-1"Table 5-1 ID="78915"Load and Store Format SummaryLEFT="0" WIDTH="126"DescriptionLEFT="135" WIDTH="45"Op-codeLEFT="185" WIDTH="135"OperandsLEFT="0" WIDTH="126"Load AddressLEFT="135" WIDTH="45"LALEFT="185" WIDTH="135"destination, addressLEFT="0" WIDTH="126"Load Doubleword AddressLEFT="135" WIDTH="45"DLALEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Load ByteLEFT="135" WIDTH="45"LBLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Load Byte UnsignedLEFT="135" WIDTH="45"LBULEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Load HalfwordLEFT="135" WIDTH="45"LHLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Load Halfword UnsignedLEFT="135" WIDTH="45"LHULEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Load Linked*LEFT="135" WIDTH="45"LLLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Load WordLEFT="135" WIDTH="45"LWLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Load Word LeftLEFT="135" WIDTH="45"LWLLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Load Word RightLEFT="135" WIDTH="45"LWRLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Load DoublewordLEFT="135" WIDTH="45"LDLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Unaligned Load HalfwordLEFT="135" WIDTH="45"ULHLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Unaligned Load Halfword 
UnsignedLEFT="135" WIDTH="45"ULHULEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Unaligned Load WordLEFT="135" WIDTH="45"ULWLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Load ImmediateLEFT="135" WIDTH="45"LILEFT="185" WIDTH="135"destination, expressionLEFT="0" WIDTH="126"Load Doublewod ImmediateLEFT="135" WIDTH="45"DLILEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Store Double RightLEFT="135" WIDTH="45"SDRLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Unaligned Store DoublewordLEFT="135" WIDTH="45"USDLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Load Upper ImmediateLEFT="135" WIDTH="45"LUILEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Store ByteLEFT="135" WIDTH="45"SBLEFT="185" WIDTH="135"source, addressLEFT="0" WIDTH="126"Store Conditional *LEFT="135" WIDTH="45"SCLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Store DoubleLEFT="135" WIDTH="45"SDLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Store HalfwordLEFT="135" WIDTH="45"SHLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Store Word LeftLEFT="135" WIDTH="45"SWLLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Store Word RightLEFT="135" WIDTH="45"SWRLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Store WordLEFT="135" WIDTH="45"SWLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Unaligned Store HalfwordLEFT="135" WIDTH="45"USHLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Unaligned Store WordLEFT="135" WIDTH="45"USWLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Load DoublewordLEFT="135" WIDTH="45"LDLEFT="185" WIDTH="135"destination, addressLEFT="0" WIDTH="126"Load Linked DoublewordLEFT="135" WIDTH="45"LLDLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Load Word UnsignedLEFT="135" WIDTH="45"LWULEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Load Doubleword LeftLEFT="135" WIDTH="45"LDLLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Load Doubleword RightLEFT="135" WIDTH="45"LDRLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Unaligned Load DoubleLEFT="135" WIDTH="45"ULDLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Store DoublewordLEFT="135" WIDTH="45"SDLEFT="185" WIDTH="135"source, addressLEFT="0" WIDTH="126"Store Conditional 
DoublewordLEFT="135" WIDTH="45"SCDLEFT="185" WIDTH="135"LEFT="0" WIDTH="126"Store Double LeftLEFT="135" WIDTH="45"SDLLEFT="185" WIDTH="135"LEFT="0" WIDTH="45"LEFT="50" WIDTH="135"LBL="a" ID="05.instructTF1a"* Not valid in MIPS1 architecturesLBL="" HELPID=""Load Instruction DescriptionsID="05.instruct17"ID="05.instruct18"For all load instructions, the effective address is the 32-bit twos-complement sum of the contents of the index-register and the (sign-extended) 16-bit offset. Instructions that have symbolic labels imply an index register, which the assembler determines. The assembler supports additional load instructions, which can produce multiple machine instructions.Note Load instructions can generate many code sequences for which the link editor must fix the address by resolving external data items.COLUMNS="2"LBL="5-2"Table 5-2 ID="51991"Load Instruction DescriptionsLEFT="0" WIDTH="90"Instruction NameLEFT="95" WIDTH="240"DescriptionLEFT="0" WIDTH="90"Load Address (LA)LEFT="95" WIDTH="240"Loads the destination register with the effective 32-bit 
address of the specified data item. LEFT="0" WIDTH="90"Load Doubleword 
Address (DLA)LEFT="95" WIDTH="240"Loads the destination register with the effective 64-bit 
address of the specified data item (MIPS4 only). LEFT="0" WIDTH="90"Load Byte (LB)LEFT="95" WIDTH="240"Loads the least-significant byte of the destination register 
with the contents of the byte that is at the memory location 
specified by the effective address. The system treats the 
loaded byte as a signed value: bit seven is extended to fill 
the three most-significant bytes.LEFT="0" WIDTH="90"Load Byte Unsigned 
(LBU)LEFT="95" WIDTH="240"Loads the least-significant byte of the destination register 
with the contents of the byte that is at the memory location 
specified by the effective address. Because the system treats 
the loaded byte as an unsigned value, it fills the three 
most-significant bytes of the destination register with zeros. LEFT="0" WIDTH="90"Load Halfword (LH)LEFT="95" WIDTH="240"Loads the two least-significant bytes of the destination 
register with the contents of the halfword that is at the 
memory location specified by the effective address. The 
system treats the loaded halfword as a signed value. If the 
effective address is not even, the system signals an address 
error exception. LEFT="0" WIDTH="90"Load Halfword 
Unsigned (LHU)LEFT="95" WIDTH="240"Loads the least-significant bits of the destination register 
with the contents of the halfword that is at the memory 
location specified by the effective address. Because the 
system treats the loaded halfword as an unsigned value, it 
fills the two most-significant bytes of the destination 
register with zeros. If the effective address is not even, the 
system signals an address error exception.LEFT="0" WIDTH="90"Load Linked (LL) *LEFT="95" WIDTH="240"Loads the destination register with the contents of the word 
that is at the memory location. This instruction performs an 
SYNC operation implicitly; all loads and stores to shared 
memory fetched prior to the LL must access memory before 
the LL, and loads and stores to shared memory fetched 
subsequent to the LL must access memory after the LL. 
Load Linked and Store Conditional can be use to update 
memory locations atomically.  The system signals an 
address exception when the effective address is not 
divisible by four. *This instruction is not valid in the MIPS1 
architectures.LEFT="0" WIDTH="90"Load Word (LW) LEFT="95" WIDTH="240"Loads the destination register with the contents of the word 
that is at the memory location. The system replaces all bytes 
of the register with the contents of the loaded word. The 
system signals an address error exception when the 
effective address is not divisible by four.LEFT="0" WIDTH="90"Load Word Left 
(LWL) LEFT="95" WIDTH="240"Loads the sign; that is, Load Word Left loads the destination 
register with the most-significant bytes of the word 
specified by the effective address. The effective address 
must specify the byte containing the sign. In a big-endian 
system, the effective address specifies the lowest numbered 
byte; in a little-endian system, the effective address specifies 
the highest numbered byte.  Only the bytes which share the 
same aligned word in memory are merged into the 
destination register.LEFT="0" WIDTH="90"Load Word Right 
(LWR)LEFT="95" WIDTH="240"Loads the lowest precision bytes; that is, Load Word Right 
loads the destination register with the least-significant bytes 
of the word specified by the effective address. The effective 
address must specify the byte containing the 
least-significant bits. In a big-endian configuration, the 
effective address specifies the highest numbered byte; in a 
little-endian configuration, the effective address specifies 
the lowest numbered byte. Only the bytes which share the 
same aligned word in memory are merged into the 
destination register.LEFT="0" WIDTH="90"Load Doubleword 
(LD)LEFT="95" WIDTH="240"LD is a machine instruction in the MIPS3 architecture. For 
the -mips1 [default] and -mips2 option: Loads the register 
pair (destination and destination +1) with the two successive 
words specified by the address. The destination register 
must be the even register of the pair. When the address is 
not on a word boundary, the system signals an address error 
exception. Note: This is retained for use with the -mips1 and -mips2 
options to provide backward compatibility only. LEFT="0" WIDTH="90"Unaligned Load 
Halfword (ULH)LEFT="95" WIDTH="240"Loads a halfword into the destination register from the 
specified address and extends the sign of the halfword. 
Unaligned Load Halfword loads a halfword regardless of 
the halfword's alignment in memory. LEFT="0" WIDTH="90"Unaligned Load 
Halfword Unsigned 
(ULHU)LEFT="95" WIDTH="240"Loads a halfword into the destination register from the 
specified address and zero extends the halfword. Unaligned 
Load Halfword Unsigned loads a halfword regardless of 
the halfword's alignment in memory.LEFT="0" WIDTH="90"Unaligned Load 
Word (ULW)LEFT="95" WIDTH="240"Loads a word into the destination register from the 
specified address. Unaligned Load Word loads a word 
regardless of the word's alignment in memory. LEFT="0" WIDTH="90"Load Immediate (LI)LEFT="95" WIDTH="240"Loads the destination register with the 32-bit value of an 
expression that can be computed at assembly time. Note: Load Immediate can generate any efficient code 
sequence to put a desired value in the register.LEFT="0" WIDTH="90"Load Doubleword 
Immediate (DLI)LEFT="95" WIDTH="240"Loads the destination register with the 64-bit value of an 
expression that can be computed at assembly time. Note: Load Immediate can generate any efficient code 
sequence to put a desired value in the register (MIPS4 only).LEFT="0" WIDTH="90"Load Upper 
Immediate (LUI)LEFT="95" WIDTH="240"Loads the most-significant half of a register with the 
expression's value. The system fills the least-significant half 
of the register with zeros. The expression's value must be in 
the range ­32768...65535.COLUMNS="2"LBL="5-3"Table 5-3 ID="88275"Load Instruction Descriptions for MIPS3/4 Architecture OnlyLEFT="0" WIDTH="90"Instruction NameLEFT="95" WIDTH="242"DescriptionLEFT="0" WIDTH="90"Load Doubleword 
(LD)LEFT="95" WIDTH="242"Loads the destination register with the contents of the 
doubleword that is at the memory location. The system 
replaces all bytes of the register with the contents of the 
loaded doubleword. The system signals an address error 
exception when the effective address is not divisible by 
eight.LEFT="0" WIDTH="90"Load Linked 
Doubleword (LLD)LEFT="95" WIDTH="242"Loads the destination register with the contents of the 
doubleword that is currently in the memory location. This 
instruction performs a SYNC operation implicitly. Load 
Linked Doubleword and Store Conditional Doubleword can 
be used to update memory locations atomically.LEFT="0" WIDTH="90"Load Word 
Unsigned(LWU)LEFT="95" WIDTH="242"Loads the least-significant bits of the destination register 
with the contents of the word (32 bits) that is at the memory 
location specified by the effective address. Because the 
system treats the loaded word as an unsigned value, it fills 
the four most-significant bytes of the destination register 
with zeros. If the effective address is not divisible by four, 
the system signals an address error exception.LEFT="0" WIDTH="90"Load Doubleword 
Left (LDL)LEFT="95" WIDTH="242"Loads the destination register with the most-significant 
bytes of the doubleword specified by the effective address. 
The effective address must specify the byte containing the 
sign. In a big-endian configuration, the effective address 
specifies the lowest numbered byte; in a little-endian 
machine, the effective address specifies the highest 
numbered byte. Only the bytes which share the same 
aligned doubleword in memory are merged into the 
destination register.LEFT="0" WIDTH="90"Load Doubleword 
Right (LDR)LEFT="95" WIDTH="242"Loads the destination register with the least-significant 
bytes of the doubleword specified by the effective address. 
The effective address must specify the byte containing the 
least-significant bits. In a bid-endian machine, the effective 
address specifies the highest numbered byte. In a 
little-endian machine, the effective address specifies the 
lowest numbered byte. Only the bytes which share the same 
aligned doubleword in memory are merged into the 
destination register.LEFT="0" WIDTH="90"Unaligned Load 
Doubleword (ULD)LEFT="95" WIDTH="242"Loads a doubleword into the destination register from the 
specified address. ULD loads a doubleword regardless of 
the doubleword's alignment in memory.LBL="" HELPID=""Store Instruction DescriptionsID="05.instruct19"For all machine store instructions, the effective address is the 32-bit twos-complement sum of the contents of the index-register and the (sign-extended) 16-bit offset. The assembler supports additional store instructions, which can produce multiple machine instructions. Instructions that have symbolic labels imply an index-register, which the assembler determines.        ID="05.instruct20"COLUMNS="2"LBL="5-4"Table 5-4 ID="16676"Store Instruction DescriptionsLEFT="0" WIDTH="90"Instruction NameLEFT="95" WIDTH="240"DescriptionLEFT="0" WIDTH="90"Store Byte (SB)LEFT="95" WIDTH="240"Stores the contents of the source register's least-significant 
byte in the byte specified by the effective address.LEFT="0" WIDTH="90"Store Conditional* 
(SC)LEFT="95" WIDTH="240"Stores the contents of a word from the source register into 
the memory location specified by the effective address. This 
instruction implicitly performs a SYNC operation; all loads 
and stores to shared memory fetched prior to the sc must 
access memory before the sc, and loads and stores to shared 
memory fetched subsequent to the sc must access memory 
after the sc. If any other processor or device has modified 
the physical address since the time of the previous Load 
Linked instruction, or if an RFE or ERET instruction occurs 
between the Load Linked and this store instruction, the 
store fails. The success or failure of the store operation (as 
defined above) is indicated by the contents of the source 
register after execution of the instruction. A successful store 
sets it to 1; and a failed store sets it to 0. The machine signals 
an address exception when the effective address is not 
divisible by four. *This instruction is not valid in the MIPS1 
architectures.LEFT="0" WIDTH="90"Store Doubleword 
(SD)LEFT="95" WIDTH="240"SD is a machine instruction in the MIPS3 architecture. For 
the -mips1 [default] and -mips2 options: Stores the 
contents of the register pair in successive words, which the 
address specifies. The source register must be the even 
register of the pair, and the storage address must be word 
aligned. Note: This is retained for use with the -mips1 and -mips2 
options to provide backward compatibility only.LEFT="0" WIDTH="90"Store Halfword (SH)LEFT="95" WIDTH="240"Stores the two least-significant bytes of the source register 
in the halfword that is at the memory location specified by 
the effective address. The effective address must be 
divisible by two; otherwise the machine signals an address 
error exception.LEFT="0" WIDTH="90"Store Word Left 
(SWL)LEFT="95" WIDTH="240"Stores the most-significant bytes of a word in the memory 
location specified by the effective address. The contents of 
the word at the memory location, specified by the effective 
address, are shifted right so that the leftmost byte of the 
unaligned word is in the addressed byte position. The 
stored bytes replace the corresponding bytes of the effective 
address. The effective address's last two bits determine how 
many bytes are involved.LEFT="0" WIDTH="90"Store Word Right 
(SWR)LEFT="95" WIDTH="240"Stores the least-significant bytes of a word in the memory 
location specified by the effective address. The contents of 
the word at the memory location, specified by the effective 
address, are shifted left so that the right byte of the 
unaligned word is in the addressed byte position. The 
stored bytes replace the corresponding bytes of the effective 
address. The effective address's last two bits determine how 
many bytes are involved.LEFT="0" WIDTH="90"Store Word (SW)LEFT="95" WIDTH="240"Stores the contents of a word from the source register in the 
memory location specified by the effective address. The 
effective address must be divisible by four; otherwise the 
machine signals an address error exception.LEFT="0" WIDTH="90"Unaligned Store 
Halfword (USH)LEFT="95" WIDTH="240"Stores the contents of the two least-significant bytes of the 
source register in a halfword that the address specifies. The 
machine does not require alignment for the storage address.LEFT="0" WIDTH="90"Unaligned Store 
Word (USW)LEFT="95" WIDTH="240"Stores the contents of the source register in a word specified 
by the address. The machine does not require alignment for 
the storage address.COLUMNS="2"LBL="5-5"Table 5-5 ID="88873"Store Instruction Descriptions for MIPS3/4 Architecture OnlyLEFT="0" WIDTH="90"Instruction NameLEFT="95" WIDTH="242"DescriptionLEFT="0" WIDTH="90"Store Doubleword 
(SD)LEFT="95" WIDTH="242"Stores the contents of a doubleword from the source register 
in the memory location specified by the effective address. 
The effective address must be divisible by eight, otherwise 
the machine signals an address error exception.LEFT="0" WIDTH="90"Store Conditional 
Doubleword (SCD)LEFT="95" WIDTH="242"Stores the contents of a doubleword from the source register 
into the memory locations specified by the effective address. 
This instruction implicitly performs a SYNC operation. If 
any other processor or device has modified the physical 
address since the time of the previous Load Linked 
instruction, or if an ERET instruction occurs between the 
Load Linked instruction and this store instruction, the store 
fails and is inhibited from taking place. The success or 
failure of the store operation (as defined above) is indicated 
by the contents of the source register after execution of this 
instruction. A successful store sets it to 1; and a failed store 
sets it to 0. The machine signals an address exception when 
the effective address is not divisible by eight.LEFT="0" WIDTH="90"Store Doubleword 
Left (SDL)LEFT="95" WIDTH="242"Stores the most-significant bytes of a doubleword in the 
memory location specified by the effective address. It alters 
only the doubleword in memory which contains the byte 
indicated by the effective address.LEFT="0" WIDTH="90"Store Doubleword 
Right (SDR)LEFT="95" WIDTH="242"Stores the least-significant bytes of a doubleword in the 
memory location specified by the effective address. It alters 
only the doubleword in memory which contains the byte 
indicated by the effective address.LEFT="0" WIDTH="90"Unaligned Store 
Doubleword (USD)LEFT="95" WIDTH="242"Stores the contents of the source register in a doubleword 
specified by the address. The machine does not require 
alignment for the storage address.LBL="" HELPID=""Computational InstructionsID="05.instruct21"ID="05.instruct22"The machine has general-purpose and coprocessor-specific computational instructions (for example, the floating-point coprocessor). This part of the book describes general-purpose computational instructions. LBL="" HELPID=""Computational InstructionsComputational instructions perform the following operations on register values;arithmeticlogicalshiftmultiplydivideIDREF="15026" TYPE="TABLE"Table 5-6 summarizes the computational format summaries, and IDREF="32540" TYPE="TABLE"Table 5-7 and IDREF="45575" TYPE="TABLE"Table 5-8 describe these instructions in more detail. COLUMNS="3"LBL="5-6"Table 5-6 ID="15026"Computational Format SummariesLEFT="0" WIDTH="138"DescriptionLEFT="145" WIDTH="45"Op-codeLEFT="195" WIDTH="121"OperandLEFT="0" WIDTH="138"Add with OverflowLEFT="145" WIDTH="45"ADDLEFT="195" WIDTH="121"destination, src1, src2LEFT="0" WIDTH="138"Add without OverflowLEFT="145" WIDTH="45"ADDULEFT="195" WIDTH="121"destination, src1, src2LEFT="0" WIDTH="138"ANDLEFT="145" WIDTH="45"ANDLEFT="195" WIDTH="121"destination, src1, immediateLEFT="0" WIDTH="138"Divide SignedLEFT="145" WIDTH="45"DIVLEFT="195" WIDTH="121"destination/src1, immediateLEFT="0" WIDTH="138"Divide UnsignedLEFT="145" WIDTH="45"DIVULEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Exclusive-ORLEFT="145" WIDTH="45"XORLEFT="195" WIDTH="121"LEFT="0" WIDTH="138"MultiplyLEFT="145" WIDTH="45"MULLEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Multiply with OverflowLEFT="145" WIDTH="45"MULOLEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Multiply with Overflow 
UnsignedLEFT="145" WIDTH="45"MULOULEFT="195" WIDTH="121"LEFT="0" WIDTH="138"NOT ORLEFT="145" WIDTH="45"NORLEFT="195" WIDTH="121"LEFT="0" WIDTH="138"ORLEFT="145" WIDTH="45"ORLEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Set EqualLEFT="145" WIDTH="45"SEQLEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Set Greater ThanLEFT="145" WIDTH="45"SGTLEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Set Greater/EqualLEFT="145" WIDTH="45"SGELEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Set Greater/Equal UnsignedLEFT="145" WIDTH="45"SGEULEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Set Greater UnsignedLEFT="145" WIDTH="45"SGTULEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Set Less ThanLEFT="145" WIDTH="45"SLTLEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Set Less/EqualLEFT="145" WIDTH="45"SLELEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Set Less/Equal UnsignedLEFT="145" WIDTH="45"SLEULEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Set Less Than UnsignedLEFT="145" WIDTH="45"SLTULEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Set Not EqualLEFT="145" WIDTH="45"SNELEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Subtract with OverflowLEFT="145" WIDTH="45"SUBLEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Subtract without OverflowLEFT="145" WIDTH="45"SUBULEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Remainder SignedLEFT="145" WIDTH="45"REMLEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Remainder UnsignedLEFT="145" WIDTH="45"REMULEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Rotate LeftLEFT="145" WIDTH="45"ROLLEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Rotate RightLEFT="145" WIDTH="45"RORLEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Shift Right ArithmeticLEFT="145" WIDTH="45"SRALEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Shift Left LogicalLEFT="145" WIDTH="45"SLLLEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Shift Right LogicalLEFT="145" WIDTH="45"SRLLEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Absolute ValueLEFT="145" WIDTH="45"ABSLEFT="195" WIDTH="121"destination, src1LEFT="0" WIDTH="138"Negate with OverflowLEFT="145" WIDTH="45"NEGLEFT="195" WIDTH="121"destination/src1LEFT="0" WIDTH="138"Negate without OverflowLEFT="145" WIDTH="45"NEGULEFT="195" WIDTH="121"LEFT="0" WIDTH="138"NOTLEFT="145" WIDTH="45"NOTLEFT="195" WIDTH="121"LEFT="0" WIDTH="138"MoveLEFT="145" WIDTH="45"MOVELEFT="195" WIDTH="121"destination, src1LEFT="0" WIDTH="138"Move Conditional on Not ZeroLEFT="145" WIDTH="45"MOVNLEFT="195" WIDTH="121"destination, src1, src2LEFT="0" WIDTH="138"Move Conditional on ZeroLEFT="145" WIDTH="45"MOVZLEFT="195" WIDTH="121"LEFT="0" WIDTH="138"MultiplyLEFT="145" WIDTH="45"MULTLEFT="195" WIDTH="121"src1,src2LEFT="0" WIDTH="138"Multiply UnsignedLEFT="145" WIDTH="45"MULTULEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Trap if EqualLEFT="145" WIDTH="45"TEQLEFT="195" WIDTH="121"src1, src2LEFT="0" WIDTH="138"Trap if not EqualLEFT="145" WIDTH="45"TNELEFT="195" WIDTH="121"src1, immediateLEFT="0" WIDTH="138"Trap if Less ThanLEFT="145" WIDTH="45"TLTLEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Trap if Less than, UnsignedLEFT="145" WIDTH="45"TLTULEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Trap if Greater Than or EqualLEFT="145" WIDTH="45"TGELEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Trap if Greater than or Equal, 
UnsignedLEFT="145" WIDTH="45"TGEULEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Doubleword Add with OverflowLEFT="145" WIDTH="45"DADDLEFT="195" WIDTH="121"destination,src1, src2
destination/src1,src2LEFT="0" WIDTH="138"Doubleword Add without 
OverflowLEFT="145" WIDTH="45"DADDULEFT="195" WIDTH="121"destination, src1, immediatedestination/src1, immediateLEFT="0" WIDTH="138"Doubleword Divide SignedLEFT="145" WIDTH="45"DDIVLEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Doubleword Divide UnsignedLEFT="145" WIDTH="45"DDIVULEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Doubleword MultiplyLEFT="145" WIDTH="45"DMULLEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Doubleword Multiply with 
OverflowLEFT="145" WIDTH="45"DMULOLEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Doubleword Multiply with 
Overflow UnsignedLEFT="145" WIDTH="45"DMULO
ULEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Doubleword Subtract with 
OverflowLEFT="145" WIDTH="45"DSUBLEFT="195" WIDTH="121"LEFT="0" WIDTH="138"Doubleword Subtract without 
OverflowLEFT="145" WIDTH="45"DSUBULEFT="195" WIDTH="121"COLUMNS="3"LEFT="0" WIDTH="142"DescriptionLEFT="150" WIDTH="45"Op-codeLEFT="200" WIDTH="118"OperandLEFT="0" WIDTH="142"Doubleword Remainder SignedLEFT="150" WIDTH="45"DREMLEFT="200" WIDTH="118"LEFT="0" WIDTH="142"Doubleword Remainder UnsignedLEFT="150" WIDTH="45"DREMULEFT="200" WIDTH="118"LEFT="0" WIDTH="142"Doubleword Rotate LeftLEFT="150" WIDTH="45"DROLLEFT="200" WIDTH="118"LEFT="0" WIDTH="142"Doubleword Rotate RightLEFT="150" WIDTH="45"DRORLEFT="200" WIDTH="118"LEFT="0" WIDTH="142"Doubleword Shift Right 
ArithmeticLEFT="150" WIDTH="45"DSRALEFT="200" WIDTH="118"LEFT="0" WIDTH="142"Doubleword Shift Left LogicalLEFT="150" WIDTH="45"DSLLLEFT="200" WIDTH="118"LEFT="0" WIDTH="142"Doubleword Shift Right LogicalLEFT="150" WIDTH="45"DSRLLEFT="200" WIDTH="118"LEFT="0" WIDTH="142"Doubleword Absolute ValueLEFT="150" WIDTH="45"DABSLEFT="200" WIDTH="118"destination, src1LEFT="0" WIDTH="142"Doubleword Negate with 
OverflowLEFT="150" WIDTH="45"DNEGLEFT="200" WIDTH="118"destination/src1LEFT="0" WIDTH="142"Doubleword Negate without 
OverflowLEFT="150" WIDTH="45"DNEGULEFT="200" WIDTH="118"LEFT="0" WIDTH="142"Doubleword MultiplyLEFT="150" WIDTH="45"DMULTLEFT="200" WIDTH="118"src1, src2LEFT="0" WIDTH="142"Doubleword Multiply UnsignedLEFT="150" WIDTH="45"DMULT
ULEFT="200" WIDTH="118"src1, immediateLBL="" HELPID=""Computational Instruction DescriptionsID="05.instruct23"COLUMNS="2"LBL="5-7"Table 5-7 ID="32540"Computational Instruction DescriptionsLEFT="0" WIDTH="90"Instruction NameLEFT="95" WIDTH="243"DescriptionLEFT="0" WIDTH="90"Absolute Value 
(ABS)LEFT="95" WIDTH="243"Computes the absolute value of the contents of src1 and puts 
the result in the destination register. If the value in src1 is 
­2147483648, the machine signals an overflow exception.LEFT="0" WIDTH="90"Add with Overflow 
(ADD)LEFT="95" WIDTH="243"Computes the twos-complement sum of two signed values. 
This instruction adds the contents of src1 to the contents of 
src2, or it can add the contents of src1 to the immediate value. 
Add (with Overflow) puts the result in the destination 
register. When the result cannot be extended as a 32-bit 
number, the machine signals an overflow exception.LEFT="0" WIDTH="90"Add without 
Overflow (ADDU)LEFT="95" WIDTH="243"Computes the twos-complement sum of two 32-bit values. 
This instruction adds the contents of src1 to the contents of 
src2, or it can add the contents of src1 to the immediate value. 
Add (without Overflow) puts the result in the destination 
register. Overflow exceptions never occur.LEFT="0" WIDTH="90"AND (AND)LEFT="95" WIDTH="243"Computes the Logical AND of two values. This instruction 
ANDs (bit-wise) the contents of src1 with the contents of 
src2, or it can AND the contents of src1 with the immediate 
value. The immediate value is not sign extended. AND puts 
the result in the destination register.LEFT="0" WIDTH="90" Divide Signed (DIV)LEFT="95" WIDTH="243"Computes the quotient of two values. Divide (with 
Overflow) treats src1 as the dividend. The divisor can be src2 
or the immediate value. The instruction divides the contents 
of src1 by the contents of src2, or it can divide src1 by the 
immediate value. It puts the quotient in the destination 
register. If the divisor is zero, the machine signals an error 
and may issue a BREAK instruction. The DIV instruction 
rounds toward zero. Overflow is signaled when dividing 
­2147483648 by ­1. The machine may issue a BREAK 
instruction for divide-by-zero or for overflow. Note: The special case DIV $0,src1,src2 generates the real 
machine divide instruction and leaves the result in the 
HI/LO register. The HI register contains the remainder and 
the LO register contains the quotient. No checking for 
divide-by-zero is performed.LEFT="0" WIDTH="90"Divide Unsigned 
(DIVU)LEFT="95" WIDTH="243"Computes the quotient of two unsigned 32-bit values. 
Divide (unsigned) treats src1 as the dividend. The divisor 
can be src2 or the immediate value. This instruction divides 
the contents of src1 by the contents of src2, or it can divide 
the contents of src1 by the immediate value. Divide 
(unsigned) puts the quotient in the destination register. If the 
divisor is zero, the machine signals an exception and may 
issue a BREAK instruction. See the note for DIV concerning 
$0 as a destination. Overflow exceptions never occur.LEFT="0" WIDTH="90"Exclusive-OR (XOR)LEFT="95" WIDTH="243"Computes the XOR of two values. This instruction XORs 
(bit-wise) the contents of src1 with the contents of src2, or it 
can XOR the contents of src1 with the immediate value. The 
immediate value is not sign extended. Exclusive-OR puts 
the result in the destination register.LEFT="0" WIDTH="90"Move (MOVE)LEFT="95" WIDTH="243"Moves the contents of src1 to the destination register.LEFT="0" WIDTH="90"Move Conditional on 
Not Zero  (MOVN)LEFT="95" WIDTH="243"Conditionally moves the contents of src1 to the destination 
register after testing that src2 is not equal to zero (MIPS4 
only.)LEFT="0" WIDTH="90"Move Conditional on 
Zero  (MOVZ)LEFT="95" WIDTH="243"Conditionally moves the contents of src1 to the destination 
register after testing that src2 is equal to zero (MIPS4 only).LEFT="0" WIDTH="90"Multiply (MUL)LEFT="95" WIDTH="243"Computes the product of two values. This instruction puts 
the 32-bit product of src1 and src2, or the 32-bit product of 
src1 and the immediate value, in the destination register. The 
machine does not report overflow. Note: Use MUL when you do not need overflow protection: 
it's often faster than MULO and MULOU. For multiplication 
by a constant, the MUL instruction produces faster machine 
instruction sequences than MULT or MULTU instructions 
can produce.LEFT="0" WIDTH="90"Multiply (MULT)LEFT="95" WIDTH="243"Computes the 64-bit product of two 32-bit signed values. 
This instruction multiplies the contents of src1 by the 
contents of src2 and puts the result in the HI and LO registers 
(see Chapter 1). No overflow is possible. Note: The MULT instruction is a real machine language 
instruction.LEFT="0" WIDTH="90"Multiply Unsigned 
(MULTU)LEFT="95" WIDTH="243"Computes the product of two unsigned 32-bit values. It 
multiplies the contents of src1 and the contents of src2 and 
puts the result in the HI and LO registers (see Chapter 1). No 
overflow is possible. Note: The MULTU instruction is a real machine language 
instruction.LEFT="0" WIDTH="90"Multiply with 
Overflow (MULO)LEFT="95" WIDTH="243"Computes the product of two 32-bit signed values. Multiply 
(with Overflow) puts the 32-bit product of src1 and src2, or 
the 32-bit product of src1 and the immediate value, in the 
destination register. When an overflow occurs, the machine 
signals an overflow exception and may execute a BREAK 
instruction. Note: For multiplication by a constant, MULO produces 
faster machine instruction sequences than MULT or MULTU 
can produce; however, if you do not need overflow 
detection, use the MUL instruction. It's often faster than 
MULO.LEFT="0" WIDTH="90"Multiply with 
Overflow Unsigned 
(MULOU)LEFT="95" WIDTH="243"Computes the product of two 32-bit unsigned values. 
Multiply (with Overflow Unsigned) puts the 32-bit product 
of src1 and src2, or the product of src1 and the immediate 
value, in the destination register. This instruction treats the 
multiplier and multiplicand as 32-bit unsigned values. 
When an overflow occurs, the machine signals an overflow 
exception and may issue an BREAK instruction. Note: For multiplication by a constant, MULOU produces 
faster machine instruction sequences than MULT or MULTU 
can reproduce; however, if you do not need overflow 
detection, use the MUL instruction. It's often faster than 
MULOU.LEFT="0" WIDTH="90"Negate with 
Overflow (NEG)LEFT="95" WIDTH="243"Computes the negative of a value. This instruction negates 
the contents of src1 and puts the result in the destination 
register. If the value in src1 is ­2147483648, the machine 
signals an overflow exception.LEFT="0" WIDTH="90"Negate without 
Overflow (NEGU)LEFT="95" WIDTH="243"Negates the integer contents of src1 and puts the result in the 
destination register. The machine does not report overflows.LEFT="0" WIDTH="90"NOT (NOT)LEFT="95" WIDTH="243"Computes the Logical NOT of a value. This instruction 
complements (bit-wise) the contents of src1 and puts the 
result in the destination register.LEFT="0" WIDTH="90"NOT OR (NOR)LEFT="95" WIDTH="243"Computes the NOT OR of two values. This instruction 
combines the contents of src1 with the contents of src2 (or the 
immediate value). NOT OR complements the result and 
puts it in the destination register.LEFT="0" WIDTH="90"OR (OR)LEFT="95" WIDTH="243"Computes the Logical OR of two values. This instruction 
ORs (bit-wise) the contents of src1 with the contents of src2, 
or it can OR the contents of src1 with the immediate value. 
The immediate value is not sign-extended. OR puts the 
result in the destination register.LEFT="0" WIDTH="90"Remainder Signed 
(REM)LEFT="95" WIDTH="243"Computes the remainder of the division of two unsigned 
32-bit values. The machine defines the remainder REM(i,j) 
as i­(j*div(i,j)) where j · 0. Remainder (with Overflow) treats 
src1 as the dividend. The divisor can be src2 or the 
immediate value. This instruction divides the contents of 
src1 by the contents of src2, or it can divide the contents of 
src1 by the immediate value. It puts the remainder in the 
destination register. The REM instruction rounds toward 
zero, rather than toward negative infinity. For example, 
div(5,­3)=­1, and rem(5,­3)=2. For divide-by-zero, the 
machine signals an error and may issue a BREAK 
instruction.LEFT="0" WIDTH="90"Remainder 
Unsigned (REMU)LEFT="95" WIDTH="243"Computes the remainder of the division of two unsigned 
32-bit values. The machine defines the remainder REM(i,j) 
as i­(j*div(i,j)) where j · 0. Remainder (unsigned) treats src1 
as the dividend. The divisor can be src2 or the immediate 
value. This instruction divides the contents of src1 by the 
contents of src2, or it can divide the contents of src1 by the 
immediate value. Remainder (unsigned) puts the remainder 
in the destination register. For divide-by-zero, the machine 
signals an error and may issue a BREAK instruction.LEFT="0" WIDTH="90"Rotate Left (ROL)LEFT="95" WIDTH="243"Rotates the contents of a register left (toward the sign bit). 
This instruction inserts in the least-significant bit any bits 
that were shifted out of the sign bit. The contents of src1 
specify the value to shift, and the contents of src2 (or the 
immediate value) specify the amount to shift. Rotate Left 
puts the result in the destination register. If src2 (or the 
immediate value) is greater than 31, src1 shifts by (src2 MOD 
32).LEFT="0" WIDTH="90"Rotate Right (ROR)LEFT="95" WIDTH="243"Rotates the contents of a register right (toward the 
least-significant bit). This instruction inserts in the sign bit 
any bits that were shifted out of the least-significant bit. The 
contents of src1 specify the value to shift, and the contents of 
src2 (or the immediate value) specify the amount to shift. 
Rotate Right puts the result in the destination register. If src2 
(or the immediate value) is greater than 32, src1 shifts by src2 
MOD 32.LEFT="0" WIDTH="90"Set Equal (SEQ)LEFT="95" WIDTH="243"Compares two 32-bit values. If the contents of src1 equal the 
contents of src2 (or src1 equals the immediate value) this 
instruction sets the destination register to one; otherwise, it 
sets the destination register to zero.LEFT="0" WIDTH="90"Set Greater Than 
(SGT)LEFT="95" WIDTH="243"Compares two signed 32-bit values. If the contents of src1 are 
greater than the contents of src2 (or src1 is greater than the 
immediate value), this instruction sets the destination 
register to one; otherwise, it sets the destination register to 
zero.LEFT="0" WIDTH="90"Set Greater/Equal 
(SGE)LEFT="95" WIDTH="243"Compares two signed 32-bit values. If the contents of src1 are 
greater than or equal to the contents of src2 (or src1 is greater 
than or equal to the immediate value), this instruction sets 
the destination register to one; otherwise, it sets the 
destination register to zero.LEFT="0" WIDTH="90"Set Greater/Equal 
Unsigned (SGEU)LEFT="95" WIDTH="243"Compares two unsigned 32-bit values. If the contents of src1 
are greater than or equal to the contents of src2 (or src1 is 
greater than or equal to the immediate value), this 
instruction sets the destination register to one; otherwise, it 
sets the destination register to zero.LEFT="0" WIDTH="90"Set Greater Than 
Unsigned (SGTU)LEFT="95" WIDTH="243"Compares two unsigned 32-bit values. If the contents of src1 
are greater than the contents of src2 (or src1 is greater than 
the immediate value), this instruction sets the destination 
register to one; otherwise, it sets the destination register to 
zero.LEFT="0" WIDTH="90"Set Less Than (SLT)LEFT="95" WIDTH="243"Compares two signed 32-bit values. If the contents of src1 are 
less than the contents of src2 (or src1 is less than the 
immediate value), this instruction sets the destination 
register to one; otherwise, it sets the destination register to 
zero.LEFT="0" WIDTH="90"Set Less/Equal (SLE)LEFT="95" WIDTH="243"Compares two signed 32-bit values. If the contents of src1 are 
less than or equal to the contents of src2 (or src1 is less than 
or equal to the immediate value), this instruction sets the 
destination register to one; otherwise, it sets the destination 
register to zero.LEFT="0" WIDTH="90"Set Less/Equal 
Unsigned (SLEU)LEFT="95" WIDTH="243"Compares two unsigned 32-bit values. If the contents of src1 
are less than or equal to the contents of src2 (or src1 is less 
than or equal to the immediate value) this instruction sets 
the destination register to one; otherwise, it sets the 
destination register to zero.LEFT="0" WIDTH="90"Set Less Than 
Unsigned (SLTU)LEFT="95" WIDTH="243"Compares two unsigned 32-bit values. If the contents of src1 
are less than the contents of src2 (or src1 is less than the 
immediate value), this instruction sets the destination 
register to one; otherwise, it sets the destination register to 
zero.LEFT="0" WIDTH="90"Set Not Equal (SNE)LEFT="95" WIDTH="243"Compares two 32-bit values. If the contents of scr1 do not 
equal the contents of src2 (or src1 does not equal the 
immediate value), this instruction sets the destination 
register to one; otherwise, it sets the destination register to 
zero.LEFT="0" WIDTH="90"Shift Left Logical 
(SLL)LEFT="95" WIDTH="243"Shifts the contents of a register left (toward the sign bit) and 
inserts zeros at the least-significant bit. The contents of src1 
specify the value to shift, and the contents of src2 or the 
immediate value specify the amount to shift. If src2 (or the 
immediate value) is greater than 31 or less than 0, src1 shifts 
by src2 MOD 32.LEFT="0" WIDTH="90"Shift Right 
Arithmetic (SRA)LEFT="95" WIDTH="243"Shifts the contents of a register right (toward the 
least-significant bit) and inserts the sign bit at the 
most-significant bit. The contents of src1 specify the value to 
shift, and the contents of src2 (or the immediate value) 
specify the amount to shift. If src2 (or the immediate value) 
is greater than 31 or less than 0, src1 shifts by the result of src2 
MOD 32.LEFT="0" WIDTH="90"Shift Right Logical 
(SRL)LEFT="95" WIDTH="243"Shifts the contents of a register right (toward the 
least-significant bit) and inserts zeros at the most-significant 
bit. The contents of src1 specify the value to shift, and the 
contents of src2 (or the immediate value) specify the amount 
to shift. If src2 (or the immediate value) is greater than 31 or 
less than 0, src1 shifts by the result of src2 MOD 32.LEFT="0" WIDTH="90"Subtract with 
Overflow (SUB)LEFT="95" WIDTH="243"Computes the twos-complement difference for two signed 
values. This instruction subtracts the contents of src2 from 
the contents of src1, or it can subtract the contents of the 
immediate from the src1 value. Subtract (with Overflow) 
puts the result in the destination register. When the true 
result's sign differs from the destination register's sign, the 
machine signals an overflow exception.LEFT="0" WIDTH="90"Subtract without 
Overflow (SUBU)LEFT="95" WIDTH="243"Computes the twos-complement difference for two 32-bit 
values. This instruction subtracts the contents of src2 from 
the contents of src1, or it can subtract the contents of the 
immediate from the src1 value. Subtract (without Overflow) 
puts the result in the destination register. Overflow 
exceptions never happen.LEFT="0" WIDTH="90" Trap if Equal (TEQ)LEFT="95" WIDTH="243"Compares two 32-bit values. If the contents of src1 equal the 
contents of src2 (or src1 equals the immediate value), a trap 
exception occurs.LEFT="0" WIDTH="90"Trap if Not Equal 
(TNE)LEFT="95" WIDTH="243"Compares two 32-bit values. If the contents of src1 do not 
equal the contents of src2 (or src1 does not equal the 
immediate value), a trap exception occurs.LEFT="0" WIDTH="90"Trap if Less Than 
(TLT)LEFT="95" WIDTH="243"Compares two signed 32-bit values. If the contents of src1 are 
less than the contents of src2 (or src1 is less than the 
immediate value), a trap exception occurs.LEFT="0" WIDTH="90"Trap if Less Than 
Unsigned (TLTU)LEFT="95" WIDTH="243"Compares two unsigned 32-bit values. If the contents of src1 
are less than the contents of src2 (or src1 is less than the 
immediate value), a trap exception occurs.LEFT="0" WIDTH="90"Trap if Greater than 
or Equal (TGE)LEFT="95" WIDTH="243"Compares two signed 32-bit values. If the contents of src1 are 
greater than the contents of src2 (or src1 is greater than the 
immediate value), a trap exception occurs.LEFT="0" WIDTH="90"Trap if Greater than 
or Equal Unsigned 
(TGEU)LEFT="95" WIDTH="243"Compares two unsigned 32-bit values. If the contents of src1 
are greater than the contents of src2 (or src1 is greater than 
the immediate value), a trap exception occurs.COLUMNS="2"LBL="5-8"Table 5-8 ID="45575"Computational Instruction Descriptions for MIPS3/4 Architecture LEFT="0" WIDTH="90"Instruction NameLEFT="95" WIDTH="243"DescriptionLEFT="0" WIDTH="90"Doubleword 
Absolute Value 
(DABS)LEFT="95" WIDTH="243"Computes the absolute value of the contents of src1, treated 
as a 64-bit signed value, and puts the result in the 
destination register. If the value in src1 is -2**63, the machine 
signals an overflow exception.LEFT="0" WIDTH="90"Doubleword Add 
with Overflow 
(DADD)LEFT="95" WIDTH="243"Computes the twos-complement sum of two 64-bit signed 
values. The instruction adds the contents of src1 to the 
contents of src2, or it can add the contents of src1 to the 
immediate value. When the result cannot be extended as a 
64-bit number, the system signals an overflow exception.LEFT="0" WIDTH="90"Doubleword Add 
without Overflow 
(DADDU)LEFT="95" WIDTH="243"Computes the twos-complement sum of two 64-bit values. 
The instruction adds the contents of src1 to the contents of 
src2, or it can add the contents of src1 to the immediate value. 
Overflow exceptions never occur.LEFT="0" WIDTH="90"Doubleword Divide 
Signed (DDIV)LEFT="95" WIDTH="243"Computes the quotient of two 64-bit values. DDIV treats src1 
as the dividend. The divisor can be src2 or the immediate 
value. It puts the quotient in the destination register. If the 
divisor is zero, the system signals an error and may issue a 
BREAK instruction. The DDIV instruction rounds towards 
zero. Overflow is signaled when dividing -2**63 by -1. Note: The special case DDIV $0,src1,src2 generates the real 
doubleword divide instruction and leaves the result in the 
HI/LO register. The HI register contains the quotient. No 
checking for divide-by-zero is performed.LEFT="0" WIDTH="90"Doubleword Divide 
Unsigned (DDIVU)LEFT="95" WIDTH="243"Computes the quotient of two unsigned 64-bit values. 
DDIVU treats src1 as the dividend. The divisor can be src2 or 
the immediate value. It puts the quotient in the destination 
register. If the divisor is zero, the system signals an exception 
and may issue a BREAK instruction. See note for DDIV 
concerning $0 as a destination. Overflow exceptions never 
occur.LEFT="0" WIDTH="90"Doubleword 
Multiply (DMUL)LEFT="95" WIDTH="243"Computes the product of two values. This instruction puts 
the 64-bit product of src1 and src2, or the 64-bit product of 
src1 and the immediate value, in the destination 
register.Overflow is not reported. Note: Use DMUL when you do not need overflow 
protection. It is often faster than DMULO and DMULOU. 
For multiplication by a constant, the DMUL instruction 
produces faster machine instruction sequences than 
DMULT or DMULTU can produce.LEFT="0" WIDTH="90"Doubleword 
Multiply (DMULT)LEFT="95" WIDTH="243"Computes the 128-bit product of two 64-bit signed values. 
This instruction multiplies the contents of src1 by the 
contents of src2 and puts the result in the HI and LO 
registers. No overflow is possible. Note: The DMULT 
instruction is a real machine language instruction.LEFT="0" WIDTH="90"Doubleword 
Multiply Unsigned 
(DMULTU)LEFT="95" WIDTH="243"Computes the product of two unsigned 64-bit values. It 
multiplies the contents of src1 and the contents of src2, 
putting the result in the HI and LO registers. No overflow is 
possible. Note: The DMULTU instruction is a real machine language 
instruction.LEFT="0" WIDTH="90"Doubleword 
Multiply with 
Overflow (DMULO)LEFT="95" WIDTH="243"Computes the product of two 64-bit signed values. It puts 
the 64-bit product of src1 and src2, or the 64-bit product of 
src1 and the immediate value, in the destination register. 
When an overflow occurs, the system signals an overflow 
exception and may execute a BREAK instruction. Note: For multiplication by a constant, DMULO produces 
faster machine instruction sequences than DMULT or 
DMULTU can produce; however, if you do not need 
overflow detection, use the DMUL instruction. It is often 
faster than DMULO.LEFT="0" WIDTH="90"Doubleword 
Multiply with 
Overflow Unsigned 
(DMULOU)LEFT="95" WIDTH="243"Computes the product of two 64-bit unsigned values. It puts 
the 64-bit product of src1 and src2, or the 64-bit product of 
src1 and the immediate value, into the destination register. 
When an overflow occurs, the system signals an overflow 
exception and may issue a BREAK instruction. Note: For multiplication by a constant, DMULOU produces 
faster machine instruction sequences than DMULT or 
DMULTU produces; however, if you do not need overflow 
detection, use the DMUL instruction. It is often faster than 
DMULOU.LEFT="0" WIDTH="90"Doubleword Negate 
with Overflow 
(DNEG)LEFT="95" WIDTH="243"Computes the negative of a 64-bit value. The instruction 
negates the contents of src1 and puts the result in the 
destination register. If the value of src1 is -2**63, the system 
signals an overflow exception.LEFT="0" WIDTH="90"Doubleword Negate 
without Overflow 
(DNEGU)LEFT="95" WIDTH="243"Negates the 64-bit contents of src1 and puts the result in the 
destination register. Overflow is not reported.LEFT="0" WIDTH="90"Doubleword 
Remainder Signed 
(DREM)LEFT="95" WIDTH="243"Computes the remainder of the division of two signed 64-bit 
values. It treats src1 as the dividend. The divisor can be src2 
or the immediate value. The DREMU instruction puts the 
remainder in the destination register. If the divisor is zero, 
the system signals an error and may issue a BREAK 
instruction.LEFT="0" WIDTH="90"Doubleword 
Remainder 
Unsigned (DREMU)LEFT="95" WIDTH="243"Computes the remainder of the division of two unsigned 
64-bit values. It treats src1 as the dividend. The divisor can 
be src2 or the immediate value. The DREMU instruction 
puts the remainder in the destination register. If the divisor 
is zero, the system signals an error and may issue a BREAK 
instruction.LEFT="0" WIDTH="90"Doubleword Rotate 
Left (DROL)LEFT="95" WIDTH="243"Rotates the contents of a 64-bit register left (towards the sign 
bit). This instruction inserts in the least-significant bit any 
bits that were shifted out of the sign bit. The contents of src1 
specify the value to shift, and contents of src2 (or the 
immediate value) specify the amount to shift. If src2 (or the 
immediate value) is greater than 63, src1 shifts by src2 MOD 
64.LEFT="0" WIDTH="90"Doubleword Rotate 
Right (DROR)LEFT="95" WIDTH="243"Rotates the contents of a 63-bit register right (towards the 
least-significant bit). This instruction inserts in the sign bit 
any bits that were shifted out of the least-significant bit. The 
contents of src1 specify the value to shift, and the contents of 
src2 (or the immediate value) specify the amount to shift. If 
src2 (or the immediate value is greater than 63, src1 shifts by 
src2 MOD 64.LEFT="0" WIDTH="90"Doubleword Shift 
Left Logical (DSLL)LEFT="95" WIDTH="243"Shifts the contents of a 64-bit register left (towards the sign 
bit) and inserts zeros at the least-significant bit. The contents 
of src1 specify the value to shift, and the contents of src2 (or 
the immediate value) specify the amount to shift. If src2 (or 
the immediate value) is greater than 63, src1 shifts by src2 
MOD 64.LEFT="0" WIDTH="90"Doubleword Shift 
Right Arithmetic 
(DSRA)LEFT="95" WIDTH="243"Shifts the contents of a 64-bit register right (towards the 
least-significant bit) and inserts the sign bit at the 
most-significant bit. The contents of src2 (or the immediate 
value) specify the amount to shift. If src2 (or the immediate 
value) is greater than 63, src1 shifts by src2 MOD 64.LEFT="0" WIDTH="90"Doubleword Shift 
Right Logical (DSRL)LEFT="95" WIDTH="243"Shifts the contents of a 64-bit register right (towards the 
least-significant bit) and inserts zeros at the most-significant 
bit. The contents of src1 specify the value to shift, and the 
contents of src2 (or the immediate value) specify the amount 
to shift. If src2 (or the immediate value) is greater than 63, 
src1 shifts by src2 MOD 64.LEFT="0" WIDTH="90"Doubleword 
Subtract with 
Overflow (DSUB)LEFT="95" WIDTH="243"Computes the twos-complement difference for two signed 
64-bit values. This instruction subtracts the contents of src2 
from the contents of src1, or it can subtract the immediate 
value from the contents of src1. It puts the result in the 
destination register. When the true result's sign differs from 
the destination register's sign, the system signals an 
overflow exception.LEFT="0" WIDTH="90"Doubleword 
Subtract without 
Overflow (DSUBU)LEFT="95" WIDTH="243"Computes the twos complement difference for two 
unsigned 64-bit values. This instruction subtracts the 
contents of src2 from the contents of src1, or it can subtract 
the immediate value from the contents of src1. It puts the 
result in the destination register.  Overflow exceptions never 
happen.LBL="" HELPID=""Jump and Branch InstructionsID="05.instruct24"ID="05.instruct25"The jump and branch instructions let you change an assembly program's control flow. This section of the book describes jump and branch instructions.LBL="" HELPID=""Jump and Branch InstructionsID="05.instruct26"Jump and branch instructions change the flow of a program. IDREF="76462" TYPE="TABLE"Table 5-9 summarizes the formats of jump and branch instructions.COLUMNS="3"LBL="5-9"Table 5-9 ID="76462"Jump and Branch Format SummaryLEFT="0" WIDTH="180"DescriptionLEFT="185" WIDTH="54"Op-codeLEFT="245" WIDTH="99"OperandLEFT="0" WIDTH="180"JumpLEFT="185" WIDTH="54"JLEFT="245" WIDTH="99"addressLEFT="0" WIDTH="180"Jump and LinkLEFT="185" WIDTH="54"JALLEFT="245" WIDTH="99"addresstarget return,targetLEFT="0" WIDTH="180"Branch on EqualLEFT="185" WIDTH="54"BEQLEFT="245" WIDTH="99"src1,src2,labelLEFT="0" WIDTH="180"Branch on GreaterLEFT="185" WIDTH="54"BGTLEFT="245" WIDTH="99"src1,immediate,labelLEFT="0" WIDTH="180"Branch on Greater/EqualLEFT="185" WIDTH="54"BGELEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Greater/Equal UnsignedLEFT="185" WIDTH="54"BGEULEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Greater Than UnsignedLEFT="185" WIDTH="54"BGTULEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Less ThanLEFT="185" WIDTH="54"BLTLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Less/EqualLEFT="185" WIDTH="54"BLELEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Less/Equal UnsignedLEFT="185" WIDTH="54"BLEULEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Less Than UnsignedLEFT="185" WIDTH="54"BLTULEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Not EqualLEFT="185" WIDTH="54"BNELEFT="245" WIDTH="99"LEFT="0" WIDTH="180"BranchLEFT="185" WIDTH="54"BLEFT="245" WIDTH="99"labelLEFT="0" WIDTH="180"Branch and LinkLEFT="185" WIDTH="54"BALLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Equal Likely*LEFT="185" WIDTH="54"BEQLLEFT="245" WIDTH="99"src1,src2,labelLEFT="0" WIDTH="180"Branch on Greater Than Likely*LEFT="185" WIDTH="54"BGTLLEFT="245" WIDTH="99"src1, immediate,labelLEFT="0" WIDTH="180"Branch on Greater/Equal Likely *LEFT="185" WIDTH="54"BGELLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Greater/Equal Unsigned Likely*LEFT="185" WIDTH="54"BGEULLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Greater Than Unsigned Likely*LEFT="185" WIDTH="54"BGTULLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Less Than Likely*LEFT="185" WIDTH="54"BLTLLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Less/Equal Likely *LEFT="185" WIDTH="54"BLELLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Less/Equal Unsigned Likely*LEFT="185" WIDTH="54"BLEULLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Less Than Unsigned Likely*LEFT="185" WIDTH="54"BLTULLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Not Equal Likely*LEFT="185" WIDTH="54"BNELLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Equal to ZeroLEFT="185" WIDTH="54"BEQZLEFT="245" WIDTH="99"src1,labelLEFT="0" WIDTH="180"Branch on Greater/Equal ZeroLEFT="185" WIDTH="54"BGEZLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Greater Than ZeroLEFT="185" WIDTH="54"BGTZLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Greater or Equal to Zero and LinkLEFT="185" WIDTH="54"BGEZALLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Less Than Zero and LinkLEFT="185" WIDTH="54"BLTZALLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Less/Equal ZeroLEFT="185" WIDTH="54"BLEZLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Less Than ZeroLEFT="185" WIDTH="54"BLTZLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Not Equal to ZeroLEFT="185" WIDTH="54"BNEZLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Equal to Zero Likely*LEFT="185" WIDTH="54"BEQZLLEFT="245" WIDTH="99"src1,labelLEFT="0" WIDTH="180"Branch on Greater/Equal Zero Likely*LEFT="185" WIDTH="54"BGEZLLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Greater Than Zero Likely*LEFT="185" WIDTH="54"BGTZLLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Greater or Equal to Zero and Link 
Likely*LEFT="185" WIDTH="54"BGEZALLLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Less Than Zero and Link Likely*LEFT="185" WIDTH="54"BLTZALLLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Less/Equal Zero Likely*LEFT="185" WIDTH="54"BLEZLLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Less Than Zero Likely*LEFT="185" WIDTH="54"BLTZLLEFT="245" WIDTH="99"LEFT="0" WIDTH="180"Branch on Not Equal to Zero Likely*LEFT="185" WIDTH="54"BNEZLLEFT="245" WIDTH="99"LEFT="0" WIDTH="54"LEFT="60" WIDTH="99"LBL="a" ID="05.instructTF10a"* Not valid inMIPS1 architecture.LBL="" HELPID=""Jump and Branch Instruction DescriptionsID="05.instruct27"In IDREF="11621" TYPE="TABLE"Table 5-10  branch instructions, branch destinations must be defined in the source being assembled.COLUMNS="2"LBL="5-10"Table 5-10 ID="11621"Jump and Branch Instruction DescriptionsLEFT="0" WIDTH="83"Instruction NameLEFT="90" WIDTH="249"DescriptionLEFT="0" WIDTH="83"Branch (B)LEFT="90" WIDTH="249"Branches unconditionally to the specified label.LEFT="0" WIDTH="83"Branch and Link 
(BAL)LEFT="90" WIDTH="249"Branches unconditionally to the specified label and puts the 
return address in general register $31.LEFT="0" WIDTH="83"Branch on Equal 
(BEQ)LEFT="90" WIDTH="249"Branches to the specified label when the contents of src1 equal 
the contents of src2, or when the contents of src1 equal the 
immediate value.LEFT="0" WIDTH="83"Branch on Equal to 
Zero (BEQZ)LEFT="90" WIDTH="249"Branches to the specified label when the contents of src1 equal 
zero.LEFT="0" WIDTH="83"Branch on Greater 
Than (BGT)LEFT="90" WIDTH="249"Branches to the specified label when the contents of src1 are 
greater than the contents of src2, or it can branch when the 
contents of src1 are greater than the immediate value. The 
comparison treats the comparands as signed 32-bit values.LEFT="0" WIDTH="83"Branch on 
Greater/Equal 
Unsigned (BGEU)LEFT="90" WIDTH="249"Branches to the specified label when the contents of src1 are 
greater than or equal to the contents of src2, or it can branch 
when the contents of src1 are greater than or equal to the 
immediate value. The comparison treats the comparands as 
unsigned 32-bit values.LEFT="0" WIDTH="83"Branch on 
Greater/Equal 
Zero (BGEZ)LEFT="90" WIDTH="249"Branches to the specified label when the contents of src1 are 
greater than or equal to zero.LEFT="0" WIDTH="83"Branch on 
Greater/Equal 
Zero and Link 
(BGEZAL)LEFT="90" WIDTH="249"Branches to the specified label when the contents of src1 are 
greater than or equal to zero and puts the return address in 
general register $31. When this write is done, it destroys the 
contents of the register. See the MIPS Microprocessor User's 
Manual appropriate to your architecture for more information. 
Do not use BGEZAL $31.LEFT="0" WIDTH="83"Branch on Greater 
or Equal (BGE)LEFT="90" WIDTH="249"Branches to the specified label when the contents of src1 are 
greater than or equal to the contents of src2, or it can branch 
when the contents of src1 are greater than or equal to the 
immediate value. The comparison treats the comparands as 
signed 32-bit values.LEFT="0" WIDTH="83"Branch on Greater 
Than Unsigned 
(BGTU)LEFT="90" WIDTH="249"Branches to the specified label when the contents of src1 are 
greater than the contents of src2, or it can branch when the 
contents of src1 are greater than the immediate value. The 
comparison treats the comparands as unsigned 32-bit values.LEFT="0" WIDTH="83"Branch on Greater 
Than Zero (BGTZ)LEFT="90" WIDTH="249"Branches to the specified label when the contents of src1 are 
greater than zero.LEFT="0" WIDTH="83"Branch on Less 
Than Zero (BLTZ)LEFT="90" WIDTH="249"Branches to the specified label when the contents of src1 are 
less than zero. The program must define the destination.LEFT="0" WIDTH="83"Branch on Less 
Than (BLT)LEFT="90" WIDTH="249"Branches to the specified label when the contents of src1 are 
less than the contents of src2, or it can branch when the 
contents of src1 are less than the immediate value. The 
comparison treats the comparands as signed 32-bit values.LEFT="0" WIDTH="83"Branch on 
Less/Equal 
Unsigned (BLEU)LEFT="90" WIDTH="249"Branches to the specified label when the contents of src1 are 
less than or equal to the contents of src2, or it can branch when 
the contents of src1 are less than or equal to the immediate 
value. The comparison treats the comparands as unsigned 
32-bit values.LEFT="0" WIDTH="83"Branch on 
Less/Equal Zero 
(BLEZ)LEFT="90" WIDTH="249"Branches to the specified label when the contents of src1 are 
less than or equal to zero. The program must define the 
destination.LEFT="0" WIDTH="83"Branch on Less or 
Equal (BLE)LEFT="90" WIDTH="249"Branches to the specified label when the contents of src1 are 
less than or equal to the contents of src2, or it can branch when 
the contents of src1 are less than or equal to the immediate 
value. The comparison treats the comparands as signed 32-bit 
values.LEFT="0" WIDTH="83"Branch on Less 
Than Unsigned 
(BLTU)LEFT="90" WIDTH="249"Branches to the specified label when the contents of src1 are 
less than the contents of src2, or it can branch when the 
contents of src1 are less than the immediate value. The 
comparison treats the comparands as unsigned 32-bit values.LEFT="0" WIDTH="83"Branch on Less 
Than Zero and 
Link (BLTZAL)LEFT="90" WIDTH="249"Branches to the specified label when the contents of src1 are 
less than zero and puts the return address in general register 
$31. Because the value is always stored in register 31, there is 
a chance of a stored value being overwritten before it is used. 
See the MIPS microprocessor user's manual appropriate to 
your architecture for more information. Do not use BGEZAL 
$31LEFT="0" WIDTH="83"Branch on Not 
Equal (BNE)LEFT="90" WIDTH="249"Branches to the specified label when the contents of src1 do 
not equal the contents of src2, or it can branch when the 
contents of src1 do not equal the immediate value.LEFT="0" WIDTH="83"Branch on Not 
Equal to Zero 
(BNEZ)LEFT="90" WIDTH="249"Branches to the specified label when the contents of src1 do 
not equal zero. LEFT="0" WIDTH="83"Jump (J)LEFT="90" WIDTH="249"Unconditionally jumps to a specified location. A symbolic 
address or a general register specifies the destination. The 
instruction J $31 returns from a JAL call instruction.LEFT="0" WIDTH="83"Jump And Link 
(JAL)LEFT="90" WIDTH="249"Unconditionally jumps to a specified location and puts the 
return address in a general register.  A symbolic address or a 
general register specifies the target location. By default, the 
return address is placed in register $31. If you specify a pair of 
registers, the first receives the return address and the second 
specifies the target. The instruction JAL procname transfers to 
procname and saves the return address. For the two-register 
form of the instruction, the target register may not be the same 
as the return-address register. For the one-register form, the 
target may not be $31.LEFT="0" WIDTH="83"Branch Likely 
InstructionsLEFT="90" WIDTH="249"Same an the ordinary branch instruction (without the 
"Likely"), except in a branch likely instruction, the instruction 
in the delay slot is nullified if the conditional branch is not 
taken.Note: The branch likely instructions should be used only 
inside a .set noreorder schedule in an assembly program. The 
assembler does not attempt to schedule the delay slot of a 
branch likely instruction.LBL="" HELPID=""Special Instructions ID="05.instruct28"ID="05.instruct29"The main processor's special instructions  do miscellaneous tasks. See ID="05.instruct30"IDREF="81460" TYPE="TABLE"Table 5-11.LBL="" HELPID=""Special Instruction DescriptionsCOLUMNS="2"LBL="5-11"Table 5-11 ID="81460"Special Instruction DescriptionsLEFT="0" WIDTH="90"Instruction NameLEFT="95" WIDTH="243"DescriptionLEFT="0" WIDTH="90"Break (BREAK)LEFT="95" WIDTH="243"Unconditionally transfers control to the exception handler. 
The breakcode operand is interpreted by software 
conventions. The breakcode1 operand is used to fill the 
low-order 10 bits of the 20-bit immediate field in the BREAK 
instruction. The optional second operand, breakcode2, fills 
the high-order 10 bits.LEFT="0" WIDTH="90"Exception Return 
(ERET)LEFT="95" WIDTH="243"Returns from an interrupt, exception or error trap. Similar to 
a branch or jump instruction, ERET executes the next 
instruction before taking effect. Use this on R4000 processor 
machines in place of RFE.LEFT="0" WIDTH="90"Move From HI 
Register (MFHI)LEFT="95" WIDTH="243"Moves the contents of the HI register to a general-purpose 
register.LEFT="0" WIDTH="90"Move From LO 
Register (MFLO)LEFT="95" WIDTH="243"Moves the contents of the LO register to a general-purpose 
register.LEFT="0" WIDTH="90"Move To HI Register 
(MTHI)LEFT="95" WIDTH="243"Moves the contents of a general-purpose register to the HI 
register.LEFT="0" WIDTH="90"Move To LO Register 
(MTLO)LEFT="95" WIDTH="243"Moves the contents of a general-purpose register to the LO 
register.LEFT="0" WIDTH="90"Restore From 
Exception (RFE)LEFT="95" WIDTH="243"Restores the previous interrupt called and user/kernel state. 
This instruction can execute only in kernel state and is 
unavailable in user mode.LEFT="0" WIDTH="90"Syscall (SYSCALL)LEFT="95" WIDTH="243"Causes a system call trap. The operating system interprets 
the information set in registers to determine what system 
call to do.LBL="" HELPID=""Coprocessor Interface InstructionsID="05.instruct31"ID="05.instruct32"The coprocessor interface instructions provide standard ways to access your machine's coprocessors. See ID="05.instruct33"IDREF="97888" TYPE="TABLE"Table 5-12 and IDREF="17151" TYPE="TABLE"Table 5-13.LBL="" HELPID=""Coprocessor Interface SummaryID="05.instruct34"COLUMNS="3"LBL="5-12"Table 5-12 ID="97888"Coprocessor Interface FormatsLEFT="0" WIDTH="178"DescriptionLEFT="185" WIDTH="61"Op-codeLEFT="255" WIDTH="95"OperandLEFT="0" WIDTH="178"Load Word Coprocessor zLEFT="185" WIDTH="61"LWCzLEFT="255" WIDTH="95"dest-copr,addressLEFT="0" WIDTH="178"Load Double Coprocessor z*LEFT="185" WIDTH="61"LDCzLEFT="255" WIDTH="95"LEFT="0" WIDTH="178"Store Word Coprocessor zLEFT="185" WIDTH="61"SWCzLEFT="255" WIDTH="95"src-copr, addressLEFT="0" WIDTH="178"Store Double Coprocessor z*LEFT="185" WIDTH="61"SDCzLEFT="255" WIDTH="95"LEFT="0" WIDTH="178"Move From Coprocessor zLEFT="185" WIDTH="61"MFCzLEFT="255" WIDTH="95"dest-gpr, sourceLEFT="0" WIDTH="178"Move To Coprocessor zLEFT="185" WIDTH="61"MTCzLEFT="255" WIDTH="95"src-gpr, destinationLEFT="0" WIDTH="178"Doubleword Move From Coprocessor z **LEFT="185" WIDTH="61"DMFCzLEFT="255" WIDTH="95"LEFT="0" WIDTH="178"Doubleword Move To Coprocessor z **LEFT="185" WIDTH="61"DMTCzLEFT="255" WIDTH="95"LEFT="0" WIDTH="178"Branch Coprocessor z FalseLEFT="185" WIDTH="61"BCzFLEFT="255" WIDTH="95"labelLEFT="0" WIDTH="178"Branch Coprocessor z TrueLEFT="185" WIDTH="61"BCzTLEFT="255" WIDTH="95"LEFT="0" WIDTH="178"Branch Coprocessor z False Likely*LEFT="185" WIDTH="61"BCzFLLEFT="255" WIDTH="95"LEFT="0" WIDTH="178"Branch Coprocessor z True Likely*LEFT="185" WIDTH="61"BCzTLLEFT="255" WIDTH="95"LEFT="0" WIDTH="178"Coprocessor z OperationLEFT="185" WIDTH="61"CzLEFT="255" WIDTH="95"expressionLEFT="0" WIDTH="178"Control From Coprocessor zLEFT="185" WIDTH="61"CFCzLEFT="255" WIDTH="95"dest-gpr, sourceLEFT="0" WIDTH="178"Control To Coprocessor zLEFT="185" WIDTH="61"CTCzLEFT="255" WIDTH="95"src-gpr, destinationLEFT="0" WIDTH="61"LEFT="70" WIDTH="95"LBL="a" ID="05.instructTF13a"* Not valid in MIPS1 architectures.LBL="b" ID="05.instructTF13b"** Not valid in MIPS1 and MIPS2 architectures.NoteYou cannot use coprocessor load and store instructions with the system control coprocessor (cp0). LBL="" HELPID=""Coprocessor Interface Instruction Descriptions ID="05.instruct35"ID="05.instruct36"COLUMNS="2"LBL="5-13"Table 5-13 ID="17151"Coprocessor Interface Instruction DescriptionsLEFT="0" WIDTH="90"Instruction NameLEFT="95" WIDTH="243"DescriptionLEFT="0" WIDTH="90"Branch Coprocessor 
z True (BCzT)LEFT="95" WIDTH="243"Branches to the specified label when the specified 
coprocessor asserts a true condition. The z selects one of the 
coprocessors. A previous coprocessor operation sets the 
condition.LEFT="0" WIDTH="90"Branch Coprocessor 
z False (BCzF)LEFT="95" WIDTH="243"Branches to the specified label when the specified 
coprocessor asserts a false condition. The z selects one of the 
coprocessors. A previous coprocessor operation sets the 
condition.LEFT="0" WIDTH="90"Branch Coprocessor 
z True Likely 
(BCzTL)LEFT="95" WIDTH="243"Branches to the specified label when the specified 
coprocessor asserts a true condition. If the conditional 
branch is not taken, the instruction in the branch delay slot 
is nullified. Note: The branch likely instructions should be used only 
within a .set noreorder block. The assembler does not attempt 
to schedule the delay slot of a branch likely instruction.LEFT="0" WIDTH="90"Branch Coprocessor 
z False Likely 
(BCzFL)LEFT="95" WIDTH="243"Branches to the specified label when the specified 
coprocessor asserts a false condition. If the conditional 
branch is not taken, the instruction in the branch delay slot 
is nullified. Note: The branch likely instructions should be used only 
within a .set noreorder block. The assembler does not attempt 
to schedule the delay slot of a branch likely instruction.LEFT="0" WIDTH="90"Control From 
Coprocessor z 
(CFCz)LEFT="95" WIDTH="243"Stores the contents of the coprocessor control register 
specified by the source in the general register specified by 
dest-gpr.LEFT="0" WIDTH="90"Control To 
Coprocessor (CTCz)LEFT="95" WIDTH="243"Stores the contents of the general register specified by 
src-gpr in the coprocessor control register specified by the 
destination.LEFT="0" WIDTH="90"Coprocessor z Operation (Cz)LEFT="95" WIDTH="243"Executes a coprocessor-specific operation on the specified 
coprocessor. The z selects one of four distinct coprocessors.LEFT="0" WIDTH="90"Load Word 
Coprocessor z 
(LWCz)LEFT="95" WIDTH="243"Loads the destination with the contents of a word that is at 
the memory location specified by the effective address. The 
z selects one of four distinct coprocessors. Load Word 
Coprocessor replaces all register bytes with the contents of 
the loaded word. If bits 0 and 1 of the effective address are 
not zero, the machine signals an address exception.LEFT="0" WIDTH="90"Load Double 
Coprocessor z 
(LDCz)LEFT="95" WIDTH="243"Loads a doubleword from the memory location specified by 
the effective address and makes the data available to 
coprocessor unit z. The manner in which each coprocessor 
uses the data is defined by the individual coprocessor 
specifications. This instruction is not valid in MIPS1 
architectures. If any of the three least-significant bits of the 
effective address are non-zero, the machine signals an 
address error exception.LEFT="0" WIDTH="90"Move From 
Coprocessor z (MFCz)LEFT="95" WIDTH="243"Stores the contents of the coprocessor register specified by 
the source in the general register specified by dest-gpr.LEFT="0" WIDTH="90"Move To 
Coprocessor z 
(MTCz)LEFT="95" WIDTH="243"Stores the contents of the general register specified by src-gpr 
in the coprocessor register specified by the destination.LEFT="0" WIDTH="90"Doubleword Move 
From Coprocessor z (DMFCz)LEFT="95" WIDTH="243"Stores the 64-bit contents of the coprocessor register 
specified by the source into the general register specified by 
dest-gpr.LEFT="0" WIDTH="90"Doubleword Move 
To Coprocessor z (DMTCz)LEFT="95" WIDTH="243"Stores the 64-bit contents of the general register src-gpr into 
the coprocessor register specified by the destination.LEFT="0" WIDTH="90"Store Word 
Coprocessor z 
(SWCz)LEFT="95" WIDTH="243"Stores the contents of the coprocessor register in the memory 
location specified by the effective address. The z selects one 
of four distinct coprocessors. If bits 0 and 1 of the effective 
address are not zero, the machine signals an address error 
exception.LEFT="0" WIDTH="90"Store Double 
Coprocessor z 
(SDCz)LEFT="95" WIDTH="243"Coprocessor z sources a doubleword, which the processor 
writes the memory location specified by the effective 
address. The data to be stored is defined by the individual 
coprocessor specifications. This instruction is not valid in 
MIPS1 architecture. If any of the three least-significant bits of 
the effective address are non-zero, the machine signals an 
address error exception.LBL="6"Coprocessor Instruction Set ID="06.coproc1"ID="06.coproc2"This chapter describes the coprocessor instructions for these coprocessors: System control coprocessor (cp0) instructionsFloating-point coprocessor instructionsSee Chapter 5 for a description of the main processor's instructions and the coprocessor interface instructions.LBL="" HELPID=""Instruction NotationID="06.coproc3"The tables in this chapter list the assembler format for each coprocessor's load, store, computational, jump, branch, and special instructions. The format consists of an op-code and a list of operand formats. The tables list groups of closely related instructions; for those instructions, you can use any op-code with any specified operand.NoteThe system control coprocessor instructions do not have operands. Operands can have any of these formats: Memory references: for example, a relocatable symbol +/­ an expression(register)Expressions (for immediate values)Two or three operands: for example, ADD $3,$4 is the same as ADD $3,$3,$4The following terms are used to discuss floating-point operations: infinite: A value of +1 or ­1.infinity: A symbolic entity that represents values with magnitudes greater than the largest value in that format.ordered: The usual result from a comparison, namely: <,=, or >.NaN: Symbolic entities that represent values not otherwise available in floating-point formats. There are two kinds of NaNs. Quiet NaNs represent unknown or uninitialized values. Signaling NaNs represent symbolic values and values that are too big or too precise for the format. Signaling NaNs raise an invalid operation exception whenever an operation is attempted on them.unordered: The condition that results from a floating-point comparison when one or both operands are NaNs.LBL="" HELPID=""ID="57865"Floating-Point InstructionsID="06.coproc4"ID="06.coproc5"The floating-point coprocessor has these classes of instructions: Load and Store Instructions: Load values and move data between memory and coprocessor registers.Move Instructions: Move data between registers.Computational Instructions: Do arithmetic and logical operations on values in coprocessor registers.Relational Instructions: Compare two floating-point values.A particular floating-point instruction may be implemented in hardware, software, or a combination of hardware and software.LBL="" HELPID=""Floating-Point FormatsID="06.coproc6"The formats for the single- and double-precision floating-point constants are shown in IDREF="98557" TYPE="GRAPHIC"Figure 6-1:FILE="Floating.Point.Formats.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-1"Figure 6-1 ID="98557"Floating Point FormatsLBL="" HELPID=""Floating-Point Load and Store FormatsID="06.coproc7"ID="06.coproc8"Floating-point load and store instructions must use even registers. The operands in IDREF="21180" TYPE="TABLE"Table 6-1 have the following meanings:COLUMNS="2"LEFT="0" WIDTH="98"OperandLEFT="105" WIDTH="235"MeaningLEFT="0" WIDTH="98"addressLEFT="105" WIDTH="235"Offset (base)LEFT="0" WIDTH="98"destinationLEFT="105" WIDTH="235"Destination registerLEFT="0" WIDTH="98"sourceLEFT="105" WIDTH="235"Source registerCOLUMNS="3"LEFT="0" WIDTH="99"DescriptionLEFT="105" WIDTH="54"Op-codeLEFT="165" WIDTH="180"OperandLEFT="0" WIDTH="99"Load FpLEFT="105" WIDTH="54"LEFT="165" WIDTH="180"LEFT="0" WIDTH="99"DoubleLEFT="105" WIDTH="54"L.DLEFT="165" WIDTH="180"destination, addressLEFT="0" WIDTH="99"SingleLEFT="105" WIDTH="54"L.SLEFT="165" WIDTH="180"LEFT="0" WIDTH="99"Load Indexed FpLEFT="105" WIDTH="54"LEFT="165" WIDTH="180"LEFT="0" WIDTH="99"DoubleLEFT="105" WIDTH="54"LDXC1LEFT="165" WIDTH="180"destination, index(base)LEFT="0" WIDTH="99"SingleLEFT="105" WIDTH="54"LWXC1LEFT="165" WIDTH="180"LEFT="0" WIDTH="99"Load Immediate FpLEFT="105" WIDTH="54"LEFT="165" WIDTH="180"LEFT="0" WIDTH="99"DoubleLEFT="105" WIDTH="54"LI.DLEFT="165" WIDTH="180"destination, floating-point constantLEFT="0" WIDTH="99"SingleLEFT="105" WIDTH="54"LI.SLEFT="165" WIDTH="180"LEFT="0" WIDTH="99"Store FpLEFT="105" WIDTH="54"LEFT="165" WIDTH="180"LEFT="0" WIDTH="99"DoubleLEFT="105" WIDTH="54"S.DLEFT="165" WIDTH="180"source, addressLEFT="0" WIDTH="99"SingleLEFT="105" WIDTH="54"S.SLEFT="165" WIDTH="180"LEFT="0" WIDTH="99"Store  Indexed FpLEFT="105" WIDTH="54"LEFT="165" WIDTH="180"LEFT="0" WIDTH="99"DoubleLEFT="105" WIDTH="54"SDXC1LEFT="165" WIDTH="180"destination, index(base)LEFT="0" WIDTH="99"SingleLEFT="105" WIDTH="54"SWXC1LEFT="165" WIDTH="180"LBL="" HELPID=""Floating-Point Load and Store DescriptionsThis part of Chapter 6 groups the instructions by function. Please consult IDREF="57865" TYPE="TITLE""Floating-Point Instructions" for the op-codes. IDREF="21180" TYPE="TABLE"Table 6-1 describes the floating-point Load and Store instructions.COLUMNS="2"LBL="6-1"Table 6-1 ID="21180"Floating-Point Load and Store DescriptionsLEFT="0" WIDTH="99"InstructionLEFT="105" WIDTH="234"DescriptionLEFT="0" WIDTH="99"Load Fp InstructionsLEFT="105" WIDTH="234"Load eight bytes for double-precision and four bytes for 
single-precision from the specified effective address into 
the destination register, which must be an even register 
(32-bit only) . The  bytes must be word aligned. Note: We 
recommend that you use doubleword alignment for 
double-precision operands. It is required in the MIPS2 
architecture (R4000 and later).LEFT="0" WIDTH="99"Load Indexed Fp 
InstructionsLEFT="105" WIDTH="234"Indexed loads follow the same description as the load 
instructions above except that indexed loads use 
index+base to specify the effective address (64-bit only).LEFT="0" WIDTH="99"Store Fp InstructionsLEFT="105" WIDTH="234"Stores eight bytes for double-precision and four bytes for 
single-precision from the source floating-point register in 
the destination register, which must be an even register 
(32-bit only). Note: We recommend that you use 
doubleword alignment for double-precision operands. It 
is required in the MIPS2 architecture  and later.LEFT="0" WIDTH="99"Store Indexed Fp 
InstructionsLEFT="105" WIDTH="234"Indexed stores follow the same description as the store 
instructions above except that indexed stores use 
index+base to specify the effective address (64-bit only).LBL="" HELPID=""Floating-Point Computational FormatsID="06.coproc9"This part of Chapter 6 describes floating-point computational instructions. The operands in IDREF="11463" TYPE="TABLE"Table 6-3 and IDREF="77592" TYPE="TABLE"Table 6-4 have the following meaning:COLUMNS="2"LEFT="0" WIDTH="140"OperandLEFT="145" WIDTH="191"MeaningLEFT="0" WIDTH="140"destinationLEFT="145" WIDTH="191"Destination registerLEFT="0" WIDTH="140"gprLEFT="145" WIDTH="191"General-purpose registerLEFT="0" WIDTH="140"sourceLEFT="145" WIDTH="191"Source registerCOLUMNS="3"LEFT="0" WIDTH="141"DescriptionLEFT="150" WIDTH="72"Op-codeLEFT="230" WIDTH="119"OperandLEFT="0" WIDTH="141"Absolute Value FpLEFT="150" WIDTH="72"LEFT="230" WIDTH="119"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="72"ABS.DLEFT="230" WIDTH="119"destination, src1LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="72"ABS.SLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Negate FpLEFT="150" WIDTH="72"LEFT="230" WIDTH="119"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="72"NEG.DLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="72"NEG.SLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Add FpLEFT="150" WIDTH="72"LEFT="230" WIDTH="119"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="72"ADD.DLEFT="230" WIDTH="119"destination, src1, src2LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="72"ADD.SLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Divide FpLEFT="150" WIDTH="72"LEFT="230" WIDTH="119"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="72"DIV.DLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="72"DIV.SLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Multiply FpLEFT="150" WIDTH="72"LEFT="230" WIDTH="119"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="72"MUL.DLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="72"MUL.SLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Subtract FpLEFT="150" WIDTH="72"LEFT="230" WIDTH="119"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="72"SUB.DLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="72"SUB.SLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Multiply Add FPLEFT="150" WIDTH="72"LEFT="230" WIDTH="119"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="72"MADD.DLEFT="230" WIDTH="119"destination, src1, src2, src3LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="72"MADD.SLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Negative Multiply Add FPLEFT="150" WIDTH="72"LEFT="230" WIDTH="119"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="72"NMADD.DLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="72"NMADD.SLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"LEFT="150" WIDTH="72"LEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Multiply Subtract FPLEFT="150" WIDTH="72"LEFT="230" WIDTH="119"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="72"MSUB.DLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="72"MSUB.SLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Negative Multiply Subtract FPLEFT="150" WIDTH="72"LEFT="230" WIDTH="119"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="72"NMSUB.DLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="72"NMSUB.SLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Convert Source to Specified Fp PrecisionLEFT="150" WIDTH="72"LEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Double to Single FpLEFT="150" WIDTH="72"CVT.S.DLEFT="230" WIDTH="119"destination, src1LEFT="0" WIDTH="141"Fixed Point to Single FpLEFT="150" WIDTH="72"CVT.S.WLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Single to Double FpLEFT="150" WIDTH="72"CVT.D.SLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Fixed Point to Double FpLEFT="150" WIDTH="72"CVT.D.WLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Single to Fixed Point FpLEFT="150" WIDTH="72"CVT.W.SLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Double to Fixed Point FpLEFT="150" WIDTH="72"CVT.W.DLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Truncate and Round OperationsLEFT="150" WIDTH="72"LEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Truncate to Single FpLEFT="150" WIDTH="72"TRUNC.W.SLEFT="230" WIDTH="119"destination, src, gprLEFT="0" WIDTH="141"Truncate to Double FpLEFT="150" WIDTH="72"TRUNC.W.DLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Round to Single FpLEFT="150" WIDTH="72"ROUND.W.SLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Round to Double FpLEFT="150" WIDTH="72"ROUND.W.DLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Ceiling to Double FpLEFT="150" WIDTH="72"CEIL.W.DLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Ceiling to Single FpLEFT="150" WIDTH="72"CEIL.W.SLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Ceiling to Double Fp, UnsignedLEFT="150" WIDTH="72"CEILU.W.DLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Ceiling to Single Fp, UnsignedLEFT="150" WIDTH="72"CEILU.W.SLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Floor to Double FpLEFT="150" WIDTH="72"FLOOR.W.DLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Floor to Single FpLEFT="150" WIDTH="72"FLOOR.W.SLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Floor to Double F, UnsignedLEFT="150" WIDTH="72"FLOORU.W.DLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Floor to Single Fp UnsignedLEFT="150" WIDTH="72"FLOORU.W.SLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Round to Double Fp UnsignedLEFT="150" WIDTH="72"ROUNDU.W.DLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Round to Single Fp UnsignedLEFT="150" WIDTH="72"ROUNDU.W.SLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Truncate to Double Fp UnsignedLEFT="150" WIDTH="72"TRUNCU.W.DLEFT="230" WIDTH="119"LEFT="0" WIDTH="141"Truncate to Single Fp UnsignedLEFT="150" WIDTH="72"TRUNCU.W.SLEFT="230" WIDTH="119"COLUMNS="3"LEFT="0" WIDTH="171"DescriptionLEFT="180" WIDTH="63"Op-codeLEFT="250" WIDTH="99"OperandLEFT="0" WIDTH="171"Convert Source to Specified Fp PrecisionLEFT="180" WIDTH="63"LEFT="250" WIDTH="99"LEFT="0" WIDTH="171"Long Fixed Point to Single FpLEFT="180" WIDTH="63"CVT.S.LLEFT="250" WIDTH="99"destination, src1LEFT="0" WIDTH="171"Long Fixed Point to Double FPLEFT="180" WIDTH="63"CVT.D.LLEFT="250" WIDTH="99"LEFT="0" WIDTH="171"Single to Long Fixed Point FPLEFT="180" WIDTH="63"CVT.L.SLEFT="250" WIDTH="99"LEFT="0" WIDTH="171"Double to Long Fixed Point FPLEFT="180" WIDTH="63"CVT.L.DLEFT="250" WIDTH="99"LEFT="0" WIDTH="171"Truncate and Round OperationsLEFT="180" WIDTH="63"LEFT="250" WIDTH="99"LEFT="0" WIDTH="171"Truncate Single to Long Fixed PointLEFT="180" WIDTH="63"TRUNC.L.SLEFT="250" WIDTH="99"destination, src, gprLEFT="0" WIDTH="171"Truncate Double to Long Fixed PointLEFT="180" WIDTH="63"TRUNC.L.DLEFT="250" WIDTH="99"LEFT="0" WIDTH="171"Round Single to Long Fixed PointLEFT="180" WIDTH="63"ROUND.L.SLEFT="250" WIDTH="99"LEFT="0" WIDTH="171"Round Double to Long Fixed PointLEFT="180" WIDTH="63"ROUND.L.DLEFT="250" WIDTH="99"LEFT="0" WIDTH="171"Ceiling Single to Long Fixed PointLEFT="180" WIDTH="63"CEIL.L.SLEFT="250" WIDTH="99"LEFT="0" WIDTH="171"Ceiling Double to Long Fixed PointLEFT="180" WIDTH="63"CEIL.L.DLEFT="250" WIDTH="99"LEFT="0" WIDTH="171"Floor Single to Long Fixed PointLEFT="180" WIDTH="63"FLOOR.L.SLEFT="250" WIDTH="99"LEFT="0" WIDTH="171"Floor Double to Long Fixed PointLEFT="180" WIDTH="63"FLOOR.L.DLEFT="250" WIDTH="99"LEFT="0" WIDTH="171"Reciprocal Approximation Operations LEFT="180" WIDTH="63"LEFT="250" WIDTH="99"LEFT="0" WIDTH="171"Reciprocal Approximation Single FpLEFT="180" WIDTH="63"RECIP.SLEFT="250" WIDTH="99"destination, src1LEFT="0" WIDTH="171"Reciprocal Approximation Double FpLEFT="180" WIDTH="63"RECIP.DLEFT="250" WIDTH="99"LEFT="0" WIDTH="171"Reciprocal Square Root Single FpLEFT="180" WIDTH="63"RSQRT.SLEFT="250" WIDTH="99"LEFT="0" WIDTH="171"Reciprocal Square Root Double FpLEFT="180" WIDTH="63"RSQRT.DLEFT="250" WIDTH="99"LBL="" HELPID=""Floating-Point Computational Instruction DescriptionsID="06.coproc10"This part of Chapter 6 groups the instructions by function. Refer to IDREF="11463" TYPE="TABLE"Table 6-3 and IDREF="77592" TYPE="TABLE"Table 6-4 for the op-code names. IDREF="27864" TYPE="TABLE"Table 6-2 describes the floating-point Computational instructions.COLUMNS="2"LBL="6-2"Table 6-2 ID="27864"Floating-Point Computational Instruction DescriptionsLEFT="0" WIDTH="117"InstructionLEFT="125" WIDTH="216"DescriptionLEFT="0" WIDTH="117"Absolute Value Fp 
InstructionsLEFT="125" WIDTH="216"Compute the absolute value of the contents of src1 
and put the specified precision floating-point result 
in the destination register.LEFT="0" WIDTH="117"Add Fp InstructionsLEFT="125" WIDTH="216"Add the contents of src1 (or the destination) to the 
contents of src2 and put the result in the destination 
register. When the sum of two operands with 
opposite signs is exactly zero, the sum has a positive 
sign for all rounding modes except round toward ­1. 
For that rounding mode, the sum has a negative sign.LEFT="0" WIDTH="117"Convert Source to Another 
Precision Fp InstructionsLEFT="125" WIDTH="216"Convert the contents of src1 to the specified precision, 
round according to the rounding mode, and put the 
result in the destination register.LEFT="0" WIDTH="117"Mutiply-Then-Add Fp 
InstructionsLEFT="125" WIDTH="216"Multiply  the contents of src2 and  src3, then add   the 
result to src1 and store in the destination register 
(MADD). The NMADD instruction does the same 
mutiply then add, but then negates the sign of the 
result (64-bit only)..LEFT="0" WIDTH="117"Mutiply-Then-Subtract Fp 
InstructionsLEFT="125" WIDTH="216"Multiply  the contents of src2 and  src3, then subtract   
the result from src1 and store in the destination 
register (MSUB). The NMSUB instruction does the 
same mutiply then subtract, but then negates the sign 
of the result (64-bit only)..LEFT="0" WIDTH="117"Truncate and Round 
instructionsLEFT="125" WIDTH="216"The TRUNC instructions truncate the value in the 
source floating-point register and put the resulting 
integer in the destination floating-point register, 
using the third (general-purpose) register to hold a 
temporary value. (This is a macro-instruction.) The 
ROUND instructions work like TRUNC, but round 
the floating-point value to an integer instead of 
truncating it.LEFT="0" WIDTH="117"Divide Fp InstructionsLEFT="125" WIDTH="216"Compute the quotient of two values. These 
instructions treat src1 as the dividend and src2 as the 
divisor. Divide Fp instructions divide the contents of 
src1 by the contents of src2 and put the result in the 
destination register. If the divisor is a zero, the 
machine signals a error if the divide-by-zero 
exception is enabled.LEFT="0" WIDTH="117"Multiply Fp InstructionsLEFT="125" WIDTH="216"Multiplies the contents of src1 (or the destination) 
with the contents of src2 and puts the result in the 
destination register.LEFT="0" WIDTH="117"Negate FP InstructionsLEFT="125" WIDTH="216"Compute the negative value of the contents of src1 
and put the specified precision floating-point result 
in the destination register.LEFT="0" WIDTH="117"Subtract Fp InstructionsLEFT="125" WIDTH="216"Subtract the contents of src2 from the contents of src1 
(or the destination).  These instructions put the result 
in the destination register. When the difference of two 
operands with the same signs is exactly zero, the 
difference has a positive sign for all rounding modes 
except round toward ­1. For that rounding mode, the 
sum has a negative sign.LEFT="0" WIDTH="117"Reciprocal Approximation 
Instructions LEFT="125" WIDTH="216"For RECIP, the reciprocal of the value in src1 is 
approximated and placed into the destination 
register. For RSQRT. the reciprocal of the square root 
of the value in src1 is approximated and placed into 
the destination register.LBL="" HELPID=""Floating-Point Relational OperationsID="06.coproc11"ID="06.coproc12"IDREF="11463" TYPE="TABLE"Table 6-3 summarizes the floating-point relational instructions. The first column under Condition gives a mnemonic for the condition tested. As the "branch on true/false" condition can be used logically to negate any condition, the second column supplies a mnemonic for the logical negation of the condition in the first column. This provides a total of 32 possible conditions. The four columns under Relations give the result of the comparison based on each condition. The final column states if an invalid operation is signaled for each condition.For example, with an equal condition (EQ mnemonic in the True column), the logical negation of the condition is not equal (NEQ), and a comparison that is equal is True for equal and False for greater than, less than, and unordered, and no Invalid Operation Exception is given if the relation is unordered.COLUMNS="7"LBL="6-3"Table 6-3 ID="11463"Floating-Point Relational OperatorsLEFT="0" WIDTH="59"ConditionsMnemonics         TrueLEFT="65" WIDTH="59"ConditionsMnemonics         FalseLEFT="130" WIDTH="46"Relations    Greater     ThanLEFT="185" WIDTH="41"   Less   ThanLEFT="235" WIDTH="36" EqualLEFT="280" WIDTH="55"UnorderedLEFT="340" WIDTH="86" Invalid Operation         Exception if          UnorderedLEFT="0" WIDTH="59"         FLEFT="65" WIDTH="59"         TLEFT="130" WIDTH="46"        FLEFT="185" WIDTH="41"      FLEFT="235" WIDTH="36"     FLEFT="280" WIDTH="55"          FLEFT="340" WIDTH="86"                 noLEFT="0" WIDTH="59"        UNLEFT="65" WIDTH="59"        ORLEFT="130" WIDTH="46"        FLEFT="185" WIDTH="41"      FLEFT="235" WIDTH="36"     FLEFT="280" WIDTH="55"          TLEFT="340" WIDTH="86"                 noLEFT="0" WIDTH="59"        EQLEFT="65" WIDTH="59"       NEQLEFT="130" WIDTH="46"        FLEFT="185" WIDTH="41"      FLEFT="235" WIDTH="36"     TLEFT="280" WIDTH="55"          FLEFT="340" WIDTH="86"                 noLEFT="0" WIDTH="59"       UEQLEFT="65" WIDTH="59"       OLGLEFT="130" WIDTH="46"        FLEFT="185" WIDTH="41"      FLEFT="235" WIDTH="36"     TLEFT="280" WIDTH="55"          TLEFT="340" WIDTH="86"                 noLEFT="0" WIDTH="59"       OLTLEFT="65" WIDTH="59"       UGELEFT="130" WIDTH="46"        FLEFT="185" WIDTH="41"      TLEFT="235" WIDTH="36"     FLEFT="280" WIDTH="55"          FLEFT="340" WIDTH="86"                 noLEFT="0" WIDTH="59"       ULTLEFT="65" WIDTH="59"       OGELEFT="130" WIDTH="46"        FLEFT="185" WIDTH="41"      TLEFT="235" WIDTH="36"     FLEFT="280" WIDTH="55"          TLEFT="340" WIDTH="86"                 noLEFT="0" WIDTH="59"       OLELEFT="65" WIDTH="59"       UGTLEFT="130" WIDTH="46"        FLEFT="185" WIDTH="41"      TLEFT="235" WIDTH="36"     TLEFT="280" WIDTH="55"          FLEFT="340" WIDTH="86"                 noLEFT="0" WIDTH="59"       ULELEFT="65" WIDTH="59"       OGTLEFT="130" WIDTH="46"        FLEFT="185" WIDTH="41"      TLEFT="235" WIDTH="36"     TLEFT="280" WIDTH="55"          TLEFT="340" WIDTH="86"                 noLEFT="0" WIDTH="59"        SFLEFT="65" WIDTH="59"        STLEFT="130" WIDTH="46"        FLEFT="185" WIDTH="41"      FLEFT="235" WIDTH="36"     FLEFT="280" WIDTH="55"          FLEFT="340" WIDTH="86"                 yesLEFT="0" WIDTH="59"      NGLELEFT="65" WIDTH="59"       GLELEFT="130" WIDTH="46"        FLEFT="185" WIDTH="41"      FLEFT="235" WIDTH="36"     FLEFT="280" WIDTH="55"          TLEFT="340" WIDTH="86"                 yesLEFT="0" WIDTH="59"       SEQLEFT="65" WIDTH="59"       SNELEFT="130" WIDTH="46"        FLEFT="185" WIDTH="41"      FLEFT="235" WIDTH="36"     TLEFT="280" WIDTH="55"          FLEFT="340" WIDTH="86"                 yesLEFT="0" WIDTH="59"       NGLLEFT="65" WIDTH="59"        GLLEFT="130" WIDTH="46"        FLEFT="185" WIDTH="41"      FLEFT="235" WIDTH="36"     TLEFT="280" WIDTH="55"          TLEFT="340" WIDTH="86"                 yesLEFT="0" WIDTH="59"        LTLEFT="65" WIDTH="59"       NLTLEFT="130" WIDTH="46"        FLEFT="185" WIDTH="41"      TLEFT="235" WIDTH="36"     FLEFT="280" WIDTH="55"          FLEFT="340" WIDTH="86"                 yesLEFT="0" WIDTH="59"       NGELEFT="65" WIDTH="59"        GELEFT="130" WIDTH="46"        FLEFT="185" WIDTH="41"      TLEFT="235" WIDTH="36"     FLEFT="280" WIDTH="55"          TLEFT="340" WIDTH="86"                 yesLEFT="0" WIDTH="59"        LELEFT="65" WIDTH="59"       NLELEFT="130" WIDTH="46"        FLEFT="185" WIDTH="41"      TLEFT="235" WIDTH="36"     TLEFT="280" WIDTH="55"          FLEFT="340" WIDTH="86"                 yesLEFT="0" WIDTH="59"       NGTLEFT="65" WIDTH="59"        GTLEFT="130" WIDTH="46"        FLEFT="185" WIDTH="41"      TLEFT="235" WIDTH="36"     TLEFT="280" WIDTH="55"          TLEFT="340" WIDTH="86"                 yesThe mnemonics found in IDREF="11463" TYPE="TABLE"Table 6-3 have following meanings:COLUMNS="4"LEFT="0" WIDTH="54"MnemonicLEFT="60" WIDTH="116"MeaningLEFT="185" WIDTH="57"MnemonicLEFT="250" WIDTH="133"MeaningLEFT="0" WIDTH="54"FLEFT="60" WIDTH="116"FalseLEFT="185" WIDTH="57"TLEFT="250" WIDTH="133"TrueLEFT="0" WIDTH="54"UNLEFT="60" WIDTH="116"UnorderedLEFT="185" WIDTH="57"ORLEFT="250" WIDTH="133"OrderedLEFT="0" WIDTH="54"EQLEFT="60" WIDTH="116"EqualLEFT="185" WIDTH="57"NEQLEFT="250" WIDTH="133"Not EqualLEFT="0" WIDTH="54"UEQLEFT="60" WIDTH="116"Unordered or EqualLEFT="185" WIDTH="57"OLGLEFT="250" WIDTH="133"Ordered or Less than or Greater 
thanLEFT="0" WIDTH="54"OLTLEFT="60" WIDTH="116"Ordered Less ThanLEFT="185" WIDTH="57"UGELEFT="250" WIDTH="133"Unordered or Greater than or 
EqualLEFT="0" WIDTH="54"ULTLEFT="60" WIDTH="116"Unordered or Less ThanLEFT="185" WIDTH="57"OGELEFT="250" WIDTH="133"Ordered Greater than or EqualLEFT="0" WIDTH="54"OLELEFT="60" WIDTH="116"Ordered Less than or EqualLEFT="185" WIDTH="57"UGTLEFT="250" WIDTH="133"Unordered or Greater ThanLEFT="0" WIDTH="54"ULELEFT="60" WIDTH="116"Unorderd or Less than or 
EqualLEFT="185" WIDTH="57"OGTLEFT="250" WIDTH="133"Ordered Greater ThanLEFT="0" WIDTH="54"SFLEFT="60" WIDTH="116"Signaling FalseLEFT="185" WIDTH="57"STLEFT="250" WIDTH="133"Signaling TrueLEFT="0" WIDTH="54"NGLELEFT="60" WIDTH="116"Not Greater than or Less 
than or EqualLEFT="185" WIDTH="57"GLELEFT="250" WIDTH="133"Greater than, or Less than or 
Equal LEFT="0" WIDTH="54"SEQLEFT="60" WIDTH="116"Signaling EqualLEFT="185" WIDTH="57"SNELEFT="250" WIDTH="133"Signaling Not EqualLEFT="0" WIDTH="54"NGLLEFT="60" WIDTH="116"Not Greater than or Less 
thanLEFT="185" WIDTH="57"GLLEFT="250" WIDTH="133"Greater Than or Less Less ThanLEFT="0" WIDTH="54"LTLEFT="60" WIDTH="116"Less ThanLEFT="185" WIDTH="57"NLTLEFT="250" WIDTH="133"Not Less ThanLEFT="0" WIDTH="54"NGELEFT="60" WIDTH="116"Not Greater ThanLEFT="185" WIDTH="57"GELEFT="250" WIDTH="133"Greater Than or Equal or EqualLEFT="0" WIDTH="54"LELEFT="60" WIDTH="116"Less Than or EqualLEFT="185" WIDTH="57"NLELEFT="250" WIDTH="133"Not Less Than or EqualLEFT="0" WIDTH="54"NGTLEFT="60" WIDTH="116"Not Greater ThanLEFT="185" WIDTH="57"GTLEFT="250" WIDTH="133"Greater ThanTo branch on the result of a relational: /* branching on a compare result */

c.eq.s $f1,$f2 /* compare the single-precision values */
bc1t true /* if $f1 equals $f2, branch to true */
bc1f false /* if $f1 does not equal $f2, branch to */
/* false */LBL="" HELPID=""Floating-Point Relational Instruction FormatsID="06.coproc13"These are the floating-point relational instruction formats.COLUMNS="3"LEFT="0" WIDTH="141"DescriptionLEFT="150" WIDTH="81"Op-codeLEFT="240" WIDTH="110"OperandLEFT="0" WIDTH="141"Compare FLEFT="150" WIDTH="81"LEFT="240" WIDTH="110"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="81"C.F.DLEFT="240" WIDTH="110"src1,src2LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="81"C.F.SLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"Compare UNLEFT="150" WIDTH="81"LEFT="240" WIDTH="110"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="81"C.UN.D LEFT="240" WIDTH="110"LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="81"C.UN.SLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"*Compare EQLEFT="150" WIDTH="81"LEFT="240" WIDTH="110"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="81"C.EQ.DLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="81"C.EQ.SLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"Compare UEQLEFT="150" WIDTH="81"LEFT="240" WIDTH="110"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="81"C.UEQ.DLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="81"C.UEQ.SLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"Compare OLTLEFT="150" WIDTH="81"LEFT="240" WIDTH="110"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="81"C.OLT.DLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="81"C>OLT.SLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"Compare ULTLEFT="150" WIDTH="81"LEFT="240" WIDTH="110"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="81"C.ULT.DLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="81"C.ULT.SLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"Compare OLELEFT="150" WIDTH="81"LEFT="240" WIDTH="110"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="81"C.OLE.DLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="81"C.OLE.SLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"Compare ULELEFT="150" WIDTH="81"LEFT="240" WIDTH="110"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="81"C.ULE.DLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="81"C.ULE.SLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"Compare SFLEFT="150" WIDTH="81"LEFT="240" WIDTH="110"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="81"C.SF.DLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="81"C.SF.SLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"Compare NGLELEFT="150" WIDTH="81"LEFT="240" WIDTH="110"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="81"C.NGLE.DLEFT="240" WIDTH="110"src1, src2LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="81"C.NGLE.SLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"Compare SEQLEFT="150" WIDTH="81"LEFT="240" WIDTH="110"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="81"C.SEQ.DLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="81"C.SEQ.SLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"Compare NGLLEFT="150" WIDTH="81"LEFT="240" WIDTH="110"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="81"C.NGL.DLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="81"C.NGL.SLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"*Compare LTLEFT="150" WIDTH="81"LEFT="240" WIDTH="110"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="81"C.LT.DLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="81"C.LT.SLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"Compare NGELEFT="150" WIDTH="81"LEFT="240" WIDTH="110"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="81"C.NGE.DLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="81"C.NGE.SLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"LEFT="150" WIDTH="81"LEFT="240" WIDTH="110"LEFT="0" WIDTH="141"*Compare LELEFT="150" WIDTH="81"LEFT="240" WIDTH="110"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="81"C.LE.DLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="81"C.LE.SLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"Compare NGTLEFT="150" WIDTH="81"LEFT="240" WIDTH="110"LEFT="0" WIDTH="141"DoubleLEFT="150" WIDTH="81"C.NGT.DLEFT="240" WIDTH="110"LEFT="0" WIDTH="141"SingleLEFT="150" WIDTH="81"C.NGT.SLEFT="240" WIDTH="110"NoteThese are the most common Compare instructions. The MIPS coprocessor instruction set provides others for IEEE compatibility.LBL="" HELPID=""Floating-Point Relational Instruction DescriptionsID="06.coproc14"This part of Chapter 6 describes the relational instruction descriptions by function. Refer to Chapter 1 for information regarding registers. COLUMNS="2"LBL="6-4"Table 6-4 ID="77592"Floating-Point Relational Instruction DescriptionsLEFT="0" WIDTH="117"InstructionLEFT="125" WIDTH="216"DescriptionLEFT="0" WIDTH="117"Compare EQ InstructionsLEFT="125" WIDTH="216"Compare the contents of src1 with the contents of 
src2. If src1 equals src2 a true condition results; 
otherwise, a false condition results. The machine 
does not signal an exception for unordered values.LEFT="0" WIDTH="117"Compare F InstructionsLEFT="125" WIDTH="216"Compare the contents of src1 with the contents of 
src2. These instructions always produce a false 
condition. The machine does not signal an exception 
for unordered values.LEFT="0" WIDTH="117"Compare LELEFT="125" WIDTH="216"Compare the contents of src1 with the contents of 
src2. If src1 is less than or equal to src2, a true 
condition results; otherwise, a false condition results. 
The machine signals an exception for unordered 
values.LEFT="0" WIDTH="117"Compare LTLEFT="125" WIDTH="216"Compare the contents of src1 with the contents of 
src2. If src1 is less than src2, a true condition results; 
otherwise, a false condition results. The machine 
signals an exception for unordered values.LEFT="0" WIDTH="117"Compare NGELEFT="125" WIDTH="216"Compare the contents of src1 with the contents of 
src2. If src1 is less than src2 (or the contents are 
unordered), a true condition results; otherwise, a 
false condition results. The machine signals an 
exception for unordered values.LEFT="0" WIDTH="117"Compare NGLLEFT="125" WIDTH="216"Compare the contents of src1 with the contents of 
src2. If src1 equals src2 or the contents are unordered, 
a true condition results; otherwise, a false condition 
results. The machine signals an exception for 
unordered values.LEFT="0" WIDTH="117"Compare NGLELEFT="125" WIDTH="216"Compare the contents of src1 with the contents of 
src2. If src1 is unordered, a true condition results; 
otherwise, a false condition results. The machine 
signals an exception for unordered values.LEFT="0" WIDTH="117"Compare NGTLEFT="125" WIDTH="216"Compare the contents of src1 with the contents of 
src2.  If src1 is less than or equal to src2 or the contents 
are unordered, a true condition results; otherwise, a 
false condition results. The machine signals an 
exception for unordered values.LEFT="0" WIDTH="117"Compare OLE InstructionsLEFT="125" WIDTH="216"Compare the contents of src1 with the contents of 
src2. If src1 is less than or equal to src2, a true 
condition results; otherwise, a false condition results. 
The machine does not signal an exception for 
unordered values.LEFT="0" WIDTH="117"Compare OLT InstructionsLEFT="125" WIDTH="216"Compare the contents of src1 with the contents of 
src2. If src1 is less than src2, a true condition results; 
otherwise, a false condition results. The machine 
does not signal an exception for unordered values.LEFT="0" WIDTH="117"Compare SEQ InstructionsLEFT="125" WIDTH="216"Compare the contents of src1 with the contents of 
src2. If src1 equals src2, a true condition results; 
otherwise, a false condition results. The machine 
signals an exception for unordered values.LEFT="0" WIDTH="117"Compare SF InstructionsLEFT="125" WIDTH="216"Compare the contents of src1 with the contents of 
src2. This always produces a false condition. The 
machine signals an exception for unordered values.LEFT="0" WIDTH="117"Compare ULE InstructionsLEFT="125" WIDTH="216"Compare the contents of src1 with the contents of 
src2. If src1 is less than or equal to src2 (or src1 is 
unordered), a true condition results; otherwise, a 
false condition results. The machine does not signal 
an exception for unordered values.LEFT="0" WIDTH="117"Compare UEQ InstructionsLEFT="125" WIDTH="216"Compare the contents of src1 with the contents of 
src2. If src1 equals src2 (or src1 and src2 are 
unordered), a true condition results; otherwise, a 
false condition results. The machine does not signal 
an exception for unordered values.LEFT="0" WIDTH="117"Compare ULT InstructionsLEFT="125" WIDTH="216"Compare the contents of src1 with the contents of 
src2. If src1 is less than src2 (or the contents are 
unordered), a true condition results; otherwise, a 
false condition results. The machine does not signal 
an exception for unordered values.LEFT="0" WIDTH="117"Compare UN InstructionsLEFT="125" WIDTH="216"Compare the contents of src1 with the contents of 
src2. If either src1 or src2 is unordered, a true 
condition results; otherwise, a false condition results. 
The machine does not signal an exception for 
unordered values.LBL="" HELPID=""Floating-Point Move FormatsID="06.coproc15"ID="06.coproc16"The floating-point move instructions move data from source to destination registers (only floating-point registers are allowed).COLUMNS="3"LEFT="0" WIDTH="144"DescriptionLEFT="150" WIDTH="47"Op-codeLEFT="205" WIDTH="141"OperandLEFT="0" WIDTH="144"Move FPLEFT="150" WIDTH="47"LEFT="205" WIDTH="141"LEFT="0" WIDTH="144"SingleLEFT="150" WIDTH="47"MOV.SLEFT="205" WIDTH="141"destination,src1LEFT="0" WIDTH="144"DoubleLEFT="150" WIDTH="47"MOV.DLEFT="205" WIDTH="141"LEFT="0" WIDTH="144"Move Conditional on FP FalseLEFT="150" WIDTH="47"LEFT="205" WIDTH="141"LEFT="0" WIDTH="144"SingleLEFT="150" WIDTH="47"MOVF.SLEFT="205" WIDTH="141"destination,src1, ccLEFT="0" WIDTH="144"DoubleLEFT="150" WIDTH="47"MOVF.DLEFT="205" WIDTH="141"LEFT="0" WIDTH="144"Move Conditional on FP TrueLEFT="150" WIDTH="47"LEFT="205" WIDTH="141"LEFT="0" WIDTH="144"SingleLEFT="150" WIDTH="47"MOVT.SLEFT="205" WIDTH="141"destination,src1, ccLEFT="0" WIDTH="144"DoubleLEFT="150" WIDTH="47"MOVT.DLEFT="205" WIDTH="141"LEFT="0" WIDTH="144"Floating-Point Move Conditional on 
Not ZeroLEFT="150" WIDTH="47"LEFT="205" WIDTH="141"LEFT="0" WIDTH="144"SingleLEFT="150" WIDTH="47"MOVN.SLEFT="205" WIDTH="141"gpr_destination, gpr_src1, gprLEFT="0" WIDTH="144"DoubleLEFT="150" WIDTH="47"MOVF.DLEFT="205" WIDTH="141"LEFT="0" WIDTH="144"Floating-Point Move Conditional on 
ZeroLEFT="150" WIDTH="47"LEFT="205" WIDTH="141"LEFT="0" WIDTH="144"SingleLEFT="150" WIDTH="47"MOVZ.SLEFT="205" WIDTH="141"gpr_destination, gpr_src1, gprLEFT="0" WIDTH="144"DoubleLEFT="150" WIDTH="47"MOVZ.DLEFT="205" WIDTH="141"LBL="" HELPID=""Floating-Point Move Instruction DescriptionsID="06.coproc17"This part of Chapter 6 describes the floating-point move instructions. COLUMNS="2"LBL="6-5"Table 6-5 Floating-Point Move Instruction DescriptionsLEFT="0" WIDTH="99"InstructionLEFT="105" WIDTH="234"DescriptionLEFT="0" WIDTH="99"Move FP InstructionsLEFT="105" WIDTH="234"Move the double or single-precision contents of src1 to the 
destination register, maintaining the specified precision,if 
the condition code (cc) is zero (MOVF) or is one (MOVT).LEFT="0" WIDTH="99"Conditonal  FP Move 
InstructionsLEFT="105" WIDTH="234"Conditionally, move the double-precision  or 
single-precision contents of src1 to the destination register, 
maintaining the specified precision.LEFT="0" WIDTH="99"Floating-Point 
Conditonal  Move 
InstructionsLEFT="105" WIDTH="234"Conditionally, move a floating-point value from src1 to the 
destination register if the gpr_register is zero (MOVZ) or 
not equal to zero (MOVN).LBL="" HELPID=""System Control Coprocessor InstructionsThe system control coprocessor (cp0) handles all functions and special and privileged registers for the virtual memory and exception handling subsystems. The system control coprocessor translates addresses from a large virtual address space into the machine's physical memory space. The coprocessor uses a translation lookaside buffer (TLB) to translate virtual addresses to physical addresses.LBL="" HELPID=""System Control Coprocessor Instruction FormatsID="06.coproc18"These coprocessor system control instructions do not have operands.COLUMNS="2"LEFT="0" WIDTH="207"DescriptionLEFT="215" WIDTH="126"Op-codeLEFT="0" WIDTH="207"Cache**LEFT="215" WIDTH="126"CACHELEFT="0" WIDTH="207"Translation Lookaside Buffer ProbeLEFT="215" WIDTH="126"TLBPLEFT="0" WIDTH="207"Translation Lookaside Buffer ReadLEFT="215" WIDTH="126"TLBRLEFT="0" WIDTH="207"Translation Lookaside Buffer Write RandomLEFT="215" WIDTH="126"TLBWRLEFT="0" WIDTH="207"Translation Lookaside Write IndexLEFT="215" WIDTH="126"TLBWILEFT="0" WIDTH="207"Synchronize*LEFT="215" WIDTH="126"SYNCLEFT="0" WIDTH="126"LEFT="0" WIDTH="126"LBL="a" ID="06.coprocTF13a"* Not valid in MIPS1 architectures.LBL="b" ID="06.coprocTF13b"** Not valid in MIPS1 and MIPS2  architectures.LBL="" HELPID=""System Control Coprocessor Instruction DescriptionsID="06.coproc19"This part of Chapter 6 describes the system control coprocessor instructions.COLUMNS="2"LBL="6-6"Table 6-6 ID="64759"System Control Coprocessor Instruction DescriptionsLEFT="0" WIDTH="117"InstructionLEFT="125" WIDTH="216"DescriptionLEFT="0" WIDTH="117"Cache (CACHE) **LEFT="125" WIDTH="216"Cache is the R4000 instruction to perform cache 
operations. The 16-bit offset is sign-extended and 
added to the contents of general register base to form 
a virtual address. The virtual address is translated to 
a physical address using the TLB. The 5-bit 
sub-opcode ("op") specifies the cache operation for 
that address. Part of the virtual address is used to 
specify the cache block for the operation. Possible 
operations include invalidating a cache block, 
writeback to a secondary cache or memory, etc.** This instruction is not valid in MIPS1 or MIPS2 
architectures.LEFT="0" WIDTH="117"Translation Lookaside 
Buffer Probe (TLBP)LEFT="125" WIDTH="216"Probes the translation lookaside buffer (TLB) to see if 
the TLB has an entry that matches the contents of the 
EntryHi register. If a match occurs, the machine loads 
the Index register with the number of the entry that 
matches the EntryHi register. If no TLB entry 
matches, the machine sets the high-order bit of the 
Index register.LEFT="0" WIDTH="117"Translation Lookaside 
Buffer Read (TLBR)LEFT="125" WIDTH="216"Loads the EntryHi and EntryLo registers with the 
contents of the translation lookaside buffer (TLB) 
entry specified in the TLB Index register.LEFT="0" WIDTH="117"Translation Lookaside 
BufferWrite Random 
(TLBWR)LEFT="125" WIDTH="216"Loads the specified translation lookaside buffer (TLB) 
entry with the contents of the EntryHi and EntryLo 
registers. The contents of the TLB Random register 
specify the TLB entry to be loaded.LEFT="0" WIDTH="117"Translation Lookaside 
Buffer Write Index (TLBWI)LEFT="125" WIDTH="216"Loads the specified translation lookaside buffer (TLB) 
entry with the contents of the EntryHI and EntryLO 
registers. The contents of the TLB Index register 
specify the TLB entry to be loaded.LEFT="0" WIDTH="117"Synchronize (SYNC) *LEFT="125" WIDTH="216"Ensures that all loads and stores fetched before the 
sync are completed, before allowing any following 
loads or stores. Use of sync to serialize certain 
memory references may be required in 
multiprocessor environments.* This instruction is not valid in the MIPS1 
architecture.LBL="" HELPID=""Control and Status Register ID="06.coproc20"Floating-point coprocessor control register 31 contains status and control information. See IDREF="55847" TYPE="GRAPHIC"Figure 6-2. It controls the arithmetic rounding mode and the enabling of user-level traps, and indicates exceptions that occurred in the most recently executed instruction, and any exceptions that may have occurred without being trapped:FILE="fig6-2.fp_reg.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-2"Figure 6-2 ID="55847"Floating Control and Status Register 31The exception bits are set for instructions that cause an IEEE standard exception or an optional exception used to emulate some of the more hardware-intensive features of the IEEE standard.The exception field is loaded as a side-effect of each floating-point operation (excluding loads, stores, and unformatted moves). The exceptions which were caused by the immediately previous floating-point operation can be determined by reading the exception field.The meaning of each bit in the exception field is given below. If two exceptions occur together on one instruction, the field will contain the inclusive-OR of the bits for each exception:COLUMNS="2"LEFT="0" WIDTH="66"Exception 
Field BitLEFT="75" WIDTH="271"DescriptionLEFT="0" WIDTH="66"ELEFT="75" WIDTH="271"Unimplemented OperationLEFT="0" WIDTH="66"ILEFT="75" WIDTH="271"Inexact ExceptionLEFT="0" WIDTH="66"OLEFT="75" WIDTH="271"Overflow ExceptionLEFT="0" WIDTH="66"ULEFT="75" WIDTH="271"Underflow ExceptionLEFT="0" WIDTH="66"VLEFT="75" WIDTH="271"Invalid OperationLEFT="0" WIDTH="66"ZLEFT="75" WIDTH="271"Division-by-ZeroThe unimplemented operation exception is normally invisible to user-level code. It is provided to maintain IEEE compatibility for non-standard implementations.The five IEEE standard exceptions are listed below:COLUMNS="2"LEFT="0" WIDTH="66"FieldLEFT="75" WIDTH="266"DescriptionLEFT="0" WIDTH="66"ILEFT="75" WIDTH="266"Inexact ExceptionLEFT="0" WIDTH="66"OLEFT="75" WIDTH="266"Overflow ExceptionLEFT="0" WIDTH="66"ULEFT="75" WIDTH="266"Underflow ExceptionLEFT="0" WIDTH="66"VLEFT="75" WIDTH="266"Invalid OperationzLEFT="0" WIDTH="66"ZLEFT="75" WIDTH="266"Division-by-ZeroEach of the five exceptions is associated with a trap under user control, which is enabled by setting one of the five bits of the enable field, shown above.When an exception occurs, both the corresponding exception and status bits are set. If the corresponding enable flag bit is set, a trap is taken. In some cases the result of an operation is different if a trap is enabled.The status flags are never cleared as a side effect of floating-point operations, but may be set or cleared by writing a new value into the status register, using a "move to coprocessor control" instruction.The floating-point compare instruction places the condition which was detected into the `c' bit of the control and status register, so that the state of the condition line may be saved and restored. The `c' bit is set if the condition is true, and cleared if the condition is false, and is affected only by compare and move to control register instructions.LBL="" HELPID=""Exception Trap ProcessingID="06.coproc21"ID="06.coproc22"For each IEEE standard exception, a status flag is provided that is set on any occurrence of the corresponding exception condition with no corresponding exception trap signaled. It may be reset by writing a new value into the status register. The flags may be saved and restored individually, or as a group, by software. When no exception trap is signaled, a default action is taken by the floating-point coprocessor, which provides a substitute value for the original, exceptional, result of the floating-point operation. The default action taken depends on the type of exception, and in the case of the Overflow exception, the current rounding mode.LBL="" HELPID=""Invalid Operation ExceptionID="06.coproc23"ID="06.coproc24"The invalid operation exception is signaled if one or both of the operands are invalid for an implemented operation. The result, when the exception occurs without a trap, is a quiet NaN when the destination has a floating-point format, and is indeterminate if the result has a fixed-point format. The invalid operations are:Addition or subtraction: magnitude subtraction of infinities, such as( + 1 ) ­ ( ­ 1 ).Multiplication: 0 times 1, with any signs.Division: 0 over 0 or 1 over 1, with any signs.Square root of x: where x is less than zero.Conversion of a floating-point number to a fixed-point format when an overflow, or operand value of infinity or NaN, precludes a faithful representation in that format.Comparison of predicates involving < or > without ?, when the operands are "unordered".Any operation on a signaling NaN.Software may simulate this exception for other operations that are invalid for the given source operands. Examples of these operations include IEEE-specified functions implemented in software, such as Remainder: x REM y, where y is zero or x is infinite; conversion of a floating-point number to a decimal format whose value causes and overflow or is infinity of NaN; and transcendental functions, such as ln (­5) or cos-1(3).LBL="" HELPID=""Division-by-zero ExceptionID="06.coproc25"ID="06.coproc26"The division by zero exception is signaled on an implemented divide operation if the divisor is zero and the dividend is a finite nonzero number. The result, when no trap occurs, is a correctly signed infinity.If division by zero traps are enabled, the result register is not modified, and the source registers are preserved.Software may simulate this exception for other operations that produce a signed infinity, such as ln(0), sec(p/2), csc(0) or 0-1.LBL="" HELPID=""Overflow ExceptionID="06.coproc27"ID="06.coproc28"The overflow exception is signaled when what would have been the magnitude of the rounded floating-point result, were the exponent range unbounded, is larger than the destination format's largest finite number. The result, when no trap occurs, is determined by the rounding mode and the sign of the intermediate result.If overflow traps are enabled, the result register is not modified, and the source registers are preserved.LBL="" HELPID=""Underflow ExceptionID="06.coproc29"ID="06.coproc30"Two related events contribute to underflow. One is the creation of a tiny non-zero result between \xb1 2Emin (minimum expressible exponent) which, because it is tiny, may cause some other exception later. The other is extraordinary loss of accuracy during the approximation of such tiny numbers by denormalized numbers.The IEEE standard permits a choice in how these events are detected, but requires that they must be detected the same way for all operations.The IEEE standard specifies that "tininess" may be detected either: "after rounding" (when a nonzero result computed as though the exponent range were unbounded would lie strictly between \xb1 2Emin), or "before rounding" (when a nonzero result computed as though the exponent range and the precision were unbounded would lie strictly between \xb1 2Emin). The architecture requires that tininess be detected after rounding.Loss of accuracy may be detected as either "denormalization loss" (when the delivered result differs from what would have been computed if the exponent range were unbounded), or "inexact result" (when the delivered result differs from what would have been computed if the exponent range and precision were both unbounded). The architecture requires that loss of accuracy be detected as inexact result.When an underflow trap is not enabled, underflow is signaled (via the underflow flag) only when both tininess and loss of accuracy have been detected. The delivered result might be zero, denormalized, or \xb1  2Emin. When an underflow trap is enabled, underflow is signaled when tininess is detected regardless of loss of accuracy.If underflow traps are enabled, the result register is not modified, and the source registers are preserved.LBL="" HELPID=""Inexact ExceptionID="06.coproc31"ID="06.coproc32"If the rounded result of an operation is not exact or if it overflows without an overflow trap, then the inexact exception is signaled. The rounded or overflowed result is delivered to the destination register, when no inexact trap occurs. If inexact exception traps are enabled, the result register is not modified, and the source registers are preserved.LBL="" HELPID=""Unimplemented Operation ExceptionID="06.coproc33"ID="06.coproc34"If an operation is specified that the hardware may not perform, due to an implementation restriction on the supported operations or supported formats, an unimplemented operation exception may be signaled, which always causes a trap, for which there are no corresponding enable or flag bits. The trap cannot be disabled.This exception is raised at the execution of the unimplemented instruction. The instruction may be emulated in software, possibly using implemented floating-point unit instructions to accomplish the emulation. Normal instruction execution may then be restarted.This exception is also raised when an attempt is made to execute an instruction with an operation code or format code which has been reserved for future architectural definition. The unimplemented instruction trap is not optional, since the current definition contains codes of this kind.This exception may be signaled when unusual operands or result conditions are detected, for which the implemented hardware cannot handle the condition properly. These may include (but are not limited to), denormalized operands or results, NaN operands, trapped overflow or underflow conditions. The use of this exception for such conditions is optional.LBL="" HELPID=""Floating-Point RoundingID="06.coproc35"Bits 0 and 1 of the coprocessor control register 31 sets the rounding mode for floating-point. The machine allows four rounding modes:Round to nearest rounds the result to the nearest representable value. When the two nearest representable values are equally near, this mode rounds to the value with the least significant bit zero. To select this mode, set bits 1..0 of control register 31 to 0.Round toward zero rounds toward zero. It rounds to the value that is closest to and not greater in magnitude than the infinitely precise result. To select this mode, set bits 1..0 of control register 31 to 1.Round toward positive infinity rounds to the value that is closest to and not less than the infinitely precise result. To select this mode, set bits 1..0 of control register 31 to 2.Round toward negative infinity rounds toward negative infinity. It rounds to the value that is closest to and not greater than the infinitely precise result. To select this mode, set bits 1..0 of control register 31 to 3.To set the rounding mode: /* setting the rounding mode */
RoundNearest = Ox0
RoundZero = Ox1
RoundPosInf = Ox2
RoundNegInf = Ox3
    cfc1 rt2, $31          # move from coprocessor 1
    and rt, Oxfffffffc     # zero the round mode bits
    or rt, RoundZero       # set mask as round to zero
    ctc1 rt, $f31          # move to coprocessor 1LBL="7"Linkage ConventionsID="07.link1"ID="07.link2"This chapter gives rules and examples to follow when designing an assembly language program. The chapter includes a "learn by doing" section that contains information about how  calling sequenca  work. This involves writing a skeleton version of your prospective assembly routine using a high level language, and then compiling it with the ­S option to generate a human-readable assembly language file. The assembly language file can then be used as the starting point for coding your routine.This assembler works in either 32-bit, high performance 32-bit (N32) or 64-bit compilation modes. While these modes are very similar, due to the difference in data, register and address sizes,  the  N32 and 64-bit assembler linkage conventions are not always the same as those for 32-bit mode. For details on some of these differences, see the MIPSpro 64-bit Porting and Transition Guide and MIPSpro N32 ABI Guide.The procedures and examples in this chapter, for the most part, describe 32-bit compilation mode. In some cases, specific differences necessitated by 64-bit mode are highlighted.LBL="" HELPID=""IntroductionWhen you write assembly language routines, you should follow the same calling conventions that the compilers observe, for two reasons:Often your code must interact with compiler-generated code, accepting and returning arguments or accessing shared global data.The symbolic debugger gives better assistance in debugging programs using standard calling conventions.The conventions for the compiler system are a bit more complicated than some, mostly to enhance the speed of each procedure call. Specifically:The compilers use the full, general calling sequence only when necessary; where possible, they omit unneeded portions of it. For example, the compilers don't use a register as a frame pointer whenever possible.The compilers and debugger observe certain implicit rules rather than communicating via instructions or data at execution time. For example, the debugger looks at information placed in the symbol table by a ".frame" directive at compilation time, so that it can tolerate the lack of a register containing a frame pointer at execution time.LBL="" HELPID=""Program DesignID="07.link3"ID="07.link4"This section describes three general areas of concern to the assembly language programmer:Usable and restricted registers.Stack frame requirements on entering and exiting a routine.The "shape" of data (scalars, arrays, records, sets) laid out by the various high level languages.LBL="" HELPID=""Register Use and LinkageID="07.link5"ID="07.link6"ID="07.link7"The main processor has 32 integer registers. They are each 32-bit wide in MIPS1 and MIPS2 architectures. In MIPS3 and later architecture, each register is 64 bits wide. The uses and restrictions of these registers are described in IDREF="19384" TYPE="TABLE"Table 1-1 and IDREF="10891" TYPE="TABLE"Table 1-2 in Chapter 1.The floating point coprocessor has 16 floating-point registers. Each register can hold either a single precision (32 bit) or a double precision (64 bit) value. All references to the32-bit versions of these registers use an even register number (e.g., $f4).  IDREF="98599" TYPE="TABLE"Table 1-4 and IDREF="84436" TYPE="TABLE"Table 1-5 list the floating point registers and describe their use.LBL="" HELPID=""The Stack FrameID="07.link8"This discussion of the stack frame, particularly regarding the graphics, describes 32-bit operations.  In 32-bit mode, restrictions such as stack addressing are enforced strictly. While these restrictions are not enforced rigidly for 64-bit stack frame usage, their observance is probably still a good coding practice, especially if you count on reliable debugging information.The compilers classify each routine into one of the following categories:Non-leaf routines, that is, routines that call other procedures. ID="07.link9"ID="07.link10"Leaf routines, that is, routines that do not themselves execute any procedure calls. Leaf routines are of two types:Leaf routines that require stack storage for local variablesLeaf routines that do not require stack storage for local variables.You must decide the routine category before determining the calling sequence.To write a program with proper stack frame usage and debugging capabilities, use the following procedure:Regardless of the type of routine, you should include a .ent pseudo-op and an entry label for the procedure. The .ent pseudo-op is for use by the debugger, and the entry label is the procedure name. The syntax is:.ent    procedure_nameprocedure_name:If you are writing a leaf procedure that does not use the stack, skip to step 3. For leaf procedure that uses the stack or non-leaf procedures, you must allocate all the stack space that the routine requires. The syntax to adjust the stack size is:subu    $sp,framesizewhere framesize is the size of frame required; framesize must  be a multiple of 16. Space must be allocated for:Local variables.Saved general registers. Space should be allocated only for those registers saved. For non-leaf procedures, you must save $31, which is used in the calls to other procedures from this routine. If you use registers $16­$23, you must also save them.Saved floating-point registers. Space should be allocated only for those registers saved. If you use registers $f20­$f30 (for 32-bit) or $f24-$f31 (for 64-bit), you must also save them.Procedure call argument area. You must allocate the maximum number of bytes for arguments of any procedure that you call from this routine.NoteOnce you have modified $sp, you should not modify it again for the rest of the routine.Now include a .frame pseudo-op:.frame    framereg,framesize,returnregThe virtual frame pointer is a frame pointer as used in other compiler systems but has no register allocated for it. It consists of the framereg ($sp, in most cases) added to the framesize (see step 2 above). IDREF="15108" TYPE="GRAPHIC"Figure 7-1 illustrates the stack components.The returnreg specifies the register containing the return address (usually $31). These usual values may change if you use a varying stack pointer or are specifying a kernel trap routine.FILE="fig7-1.stack_org.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-1"Figure 7-1 ID="15108"Stack OrganizationID="07.link11"If the procedure is a leaf procedure that does not use the stack, skip to step 7. Otherwise you must save the registers you allocated space for in step 2.To save the general registers, use the following operations:.mask    bitmask,frameoffset
sw reg,framesize+frameoffset­N($sp)The .mask directive specifies the registers to be stored and where they are stored. A bit should be on in bitmask for each register saved (for example, if register $31 is saved, bit 31 should be `1' in bitmask. Bits are set in bitmask in little-endian order, even if the machine configuration is big-endian).The frameoffset is the offset from the virtual frame pointer (this number is usually negative).N should be 0 for the highest numbered register saved and then incremented by four for each subsequently lower numbered register saved. For example:sw    $31,framesize+frameoffset($sp)
sw    $17,framesize+frameoffset­4($sp)
sw    $16,framesize+frameoffset­16($sp)IDREF="21908" TYPE="GRAPHIC"Figure 7-2 illustrates this example.Now save any floating-point registers that you allocated space for in step 2 as follows:.fmask    bitmask,frameoffsets.[sd]reg,framesize+frameoffset­N($sp)Notice that saving floating-point registers is identical to saving general registers except we use the .fmask pseudo-op instead of .mask, and the stores are of floating-point singles or doubles.The discussion regarding saving general registers applies here as well, but remember that N should be incremented by 16 for doubles.The stack framesize must be a multiple of 16.FILE="fig7-2.stack_exmpl.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-2"Figure 7-2 ID="21908"Stack ExampleThis step describes parameter passing: how to access arguments passed into your routine and passing arguments correctly to other procedures. For information on high-level language-specific constructs (call-by-name, call-by-value, string or structure passing), refer to  the MIPSpro Compiling, Debugging and Performance Tuning Guide.As specified in step 2, space must be allocated on the stack for all arguments even though they may be passed in registers. This provides a saving area if their registers are needed for other variables.General registers must be used for passing arguments. For 32-bit compilations, general registers $4­$7 and float registers $f12, $f14 are used for passing the first four arguments (if possible). You must allocate a pair of registers (even if it's a single precision argument) that start with an even register for floating-point arguments appearing in registers.For 64-bit compilations, general registers $4­$11 and float registers $f12, through $f19 are used for passing the first eight arguments (if possible). In IDREF="48839" TYPE="TABLE"Table 7-1 and IDREF="56806" TYPE="TABLE"Table 7-2, the "fN" arguments are considered single- and double-precision floating-point arguments, and "nN" arguments are everything else. The ellipses (...) mean that the rest of the arguments do not go in registers regardless of their type. The "stack" assignment means that you do not put this argument in a register. The register assignments occur in the order shown in order to satisfy optimizing compiler protocols:COLUMNS="2"LBL="7-1"Table 7-1 ID="48839"Parameter Passing (32-Bit)LEFT="0" WIDTH="127"Argument ListLEFT="135" WIDTH="228"Register and Stack AssignmentsLEFT="0" WIDTH="127"f1, f2LEFT="135" WIDTH="228"$f12, $f14LEFT="0" WIDTH="127"f1, n1, f2LEFT="135" WIDTH="228"$f12, $6, stackLEFT="0" WIDTH="127"f1, n1, n2LEFT="135" WIDTH="228"$f12,  $6  $7LEFT="0" WIDTH="127"n1, n2, n3, n4LEFT="135" WIDTH="228"$4,  $5,  $6,  $7LEFT="0" WIDTH="127"n1, n2, n3, f1LEFT="135" WIDTH="228"$4, $5, $6, stackLEFT="0" WIDTH="127"n1, n2, f1LEFT="135" WIDTH="228"$4, $5, ($6, $6)LEFT="0" WIDTH="127"n1, f1LEFT="135" WIDTH="228"$4, ($6, $7)COLUMNS="2"LBL="7-2"Table 7-2 ID="56806"Parameter Passing (64-Bit)LEFT="0" WIDTH="128"Argument ListLEFT="135" WIDTH="228"Register and Stack AssignmentsLEFT="0" WIDTH="128"d1,d2LEFT="135" WIDTH="228"$f12, $f13LEFT="0" WIDTH="128"s1,s2LEFT="135" WIDTH="228"$f12, $f13LEFT="0" WIDTH="128"s1,d1LEFT="135" WIDTH="228"$f12, $f13LEFT="0" WIDTH="128"d1,s1LEFT="135" WIDTH="228"$f12, $f13LEFT="0" WIDTH="128"n1,d1LEFT="135" WIDTH="228"$4,$f13LEFT="0" WIDTH="128"d1,n1,d1LEFT="135" WIDTH="228"$f12, $5,$f14LEFT="0" WIDTH="128"n1,n2,d1LEFT="135" WIDTH="228"$4, $5,$f14LEFT="0" WIDTH="128"d1,n1,n2LEFT="135" WIDTH="228"$f12, $5,$6LEFT="0" WIDTH="128"s1,n1,n2LEFT="135" WIDTH="228"$f12, $5,$6LEFT="0" WIDTH="128"d1,s1,s2LEFT="135" WIDTH="228"$f12, $f13, $f14LEFT="0" WIDTH="128"s1,s2,d1LEFT="135" WIDTH="228"$f12, $f13, $f14LEFT="0" WIDTH="128"n1,n2,n3,n4LEFT="135" WIDTH="228"$4,$5,$6,$7LEFT="0" WIDTH="128"n1,n2,n3,d1LEFT="135" WIDTH="228"$4,$5,$6,$f15LEFT="0" WIDTH="128"n1,n2,n3,s1LEFT="135" WIDTH="228"$4,$5,$6, $f15LEFT="0" WIDTH="128"s1,s2,s3,s4LEFT="135" WIDTH="228"$f12, $f13,$f14,$f15LEFT="0" WIDTH="128"s1,n1,s2,n2LEFT="135" WIDTH="228"$f12, $5,$f14,$7LEFT="0" WIDTH="128"n1,s1,n2,s2LEFT="135" WIDTH="228"$4,$f13,$6,$f15LEFT="0" WIDTH="128"n1,s1,n2,n3LEFT="135" WIDTH="228"$4,$f13,$6,$7LEFT="0" WIDTH="128"d1,d2,d3,d4,d5LEFT="135" WIDTH="228"$f12, $f13, $f14, $f15, $f16LEFT="0" WIDTH="128"d1,d2,d3,d4,d5,s1,s2,s3,s4LEFT="135" WIDTH="228"$f12, $f13, $f14, $f15, $f16, $f17, $f18,$f19,stackLEFT="0" WIDTH="128"d1,d2,d3,s1,s2,s3,n1,n2,n3LEFT="135" WIDTH="228"$f12, $f13, $f14, $f15, $f16, $f17, $10,$11, stackNext, you must restore registers that were saved in step 4. To restore general purpose registers:lw reg,framesize+frameoffset­N($sp)To restore the floating-point registers:l.[sd] reg,framesize+frameoffset­N($sp)Refer to step 4 for a discussion of the value of N.)Get the return address:lw $31,framesize+frameoffset($sp)Clean up the stack:addu framesizeReturn:j $31To end the procedure: .end procedurenameThe difference in stack frame usage for 64-bit operations can be summarized as followsThe portion of the argument structure beyond the initial eight doublewords is passed in memory on the stack, pointed to by the stack pointer at the time of call. The caller does not reserve space for the register arguments; the callee is responsible for reserving it if required (either adjacent to any caller-saved stack arguments if required, or elsewhere as appropriate). No requirement is placed on the callee either to allocate space and save the register parameters, or to save them in any particular place. LBL="" HELPID=""The Shape of DataID="07.link12"In most cases, high-level language routine and assembly routines communicate via simple variables: pointers, integers, booleans, and single- and double-precision real numbers. Describing the details of the various high-level data structures (arrays, records, sets, and so on) is beyond our scope here. If you need to access such a structure as an argument or as a shared global variable, refer to the MIPSpro Compiling, Debugging and Performance Tuning Guide.LBL="" HELPID=""ExamplesThis section contains the examples that illustrate program design rules. Each example shows a procedure written and C and its equivalent written in assembly language.The following example shows a non-leaf procedure. Notice that it creates a stackframe, and also saves its return address since it must put a new return address into register $31 when it invokes its callee:float
nonleaf(i, j)
   int i, *j;
   {
   double atof();
   int temp;

   temp = i - *j;
   if (i < *j) temp = -temp;
   return atof(temp);
   }
         .globl       nonleaf
 #   1   float
 #   2   nonleaf(i, j)
 #   3      int i, *j;
 #   4      {
         .ent        nonleaf 2
 nonleaf;
         subu        $sp, 24      ## Create stackframe
         sw          $31, 20($sp) ## Save the return
                                  ##  address
         .mask       0x80000000, -4
            .frame    $sp, 24, $31
 #  5        double atof();
 #  6        int temp;
 #  7
 #  8        temp = i - *j;
              lw      $2, 0($5)    ## Arguments are in                                    ##  $4 and $5
             subu     $3, $4, $2
 #  9        if (i < *j) temp = -temp;
             bge      $4, $2, $32  ## Note: $32 is a label,                                   ##  not a reg
             negu     $3, $3
$32:
 #  10       return atof(temp);
   move      $4, $3
   jal       atof
   cvt.s.    $f0, $f0             ## Return value goes in $f0
   lw        $31, 20($sp)         ## Restore return address
   addu      $sp, 24              ## Delete stackframe
   j         $31                  ## Return to caller
   .end      nonleaf   This example shows a leaf procedure that does not require stack space for local variables. Notice that it creates no stackframe, and saves no return address.int
leaf(p1, p2)
  int p1, p2;
  {
  return (p1 > p2) ? p1 : p2;
  }
              .globl        leaf
 #    1       int
 #    2       leaf(p1, p2)
 #    3         int p1, p2;
 #    4         {
              .ent          leaf2
leaf:
              .frame        $sp, 0, $31
 #    5         return (p1 > p2) ? p1 : p2;
               ble          $4, $5, $32    ## Arguments in                                           ##  $4 and $5
               move         $3, $4
               b            $33
$32:
               move         $3, $5
$33:
               move         $2, $3         ## Return value                                           ##  goes in $2
               j            $31            ## Return to                                           ##  caller
 #    6          }
               .end    leafThe next example shows a leaf procedure that requires stack space for local variables. Notice that it creates a stack frame, but does not save a return address.char
leaf_storage(i)
  int i;
  {
  char a[16];
  int j;
  for (j = 0; j < 10; j++)
    a[j] = `0' + j;
  for (j = 10; j < 16; j++)
    a[j] = `a' + j;
  return a[i];
  }

             .global        leaf_storage
 #    1      char
 #    2      leaf_storage(i)
 #    3        int i;
 #    4        {
             .ent           leaf_storage 2 ## "2" is the                                           ##  lexical level                                           ##  of the                                           ##  procedure.You                                           ##  may omit i.
leaf_storage:
             subu           $sp, 24           ## Create                                              ##  stackframe.
             .frame         $sp, 24, $31
 #    5        char a[16];
 #    6        int j;
 #    7    
 #    8        for (j = 0; j < 10; j++)
              sw            $0, 4($sp)
              addu          $3, $sp, 24
$32:
 #    9           a[j] = `0' + j;
              lw            $14, 4($sp)
              addu          $15, $14, 48
              addu          $24, $3, $14
              sb            $15, =16($24)
              lw            $25, 4($sp)
              addu          $8, $25, 1
              sw            $8, 4($sp)
              blt           $8, 10, $32
 #    10        for (j = 10; j < 16; j++)
              li            $9, 10
              sw            $9, 4($sp)
$33:
 #    11          a[j] = `a' + j;
              lw            $10, 4($sp)
              addu          $11, $10, 97
              addu          $12, $3, $10
              sb            $11, -16($12)
              lw            $13, 4($sp)
              addu          $14, $13, 1
              sw            $14, 4($sp)
              blt           $14, 16, $33









 #    12        return a[i];
              addu          $15, $3, $4     ## Argument is                                            ##  in $4.
              lbu           $2, -16($15)    ## Return value                                            ##  goes in $
              addu          $sp, 24         ## Delete                                            ##  stackframe
              j             $31             ## Return to                                            ##  caller.
              .end          leaf_storage  LBL="" HELPID=""Learning by DoingThe rules and parameter requirements that exist  between assembly language and other languages are varied and complex. The simplest approach to coding an interface between an assembly routine and a routine written in a high-level language is to do the following:Use the high-level language to write a skeletal version of the routine that you plan to code in assembly language.Compile the program using the ­S option, which creates an assembly language (.s) version of the compiled source file (the ­O option, though not required, reduces the amount of code generated, making the listing easier to read).Study the assembly-language listing and then, imitating the rules and conventions used by the compiler, write your assembly language code.LBL="8"Pseudo Op-CodesID="08.pseudo1"This chapter describes pseudo op-codes (directives). These pseudo op-codes influence the assembler's later behavior. In the text, boldface type specifies a keyword and italics represents an operand that you define.The assembler has the pseudo op-codes listed in IDREF="10139" TYPE="TABLE"Table 8-1.COLUMNS="2"LBL="8-1"Table 8-1 ID="10139"Pseudo Op-CodesLEFT="0" WIDTH="144"Pseudo-OpLEFT="150" WIDTH="189"DescriptionLEFT="0" WIDTH="144".ID="08.pseudo2"2byte expression1 [ , expression2 ] ... 
[ , expressionN]*LEFT="150" WIDTH="189"Truncates the expressions in the 
comma-separated list to 16-bit values and 
assembles the values in successive locations. 
The expressions must be absolute or  in the 
form of a label difference ( label1 - label2) if both 
labels are defined in the same section.This directive optionally can have the form 
expression1 [ : expression2 ]. The expression2 
replicates expression1's value expression2 
times. This directive does no automatic alignment. 
(*64-bit and N32 only)LEFT="0" WIDTH="144".ID="08.pseudo3"4byte expression1 [ , expression2 ] ... 
[ , expressionN]*LEFT="150" WIDTH="189"Truncates the expressions in the 
comma-separated list to 32-bit values and 
assembles the values in successive 
locations.The expressions must be absolute or 
in the form of a label difference ( label1 - label2) 
if both labels are defined in the same section.This directive optionally can have the form 
expression1 [ : expression2 ]. The expression2 
replicates expression1's value expression2 
times. This directive does no automatic alignment. 
(*64-bit and N32 only)LEFT="0" WIDTH="144".ID="08.pseudo4"8byte expression1 [ , expression2 ] ... 
[ , expressionN]*LEFT="150" WIDTH="189"Truncates the expressions in the 
comma-separated list to 64-bit values and 
assembles the values in successive locations. 
The expressions must be absolute or  in the 
form of a label difference ( label1 - label2) if both 
labels are defined in the same section.This directive optionally can have the form 
expression1 [ : expression2 ]. The expression2 
replicates expression1's value expression2 
times. This directive does no automatic 
alignment. (*64-bit and N32 only)LEFT="0" WIDTH="144".ID="08.pseudo5"aentname, symnoLEFT="150" WIDTH="189"Sets an alternate entry point for the current 
procedure. Use this information when you 
want to generate information for the 
debugger. It must appear inside an .ent/.end 
pair.LEFT="0" WIDTH="144".ID="08.pseudo6"alias reg1, reg2*LEFT="150" WIDTH="189"Indicates that memory reference through the 
two registers (reg1, reg2) will overlap. The 
compiler uses this form to improve instruction 
scheduling. (32-bit only.)LEFT="0" WIDTH="144".ID="08.pseudo7"align expressionLEFT="150" WIDTH="189"Advances the location counter to make the 
expression low order bits of the counter zero. 
Normally, the .half, .word, .float, and .double 
directives automatically align their data 
appropriately.  For example, .word does an 
implicit .align 2 (.double does an .align 3). You 
disable the automatic alignment feature with 
.align 0. The assembler reinstates automatic 
alignment at the next .text, .data, .rdata, or .sdata 
directive.Labels immediately preceding an automatic or 
explicit alignment are also realigned. For 
example, foo: .align 3; .word 0 is the same as 
.align 3; foo: .word 0.LEFT="0" WIDTH="144".ID="08.pseudo8"ascii string [, string]... LEFT="150" WIDTH="189"Assembles each string from the list into 
successive locations. The .ascii directive does 
not null pad the string. You MUST put 
quotation marks (") around each string. You 
can use the backslash escape characters. For a 
list of the backslash characters, see Chapter 4.LEFT="0" WIDTH="144".ID="08.pseudo9"asciiz string [, string]... LEFT="150" WIDTH="189"Assembles each string in the list into 
successive locations and adds a null. You can 
use the backslash escape characters. For a list 
of the backslash characters, see Chapter 4.LEFT="0" WIDTH="144"ID="08.pseudo10".asm0*LEFT="150" WIDTH="189"Tells the assembler's second pass that this 
assembly came from the first pass.For use by 
compilers) (*32-bit only.)LEFT="0" WIDTH="144".ID="08.pseudo11"bgnb symno*LEFT="150" WIDTH="189"Sets the beginning of a language block. For use 
by compilers. The .bgnb and .endb directives 
delimit the scope of a variable set. The scope 
can be an entire procedure, or it can be a nested 
scope (for example a "{}" block in the C 
language). The symbol number symno refers to 
a dense number in a .T file. For an explanation 
of .T files, see the MIPSpro Compiling, 
Debugging and Performance Tuning Guide. To set 
the end of a language block, see .endb. (*32-bit 
only.)LEFT="0" WIDTH="144".ID="08.pseudo12"byte expression1 [, expression2 ] ...[, expressionN]LEFT="150" WIDTH="189"Truncates the expressions from the 
comma-separated list to 8-bit values, and 
assembles the values in successive locations. 
The expressions must be absolute. The 
operands can optionally have the form: 
expression1 [ : expression2 ]. The expression2 
replicates expression1's value expression2 times.LEFT="0" WIDTH="144".ID="08.pseudo13"comm name, expression [alignment]LEFT="150" WIDTH="189"Unless defined elsewhere, name becomes a 
global common symbol at the head of a block 
of expression bytes of storage. The linker 
overlays like-named common blocks, using 
the maximum of the expressions. The 64-bit and 
N32 assembler also accepts an optional value 
which specifies the alignment of the symbol. LEFT="0" WIDTH="144".ID="08.pseudo14"cpadd regLEFT="150" WIDTH="189"Emits code that adds the value of "_gp" to reg. LEFT="0" WIDTH="144".ID="08.pseudo15"cpload regLEFT="150" WIDTH="189"Expands into the three instructions function 
prologue that sets up the $gp register. This 
directive is used by position-independent 
code.LEFT="0" WIDTH="144".ID="08.pseudo16"cplocal reg*LEFT="150" WIDTH="189"Causes the assembler to use reg instead of $gp 
as the context pointer. This directive is used by 
position-independent code.(*64-bit and N32 only)LEFT="0" WIDTH="144".ID="08.pseudo17"cprestore offsetLEFT="150" WIDTH="189"Causes the assembler to emit the following at 
the point where it occurs:sw $gp, offset ($sp)Also, causes the assembler to generate:lw $gp, offset ($sp)after every JAL or BAL operation. Offset 
should point to the saved register area as 
described in Chapter 7. This directive is used by position-independent 
code following the caller saved gp convention.LEFT="0" WIDTH="144"ID="08.pseudo18".cpreturn*LEFT="150" WIDTH="189"Causes the assembler to emit the following at 
the point where it occurs:ld $gp, offset ($sp)The offset is obtained from the previous 
.cpsetup pseudo-op.(*64-bit and N32 only)LEFT="0" WIDTH="144".ID="08.pseudo19"cpsetup reg1, {offset | reg2}, label*LEFT="150" WIDTH="189"Causes the assembler to emit the following at 
the point where it occurs:sd     $gp, offset ($sp)lui    $gp, 0 { label }daddiu $gp, $gp, 0 { label }daddu  $gp, $gp, reg1ld     $gp, offset ($sp)This sequence is used by 
position-independent code following the 
callee saved gp convention. It stores $gp in the 
saved register area and calculates the virtual 
address of label and places it in reg1. By 
convention, reg1 is $25 (t9).If reg2 is used instead of offset, $gp is saved 
and restored to and from this register.(*64-bit and N32 only)LEFT="0" WIDTH="144"ID="08.pseudo20".dataLEFT="150" WIDTH="189"Tells the assembler to add all subsequent data 
to the data section.LEFT="0" WIDTH="144".ID="08.pseudo21"double expression [ , expression2] ...[, expressionN] LEFT="150" WIDTH="189"Initializes memory to 64-bit floating point 
numbers. The operands optionally can have 
the form: expression1 [ : expression2 ]. The 
expression1 is the floating point value. The 
optional expression2 is a non-negative 
expression that specifies a repetition count. 
The expression2 replicates expression1's value 
expression2 times. This directive aligns its data 
and any preceding labels automatically to a 
double-word boundary. You can disable this 
feature by using .align 0.LEFT="0" WIDTH="144"ID="08.pseudo22".dword expression [ , expression2 ] ...[, expressionN] LEFT="150" WIDTH="189"Truncates the expressions in the 
comma-separated list to 64-bits and assembles 
the values in successive locations. The 
expressions must be absolute. The operands 
optionally can have the form: expression1 
[:expression2]. The expresssion2 replicates 
expression1's value expression2 number of 
times. The directive aligns its data and 
preceding labels automatically to a 
doubleword boundary. You can disable this 
feature by using .align 0.LEFT="0" WIDTH="144".ID="08.pseudo23"end [proc_name]LEFT="150" WIDTH="189"Sets the end of a procedure. Use this directive 
when you want to generate information for 
the debugger. To set the beginning of a 
procedure, see .ent.LEFT="0" WIDTH="144".ID="08.pseudo24"endb symno*LEFT="150" WIDTH="189"Sets the end of a language block. To set the 
beginning of a language block, see .bgnb. 
(*32-bit only.)LEFT="0" WIDTH="144".ID="08.pseudo25"endrLEFT="150" WIDTH="189"Signals the end of a repeat block. To start a 
repeat block, see .repeat.LEFT="0" WIDTH="144".ID="08.pseudo26"ent proc_nameLEFT="150" WIDTH="189"Sets the beginning of the procedure proc_name. 
Use this directive when you want to generate 
information for the debugger. To set the end of 
a procedure, see .end.LEFT="0" WIDTH="144".ID="08.pseudo27"extern name expressionLEFT="150" WIDTH="189"name is a global undefined symbol whose size 
is assumed to be expression bytes. The 
advantage of using this directive, instead of 
permitting an undefined symbol to become 
global by default, is that the assembler can 
decide whether to use the economical 
$gp-relative addressing mode, depending on 
the value of the ­G option. As a special case, if 
expression is zero, the assembler refrains from 
using $gp to address this symbol regardless of 
the size specified by ­G.LEFT="0" WIDTH="144".ID="08.pseudo28"err*LEFT="150" WIDTH="189"Signals an error. For use by compilers. Any 
compiler front-end that detects an error 
condition puts this directive in the input 
stream. When the assembler encounters a .err, 
it quietly ceases to assemble the source file. 
This prevents the assembler from continuing 
to process a program that is incorrect. (*32-bit 
only.)LEFT="0" WIDTH="144".ID="08.pseudo29"file file_number file_name_stringLEFT="150" WIDTH="189"Specifies the source file corresponding to the 
assembly instructions that follow. For use only 
by compilers, not by programmers; when the 
assembler sees this, it refrains from generating 
line numbers for dbx to use unless it also sees 
.loc directives.LEFT="0" WIDTH="144".ID="08.pseudo30"float expression1[ , expression2 ] ... [, expressionN]LEFT="150" WIDTH="189"Initializes memory to single precision 32-bit 
floating point numbers. The operands 
optionally can have the form: expression1[ : expression2 ]. The optional expression2 is a 
non-negative expression that specifies a 
repetition count. This optional form replicates 
expression1's value expression2 times. This 
directive aligns its data and preceding labels 
automatically to a word boundary. You can 
disable this feature by using .align 0.LEFT="0" WIDTH="144".ID="08.pseudo31"fmask mask offset LEFT="150" WIDTH="189"Sets a mask with a bit turned on for each 
floating point register that the current routine 
saved. The least-significant bit corresponds to 
register $f0. The offset is the distance in bytes 
from the virtual frame pointer at which the 
floating point registers are saved. The 
assembler saves higher register numbers 
closer to the virtual frame pointer. You must 
use .ent before .fmask and only one .fmask may 
be used per .ent. Space should be allocated for 
those registers specified in the .fmask.LEFT="0" WIDTH="144".ID="08.pseudo32"frame frame-register offset 
return_pc_registerLEFT="150" WIDTH="189"Describes a stack frame. The first register is the 
frame-register, the offset is the distance from 
the frame register to the virtual frame pointer, 
and the second register is the return program 
counter (or, if the first register is $0, this 
directive shows that the return program 
counter is saved four bytes from the virtual 
frame pointer). You must use .ent before .frame 
and only one .frame may be used per .ent. No 
stack traces can be done in the debugger 
without .frame.LEFT="0" WIDTH="144".ID="08.pseudo33"globl name LEFT="150" WIDTH="189"Makes the name external. If the name is 
defined otherwise (by its appearance as a 
label), the assembler will export the symbol; 
otherwise it will import the symbol. In 
general, the assembler imports undefined 
symbols (that is, it gives them the UNIX 
storage class "global undefined" and requires 
the linker to resolve them).LEFT="0" WIDTH="144".ID="08.pseudo34"gjaldefint_bitmask fp_bitmask*LEFT="150" WIDTH="189"Sets the masks defining the registers whose 
value is preserved during a procedure call. For 
use by compilers. See Table 1-1 for the default 
for integer saved registers. (*32-bit only.)LEFT="0" WIDTH="144"ID="08.pseudo35".gjalliveint_bitmask fp_bitmask*LEFT="150" WIDTH="189"Sets the default masks for live registers before 
a procedure call (A JAL instruction). For use 
by compilers. (*32-bit only.)LEFT="0" WIDTH="144"ID="08.pseudo36".gjrlive int_bitmask fp_bitmask*LEFT="150" WIDTH="189"Sets the default masks for live registers before 
a procedure's return (A JR instruction). For use 
by compilers. (*32-bit only.)LEFT="0" WIDTH="144"ID="08.pseudo37".gpword local-symLEFT="150" WIDTH="189"This directive is similar to .word except that the 
relocation entry for local-sym has the 
R_MIPS_GPREL32 type. After linkage, this 
results in a 32-bit value that is the distance 
between local-sym and gp. local-sym must be 
local. This directive is used by the code 
generator for PIC switch tables.LEFT="0" WIDTH="144".ID="08.pseudo38"half expression1 [ , expression2 ] ... {, expressionN]LEFT="150" WIDTH="189"Truncates the expressions in the 
comma-separated list to 16-bit values and 
assembles the values in successive locations. 
The expressions must be absolute. This 
directive optionally can have the form: 
expression1 [ : expression2 ]. The expression2 
replicates expression1's value expression2 
times. This directive automatically aligns its 
data appropriately. You can disable this 
feature by using .align 0.LEFT="0" WIDTH="144".ID="08.pseudo39"lab label_nameLEFT="150" WIDTH="189"Associates a named label with the current 
location in the program text. For use by 
compilers.LEFT="0" WIDTH="144".ID="08.pseudo40"lcomm name, expression LEFT="150" WIDTH="189"Makes the name's data type bss. The assembler 
allocates the named symbol to the bss area, and 
the expression defines the named symbol's 
length. If a .globl directive also specifies the 
name, the assembler allocates the named 
symbol to external bss. The assembler puts bss 
symbols in one of two bss areas. If the defined 
size is smaller than (or equal to) the size 
specified by the assembler or compiler's ­G 
command line option, the assembler puts the 
symbols in the sbss area and uses $gp to 
address the data.LEFT="0" WIDTH="144".ID="08.pseudo41"livereg int_bitmask fp_bitmask*LEFT="150" WIDTH="189"Affects the next jump instruction even if it is 
not the successive instruction. For use by 
compilers. The .livereg directive may come 
before any of the following instructions: JAL, 
JR, and SYSCALL. By default, external J 
instructions and JR instructions through a 
register other than $ra, are treated as external 
calls; that is; all registers are assumed live. The 
directive .livereg cannot appear before an 
external J (it will affect the next JR, JAL, or 
SYSCALL instead of the J instruction). .livereg 
may appear before a JR instruction through a 
register other than $ra. The directive can't be 
used before a BREAK instruction. For BREAK 
instructions, the assembler also assumes all 
registers are live..livereg notes to the assembler which registers 
are live before a jump, in order to avoid unsafe 
optimizations by the reorganizer. The 
directive .livereg takes two arguments, 
int_bitmask, and fp_bitmask, which are 32 bit 
bitmasks with a bit turned on for each register 
that is live before a jump. The most significant 
bit corresponds to register $0 (which is 
opposite to that used in other assembly 
directives, .mask, .fmask). The first bitmap 
indicates live integer registers and the second 
indicates live FPs. (*32-bit only)LEFT="0" WIDTH="144".ID="08.pseudo42"loc file_number line_number 
[column]LEFT="150" WIDTH="189"Specifies the source file and the line within 
that file that corresponds to the assembly 
instructions that follow. For use by compilers. 
The assembler ignores the file number when 
this directive appears in the assembly source 
file. Then, the assembler assumes that the 
directive refers to the most recent .file 
directive. The 64-bit and N32 assembler also 
supports an optional value that specifies the 
column number.LEFT="0" WIDTH="144".ID="08.pseudo43"mask mask, offset LEFT="150" WIDTH="189"Sets a mask with a bit turned on for each 
general purpose register that the current 
routine saved. For use by compilers. Bit one 
corresponds to register $1. The offset is the 
distance in bytes from the virtual frame 
pointer where the registers are saved. The 
assembler saves higher register numbers 
closer to the virtual frame pointer. Space 
should be allocated for those registers 
appearing in the mask. If bit zero is set it is 
assumed that space is allocated for all 31 
registers regardless of whether they appear in 
the mask.LEFT="0" WIDTH="144"ID="08.pseudo44"nada*LEFT="150" WIDTH="189"Tells the assembler to put in an instruction that 
has no effect on the machine state. It has the 
same effect as nop (described below), but it 
produces more efficient code on an R8000. 
(*64-bit and N32 only)LEFT="0" WIDTH="144".ID="08.pseudo45"noalias reg1, reg2*LEFT="150" WIDTH="189"Register1 and register2, when used as indexed 
registers to memory will never point to the 
same memory. The assembler will use this as a 
hint to make more liberal assumptions about 
resource dependency in the program. To 
disable this assumption, see .alias. (*32-bit 
only.)LEFT="0" WIDTH="144"ID="08.pseudo46"nopLEFT="150" WIDTH="189"Tells the assembler to put in an instruction that 
has no effect on the machine state. While 
several instructions cause no-operation, the 
assembler only considers the ones generated 
by the nop directive to be wait instructions. 
This directive puts an explicit delay in the 
instruction stream.Note: Unless you use ".set noreorder", the 
reorganizer may eliminate unnecessary "nop" 
instructions.LEFT="0" WIDTH="144".ID="08.pseudo47"option optionsLEFT="150" WIDTH="189"Tells the assembler that certain options were 
in effect during compilation. (These options 
can, for example, limit the assembler's 
freedom to perform branch optimizations.) 
This option is intended for 
compiler-generated .s files rather than for 
hand-coded ones.LEFT="0" WIDTH="144"ID="08.pseudo48".origin expression*LEFT="150" WIDTH="189"Specifiess the current offset in a section to the 
value of expression. (*64-bit and N32 only)LEFT="0" WIDTH="144".ID="08.pseudo49"repeat expression LEFT="150" WIDTH="189"Repeats all instructions or data between the 
.repeat directive and the .endr directive. The 
expression defines how many times the data 
repeats. With the .repeat directive, you cannot 
use labels, branch instructions, or values that 
require relocation in the block. To end a .repeat, 
see .endr.LEFT="0" WIDTH="144"ID="08.pseudo50".rdataLEFT="150" WIDTH="189"Tells the assembler to add subsequent data 
into the rdata section.LEFT="0" WIDTH="144"ID="08.pseudo51".sdataLEFT="150" WIDTH="189"Tells the assembler to add subsequent data to 
the sdata section.LEFT="0" WIDTH="144".ID="08.pseudo52"section name [, section type, section 
flags, section entry size, section 
alignment]*LEFT="150" WIDTH="189"Instructs the assembler to create a section with 
the given name and optional attributes. Legal section type values are denoted by 
variables prefixed by SHT_ in <elf.h>.Legal section flags values are denoted by 
variables prefixed by SHF_ in <elf.h>.The section entry size specifies the size of each 
entry in the section. For example, it is 4 for .text 
sections.The section alignment specifies the byte 
boundary requirement for the section. For 
example, it is 16 for .text sections. (*64-bit and N32 only)LEFT="0" WIDTH="144".ID="08.pseudo53"set option LEFT="150" WIDTH="189"Instructs the assembler to enable or to disable 
certain options. Use .set options only for 
hand-crafted assembly routines. The 
assembler has these default options: reorder, 
macro, and at. You can specify only one option 
for each .set directive. You can specify these .set 
options:\The reorder option lets the assembler reorder 
machine language instructions to improve 
performance. The noreorder option prevents 
the assembler from reordering machine 
language instructions. If a machine language 
instruction violates the hardware pipeline 
constraints, the assembler issues a warning 
message.The bopt/nobopt option lets the assembler 
perform branch optimization. This involves 
moving an instruction that is the target of a 
branch or jump instruction into the delay slot; 
this is performed only if no unpredictable side 
effects can occur.The macro option lets the assembler generate 
multiple machine instructions from a single 
assembler instruction.The nomacro option causes the assembler to 
print a warning whenever an assembler 
operation generates more than one machine 
language instruction. You must select the 
noreorder option before using the nomacro 
option; otherwise, an error results.LEFT="0" WIDTH="144".ID="08.pseudo54"set option (continued)LEFT="150" WIDTH="189"The at option lets the assembler use the $at 
register for macros, but generates warnings if 
the source program uses $at. When you use the 
noat option and an assembler operation 
requires the $at register, the assembler issues a 
warning message; however, the noat option 
does let source programs use $at without 
issuing warnings.The nomove option tells the assembler to mark 
each subsequent instruction so that it cannot 
be moved during reorganization. Because the 
assembler can still insert nop instructions 
where necessary for pipeline constraints, this 
option is less stringent than noreorder. The 
assembler can still move instructions from 
below the nomove region to fill delay slots 
above the region or vice versa. The nomove 
option has part of the effect of the "volatile" C 
declaration; it prevents otherwise 
independent loads or stores from occurring in 
a different order than intended.The move option cancels the effect of nomove.The notransform option tells the assembler to 
mark each subsequent instruction so that it 
cannot be transformed by pixie(1), into an 
equivalent set of instructions. For an overview 
of pixie(1)  see the MIPSpro Compiling, 
Debugging, and Performance Tuning Guide.The transform option cancels the effect of 
notransform.LEFT="0" WIDTH="144".size name, expressionLEFT="150" WIDTH="189"Specifiess the size of an object denoted by name to the value of expression.LEFT="0" WIDTH="144"ID="08.pseudo55".space expressionLEFT="150" WIDTH="189"Advances the location counter by the value of 
the specified expression bytes. The assembler 
fills the space with zeros.LEFT="0" WIDTH="144".ID="08.pseudo56"struct expression LEFT="150" WIDTH="189"This permits you to lay out a structure using 
labels plus directives like .word, .byte, and so 
forth. It ends at the next segment directive 
(.data, .text, etc.). It does not emit any code or 
data, but defines the labels within it to have 
values which are the sum of expression plus 
their offsets from the .struct itself.LEFT="0" WIDTH="144"(ID="08.pseudo57"symbolic equate)LEFT="150" WIDTH="189"Takes one of these forms: name = expression or 
name = register. You must define the name only 
once in the assembly, and you cannot redefine 
the name. The expression must be computable 
when you assemble the program, and the 
expression must involve operators, constants, 
and equated symbols. You can use the name as 
a constant in any later statement.LEFT="0" WIDTH="144"ID="08.pseudo58".textLEFT="150" WIDTH="189"Tells the assembler to add subsequent code to 
the text section. (This is the default.) LEFT="0" WIDTH="144".ID="08.pseudo59"type name, value*LEFT="150" WIDTH="189"Specifies the elf type of an object denoted by 
name to value. Legal elf type values are 
denoted by variables prefixed by STT_ in 
<elf.h>. (*64-bit and N32 only)LEFT="0" WIDTH="144".ID="08.pseudo60"verstamp major minorLEFT="150" WIDTH="189"Specifies the major and minor version 
numbers (for example, version 0.15 would be 
.verstamp 0 15).LEFT="0" WIDTH="144".ID="08.pseudo61"vreg register offset symno* LEFT="150" WIDTH="189"Describes a register variable by giving the 
offset from the virtual frame pointer and the 
symbol number symno (the dense number) of 
the surrounding procedure. For use by 
compilers. (*32-bit only.)LEFT="0" WIDTH="144"ID="08.pseudo62".weakextweak_name [strong_name]LEFT="150" WIDTH="189"Defines a weak external name and optionally  
associates it with the strong_name.LEFT="0" WIDTH="144".ID="08.pseudo63"word expression1 [, expression2 ] ... [, expressionN]LEFT="150" WIDTH="189"Truncates the expressions in the 
comma-separated list to 32-bits and assembles 
the values in successive locations. The 
expressions must be absolute. The operands 
optionally can have the form: expression1 [ : expression2 ]. The expression2 replicates 
expression1's value expression2 times. This 
directive aligns its data and preceding labels 
automatically to a word boundary. You can 
disable this feature by using .align 0.&spaceIDREF="05.instruct34"Coprocessor Interface Summary(symbolic equate)IDREF="08.pseudo57"Pseudo Op-Codes-G valuelink editorIDREF="04.lex18"Section and Location CountersaddressdescriptionIDREF="02.address34"Address DescriptionsdescriptionsIDREF="02.address36"Address DescriptionsformatIDREF="02.address32"Address FormatsaddressingIDREF="02.address1"Addressing alignmentIDREF="02.address2"Addressing .aent name, symnoIDREF="08.pseudo5"Pseudo Op-Codes.alias IDREF="08.pseudo6"Pseudo Op-Codes.align IDREF="08.pseudo7"Pseudo Op-Codesaligned dataload and store instructionsIDREF="02.address21"Addressing alignmentaddressingIDREF="02.address3"Addressing .asciizIDREF="08.pseudo9"Pseudo Op-CodesIDREF="08.pseudo8"Pseudo Op-Codes.asm0IDREF="08.pseudo10"Pseudo Op-CodesassemblertokensIDREF="04.lex3"Tokens.bgnb IDREF="08.pseudo11"Pseudo Op-Codesbranch instructionsfilling delay slotsIDREF="05.instruct5"Instruction ClassesIDREF="05.instruct7"Instruction Classes.byte IDREF="08.pseudo12"Pseudo Op-Codes.commIDREF="08.pseudo15"Pseudo Op-CodesIDREF="08.pseudo13"Pseudo Op-CodesIDREF="08.pseudo17"Pseudo Op-CodesIDREF="08.pseudo14"Pseudo Op-CodescommentsIDREF="04.lex4"Commentscomputational instructionsIDREF="05.instruct4"Instruction ClassesIDREF="05.instruct22"Computational Instructionsdescriptions - tableIDREF="05.instruct23"Computational Instruction DescriptionsconstantsIDREF="04.lex9"Constantsfloating pointIDREF="04.lex13"Floating Point ConstantsscalarIDREF="04.lex10"Scalar ConstantsstringIDREF="04.lex15"String Constantsconventionlinkage and register useIDREF="07.link7"Register Use and LinkageIDREF="07.link6"Register Use and Linkageconventionsdata typesIDREF="04.lex35"Data Typesexpression operatorsIDREF="04.lex32"Expression OperatorsIDREF="04.lex34"Expression OperatorsexpressionsIDREF="04.lex26"ExpressionslexicalIDREF="04.lex1"Lexical ConventionslinkageIDREF="07.link2"Linkage ConventionsprecedenceIDREF="04.lex28"PrecedencestatementsIDREF="04.lex19"Statementscoprocessor instructionnotationIDREF="06.coproc3"Instruction Notationcoprocessor instruction setIDREF="06.coproc2"Coprocessor Instruction Set coprocessor interface instructionsIDREF="05.instruct31"Coprocessor Interface Instructionsdescription ofIDREF="05.instruct36"Coprocessor Interface Instruction Descriptions counterssections and locationsIDREF="04.lex16"Section and Location Counters.dataIDREF="08.pseudo20"Pseudo Op-Codesdata typesconventionsIDREF="04.lex36"Data TypesdescriptionaddressIDREF="02.address35"Address Descriptionsdescriptionsload instructionsIDREF="05.instruct18"Load Instruction Descriptionsdivision by zeroIDREF="06.coproc25"Division-by-zero Exception.doubleIDREF="08.pseudo21"Pseudo Op-Codes.dwordIDREF="08.pseudo22"Pseudo Op-Codes.endIDREF="08.pseudo23"Pseudo Op-Codes.endrIDREF="08.pseudo25"Pseudo Op-Codes.endb IDREF="08.pseudo24"Pseudo Op-CodesendiannessIDREF="01.reg4" Register Format    .ent IDREF="08.pseudo26"Pseudo Op-Codes.errIDREF="08.pseudo28"Pseudo Op-Codesexceptiondivision by zeroIDREF="06.coproc26"Division-by-zero Exceptionunimplemented operationIDREF="06.coproc34"Unimplemented Operation Exceptionexception trap processingIDREF="06.coproc21"Exception Trap ProcessingexceptionsIDREF="03.except1"Exceptionsfloating pointIDREF="03.except4"Floating Point Exceptions main processorIDREF="03.except2"Main Processor ExceptionsexecptioninexactIDREF="06.coproc32"Inexact Exceptioninvalid operationIDREF="06.coproc23"Invalid Operation ExceptionoverflowIDREF="06.coproc28"Overflow Exceptiontrap processingIDREF="06.coproc22"Exception Trap ProcessingunderflowIDREF="06.coproc30"Underflow Exceptionexpressiontype propagationIDREF="04.lex38"Type Propagation in Expressionsexpression operatorsIDREF="04.lex33"Expression OperatorsexpressionsIDREF="04.lex27"ExpressionsprecedenceIDREF="04.lex30"PrecedenceIDREF="04.lex31"Precedence.extern name expressionIDREF="08.pseudo27"Pseudo Op-Codes.file IDREF="08.pseudo29"Pseudo Op-Codes.float IDREF="08.pseudo30"Pseudo Op-Codesfloating pointcomputational - descriptionIDREF="06.coproc10"Floating-Point Computational Instruction Descriptionscomputational - formatIDREF="06.coproc9"Floating-Point Computational Formatscontrol register IDREF="06.coproc20"Control and Status Register exceptionsIDREF="03.except3"Floating Point Exceptions instruction formatIDREF="06.coproc6"Floating-Point FormatsinstructionsIDREF="06.coproc4"Floating-Point Instructionsload and storeIDREF="06.coproc8"Floating-Point Load and Store Formatsmove instruction - description of IDREF="06.coproc17"Floating-Point Move Instruction Descriptionsmove instructions - formatIDREF="06.coproc15"Floating-Point Move FormatsregistersIDREF="01.reg9"Floating Point Registers relational instruction - descriptionIDREF="06.coproc14"Floating-Point Relational Instruction Descriptionsrelational instruction formatsIDREF="06.coproc13"Floating-Point Relational Instruction Formatsrelational operationsIDREF="06.coproc11"Floating-Point Relational OperationsroundingIDREF="06.coproc35"Floating-Point Roundingfloating point constantsIDREF="04.lex12"Floating Point Constants.fmaskIDREF="08.pseudo31"Pseudo Op-CodesformataddressIDREF="02.address33"Address Formatsformatsload and storeIDREF="05.instruct15"Load and Store Instructions.frameIDREF="08.pseudo32"Pseudo Op-Codes.galiveIDREF="08.pseudo35"Pseudo Op-Codesgeneral registersIDREF="01.reg6"General Registers .gjaldefIDREF="08.pseudo34"Pseudo Op-Codes.gjrliveIDREF="08.pseudo36"Pseudo Op-Codes.globlIDREF="08.pseudo33"Pseudo Op-Codes.half IDREF="08.pseudo38"Pseudo Op-CodesidentifiersIDREF="04.lex6"Identifiersinexact exceptionIDREF="06.coproc31"Inexact Exceptioninstruction setIDREF="05.instruct1"The Instruction SetcoprocessorIDREF="06.coproc1"Coprocessor Instruction Set instructionsclasses ofIDREF="05.instruct2"Instruction ClassescomputationalIDREF="05.instruct21"Computational Instructionsconstraints and rulesIDREF="05.instruct11"Reorganization Constraints and Rules IDREF="05.instruct10"Reorganization Constraints and Rules coprocessor interfaceIDREF="05.instruct32"Coprocessor Interface Instructionscoprocessor interface - descriptionIDREF="05.instruct33"Coprocessor Interface InstructionsIDREF="05.instruct35"Coprocessor Interface Instruction Descriptions coprocessor interface formatIDREF="05.instruct34"Coprocessor Interface Summaryfloating pointIDREF="06.coproc5"Floating-Point Instructionsinstruction notationIDREF="05.instruct13"Instruction Notation jump and branchIDREF="05.instruct24"Jump and Branch Instructionsload and store - unaligned dataIDREF="02.address5"Addressing miscellaneous tasksIDREF="05.instruct30"Special Instructions reorganization rulesIDREF="05.instruct9"Reorganization Constraints and Rules specialIDREF="05.instruct28"Special Instructions invalid operation exceptionIDREF="06.coproc24"Invalid Operation Exceptionjump and branch instructionsIDREF="05.instruct6"Instruction ClassesIDREF="05.instruct25"Jump and Branch InstructionsdescriptionsIDREF="05.instruct27"Jump and Branch Instruction DescriptionsformatsIDREF="05.instruct26"Jump and Branch Instructionskeyword statementsIDREF="04.lex25"Keyword Statements.lab IDREF="08.pseudo37"Pseudo Op-CodesIDREF="08.pseudo39"Pseudo Op-Codeslabel definitionsstatementsIDREF="04.lex20"Label Definitions.lcommIDREF="08.pseudo40"Pseudo Op-Codesleaf routinesIDREF="07.link9"The Stack Framelexical conventionsIDREF="04.lex2"Lexical Conventionslink editor-G optionIDREF="04.lex17"Section and Location CounterslinkageconventionsIDREF="07.link1"Linkage Conventionsprogram designIDREF="07.link4"Program Designregister useIDREF="07.link5"Register Use and Linkage.liveregIDREF="08.pseudo41"Pseudo Op-Codes.locIDREF="08.pseudo42"Pseudo Op-Codesload and storefloating pointIDREF="06.coproc7"Floating-Point Load and Store Formatsload and store instructionsformatsIDREF="05.instruct14"Load and Store Instructionsload instructionsdelayedIDREF="05.instruct3"Instruction ClassesdescriptionIDREF="05.instruct17"Load Instruction Descriptionslb (load byte)IDREF="02.address26"Addressing lbu (load byte unsigned)IDREF="02.address27"Addressing lh (load halfword)IDREF="02.address24"Addressing lhu (load halfword unsigned)IDREF="02.address25"Addressing lw (load word)IDREF="02.address23"Addressing IDREF="02.address22"Addressing lwl (load word left)IDREF="02.address6"Addressing IDREF="02.address7"Addressing lwr (load word right)IDREF="02.address8"Addressing IDREF="02.address9"Addressing ulh (unaligned load halfword unsigned)IDREF="02.address17"Addressing ulh (unaligned load halfword)IDREF="02.address16"Addressing ulw (unaligned load word)IDREF="02.address14"Addressing IDREF="02.address15"Addressing .maskIDREF="08.pseudo43"Pseudo Op-Codesmove instructionsfloating pointIDREF="06.coproc16"Floating-Point Move FormatsnoaliasIDREF="08.pseudo45"Pseudo Op-Codesnon-leaf routinesIDREF="07.link10"The Stack FramenopIDREF="08.pseudo59"Pseudo Op-CodesIDREF="08.pseudo48"Pseudo Op-CodesIDREF="08.pseudo3"Pseudo Op-CodesIDREF="08.pseudo62"Pseudo Op-CodesIDREF="08.pseudo4"Pseudo Op-CodesIDREF="08.pseudo16"Pseudo Op-CodesIDREF="08.pseudo52"Pseudo Op-CodesIDREF="08.pseudo18"Pseudo Op-CodesIDREF="08.pseudo19"Pseudo Op-CodesIDREF="08.pseudo44"Pseudo Op-CodesIDREF="08.pseudo46"Pseudo Op-CodesIDREF="08.pseudo2"Pseudo Op-Codesnull statementsIDREF="04.lex22"Null Statements.optionIDREF="08.pseudo47"Pseudo Op-Codesoverflow exceptionIDREF="06.coproc27"Overflow ExceptionperformancemaximizingIDREF="05.instruct12"Reorganization Constraints and Rules precedence in expressionsIDREF="04.lex29"Precedenceprogram designlinkageIDREF="07.link3"Program Designpseudo op-codesIDREF="08.pseudo1"Pseudo Op-Codes.rdataIDREF="08.pseudo50"Pseudo Op-CodesregisterIDREF="01.reg1"RegistersendiannessIDREF="01.reg3" Register Format    formatIDREF="01.reg2" Register Format    registersfloating pointIDREF="01.reg10"Floating Point Registers generalIDREF="01.reg5"General Registers specialIDREF="01.reg8"Special Registers relational operationsfloating pointIDREF="06.coproc12"Floating-Point Relational Operations.repeatIDREF="08.pseudo49"Pseudo Op-Codesscalar constantsIDREF="04.lex11"Scalar Constants.sdataIDREF="08.pseudo51"Pseudo Op-Codes.setIDREF="08.pseudo54"Pseudo Op-CodesIDREF="08.pseudo53"Pseudo Op-Codesshape of dataIDREF="07.link12"The Shape of Data.spaceIDREF="08.pseudo55"Pseudo Op-Codesspecial instructionsIDREF="05.instruct8"Instruction ClassesIDREF="05.instruct29"Special Instructions special registersIDREF="01.reg7"Special Registers stack frameIDREF="07.link8"The Stack Framestack organization- figureIDREF="07.link11"The Stack FramestatementskeywordIDREF="04.lex24"Keyword Statementslabel definitionsIDREF="04.lex21"Label DefinitionsnullIDREF="04.lex23"Null Statementsstore instructionsdescriptionIDREF="05.instruct19"Store Instruction Descriptionsdescription - tableIDREF="05.instruct20"Store Instruction DescriptionsformatIDREF="05.instruct16"Load and Store Instructionssb (store byte)IDREF="02.address31"Addressing sh (store halfword)IDREF="02.address30"Addressing sw (store word)IDREF="02.address28"Addressing IDREF="02.address29"Addressing swl (store word left)IDREF="02.address11"Addressing IDREF="02.address10"Addressing swr (store word right)IDREF="02.address13"Addressing IDREF="02.address12"Addressing ush (unaligned store halfword)IDREF="02.address20"Addressing usw (unaligned store word)IDREF="02.address19"Addressing IDREF="02.address18"Addressing string constantsIDREF="04.lex14"String Constants.structIDREF="08.pseudo56"Pseudo Op-Codessystem controlinstruction descriptionsIDREF="06.coproc19"System Control Coprocessor Instruction Descriptionsinstruction formatsIDREF="06.coproc18"System Control Coprocessor Instruction Formats.textIDREF="08.pseudo58"Pseudo Op-CodestokenscommentsIDREF="04.lex5"CommentsconstantsIDREF="04.lex8"ConstantsidentifiersIDREF="04.lex7"Identifierstype propagation in expressionIDREF="04.lex37"Type Propagation in Expressionsunaligned dataload and store instructionsIDREF="02.address4"Addressing underflow exceptionIDREF="06.coproc29"Underflow Exceptionunimplemented operation exceptionIDREF="06.coproc33"Unimplemented Operation Exception.verstampIDREF="08.pseudo60"Pseudo Op-Codes.vregIDREF="08.pseudo61"Pseudo Op-Codes.wordIDREF="08.pseudo63"Pseudo Op-Codes