#EDIR DATA#
LANG=CDeveloper Magic‘: Debugger User's GuideDocument Number 007-2579-002CONTRIBUTORSWritten by Douglas B. O'Morain, John Stearns, and Carol GearyIllustrated by Douglas B. O'Morain, John Stearns, and Carol GearyEdited by Christina CaryProduction by Laura CooperEngineering contributions by David Henke, Stuart Liroff, Song Liang, Ashok Mouli, Michey Mehta, Anil Pal, Kim Rachmeler, Jack Repenning, Krishna Sethuraman, Ravi Shankar, John Templeton, Shankar Unni, and Mike Yang© Copyright 1995, Silicon Graphics, Inc.name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' All Rights ReservedThis document contains proprietary and confidential information of Silicon Graphics, Inc. The contents of this document may not be disclosed to third parties, copied, or duplicated in any form, in whole or in part, without the prior written permission of Silicon Graphics, Inc.RESTRICTED RIGHTS LEGENDUse, duplication, or disclosure of the technical data contained in this document by the Government is subject to restrictions as set forth in subdivision (c) (1) (ii) of the Rights in Technical Data and Computer Software clause at DFARS 52.227-7013 and/or in similar or successor clauses in the FAR, or in the DOD or NASA FAR Supplement. Unpublished rights reserved under the Copyright Laws of the United States. Contractor/manufacturer is Silicon Graphics, Inc., 2011 N. Shoreline Blvd., Mountain View, CA 94043-1389.Silicon Graphics and IRIS are registered trademarks and IRIX, IRIS IM, IRIS ViewKit, Indigo Magic, and Indigo Magic Desktop, are trademarks of Silicon Graphics, Inc. Open Software Foundation, Motif, OSF, OSF/Motif are trademarks of the Open Software Foundation, Inc. PostScript is a registered trademark of Adobe Systems, Inc.IntroductionThis guide describes the Debugger. The Debugger is part of ProDev WorkShop, a suite of graphical, interactive, software engineering tools designed especially for programmers who develop and maintain C, C++, Fortran, and Ada libraries and applications.LBL="" HELPID=""What This Guide ContainsThis guide contains the following chapters:IDREF="40971" TYPE="TITLE"Chapter 1, "Getting Started with the WorkShop Debugger" presents an overview of the ProDev Debugger, including how the Debugger is typically applied, a road map of the commands available from the Debugger Main View window, and a summary of the Debugger command line interface.IDREF="34853" TYPE="TITLE"Chapter 2, "Managing Source Files" presents the details for accessing source code files from the Debugger.IDREF="21883" TYPE="TITLE"Chapter 3, "A Short Debugger Tutorial" provides a tutorial to introduce you to the major features of the ProDev Debugger.IDREF="25908" TYPE="TITLE"Chapter 4, "Setting Traps" describes the facilities for setting stop traps and sample traps from the Debugger Main View, Source View, the Trap Manager, the Signal Panel, the Syscall Panel, and the Debugger command line interface.IDREF="25765" TYPE="TITLE"Chapter 5, "Controlling Process Execution" describes how to control process execution in a debugging session through the Debugger Main View control panel, the PC menu, Execution View, and the Debugger command line interface.IDREF="24462" TYPE="TITLE"Chapter 6, "Examining Debugger Data" presents reference information for the high-level Debugger views, which let you examine the Call Stack expressions, variables, arrays, and data structures. The chapter also describes how you can access debugger data through the Debugger command line interface.IDREF="39823" TYPE="TITLE"Chapter 7, "Debugging with Fix+Continue: A Tutorial," teaches you to perform the basic tasks that the Fix and Continue utility allows, such as making changes to functions and running the program with compiling or linking. Each task description is accompanied by a corresponding tutorial session.IDREF="12096" TYPE="TITLE"Chapter 8, "Detecting Heap Corruption" presents techniques for solving heap corruption problems and includes a tutorial.IDREF="37759" TYPE="TITLE"Chapter 9, "Multiple Process Debugging" describes how to use the Debugger Multiprocess View to debug programs with multiple processes.IDREF="97409" TYPE="TITLE"Chapter 10, "Using the X/Motif Analyzer: A Tutorial," provides a tutorial to introduce you to the major features of the X/Motif analyzer.IDREF="46334" TYPE="TITLE"Appendix A, "Debugger Reference" contains a complete description of the Debugger's graphical user and command-line interfaces.IDREF="50420" TYPE="TITLE"Appendix B, "Using the Build Manager," describes the Build Manager, the tool for performing builds from ProDev. Two windows comprise the Build Manager:Build View for watching compiles and correcting errorsBuild Analyzer for viewing build dependency relations between filesLBL="" HELPID=""What You Should Know Before Reading This GuideThis guide assumes that you're familiar with C, C++, and object-oriented programming.ID="0Intro1"LBL="" HELPID=""Related InformationThe Debugger is layered on the core ProDev WorkShop toolset (available from Silicon Graphics, Inc.). For further information about related tools, refer to the following documents:Developer Magic Overview, which provides an overview of the Developer Magic/ProDev toolset.Developer Magic: Static Analyzer and Browser User's Guide, which contains detailed information on how to use the static analyzer.Developer Magic: Performance Analyzer and Tester User's Guide, which contains detailed information on how to use the performance analyzer.C++ Programmer's Guide, which describes the Silicon Graphics C++ programming environment.Ada Programmer's Guide, which describes the Silicon Graphics C++ programming environment.IRIS ViewKit User's Guide, which describes how to create programs using IRIS ViewKit, a C++ toolkit that provides commonly needed facilities for applications based on the IRIS user interface toolkit.MIPSpro Compiling, Debugging and Performance Tuning, which discusses how to compile, debug, and tune the performance of programs written in the Silicon Graphics development environment (C, Fortran, and C++).LBL="" HELPID=""ConventionsBelow are the typographical and graphic conventions used in this guide:ID="0Intro2"Boldname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Functions, option flags, and classes.Italicsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Filenames, button names, field names, variables, emphasis, glossary terms, and IRIX commands.Regularname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Menu and window names, data types, keywords, and text."Quoted"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Menu choices.Fixed-widthname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Code examples and command syntax.Bold fixed-widthname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'User input. Nonprinting <keys> are bracketed. Graphic conventionname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Pull-down or popup menus.LBL="1"ID="40971"Getting Started with the WorkShop DebuggerThe WorkShop Debugger is a UNIX source-level debugging tool that provides special windows (views) for displaying program data and execution status. These views update as the program executes. This chapter presents an overview of the WorkShop Debugger and is divided into these sections:IDREF="22764" TYPE="TITLE""Typical Debugger Usage"IDREF="81699" TYPE="TITLE""Customizing the Debugger"LBL="" HELPID=""ID="22764"Typical Debugger UsageThis section provides a general description of debugging software with WorkShop. It covers these topics:IDREF="14840" TYPE="TITLE""Starting and Exiting the Debugger"IDREF="42337" TYPE="TITLE""Using the Debugger From a Remote Host"IDREF="38404" TYPE="TITLE""Using Main View"IDREF="25208" TYPE="TITLE""Setting Traps"IDREF="26027" TYPE="TITLE""Inspecting Debugger Data"IDREF="17249" TYPE="TITLE""Changing Source Code"IDREF="28739" TYPE="TITLE""Updating and Saving Views"IDREF="25532" TYPE="TITLE""Integration With Other WorkShop Tools"LBL="" HELPID=""ID="14840"Starting and Exiting the DebuggerTo start the Debugger, you use the following syntax:ID="1GStartDebug1"cvd [-pid pid] [-host host] [executable [corefile]] [&]The -pid option lets you attach the Debugger to a running process. You can use this to determine why a live process is in a loop.The argument executable is the name of the executable file for the process you want to run. It is optional; you can invoke the Debugger first and specify the executable later.You can also invoke the Debugger and specify a core file (with its executable) to try to determine why a program crashed.To exit the Debugger, select "Exit" from the Admin menu in the Main View window. You have two other options: you can type ID="1GStartDebug2"quit at the Debugger command line or press <Ctrl-c> where you first entered cvd into a terminal. You can also double-click the window system menu, or select its "Quit" entry.LBL="" HELPID=""ID="42337"Using the Debugger From a Remote HostThe -host option  lets you specify a remote host on which the target executable will be run; the Debugger runs locally. This option is useful ifyou don't want the Debugger windows to interfere with the application you are debuggingyou are supporting an application remotelyyou don't want to use the Debugger on the target machine for some other reasonLBL="" HELPID=""ID="38404"Using Main View Starting the Debugger with an executable brings up the Main View window, loaded with the source code, and ready to run the process with any specified arguments. You perform most of your work in Main View, which providesID="1GStartDebug3"a menu bar for performing Main View functions and for accessing other viewsa control panel for specifying and controlling the process to be debuggeda source code display area for inspecting the source codeID="1GStartDebug4"a status line for viewing the state of the programID="1GStartDebug5"the Debugger command line for entering special debugging commands (see ID="1GStartDebug6"IDREF="76970" TYPE="TITLE""Debugger Command Line" for the syntax) The major areas of the Main View window are shown in IDREF="62188" TYPE="GRAPHIC"Figure 1-1.FILE="1GStartDebug4.gif" POSITION="INLINE" SCALE="FALSE"LBL="1-1"Figure 1-1 ID="62188"Major Areas of the Main View WindowLBL="" HELPID=""ID="25208"Setting TrapsA major part of the debugging process is inspecting data at points during execution. A trap is a mechanism for gathering this data. A ID="1GStartDebug7"stop trapID="1GStartDebug8" halts the process so that you can manually examine data. A sample trapID="1GStartDebug9" collects specified performance data without stopping.The Debugger lets you set traps:at a line in a file (breakpoint)ID="1GStartDebug10"at an instruction addresson entry to or exit from a functionwhen a signal is receivedID="1GStartDebug11"when a system call is made, at either the entry or exit point ID="1GStartDebug12"when a given variable or address is written to, read from, or executed (watchpoint)ID="1GStartDebug13"at set time intervals (pollpoint)ID="1GStartDebug14"For more information on traps, refer to IDREF="25908" TYPE="TITLE"Chapter 4, "Setting Traps."LBL="" HELPID=""ID="26027"Inspecting Debugger DataWhen you stop the process, you then have a number of options for examining the data. You can inspectID="1GStartDebug15"the call stack at the breakpoint (using Call Stack)ID="1GStartDebug16"the value of specified expressions (using Expression View)ID="1GStartDebug17"the values, types, or addresses of variables (using Variable Browser)ID="1GStartDebug18"data structures (using Structure Browser)ID="1GStartDebug19"ID="1GStartDebug20"the values of an array variable (using Array Browser)ID="1GStartDebug21"ID="1GStartDebug22"values in specified memory locations (using Memory View) or registers (using Register View)ID="1GStartDebug23"ID="1GStartDebug24"ID="1GStartDebug25"ID="1GStartDebug26"the disassembled code (using Disassembly View)ID="1GStartDebug27"ID="1GStartDebug28"For more information on the standard Debugger views, refer to IDREF="24462" TYPE="TITLE"Chapter 6, "Examining Debugger Data."LBL="" HELPID=""ID="17249"Changing Source CodeTo change your source code and recompile, follow these steps:Switch to a text editor ("Fork Editor" selection in Source menu) or edit in Main View ("Make Editable" in Source menu). ID="1GStartDebug29"ID="1GStartDebug30"If you are using a configuration management system, then you can check out the source code, by selecting "Versioning" from the Source menu and accessing the source through the configuration management shell.Make any changes and save them. In the Main View, pull down the Source menu and select "Save..."In the Main View, pull down the Source menu and select "Recompile."The Build View window displays and lets you start the compile. Any compile errors are listed in the window, and you can access the related source code by clicking the errors. For more information on the Build Manager, refer to IDREF="50420" TYPE="TITLE"Appendix B, "Using the Build Manager."When the code is rebuilt successfully, the new executable reattaches automatically to the Debugger and Static Analyzer. Previously set traps are intact unless you have traps triggered at line numbers and have changed the line count. LBL="" HELPID=""ID="28739"Updating and Saving ViewsUpdating and saving view data is done through the Admin menu in the particular view (see ID="1GStartDebug31"ID="1GStartDebug32"IDREF="70205" TYPE="GRAPHIC"Figure 1-2). FILE="f01admvu.gif" POSITION="INLINE" SCALE="FALSE"LBL="1-2"Figure 1-2 ID="70205"Admin Menu in Debugger ViewsTypically, you display the WorkShop views of interest when you are stopped at a trap and leave them on the screen as you run the process. "Active" ID="1GStartDebug33"Updates the view each time the process stops or if the context is changed in the Call Stack View window. The active state is the default."Clone"ID="1GStartDebug34"Makes a duplicate, inactive copy of the view, allowing you to save current information for future reference."Save As Text..."ID="1GStartDebug35"Lets you save the data currently displayed in a view to a text file. Note that not all views have the "Save as Text..." option."Close"Closes the window of the view.LBL="" HELPID=""ID="25532"Integration With Other WorkShop ToolsID="1GStartDebug36"The WorkShop tools are designed so that you can move easily between them in a work session.LBL="" HELPID=""Accessing the Performance Analyzer From Main ViewYou can switch to the Performance Analyzer at any time while debugging. Selecting "Performance Task..." from the Admin menu lets you enable data collection for your experiment. A performance task must be specified before the process is run; this enables the correct data collection. If you are in the middle of a run, you must terminate it, select a task, and restart the target to collect the data. Selecting "Performance Analyzer" from the "Launch Tool" submenu displays the main Performance Analyzer for analyzing the experiment results. LBL="" HELPID=""Accessing the Static Analyzer From Main ViewYou can access the Static Analyzer from the "Launch Tool" submenu, if desired. The Static Analyzer displays source information from Main View, making it easy to set traps in source code located by the Static Analyzer. Note that the Query menu enables you to conduct some of the same queries as in the Static Analyzer. LBL="" HELPID=""Accessing Editors From Main ViewAfter you solve a problem with the WorkShop tools, you may wish to make the change in Source View (or your preferred editor) and then recompile. LBL="" HELPID=""Accessing Configuration Management ToolsIf you use ClearCase‘ (available from Silicon Graphics), RCS, or SCCS for configuration management, you can integrate the tool into the WorkShop environment by typingcvconfig [clearcase | rcs | sccs] This enables the "Versioning" in the Source menu, which provides selections for checking files in and out.LBL="" HELPID=""Recompiling From Main View or Source ViewTo access the Build View window (which lets you start the compile), in the Main View, pull down the Source menu and select "Recompile." To examine the build dependencies, in the Main View, pull down the Admin menu and select "Build Analyzer." For more information on the Build Manager tools, see IDREF="50420" TYPE="TITLE"Appendix B, "Using the Build Manager."LBL="" HELPID=""ID="75742"Debugging with Fix+ContinueFix and Continue is integrated with the Debugger. You issue Fix and Continue commands graphically from the Fix+Continue pulldown menu of the Debugger main window. You may also issue Fix and Continue commands from the Debugger command line (ID="1GStartDebug37"cvd>). LBL="" HELPID=""ID="45021"Redefining Functions Using Fix and ContinueFix and Continue gives you the ability to make changes to a program you are debugging without having to recompile and link the entire program, and then continue debugging the code. With Fix and Continue, you can edit a function, parse the new function, and continue execution of the program being debugged. Fix and Continue enables you to speed up your development cycle significantly.ID="1GStartDebug38"IDREF="35507" TYPE="TABLE"Table 1-1 compares the cycle time in seconds between a full rebuild and a Fix and Continue for three typical programs. COLUMNS="3"LBL="1-1"Table 1-1 ID="35507"Fix and Continue Compile Time CycleLEFT="0" WIDTH="87"ExampleLEFT="95" WIDTH="87"Time to RebuildLEFT="190" WIDTH="87"Time to Fix+ContinueLEFT="0" WIDTH="87"Program ALEFT="95" WIDTH="87"0:06LEFT="190" WIDTH="87"0:02LEFT="0" WIDTH="87"Program BLEFT="95" WIDTH="87"0:33LEFT="190" WIDTH="87"0:06LEFT="0" WIDTH="87"Program CLEFT="95" WIDTH="87"5:24LEFT="190" WIDTH="87"0:49LBL="" HELPID=""Fix and Continue FunctionalityFix and Continue lets you:ID="1GStartDebug39"Redefine existing function definitionsDisable, re-enable, save, and delete redefinitionsSet breakpoints in and single-step within redefined codeView the status of changesExamine differences between original and redefined functionsThe basic cycle of using Fix and Continue is shown in ID="1GStartDebug40"IDREF="75885" TYPE="GRAPHIC"Figure 1-3. FILE="cycle.gif" POSITION="INLINE" SCALE="FALSE"LBL="1-3"Figure 1-3 Fix and Continue CycleA typical session would be the following: Using the Fix and Continue commands, you redefine a function. When you continue executing the program, the Debugger attempts to call the redefined function. If it cannot, an information popup appears, and the redefined function will be executed the next time the program calls that function.You redefine other functions, alternating between debugging, disabling, re-enabling, and deleting redefinitions. You might save function redefinitions to their own files, or save files to a different name, to be used later with the present or with other programs. Frequently during debugging you can review the status of changes by listing them, showing specific changes, or looking at the Fix and Continue Status View. You can compare changes to an individual function or to an entire file with the compiled versions. When satisfied with the behavior of your application, you save the file, replacing the compiled source.LBL="" HELPID=""Fix and Continue/WorkShop IntegrationUsing Fix and Continue affects these WorkShop tools:ID="1GStartDebug41"The WorkShop Debugger Main View, the Source View, and the Fix and Continue Status window make a clear distinction between compiled and redefined code, and allow editing only in redefined code.The different WorkShop views that are knowledgeable about redefined code:Call StackTrap ManagerDebugger command-lineLBL="" HELPID=""How Redefined Code Is Distinguished From Compiled CodeRedefined functions have an identification number and special line numbers, and in the Debugger views are color-coded according to their state (edited, parsed, and so on).Line numbers in the compiled file stay the same, no matter how redefined functions change. However, when you begin editing a function, the line numbers of the function body are represented in decimal notation (n.1, n.2, ..., n.m). n is the compiled line number where the function body begins. m is the line number relative to the beginning of the function body, starting with 1.IDREF="65766" TYPE="GRAPHIC"Figure 1-4 shows two redefined functions. Function 1 replaces lines 8-15. Function 2 replaces lines 18-20. Although its three lines are now one, the following line number is still 21.FILE="linNumDec.gif" POSITION="INLINE" SCALE="FALSE"LBL="1-4"Figure 1-4 Line Numbers in Decimal NotationThe Call Stack and Trap Manager both use function-relative decimal notation when referring to a line number within the body of a redefined function. The Debugger command line reports ongoing status. In addition to providing the same commands available from the menu, edit commands allow you to add, replace, or delete lines from files. You can easily operate on several files at once.LBL="" HELPID=""Restrictions on Fix and ContinueFix and Continue has the following restrictions when you fix a function in which you have stopped:ID="1GStartDebug42"You may not add, delete, or reorder the local variables in a function.You may not change the type of a local variable.You may not change a local variable to be a register variable, and vice- versa.You may not add any function calls that increase the size of the parameter area.You may not add an alloca function to a frame that did not previously use an alloca.Both the old and new functions must be compiled with -g.In other words, the layout of the stack frames of both the old and new functions must be identical for you to continue execution in the function that is being modified. If not, execution of the old function continues, and the new function is executed the next time it is called.If you redefine functions which are in but not on top of the call stack, the modified code will not be executed when they combine. Modified functions will be executed only on their next call or on a re-run.For example, consider the following call stack:foo()
bar()
foobar()
main()If you redefine foo(), you can continue execution provided the layout of the stack frames are same.If you redefine bar() [or foobar()], the new code will not be executed when foo() returns. The code will be executed only on the next call of bar() [or foobar()].If you redefine main() after you have run, it will be executed only when you re-run.LBL="" HELPID=""ID="34491"The Fix and Continue EnvironmentThe interface to Fix and Continue is through the Fix+Continue menu and its associated windows: Status, Message, and Build Environment. These windows are completely dependent on Fix and Continue, and do not operate unless it is installed.ID="1GStartDebug43"For more complete information on all of the Fix and Continue menus, windows, and functions, see IDREF="12535" TYPE="TITLE""Fix+Continue Windows".LBL="" HELPID=""Debugger With Fix and Continue SupportWithout Fix and Continue, the Debugger source views are ID="1GStartDebug44"Read-Only by default. That is so you can examine your files with no risk of changing them. When you select "Edit" from the Fix+Continue menu, the Debugger source code status indicator (in the lower-right corner of the Debugger windowname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'see ID="1GStartDebug45"ID="1GStartDebug46"IDREF="62188" TYPE="GRAPHIC"Figure A-1) remains Read-Only. Fix and Continue edits are saved in an intermediate state and must be explicitly written with the "Save File+Fixes As..." option to be saved.When you edit a function, it is color-highlighted. Then, if you switch to the compiled version, the color changes to show that there is a redefinition. If you try to edit the compiled version, the Debugger beeps, indicating it is Read-Only.When you have completed your edits and wish to see the results, click "Parse and Load." When the Parse and Load has executed successfully, the color changes again. If the color doesn't change, there may be errors, and you should check your "Message Window..." view.LBL="" HELPID=""GUI Debugger Command LineJust as you can enter any ID="1GStartDebug47"dbx command at the Debugger command line, you can enter Fix and Continue commands there. LBL="" HELPID=""Change ID, Build Path, and Other ConceptsThe Fix and Continue methods for accessing functions through ID numbers, finding files, and so forth, are discussed below.ID="1GStartDebug48"Each redefined function is numbered with a change ID. Its status is redefined, enabled, disabled, deleted, or detached.ID="1GStartDebug49"Fix and Continue needs to know where to find include files and other parameters specified by compiler build flags (compiler options). You can set the build environment for all files or for a specific file. You can display the current build environment from the Fix+Continue pulldown menu, the command line, or the Fix and Continue Status Window. When you finish a Fix and Continue session, you can unset the build environment.ID="1GStartDebug50"A successful run results in output in the Execution View. This functionality is the same as it is in the Debugger without Fix and Continue.ID="1GStartDebug51"LBL="" HELPID=""ID="16728"Debugging with the X/Motif AnalyzerThe X/Motif analyzer is integrated with the Debugger. You issue X/Motif analyzer commands graphically from the X/Motif analyzer subwindow of the main Debugger window (see ID="1GStartDebug52"IDREF="33935" TYPE="GRAPHIC"Figure 1-5). To access the subwindow, you must pull down the Views menu and select "X/Motif Analyzer"FILE="1GStartDebug2.gif" POSITION="INLINE" SCALE="FALSE"LBL="1-5"Figure 1-5 ID="33935"Launching the X/Motif AnalyzerLBL="" HELPID=""ID="90583"Special LibrariesWhen you first bring up the X/Motif Analyzer, it may ask you if you want to change $LD_LIBRARY_PATH to include /usr/lib/WorkShop/Motif. In that directory are instrumented versions of the Silicon Graphics ID="1GStartDebug53"Xlib, Xt, and Xm libraries. These versions include debugging symbols and special support for X/Motif Analyzer functions.It is strongly recommended that you click OK to the dialog and use these libraries. Doing so enables all of the features of the X/Motif Analyzer. These libraries are identical in functionality to the libraries shipped with IRIX 5.3. The analyzer uses the Silicon Graphics enhanced version of these libraries. There are no instrumented MIPS/ABI versions of the libraries.LBL="" HELPID=""ID="42799"Using the X/Motif AnalyzerThe X/Motif Analyzer provides specific debugging support for X/Motif applications. There are various examiners for different X/Motif objects (for example, widgets and X graphics contexts) that are normally difficult or impossible to inspect using ordinary debugger functionality. Also, you can set widget-level breakpoints and collect X event history information (in the same manner as ID="1GStartDebug54"xscope).LBL="" HELPID=""Examiners OverviewWhen you first bring up the X/Motif Analyzer, you see the Widget examiner. It may be blank or displaying a Widget that it found on the callstack if you have a stopped process. Most of the examiners in the X/Motif Analyzer try to detect interesting objects from the callstack and offer to display them for you, automatically.ID="1GStartDebug55"At the bottom of the X/Motif Analyzer is a tab panel showing the current set of examiners. Besides the Widget examiner, the Breakpoints, Tree, and Trace examiners are available by default. These four tabs are always present.To bring up new examiners, use the Examine menu and select one from below the separator. Some examiners (for example, the Callback examiner) cannot be manually selectedname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'they appear only when the callstack context is appropriate. In the case of the Callback examiner, it appears only when the process is stopped somewhere in a widget callback.To remove an examiner from the tab panel, put the pointer over the tab, click the right button of your mouse, and select 'Remove Examiner' from the popup menu. The tab disappears.LBL="" HELPID=""Examiners and SelectionsIf you select text in one examiner and then choose another using the Examine menu, the new examiner is brought up and the text is used as an expression for it. If you selected text that evaluated to an inappropriate object for the new examiner, an error is generated.ID="1GStartDebug56"Alternatively, you can select text, pull down the Examine menu, and choose "Selection." The X/Motif Analyzer attempts to select an appropriate examiner for the type of the selected text. If the type of the text is unknown, the error Couldn't examine selection in more detail is generated. Otherwise, the appropriate examiner is chosen and the text is evaluated.You can accomplish the same thing by triple-clicking the line of text. If the type of the text is unknown, nothing happens. Otherwise, the appropriate examiner is chosen and the text is evaluated.LBL="" HELPID=""Inspecting DataX/Motif applications consist of collections of objects (Motif widgets) and make extensive use of X resources such as windows, graphics context, and so on. The construction model of an X window system hinders you from inspecting the internal structures of widgets and X resources because you are presented with ID values. The X/Motif Analyzer provides inspection capability for you to see into the data structures behind the ID values.LBL="" HELPID=""Inspecting the Control FlowTraditional debuggers enable you to set breakpoints only in source lines or functions. With the X/Motif Analyzer, you can set breakpoints for specific widgets or widget classes, for specific control flow constructs like callbacks or event handlers, and (at a lower level) for specific X events or requests.LBL="" HELPID=""Tracing the ExecutionThe X/Motif Analyzer can trace Xlib-level server events and client requests, Xt-level event dispatching information, widget life cycle, and widget status information.LBL="" HELPID=""ID="79630"Restrictions and LimitationsDue to implementation details, there are several nuisances that currently pose some restrictions to the X/Motif Analyzer:ID="1GStartDebug57"The Breakpoints area is active only after you've stopped the process once, and if you've changed $LD_LIBRARY_PATH.Sometimes, gadget names may be unavailable and are displayed as <object>.You can minimize this condition by getting the widget tree beforehand.editres-type requests (widget selection and widget tree) work only if the process is running or if the process is stopped outside of a system call. This can be annoying when the process is stopped in select(), waiting for an X server event.The process state and appearance of the cvd Main View flickers while the X/Motif Analyzer tries to complete an editres request when the process is stopped.editres requests may be unreliable if the process is stopped. LBL="" HELPID=""ID="81699"Customizing the DebuggerIf there are Debugger commands or combinations of Debugger commands that you use frequently, you may find it convenient to create a script composed of Debugger commands. Debugger scripts are ASCII files containing one Debugger command with its arguments per line. A Debugger script can in turn call other Debugger scripts. There are three general methods for running scripts:Entering the source command and the filename at the Debugger command linename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'this is useful for scripts that you need only occasionally. Including the script in a startup filename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'this is useful for scripts that you want implemented every time you use the Debugger.Defining a button in the graphical interface to run the scriptname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'use this method for scripts that you use frequently but apply only at specific times in a debugging sessionLBL="" HELPID=""Using a Startup FileThe startup file feature lets you preload your favorite buttons and aliases in a file that runs when cvd is invoked. It's also useful if you have traps that you set the same way each time. The suggested name for the startup file is .cvdrc; you can supply a different name as long as you specify its path in the environment variable CVDINIT. The steps in the algorithm that cvd follows when looking for a startup file are:Check the environment variable CVDINIT.Check for the file  .cvdrc in the current directory.Check for the file  .cvdrc in the user's home directory.LBL="" HELPID=""Implementing User-Defined ButtonsIf there are Debugger commands or combinations of Debugger commands that you use frequently, you may find it convenient to define a button for the graphical interface. You can implement buttons by providing a special Debugger startup file or by creating them on the fly within a debugging session. Buttons appear in order of implementation in a row at the bottom of the control panel area. Currently, you can define only one row of custom buttons. IDREF="20626" TYPE="GRAPHIC"Figure 1-6 is a typical example of Main View with user-defined buttons. The definitions for the user-defined buttons display in the Debugger command line area.FILE="1GStartDebug5.gif" POSITION="INLINE" SCALE="FALSE"LBL="1-6"Figure 1-6 ID="20626"User-Defined Button ExampleThe syntax for creating a button isbutton label command [$sel]The syntax for creating a multiple-command button isbutton label {command1 [$sel]; command2 [$sel]; ...}wherebutton is the Debugger command for defining buttons. It can be applied at the Debugger command line or in a startup file.label  is the name appearing on the button. Button labels should be kept short since there is only room for a single row of buttons. There can be no spaces in a label.command is one of the the Debugger commands, which are entered at the command line at the bottom of Main View. See IDREF="76970" TYPE="TITLE""Debugger Command Line".$sel is a substitute for the current cursor selection and should be appropriate as an argument to the selected command.command1, command2 (and any additional commands) are Debugger commands to be applied in order. They must be separated by semicolons (;) and enclosed by braces ({}). The multiple-command button is a powerful feature; it lets you write a short script to be executed when you click the button.The following syntaxbutton displays a list of all currently defined buttons.The syntaxunbutton labeldeletes the button corresponding to the label. You might use this if you needed room to implement different buttons. The effect of unbutton is temporary so that subsequently running the startup file reactivates the button.The syntaxbutton labeldisplays the button's definition if it exists. If the button does not exist, an error message displays along with the standard usage syntax for button.LBL="2"ID="34853"Managing Source FilesID="2MngSrc1"This chapter looks at the details of working with source files. It covers these topics:IDREF="62531" TYPE="TITLE""Accessing Files Used by an Executable"IDREF="17428" TYPE="TITLE""Opening a New File"IDREF="70316" TYPE="TITLE""Path Remapping"LBL="" HELPID=""ID="62531"Accessing Files Used by an ExecutableThe File Browser, available from the Views menu in the Main View, provides a scrollable list of the source files used by your executable, including files in linked libraries. See ID="2MngSrc2"IDREF="21788" TYPE="GRAPHIC"Figure 2-1.FILE="f03fbrow.gif" POSITION="INLINE" SCALE="FALSE"LBL="2-1"Figure 2-1 ID="21788"File Browser WindowThe File Browser has a field labeled Search for quickly locating files in the list. File searching is incrementalname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'as you type the string you are searching for in the Search field, the first string that matches the entered string is highlighted. To load a file directly into Main View from the File Browser window, simply double-click the filename.LBL="" HELPID=""ID="17428"Opening a New FileID="2MngSrc3"Another way to load a file is to specify it by using the "Open..." selection from the Source menu. The dialog box in IDREF="54633" TYPE="GRAPHIC"Figure 2-2 displays, listing the files in the file list display area and the currently selected directory in the selection field.FILE="2MngSrc2.gif" POSITION="INLINE" SCALE="FALSE"LBL="2-2"Figure 2-2 ID="54633"Open Source File Dialog BoxTo load a file listed in the file list, double-click the file's name. You can also type the full pathname of the file in the Selection field and click the OK button to load the file. Another alternative is to drag the file's icon into the drop pocket.If the file you want to load is not in the current directory, enter the appropriate directory in the selection field. The files in the new directory are listed in the file list. If you specify a filename without a full path, the Debugger will use the current path remapping information to attempt to locate the file. Another method for opening a file in Main View is to enter its full name in the File field, below the source code display area, and press <Enter>.LBL="" HELPID=""ID="70316"Path RemappingThe path remapping option allows you to modify the set of mappings used to redirect filenames located in your executable to their actual locations in your file system. Since WorkShop uses full (absolute) pathnames, path remapping is generally not necessary. However, if you have mounted executable files on a different tree from the one on which they were compiled, you will need to remap the root prefix to get access to the files in that hierarchy. ID="2MngSrc4"The most basic remapping is for ".", which allows you to specify the directories to be searched for files. This basic function works just like dbx and can be modified using the use and dir commands in the command line. To open the Path Remapping dialog box, choose "Remap Paths..." from the "Project" submenu in the Main View Admin menu. The Path Remapping dialog box appears (see ID="2MngSrc5"IDREF="46544" TYPE="GRAPHIC"Figure 2-3).FILE="2MngSrc3.gif" POSITION="INLINE" SCALE="FALSE"LBL="2-3"Figure 2-3 ID="46544"Path Remapping Dialog BoxFor each prefix listed in the Prefix list, there is an ordered set of substitutions that are used to find a real file. By default, the path remapping is initialized so that "." is mapped to the current directory. The Substitution Set list shows the substitution list for the currently highlighted item in the Prefix list. Here are some operations you can perform:To view the substitution set for a different prefix, click that prefix. To add a new prefix, enter the new value in the Value field below the Prefix list and click the Add button. A new, empty substitution set is created. Next, type the desired substitution in the Value field below the Substitution Set list.To modify the currently selected prefix, edit the string in the Value field and click the Modify button.To remove the current prefix and its substitution set, select the prefix and click the Remove button.LBL="3"ID="21883"A Short Debugger TutorialThis chapter presents a short tutorial for using the Debugger. The tutorial applies the Debugger to a program called jello, which provides a walk through some typical debugging situations. The tutorial is divided into four parts:IDREF="93678" TYPE="TITLE""Starting the Debugger"IDREF="72807" TYPE="TITLE""Performing a Search"IDREF="44659" TYPE="TITLE""Setting Traps"IDREF="13777" TYPE="TITLE""Examining Data"NoteWorkShop identifies files with the pathnames in which they were compiled. The pathnames in the tutorial may not match the ones on your system.LBL="" HELPID=""ID="93678"Starting the DebuggerID="3TutGen1"In this part of the tutorial, you invoke the Debugger and start a typical process running. The ID="3TutGen2"jello program simulates an elastic polyhedron bouncing around inside of a revolving cube. The program's functionality is mainly contained in a single loop that calculates the acceleration, velocity, and position of the polyhedron's vertices. Go to the directory /usr/demos/WorkShop/jello.If the jello executable does not yet exist, type make jelloTo invoke the Debugger, type cvd jelloThe Main View window appears as shown in IDREF="31181" TYPE="GRAPHIC"Figure 3-1. The display scrolls automatically to the main function.FILE="3TutGen7.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-1"Figure 3-1 ID="31181"The Main View Window with jello Source CodeNoteMain View brings up the source file in read-only mode to avoid inadvertent changes during debugging. You can change this mode by selecting "Make Editable" from the Source menu (provided you have the proper file access permissions).Click the Run button in the upper-right corner of the Main View to start the jello process. The jello window opens on your display (see IDREF="36796" TYPE="GRAPHIC"Figure 3-2). Enlarge this window to watch the program execute. The polyhedron is initially suspended in the center of the cube. Click the left mouse button anywhere inside the jello window.The polyhedron drops to the floor of the cube. Hold down the right mouse button to display the pop-up menu and select "spin."The cube now rotates and the polyhedron bounces. If you select "display" from the menu, you can change the appearance of the polyhedron: points only, lines only, full color, visible points only, or single color. NoteYou may encounter flashing colors inside windows while running jello. This is a normal side effect due to GL/X interaction.FILE="f02jello.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-2"Figure 3-2 ID="36796"The jello WindowLBL="" HELPID=""ID="72807"Performing a SearchThis part of the tutorial covers the search facility in the Debugger. You will search through the jello source file for a function called spin. The spin function recalculates the position of the cube.Choose "Search" from the Source menu.ID="3TutGen3"The Search dialog box appears.Type spin in the entry field in the Search dialog box, as shown in IDREF="80872" TYPE="GRAPHIC"Figure 3-3.FILE="f02srch.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-3"Figure 3-3 ID="80872"The Search Dialog BoxClick the Apply button in the Search dialog box.The search takes place. Each instance of "spin," the target string, is highlighted in the source code and flagged in the scroll bar to the right of the display area. IDREF="89911" TYPE="GRAPHIC"Figure 3-4 shows typical search target indicators. The Next and Prev buttons let you move from one occurrence to the next in the order indicated. For more information on Search, see IDREF="70501" TYPE="TITLE""Source Menu".Click the Close button in the Search dialog box.The dialog box disappears.Click the middle mouse button on the last search target indicator.This scrolls the source code down to the last occurrence, which is the location of the spin function.FILE="3TutGen8.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-4"Figure 3-4 ID="89911"Search Target IndicatorsLBL="" HELPID=""ID="44659"Setting TrapsStop traps (also called breakpoints) stop the program's execution at a specified line in the code, allowing you to track the progress of your program and to check the values of variables at that point. Typically, you set breakpoints in your program prior to running it under the Debugger. For more information on traps, refer to ID="3TutGen4"IDREF="25908" TYPE="TITLE"Chapter 4, "Setting Traps."In this part of the tutorial, you set a breakpoint at the spin function. Click the left mouse button in the source code annotation column next to the line containing if ((a+=1)>3600) a -= 3600;. A stop trap indicator appears in the annotation column as shown in IDREF="22142" TYPE="GRAPHIC"Figure 3-5. This stop trap halts execution of jello at the beginning of the next call to the spin function. When the process stops, an icon indicating the current PC appears and the line becomes highlighted.FILE="3TutGen9.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-5"Figure 3-5 ID="22142"Stop Trap IndicatorClick the Continue button at the upper-left corner of the Main View window repeatedly so that jello goes through several iterations.The ID="3TutGen5"Continue button resumes execution until the next breakpoint (in this case, spin) is encountered. Stopping at the spin function allows you to view the jello image one frame at a time.Select "Trap Manager" from the Views menu in Main View.The Trap Manager window appears as shown in IDREF="96147" TYPE="GRAPHIC"Figure 3-6.Trap Manager lets you list, add, edit, disable, or remove traps in a process. You set one breakpoint in the ID="3TutGen6"spin function by clicking in the source code annotation column. This trap is displayed in the trap display area.You can define other traps as well in the Trap Manager. You set conditional traps in the Condition field from the top. The count information lets you specify the number of times a trap should be encountered before it fires. The trap controls let you manipulate traps. All traps (active and inactive) are shown in the trap display area.FILE="3TutGen10.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-6"Figure 3-6 ID="96147"The Trap Manager WindowClick the button to the left of the stop trap in the trap display area.The trap is temporarily disabled. Trap Manager lets you turn traps on and off by clicking them.ID="3TutGen7"Click the ID="3TutGen8"Clear button, move the cursor to the Trap: field, typewatch display_modeID="3TutGen9" and click ID="3TutGen10"Add.This sets a watchpoint for the variable ID="3TutGen11"display_mode. A watchpoint is a trap that fires when a specified variable or address is read, written, or executed. After you continue the process, you can fire this watchpoint by holding down the right mouse button in the jello window and selecting "display" and a different display option. The variable display_mode is accessed and the watchpoint fires.Click the ID="3TutGen12"Continue button to restart the process.The process now runs somewhat slower but still at a reasonable speed for debugging.Hold down the right mouse button in the jello window to display the popup menu, and select "display" and then the "conecs" option with the right button.This triggers the watchpoint and stops the process. If you were tracking the effects of changing display modes, you could bring up other views now.Go to the Trap Manager window and click the button next to the display_mode watchpoint to deactivate it. Click the button next to the spin stop trap to reactivate it.This resets the traps for use in this tutorial.Enter 100 in the ID="3TutGen13"Cycle Count field, press <Enter>, and click the Continue button in Main View.This takes the process through the stop trap for the specified number of times, provided no other interruptions occur. The Current Count field keeps track of the actual number of iterations since the last stop, which is useful if an interrupt occurs. Note that it updates at interrupts only.Select "Close" from the Admin menu in Trap Manager to close it.LBL="" HELPID=""ID="13777"Examining DataID="3TutGen14"This part of the tutorial describes how to examine data after the process stops.Select "Call Stack" from the Views menu in Main View.ID="3TutGen15"The Call Stack View window appears as in IDREF="84799" TYPE="GRAPHIC"Figure 3-7. The Call Stack View window shows each frame in the call stack at the time of the breakpoint with the calling parameters and their values. You can also display the calling parameters' types, locations, and PC (program counter) through the Display menu. For more information, see IDREF="55087" TYPE="TITLE""Tracing Through Call Stack View".In this example, the spin and main stack frames are displayed in Call Stack View, and the ID="3TutGen16"spin stack frame is highlighted, indicating that it is the current stack frame.Pull down the Admin menu and examine the "Active" selection.ID="3TutGen17"By default, the "Active" toggle button in the Admin menu is turned on. Active views are those that have been specified to change their contents at stops or at call stack context changes. If the toggle is on, the call stack is updated automatically whenever the process stops.FILE="f02cstck.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-7"Figure 3-7 ID="84799"Call Stack View at spin Stop TrapDouble-click the main stack frame.This shifts the stack frame to theID="3TutGen18" main function, scrolls the source code in Main View (or Source View) to the place in main where spin was called, and highlights the call in the designated context color. Any active views are updated according to the new stack frame. Double-click the spin stack frame.This returns the stack frame to theID="3TutGen19" spin function. ID="46838"Select "Variable Browser" from the Views menu in Main View.ID="3TutGen20"The Variable Browser window appears. This window shows you the value of local variables at the breakpoint. The variables appear in the left column (read-only), and the corresponding values appear in the right column (editable). Since the right column is editable, you can change the values of the variables if you want. ID="3TutGen21"Your Variable Browser window should resemble the one in IDREF="64767" TYPE="GRAPHIC"Figure 3-8, although you may need to enlarge the window to see all the variables (the values will be different). The jello program uses variables a, b, and c as angles (in tenths); ca, cb, cc as their corresponding cosines; and sa, sb, sc as their sines. Whenever you stop at spin, these values change.FILE="f02vrbr1.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-8"Figure 3-8 ID="64767"Variable Browser at spin Double-click some different frames in Call Stack View and observe the changes to Variable Browser and Main View.These views update appropriately whenever you change frames in Call Stack View. Notice also the change indicators in the upper right corners of the Result fields (see IDREF="90207" TYPE="GRAPHIC"Figure 3-9). These appear if the value has changed. If you click the "folded" corner, the previous value displays (and the indicator appears "unfolded"). You can then toggle back to the current value.FILE="3TutGen11.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-9"Figure 3-9 ID="90207"Variable Browser after ChangesSelect "Close" from the Admin menu in Variable Browser and "Close" from the Admin menu in Call Stack View to close them.Select "Expression View" from the Views menu in Main View.ID="3TutGen22"The Expression View window appears. It lets you evaluate an expression involving data from the process. The expression can be typed in or more conveniently cut and pasted from your source code. You can view the value of variables (or expressions involving variables) any time the process stops. Enter the expression in the left column, and the corresponding value appears in the right column. For more information, see ID="3TutGen23"IDREF="38851" TYPE="TITLE""Evaluating Expressions".Hold down the right mouse button in the Expression column to bring up the Language menu. Then hold down the right mouse button in the Result column to display the Format menu.The Language menu (shown on the left side of ID="3TutGen24"IDREF="86783" TYPE="GRAPHIC"Figure 3-10) lets you apply the language semantics to the expression.The Format menu (shown on the right side of ID="3TutGen25"IDREF="86783" TYPE="GRAPHIC"Figure 3-10) lets you view the value, type, address, or size of the result. You can further specify the display format for the value and address.FILE="3TutGen12.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-10"Figure 3-10 ID="86783"Expression View With Language and Format Menus DisplayedClick on the first Expression field in the Expression View window. Then enter (a+1)>3600 in the field and press <Enter>.This is a test performed in jello to ensure that the value of a is less than 3600. This uses the variable a that was displayed previously in Variable Browser. After you press <Enter>, the result is displayed in the right column; 0 signifies false. Select "Close" from the Admin menu in Expression View to close it.ID="49689"Select "Structure Browser" from the Views menu in Main View.ID="3TutGen26"Enter jello_conec in the ID="3TutGen27"Expression field and press <Enter>.The Structure Browser displays the structure for the given expression; field names are displayed in the left column, and values in the right column. If only pointers are available, Structure Browser will dereference the pointers automatically until actual values are encountered. You can then perform any further dereferencing by double-clicking pointer addresses in the right column of the data structure objects. A window similar to the one shown in IDREF="74118" TYPE="GRAPHIC"Figure 3-11 now appears. FILE="f02strc1.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-11"Figure 3-11 ID="74118"Structure Browser Window With jello_conec StructureClick once to focus, then double-click the address of the next field (in the right column of the jello_conec structure). Double-clicking the address corresponding to a pointer field dereferences it. Double-clicking the field name displays the complete name of the field in the Expression field at the top of the Structure Browser window. (See IDREF="85628" TYPE="GRAPHIC"Figure 3-12.)FILE="f02strc2.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-12"Figure 3-12 ID="85628"Structure Browser Window With Next Pointer DereferencedSelect "Close" from the Admin menu in Structure Browser to close it.ID="69564"Select "Array Browser" from the Views menu in Main View.ID="3TutGen28"The Array Browser lets you see or change values in an array variable. It is particularly valuable for finding bad data in an array or for testing the effects of values you enter. ID="3TutGen29"Type shadow in the Array field and press <Enter>.You can now see the values of the shadow matrix, which displays the polyhedron's shadow on the cube. The Array Browser template should resemble IDREF="54588" TYPE="GRAPHIC"Figure 3-13 but with different data values. If any fields are hidden, you can drag the sash buttons at the right of the window to expose them.FILE="3TutGen13.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-13"Figure 3-13 ID="54588"Array Browser Window for ID="3TutGen30"shadow MatrixSelect the ID="3TutGen31"Col button next to the $k index.The Array Browser can handle matrices containing up to six dimensions but displays only two dimensions at a time. Selecting the Col button for $k has the effect of switching from a display of $i by $j to $i by $k.IDREF="16220" TYPE="GRAPHIC"Figure 3-14 shows a close-up view of the subscript control area.ID="3TutGen32"FILE="3TutGen14.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-14"Figure 3-14 ID="16220"Subscript Control Area in Array BrowserThe row/column toggles indicate whether a vector appears as a row, column, or not at all in the spreadsheet area. Although any number of vectors can reside in an array, you can view only two vectors at a time. The index values show the number of elements in a vector and are used to change the dimensions of the matrix. The index sliders let you move the focus cell along the particular vector. The index minimums and index maximums identify the beginning and ending elements, respectively, in the vectors. Use the horizontal and vertical scroll bars to expose hidden portions of the Array Browser window.Select "Surface" from the Render menu.The Render menu displays the data from the selected array variable graphically, in this case as a three-dimensional surface. The selected cell is highlighted by a rectangular prism. The selected subscripts correspond to the x- and y-axes in the rendering; the corresponding value is plotted on the z-axis. The data can be rendered as a surface, bar chart, multiple lines, or points. Select "Exit" from the Admin menu in Main View to end this tutorial.LBL="4"ID="25908"Setting TrapsSetting traps is one of the most important functions of a debugger or performance analyzer. A ID="4Traps1"trap enables you to select a location or condition within your program at which you can stop the process or collect performance data automatically. In general, you set or clear traps from Main View (Source View) or the Trap Manager. You can also specify traps in the Debugger command line at the bottom of the Main View window. For signal traps, you can also use the Signal Panel window. For system call traps, use the Syscall Panel window.When you are debugging a program, you typically set a trap in a process to determine if there is a problem at that point. WorkShop lets you inspect the call stack, examine variables, or perform other procedures to get information about the state of the process. Traps are also useful for analyzing a program's performance. They let you collect data related to resource usage without stopping the process. This chapter covers the following topics:IDREF="34548" TYPE="TITLE""Trap Terminology"IDREF="42200" TYPE="TITLE""Setting Traps in Main View and Source View"IDREF="21399" TYPE="TITLE""Setting Traps in Trap Manager"IDREF="23429" TYPE="TITLE""Setting Traps With Signal Panel and Syscall Panel"For a tutorial on the use of traps, see IDREF="44659" TYPE="TITLE""Setting Traps".LBL="" HELPID=""ID="34548"Trap TerminologyID="4Traps2"In WorkShop, the term trap refers to any intentional process interruption. A trap has two dimensions: the ID="4Traps3"trigger, which specifies when the trap fires, and the ID="4Traps4"action taken when the trap fires, either stopping the process or capturing data.When used as a verb, the term trigger refers to engaging a trap but not necessarily firing it. There are some circumstances where the process may hit a trap but not satisfy all the conditions necessary for firing it. LBL="" HELPID=""Trap TriggersYou can set traps at a specified location or when a specified event occurs. The triggers provided in WorkShop areat a given line in a file (traditionally referred to as "breakpoints")at a given instruction addressat the entry or exit for a given functionafter set time intervals (referred to as "pollpoints")when a given variable or address is read, written, or executed (referred to as "watchpoints")when a given signal is receivedwhen a given system call is entered or exitedFurthermore, you can specify a condition (as an expression) that must be met before a trap fires. You can also specify the cycle count, that is, a specific number of passes through a trap without firing it. LBL="" HELPID=""ID="86295"Trap ActionsTwo actions can occur when a trap is fired: one or all processes can be stoppeda sample of performance data can be taken A trap that stops processes is called a ID="4Traps5"stoptrap, or a breakpoint. A trap that collects performance data is called a ID="4Traps6"sample trap. In single process debugging, a stop trap stops the current process. In multiprocess debugging, you can specify the stop trap to stop all processes or the current process only.Sample traps are used only in performance analysis, not directly in debugging. They collect data without stopping the process. You can specify sample traps to collect such information as call stack data, function counts, basic block counts, PC profile counts, mallocs/frees, system calls, and page faults. Sample traps can use any of the triggers that stop traps use. Sample traps are often set up as pollpoints so that they collect data at set time intervals. LBL="" HELPID=""ID="42200"Setting Traps in Main View and Source ViewYou can set traps directly in Main View by using the Traps Menu or by clicking the mouse in the source annotation column. You can also specify traps in the Debugger command line.LBL="" HELPID=""Setting Traps With the Traps Menu in Main View The Traps Menu in Main View is shown in ID="4Traps7"IDREF="96767" TYPE="GRAPHIC"Figure 4-1.FILE="4Traps3.gif" POSITION="INLINE" SCALE="FALSE"LBL="4-1"Figure 4-1 ID="96767"Traps Menu in Main ViewTo set a trap using the Traps menu, you need to identify where the trap is to be located and its type. To set a stop trap at a line displayed in Main View (or Source View), click the cursor in the source annotation column next to the appropriate line in the source code and select "Set Trap," then "Stop" or "Sample."ID="4Traps8"For a trap at the beginning or end of a function, highlight the function name in the source code display area and select "Set Trap," then "Stop At Function Entry," "Stop At Function Exit," "Sample At Function Entry," or "Sample At Function Exit," as appropriate. ID="4Traps9"ID="4Traps10"ID="4Traps11"ID="4Traps12"The traps are indicated by icons in the source annotation column (and also appear in Trap Manager if you have it open). ID="4Traps13"IDREF="46985" TYPE="GRAPHIC"Figure 4-2 shows some typical trap icons. Sampling is indicated by a dot in the center of the icon. Traps appear in normal color or grayed out, depending on whether they are active or inactive. A transcript of the trap activity appears in the Debugger command line area. The active/inactive nature of traps is discussed in IDREF="20481" TYPE="TITLE""Enabling and Disabling Traps."The "Clear Trap" selection in the Traps menu deletes the trap on the line containing the cursor. You must designate a "Stop" or "Sample" trap type, since both types can exist at the same location, appearing superimposed on each other.ID="4Traps14"FILE="4Traps4.gif" POSITION="INLINE" SCALE="FALSE"LBL="4-2"Figure 4-2 ID="46985"Typical Trap IconsLBL="" HELPID=""Setting Traps With the MouseID="4Traps15"The quickest way to set a trap is to click in the source annotation column in Main View and Source View. A subsequent click removes the trap. When the trap is set, an icon appears representing the trap. If data collection mode has been specified in the Performance Data window, clicking produces a sample trap; otherwise, a stop trap is entered. (The way to tell if data collection is on is to look at the Debug option menu in the upper-right corner of the Debugger main view, and see whether it is set to "Debug Only," "Performance," or "Purify.")ID="4Traps16"LBL="" HELPID=""ID="21399"Setting Traps in Trap ManagerThe Trap Manager helps you manage all the traps involved with a process. Its two major functions are to list all traps in the process (except signals) and to let you add, delete, modify, or disable traps. The Trap Manager appears in ID="4Traps17"IDREF="45421" TYPE="GRAPHIC"Figure 4-3 with the Config, Traps, and Display menus displayed.ID="4Traps18"ID="4Traps19"ID="4Traps20"FILE="4Traps5.gif" POSITION="INLINE" SCALE="FALSE"LBL="4-3"Figure 4-3 ID="45421"Config, Traps, and Display Menus in the Trap Manager LBL="" HELPID=""ID="38093"Setting Single-process and Multiprocess Traps in the Trap: FieldID="4Traps21"New or modified traps are entered in the Trap: field. They have the general form:ID="4Traps22"[stop | sample] [all] [pgrp] <location | condition>The entry [stop | sample] refers to the trap action. You can set a default for it in the Traps menu ("Stop Trap Default" or "Sample Trap Default") and omit entering it at the beginning of the specification. The entries [all]ID="4Traps23" and [pgrp]ID="4Traps24" are used in multiprocess analysis. The [all] entry causes all processes in the process group to stop or sample when the trap fires. The [pgrp] entry sets the trap in all processes within the process group that contains the code where the trap is set. These will be entered by default if the "Stop All Default" and "Group Trap Default" toggles in the Traps menu are on.The specific syntaxes for the location and condition are shown below. After you enter the trap (by the Add or Modify button or by <Enter>), the full syntax of the specification appears in the field. The Clear button clears the Trap and Condition fields and the cycle fields. [stop | sample] [all] [pgrp] at [file filename] \[line line-number]Trap at the specified line in the specified file.[stop | sample] [all] [pgrp] addr instruction-address Trap on the specified instruction address.[stop | sample] [all] [pgrp] entry function [[file] \filename][stop | sample] [all] [pgrp] in function [[file] \filename]Trap on entry to the specified function. If the filename is given, the function is assumed to be in that file's scope.[stop | sample] [all] [pgrp] exit function [[file] \filename]Trap on exit from the specified function. If the filename is given, the function is assumed to be in that file's scope.[stop | sample] [all] [pgrp] ID="4Traps25"watch expression \[[for] read | write | execute [access]]Set a data watchpoint on the specified expression (using the address and size of the expression for the watchpoint span). The watchpoint may be specified to fire on write, read, or execution (or some combination thereof). If not specified, the write condition is assumed.[stop | sample] [all] [pgrp] watch addr[ess] address \[[size] size] [for] read | write | execute \ [access]]Set a watchpoint for the specified address and size in bytes. The watchpoint may be specified to fire on write, read, or execute (or some combination thereof) of memory in the given span. If not specified, the size defaults to 4 bytes.[stop | sample] [all] [pgrp] signal ID="4Traps26"signal-nameTrap on receipt of the given signal. Same as "catch" in dbx.[stop | sample] [all] [pgrp] syscall entry ID="4Traps27"sys-call-nameTrap on entry to the specified system call. This is slightly different from setting a trap on entry to the function by the same name. A syscall entry trap sets a trap on entry to the actual system call. A function entry trap sets a trap on entry to the stub function that calls the system call.[stop | sample] [all] [pgrp] syscall exit sys-call-nameTrap on exit from the specified system call. This is slightly different from setting a trap on exit from the function by the same name. A syscall exit trap sets a trap on exit from the actual system call. A function exit trap sets a trap on exit from the stub function that calls the system call.[stop | sample] pollpoint [interval] ID="4Traps28"time [seconds]Trap at regular intervals of time seconds. This is typically used for sampling only.Some typical trap examples are provided in ID="4Traps29"IDREF="43986" TYPE="GRAPHIC"Figure 4-4. The entries made in the Trap field are shown in the left portion of the figure, the trap display in Trap Manager resulting from these entries is shown on the right, and the trap display shown at the command line in Main View is shown at the bottom.FILE="4Traps6.gif" POSITION="INLINE" SCALE="FALSE"LBL="4-4"Figure 4-4 ID="43986"Trap ExamplesLBL="" HELPID=""Setting a Trap ConditionThe ID="4Traps30"Condition: field lets you specify a condition necessary for the trap to be fired. A condition can be any legal expression and will be true if it returns a nonzero value when the corresponding trap is encountered. The expression must be valid in the context in which it will be evaluated. For example, a Fortran condition like ID="4Traps31"a .gt. 2 cannot be evaluated if it is tested while the program is stopped in a C function.There are two possible sequences for entering a trap with a condition:Define the trap.Define the condition.Click Add.andDefine the trap.Click Add.Define the condition.Click Modify or press <Enter>.An example of a trap with a condition is shown in IDREF="43986" TYPE="GRAPHIC"Figure 4-4. The expression i==1 has been entered in the Condition: field. (If you were debugging in Fortran, you would use the Fortran syntax, for example,i .eq. 1.) After the trap has been entered, the condition appears as part of the trap definition in the display area. During execution, the requirements set by the trigger must be satisfied first for the condition to be tested. A condition is true if the expression (valid in the language of the program you are debugging) evaluates to a nonzero value. LBL="" HELPID=""Setting a Trap Cycle CountThe ID="4Traps32"Cycle Count field lets you pass through a trap a specific number of times without firing. If you set a cycle count of n, the trap will fire at the nth time the trap is encountered and every n iterations thereafter. The Current Count field indicates the number of times the process has passed the trap since either the cycle count was set or the trap last fired. The current count updates only when the process stops.LBL="" HELPID=""Setting a Trap With the Traps Menu and Source DisplayFILE="f05tmenu.gif" POSITION="MARGIN" SCALE="FALSE"LBL="4-5"Figure 4-5 ID="13090"Traps Menu in Trap ManagerThe Traps menu in Trap Manager (see ID="4Traps33"IDREF="13090" TYPE="GRAPHIC"Figure 4-5) lets you specify traps in conjunction with Main View or Source View. Clicking "At Source Line" sets a trap at the line in the source display area containing the current selection. To set a trap at the beginning or end of a function, you select the function name in the source display and then click "Entry Function" or "Exit Function." The trap set in all of these cases is governed by the defaults you have set in the menu.LBL="" HELPID=""Moving around the Trap Display AreaThe trap display area shows all traps set for the current process. You have vertical and horizontal scroll bars for moving around the display area. The ID="4Traps34"Search field lets you incrementally search for any string in any trap. LBL="" HELPID=""ID="20481"Enabling and Disabling TrapsEach trap has an indicator to its left for toggling back and forth between its active and inactive states. This feature lets you accumulate traps and turn them on only as needed. Thus, when you don't need the trap, it won't get in your way. When you do need it, it is readily re-enabled.LBL="" HELPID=""Saving and Reusing Trap SetsThe "Load Traps..." selection in the Config menu lets you bring in previously saved trap sets by means of a file browser window. This is useful for reestablishing a set of traps between debugging sessions. "Save Traps..." lets you save the current traps to a file.ID="4Traps35"ID="4Traps36"LBL="" HELPID=""ID="23429"Setting Traps With Signal Panel and Syscall PanelYou can trap signals using Signal Panel and system calls using Syscall Panel (see ID="4Traps37"ID="4Traps38"IDREF="79508" TYPE="GRAPHIC"Figure 4-6). FILE="f05sgnal.gif" POSITION="INLINE" SCALE="FALSE"LBL="4-6"Figure 4-6 ID="79508"Signal Panel and Syscall PanelBoth are selected from the Views menu in Main View. Signal Panel sets a trap on receipt of the signal(s) selected. Syscall Panel sets a trap at the selected entry to or return from the system call.LBL="5"ID="25765"Controlling Process ExecutionThis chapter tells you how to control process execution in CASEVision. It includes the following topics:ID="5ProcCon1"IDREF="15376" TYPE="TITLE""Main View Control Panel"IDREF="17348" TYPE="TITLE""Controlling Process Execution With PC Menu"IDREF="41270" TYPE="TITLE""Execution View"LBL="" HELPID=""ID="15376"Main View Control PanelID="5ProcCon2"Process execution is controlled using the top portion of the Main View window. See ID="5ProcCon3"IDREF="14287" TYPE="GRAPHIC"Figure 5-1. FILE="5ProcCon.gif" POSITION="INLINE" SCALE="FALSE"LBL="5-1"Figure 5-1 ID="14287"Main View Control PanelThe Main View window contains a row of execution control buttons that enable you to control program execution. The execution control buttons are located above the source display area. To use any of these commands, click on the appropriate button with the left mouse button. The Main View control panel is described below. LBL="" HELPID=""Status and Entry Fields in the Main View Control PanelThe panel contains the following fields:ID="5ProcCon4"CommandLets you enter the command for running the process with any argument(s).ID="5ProcCon5"StatusID="5ProcCon6"Displays information about the execution status of the program you are debugging. The top line in this box tells you whether the program is running or stopped. The next line lists the current call stack frame, if applicable. (To see all of the stack frames, open the Call Stack View from the Views menu.)LBL="" HELPID=""Execution Control ButtonsThe execution control buttons enable you to control program execution. The two control buttons for starting and terminating a process are:ID="5ProcCon7"ID="5ProcCon8"RunCreates a new process for the program and starts execution. It is also used to rerun the program.ID="5ProcCon9"ID="5ProcCon10"KillKills the active process.The control buttons used for process interruptions areID="5ProcCon11"ContinueResumes program execution after a halt and continues until a breakpoint or other event stops execution.ID="5ProcCon12"StopStops execution of the program. When program execution stops, the current source line is highlighted in the Main View and annotated with an arrow indicating the program counter (PC).ID="5ProcCon13"ID="5ProcCon14"Step IntoSteps to the next source line and into function calls. To step a specific number of lines, hold down the right mouse button over the Step Into button. This displays the popup menu shown in IDREF="55555" TYPE="GRAPHIC"Figure 5-2. You can select one of the fixed values or enter your own number of steps by selecting "N...". Selecting "N..." displays the dialog box shown at the right in IDREF="55555" TYPE="GRAPHIC"Figure 5-2.ID="5ProcCon15"FILE="5ProcCon2.gif" POSITION="INLINE" SCALE="FALSE"LBL="5-2"Figure 5-2 ID="55555"Step Into Popup Menu and Dialog BoxID="5ProcCon16"Step OverSteps to the next source line and over function calls. To step a specific number of lines, hold down the right mouse button over the Step Over button. This displays the popup menu shown in IDREF="92066" TYPE="GRAPHIC"Figure 5-3. You can select one of the fixed values or enter your own number of steps by selecting "N...". Selecting "N..." displays the dialog box shown at the right in IDREF="92066" TYPE="GRAPHIC"Figure 5-3.ID="5ProcCon17"FILE="5ProcCon3.gif" POSITION="INLINE" SCALE="FALSE"LBL="5-3"Figure 5-3 ID="92066"Step Over Popup Menu and Dialog BoxID="5ProcCon18"ReturnExecutes the remaining instructions in the current function. Program execution stops upon return from that procedure.There is one button in the control panel for spontaneous sampling:ID="5ProcCon19"SampleCollects performance data when clicked. A performance task must have been previously specified in the Performance Task window and data collection must have been enabled.LBL="" HELPID=""ID="17348"Controlling Process Execution With PC MenuThe PC (program counter) menu in Main View provides a quick and informal means of controlling process execution. See ID="5ProcCon20"IDREF="93270" TYPE="GRAPHIC"Figure 5-4.ID="5ProcCon21"FILE="f06pc.gif" POSITION="MARGIN" SCALE="FALSE"LBL="5-4"Figure 5-4 ID="93270"PC Menu in Main ViewThese options let you manually control process execution without setting traps. The target location is determined by the location of the cursor in the source display area. There are two selections:ID="5ProcCon22""Continue To"ID="5ProcCon23"Lets you select a target location in the current process (by placing the cursor in the line). The process proceeds from the current PC to that point (provided there are no interruptions) and stops there, as it would for a stop trap. "Continue To" is equivalent to setting a one-time trap. If the process is interrupted before reaching the target location, then the command is cancelled.ID="5ProcCon24""Jump To"ID="5ProcCon25"Lets you select a target location in the current process (by placing the cursor in the line). The location must be in the same function. Instead of starting from the current PC, "Jump To" skips over any intervening code and restarts the process at the target. This is particularly useful if you want to get around bad code or irrelevant portions of the program. It also lets you back up and re-execute a portion of code.LBL="" HELPID=""ID="41270"Execution ViewID="5ProcCon26"The Execution View window is a simple shell that lets you set  environment variables and inspect error messages. Your target program I/O, if any, is displayed in the Execution View window. If the program is I/O-based, then all interaction takes place in Execution View.ID="5ProcCon27"ID="5ProcCon28"NoteWhen you launch the debugger, the Execution View is launched in iconified form.LBL="6"ID="24462"Examining Debugger DataID="6ExmnData1"After you have learned how to set traps in CASEVision, the next step is to look at the facilities for examining the data. This chapter covers:IDREF="55087" TYPE="TITLE""Tracing Through Call Stack View"IDREF="38851" TYPE="TITLE""Evaluating Expressions"The Debugger also lets you examine data at the machine level. The tools for viewing disassembled code, machine registers, and data by specific memory location are described in IDREF="46334" TYPE="TITLE"Appendix A, "Debugger Reference."LBL="" HELPID=""ID="55087"Tracing Through Call Stack ViewThe Call Stack View window displays the functions in the call stack (referred to as ID="6ExmnData2"ID="6ExmnData3"ID="6ExmnData4"frames) when the process has stopped. The window is shown in IDREF="50813" TYPE="GRAPHIC"Figure 6-1 with the major menus displayed.FILE="6ExmnData.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-1"Figure 6-1 ID="50813"Call Stack View Window With Config and Display Menus and Preferences Dialog BoxIn addition to the functions, the Call Stack View window lets you see the argument names, values, and types as well as the locations of the functions and the PC. If symbolic information for the arguments has been stripped from the executable, the label <stripped> will appear in place of the arguments, as in the function _start in the above example. You also have the option of setting the maximum depth of the Call Stack View by selecting "Preferences..." from the Config menu. To move through the call stack, you simply double-click a frame in the stack. The frame becomes highlighted to indicate the current context. The source display in Main View (or Source View) scrolls automatically to the location where the function was called, and any other active views (such as the Variable Browser or Structure Browser) will update. The source display has two special annotations:The location of the current program state is indicated by a large green (depending on color scheme) arrow representing the PC.The location of the call to the function selected in the Call Stack View window is indicated by a smaller blue (depending on color scheme) arrow representing the current context, and the source line becomes highlighted.IDREF="26275" TYPE="GRAPHIC"Figure 6-2 illustrates the correspondence between a frame and the source code when a frame is clicked in the Call Stack View window. In this example, the stack frame spin has been selected; Main View scrolls to the place where the trap occurred. If the second stack (main) had been selected, then the window would have scrolled to the place where the function main calls spin.FILE="f07sttrc.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-2"Figure 6-2 Tracing Through Call Stack ViewID="26275"LBL="" HELPID=""ID="38851"Evaluating ExpressionsYou can evaluate any valid expression (in C, C++, or Fortran) at a stopping point in the process and trace it through the process. Expressions are evaluated by default in the frame and language of the current context. Expressions may contain data names or constants; however, they may not contain names known only to the C pre-processor, as in a #define directive or a macro.To evaluate expressions, you can use the Expression View, which lets you evaluate multiple expressions simultaneously, updating their values each time the process stops.NoteExpressions can also be evaluated from the command line.LBL="" HELPID=""Expression ViewThe Expression View window is shown in ID="6ExmnData5"IDREF="37551" TYPE="GRAPHIC"Figure 6-3 with its major menus displayed. Note that Expression View has two popup menus. The Language menu is invoked by holding down the right mouse button while the cursor is in the Expression column. The Format menu is displayed by holding down the right mouse button in the Result column.ID="6ExmnData6"ID="6ExmnData7"ID="6ExmnData8"ID="6ExmnData9"To specify the expression to be evaluated, first click in the Expression column, on the left side of the window, then enter the expression in the selected field. This expression can be typed directly or pasted in from the source code display. It must be a valid expression in the current or selected language: C, C++, or Fortran. To change languages, display the Language menu and make your selection. When you press <Enter>, the result of the expression is displayed in the right column.FILE="6ExmnData3.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-3"Figure 6-3 ID="37551"Expression View With Major Menus DisplayedIf you want to change the type of result information displayed in the right column, hold down the right mouse button over the right column. This displays the Format menu. You can see the value asa string, or as decimal, unsigned, octal, hexadecimal, float, or characters. You can also display the type, the address (in decimal, octal, or hex), or the size of the result in bits.CautionThe CASEVision Debugger uses the target program's symbol table to determine the types of variables. Some variables in libraries, such as errno and _environ, are not fully described in the symbol table. As a result, the Debugger may not know their types. When the Debugger evaluates such a variable, it assumes that the variable is a full-word integer. This gives the correct value for full-word integers or pointers, but the wrong value for non-full-word integers and for floating-point values. To see the value correctly of a variable of unknown type, you can cast the address of the variable to a pointer to the correct type, using C type-cast syntax. For example, the global variable _environ should be of type char**. You can see its value by evaluating *(char***)&_environ.After you display the current value of the expression, you may find it useful to leave the window open so that you can trace the expression as it changes value from trap to trap (or when you change the current context by double-clicking in the callstack). Like the other views involved with variables, Expression View has variable change indicators for value fields that let you see previous values, as shown in IDREF="97073" TYPE="GRAPHIC"Figure 6-4. FILE="6ExmnData4.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-4"Figure 6-4 ID="97073"Change Indicators in Expression ViewAnother useful technique is to save your expressions to a file for later reuse. Expressions are saved by choosing "Save Expressions..." from the Config menu and retrieved by selecting "Load Expressions..." ID="6ExmnData10"ID="6ExmnData11"LBL="" HELPID=""Assigning Values to VariablesID="6ExmnData12"To assign a value to a variable, click the left column and enter the variable name. The current value appears in the right column. If this Result field is editable (highlighted), you can click it and enter a new value or legal expression. Pressing <Enter> performs the assignment. You can perform an assignment to any expression that evaluates to a legal lvalue (in C). The C operator = is not valid in Expression View. The valid expression operations are shown in the following paragraphs.LBL="" HELPID=""Evaluating Expressions in CThe valid C expressions are shown in ID="6ExmnData13"IDREF="62391" TYPE="TABLE"Table 6-1. COLUMNS="2"LBL="6-1"Table 6-1 ID="62391"Valid C OperationsLEFT="0" WIDTH="90"OperationLEFT="95" WIDTH="216"SymbolLEFT="0" WIDTH="90"Arithmetic (unary)LEFT="95" WIDTH="216"+ - ++ -- (increment and decrement do not have side effects)LEFT="0" WIDTH="90"Arithmetic (binary)LEFT="95" WIDTH="216"+ - * / % LEFT="0" WIDTH="90"LogicalLEFT="95" WIDTH="216"&& || !LEFT="0" WIDTH="90"RelationalLEFT="95" WIDTH="216"< > <= >= == !=LEFT="0" WIDTH="90"Bit LEFT="95" WIDTH="216" & | ^ << >> ~LEFT="0" WIDTH="90"DereferenceLEFT="95" WIDTH="216"*LEFT="0" WIDTH="90"AddressLEFT="95" WIDTH="216"&LEFT="0" WIDTH="90"Array indexingLEFT="95" WIDTH="216"[ ]LEFT="0" WIDTH="90"Conditional LEFT="95" WIDTH="216"? :LEFT="0" WIDTH="90"Member extractionLEFT="95" WIDTH="216". -> (these operations are interchangeable)LEFT="0" WIDTH="90"SizeofLEFT="95" WIDTH="216"LEFT="0" WIDTH="90"Type-castLEFT="95" WIDTH="216"LEFT="0" WIDTH="90"Function callLEFT="95" WIDTH="216"LEFT="0" WIDTH="90"AssignmentLEFT="95" WIDTH="216"  =  +=  -=  /=  %=  >>=  <<=  &=  ^=  |=(Note that a new assignment is made at each stepping 
point. Use assignments with caution to avoid 
inadvertently modifying variables. )LBL="" HELPID=""C Function CallsID="6ExmnData14"Function calls can be evaluated in expressions, as long as enough actual parameters are supplied. Arguments are passed by value. Following the rules of C, each actual parameter is converted to a value of the same type as the formal parameter, before the call. If the types of the formal parameters are unknown, integral arguments are widened to full words, and floating-point arguments are converted to doubles.Functions may return pointers, scalar values, unions, or structs. Note that if the function returns a pointer into its stack frame (rarely a good programming practice), the value pointed to will be meaningless, since the temporary stack frame is destroyed immediately after the call is completed.Function calls may be nested. For example, if the user's program contains a successor function succ, the Debugger will evaluate the expression succ(succ(succ(3))) to 6.LBL="" HELPID=""Evaluating Expressions in C++C++ expressions may contain any of the C operations. You can use the word ID="6ExmnData15"this to explicitly reference data members of an object in a member function. When stopped in a member function, the scope for this is searched automatically for data members. Names may be used in either mangled or demangled form. Names qualified by class name are supported (for example, Symbol::a). If you wish to look at a static member variable for a c++ class, you need not specify the variable with the class qualifier if you are within the context of the class. For example, you would specify myclass::myvariable for the static variable myvariable outside of class myclass and myvariable inside myclass.LBL="" HELPID=""LimitationsConstructors may be called from Expression View, just like any other member function. To call a constructor, you must pass in a first argument that points to the object to be created. C++ function calls have the same possibility of side effects as C functions.LBL="" HELPID=""Evaluating Expressions in FortranFortran expressions may contain any of the arithmetic, relational, or logical operators. Relational and logical operator keywords may be spelled in upper case, lower case, or mixed case.ID="6ExmnData16"The usual forms of Fortran constants, including complex constants, may be used in expressions. String constants and string operations, however, are not supported. The operators in IDREF="51448" TYPE="TABLE"Table 6-2 are supported on data of integral, real, and complex types.COLUMNS="2"LBL="6-2"Table 6-2 ID="51448"Valid Fortran OperationsLEFT="0" WIDTH="126"OperationLEFT="135" WIDTH="180"SymbolLEFT="0" WIDTH="126"Arithmetic (unary)LEFT="135" WIDTH="180"- +LEFT="0" WIDTH="126"Arithmetic (binary)LEFT="135" WIDTH="180"- + * / **LEFT="0" WIDTH="126"LogicalLEFT="135" WIDTH="180".NOT. .AND. .OR. .XOR. .EQV .NEQV.LEFT="0" WIDTH="126"RelationalLEFT="135" WIDTH="180".GT. .GE. .LT. .LE. .EQ. .NE.LEFT="0" WIDTH="126"Array indexingLEFT="135" WIDTH="180"( )LEFT="0" WIDTH="126"Intrinsic function calls (except 
string intrinsics)LEFT="135" WIDTH="180"LEFT="0" WIDTH="126"Function subroutine callsLEFT="135" WIDTH="180"LEFT="0" WIDTH="126"AssignmentLEFT="135" WIDTH="180"=  (Note that a new assignment is made at 
each stepping point. Use assignments with 
caution to avoid inadvertently modifying 
variables. )LBL="" HELPID=""Fortran VariablesID="6ExmnData17"Names of Fortran variables, functions, parameters, arrays, pointers, and arguments are all supported in expressions, as are names in common blocks and equivalence statements. Names may be spelled in upper case, lower case, or mixed case.LBL="" HELPID=""Fortran Function CallsID="6ExmnData18"The Debugger evaluates function calls the same way that compiled code does. If an argument can be passed by reference, it is; otherwise, a temporary expression is allocated and passed by reference. Following the rules of Fortran, actual arguments are not converted to match the types of formal arguments. Side effects can be caused by Fortran function calls. A useful technique to protect the value of a parameter from being modified by a function subroutine is to pass an expression such as (parameter + 0) instead of just the parameter name. This causes a reference to a temporary expression to be passed to the function rather than a reference to the parameter itself; the value is the same.LBL="7"ID="39823"Debugging with Fix+Continue: A TutorialThis chapter provides an interactive sample session that demonstrates most of the Fix and Continue functions. The session outlines common tasks you can perform with Fix and Continue, using example C++ application source to illustrate the use of each function. For complete reference information on the Fix and Continue user interface, see ID="7TutF+C1"ID="7TutF+C2"IDREF="12535" TYPE="TITLE""Fix+Continue Windows".Most steps in the session let you use either the graphical interface or the command-line alternatives.This chapter contains the following sections:IDREF="67925" TYPE="TITLE""Setting Up the Sample Session"IDREF="68957" TYPE="TITLE""Redefining a Function"IDREF="99836" TYPE="TITLE""Setting Breakpoints in Redefined Code"IDREF="64510" TYPE="TITLE""Viewing Status"IDREF="73543" TYPE="TITLE""Comparing Original and Redefined Code"IDREF="75661" TYPE="TITLE""Ending the Session"LBL="" HELPID=""ID="67925"Setting Up the Sample SessionFor this tutorial, use the demo files in the directory ID="7TutF+C3"/usr/demos/WorkShop/bounce, which contain the complete source code for the C++ application bounce. To prepare for the session, you first need to create FILE="iconIExec.gif" POSITION="MARGIN" SCALE="FALSE"LBL="7-1"Figure 7-1 ID="87353"Execution View Icon
the fileset, then launch Fix and Continue from the Debugger. You must enter the commands listed below:cd /usr/demos/WorkShop/bouncemake bouncecvd bounce &The cvd command brings up the CaseVision Debugger, from which you can use the Fix and Continue utility. The Execution View icon (shown in IDREF="87353" TYPE="GRAPHIC"Figure 7-1) and Main View (shown in IDREF="99521" TYPE="GRAPHIC"Figure 7-2) appear. Note that the Debugger shows that the source code status indicator is ID="7TutF+C4"(Read Only).FILE="debugMainFC.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-2"Figure 7-2 Debugger Main View With Fix and Continue MenuOpen the Execution View and position the window so you can see it and the Debugger Main View.To see what the program does, click Run. The bounce program opens a window on your desktop. Click Run in the new window, and then add balls from the Actors Menu to see how the program executes. (You may need to resize the bounce window.)The Execution View shows the program output (see IDREF="86102" TYPE="GRAPHIC"Figure 7-3).FILE="FCexecV.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-3"Figure 7-3 ID="86102"Program Results in Execution ViewIf your screen shows different results, the program files may have been modified during a previous tutorial session.LBL="" HELPID=""ID="68957"Redefining a FunctionIn this section, you will do the following:ID="7TutF+C5"edit a functionchange the code of an existing function and then parse and load the function, rebuilding your program to see the effect of your changes on program output (without recompiling) save the changed function to its own separate fileLBL="" HELPID=""Editing a FunctionChoose a function to edit by entering the following on the command line:cvd> func Clock::speedChanged This opens the file Clock.C, and places the cursor at the beginning of the function Clock::speedChanged, as shown in IDREF="20265" TYPE="GRAPHIC"Figure 7-4.FILE="selectFunc.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-4"Figure 7-4 Selecting a Function for RedefinitionShow line numbers by selecting "Show Line Numbers" from the Debugger Display menu.ID="7TutF+C6"Select "Edit" from the Debugger Fix+Continue menu, or enter the Alt-Ctrl-E keyboard accelerator. The function is highlighted.Note the results as shown in IDREF="23989" TYPE="GRAPHIC"Figure 7-5. Line numbers change to a decimal notation based on the first line number of the function body. The function body highlights to show that it is being edited. The line numbers of the rest of the file are not affected.FILE="redefFunc.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-5"Figure 7-5 Redefined FunctionLBL="" HELPID=""Changing CodeTo increase the speed of the ball, change the value of ID="7TutF+C7"_delta from 1000 / value to 100 / value.Click the Stop button in the Debugger to halt the bounce process.Select "Parse and Load" from the Debugger Fix+Continue menu, or enter the Alt-Ctrl-X keyboard accelerator. If there are any errors, the Fix+Continue error messages window opens as shown in IDREF="37188" TYPE="GRAPHIC"Figure 7-6. The Debugger command line also gives a report. If all went as planned, there are no errors or warnings.FILE="FCparse-res.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-6"Figure 7-6 ID="37188"Checking Syntax Opens Fix and Continue Status WindowIf you do have an error, correct it and repeat steps 1-3. You can go to the error location by double-clicking the appropriate line in the error message window. When you see the change ID and activated status, as shown in IDREF="16684" TYPE="GRAPHIC"Figure 7-7, continue with the next step.When the parse and load has completed, the highlighting color of the function changes.FILE="reportRedef.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-7"Figure 7-7 Report of Successful RedefinitionSelect Continue from the Debugger main view. The new value is not active until the function is called. To call the function, adjust the slider bar in the bounce window (see IDREF="67864" TYPE="GRAPHIC"Figure 7-8).FILE="bounceWin.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-8"Figure 7-8 ID="67864"bounce WindowLBL="" HELPID=""Deleting Changed CodeIf you make a mistake, there's a graceful way out. Suppose for example that you decided you didn't want to change the speed after all. To delete the change, you need merely select the "Delete Edits" option from the Fix+Continue menu in the Source view.ID="7TutF+C8"LBL="" HELPID=""Changing Code From the Debugger Command LineAs an alternative to using the Fix and Continue menu, you can redefine and check syntax for a function from the Debugger command line. Try changing ID="7TutF+C9"_delta to 100 by entering the following at the command line:cvd> replace_source "Clock.C":83
"Clock.C":84.0> 
"Clock.C":84.1> 
"Clock.C":84.2> _delta = 100 / value;
"Clock.C":84.3> .This generates the following output:Change id: 4 redefined
Change id: 4 modified
Process 5779 stopped at ["select.s":12, 0x0fac2010]
Change id: 4 activated
Change id: 4 , build results:
  4  enabled  /usr/demos/WorkShop/bounce/Clock.C  Clock::speedChanged(int)
cvd> If you prefer to use the command line, experiment with add_source and redefine to get the same functionality described for the menu commands. For details on each command, refer to IDREF="76970" TYPE="TITLE""Debugger Command Line".LBL="" HELPID=""Saving ChangesYour original source files are not updated until the changed source file is saved. You could save redefined function changes to ID="7TutF+C10"Clock.C. However, if you did, the file would not match the tutorial. So just observe the following steps:Select "Save As..." from the Fix+Continue menu. Look at the features of the dialog box (see IDREF="72589" TYPE="GRAPHIC"Figure 7-9) that enable you to save your file. To save the changes back to the original source files, click that radio button and then click Apply or OK. To save to a different file, click the other radio button, choose a suffix, and click Apply or OK. Since you don't want to save the changes, press Cancel. Alternatively, on the Debugger command line, you could type save_changes -file Clock.C Clock.C. Either method saves all the changes to the file, replacing the compiled source code.FILE="saveFunc.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-9"Figure 7-9 Saving a Function FileYou usually want to wait until you are finished with Fix and Continue before you save your changes. In addition to the method described above, you can also save your changes with the "Save All Files..." option of the Fix+Continue menu. See IDREF="15402" TYPE="TITLE""Fix+Continue Menu" for more information.LBL="" HELPID=""ID="99836"Setting Breakpoints in Redefined CodeTo see how the Debugger works with traps (breakpoints) in redefined code you'll set breakpoints, run the Debugger, and view the results.ID="7TutF+C11"Choose the function BouncingBall::BouncingBall by entering the following on the command line:cvd> func BouncingBall::BouncingBall This opens the file BouncingBall.C, and places the cursor at the beginning of the function BouncingBall::BouncingBall.Select "Edit" from the Fix+Continue menu or enter Alt-Ctrl-E.Enter the following line after line 35.3:#define SIZE 15This makes the size of the balls smaller.Select "Parse and Load" from the Fix+Continue menu.Set a breakpoint just after your new SIZE definition by clicking in the source annotation column at line 35.5.Alternatively, you can set a breakpoint through the command line by entering stop at # or b # where # is the line number at which you want your breakpoint. Note that in code that has already been parsed and loaded, the line number is in decimal notation.FILE="FCbreak.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-10"Figure 7-10 Stopping After Breakpoints in Redefined CodeSelect Run, then in the bounce window pull down the Actors menu and select "Add Red Ball". The Debugger command line reports that the process stopped at some point in the code. You see the following information in the Debugger command line:[1] Stop at file /usr/demos/WorkShop/bounce/BouncingBall.C line 35.6
[0] Process 595 stopped at ["BouncingBall.C":35, 0x004088d0]Select "Call Stack" from the Views menu to view the results of the breakpoint (see ID="7TutF+C12"IDREF="53711" TYPE="GRAPHIC"Figure 7-11).FILE="callSV.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-11"Figure 7-11 ID="53711"Call Stack BreakPoint ResultsSelect "Trap Manager" from the Views menu to view the locations of the traps (see ID="7TutF+C13"IDREF="32160" TYPE="GRAPHIC"Figure 7-12).FILE="trap.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-12"Figure 7-12 ID="32160"Trap Manager BreakPoint ResultsRemove the breakpoint by clicking on it in the source annotation column.LBL="" HELPID=""ID="64510"Viewing StatusPull down the Fix+Continue menu, choose the Views submenu, and select "Status Window". The View Status window opens, as shown in ID="7TutF+C14"IDREF="78770" TYPE="GRAPHIC"Figure 7-13.FILE="statMen.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-13"Figure 7-13 ID="78770"Using the View Status WindowLBL="" HELPID=""ID="73543"Comparing Original and Redefined CodeYou can compare your modified code to the original source when using Fix and Continue. This section shows you several ways to view your changes.ID="7TutF+C15"LBL="" HELPID=""Switching Between Compiled and Redefined CodeIf you want to see how the redefined code makes your executable different, follow these steps:ID="7TutF+C16"Select Run to view your redefined code. Notice that the balls you add are smaller in your modified version.Place the insertion point in function BouncingBall.Select "Edit<-->Compiled" from the Fix+Continue menu. This disables your changes.Select Continue. Notice that the balls you add are now their original size, and that the Debugger command line states that the change has been deactivated.You can get the same results by entering the command disable_changes# from the Debugger command line, where # is the redefined function ID number.To re-enable your changes, do the following:ID="7TutF+C17"Select Stop.Select "Edit<-->Compiled" from the Fix+Continue menu. This re-enables your changes. The balls you add will now be smaller.You can get the same results by entering the command enable_changes# at the Debugger command line.LBL="" HELPID=""Comparing Function DefinitionsPlace the insertion point in the ID="7TutF+C18"BouncingBall function body.Pull down the Fix+Continue menu, choose the Show Difference submenu, and select "For Function". A xdiff window opens as shown in IDREF="51600" TYPE="GRAPHIC"Figure 7-14. FILE="FCxdiff.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-14"Figure 7-14 ID="51600"Comparing Compiled vs. Redefined Function Code: xdiffYou can get the same result by entering the command show_diff# from the Debugger command line.If you don't like ID="7TutF+C19"xdiff, you can change the comparison tool by pulling down the Fix+Continue menu, choosing the Show Difference submenu, and selecting "Set Diff Tool...".LBL="" HELPID=""Comparing Source Code FilesWhen you have made several redefinitions to a file, sometimes you need a side-by-side comparison of the entire file. To see how your changes to the file look, pull down the Fix+Continue menu, choose the Show Difference submenu, and select "For Function". This opens a ID="7TutF+C20"xdiff window that displays the entire file, rather than just the function.You'll get the same result from the Debugger command line if you enter the following:show_diff -file BouncingBall.CAs an alternative to pulling down menus using the mouse, you can use mnemonics to select the menu item from the keyboard. After closing the difference window, you'll reopen it. With the insertion point anywhere in the file, enter the following:Alt-f d fLBL="" HELPID=""ID="75661"Ending the SessionExit the Debugger by pulling down the Admin menu and choosing "Exit".ID="7TutF+C21"LBL="8"ID="12096"Detecting Heap CorruptionThis chapter describes heap corruption detection and covers the following topics:ID="8Heaps1"IDREF="23866" TYPE="TITLE""Typical Heap Corruption Problems"IDREF="15431" TYPE="TITLE""Detecting Heap Corruption Errors"IDREF="35701" TYPE="TITLE""Heap Corruption Detection Tutorial"LBL="" HELPID=""ID="23866"Typical Heap Corruption ProblemsDue to the dynamic nature of allocating and deallocating memory, the heap is vulnerable to these common corruption problems:ID="8Heaps2"ID="8Heaps3"Boundary overrunoccurs when a program writes beyond the malloc region.Boundary underrunID="8Heaps4"occurs when a program writes in front of the malloc region.ID="8Heaps5"Access to uninitialized memoryoccurs when a program attempts to read memory that has not yet been initialized.ID="8Heaps6"Access to freed memoryoccurs when a program attempts to read or write to memory that has been freed.ID="8Heaps7"Double freesoccur when a program frees some structure that it had already freed. In such a case, a subsequent reference can pick up a meaningless pointer, causing a segmentation violation. Erroneous freesID="8Heaps8"occur when a program calls free() on addresses that were not returned by malloc, such as static, global, or automatic variables, or other invalid expressions.LBL="" HELPID=""ID="15431"Detecting Heap Corruption ErrorsTo detect heap corruption problems, you need to relink your executable with a special WorkShop malloc library (-lmalloc_cv) instead of the standard malloc library (-lmalloc). By default, the library always catches these errors:malloc call failing (returning NULL)realloc call failing (returning NULL)realloc call with an address outside the range of heap addresses returned by malloc or memalignmemalign call with an improper alignmentfree call with an address that is improperly alignedfree call with an address outside the range of heap addresses returned by malloc or memalignIf you additionally set the MALLOC_FASTCHK environment variable, you can detect these errors:free or realloc calls where the words prior to the user block have  been corruptedfree or realloc calls where the words following the user block have  been corruptedfree or realloc calls where the address is that of a block that has already been freed. This error may not always be detected if the area around the block is reallocated after it was first freed.LBL="" HELPID=""ID="20451"Compiling With the Malloc LibraryYou can compile your executable from scratch as follows:cc -g -o targetprogram targetprogram.c -lmalloc_cvYou can also relink it by using:ld -o targetprogram targetprogram.o -lmalloc_cv ...An alternative to rebuilding your executable is to use the environment variable _RLD_LIST to link the -lmalloc_cv library. See the reference (man) page for rld(1).LBL="" HELPID=""ID="45069"Setting the Environment VariablesAfter compiling, you invoke the Debugger with your executable as the target. In Execution View, you can set environment variables to enable different levels of heap corruption detection from within the malloc library, as follows:MALLOC_CLEAR_FREEclears the data in any memory allocation freed by free. It also requires that MALLOC_FASTCHK be set. MALLOC_CLEAR_FREE_PATTERN <pattern> specifies a pattern to clear the data if MALLOC_CLEAR_FREE is  enabled. The default pattern is 0xcafebeef for the 32-bit version,  and 0xcafebeefcafebeef for the 64-bit versions. Only full words (double words for 64-bits) are cleared to the pattern.MALLOC_CLEAR_MALLOCclears the data in any memory allocation returned by malloc. It also requires that MALLOC_FASTCHK be set. MALLOC_CLEAR_MALLOC_PATTERN <pattern>specifies a pattern to clear the data if MALLOC_CLEAR_MALLOC is   enabled. The default pattern is 0xfacebeef for the 32-bit version, and 0xfacebeeffacebeef for the 64-bit versions. Only full words   (double words for 64-bits) are cleared to the pattern.MALLOC_FASTCHKenables certain additional corruption checks when you call the routines in this library, libmalloc_cv. Error detection is done by allocating a space larger than the requested area, and putting "guard words", that is, specific patterns, in front of and behind the area returned to the caller. When free or realloc is called on a block, its guard words are checked, and if the area was overwritten, an error message is printed to stderr using an internal call to the routine cvmalloc_error. Under the Debugger, a trap may be set at exit from this routine to catch the program at the error.MALLOC_MAXMALLOC n(where n is an integer, in any base) sets a maximum size for any malloc or realloc allocation. Any request exceeding that size is flagged as an error, and returns a NULL pointer. MALLOC_NO_REUSEspecifies that no area that has been freed can be reused. With this option enabled, no actual free calls are really made, and the process space and swap requirements can grow quite large.MALLOC_TRACING prints out all the malloc events including address and size of the malloc or free. Tracing is normally done in the course of a performance experiment; the variable need not be set in such cases, because the running of the experiment automatically enables it. If the option is enabled when the program is run independently, and MALLOC_VERBOSE is set to 2 or greater, the trace events and program call stacks are written to stderr.MALLOC_VERBOSEcontrols message output. If set to 1, minimal output displays; if set to 2, full output displays.For further information, see the reference page for malloc_cv.LBL="" HELPID=""Trapping Heap Errors using the Malloc LibraryIf you are using the -lmalloc_cv library, you can use the Trap Manager to set a stop trap at the exit from the function cvmalloc_error which is called when an error is detected. Errors are detected only during calls to heap management routines, such as malloc() and free(). Some kinds of errors, such as overruns, are not detected until the block is freed or realloced.When you run the program, it will halt at the stop trap if a heap corruption error is detected. The error and the address are displayed in Execution View. You can also examine the Call Stack View at this point to get stack information. To find the next error, click the Continue button.If you need more information to isolate the error, set a watchpoint trap to detect a write at the displayed address; then run your program again. Use MALLOC_CLEAR_FREE and MALLOC_CLEAR_MALLOC to catch problems from attempts to access uninitialized or freed memory.NoteYou can run programs linked with -lmalloc_cv library outside of the Debugger. The trade-off is that you have to browse through the stderr messages and catch any errors through visual inspection.LBL="" HELPID=""ID="35701"Heap Corruption Detection TutorialThis tutorial demonstrates how to detect corruption errors, using a program called corrupt. The corrupt program has already been linked with the WorkShop malloc library (libmalloc_cv). Its listing follows:#include <string.h>
void main (int argc, char **argv)
{
 char *str;
 int **array, *bogus, value;

 /* Let us malloc 3 bytes */
 str = (char *) malloc(strlen("bad"));

 /* The following statement writes 0 to the 4th byte */
 strcpy(str, "bad");

 free (str);

 /* Let us malloc 100 bytes */
 str = (char *) malloc(100);
 array = (int **) str;

 /* Get an uninitialized value */
 bogus = array[0];

 free (str);
 /* The following is a double free */
 free (str);

 /* The following statement uses the uninitialized value as a pointer */
 value = *bogus;
}Go to the directory /usr/demos/WorkShop/mallocbug.Invoke the Debugger by typing:cvd corrupt &The Debugger Main View window displays with corrupt as the target executable.Open the Execution View window (if it is minimized) and set the MALLOC_FASTCHK and MALLOC_CLEAR_MALLOC environment variables.If you are using the C shell, type: setenv MALLOC_FASTCHK setenv MALLOC_CLEAR_MALLOC If you are using the Korn or Bourne shell, type: MALLOC_FASTCHK=MALLOC_CLEAR_MALLOC=export MALLOC_FASTCHK MALLOC_CLEAR_MALLOCSelect "Trap Manager" from the Views menu in Main View.Type the following command in the Trap field of the Trap Manager window and click Add:Stop exit cvmalloc_errorA stop trap is set at the exit from the malloc library routine cvmalloc_error. This stops the process when a heap corruption error is detected. The Trap Manager is shown in IDREF="85199" TYPE="GRAPHIC"Figure 8-1 with the stop trap set.FILE="8Heaps2.gif" POSITION="INLINE" SCALE="FALSE"LBL="8-1"Figure 8-1 ID="85199"Setting Traps to Detect Heap CorruptionClick Run in the Main View control panel to start program execution and observe Execution View.A heap corruption is detected and the process stops at one of the traps. The type of error and its address display in Execution View as shown in IDREF="59576" TYPE="GRAPHIC"Figure 8-2.FILE="f09exec.gif" POSITION="INLINE" SCALE="FALSE"LBL="8-2"Figure 8-2 ID="59576"Heap Corruption Warning Displayed in Execution ViewSelect "Call Stack" from the Views menu in Main View.Call Stack View is opened displaying the call stack frame at the time of the error (see IDREF="16575" TYPE="GRAPHIC"Figure 8-3).FILE="f09cstck.gif" POSITION="INLINE" SCALE="FALSE"LBL="8-3"Figure 8-3 ID="16575"Call Stack at Boundary Overrun WarningClick Continue in the Main View control panel and watch Execution View and Call Stack View.The process continues from the stop at the boundary overrun warning until it hits the next trap where an erroneous free error occursClick Continue again and watch Execution View and Call Stack View.This time the process stops at a bus error. The PC stops at the statement:value=*bogusbecause bogus was set to an uninitialized value. Type p &bogus at the Debugger command line at the bottom of the Main View window.This gives us the address for the variable bogus and has been done in IDREF="65212" TYPE="GRAPHIC"Figure 8-4. We need the bad address so that we can set a watchpoint to find out when it is written to. (Note in this example that the address is 0x7fffaef4name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'your address will be different.)FILE="8Heaps.gif" POSITION="INLINE" SCALE="FALSE"LBL="8-4"Figure 8-4 ID="65212"Main View at Bus ErrorDeactivate the stop trap by clicking the toggle button next to the trap description in the Trap Manager window, and click Kill in Main View to kill the process.Type the following command in the Trap field in the Trap Manager using the address you obtain from the Debugger command line (see IDREF="65212" TYPE="GRAPHIC"Figure 8-4) and click Add:stop watch address 0x7fffaef4 for writeUse the actual address from your system, not the one in the tutorial. This sets a watchpoint that is triggered if a write is attempted at that address. Click Run and observe Main View.The process stops at the point where the variable bogus gets a bad value. The details of the error display in the Main View Status field (see IDREF="12431" TYPE="GRAPHIC"Figure 8-5).FILE="8Heaps5.gif" POSITION="INLINE" SCALE="FALSE"LBL="8-5"Figure 8-5 ID="12431"Watch Point Error Displayed in Main ViewLBL="9"ID="37759"Multiple Process DebuggingWorkShop supports performance analysis and debugging of multiprocess applications, including processes spawned either with fork or sproc. You can perform process control operations on a single process or on all members of a process group. You can attach WorkShop automatically to child processes. You can also specify spawned processes to inherit traps. The Trap Manager provides special trap commands to facilitate debugging multiple processes simultaneously.This chapter discusses the details of multiprocess debugging in WorkShop and includes the following topics:IDREF="10675" TYPE="TITLE""Debugging With Multiprocess View"IDREF="26149" TYPE="TITLE""Controlling Execution and Setting Traps in a Multiprocess Program"IDREF="37241" TYPE="TITLE""Debugging a Multiprocess Fortran Program"LBL="" HELPID=""ID="10675"Debugging With Multiprocess ViewMultiprocess View operates on a process group. By default, a process group includes the parent process and all descendants spawned by sproc. Through a preferences option, processes spawned with fork during the session can be added to the process group automatically when they are created. Note that a child that performs an exec with setuid (the user ID) enabled will not become part of the process group. Any process to which you have read/write access can also be added to the process group, if desired. All sproc'd processes must be in the same process group, since they share information.Each process in the session can have a standard Main View session associated with it. All processes in a process group share a single Multiprocess View. Selecting "Multiprocess View..." from the Admin menu in Main View for any process in the group brings up the Multiprocess View window. If the Multiprocess window exists, it will be raised to the front; otherwise, a new window will be created.Currently, Multiprocess View handles these multiple process situations:True multiprocess program, which refers to a tightly integrated system of sproc'd processes, generated by POWER/Fortran or POWER/C.Auto-fork application, which is a process that spawns a child process and then runs in the background.Locally distributed application, which is an application that involves two different executables running in different processes on the same host, coordinated by a rendezvous mechanism. To use the Performance Analyzer, you must have a Main View for each process and enable data collection accordingly.Fork application, which is a process that spawns child processes and can interact with them. The WorkShop Performance Analyzer supports applications that fork but not those that exec.Multiprocess View does not support remotely distributed applications.LBL="" HELPID=""Displaying the Multiprocess ViewThe first step in debugging multiple processes simultaneously is to invoke the Debugger with the parent process. Then select "Multiprocess View" from the Admin menu to bring up Multiprocess View. Main View is attached to the parent process. IDREF="50758" TYPE="GRAPHIC"Figure 9-1 shows a typical Multiprocess View with Config and Process menus displayed.FILE="9MultiProc10.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-1"Figure 9-1 ID="50758"Multiprocess View With Config and Process Menus DisplayedTo open a Main View (or other debugging views) for another process, double-click the desired process in Multiprocess View. A separate Main View window displays the selected process, and you can select any debugging views desired. If a set of views exists for that process, the views are raised to the foreground. To reuse views already displayed, select "Switch Process..." from the Admin menu in Main View. (If a process is currently highlighted in Multiprocess View, its ID is entered automatically in the Process ID: field in the Switch Process dialog box.)LBL="" HELPID=""Viewing Process StatusWhen Multiprocess View comes up, it lists the status of all processes in the process group. This information includes: PID:shows the process identifier (ID).PPID:lists the parent process IDs. Notice in IDREF="50758" TYPE="GRAPHIC"Figure 9-1 that the first process PID#7748 is the parent process of the second.State:represents the state of the process: stopped, running, or created, which appears just prior to running. Terminated processes are not displayed.Name:identifies the process by filename.Function/PC:indicates the current function and program counter (PC) for any stopped processes.LBL="" HELPID=""Multiprocess Control ButtonsMultiprocess View uses the same control buttons as MainView with two exceptions. The buttons are applied to all processes as a group. There is no separate Run button. Using a control button in Multiprocess View has the same effect as clicking the button in each process's Main View window. The buttons are:Continueresumes program execution after a halt and continues until a stop trap or other event stops execution.Stopstops execution of all processes. When program execution stops, the current source line of each process is highlighted in its Main View, if one is active, and annotated with an arrow indicating the PC.Step Intosteps to the next source line and into function calls. To step a specific number of lines, hold down the right mouse button over the Step Into button. A popup menu displays that lets you select one of the fixed values or a specified number of steps.Step Oversteps to the next source line and over function calls. To step a specific number of lines, hold down the right button over the Step Over button. A popup menu displays that lets you select one of the fixed values or a specified number of steps.Returnexecutes the remaining instructions in the current function. Program execution stops upon return from that procedure.Samplecollects performance data for each process (if performance data collection is enabled).Killterminates all processes in the group.LBL="" HELPID=""Multiprocess TrapsAs discussed in IDREF="25908" TYPE="TITLE"Chapter 4, "Setting Traps," the trap qualifiers [all] and [pgrp] are used in multiprocess analysis. The [all] entry stops or samples all processes when a trap fires. The [pgrp] entry sets the trap in all processes within the process group containing the trap location. The qualifiers can be entered by default by the "Group Trap Default" and "Stop All Default" selections in the Traps menu in Trap Manager. Note that the Sample button always samples all processes.LBL="" HELPID=""Adding and Removing ProcessesFILE="f10prcmn.gif" POSITION="MARGIN" SCALE="FALSE"LBL="9-2"Figure 9-2 ID="88868"Process Menu in Multiprocess ViewThe Process menu lets you manually add or remove a process from the process group (see IDREF="88868" TYPE="GRAPHIC"Figure 9-2). To remove a process, click the process and select "Remove" from the Process menu. Note that a process in a sproc share group cannot be removed from the process group.To add a process, select "Add...". The dialog box shown in IDREF="42348" TYPE="GRAPHIC"Figure 9-3 displays. Enter the new process ID and click OK.FILE="f10addpr.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-3"Figure 9-3 ID="42348"Add Process Dialog BoxLBL="" HELPID=""Multiprocess PreferencesThe "Preferences..." option in the Config menu brings up the Preferences dialog box. It lets you control when processes are added to the group, and it specifies their behavior (see IDREF="37471" TYPE="GRAPHIC"Figure 9-4).FILE="f10prefs.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-4"Figure 9-4 ID="37471"Multiprocess View Preferences Dialog BoxThe Multiprocess View preference options are:Attach to forked processesattaches new processes spawned by the fork command to the group automatically. (Note that processes spawned by sproc are always attached.)Copy traps to forked processescopies traps you have set in the parent process to new forked processes automatically. If you create parent traps with Trap Manager and specify pgrp, then the children inherit these traps automatically, regardless of the state of this flag.Copy traps to sproc'd processescopies traps you have set in the parent process to new sproc'd processes automatically. As in the previous option, if you create parent traps with the Trap Manager and specify pgrp, the children inherit these traps automatically, whether this flag is set or not.Resume parent after forkrestarts the parent process automatically when a child is forked.Resume child after attach on forkrestarts the new forked process automatically when it is attached. If this option is left off, a new process will stop as soon as it is attached.Resume parent after sprocrestarts the parent process automatically when a child is sproced.Resume child after attach on sprocrestarts the new sproced process automatically when it is attached. If this option is left off, a new process will stop as soon as it is attached.LBL="" HELPID=""ID="26149"Controlling Execution and Setting Traps in a Multiprocess ProgramThis section uses a C program that generates numbers in the Fibonacci sequence to demonstrate some of the tasks you'll be performing most often when using cvd to debug mp code. The tasks demonstrated are:stopping a child process on a sprocusing the Multiprocess View buttons to control all processessetting traps in the parent process onlysetting group trapsThe program fibo uses sproc to split off a child process, which in turn uses sproc to split off a grandchild process. All three processes churn out Fibonacci numbers until stopped. If you installed the demo programs, you can find the source for fibo.c in the directory/usr/demos/WorkShop/mp. A listing of fibo.c follows:#include <stdio.h>
#include <sys/types.h>
#include <sys/prctl.h>

int NumberToCompute = 100;
int fibonacci();
void run(),run1();

int fibonacci(int n)
{
int f, f_minus_1, f_plus_1;
int i;

    f = 1;
    f_minus_1 = 0;
    i = 0;

    for (; ;) {
        if (i++ == n) return f;
        f_plus_1 = f + f_minus_1;
         f_minus_1 = f;
         f = f_plus_1;
    }
}

void run()
{
int fibon;
    for (; ;) {
        NumberToCompute = (NumberToCompute + 1) % 10;
        fibon = fibonacci(NumberToCompute);
        printf("%d'th fibonacci number is %d\n", 
             NumberToCompute, fibon);
    }
}

void run1()
{
int grandChild;

    errno = 0;
    grandChild = sproc(run,PR_SADDR);

    if (grandChild == -1) {
        perror("SPROC GRANDCHILD");
    }
    else
        printf("grandchild is %d\n", grandChild);
    run();
}

void main ()
{
int second;

    second = sproc(run1,PR_SADDR);
    if (second == -1)
        perror("SPROC CHILD");
    else
        printf("child is %d\n", second);

    run();
    exit(0);
}To get started, compile the program and run the Debugger.Compile fibo.c.cc -g fibo.c -o fiboInvoke the Debugger on fibo.cvd fibo &Bring up the multiprocess view by selecting "Multiprocess View..." from the Admin menu.In the next section, you'll set options to control how the process executes.LBL="" HELPID=""Using the Multiprocess View to Control ExecutionTo examine each process as it appears, you need to stop child processes as they are created with sproc. You can control the Debugger's behavior on sproc by setting Multiprocess preferences. Select "Preferences..." from the Config menu in Multiprocess View.Deactivate Resume child after attach on sproc.At the same time, you can turn off trap inheritance, so you can experiment with trap setting later.Click OK to accept the change. Now you're ready to run the process. In the Main View, click Run.If you watch Multiprocess View, you see the main process appear, and spawn a child process. The child process stops as soon as it appears, since you turned off the Resume child after attach on sproc option. You can now use Multiprocess View to open a new main view for the child process. Double-click the child process in the Multiprocess View window.You see a dialog box like the one in IDREF="61744" TYPE="GRAPHIC"Figure 9-5, and the Debugger creates a new window.FILE="f10dialg.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-5"Figure 9-5 ID="61744"Launching a Debug Session Dialog BoxYou can use the buttons in Multiprocess View to control all the processes simultaneously, or use the buttons in each of the Main Views to control each process separately. NoteYou'll probably get a warning that the sproc.s is missing. This is a reference to assembly code and can be ignored.To send the child process on its way, click Continue in the Multiprocess View window.The first child now spawns a grandchild process. The grandchild stops in sproc, as shown in IDREF="54385" TYPE="GRAPHIC"Figure 9-6:FILE="f10mpvue.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-6"Figure 9-6 ID="54385"Using the Multiprocess View to Examine Process StateLBL="" HELPID=""Using the Trap Manager to Control Trap InheritanceThis section shows you how to use the Trap Manager to set traps that affect one or all of the fibo process group. For complete information on using the Trap Manager, refer to IDREF="25908" TYPE="TITLE"Chapter 4, "Setting Traps."In the Main View for the parent process, select "Trap Manager" from the Views menu. Right now, traps set using the Traps menu in any of the Main View windows will affect only the process controlled by that Main View. For example, see what happens if you set a stop trap in the first executable line of run(), which is line 32:32 NumbertoCompute = (NumbertoCompute + 1) % 10; Using the Traps menu of the parent process, set a stop trap at line 32 of fibo.c.Only the parent process halts. The child processes continue running, as a glance at Multiprocess View will confirm.You can use the Trap Manager to edit the trap so that it affects the whole process group. Insert the word pgrp after the word Stop.The trap should read Stop pgrp at.., as shown in IDREF="38782" TYPE="GRAPHIC"Figure 9-7.FILE="f10trmgr.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-7"Figure 9-7 ID="38782"Modifying a Trap to Affect a Process GroupClick Modify to accept your change to the trap.The trap affects the two child processes as well. Watch the Multiprocess View to see the whole process group stop at the trap on line 32.You can set an option to make all traps affect the process group by default for those traps set using the Trap Manager.Select "Group Trap Default" from the Traps menu (see IDREF="40084" TYPE="GRAPHIC"Figure 9-8).FILE="f10trpmn.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-8"Figure 9-8 ID="40084"Setting the Group Trap DefaultIn the Main View of the parent process, place the cursor in any executable line in the function fibonacci and select "At Source Line" from the Traps menu of the Trap Manager.The trap you've just set includes the modifier pgrp. It automatically affects both child processes.You have now learned the basics of controlling the execution of multiple processes and setting traps.Select "Exit" from the Admin menu in each Main View to end this tutorial.Note that the Multiprocess View window must be closed explicitly. It does not close when the Main View windows do.LBL="" HELPID=""ID="37241"Debugging a Multiprocess Fortran ProgramThe first part of this section presents a few standard techniques to assist you in debugging a parallel program. The second part shows you how to use the WorkShop Debugger to debug the sample program from Chapter 6 of the Fortran 77 Programmer's Guide.LBL="" HELPID=""General Fortran Debugging HintsDebugging a multiprocessed program is more difficult than debugging a single-processor program; therefore, debug as much as possible on the single-processor version.Try to isolate the problem as much as possible. If you can, reduce the problem to a single C$DOACROSS loop.Once you've isolated the problem to a specific DO loop, try changing the order of its iterations in a single-processor version. If the loop can be multiprocessed, then the iterations can execute in any order and produce the same answer. If the loop cannot be multiprocessed, changing the order frequently causes the single-processor version to fail. If it fails, you can use standard single-process debugging techniques to find the problem.If this technique fails, you need to debug the multiprocessed version. Compile your code with the flags ≠g and ≠mp_keep. The ≠mp_keep flag saves the file containing the multiprocessed DO loop Fortran code. The compiler saves the code in a file named$TMPDIR/P<user_subroutine_name><machine_name><pid>where user_subroutine_name is the name of the subroutine containing the DOACROSS, machine_name is your machine name, and pid is the process ID number of the compilation.If you have not set the environment variable TMPDIR, /tmp is used.LBL="" HELPID=""Multiprocess Debugging SessionThis section walks you through the process of using the Debugger to debug a small segment of incorrectly multiprocessed code. The example used in this section is also treated in Chapter 6 of the Fortran 77 Programmer's Guide with dbx. You can use cvd to perform the same tasks with less effort.If you installed the demo programs, you can find the source for the code you will be debugging, total.f, in the directory /usr/demos/WorkShop/mp. A listing follows:program driver
    implicit none
    integer iold(100,10), inew(100,10),i,j
    double precision aggregate(100, 10),result
    common /work/ aggregate
    call total(100, 10, iold, inew)
    do 20 j=1,10
      do 10 i=1,100
        result=result+aggregate(i,j)
10    continue
20  continue
    write(6,*)' result=',result
    stop
    end

    subroutine total(n, m, iold, inew)
    implicit none
    integer n, m
    integer iold(n,m), inew(n,m)
    double precision aggregate(100, 100)
    common /work/ aggregate
    integer i, j, num, ii, jj
    double precision tmp

    C$DOACROSS LOCAL(i,ii,j,jj,num)
    do j = 2, m-1
      do i = 2, n-1
        num = 1
        if (iold(i,j) .eq. 0) then
          inew(i,j) = 1
        else
        num = iold(i-1,j) +iold(i,j-1) + iold(i-1,j-1) +
&         iold(i+1,j) + iold(i,j+1) + iold(i+1,j+1)
          if (num .ge. 2) then
            inew(i,j) = iold(i,j) + 1
          else
            inew(i,j) = max(iold(i,j)-1, 0)
          end if
        end if
        ii = i/10 + 1
        jj = j/10 + 1
        aggregate(ii,jj) = aggregate(ii,jj) + inew(i,j)
      end do
    end do
    endIn the program, the local variables are properly declared. The inew always appears with j as its second index, so it can be a share variable when multiprocessing the j loop. The iold, m, and n are only read (not written), so they are safe. The problem is with aggregate. The person analyzing this code reasoned that because j is always different in each iteration, j/10 will also be different. Unfortunately, since j/10 uses integer division, it often gives the same results for different values of j.While this is a fairly simple error, it is not easy to see. When run on a single processor, the program always gets the right answer. Sometimes it gets the right answer when multiprocessing. The error occurs only when different processes attempt to load from and/or store into the same location in the aggregate array at exactly the same time. Here are the steps in this exercise:First try reversing the order of the iterations. Replacedo j = 2, m-1withdo j = m-1, 2, -1This still gives the right answer when running with one process but the wrong answer when running with multiple processes. The local variables look right, there are no equivalence statements, and inew uses only simple indexing. The likely item to check is aggregate. Your next step is to look at aggregate with the Debugger.Compile the program with the ≠g ≠mp_keep options: % f77 -g -mp -mp_keep total.f -o totalIf your debugging session is not running on a multiprocessor machine, you can force the creation of two threads for example purposes by setting an environment variable. If you use the C shell, type% setenv MP_SET_NUMTHREADS 2Start the Debugger:% cvd total&The Debugger Main View window displays.Choose "Go To Line..." from the Source menu and select line 43.This takes you to line 43:aggregate(ii,jj) = aggregate(ii,jj) + inew(i,j) The subroutine touches aggregate in only one place, line 43. You want to set a stop trap at this line, so you can see what each thread is doing with aggregate, ii, and jj. You also want this trap to affect all threads of the process group. One way to do this is to turn on trap inheritance using the Multiprocess View Preferences dialog box. Another way is to use the Trap Manager to specify group traps, as follows.From the Views menu, select Trap Manager.In the Trap Manager window, pull down the Traps menu. Select the "Group Trap Default" option from the menu.This sets the group default.Place the cursor in line 43 in the Main View window.This selects the line.From the Traps menu in Traps Manager, select "At Source Line."This sets the stop trap, which should read something like this trap:Stop pgrp in file /usr/demos/WorkShop/mp/total.f line 43Bring up the Multiprocess View to keep tabs on the status of the two processes. Now you're ready to run the program.Click Run in the Main View window.As you watch the Multiprocess View, you'll see the two processes appear, run, and stop in the function _total_25_aaaa. The Main View window is now relative to the master process. Double-click the slave process listed in the Multiprocess View window, as in IDREF="82126" TYPE="GRAPHIC"Figure 9-9.This invokes a Main View debugging session on the slave process.FILE="f10total.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-9"Figure 9-9 ID="82126"Launching a New Debugging Session From Multiprocess ViewNow you can invoke the Variable Browser on each process. Look at ii and jj in IDREF="64055" TYPE="GRAPHIC"Figure 9-10.FILE="f10totl2.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-10"Figure 9-10 ID="64055" Comparing Variable Values From Two ProcessesThey have the same values in each process; therefore, both processes may attempt to write to the same member of the array aggregate at the same time. So aggregate should not be declared as a share variable. You've found the bug in your parallel Fortran program.LBL="10"ID="97409"Using the X/Motif Analyzer: A TutorialThis chapter provides an interactive sample session that demonstrates most of the X/Motif Analyzer functions. The session outlines common tasks you can perform with the X/Motif Analyzer.ID="10TutCvmotif1"This chapter contains the following sections:IDREF="45692" TYPE="TITLE""Setting Up the Sample Session"IDREF="73508" TYPE="TITLE""Navigating the Widget Structure"IDREF="49412" TYPE="TITLE""Examining Widgets"IDREF="48625" TYPE="TITLE""Setting Callback Breakpoints"IDREF="64707" TYPE="TITLE""Using Additional Features of the Analyzer"IDREF="49136" TYPE="TITLE""Ending the Session"LBL="" HELPID=""ID="45692"Setting Up the Sample SessionFor this tutorial, use the demo files in the directoryID="10TutCvmotif2" /usr/demos/WorkShop/bounce, which contains the complete source code for the C++ application bounce. To prepare for the session, you first need to create the fileset, then launch the X/Motif Analyzer from the Debugger. FILE="iconIExec.gif" POSITION="MARGIN" SCALE="FALSE"LBL="10-1"Figure 10-1 ID="87353"Execution View IconLBL="" HELPID=""Preparing the FilesetYou must enter the commands listed below:ID="10TutCvmotif3"cd /usr/demos/WorkShop/bouncemake bouncecvd bounce &The cvd command brings up the CaseVision Debugger, from which you can use the X/Motif Analyzer. You see the Execution View icon (shown in IDREF="87353" TYPE="GRAPHIC"Figure 10-1) and Main View (shown in ID="10TutCvmotif4"IDREF="15024" TYPE="GRAPHIC"Figure 10-2) appear. Note that the source code status indicator in the Debugger is (Read Only).FILE="10TutCvmotif3.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-2"Figure 10-2 ID="15024"Debugger Main ViewOpen the Execution View and position the window so you can see it and the Debugger Main View.To see what the program does, click Run. The bounce program opens a window on your desktop. Click Run in the new window, resize the window to make it taller, and then add balls from the Actors Menu to see how the program executes. The Execution View shows the program output (see ID="10TutCvmotif5"IDREF="43269" TYPE="GRAPHIC"Figure 10-3).FILE="FCexecV.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-3"Figure 10-3 ID="43269"Program Results in Execution ViewIf your screen shows different results, the program files may have been modified during a previous tutorial session.LBL="" HELPID=""Launching the X/Motif AnalyzerOnce the ID="10TutCvmotif6"bounce fileset is built and the debugger is active, you need to launch the X/Motif Analyzer with the following steps:Pull down the Views menu in the menu bar of the debugger Main View.Select "X/Motif Analyzer."Click OK when asked if you wish to change your $LD_LIBRARY_PATH environment variable to include /usr/lib/WorkShop/Motif. These are instrumented versions of the Silicon Graphics 5.3 libraries and add special support for the X/Motif Analyzer, in addition to containing symbols.Click Kill in the debugger Main View to kill bounce.You are now ready to begin the sample session.LBL="" HELPID=""ID="73508"Navigating the Widget StructureAfter being launched, the X/Motif Analyzer brings up an empty Widget examiner. The tab panel also shows the Breakpoints area, Trace examiner, and Tree examiner (see ID="10TutCvmotif7"IDREF="76562" TYPE="GRAPHIC"Figure 10-4).FILE="widget.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-4"Figure 10-4 ID="76562"First View of the X/Motif Analyzer (Widget Examiner)Click ID="10TutCvmotif8"Run in the debugger Main View to run bounce again (this time with the augmented versions of the libraries). Click Run in the bounce window and resize the window to make it taller. Click Select in the X/Motif Analyzer. This brings up an information dialog and changes the cursor to a +. Do not click OK in the information dialog. Click Step in the Bounce window as instructed by the dialog. The widget examiner displays the Step widget structure.In the X/Motif Analyzer, click the Tree tab. The tree examiner displays the widget hierarchy of the target object (see IDREF="14659" TYPE="GRAPHIC"Figure 10-5).FILE="treeX.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-5"Figure 10-5 ID="14659"Widget Hierarchy Displayed in the Tree ExaminerDouble-click the "Run" node in the tree. ("Run" is in the upper-right area of the window). This brings up the widget examiner, which displays the ID="10TutCvmotif9"Run widget structure. Notice that the Parent button shows the name of the current widget's parent.In the X/Motif Analyzer, click the Parent button to switch the view to the Run widget's parent, the Control object. The widget examiner now displays the Control widget structure. You can navigate through the widget hierarchy using either the widget examiner or the tree examiner.LBL="" HELPID=""ID="49412"Examining WidgetsIn the widget examiner, pull down the Children... menu and select "Run." The ID="10TutCvmotif10"Run widget structure is now displayed in the examiner.In the bounce window, pull down the Actors... menu and select "Add Red Ball."In the debugger Main View, enter stop in Clock::timeout in the cvd command-line area to set a breakpoint in bounce. Notice that the "Event" tab (for the event examiner) is added to the tab list.In the debugger Main View, click Continue a few times to observe the behavior of bounce with this breakpoint added.In the X/Motif Analyzer, click the Breakpoints tab to go to the breakpoints examiner. This examiner allows you to set widget-level breakpoints.In the "Callback Name" text field, enter activateCallback, then click Add to add a breakpoint for the activateCallback object of the Run widget. The result is displayed in IDREF="59330" TYPE="GRAPHIC"Figure 10-6.FILE="actCB.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-6"Figure 10-6 ID="59330"Adding a Breakpoint for a WidgetIn the debugger Main View, click the breakpoint arrow to remove the ID="10TutCvmotif11"Clock::timeout breakpoint.In the debugger Main View, click Continue.In the bounce window, click Stop.In the bounce window, click Run. The process stops in the Run button's registered activateCallback. This is the routine that was passed to XtAddCallback routine. Notice that the "Callback" tab (for the callback examiner) is added to the tab list.LBL="" HELPID=""ID="48625"Setting Callback BreakpointsIn the X/Motif Analyzer, click the Breakpoints list item to highlight the breakpoint. ID="10TutCvmotif12"In the X/Motif Analyzer, delete the widget address in the "Widget" text field and click Modify. This changes the activateCallback breakpoint to apply to all push button gadgets (XmPushButtonGadget, set in the "Class" text field) rather than just the Run button (see IDREF="49196" TYPE="GRAPHIC"Figure 10-7).FILE="widCls.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-7"Figure 10-7 ID="49196"Setting Breakpoints for a Widget ClassIn the debugger Main View, click ID="10TutCvmotif13"Continue.In the bounce window, click Stop. The process now stops in the Stop button's activateCallback routine.In the X/Motif Analyzer, click the Callback tab to go to the callback examiner. This examiner displays the callback context and the appropriate call_data structure (see IDREF="92811" TYPE="GRAPHIC"Figure 10-8).FILE="calCtx.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-8"Figure 10-8 ID="92811"Viewing the Callback Context With the Callback ExaminerDouble-click the window value in the callback structure, fourth line from bottom.ID="10TutCvmotif14"Pull down the Examine menu and select "Window." The X/Motif Analyzer displays the window attributes for that window (the window of the Stop button). Notice that the "Window" tab (for the window examiner) is added to the tab list. See IDREF="73435" TYPE="GRAPHIC"Figure 10-9.You can also accomplish the same action by triple-clicking the window value in the callback structure of the callback examiner. In general, triple-clicking on an address brings you to that object in the appropriate examiner.FILE="winTut.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-9"Figure 10-9 ID="73435"Viewing Window Attributes With the Window ExaminerID="10TutCvmotif15"LBL="" HELPID=""ID="64707"Using Additional Features of the AnalyzerIn the X/Motif Analyzer, click the Widget tab.ID="10TutCvmotif16"Double-click the widget_class value on the fourth line.Pull down the Examine menu and select "Widget Class." The X/Motif Analyzer displays the class record for the XmPushButtonGadget routine. Notice that the "Widget Class" tab (for the widget class examiner) is added to the tab list.(Again, the same action can be accomplished by triple-clicking the widget_class value in the widget examiner.)Triple-click the superclass value on the third line. The X/Motif Analyzer displays the class record for XmLabelGadget, the superclass of XmPushButtonGadget. (Triple-clicking is a shortcut for automatically selecting the correct examiner.)Triple-click the superclass value on the third line. The X/Motif Analyzer displays the class record for XmGadget, the superclass of XmLabelGadget. Click the Widget tab to change to the widget examiner.Triple-click the parent value on the fifth line. The X/Motif Analyzer now displays the widget control, the parent of Run. This action produces the same results as clicking the Parent button.In the X/Motif Analyzer, click the tab overflow area (the area where the tabs overlap, to the far left of the tab list) and select the Breakpoints tab (see IDREF="88737" TYPE="GRAPHIC"Figure 10-10).FILE="tabOvr.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-10"Figure 10-10 ID="88737"Selecting the Breakpoints Tab From the Overflow AreaID="10TutCvmotif17"Change the Breakpoint Type from "Callback" to "Resource-Change."In the "Class" text field, enter Any.In the "Resource Name" text field, enter sensitive.Click Add. This adds a breakpoint in instances when the "sensitive" resource is changed for any push button gadget.In the debugger Main View, click Continue. The Resource-Change breakpoint was reached, stopping the process in the XtSetValues routine.In the debugger Main View, pull down the Views menu and select "Call Stack." Notice the call to XtSetValues on the second line (see IDREF="50246" TYPE="GRAPHIC"Figure 10-11).FILE="calStk.gif" POSITION="INLINE" SCALE="FALSE"LBL="10-11"Figure 10-11 ID="50246"Viewing Breakpoint Results in the Callstack ViewID="10TutCvmotif18"In the Callstack view, double-click the Cmdinterface::activate frame (just below XtSetSensitive). This is where the sensitive resource was changed.In the X/Motif Analyzer, click the Widget tab.In the X/Motif Analyzer, double-click the widget address in the "Widget" text field, press backspace, enter _w, and press <Enter>. The X/Motif Analyzer now displays the Run widget, which is the widget currently being changed.In the debugger Main View, click Continue. The process stops again in the XtSetValues routine, which is another sensitivity change.Double-click the Cmdinterface::active frame (just below XtSetSensitive).Double-click in Widget field, press backspace, enter _w, and press <Enter>. The X/Motif Analyzer displays the Step widget, which is the widget now being changed.LBL="" HELPID=""ID="49136"Ending the SessionExit the X/Motif Analyzer by pulling down the Admin menu and choosing "Close." Exit the Debugger by pulling down the Admin menu and choosing "Exit."ID="10TutCvmotif19"NoteIf you exit the debugger, you automatically exit the X/Motif Analyzer.LBL="A"ID="46334"Debugger ReferenceThis chapter describes in detail the function of each window, menu, and display in the Debugger's graphical user interface (GUI). In addition, the chapter describes the Debugger commands available on the Debugger command line (see IDREF="76970" TYPE="TITLE""Debugger Command Line"). Most commands are available from either interface. You can move from one to the other as you prefer. This chapter contains the following sections:IDREF="92260" TYPE="TITLE""Main View"IDREF="60840" TYPE="TITLE""Basic Windows"IDREF="17727" TYPE="TITLE""X/Motif Analyzer Windows"IDREF="71783" TYPE="TITLE""Project Session Management Windows"IDREF="38384" TYPE="TITLE""Data Examination Windows"IDREF="49277" TYPE="TITLE""Machine-level Debugging Windows"IDREF="69417" TYPE="TITLE""Multiple Process Debugging Windows"IDREF="12535" TYPE="TITLE""Fix+Continue Windows"IDREF="76970" TYPE="TITLE""Debugger Command Line"LBL="" HELPID="MainView"ID="92260"Main ViewThe major areas of the Main View window are shown in IDREF="62188" TYPE="GRAPHIC"Figure A-1.FILE="AReference.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-1"Figure A-1 ID="62188"Major Areas of the Main View WindowThe Main View contains a menu bar, from which you can perform a number of functions and launch windows. The menu bar contains the following items, which are discussed in detail in later pages:IDREF="70545" TYPE="TITLE""Admin Menu"IDREF="19829" TYPE="TITLE""Views Menu"IDREF="39329" TYPE="TITLE""Query Menu"IDREF="70501" TYPE="TITLE""Source Menu"IDREF="62218" TYPE="TITLE""Display Menu"IDREF="27296" TYPE="TITLE""Perf Menu"IDREF="42515" TYPE="TITLE""Traps Menu"IDREF="12811" TYPE="TITLE""PC Menu"IDREF="15402" TYPE="TITLE""Fix+Continue Menu"IDREF="25659" TYPE="TITLE""Help Menu"In addition, the Main View contains the following items:"Command" text fieldDisplays the full pathname of the executable that you are currently debugging.Debug option menuAllows you to conduct performance experiments using either the built-in WorkShop performance tools, or the Purify memory corruption analysis tool. The option menu choices are:"Debug Only," which runs the Debugger in Debug mode only, with no performance tools enabled."Performance," which causes performance data to be gathered and instrumented code to be generated for performance analysis while using the debugger."Purify," which causes the Purify memory corruption analysis tool is active during your debugger run. The code that you view with the debugger (in Main View, Source View, and so on) is Purify code. For further information on Purify, see the Purify documents. NotePurify is not part of the standard debugger package; it must be ordered separately. ContinueContinues the execution of the current process. This command is legal only if the running process is stopped. If the program has not been run or has been killed, the Continue button is desensitized (grayed-out). If the target program has not yet started executing, use the Run command to start execution.StopStops the execution of the current process while it is running. his command is valid only when a process is running; otherwise the command button is desensitized (grayed-out). Traps can also be planted to stop the program at a specific location or on a particular condition. See the Trap Manager for more details.Step IntoExecutes a source line single step of the current process. If a function call is encountered, it is stepped "into." That is, the current process continues to the next source statement, even if that statement is encountered in a function that is called. The Step Over command can be used to step over function calls, then stop.If a trap is encountered while executing Step Into, the command is canceled and the process is stopped where the trap was fired. This command is legal only if the running process is stopped; otherwise the command button is desensitized (grayed-out).When you press the right mouse button over the Step Into button, a menu pops up to allow you to choose the number of source lines to be stepped. The step value menu selections consist of "1, 2, 3, 4, 5, 10, 15, 20, N..." If you choose the last menu entry "N...", a dialog window is opened to allow you to enter a step value.Step OverExecutes source line single step of the current process. If a function call is encountered, it is stepped "over." That is, the current process continues to the next source statement, but does not count statements in functions that are called while stepping. Step Into can be used to step into function calls, then stop. If a trap is encountered while executing Step Over, the command is canceled and the process is stopped where the trap was fired.When you press the right mouse button over Step Over, a menu pops up to allow you to choose the number of source lines to be stepped. The step value menu selections consist of "1, 2, 3, 4, 5, 10, 15, 20, N..." If you choose the last menu entry "N...", a dialog window is opened to allow you to enter a step value.ReturnContinues the execution of the process until the current function that is being executed returns. The process is stopped immediately upon returning to the calling function. All code within the current function is executed as usual. If a trap is encountered while executing the Return command, the command is canceled and the process is stopped where the trap was fired. This command is legal only if the running process is stopped; otherwise the command button is desensitized (grayed-out). This command is not allowed if the executable is instrumented for performance analysis.SampleAllows you to manually sample the state of a process for evaluation by the Performance Analyzer. This command is legal only if the process is running and the Enable Data Collection mode is set on the Performance panel; otherwise the command button is desensitized (grayed-out).PrintPrints the value of the currently selected expression.KillKills the currently running process that you are debugging by sending it the equivalent of a "kill -9" signal. This command is legal if the process is running or stopped; otherwise the command button is desensitized (grayed-out).RunRuns the program that you are currently debugging. After the initial run, Run allows you to rerun the program, maintaining the traps you have set.Status areaDisplays information about the process that you are debugging.Source Code areaDisplays the source code that your are currently debugging.Annotation columnWhere such things as stop points are displayed."File" text fieldDisplays the name of the file that you are currently debugging.Command line areaArea of the Main View where you can enter command-line Debugger commands.Show/Hide annotations buttonThis button (see IDREF="65653" TYPE="GRAPHIC"Figure A-2) only becomes visible if you run or load a performance experiment (see the Performance Analyzer User's Guide for more information on the performance tools). This is a toggle button that shows or hides performance related annotations.FILE="" POSITION="INLINE" SCALE="FALSE"FILE="AReference132.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-2"Figure A-2 ID="65653"Show/Hide Annotations Button in Main ViewLBL="" HELPID="AdminMenu"ID="70545"Admin MenuFILE="f01admin.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-3"Figure A-3 ID="64519"Admin Menu in Main ViewThe Admin menu in Main View performs general management functions dealing with processes, windows, and user preferences (see ID="AReference1"IDREF="64519" TYPE="GRAPHIC"Figure A-3). The Admin menu provides these selections:"Library Search Path..."ID="AReference2"Controls where the Debugger looks for DSOs when you invoke the Debugger on an executable or core file. The Library Search Path dialog box allows you to reset the environment variables LD_LIBRARY_PATH and _RLD_ROOT. You can also reset _RLD_LIST to control the set of DSOs that will be used by the program. See the reference dpage for rld for more information on these variables. Any changes you make to these variables are propagated into the Execution View shell when you run the program.The Library Search Path dialog is opened automatically when you invoke the Debugger on an executable or core file and the Debugger is unable to find all of the required DSOs. You may also open the Library Search Path dialog box by selecting "Library Search Path..." from the Admin Menu (see IDREF="12920" TYPE="GRAPHIC"Figure A-4). The list of required DSOs displays at the top of the dialog box, annotated by the status of each DSO. The status can be "OK," "Error: Cannot   find library," or "Error: Core file and library mismatch." The status "Error: Core file and library mismatch" indicates that the debugger found a DSO that did not match the core file. There are three fields for the variables below the list area where you can modify their values.FILE="AReference11.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-4"Figure A-4 ID="12920"The Library Search Path Dialog BoxInsert Before and Insert After move the shared object specified in the Value field before or after the selected object in the list. Modify replaces the selected object in the list with the file entered in the Value field. Remove deletes the selected shared object from the list."Multiprocess View..."ID="AReference3"Displays the Multiprocess View window, which helps you debug several processes at once."GLdebug"ID="AReference4"Provides a toggle to turn on GLdebug. GLdebug is a graphical software tool for debugging application programs that use the IRIS Graphics Library (GL). GLdebug locates programming errors in executables when GL calls are used incorrectly. For more information, refer to the GLdebug User's Guide. "Switch Process..."ID="AReference5"Changes the current process. You will be queried for the new process ID, as shown in IDREF="25343" TYPE="GRAPHIC"Figure A-5. You can type it in or paste it from another window, if desired. Switching processes changes the session. If you select a process in Multiprocess View, it is used as the default value.FILE="f01swpro.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-5"Figure A-5 ID="25343"The Switch Process Dialog BoxID="AReference6""Switch Executable..."ID="AReference7"Changes the current executable. This option also lets you debug a different core file. It brings up the dialog box shown in IDREF="28984" TYPE="GRAPHIC"Figure A-6.FILE="f01swexe.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-6"Figure A-6 ID="28984"The Switch Executable Dialog Box"Detach"ID="AReference8"Releases the process from the Debugger. This allows you to make changes to the source code. You must detach the process before you recompile the program. "Load Settings..."ID="AReference9"Allows you to use the previously saved preference settings to an initialization file used when the Debugger is first started. See the description of "Save Settings...", the following item."Save Settings..."ID="AReference10"Allows you to save the current preference settings to an initialization file used when the Debugger is first started. These can include such items as window sizes, current views, window configurations, and so on. "Iconify"ID="AReference11"Iconifies all of the session's views."Raise"ID="AReference12"Brings all the session's view windows to the foreground and redisplays any iconified windows."Launch Tool"Lets you run the WorkShop tools. See IDREF="15010" TYPE="GRAPHIC"Figure A-7. You can switch to the other tools by selecting "Build Manager," "Static Analyzer," "Performance Analyzer," or "Tester." Selecting "Debugger" lets you start another debugging session. If you buy WorkShop Pro MPF (for multi-process debugging), the "Parallel Analyzer" selection is enabled.FILE="f01lnch.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-7"Figure A-7 ID="15010""Launch Tool" Submenu"Project"ID="AReference13"Lets you control the WorkShop tools operating on the same executable as a group. See IDREF="54285" TYPE="GRAPHIC"Figure A-8. For more information on "Project View," a facility for managing CASEVision tools operating on a common target, see IDREF="26575" TYPE="TITLE""Project View".FILE="f01proj.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-8"Figure A-8 ID="54285""Project" Submenu"Exit"ID="AReference14"Exits all views in the session and terminates the session.LBL="" HELPID="ViewsMenu"ID="19829"Views MenuFILE="f01views.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-9"Figure A-9 ID="93800"Views Menu in Main ViewThe Views menu in Main View (see ID="AReference15"IDREF="93800" TYPE="GRAPHIC"Figure A-9) provides these selections for viewing the process(es) and their corresponding data:"Array Browser"ID="AReference16"Displays values from an array or array-slice in a two-dimensional spreadsheet and optionally in a three-dimensional representation; that is, a bar graph, surface, multiple lines, or points in space. These help you pick out bad data more readily. Arrays can contain up to 100 x 100 elements."Call Stack"ID="AReference17"Displays the call stack along with parameters to the calls. If you double-click a frame in the stack, you can switch the current context to the invocation of that frame and check the state of variables. "Disassembly View"ID="AReference18"Displays assembly code corresponding to the source code."Exception View"ID="AReference19"Displays the Exception View, and Ada-specific window used for exception handling."Execution View"ID="AReference20"Displays the Execution View window for handling the target process's input and output."Expression View"ID="AReference21"Evaluates expressions in Fortran, C, or C++. To enter an expression, select it in the source code display and paste it into the Expression View field, using the middle mouse button."File Browser"ID="AReference22"Displays a scrollable list of source files used by the current executable. Double-click a file in the list to load it directly into the source display area in Main View or Source View. The Search field lets you find files in the list quickly. "Memory View"ID="AReference23"Displays the value at a given memory address."Process Meter"ID="AReference24"Monitors the resource usage of a running process without saving the data. (Used with the Performance Analyzer.)"Register View"ID="AReference25"Displays the values stored in the hardware registers for the target process."Signal Panel"ID="AReference26"Displays the signals that can occur. You can specify which signals trigger traps and which are to be ignored."Source View"ID="AReference27"Displays source code. Lets you set traps, perform searches, and inspect source code without losing information in Main View. "Structure Browser"ID="AReference28"Displays data structures in a graphical format. You can dereference pointers by double-clicking."Syscall Panel"ID="AReference29"Lets you set traps at the entry to or exit from system calls."Task View"ID="AReference30"Brings up the Task View, an Ada-specific view that provides task and callstack information for processes."Trap Manager"ID="AReference31"Allows you to set, edit, and manage traps. (Used in both the Debugger and Performance Analyzer.)"Variable Browser"ID="AReference32"Displays the values of local variables and parameters for the current context."X/Motif Analyzer"ID="AReference33"Provides you with specific debugging support for X/Motif applications. There are various examiners for different X/Motif objects, such as widgets and X graphics contexts, that might be difficult or impossible to inspect using ordinary debugger functionality.LBL="" HELPID="QueryMenu"ID="39329"Query MenuThe Query menu (see IDREF="56752" TYPE="GRAPHIC"Figure A-10) lets you perform some of the queries available in the Static Analyzer. If you have previously built a cvstatic fileset, this is rather convenient; however, if you need to build the fileset from scratch, the process becomes more involved.FILE="AReference18.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-10"Figure A-10 ID="56752"Query Menu With SubmenusWith a current fileset, you can double-click any defined entity in the source code, select the "Where Defined?" option appropriate to its type, and the source code display area will scroll to the location where the item is defined.LBL="" HELPID="SourceMenu"ID="70501"Source MenuFILE="f01srce.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-11"Figure A-11 ID="15104"Source Menu in Main ViewThe Source menu in Main View (see IDREF="15104" TYPE="GRAPHIC"Figure A-11) provides these selections to deal with source code files:"Open..."ID="AReference34"Loads a source file."Save"ID="AReference35"Records changes made during the debugging session to the source file. You must first select "Make Editable," which appears in the Source menu when the file is read-only. "Save As..."ID="AReference36"Records changes made during the debugging session to the source file under a different filename."Save As Text..."ID="AReference37"Records the information in the display area as a text file."Insert Source..."ID="AReference38"Inserts the text of a file within your current file."Fork Editor"ID="AReference39"Starts your default editor on the current file. The default editor is determined by the editorCommand resource in the app-defaults file. The value of this resource defaults towsh -c vi +%d, which means run vi in a wsh window and scroll to the current line. If the editor lets you specify a starting line, enter %d in the resource to indicate the new line number. "Recompile"ID="AReference40"Displays the Build View window, which lets you compile the source code associated with the current executable."Make Read Only" / "Make Editable"ID="AReference41"ID="AReference42"Toggles the source code displayed between read-only and writable states so that you can edit your code.ID="43311""Search..."ID="AReference43"Searches for a literal case-sensitive, literal case-insensitive, or regular expression (see IDREF="45428" TYPE="GRAPHIC"Figure A-12). After you have set your target and clicked Apply (or pressed <Enter>), each instance is marked by a search target indicator in the scroll bar. You can search forward or backward in the file by clicking the Next and Prev buttons. You can also click an indicator with the middle mouse button to scroll Main View to that point. Clicking Reset removes the search target indicators. FILE="f01srch.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-12"Figure A-12 ID="45428"The Search Dialog Box"Go to Line..."ID="AReference44"Lets you scroll to a position in the source code by specifying a line number. "Go to Line..." brings up a dialog box similar to the one shown in IDREF="14170" TYPE="GRAPHIC"Figure A-13. FILE="AReference22.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-13"Figure A-13 ID="14170"Go to Dialog BoxID="AReference45"You can enter a line number or use the slider at the top of the box to select a line number. You do not have to display line numbers to use this feature. Versioning"Provides access to the configuration management tool, if you have designated one. The cvconfig script lets you designate CASEVision/ClearCase, RCS, or SCCS. Type: cvconfig [clearcase | rcs | sccs]FILE="f01vrsn.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-14"Figure A-14 ID="76270"Versioning SubmenuThe "Versioning" submenu appears in IDREF="76270" TYPE="GRAPHIC"Figure A-14. Selecting any of these options displays a shell in which you can access the configuration management tool. The selections in the submenu are:"Versioning":"CheckIn": Saves the source file and checks it into the database as a new version."Versioning":"CheckOut": Recalls the source file from the tool's database if you have the proper authority, locks it, and makes it editable."Versioning":"UncheckOut": Cancels the checkout, with no changes registered.LBL="" HELPID="DisplayMenu"ID="62218"Display MenuFILE="f01dsply.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-15"Figure A-15 ID="71768"Display Menu in Main ViewThe Display menu in Main View (see ID="AReference46"IDREF="71768" TYPE="GRAPHIC"Figure A-15) provides these selections to annotate the source code displayed:"Show Line Numbers"/"Hide Line Numbers"ID="AReference47"ID="AReference48"Displays or hides line numbers in the annotation column corresponding to the source code."Preferences..."Displays the Preferences dialog box (see IDREF="78286" TYPE="GRAPHIC"Figure A-16), which lets you show or hide column annotations and menus specific to the different WorkShop tools. In the Debugger, you can display trap, pc, and context icons. If you have purchased WorkShop/MP, you can display and manipulate loop indicators. The Performance Analyzer displays experiment statistics. The Tester module (if purchased) lets you see coverage statistics. Turning off the Performance toggle deletes the performance annotations from the Source View.FILE="f01prefs.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-16"Figure A-16 ID="78286"Preferences Dialog Box"Hide Icons"/"Show Icons"ID="AReference49"ID="AReference50"Removes or displays the annotation column next to the source code display area.LBL="" HELPID="PerfMenu"ID="27296"Perf MenuThe Perf (Performance) menu (see IDREF="18097" TYPE="GRAPHIC"Figure A-17) offers the following menu selections: Select Task submenuAllows you to choose the task for your performance analysis. The choices available are shown in IDREF="18097" TYPE="GRAPHIC"Figure A-17. You may only select one task per performance analysis run. If none of the given tasks sastisfy your requirements, you can choose the "Custom task," which will bring up the Custom Task dialog, which allows you to design your own task requirements (see IDREF="49744" TYPE="GRAPHIC"Figure A-19).FILE="AReference139.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-17"Figure A-17 ID="18097"Perf Menu and SubwindowsExamine Results...Launches the Performance Analyzer (IDREF="10481" TYPE="GRAPHIC"Figure A-18). For complete information on the Performance Analyzer, see the Performance Analyzer User's Guide. FILE="AReference141.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-18"Figure A-18 ID="10481"Launching Performance Analyzer From Perf MenuConfigs...Brings up the configurations dialog, which contains the following items:"Experiment Directory" text field, which allows you to specify the directory where the data captured during the next experiment is stored. The Performance Analyzer provides a default directory named test0000. If you use the default or any other name that ends in four digits, the four digits are used as a counter and will be incremented automatically for each subsequent experiment. "Instrument Directory," which lets you reuse a previously instrumented executable. This technique avoids the processing necessary for a new instrumentation. Often in a series of experiments, you collect the same type of data while stressing the target executable in different ways. Reusing the instrumented executable lets you do this conveniently."Track Exec'd Processes" toggle, which enables the Executable menu, which will contain selections for any exec'd processes. These selections let you see the performance results for the other executables."Auto Launch Performance Analyzer" toggle, which automatically launches the Performance Analyzer when the experiment is completed.FILE="perfCustom.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-19"Figure A-19 ID="49744"Custom Task DialogThe Custom Task dialog contains the following items:"Sampling Data" togglesThese toggles specify which type of sampling data is collected and recorded during instrumentation. The available choices are"Function Counts""Basic Block Counts""PC Profile Counts"Tracing Data" toggles"These toggles the type of data recorded at tthe time at which an event of the selected type occurred. The available choices are"Malloc/Free Trace""Syscall Trace""Page Fault Trace""I/O Syscall Trace""FP Exception Trace""Pollpoint Sampling" text fieldAllows you to specify a regular time interval for capturing performance data, including resource usage and any enabled sampling or tracing functions. Pollpoint is best used with call stack data only rather than other profiling data. Its primary utility is to enable you to identify boundary points for phases. "Fine Grained Usage" text fieldAllows you to set a time in to record resource usage data more frequently, at the specified time intervals. Fine grained usage helps you see fluctuations in usage between sample points."Call Stack Profiling" text fieldAllows you to set the interval for which the the call stack of the target executable is sampled.For further information on the Performance Analyzer, see the Performance Analyzer User's Guide.LBL="" HELPID="TrapsMenu"ID="42515"Traps MenuFILE="trapsTO.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-20"Figure A-20 ID="39601"Traps MenuThe Traps menu (see IDREF="39601" TYPE="GRAPHIC"Figure A-20) offers the following menu selections:"Set Trap"Allows you to set a trap in your source code. You can set a trap in a number of ways, depending which selection you make from the submenu (see IDREF="19429" TYPE="GRAPHIC"Figure A-21).FILE="setTrapSub.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-21"Figure A-21 ID="19429"Set Trap Submenu"Set Trap":"Sample"Allows you to set a a stop trap at a designated line in your source code. To set a stop trap at a line displayed in Main View (or Source View), click the cursor in the source annotation column next to the appropriate line in the source code, pull down the "Set Trap" submenu, and select "Sample." ID="AReference51""Set Trap":"Sample At Function Entry"Allows you to set a trap at the beginning of a function. To set, highlight the function name in the source code display area and select "Set Trap," then "Sample At Function Entry." ID="AReference52""Set Trap":"Sample At Function Exit"Allows you to set a trap at the end of a fucntion. To set, highlight the function name in the source code display area and select "Set Trap," then "Sample At Function Exit." ID="AReference53""Set Trap":"Stop"Allows you to set a a stop trap at a designated line in your source code. To set a stop trap at a line displayed in Main View (or Source View), click the cursor in the source annotation column next to the appropriate line in the source code, pull down the "Set Trap" submenu, and select "Stop." ID="AReference54""Set Trap":"Stop At Function Entry"Allows you to set a trap at the beginning of a function. To set, highlight the function name in the source code display area and select "Set Trap," then "Stop At Function Entry." ID="AReference55""Set Trap":"Stop At Function Exit"Allows you to set a trap at the end of a fucntion. To set, highlight the function name in the source code display area and select "Set Trap," then "Stop At Function Exit." ID="AReference56""Clear Trap"Deletes the trap on the line containing the cursor. You must designate "Stop" or "Sample" trap type, since both types can exist at the same location, appearing superimposed on each other (see ID="AReference57"IDREF="51637" TYPE="GRAPHIC"Figure A-22).FILE="clearTrapSub.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-22"Figure A-22 ID="51637"Clear Trap Subenu"Clear Trap":"Sample"Designates the "Stop" trap type."Clear Trap":"Stop"Designates the "Sample" trap type.LBL="" HELPID="PC_Menu"ID="12811"PC MenuID="AReference58"FILE="f01pc.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-23"Figure A-23 ID="13090"PC Menu in Main ViewThe PC (program counter) menu in Main View (see ID="AReference59"ID="AReference60"IDREF="13090" TYPE="GRAPHIC"Figure A-23) provides these selections for controlling the execution of a process:"Continue To"ID="AReference61"Continues the process to the selected point in the program unless some other event interrupts. You select a line by placing the cursor in it."Jump To"ID="AReference62"Goes directly to a selected point within the same function, jumping over intervening code. Waits for command to resume execution. You select a line by placing the cursor in it.LBL="" HELPID="Fix+ContinueMenu"ID="15402"Fix+Continue MenuFILE="FCmenu.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-24"Figure A-24 ID="43950"Fix+Continue MenuThe Fix+Continue menu (see ID="AReference63"IDREF="43950" TYPE="GRAPHIC"Figure A-24) offers the following menu selections:"Edit"Allows you to edit functions using the Debugger editor. "External Edit"Allows you to edit functions using an external editor. The default editor is vi, but can be changed by using the "Set Edit Tool..." popup menu in the Admin menu of the Status window. See IDREF="21697" TYPE="TITLE""Fix+Continue Status Window" for further information."Parse and Load"Parses your modified function and loads it for execution. You can execute the modified function by clicking on the Run or Continue buttons in the Debugger main view."Show Difference" submenuAllows you to see the difference between the original code and your modifications. See IDREF="87343" TYPE="TITLE""Show Difference Submenu" for further information."Edited<-->Compiled"Enables or disables your changes. This switch allows you to see how your application executed before and after the changes you made."Save As..."Allows FILE="savePop.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-25"Figure A-25 ID="76936""Save File+Fixes As..." Popup Window
you to save your changes to a file (see IDREF="76936" TYPE="GRAPHIC"Figure A-25). You can save the changes to the current source file (the default), or to a separate file."Save All Files..." Launches the "Save File+Fixes As..." dialog (see ID="AReference64"IDREF="76936" TYPE="GRAPHIC"Figure A-25), which allows you to update the current session, saving all the modified functions to the appropriate files."View" submenuAllows you to change to different views. Fix and Continue supports status, message, and build environment windows. See IDREF="61893" TYPE="TITLE""View Submenu" for further information."Preferences" submenuAllows you to set your Fix+Continue preferences. See IDREF="28839" TYPE="TITLE""Preferences Submenu" for further information."Cancel Edit"Takes you out of edit mode."Delete Edits"Deletes any changes that you made to functions.LBL="" HELPID=""ID="87343"Show Difference SubmenuThis submenuID="AReference65"FILE="Showdiff.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-26"Figure A-26 ID="17310"Show Difference Submenu
 (see IDREF="17310" TYPE="GRAPHIC"Figure A-26) allows you to see the difference between the original and your modified code. It contains the following options:"For Function"Opens a window that shows you the differences between the original function source and your modified source. "For File"Opens a window that shows you the differences between the original source file and your modified version."Set Diff Tool ..."Launches the Preference dialog (see IDREF="70893" TYPE="GRAPHIC"Figure A-29), which allows you to set the tool that displays the differences between the two sets of code. The default is xdiff. For further information on the Preference dialog, see IDREF="28839" TYPE="TITLE""Preferences Submenu".LBL="" HELPID=""ID="61893"View SubmenuThis submenuID="AReference66"FILE="View.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-27"Figure A-27 ID="14552"View Submenu
 (see IDREF="14552" TYPE="GRAPHIC"Figure A-27) allows you to open different Fix+Continue view windows. It contains the following options:"Status Window"Launches the Fix+Continue Status window. See IDREF="21697" TYPE="TITLE""Fix+Continue Status Window" for more information."Message Window"Launches the Fix+Continue Message window. See IDREF="22020" TYPE="TITLE""Fix+Continue Message Window" for more information."Build Environment Window"Launches the Fix+Continue Build Environment window. See IDREF="65193" TYPE="TITLE""Fix+Continue Build Environment Window" for more information.LBL="" HELPID=""ID="28839"Preferences SubmenuThe Preference FILE="PrefMenu.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-28"Figure A-28 ID="97291"Preferences Submenu
Menu (see ID="AReference67"IDREF="97291" TYPE="GRAPHIC"Figure A-28) allows you to set various options for the Fix and Continue environment, such as the difference tool, the external editor command, and so on. The menu contains the following options:"Show Preferences"Launches the Preference dialog (see IDREF="70893" TYPE="GRAPHIC"Figure A-29), which displays the preferences that are currently enabled for the session, and allows you to change the settings.FILE="PrefDiag.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-29"Figure A-29 ID="70893"Fix+Continue Preferences DialogThe preferences available through the dialog are"External Editor Command" text field, which allows you to choose your text editor. The default is vi."File Difference Tool" text field, which allows you to choose the tool that you use when comparing code. The default is xdiff."Copy Traps On Previous Definition" toggle. When you edit and parse a function, Fix+Continue copies traps from the old definition to the new one by mapping old lines to new lines. (This mapping is the same that can be generated using the UNIX diff utility.) If "Copy Traps On Previous Definition" is on and the mapped line the new definition is modified, then F&C will look at the switch."Copy Traps Even On Changed Lines" toggle, which causes the debugger to copy traps onto a mapped line."Continue Even If Line Has Changed" toggle. When you edit and parse a function in which your program is currently stopped, Fix+Continue can continue in the new definition provided some conditions are satisfied. The line from which the program continues depending on the mapping from the line in which it stopped. In case it can continue in the new definition from a line which you have modified, Fix+Continue consults this toggle to determine whether to continue in the new or old definition. This toggle allows you to override the default behavior."Warn Unfinished Edits Before Run" toggle, which pops up a warning dialog before a Run if you have unfinished edits."Warn Unfinished Edits Before Continue" toggle, which pops up a warning dialog before a continue if you have unfinished edits."Save deactivated code during File Save" toggle. The Fix+Continue file save substitutes new definitions in place of old ones. If you want to save your original functions in the same file, this switch allows you to save the old (original or compiled) code under an #ifdef. When you compile, the old code won't get compiled. You can manually edit the source to use the old definition in any way you desire."Reset Factory Defaults"Sets the preferences to the installed defaults."Save Preferences"Allows you to save your preferences to a file. This item brings up the File dialog. See IDREF="35936" TYPE="GRAPHIC"Figure A-139."Load Preferences..."Allows you to load preferences from a file. This item brings up the File dialog. See IDREF="35936" TYPE="GRAPHIC"Figure A-139.LBL="" HELPID=""Keyboard AcceleratorsUse the accelerators in IDREF="79660" TYPE="TABLE"Table A-1 to issue Fix+Continue commands directly from the keyboard.The accelerators are listed alphabetically by command.COLUMNS="2"LBL="A-1"Table A-1 ID="79660"Fix and Continue Keyboard AcceleratorsLEFT="0" WIDTH="211"CommandLEFT="220" WIDTH="54"Ctrl + keyLEFT="0" WIDTH="211"Cancel EditLEFT="220" WIDTH="54"ULEFT="0" WIDTH="211"EditLEFT="220" WIDTH="54"ELEFT="0" WIDTH="211"External EditLEFT="220" WIDTH="54"XLEFT="0" WIDTH="211"Parse And LoadLEFT="220" WIDTH="54"PLBL="" HELPID=""ID="25659"Help MenuID="AReference68"FILE="f01help.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-30"Figure A-30 ID="97007"Help MenuThe Help menu (see IDREF="97007" TYPE="GRAPHIC"Figure A-30) provides these options:"Click for Help"ID="AReference69"Provides information on the selected window's feature."Overview"ID="AReference70"Provides overview information on the current tool."Index..."ID="AReference71"Displays the entire list of help topics, alphabetically, hierarchically, or graphically."Keys & Shortcuts"ID="AReference72"Lists the keys and shortcuts for the current tool."Product Information"ID="AReference73"Provides general copyright and version number information on the current tool.LBL="" HELPID=""ID="60840"Basic WindowsThis section discusses some of the basic additional views that are available throught the Debugger; the Execution View, Source View, and Process Meter.LBL="" HELPID="ExecutionView"Execution ViewThe Execution View window is a simple shell that lets you set  environment variables and inspect error messages. Your target program I/O, if any, will be displayed in the Execution View window. If the program is I/O-based, then all interaction takes place in Execution View.ID="AReference74"ID="AReference75"The Execution View (see IDREF="99982" TYPE="GRAPHIC"Figure A-31) is launched automatically with the Debugger.FILE="FCexecV.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-31"Figure A-31 ID="99982"Execution ViewLBL="" HELPID="SourceView"Source ViewThe Source View (see IDREF="12610" TYPE="GRAPHIC"Figure A-32) displays your source, opening your Main program file by default. FILE="SrcVw.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-32"Figure A-32 ID="12610"Source ViewLBL="" HELPID=""Menu BarThe Source View menu bar contains five items that are duplicated from the Main View: Display, Traps, PC, and Fix+Continue. Each of these menus has the same functionality as its counterpart in the Main View (see IDREF="92260" TYPE="TITLE""Main View"). The only new menu bar item is the file menu (ID="AReference76"IDREF="93892" TYPE="GRAPHIC"Figure A-33), described below:FILE="SVfilMen.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-33"Figure A-33 ID="93892"Source View File Menu"Open..."Launches the file dialog (see IDREF="35936" TYPE="GRAPHIC"Figure A-139), allowing you to choose a file to load into the source view."Save"records changes made during the debugging session to the source file. You must first select "Make Editable," which appears in the Source menu when the file is read only. "Save As..."records changes made during the debugging session to the source file under a different filename."Save As Text..."records the information in the display area as a text file."Open Separate..."launches the File dialog, allowing you to create a new source view with the contents of a different source file."Insert File..."inserts the text of a file within your current file."Clone"clones the current window."Fork Editor"starts your default editor on the current file. The default editor is determined by the editorCommand resource in the app-defaults file. The value of this resource defaults towsh -c vi +%d, which means run vi in a wsh window and scroll to the current line. If the editor lets you specify a starting line, enter %d in the resource to indicate the new line number. "Recompile"displays the Build View window, which lets you compile the source code associated with the current executable."Make Editable"toggles the source code displayed between read-only and writable states so that you can edit your code."Search"searches for a literal case-sensitive, literal case-insensitive, or regular expression (see IDREF="45428" TYPE="GRAPHIC"Figure A-12). After you have set your target and clicked Apply (or pressed <Enter>), each instance is marked by a search target indicator in the scroll bar. You can search forward or backward in the file by clicking the Next and Prev buttons. You can also click an indicator with the middle mouse button to scroll Main View to that point. Clicking Reset removes the search target indicators. "Go To Line..."launches the Go To Line dialog, which allows you to go to a specific line in the source. You can type in the line, or select the line number via the slider bar.FILE="goToLin.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-34"Figure A-34 Go To Line Dialog"Versioning"provides access to the configuration management tool, if you have designated one. The cvconfig script lets you designate CASEVision/ClearCase from SGI, RCS or SCCS. Type: cvconfig [clearcase | rcs | sccs]Selecting any of these options displays a shell in which you can access the configuration management tool. The selections in the submenu are:"Versioning":"CheckIn" saves the source file and checks it into the database as a new version."Versioning":"CheckOut" recalls the source file from the tool's database if you have the proper authority, locks it, and makes it editable."Versioning":"UncheckOut"cancels the checkout, with no changes registered."Close"Dismisses the Source View window.LBL="" HELPID="ProcessMeter"Process MeterThe Process Meter monitors the resource usage of a running process without saving the data. IDREF="28006" TYPE="GRAPHIC"Figure A-35 shows the Process Meter in its default configuration (with only the User/Sys Time chart active).FILE="procMeter.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-35"Figure A-35 ID="28006"Process MeterThe Process Meter contains its own menu bar, which contains the Admin, Charts, Scale, and Help menus. The Admin menu is the same as that described in IDREF="43163" TYPE="TITLE""Admin Menu". The Help menu is the same as that described in IDREF="25659" TYPE="TITLE""Help Menu". The other menus are described in the following sections.LBL="" HELPID=""Charts MenuFILE="charts.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-36"Figure A-36 Process Meter Charts MenuThe Charts Menu contains a set of toggles that allow you to choose which charts are displayed in the Process Meter. You can display as many charts simultaneously as you wish. The choices available are:User/Sys Time (the default)Major/Minor FaultsContext SwitchesBytes Read/WrittenRead/Write Sys CallsOther Sys CallsTotal Sys CallsSignalsProcess SizeLBL="" HELPID=""Scale MenuFILE="scale.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-37"Figure A-37 Process Meter Scale MenuThe Scale Menu is a radio button panel that allows you to set the time scale for the processes displayed in the Process Meter. The choices available are:2 seconds5 seconds10 seconds30 seconds1 minute (the default)2 minutes5 minutes 10 minutes LBL="" HELPID=""Ada-specific WindowsThis section discusses the Debugger windows that are specific to Ada: the Task View and Exception View.LBL="" HELPID="TaskView"Task ViewThe Task View is an Ada-specific view that provides you with task and callstack information. If you do not have Ada installed on your system, the Task View menu item in the Views menu will be grayed-out.FILE="AReference194.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-38"Figure A-38 Task ViewThe Task View contains its own menu bar, which contains the Admin, Config, Display, and Help menus. The Help menu is the same as that described in IDREF="25659" TYPE="TITLE""Help Menu". The other menus are described in the following sections.In addition, the Task View contains the following items:Process Sort togglesAllow you to sort the process list in one of three ways, depending on which of the following radio buttons are active:"Name""Status""Sproc"Process Display tabsAllows you to view either a list of the tasks, or the details of the currently running (and highlighted) task. (See IDREF="86614" TYPE="GRAPHIC"Figure A-39.)FILE="TVprocDetails.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-39"Figure A-39 ID="86614"Task View Process Detail ViewTask Display tabsAllows you to view the callstack information, or the callstack details of the currently selected process.(See IDREF="98891" TYPE="GRAPHIC"Figure A-40.)FILE="TVcallDetails.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-40"Figure A-40 ID="98891"Task View Callstack Detail ViewLBL="" HELPID=""ID="43163"Admin MenuThe Admin Menu (see IDREF="47414" TYPE="GRAPHIC"Figure A-41) contains the following items: FILE="CVadmn.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-41"Figure A-41 ID="47414"Task View Admin Menu"Active" toggle Activates the current window in a set of cloned windows. In the current release, this toggle is always active.ID="AReference77""Clone"ID="AReference78"Creates a clone of the current window. This function is not supported in the current release, and the option is grayed out."Save As Text..."ID="AReference79"Launches the "Save Text" dialog (see IDREF="28166" TYPE="GRAPHIC"Figure A-49). This dialog allows you to save your current session as text in a file you designate."Close" ID="AReference80"Closes the current window.LBL="" HELPID=""Config MenuThe Config Menu (IDREF="39397" TYPE="GRAPHIC"Figure A-42) contains the following items:"Preferences..."launchest the preference dialog (IDREF="39397" TYPE="GRAPHIC"Figure A-42), which allows you the option of setting the maximum depth of the Task View.FILE="AReference197.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-42"Figure A-42 ID="39397"Task View Config MenuLBL="" HELPID=""Layout MenuThe Layout Menu (IDREF="68616" TYPE="GRAPHIC"Figure A-43) contains the following toggles: FILE="TVlayout.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-43"Figure A-43 ID="68616"Task View Layout Menu"Task List"Causes only the Callstack Display to be shown."Single Task"Causes only the Process Display to be shown.LBL="" HELPID=""Display MenuThe Display Menu (IDREF="32885" TYPE="GRAPHIC"Figure A-44) is divided into the Task List Format and Callstack Format sections. The Callstack Format toggles match the toggles that are contained in the Callstack View Display menu. The Task List Format toggles control what radio buttons are made available in the toggle sort list, as well as what information is displayed in the Process Display area.FILE="CVdisp.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-44"Figure A-44 ID="32885"Task View Display MenuThe Task View Display menu contains the following toggles:"Status"Displays the status of the process. This toggle is active by default."Priority"Displays the priority of the process."Sproc"Displays the sproc value of the process. This toggle is active by default."Resource Vector"Displays the resource vector value of the process."Arg Values"Allows you to set the argument values in the Task View. This toggle is active by default."Arg Names"Allows you to set the argument names in the Task View. This toggle is active by default."Arg Types"Allows you to set the argument types in the Task View. "Location"Allows you to set the function location in the Task View. This toggle is active by default."PC"Allows you to set the PC in the Task View. LBL="" HELPID="ExceptionView"Exception ViewThe Exception View is an Ada-specific view that allows you to set traps on exceptions. This view only functions if Ada is installed.FILE="AReference199.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-45"Figure A-45 Exception ViewThe Exception View contains the following items:Admin menuContains the following items:"Active" toggle: Activates the current window in a set of cloned windows. In the current release, this toggle is always active."Clone": Creates a clone of the current window. This function is not supported in the current release, and the option is grayed out."Save As Text...": Launches the "Save Text" dialog (see IDREF="28166" TYPE="GRAPHIC"Figure A-49). This dialog allows you to save your current session as text in a file you designate."Close": Closes the current window."Stop" toggleIndicates when a trap is active."When" option menuAllows you to select when an exception trap fires. Contains the following choices:"Always:" stop any time the exception is raised."Catch-All:" stop when caught by a catchall rather than an explicit handler, or when unhandled."Unhandled:" stop when the exception is unhandled.The process is always stopped at the point of a raise."Search" text fieldAllows you to search for an exception. FILE="excptWhen.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-46"Figure A-46 "When" Exception Option MenuLBL="" HELPID="XMotifAnalyzer"ID="17727"X/Motif Analyzer WindowsThe X/Motif analyzer provides specific debugging support for X/Motif applications. There are various examiners for different X/Motif objects, such as widgets and X graphics contexts, that might be difficult or impossible to inspect using ordinary debugger functionality.To access the X/Motif analyzer window, you must pull down the Views menu and select "X/Motif Analyzer" (see IDREF="97532" TYPE="GRAPHIC"Figure A-47).FILE="AReference51.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-47"Figure A-47 ID="97532"Launching the X/Motif AnalyzerLBL="" HELPID=""ID="75030"Global ObjectsThough the X/Motif Analyzer is made up of several different examiner windows, a number of objects remain constant throughout window changes. The examiner windows available areIDREF="37518" TYPE="TITLE""Breakpoints Examiner"IDREF="22611" TYPE="TITLE""Trace Examiner"IDREF="67883" TYPE="TITLE""Widget Examiner"IDREF="21251" TYPE="TITLE""Tree Examiner"IDREF="31463" TYPE="TITLE""Callback Examiner"IDREF="91799" TYPE="TITLE""Window Examiner"IDREF="14627" TYPE="TITLE""Event Examiner"IDREF="67664" TYPE="TITLE""Graphics Context Examiner"IDREF="86505" TYPE="TITLE""Pixmap Examiner"IDREF="98696" TYPE="TITLE""Widget Class Examiner"LBL="" HELPID=""Admin MenuThe Admin menu (see ID="AReference81"IDREF="82625" TYPE="GRAPHIC"Figure A-48) offers the following menu selections:FILE="adMenu.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-48"Figure A-48 ID="82625"Admin Menu"Active" toggleID="AReference82"Activates the current window in a set of cloned windows. In the current release, this toggle is always active."Clone"ID="AReference83"Creates a clone of the current window. This function is not supported in the current release, and the option is grayed out."Save As Text..."ID="AReference84"Launches the "Save Text" dialog (see IDREF="28166" TYPE="GRAPHIC"Figure A-49). This dialog allows you to save your current session as text in a file you designate."Close" ID="AReference85"Closes the current window.FILE="AReference54.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-49"Figure A-49 ID="28166""Save Text" DialogLBL="" HELPID=""Examine MenuThe Examine menu (see ID="AReference86"IDREF="87731" TYPE="GRAPHIC"Figure A-50) offers the following menu selections:FILE="exMenu.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-50"Figure A-50 ID="87731"Examine Menu"Selection"ID="AReference87"Selects the currently highlighted object for examination."Widget"ID="AReference88"Uses the current selection as input to the widget examiner, then opens that examiner (see IDREF="67883" TYPE="TITLE""Widget Examiner" for information)."Widget Tree"ID="AReference89"Switches the window view to the widget tree examiner (see IDREF="21251" TYPE="TITLE""Tree Examiner" for information)."Widget Class"ID="AReference90"Switches the window view to the widget class examiner (see IDREF="98696" TYPE="TITLE""Widget Class Examiner" for information)."Window"ID="AReference91"Switches the window view to the window examiner (see IDREF="91799" TYPE="TITLE""Window Examiner" for information)."X Event"ID="AReference92"Switches the window view to the X Event examiner (see IDREF="14627" TYPE="TITLE""Event Examiner" for information)."X Graphics Context"ID="AReference93"Switches the window view to the X graphics context examiner (see IDREF="67664" TYPE="TITLE""Graphics Context Examiner" for information)."X Pixmap"ID="AReference94"Switches the window view to the X pixmap examiner (see IDREF="86505" TYPE="TITLE""Pixmap Examiner" for information).LBL="" HELPID=""Examiner TabsIn addition to access through the Examine menu, each examiner can be accessed through a tab at the bottom of each view (see ID="AReference95"IDREF="31161" TYPE="GRAPHIC"Figure A-51).FILE="AReference57.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-51"Figure A-51 ID="31161"Examiner TabsWhen first launched, the X/Motif Analyzer has only four tabs: Breakpoints, Trace, Widget, and Tree. As you use new examiners through the Examine menu, new tabs are added for the new examiners. Any of these new tabs may be deleted at any time by selecting the tab, clicking the right mouse button, and then selecting "Remove Examiner" (see IDREF="63285" TYPE="GRAPHIC"Figure A-52). The initial four tabs may not be removed. FILE="remTab.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-52"Figure A-52 ID="63285"Removing TabsLBL="" HELPID=""Return ButtonThe "Widget" and "Name" text fields both have return buttons (see IDREF="72283" TYPE="GRAPHIC"Figure A-53) just to their right. Clicking these buttons causes the X/Motif Analyzer to respond exactly as if you had pressed Return on your keyboard.LBL="" HELPID="BreakpointsExaminer"ID="37518"Breakpoints ExaminerThe Breakpoints examiner is not really an examiner, but a control area where you can set widget-level breakpoints. The breakpoints examiner is divided into three areas (see ID="AReference96"IDREF="72283" TYPE="GRAPHIC"Figure A-53):The widget specification area, which contains the same information as that in the Widget examiner. You can select a widget address, name, or class in this area, as well as move to the widgets parents or children, or select a widget in the application. In cases where the breakpoint type does not apply to widgets (for example, input-handler breakpoints), this area is blank.The parameter specification area, the contents of which vary according to the type of breakpoint you are setting. For example, for Callback breakpoints, this area contains the callback name and client data; for event-handler breakpoints, it contains the event type and the client data, and so on.The breakpoint area, which contains the breakpoint name, a search field, and the Add, Modify, Delete, and Step To buttons.FILE="AReference60.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-53"Figure A-53 ID="72283"Breakpoints ExaminerThe control area has eight different breakpoint types that it can examine. These types are set through the "Breakpoint Type" option button (see IDREF="57766" TYPE="GRAPHIC"Figure A-54). The options for the "Breakpoint Type" option button are described below:ID="AReference97"FILE="brkTyp.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-54"Figure A-54 ID="57766"Breakpoint Type Option Button"Callback:" Widget callback installed by XtAddCallback. Parameters include callback name and client_dataXtPointer value. See IDREF="65927" TYPE="TITLE""Callback Breakpoints Examiner" for more information."Event-Handler:" Widget event handler installed by XtAddEventHandler. Parameters include X event type and client_dataXtPointer value. See IDREF="52803" TYPE="TITLE""Event-Handler Breakpoints Examiner" for more information."Resource-Change:" Resource change caused by XtSetValues or XtVaSetValues. Parameters include resource name and resource value, both strings. See IDREF="91945" TYPE="TITLE""Resource-Change Breakpoints Examiner" for more information."Timeout-Procedure:" Timeout callback installed by XtAppAddTimeOut. Parameters include client_dataXtPointer value. See IDREF="20368" TYPE="TITLE""Timeout-Procedure Breakpoints Examiner" for more information."Input-Handler:" Input callback installed by XtAppAddInput. Parameters include client_dataXtPointer value. See IDREF="29024" TYPE="TITLE""Input-Handler Breakpoints Examiner" for more information."State-Change:" Various widget state changes (for example, "managed" or "realized"). Parameters include widget state. See IDREF="36797" TYPE="TITLE""State-Change Breakpoints Examiner" for more information."X-Event:" X event received by target application. Parameters include X event type. See IDREF="81641" TYPE="TITLE""X-Event Breakpoints Examiner" for more information."X-Request:" X request received by target application. Parameters include X request type. See IDREF="89840" TYPE="TITLE""X-Request Breakpoints Examiner" for more information.LBL="" HELPID=""ID="65927"Callback Breakpoints ExaminerWhen the "Callback" option of the "Breakpoint Type" option button in the Breakpoint Examiner is selected, the examiner appears as shown in ID="AReference98"IDREF="67841" TYPE="GRAPHIC"Figure A-55.FILE="AReference63.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-55"Figure A-55 ID="67841"Callback Breakpoints ExaminerThe Callback Breakpoints examiner contains the following items:"Widget" text fieldAllows you to choose a widget to examine by entering the widget address."Name" text fieldAllows you to choose a widget to examine by entering the widget name."Class" text fieldAllows you to choose a widget to examine by entering the widget's class. Leave the field blank or enter Any to select all widgets.Parent buttonAllows you to move the parent of the currently selected widget.Previous buttonMoves you to the previously selected widget.Children... buttonShows you the widget's children (it is grayed out if the selected widget cannot have children).Select... buttonAllows you to select the widget in the target process."Breakpoint Type" option buttonAllows you to select the type of breakpoint you wish to set.Clear buttonClears all the current breakpoint selections and text fields."Callback Name" text fieldAllows you to set the name of the callback for the breakpoint."Client_Data" text fieldAllows you to pass in and get back pointer values for the Client_Data."Search" text fieldAllows you to perform a text search through your breakpoints.Add buttonAllows you to add a new breakpoint.Modify buttonAllows you to change the selected breakpoint's settings.Delete buttonDeletes the selected breakpoint.Step To buttonAllows you to step to the next condition. Step To creates a temporary breakpoint, resumes the process, and waits until the process stops. This temporary breakpoint acts exactly like an ordinary breakpoint, save that the Step To button automatically resumes the process and puts up a busy cursor until the condition becomes true.LBL="" HELPID=""ID="52803"Event-Handler Breakpoints ExaminerWhen the "Event-Handler" option of the "Breakpoint Type" option button in the Breakpoint Examiner is selected, the examiner appears as shown in ID="AReference99"IDREF="13958" TYPE="GRAPHIC"Figure A-56.FILE="AReference64.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-56"Figure A-56 ID="13958"Event-Handler Breakpoints ExaminerThe Event-Handler Breakpoints examiner contains the following items:"Widget" text fieldAllows you to choose a widget to examine by entering the widget address."Name" text fieldAllows you to choose a widget to examine by entering the widget name."Class" text fieldAllows you to choose a widget to examine by entering the widget's class. Leave the field blank or enter Any to select all widgets.Parent buttonAllows you to move the parent of the currently selected widget.Previous buttonMoves you to the previously selected widget.Children... buttonShows you the widget's children (it is grayed out if the selected widget cannot have children).Select... buttonAllows you to select the widget in the target process."Breakpoint Type" option buttonAllows you to select the type of breakpoint you wish to set.Clear buttonClears all the current breakpoint selections and text fields."Event Type" option buttonTakes the place of the "Callback Name" text field in the Callback Breakpoints examiner. Allows you to set the event type for a given breakpoint. The types available are shown in IDREF="10679" TYPE="GRAPHIC"Figure A-57.FILE="evtTyp.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-57"Figure A-57 ID="10679"Event Type Option Button"Client_Data" text fieldAllows you to pass in and get back pointer values for the Client_Data."Search" text fieldAllows you to perform a text search through your breakpoints.Add buttonAllows you to add a new breakpoint.Modify buttonAllows you to change the selected breakpoint's settings.Delete buttonDeletes the selected breakpoint.Step To buttonAllows you to step to the next condition. Step To creates a temporary breakpoint, resumes the process, and waits until the process stops. This temporary breakpoint acts exactly like an ordinary breakpoint, save that the Step To button automatically resumes the process and puts up a busy cursor until the condition becomes true.LBL="" HELPID=""ID="91945"Resource-Change Breakpoints ExaminerWhen the "Resource-Change" option of the "Breakpoint Type" option button in the Breakpoint Examiner is selected, the examiner appears as shown in ID="AReference100"IDREF="48607" TYPE="GRAPHIC"Figure A-58.FILE="AReference67.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-58"Figure A-58 ID="48607"Resource-Change Breakpoints ExaminerThe Resource-Change Breakpoints examiner contains the following items:"Widget" text fieldAllows you to choose a widget to examine by entering the widget address."Name" text fieldAllows you to choose a widget to examine by entering the widget name."Class" text fieldAllows you to choose a widget to examine by entering the widget's class. Leave the field blank or enter Any to select all widgets.Parent buttonAllows you to move the parent of the currently selected widget.Previous buttonMoves you to the previously selected widget.Children... buttonShows you the widget's children (it is grayed out if the selected widget cannot have children).Select... buttonAllows you to select the widget in the target process."Breakpoint Type" option buttonAllows you to select the type of breakpoint you wish to set.Clear buttonClears all the current breakpoint selections and text fields."Resource Name" text fieldTakes the place of the "Callback Name" text field. Allows you to set the resource name for the breakpoint."Resource Value" text fieldTakes the place of the "Client Data" text field. Allows you to set the resource value for the breakpoint."Search" text fieldAllows you to perform a text search through your breakpoints.Add buttonAllows you to add a new breakpoint.Modify buttonAllows you to change the selected breakpoint's settings.Delete buttonDeletes the selected breakpoint.Step To buttonAllows you to step to the next condition. Step To creates a temporary breakpoint, resumes the process, and waits until the process stops. This temporary breakpoint acts exactly like an ordinary breakpoint, save that the Step To button automatically resumes the process and puts up a busy cursor until the condition becomes true.LBL="" HELPID=""ID="20368"Timeout-Procedure Breakpoints ExaminerWhen the "Timeout Procedure" option of the "Breakpoint Type" option button in the Breakpoint Examiner is selected, the examiner appears as shown in ID="AReference101"IDREF="58759" TYPE="GRAPHIC"Figure A-59. FILE="AReference68.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-59"Figure A-59 ID="58759"Timeout-Procedure Breakpoints ExaminerThe Resource-Change Breakpoints examiner contains the following items:"Breakpoint Type" option buttonAllows you to select the type of breakpoint you wish to set.Clear buttonClears all the current breakpoint selections and text fields."Client_Data" text fieldAllows you to pass in and get back pointer values for the Client_Data."Search" text fieldAllows you to perform a text search through your breakpoints.Add buttonAllows you to add a new breakpoint.Modify buttonAllows you to change the selected breakpoint's settings.Delete buttonDeletes the selected breakpoint.Step To buttonAllows you to step to the next condition. Step To creates a temporary breakpoint, resumes the process, and waits until the process stops. This temporary breakpoint acts exactly like an ordinary breakpoint, save that the Step To button automatically resumes the process and puts up a busy cursor until the condition becomes true.LBL="" HELPID=""ID="29024"Input-Handler Breakpoints ExaminerWhen the "Input-Handler" option of the "Breakpoint Type" option button in the Breakpoint Examiner is selected, the examiner appears as shown in ID="AReference102"IDREF="10204" TYPE="GRAPHIC"Figure A-60.FILE="AReference69.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-60"Figure A-60 ID="10204"Input-Handler Breakpoints ExaminerThe Input-Handler Breakpoints examiner contains the following items:"Breakpoint Type" option buttonAllows you to select the type of breakpoint you wish to set.Clear buttonClears all the current breakpoint selections and text fields."Client_Data" text fieldAllows you to pass in and get back pointer values for the Client_Data."Search" text fieldAllows you to perform a text search through your breakpoints.Add buttonAllows you to add a new breakpoint.Modify buttonAllows you to change the selected breakpoint's settings.Delete buttonDeletes the selected breakpoint.Step To buttonAllows you to step to the next condition. Step To creates a temporary breakpoint, resumes the process, and waits until the process stops. This temporary breakpoint acts exactly like an ordinary breakpoint, save that the Step To button automatically resumes the process and puts up a busy cursor until the condition becomes true.LBL="" HELPID=""ID="36797"State-Change Breakpoints ExaminerWhen the "State-Change" option of the "Breakpoint Type" option button in the Breakpoint Examiner is selected, the examiner appears as shown in ID="AReference103"IDREF="43985" TYPE="GRAPHIC"Figure A-61.FILE="AReference71.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-61"Figure A-61 ID="43985"State-Change Breakpoints ExaminerThe Resource-Change Breakpoints examiner contains the following items:"Widget" text fieldAllows you to choose a widget to examine by entering the widget address."Name" text fieldAllows you to choose a widget to examine by entering the widget name."Class" text fieldAllows you to choose a widget to examine by entering the widget's class. Leave the field blank or enter Any to select all widgets.Parent buttonAllows you to move the parent of the currently selected widget.Previous buttonMoves you to the previously selected widget.Children... buttonShows you the widget's children (it is grayed out if the selected widget cannot have children).Select... buttonAllows you to select the widget in the target process."Breakpoint Type" option buttonAllows you to select the type of breakpoint you wish to set.Clear buttonClears all the current breakpoint selections and text fields."State Type" option buttonTakes the place of the "Callback Name" text field in the Callback Breakpoints examiner. Allows you to set the state change type for a given breakpoint. The types available are as follows (see IDREF="33958" TYPE="GRAPHIC"Figure A-62):CreatedDestroyedManagedRealizedUnmanagedAnyFILE="steTyp.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-62"Figure A-62 ID="33958"State Type Option Button"Search" text fieldAllows you to perform a text search through your breakpoints.Add buttonAllows you to add a new breakpoint.Modify buttonAllows you to change the selected breakpoint's settings.Delete buttonDeletes the selected breakpoint.Step To buttonAllows you to step to the next condition. Step To creates a temporary breakpoint, resumes the process, and waits until the process stops. This temporary breakpoint acts exactly like an ordinary breakpoint, save that the Step To button automatically resumes the process and puts up a busy cursor until the condition becomes true.LBL="" HELPID=""ID="81641"X-Event Breakpoints ExaminerWhen you select the "X-Event" option of the "Breakpoint Type" option button in the Breakpoint Examiner, the examiner appears as shown in ID="AReference104"IDREF="36740" TYPE="GRAPHIC"Figure A-63.FILE="AReference74.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-63"Figure A-63 ID="36740"X-Event Breakpoints ExaminerThe X-Event Breakpoints examiner contains the following items:"Breakpoint Type" option buttonAllows you to select the type of breakpoint you wish to set.Clear buttonClears all the current breakpoint selections and text fields."Event Type" option buttonTakes the place of the "Callback Name" text field in the Callback Breakpoints examiner. Allows you to set the event type for a given breakpoint. The types available are shown in IDREF="10679" TYPE="GRAPHIC"Figure A-57.FILE="evtTyp.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-64"Figure A-64 ID="10679"Event Type Option Button"Window ID" text fieldTakes the place of the "Client_Data" text field. Allows you to set the Window ID value for the breakpoint."Search" text fieldAllows you to perform a text search through your breakpoints.Add buttonAllows you to add a new breakpoint.Modify buttonAllows you to change the selected breakpoint's settings.Delete buttonDeletes the selected breakpoint.Step To buttonAllows you to step to the next condition. Step To creates a temporary breakpoint, resumes the process, and waits until the process stops. This temporary breakpoint acts exactly like an ordinary breakpoint, save that the Step To button automatically resumes the process and puts up a busy cursor until the condition becomes true.LBL="" HELPID=""ID="89840"X-Request Breakpoints ExaminerWhen the "X-Request" option of the "Breakpoint Type" option button in the Breakpoint Examiner is selected, the examiner appears as shown in IDREF="80052" TYPE="GRAPHIC"Figure A-65.FILE="AReference78.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-65"Figure A-65 ID="80052"X-Request Breakpoints ExaminerThe X-Request Breakpoints examiner contains the following items:"Breakpoint Type" option buttonAllows you to select the type of breakpoint you wish to set.Clear buttonClears all the current breakpoint selections and text fields.Request Type buttonLaunches the "Request Type Selection" dialog (see IDREF="23152" TYPE="GRAPHIC"Figure A-66). This dialog allows you to select the type of X-Request used for your breakpoint. The information displayed is in outline form; selecting a given item selects all its subitems. For example, if you select Window-Category, CreateWindow, ChangeWindowAttributes, GetWindowAttributes, and so on are also selected.FILE="AReference79.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-66"Figure A-66 ID="23152""Request Type Selection" Dialog"Search" text fieldAllows you to perform a text search through your breakpoints.Add buttonAllows you to add a new breakpoint.Modify buttonAllows you to change the selected breakpoint's settings.Delete buttonDeletes the selected breakpoint.Step To buttonAllows you to step to the next condition. Step To creates a temporary breakpoint, resumes the process, and waits until the process stops. This temporary breakpoint acts exactly like an ordinary breakpoint, save that the Step To button automatically resumes the process and puts up a busy cursor until the condition becomes true.LBL="" HELPID="TraceExaminer"ID="22611"Trace ExaminerThe Trace examiner (see ID="AReference105"IDREF="75703" TYPE="GRAPHIC"Figure A-67) is a control area where you can trace the execution of your application and collect various forms of data. The following data is collected:X Server EventsX Server RequestsWidget Event Dispatch InformationWidget Resource Changes (through XtSetValues)Widget State Changes (create, destroy, manage, realize, unmanage)Xt Callbacks (widget, event handler, work proc, timeout, input, signal)FILE="AReference80.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-67"Figure A-67 ID="75703"Trace ExaminerThe Trace examiner contains the following items:"Collect Trace" toggleAllows you to turn the tracing on and off."File" text fieldAllows you to select the filename for the trace. If no file is selected, a default filename for the trace is chosen."Search" text fieldAllows you to perform an incremental, textural search for the trace list.Filter... buttonLaunches a dialog that allows you to select the trace entry types you want displayed in the list.Clear File buttonErases the trace file. Any subsequent trace information goes to the beginning of the file.LBL="" HELPID="WidgetExaminer"ID="67883"Widget ExaminerThe Widget examiner (see ID="AReference106"IDREF="91270" TYPE="GRAPHIC"Figure A-68) displays the internal Xt widget structure, as well as the Xt inheritance implemenation using nested C structs.FILE="AReference82.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-68"Figure A-68 ID="91270"Widget ExaminerThe Widget examiner contains the following items:"Widget" text fieldAllows you to choose a widget to examine by entering the widget address."Name" text fieldAllows you to choose a widget to examine by entering the widget name.Parent buttonAllows you to move the parent of the currently selected widget.Previous buttonMoves you to the previously selected widget.Children... buttonShows you the widget's children. (It is grayed out if the selected widget cannot have children.)Select... buttonAllows you to select the widget in the target process.LBL="" HELPID="TreeExaminer"ID="21251"Tree ExaminerThe Tree examiner (see ID="AReference107"IDREF="93442" TYPE="GRAPHIC"Figure A-69) displays the widget hierarchy.FILE="AReference83.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-69"Figure A-69 ID="93442"Tree ExaminerYou may double-click a node to view that widget in the Widget examiner. Use the option menu in the bottom-right corner to switch the display among widget names, class names, and IDs.If the Tree examiner is currently selected, it will not automatically fetch the current widget tree each time the process stops. To force retrieval of the widget tree, select another examiner and then go back to the Tree examiner. Or, click on the Tree tab.You may display the tree according to widget name, class, or ID value. You can select this by choosing the appropriate option from the widget view type option button (see IDREF="14192" TYPE="GRAPHIC"Figure A-70) in the lower-right portion of the examiner.FILE="treMen.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-70"Figure A-70 ID="14192"Widget View Type Option ButtonLBL="" HELPID="CallbackExaminer"ID="31463"Callback ExaminerThe Callback examiner (see ID="AReference108"IDREF="97167" TYPE="GRAPHIC"Figure A-71) automatically appears when the process is stopped somewhere in a callback. It first displays the callstack frame for the callback function. Next, it displays information about the widget in the callback. Finally, it displays the proper callback structure contained in the call_data argument to the callback procedure, based on the widget type and the callback name.FILE="AReference86.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-71"Figure A-71 ID="97167"Callback ExaminerLBL="" HELPID="WindowExaminer"ID="91799"Window ExaminerThe Window examiner (see ID="AReference109"IDREF="89421" TYPE="GRAPHIC"Figure A-72) displays window attributes for an X window. These are the attributes returned by XGetWindowAttributes, with decoding of the Visual structure and enums and masks decoded. Additionally, the Window examiner shows the parent and children window IDs.FILE="winTut.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-72"Figure A-72 ID="89421"Window ExaminerThe Window examiner contains the "Window" text field, which displays the address of the window that is being examined. You may change to a different window by entering a new address and pressing the ENTER key.LBL="" HELPID="EventExaminer"ID="14627"Event Examiner The Event examiner (see ID="AReference110"IDREF="22406" TYPE="GRAPHIC"Figure A-73) displays the event structure for an XEvent pointer. The proper XEvent union member is used, and enums and masks are decoded.FILE="AReference88.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-73"Figure A-73 ID="22406"Event ExaminerThe Event examiner contains the "X Event" text field, which displays the address of the X event that is being examined. You may change to a different X event by entering a new address and pressing the ENTER key.LBL="" HELPID="GCExaminer"ID="67664"Graphics Context ExaminerThe Graphics Context examiner (see ID="AReference111"IDREF="65050" TYPE="GRAPHIC"Figure A-74) displays the X graphics context attributes that are cached by Xlib in the form of an XGCValues structure. Enums and masks are decoded.FILE="AReference89.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-74"Figure A-74 ID="65050"Graphics Context ExaminerThe Graphics Context examiner contains the "GC" text field, which displays the address of the graphics context that is being examined. You may change to a different context by entering a new address and pressing the ENTER key.LBL="" HELPID="PixmapExaminer"ID="86505"Pixmap ExaminerThe Pixmap examiner (see ID="AReference112"IDREF="17025" TYPE="GRAPHIC"Figure A-75) displays basic attributes of an X pixmap, like size and depth. It also attempts to provide an ASCII display of small pixmaps, using the units digit of the pixel values.FILE="AReference90.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-75"Figure A-75 ID="17025"Pixmap ExaminerThe Pixmap examiner displays the contents of an X pixmap. Specify the X pixmap identifier and optionally, the X colormap identifier, by entering expressions in the two text areas at the top of the window. Use 'default' as the colormap identifier to specify the default X colormap for your screen. In the actual pixmap display, left-click on a pixel to see the pixel value, position, and red-green-blue intensities.LBL="" HELPID="WCExaminer"ID="98696"Widget Class ExaminerThe Widget Class examiner (see ID="AReference113"IDREF="27033" TYPE="GRAPHIC"Figure A-76) displays the Xt widget class structure, as well as the Xt inheritance implementation using nested C structs.FILE="AReference91.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-76"Figure A-76 ID="27033"Widget Class ExaminerThe Widget Class examiner contains the "W Class" text field, which displays the address of the widget class that is being examined. You may change to a different widget class by entering a new address and pressing the ENTER key.LBL="" HELPID=""ID="71783"Project Session Management WindowsA project is a single CASEVision work session focused on a common task. Its purpose is to let you perform operations conveniently on selected project components or on the project as a whole. A project includes all CASEVision tools and windows invoked from the command line (unless invoked with the -privateProject switch) and from the graphical user interface of one of those tools. When you are working on a single project, with only a few windows open simultaneously, you can keep track of your activities with relative ease. In situations where you have many windows open from one or more projects, it is easy to get confused. To simplify the use of multiple windows, WorkShop provides facilities for iconifying and raising windows inMain View Admin menuthe "Project" submenuthe Project View windowIDREF="31138" TYPE="GRAPHIC"Figure A-77 shows where these facilities are located.FILE="AReference92.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-77"Figure A-77 ID="31138"Iconify and Raise FacilitiesThe window facilities in the Main View Admin menu apply to the current application and its windows only. "Iconify" iconifies all of the application's views. "Raise" brings all the application's view windows to the foreground and redisplays any iconified windows.ID="AReference114"ID="AReference115"The "Project" submenu selections "Iconify," "Raise," "Remap Paths...," and "Exit" operate the same way as their counterparts do in the MainView Admin menu, except that they are applied to all tools and windows in the current project. LBL="" HELPID="ProjectView"ID="26575"Project ViewTo display the Project View window, in the Main View, pull down the Admin menu, select the "Project" submenu, and select "Project View..." The Project View window is shown in IDREF="16706" TYPE="GRAPHIC"Figure A-78 with its Admin menu and right-button popup menu. Project View represents the components of a project (tools or windows depending on the toggles in the Admin menu) as buttons. Elements from the same project are grouped within a rectangle. A dashed-line rectangle indicates the currently selected project. When a project is selected, you can change its name or change the command.FILE="AReference93.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-78"Figure A-78 ID="16706"Project View Window with MenusLBL="" HELPID=""Project View Admin MenuThe "Show Applications" and "Show Windows" toggle selections in the Admin menu determine whether applications or individual windows display as project element buttons. The "Rescan" selection reevaluates the state of your projects and redisplays the current elements. "Exit" closes the Project View window.LBL="" HELPID=""Project View Text FieldsThe Project field lets you enter a name to identify the current project. The Command field lets you invoke other tools to be included in the project. These can be WorkShop tools or integrated tools, such as CASEVision/ClearCase. LBL="" HELPID=""Project Display AreaThe elements of a project are represented by buttons. When a button protrudes from the screen, the item is currently iconified; when it is recessed, the item is displayed. Clicking the button toggles it between display and iconify modes.LBL="" HELPID=""Project Popup MenuWhen you hold down the right mouse button inside a project rectangle, the Project popup menu displays. It lets you "Iconify," "Raise," or "Quit" the item under the cursor or all items in the project as a whole, if the cursor is within the rectangle but not over an item.LBL="" HELPID=""Trap Management WindowsIn addition to setting traps through the Main View and the command line, the debugger provides you with three views specific to trap management:Trap ManagerSignal PanelSyscall PanelLBL="" HELPID="TrapManager"Trap ManagerThe Trap Manager allows you to set, edit, and manage traps (used in both the Debugger and Performance Analyzer). The Trap Manager is shown in IDREF="27730" TYPE="GRAPHIC"Figure A-79.FILE="trap.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-79"Figure A-79 ID="27730"Trap ManagerThe Trap Manager contains the following items (besides the menu bar, which is discussed below):"Trap" text fieldContains a description of the trap."Condition" text fieldContains the condition of the trap."Cycle Count" text fieldDisplays the current cycle count."Current Count" text fieldDisplays the current trap count.Modify buttonAllows you to change the selected breakpoint's settings.Add buttonAllows you to add a new breakpoint.Clear buttonClears all the current breakpoint selections and text fields.Delete buttonDeletes the selected breakpoint.Trap Display areaContains a description of each trap, and a toggle to indicate whether or not the trap is active."Search" text fieldAllows you to perform an incremental, textural search for the trap list.The Trap Manager has a menu bar which contains the Admin, Config, Traps, Display, and Help menus. The Admin menu is the same as that described in IDREF="43163" TYPE="TITLE""Admin Menu". The Help menu is the same as that described in IDREF="25659" TYPE="TITLE""Help Menu". The other menus are described in the following sections.LBL="" HELPID=""Config MenuFILE="TMconfig.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-80"Figure A-80 ID="39733"Trap Manager Config MenuThe Config Menu (IDREF="39733" TYPE="GRAPHIC"Figure A-80) contains the following items:"Load Traps..."Brings up the File dialog (see IDREF="35936" TYPE="GRAPHIC"Figure A-139), allowing you to load the traps from a file."Save Traps..."Brings up the File dialog (see IDREF="35936" TYPE="GRAPHIC"Figure A-139), allowing you to save the current traps to a file.LBL="" HELPID=""Traps MenuFILE="TMtraps.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-81"Figure A-81 ID="34031"Trap Manager Traps MenuThe Traps Menu (IDREF="34031" TYPE="GRAPHIC"Figure A-81) allows you to set traps under a number of conditions. These conditions are:"At Source Line""Entry Function""Exit Function""Stop Trap Default""Sample Trap Default""Group Trap Default""Stop All Default"LBL="" HELPID=""Display MenuFILE="TMdisplay.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-82"Figure A-82 ID="41596"Trap Manager Display MenuThe Display Menu (IDREF="41596" TYPE="GRAPHIC"Figure A-82) contains the following items:"Delete All"Deletes all traps from the trap list.LBL="" HELPID="SignalPanel"Signal PanelThe Signal Panel displays the signals that can occur. You can specify which signals trigger traps and which are to be ignored. The Signal Panel is shown in IDREF="64682" TYPE="GRAPHIC"Figure A-83.FILE="signal.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-83"Figure A-83 ID="64682"Signal PanelThe Signal Panel contains an Admin menu (described  in IDREF="43163" TYPE="TITLE""Admin Menu") and a Help menu (described in IDREF="25659" TYPE="TITLE""Help Menu"). Each signal trigger trap in the display has a toggle associated with it. In addition, the panel has a Search field.LBL="" HELPID="SyscallPanel"Syscall PanelThe Syscall Panel lets you set traps at the entry to or exit from system calls. The Syscall Panel is shown in IDREF="16964" TYPE="GRAPHIC"Figure A-84.FILE="syscall.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-84"Figure A-84 ID="16964"Syscall PanelThe Syscall Panel contains an Admin menu (described  in IDREF="43163" TYPE="TITLE""Admin Menu") and a Help menu (described in IDREF="25659" TYPE="TITLE""Help Menu"). Each system call in the display has two toggle associated with it: one to set a trap on entry, one to set a trap on exit. In addition, the panel has a Search field.LBL="" HELPID=""ID="38384"Data Examination WindowsThere are several windows that are used primarily to examine your debugging data: IDREF="84807" TYPE="TITLE""Array Browser"IDREF="31820" TYPE="TITLE""Call Stack View"IDREF="56801" TYPE="TITLE""Expression View"IDREF="65348" TYPE="TITLE""File Browser"IDREF="23500" TYPE="TITLE""Structure Browser"IDREF="40944" TYPE="TITLE""Variable Browser"ID="84807"LBL="" HELPID="ArrayBrowser"Array BrowserTo examine data in an array variable, select Array Browser from the Views menu at a point in the process where the variable is present. Array Browser lets you view elements in a multi-dimensional array (up to 100 x 100 elements), presented in a spreadsheet and graphically, if desired. (For a tutorial example of the Array Browser, see ID="AReference116"ID="AReference117"IDREF="13777" TYPE="TITLE""Examining Data".)FILE="AReference173.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-85"Figure A-85 ID="58268" Array Browser With Display Menu OptionsThe array specification area lets you specify the variable and its dimensions. It consists of these fields:Array:ID="AReference118" Lets you enter the name of the array variable. This entry is language-dependent. For Fortran, the expression may be an array or a dummy array variable name. If the last dimension of the array is unspecified (*), a subscript value of 1 is assumed initially.For C and C++, the entry may be an array, a pointer, or an array pointer. If pointers are used, the expression is treated as though it were a single element, in which case you need to use the subscript controls to see more than the first element.Indexing Expression:ID="AReference119" The expression used to view an element in the array. It is filled in automatically when you specify an array to view. The expression supplied is language-specific. It represents the indexing expression used in the language to access a particular element. The subscripts are specified by special indexing variables ($i, $j, $k, and so forth) that can be manipulated in the subscript controls area. The subscript control areaID="AReference120" serves two functions: (1) it lets you control which elements in the variable are to be displayed, and (2) it lets you shift the current element. The number of dimensions in the array governs the number of controls that are displayed. A close-up view of the subscript controls area appears in IDREF="25915" TYPE="GRAPHIC"Figure A-86.FILE="AReference174.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-86"Figure A-86 ID="25915"Subscript Control Area in Array BrowserThe subscript control area provides these featuresrow/column togglesID="AReference121"Control whether an index variable represents rows or columns (or neither) in the spreadsheet area. You are not limited by the number of vectors in an array, but you can only view a two-dimensional orthogonal slice of the array at a time. index identifiersID="AReference122"Indicate to which subscript the controls in the row refer.index valuesID="AReference123" Show the value of the subscript for the element currently in the focus cell. You can enter a different value if you wish.index slidersID="AReference124" Let you move the focus cell along the particular vector.index minimumsID="AReference125"Identify the beginning visible element in a vector. ID="AReference126"index maximumsIdentify the last visible element in a vector. If you have an unspecified array, you can use this field to specify the last element in the vector to be displayed in the spreadsheet.ID="AReference127"step indicatorsSpecifies the increment between adjacent elements in a vector to be displayed. A value of 1 displays consecutive data. Specifying some n greater than 1 lets you display every nth element in a vector.control area scroll bars Let you expose hidden portions of the subscript control area if your window is not large enough for viewing all of the controls.The ID="AReference128"spreadsheet area is where numeric data is displayed. It can show two dimensions at a time (indicated in the upper left corner of the matrix). The column indexes run along the top of the matrix and the row indexes are displayed along the left column. The spreadsheet area has scroll bars for viewing data elements not currently visible in the viewing area. IDREF="29084" TYPE="GRAPHIC"Figure A-87 shows a close-up of the spreadsheet area.FILE="AReference175.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-87"Figure A-87 ID="29084" Array Browser Spreadsheet AreaThe current element is highlighted by a colored rectangle in the spreadsheet area. Its corresponding expression is shown in the current element identifier field, and the value is shown in the current element value field. LBL="" HELPID=""Spreadsheet MenuFILE="f07sprmn.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-88"Figure A-88 ID="18760"Spreadsheet MenuThe Spreadsheet menu (see IDREF="18760" TYPE="GRAPHIC"Figure A-88) lets you change the appearance of data in the spreadsheet area. It provides these selections:"Column Width..."ID="AReference129"Lets you specify the width of the spreadsheet cells in terms of characters. For instance, a value of 12 indicates that 12 characters, including punctuation and digits are viewable."Wrapped Display"ID="AReference130"Lets you display a single dimension of an array wrapped around the entire spreadsheet area. The index value for an element is determined by adding the appropriate row index and column index values.IDREF="93773" TYPE="GRAPHIC"Figure A-89 shows an example of a wrapped array. There is only one index $i. The current cell is element 4 in the array (by adding 3 and +1).FILE="AReference178.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-89"Figure A-89 ID="93773" Example of Wrapped ArrayLBL="" HELPID=""Format MenuFILE="AReference179.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-90"Figure A-90 Format Menu With Value SubmenuID="13090"The Format menu (see IDREF="13090" TYPE="GRAPHIC"Figure A-23) displays a separate menu that you lets you display the elements in the default format, as formatted values (decimal, unsigned, octal, and so forth) or as their data types. The graphical display area presents the array data in a 3-D graph in one of the following forms:surface (polyhedron)bar chartpointsmultiple lines (array vectors)LBL="" HELPID=""Render MenuFILE="f07rndmn.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-91"Figure A-91 ID="20145"Render MenuYou select the graphical display mode through the Render menu. The Render menu (see IDREF="20145" TYPE="GRAPHIC"Figure A-91) has the following items:"Surface"Exhibits the data as a solid using the data values as vertices in a polyhedron."Bar Chart"Presents the data values as 3-D bar charts."Points"Simply plots the data values in 3-D space."Multi Line"Plots and connects the data values in each row."None"Lets you display Array Browser with no graphical display, in effect turning off graphical display mode.LBL="" HELPID=""Color MenuFILE="f07clrmn.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-92"Figure A-92 ID="62940"Color MenuThe Color menu (see IDREF="62940" TYPE="GRAPHIC"Figure A-92) provides these options:"Monotone Ramp"Displays the data values in a single tone, with lower numbers being darker and higher values lighter in tone."Hue Ramp"Displays the data values in a spectrum of colors ranging from blue (lowest values) through green, yellow, orange, and red (highest values)."Exception"Lets you flag certain conditions by color, usually for the purpose of spotting bad data. When you select "Exception," the controls shown in IDREF="52405" TYPE="GRAPHIC"Figure A-93 appear in the window. FILE="f07clrex.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-93"Figure A-93 ID="52405" Color Exception Portion of Array Browser WindowThus, you can highlight data values less than or greater than specified values, values of plus or minus infinity, values of plus or minus underflow, zero values, and NaN (not a number) values.FILE="AReference186.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-94"Figure A-94 ID="11687" Array Browser Graphic ModesLBL="" HELPID=""Scale MenuFILE="f07sclmn.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-95"Figure A-95 ID="32378"Scale MenuThe Scale menu (see IDREF="32378" TYPE="GRAPHIC"Figure A-95) provides options for changing the ratio of the z-dimension, which represents the value of the element. The number on the left represents the value of the x- and y-dimensions (which are always the same as each other); the number on the right is the z dimension.Manipulating the z-dimension affects the ease of spotting differences in values. If your data is scattered over a narrow range of values, you may wish to heighten the graph by selecting "10:1" as your scale; this exaggerates the values in the z-dimension. If your data is in a wide range, selecting "1:2" or "1:10" as the scale will minimize the differences, flattening the graph. LBL="" HELPID=""Examiner Viewer Controls The graphical display uses controls and menus from Examiner Viewer. Examiner Viewer is based on a camera metaphor and borrows terms from the film industry, such as zoom and dolly, in naming its controls. The graphical display area of the window is shown in IDREF="39236" TYPE="GRAPHIC"Figure A-96, with its main controls and menus. Note that the buttons on the upper right side of the graphical display area may not be visible if the area is too small; you can expose them by moving either the upper or lower sash to enlarge the display area.Examiner Viewer provides these controls for viewing the graph. The right side buttons are:view modeToggles between a view-only mode (closed eye) and manipulation mode (open eye). In view-only mode, the cursor appears as an arrow and the graph cannot be moved. Clicking on a portion of the graph selects the corresponding array element in the spreadsheet.In manipulation mode, the cursor appears as a hand and you can move the graph. Dragging the graph with the left mouse button down moves the graph in any direction as if it were in a trackball; a quick movement spins the graph. Dragging the graph with the left mouse button and the ctrl button rolls (rotates) the graph in the plane of the screen. Dragging the graph with the middle mouse button moves it without changing the viewing angle. If you drag the graph with both the left and middle mouse buttons down, the graph will appear to move into or out of the window (this is the same as the dolly thumbwheel which is described in this section).FILE="AReference189.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-96"Figure A-96 ID="39236" Examiner Viewer With Controls and MenushelpRuns a special help system containing Inventor Viewer information.homeRepositions the graph in its original viewing position.set homeChanges the home (original viewing) position for subsequent use of the home button.view allRepositions the display area so that the entire graph is visible.seekProvides a special cursor that lets you reposition the graph in the center of the display area or lets you center the view on a point you select with the cursor. See "Seek to point <or object>" in the Preferences dialog box.These four controls let you move the graphic display:x rotation thumbwheelRotates the graph around its x-axis.y rotation thumbwheelRotates the graph around its y-axis.zoom slider and readoutChanges the size of the graph by scaling it.dolly thumbwheelChanges the size of the graph and adjusts the angles to maintain perspective. The dolly control simulates moving the viewing camera back and forth with respect to the graph.LBL="" HELPID=""Examiner Viewer MenuYou access the Examiner Viewer menu (see IDREF="39236" TYPE="GRAPHIC"Figure A-96) by holding down the right mouse button in the graphical display area. The Examiner Viewer menu provides these selections:"Functions"Displays a submenu with the selections "Help," "Home," "Set Home," "View All," and "Seek," which are the same as the right mouse button controls described in the previous section, and the "Copy View" and "Paste View" selections. These operate like standard copy and paste editing commands, enabling you to transfer graphs."Draw Style"Displays a submenu that controls how the graph is displayed. The selections "as is," "filled," "wireframe," and "points" control how the graph is displayed when it is static. These override the Render menu selections. The selections "move wireframe" and "move points" control how the graph is displayed while in motion. The selections "single," "double," and "interactive" refer to buffering techniques used in moving the graph. These affect the smoothness of the movement."Viewing"The same as the view mode button described in the previous section. When it is off, you can select points from the graph to display in the spreadsheet but cannot move the graph. When on, it lets you manipulate the graph."Decoration"Displays the right side buttons when it is on and hides them when it is off."Headlight"Controls the shadow effect on the graph. When it is on, the light appears to come from the camera."Preferences"Causes the Examiner Viewer Preferences dialog box to display.FILE="f07exmpr.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-97"Figure A-97 Examiner Viewer Preferences Dialog Box"Seek animation time"Lets you specify the time it takes for the graph to be repositioned after you change the seek point. See  "Seek to point <or object>." "Seek to point <or object>"Lets you change the view of the graph to its center (object) or to a point in the graph that you specify with the seek cursor."Zoom slider ranges from"Lets you change the Zoom range, that is, the distance that the object appears to be away from the front of the window."Auto clipping planes"Centers the graph in your view if enabled. If disabled, it provides controls for removing data from visibility at either end of the z-axis. This is useful if you wish to focus on data above or below a set value."Enable spin automation"Lets you spin the graph. You grab the graph with the mouse, move it quickly in the desired direction, and release the mouse button. The graph spins as if in a trackball."Show point of rotation axes"Displays a set of three axes. You can move the graph around the x and y axes using the thumbwheel controls described in the previous section. When this option is on, you can set the size of the axes in pixels.ID="31820"LBL="" HELPID="CallStackView"Call Stack ViewThe Call Stack View (ID="AReference131"ID="AReference132"IDREF="50813" TYPE="GRAPHIC"Figure A-98) displays the functions in the call stack (referred to as ID="AReference133"frames) when the process has stopped.FILE="f02cstck.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-98"Figure A-98 ID="50813"Call Stack ViewThe source display has two special annotations:The location of the current program state is indicated by a large green (depending on color scheme) arrow representing the PC.The location of the call to the function selected in the Call Stack View window is indicated by a smaller blue (depending on color scheme) arrow representing the current context, and the source line becomes highlighted.The Call Stack View contains its own menu bar, which contains the Admin, Config, Display, and Help menus. The Admin menu is the same as that described in IDREF="43163" TYPE="TITLE""Admin Menu". The Help menu is the same as that described in IDREF="25659" TYPE="TITLE""Help Menu". The other menus are described in the following sections.LBL="" HELPID=""Config MenuThe Config Menu (IDREF="60710" TYPE="GRAPHIC"Figure A-99) contains the following items:"Preferences..."launchest the preference dialog (IDREF="60710" TYPE="GRAPHIC"Figure A-99), which allows you the option of setting the maximum depth of the Call Stack View.FILE="AReference95.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-99"Figure A-99 ID="60710"Call Stack View Config MenuLBL="" HELPID=""Display MenuFILE="CVdisp.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-100"Figure A-100 ID="52257"Call Stack View Display MenuThe Display Menu (IDREF="52257" TYPE="GRAPHIC"Figure A-100) contains the following toggles:"Arg Values"Allows you to set the argument values in the Call Stack View."Arg Names"Allows you to set the argument names in the Call Stack View."Arg Types"Allows you to set the argument types in the Call Stack View."Location"Allows you to set the function location in the Call Stack View."PC"Allows you to set the PC in the Call Stack View.ID="56801"LBL="" HELPID="ExpressionView"Expression ViewThe Expression View window is shown in ID="AReference134"IDREF="37551" TYPE="GRAPHIC"Figure A-101. The expression view displays a collection of expressions that are evaluated each time the process stops or the context changes.FILE="f07expv2.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-101"Figure A-101 ID="37551"Expression ViewIn addition to the items on the menu bar, the Expression View has two popup menus: the Language menu and the Format menu. The menu bar items and the two popup menus are discussed in the following sections. (The Admin menu is the same as that described in ID="AReference135"ID="AReference136"IDREF="43163" TYPE="TITLE""Admin Menu". The Help menu is the same as that described in IDREF="25659" TYPE="TITLE""Help Menu". The other menus are described in the following sections.)LBL="" HELPID=""Config MenuFILE="EVconf.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-102"Figure A-102 ID="33217"Expression View Config MenuThe Config Menu (see IDREF="33217" TYPE="GRAPHIC"Figure A-102) contains the following items: "Load Expressions..."Launches the File menu (IDREF="28166" TYPE="GRAPHIC"Figure A-49), allowing you to choose a source file from which to load your expressions."Save Expressions..."Launches the File menu (IDREF="28166" TYPE="GRAPHIC"Figure A-49), allowing you to choose a file to which you can save your expressions.LBL="" HELPID=""Display MenuFILE="EVdply.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-103"Figure A-103 ID="92022"Expression View Display MenuThe Display Menu (see IDREF="92022" TYPE="GRAPHIC"Figure A-103) contains the following items: "Clear All"Clears all fields in the view.LBL="" HELPID=""Language PopupFILE="EVlang.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-104"Figure A-104 ID="28809"Expression View Language PopupThe Language popup (see IDREF="28809" TYPE="GRAPHIC"Figure A-104) contains three radio buttons, allowing you to select one of three languages for evaluation: C, C++ or Fortran. The Language popup is invoked by holding down the right mouse button while the cursor is in the Expression column.ID="AReference137"ID="AReference138"LBL="" HELPID=""Format PopupThe Format popup (see IDREF="88141" TYPE="GRAPHIC"Figure A-105) The Format menu is displayed by holding down the right mouse button in the Result column. ID="AReference139"ID="AReference140"FILE="AReference97.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-105"Figure A-105 ID="88141"Expression View Format Popup with SubmenusThe Format popup contains the following items: "Default"A radio button that sets the format to the default values."Value"Launches a submenu of radio buttons from which you can select a value of type Decimal, Unsigned, Octal, Hex, Float, Char, or String."Type"Launches a submenu of radio buttons from which you can select a type of Decimal, Octal, or Hex."Bit size"A radio button that sets the format to the bit size.ID="65348"LBL="" HELPID="FileBrowser"File BrowserThe File Browser displays a scrollable list of source files used by the current executable. Double-click a file in the list to load it directly into the source display area in Main View or Source View. The Search field lets you find files in the list quickly. FILE="f03fbrow.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-106"Figure A-106 File BrowserThe File Browser contains an Admin menu (described  in IDREF="43163" TYPE="TITLE""Admin Menu") and a Help menu (described in IDREF="25659" TYPE="TITLE""Help Menu"). In addition, the browser has a Search field.ID="23500"SStructureBrowserLBL="" HELPID=""tructure BrowserThe Structure Browser lets you examine data structures and the relationships of the data within them. It displays complex data structures as separate graphical objects, using arrows to indicate relationships. A typical Structure Browser example is shown in ID="AReference141"IDREF="88425" TYPE="GRAPHIC"Figure A-107 with the Config, Display, Node, and Format menus displayed. (For a tutorial example of the Structure Browser, see IDREF="13777" TYPE="TITLE""Examining Data".)FILE="AReference169.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-107"Figure A-107 ID="88425" Structure Browser With the Config, Display, Node, and Format MenusThe structure name is entered in the Expression field. It then appears as an object or set of objects in the display area in the lower portion of the window. Each structure has a header identifying the structure, color coded by data type. Below the header are two columns: the left displays the field name and the right displays the field's value. If the structures to be displayed exceed the size of the Structure Browser window, scroll bars appear. In addition to the Admin menu, Structure Browser provides four menus that are used to change the way the data displays. The menus are:ConfigID="AReference142"For saving and reusing type-specific formats and expressions. You can also set preferences regarding how objects of a given type are to be displayed.DisplayID="AReference143"Provides operations for all objects in the display area.NodeID="AReference144"Provides operations for selected objects in the display area only.FormatID="AReference145"Lets you change or reformat a specific value in the result column. It is a popup menu that is accessed by holding down the right mouse button while the cursor is over the result column.LBL="" HELPID=""Using the Overview Window to NavigateWorkShop provides the Overview window (from the "Show Overview" selection in the Display menu) as another way to navigate around the display area (see IDREF="25987" TYPE="GRAPHIC"Figure A-108). FILE="f07strov.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-108"Figure A-108 ID="25987" Structure Browser Overview WindowThe Overview window is a reduced-scale view of the requested structures. The structures are represented by solid rectangles color- coded by data type. The relative position of the currently visible area is represented by a transparent rectangle. This rectangle can be dragged (using the left mouse button) to change the display of the Structure Browser. Clicking the left mouse button in an area of the Overview window repositions the currently visible area.LBL="" HELPID=""Entering ExpressionsThe Structure Browser accepts any valid expression. If the result type is simple, a structure displays showing the type and value. If the result type is a pointer, it is automatically dereferenced until a non-pointer type is reached. If the result type is a structure or union, an object is displayed showing the structures' fields and their values. After the expression is entered, the Expression field clears. The Structure Browser can display unrelated structures at the same timename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'you simply enter new structures using the ID="AReference146"Expression field.The Expression field is also used to enter strings used in searches.LBL="" HELPID=""Working in the Structure Browser Display AreaWithin the display area, you select objects by clicking in the node headers. Shift-clicks add the selected object to the current selection. You can drag selected objects using the middle mouse button.ID="AReference147"Clicking the right button while the cursor is in the right column of an object displays the Format menu, used to change the display of a specific result (see IDREF="70721" TYPE="GRAPHIC"Figure A-109). You can set a default format or request that results be displayed by value, type, address, or size in bits.FILE="AReference171.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-109"Figure A-109 ID="70721" Structure Browser Format MenuHolding down the right button in the header of a Structure Browser object brings up the Node popup menu, which is the same as the Node Menu in the menu bar. It is used to change the way selected objects are displayed. When you left-click in the header of an object, it turns on the resizer, which lets you change the size of the object. Left-clicking the handle resizes; middle-clicking moves it. ID="AReference148"Graphical arrows show the pointer relationships among the displayed structures. If a pointer field is not visible in a structure, its arrow tail is displayed at the top or bottom of the scrolling area for fields. Otherwise, its tail is adjacent to its field.Double-clicking a value field (right column) for a pointer dereferences it, so that the data structure it points to is displayed.Double-clicking a member field (left column) puts the full expression for that member in the Expression field.LBL="" HELPID=""Structure Browser Display MenuThe Display menu controls the way structures appear in the display area of Structure Browser. The menu is shown in ID="AReference149"IDREF="95060" TYPE="GRAPHIC"Figure A-110.FILE="AReference172.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-110"Figure A-110 ID="95060" Structure Browser Display MenuThe Display menu provides the following selections:"Display" ID="AReference150"has two options:"Expression" displays the structure of the expression entered in the ID="AReference151"Expression field."Selection" displays the structure based on the text from the current selection.ID="AReference152""Arrange" ID="AReference153"rearranges the currently selected nodes. There are two options (see IDREF="47342" TYPE="GRAPHIC"Figure A-111): "Tree" arranges them into a tree-type formation, that is, the hierarchy descends from left to right and child structures are shown as branches to the right of the parent.ID="AReference154""Linked List" arranges them into a linked list formation, that is, horizontally.ID="AReference155"FILE="fig7-27snap.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-111"Figure A-111 ID="47342"Tree and Linked List Arrangements of Structures"Search" ID="AReference156"Lets you select structures containing the string specified in the Expression field. There are four options:"Name" selects structures whose names contain the specified string."Type" selects structures whose types contain the specified string."Field Name" selects structures that have a field whose name contains the specified string."Value" selects structures that have a field value containing the specified string."Update"ID="AReference157"Explicitly updates the displayed structures. This happens automatically in the current Structure Browser when the process stops. This can be used in an inactive Structure Browser to update it. It can also be used to update the display after changes have been made in other Debugger views."Show Overview"ID="AReference158"Brings up the Overview window."Clear All"ID="AReference159"Clears all structures from the display area.LBL="" HELPID=""Node MenuThe Node menu is shown in ID="AReference160"IDREF="74142" TYPE="GRAPHIC"Figure A-112.FILE="AReference191.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-112"Figure A-112 ID="74142" Structure Browser Node MenuThe Node menu consists of the following entries and applies to the currently selected objects:"State" ID="AReference161"Controls the display of nodes. There are three options:"Iconic" displays the node header only.ID="AReference162""Normal" uses the default chart display but hides those fields selected to be invisible. ID="AReference163""Detail" uses the default chart display and shows all fields. ID="AReference164""Geometry"ID="AReference165"Manages graphical objects in the display area. There are four options:"Minimize" sets the vertical size of an object to the default minimum number of fields. The initial default is four fields but can be changed through either the "Formatting" selection from the Node menu or the "Preferences..." selection from the Config menu.ID="AReference166""Maximize" displays the object as large vertically as necessary to fit all of the fields. ID="AReference167""Raise" raises the selected object(s) to the top of the display.ID="AReference168""Lower" lowers the selected object(s) to the bottom of the display."Select" ID="AReference169"Lets you select objects in various ways. There are six options:"Parents" selects all objects that have pointers pointing to a selected object."Children" selects all objects pointed to by any fields in a selected object."Ancestors" selects all objects pointed to a selected object or pointing to an object that has a descendant pointing to a selected object."Descendants" selects all objects pointed to by any fields in a selected object or pointed to by any children of a selected object."Family" selects all ancestors and descendants of a selected object."All" selects all objects."Formatting"Brings up the type formatting dialog for this type. See IDREF="69199" TYPE="TITLE""Formatting Fields.""Dereference Ptrs"ID="AReference170"Dereferences any pointers in selected objects."Pattern Layout"ID="AReference171"Uses the spatial relationship between selected structures connected by pointers to position all similarly related structures in the same way."Remove"ID="AReference172"Removes the selected object from the display.LBL="" HELPID=""ID="69199"Formatting FieldsID="AReference173"Each field in a data structure has certain display characteristics. These can be specified for all objects in the Structure Browser Preferences dialog box or for type-specific objects only in the Type Formatting dialog box. To display the Structure Browser Preferences dialog box, select "Preferences..." from the Config menu (see IDREF="41628" TYPE="GRAPHIC"Figure A-113). FILE="f07stprf.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-113"Figure A-113 ID="41628" Structure Browser Preferences Dialog BoxID="AReference174"The Structure Browser Preferences dialog box has the following fields:ID="AReference175"Default Structure Field CountSets the number of fields to be displayed initially.ID="AReference176"Default Structure WidthThe width in pixels of the object.ID="AReference177"Default Iconic WidthThe width in pixels of the object when it is in iconic form.ID="AReference178"Automatic Dereference LimitSets a limit on the number of structures that are automatically dereferenced.ID="AReference179"Dereference Ptrs By DefaultLets you toggle automatic dereferencing on and off.To bring up the Type Formatting dialog box, select the set of structures under consideration and select "Node Formatting" from the Node menu (see IDREF="43431" TYPE="GRAPHIC"Figure A-114).FILE="AReference193.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-114"Figure A-114 ID="43431" Type Formatting Dialog BoxID="AReference180"The Type Formatting dialog box has the following fields:ID="AReference181"Type NameDisplays the current data type.ID="AReference182"Default Field CountThe number of fields to be displayed initially for objects of that type.ID="AReference183"Default Structure WidthThe width in pixels of the object.ID="AReference184"Default Iconic WidthThe width in pixels of the object when it is in iconic form.ID="AReference185"Default StateBrings up a popup menu that lets you specify whether structures are first displayed as icons ("Iconic"), with the minimum number of fields displayed ("Normal") or with all fields displayed ("Detail").ID="AReference186"Type ColorProvides a submenu for color coding. It lets you select a color for the header and overview rectangles for objects of a given type.For structure and union types, the list box shows all the fields with their types. For each field, you can change the result format to one of the following:defaultdecimalunsignedoctalhexfloatcharstringtypedec addroct addrhex addrsize in BitsYou can also specify whether a field is visible in normal state, and if it is a pointer field, whether it should be automatically dereferenced.Once you specify the format for this type, you can apply it to any combination of the following through the toggle buttons in the bottom left portion of the window:selected instances all existing instancesany future instances of this typeID="AReference187"ID="40944"LBL="" HELPID="VariableBrowser"Variable BrowserThe Variable Browser lets you view and change the values of local variables and arguments at a specific point in a process. (Global variables can be viewed or changed using Expression View or the "Evaluate Expression" selection from the Data menu for one-shot evaluations.) In addition to providing the values, Variable Browser is useful for getting a quick list of the local variables in a scope without having to search for their names. A sample Variable Browser window with the Language and Format menus displayed is shown in ID="AReference188"ID="AReference189"ID="AReference190"IDREF="27065" TYPE="GRAPHIC"Figure A-115. (For a tutorial example of the Variable Browser see IDREF="13777" TYPE="TITLE""Examining Data".)Typically, you inspect variable valuesat a stop trapat a frame in a call stackas you step through a processNoteA useful technique is to set a trap at the entry to a function and inspect the values of the variables there. Some variables may be in an uninitialized state at that point. You can then step through the function and make sure that no uninitialized variables are used inadvertently.LBL="" HELPID=""Entering Variable ValuesThe Variable Browser lets you change the values of variables in the window. You simply enter the new value in the result column and press <Enter>. Thus, you can force new values into the process and see their effect.FILE="AReference159.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-115"Figure A-115 ID="27065"Variable Browser With Language and Format MenusLBL="" HELPID=""Changing Variable Column WidthsThe Variable Browser has a sash between columns that lets you adjust the relative widths of the Variable and Result columns (see IDREF="27065" TYPE="GRAPHIC"Figure A-115). For example, you may wish to adjust for short variable names and long result values.LBL="" HELPID=""ID="54889"Viewing Variable ChangesThe Debugger views that are involved with variables (that is, the Variable Browser and Expression View) have indicators that show when the variable has changed since the last breakpoint. If you click the indicator, you can view the previous value. The variable change indicators for a Variable Browser window are shown in IDREF="47526" TYPE="GRAPHIC"Figure A-116.FILE="AReference160.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-116"Figure A-116 ID="47526"Typical Variable Change IndicatorsLBL="" HELPID=""ID="49277"Machine-level Debugging WindowsThe Debugger offers three views useful in debugging at the machine level; the Disassembly View, Register View, and Memory View.LBL="" HELPID="DisassemblyView"Disassembly ViewThe Disassembly View of the Debugger lets you look at machine-level code rather than source-level code. A typical Disassembly View window appears in IDREF="34547" TYPE="GRAPHIC"Figure A-117, with the Disassemble menu displayed.FILE="AReference100.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-117"Figure A-117 ID="34547"Disassembly View With Disassemble Menu Displayed LBL="" HELPID=""Similarities With Main ViewAt the top of the window are the same process control buttons as those in Debugger Main View. They behave the same way except for ID="AReference191"Step Into and ID="AReference192"Step Over, which do machine-level instruction stepping instead of source-level. Remember that you select the number of steps by holding down the right mouse button over the Step Into and Step Over buttons. The menus are basically the same as in Main View except for the Disassemble menu. The PC menu selections "Continue To" and "Jump To" are based on machine-level instructions rather than source-level steps. The Config menu has a "Preferences..." selection that brings up a dialog box oriented to Disassembly View.ID="AReference193"ID="AReference194"ID="AReference195"You can set traps either by using the Traps menu or by clicking in the annotation column of the source display area that contains the disassembled code.LBL="" HELPID=""Disassemble MenuFILE="f08dismn.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-118"Figure A-118 ID="27955"Disassemble MenuThe Disassemble menu (see ID="AReference196"IDREF="27955" TYPE="GRAPHIC"Figure A-118) lets you display disassembled code. It contains the following items:"Address..."ID="AReference197"allows you to disassemble a specified number of lines, starting from a specified source line address (see IDREF="92802" TYPE="GRAPHIC"Figure A-119). FILE="f08disad.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-119"Figure A-119 ID="92802"Disassemble From Address Dialog Box"Function..."ID="AReference198"allows you to disassemble a specified number of lines, starting from the beginning address of a specified function name (see IDREF="63119" TYPE="GRAPHIC"Figure A-120). FILE="f08disfu.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-120"Figure A-120 ID="63119"Disassemble Function Dialog BoxID="AReference199""File..."ID="AReference200"allows you to disassemble a specified number of lines, starting from the address corresponding to a specified line number in a specified file (refer to IDREF="91612" TYPE="GRAPHIC"Figure A-121). If you have a current selection in Main View or Source View, its file and cursor position are used as the default filename and line number, respectively. FILE="f08disfi.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-121"Figure A-121 ID="91612"Disassemble File Dialog BoxID="AReference201"LBL="" HELPID=""Disassembly View PreferencesID="AReference202"Selecting "Preferences..." from the Config menu brings up the Disassembly View Preferences dialog box (shown in IDREF="73500" TYPE="GRAPHIC"Figure A-122) so that you can change the global preferences.FILE="AReference106.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-122"Figure A-122 ID="73500"Disassembly View Preferences Dialog Box with Format Popup Menu The dialog box provides you with these options:Number of instructions to disassembleID="AReference203"controls the default number of disassembly lines shown when the process stops. This number appears in the dialog boxes selected from the Disassemble menu (see IDREF="92802" TYPE="GRAPHIC"Figure A-119, IDREF="63119" TYPE="GRAPHIC"Figure A-120, and IDREF="91612" TYPE="GRAPHIC"Figure A-121). The default is all instructions, indicating that the entire function will be disassembled.Minimum lines around current instructionID="AReference204"controls the display of the disassembled code, enabling you to view at least the specified number of instructions before and after the current instruction.Register name display formatID="AReference205"controls how register names are displayed. The available modes are "Hardware," "Compiler," and "Assembler." The Display Options selections control what information is shown in each disassembled line.Show embedded source annotationID="AReference206"turns on interleaved source lines in the appropriate positions. Show source file and line numberID="AReference207"displays the filename and file position along with each machine instruction. Show function name and line numberdisplays the function name and file position along with each machine instruction. Show machine addressID="AReference208"displays the memory address of each machine instruction.Show instruction valueID="AReference209"displays the instruction word along with each machine instruction. Show jal targets numericallyID="AReference210"controls whether the target address of a jal instruction is displayed as a hex address or symbolic label. LBL="" HELPID="RegisterView"ID="32261"Register ViewRegister View lets you examine and modify register values. You bring it up by selecting "Register View" from the Views menu in Main View. ID="AReference211"IDREF="21335" TYPE="GRAPHIC"Figure A-123 shows a typical Register View window that has been resized to show all available registers.Register View displays each register with its current value. A question mark (?) displayed immediately before a register value signifies that the value is suspect; it may not be valid for the current frame. This can occur if a register is not saved across a function call. A colored marker indicates that a register value has changed since the last time the process stopped. FILE="AReference107.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-123"Figure A-123 ID="21335"Register View LBL="" HELPID=""Register View WindowThe major features of the Register View window are:ID="AReference212"Current register fieldidentifies the currently selected register. You can switch to a different register by entering its name (either by hardware name or by alias) in this field and pressing <Enter>. You can also switch registers by clicking on the new register in the display area.Current register value fieldshows the contents of the selected register. You can assign a new value to a register by entering either a literal or an expression into the Value field. You then click on the Modify button to change the value or press <Enter>.Register display areashows the registers organized into four groups: general, special, floating, and double. Note that the general registers are identified by both their hardware and software names. Double registers have a one-to-two correspondence with the floating registers.NoteThe special registers p0, p1, and p2 are empty in the figure. These are used for instrumentation and display values only when instrumentation has taken place. LBL="" HELPID=""Changing the Register View DisplayThe "Preferences..." selection in the Config menu lets you change the Register View display. It brings up the Register View Preferences dialog box (see IDREF="70840" TYPE="GRAPHIC"Figure A-124). The Register Display toggle buttons let you specify which types of registers are to be displayed by default.FILE="AReference108.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-124"Figure A-124 ID="70840"Register View Preferences Dialog BoxID="AReference213"The ID="AReference214"Register Formatting area lets you select formats for any of the registers. You have a choice of "default," "decimal," "octal," or "hex" format. The default fields in the top row let you change the defaults for the four major types, which are set as follows:general registersname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'hexadecimalspecial registersname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'hexadecimalfloat registersname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'floating pointdouble registersname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'floating pointThe rows in the register formatting area let you change the modes for the individual registers.LBL="" HELPID="MemoryView"ID="54884"Memory ViewMemory View lets you examine and modify memory. A typical Memory View window appears in ID="AReference215"IDREF="47506" TYPE="GRAPHIC"Figure A-125.FILE="AReference109.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-125"Figure A-125 ID="47506"Memory View With Mode Menu Displayed LBL="" HELPID=""Viewing a Portion of MemoryTo view a portion of memory, enter the beginning memory location in the Address field. You can enter the literal value or an expression that evaluates to an integer address. These address specifications must be in the language of the current process as indicated by the call stack frame. For example, you can enter 0x7fff4000+4 as the memory address when stopped in a C function or enter $7fff4000+4 as the equivalent for a Fortran routine. Press <Enter> while the cursor is in the field or click the View button to display the contents of that location and the subsequent locations in the display area. This also displays the contents of the first address in the Value field where it can be modified.The memory display area shows the contents of individual byte addresses. The column at the left of the display shows the first address in the row. The contents at that address are shown immediately to its right, followed by the contents of the next seven byte locations. If you enlarge the Memory View window, you can see additional rows of memory. LBL="" HELPID=""Changing the Contents of a Memory LocationTo change the contents of a memory location, you select the address to be changed, either by direct entry or by clicking on the byte value in the display area. You can enter a single value or a sequence of hex byte values separated by spaces (for example, 00 3a 07 b2) in the Value field. You can also enter a quoted string to change a consecutive range of values to the ASCII values of that string. Pressing <Enter> while the cursor is in the Value field or clicking the Modify button substitutes the new value(s) starting at the specified location. LBL="" HELPID=""Changing the Memory Display FormatThe Mode menu lets you change the format of the value field or byte locations to either decimal, octal, hex, or ASCII.ID="AReference216"LBL="" HELPID=""Moving around the Memory View Display AreaThe four control buttons at the upper right of the window help you move around the display area. These buttons are:Upfor moving the displayed bytes up a single row.Downfor moving the displayed bytes down a single row. Page Upfor moving the displayed bytes upward by as many rows as are currently displayed.Page Downfor moving the displayed bytes downward by as many rows as are currently displayed.LBL="" HELPID=""ID="69417"Multiple Process Debugging WindowsWorkShop supports performance analysis and debugging of multiprocess applications, including processes spawned either with fork or sproc. Multiprocess debugging is supported primarily through the Multiprocess View.LBL="" HELPID="MultiprocessView"Multiprocess ViewSelect "Multiprocess View" from the Admin menu to bring up Multiprocess View. Main View is attached to the parent process. IDREF="50758" TYPE="GRAPHIC"Figure A-126 shows a typical Multiprocess View with Config and Process menus displayed.FILE="AReference110.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-126"Figure A-126 ID="50758"Multiprocess View with Config and Process Menus DisplayedTo open a Main View (or other debugging views) for another process, double-click the desired process in Multiprocess View. A separate Main View window displays the selected process, and you can select any debugging views desired. If a set of views exists for that process, the views are raised to the foreground. To reuse views already displayed, select "Switch Process..." from the Admin menu in Main View. (If a process is currently highlighted in Multiprocess View, its id is entered automatically in the Process id: field in the Switch Process dialog box.)LBL="" HELPID=""Viewing Process StatusWhen Multiprocess View comes up, it lists the status of all processes in the process group. This information includes: PID:shows the process identifier (id).PPID:lists the parent process ids. Notice in IDREF="50758" TYPE="GRAPHIC"Figure A-126 that the first process PID#7748 is the parent process of the second.State:represents the state of the process: stopped, running, or created, which appears just prior to running. Terminated processes are not displayed.Name:identifies the process by filename.Function/PC:indicates the current function and program counter (PC) for any stopped processes.LBL="" HELPID=""Multiprocess Control ButtonsMultiprocess View uses the same control buttons as MainView with two exceptions. The buttons are applied to all processes as a group. There is no separate Run button. Using a control button in Multiprocess View has the same effect as clicking the button in each process's Main View window. The buttons are:Continueresumes program execution after a halt and continues until a stop trap or other event stops execution.Stopstops execution of all processes. When program execution stops, the current source line of each process is highlighted in its Main View, if one is active, and annotated with an arrow indicating the PC.Step Intosteps to the next source line and into function calls. To step a specific number of lines, hold down the right mouse button over the Step Into button. A popup menu displays that lets you select one of the fixed values or a specified number of steps.Step Oversteps to the next source line and over function calls. To step a specific number of lines, hold down the right button over the Step Over button. A popup menu displays that lets you select one of the fixed values or a specified number of steps.Returnexecutes the remaining instructions in the current function. Program execution stops upon return from that procedure.Samplecollects performance data for each process (if performance data collection is enabled).Killterminates all processes in the group.LBL="" HELPID=""Multiprocess TrapsAs discussed in IDREF="25908" TYPE="TITLE"Chapter 4, "Setting Traps," the trap qualifiers [all] and [pgrp] are used in multiprocess analysis. The [all] entry stops or samples all processes when a trap fires. The [pgrp] entry sets the trap in all processes within the process group containing the trap location. The qualifiers can be entered by default by the "Group Trap Default" and "Stop All Default" selections in the Traps menu in Trap Manager. Note that the Sample button always samples all processes.LBL="" HELPID=""Adding and Removing ProcessesFILE="f10prcmn.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-127"Figure A-127 ID="88868"Process Menu in Multiprocess ViewThe Process menu lets you manually add or remove a process from the process group (see IDREF="88868" TYPE="GRAPHIC"Figure A-127). To remove a process, click the process and select "Remove" from the Process menu. Note that a process in a sproc share group cannot be removed from the process group.To add a process, select "Add..." The dialog box shown in IDREF="42348" TYPE="GRAPHIC"Figure A-128 displays. Enter the new process id and click OK.FILE="f10addpr.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-128"Figure A-128 ID="42348"Add Process Dialog BoxLBL="" HELPID=""Multiprocess PreferencesThe "Preferences..." option in the Config menu brings up the Preferences dialog box. It lets you control when processes are added to the group, and it specifies their behavior (see IDREF="37471" TYPE="GRAPHIC"Figure A-129).FILE="f10prefs.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-129"Figure A-129 ID="37471"Multiprocess View Preferences Dialog BoxThe Multiprocess View preference options are:Attach to forked processesattaches new processes spawned by the fork command to the group automatically. (Note that processes spawned by sproc are always attached.)Copy traps to forked processescopies traps you have set in the parent process to new forked processes automatically. If you create parent traps with Trap Manager and specify pgrp, then the children inherit these traps automatically, regardless of the state of this flag.Copy traps to sproc'd processescopies traps you have set in the parent process to new sproc'd processes automatically. As in the previous option, if you create parent traps with the Trap Manager and specify pgrp, the children inherit these traps automatically, whether this flag is set or not.Resume parent after forkrestarts the parent process automatically when a child is forked.Resume child after attach on forkrestarts the new forked process automatically when it is attached. If this option is left off, a new process will stop as soon as it is attached.Resume parent after sprocrestarts the parent process automatically when a child is sproc'd.Resume child after attach on sprocrestarts the new sproc'd process automatically when it is attached. If this option is left off, a new process will stop as soon as it is attached.LBL="" HELPID=""ID="12535"Fix+Continue WindowsThe Fix and Continue GUI affects several WorkShop windows and provides three more. The Debugger and Source View access the Fix and Continue utility from the menu bar. The results of running redefined code are displayed in the Debugger Execution View. Special line numbers (decimal notation) applied to redefined functions appear in several WorkShop views (refer to ID="AReference217"IDREF="11461" TYPE="TITLE""Changes to Debugger Views"). Fix and Continue comes with three windows devoted entirely to Fix and Continue: Status, Message, and Build Environment. This section describes Fix and Continue menu selections and these windows.The Fix and Continue menu is available from the Debugger Main View menu bar, as shown in IDREF="22899" TYPE="GRAPHIC"Figure A-130. The menu selections operate on the selected function or on the file shown in the source view. The Fix and Continue menu is also available from Source View and from the Fix and Continue Status window.FILE="AReference142.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-130"Figure A-130 ID="22899"Fix+Continue Menu SelectionsLBL="" HELPID="Fix+ContinueStatusWindow"ID="21697"Fix+Continue Status WindowThis section describes the Fix+Continue Status window (see ID="AReference218"IDREF="89566" TYPE="GRAPHIC"Figure A-131). The Status window provides you with a summary of the modifications that you have made during your session. It also allows you quick access to your modified functions, and a somewhat expanded Fix+Continue menu. FILE="AReference143.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-131"Figure A-131 ID="89566"Fix+Continue Status WindowThe function ID number, status, name, and filename are displayed in the Status window. Double-clicking a line item in the status window brings up the corresponding source in the Debugger main window. The menus and submenus that provide you with extra functionality through the Status window (see IDREF="75615" TYPE="GRAPHIC"Figure A-132) are described below.FILE="AReference144.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-132"Figure A-132 ID="75615"Fix+Continue Status Window MenusLBL="" HELPID=""Admin MenuFILE="statAdmin.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-133"Figure A-133 ID="13655"Status Window Admin MenuThe Admin menu (see ID="AReference219"IDREF="13655" TYPE="GRAPHIC"Figure A-133) contains an option for closing the window."Close"Closes the Status window.LBL="" HELPID=""View MenuFILE="statView.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-134"Figure A-134 ID="40079"Status Window View MenuThe View menu (see ID="AReference220"IDREF="40079" TYPE="GRAPHIC"Figure A-134) contains options for sorting the information in the window, and displaying filenames."Sort Status View"Sorts the information in the status view according to the field currently selected. "Show Long Filenames"A toggle that allows you to show the absolute (long) pathnames, relative pathnames, or base names.LBL="" HELPID=""Fix+Continue MenuFILE="statFCmenu.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-135"Figure A-135 ID="42000"Status Window Fix+Continue MenuThe Fix+Continue menu (see ID="AReference221"IDREF="42000" TYPE="GRAPHIC"Figure A-135) that is available from the Status view is somewhat different from that available through the Debugger main view. It contains a number of options and submenus, which are all described below. These options and submenus are active on the function that you select in the Source view. You can select a function by clicking on it."External Editor"Allows you to edit with an external editor such as vi, rather than the Debugger's default editor."Parse And Load"Parses your modified function and loads it for execution. You can execute the modified function by clicking on the Run or Continue buttons in the Debugger main view.Update All Files..."Launches the "Save File+Fixes As..." dialog (see ID="AReference222"IDREF="76936" TYPE="GRAPHIC"Figure A-25), which allows you to update the current session, saving all the modified functions to the appropriate files."Show Difference" submenu (see IDREF="99121" TYPE="GRAPHIC"Figure A-136)Allows FILE="statFCshowd.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-136"Figure A-136 ID="99121"Show Difference Submenu
you to show the difference between the original source and your modified code. You can show the difference in the code in one of the two following ways:"For Function" shows the differences for the current function only."For File" shows the differences for the entire file that contains the current function."Enable" submenu (see IDREF="52877" TYPE="GRAPHIC"Figure A-137)Allows FILE="statFCdel.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-137"Figure A-137 ID="52877"Enable Submenu
you to enable the changes in your modified code in one of the three following ways:"Function" enables the changes in the current function."Functions in File" enables the changes to the current function in its own file."All Functions" enables the changes to all functions in the modified code."Disable" submenu (see IDREF="52877" TYPE="GRAPHIC"Figure A-137)Has the same menu choices as the "Enable" submenu, but disables rather than enables."Save" submenu (see IDREF="80362" TYPE="GRAPHIC"Figure A-138)Allows FILE="statFCsave.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-138"Figure A-138 ID="80362"Save Submenu
you to save your code changes to a file. You can save the changes in one of the three FILE="FCsaveFunc.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-139"Figure A-139 ID="35936"File Dialog
 following ways:"Function..."  launches the File dialog (see IDREF="35936" TYPE="GRAPHIC"Figure A-139), allowing you to save only the current function to a file."File..." launches the "Save File+Fixes As..." popup window (see IDREF="76936" TYPE="GRAPHIC"Figure A-25), allowing you to save the entire file that contains the current function."Delete" submenu (see IDREF="52877" TYPE="GRAPHIC"Figure A-137)has the same menu choices as the "Enable" submenu, but deletes rather than enables."Show" submenu (see IDREF="46789" TYPE="GRAPHIC"Figure A-140)Allows FILE="statFCshow.gif" POSITION="MARGIN" SCALE="FALSE"LBL="A-140"Figure A-140 ID="46789"Show Submenu
you to launch any of the following three different Fix and Continue windows:"Message Window" launches a Message window for the selected function. See IDREF="22020" TYPE="TITLE""Fix+Continue Message Window" for more details."Build Env for File" launches a Build Environment window for the file shown in the Source View. See IDREF="65193" TYPE="TITLE""Fix+Continue Build Environment Window" for more details on the Build Environment window."Default Build Env" launches the Build Environment window to show the options that are to be used in cases where they could not be obtained from the target. See IDREF="65193" TYPE="TITLE""Fix+Continue Build Environment Window" for details on the Build Environment window.LBL="" HELPID="Fix+ContinueMessageWindow"ID="22020"Fix+Continue Message WindowThe Fix+Continue Message window (see ID="AReference223"IDREF="90493" TYPE="GRAPHIC"Figure A-141) contains a list of any errors and other system messages that pertain to your source modifications, parses, and attempts to run your modified source. FILE="AReference145.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-141"Figure A-141 ID="90493"Fix+Continue Message WindowYou can highlight the source line where the error occurred by double-clicking the appropriate line in the Message window. The window contains the following buttons:ID="AReference224"ClearClears all the parsing errors and warnings.NextPuts a tick mark on the next unticked error warning entry in the parse messages. It displays the corresponding file and line in the Source view, highlighting it according to the type of error or warning. Next doesn't function after all the entries in the messages are ticked.RescanErases all the ticks, so that you can rescan all the error warnings from the beginning.The added functionality available through the Message window's Admin and View menus is described below.LBL="" HELPID=""Admin MenuThe Admin menu allows you to perform either of the following two operations: ID="AReference225""Clear All"Clears all messages in the Message window."Close"Closes the window.LBL="" HELPID=""View MenuThe View menu allows you to set any of the following three toggles:ID="AReference226""Show Warnings"Causes compile warnings to be displayed in the parse errors list."Append Parse Messages"Causes parse messages to be appended to the parse errors list."Append Load Messages"Causes load messages to be appended to the load errors list.LBL="" HELPID="Fix+ContinueBuildEnvironmentWindow"ID="65193"Fix+Continue Build Environment WindowThis section describes the Fix+Continue Build Environment window (see ID="AReference227"IDREF="85628" TYPE="GRAPHIC"Figure A-142). The Build Environment window provides you with the build information for your source code in your current environment. It displays the command that was used to build your executable and the name of the file that contains the function that you currently have selected.FILE="AReference146.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-142"Figure A-142 ID="85628"Fix+Continue Build Environment WindowThe compiler and associated flags that were used to compile the file are normally gathered from the target. You can use the Build Environment window to make any changes to these flags.The Build Environment window allows you to select your build environment setting through the "Build Environment Setting" toggle, which contains the two options described below:"Default"Sets the build environment to default that is displayed in the Build Environment window."File Specific"Sets the build environment to that of the file that contains the currently selected function. You can change the file by clicking the Select File button, which launches the File dialog (see IDREF="35936" TYPE="GRAPHIC"Figure A-139).The Build Environment window also contains the following buttons:Select FileLaunches the File dialog and allows you to select a file from which to set the build environment.ClearClears the window.SetSets the build environment to what is displayed in the window.UnsetUnsets the build environment.DoneDismisses the window.LBL="" HELPID=""ID="11461"Changes to Debugger ViewsWhen you use Fix and Continue, Debugger views change to show redefined functions or stopped lines containing redefined functions.ID="AReference228"LBL="" HELPID=""ID="38887"Main ViewWhen you open the Debugger after installing Fix and Continue, you'll notice several changes to the environment. All Fix and Continue functions are available through the Fix+Continue menu. See ID="AReference229"IDREF="48803" TYPE="GRAPHIC"Figure A-143 for details.FILE="AReference147.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-143"Figure A-143 ID="48803"Debugger Main ViewYou select Fix and Continue commands from the Fix+Continue menu or enter them at the Debugger command line. The source code status is Read Only. Color coding shows the differences between editable code, enabled redefinitions, disabled definitions, and breakpoints. Line numbers in redefined functions have decimal notation that is used for every reference to the line number. The integer portion of the decimal is the same as the first line of the function. This ensures that compiled source code line numbers remain unchanged.LBL="" HELPID=""Command-Line InterfaceThe Debugger command-line interface accepts Fix and Continue commands and reports status involving redefined functions or files. ID="AReference230"IDREF="42522" TYPE="GRAPHIC"Figure A-144 shows a function successfully redefined using the command line. Change id 1 was previously redefined and assigned the number 1.FILE="AReference148.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-144"Figure A-144 ID="42522"Command-Line Interface With Redefined FunctionLBL="" HELPID=""Call StackThe Call Stack View recognizes redefined functions. It uses the decimal notation for line numbers, as shown in ID="AReference231"IDREF="27778" TYPE="GRAPHIC"Figure A-145.FILE="AReference149.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-145"Figure A-145 ID="27778"Call Stack LBL="" HELPID=""Trap ManagerThe Trap Manager recognizes redefined functions. It uses the decimal notation for line numbers, as shown in ID="AReference232"IDREF="71288" TYPE="GRAPHIC"Figure A-146.FILE="AReference150.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-146"Figure A-146 ID="71288"Trap Manager With Redefined FunctionLBL="" HELPID=""ID="76970"Debugger Command LineID="AReference233"To use the Debugger commands, which are entered at the command line at the bottom of Main View (see IDREF="62188" TYPE="GRAPHIC"Figure A-1), you should be familiar with dbxID="AReference234" commands. For more information, refer to the dbx Reference Manual. The syntax for the debugging commands is as follows:add_source {"filename":line_number}Prompts you to add source code lines (for example, add_source "fmain.c":15.2). line_number must be within the body of a function. Entering a period (.) specifies the end of your input. The source lines you provide are added after the specified line. This command returns an ID existing or new, depending on whether the function affected has already been changed or not. The resulting new definition of the function is executed on its entry next time. See also delete_source, replace_source.ID="AReference235"alias [shortform command]Lists all aliases without arguments. With arguments, it assigns command to shortform.ID="AReference236"assign expression1=expression2Assigns expression1 to expression2.ID="AReference237"attach pidattaches to specified process ID pid.call function_name [ID="AReference238"argument, ...]Executes the specified function with any arguments supplied.catch [ID="AReference239"signal_name | all]With no arguments, lists signals to be trapped. If a signal is specified, it's added to the list. If all is specified, it traps all signals. clear [all | ID="AReference240"source_line]Clears breakpoints. The all option clears all breakpoints. The source_line option clears the breakpoint at the specified source line.clearbufferID="AReference241"Clears the currently displayed lines.clearcallsID="AReference242"Cancels pending interactive function calls.cont in ID="AReference243"function_nameContinues execution from the current line to the entry to the specified function.cont to ID="AReference244"line_numberContinues execution from the current line until the specified line.continueID="AReference245"Continues executing a program after a breakpoint. Note that you can c and cont as aliases for continue.continue [ID="AReference246"signal]Sends specified signal and continues executing a program after a breakpoint.corefile [ID="AReference247"filename]With no arguments, reports whether data referencing commands reference a core file. If so, displays the current core file. With filename provided, specifies core file to be debugged.delete ID="AReference248"displaynumber [,displaynumber, ...]Deletes the specified expression from the display list.delete allID="AReference249"deletes all traps.delete_changes {func_spec | -all | {-file filename}}Undoes the changes corresponding to the selected functions (for example, delete_changes getNumbers -file fmain.c). Once deleted, you won't be able to use the IDs again, since the IDs associated with the selected functions are released. The default is -all. See also save_changes.delete_source {"filename":line_number[,line_number]}Deletes the given line(s) if line_number or ,line_number (range) is within the body of a function. An example is: delete_source "fmain.c":8.6,8.7. This command eturns an ID existing or new, depending on whether the function affected has already been changed or not. The resulting new definition of the function is executed on its entry next time.delete ID="AReference250"trap_number [,trap_number, ...]Deletes the specified breakpoint from the status list.ID="AReference251"detachDetaches from the current process.disable allID="AReference252"Deactivates all inactive traps.disable_changes {func_spec | -all | {-file filename}}Undoes changes specified for the selected functions (for example, disable_changes getNumbers -file fmain.c. Nothing happens if the selected function is already disabled. The compiled definition of the function is executed on its next entry. You can invoke this command when the process is stopped or on a running process when a function entry breakpoint is set. disable ID="AReference253"trap_number [,trap_number, ...]Deactivates a trap set by stop command.display [ID="AReference254"expression, ...]With expression, adds expression to the list of expressions displayed whenever the process stops. With no arguments, lists all expressions on the display list. down [ID="AReference255"expression]Moves down the specified number of frames in the call stack. down moves in the direction of the called function.ID="AReference256"dumpPrints local variable values.enable allID="AReference257"Reactivates all inactive traps.enable_changes {func_spec | -all | {-file filename}}Redoes changes specified for the selected functions (for example, enable_changes getNumbers -file fmain.c. Nothing happens if the selected function is already enabled. The latest accepted definition of the function is redefined on its next entry. You can invoke this command when the process is stopped or on a running process when a function entry breakpoint is set. enable ID="AReference258"trap_number [,trap_number, ...]Reactivates a disabled stop trap.expressionID="AReference259"/[count] [format] or expression,[count] /[format] Prints the contents of the memory address specified by expression, according to the specified format. count represents the number of formatted items. The format options are:d prints a short word in decimalD prints a long word in decimalo prints a short word in octalO prints a long word in octalx prints a short word in hexadecimalX prints a long word in hexadecimalb prints a byte in octalc prints a byte as a characters prints a string of characters that ends in a null bytef prints a single-precision real numberg prints a double-precision real number file [ID="AReference260"filename]Displays the name of the current or specified file (filename). If a file is specified, it becomes the current file. func [ID="AReference261"func_name]Moves to the source code corresponding to the specified frame in the call stack or to the function in the executable if not on the stack.givenfile [ID="AReference262"filename]With no arguments, displays name of current object file. With filename, specifies object file to be debugged.ID="AReference263"goto linenumberGoes to the specified line number.ignore [ID="AReference264"signal_name | all]With no arguments, lists those signals not to be trapped. If a signal is specified, this command removes it from the list of signals to be trapped. If all is specified, ignores all signals.kill [ID="AReference265"pid]Kills the specified process currently controlled by the Debugger.list [[ID="AReference266"expression [,expression]] | [function_name]]Lists the specified number (expression) of lines. The default is 10 lines. You can optionally specify a function where the list is to take place.list_changes [func_spec | -all | {-file filename}]Lists one or more lines using the following syntax:change_id isEnabled filename function_specFor example:4 enabled foo.c foo
8 disabled A.c++ A::bingoThe default is list_changes -all. next [ID="AReference267"INT]Steps over the specified number of source instructions. This command does not step into procedures. The default is one instruction.nexti [ID="AReference268"INT]Steps over the specified number of machine instructions. This command does not step into procedures. The default is one line.print ID="AReference269"expression [,expression, ...]Prints the value of the specified expression(s). If the expression is a character pointer or array, both the string and address print.printd ID="AReference270"expression [,expression, ...]Prints the value of the specified expression(s) in decimal format. You can use pd as an alias.printo ID="AReference271"expression [,expression, ...]Prints the value of the specified expression(s) in octal format. You can use po as an alias.ID="AReference272"printregsPrints the contents of the registers.printx ID="AReference273"expression [,expression, ...]Prints the value of the specified expression(s) in hexadecimal format. You can use px as an alias.pwdID="AReference274"Sisplays the current directory.quitID="AReference275"Exits the debugging session.redefine func_spec[-edit |{ -read filename[line_number,line_number]}]Specifies a new body for a function. The new definition is checked, and errors (if any) are printed. The new function body is redefined on the next function entry. Breakpoints (if set) on the old definition are put on the new definition based on their relative line number position from the beginning of the function definition. (Note that some breakpoints may not make it to the new definition.) You can invoke this command when the process is stopped or on a running process when a function entry breakpoint is set. There are three ways to provide a new definition:-edit pops up an editor of your choice containing the current definition of the function. The specification of the new definition is complete when you exit the editor. You may not leave the editor open. IDREF="92624" TYPE="GRAPHIC"Figure A-147 shows the vi editor.FILE="AReference151.gif" POSITION="INLINE" SCALE="FALSE"LBL="A-147"Figure A-147 ID="92624"Editing a Function in the vi Editor-read takes the contents of the file specified (within the line numbers if given) as the new function definition.No option allows you to type in replacement code from the next line. A period in the first column on a fresh line terminates the definition. For example:redefine getNums"/usr/fmain.c":8.1> {"/usr/fmain.c":8.2> printf("In getNums.\n");"/usr/fmain.c":8.3> }"/usr/fmain.c":8.4> .You can use a combination of characters (yet to be determined) to open an editor of your choice containing the lines typed. The specification of the new definition is complete when you exit the editor. replace_source {"filename":line_number[,line_number]}Prompts you to type in replacement source if line_number or ,line_number (range) is within the body of a function. The source lines you provide replace the specified line(s). An example is replace_source "fmain.c":12. This command returns an existing or new id depending on whether the function affected has already been changed or not. The resulting new definition of the function is executed on its entry next time. See also add_source and delete_source.rerunID="AReference276"Runs the program again using the same arguments.returnID="AReference277"Continues executing the current procedure and returns to the next sequential line in the calling function.runID="AReference278"Runs the program.runtime_check func_spec [-options key [key,...]]Enables all run-time checking options by default. If -options is specified then run-time checking is restricted to the keys. The result of the checks selected will be printed when the specified function is entered next time. You can invoke this command when the process is stopped or on a running process where a break point is set at function entry.key = [[+|-] runtime_check option key]For example:A unique identifier (key) is returned whenever you specify a function as an argument for runtime_check. save_changes {func_spec | {-file filename}} [-[w|a]]filename_to_saveSaves (enabled or disabled) function redefinitions or an entire file to a separate file (filename_to_save). An example of saving a function definition is the following:save_changes getNumbers getNumbersFuncIf you specify the -file option, then before saving to filename_to_save, all function changes are applied to the compiled source of the file (with the condition that the file has had only its functions redefined, and has not been edited since the last build). An example of saving an entire file is the following:save_changes -file fmain.c fmain.c-w replaces the filename_to_save. -a appends to the file_to_save. An example of adding a function to a file is the following:save_changes getNumbers -a newFuncsSee also delete_changes.setbuildenv ["filename"] compiler-flag-listOverrides default build environment flags (compiler options). Without filename, the flags are passed along with -c -g flags to the compiler for any function in any file except those set separately with setbuildenv. An example is the following:setbuildenv -DnameA -IdirIf filename is given, this command sets separate flags specifically for that file. For example, consider the following: 
setbuildenv "fermat.c" -DnameB -IanotherdirSee also unsetbuildenv.ID="AReference279"sh [shell_command]Call a shell if no arguments; otherwise, executes the specified shell command.showbuildenv ["filename"]Lists all the build environment flags set so far. showbuildenv"filename" lists any build environment specs set separately with setbuildenv"filename".show_changes [func_spec | -all | {-file filename}]Prints the code of all enabled redefinitions of the specified function(s). The default is show_changes -all. See also enable_changes and disable_changes.show_diff {func_spec | {-file filename}}Launches a xdiff comparing the compiled source and its latest redefinition for the specified function. If -filefilename is specified, xdiff shows the difference between the compiled file and the file with all redefinitions applied to the compiled source of the file (with the condition that the file has had only its functions redefined, and has not been edited since the last build). ID="AReference280"source filenameExecutes commands in the specified file.statusID="AReference281"Displays a list of currently set breakpoints and traces.step [ID="AReference282"INT]Steps the specified number of source instructions. This command steps into procedures. The default is one instruction.stepi [ID="AReference283"INT]Steps the specified number of machine instructions. This command steps into procedures. The default is one line.stop at [ID="AReference284"filename:] line_number [if expression]Traps at the specified line in the specified file. If the if option is used, the trap fires only if expression is true. stop in [ID="AReference285"filename:] function_name [if expression]Traps at the entry to the specified function. If the if option is used, then the trap fires only if expression is true. If the filename is given, the function is assumed to be in that file's scope.syscall catch | ignore [call | return] \ID="AReference286"[sys_call_name | all]The catch option adds a system call to the list of system calls to be trapped. The ignore option removes a system call from the system call trap list. The call option specifies the entry to the system call and return signifies the return from the call.trace [ID="AReference287"variable] at [["filename":] \[line_number | function_name] \[if expression]]Traces the specified variable. You can specify a file and/or test condition. You can also specify a line number or a function where the trace is to take place.ID="AReference288"unalias aliasnameCancels the alias specified as aliasname.undisplay [ID="AReference289"displaynumber, ...]Stops display of expression with specified displaynumber when the process stops. Removes the expression from the display list.unsetbuildenv ["filename"]Disregards the default build environment flags if specified earlier. For all functions in files that don't have an overriding build environment, unsetbuildenv passes only the -c and -g flags.If filename is given, this command disregards the build environment flags specified for the file earlier. Further redefinition of the functions in the file use the default build environment flags, if set. See also setbuildenv.up [ID="AReference290"expression]Moves up the specified number of frames in the call stack. up moves in the direction of the caller.use [ID="AReference291"path]uses the specified path to search for source files.whatis ID="AReference292"identifierDisplays all the qualifications of the specified variable.when at [ID="AReference293"filename:] line_number {command [; command ...]}Stops the process and performs other Debugger commands when the process reaches a specified line number. when in [ID="AReference294"filename:] function_name {command [; command ...]}Stops the process and performs other Debugger commands at entry to function. If the filename is given, the function is assumed to be in that file's scope.which ID="AReference295"identifierDisplays the qualification of the specified variable.whereID="AReference296"Performs a stack trace.LBL="B"ID="50420"Using the Build ManagerWorkShop lets you compile software without leaving the WorkShop environment. Thus, you can look for problems using the WorkShop analysis tools (Static Analyzer, Debugger, and Performance Analyzer), make changes to the source, suspend your testing, and run a compile. WorkShop provides two tools to help you compile:ID="BBuild1"IDREF="20352" TYPE="TITLE""Build View"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for compiling, viewing compile error lists, and accessing the code containing the errors in Source View (the CASEVision editor) or an editor of your choice. Build View helps you find files containing compile errors so that you can quickly fix them, recompile, and resume testing. IDREF="20095" TYPE="TITLE""Build Analyzer"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for viewing build dependencies and recompilation requirements and accessing source files. Build View uses the UNIX“make facility as its default build software. Although cvmake can be set up to run any program instead of make (for example, gnumake), cvbuild will only parse and display standard makefiles (in particular, it does not understand gnu make constructs).LBL="" HELPID="BuildView"ID="20352"Build ViewYou can access Build View from the WorkShop analysis tools, from a command line (by typing ID="BBuild2"cvmake), or from Build Analyzer (see next section). To access Build View from WorkShop, select "Recompile" from the Source menu in the Main View window in the Debugger or from the File menu in Source View (for more information on Main View and Source View, refer to IDREF="40971" TYPE="TITLE"Chapter 1, "Getting Started with the WorkShop Debugger"). Selecting "Recompile" detaches the current executable from the WorkShop analysis tools and displays Build View. You can edit the Directory and Target(s) fields as needed and click Build to compile. If the source compiles successfully, the new executable is reattached when you reenter the WorkShop analysis tools.The Build View window is shown in IDREF="78913" TYPE="GRAPHIC"Figure B-1 with its Admin menu.FILE="BBuild.gif" POSITION="INLINE" SCALE="FALSE"LBL="B-1"Figure B-1 ID="78913"Build View Window With Admin Menu DisplayedThe Build View window has three major areas:IDREF="32620" TYPE="TITLE""Build Process Control Area"IDREF="34202" TYPE="TITLE""Transcript Area"IDREF="32799" TYPE="TITLE""Error List Area"LBL="" HELPID=""ID="32620"Build Process Control AreaThe build process control area lets you run or stop the build and view the status. See IDREF="56748" TYPE="GRAPHIC"Figure B-2.FILE="BBuild2.gif" POSITION="INLINE" SCALE="FALSE"LBL="B-2"Figure B-2 ID="56748"Build Process Control Area in Build View WindowThe directory in which the build will run displays in the Directory field at the top of the area. The current directory displays by default. You can specify the build using make, smake, pmake, clearmake, or any other builder and any flags or options that the builder understands (see IDREF="48612" TYPE="TITLE""Build View Preferences" and IDREF="35701" TYPE="TITLE""Build Options"). The target to be built is specified in the Target(s) field. The build process control buttons let you control the build process. The buttons are:Buildruns (or reruns) a build. NoteIf you have modified any files in Source View, you will be prompted to save the new version prior to the compile.Interruptterminates a build.Suspendstops a build temporarily.Resumerestarts a suspended build.The status field is to the right of the build process control buttons. It indicates the progress of the build.LBL="" HELPID=""ID="34202"Transcript AreaThe transcript area displays the verbatim output from the build. The vertical scroll bar lets you go through the list; the horizontal scroll bar lets you see long messages obscured from view. A sash between the compile transcript area and the error list area lets you adjust the lengths of the lists displayed. See IDREF="77161" TYPE="GRAPHIC"Figure B-3.FILE="BBuild3.gif" POSITION="INLINE" SCALE="FALSE"LBL="B-3"Figure B-3 ID="77161"Build View Window With Typical DataLBL="" HELPID=""ID="32799"Error List AreaThe error list area consists of the error list display and three control buttons. The buttons are:Next Errorbrings up the default editor scrolled to the next error location. This button is below the error list display.Rescanrefreshes the error list display.Clearclears the error list display area.The error list area displays compile errors (see IDREF="77161" TYPE="GRAPHIC"Figure B-3). The errors are annotated according to their severity level (fatal has a solid icon and the warning icon is hollow). Double-clicking the text portion of an error brings up the default editor scrolled to the error location and displays a check mark to help you keep track of where you are in the error list. Check marks also display when you click the Next Error button.LBL="" HELPID=""Build View Admin MenuFILE="f11vuadm.gif" POSITION="MARGIN" SCALE="FALSE"LBL="B-4"Figure B-4 ID="81561"Admin Menu in Build View WindowThe Admin menu in Build View (see IDREF="81561" TYPE="GRAPHIC"Figure B-4) has two selections in addition to the standard WorkShop entries: IDREF="48612" TYPE="TITLE""Build View Preferences"IDREF="35701" TYPE="TITLE""Build Options"For more information on "Launch Tool" and "Project"menu selections, refer to the section IDREF="70545" TYPE="TITLE""Admin Menu".LBL="" HELPID="BVPreferences"ID="48612"Build View PreferencesThe "Preferences..." selection brings up the dialog box shown in IDREF="64087" TYPE="GRAPHIC"Figure B-5. The options are:Maker Program fieldlets you enter the program you use to build your executable.Macro Settings fieldlets you enter build macros, such as CFLAGS=-g.Makefile fieldlets you enter the name of a makefile if you do not wish to use the default.Discard Duplicate Errors buttoneliminates subsequent duplicates of errors in the error list area.Show Warnings buttontoggles the option to display warnings in the list.FILE="f11vuprf.gif" POSITION="INLINE" SCALE="FALSE"LBL="B-5"Figure B-5 ID="64087"Build View Preferences Dialog BoxLBL="" HELPID="BuildOptions"ID="35701"Build OptionsThe Build Options dialog box lets you add the options shown in IDREF="58533" TYPE="GRAPHIC"Figure B-6 to your make command.FILE="f11vuopt.gif" POSITION="INLINE" SCALE="FALSE"LBL="B-6"Figure B-6 ID="58533"Build Options Dialog BoxLBL="" HELPID=""Using Build ViewThe steps in running a compile using Build View are:Bring up Build View.Edit the Targets and Directory fields as required.Specify your preference regarding duplicate errors and warnings using the Admin menu (optional). Click Build to start the build. All compile information displays in the transcript area; errors are grouped in a list below. Click Interrupt to terminate or Suspend for a temporary stop, if you want to stop the build. The Resume button restarts a suspended build.Double-click an error to bring up your preferred editor with the appropriate source code. A check mark indicates that an error has been accessed.NoteThe default editor is determined by the editorCommand resource in the app-defaults file. The value of this resource defaults to wsh -c vi +%d, which means run vi in a wsh window and scroll to the current line. If the editor lets you specify a starting line, enter %d in the resource to indicate the new line number. Click Build to restart the build. LBL="" HELPID="BuildAnalyzer"ID="20095"Build AnalyzerBuild Analyzer displays a graph indicating the source files and derived files in the build, and their dependency relationships and current status. ID="BBuild3"Source files refers to input files, such as code modules, documentation, data files, and resources. Derived files refers to output files, such as compiled code. You request builds in Build Analyzer by either:double-clicking a derived modulemaking a selection from the Build menuYou access Build Analyzer from WorkShop by selecting "Launch Tool" from the Admin menu in Main View. Outside of WorkShop, you can access Build Analyzer by typing cvbuild at the command line. A typical Build Analyzer window appears in IDREF="32953" TYPE="GRAPHIC"Figure B-7 with the menus displayed.FILE="BBuild8.gif" POSITION="INLINE" SCALE="FALSE"LBL="B-7"Figure B-7 ID="32953"Build Analyzer WindowLBL="" HELPID=""Build Specification AreaThe three fields in the build specification area identify the working directory, makefile script, and target file(s) for compilation. You can edit the Directory, Makefile, and Targets field directly. The Targets field also lets you specify a search string for locating a file in the build graph.LBL="" HELPID=""Build Graph AreaThe build graph area displays the specified source and derived files and their dependency relationships. Files are depicted as rectangles; dependency relationships are shown as arrows, with the supplying file at the base of the arrow and the dependent file at the head. The colors used to depict the files depends on your color scheme. Build Analyzer differentiates the two types of files by depicting one with light characters on a dark background and the other with dark text on a light background. If you double-click a source file icon, an editor is brought up for that file. Double-clicking a derived file starts a build and displays Build View. In addition to dependency relationships, Build Analyzer indicates the status of the files and relationships as follows:source file availability status: normal or checked out Normal means that the source file is read-only and needs to be made writable to be edited. Normal files appear as light rectangles with black text.Checked out means that you have a writable version of this file available and can thus edit it. A checked out file appears in a different color (from normal files) with a shadow.derived file compile status: current or obsoleteWhen applied to a derived file, the term current means that none of the files on which the derived file depends have been edited since the derived file was created. Current derived files appear as dark rectangles with white text.Obsolete means that one or more of the source files have been modified since the derived file was created. Obsolete files appear in the same color as current derived files but with a colored outline.dependency relationship: current or obsoleteCurrent means that the derived file is up to date with the source files. Note that a relationship can be current even if both files are obsolete. This happens when a file on which both files are dependent has been modified. Current arcs are black.Obsolete means that the source file has changed and the derived file has not been updated accordingly. Obsolete arcs appear as colored arrows.Some typical build graph icons are shown in IDREF="86330" TYPE="GRAPHIC"Figure B-8.FILE="BBuild9.gif" POSITION="INLINE" SCALE="FALSE"LBL="B-8"Figure B-8 ID="86330"Build Graph IconsThe main.c and hello.h source files are in their normal state. The source files warn.c++ and foo.h are checked out and thus appear highlighted and with dropped shadows. The derived file main.o is current, since it has not changed since the last compile. The black dependency arcs indicate that the source and derived files at either end are current with each other. When an arc is highlighted, it indicates that the source has changed since the last compile. The derived files warn.o and a.out are obsolete because warn.c++ has changed.LBL="" HELPID=""Build Graph Control AreaThe build graph control area contains a row of graph control buttons similar to the ones in the WorkShop Static Analyzer and the Call Graph View in the Performance Analyzer. The Overview button is particularly useful in the Build Analyzer because it helps you quickly find obsolete files where a lot of dependencies are involved.The build graph control area is shown in IDREF="32053" TYPE="GRAPHIC"Figure B-9. FILE="BBuild10.gif" POSITION="INLINE" SCALE="FALSE"LBL="B-9"Figure B-9 ID="32053"Build Graph Control AreaLBL="" HELPID="BAOverviewWindow"Overview WindowSince build graphs can get quite complicated, an overview mode (similar to those in Static Analyzer and Profiling View) is supplied that lets you view the entire graph at a reduced scale. To display the overview window, you click the overview icon (see IDREF="32053" TYPE="GRAPHIC"Figure B-9). IDREF="74984" TYPE="GRAPHIC"Figure B-10 shows a typical Overview window with the resulting graph in Build Analyzer. The Overview window has a movable viewport that lets you select the portion of the build graph displayed in Build Analyzer. Source files that have changed and derived files needing recompilation are highlighted for easy detection. In this particular color scheme, the Overview window displays normal source files in turquoise, checked out source files in pink, current derived files in dark blue, and obsolete derived files in yellow. Arcs appear only in black in the Overview window.FILE="BBuild11.gif" POSITION="INLINE" SCALE="FALSE"LBL="B-10"Figure B-10 ID="74984"Overview Window With Resulting Build Analyzer GraphLBL="" HELPID=""Build Analyzer MenusBuild Analyzer contains these menus:AdminBuildFilterQueryLBL="" HELPID=""ID="41360"Build Analyzer Admin MenuFILE="f11anadm.gif" POSITION="MARGIN" SCALE="FALSE"LBL="B-11"Figure B-11 ID="48199"Admin Menu in Build AnalyzerThe Admin menu (ID="BBuild4"IDREF="48199" TYPE="GRAPHIC"Figure B-11) provides one selection "Refresh Graph Display" in addition to the standard WorkShop selections. "Refresh Graph Display" refreshes the window."Launch Tool"lets you execute the WorkShop tools. For more information, see the section IDREF="70545" TYPE="TITLE""Admin Menu"."Project"lets you control the WorkShop tools operating on the same executable as a group. For more information, see the section IDREF="70545" TYPE="TITLE""Admin Menu".LBL="" HELPID=""ID="41391"Build MenuFILE="f11anbld.gif" POSITION="MARGIN" SCALE="FALSE"LBL="B-12"Figure B-12 ID="42387"Build MenuThe selections in the Build menu (see IDREF="42387" TYPE="GRAPHIC"Figure B-12) let you perform builds as follows:"Build Default Target"performs a make with no arguments."Build Selected Target(s)"performs the build(s) as entered in the Targets field."Show Build Rule"displays a dialog box showing the makefile line for the selected node.LBL="" HELPID=""ID="28074"Filter MenuThe Filter menu has only one selection:"Select files to show in graph"lets you enter a regular expression to filter the files displayed in the build graph. The File Filter dialog box appears in IDREF="45013" TYPE="GRAPHIC"Figure B-13. FILE="BBuild16.gif" POSITION="INLINE" SCALE="FALSE"LBL="B-13"Figure B-13 ID="45013"Filter Dialog BoxThe upper list area lets you specify files to be excluded from the build graph. The lower list is for specifying files to appear in the graph.LBL="" HELPID=""ID="30624"Query MenuFILE="f11anqur.gif" POSITION="MARGIN" SCALE="FALSE"LBL="B-14"Figure B-14 ID="81879"Query MenuThe Query menu lets you request information about the build graph (see IDREF="81879" TYPE="GRAPHIC"Figure B-14). The selections are:"Why Is This File Out Of Date?"identifies the source files requiring this file to be recompiled. This query only applies to derived files."What Will Changing This File Affect?"shows all derived files dependent on this source file."Active" selection in Admin menuIDREF="1GStartDebug33"Updating and Saving ViewsIDREF="3TutGen17"Examining Data"Address..." selection in Disassemble menuIDREF="AReference197"Disassemble Menu"Arrange" selection in Structure Browser Display menuIDREF="AReference153"Structure Browser Display Menu"Array Browser" selection in Views menuIDREF="3TutGen28"Examining DataIDREF="AReference16"Views Menu"Call Stack" selection in Views menuIDREF="AReference17"Views MenuIDREF="3TutGen15"Examining Data"Clear All" selection in Structure Browser Display menuIDREF="AReference159"Structure Browser Display Menu"Clear Trap" selection in Traps menuIDREF="4Traps14"Setting Traps With the Traps Menu in Main View IDREF="AReference57"Traps Menu"Click for Help" selection in Help menuIDREF="AReference69"Help Menu"Clone" selection in Admin menuIDREF="1GStartDebug34"Updating and Saving Views"Column Width..." selection in Array Browser Display menuIDREF="AReference129"Spreadsheet Menu"Continue To" selection in Disassembly View PC menuIDREF="AReference194"Similarities With Main View"Continue To" selection in PC menuIDREF="AReference61"PC MenuIDREF="5ProcCon23"Controlling Process Execution With PC Menu"Dereference Ptrs" selection in Structure Browser Node menuIDREF="AReference170"Node Menu"Detach" selection in Admin menuIDREF="AReference8"Admin Menu"Detail" selection in Structure Browser submenuIDREF="AReference164"Node Menu"Disassembly View" selection in Views menuIDREF="AReference18"Views Menu"Display" selection in Structure Browser Display menuIDREF="AReference150"Structure Browser Display Menu"Exception View" selection in Views menuIDREF="AReference19"Views Menu"Execution View" selection in Views menuIDREF="AReference20"Views Menu"Exit" selection in Admin menuIDREF="AReference14"Admin Menu"Expression View" selection in Views menuIDREF="AReference21"Views MenuIDREF="3TutGen22"Examining Data"Expression" selection in Structure Browser Display submenuIDREF="AReference151"Structure Browser Display Menu"File Browser" selection in Views menuIDREF="AReference22"Views Menu"File..." selection in Disassemble menuIDREF="AReference200"Disassemble Menu"Fork Editor" selection in Source menuIDREF="1GStartDebug29"Changing Source CodeIDREF="AReference39"Source Menu"Function..." selection in Disassemble menuIDREF="AReference198"Disassemble Menu"Geometry" selection in Structure Browser Node menuIDREF="AReference165"Node Menu"GLdebug" selection in Admin menuIDREF="AReference4"Admin Menu"Go to Line..." selection in Source menuIDREF="AReference44"Source Menu"Hide Icons" selection in Display menuIDREF="AReference49"Display Menu"Hide Line Numbers" selection in Display menuIDREF="AReference48"Display Menu"Iconic" selection in Structure Browser submenuIDREF="AReference162"Node Menu"Iconify" selection in Admin menuIDREF="AReference11"Admin Menu"Iconify" selection in Session menuIDREF="AReference114"Project Session Management Windows"Index..." selection in Help menuIDREF="AReference71"Help Menu"Insert Source..." selection in Source menuIDREF="AReference38"Source Menu"Jump To" selection in Disassembly View PC menuIDREF="AReference195"Similarities With Main View"Jump To" selection in PC menuIDREF="5ProcCon25"Controlling Process Execution With PC MenuIDREF="AReference62"PC Menu"Keys & Shortcuts" selection in Help menuIDREF="AReference72"Help Menu"Linked List" selection in Structure Browser Display menuIDREF="AReference155"Structure Browser Display Menu"Load Expressions..." selection in Expression View Config menuIDREF="6ExmnData11"Expression View"Load Settings..." selection in Admin menuIDREF="AReference9"Admin Menu"Load Traps..." selection in Config menu in Trap ManagerIDREF="4Traps35"Saving and Reusing Trap Sets"Make Editable" in Source menuIDREF="1GStartDebug30"Changing Source Code"Make Editable" selection in Source menuIDREF="AReference42"Source Menu"Make Read Only" selection in Source menuIDREF="AReference41"Source Menu"Maximize" selection in Structure Browser Node submenuIDREF="AReference167"Node Menu"Memory View" selection in Views menuIDREF="AReference23"Views Menu"Minimize" selection in Structure Browser Node submenuIDREF="AReference166"Node Menu"Multiprocess View..." selection in Admin menuIDREF="AReference3"Admin Menu"N..." selection in Step Into menuIDREF="5ProcCon15"Execution Control Buttons"N..." selection in Step Over menuIDREF="5ProcCon17"Execution Control Buttons"Normal" selection in Structure Node submenuIDREF="AReference163"Node Menu"Open..." selection in Source menuIDREF="AReference34"Source Menu"Overview" selection in Help menuIDREF="AReference70"Help Menu"Pattern Layout" in Structure Browser Node menuIDREF="AReference171"Node Menu"Process Meter" selection in Views menuIDREF="AReference24"Views Menu"Product Information" selection in Help menuIDREF="AReference73"Help Menu"Project" selection in Admin menuIDREF="AReference13"Admin Menu"Raise" selection in Admin menuIDREF="AReference12"Admin Menu"Raise" selection in Session menuIDREF="AReference115"Project Session Management Windows"Raise" selection in Structure Browser Node submenuIDREF="AReference168"Node Menu"Recompile" selection in the Source menuIDREF="AReference40"Source Menu"Register View" selection in Views menuIDREF="AReference25"Views Menu"Remap Paths..." selection in Session menuIDREF="2MngSrc5"Path Remapping"Remove" selection in Structure Browser Node menuIDREF="AReference172"Node Menu"Sample At Function Entry" selection in Traps submenuIDREF="4Traps11"Setting Traps With the Traps Menu in Main View IDREF="AReference52"Traps Menu"Sample At Function Exit" selection in Traps submenuIDREF="AReference53"Traps MenuIDREF="4Traps12"Setting Traps With the Traps Menu in Main View "Save as Text..." selection in Admin menuIDREF="1GStartDebug35"Updating and Saving Views"Save As Text..." selection in Source menuIDREF="AReference37"Source Menu"Save As..." selection in Source menuIDREF="AReference36"Source Menu"Save Expressions..." selection in Expression View Config menuIDREF="6ExmnData10"Expression View"Save Settings..." selection in Admin menuIDREF="AReference10"Admin Menu"Save Traps..." selection in Config menu in Trap ManagerIDREF="4Traps36"Saving and Reusing Trap Sets"Save" selection in Source menuIDREF="AReference35"Source Menu"Search" selection in Source menuIDREF="3TutGen3"Performing a Search"Search" selection in Structure Browser Display menuIDREF="AReference156"Structure Browser Display Menu"Search..." selection in Source menuIDREF="AReference43"Source Menu"Select" selection in Structure Browser Node menuIDREF="AReference169"Node Menu"Selection" selection in Structure Browser Display menuIDREF="AReference152"Structure Browser Display Menu"Set Trap" selection in Traps menuIDREF="AReference51"Traps MenuIDREF="AReference54"Traps MenuIDREF="4Traps8"Setting Traps With the Traps Menu in Main View "Show Icons" selection in Display menuIDREF="AReference50"Display Menu"Show Line Numbers" selection in Display menuIDREF="AReference47"Display Menu"Show Overview" selection in Structure Browser Display menuIDREF="AReference158"Structure Browser Display Menu"Signal Panel" selection in Views menuIDREF="AReference26"Views Menu"Source View" selection in Views menuIDREF="AReference27"Views Menu"State" selection in Structure Browser Node menuIDREF="AReference161"Node Menu"Stop At Function Entry" selection in Traps submenuIDREF="AReference55"Traps MenuIDREF="4Traps9"Setting Traps With the Traps Menu in Main View "Stop At Function Exit" selection in Traps submenuIDREF="4Traps10"Setting Traps With the Traps Menu in Main View IDREF="AReference56"Traps Menu"Structure Browser" selection in Views menuIDREF="3TutGen26"Examining DataIDREF="AReference28"Views Menu"Switch Executable..." selection in Admin menuIDREF="AReference7"Admin Menu"Switch Process..." selection in Admin menuIDREF="AReference5"Admin Menu"Syscall Panel" selection in Views menuIDREF="AReference29"Views Menu"Task View" selection in Views menuIDREF="AReference30"Views Menu"Trap Manager" selection in Views menuIDREF="AReference31"Views Menu"Tree" selection in Structure Browser Display submenuIDREF="AReference154"Structure Browser Display Menu"Update" selection in Structure Browser Display menuIDREF="AReference157"Structure Browser Display Menu"Variable Browser" selection in Views menuIDREF="AReference32"Views MenuIDREF="3TutGen20"Examining Data"Wrapped Display" selection in Array Browser Display menuIDREF="AReference130"Spreadsheet Menu"X/Motif Analyzer" selection in Views menuIDREF="AReference33"Views Menuaccess to freed memoryIDREF="8Heaps6"Typical Heap Corruption ProblemsAccess to uninitialized memoryIDREF="8Heaps5"Typical Heap Corruption Problemsaccessing filesIDREF="2MngSrc2"Accessing Files Used by an Executableactive toggleIDREF="AReference82"Admin MenuIDREF="AReference77"Admin MenuAdd button in Trap ManagerIDREF="3TutGen10"Setting Trapsadding a breakpointIDREF="10TutCvmotif11"Examining WidgetsAdmin menuIDREF="AReference219"Admin MenuIDREF="AReference81"Admin Menu"Library Search Path..."IDREF="AReference2"Admin Menuactive toggleIDREF="AReference77"Admin MenuIDREF="AReference82"Admin MenucloneIDREF="AReference78"Admin MenuIDREF="AReference83"Admin MenucloseIDREF="AReference80"Admin MenuIDREF="AReference85"Admin MenuDebugger viewsIDREF="1GStartDebug32"Updating and Saving Views general descriptionIDREF="AReference1"Admin Menusave as textIDREF="AReference84"Admin MenuIDREF="AReference79"Admin Menualias debugger commandIDREF="AReference235"Debugger Command Lineall trap Debugger command optionIDREF="4Traps23"Setting Single-process and Multiprocess Traps in the Trap: Fieldarguments, command lineIDREF="5ProcCon4"Status and Entry Fields in the Main View Control PanelArray BrowserIDREF="1GStartDebug22"Inspecting Debugger DataIDREF="3TutGen29"Examining Datageneral descriptionIDREF="AReference117"Array Browsersubscript controlsIDREF="3TutGen32"Examining DataArray Browser windowIDREF="3TutGen30"Examining DataArray field in Array BrowserIDREF="AReference118"Array Browserarray subscriptsIDREF="AReference120"Array Browserarray variablesIDREF="AReference116"Array BrowserIDREF="1GStartDebug21"Inspecting Debugger Dataassign Debugger commandIDREF="AReference236"Debugger Command Lineassigning values to variablesIDREF="6ExmnData12"Assigning Values to Variablesattach Debugger commandIDREF="AReference237"Debugger Command LineAutomatic Dereference Limit field in Structure Browser  Preferences boxIDREF="AReference178"Formatting Fieldsboundary overrunsIDREF="8Heaps3"Typical Heap Corruption Problemsboundary underrunIDREF="8Heaps4"Typical Heap Corruption ProblemsbreakpointIDREF="1GStartDebug10"Setting Trapsbreakpoint results, viewingIDREF="10TutCvmotif18"Using Additional Features of the Analyzerbreakpoint type option buttonIDREF="AReference97"Breakpoints Examinerbreakpoint, addingIDREF="10TutCvmotif11"Examining Widgetsbreakpoints examinerIDREF="AReference96"Breakpoints ExaminercallbackIDREF="AReference98"Callback Breakpoints Examinerevent-handlerIDREF="AReference99"Event-Handler Breakpoints Examinerinput-handlerIDREF="AReference102"Input-Handler Breakpoints Examinerresource-changeIDREF="AReference100"Resource-Change Breakpoints Examinerstate-changeIDREF="AReference103"State-Change Breakpoints Examinertimeout-procedureIDREF="AReference101"Timeout-Procedure Breakpoints ExaminerX-eventIDREF="AReference104"X-Event Breakpoints Examinerbreakpoints tabIDREF="10TutCvmotif17"Using Additional Features of the Analyzerbreakpoints, settingIDREF="7TutF+C11"Setting Breakpoints in Redefined Codebreakpoints, setting for a classIDREF="10TutCvmotif13"Setting Callback BreakpointsBuild AnalyzerIDREF="BBuild3"Build AnalyzerBuild Environment windowIDREF="AReference227"Fix+Continue Build Environment WindowBuild ManagerIDREF="BBuild1"Using the Build Managerbuild pathIDREF="1GStartDebug48"Change ID, Build Path, and Other ConceptsBuild ViewIDREF="BBuild2"Build ViewC expressionsIDREF="6ExmnData13"Evaluating Expressions in CC function callsIDREF="6ExmnData14"C Function CallsC++ expressionsIDREF="6ExmnData15"Evaluating Expressions in C++call Debugger commandIDREF="AReference238"Debugger Command LineCall StackIDREF="1GStartDebug16"Inspecting Debugger DataIDREF="7TutF+C12"Setting Breakpoints in Redefined CodeCall Stack ViewIDREF="6ExmnData3"Tracing Through Call Stack ViewIDREF="AReference231"Call StackIDREF="3TutGen16"Examining DataIDREF="AReference132"Call Stack Viewcallback breakpoints examinerIDREF="AReference98"Callback Breakpoints Examinercallback context, viewingIDREF="10TutCvmotif14"Setting Callback Breakpointscallback examinerIDREF="10TutCvmotif14"Setting Callback BreakpointsIDREF="AReference108"Callback Examinercallstack viewIDREF="10TutCvmotif18"Using Additional Features of the Analyzercatch Debugger commandIDREF="AReference239"Debugger Command Linechange IDIDREF="1GStartDebug48"Change ID, Build Path, and Other Conceptschanges, re-enablingIDREF="7TutF+C17"Switching Between Compiled and Redefined Codeclasses, examining widgetIDREF="10TutCvmotif12"Setting Callback BreakpointsClear button in Trap ManagerIDREF="3TutGen8"Setting Trapsclear Debugger commandIDREF="AReference240"Debugger Command Lineclearbuffer Debugger commandIDREF="AReference241"Debugger Command Lineclearcalls Debugger commandIDREF="AReference242"Debugger Command Lineclone current windowIDREF="AReference83"Admin MenuIDREF="AReference78"Admin Menuclose current windowIDREF="AReference85"Admin MenuIDREF="AReference80"Admin Menucode, changingIDREF="7TutF+C7"Changing Codecode, changing from command lineIDREF="7TutF+C9"Changing Code From the Debugger Command Linecode, comparingIDREF="7TutF+C15"Comparing Original and Redefined Code code, deleting changedIDREF="7TutF+C8"Deleting Changed Codecode, switching between compiled and redefinedIDREF="7TutF+C16"Switching Between Compiled and Redefined CodeCol button in Array BrowserIDREF="3TutGen31"Examining DataCommand field in Main ViewIDREF="5ProcCon4"Status and Entry Fields in the Main View Control Panelcommand line interfaceIDREF="AReference230"Command-Line Interfacecomparing function definitionsIDREF="7TutF+C18"Comparing Function DefinitionsCondition field in Trap ManagerIDREF="4Traps30"Setting a Trap ConditionConfig menu in Structure BrowserIDREF="AReference142"tructure BrowserConfig menu in Trap ManagerIDREF="4Traps18"Setting Traps in Trap Managercont in Debugger commandIDREF="AReference243"Debugger Command Linecont to Debugger commandIDREF="AReference244"Debugger Command LineContinue button in Main ViewIDREF="5ProcCon11"Execution Control ButtonsIDREF="3TutGen12"Setting TrapsIDREF="3TutGen5"Setting Trapscontinue Debugger commandIDREF="AReference245"Debugger Command Lineconventions, font, for manualIDREF="0Intro2"Conventionscorefile Debugger commandIDREF="AReference247"Debugger Command LinecvdExecution ViewIDREF="10TutCvmotif5"Preparing the FilesetMain ViewIDREF="10TutCvmotif4"Preparing the FilesetCycle Count field in Trap ManagerIDREF="3TutGen13"Setting TrapsIDREF="4Traps32"Setting a Trap Cycle Countdata structuresIDREF="1GStartDebug19"Inspecting Debugger Datadbx commandsIDREF="AReference234"Debugger Command LineDebuggercall stack viewIDREF="AReference231"Call Stackchanges to viewsIDREF="AReference228"Changes to Debugger Viewscommand line interfaceIDREF="AReference230"Command-Line InterfaceExecution ViewIDREF="10TutCvmotif5"Preparing the FilesetexitingIDREF="1GStartDebug2"Starting and Exiting the DebuggerMain ViewIDREF="10TutCvmotif4"Preparing the FilesetIDREF="AReference229"Main Viewprocess execution controlIDREF="5ProcCon1"Controlling Process Execution startingIDREF="1GStartDebug1"Starting and Exiting the DebuggerstartingIDREF="3TutGen1"Starting the Debuggertrap managerIDREF="AReference232"Trap Manager Debugger commandIDREF="AReference246"Debugger Command LineDebugger command lineIDREF="1GStartDebug6"Using Main View IDREF="AReference233"Debugger Command LineDebugger dataIDREF="6ExmnData1"Examining Debugger DataDebugger viewsIDREF="6ExmnData2"Tracing Through Call Stack ViewIDREF="AReference187"Formatting FieldsIDREF="AReference131"Call Stack ViewDebugger with Fix and Continue supportFix and Continue Debugger support withIDREF="1GStartDebug44"Debugger With Fix and Continue SupportDebugger, exitingIDREF="7TutF+C21"Ending the SessionDefault Field Count field in Structure Browser Type FormattingIDREF="AReference182"Formatting FieldsDefault Iconic Width field in Structure Browser Preferences boxIDREF="AReference177"Formatting FieldsDefault Iconic Width field in Structure Browser Type Formatting boxIDREF="AReference184"Formatting FieldsDefault State field in Structure Browser Type Formatting boxIDREF="AReference185"Formatting FieldsDefault Structure Field Count field in Structure Browser Preferences boxIDREF="AReference175"Formatting FieldsDefault Structure Width field in Structure Browser Preferences boxIDREF="AReference176"Formatting FieldsDefault Structure Width in STructure Browser Type Formatting boxIDREF="AReference183"Formatting Fieldsdelete all Debugger commandIDREF="AReference249"Debugger Command Linedelete Debugger commandIDREF="AReference248"Debugger Command Linedelete trap Debugger commandIDREF="AReference250"Debugger Command LineDereference Ptrs By Default field in Structure Browser Preferences boxIDREF="AReference179"Formatting FieldsdetachIDREF="AReference251"Debugger Command Linedifference toolsIDREF="7TutF+C19"Comparing Function Definitionsdisable all Debugger commandIDREF="AReference252"Debugger Command Linedisable Debugger commandIDREF="AReference253"Debugger Command Linedisabling trapsIDREF="3TutGen7"Setting TrapsDisassemble File dialog boxIDREF="AReference201"Disassemble MenuDisassemble Function dialog boxIDREF="AReference199"Disassemble MenuDisassemble menu in Disassembly ViewIDREF="AReference196"Disassemble Menudisassembled codeIDREF="1GStartDebug27"Inspecting Debugger DataDisassembly ViewIDREF="1GStartDebug28"Inspecting Debugger DatapreferencesIDREF="AReference202"Disassembly View Preferencesdisplay area in Structure BrowserIDREF="AReference147"Working in the Structure Browser Display Areadisplay Debugger commandIDREF="AReference254"Debugger Command LineDisplay menuMain ViewIDREF="BBuild4"Build Analyzer Admin MenuIDREF="AReference46"Display MenuDisplay menu in Structure BrowserIDREF="AReference149"Structure Browser Display MenuIDREF="AReference143"tructure BrowserDisplay menu in Traps ManagerIDREF="4Traps20"Setting Traps in Trap Managerdocumentation, recommended readingIDREF="0Intro1"What You Should Know Before Reading This Guidedouble freesIDREF="8Heaps7"Typical Heap Corruption Problemsdown Debugger commandIDREF="AReference255"Debugger Command Linedump Debugger commandIDREF="AReference256"Debugger Command Lineenable all Debugger commandIDREF="AReference257"Debugger Command Lineenable trap Debugger commandIDREF="AReference258"Debugger Command Lineenvironment variablessettingIDREF="AReference75"Execution ViewIDREF="5ProcCon28"Execution Viewerroneous freesIDREF="8Heaps8"Typical Heap Corruption ProblemsError Message windowIDREF="AReference223"Fix+Continue Message Windowevent examinerIDREF="AReference110"Event Examiner event-handler breakpoints examinerIDREF="AReference99"Event-Handler Breakpoints Examinerexamin menuwidget treeIDREF="AReference89"Examine Menuexamine menuIDREF="AReference86"Examine MenuselectionIDREF="AReference87"Examine MenuwidgetIDREF="AReference88"Examine Menuwidget classIDREF="AReference90"Examine MenuX eventIDREF="AReference92"Examine MenuexaminerbreakpointIDREF="10TutCvmotif11"Examining WidgetsbreakpointsIDREF="AReference96"Breakpoints ExaminercallbackIDREF="10TutCvmotif14"Setting Callback BreakpointsIDREF="AReference108"Callback Examinercallback breakpointsIDREF="AReference98"Callback Breakpoints ExaminereventIDREF="AReference110"Event Examiner event-handler breakpointsIDREF="AReference99"Event-Handler Breakpoints Examinergraphics context (GC)IDREF="AReference111"Graphics Context Examinerinput-handler breakpointsIDREF="AReference102"Input-Handler Breakpoints ExaminerpixmapIDREF="AReference112"Pixmap Examinerresource-change breakpointsIDREF="AReference100"Resource-Change Breakpoints Examinerstate-change breakpointsIDREF="AReference103"State-Change Breakpoints Examinertimeout-procedure breakpointsIDREF="AReference101"Timeout-Procedure Breakpoints ExaminertraceIDREF="AReference105"Trace ExaminertreeIDREF="AReference107"Tree ExaminerIDREF="10TutCvmotif9"Navigating the Widget StructurewidgetIDREF="10TutCvmotif8"Navigating the Widget StructureIDREF="AReference106"Widget Examinerwidget classIDREF="AReference113"Widget Class ExaminerwindowIDREF="AReference109"Window ExaminerIDREF="10TutCvmotif15"Setting Callback BreakpointsX-event breakpointsIDREF="AReference104"X-Event Breakpoints Examinerexaminer menuX graphics contextIDREF="AReference93"Examine MenuX PixmapIDREF="AReference94"Examine Menuexaminer tabsIDREF="AReference95"Examiner TabsexaminersoverviewIDREF="1GStartDebug55"Examiners OverviewselectionsIDREF="1GStartDebug56"Examiners and Selectionsexamining Debugger dataIDREF="1GStartDebug15"Inspecting Debugger DataIDREF="6ExmnData1"Examining Debugger DataExamining view dataIDREF="3TutGen14"Examining Dataexamining widget classesIDREF="10TutCvmotif12"Setting Callback Breakpointsexamining widgetsIDREF="10TutCvmotif10"Examining Widgetsexecution control buttonsIDREF="5ProcCon7"Execution Control ButtonsExecution ViewIDREF="AReference74"Execution ViewIDREF="5ProcCon27"Execution ViewIDREF="5ProcCon26"Execution ViewIDREF="10TutCvmotif5"Preparing the Filesetexiting DebuggerIDREF="7TutF+C21"Ending the Sessionexiting the DebuggerIDREF="1GStartDebug2"Starting and Exiting the Debuggerexiting X/Motif analyzerIDREF="10TutCvmotif19"Ending the SessionExpression column in Expression ViewIDREF="6ExmnData7"Expression ViewIDREF="AReference138"Language Popupexpression count Debugger commandIDREF="AReference259"Debugger Command LineExpression field in Structure BrowserIDREF="3TutGen27"Examining DataIDREF="AReference146"Entering ExpressionsExpression ViewIDREF="6ExmnData5"Expression ViewIDREF="AReference134"Expression ViewIDREF="3TutGen23"Examining DataIDREF="1GStartDebug17"Inspecting Debugger DataexpressionsCIDREF="6ExmnData13"Evaluating Expressions in CC++IDREF="6ExmnData15"Evaluating Expressions in C++FortranIDREF="6ExmnData16"Evaluating Expressions in FortranFile BrowserIDREF="2MngSrc2"Accessing Files Used by an Executablefile Debugger commandIDREF="AReference260"Debugger Command LineFile Menu, Source ViewIDREF="AReference76"Menu BarfilesopeningIDREF="2MngSrc3"Opening a New Filefiles, comparing source codeIDREF="7TutF+C20"Comparing Source Code Filesfiles, findingIDREF="1GStartDebug50"Change ID, Build Path, and Other Conceptsfinding filesIDREF="1GStartDebug50"Change ID, Build Path, and Other ConceptsFix and Continuebasic cycleIDREF="1GStartDebug40"Fix and Continue FunctionalitybreakpointsIDREF="7TutF+C11"Setting Breakpoints in Redefined CodeBuild Environment windowIDREF="AReference227"Fix+Continue Build Environment Windowbuild pathIDREF="1GStartDebug48"Change ID, Build Path, and Other Conceptschange IDIDREF="1GStartDebug48"Change ID, Build Path, and Other Conceptschanging codeIDREF="7TutF+C7"Changing Codechanging code from command lineIDREF="7TutF+C9"Changing Code From the Debugger Command Linedeleting changed codeIDREF="7TutF+C8"Deleting Changed Codeediting a functionIDREF="7TutF+C6"Editing a FunctionenvironmentIDREF="1GStartDebug43"The Fix and Continue EnvironmentError Message windowIDREF="AReference223"Fix+Continue Message WindowfunctionalityIDREF="1GStartDebug39"Fix and Continue FunctionalityGUIIDREF="AReference217"Fix+Continue WindowsGUI command lineIDREF="1GStartDebug47"GUI Debugger Command Linemenu operationsIDREF="AReference63"Fix+Continue Menuredefining functions withIDREF="1GStartDebug38"Redefining Functions Using Fix and ContinuerestrictionsIDREF="1GStartDebug42"Restrictions on Fix and Continuesample sessionIDREF="7TutF+C3"Setting Up the Sample SessionSessionIDREF="AReference222"Fix+Continue MenuIDREF="AReference64"Fix+Continue MenuShow DifferenceIDREF="AReference65"Show Difference SubmenustartingIDREF="1GStartDebug37"Debugging with Fix+ContinueStatus windowIDREF="AReference218"Fix+Continue Status WindowIDREF="7TutF+C14"Viewing StatustrapsIDREF="7TutF+C11"Setting Breakpoints in Redefined CodeViewIDREF="AReference66"View SubmenuWorkShop integrationIDREF="1GStartDebug41"Fix and Continue/WorkShop IntegrationFix+Continue menuIDREF="AReference221"Fix+Continue Menufont conventions, for manualIDREF="0Intro2"ConventionsFormat menu in Expression ViewIDREF="3TutGen25"Examining DataIDREF="AReference139"Format PopupIDREF="6ExmnData8"Expression ViewIDREF="AReference136"Expression ViewFormat menu in Structure BrowserIDREF="AReference145"tructure BrowserFormat menu in Variable BrowserIDREF="AReference190"Variable Browserformatting fields in Structure BrowserIDREF="AReference173"Formatting FieldsFortran expressionsIDREF="6ExmnData16"Evaluating Expressions in FortranFortran function callsIDREF="6ExmnData18"Fortran Function CallsFortran variablesIDREF="6ExmnData17"Fortran VariablesframesIDREF="6ExmnData4"Tracing Through Call Stack ViewIDREF="AReference133"Call Stack Viewfunc Debugger commandIDREF="AReference261"Debugger Command Linefunction definitions, comparingIDREF="7TutF+C18"Comparing Function Definitionsfunction, editingIDREF="7TutF+C6"Editing a Functionfunction, redefiningFix and Continueredefining functionsIDREF="7TutF+C5"Redefining a Functionfunctions, identifyingIDREF="1GStartDebug49"Change ID, Build Path, and Other ConceptsgdiffIDREF="7TutF+C19"Comparing Function Definitionsgivenfile Debugger commandIDREF="AReference262"Debugger Command LineGLdebugIDREF="AReference4"Admin Menugoto Debugger commandIDREF="AReference263"Debugger Command LineGoto dialog boxIDREF="AReference45"Source Menugraphics context (GC) examinerIDREF="AReference111"Graphics Context ExaminerGUI command lineIDREF="1GStartDebug47"GUI Debugger Command Lineheap corruptiondetectionIDREF="8Heaps1"Detecting Heap Corruptionheap corruption problemsdefinedIDREF="8Heaps2"Typical Heap Corruption ProblemsHelp menuIDREF="AReference68"Help Menuidentifying functionsIDREF="1GStartDebug49"Change ID, Build Path, and Other Conceptsignore Debugger commandIDREF="AReference264"Debugger Command Lineindex identifiers in Array BrowserIDREF="AReference122"Array Browserindex maximum specification in Array BrowserIDREF="AReference126"Array Browserindex minimum specification in Array BrowserIDREF="AReference125"Array Browserindex sliders in Array BrowserIDREF="AReference124"Array Browserindex values in Array BrowserIDREF="AReference123"Array BrowserIndexing Expression field in Array BrowserIDREF="AReference119"Array Browserinput-handler breakpoints examinerIDREF="AReference102"Input-Handler Breakpoints Examinerintegration of WorkShop toolsIDREF="1GStartDebug36"Integration With Other WorkShop Toolsinterface, command lineIDREF="AReference230"Command-Line Interfacejello programIDREF="3TutGen2"Starting the DebuggerKill button in Main ViewIDREF="5ProcCon10"Execution Control Buttonskill Debugger commandIDREF="AReference265"Debugger Command LineLanguage menu in Expression ViewIDREF="AReference135"Expression ViewIDREF="AReference137"Language PopupIDREF="3TutGen24"Examining DataIDREF="6ExmnData6"Expression ViewLanguage menu in Variable BrowserIDREF="AReference189"Variable Browserlaunching the X/Motif analyerIDREF="1GStartDebug52"Debugging with the X/Motif Analyzerlaunching X/Motif analyzerIDREF="10TutCvmotif6"Launching the X/Motif Analyzer$LD_LIBRARY_PATH, settingIDREF="1GStartDebug53"Special LibrariesLibrary Search Path dialog boxIDREF="AReference2"Admin Menulist Debugger commandIDREF="AReference266"Debugger Command LineMain ViewIDREF="10TutCvmotif4"Preparing the FilesetCommand fieldIDREF="5ProcCon4"Status and Entry Fields in the Main View Control PanelContinue buttonIDREF="5ProcCon11"Execution Control Buttonscontrol panelIDREF="5ProcCon2"Main View Control PanelDisplay menuIDREF="AReference46"Display MenuIDREF="BBuild4"Build Analyzer Admin Menugeneral descriptionIDREF="1GStartDebug3"Using Main View Kill buttonIDREF="5ProcCon10"Execution Control ButtonsPC MenuIDREF="5ProcCon20"Controlling Process Execution With PC MenuIDREF="5ProcCon21"Controlling Process Execution With PC MenuRun buttonIDREF="5ProcCon8"Execution Control ButtonsSample buttonIDREF="5ProcCon19"Execution Control ButtonsStatus fieldIDREF="5ProcCon6"Status and Entry Fields in the Main View Control PanelIDREF="5ProcCon5"Status and Entry Fields in the Main View Control PanelStep IntoIDREF="5ProcCon14"Execution Control ButtonsStep Over buttonIDREF="5ProcCon16"Execution Control ButtonsStop buttonIDREF="5ProcCon12"Execution Control Buttonsmain view, DebuggerIDREF="AReference229"Main Viewmanaging source filesIDREF="2MngSrc1"Managing Source Filesmemory locationsIDREF="1GStartDebug23"Inspecting Debugger DataMemory ViewIDREF="AReference215"Memory ViewIDREF="1GStartDebug24"Inspecting Debugger DataMemory View Mode menuIDREF="AReference216"Changing the Memory Display Formatmenu operationsIDREF="AReference63"Fix+Continue MenuMessage windowIDREF="AReference223"Fix+Continue Message WindowAdmin menuIDREF="AReference225"Admin MenubuttonsIDREF="AReference224"Fix+Continue Message WindowView menuIDREF="AReference226"View MenuMinimum lines around current instruction field in Disassembly View Preferences boxIDREF="AReference204"Disassembly View Preferencesmultiprocess trapsIDREF="4Traps21"Setting Single-process and Multiprocess Traps in the Trap: Fieldnext Debugger commandIDREF="AReference267"Debugger Command Linenexti Debugger commandIDREF="AReference268"Debugger Command LineNode menu in Structure BrowserIDREF="AReference144"tructure BrowserIDREF="AReference160"Node MenuNode popup menu in Structure BrowserIDREF="AReference148"Working in the Structure Browser Display AreaNumber of instructions to disassemble field in Disassembly View Preferences boxIDREF="AReference203"Disassembly View Preferencesopening filesIDREF="2MngSrc3"Opening a New Filepath remappingIDREF="2MngSrc4"Path RemappingPCIDREF="AReference59"PC MenuPC menuIDREF="AReference58"PC MenuIDREF="5ProcCon21"Controlling Process Execution With PC Menu"Continue To"IDREF="5ProcCon23"Controlling Process Execution With PC Menu"Jump To"IDREF="5ProcCon25"Controlling Process Execution With PC MenuPC menu in Disassembly ViewIDREF="AReference193"Similarities With Main ViewPC menu in Main ViewIDREF="5ProcCon20"Controlling Process Execution With PC Menuperformance dataSample buttonIDREF="5ProcCon19"Execution Control Buttonspgrp trap Debugger command optionIDREF="4Traps24"Setting Single-process and Multiprocess Traps in the Trap: Fieldpixmap examinerIDREF="AReference112"Pixmap ExaminerpollpointIDREF="1GStartDebug14"Setting Trapspollpoint trap Debugger command optionIDREF="4Traps28"Setting Single-process and Multiprocess Traps in the Trap: FieldPreference menuIDREF="AReference67"Preferences Submenupreparing the filesetIDREF="10TutCvmotif3"Preparing the Filesetprint expression Debugger commandIDREF="AReference269"Debugger Command Lineprintd expression Debugger commandIDREF="AReference270"Debugger Command Lineprinto expression Debugger commandIDREF="AReference271"Debugger Command Lineprintregs Debugger commandIDREF="AReference272"Debugger Command Lineprintx expression Debugger commandIDREF="AReference273"Debugger Command Lineprocess execution controlIDREF="5ProcCon1"Controlling Process ExecutionMain View control panelIDREF="5ProcCon3"Main View Control PanelPC menuIDREF="5ProcCon22"Controlling Process Execution With PC Menuprogram counterIDREF="AReference60"PC MenuIDREF="5ProcCon20"Controlling Process Execution With PC Menuprogram output, trackingIDREF="1GStartDebug51"Change ID, Build Path, and Other Conceptspwd Debugger commandIDREF="AReference274"Debugger Command Linequit Debugger commandIDREF="AReference275"Debugger Command LineRead-Only Debugger statusIDREF="1GStartDebug45"Debugger With Fix and Continue Supportredefining functionsIDREF="1GStartDebug38"Redefining Functions Using Fix and ContinueRegister name display format field in Disassembly View Preferences boxIDREF="AReference205"Disassembly View PreferencesRegister ViewIDREF="1GStartDebug26"Inspecting Debugger DataIDREF="AReference211"Register ViewRegister View formattingIDREF="AReference214"Changing the Register View DisplayRegister View Preferences dialog boxIDREF="AReference213"Changing the Register View DisplayRegister View windowIDREF="AReference212"Register View WindowregistersIDREF="1GStartDebug25"Inspecting Debugger Dataremoving traps with mouseIDREF="4Traps16"Setting Traps With the Mousererun Debugger commandIDREF="AReference276"Debugger Command Lineresource-change breakpoints examinerIDREF="AReference100"Resource-Change Breakpoints Examinerrestrictions and limitationsIDREF="1GStartDebug57"Restrictions and LimitationsResult column in Expression ViewIDREF="6ExmnData9"Expression ViewIDREF="AReference140"Format PopupReturn button in Main ViewMain ViewReturn buttonIDREF="5ProcCon18"Execution Control Buttonsreturn Debugger commandIDREF="AReference277"Debugger Command Linerow/column toggles in Array BrowserIDREF="AReference121"Array BrowserRun button in Main ViewIDREF="5ProcCon8"Execution Control Buttonsrun Debugger commandIDREF="AReference278"Debugger Command LineSample button in Main ViewIDREF="5ProcCon19"Execution Control Buttonssample sessionIDREF="10TutCvmotif1"Using the X/Motif Analyzer: A TutorialInterpreterIDREF="7TutF+C2"Debugging with Fix+Continue: A Tutorialpreparing filesetIDREF="10TutCvmotif3"Preparing the Filesetsetting upIDREF="10TutCvmotif2"Setting Up the Sample Sessionsample session setupIDREF="7TutF+C3"Setting Up the Sample Sessionsample trapIDREF="4Traps6"Trap Actionssample trap commandIDREF="4Traps22"Setting Single-process and Multiprocess Traps in the Trap: Fieldsample trapsIDREF="1GStartDebug9"Setting Trapssave as textIDREF="AReference84"Admin MenuIDREF="AReference79"Admin Menusaving to source fileIDREF="7TutF+C10"Saving Changessaving view dataIDREF="1GStartDebug31"Updating and Saving ViewsSearch field in Trap ManagerIDREF="4Traps34"Moving around the Trap Display AreaselectionIDREF="AReference87"Examine MenuSession submenuIDREF="AReference64"Fix+Continue MenuIDREF="AReference222"Fix+Continue Menusetting trapsIDREF="3TutGen4"Setting Trapssetting traps with the mouseIDREF="4Traps15"Setting Traps With the Mousesh Debugger commandIDREF="AReference279"Debugger Command LineShow Difference submenuIDREF="AReference65"Show Difference SubmenuShow embedded source annotation field in Disassembly View Preferences boxIDREF="AReference206"Disassembly View PreferencesShow instruction value field in Disassembly View Preferences boxIDREF="AReference209"Disassembly View PreferencesShow jal target numerically field in Disassembly View Preferences boxIDREF="AReference210"Disassembly View PreferencesShow machine address field in Disassembly View Preferences boxIDREF="AReference208"Disassembly View PreferencesShow source file and line number field in Disassembly View Preferences boxIDREF="AReference207"Disassembly View Preferencescontinue IDREF="AReference246"Debugger Command LineSignal PanelIDREF="4Traps37"Setting Traps With Signal Panel and Syscall Panelsignal trap Debugger command optionIDREF="4Traps26"Setting Single-process and Multiprocess Traps in the Trap: FieldsignalstrapsIDREF="1GStartDebug11"Setting Trapssource annotation columntrapsIDREF="4Traps13"Setting Traps With the Traps Menu in Main View source code display areaIDREF="1GStartDebug4"Using Main View source code status indicatorIDREF="7TutF+C4"Setting Up the Sample SessionIDREF="1GStartDebug46"Debugger With Fix and Continue Supportsource Debugger commandIDREF="AReference280"Debugger Command Linesource file, saving toIDREF="7TutF+C10"Saving Changessource filesmanagingIDREF="2MngSrc1"Managing Source FilesSource ViewFile MenuIDREF="AReference76"Menu Barspecial librariesIDREF="1GStartDebug53"Special Librariesspreadsheet area in Array BrowserIDREF="AReference128"Array Browserstack frameIDREF="3TutGen19"Examining DataIDREF="3TutGen18"Examining Datastack framesIDREF="6ExmnData4"Tracing Through Call Stack ViewIDREF="AReference133"Call Stack Viewstarting Fix and ContinueIDREF="1GStartDebug37"Debugging with Fix+Continuestarting the DebuggerIDREF="1GStartDebug1"Starting and Exiting the DebuggerIDREF="3TutGen1"Starting the Debuggerstarting the X/Motif analyzerIDREF="1GStartDebug52"Debugging with the X/Motif Analyzerstarting, process executionIDREF="5ProcCon9"Execution Control Buttonsstate-change breakpoints examinerIDREF="AReference103"State-Change Breakpoints Examinerstatus Debugger commandIDREF="AReference281"Debugger Command LineStatus field in Main ViewIDREF="5ProcCon5"Status and Entry Fields in the Main View Control PanelIDREF="5ProcCon6"Status and Entry Fields in the Main View Control Panelstatus lineMain ViewIDREF="1GStartDebug5"Using Main View Status windowIDREF="AReference218"Fix+Continue Status WindowIDREF="7TutF+C14"Viewing StatusAdmin menuIDREF="AReference219"Admin MenuFix+Continue menuIDREF="AReference221"Fix+Continue MenuPreference menuIDREF="AReference67"Preferences SubmenuView menuIDREF="AReference220"View Menustatus, viewingIDREF="7TutF+C14"Viewing Statusstep Debugger commandIDREF="AReference282"Debugger Command Linestep indicators in Array BrowserIDREF="AReference127"Array BrowserStep Into button in Disassembly ViewIDREF="AReference191"Similarities With Main ViewStep Into button in Main ViewIDREF="5ProcCon14"Execution Control ButtonsStep Over button in Disassembly ViewIDREF="AReference192"Similarities With Main ViewStep Over button in Main ViewIDREF="5ProcCon16"Execution Control Buttonsstepi Debugger commandIDREF="AReference283"Debugger Command Linestop at Debugger commandIDREF="AReference284"Debugger Command LineStop button in Main ViewIDREF="5ProcCon12"Execution Control Buttonsstop in Debugger commandIDREF="AReference285"Debugger Command Linestop trapIDREF="4Traps5"Trap Actionsstop trap commandIDREF="4Traps22"Setting Single-process and Multiprocess Traps in the Trap: Fieldstop trapsIDREF="1GStartDebug8"Setting TrapsIDREF="3TutGen4"Setting Trapsstopping, process executionIDREF="5ProcCon13"Execution Control ButtonsStructure BrowserIDREF="1GStartDebug20"Inspecting Debugger Datageneral descriptionIDREF="AReference141"tructure BrowserStructure Browser Preferences dialog boxIDREF="AReference174"Formatting Fieldssubscript controls In Array BrowserIDREF="3TutGen32"Examining DatasubscriptsarrayIDREF="AReference120"Array BrowserSwitch Process dialog boxIDREF="AReference6"Admin Menusyscall Debugger commandIDREF="AReference286"Debugger Command LineSyscall PanelIDREF="4Traps38"Setting Traps With Signal Panel and Syscall Panelsyscall trap Debugger command optionIDREF="4Traps27"Setting Single-process and Multiprocess Traps in the Trap: Fieldsystem callstrapsIDREF="1GStartDebug12"Setting Trapstab overflow areaIDREF="10TutCvmotif17"Using Additional Features of the AnalyzertabsIDREF="10TutCvmotif17"Using Additional Features of the Analyzertabs, examinerIDREF="AReference95"Examiner Tabstimeout procedure breakpoints examinerIDREF="AReference101"Timeout-Procedure Breakpoints Examinertrace Debugger commandIDREF="AReference287"Debugger Command Linetrace examinerIDREF="AReference105"Trace Examinertracking program outputIDREF="1GStartDebug51"Change ID, Build Path, and Other Conceptstrap actionsIDREF="4Traps4"Trap Terminologytrap conditionIDREF="4Traps31"Setting a Trap Conditiontrap examplesIDREF="4Traps29"Setting Single-process and Multiprocess Traps in the Trap: Fieldtrap managerIDREF="7TutF+C13"Setting Breakpoints in Redefined CodeIDREF="3TutGen6"Setting TrapsTrap Manager menusIDREF="4Traps17"Setting Traps in Trap Managertrap manangerIDREF="AReference232"Trap Managertrap terminologyIDREF="4Traps2"Trap TerminologytrapsIDREF="3TutGen4"Setting TrapsIDREF="1GStartDebug7"Setting TrapsdisablingIDREF="3TutGen7"Setting Trapsgeneral descriptionIDREF="4Traps1"Setting Trapsone-timeIDREF="5ProcCon24"Controlling Process Execution With PC Menuremoving with mouseIDREF="4Traps16"Setting Traps With the Mousesetting conditionsIDREF="4Traps30"Setting a Trap Conditionsetting cycle countIDREF="4Traps32"Setting a Trap Cycle Countsetting with mouseIDREF="4Traps15"Setting Traps With the MouseSignal PanelIDREF="4Traps37"Setting Traps With Signal Panel and Syscall PanelSyscall PanelIDREF="4Traps38"Setting Traps With Signal Panel and Syscall PaneltriggeringIDREF="4Traps3"Trap TerminologyTraps menu in Main ViewIDREF="4Traps7"Setting Traps With the Traps Menu in Main View Traps menu in Trap ManagerIDREF="4Traps33"Setting a Trap With the Traps Menu and Source DisplayIDREF="4Traps19"Setting Traps in Trap Managertraps multiprocessIDREF="4Traps21"Setting Single-process and Multiprocess Traps in the Trap: Fieldtraps, settingIDREF="7TutF+C11"Setting Breakpoints in Redefined Codetree examinerIDREF="10TutCvmotif9"Navigating the Widget StructureIDREF="AReference107"Tree Examinertriggering trapsIDREF="4Traps3"Trap TerminologyType Color field in Structure Browser Type Formatting boxIDREF="AReference186"Formatting FieldsType Formatting dialog boxIDREF="AReference180"Formatting FieldsType Name field in Structure Browser Type Formatting boxIDREF="AReference181"Formatting Fieldsunalias Debugger commandIDREF="AReference288"Debugger Command Lineundisplay Debugger commandIDREF="AReference289"Debugger Command Lineup Debugger commandIDREF="AReference290"Debugger Command Lineupdating view dataIDREF="1GStartDebug31"Updating and Saving Viewsuse Debugger commandIDREF="AReference291"Debugger Command LineusingInterpreterIDREF="7TutF+C1"Debugging with Fix+Continue: A Tutorialusing the X/Motif analyzerIDREF="1GStartDebug54"Using the X/Motif AnalyzerVariable BrowserIDREF="1GStartDebug18"Inspecting Debugger DataIDREF="3TutGen21"Examining Datageneral descriptionIDREF="AReference188"Variable BrowservariablesassignmentIDREF="6ExmnData12"Assigning Values to Variablesview changes in DebuggerIDREF="AReference228"Changes to Debugger Viewsview dataIDREF="1GStartDebug31"Updating and Saving ViewsView menuIDREF="AReference220"View MenuView submenuIDREF="AReference66"View Submenuview, call stackIDREF="AReference231"Call Stackviewing statusIDREF="7TutF+C14"Viewing StatusviewsDebuggerIDREF="AReference187"Formatting FieldsViews menu in Main ViewIDREF="AReference15"Views Menuwatch commandIDREF="3TutGen9"Setting Trapswatch trap Debugger command optionIDREF="4Traps25"Setting Single-process and Multiprocess Traps in the Trap: FieldwatchpointIDREF="3TutGen11"Setting TrapswatchpointsIDREF="1GStartDebug13"Setting Trapswhatis Debugger commandIDREF="AReference292"Debugger Command Linewhen at Debugger commandIDREF="AReference293"Debugger Command Linewhen in Debugger commandIDREF="AReference294"Debugger Command Linewhere Debugger commandIDREF="AReference296"Debugger Command Linewhich Debugger commandIDREF="AReference295"Debugger Command Linewidget class examinerIDREF="AReference113"Widget Class Examinerwidget class menu itemIDREF="AReference90"Examine Menuwidget classes, examiningIDREF="10TutCvmotif12"Setting Callback Breakpointswidget examinerIDREF="AReference106"Widget Examinerwidget hierarchyIDREF="10TutCvmotif9"Navigating the Widget Structurewidget itemIDREF="AReference88"Examine Menuwidget structure, navigatingIDREF="10TutCvmotif7"Navigating the Widget Structurewidget tree menu itemIDREF="AReference89"Examine Menuwidgets, examiningIDREF="10TutCvmotif10"Examining Widgetswindow attributes, viewingIDREF="10TutCvmotif15"Setting Callback Breakpointswindow examinerIDREF="AReference109"Window ExaminerIDREF="10TutCvmotif15"Setting Callback Breakpointswindow menu itemexamine menuwindowIDREF="AReference91"Examine MenuWorkShop integrationIDREF="1GStartDebug41"Fix and Continue/WorkShop IntegrationX event menu itemIDREF="AReference92"Examine MenuX graphics context menu itemIDREF="AReference93"Examine MenuX Pixmap menu itemIDREF="AReference94"Examine MenuX-event breakpoints examinerIDREF="AReference104"X-Event Breakpoints ExaminerX/Motif analyerlaunchingIDREF="1GStartDebug52"Debugging with the X/Motif AnalyzerX/Motif analyzeradditional featuresIDREF="10TutCvmotif16"Using Additional Features of the Analyzerdefault viewIDREF="10TutCvmotif8"Navigating the Widget StructureexitingIDREF="10TutCvmotif19"Ending the SessionlaunchingIDREF="10TutCvmotif6"Launching the X/Motif Analyzernavigating widget structureIDREF="10TutCvmotif7"Navigating the Widget Structurerestrictions and limitationsIDREF="1GStartDebug57"Restrictions and Limitationssample sessionIDREF="10TutCvmotif1"Using the X/Motif Analyzer: A TutorialstartingIDREF="1GStartDebug52"Debugging with the X/Motif AnalyzerusingIDREF="1GStartDebug54"Using the X/Motif Analyzer