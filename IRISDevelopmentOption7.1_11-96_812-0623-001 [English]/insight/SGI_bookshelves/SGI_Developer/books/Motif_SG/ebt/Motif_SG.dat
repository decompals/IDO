#EDIR DATA#
LANG="C"OSF/Motif Style GuideRevision 1.2 (For OSF/Motif Release 1.2)Copyright  1989, 1990, 1992 Open  Software  Foundation, Inc.Copyright  1989 Digital Equipment Corporation.Copyright   1987,  1988,  1989,  1992   Hewlett-Packard Company.Copyright  1988 Massachusetts Institute of Technology.Copyright  1988 Microsoft Corporation.ALL RIGHTS RESERVED The  information  contained  within  these documents is subject to change without notice.OSF MAKES NO WARRANTY OF ANY KIND WITH REGARD  TO  THIS MATERIAL,  INCLUDING,  BUT  NOT LIMITED TO, THE IMPLIED WARRANTIES  OF  MERCHANTABILITY  AND  FITNESS   FOR   A PARTICULAR PURPOSE.OSF shall not be liable for errors contained herein  or for incidental consequential damages in connection with the furnishing, performance, or use of this material.All rights are reserved.  No part of these publications may  be  photocopied,  reproduced,  or  translated into another language without the prior written  consent  of the Open Software Foundation, Inc. THIS  DOCUMENT  AND THE  SOFTWARE DESCRIBED  HEREIN ARE  FURNISHED UNDER  A LICENSE, AND MAY  BE USED AND COPIED ONLY IN ACCORDANCE WITH  THE TERMS OF  SUCH LICENSE AND  WITH THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE. TITLE TO AND OWNERSHIP  OF THE  DOCUMENT AND  SOFTWARE REMAIN WITH OSF OR ITS LICENSORS.FOR   U.S.   GOVERNMENT   CUSTOMERS   REGARDING    THIS DOCUMENTATION AND THE ASSOCIATED SOFTWAREThese notices shall be marked on  any  reproduction  of data, in whole or in part.NOTICE: Notwithstanding any other lease or license that may  pertain  to,  or  accompany  the delivery of, this computer  software,  the  rights  of   the   Government regarding  its  use, reproduction and disclosure are as set  forth  in  Section  52.227-19  of  FARS   Computer Software-Restricted Rights clause.RESTRICTED  RIGHTS   NOTICE:   Use,   duplication,   or disclosure by the Government is subject to restrictions as set forth in subparagraph (c)(1)(ii) of  the  Rights in Technical Data and Computer Software clause of DFARS 52.227-7013.ID="18097"PrefaceThe OSF/Motif Style Guide provides a framework of behavior specifications to guide application developers, widget developers, user interface system developers, and window manager developers in the design and implementation of new products consistent with the OSF/Motifname='tm' font=symbol charset=fontspecific code=212
	descr='[trademarkserif]' user interface.  This OSF/Motif Style Guide is also closely consistent with Microsoft Windows, Presentation Manager, and Common User Access (CUA).  The OSF/Motif Style Guide establishes a consistent behavior among new products by drawing out the common elements from a variety of current behavioral models.  The OSF/Motif Style Guide anticipates the evolution of graphical user interfaces as new technology becomes available and as the use of the Motifname='tm' font=symbol charset=fontspecific code=212
	descr='[trademarkserif]' user interface spreads.  Behavioral guidelines will be added over time as they become stable.  For specific details of coding the implementation into an application program, widget, or window manager, see the other volumes of the OSF/Motif documentation set.  LBL="" HELPID=""AudienceThis document is written for four audiences.  The following text suggests the sections in this guide that are relevant to each audience.  We recommend that you read through the entire OSF/Motif Style Guide once to familiarize yourself with all user interface design concepts and to ensure that you do not miss anything.  Application Designers Should be familiar with the contents of Chapter 1, Chapter 6,  Chapter 8,  Appendix A and Appendix B.Widget Designers Should be familiar with the contents of Chapter 1 through Chapter 6, Chapter 8, Chapter 9, Appendix A and Appendix B.User Interface System Designers Should be familiar with the entire contents of this guide.  Window Manager Designers Should be familiar with the contents of Chapter 1, Chapter 6, Chapter 7,  Chapter 8, and Appendix A.LBL="" HELPID=""ApplicabilityThis is Revision 1.2 of this document.  It applies to Release 1.2 of the OSF/Motif software system.  LBL="" HELPID=""PurposeThe purpose of this guide is to explain how to create OSF/Motif compliant applications, window managers, controls, and systems.  LBL="" HELPID=""Document UsageThis document is organized into nine chapters and two appendixes.  IDREF="13056" TYPE="TITLE"Chapter 1, "User Interface Design Principles" provides general user interface design principles.  Everyone should read this chapter.  IDREF="16621" TYPE="TITLE"Chapter 2, "Input Models" describes the input model.  New widget designers and user interface system designers should read this chapter.  IDREF="31210" TYPE="TITLE"Chapter 3, "Navigation" describes the navigation model.  New widget designers and user interface system designers should read this chapter.  IDREF="12570" TYPE="TITLE"Chapter 4, "Selection" describes the selection model.  New widget designers and user interface system designers should read this chapter.  IDREF="15303" TYPE="TITLE"Chapter 5, "Component Activation" describes the activation model.  New widget designers and user interface system designers should read this chapter.  IDREF="20011" TYPE="TITLE"Chapter 6, "Application Design Principles" describes user interface component choices, layout, and interaction.  Everyone should read this chapter.  IDREF="24491" TYPE="TITLE"Chapter 7, "Window Manager Design Principles" describes window manager design.  Window manager designers and user interface system designers should read this chapter.  IDREF="38166" TYPE="TITLE"Chapter 8, "Designing for International Markets" introduces and briefly describes internationalization and localization concepts and issues as they relate to user interface design.  Everyone should read this chapter.  IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages" provides reference information for concepts described in earlier chapters, and provides detailed information about components.  This chapter should be read by new widget designers and can by used as a reference by everyone.IDREF="36096" TYPE="TITLE"Appendix A, "OSF/Motif Widgets and Components Correspondence" shows the correspondence between OSF/Motif widgets and components described in this guide.  IDREF="15733" TYPE="TITLE"Appendix B, "OSF/Motif Level One Certification Checklist" contains the Level One Certification Checklist, which is based on this guide.  LBL="" HELPID=""Related DocumentsFor additional information about OSF/Motif, refer to the following documents: The Application Enviroment Specification (AES) User Enviroment Volume defines a stable set of routines for creating user interface applications.  The OSF/Motif User's Guide explains how to interact with OSF/Motif based applications.  The OSF/Motif Programmer's Guide explains how to write applications using the OSF/Motif widget set.  The OSF/Motif Programmer's Reference provides detailed reference information for programmers writing Motif applications.  LBL="" HELPID=""Typographic and Keying ConventionsThis document uses the following typographic conventions: BoldBold words or characters represent system elements that you must use literally, such as commands, flags, and pathnames.  Bold words also indicate the first use of a term included in the glossary.  ItalicItalic words or characters represent variable values that you must supply.  < >Angle brackets enclose the name of a key on the keyboard.  Components of the user interface are represented by capital letters on each major word in the name of the component, such as PushButton.  See IDREF="31218" TYPE="TITLE""Compliance Conventions"
 later in this Preface for an explanation of the asterisks (*) that appear in the margins.  LBL="" HELPID=""Keyboard ConventionsSince not all keyboards are the same, it is difficult to give style guidelines that are correct for every manufacturer's keyboard.  To solve this problem, this guide describes keys using a model keyboard mechanism.  Wherever keyboard input is specified, the keys are indicated by the engraving they have on the OSF/Motif model keyboard.  The model keyboard does not correspond directly to any existing keyboard, rather it assumes a keyboard with an ideal set of keys.  In addition to the standard letter, number, and character keys, the OSF/Motif model keyboard is composed of the following special keys: The special printing characters </>,<\>,and <!>The standard modifier keys <Ctrl>,<Alt>,and <Shift> Ten function keys <F1> through <F10> The arrow keys <Down arrow>,<Left arrow>,<Right arrow>,and <Up arrow> <Backspace> <Cancel> <Delete><End><Escape><Help><Home>,<Begin>, or both <Insert><Menu><PageDown><PageUp><Return><Space><Tab>The OSF/Motif model keyboard also contains the following optional keys, which, although useful, are either not necessary or may be created by combinations of other keys: <CapsLock><Copy><Cut><Enter><ModeSwitch><NumLock><PageLeft><PageRight><Paste><ScrollLock><Select><Undo>Throughout this guide, behavior is described in terms of model keyboard keys.  When a behavior takes advantage of an optional key from the model keyboard, it is also described in terms of the required special keys.  Each of the keys described on the OSF/Motif model keyboard must be available either as specified or using other keys or key combinations if the specified key is unavailable.  A few of the more important alternative key bindings are described here for your convenience.  If <Cancel> does not exist, <Escape> can be used in its place.  If <Help> does not exist, <F1> can be used in its place.  If <Menu> does not exist, <Shift> <F10> can be used in its place.  If <F10> does not exist, <Shift> <Menu> can be used in its place.  If <Home> or <Begin> does not exist, <Alt> <Left arrow> can be used in its place.  If <End> does not exist, <Alt> <Right arrow> can be used in its place Wherever <Select> and <Space> can be used for a selection action, <Ctrl> <Space> can be used as well.  Wherever <Enter> and <Return> can be used for activation, <Ctrl> <Return> can be used as well.  LBL="" HELPID=""Mouse ConventionsMouse buttons are described in this guide using a virtual button mechanism to better describe behavior independent from the number of buttons on the mouse.  This guide assumes a 3-button mouse.  On a 3-button mouse, the leftmost mouse button is usually defined as BSelect, the middle mouse button is usually defined as BTransfer, and the rightmost mouse button is usually defined as BMenu.  Details about how virtual mouse buttons are usually defined are given in IDREF="28826" TYPE="TITLE"Section 2.2, "The Input Device Model."LBL="" HELPID=""ID="31218"Compliance ConventionsThroughout the guide "must," "should," and "can" have special meanings.  Guidelines with "must" in them are requirements for OSF/Motif Style Guide compliance.  Any guideline with "must" is included in the "OSF/Motif Level One Certification Checklist" for OSF/Motif Style Guide compliance.  Guidelines with "must" are marked in the margin with an asterisk (*).  Guidelines with "should" in them are recommendations.  We consider them important for interapplication consistency, but we do not require them for compliance.  You should follow them as closely as you are able.  Guidelines with "can" in them indicate optional elements of user interface style.  The process for how OSF/Motif Style Guide elements migrate from options to requirements is described in the "OSF/Motif Level One Certification Checklist" (see IDREF="15733" TYPE="TITLE"Appendix B, "OSF/Motif Level One Certification Checklist"
).  Note that by default this guide assumes your application is being designed for a left-to-right language direction environment, and that the application is written in English.  Many of these guidelines can, and in fact should, be modified based on both language and scanning direction.  LBL="" HELPID=""Style Guide Support Level ProcessAs of the 1.2 release, regions of this guide are designated with a support level.  This support level system, which closely parallels the current Application Enviroment Specification (AES) User Enviroment Volume support level system, specifies the commitment OSF makes to the guidelines in that region.  The higher the support level, the longer the warning period required before OSF can delete the guidelines, or make an incompatible change in the guidelines.  (An incompatible change is one that might require compliant applications to be rewritten.) Support levels, therefore, serve as advisories for application developers because they indicate the length of time that a guideline is guaranteed to remain stable.  During the OSF/Motif Style Guide development process, OSF staff members propose support levels for guidelines, based on criteria defined later in this Preface.  OSF members review and comment on these support levels and the rest of the document.  In general, membership review proceeds as follows: OSF prepares a list of proposed changes to the OSF/Motif Style Guide, and circulates it to OSF members.  This review period may last from one to several months.  Members submit comments.  OSF responds to members' comments in the next version of the document, or in a discussion that takes place in an electronic news group or at a meeting.  OSF considers all review comments during the development of the OSF/Motif Style Guide and brings important or controversial issues up for further discussion.  However, the review process is not a voting process, and OSF does not wait for consensus among the membership before adding new interfaces to the OSF/Motif Style Guide or making other technical decisions.  LBL="" HELPID=""AES Support LevelsThis section defines the support levels assigned to the guidelines.  As previously mentioned, support levels define OSF's commitment to interface definitions by indicating the warning period required to make an incompatible modification or deletion of the guideline.  New OSF/Motif Style Guide revisions may introduce upwardly compatible changes at any time, regardless of the support level.  The support levels are as follows: Full use Trial use The following sections explain each support level, and how guidelines move from proposed status (in drafts) to final status (in published versions).  LBL="" HELPID=""Full UseA full-use guideline has the highest support level, so it is the most protected from incompatible modification or deletion.  OSF assigns a support level of full use to guidelines for the following reasons: The guideline already exists in an approved de jure standard.  (A de jure standard is one that is set by an official standards body.) The guideline as specified in the OSF/Motif Style Guide is considered stable and already in widespread use in applications.  The guideline has been upgraded to full-use status after a period of trial-use status in an earlier OSF/Motif Style Guide revision.  There should rarely be a need to remove a full-use guideline, or make incompatible modifications to it.  However, if this ever becomes necessary, a full-use guideline keeps its full-use status, but we will publish a warning describing the proposed future change in at least two successive revisions of the OSF/Motif Style Guide before we make the change.  This provides time for applications to be altered to deal with a different guideline, and for implementations to prepare for the change.  For example, suppose it becomes necessary to modify a full-use guideline that appeared in Release 1.2 of the OSF/Motif Style Guide.  The draft for Release 1.3 shows the guideline as "proposed-for-modification/removal." Assuming the review concludes that this change is appropriate, the guideline in Release 1.3 still has full-use status, but is accompanied by a warning.  The warning states that the guideline is scheduled for modification after Release 1.4, and describes the modified behavior.  Application developers can now allow for either the original or the modified guideline.  Release 1.4 contains the same warning.  Release 1.5 provides the modified definition only.  LBL="" HELPID=""Trial UseA trial-use guideline is easier to modify or delete than a full-use guideline.  There are several reasons why OSF classifies guidelines as trial use instead of full use.  A guideline may be under consideration for inclusion in a de jure standard and so may possibly change as a result of the standards process.  Or, OSF may perceive that the guideline is new compared to other included guidelines and, therefore, the implementation and use of the guideline may suggest revisions in its definition.  If it becomes necessary to modify or delete a trial-use guideline, it keeps its trial-use status, with warnings about its removal or incompatible change, for one full revision of the OSF/Motif Style Guide.  In the preceding example, if the guideline to be modified were a trial-use guideline, Release 1.3 would include the unmodified definition with a warning and description of the change, and Release 1.4 would include the modified definition only.  LBL="" HELPID=""Proposed Usage LevelsDraft versions of the OSF/Motif Style Guide give newly added or changed guidelines a "proposed-for-level" status, where level is full- or trial-use.  In final versions, these guidelines move from "proposed-for-level" status to level status.   Most existing guidelines retain their support level from the previous revision.  A few may carry a proposed-for-change status (described as follows).  New guidelines carry a proposed-for-level status.  The following list defines more exactly the AES proposed-for-inclusion and proposed for-change levels.  Proposed-for-level-useA review level leading to level-use inclusion on acceptance, and no change in status otherwise.  This status may be used to propose a new guideline for level-use, or to move an existing guideline to a higher status.  Proposed-for-modification/removal  A review level for existing guidelines that OSF proposes to make an incompatible modification in or remove from the OSF/Motif Style Guide.  If this proposal is accepted during the review process, a full-use guideline remains as is, with a warning, for two revisions; a trial-use or temporary-use guideline remains as is with a warning, for one revision.  If the proposal is rejected, the guideline remains as is.  Proposed-for-correctionA review level for guidelines of any support level in which OSF wishes to correct a specification error.  OSF will propose correcting a guideline if a definition was obviously wrong (and implementations and applications could never follow the specification as it is written), if clarification of an unclear section is required, or if an error makes a definition clearly internally inconsistent or inappropriate.  Guidelines proposed for correction return to their original status, in corrected form, on acceptance of the correction. They return to their original status in uncorrected form on rejection of the correction.  (Proposal for correction is not required for OSF to fix a typographical error.) Proposed-for-enhancementA review level for guidelines in which OSF wants to make an upwardly compatible change in definition.  If accepted, the definition change is effective in the published revision after the draft in which the proposal for enhancement occurred.  LBL="1"ID="13056"User Interface Design PrinciplesA user interface is simply the interface between an application and the user of an application.  The primary goal of a user interface is to help user interface designers easily create applications that increase user effectiveness and satisfaction.  By following the guidelines presented in this ID="ch011"OSF/Motif Style Guide, you can create applications that are well designed and easy to use.  These guidelines pertain to all sorts of applications, from spreadsheets and word processors to CAD tools.  To be effective, a user interface allows a user to interact with an application simply and naturally.  Successful user interface designers keep the user in mind while designing an application.  Keep the user in mind by following these two principles: Know the user.  Empower the user.  The user of an application, above all, wants to get the job done.  A user interface needs to be designed so the user can quickly and easily complete the tasks.  Users want mastery over an application.  Make it simple for the user to master the basics of your application.  At the same time, you can include advanced methods of interaction with the application, shortcuts for the user.  Users are curious and exploratory.  They will find these shortcuts as they use and master the application.  Such shortcuts need not be as intuitive as the regular methods of interaction.  This chapter discusses the following guidelines for creating user interfaces that are consistent and easy to use.  Because of the particular nature of your client application, component, or window manager, or in response to customers' needs, you may not be able to apply all of these principles all of the time.  Adopt the user's perspective.  Give the user control.  Use real-world metaphors.  Keep interfaces natural.  Keep interfaces consistent.  Communicate application actions to the user.  Avoid common design pitfalls.  LBL="1.1" HELPID=""Adopt the User's PerspectiveEffective design starts with adopting the user's point of view, which is often difficult to do.  Application designers tend to see an application as the implementation of functions.  In contrast, the user sees an application in terms of its interface.  Good design is rooted in an understanding of the user's work.  A well-designed application solves users' problems, makes their work easier, and offers them new capabilities.  The two most effective ways to understand the user's work are to involve users in the design and to be a user yourself.  Input from users can help determine both appropriate functions and methods for presenting them.  Involve users as early as possible in the design process because, as the design progresses and the schedule closes in, the possibilities for design change decrease.  ID="ch012"You do not need a working prototype to involve users.  In fact, you can even involve users while you are writing specifications.  At this stage, you can watch users work in order to understand the environment in which your application will be used.  Talk to these users about their work, their current tools, and their goals for new tools.  For example, if you are designing software to create and display charts and graphs during meetings, you might attend meetings at various customer sites, see how charts and graphs are currently used in meetings, and interview meeting participants to learn what they would like to see in a new tool.  Once you have a working prototype of your application, invite users to test it to see if your interface meets the goals you established for it.  Try to use your application in real situations.  Using an application can provide critical insights into user interface problems.  Acquiring experience with the application can be difficult and time consuming, but it is a worthwhile exercise.  Before you even create the interface for your application, you can use similar applications, even competitive products, to help you understand the user's tasks.  LBL="1.2" HELPID=""Give the User ControlUsers want and need to be in control of the tools they use to perform their work.  The user can be in control when an application is flexible and uses progressive disclosure.  LBL="1.2.1" HELPID=""Keep Interfaces FlexibleID="ch013"Providing multiple ways for users to access application functions and accomplish their tasks increases their sense of control.  Flexibility enables users to select the best method of accessing a function based on the criteria they choose: experience level, personal preference, unique situation, or simply habit.  For example, a user can access a function through a Pulldown Menu, direct manipulation of an object, a mnemonic key press, or a keyboardaccelerator.  Your application should also be configurable.  Allowing users to configure settings and select personal preferences enhances their sense of control and encourages them to take an active role in understanding your product and how it works.  To be effective, the configurability of your application needs to be easily accessible.  LBL="1.2.2" HELPID=""Use Progressive DisclosureID="ch014"ID="ch015"Design your application so that the necessary and common functions are presented first and in a logical order.  Make the more sophisticated and less frequently used functions hidden from immediate view, but still available.  For example, use a DialogBox to hide settings that are not accessed often.  Decisions about the placement of functions are not easy to make.  From the implementation standpoint, all functions are important.  Often, however, a relatively small number of functions account for the majority of use.  Make sure that these important functions are prominently featured in the presentation of the interface.  Also remember that they can be prominent only if other functions are hidden.  LBL="1.3" HELPID=""Use Real-World MetaphorsID="ch016"ID="ch017"A good user interface allows the user to transfer skills from real-world experiences.  For example, PushButtons push, and Scales slide.  This makes it easier for the user to infer how to use an application.  When you design a new component, consider how a similar real-world control performs to incorporate the metaphor into the new component.  Real-world metaphors can extend to groups of components as well, especially when making a computer-based user interface to replace a mechanical user interface.  LBL="1.3.1" HELPID=""Allow Direct ManipulationID="ch018"ID="ch019"Users need to be able to directly manipulate elements of the user interface and their applications.  For example, the user needs to be able to directly scroll Text with a ScrollBar, rather than using a keyboard-driven command.  Direct manipulation simulates the real world where the user employs tools to perform tasks on physical objects.  Users control applications by directly manipulating graphical components similar to real-world controls, rather than entering a command on a command line.  Direct manipulation reduces the amount of information the user needs to memorize.  Direct manipulation connects an action to an observable response from a component.  Using direct manipulation, the user gets an immediate visible result from each action.  ID="ch0110"ID="ch0111"The direct manipulation model is an object-action model.  That is, you first select an object or group of objects, then you perform an action on the selected objects.  An object-action model allows the user to see what elements will be acted on before performing an action.  It also allows multiple actions to be performed successively on the selected elements.  Although it is important to allow direct manipulation of the objects in your application, you must also support methods for interacting with your application by keyboard-only users.  These methods can also be used by advanced users to perform some tasks more quickly.  LBL="1.3.2" HELPID=""Provide Rapid ResponseID="ch0112"ID="ch0113"Make your application respond to input as rapidly as possible.  The immediacy of the visual response is crucial to the experience of direct manipulation.  When using components, provide the application's response immediately and in proportion to the component's actions.  The application must also have a consistent speed of response.  Delays, disproportionate responses, or inconsistent responses can render an otherwise well-designed application unusable.  Performance problems make it difficult for the user to concentrate on the task at hand.  LBL="1.3.3" HELPID=""Provide Output as InputAnother feature of direct manipulation is that the output of one part of an application or the output of the application itself is also available as input.  For example, if one action produces a list of filenames, another action can select them for use elsewhere.  The user manipulates objects by locating them and clicking on them rather than typing in their names.  Design so that the only time the user needs to type a name is to create an object. A well-designed application reduces the amount of information the user needs to memorize to perform tasks.  LBL="1.4" HELPID=""Keep Interfaces NaturalYou can extend the concepts of giving the user control and using real-world metaphors to arrange your application so that tasks flow naturally.  Users need to be able to anticipate the natural progression of each task; through this anticipation, they are able to complete tasks more quickly.  Each screen object needs to have a distinct appearance that the user can easily recognize and quickly understand.  At the same time, the style of the interface needs to graphically unify these elements and ensure a consistent and attractive appearance at any screen resolution.  LBL="1.4.1" HELPID=""Make Navigation EasyID="ch0114"Make navigation easy by providing a straightforward presentation of the overall work area and the mechanisms for moving through it.  Moving easily and quickly within the work area gives the user a sense of mastery over the application.  For example, ScrollBars are an effective way to indicate the position of the current view in relation to an area as a whole.  In addition to providing positional feedback, ScrollBars allow the user to move through the area.  Arrange elements on the screen according to their use; an optimal arrangement assists the user's decision-making processes and reduces the possibility of errors.  The best approach for arranging screen elements according to use is to involve users in the arrangement process.  Present screen objects in an orderly, simple, and uncluttered manner.  Reduce mouse movement to simplify the actions of the user.  For example, place secondary DialogBoxes near their parent DialogBox so that when the secondary DialogBox appears, the mouse pointer is over the default PushButton, unless the user needs to see the contents of the original DialogBox.  Reducing mouse movement helps make an interface natural because, from the user's point of view, work involves a stream of thoughts, intentions, and tasks (some predefined and some that become apparent during the process) that all relate to some desired outcome or accomplishment.  This stream of thought is disrupted when the user has to make unnecessary mouse movements, open and close DialogBoxes, or search for commands.  LBL="1.4.2" HELPID=""Provide Natural Shades and ColorsID="ch0115"ID="ch0116"Minimize the contrast between screen objects in order to direct the user's attention.  Appropriate use of contrast helps the user distinguish screen objects against the background of a window.  Very dark screen objects on a light background, very bright objects on a dark background, and bright colors all command the user's attention.  If there are many objects with strong contrast or bright colors on the screen, the user will have difficulty knowing where to look first because all these objects compete equally for attention.  Use color as a redundant aspect of the interface; that is, use it to provide additional differentiation among screen objects.  Differentiation also comes from the shape and size of the screen objects.  For example, in many parts of the world, stop signs are red octagons. You recognize the stop sign by both its shape and color.  LBL="1.5" HELPID=""Keep Interfaces ConsistentID="ch0117"The main purpose of the OSF/Motif Style Guide is to ensure consistency.  Consistency is important both among applications and within a single application.  Consistency helps the user transfer familiar skills to new situations.  The user can apply the knowledge learned from one application to another application, reducing the amount of learning and subsequent recall.  Consistency within applications facilitates exploration of new functions.  When components work in a manner that is consistent with other components, the user will be less afraid to try new functions.  The new functions will seem familiar, comfortable, and appropriate.  The guidelines in the OSF/Motif Style Guide allow you to create applications that are consistent in a diverse market and that help your applications succeed in the marketplace.  ID="ch0118"ID="ch0119"Intraapplication consistency means the following: Similar components operate similarly and have similar uses.  For example, because Pulldown, Popup, and Option Menus are similar components, their operation and use should be similar.  Choosing the proper component is described in IDREF="34542" TYPE="TITLE"Section 6.1, "Choosing Components."
 Component interaction is described in the reference section for each component and also in IDREF="26054" TYPE="TITLE"Section 6.3, "Interaction."The same action should always have the same result.  For example, pushing the top arrow in a ScrollBar should always move the ScrollBar up.  Interaction is described in IDREF="26054" TYPE="TITLE"Section 6.3, "Interaction."The function of components should not change based on context.  For example, clicking a button should always perform the same action.  Note that even though the action is the same, the result of the action can depend on context.  A button in a file editor can begin editing one of a number of files.  The button need not always edit the same file; rather, its consistent action is to edit the selected file.  Interaction is described in IDREF="26054" TYPE="TITLE"Section 6.3, "Interaction."The position of components should not change based on context.  Components should not generally be added and removed as needed.  This makes it difficult to quickly find the desired component.  Instead, you should make unneeded components nonfunctional and indicate this by deemphasizing (graying out) their labels.  Component layout is described in IDREF="22928" TYPE="TITLE"Section 6.2, "Layout."The position of the mouse pointer should not warp.  The location of the mouse pointer should be determined by direct manipulation and should not be positioned arbitrarily by the application.  Positioning the mouse pointer by the application causes the user to lose track of the pointer.  Warping the pointer also causes problems with tablet style pointing devices that rely on absolute pointer positioning.  The input model is described in IDREF="16621" TYPE="TITLE"Chapter 2, "Input Models."Consistency among applications increases the user's sense of mastery.  Experience with one application can be readily applied to another application, creating a positive transfer of knowledge.  The task at hand, rather than learning a new application, becomes the focus of a computer session.  When applications work in a manner that is consistent with other applications, users enjoy a feeling of immediate confidence in their ability to master the new program.  Also, they are pleasantly surprised when trying new functions because, although new, the functions seem familiar.  ID="ch0120"ID="ch0121"Interapplication consistency means the following: Components look familiar.  This does not mean that components look exactly the same, but that the internal layout of components should be the same.  Elements of appearance such as color, size, and thickness of beveled edges are less important to application interoperability.  Component design and layout are described in the reference section for each component and also in IDREF="24980" TYPE="TITLE"Section 6.4, "Component Design."Interaction is familiar.  When interaction is different among applications, it confuses the user and makes it difficult to concentrate on the task of the application.  This applies to the behavior of components, input methods, selection models, and keyboard navigation.  Interaction is described in IDREF="26054" TYPE="TITLE"Section 6.3, "Interaction."Components are organized in a familiar manner.  The user needs to be able to quickly find the proper component for each task.  Organizing the components according to consistent guidelines helps the user do this.  Application layout guidelines are described in IDREF="22928" TYPE="TITLE"Section 6.2, "Layout."LBL="1.6" HELPID=""Communicate Application Actions to the UserEffective applications let the user know what is happening with the application, but without revealing implementation details.  Proper communication between the user and the application increases user satisfaction.  There are three guidelines for communicating from the application to the user: provide feedback, anticipate errors, and provide warnings.  LBL="1.6.1" HELPID=""Give the User FeedbackID="ch0122"Feedback lets users know that the computer has received their input.  Give users feedback whenever they have selected a component or Menu item by highlighting the component or Menu item in some way.  In addition, if certain operations take more than a few seconds, you should let the user know that the computer is working on that operation by providing a message or by changing the pointer to a working pointer.  LBL="1.6.2" HELPID=""Anticipate ErrorsID="ch0123"ID="ch0124"Anticipate the errors that are likely to occur.  By anticipating errors, you can avoid them in your design, enable the support of recovery attempts, and provide messages informing the user of the proper corrective action.  For example, one technique for avoiding excessive error messages is to dim interface components when they cannot be used.  ID="ch0125"ID="ch0126"Context-sensitive help aids understanding, reduces errors, and eases recovery efforts.  Help information text needs to be clear, concise, and written in everyday language.  Help information needs to be readily accessible and just as readily removable.  ID="ch0127"Many users are most comfortable with learning how to use software applications when they use a natural, trial-and-error method.  An undo function supports learning by trial and error by minimizing the cost of errors.  An undo function allows the user to retract previous actions, and fosters a spirit of exploration and experimentation that is essential.  LBL="1.6.3" HELPID=""Use Explicit DestructionID="ch0128"Explicit destruction means that, when an action has irreversible negative consequences, it should require the user to take an explicit action to perform it.  For example, while a worksheet can be saved simply by clicking on a Save PushButton, erasing the worksheet should require clicking on an Erase PushButton and answering a warning question like "Are you sure you want to erase this worksheet?" with a button click in the warning DialogBox.  ID="ch0129"Warnings protect the user from inadvertent destructive operations, yet allow the user to remain in control of the application.  Warnings also encourage the user to experiment without fear of loss.  Operations that can cause a serious or unrecoverable loss of data should warn the user of the consequences and request explicit confirmation.  LBL="1.7" HELPID=""Avoid Common Design PitfallsThe process of achieving good design presents many challenges and potential pitfalls.  The following guidelines can help you avoid common pitfalls: Pay attention to details.  The details of an application express the sense of craft that you applied to the application.  The details of an elegantly designed interface both please users and facilitate their work.  For example, aligning the PushButtons of two related and overlapping DialogBoxes makes it easier for the user to activate new settings in an apparently seamless operation.  Consistent capitalization of Menu items and DialogBox labels is a design detail that reduces textual distractions for the user.  Do not finish prematurely.  A common design pitfall is assuming too early that a design is complete.  This tendency is aggravated by schedule pressures and difficulty in pinpointing the inadequacies of a design.  While it is important to begin designing early, it is also important to allow for redesigning for as long as possible.  The first design of an application is not a solution but a fresh perspective from which to view interface design problems.  Design iteratively.  Interface design is best done iteratively.  The development cycle of implementation, feedback, evaluation, and change avoids errors by allowing for early recognition and correction of unproductive designs.  Start with a fresh perspective.  Avoid the temptation to convert existing software by simply translating it to a new style of interface.  Because direct manipulation changes the way the user works, a simple one-to-one translation is unlikely to be successful.  Command line applications that are converted to direct manipulation need to be extensively reconsidered and revised.  The structure of the function hierarchy and presentation needs to be completely redesigned.  Hide implementation details.  User interfaces need to hide the underlying software and present a consistent interface to the user.  A good user interface does not allow implementation details of the application to show through; it frees the user from focusing on the mechanics of an application.  LBL="2"ID="16621"Input ModelsConsistent models increase the user's sense of control of a system.  By implementing consistent models across systems and applications, you encourage that sense of control.  This chapter describes the models OSF/Motif uses to interact with the components: ID="ch021"ID="ch022"ID="ch023"ID="ch024"The keyboard focus model, which determines which component on the screen receives keyboard events.  The input device model, which describes how different input devices, such as the keyboard and the mouse, interact with applications.  The navigation, activation, and selection models, also important for system and application consistency, are described in IDREF="31210" TYPE="TITLE"Chapter 3, "Navigation,"IDREF="12570" TYPE="TITLE"Chapter 4, "Selection,"
 and IDREF="15303" TYPE="TITLE"Chapter 5, "Component Activation."LBL="2.1" HELPID=""ID="31977"The Keyboard Focus ModelID="ch025"ID="ch026"ID="ch027"ID="ch028"ID="ch029"ID="ch0210"ID="ch0211"ID="ch0212"ID="ch0213"ID="ch0214"ID="ch0215"ID="ch0216"ID="ch0217"ID="ch0218"ID="ch0219"A typical workspace can contain many windows.  Each window will receive input from the keyboard, the mouse, or both.  The window that receives keyboard events has the input focus.  Indeed, when keyboard input is directed to a window, it is actually received by some control within the window.  The keyboard focus  model determines which window in the workspace and which component within that window gets each keyboard input.  The keyboard focus may also be referred to as the input focus.  In order to avoid conflicts, the window manager must allow only one window to have the keyboard focus at a time.  The window with the keyboard focus must be highlighted in some way, usually by a change in shade or color to the window border.  Each application must allow only one component at a time to have the keyboard focus within the window that has the keyboard focus.  The keyboard focus model is defined by a focus policy.  A focus policy is a specific mechanism for moving the focus among windows and components.  The focus policy can be different between windows than it is within windows.  This section only attempts to describe the focus policies; however, their impact on window managers, applications, and components is described in detail where it applies.  It is sufficient at this point to note that window managers, applications, and new components must support both explicit and implicit focus policies.  IDREF="24491" TYPE="TITLE"Chapter 7, "Window Manager Design Principles"
 describes in detail how to move the focus among windows that use explicit and implicit focus policies.  LBL="2.1.1" HELPID=""Implicit FocusID="ch0220"ID="ch0221"ID="ch0222"ID="ch0223"ID="ch0224"ID="ch0225"ID="ch0226"ID="ch0227"ID="ch0228"ID="ch0229"ID="ch0230"ID="ch0231"In the implicit focus policy, the keyboard focus tracks the mouse pointer.  No explicit action (other than mouse motion) is performed to set the keyboard focus in the implicit focus model.  When an implicit focus policy is used at the window level, keyboard events are sent to the window that the mouse pointer is in.  When an implicit focus policy is used within a window, keyboard events are sent to the component that the mouse pointer is in.  In implicit mode, the keyboard focus tracks the mouse pointer.  Because of this, there is no way to move the keyboard focus from the keyboard using implicit mode.  Implicit focus is sometimes referred to as pointer, track pointer, or track listener policy, or as being real-estate driven.  In this focus policy, the location cursor for keyboard events does not need to be shown except in components like Text, in which keyboard input is common; however, the application can show it.  ID="ch0232"ID="ch0233"ID="ch0234"LBL="2.1.2" HELPID=""ID="37103"Explicit FocusID="ch0235"ID="ch0236"ID="ch0237"ID="ch0238"ID="ch0239"ID="ch0240"ID="ch0241"ID="ch0242"ID="ch0243"The explicit focus policy requires the user to explicitly select which window or component receives the keyboard focus.  In explicit focus mode at the window level, a user moves the keyboard focus to a window by pressing BSelect while the mouse pointer is over the window.  Simply moving the mouse pointer over a window does not give the window the keyboard focus.  Because of this, explicit mode is often called click-to-type.  In explicit mode within a window, a user generally moves the keyboard focus to a specific component within a window by pressing BSelect over the component.  Pressing BSelect must not move focus to a component that is not traversable or does not accept input.  Pressing BSelect in a component that is used only to change the visible portion of another component, such as a ScrollBar or Sash, should act on that component but should not move focus to it.  In this focus policy, the location of keyboard focus must be shown by a location cursor.  In explicit mode, focus can also be moved among windows by the keyboard using <Alt> <F6>,<Alt> <Tab>,<Alt> <Shift> <Tab>,and <Alt> <Shift> <F6>.ID="ch0244"ID="ch0245"ID="ch0246"In explicit mode, keyboard focus moves explicitly among the components in a window as well as among the windows.  Moving the keyboard focus among components in a window using the keyboard is called component navigation.  Keyboard events go to the component in the window with the keyboard focus.  Keyboard focus is moved among components using <Tab>,<Ctrl> <Tab>,<Shift> <Tab>,<Ctrl> <Shift> <Tab>,<F10>,<Menu>,<Down arrow>,<Left arrow>,<Right arrow>,and <Up arrow>.Internal window navigation is described in detail in IDREF="31210" TYPE="TITLE"Chapter 3, "Navigation."ID="ch0247"ID="ch0248"ID="ch0249"ID="ch0250"ID="ch0251"ID="ch0252"If the focus policy is implicit, an implementation can still enable keyboard-based operations that explicitly move the location cursor.  It must at least implement the special cases for Menu traversal as described in IDREF="31210" TYPE="TITLE"Chapter 3, "Navigation."<F10> (or <Shift> <Menu> if <F10> is not available) moves the cursor to the MenuBar.  <Menu> (or <Shift> <F10> if <Menu> is not available) pops up a Popup Menu.  LBL="2.2" HELPID=""ID="28826"The Input Device ModelID="ch0253"ID="ch0254"ID="ch0255"ID="ch0256"ID="ch0257"ID="ch0258"ID="ch0259"User interface applications can take input from both pointing devices and keyboards.  For whatever reason, a user may prefer to interact with an application by using either a keyboard or a pointing device.  Some users may even be restricted to using only a keyboard.  Because of these preferences and possible restrictions, all application functionality must be available from the keyboard alone.  Design your application so that the user can control it using a pointing device, the keyboard, or both.  Although you can decide to make the pointing device the primary means of control, you must provide the user with keyboard methods to control the application.  Designing applications for dual accessibility enables users to choose the input device they find best suited to their particular work situation and personal preferences.  Certain disabled users are unable to keep modifier keys pressed while typing another key.  Underlying window systems should provide a mode in which a typed modifier key acts as if it remains pressed until the next nonmodifier key is typed.  LBL="2.2.1" HELPID=""ID="42447"Pointing DevicesID="ch0260"ID="ch0261"ID="ch0262"ID="ch0263"ID="ch0264"ID="ch0265"ID="ch0266"ID="ch0267"ID="ch0268"ID="ch0269"A pointing device is a tool that lets the user move a pointer around on the screen.  A pointing device also has some means of activating the object under the pointer.  A pointing device allows the user to directly manipulate screen objects.  Rather than entering a keyboard command for each action, a user can point to an object and directly manipulate it using the pointing device.  The most typical pointing device is a mouse, although a graphics tablet, track ball, joystick, and other tools also work as pointing devices.  Throughout this guide we use the term mouse to refer to all pointing devices.  You can use any pointing device in place of a mouse.  With a mouse, objects on the screen can be manipulated by combining the mouse pointer with the mouse buttons.  This guide assumes that a mouse, or any pointing device, has three buttons: BSelect Used for selection, activation, and setting the location cursor.  This button must be the leftmost button, except for left-handed users where it can be the rightmost button.  BTransfer Used for moving and copying elements.  This button must be the middle mouse button, unless dragging is integrated with selection.  Details about the effects of integrating BTransfer with BSelect are described in IDREF="37315" TYPE="TITLE"Section 4.3.5, "Integrating Selection and Transfer."BMenu Used for popping up Menus.  This button must be the rightmost button, except for left-handed users, where it can be the leftmost button.  If your pointing device only has two buttons, BSelect still must be bound to the leftmost button.  There are a number of alternatives to properly binding BTransfer and BMenu: The mouse can be treated as a 3-button mouse if chording the two buttons is treated as the third button.  Chording buttons means to press, click, or release two or more buttons simultaneously.  The chorded buttons can be treated as the second or third button on a 3-button mouse, in which case the unchorded buttons are treated as the first and third, or first and second buttons, respectively.  Alternatively, ID="ch0270"ID="ch0271"BTransfer can be bound to the rightmost button, and BMenu is then bound to <Alt> BSelect.  Finally, BMenu can be bound to the rightmost button, and BTransfer is then integrated with the selection button.  As with a 3-button mouse, the actions of the rightmost and leftmost mouse buttons can be switched for left-handed users.  ID="ch0272"If your mouse has only one button, BSelect must be bound to it, BTransfer can be integrated with BSelect, and BMenu must be bound to <Alt> BSelect.  Mouse-based primary and quick transfer mechanisms are unavailable using a 1-button mouse.  ID="ch0273"If your mouse has more than three buttons, the first three correspond to those on a 3-button mouse.  ID="ch0274"ID="ch0275"ID="ch0276"ID="ch0277"ID="ch0278"ID="ch0279"ID="ch0280"Users can combine mouse button press and release actions along with mouse movements to activate elements of applications and components.  Various mouse button actions are described as follows, along with this guide's usage conventions: Press Indicates pressing a mouse button without releasing it.  This mouse action is often used to select an object for action.  This guide uses BSelect Press to indicate a press on the first mouse button.  Release Indicates releasing a mouse button after pressing it.  This mouse action is often used to perform the action initiated by a press or a drag.  This guide uses BSelect Release to indicate a release on the first mouse button.  Click Indicates pressing and releasing a mouse button without moving the pointer.  This mouse action is used to select an object or perform an action.  The activation action actually occurs on the release of the mouse button.  This guide uses BSelect Click to indicate a click on the first mouse button.  Motion Indicates pressing a mouse button without releasing it and then moving the position of the pointer.  The action of a drag operation tracks the position of the mouse pointer.  The drag action ends with a release action.  This mouse action is commonly used to select a range of objects, or move a selected object.  This guide uses BSelect Motion to indicate a drag using the first mouse button.  MultiClick Indicates a number of clicks in quick succession.  MultiClicks are often referred to by the actual number of clicks, as in double-click or triple-click.  A double-click is often used to perform the default action of an object.  This guide uses BSelect Click 2 to indicate a double-click on the first mouse button, BSelect Click 3 to indicate a triple-click, and so on.  This guide uses BSelect Click 2+ to indicate two or more clicks on the first mouse button.  MultiPress Indicates a number of clicks in quick succession without a final release.  As in MultiClick, MultiPresses are often referred to by the actual number of presses.  This guide uses BSelect Press 2 and the variations mentioned in MultiClick to indicate MultiPress actions on the first mouse button.  MultiMotion Indicates a MultiPress action followed by moving the position of the pointer.  The action of a MultiMotion operation tracks the position of the mouse pointer.  The MultiMotion action ends with a release action.  As in MultiClick, MultiMotions are often referred to by the actual number of presses.  This guide uses BSelect Motion 2 and the variations mentioned in MultiClick to indicate MultiMotion actions using the first mouse button.  LBL="2.2.2" HELPID=""ID="11954"Pointer ShapesID="ch0281"ID="ch0282"ID="ch0283"ID="ch0284"The shape of the mouse pointer provides the user with an important visual cue, indicating the functionality of the area in which the mouse pointer is currently located.  You should not create new mouse pointer shapes for functions that already have mouse pointer shapes associated with them, except for localization, but you can create new mouse pointer shapes for functions not already associated with a pointer shape.  You should not use a predefined shape to symbolize a function that it was not designed to represent.  ID="ch0285"ID="ch0286"ID="ch0287"A list of the defined pointer shapes follows, along with their usage and hotspots.  A pointer's hotspot is the actual position on the pointer that tracks the movements of the mouse.  As the pointer changes from one shape to another, the location of the hotspot must not move on the screen.  The hotspot is the precise location on the pointer where mouse actions occur.  LBL="2-1" FILE="arrowp.gif" POSITION="INLINE" SCALE="FALSE"ID="ch0288"ID="ch0289"LBL="2-1"Figure 2-1 
The upper-left pointing arrowThe upper-left pointing arrow pointer is a general-purpose pointer.  It is used in most window areas for single-object selection and activation.  The hotspot for the arrow pointer should be in the point of the arrow.  LBL="2-2" FILE="ibeamp.gif" POSITION="INLINE" SCALE="FALSE"LBL="2-2"Figure 2-2 
The I-beam pointerYou can optionally use an ID="ch0290"ID="ch0291"I-beam pointer in any Text component.  It is used to change the location of the text insertion cursor and to perform actions on text.  If the I-beam is used, it can be hidden during the time between any keyboard action and a mouse movement.  This helps the user distinguish the I-beam pointer from the text insertion cursor, which can also be an I-beam.  The hotspot for the I-beam pointer should be on the vertical bar of the I-beam about one-third up from the bottom.  LBL="2-3" FILE="xp.gif" POSITION="INLINE" SCALE="FALSE"LBL="2-3"Figure 2-3 
The X pointer The X pointer can indicate when the pointer is outside of any application area.  The hotspot for the X pointer should be where the lines intersect.  ID="ch0292"ID="ch0293"LBL="2-4" FILE="8sizep.gif" POSITION="INLINE" SCALE="FALSE"LBL="2-4"Figure 2-4 
The resize pointersThe resize pointers indicate positions for area resize, and they remain during a resize operation.  The direction of the arrow in the pointer indicates the direction of increasing size.  The horizontal and vertical pointers indicate resize in either the horizontal or vertical direction.  The diagonal pointers indicate resize in both the horizontal and vertical directions simultaneously.  The hotspot for the resizing pointers should be on the elbow or the line at the position pointed to by the arrow.  LBL="2-5" FILE="hourglas.gif" POSITION="INLINE" SCALE="FALSE"LBL="2-5"Figure 2-5 
The hourglass pointerThe hourglass pointer, a working pointer, indicates that an action is in progress in the area, and that the pointer has no effect in the area.  While the hourglass pointer is active, all mouse button and keyboard events are ignored in the area.  The hotspot for the hourglass pointer should be located at the center of the hourglass, although it should not be used for activation.  The hourglass pointer can be used interchangeably with the watch pointer.  LBL="2-6" FILE="watchp.gif" POSITION="INLINE" SCALE="FALSE"LBL="2-6"Figure 2-6 
The watch pointerThe watch pointer, a working pointer, indicates that an action is in progress in the area, and that the pointer has no effect in the area.  While the watch pointer is active, all mouse button and keyboard events are ignored in the area.  The hotspot for the watch pointer should be located at the top of the watch, although it should not be used for activation.  The watch pointer can be used interchangeably with the hourglass pointer.  LBL="2-7" FILE="movingp.gif" POSITION="INLINE" SCALE="FALSE"LBL="2-7"Figure 2-7 
The 4-directional arrow pointer The 4-directional arrow pointer indicates a move operation is in progress, or a resize operation before the resize direction has been determined.  During a move operation, the object, or an outline of the object should move to track the location of the pointer.  During a resize operation, the pointer is used to indicate a direction for resizing.  The 4-directional arrow pointer should change to the appropriate resize arrow when the resize direction is determined, either by crossing an object boundary with the pointer or by pressing a keyboard direction key.  The hotspot for the 4-directional arrow pointer should be at the spot where the arrows intersect.  ID="ch0294"ID="ch0295"ID="ch0296"LBL="2-8" FILE="sightp.gif" POSITION="INLINE" SCALE="FALSE"LBL="2-8"Figure 2-8 
The sighting ponterThe sighting pointer is used to make fine position selections.  For example, in a drawing program it can be used to indicate a pixel to fill or the connecting points of lines.  The hotspot for the sighting pointer should be at the spot where the lines intersect.  ID="ch0297"ID="ch0298"LBL="2-9" FILE="cautionp.gif" POSITION="INLINE" SCALE="FALSE"LBL="2-9"Figure 2-9 
The caution pointerThe caution pointer is used to indicate that action is expected in another area before input can be given to the current area, and that the pointer has no effect in the area.  While the caution pointer is active, all mouse button and keyboard events are ignored in the area.  The hotspot for the caution pointer should be located at the center of the caution symbol, although it should not be used for activation.  LBL="2-10" FILE="questp.gif" POSITION="INLINE" SCALE="FALSE"LBL="2-10"Figure 2-10 
The question pointerThe question pointer is used to request an input position or component from the user.  This is often used to input an object for interactive help.  The user requests interactive help, then the question pointer is displayed to allow the user to indicate what position or component help is requested for.  The hotspot for the question pointer should be at the bottom of the question mark.  LBL="2-11" FILE="menuarro.gif" POSITION="INLINE" SCALE="FALSE"LBL="2-11"Figure 2-11 
The upper-right arrow pointer You can optionally use an arrow pointing to the upper-right corner to indicate a pending Menu action.  This shape indicates that a Menu is popped up or pulled down and waiting for a Menu item to be activated or the Menu to be removed.  The hotspot for this arrow pointer should be in the point of the arrow.  ID="ch0299"If you need to design a new mouse pointer shape, keep the following in mind: The shape of the pointer should give a hint to its purpose.  The hotspot should be easy to locate, and obvious.  The shape should be easy to see.  The shape should not create visual clutter.  LBL="2.2.3" HELPID=""Gain and AccelerationID="ch02100"ID="ch02101"The details of how the pointer tracks the motion of the mouse are not handled at the level of the application, but they are worth noting here.  There are two concepts that define how the pointer tracks the motion of the mouse: gain and acceleration.  ID="ch02102"ID="ch02103"Gain refers to the ratio of the distance the pointer moves to the distance the mouse moves.  If the gain is increased, the mouse pointer moves farther for a given mouse movement.  The gain should not change across the environment.  Instead, if your application requires finer motion, it should include a zoom feature.  A zoom feature changes the relative size of an area of your application.  Zooming in on an area allows the user to make finer adjustments than normal.  Zooming out from an area allows the user to move through the application more quickly.  ID="ch02104"ID="ch02105"Acceleration is a temporary change in the gain.  It is commonly used to change the gain, based on the speed of the mouse movements.  The acceleration could be set so that, if the mouse moves slowly, the gain is reduced to allow for finer adjustments of pointer position or, if the mouse moves quickly, the gain is increased to allow quicker screen movement.  This can be very confusing to new users.  Gain and acceleration are handled on a global scale in the system, outside of the application.  Applications should not change the gain and acceleration characteristics of mouse movement.  LBL="2.2.4" HELPID=""ID="30055"Warp Pointer Only If Explicitly EnabledID="ch02106"ID="ch02107"The pointer position is intended only as input to applications.  It is not intended as an output mechanism for applications.  Changing the location of the mouse pointer is known as warping the pointer.  Your application must not warp the pointer, unless you provide the user with a means of disabling this behavior.  Warping the pointer is confusing to users, and reduces their sense of control.  Also, warping the pointer can cause problems for users of absolute location pointing devices (like graphics tablets).  Graphics tablets map pointer device locations to absolute screen locations; so, if the pointer is warped, the pointer loses synchronization with the pointing device, making some screen locations impossible to reach.  Note that for these types of devices, accelerating the pointer has the same effect as warping the pointer, but this can be handled by the pointer driver software.  LBL="3"ID="31210"NavigationRegardless of whether they use a mouse, a keyboard, or both, users need to move the location cursor to new positions.  That is, they will need to navigate around the workspace.  The model is simple for mouse users, and more complicated for keyboard users.  This chapter describes the general navigation model for mouse and keyboard users, describes the more complicated Menu navigation model, and then describes navigation within scrollable components.  ID="ch031"ID="ch032"ID="ch033"ID="ch034"ID="ch035"ID="ch036"ID="ch037"ID="ch038"ID="ch039"LBL="3.1" HELPID=""ID="26768"Mouse-Based NavigationID="ch0310"ID="ch0311"In mouse-based navigation, the mouse is used to move the focus among controls.  If an implicit focus policy is in use, the keyboard focus simply follows the mouse pointer, and no other explicit action is required to change the focus.  With an explicit focus policy, pressing BSelect on a component must move focus to it, except for components that are used to adjust the size and location of other elements, such as ScrollBars.  Pressing BSelect on these components need not move the focus.  If not, after the mouse has acted on the component, the focus should remain on the component that previously had it.  Pressing BSelect will also generally perform some selection or activation operation.  Clicking <Ctrl> BSelect on an activatable component can move focus to it without any other effect.  ID="ch0312"ID="ch0313"ID="ch0314"ID="ch0315"ID="ch0316"ID="ch0317"ID="ch0318"ID="ch0319"The only exception to the simple model of pointer navigation is a Menu system because Menus are not available on the screen until activated.  Activating a Menu causes it to be shown on the screen.  There are three types of Menus:  Pulldown Menus, Popup Menus, and Option Menus.  The MenuBar is also a special kind of Menu.  A Menu system consists of all the Menus cascading from a single CascadeButton, OptionButton, or Popup Menu.  The MenuBar system consists of the MenuBar and all of its associated Menus.  A Pulldown Menu is generally activated by pressing BSelect on a CascadeButton, which displays the Pulldown Menu.  A Popup Menu is generally activated by pressing BMenu in an area with a Popup Menu, which displays the Popup Menu.  An Option Menu is generally activated by pressing BSelect on an OptionButton, which displays the Option Menu.  A Pulldown Menu pulled down from a CascadeButton within a Pulldown, Popup, or Option Menu is called a Cascade Menu.  A MenuBar is generally activated by moving the input focus to the MenuBar.  Since a MenuBar is always visible, activating the MenuBar does not change its appearance.  Navigating to a Menu is equivalent to activating a Menu.  Menus are activated in one of two ways: spring-loaded or posted.  Spring-loaded means that the Menu is removed when the mouse button that activated it is released.  Posted means that the Menu is not removed when the mouse button that activated it is released, but must be explicitly removed by another user action.  BSelect Press with the pointer on a Menu must activate the Menu in a spring-loaded manner.  If the pointer is in an element with an inactive Popup Menu and the context of the element allows a Popup Menu to be displayed, BMenu Press must post (activate) the Menu in a spring-loaded manner.  Note that the availability and contents of the Popup Menu can depend on the location of the pointer within the element, the contents of the element, or the selection state of the element.  In the case where a Popup Menu can be posted by both an element and an element contained within it, the Popup Menu of the internal element must be posted.  Once a Popup Menu is posted, BMenu must behave just as BSelect is described for any Menu system.  BSelect must also be available from within a posted Popup Menu system, and must behave just as in any Menu system.  BSelect Release within a spring-loaded Menu system must activate the button under the pointer at the time of the release.  If the release is on a CascadeButton or OptionButton and the associated Cascade Menu was already posted at the time BSelect was pressed, it should be unposted; otherwise, the associated Cascade Menu must be posted.  Whenever any Menu is popped up or pulled down, the location cursor must be placed on the Menu's default entry, or on the first entry in the Menu if there is no default entry.  Support for default entries in Menus is optional.  A spring-loaded Menu must be removed when the mouse button that activated it is released, except when the button is released on a CascadeButton in the Menu hierarchy.  While a spring-loaded Menu system is popped up or pulled down, moving the pointer within the Menu system must move the location cursor to track the pointer.  If the pointer rests on a CascadeButton, the Menu must be pulled down and must also become traversable.  The Menu must be removed, possibly after a short delay, once the pointer moves to a Menu item outside of the Menu or its CascadeButton.  If the Menu system is part of a MenuBar, moving the pointer to any other element on the MenuBar must unpost the current Menu system and post the Pulldown Menu associated with the new element.  Releasing the button must activate any component in the Menu system, including a CascadeButton.  Note that releasing the mouse button during a spring-loaded Menu operation in a CascadeButton, even a CascadeButton in the MenuBar, causes the associated Menu to remain posted.  BMenu Click with the pointer in an area with a Popup Menu that was not previously posted must activate the Menu in a posted manner.  BMenu Release with the pointer in an area with a Popup Menu that was posted prior to the associated BMenu Press should unpost the Menu.  A posted Menu remains visible until explicitly unposted.  The keyboard focus model is forced to explicit, and the Menu system can be traversed using the keyboard as described later in this section.  If a mouse button is pressed outside of the Menu to unpost the Menu, the button press can also be treated as follows: The button press can have no effect other than to unpost the Menu.  The button press can be passed to the underlying component, either always or only if some condition is met.  For example, it can be passed to the underlying component only if the component is in the same window as the Menu system.  Whether or not the button press is passed to the underlying component, it can have some other effect.  For example, it can raise and give focus to the underlying window.  If the button press that unposts a Menu is not also passed to the underlying component, subsequent events up to and including the button release must not be passed to the underlying component.  Once a Pulldown or Option Menu is posted, BSelect Press in the Menu system must cause the Menu to behave as a spring-loaded Menu.  Once a Popup Menu is posted, BSelect Press or BMenu Press in the Menu system must cause the Menu to behave as a spring-loaded Menu.  Because of this, the pointer-driven activation behavior of spring-loaded Menus fully describes pointer-driven activation behavior in Menus.  LBL="3.2" HELPID=""Keyboard-Based NavigationID="ch0320"ID="ch0321"The navigation model for keyboard users is more complicated than the pointer navigation model.  As described earlier, keyboard navigation is only required when the focus policy is explicit.  Since window managers, applications, and components must support the explicit focus policy, they must also support keyboard navigation.  The keyboard navigation model is composed of the following: A focus identifier (the location cursor) Navigating among windows Navigating within windows LBL="3.2.1" HELPID=""ID="18305"Location CursorID="ch0322"ID="ch0323"ID="ch0324"The window with the focus is identified by highlighting the window border as described in IDREF="24491" TYPE="TITLE"Chapter 7, "Window Manager Design Principles."
  Within the window with the focus, the component with the keyboard focus is identified by the location cursor.  The term location cursor refers to any visual element that indicates the location where keyboard events are sent.  The location cursor is not strictly a cursor.  The name cursor simply refers to its use as indicating the location of input.  ID="ch0325"ID="ch0326"The location cursor is shown in a number of ways, depending on the type of component with the keyboard focus.  Possible location cursor types and their uses are described in the following text.  When designing new components, p]you should try to use one of the existing styles of location cursor, but you can create your own if it is appropriate.  Box The box cursor should be the default location cursor.  It is shown as a box drawn around the object.  IDREF="38262" TYPE="GRAPHIC"Figure 3-1
 shows the first ToggleButton in a group with a box style location cursor.LBL="3-1" FILE="boxcurso.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-1"Figure 3-1 
ID="38262"A Box Style Location CursorOutline Highlight  This cursor style is similar to the box style cursor.  The outline is shown of a component whose outline is not normally shown.  This form of location cursor is commonly used within Menu systems to show the Menu item with the location cursor.  ID="ch0327"IDREF="37364" TYPE="GRAPHIC"Figure 3-2
 shows a Menu with an outline highlight style location cursor. LBL="3-2" FILE="outcurso.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-2"Figure 3-2 
ID="37364"An Outline Highlight Style Location CursorText Cursor In Text components, the text cursor acts as the location cursor to indicate that the Text component has the keyboard focus.  ID="ch0328"ID="ch0329"IDREF="32556" TYPE="GRAPHIC"Figure 3-3
 shows possible text cursor shapes.  LBL="3-3" FILE="cursors.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-3"Figure 3-3 
ID="32556"Text Cursor ShapesA text cursor must be shown differently when the Text does and does not have the keyboard focus.  This can be done by Darkening the cursor when the Text has focus and graying the cursor when the Text does not have focus Using a blinking cursor when the Text has focus and a static cursor when the Text does not have focus Showing the cursor when the Text has focus and hiding the cursor when the Text does not have focus If the text cursor is hidden when the Text component does not have the focus and if the component gets the focus, the text cursor must reappear at the same position it had when the component lost focus.  A Text component can optionally include an outline highlight style location cursor to reinforce the location of the keyboard focus.  IDREF="41800" TYPE="GRAPHIC"Figure 3-4
 shows a Text component with the keyboard focus. LBL="3-4" FILE="text.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-4"Figure 3-4 
ID="41800"A Text Cursor Style Location CursorItem Cursor A component that manages groups of elements, like a List, should indicate that it has the keyboard focus with an item cursor style location cursor.  An item cursor highlights a single element, or group of elements, that the component acts on.  In the case of a List, the item cursor should be a box around an element.  In the case of a Drawing area, it could be a box with resize handles around a drawn element.  Components that use an item cursor to indicate keyboard focus can optionally include an outline highlight style location cursor to reinforce the location of the keyboard focus.  ID="ch0330"ID="ch0331"IDREF="17552" TYPE="GRAPHIC"Figure 3-5
 shows a List component with the keyboard focus. LBL="3-5" FILE="itemcurs.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-5"Figure 3-5 
ID="17552"An Item Cursor Style Location CursorFill Some very small components, like a Sash for resizing Panes, should indicate the keyboard focus by filling.  Where this is the case, there must be no other meaning associated with the filled state.  Filling avoids the problem caused by other styles of location cursor that make the small component too large.  ID="ch0332"IDREF="25565" TYPE="GRAPHIC"Figure 3-6
 shows the first of two Sashes with the keyboard focus. LBL="3-6" FILE="panedw1.gif" POSITION="INLINE" SCALE="FALSE"LBL="3-6"Figure 3-6 
ID="25565"A Fill Style Location CursorComponents must be designed and positioned within applications so that adding and removing the component's location cursor does not change the amount of space that the component takes up on the screen; that is, there is always room for the location cursor.  LBL="3.2.2" HELPID=""Window NavigationID="ch0333"ID="ch0334"ID="ch0335"ID="ch0336"ID="ch0337"ID="ch0338"ID="ch0339"ID="ch0340"ID="ch0341"ID="ch0342"A typical environment has several applications in operation simultaneously.  Each application typically has a main or primary window that displays data and in which the user carries on primary interaction with the application.  Applications can have additional windows to communicate context-specific interactions with the user of the application.  These additional windows are called secondary windows, or transient windows.  DialogBoxes are often used to create secondary windows.  ID="ch0343"ID="ch0344"ID="ch0345"ID="ch0346"ID="ch0347"The window navigation model can be divided into two levels: Moving among window families (among primary windows) Moving within a window family (among secondary windows) ID="ch0348"A window family consists of a single primary window and all of its associated secondary windows.  <Alt> <F6> and <Alt> <Shift> <F6> move the focus among windows in a window family.  <Alt> <Tab> and <Alt> <Shift> <Tab> move the focus among window families.  Window navigation is described in more detail in IDREF="24491" TYPE="TITLE"Chapter 7, "Window Manager Design Principles."LBL="3.2.3" HELPID=""ID="22203"Component NavigationID="ch0349"ID="ch0350"ID="ch0351"ID="ch0352"ID="ch0353"ID="ch0354"ID="ch0355"Component navigation moves the location cursor, and therefore the keyboard focus, among components in a window.  The window is divided into fields, and operations that use the <Tab> key move the cursor from one field to another.  For this reason, fields are also known as tab groups.  The directional keys <Down arrow>,<Up arrow>,<Right arrow>,and <Left arrow> are used for navigation within a field.  Menu systems, including the MenuBar, follow a different traversal model, described in IDREF="40574" TYPE="TITLE"Section 3.3, "Menu Traversal."A field can be an individual control, such as a Text control.  In this case, the directional keys are used for internal navigation within the control.  Alternately, a field can consist of a group of controls such as a RadioBox, which holds a group of RadioButtons.  In this case, the directional keys are used to navigate among the component controls of the group.  ID="ch0356"ID="ch0357"ID="ch0358"ID="ch0359"The fields in a window are ordered.  <Tab> generally moves the location cursor to the next field, and <Shift> <Tab> moves the location cursor to the previous field.  However, a field can use <Tab> and <Shift> <Tab> for internal navigation.  For example, within a multiline Text control, <Tab> is used to tab within the text.  Consequently, <Ctrl> <Tab> must always navigate to the next field, and <Ctrl> <Shift> <Tab> must always navigate to the previous field.<Tab> (if not used for internal navigation) and <Ctrl> <Tab> must move the location cursor forward through fields according to the following rules: If the next field is a control, <Tab> (if not used for internal navigation) and <Ctrl> <Tab> must move the location cursor to that control.  If the next field is a group, <Tab> (if not used for internal navigation) and <Ctrl> <Tab> must move the location cursor to a traversable component within the group.  If the field contains a button that currently shows default highlighting, the location cursor should be placed on that button; ]otherwise, the first control in the field (the top-leftmost one in a left-to-right language environment) should get focus.  If the next field contains no traversable components, <Tab> (if not used for internal navigation) and <Ctrl> <Tab> must skip the field.  Note that Separators and Labels should not be traversable.  The ScrollBars of ScrolledWindows also should not be traversable, particularly if a <ScrollLock> key is available on the keyboard.<Shift> <Tab> (if not used for internal navigation) and <Ctrl> <Shift> <Tab> must move the location cursor backward through fields in the order opposite to that of <Tab> (if not used for internal navigation) and <Ctrl> <Tab>.When a window acquires focus, the location cursor must be placed on the control that last had focus in the window, providing that all the following conditions are met: The window uses an explicit keyboard focus policy.  The window acquires the focus through keyboard navigation or through a button press other than within the client area of the window.  The window had the focus at some time in the past.  The control that last had focus in the window is still traversable.  If the component that last had focus is no longer traversable, or if the window has not previously had the focus, the location cursor should be placed on the component with which the user is most likely to want to interact.  In a DialogBox, this is often a text control or a default button.  If no such control exists, the location cursor should be placed in the first field in the windowname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in a left-to-right language environment, the top-leftmost field.  Developers should follow these general rules for field navigation: Fields should be traversed from the upper left to the lower right in a left-to-right language environment.  In a right-to-left language environment, fields should be traversed from the upper right to the lower left.  Field navigation must wrap between the first and last fields of the window.  In a PanedWindow, each Pane should consist of one or more fields, and each Sash should be a field.  Fields in a PanedWindow should be traversed in the following order: All fields in the topmost Pane The topmost Sash All fields in the next Pane toward the bottom The next Sash toward the bottom and so on, to the bottom of the PanedWindow.  Directional keys are used both for component navigation within a field and for internal purposes, including internal navigation, within a control.  When <Down arrow> and <Up arrow> are used for component navigation within a field, they must behave in the following way: In a left-to-right language environment, <Down arrow> must move the location cursor through all traversable controls in the field, starting at the upper left and ending at the lower right, then wrapping to the upper left.  If the controls are aligned in a matrix-like arrangement, <Down arrow> must first traverse one column from top to bottom, then traverse the column to its right, and so on.  In a right-to-left language environment, <Down arrow> must move the location cursor through all traversable controls, starting at the upper right and ending at the lower left.  <Up arrow> must move the location cursor through all traversable controls in the field in the order opposite to that of <Down arrow>.When <Right arrow> and <Left arrow> are used for component navigation within a field, they must behave in the following way: In a left-to-right language environment, <Right arrow> must move the location cursor through all traversable controls in the field, starting at the upper left and ending at the lower right, then wrapping to the upper left.  If the controls are aligned in a matrix-like arrangement, <Right arrow> must first traverse one row from left to right, then traverse the row below it, and so on.  In a right-to-left language environment, <Right arrow> must move the location cursor through all traversable controls, starting at the lower left and ending at the upper right.  <Left arrow> must move the location cursor through all traversable controls in the field in the order opposite to that of <Right arrow>.Controls that use directional keys internallyname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'such as Text, List, Canvas, Sash, ScrollBar, and Scalename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'should be fields.  If a control that uses directional keys internally does not act like a field, the directional keys must be used for both internal purposes and component navigation.  In particular, controls can use directional keys in one dimension for internal purposes and in another dimension for component navigation.  For example, a vertically organized group of single-line Text controls can be grouped together as a single field.  <Down arrow> and <Up arrow> navigate among the single-line Text controls in the field.  <Right arrow>,<Ctrl> <Right arrow>,<Left arrow>,and <Ctrl> <Left arrow> navigate among characters and words within an individual single-line Text control.  The directional keys modified with <Ctrl> can also be used for component navigation, following the same rules specified above.  If the directional keys modified with <Ctrl> are used for component navigation, the unmodified directional keys can be used for internal purposes.  For example, a table can consist of an array of single-word Text controls, with <Up arrow> and <Down arrow> used to navigate up and down a column.  <Right arrow> and <Left arrow> can navigate among characters within an individual single-word Text control, while <Ctrl> <Right arrow> and <Ctrl> <Left arrow> navigate horizontally among the Text components in a row.  Within a control, the directional keys can be used in a variety of ways.  In list-like controls, or in graphics-like controls in which the elements are laid out in a matrix-like arrangement, internal navigation using the directional keys should move the cursor among elements using the same rules followed for component navigation.  However, if the control is scrollable, directional navigation should not wrap between the first and last elements of the control; a directional key that would otherwise cause wrapping should have no effect at the first or last element.  Additional internal navigation techniques may be needed in situations not covered by this guide, such as the following: Graphics-like controls in which the elements are densely populated or are organized into layers Applications that use 3-dimensional navigation Applications that organize elements hierarchically In such cases, navigation models should not deviate unnecessarily from the standard navigation models.  Rather than move the cursor among elements, a graphics-like control can use a positional cursor.  In this case, <Down arrow>,<Up arrow>,<Right arrow>,and <Left arrow> must internally navigate by moving the cursor one unit (for example, one pixel) at a time in the direction indicated by the key.  In this model, the cursor is sometimes on an element and sometimes in the background of the control.  The use of the directional keys for internal navigation in text-like controls is described in the Text reference page in IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages."
  In a control that displays a value, the directional keys can increment or decrement that value.  When the directional keys cause changes that are based on some unit, the directional keys modified by <Ctrl> can cause changes based on a larger unit.  For example: In Text, <Right arrow> moves the cursor a character to the right, and <Ctrl> <Right arrow> moves the cursor a word to the right.  In a Canvas, <Right arrow> can move a positional cursor one pixel to the right, and <Ctrl> <Right arrow> can move the cursor some number of pixels to the right.  In a Scale, <Right arrow> can increment the Scale value by one unit indicated by minor tick marks, and <Ctrl> <Right arrow> can increment the Scale value by an amount corresponding to the distance between major tick marks.  If a control uses <Right arrow> and <Left arrow> for internal navigation, it must support the following behavior: <Begin> In a left-to-right language environment, this action must move the location cursor to the leftmost edge of the data or the leftmost element.  In a right-to-left language environment, this action must move the location cursor to the rightmost edge of the data or the rightmost element.  <End> In a left-to-right language environment, this action must move the location cursor to the rightmost edge of the data or the rightmost element.  In a right-to-left language environment, this action must move the location cursor to the leftmost edge of the data or the leftmost element.  If a control uses <Up arrow> and <Down arrow> for internal navigation, it must support the following behavior: <Ctrl> <Begin> This action must move the location cursor to one of the following: The first element The topmost edge of the data In a left-to-right language environment, the topmost left edge of the data; in a right-to-left language environment, the topmost right edge of the data <Ctrl> <End> This action must move the location cursor to one of the following: The last element The bottommost edge of the data In a left-to-right language environment, the bottommost right edge of the data; in a right-to-left language environment, the bottommost left edge of the data Groups that are fields can also use <Begin>,<End>,<Ctrl> <Begin>,and <Ctrl> <End> to move the location cursor to appropriate controls within the group.  LBL="3.3" HELPID=""ID="40574"Menu TraversalID="ch0360"The Menu traversal model is different from the field traversal model.  This allows Menus to be traversable even when the focus policy is implicit.  If a Menu is traversed to while the focus policy in the application is implicit, the focus policy must temporarily change to explicit.  The focus policy must revert to implicit whenever the user traverses out of the Menu system.  ID="ch0361"ID="ch0362"ID="ch0363"Traversing to a Menu system is the same as activating the Menu system.  If the MenuBar is inactive, <F10> must traverse to, or activate, the MenuBar system.  The location cursor must be placed on the first traversable CascadeButton in the MenuBar.  If there are no traversable CascadeButtons in the MenuBar, <F10> must do nothing.  Note that <Shift> <Menu> is used on systems where <F10> is not available.  If the keyboard focus is on an element with an inactive Popup Menu and the context of the element allows a Popup Menu to be displayed, <Menu> must post (activate) the Popup Menu.  The location cursor must be placed on the default item of the Menu, or the first traversable item if there is no default item.  Note that the availability of the Popup Menu can depend on the location of the cursor within the element, the contents of the element, or the selection state of the element.  Menus popped up from the keyboard should be in the context of the insertion position of the element with the location cursor.  If there are no traversable items in the Popup Menu, it is up to the system and the application whether to post the Menu or not.  Note that <Shift> <F10> is used on systems where <Menu> is not available.  If the keyboard focus is in an OptionButton, <Select> or <Space> must post the Option Menu.  The location cursor must be placed on the previously selected item in the Option Menu.  If the Option Menu is pulled down for the first time, the location cursor must be placed on the default item in the Menu.  If there are no traversable items in the Option Menu, the application should decide whether to post the Menu or not.  If there is an active Option Menu, <Enter>,<Return>,<Select>,or <Space> must select the current item in the Option Menu, unpost the active Option Menu system, and return the location cursor to the OptionButton.  Once a Menu system is posted, the Menu items can be traversed using <Down arrow>,<Left arrow>,<Right arrow>,and <Up arrow>.A posted Menu system behaves somewhat like a field, with the addition of traversing among Menus in the system.  When a Menu traversal action traverses to the next or previous component in a Menu or MenuBar, the order of traversal and the wrapping behavior must be the same as that of the corresponding component navigation action within a field, as described in IDREF="22203" TYPE="TITLE"Section 3.2.3, "Component Navigation."Two-dimensional Menus must not contain CascadeButtons.  The following Menu traversal behavior must be supported: <Down arrow> This action must do the following: If the component is in a vertical or 2-dimensional Menu, traverse down to the next traversable component, wrapping within the Menu if necessary.  If the component is in a MenuBar, and the component with the keyboard focus is a CascadeButton, post its associated Pulldown Menu and traverse to the default entry in the Menu or, if the Menu has no default, to the first traversable entry in the Menu.  <Up arrow> If the component is in a vertical or 2-dimensional Menu, this action must traverse up to the previous traversable component, wrapping within the Menu if necessary, and proceeding in the order opposite to that of <Down arrow>.<Left arrow> This action must do the following: If the component is in a MenuBar or 2-dimensional Menu, but not at the left edge, traverse left to the previous traversable component.  If the component is at the left edge of a MenuBar, wrap within the MenuBar.  If the component is at the left edge of a vertical or 2-dimensional Menu that is the child of a vertical or 2-dimensional Menu, unpost the current Menu and traverse to the parent CascadeButton.  If the component is at the left edge of a vertical or 2-dimensional Menu that is the child of a MenuBar, unpost the current Menu and traverse left to the previous traversable entry in the MenuBar.  If that entry is a CascadeButton, post its associated Pulldown Menu and traverse to the default entry in the Menu or, if the Menu has no default, to the first traversable entry in the Menu.  <Right arrow> This action must do the following: If the component is a CascadeButton in a vertical Menu, post its associated Pulldown Menu and traverse to the default entry in the Menu or, if the Menu has no default, to the first traversable entry in the Menu.  If the component is in a MenuBar or 2-dimensional Menu, but not at the right edge, traverse right to the next traversable component.  If the component is at the right edge of a MenuBar, wrap within the MenuBar.  If the component is not a CascadeButton and is at the right edge of a vertical or 2-dimensional Menu, and if the current Menu has an ancestor CascadeButton (typically in a MenuBar) from which <Down arrow> posts its associated Pulldown Menu, unpost the Menu system pulled down from the nearest such ancestor CascadeButton and traverse right from that CascadeButton to the next traversable component.  If that component is a CascadeButton, post its associated Pulldown Menu and traverse to the default entry in the Menu or, if the Menu has no default, to the first traversable entry in the Menu.  For all Menu traversal actions, when the Menu is first posted, traversal should go to the second traversable entry in the Menu if the Menu has no default and the first traversable entry is a TearOffButton.  Subsequent traversal actions must traverse to the TearOffButton in the same way as for other Menu entries.  The user can use keyboard actions to exit a Menu or a Menu system in the following way: When a MenuBar system is active, <F10> should unpost the entire Menu system.  When a Popup Menu system is active, <Menu> should unpost the entire Menu system.  In a Pulldown Menu, <Cancel> must either dismiss the Menu and move the location cursor to the CascadeButton used to pull down the Menu, or unpost the entire Menu system.  In a Popup Menu, Option Menu, TearOff Menu, or MenuBar, <Cancel> must unpost the Menu system.  When <F10>,<Menu>,or <Cancel> is used to unpost an entire Menu system and an explicit focus policy is in use, the location cursor must be moved back to the component that had it before the Menu system was posted.  LBL="3.4" HELPID=""ID="29873"Scrollable Component NavigationID="ch0364"ID="ch0365"ID="ch0366"Certain components, such as List and Text, have built-in support for scrolling.  However, any component or group of components can be associated with scrolling components or placed inside a ScrolledWindow and made scrollable.  A scrollable component generally has ScrollBars or some other type of scrolling component associated with it.  When a component does not have a scrolling component associated with it, it generally should not be scrollable; however, components whose visible contents alone indicate that additional items exist beyond the bounds of the visible area, like Text, can be scrollable even if they do not have an associated scrolling component.  ID="ch0367"ID="ch0368"ID="ch0369"Any scrollable component must support the appropriate navigation and scrolling operations.  You must use the page navigation keys <PageUp>,<PageDown>,<PageLeft> or <Ctrl> <PageUp>,and <PageRight> or <Ctrl> <PageDown> for scrolling the visible region by a page increment.  A page is the portion of data that is visible, not any underlying structure of the data.  When scrolling by a page, you must leave at least one unit of overlap between the old and new pages; for example, a line in a Text component.  If the location cursor can be made visible, it must be.  It should be moved within the component so that it remains as near as possible to its original location in the viewport.  However, if a navigation key (including directional and page navigation keys) is pressed while the <ScrollLock> key is down, the navigation key should be interpreted as specified for an associated ScrollBarname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'that is, it causes scrolling, while leaving the position of the cursor within the scrollable component unchanged.  See the ScrollBar reference page in IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages."You should use the directional keys <Up arrow>,<Down arrow>,<Left arrow>,and <Right arrow> for moving the location cursor among elements, moving the location cursor by increments, or scrolling the visible region by regular increments.  In general, keyboard operations should traverse through the entire scrollable component, not just through the visible portion.  When a mouse button is pressed initiating a selection operation within a scrollable component, and the pointer is then dragged outside of the scrollable component, the component should scroll toward the pointer.  This is called autoscrolling.  Drag and drop operations should produce similar scrolling behavior within scrollable components that force dragged elements to remain within the component.  Releasing the button outside of the component must not do any transfer in these cases.  Parking the cursor on the edge of the scrollable component during the drag and drop operation should scroll the component toward the pointer.  When the location cursor is within a scrollable component, scrolling can move the cursor out of view; however, any keyboard operation that moves the cursor to or in the component, or that inserts, deletes, or modifies items at the cursor location must scroll the component so that the cursor is visible when the operation is complete.  When scrolling using the mouse, the location cursor can be allowed to scroll out of the visible region.  When scrolling using the keyboard, the location cursor must be moved so that it remains within the visible region, if that is possible.  If a mouse-based scrolling action is in progress, <Cancel> must cancel the scrolling action and return the slider to its position prior to the start of the scrolling operation.  LBL="4"ID="12570"SelectionThe selection model determines how elements are selected from a group of elements.  This chapter describes the selection models that are used by the various components of an application.  OSF/Motif compliant applications use an object-action selection model.  In an object-action selection model, the user first selects an object and then performs an action on it.  The object-action selection model mimics real life, so it is a familiar process to the user and increases the user's sense of control over applications.  ID="ch041"ID="ch042"ID="ch043"Objects include not only recognizable objects like windows, PushButtons, and List elements, but also component elements that are not always recognized as discrete objects, like individual letters of a text file.  Applications can also treat a group of elements as a single element, either in a contiguous range or as a noncontiguous group.  This chapter describes the following topics: IDREF="12200" TYPE="TITLE"Section 4.1, "Selection Models," which determine how elements in a collection are selected for later action.  IDREF="21835" TYPE="TITLE"Section 4.2, "Selection Actions," which perform actions directly on a selection, such as cut, copy, and paste.  LBL="4.1" HELPID=""ID="12200"Selection ModelsSelection is used to mark one or more of a group of elements simply for highlighting the elements, or so they can be moved, copied, or otherwise manipulated by the application.  ID="ch044"ID="ch045"ID="ch046"ID="ch047"ID="ch048"ID="ch049"Groups of elements can be organized into the following three types of collections: List-like collections Text-like collections Graphics-like collections ID="ch0410"ID="ch0411"ID="ch0412"In list-like collections, when the pointer or location cursor is in the collection, the pointer or location cursor is considered to be on an element.  In text-like collections, when the pointer or location cursor is in the collection, the pointer or location cursor is considered to be between two elements.  The name "text-like" refers to Text components in insert mode where the insertion cursor is always between two letters.  List-like and text-like collections are usually ordered as linear collections; that is, the collections are treated as if the elements were connected as a series of elements in one dimension.  ID="ch0413"ID="ch0414"In graphics-like collections, the pointer and location cursor can be either on or between elements.  Graphics-like collections are usually ordered as 2-dimensional collections.  That is, the ordering of elements in the collection depends on both the horizontal and vertical position of the element within each collection.  The notion of "on" depends on the manipulation model presented by the control.  For example, "on" can mean that the cursor is within the bounds of the element, or it can mean that the cursor is on the boundary of the element, or the element can have handles, and "on" means that the cursor is on one of the handles.  ID="ch0415"OSF/Motif compliant systems must support the five different selection models.  Each model is used where appropriate in applications to limit the type of selections the user can make.  For example, a List can limit selection to a single element where the user is only allowed to make one choice. The five selection models are as follows: Single Selection  Used to select a single element in a collection.  Clicking ID="ch0416"ID="ch0417"BSelect on an element selects it and deselects the previously selected element in the collection.  Single selection is described in IDREF="40662" TYPE="TITLE"Section 4.1.1, "Mouse-Based Single Selection."Browse Selection  Used to allow browsing through single selection collections.  ID="ch0418"ID="ch0419"Browse selection is also used to select a single element of a collection.  Browse selection allows the user to browse through the elements by dragging BSelect through the elements in the collection.  Browse selection highlights each element as it is traversed, and gives the application an opportunity to provide information about each element as it is highlighted.  Releasing BSelect on an element selects it and deselects the previously selected element.  Browse selection is described in IDREF="35080" TYPE="TITLE"Section 4.1.2, "Mouse-Based Browse Selection."Multiple Selection  Used to select or deselect multiple elements of a collection.  Clicking ID="ch0420"ID="ch0421"BSelect on an unselected element adds that element to the current selection.  Clicking BSelect on a selected element removes that element from the current selection.  Multiple selection is described in IDREF="17616" TYPE="TITLE"Section 4.1.3, "Mouse-Based Multiple Selection."Range Selection  Used to select a contiguous range of elements in a collection.  Clicking ID="ch0422"ID="ch0423"BSelect on an element selects the single element and deselects any previous selection.  BSelect Motion over a range of elements selects all the elements within the range and deselects any previous selection.  Range selection is described in IDREF="35475" TYPE="TITLE"Section 4.1.4, "Mouse-Based Range Selection."Discontiguous Selection  Used for selecting multiple discontiguous ranges of elements in a collection.  Clicking or dragging ID="ch0424"ID="ch0425"BSelect operates just as for range selection.  Discontiguous selection also allows <Ctrl> BSelect to be used to add or remove selection ranges.  Discontiguous selection is described in IDREF="37548" TYPE="TITLE"Section 4.1.5, "Mouse-Based Discontiguous Selection."ID="ch0426"The choice of the selection model should be made on a collection-by-collection basis.  Some components, like Text, enforce a selection model.  Other components, like a List, allow the application or the user to determine the selection model.  Variants of these selection models may be needed for collections that are especially dense, when elements are organized in layers, when 3-dimensional selection is needed, when elements are hierarchically organized, or in other situations not covered by this guide.  Selection models for such cases should not deviate unnecessarily from the standard selection models.  In all selection models, the selected element or group of elements should be visually highlighted in some way.  Highlighting the selection can be done in the following ways: Using any one of the location cursor mechanisms Inverting the colors of the selection Drawing a solid or dashed box around the elements of the selection The selection can also be an empty selection; that is, it is possible for no items to be selected in a collection.  This commonly occurs in text-like collections where the location cursor is between two elements, or when the user has deselected all the elements.  LBL="4.1.1" HELPID=""ID="40662"Mouse-Based Single SelectionID="ch0427"ID="ch0428"The single selection model is the simplest selection model.  In the single selection model, when BSelect is clicked in a deselected element, the location cursor must move to that element, that element must be selected, and any other selection in the collection must be deselected.  LBL="4.1.2" HELPID=""ID="35080"Mouse-Based Browse SelectionID="ch0429"ID="ch0430"The browse selection model is very similar to the single selection model.  In browse selection, like single selection, only a single element is selected at a time.  In the browse selection model, when BSelect is released in a selectable element, that element must be selected, and any other selection in the collection must be deselected.  As BSelect is dragged through selectable elements, each element under the pointer must be selected, and the previously selected element must be deselected.  The selection must remain on the element where BSelect is released, and the location cursor must be moved there.  The browse selection model gives the application an opportunity to provide information about each element as it is highlighted.  LBL="4.1.3" HELPID=""ID="17616"Mouse-Based Multiple SelectionID="ch0431"ID="ch0432"Multiple selection allows the user to select or deselect multiple single elements of a collection.  Clicking BSelect on an unselected element must add that element to the current selection in the collection.  Clicking BSelect on a selected element must remove that element from the current selection in the collection.  Clicking BSelect on an element must move the location cursor to that element.  With multiple selection, the user can select any group of elements in a collection, including discontiguous groups, all the elements, or none of the elements.  Because multiple selection requires one mouse click for each element selected, although a simple model, it is not well-suited for selecting large groups of elements.  BSelect Motion can optionally toggle a range of elements.  (See IDREF="37548" TYPE="TITLE"Section 4.1.5, "Mouse-Based Discontiguous Selection"
 for a description of range toggling.) LBL="4.1.4" HELPID=""ID="35475"Mouse-Based Range SelectionID="ch0433"ID="ch0434"The range selection model allows the user to select multiple contiguous elements of a collection.  The description of this selection model assumes that drag and drop is not integrated with selection.  Integrating dragging and selection is described in IDREF="21864" TYPE="TITLE"Section 4.3, "Transfer Models."ID="ch0435"In the range selection model, pressing BSelect must set an anchor on the element, or at the position where BSelect was pressed, and must deselect all elements in the collection.  The anchor and the current position of the pointer determine the current range.  As BSelect is dragged through the collection, the current range must be highlighted.  When BSelect is released, the anchor must not move, and all the elements within the current range must be selected.  ID="ch0436"In text-like collections, elements are ordered linearly, and a text pointer is always considered to be between elements at a point near the actual pointer position.  The anchor point must be the text pointer position when BSelect is pressed, and the current range must consist of all elements between the anchor point and the current text pointer position.  ID="ch0437"ID="ch0438"In graphics-like and list-like collections, a marquee, or highlighted rectangle, is typically used to indicate the current range of the selection.  The current range must consist of those elements that fall completely within the marquee.  If a marquee selection is started when the pointer is on an element, that element can be used as an anchor element, and should be used as an anchor element if the collection is arranged as a list or matrix.  If there is an anchor element, the marquee must always be made large enough to completely enclose it.  Otherwise, an anchor point is used, which must be the point at which BSelect was pressed, and must determine one corner of the marquee.  If the collection is arranged as a list or matrix, and the pointer is on an element, the marquee should be extended to completely enclose the element under the pointer.  Otherwise, the marquee must be extended to the pointer position.  Marquee selection can be implemented so that it is used only when BSelect is pressed in the background; other selection models, not described in this style guide, can be used when BSelect is pressed on an element.  If marquee selection is used, even if only when started in the background, clicking BSelect on a selectable element must make it an anchor element, select it, and deselect all other elements.  ID="ch0439"The user can extend the range selection using <Shift> BSelect.  When <Shift> BSelect is pressed, the anchor remains unchanged, and an extended range for the selection is determined, based on one of the following extension models: Reselect The extended range must be determined by the anchor and the current pointer position, in exactly the same manner as when the selection was initially made.  ID="ch0440"Enlarge Only The selection can only be enlarged.  The extended range is determined by the anchor and the current pointer position, but then must be enlarged to include the current selection.  ID="ch0441"Balance Beam A balance point is defined at the midpoint of the current selection.  When ID="ch0442"<Shift> BSelect is pressed on the opposite side of the balance point from the anchor, this model must work exactly like the reselect model.  When <Shift> BSelect is pressed, or a navigation action modified by <Shift> is started on the same side of the balance point as the anchor, this model must move the anchor to the opposite end of the selection, and then must work exactly like the reselect model.  In graphics-like collections, balancing the anchor is done separately in each dimension.  As <Shift> BSelect is dragged through the collection, the extended range should be highlighted, and selected elements outside of it should be dehighlighted.  When BSelect is released, the anchor must not move, all the elements within the extended range must be selected, and all the elements outside of it must be deselected.  Text-like collections should use the balance beam model.  The extension model used by other collections depends on the purpose of the collection.  In the range selection model, clicking <Ctrl> BSelect should move the location cursor to the position of the pointer without affecting the current selection.  LBL="4.1.5" HELPID=""ID="37548"Mouse-Based Discontiguous SelectionID="ch0443"ID="ch0444"The discontiguous selection mechanism allows the user to make multiple simultaneous range selections.  It is an extension of the range selection model.  The description of this selection model assumes that drag and drop is not integrated with selection.  Integrating dragging and selection is described in IDREF="21864" TYPE="TITLE"Section 4.3, "Transfer Models."ID="ch0445"The behavior of BSelect in the discontiguous selection model must be exactly the same as in the range selection model, and after setting the anchor with BSelect, <Shift> BSelect must work exactly as in the range selection model.  ID="ch0446"ID="ch0447"The primary difference between the range selection model and the discontiguous selection model is the use of <Ctrl> BSelect.  In the range selection model, <Ctrl> BSelect is only used to move the position of the location cursor without disrupting the current selection.  In the discontiguous model, <Ctrl> BSelect is used to toggle the selection state of an element or a range of elements.  If the current selection is empty, <Ctrl> BSelect Click can simply move the location cursor, but leave the anchor alone and leave all elements deselected.  Otherwise, if <Ctrl> BSelect is clicked, the anchor and location cursor must move to that point, and if <Ctrl> BSelect is clicked on an element, the selection state of that element must be toggled, and that element must become the anchor element. <Ctrl> BSelect Motion must be used to toggle the selection state of a range of elements.  The range itself must be determined exactly as for BSelect Motion.  Releasing <Ctrl> BSelect must toggle the selection state of the elements in the range according to one of two models: Anchor Toggle Toggling is based upon an anchor element.  If the range is anchored by a point, and is not empty, the anchor element must be set to the element within the range that is nearest to the anchor point.  Toggling must set the selection state of all elements in the range to the inverse of the initial state of the anchor element.  This is the model recommended for toggling.  Full Toggle The selection state of each element in the extended range must be toggled.  As <Ctrl> BSelect is dragged through the collection, highlighting should be used to indicate the current range and the selection state of each element that would result from releasing <Ctrl> BSelect at the current position.  After using <Ctrl> BSelect to toggle a selection, <Shift> BSelect or <Ctrl> <Shift> BSelect must be able to be used to extend the range of toggled elements.  The extended range must be determined in exactly the same way as when <Shift> BSelect is used to extend a range selection.  When <Ctrl> <Shift> BSelect is released, the selection state of elements added to the range must be determined by the toggle model as previously described.  If elements are removed from the range, they must either revert to their state prior to the last use of <Ctrl> BSelect, or change to the state opposite from the elements remaining within the extended range.  As <Shift> BSelect or <Ctrl> <Shift> BSelect is dragged through the collection, highlighting should be used to indicate the current range and the selection state of each element that would result from releasing <Shift> BSelect or <Ctrl> <Shift> BSelect at the current position.  LBL="4.1.6" HELPID=""ID="22109"Keyboard SelectionID="ch0448"ID="ch0449"ID="ch0450"Selections can be made by using the keyboard as well as the mouse.  Two keyboard selection models are available: normal mode and add mode.  ID="ch0451"ID="ch0452"Normal mode is used for making simple contiguous selections from the keyboard.  Normal mode is a navigation/selection mode where the location cursor is never disjoint from the current selection.  In collections where the location cursor is on an element, the element with the location cursor is ordinarily selected; if it is not, pressing <Select> or <Space> moves the selection to the cursored element.  Add mode is used for making more complex and possibly disjoint selections.  Add mode is a navigation/selection mode where the location cursor can move independent of the current selection.  Even in collections that do not support discontiguous selections, add mode allows the selection to be unaffected by keyboard navigation.  Browse selections must only support normal mode.  Single and multiple selections must only support add mode.  Range selection must support normal mode and can also support add mode.  Discontiguous selections must support both modes.  The default mode for range and discontiguous selections must be normal mode.  <Shift> <F8> must switch between add mode and normal mode if both modes are supported.  When switching from normal to add mode, if the cursored element is the only element selected in the collection, it should be deselected.  Mouse-based selection must not change based on the keyboard selection mode.  In editable components, add mode is a temporary mode that must be exited when an operation is performed on the selection or when the selection is deselected.  LBL="" HELPID=""ID="23133"Keyboard-Based Single SelectionID="ch0453"ID="ch0454"Collections using the single selection model must use add mode.  In add mode, the navigation keys for the collection must move the location cursor independent from the selected element.  If <Select> or <Space> is pressed on an unselected element, it must select the element with the location cursor, and it must deselect any previous selection in the collection.  LBL="" HELPID=""ID="10369"Keyboard-Based Browse SelectionID="ch0455"ID="ch0456"Collections using the browse selection model must use normal mode.  The navigation keys must move the location cursor and select the cursored element, deselecting any other element.  If the application has deselected all elements or if the cursor is left disjoint from the selection, <Select> or <Space> must select the cursored element and deselect any other element.  LBL="" HELPID=""ID="41052"Keyboard-Based Multiple SelectionID="ch0457"ID="ch0458"Collections using the multiple selection model must use add mode.  The navigation keys for the collection must move the location cursor independent from the current selection.  <Select> or <Space> on an unselected element must add the element to the current selection.  <Select> or <Space> on a selected element must remove the element from the current selection.  LBL="" HELPID=""ID="13340"Keyboard-Based Range SelectionID="ch0459"ID="ch0460"ID="ch0461"Collections using the range selection model must initially use normal mode.  This allows a keyboard-based behavior similar to dragging with the mouse.  In normal mode, navigation keys must move the location cursor and deselect the current selection.  If the cursor is on an element, it must be selected.  The anchor must move with the location cursor.  However, in text-like collections, a different model can be used in which the anchor must instead remain at its current location, except that, if the current selection is not empty, it must be deselected and the anchor must be moved to the location of the cursor prior to navigation.  <Select> or <Space> (except in a Text component) must move the anchor to the cursor, deselect the current selection, and, if the cursor is on an element, select the element.  Unless the anchor is on a deselected item, <Shift> <Select> or <Shift> <Space> (except in Text) must extend the selection from the anchor to the cursor, based on the extension model used by <Shift> BSelect.  Using <Shift> in conjunction with the navigation keys must extend the selection, based on the extension model used by <Shift> BSelect.  If the current selection is empty, the anchor must first be moved to the cursor.  The cursor must then be moved according to the navigation keys, and the selection must be extended based on the extension model used by <Shift> BSelect.  In add mode, <Select>,<Space>,<Shift> <Select>,and <Shift> <Space> must work exactly as in normal mode.  However, ordinary navigation must simply move the location cursor, but must leave the anchor unchanged.  Shifted navigation must move the location cursor according to the navigation keys, and the selection must be extended based on the extension model used by <Shift> BSelect.  In Text, both <Space> and <Shift> <Space> must insert a space character.  LBL="" HELPID=""ID="18552"Keyboard-Based Discontiguous SelectionID="ch0462"ID="ch0463"Collections using the discontiguous selection model must initially use normal mode.  In the discontiguous selection model, add mode is not only a separate model of interaction but also an extension to the range selection model that allows the user to select discontiguous elements.  In normal mode, all keyboard operations must have the same effect as in the range selection model.  In normal mode, discontiguous selections cannot be made using the keyboard.  In add mode, <Select> or <Space> must move the anchor to the location cursor and initiate toggling.  If the location cursor is on an element, the selection state of that element must be toggled, but the selection state of all other elements must remain unchanged.  <Shift> <Select> or <Shift> <Space> and shifted navigation operations must extend the selection between the anchor and the location cursor, based on the toggle mechanism used by <Ctrl> BSelect.  LBL="4.1.7" HELPID=""ID="19005"Canceling a SelectionID="ch0464"ID="ch0465"ID="ch0466"ID="ch0467"<Cancel> must cancel or undo any incomplete motion operation used for selection.  Once <Cancel> is pressed to cancel a motion operation, the application must ignore subsequent key and button releases until after all buttons and keys are released.  <Cancel> during a range selection should leave all elements, except possibly for the cursored element, deselected.  <Cancel> while extending or toggling must leave the selection state of all elements as they were prior to the button press.  LBL="4.1.8" HELPID=""ID="20267"Autoscrolling and SelectionIf the user drags the pointer out of a scrollable collection during a motion-based selection operation, autoscrolling must be used to scroll the collection in the direction of the pointer.  If the user presses <Cancel> with BSelect pressed, the selection operation must be canceled as described in IDREF="19005" TYPE="TITLE"Section 4.1.7, "Canceling a Selection."LBL="4.1.9" HELPID=""ID="15181"Selecting and Deselecting All ElementsID="ch0468"ID="ch0469"ID="ch0470"There are two special keyboard-based selection mechanisms for selecting (via <Ctrl> </> ) and deselecting (via <Ctrl> <\> ) all the elements in a collection.  <Ctrl> </> in a collection using multiple, range, or discontiguous selection must select all the elements in a collection, place the anchor at the beginning of the collection, and leave the location cursor at its previous position.  Deselection differs between add mode and normal mode.  In add mode, <Ctrl> <\> must deselect all the elements in a collection.  In normal mode, <Ctrl> <\> must deselect all the elements in a collection, except the element with the location cursor if the location cursor is being displayed.  In either case, it must leave the location cursor at its current location and move the anchor to the location cursor.  An application can deselect all elements in a collection regardless of the state of add mode or the selection model.  LBL="4.1.10" HELPID=""ID="22746"Using Mnemonics for ElementsID="ch0471"ID="ch0472"Collections can also support mnemonics associated with its elements if the elements have labels.  Pressing a mnemonic key while the collection has the keyboard focus must be equivalent to moving the location cursor to the element and pressing <Select> or <Space>.LBL="4.2" HELPID=""ID="21835"Selection ActionsEach collection maintains its own selection.  A selection need not contain any elements, in which case it is said to be an empty selection.  At any time, there is one selection called the primary selection, which is the last selection explicitly started by the user.  Clicking BSelect or <Ctrl> BSelect moves the primary selection to a collection only when it results in making a selection that is not empty.  When <Shift> BSelect is clicked, an implementation can move the primary selection to the component even if the resulting selection is empty.  Dragging BSelect, <Shift> BSelect, or <Ctrl> BSelect must move the primary selection to the component if a button release during the pointer motion could have potentially selected any element.  A selection is said to be persistent if it is highlighted even when it is not the primary selection.  Persistent There are two variants of persistent selections: persistent always, in which the current selection is always highlighted, and persistent on focus, in which the current selection is only highlighted when it is the primary selection or when the collection has the keyboard focus.  In either case, stronger highlighting should be used when the current selection is also the primary selection.  When focus is in the collection, <Alt> <Insert> can be used to promote the current selection to the primary selection.  Nonpersistent The collection only highlights a primary selection.  When the primary selection is lost to another collection, the current selection is set to empty.  When focus is in the collection, and it does not have the primary selection, <Alt> <Insert> can be used to restore the previous selection and make it the primary selection.  Collections that are never editable (such as noneditable Lists) should always use persistent selections.  Collections that are editable can use either persistent or non-persistent selections.  When the user makes or changes a selection, the application can display information about the selection, but it should not perform any other action that uses the selected elements.  For example, selecting a file from a List of files should not automatically open the file.  Such actions should require additional user interaction.  LBL="4.2.1" HELPID=""ID="24375"Destination ComponentThe destination component is used to identify the component on which certain operations, primarily data transfer operations, act.  There is only one destination component at a time.  When using an explicit focus policy, the destination component must be the editable component that last had focus.  When using a pointer focus policy, the destination component must be the editable component that last received mouse button or keyboard input.  Special highlighting should be used to identify the destination component.  In Text, a solid insertion cursor can be shown.  LBL="4.2.2" HELPID=""ID="29313"Operation TargetsOnce a selection is made, the elements of the selection can be acted on using selection actions.  Some common selection actions are delete, cut, copy, and paste, although your application is not limited to these.  This section and the following one describe the way many selection operations work.  Operations that transfer data are described in greater detail in IDREF="21864" TYPE="TITLE"Section 4.3, "Transfer Models."The user may invoke an operation that can act on a selection in some component.  A keyboard operation can be used, or a control can be activated, which performs the operation.  There can be a number of components in a window to which the action could be applied, and it may not be clear which component is the target.  This could be the case, for example, when selecting Copy from the Edit Menu, or when typing <Ctrl> <Insert>,the accelerator for Copy.  For operations that act on selections, use the following hierarchy of rules to determine which component's selection to act on: If the keyboard focus is in a component (or a Popup Menu of a component) that supports selections, the action must act on that component.  Otherwise, if the keyboard focus is in a window (or a Menu of a window) with a main component that has a persistent selection, it should act on the main component.  Otherwise, if the keyboard focus is in the window (or a Menu of the window) that has the destination component, and the destination component contains a persistent selection that is not empty, it should act on the destination component.  Otherwise, if the keyboard focus is in the same window (or a Menu of the window) that has the primary selection, it should act on the component with the primary selection.  Otherwise, if the keyboard focus is in a window (or a Menu of a window) that has only one editable component with a persistent selection, then it can act on that component.  Otherwise, invoking the action should have no effect, except to signal an error or post a DialogBox.  Similarly, the user may invoke an operation that transfers data to a component or otherwise uses a component in some way, and, again, it may not be clear which component should be used.  This could be the case, for example, when selecting Paste from the Edit Menu, or when typing <Shift> <Insert>,the accelerator for Paste.  For operations that do not act on selections, use the following hierarchy of rules: If the keyboard focus is in a component (or a Popup Menu of a component) that supports the action, the action must be applied to that component.  Otherwise, if the keyboard focus is in a window (or a Menu of a window) with a main component that supports the action, it should be applied to the main component.  Otherwise, if the keyboard focus is in the window (or a Menu of the window) that has the destination component, and the destination component supports the action, it should be applied to the destination component.  Otherwise, invoking the action should have no effect, except to signal an error or post a DialogBox.  LBL="4.2.3" HELPID=""ID="14005"Selection OperationsThis subsection describes some of the standard operations available through the Edit Menu and through standard keyboard bindings that operate on selections.  A collection can either enable or disable pending delete, which controls the circumstances under which the selection is deleted.  By default, pending delete should be enabled.  Inserting or pasting elements into a selection, except for a primary transfer operation at the bounds of the primary selection, must first delete the selection if pending delete is enabled.  In normal mode, inserting or pasting elements disjoint from the selection must also deselect the selection, except for primary transfer operations whose source and destination are in the same collection.  In add mode, the selection must not be deselected.  In editable list-like and graphics-like collections, <Delete> must delete the selected elements.  In editable text-like collections, <Delete> and <BackSpace> must behave as follows: If the selection is not empty and the control is in normal mode, the selection must be deleted.  If the selection is not empty, the control is in add mode, and the cursor is not disjoint from the selection, the selection must be deleted.  If the selection is not empty and the control is in add mode, but the cursor is disjoint from the selection, <Delete> must delete one character forward, and <BackSpace> must delete one character backward.  If the selection is empty, <Delete> must delete one character forward, and <BackSpace> must delete one character backward.  More generally, any operation that deletes a region (for example, a word or line) behaves as follows: If the selection is not empty and the control is in normal mode, the selection must be deleted.  If selection is not empty, the control is in add mode, and the cursor is not disjoint from the selection, the selection must be deleted.  If the selection is not empty and the control is in add mode, but the cursor is disjoint from the selection, the operation must delete the region.  If the selection is empty, the operation must delete the region.  If the region deleted (in add mode) partially overlaps the selection, then the overlapped part of the selection must be deleted.  Generally, whenever an action causes data to be removed from a component, what to do with the space left by the data is up to the component.  In cases where the surrounding data can be reformatted to fill in the space left by the removed data (such as in Text components), the delete action should cause this reformatting.  In this case, a clear action should delete the data without reformatting any surrounding data.  In Text components, the clear action deletes the selected text and replaces it with white space.  In cases where the surrounding data cannot be reformatted to fill in the space left by the removed data (such as in bitmap graphics), the delete action should remove the data but not cause any reformatting.  The Cut entry from the Edit Menu should behave like the delete action.  In cases where an action adds data to a component, the effect the new data has on the surrounding data depends on the component.  In cases where the surrounding data can be reformatted to allow the new data to fit in (such as in Text components), insert actions should cause this reformatting.  The Paste entry from the Edit Menu should behave like insert actions.  <Undo> or <Alt> <BackSpace> should undo the last operation on a selection.  LBL="4.3" HELPID=""ID="21864"Transfer ModelsThis section describes the four techniques available for transferring data: Clipboard Transfer This technique transfers a selection from a source to the clipboard, and then subsequently from the clipboard to a destination.  Primary Transfer This technique transfers the primary selection directly to a destination without using the clipboard for intermediate storage of the data.  Quick Transfer This technique allows the user to indicate a range of elements (called a secondary selection) that are then transferred to the destination component.  Drag Transfer or Drag and Drop This technique allows the user to drag a selection or an unselected element from a source to a destination.  Clipboard and primary transfer operations can be invoked from Pulldown or Popup Menus and have standard keyboard bindings as well.  Primary, quick, and drag transfer operations can also be invoked using BTransfer.  There are three transfer operations generally available: Copy, which copies elements from the source to the destination.  Move, which moves elements from the source to the destination.  Link, which inserts a link in the destination to elements in the source.  The default operation for primary and quick transfer using BTransfer is copy.  The default operation for drag transfer is generally move, though it depends on the characteristics of the source and the destination.  Modifiers can be used to force an operation different from the default: <Ctrl> must force a copy.  <Shift> must force a move.  <Ctrl> <Shift> must force a link.  If the move, copy, or link operation the user requests is not available, the transfer operation must fail.  When data is moved or copied, it can change its appearance or representation.  The destination can determine the representation of the transferred data as it chooses.  For example, if a graphic element representing a file is transferred to a Text component, the name of the file (or possibly the contents, if it is a text file) can be inserted.  If possible, the source must transfer the format that the destination requests.  Otherwise, the destination can use any heuristic to determine the best format to transfer the data in.  That heuristic can even be, if the source cannot transfer in the preferred format, fail.  If the destination decides that a transfer in its chosen format could possibly cause a loss of data between the source and the destination, the destination should notify the user of the possible loss of data and confirm the action before proceeding.  If there is a choice of the exact representation of data to be inserted, there should be some visual means that clearly indicates to the user which representation the application will use.  If there is no such indication, then when the user performs the transfer operation, the application can post a Popup Menu or a DialogBox to allow the user to choose the representation.  A transfer can also cause the destination to take related actions.  For example, transferring an element to a printer icon can cause the element to be printed.  The insertion position is the position in the destination at which transferred data is placed.  The insertion position is determined in the following way: Some collections have a fixed insertion point (as in append-only text) or keep the elements in the collection ordered in a specific way.  In those cases, the collection can determine where to place the data.  If the collection does not have a fixed insertion point or keep elements ordered in a specific way, the insertion position for BTransfer-based primary and drag transfer operations must be the position at which the user releases BTransfer.  If the collection does not have a fixed insertion point or keep elements ordered in a specific way, the insertion position for other transfer operations, including keyboard-based transfer operations, is determined as follows: In text-like collections, the insertion position must be the location cursor, and the data must be pasted before it.  In list-like collections, the insertion position must be the element with the location cursor, and the data must be pasted before it.  In graphics-like collections, the insertion position should be at the location cursor, but the exact placement of the data with respect to the location cursor is unspecified.  LBL="4.3.1" HELPID=""ID="12791"Clipboard TransferID="ch0473"ID="ch0474"ID="ch0475"ID="ch0476"The clipboard transfer operations Cut, Copy, and Paste, are usually performed using the Edit Menu of an application.  They also have standard keyboard bindings that must be available in every editable collection. ID="ch0477"ID="ch0478"ID="ch0479" <Cut> or <Shift> <Delete> and the Cut entry of the Edit Menu must cut selected elements of the target component to the clipboard.ID="ch0480"ID="ch0481"ID="ch0482" <Copy> or <Ctrl> <Insert> and the Copy entry of the Edit Menu must copy selected elements of the target component to the clipboard and can mark the selection for subsequent use with Paste Link.  ID="ch0483"ID="ch0484"ID="ch0485"A Copy Link entry of the Edit Menu can be used to place a link in the clipboard to selected elements of the target component so that the link can be placed in a destination by subsequent use of Paste or Paste Link.  See the rules for operations that act on selections in IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets"
 for determining which component in a window is targeted by a Cut, Copy, or Copy Link operation.ID="ch0486"ID="ch0487"ID="ch0488"<Paste> or <Shift> <Insert> and the Paste entry of the Edit Menu must paste the contents of the clipboard at the insertion position of the target component.  ID="ch0489"ID="ch0490"ID="ch0491"The Paste Link entry of the Edit Menu can place a link at the insertion position of the target component to the selection last marked by a Copy or Copy Link operation.  See the rules for operations that do not act on selections in IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets"
 for determining which collection in a window is targeted by a Paste or Paste Link operation.  If the last data cut was the primary selection, pasting it can make it the primary selection if there is no current primary selection.  Otherwise, pasting data should not select it.  However, if the collection is in normal mode, the anchor and the cursor should be placed at opposite ends of the pasted data so that subsequent use of <Shift> <Select> or <Shift> <Space> can be used to select it.  If Paste or Paste Link is invoked using a component's Popup Menu, the data must be pasted at the insertion position of the component.  However, if the Popup Menu is popped up over a selection, the selection must first be deleted, even if pending delete is disabled, and the pasted data must replace it, if possible.  If Paste or Paste Link is invoked from the Edit Menu or by a keyboard operation, and the insertion position in the target component is not disjoint from a selection, the pasted data must replace the selection contents if pending delete is enabled.  LBL="4.3.2" HELPID=""ID="39087"Primary TransferID="ch0492"ID="ch0493"ID="ch0494"ID="ch0495"Primary transfer can be invoked by clicking BTransfer or through standard keyboard bindings.  There are three primary transfer operations: Primary Copy In an editable collection, ID="ch0496"ID="ch0497"ID="ch0498"BTransfer Click, <Ctrl> BTransfer Click, <Alt> <Copy>,and <Alt> <Ctrl> <Insert> must copy the primary selection to the insertion position, as defined in IDREF="21864" TYPE="TITLE"Section 4.3, "Transfer Models."
 (Note that the insertion position is usually different for mouse and keyboard operations.) Primary Move In an editable collection, ID="ch0499"ID="ch04100"ID="ch04101"<Shift> BTransfer Click, <Alt> <Cut>,and <Alt> <Shift> <Delete> must move the primary selection to the insertion position, as defined in IDREF="21864" TYPE="TITLE"Section 4.3, "Transfer Models."
  (Note that the insertion position is usually different for mouse and keyboard operations.) Primary Link In an editable collection, ID="ch04102"ID="ch04103"ID="ch04104"<Ctrl> <Shift> BTransfer Click must place a link to the primary selection at the insertion position, as defined in IDREF="21864" TYPE="TITLE"Section 4.3, "Transfer Models."Transferring data to the destination by a Primary Copy or Primary Link must not select it.  However, if the source and the destination components are different, and if the collection is in normal mode, the anchor and the cursor should be placed at opposite ends of the transferred data, so that subsequent use of <Shift> <Select> or <Shift> <Space> can be used to select it.  A Primary Move must move the primary selection as well as the elements selected; that is, the element moved to the destination must become selected as the primary selection.  If a primary transfer operation is invoked using a component's Popup Menu, the data must be transferred to the insertion position of the component.  However, if the Popup Menu is popped up over a persistent nonprimary selection, the selection must first be deleted, even if pending delete is disabled, and the transferred data must replace it.  When a primary transfer transfers data into a nonprimary selection, the transferred data must replace the selection contents if pending delete is enabled.  When a Primary Copy or Primary Link is invoked by using BTransfer with the pointer at the edge of the primary selection, by popping up a Popup Menu at the edge of a primary selection, or by a keyboard operation when the insertion position is at the edge of the primary selection, the data should be transferred, and the selection should be left unchanged, even if pending delete is enabled.  If a Primary Copy or Primary Link is invoked inside the primary selection, the operation should have no effect.  If BTransfer is pressed outside a primary selection, but at a position both where a drag can be initiated and where data can be pasted by a primary transfer, a user-settable timeout and motion threshold should be used in the following way to distinguish drag initiation from primary transfer: If BTransfer Motion exceeding the motion threshold occurs following the BTransfer Press, a drag should be initiated.  Otherwise, if the BTransfer Release follows the BTransfer Press within the timeout period, a primary transfer should be done.  Otherwise, when the timeout period expires, a drag should be initiated.  However, if BTransfer Release is then done without motion exceeding the threshold, the drag should be canceled.  If BTransfer is pressed within a draggable primary selection, the drag should be initiated on the BTransfer Press.  LBL="4.3.3" HELPID=""ID="33280"Quick TransferID="ch04105"ID="ch04106"ID="ch04107"ID="ch04108"ID="ch04109"Quick transfer is used to make a temporary (or secondary) selection and then immediately copy, move, or link that selection to the insertion position of the destination component.  Quick transfer is implemented using <Alt> BTransfer Motion, with the standard modifiers used to force the various transfer operations.  Text components must support quick transfer.  There are three quick transfer operations: Quick Copy If a component supports quick transfer, ID="ch04110"ID="ch04111"ID="ch04112"<Alt> BTransfer Motion or <Alt> <Ctrl> BTransfer Motion must temporarily select elements in the specified range and, on release, must copy them to the insertion position of the destination component.  Quick Cut If a component supports quick transfer, ID="ch04113"ID="ch04114"ID="ch04115"<Alt> <Shift> BTransfer Motion must temporarily select elements in the specified range and, on release, must move them to the insertion position of the destination component.  Quick Link If a component supports quick transfer, ID="ch04116"ID="ch04117"ID="ch04118"<Alt> <Ctrl> <Shift> BTransfer Motion must temporarily select elements in the specified range and, on release, must place a link to them at the insertion position of the destination component.  The range of the temporary selection must be determined by using exactly the same model used when BSelect Motion determines the range of a primary selection.  If the insertion position of the destination component is not disjoint from the selection, the transferred data must replace the selection contents if pending delete is enabled.  Transferring data to the destination component by a quick transfer must not select it.  However, if the destination component is in normal mode, the anchor and the cursor should be placed at opposite ends of the transferred data so that subsequent use of <Shift> <Select> or <Shift> <Space> can be used to select it.  Quick transfer can be used to transfer static text or graphics that are not ordinarily selectable.  For example, a portion of the text label of a PushButton is not ordinarily selectable, since BSelect Click, <Select> or <Space> activate the PushButton instead.  While dragging out the quick selection, the range should be highlighted in some way.  The highlighting mechanism should be different from that used for the primary selection.  In text, the highlight should be underlining.  If the pointer is dragged out of a scrollable collection while making the temporary selection, autoscrolling must be used to scroll the collection in the direction of the pointer.  If BTransfer is released with the pointer outside of the collection, or if <Cancel> is pressed with BTransfer pressed, the highlighting must be removed and a transfer must not be performed.  LBL="4.3.4" HELPID=""ID="14546"Drag TransferID="ch04119"ID="ch04120"Drag transfer, also known as drag and drop, provides a quick and simple model for transferring data within and between applications.  Depending on where it is initiated, drag transfer can be used to transfer the selected elements of a collection, a single unselected element, an entire collection, and even unselectable static textual and graphics labels.  A user performs a drag transfer by pressing BTransfer in the source, moving the pointer to the destination (called the drop site), and releasing BTransfer.  This transfers the data from the source to the destination.  The usual modifier keys can be used to force a copy, move, or link: <Ctrl> BTransfer Motion must force a drag copy.  <Shift> BTransfer Motion must force a drag move.  <Ctrl> <Shift> BTransfer Motion must force a drag link.  If no modifier key is chosen, the default operation should be a move, although it depends on the characteristics of the source and the destination.  In particular, the default should be copy if the source is not editable, or if the destination is a copying or transformation device; for example, if the drop occurs over an icon for a printer or a compiler.  When a drag move moves the primary selection, the primary selection should move to the destination, as well as the elements selected; that is, the element moved to the destination should become selected as the primary selection.  When a drag move moves a selection within the same component, the selection must move along with the elements selected.  In other cases, data transferred by a drag transfer must not become selected at the destination.  However, if the destination is in normal mode, then except when drag copy and drag link transfer a selection within the same component, the anchor and the cursor should be placed at opposite ends of the transferred data so that subsequent use of <Shift> <Select> or <Shift> <Space> can be used to select it.  Within a collection, drag transfer can be used to either drag a selected set of elements, a single unselected element, or the entire collection.  This is determined in the following way: In text-like collections, initiating a drag in a selected region must drag the text selection (including all pieces if it is discontiguous).  In list-like and graphics-like collections, initiating a drag on a selected element must drag the entire selection.  In list-like and graphics-like collections, initiating a drag on an unselected element must drag just that element.  If the collection contains a selection, the selection must not be affected (except if the drop occurs in the same collection).  In graphics-like collections, initiating a drag in the background of a contiguous selected region can drag the selection.  Otherwise, BTransfer Motion beginning in the background of a collection can drag the entire collection or, if the collection is scrollable, can be used to pan the collection.  If a drag is initiated in an unselected region and the pointer is over two possible draggable elements, the drag must occur on the highest draggable element in the stacking order.  This also implies that with nested draggable elements, the drag occurs on the smallest draggable element under the pointer.  All collections should support drag transfer and should allow elements to be dragged to or from other collections, including those in different applications.  A collection can support only drag (particularly if it is not editable) or only drop.  If a collection only allows elements dragged from it to be dropped in the same collection, then, during the drag, it can prevent the pointer from moving outside of the collection.  If so, and if the collection is scrollable, holding the pointer at the edge of the collection should cause autoscrolling.  LBL="" HELPID=""ID="29854"Drag IconsWhen a drag operation is started, the pointer must be replaced with a drag icon.  A drag icon provides visual feedback that a drag is in progress.  It can be composed of three parts: A source indicator An operation indicator A state indicator IDREF="25001" TYPE="GRAPHIC"Figure 4-1 shows move, copy, and link drag icons for graphical and textual information.  The bulk of the icon is the source indicator.  When defining new drag icons, you should follow the same rules as for defining new pointers described in IDREF="11954" TYPE="TITLE"Section 2.2.2, "Pointer Shapes."LBL="4-1" FILE="dragicon.gif" POSITION="INLINE" SCALE="FALSE"LBL="4-1"Figure 4-1 
ID="25001"Drag IconsAll drag icons must include a source indicator.  A source indicator should give a visual representation of the type of elements being dragged; for example, horizontal lines in a rectangle for representing text.  The source indicator can include a fragment of the actual data being dragged, such as the first few characters of some text.  An operation indicator shows whether the drag operation will result in a move, copy, or link operation.  Most drag icons should include an operation indicator.  An operation indicator can be shown either as a separate element of the drag icon or as a variation of a graphic used for the source indicator.  The source of the dragged elements can also provide visual indications of the result of a drop.  For example, if the default operation for the dragged elements is a move, the source can be hidden or deemphasized; or if the default operation of the dragged elements is a link, a line can be drawn from the source to the pointer.  A state indicator shows whether the current pointer location is over a valid drop site for the dragged elements.  All drag icons can include a state indicator.  A state indicator should be coincident with the hotspot of the pointer.  LBL="" HELPID=""ID="33182"During a DragSystems should provide help operations during drag and drop.  If a system provides drag and drop help, pressing <Help> (followed by releasing BTransfer) during a drag and drop operation should allow the posting of a DialogBox with the help information and the possible choices for concluding the drag and drop operation.  The DialogBox should allow for canceling the drag and drop operation or for dropping the elements at the current location as a move, copy, or link.  Pressing <Cancel> during a drag operation must cancel the current drag operation and return the system to the state prior to the start of the drag operation.  It can be difficult during a drag and drop operation to make both the drag source and drop site visible to the user at the same time.  A system can alleviate this problem by making it possible to navigate to drop sites that were not visibly available at the start of the drag operation.  For example, a system can scroll a scrollable region when the pointer rests on the edge of that scrollable region.  A system can open an icon view when the pointer rests on that icon.  A system can also raise a window when the pointer rests in that window.  During a drag and drop interaction, the system should indicate dynamically whether the current pointer location is a possible valid drop site for the data that the user is dragging.  This is done using drag-over effects, and drag-under effects.  A drag-over effect is a change in the visual state of the drag icon.  This change is usually represented in the drag icon's state indicator.  If a drag icon has a state indicator, it should be coincident with the pointer's hotspot.  The state indicator should be emphasized for valid drop sites and deemphasized for invalid drops sites.  The state indicator can also indicate that there is no drop site under the pointer.  A drag-under effect is a change to the visual state of a possible valid drop site when the drag icon pointer is over the drop site.  All drop sites should use some kind of drag-under effect.  Drop sites can use a solid line around the site, or a raised or lowered beveled edge around the drop site as a drag-under effect.  Drop sites can also change any visual component of the drop site, or even animate those changes, as a drag-under effect.  For example, an icon representing a folder might show an animated image of the folder opening as a user drags a file onto it.  Drop sites can also use other media (for example, audio effects) to provide feedback.  LBL="" HELPID=""ID="10867"Ending a DragReleasing BTransfer (or BSelect when transfer and selection are integrated) must end a drag and drop operation.  In addition, as mentioned in the previous section, pressing <Cancel> must also end a drag and drop operation by canceling the drag in progress.  When a user releases BTransfer, the drop operation must occur at the location of the hotspot of the drag icon pointer.  The drop must occur into the highest drop site in the stacking order.  This also implies that in a group of nested drop sites the drop occurs into the smallest drop site under the pointer.  However, if a drop occurs within a selection at any level, the transferred data must replace the contents of the entire selection if pending delete is enabled.  LBL="" HELPID=""ID="29666"Drop ResultsEvery drop operation, even when there was a visual indication of a valid drop site, can result in either success, failure, or partial failure (in the case of dragging multiple elements).  While the transfer is in progress, that is until the drop site determines the success of the drag and drop operation, the data must not leave the source.  While the transfer is in progress, a transfer icon representing the type of data being transferred should appear at the drop site. After a successful transfer, the data must be placed in the drop site and the transfer icon must be removed.  The removal of the transfer icon can be accompanied by an animation that shows the icon transforming into the drop site.  For example, the transfer icon can melt into the drop site.  After a failed transfer, the data must remain at the drag source, the data must not be placed in the drop site, and the transfer icon must be removed.  The removal of the transfer icon should be accompanied by an animation that shows the icon returning to the source location.  For example, the transfer icon can snap back to the location of the drag source.  When multiple elements are involved in a drag and drop operation, the success or failure of the operation can be determined for the group as a whole or for each individual element in the group.  If the group is transferred as a whole, there should only be one transfer icon at the drop site while the transfer is in progress.  If the elements in the group succeed or fail individually, there can either be a transfer icon for each element or one transfer icon for the whole group.  In either case, if partial success or failure is allowed, the drop site should post a message for each individual failure or otherwise indicate which transfers succeeded or failed.  LBL="4.3.5" HELPID=""ID="37315"Integrating Selection and TransferInstead of using BTransfer, transfer operations can be integrated with BSelect.  When BSelect is used for dragging operations, its use partially supersedes the use of BSelect Motion in the selection models described in IDREF="12200" TYPE="TITLE"Section 4.1, "Selection Models."
  The following rules are designed to make the integration of selection and transfer less restrictive: In text-like collections, BSelect Motion starting in a selected region must drag the text selection; starting outside the selected region, it must be used for making selections.  In list-like and graphics-like collections, BSelect Motion starting on a selected element must drag the entire selection.  In dense list-like or graphics-like collections, in which background space around elements is not generally available and in which BSelect Motion is used for browsing or for selecting or toggling a range of elements, BSelect Motion starting on an unselected element must be used for making selections.  In less dense list-like or graphics-like collections, BSelect Motion in the background must be used for making marquee selections; if they are not supported, BSelect Motion can be used to drag the entire collection, or to pan if the collection is scrollable.  BSelect Click must always be used for selection.  When BSelect is used for dragging, the <Ctrl> and <Shift> modifiers must be used to force the transfer operation as for BTransfer.  When BSelect is only used for selection, the <Ctrl> and <Shift> modifiers have their usual selection-specific meanings.  If BMenu is not available for Popup Menus, <Alt> BSelect must be used instead.  If BMenu is available, then when transfer is integrated with selection, <Alt> BSelect Click should be used for primary transfer, and <Alt> BSelect Motion should be used for quick transfer, with <Ctrl> and <Shift> forcing the transfer operation as usual.  LBL="5"ID="15303"Component ActivationThis chapter describes the component activation model, which determines how to act upon previously selected elements.  ID="ch051"ID="ch052"ID="ch053"Once users select an object, they can perform an action on it by using the components available in the application, or by using one of the selection actions described in IDREF="12570" TYPE="TITLE"Chapter 4, "Selection."
  Using components to perform actions on a selection is called activation.  ID="ch054"ID="ch055"Components are used to send information to the underlying application.  For example, a Text component is used to send complicated information to the application, but most components (for example, PushButtons) are simply used to start an application process.  In fact, even a complicated component like Text may need to tell the application that the user is finished entering information.  Components that start some application process are used following the activation model, which this chapter divides into the following areas: IDREF="10735" TYPE="TITLE"Section 5.1, "Basic Activation"IDREF="39548" TYPE="TITLE"Section 5.2, "Accelerators"IDREF="34761" TYPE="TITLE"Section 5.3, "Mnemonics"IDREF="23279" TYPE="TITLE"Section 5.4, "TearOff Activation"IDREF="23175" TYPE="TITLE"Section 5.5, "Help Activation"IDREF="21012" TYPE="TITLE"Section 5.6, "Default Activation"IDREF="42018" TYPE="TITLE"Section 5.7, "Expert Activation"IDREF="28868" TYPE="TITLE"Section 5.8, "Previewing and Autorepeat"IDREF="15274" TYPE="TITLE"Section 5.9, "Cancel Activation"LBL="5.1" HELPID=""ID="10735"Basic ActivationID="ch056"ID="ch057"ID="ch058"ID="ch059"The basic activation model mimics real-life button activation in that pressing on a button activates it.  The user selects a button with the location cursor, which can be moved among components following the navigation model described in IDREF="31210" TYPE="TITLE"Chapter 3, "Navigation."Clicking BSelect on the button must activate the button.  <Select> or <Space> on a button with the focus must activate the button.  <Select>,<Space>,<Enter>,or <Return> on an activatable Menu entry with the focus must activate the entry.  When BSelect is pressed over a button, the appearance of the button must change to indicate that releasing BSelect activates the button.  If, while BSelect is pressed, the pointer is moved outside of the button, the visual state must be restored.  If, while BSelect is still pressed, the pointer is moved back inside of the button, the visual state must again be changed to indicate the pending activation.  If BSelect is pressed and released within a button, the button must be activated, regardless of whether the pointer has moved out of the button while it was pressed.  An implementation can allow BSelect Click 2+ (multiple mouse button clicks) to be treated as a single mouse button click on a per-component basis; that is, all clicks except the first are discarded.  In an application where double-clicks are used heavily, this can help prevent the user from unintentionally activating a button twice.  A selectable element of a collection can be activatable; for example, a link icon, or an audio annotation in Text.  If so, BSelect Click, <Select>,and <Space> (except in Text) must select it.  BSelect Click 2 must select and activate it.  LBL="5.2" HELPID=""ID="39548"AcceleratorsID="ch0510"ID="ch0511"ID="ch0512"An accelerator is a key or key combination that invokes the action of some component regardless of the position of the location cursor when the accelerator is pressed.  Accelerators are most commonly used to activate Menu items without first posting the Menu.  If the button with the accelerator is within a primary or secondary window, or within a Pulldown Menu system from its MenuBar, it must be activatable whenever the input focus is in the window or the MenuBar system.  If the button with the accelerator is within a Popup Menu system, it must be activatable whenever the focus is in the Popup Menu system or the component with the Popup Menu.  Applications can provide accelerators for any button component.  Implementations must support accelerators in PushButtons and ToggleButtons that are in Menus.  If a button has an accelerator, the accelerator must be shown following the label of the button.  LBL="5.3" HELPID=""ID="34761"MnemonicsID="ch0513"ID="ch0514"ID="ch0515"A mnemonic is a single character that can be associated with any component that contains a text label.  The label must contain the character, and the character must be underlined within the label, except in language environments in which underlining is unavailable.  If a label does not naturally contain the character of the mnemonic, the mnemonic must be placed in parentheses following the label.  Labels can also be sequentially numbered, and the number can serve as the mnemonic.  Labels that are duplicated within an application should be given the same mnemonic.  Mnemonics must be case insensitive for activation.  Either an uppercase or lowercase letter can be underlined in the label.  When the location cursor is within a Menu or a MenuBar, pressing the mnemonic key of a component within that Menu or MenuBar must move the location cursor to the component and activate it.  If a mnemonic is used for an OptionButton or for a CascadeButton in a MenuBar, pressing <Alt> and the mnemonic anywhere in the window or its Menus must move the cursor to the component with that mnemonic and activate it.  Implementation must support mnemonics for OptionButtons, PushButtons in a Menu, ToggleButtons in a Menu, and CascadeButtons in a Menu or MenuBar.  Mnemonics can also be used to select and deselect elements within a component as described in IDREF="22746" TYPE="TITLE"Section 4.1.10, "Using Mnemonics for Elements."LBL="5.4" HELPID=""ID="23279"TearOff ActivationID="ch0516"ID="ch0517"ID="ch0518"Some Menus have TearOffButtons as their first elements.  A TearOffButton is like a PushButton with the special interaction of converting a Menu into a DialogBox; that is, tearing off the Menu from its CascadeButton.  TearOffButtons must follow the rules for the basic activation model described in IDREF="10735" TYPE="TITLE"Section 5.1, "Basic Activation."
  For example, pressing and releasing BSelect in a TearOffButton tears off the Menu and transforms it into a DialogBox.  TearOffButtons also have a second activation mechanism.  Once a Menu with a TearOffButton is posted, pressing BTransfer in the TearOffButton must start a TearOff action.  As long as BTransfer is held, a representation of the Menu must follow the movements of the pointer.  Releasing BTransfer must end the TearOff action by unposting the Menu system, creating a new window at the current pointer location with the contents of the Menu, and give focus to the new window in explicit pointer mode.  The contents of the new window should not include the TearOffButton.  Pulling down or popping up a Menu that is currently torn off should not affect the torn off Menu.  If the same Menu is torn off again, using either basic activation or TearOff activation, the existing torn off window should be removed prior to the creation of the new window.  A torn off Menu is closed by pressing <Cancel> while focus is in the window or by using the TearOff Menu's window Menu.  LBL="5.5" HELPID=""ID="23175"Help ActivationID="ch0519"ID="ch0520"ID="ch0521"Help is generally invoked from selections in the Help Menu of the MenuBar.  In addition, <Help> on a component must invoke any context-sensitive help for the component or its nearest ancestor with context-sensitive help available.  Within DialogBoxes, applications should provide context-sensitive help for the DialogBox as a whole.  <Shift> <Help> should switch into context-sensitive help mode if it is available.  In the context-sensitive help mode, the pointer shape changes to show the mode, and help is provided for the next component that the user selects, after which context-sensitive help mode is exited.  LBL="5.6" HELPID=""ID="21012"Default ActivationID="ch0522"ID="ch0523"ID="ch0524"Any window can have a default action, although default actions are most frequently used in DialogBoxes.  A DialogBox should have a default action associated with it.  The default action in a window can change depending upon which component has the focus.  The current default action should correspond to the action of some PushButton, called the current default PushButton of the window.  The current default PushButton must be highlighted in some way, usually by displaying a border around it.  When the focus is on a PushButton, its action must be the default action, and the PushButton must show default highlighting.  If the default action in a window varies, some PushButton must always have default highlighting, except when there is no current default action.  In a DialogBox, default PushButtons should be in the bottom area of PushButtons of the DialogBox.  However, if a particular default action is associated with a cluster of controls in a window, the corresponding default PushButton can be located adjacent to the cluster.  When an explicit focus policy is in use, and the focus is outside the window, default highlighting should be placed on the PushButton whose action corresponds to the default action that would result from moving the focus to the window by using keyboard navigation among windows.  The default action of a DialogBox is activated according to the following rules: If the focus is in a window, <Enter> and <Ctrl> <Return> must invoke the default action, and, if the focus is in a component in a window other than multiline Text, <Return> must invoke the default action.  These actions must have no other effect on the component with the focus, unless the default action has some effect.  In list-like and graphics-like collections, when the location cursor is not on an activatable element, BSelect Click 2 should act like BSelect Click, followed by invocation of the default action.  When the focus is on a ToggleButton not used for expert activation, BSelect Click 2 should activate the ToggleButton and then perform the default action.  Except in the middle of a button motion operation, <Cancel> anywhere in a DialogBox must be equivalent to activating the Cancel PushButton in the DialogBox.  LBL="5.7" HELPID=""ID="42018"Expert ActivationID="ch0525"ID="ch0526"ID="ch0527"ID="ch0528"ID="ch0529"Some activatable elements, usually PushButtons and ToggleButtons, can have expert activation actions associated with them.  BSelect Click 2 (that is, double-clicking the element) should activate any expert action for the element.  Expert actions should only be available in a Panel of PushButtons or in a Panel of RadioButtons where one of the RadioButtons is always on.  When the focus is on a button used for expert activation, there must be no default action available, unless the default and expert actions are the same.  The expert action should include the regular action of the component in a more global manner.  For example, a Panel of RadioButtons in a drawing application could include a tool for turning on the erase cursor.  Selecting the  turns on the erase cursor.  Double-clicking the RadioButton could erase the drawing area.  If a component with an expert action is selectable, activating the expert action must first select the component and then perform the expert action.  To support new users and keyboard-only users, expert actions must only be shortcuts to application features available elsewhere.  LBL="5.8" HELPID=""ID="28868"Previewing and AutorepeatID="ch0530"ID="ch0531"ID="ch0532"ID="ch0533"Two special actions can be used with activation: previewing and autorepeat.  When BSelect is pressed and held over a PushButton or ToggleButton, the application can present information in some way that describes the effect of activating the button.  This is called previewing.  The information must be removed when the user releases BSelect.  Applications should provide a means to disable previewing for experienced users.  PushButtons can also autorepeat; that is, when BSelect is pressed and held, the PushButton activates and continues to activate at regular intervals until the PushButton is released.  Autorepeating buttons should continue to repeat even when the pointer moves outside the button while the button is pressed; however, applications can suspend the activation of the button until the pointer is moved back inside of the button.  While the button is active, it should be drawn in the active state.  LBL="5.9" HELPID=""ID="15274"Cancel ActivationID="ch0534"ID="ch0535"ID="ch0536"<Cancel> is available in most contexts to stop or cancel the current interaction.  <Cancel> has an impact on the following contexts: Pressing <Cancel> during a mouse-based selection or drag operation must cancel the operation.  Pressing <Cancel> during a mouse-based scrolling operation must cancel the scrolling action and return the system to its state prior to the start of the scrolling operation.  Pressing <Cancel> anywhere in a DialogBox must be equivalent to activating the Cancel PushButton, if one exists, except during a mouse-based selection or drag operation, in which case it should cancel the operation.  Pressing <Cancel> in a Pulldown Menu must either dismiss the Menu and move the location cursor to the CascadeButton used to pull it down or unpost the entire Menu system.  <Cancel> in a Popup Menu, Option Menu, TearOff Menu, or MenuBar must unpost the Menu system.  Pressing <Cancel> while the focus is in a torn off Menu window must close the torn off Menu window.  LBL="6"ID="20011"Application Design PrinciplesThis chapter is directed at application designers, rather than the people who write the algorithms of an application, although they are often one in the same.  Application designers are the people who design the interface between the application algorithms and the user.  In designing user interfaces, an application designer chooses the proper controls or groups of controls, or components, to pass data between the base application and the user, lays out those components naturally, and ensures that user interaction with the components and the layout are easy to use.  ID="ch061"ID="ch062"This chapter describes the three elements of application user interface design, as well as the principles for designing new user interface components.  The four major sections of this chapter are as follows: IDREF="34542" TYPE="TITLE"Section 6.1, "Choosing Components"IDREF="22928" TYPE="TITLE"Section 6.2, "Layout"IDREF="26054" TYPE="TITLE"Section 6.3, "Interaction"IDREF="24980" TYPE="TITLE"Section 6.4, "Component Design"LBL="6.1" HELPID=""ID="34542"Choosing ComponentsID="ch063"ID="ch064"ID="ch065"ID="ch066"ID="ch067"ID="ch068"ID="ch069"ID="ch0610"The user interface of an application is made up of components that perform two simple functions: presenting the application information to the user, and allowing the user to enter data for the application.  Components can be divided into six types: basic controls, field controls, basic groups, layout groups, framing groups, and DialogBox groups.  The groups are containers for controls and groups of controls.  Groups can be nested.  The component types that should be available in a user interface toolkit are described in the following lists.  The details of these components are described in the reference section in IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
 of this guide.  The correspondence of these components to widgets available in the OSF/Motif toolkit is described in IDREF="36096" TYPE="TITLE"Appendix A, "OSF/Motif Widgets and Components Correspondence."ID="ch0611"Basic ControlsSeparator Draws a separating line within windows, between Menu items, and between Panes of a PanedWindow.  A Separator does not allow application interaction.  ID="ch0612"ID="ch0613"LabelDisplays static text and images.  A Label presents application information to the user.  ID="ch0614"ID="ch0615"PushButton A button used to activate an operation.  A PushButton contains a Label that indicates the operation of the button.  The Label can contain text or an image.  ID="ch0616"ID="ch0617"CascadeButton A button used to display a Pulldown Menu.  A CascadeButton contains a Label that indicates the Menu to be displayed.  CascadeButtons can also contain an arrow graphic after the Label to distinguish it from PushButtons and to indicate the direction of the ID="ch0618"ID="ch0619"cascading Menu.  OptionButton A button used to display an Option Menu.  An Option Menu allows for a one-of-many selection.  An OptionButton contains a Label that ID="ch0620"ID="ch0621"indicates the current state of the Option Menu and a bar graphic to distinguish it from a PushButton.  ToggleButton A button with two states: on and off.  A ToggleButton contains a Label that indicates the active state.  Normally, preceding the Label is a graphic indicator of the state of the ToggleButton.  ID="ch0622"ID="ch0623"CheckButtonA ToggleButton in a group of ToggleButtons where any number of the ToggleButtons can be on at a time.  The graphic indicator for a CheckButton is usually a filled square to indicate the on state or an empty square to indicate the off state.  On color systems, the filled color can be distinct from general application colors to visually distinguish the on state.  ID="ch0624"ID="ch0625"RadioButton A ToggleButton in a group of ToggleButtons where only one of the ToggleButtons can be on at a time.  The graphic indicator for a RadioButton is usually a filled diamond or circle to indicate the on state or an empty diamond or circle to indicate the off state.  On color systems, the filled color can be distinct from general application colors to visually distinguish the on state.  ID="ch0626"ID="ch0627"TearOffButton A button used for tearing off a Menu to create a dialog representation of the Menu contents.  A TearOffButton tears off a Menu in place when activated, or is dragged to tear off and move in one action.  A TearOffButton usually contains a dashed line graphic representing perforations.  ID="ch0628"ID="ch0629"Field ControlsID="ch0630"Sash Used to set the boundary between two components.  A Sash is usually a small square on the boundary between two components.  The separated components are called Panes, and a group of Panes, Separators, and Sashes is called a PanedWindow.  ID="ch0631"ID="ch0632"ID="ch0633"Scale Used to set or display a value in a range.  A Scale is usually composed of a slider, moving within an element that indicates the size of the range, and a Label that indicates the current value.  The position of the slider indicates the value relative to the range.  The slider is moved directly by using the mouse pointer or by using the arrow keys.  A Scale can also have buttons with arrow graphics for moving the slider with the mouse.  ID="ch0634"ID="ch0635"ScrollBar Used to scroll the visible area of a component.  A ScrollBar is usually composed of a slider, moving within an element that indicates the full size of the component, and buttons with arrow graphics for moving the slider with the mouse.  The slider indicates the relative position and size of the visible area of the component.  The slider is moved directly by using the mouse pointer or by using the arrow keys.  ID="ch0636"ID="ch0637"List Used for selecting elements from a list of elements.  A List can allow multiple items to be selected or can be constrained to only allow one item to be selected at a time.  A List is usually composed of a vertical list of items.  A List can also have both horizontal and vertical ScrollBars for scrolling the visible portion of the list of items.  ID="ch0638"ID="ch0639"Text Used for displaying, entering, and modifying text.  There are single line and multiple line variants.  Multiline Text can have both horizontal and vertical ScrollBars for scrolling the visible portion of the text area.  ID="ch0640"ID="ch0641"Canvas Used for displaying, entering, and modifying graphics.  A Canvas can have both horizontal and vertical ScrollBars for scrolling the visible portion of the drawing area.  ID="ch0642"ID="ch0643"Basic GroupsID="ch0644"Panel Organizes a collection of components in a horizontal, vertical, or 2-dimensional layout.  A Panel is usually composed of just one type of button.  ID="ch0645"ID="ch0646"Menu Organizes a collection of buttons, Labels, and Separators in a horizontal, vertical, or 2-dimensional layout within a separate Menu window.  There are three types of Menus: Pulldown, Popup, and Option.  A Menu is only available while it is pulled down or popped up.  ID="ch0647"ID="ch0648"MenuBar Organizes a collections of CascadeButtons in a horizontal layout at the top of a MainWindow.  ID="ch0649"ID="ch0650"Layout GroupsComposition Organizes a collection of components in an arbitrary layout.  ID="ch0651"ID="ch0652"PanedWindow A linear grouping of components, Separators, and Sashes.  Sashes are used to set the boundary between two components.  The separated components are called Panes and can contain any components.  ID="ch0653"ID="ch0654"Framing GroupsID="ch0655"Frame Draws framing decorations around a component.  ID="ch0656"ID="ch0657"ScrolledWindow Frames a component and adds ScrollBars for scrolling the visible area of the component.  ID="ch0658"ID="ch0659"MainWindow Organizes the contents of a primary window.  A MainWindow frames the client area and can optionally include ScrollBars, a MenuBar, a command area, and a message area.  ID="ch0660"ID="ch0661"DialogBox GroupsID="ch0662"A DialogBox group can either be nested within another group or organizes the contents of a secondary window.  Although a DialogBox can contain any component, a simple DialogBox is composed of a Label and a Panel of PushButtons for supplying a response to the DialogBox.  The OSF/Motif toolkit provides a number of ready-designed DialogBoxes for common uses: CommandDialog, FileSelectionDialog, MessageDialog, PromptDialog, and SelectionDialog.  Several types of MessageDialog are available: ErrorDialog, InformationDialog, QuestionDialog, WorkingDialog, and WarningDialog.  LBL="6.1.1" HELPID=""Guidelines for Choosing a Main Component GroupID="ch0663"ID="ch0664"ID="ch0665"At the highest level, components are organized into MainWindows, Menus, and DialogBoxes.  Correctly deciding which component group to use for which parts of an application is one of the most important tasks of an application designer.  Every application must contain at least one MainWindow.  The MainWindow can contain a MenuBar, ScrollBars, a command area, a message area, and the client area.  The client area of the MainWindow contains the framework of an application.  The client area should contain all the components needed to perform the primary actions of the applications.  For example, in a text editor application, the MainWindow usually contains a text editing area; in a graphics editor application, the MainWindow usually contains a graphics editing area and the components for changing drawing functions.  Components that are used constantly throughout the application should be contained in the MainWindow's client area.  Components that are used intermittently or infrequently should be placed in Menus or DialogBoxes.  ID="ch0666"The advantages of Menus are that they are readily available, quickly accessed and dismissed, and easy to browse through.  The most commonly used Menus should be placed in the MenuBar in the MainWindow to increase these advantages.  Because Menus are readily available, and quickly accessed and dismissed, they should be used for components that are frequently used.  The time delays of bringing up a DialogBox for frequently used components can greatly reduce user productivity.  Because Menus are easy to browse through, they should also be used for components that are commonly accessed by most users.  ID="ch0667"The advantages of Menus also cause some disadvantages.  A Menu is a very short-lived component group.  It is displayed only while the user makes a selection.  Once the user makes a selection, the Menu disappears.  So a Menu is not well-suited for making several selections at once.  ID="ch0668"ID="ch0669"Adding a TearOffButton to a Menu can allow that Menu to remain available even after a user selection.  By activating a TearOffButton, the user changes the current Menu into a simple DialogBox with the same contents as the Menu.  A Menu with a TearOffButton allows the user to make multiple selections because the user can cause it to stay posted after a selection.  A TearOffButton is useful when it is unclear whether you should include a set of buttons in a Menu or DialogBox.  Menus, other than TearOff Menus,  are also modal; that is, while a Menu is posted, the user cannot interact with other elements of the application.  Because of this, unless a Menu can be torn off, it should not be used for components that the user may want to have available while interacting with other elements of the application.  ID="ch0670"The other disadvantage of Menus is that they can only contain buttons and Labels.  Menus should be used for performing simple actions and setting values, but they are not suitable for more complicated functions like text entry.  ID="ch0671"ID="ch0672"DialogBoxes are used for two general purposes: to present information to the user and to take user input.  Applications should use DialogBoxes to present transient information to the user, like warnings, cautions, or conformations to actions.  DialogBoxes that present information to the user are called Message DialogBoxes.  Message DialogBoxes are often placed on the screen by applications without a request from the user.  Because Message DialogBoxes can disrupt a user's work, applications should present constantly updated information in the client area of the MainWindow.  Also, applications can present minor cautions, incidental notes, and simple help in the message area of the MainWindow.  ID="ch0673"The advantages of using DialogBoxes to take user input are that they are long-lived and can contain any components.  Because they are long-lived, they can be used to perform more than one action at a time and can remain available while the user interacts with other parts of the application.  Applications should use user-input DialogBoxes like small applications.  DialogBoxes should be used to perform tasks ancillary to the application, where the user can take more than one action before dismissing the DialogBox.  Applications should also use DialogBoxes where the task requires more complicated interaction than is available in a Menu, like file selection.  IDREF="23340" TYPE="TABLE"Table 6-1 summarizes the suggested uses for MainWindows, Menus, and DialogBoxes.                                           Use This Main Component GroupCOLUMNS="4"LEFT="0" WIDTH="162"For These CasesLEFT="170" WIDTH="72"MainWindowLEFT="250" WIDTH="54"MenuLEFT="310" WIDTH="356"DialogBoxLEFT="0" WIDTH="162"Primary application actionsLEFT="170" WIDTH="72"XLEFT="250" WIDTH="54"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="310" WIDTH="356"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="162"Ancillary application actionsLEFT="170" WIDTH="72"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="250" WIDTH="54"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="310" WIDTH="356"XLEFT="0" WIDTH="162"Components used intermittentlyLEFT="170" WIDTH="72"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="250" WIDTH="54"XLEFT="310" WIDTH="356"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="162"Components used frequentlyLEFT="170" WIDTH="72"XLEFT="250" WIDTH="54"XLEFT="310" WIDTH="356"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="162"Components used seldomlyLEFT="170" WIDTH="72"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="250" WIDTH="54"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="310" WIDTH="356"XLEFT="0" WIDTH="162"Components accessed by most usersLEFT="170" WIDTH="72"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="250" WIDTH="54"XLEFT="310" WIDTH="356"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="162"Simple actionsLEFT="170" WIDTH="72"XLEFT="250" WIDTH="54"XLEFT="310" WIDTH="356"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="162"Complex actionsLEFT="170" WIDTH="72"XLEFT="250" WIDTH="54"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="310" WIDTH="356"XLEFT="0" WIDTH="162"Presenting transient informationLEFT="170" WIDTH="72"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="250" WIDTH="54"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="310" WIDTH="356"XLEFT="0" WIDTH="162"Presenting updating informationLEFT="170" WIDTH="72"XLEFT="250" WIDTH="54"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="310" WIDTH="356"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="162"Presenting minor informationLEFT="170" WIDTH="72"XLEFT="250" WIDTH="54"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="310" WIDTH="356"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LBL="6-1"Table 6-1 
ID="23340"Suggested Window TypesLBL="6.1.2" HELPID=""Guidelines for Choosing Interactive MethodsID="ch0674"ID="ch0675"Choosing the correct components for a task is usually simple.  In most cases, a task seems to naturally belong to a component; for instance, scrolling a region with a ScrollBar or choosing a value from a range with a Scale.  Each component's general purpose is described in IDREF="34542" TYPE="TITLE"Section 6.1, "Choosing Components,"
 as well as in the reference section in IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages."
  In some cases, though, it is difficult to decide between two controls or groups of controls that could perform the same task.  The following subsections give some guidelines for choosing among some common similar components: ID="ch0676"ID="ch0677"IDREF="10850" TYPE="TITLE""Choosing a Single-Choice Component"ID="ch0678"ID="ch0679"IDREF="25958" TYPE="TITLE""Choosing a Multiple-Choice Component"ID="ch0680"ID="ch0681"ID="ch0682"ID="ch0683"IDREF="21442" TYPE="TITLE""Choosing Among Menus and Panels"ID="ch0684"ID="ch0685"ID="ch0686"IDREF="19304" TYPE="TITLE""Choosing Between Text or Canvas, and a Label"LBL="" HELPID=""ID="10850"Choosing a Single-Choice ComponentID="ch0687"ID="ch0688"A single-choice component allows the user to select a single item from a group of items.  Applications should use a single-choice component to limit the user to one choice; for example, choosing among available pen widths in a drawing program.  The available single-choice components are as follows: RadioBox ID="ch0689"OptionButton ID="ch0690"ID="ch0691"List ID="ch0692"ID="ch0693"ID="ch0694"You should choose a single-choice component based on the number of items to choose among, the space available for the selection area, and the permanence of the selection.  For a small number of items, the best component is a RadioBox or an OptionButton.  RadioBoxes should usually contain no more than 5 or 6 items.  Option Menus, which are connected to OptionButtons, should usually contain no more than 10 to 12 items.  If there is very little space available in your application, you should use an OptionButton over a RadioBox, since the OptionButton takes up very little space.  ID="ch0695"ID="ch0696"ID="ch0697"When the number of items to choose from gets larger than a RadioBox or OptionButton can easily handle, you should use a List.  You should also use a List when the items to choose from can change.  For application consistency, the choices in a RadioBox or OptionButton should not change, but, if they do, you should use an OptionButton over a RadioBox.  If a RadioBox or OptionButton choice becomes unavailable, it should be disabled rather than removed.  IDREF="40206" TYPE="TITLE""Showing Unavailable Components"
 describes disabling components in detail.  LBL="" HELPID=""ID="25958"Choosing a Multiple-Choice ComponentID="ch0698"ID="ch0699"ID="ch06100"ID="ch06101"A multiple-choice control or group of controls allows the user to simultaneously choose multiple items from a group of items.  Applications should use multiple-choice components, rather than a series of single-choice actions, where the user may want to select more than one item from a group. The available multiple-choice components are as follows: CheckBox List As with single-choice components, the main factor when choosing which one to use is the number of items in the group.  For small groups of fewer than seven static elements, applications should use a CheckBox.  Applications should otherwise use a List.  Note that a List component can be used as a single-choice or multiple-choice component.  LBL="" HELPID=""ID="21442"Choosing Among Menus and PanelsID="ch06102"ID="ch06103"ID="ch06104"ID="ch06105"ID="ch06106"ID="ch06107"Popup Menus should only be considered as shortcuts to application features because they are hidden in the application.  Features hidden in Popup Menus are difficult to find for beginning users of an application because they provide no cue to their existence; however, they can provide rapid access to frequently used functionality once the user learns their contents.  Applications should use Popup Menus to allow users to remain focused on their work areas and when there is not enough space in the client area for a Panel of buttons.  Popup Menus contain a set of buttons that can be used in the same way as a Panel of buttons or a Pulldown Menu.  The primary difference is availability.  A Popup Menu is only visible when requested by the user.  At all other times it is hidden, providing no cue to its existence.  When the user requests a Popup Menu, the application displays it at the location of the pointer.  Buttons and Pulldown Menus, on the other hand, are always visible, but users need to move the focus away from their main work to activate them.  Another difference is that buttons take up screen space while Popup Menus do not.  Pulldown Menus provide a good compromise in space and availability versus Popup Menus and Panels.  ID="ch06108"Applications should use a Panel of buttons when the user makes frequent or multiple selections and when space in the client area allows.  Whenever the choice between Popup Menus and Panels is difficult, applications should favor Panels.  ID="ch06109"ID="ch06110"A good compromise solution to these problems is a TearOff Menu.  A TearOff Menu is a Pulldown Menu until the user wants it torn off into a DialogBox.  After the Menu is torn off, the user can position it and use it in the same way as a Panel.  TearOff Menus are especially useful because they contain a set of PushButtons that are not part of the main function of an application, allowing the user to activate the PushButtons multiple times in a row; for example, a font size Menu in a text editing application.  In this case, the user can use the Pulldown Menu to change the font size of a single selected word or tear off the Menu into a Panel to perform a number of font size changes in the document.  After finishing the font size changes, the user can dismiss the font size Panel.  LBL="" HELPID=""ID="19304"Choosing Between Text or Canvas, and a LabelID="ch06111"ID="ch06112"ID="ch06113"A Label is a simple mechanism for displaying text or graphics.  A Label does not have any mechanisms for the user to edit its contents, or the overhead required for editing.  Applications should use a Label for displaying text or graphics that do not need user editing.  Applications should use a Text or Canvas when the text or graphics needs to be edited.  On some systems, the contents of a Label are not selectable.  If the user needs to select the contents of some noneditable text or graphics, applications should use a Text or Canvas and disable editing rather than using a Label.  LBL="6.2" HELPID=""ID="22928"LayoutID="ch06114"The previous section described the components that are available for building an application.  This section describes how to combine those components into a coherent application that encourages a user's sense of control.  The guidelines presented in this section will help you create applications that are both consistent within themselves and with other OSF/Motif compliant applications.  This section discusses the following client area design topics: IDREF="31862" TYPE="TITLE"Section 6.2.1, "Common Client Areas"IDREF="16569" TYPE="TITLE"Section 6.2.2, "Grouping Components"IDREF="40202" TYPE="TITLE"Section 6.2.3, "Menu Design"IDREF="35577" TYPE="TITLE"Section 6.2.4, "DialogBox Design"IDREF="20313" TYPE="TITLE"Section 6.2.5, "Designing Drag and Drop"Design the layout of your application windows according to the natural use order and the natural scanning order of the people who will be using your application.  First design for the natural use order.  Consider the tasks that the user will perform with your application.  The components should be positioned so that moving among the components is simple and quick while performing the most common tasksname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the less pointer movement, the better.  This is also true for keyboard traversalname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the fewer keystrokes required to perform a task, the better.  The natural scanning order is most important when arranging small groups of components to help the user find the correct component for the task.  You should put the most important and most used commands first.  In most cases, this order is from left to right and from top to bottom.  For users in right-to-left language environments, the natural scanning direction is from right to left and from top to bottom.  LBL="6.2.1" HELPID=""ID="31862"Common Client AreasID="ch06115"ID="ch06116"ID="ch06117"ID="ch06118"ID="ch06119"ID="ch06120"ID="ch06121"ID="ch06122"Your application is presented in windows.  The windows can be either MainWindows, DialogBoxes, or Menus.  The contents of these windows are the application client areas.  Some of these client areas have common features that are described in this section.  The following subsections describe in detail the contents of the MainWindow and the common MainWindow areas: IDREF="10688" TYPE="TITLE""Command Area"IDREF="11308" TYPE="TITLE""Message Area"IDREF="27340" TYPE="TITLE""ScrollBars"IDREF="29052" TYPE="TITLE""MenuBar"Following this is a description of some common Popup Menus and DialogBoxes.  These common client areas provide a familiar base for users new to your application to begin working.  LBL="" HELPID=""ID="11199"MainWindowIDREF="37959" TYPE="GRAPHIC"Figure 6-1 shows a MainWindow with its client areas.LBL="6-1" FILE="mainw.gif" POSITION="INLINE" SCALE="FALSE"ID="ch06123"LBL="6-1"Figure 6-1 
ID="37959"A Typical MainWindow and Its Common Client AreasMainWindows contain the framework for your application.  The principal component of a MainWindow is typically a scrollable work area.  The application can also provide a group of useful controls, arranging these along the top, bottom, or side of the work area.  In a text editing application, a MainWindow usually contains the text.  In a spreadsheet application, a MainWindow usually contains the spreadsheet.  In a mail browsing application, a MainWindow usually contains a list of mail messages and an area for viewing a message.  Every application must have at least one MainWindow.  ID="ch06124"ID="ch06125"Some applications may want more than one MainWindow; for example, applications with more than one primary function, like the query and update features of a database, and applications with more than one instance of the same primary function, like a graphics editor working on multiple figures.  When an application has multiple MainWindows that serve the same primary function, each window should be treated as a separate application.  Each window must close and iconify separately.  When an application has multiple MainWindows that serve different primary functions, each window must be iconifiable separately, but it is up to the application to decide whether each closes separately or whether closing one window closes the entire application.  You should take special care to identify, using the window manager title bar or a prominent internal Label, which DialogBoxes belong to each MainWindow.  LBL="" HELPID=""ID="10688"Command AreaID="ch06126"Even though user interface applications are oriented toward direct manipulation of graphical elements, your application can provide an area for a user to enter a typed command.  This can be particularly useful when updating an existing command-based application to an application based on a graphical user interface.  If your application includes a command area, it should run from border to border across the MainWindow.  If the MainWindow includes a message area at the bottom, the command area should be placed just above the message area; otherwise, it should be placed at the bottom of the MainWindow.  The command area often consists of one or both of the following components: A command entry area, consisting of a command entry field or a CommandBox A group of PushButtons for common window actions LBL="" HELPID=""ID="11308"Message AreaID="ch06127"Your application can provide a message area in the MainWindow for presenting application messages.  Your application should not use a message area for warnings or messages requiring immediate action.  These should be displayed in a DialogBox.  The message area can be used to provide brief help, either in response to a request from the user or, as the focus changes, to indicate the purpose of the component with the focus.  If your application includes a message area, it should run from border to border across the bottom of the MainWindow, below any ScrollBars or the command area.  Your application can display and remove the message area as needed.  LBL="" HELPID=""ID="27340"ScrollBarsID="ch06128"An application can use ScrollBars in its MainWindow to provide a means for viewing an area larger than the MainWindow.  Your application defaults should place ScrollBars on the bottom and right sides of the application. (ScrollBar placement can be a user preference.)  You should place ScrollBars below the MenuBar and above any command or message area.  ScrollBars should not scroll the MenuBar, command area, or message area.  The ScrollBars can be displayed and removed as needed.  LBL="" HELPID=""ID="29052"MenuBarID="ch06129"ID="ch06130"ID="ch06131"A MenuBar is a basic group that organizes the most common features of an application.  The MenuBar must be a horizontal bar at the top edge of the application just below the title area of the window frame.  The MenuBar contains a list of Menu topics in CascadeButtons with Pulldown Menus connected to them.  A MenuBar must contain only CascadeButtons, because other buttons inhibit Menu browsing.  Each Menu topic should have a single-letter mnemonic indicated by underlining.  The following Pulldown Menus provide general functions common to most applications.  Remember that these Menu guidelines, like all the guidelines in this OSF/Motif Style Guide, apply only in a left-to-right language environment in an English-language locale.  You need to make the appropriate changes for other locales.  FileThe ID="ch06132"ID="ch06133"File Menu should contain components for performing actions on the files, such as opening, saving, closing, and printing.  It should also contain components for performing actions on the application as a whole, such as quitting.  If the Label File is not appropriate to the context of your application, you can choose a different, more appropriate Label.  The File Menu should have a mnemonic of F.  SelectedThe ID="ch06134"ID="ch06135"Selected Menu should contain components for performing actions on the objects represented by the current selection of the application, such as opening or printing a selected item.  This Menu is often similar to the File Menu, except that it acts on the objects denoted by the current selection.  For example, in a directory browser, Open in the File Menu could (using a DialogBox) prompt the user for the name of a directory to open for browsing, while Open in the Selected Menu opens the file whose icon is currently selected in the browser.  The Selected Menu should not contain editing functions normally found in the Edit Menu.  The Selected Menu should have a mnemonic of S.  EditThe ID="ch06136"ID="ch06137"Edit Menu should contain components for performing actions on the current data of the application, such as an undo action or making global substitutions in a block of text.  It should also include components for interacting with the system clipboard, such as cut, copy, and paste.  The Edit Menu should have a mnemonic of E.  ViewThe ID="ch06138"ID="ch06139"View Menu should contain components for changing the user's view on the data.  Components in the View Menu should not actually change the data.  The exact contents of the View Menu are application specific but can include components that change the appearance of the data, the amount of data that is displayed, or the order in which the data is displayed.  The View Menu should have a mnemonic of V.  OptionsThe ID="ch06140"ID="ch06141"Options Menu should contain components for a user to customize the application.  The exact contents of the Options Menu are application specific.  The Options Menu should have a mnemonic of O.  HelpThe ID="ch06142"ID="ch06143"Help Menu should contain components that provide user help facilities.  The components in the Help Menu usually bring up a DialogBox with help information.  Every application should have a Help Menu.  The Help Menu should have a mnemonic of H.  While we recommend that you include the common Menus in the MenuBar of your application, your choice of Menu titles and items depends on the nature of your application.  If your application requires it, you should design more relevant titles and selections, but do not change the meanings of items used in the common Menus.  If any of the common Menus are present, they must be arranged in the following order with respect to each other, ranging from left to right across the MenuBar in a left-to-right language environment: File Menu
Selected Menu
Edit Menu
View Menu
Options Menu
Help MenuYou can omit any of these Menus if they are not relevant to the application.  You can also intersperse other, application-specific, Menus among these Menus.  However, if a File Menu is present, it must be the first Menu and must be placed at the far left of the MenuBar.  If a Help Menu is present, it must be the last Menu and must be placed at the far right of the MenuBar.  The recommended contents of the File, Edit, and Help Menus follow.  The contents of the Selected, View, and Options Menus are application specific and are not specified here.  Each of these common Menus can contain a TearOffButton.  ID="23179"File Menu ContentsID="ch06144"ID="ch06145"IDREF="29680" TYPE="GRAPHIC"Figure 6-2 shows a sample File Menu.  The common Menu contents are described following the figure.  Note that you should only include those functions actually supported by your application.  The File Menu can contain a TearOffButton. LBL="6-2" FILE="filemenu.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-2"Figure 6-2 
ID="29680"The File Menu and Its SelectionsNewMust create a new file.  This operation must clear existing data from the client area.  If completion of the operation will obliterate current changes to the file, you must display a DialogBox, asking the user about saving changes.  This action must have the mnemonic ID="ch06146"N.  Open . . .Must open an existing file.  This operation must prompt the user for the name of the file with a DialogBox.  The ID="ch06147"title bar should be updated with the name of the newly opened file.  If completion of the operation will obliterate current changes to the file, you must display a DialogBox, asking the user about saving changes.  This DialogBox should be displayed after the user selects a new file.  This action must have the mnemonic O.  SaveMust save the currently opened file without removing the existing contents of the client area.  If the currently opened file has no name, ID="ch06148"Save must prompt for a filename with a DialogBox.  This action must have the mnemonic S.  Save As . . .Must save the currently opened file under a new name without removing the existing contents of the client area.  This operation must prompt for the name of the file with a DialogBox.  If the user tries to save the new file under an existing name, ID="ch06149"Save As must alert the user with a DialogBox if a possible loss of data would occur.  This action must have the mnemonic A.  PrintMust schedule a file for printing.  If your application requires specific printing information before printing, the operation must first request that information with a DialogBox, and the entry title must be followed by an ellipsis.  Printing information can also be specified for the application in the ID="ch06150"Options Menu.  This action must have the mnemonic P.  CloseCan be supplied in applications that have multiple independent primary windows.  This action must not be supplied in applications with a single primary window or multiple dependent primary windows.  This action must only close the current primary window and its associated secondary windows; that is, the window family.  This action must have the mnemonic ID="ch06151"C.  You can include this action even though it is similar to the Close action in the window Menu.  This ensures that users have a way to close the primary window even if they are not running a compliant window manager.  Applications must prompt the user to save any unsaved changes if the action would cause loss of data.  ExitMust end the current application and all windows associated with it.  This action is equivalent to closing all primary windows of the application.  This action must have the mnemonic ID="ch06152"X.  You should include this action even though it is similar to the Close action in the window Menu.  This ensures that users have a way to end the application even if they are not running a compliant window manager.  Applications must prompt the user to save any unsaved changes if the action would cause loss of data.  If your application does not have a File Menu, put Exit at the end of the first Pulldown Menu.  You should include Menu items in the order described.  If you add new Menu items, you should insert them near similar elements.  ID="30116"Edit Menu ContentsID="ch06153"ID="ch06154"IDREF="18078" TYPE="GRAPHIC"Figure 6-3 shows a sample Edit Menu.  The common Menu contents are described following the figure.  Note that you should only include those functions actually supported by your application.  The Edit Menu can contain a TearOffButton.  LBL="6-3" FILE="editmenu.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-3"Figure 6-3 
ID="18078"The Edit Menu and Its SelectionsUndo Alt+Backspace  Must reverse the most recently executed action.  To provide a visual cue to the user, the ID="ch06155"Undo selection title should be dynamically modified to indicate what is being undone.  For example, if the most recently executed action was a paste, the action name would be Undo paste.  Your application should be able to undo all of the actions in the Edit Menu.  This action must have the mnemonic U.  Cut Shift+DelMust remove the selected portion of data from the client area to the clipboard.  This action must choose the component to act on by following the rules in ID="ch06156"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets,"
 for operations that act on selections.  This action must have the mnemonic T.  Copy Ctrl+InsMust copy the selected portion of data to the clipboard without removing the original data from the client area.  This action must choose the component to act on by following the rules in ID="ch06157"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets,"
 for operations that act on selections.  This action must have the mnemonic C.  Copy LinkMust copy a link of the selected portion of data to the clipboard without removing the original data from the client area.  This action must choose the component to act on by following the rules in ID="ch06158"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets,"
 for operations that act on selections.  This action must have the mnemonic K.  Paste Shift+InsMust paste the contents of the clipboard into a client area.  This action must choose the component to act on by following the rules in ID="ch06159"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets,"
 for operations that do not act on selections.  This action must have the mnemonic P.  Paste LinkMust paste a link of the data represented by the contents of the clipboard into a client area.  This action must choose the component to act on by following the rules in ID="ch06160"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets,"
 for operations that do not act on selections.  This action must have the mnemonic L.  ClearMust remove a selected portion of data from the client area without copying it to the clipboard.  The remaining data is not compressed to fill the space that was occupied by the cleared data.  This action must choose the component to act on by following the rules in ID="ch06161"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets,"
 for operations that act on selections.  This action must have the mnemonic E.  DeleteMust remove a selected portion of data from the client area without copying it to the clipboard.  This action must choose the component to act on by following the rules in ID="ch06162"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets,"
 for operations that act on selections.  This action must have the mnemonic D.  Select All Ctrl+/ Must make the primary selection consist of all the elements in a component of the client area.  This action must choose the component to act on by following the rules in ID="ch06163"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets,"
 for operations that do not act on selections.  If the action uses an accelerator, it should be <Ctrl> </>.Deselect All Ctrl+\  Must remove from the primary selection all the elements in a component of the client area.  This action must choose the component to act on by following the rules in ID="ch06164"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets,"
 for operations that do not act on selections.  If the action uses an accelerator, it should be <Ctrl> <\>.Select PastedMust make the primary selection consist of the last element or elements pasted into a component of the client area.  This action must choose the component to act on by following the rules in ID="ch06165"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets,"
 for operations that do not act on selections.  Reselect Alt+Insert  Must make the primary selection consist of the last selected element or elements in a component of the client area.  This action must choose the component to act on by following the rules in ID="ch06166"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets,"
 for operations that do not act on selections.  The action must be available only in components that do not support persistent selections and only when the current selection is empty.  If the action uses an accelerator, it should be <Alt> <Insert>.Promote Alt+Insert  Must promote to the primary selection the current selection of a component of the client area.  This action must choose the component to act on by following the rules in ID="ch06167"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets,"
 for operations that act on selections.  This action must only be available for components that support persistent selections.  If the action uses an accelerator, it should be <Alt> <Insert>.You should include Menu items in the order described.  If you add new Menu items, you should insert them near similar elements.  If you use accelerators for Undo, Cut, Copy, and Paste, you must use either one or both of the models presented in the following two tables.  COLUMNS="2"LEFT="0" WIDTH="90"Edit Menu ItemLEFT="95" WIDTH="356"AcceleratorLEFT="0" WIDTH="90"UndoLEFT="95" WIDTH="356"<Alt><BackSpace>LEFT="0" WIDTH="90"CutLEFT="95" WIDTH="356"<Shift><Delete>LEFT="0" WIDTH="90"CopyLEFT="95" WIDTH="356"<Ctrl><Insert>LEFT="0" WIDTH="90"PasteLEFT="95" WIDTH="356"<Shift><Insert>LBL="6-2"Table 6-2 
Edit Menu Accelorators, Model 1COLUMNS="2"LEFT="0" WIDTH="90"Edit Menu ItemLEFT="95" WIDTH="356"AcceleratorLEFT="0" WIDTH="90"UndoLEFT="95" WIDTH="356"<Ctrl><Z>LEFT="0" WIDTH="90"CutLEFT="95" WIDTH="356"<Ctrl><X>LEFT="0" WIDTH="90"CopyLEFT="95" WIDTH="356"<Ctrl><C>LEFT="0" WIDTH="90"PasteLEFT="95" WIDTH="356"<Ctrl><V>LBL="6-3"Table 6-3 
Edit Menu Accelorators, Model 2In addition, if your keyboard has <Undo>,<Cut>,<Copy>,and <Paste> keys, these should be supported as accelerators for the corresponding Menu items as well.  ID="31011"Help Menu ContentsID="ch06168"ID="ch06169"There are two acceptable models for the contents of the Help Menu.  This guide allows either model.  IDREF="19278" TYPE="GRAPHIC"Figure 6-4 shows a sample of the first model for the Help Menu.  The common Menu contents for this model are described following the figure.  Note that you should only include those functions actually supported by your application.  The Help Menu can contain a TearOffButton.  LBL="6-4" FILE="helpmenu.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-4"Figure 6-4 
ID="19278"The Help Menu and Its Selections (First Model)On Context  Shift+Help Must initiate context-sensitive help by changing the shape of the pointer to the question pointer described inID="ch06170"ID="ch06171"IDREF="11954" TYPE="TITLE"Section 2.2.2, "Pointer Shapes."
 When the user moves the pointer to the component help is wanted on and presses BSelect, any available context-sensitive help for the component must be presented, and the pointer reverts from the question pointer.  This action must have the mnemonic C.  If the action uses an accelerator, it must be <Shift> <Help>.On HelpMust provide information on how to use the application's help facility.  This action must have the mnemonic ID="ch06172"H.  On WindowMust provide general information about the window from which help was requested.  This action must have the mnemonic ID="ch06173"W.  On KeysMust provide information about the application's use of function keys, mnemonics, and keyboard accelerators.  This action must have the mnemonic ID="ch06174"K.  IndexMust provide an index for all help information in the application.  This action must have the mnemonic ID="ch06175"ID="ch06176"I.  The index can provide search capabilities.  TutorialMust provide access to the application's tutorial.  This action must have the mnemonic ID="ch06177"ID="ch06178"T.  On VersionMust provide the name and version of the application.  This action must have the mnemonic ID="ch06179"ID="ch06180"V.  It can provide other information as well.  IDREF="38786" TYPE="GRAPHIC"Figure 6-5 shows a sample of the second model for the Help Menu.  The common Menu contents in the model are described following the figure.  Note that you should only include those functions actually supported by your application.  The Help Menu can contain a TearOffButton.  LBL="6-5" FILE="help2.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-5"Figure 6-5 
ID="38786"The Help Menu and Its Selections (Second Model)Context-Sensitive Help  Shift+Help Must initiate context-sensitive help by changing the shape of the pointer to the question pointer described in ID="ch06181"ID="ch06182"IDREF="11954" TYPE="TITLE"Section 2.2.2, "Pointer Shapes."
  When the user moves the pointer to the component help is wanted on and presses BSelect, any available context-sensitive help for the component must be presented, and the pointer reverts from the question pointer.  This action should be followed by a separator.  This action must have the mnemonic C.  If the action uses an accelerator, it must be <Shift> <Help>.OverviewMust provide general information about the application window from which help was requested.  This action must have the mnemonic ID="ch06183"ID="ch06184"O.  IndexMust provide an index for all help information in the application.  This action must have the mnemonic ID="ch06185"ID="ch06186"I.  The index can provide search capabilities.  KeyboardMust provide information about the application's use of function keys, mnemonics, and keyboard accelerators.  This action must have the mnemonic ID="ch06187"ID="ch06188"K.  TutorialMust provide access to the application's tutorial.  This action must have the mnemonic ID="ch06189"ID="ch06190"T.  Using HelpMust provide information on how to use the application's help facility.  This action must have the mnemonic ID="ch06191"ID="ch06192"H.  Product Information Must provide the name and version of the application.  This action must have the mnemonic ID="ch06193"ID="ch06194"P.  It can provide other information as well.  Applications should place additional Help Menu items between Index and Using Help.  Help is usually provided in DialogBoxes but can also appear in the message area.  You should include Menu items in the order described.  If you add new Menu items, you should insert them near similar elements.  LBL="" HELPID=""ID="14825"Popup MenusID="ch06195"ID="ch06196"A Popup Menu is a Menu that is associated with another element.  It is usually hidden from the user and is posted using BMenu and <Menu>.It is used to organize actions that are specific to its associated element, but it should not be the only place in an application where those actions are available; that is, Popup Menus should be a redundant element of a user interface whose main purpose is to provide the experienced user with a quick way to perform common tasks on individual elements.  The following common actions provide general functions common to Popup Menus in many applications.  While we recommend that you include these common actions in your Popup Menus consistently with the descriptions here, your choice of items depends on the nature of your application.  If your application requires it, you should design more relevant titles and selections, but do not change the meanings of items used in the common Popup Menus.  Even within a single control, such as a Canvas, the contents of a Popup Menu can depend on the position within the control, or the state of the elements at that position, such as whether the Menu is popped up from within a selected range of elements.  When BMenu is used to pop up the Menu, the location of the pointer when BMenu is pressed is what matters.  When <Menu> is used to pop up the Menu, what matters is the position of the location cursor within the control.  Note that you should include only those functions actually supported by your application.  Remember that these Menu guidelines, like all the guidelines in this guide, apply only in a left-to-right language environment in an English-language locale.  You need to make the appropriate changes for other locales.  PropertiesMust display a properties DialogBox that the user can use to set the properties of the component.  If the Menu is popped up over a selection, it can display the properties of the selection.  If the Menu is popped up over an unselected item, it can display the properties of that item.  If the Menu is popped up over the background, it should display the properties of the collection, except over a part of the background considered to be in the selection.  This action should have the mnemonic ID="ch06197"S.  Undo  Alt+Backspace Must reverse the most recently executed action.  To provide a visual cue to the user, the ID="ch06198"Undo selection title should be dynamically modified to indicate what is being undone.  For example, if the most recently executed action was a paste, the action name would be Undo paste.  This action should have the mnemonic U.  This action should have the same  accelerator as the corresponding entry in the Edit Menu.  Primary Move   Alt+Shift+Delete Must move the contents of the primary selection to the component.  This action must only be used in an editable component.  If the action uses an accelerator, it should be ID="ch06199"<Alt> <Shift> <Delete>,<Alt> <Ctrl> <X>,or both.  In addition, if the keyboard has a <Cut> key, this action should support <Alt> <Cut> as an accelerator.  If more than one format can be moved from the primary selection, Primary Copy can cascade a Menu of possible transfer formats, in which case it should not have an accelerator.  Primary Copy   Alt+Ctrl+Insert Must copy the contents of the primary selection to the component.  This action must only be used in an editable component.  If the action uses an accelerator, it should be ID="ch06200"<Alt> <Ctrl> <Insert>,<Alt> <Ctrl> <C>,or both.  In addition, if the keyboard has a <Copy> key, this action should support <Alt> <Copy> as an accelerator.  If more than one format can be copied from the primary selection, Primary Copy can cascade a Menu of possible transfer formats, in which case it should not have an accelerator.  Primary LinkMust place a link to the primary selection in the component.  This action must only be used in an editable component.  If the link can be viewed in more than one way, ID="ch06201"Primary Link can cascade a Menu of possible viewing representations.  CutMust cut elements to the clipboard and can mark them for use in a subsequent ID="ch06202"Paste Link operation.  If the Menu is popped up in a selection, the entire selection must be cut.  If the Menu is popped up over an unselected element, just that element should be cut.  If the Menu is popped up in the background, the entire collection can be cut.  This action should have the mnemonic T.  CopyMust copy elements to the clipboard and can mark them for use in a subsequent ID="ch06203"Paste Link operation.  If the Menu is popped up in a selection, the entire selection must be copied.  If the Menu is popped up over an unselected element, just that element should be copied.  If the Menu is popped up in the background, the entire collection can be copied.  This action should have the mnemonic C.  Copy LinkMust copy a link of elements to the clipboard and can mark them for use in a subsequent ID="ch06204"Paste Link operation.  If the Menu is popped up in a selection, a link to the entire selection must be copied.  If the Menu is popped up over an unselected element, a link to just that element should be copied.  If the Menu is popped up in the background, a link to the entire collection can be copied.  This action should have the mnemonic K.  P'aste   Shift+Insert Must paste the contents of the clipboard to the component.  This action must only be used in an editable component.  This action should have the mnemonic ID="ch06205"P.  This action should have the same accelerator as the corresponding entry in the Edit Menu.  Paste LinkMust paste a link of the contents of the clipboard to the component.  This action must only be used in an editable component.  This action should have the mnemonic ID="ch06206"L.  ClearMust remove a selected portion of data from the client area without copying it to the clipboard.  If the Menu is popped up in a selection, it must delete the selection.  If the Menu is popped up over an unselected element, it should delete that element.  If the Menu is popped up over the background, except over a part of the background considered to be in the selection, it can delete all the elements.  The remaining data is not compressed to fill the space that was occupied by the cleared data.  This action should have the mnemonic ID="ch06207"E.  DeleteMust remove a selected portion of data from the client area without copying it to the clipboard.  If the Menu is popped up in a selection, it must delete the selection.  If the Menu is popped up over an unselected element, it should delete that element.  If the Menu is popped up over the background, except over a part of the background considered to be in the selection, it can delete all the elements.  This action should have the mnemonic ID="ch06208"D.  Select All   Ctrl+/ Must make the primary selection consist of all the elements in the collection with the Popup Menu.  If the action uses an accelerator, it should be ID="ch06209"<Ctrl> </>.Deselect All   Ctrl+\ Must deselect the current selection in the collection with the Popup Menu.  If the action uses an accelerator, it should be ID="ch06210"<Ctrl> <\>.Select PastedMust make the primary selection consist of the last element or elements pasted into the collection with the Popup Menu.  ID="ch06211"Reselect   Alt+Insert Must make the primary selection consist of the last selected element or elements in the component with the Popup Menu.  The action must be available only in components that do not support persistent selections and only when the current selection is empty.  If the action uses an accelerator, it should be ID="ch06212"<Alt> <Insert>.Promote   Alt+Insert Must promote the current selection to the primary selection.  This action must only be available in components that support persistent selections.  If the action uses an accelerator, it should be ID="ch06213"<Alt> <Insert>.If an action invoked from a Popup Menu, such as Primary Copy, inserts or pastes data in a collection, the data must be pasted at the insertion position of the component.  However, if the Popup Menu is popped up over a selection of an editable collection, the selection must first be deleted, even if pending delete is disabled, and the pasted data must replace it.  If an action invoked from a Popup Menu acts on a group of elements, it behaves according to the following rules: If the Menu is popped up in a selection, it must act on the entire selection.  If the Menu is popped up on an unselected element of a list or graphics collection, it should act on just that element.  If the Menu is popped up in the background, except in a part of the background considered in the selection, it can act on the entire collection.  However, if the operation is destructive, it must first prompt for verification.  Appropriate words, such as Selection or words denoting the type of a single element of the collection as a whole, should be added to a Label to specify which elements are affected.  For example, if a Popup Menu contains the entry Copy Selection, the current selection is copied to the clipboard regardless of where in the collection the Menu is popped up.  A Popup Menu item should have an accelerator only if the result of typing the accelerator would be equivalent to popping up the Menu by pressing <Menu> and then selecting the Menu item.  If Cut Selection is included in a Popup Menu, it should use the same accelerators as Cut in the Edit Menu.  If Copy Selection is included in a Popup Menu, it should use the same accelerators as Copy in the Edit Menu.  LBL="" HELPID=""DialogBoxesID="ch06214"Applications use DialogBoxes to interact with the user about application details not directly related to the primary purpose of the application.  Applications display DialogBoxes only when needed to convey a message to the user, or when the user requests it to provide input to the application.  They follow the same general layout guidelines as a MainWindow.  Additional guidelines for DialogBox design are given in IDREF="35577" TYPE="TITLE"Section 6.2.4, "DialogBox Design,"
 as well as in the reference section in IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages."The following DialogBoxes provide general functions common to many applications.  CommandDialogID="ch06215"ID="ch06216"A CommandDialog should be used to enter keyboard commands.  It should not interrupt the user's interaction with the application; that is, it should not be modal.  It should include a CommandBox as shown in IDREF="29387" TYPE="GRAPHIC"Figure 6-6
. LBL="6-6" FILE="commandb.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-6"Figure 6-6 
ID="29387"A CommandDialogFileSelectionDialogID="ch06217"ID="ch06218"A FileSelectionDialog should be used to enter the name of a file for processing.  It should not interrupt the user's interaction with the application; that is, it should not be modal.  It should include a FileSelectionBox as shown in IDREF="30004" TYPE="GRAPHIC"Figure 6-7
.LBL="6-7" FILE="fileselb.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-7"Figure 6-7 
ID="30004"A FileSelectionDialogPromptDialogID="ch06219"ID="ch06220"A PromptDialog should be used to prompt the user for input.  It can interrupt the user's interaction with the application; that is, it can be application modal.  It should include a message, a text input area, and one of the following button arrangements as shown in IDREF="30047" TYPE="GRAPHIC"Figure 6-8
.  OK CancelOK Cancel HelpOK Apply CancelOK Apply Cancel HelpOK Apply Reset CancelOK Apply Reset Cancel HelpLBL="6-8" FILE="promptbo.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-8"Figure 6-8 
ID="30047"A PromptDialogSelectionDialogID="ch06221"ID="ch06222"A SelectionDialog should be used to allow a user to make a selection from a list of choices.  It can interrupt the user's interaction with the application; that is, it can be application modal.  It should contain a SelectionBox as shown in IDREF="21020" TYPE="GRAPHIC"Figure 6-9
. LBL="6-9" FILE="selbox.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-9"Figure 6-9 
ID="21020"A SelectionDialogID="14082"MessageDialogID="ch06223"ID="ch06224"A MessageDialog should be used to convey a message to the user.  It should include a message and one of the following button arrangements: OKOK HelpOK CancelOK Cancel HelpYes No
Yes No Help
Yes No Cancel
Yes No Cancel Help
Cancel
Cancel Help
Retry Cancel
Retry Cancel HelpThere are a number of different types of MessageDialogs: ErrorDialog, InformationDialog, QuestionDialog, WorkingDialog, and WarningDialog.  ID="ch06225"ID="ch06226"An ErrorDialog should be used to convey a message about a user error.  It should stop user interaction with the application until it is dismissed; that is, it should be application modal.  It should include an error symbol, a message, and one of the following button arrangements as shown in IDREF="35292" TYPE="GRAPHIC"Figure 6-10
. OK CancelOK Cancel HelpLBL="6-10" FILE="errorbox.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-10"Figure 6-10 
ID="35292"An ErrorDialogID="ch06227"ID="ch06228"An InformationDialog should be used to convey information to the user.  It must not interrupt the user's interaction with the application; that is, it must not be modal.  It should include an information symbol, a message, and one of the following button arrangements as shown in IDREF="34725" TYPE="GRAPHIC"Figure 6-11
. KOK HelpLBL="6-11" FILE="infobox.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-11"Figure 6-11 
ID="34725"An InformationDialogID="ch06229"ID="ch06230"A QuestionDialog should be used to get a user response to a question.  It should interrupt the user's interaction with the application; that is, it should be application modal.  It should include a question symbol, a message, and one of the following button arrangements as as shown in IDREF="12890" TYPE="GRAPHIC"Figure 6-12
. Yes NoYes No HelpYes No CancelYes No Cancel HelpLBL="6-12" FILE="questbox.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-12"Figure 6-12 
ID="12890"A QuestionDialogID="ch06231"ID="ch06232"A WarningDialog should be used to alert the user to a possible danger.  It should interrupt the user's interaction with the application; that is, it should be application modal.  It should contain a warning symbol, a message, and one of the following button arrangements as shown in IDREF="23543" TYPE="GRAPHIC"Figure 6-13
. Yes NoYes No HelpOK CancelOK Cancel HelpLBL="6-13" FILE="warnbox.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-13"Figure 6-13 
ID="23543"A WarningDialogID="ch06233"ID="ch06234"A WorkingDialog should be used to show work in progress and give the user an opportunity to cancel the operation.  It should not interrupt the user's interaction with the application; that is, it should not be modal.  It should contain a working symbol, a message, and any of the following sets of buttons in order as shown in IDREF="19916" TYPE="GRAPHIC"Figure 6-14
. CloseCancel or Stop
Pause Resume
HelpA WorkingDialog should also include a progress indicator if that information is available.  LBL="6-14" FILE="progbox.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-14"Figure 6-14 
ID="19916"A WorkingDialogLBL="6.2.2" HELPID=""ID="16569"Grouping ComponentsID="ch06235"ID="ch06236"ID="ch06237"The following subsections describe how you should group components by using the group components described in IDREF="34542" TYPE="TITLE"Section 6.1, "Choosing Components."IDREF="41487" TYPE="TITLE""Grouping Similar Components"IDREF="35726" TYPE="TITLE""Arranging Components for Fixed Layout"IDREF="36365" TYPE="TITLE""Arranging Components for Resizing Layout"IDREF="10024" TYPE="TITLE""Arranging Components for Aligned Layout"IDREF="31304" TYPE="TITLE""Arranging Components in PanedWindows"Separators are a good tool for visually separating groups of components.  You should use Separators in your application any place where the border between two groups of components is not obvious by some other means, such as for a significant change in component types, framing, or a division by space.  LBL="" HELPID=""ID="41487"Grouping Similar ComponentsID="ch06238"ID="ch06239"ID="ch06240"Components similar in appearance and function group together naturally.  You should organize similar components together.  Similar PushButtons, as in a Menu, and a Panel of CheckButtons, as in a list of options, are good examples of where grouping is important.  Without grouping, related actions are difficult to find.  One of the most important cases is a Panel of RadioButtons.  Without grouping, when you turned on one RadioButton, you might not see the previous button turn off.  You can also associate a title with a group of components to better associate the group and its purpose.  LBL="" HELPID=""ID="35726"Arranging Components for Fixed LayoutID="ch06241"ID="ch06242"Components that are grouped using a Composition group component can be positioned as they best fit, both physically and visually.  This is often the case in the MainWindow client area, and is also useful when the layout of the components is important to the application.  When you lay out components in this manner, remember that your application can be resized by the user.  This can be compensated for in a number of ways.  If the area has a fixed size and is not appropriate to scroll, like a control panel, you can either clip the area or turn off resizing.  If the area has a fixed size and is appropriate to scroll, you should include ScrollBars for scrolling the viewable area.  LBL="" HELPID=""ID="36365"Arranging Components for Resizing LayoutID="ch06243"ID="ch06244"Composition component groups can also be positioned so that the position and size of each component is relative to the Composition component group or other components in the group.  This style of layout permits the components to change size proportionally to any change in the size of the Composition component.  Sometimes a window is resized too small to be useful.  Your application can either simply ignore this, clip the region once all the components are at their minimum size, remove less useful components to make room for more shrinking, or replace all the components with a message that indicates that the minimum size is reached, stating that the user needs to enlarge the window to continue working in it.  LBL="" HELPID=""ID="10024"Arranging Components for Aligned LayoutID="ch06245"ID="ch06246"ID="ch06247"ID="ch06248"ID="ch06249"Panels can arrange components aligned horizontally, vertically, or in two dimensions.  Buttons are usually aligned in Panels horizontally along the bottom of the client area, either in a MainWindow or in a DialogBox.  ToggleButtons should be arranged in vertical Panels so the graphics align and look neat.  A common use of Panels is in building Menus or RadioBoxes; that is, a set of RadioButtons.  Two-dimensional Panels are commonly used in graphics programs to present drawing styles and in spreadsheets to contain cells.  Your application should use Panels to provide the best organization for large groups of similar components.  Panels should be placed in a Composition component group to allow for proper user resizing either by using ScrollBars or by resizing the elements of the Panel.  LBL="" HELPID=""ID="31304"Arranging Components in PanedWindowsID="ch06250"ID="ch06251"ID="ch06252"ID="ch06253"ID="ch06254"PanedWindows provide a way for the user to simply adjust the size of components relative to one another.  You should use PanedWindows to separate user tasks in an application with limited space.  This allows the user to ignore elements of the application that are unused.  PanedWindows can also be used to present two simultaneous views of the same data.  For example, a text editor can use multiple Panes, with a separate Text component in each Pane to allow the user to write in one section of a document while looking at another.  The user can then resize the Panes to show more or less of either block of text.  PanedWindows can be composed of either vertical (one on top of the other) or horizontal (side by side) sets of Panes, Separators, and Sashes.  Users can resize Panes by dragging the boundary between them.  Making one Pane bigger makes the other Pane smaller, while the overall size of the window remains the same.  LBL="6.2.3" HELPID=""ID="40202"Menu DesignID="ch06255"ID="ch06256"ID="ch06257"ID="ch06258"ID="ch06259"Menus are the primary means of organizing most of an application's features.  Because of screen size limitation and visual simplicity, Menus organize components used frequently by users and components used in most application sessions.  There are four types of Menus: Pulldown Menus TearOff Menus Popup Menus Option Menus Pulldown Menus are pulled down from a CascadeButton.  CascadeButtons should always be available in the context that they are needed.  Menus can also contain CascadeButtons so that Menus can be nested.  The MenuBar is a horizontal collection of CascadeButtons.  TearOff Menus are a combination of a TearOffButton and another Menu, usually a Pulldown Menu.  A TearOffButton contains a dashed line graphic representing perforations.  TearOffButtons must be the first element within a Menu.  When the TearOffButton is activated, the Menu changes into a DialogBox.  A TearOff Menu is useful when you do not want the Menu to disappear after a Menu selection.  Popup Menus are context sensitive, but give no cue to their existence.  They are popped up when the user presses BMenu over a component with an associated Popup Menu.  Popup Menus should only be used to provide shortcuts, since new users of an application may not realize or remember that they exist.  Even within a single control, such as a Canvas, the contents of a Popup Menu can depend on the position within the control, or the state of the elements at that position, such as whether the Menu is popped up from within a selected range of elements.  Option Menus provide a means of selecting from a set of choices while taking up very little space.  An Option Menu is popped up from an OptionButton, which is distinguished by a bar graphic on the right side of the button.  Menus are composed of titles, elements, mnemonics, and accelerators.  A Menu's title should be unique to avoid confusion.  The title should clearly indicate the purpose of the Menu.  A Pulldown Menu's title is taken from the Label in the CascadeButton.  A Popup Menu's title should be placed at the top of the Popup Menu and separated from the Menu elements by a Separator.  An Option Menu's title is usually a Label to the left of the OptionButton, but it can be at the top of the Option Menu itself.  Most basic controls can be Menu elements including Labels, Separators, PushButtons, ToggleButtons, and CascadeButtons.  The elements can be identified by either a text label or a graphic.  A Menu must be wide enough to accommodate its widest element.  ID="ch06260"A mnemonic provides a quick way to access Menu elements from the keyboard.  While the location cursor is in a Menu or MenuBar, pressing the mnemonic letter of an element activates that element.  The MenuBar's and any Option Menu's mnemonics can be used by pressing <Alt> with the mnemonic letter.  An element's mnemonic should be the first character of the element's Label.  If that character conflicts with another mnemonic in the Menu, another character in the Label should be used.  The mnemonic of an element should be underlined in the element's Label.  When the appropriate mnemonic letter does not appear in the element's Label, it should appear in parentheses after the Label.  ID="ch06261"An accelerator provides a way to access Menu elements from the keyboard without posting the Menu.  Accelerators are useful to the experienced user for saving time when using frequently used components.  You should provide accelerators primarily as a matter of utility, not design conformity.  If a keyboard accelerator exists for a Menu entry, it should appear following the Menu's Label, justified on the same line.  The accelerator and the selection should be separated by enough space to make them visually distinct.  You should use the following guidelines when designing Menus and Menu systems: Keep Menu structures simple.  Group like Menu elements together.  List Menu selections by frequency of use.  List Menu selections by order of use.  Separate destructive actions.  Provide mnemonics and accelerators.  Use TearOffButtons in frequently used Menus.  LBL="" HELPID=""Keeping Menu Structures SimpleID="ch06262"ID="ch06263"ID="ch06264"ID="ch06265"ID="ch06266"Applications should keep Menu structures simple.  One of the primary benefits of Menus is the ease of access to the elements of the Menu.  While cascading submenus help the application and the user organize Menu elements, each level of a submenu reduces the ease of access to the Menu elements.  Multiple levels of cascading submenus can also quickly create visual clutter.  Whenever you consider using a cascading submenu, you should consider using a DialogBox or more Pulldown Menus instead.  LBL="" HELPID=""Grouping Like Menu Elements TogetherID="ch06267"ID="ch06268"ID="ch06269"Applications should group Menu elements into logical groups.  This helps the user locate specific Menu elements.  You should first try to place a new Menu element into the common Menu groups described in Section 6.2.1.5.  If that is not appropriate, you should group new Menu elements according to function, with the more frequently used element appearing first.  You should also use Separators between logical groups of elements.  LBL="" HELPID=""Listing Menu Selections by Frequency of UseID="ch06270"As in other client areas, applications should order Menu elements according to the frequency of usage, positioning the most frequently used elements near the top of the Menu.  LBL="" HELPID=""Listing Menu Selections by Order of UseID="ch06271"ID="ch06272"More important to Menu design than the frequency of use is the order of use.  Applications should order Menu elements according to the order of usage.  For example, the Copy element should be placed before Paste. This helps the user's interactions flow smoothly.  LBL="" HELPID=""Separating Destructive ActionsID="ch06273"ID="ch06274"Applications should separate destructive actions from frequently chosen selections.  This is to avoid accidental selection of the destructive element.  Destructive elements, like Delete or Clear, should be placed at the end of a Pulldown Menu and separated from other elements by a Separator.  LBL="" HELPID=""Providing Mnemonics and AcceleratorsID="ch06275"ID="ch06276"Applications should provide mnemonics and accelerators to Menu elements.  Try to choose mnemonics and accelerators that are easy to remember by using letters from the element's title.  Note that mnemonics and accelerators only add to the utility of your applications.  They never detract from the basic ability of a new user.  Applications should provide accelerators for frequently used Menu items.  In general, accelerators should not be assigned for every Menu item in an application.  It is preferable to assign accelerators that have some mnemonic value, although accelerators that use function keys are acceptable.  Applications should not use accelerators that are a combination of the modifier <Alt> and letter keys to avoid conflicts with mnemonics.  For example, <Alt> <E> as an accelerator for Exit conflicts with the use of <Alt> <E> to pull down the Edit Menu since it is the mnemonic for the Edit CascadeButton in the MenuBar.  Similarly, applications that involve text entry should not use accelerators that are combinations of the modifier <Shift> and letter keys to avoid conflict with the text entry commands.  Applications that expect field controls to have bindings that include combinations of the modifier <Ctrl> and letter keys, such as text editors, should also avoid these combinations.  Accelerator bindings that use only one modifier are preferable to bindings that use two or more modifier keys.  LBL="" HELPID=""Using TearOffButtonsID="ch06277"ID="ch06278"Applications should use TearOffButtons in Menus whose elements are used many times in a row.  If the semantics of the entries in a Popup Menu depend on where in a component it is popped up, the Menu should not include a TearOffButton, unless context-sensitive entries are disabled when the Menu is torn off.  Menu entries in a torn off Menu should be enabled or disabled as appropriate when the state of the application changes.  After a user tears off a Menu, the Menu elements are placed in a DialogBox that is titled with the Menu title, and the Menu is unposted.  The TearOffButton should be removed from the DialogBox, but, if it remains, it can be used to close the DialogBox.  LBL="6.2.4" HELPID=""ID="35577"DialogBox DesignID="ch06279"ID="ch06280"When designing a DialogBox, you should follow all the same layout principles as for other applications areas.  DialogBoxes are usually transitory.  The user usually wants to simply respond and get back to the primary tasks of the application.  To help the user respond quickly, there are a number of common DialogBox actions.  By using and ordering these actions consistently, you provide the user with cues to quickly respond to each DialogBox.  When a DialogBox is displayed, all components within the DialogBox should reflect the current state of the application.  For example, if the DialogBox is used for changing the current font in a text editor, the DialogBox should be initially displayed with the current font.  If the DialogBox is modeless, then any changes to the application should be updated in the DialogBox.  DialogBoxes can limit how a user can interact with other windows in order to force the order of interaction.  These limitations, which are called modes, are described in the following text.  Modeless Allows interaction with the secondary window and all other windows.  ID="ch06281"Primary modal Does not allow interaction with any ancestor of the window.  ID="ch06282"Application modal Does not allow interaction with any window created by the same application even if the application has multiple primary windows.  ID="ch06283"System modal Does not allow interaction with any window on the screen.  This includes windows from all other applications and any ID="ch06284"icon box.  To indicate a system modal secondary window, the pointer should change shape to a caution pointer whenever it leaves the system modal secondary window.  Remember that the guidelines presented in this section, like all the guidelines in this guide, apply only in a left-to-right language environment in an English-language locale.  You need to make the appropriate changes for other locales.  LBL="" HELPID=""ID="28469"Common DialogBox ActionsID="ch06285"ID="ch06286"ID="ch06287"While your application can sometimes require special DialogBox actions, most share common actions.  The common actions provide a consistent means for the user to quickly respond to DialogBoxes and get back to the primary application tasks.  The common actions should be presented in a horizontal collection of PushButtons at the bottom of the DialogBox, separated from the rest of the DialogBox by a Separator.  No DialogBox will contain all of the common actions in the following list.  You should use the ones appropriate to your application or determine new actions so they do not conflict with the common actions listed.  If you create a new action, you should give it an active-voice label that indicates its purpose.  An active-voice label describes the action that pressing the button causes.  The actions are listed in the approximate sequence in which they should appear in DialogBoxes as follows: YesMust indicate an affirmative response to a question posed in the DialogBox and then close the window.  While ID="ch06288"Yes is not an active-voice label, it implies a positive response to a question in a QuestionDialog or a WarningDialog.  Only use Yes if it is a clear answer to the question.  NoMust indicate a negative response to a question posed in the DialogBox and then close the window.  While ID="ch06289"No is not an active-voice label, it implies a negative response to a question in a QuestionDialog.  Only use No if it is a clear answer to the question.  OKMust cause the application to apply any changes and perform related actions specified by the components in the DialogBox and then dismiss the DialogBox.  While ID="ch06290"OK is not an active-voice label, its usage is too common to change.  CloseShould cause the current DialogBox to be closed without performing any of the actions specified by the components in the DialogBox.  This action is usually only available in a DialogBox that provides status information, such as a WorkingDialog.  This Label can also be used if the actions in the DialogBox cannot be reversed, in which case this Label replaces ID="ch06291"Cancel after the first irreversible action is performed.  ApplyMust apply any changes and perform related actions specified by the components in the DialogBox.  ID="ch06292"RetryMust cause the task in progress to be attempted again.  This action is commonly found in message boxes that report an error.  ID="ch06293"StopMust end the task in progress at the next possible breaking point.  This action is commonly found in a WorkingDialog.  ID="ch06294"PauseMust cause the task in progress to pause.  This action is commonly found in a WorkingDialog and should be used in combination with ID="ch06295"Resume.  ResumeMust cause a task that has previously paused to resume.  This action is commonly found in a WorkingDialog and should be used in combination with ID="ch06296"Pause.  ResetMust cancel any user changes that have not been applied to the application.  It must also reset the status of the DialogBox to the state since the last time the DialogBox action was applied or to the initial state of the DialogBox.  ID="ch06297"CancelMust close the DialogBox without performing any DialogBox actions not yet applied to the application.  Pressing ID="ch06298"<Cancel> anywhere in the DialogBox, except during a cancelable drag operation, must perform the action of this button.  HelpMust provide any help for the DialogBox.  ID="ch06299"If a DialogBox action causes an error, the DialogBox should not be dismissed before the error is displayed.  Instead, the DialogBox should remain available after the error is dismissed to give the user a chance to correct the error and reuse the DialogBox.  If the actions to be performed by OK or Apply depend on the state, then these Labels should be replaced by ones that indicate the action to be performed.  LBL="" HELPID=""Arranging Common ActionsYou should arrange PushButton actions in DialogBoxes in the same way you arrange other PushButtons, according to order and frequency of use.  The common action PushButtons should be ordered as presented in the previous section.  Positive responses to the DialogBox should be presented first, followed by negative responses, and canceling responses.  Help should always be the last action on the right.  The following rules should be used when determining what default buttons to place in a DialogBox: Modal DialogBoxes should use one of the following button arrangements unless superseded by another rule: OK CancelOK Cancel HelpModeless DialogBoxes should use one of the following button arrangements unless superseded by another rule: OK Apply CancelOK Apply Cancel HelpOK Apply Reset CancelOK Apply Reset Cancel HelpInformation DialogBoxes should use one of the following button arrangements: OKOK HelpQuestion DialogBoxes should use one of the following button arrangements: Yes NoYes No HelpIt is possible that both the Yes and No actions of a Question DialogBox will perform an action.  If this is the case, the Question DialogBox should use one of the following button arrangements: Yes No CancelYes No Cancel HelpWarning DialogBoxes should use one of the following button arrangements: Yes NoYes No HelpOK CancelOK Cancel HelpWorking DialogBoxes should contain any of the following sets of buttons in order: CloseCancel or Stop
Pause Resume
HelpLBL="" HELPID=""Determining DialogBox Location and SizeID="ch06300"ID="ch06301"Your application determines the size and location of its DialogBoxes.  You should size and place DialogBoxes so that they do not obscure important information in other windows of your application.  The initial size of a DialogBox should be large enough to contain the dialog components without crowding or visual confusion, but otherwise should be as small as possible.  DialogBoxes should follow the same rules for resizing as a MainWindow as described in IDREF="36365" TYPE="TITLE""Arranging Components for Resizing Layout"
 in this chapter.You should place DialogBoxes on the screen so they are completely visible.  In general, you should place DialogBoxes close to either the component that caused it to be displayed, the current action, or the information needed to respond to it.  When a DialogBox relates to an item in an underlying window, you should position the DialogBox to the right of the item.  If there is not enough room to the right of the item, try to position the DialogBox to the left, below or above the item, in that order, depending on screen space available.  You should only obscure related information as a last resort.  If a DialogBox does not relate to items in the underlying windows, the DialogBox should be placed centered in the application's work area.  If two DialogBoxes need to overlap, you should offset the top DialogBox to the right and below the title of the lower DialogBox.  Use your best judgement, knowing that the screen area for DialogBoxes is limited.  While the previous suggestions seem simple enough, they cannot always be followed completely.  Therefore, DialogBoxes, once displayed, should be movable so that the user can relocate them as needed to see information in underlying windows.  LBL="6.2.5" HELPID=""ID="20313"Designing Drag and DropBy default, applications allow the user to drag text from just about everywhere and drop it into any writable Text component.  If you want to use the features of drag and drop to and from other components in your application, you need to design these features into your application.  The most important decision you need to make in designing drag and drop into your applications is which elements you want to make draggable and which components you want to allow drops onto.  When making this decision, keep in mind that drag and drop not only transfers data within an application but also between applications.  Therefore you need to consider the impact of unfamiliar data being dropped into your application, and in which formats you want to allow your own application's data to be transferred out.  The following subsections discuss the following other application considerations when designing drag and drop into your application: IDREF="17547" TYPE="TITLE""Drag Icon Design"IDREF="14982" TYPE="TITLE""Drag Source Effects"IDREF="15164" TYPE="TITLE""Drag-Under Effects"IDREF="11865" TYPE="TITLE""Providing Help on Drop Sites"IDREF="23988" TYPE="TITLE""Determining Transfer Formats"IDREF="15420" TYPE="TITLE""Indicating Drop Failures"LBL="" HELPID=""ID="17547"Drag Icon DesignAt the start of a drag operation, the pointer is replaced with a drag icon.  The drag icon is defined by the application for each draggable element and can be composed of the following: A source indicator An operation indicator A state indicator The source indicator should give a visual representation of the primary data type of the draggable element; for example, horizontal lines in a rectangle for representing text or a color palette for representing a color tool.  All drag icons must include a source indicator.  IDREF="29041" TYPE="GRAPHIC"Figure 6-15
 shows move, copy, and link drag icons for graphics and textual information.  LBL="6-15" FILE="dragicon.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-15"Figure 6-15 
ID="29041"Drag IconsThe operation indicator shows whether a drop will result in a move, copy, or link of the transferred data.  Most drag icons should include an operation indicator, but an operation indicator should only be included in the drag icon when the result of the drop operation is a data transfer.  The operation indicator can be shown either as a separate element of the drag icon or as a variation of the graphic used for the source indicator.  The state indicator shows whether the current pointer location is over a valid drop site for the dragged elements.  The state indicator can show three different states: Valid drop site name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' The hotspot of the drag icon is over a valid drop site for the data the user is dragging.  A drop at this point usually results in a successful transfer.  Invalid drop site name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' The hotspot of the drag icon is over a drop site, but the data the user is dragging is not compatible with the drop site.  A drop at this point results in a failed transfer.  No drop site name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' The hotspot of the drag icon is not over a drop site.  A drop at this point results in a failed transfer.  All drag icons can include a state indicator.  The state indicator should be coincident with the hotspot of the pointer.  The state indicator can be a separate element in the drag icon or a change in the visual representation of the drag source.  When defining new drag icons for your application, you should follow the same rules as for defining any other new pointers described in IDREF="11954" TYPE="TITLE"Section 2.2.2, "Pointer Shapes."LBL="" HELPID=""ID="14982"Drag Source EffectsThe source of the dragged elements can also provide visual indications of the result of a drop.  For example, if the default operation for the dragged elements is a move, the source can be hidden or deemphasized; or, if the default operation of the dragged elements is a link, a line can be drawn from the source to the pointer.  LBL="" HELPID=""ID="15164"Drag-Under EffectsA drag-under effect is a change to the visual state of a possible valid drop site when the drag icon pointer is over the drop site.  All drop sites should use some kind of drag-under effect.  Drop sites can use a solid line around the site, or a raised or lowered beveled edge around the drop site, as a drag-under effect.  Drop sites can also change any visual component of the drop site, or even animate those changes, as a drag-under effect.  For example, an icon representing a folder might show an animated image of the folder opening as a user drags a file onto it.  LBL="" HELPID=""ID="11865"Providing Help on Drop SitesHelp on drag and drop operations should be provided by the drop site under the drag icon pointer at the time help is requested.  If a drop site gets a help request during a drag and drop operation, the drop site application should post a DialogBox with help information about the results of a drop at that location and the choices for the completion of the drag and drop operation.  The DialogBox should allow for canceling the drag and drop operation or dropping the elements at the current location as a move, copy, or link.  The drag and drop help DialogBox should be an Information DialogBox with a message describing the possible results of a drop at that location.  The first button in the row of buttons at the bottom of the DialogBox should contain the default transfer option (Move, Copy, or Link) or OK for the single transfer action described in the text of the DialogBox.  If the user has not specified a transfer option using modifier keys, and more than one is possible, then: If there is a valid move transfer option, the DialogBox should contain the move transfer option on a button labeled Move.  If there is a valid copy transfer option, the DialogBox should contain the copy transfer option on a button labeled Copy.  If there is a valid link transfer option, the DialogBox should contain the link transfer option on a button labeled Link.  The DialogBox should not include an OK button.  Drag and drop help DialogBoxes must contain a Cancel button for canceling the drag and drop operation in progress.  The DialogBox can contain a Help button for providing further help on the DialogBox actions.  LBL="" HELPID=""ID="23988"Determining Transfer FormatsAfter a drop operation, the application containing the drop site determines the best format to use to transfer the data, based on the data types that the drag source can send.  The drop site can use any heuristic to determine this format.  If multiple transfer formats (in the case of links, multiple view formats) are acceptable in the drop site, the drop site application should let the user choose the correct transfer format either through a customization feature or through a DialogBox that lists the possible choices.  The DialogBox should be a Question DialogBox asking the user to choose the best transfer format.  The DialogBox must provide a choice of available transfer formats.  The choice can be provided as a row of buttons along the bottom of the DialogBox, or in a RadioBox within the QuestionDialog.  Using either method, there must be a Cancel button in the bottom row of buttons in the DialogBox.  The DialogBox can also include a Help button that provides help on the results of a drop at the current location.  If the DialogBox uses a RadioBox to present the format choices, the most likely format should be first and initially selected, formats that are currently invalid should be set insensitive, and the DialogBox must include an OK button in the bottom row of buttons for accepting the RadioBox choice.  A Popup Menu can be used instead of a DialogBox to let the user choose the format.  LBL="" HELPID=""ID="15420"Indicating Drop FailuresIn most cases, the system indicates drop failure automatically.  If your application allows partial success on transfers, it should post messages about partial failure that provide enough information for the user to recover from the failures.  LBL="6.3" HELPID=""ID="26054"InteractionThis section gives guidelines for creating applications with consistent interactions.  When an application behaves as expected and the user is not surprised by the results of the actions, the user can complete tasks quicker.  The following subsections present the following guidelines for good application interaction: ID="ch06302"IDREF="34503" TYPE="TITLE"Section 6.3.1, "Supplying Indications of Actions"ID="ch06303"IDREF="12531" TYPE="TITLE"Section 6.3.2, "Providing Feedback"IDREF="41081" TYPE="TITLE"Section 6.3.3, "Allowing User Flexibility"LBL="6.3.1" HELPID=""ID="34503"Supplying Indications of ActionsThe first step to consistent interaction is to provide cues to the result of every action.  This means that actions of components should be indicated by the component's shape, label, and graphics.  It also means that the actions and interactions of components should remain consistent, so the user always knows what to expect.  Lastly, it means that interactions should be simple.  As interactions become complicated, it also becomes difficult to visually represent the interaction.  Complicated interactions and components create the possibility for more errors.  Even the most complicated concepts can be clarified by careful organization, so, if your application's interactions seem complicated, consider reorganizing them for simplicity.  LBL="" HELPID=""Using Common ComponentsUsers expect components to behave consistently across all applications.  PushButtons always perform an action.  OptionButtons always provide selections.  Because of this, when users want to perform an action, they look for a PushButton, usually in a Menu.  They do not look for an OptionButton.  You should use the components that are provided when appropriate, rather than create new ones.  You should not alter the look of a component so drastically that its type is unrecognizable.LBL="" HELPID=""Using Intuitive LabelsOne of the best indicators of the action of a component is its Label.  The Label can be either text or a graphic.  You should choose your Labels carefully to indicate the action of each component.  Components that perform actions should be labeled with active verbs.  Components that present options should be labeled with nouns.  You should also label component groups, including Panels, with nouns to indicate the contents of the group.  Consider the use of graphics as Labels with two cautions.  Graphic Labels cannot be nouns or active verbs, so choose a graphic whose meaning is clear in the context of the component.  Also remember that, while graphic symbols are very language independent, they can be highly culture specific.  In some cultures, a mailbox graphic can indicate a mailer action; but, since mailboxes are not common in all cultures, an envelope graphic may be better, or you can provide a mechanism for changing the graphic based on the locale.  LBL="" HELPID=""Using Graphics to Show ActionID="ch06304"Many components also include a small graphic symbol following the Label to indicate the action of the component.  CascadeButtons should use an arrow graphic that points in the direction the cascading Menu will appear.  OptionButtons should use a rectangle graphic to distinguish them from PushButtons.  Any component that needs more information to complete its action should include an ellipsis following the Label.  This additional information should be requested in a DialogBox.  The ellipsis should not be used to indicate that the component will post a DialogBox.  The ellipsis should be included only if the purpose of the DialogBox is to gather more information needed to complete the requested task.  For example, the Menu choice Print would use an ellipsis if a DialogBox is posted requesting print characteristics prior to the printing action, but the Menu choice Help would not use an ellipsis even though the help information is presented in a DialogBox.  All previously mentioned graphics should follow the text or graphic of the Label.  In left-to-right language environments, the graphic should be on the right.  In right-to-left language environments, the graphic should be on the left.  Note that the graphic indicating the state of a ToggleButton precedes the Label in a left-to-right language environment.  LBL="" HELPID=""Showing Default ActionsID="ch06305"ID="ch06306"Your application should use default values for common settings or obvious selections.  Default values should be shown in the on state.  For example, the default value for a Text area should be in the Text area in the selected state whenever text entry is requested; the default selection in a List should be set in the selected state whenever a list selection is requested; or the default RadioButton should be filled in a Panel at application start-up time.  In any case, once the state is changed, the new state should take the place of the default until the state is reset.  Your application can decide whether to save its state after being closed.  Groups of controls, such as a DialogBox, can also have a default action.  The default action is usually activated by pressing <Enter> or <Return>.The default action of a component group should be distinguished from the other selections by an extra border as shown in IDREF="33479" TYPE="GRAPHIC"Figure 6-16
. LBL="6-16" FILE="dfltbut.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-16"Figure 6-16 
ID="33479"A Default PushButtonThe OK PushButton should be the default PushButton in modal DialogBoxes and modeless DialogBoxes that are transient.  The Apply PushButton should be the default PushButton in a modeless DialogBox that is likely to be displayed for multiple actions.  Using the keyboard to navigate through the PushButtons, the button with the location cursor should become the default PushButton.  This ensures that pressing <Enter> or <Return> over a PushButton invokes the correct PushButton.  When the location cursor leaves the PushButtons, the original default button should once again become the default.  LBL="" HELPID=""Avoiding Component ModesID="ch06307"ID="ch06308"ID="ch06309"A component has modes when its action changes based on some previous action or the state of the application.  This is very confusing to the user, who was expecting the original action of the component.  Components in your application should not have modes.  Your application should use multiple components rather than modal components.  LBL="" HELPID=""ID="40206"Showing Unavailable ComponentsID="ch06310"As the state of your application changes, certain components become inappropriate.  For example, the Minimize selection in a window Menu is inappropriate when the window is already minimized.  In such cases, you should make the inappropriate components unavailable.  This is also called disabling the components.  Disabled components should be visually deemphasized, usually by graying the Label of the component.  You should not remove unavailable components from the application client areas.  The components should remain visible to remind the user of their existence and to ensure application consistency.  IDREF="12586" TYPE="GRAPHIC"Figure 6-17
 shows a disabled Menu element.  LBL="6-17" FILE="disable.gif" POSITION="INLINE" SCALE="FALSE"LBL="6-17"Figure 6-17 
ID="12586"A Disabled Menu ElementYou should disable Menu items and components to help avoid errors.  In general, you should disable the lowest level component that results in an irreversible error state.  For example, consider a graphics editor that has a DialogBox that is used for aligning selected graphics objects.  If the user might want to see the choices in the DialogBox even if the choices are not available, this DialogBox should be displayable at all times; its Menu item should not be disabled.  If there are no graphics objects to align, the DialogBox should still be displayed, but its OK and Apply buttons should be disabled.  Once graphics objects are selected, the OK and Apply buttons should become enabled.  Menu items that are inappropriate and that result in error messages should be disabled.  Some examples are the Edit Menu's Cut and Copy actions when nothing is selected.  The Edit Menu's Undo entry should be disabled if the last operation cannot be undone.  Menu items that perform no action need not be disabled.  For example, the New entry in the File Menu need not be disabled immediately after it is invoked.  It can be selectable repeatedly, even though it performs no new action, because it does not result in an error state.  A Menu item that displays a modal DialogBox should be disabled if it would cause an error either on display of the box, or on clicking the OK or Apply buttons in the DialogBox.  Since the DialogBox is modal, nothing can be changed in the application to correct the error until the box is dismissed, and it should not be displayable until the application is in a state that makes the action of the DialogBox possible.  Menu items that display modeless DialogBoxes should never be disabled.  If a box is modeless, the user can change the state of the application at any time to make the DialogBox useful.  If the action cannot be completed because some necessary information is not yet available, then the OK and Apply buttons should be disabled.  After a TearOff Menu is torn off, an application can disable elements that are not appropriate in the torn off state.  Elements in a torn off Menu can be disabled in the same manner as elements in any other Menu or DialogBox.  You should avoid frequently disabling and enabling components in situations where the state change would cause a distracting flashing.  For example, editing a Text component in a DialogBox can cause some buttons to be inappropriate at each invalid text value.  In this case, you should display an error message if the OK or Apply button is clicked for an inappropriate text value.  Of course, the error message should explain the valid text values.  LBL="6.3.2" HELPID=""ID="12531"Providing FeedbackID="ch06311"Another important element to user interaction is providing feedback about the current state of the application.  This is done, as described in the previous section, by using labels and graphics and by keeping the interface consistent.  Your application should also dynamically indicate the state of the application's actions.  For example, the mouse pointer shape changes to indicate when and where special actions can occur.  IDREF="16621" TYPE="TITLE"Chapter 2, "Input Models"
 describes mouse pointer shapes in detail.  Other ways to provide the user feedback are described in the following subsections.  LBL="" HELPID=""Showing ProgressID="ch06312"ID="ch06313"If an action takes a long time to complete, the user may mistake the delay to mean that the system or the application stopped working.  For actions that take a long time to complete, your application should indicate that there will be a delay with a WorkingDialog.  If your application can track the progress of long actions, it should try to update the WorkingDialog with the progress of the action.  LBL="" HELPID=""ID="29352"Providing WarningsID="ch06314"Certain actions can cause destructive results, such as closing an application before saving changes in the current file.  Applications should not disallow such destructive actions; instead, they should warn the user of the consequences with a WarningDialog.  The WarningDialog must allow the user to cancel the destructive action.  Note that too many WarningDialogs can be disruptive to the user's main task.  WarningDialogs should be reserved for truly destructive actions.  For destructive actions that can easily be recovered, applications should provide undo actions to reverse them; for example, the Undo element of the Edit Pulldown Menu.  LBL="" HELPID=""Providing HelpID="ch06315"ID="ch06316"Even in the most intuitive application, the purpose of a component or the way to do a task can be hard to figure out for a new user.  Your application should provide a help mechanism for all of its aspects.  IDREF="29052" TYPE="TITLE""MenuBar"
 and 
IDREF="31011" TYPE="TEXT"
 "Help Menu Contents," describe the most common base for a help mechanism, the Help Pulldown Menu on the MenuBar.  Context-sensitive help should also be available by using <Help>.LBL="6.3.3" HELPID=""ID="41081"Allowing User FlexibilityID="ch06317"Good user-application interaction should also allow user flexibility.  No matter how well your application is designed, some users will not like parts of it.  They will want to change some elements of it; for example, from simple elements like the colors and fonts to complicated elements like the default values.  You should allow users to adjust elements of your applications because it increases their sense of control over the applications.  You should consider the following attributes of your applications for user customization: Application parameters Colors Fonts Default values Key bindings Labels Messages Help information The exact list of attributes you should allow the user to customize depends on your application.  LBL="6.4" HELPID=""ID="24980"Component DesignFor consistency with other applications, you should always try to use existing components for your application tasks, but there are cases where new components are needed.  In designing new components, you should follow the same rules as application designers follow.  You should think of components as small applications.  They perform a task, present information to the user, and take information from the user.  New components must follow the guidelines for designing applications.  ID="ch06318"ID="ch06319"The first step to designing a new component is to compare its features with those of the other components.  If the new component has a feature that is the same as another component, the mechanisms for using the feature, layout, key bindings, graphics, and so on, should be the same in the new component.  You should also try to match the appearance style of components on your system.  Most OSF/Motif compliant systems use a 3-dimensional beveled presentation style.  Appearance is not specified as a matter of component style in this guide; however, any new components will assimilate better with existing components if they are designed to conform to the implied appearance style for the system on which they will be used.  LBL="7"ID="24491"Window Manager Design PrinciplesA window manager is a specialized application.  In designing a window manager, you must follow the same principles as for any other application.  A window manager must also follow the style guidelines for input, navigation, selection, and activation models as set forth in Chapter 2 through Chapter 5. ID="ch071"ID="ch072"There are a few elements of user interface design that are specific to window managers.  This chapter discusses the following elements: IDREF="33057" TYPE="TITLE"Section 7.1, "Configurability"IDREF="27625" TYPE="TITLE"Section 7.2, "Window Support"IDREF="21171" TYPE="TITLE"Section 7.3, "Window Decorations"IDREF="33250" TYPE="TITLE"Section 7.4, "Window Navigation"IDREF="32482" TYPE="TITLE"Section 7.5, "Icons"LBL="7.1" HELPID=""ID="33057"ConfigurabilityID="ch073"ID="ch074"This chapter describes only those elements of window manager design that help create a consistent user interface.  A window manager can supply a mechanism that allows the user to configure the window manager.  The window manager can make any element user-configurable, including key bindings, Menu contents, default window decorations, or any other rules and elements defined in this guide.  Any window manager that supplies a configuration mechanism must also include support for toggling between the current user configuration and the default configuration as mandated by this guide.  The configuration toggle key press, <Alt> <Shift> <Ctrl> <!>,must initiate a configuration toggle.  When the user issues a request to toggle the configuration, the window manager should request user verification before proceeding.  LBL="7.2" HELPID=""ID="27625"Window SupportID="ch075"ID="ch076"Users communicate with applications by using windows.  A window is an area of the screen (usually rectangular) that provides the user with the functional means to communicate with an application and through which an application can communicate with the user.  ID="ch077"ID="ch078"ID="ch079"ID="ch0710"ID="ch0711"ID="ch0712"ID="ch0713"ID="ch0714"ID="ch0715"A typical environment has several applications in operation simultaneously.  Each application typically has a main or primary window that displays data and in which the user carries on primary interaction with the application.  Applications can have additional windows to communicate context-specific interactions with the user of the application.  These additional windows are called secondary windows, or transient windows.  DialogBoxes are often used to create secondary windows.  IDREF="17177" TYPE="GRAPHIC"Figure 7-1
 illustrates a typical OSF/Motif environment.  LBL="7-1" FILE="rootpix.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-1"Figure 7-1 
ID="17177"A Typical OSF/Motif User EnvironmentWhile each application can be made up of many windows, each window is one of only three basic types: A primary window, the main application window ID="ch0716"ID="ch0717"A secondary window, a window that provides secondary and transient interaction with the user ID="ch0718"ID="ch0719"ID="ch0720"ID="ch0721"A Menu window, a temporary window for displaying a Menu of choices for the user ID="ch0722"ID="ch0723"A window manager must support multiple applications, each with one or more primary windows.  The window manager must also recognize and support secondary windows.  Also, it must associate each secondary window with a primary window or another secondary window.  LBL="7.2.1" HELPID=""Primary WindowID="ch0724"ID="ch0725"ID="ch0726"ID="ch0727"A primary window is the window from which all the other windows used by an application are generated.  The window manager must support one or more primary windows for each windowing application.  When an application has multiple primary windows, the window manager should treat each primary window as if it were an independent application.  ID="ch0728"ID="ch0729"ID="ch0730"ID="ch0731"ID="ch0732"ID="ch0733"When a primary window is iconized (minimized), the window and all of its associated secondary windows must be removed from the display and replaced with a single icon representing the primary window.  Iconizing a window must not automatically suspend any processes of the window.  However, a client can notice that a primary window has been unmapped and adjust its processing accordingly.  When the icon of the window is opened, the primary window and all the current associated secondary windows must be restored.  The window manager should try to place the windows in the same position from which they were iconified.  ID="ch0734"When a primary window is closed, the window and its icon must be removed from the display.  All secondary windows associated with the primary window must also be closed.  If the last primary window of an application is closed, the application must also be closed.  When an explicit focus policy is in use, any secondary windows holding a TearOff Menu can be removed from the display, except when another window of the application has the focus.  LBL="7.2.2" HELPID=""Secondary Windows (Dialog)ID="ch0735"ID="ch0736"ID="ch0737"ID="ch0738"Applications use secondary windows to conduct context-specific dialog with the user.  Such context-specific dialogs are usually transitory, and the secondary windows can be removed when they are no longer needed.  When a secondary window is closed, its parent must not be affected, and any secondary windows that are children of it must also be closed.  Secondary windows are always related to a parent window.  Sometimes the parent is a primary window, sometimes another secondary window.  Any window can have any number of secondary window children.  Secondary windows are not constrained to be clipped within their parent window, but they must always appear on top of that parent window in the window hierarchy.  In a layered window manager, you can think of a primary window and its associated secondary windows as occupying one layer in the window hierarchy.  Whenever one window is moved in the hierarchy, all of the associated windows must move accordingly.  Thus, lowering a window must move that window and all associated windows to the bottom of the window hierarchy.  Giving a window the focus must raise that window and all of the associated windows to the top of the hierarchy.  Secondary windows can limit how a user can interact with windows in order to force the order of interaction.  A window manager must support the following four types, known as modes, of interaction with secondary windows: Modeless Allows interaction with the secondary window and all other windows.  ID="ch0739"ID="ch0740"ID="ch0741"ID="ch0742"ID="ch0743"ID="ch0744"ID="ch0745"ID="ch0746"ID="ch0747"ID="ch0748"ID="ch0749"Primary modal Does not allow interaction with any ancestor of the window.  Application modal Does not allow interaction with any window created by the same application, even if the application has multiple primary windows.  System modal Does not allow interaction with any window on the screen.  This includes windows from all other applications and any icon box.  To indicate a system modal secondary window, the pointer should change shape to a caution pointer whenever it leaves the system modal secondary window.  A window manager must not allow the focus to be given to any window that is not allowed to accept input because of the modality of a DialogBox.  LBL="7.2.3" HELPID=""Menu WindowsID="ch0750"ID="ch0751"Menu windows are used to present Menus.  They are not specifically created by applications but by the components used to create the application.  Menu windows are always related to a parent window.  The parent can be either a primary window, secondary window, or another Menu window.  A window can only have one Menu window child at a time.  A Menu window is very short lived.  It is only available to a client while no mouse or button actions are being performed elsewhere on the screen.  Once interaction starts in another window on the screen, except a child Menu window, the Menu window must be removed.  Some Menus have a special behavior that allows a user to convert them into a secondary window.  These Menus are called TearOff Menus.  TearOff Menus can either be torn off in place or torn off and moved simultaneously.  The window's title should be the name of the Menu entry that was torn off.  The window manager must allow TearOff Menu transformations from Menu window to secondary window.  Menu windows are not constrained to be clipped within their parent window, but they must always appear on top of that parent window in the window hierarchy.  The window manager must not supply any window decoration to Menu windows.  LBL="7.3" HELPID=""ID="21171"Window DecorationsID="ch0752"ID="ch0753"ID="ch0754"ID="ch0755"ID="ch0756"ID="ch0757"A window manager can provide windows with a window frame that contains components called decorations.  The window decorations allow user interaction with the window manager.  Along with the frame components, a window manager contains a client area.  The client area is the display area for an application.  IDREF="35702" TYPE="GRAPHIC"Figure 7-2
 shows a typical window and its decorations.  LBL="7-2" FILE="wmcalls2.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-2"Figure 7-2 
ID="35702"A Typical OSF/Motif Window LayoutA window manager can support any number of window decorations, but it must support the client area and the window frame.  A window manager must support the following window frame components: Title area ID="ch0758"Maximize button ID="ch0759"Minimize buttonID="ch0760"Resize borderID="ch0761"Window Menu buttonID="ch0762"Each window must have a client area.  A window manager must allow each window to choose which combination of decorations to include, except that a window must not have any buttons without a title area.  A primary window must by default have all the decorations: window Menu button, maximize button, minimize button, title area, and resize border.  A secondary window must by default have a window Menu button and title area.  In a secondary window, resize borders and a maximize button can be provided if there is a reason to resize the window.  Clicking BSelect on the window frame should give the window focus and raise the window to the top of the window hierarchy, except when dialog modality disallows focus to be set in the window.  LBL="7.3.1" HELPID=""Client AreaID="ch0763"The client area is the portion of the window in which the user performs most application-level tasks.  For example, if the user is working with a graphics editor or a text editor, the client area contains the figure or document being edited. The client area is inside the window frame and can be composed of multiple work areas.  IDREF="35702" TYPE="GRAPHIC"Figure 7-2
 shows the client area in a typical window.  LBL="7.3.2" HELPID=""Title AreaID="ch0764"ID="ch0765"ID="ch0766"ID="ch0767"ID="ch0768"The title area, also called the title bar, supplies a place to identify the window.  If a window includes a title area, it must be a horizontal bar at the top of the window.  It must be just above the client area and lie horizontally between the window Menu (or other buttons) on the left and the window control buttons on the right.  IDREF="35702" TYPE="GRAPHIC"Figure 7-2
 shows the title area in a typical window.  ID="ch0769"ID="ch0770"The title area should contain a short string called the title that labels the contents of the window.  The title must be settable at window startup both by the user and by the application.  For applications with a single primary window, the title should be the name of the application.  For applications with multiple primary windows, the title should indicate the purpose of the window.  The title in secondary windows should indicate the purpose of the window.  The title can also contain other useful information, such as the machine on which the application is running, the current directory, or similar relatively static information.  Besides supplying a location for a label, the title area also acts as a position, or handle, for moving a window.  Pressing BSelect or BTransfer in the title area and dragging the pointer must move the window relative to the moving pointer.  LBL="7.3.3" HELPID=""Maximize ButtonID="ch0771"ID="ch0772"ID="ch0773"ID="ch0774"The maximize button provides mouse users with a shortcut to the Maximize entry in the window Menu.  If a window includes a maximize button, it must be just above the client area and its right border must align with the right border of the client area.  IDREF="35702" TYPE="GRAPHIC"Figure 7-2
 shows the maximize button in a typical window.  Primary windows should have a maximize button.  Secondary windows generally do not have a maximize button.  The graphic in the maximize button should be a large square or an up arrow.  If the maximize button uses an up arrow as its graphic, a maximized window should use a double-headed arrow to indicate that it is maximized.  If the maximized button uses a large square as its graphic, a maximized window can show the graphic in a different state.  Activating the maximize button must increase the size of the window to the maximum allowable size.  As a shortcut for mouse users to the Restore entry in the window Menu, activating the maximize button of a maximized window must restore the window to its size and location before being maximized.  LBL="7.3.4" HELPID=""Minimize ButtonID="ch0775"ID="ch0776"ID="ch0777"The minimize button provides mouse users with a shortcut to the Minimize entry in the window Menu.  If a window includes a minimize button, it must be just above the client area and directly to the left of the maximize button.  IDREF="35702" TYPE="GRAPHIC"Figure 7-2
 shows the minimize button in a typical window.  Primary windows should have a minimize button.  Secondary windows must not have a minimize button.  The graphic in the minimize button should be a small square or a down arrow.  Activating the minimize button must iconify the window unless the window family contains a system modal DialogBox.  LBL="7.3.5" HELPID=""Other ButtonsID="ch0778"ID="ch0779"You can bind additional window manager functions to buttons on the window frame.  Any additional buttons must be placed directly to the left of the minimize button or directly to the right of the window Menu button and above the client area.  Each button action must correspond to a entry in the window Menu.  LBL="7.3.6" HELPID=""Resize BordersID="ch0780"ID="ch0781"Applications can suggest the initial size of their windows to the window manager.  Window sizes can vary according to the work performed in them.  At any time, a user should be able to alter the size of most windows.  The Size entry in the window Menu provides a method for the user to alter the size of windows.  The resize borders provide a shortcut for mouse users for the Size entry in the window Menu.  Resize borders are not generally provided on secondary windows.  ID="ch0782"ID="ch0783"ID="ch0784"The resize borders are the outermost components of the window manager frame.  They are made up of two components: the corner handles and the edge handles.  If a window includes resize borders, there must be one corner handle in each corner of the window at its extremes, and one edge handle between each pair of corner handles.  There must be no window components outside the boundary formed by the resize borders.  IDREF="35702" TYPE="GRAPHIC"Figure 7-2
 shows resize borders in a typical window.  Pressing BSelect or BTransfer in a corner handle and dragging the pointer must change the height and width of the window relative to the moving pointer without changing the position of the opposite corner.  Pressing BSelect or BTransfer in a top or bottom edge handle and dragging the pointer must change the height of the window relative to the moving pointer without changing the width or the position of the opposite edge.  Pressing BSelect or BTransfer in a side edge handle and dragging the pointer must change the width of the window relative to the moving pointer without changing the height or the position of the opposite edge.  LBL="7.3.7" HELPID=""Window MenuID="ch0785"ID="ch0786"ID="ch0787"ID="ch0788"ID="ch0789"ID="ch0790"The window Menu, sometimes called the system Menu or control Menu, is used to display the list of window actions.  All actions possible for a window should be displayed in the window Menu because keyboard-only users interact with the window manager through this Menu.  Because of this, it is rare that a window does not need a window Menu.  The window Menu can be configured out by the application or by the user, but it should not be removed by the window manager.  If a window includes a window Menu, the window Menu button must be located just above the client area, the left edge of the button must align with the left edge of the client area, and the button must be just to the left of the title area, unless other buttons are included between the window Menu button and the title area.  Double-clicking the window Menu button can be used to close the window, unless focus is disallowed in the window.  A user must be able to activate the window Menu button for the window with the focus by using <Shift> <Escape> or <Alt> <Space>.IDREF="22958" TYPE="GRAPHIC"Figure 7-3 shows a typical window Menu.  LBL="7-3" FILE="osfmenu.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-3"Figure 7-3 
ID="22958"The Window Menu Button with Menu Pulled DownA primary window Menu must have the following entries in the order listed: Restore  Alt+F5Restores a minimized or maximized window to the previous size and location of the window.  This entry must be deemphasized (grayed out) when the window is in its normal state.  This action must have the mnemonic ID="ch0791"R.  If this action has an accelerator, it must be <Alt> <F5> if <F5> is available.  Move  Alt+F7Moves a window around the workspace.  This action must have the mnemonic ID="ch0792"M.  If this action has an accelerator, it must be <Alt> <F7> if <F7> is available.  Size  Alt+F8Changes the height and width of the window in the direction indicated by the pointer.  This action must have the mnemonic ID="ch0793"S.  If this action has an accelerator, it must be <Alt> <F8> if <F8> is available.  Minimize  Alt+F9 Changes a window into an icon.  This action must have the mnemonic ID="ch0794"N.  If this action has an accelerator, it must be <Alt> <F9> if <F9> is available.  Maximize  Alt+F10 Enlarges a window to its maximum size.  This action must have the mnemonic ID="ch0795"X.  If this action has an accelerator, it must be <Alt> <F10> if <F10> is available.  Lower  Alt+F3Moves a window to the bottom of the window hierarchy.  This action can be omitted.  This action must have the mnemonic ID="ch0796"L.  If this action has an accelerator, it must be <Alt> <F3> if <F3> is available.  Close  Alt+F4Closes a window and removes it from the workspace.  This action must have the mnemonic ID="ch0797"C.  If this action has an accelerator, it must be <Alt> <F4> if <F4> is available.  Applications should prompt the user to save any unsaved changes when a window is closed.  A secondary window Menu must have the following entries in the order listed: Move, Size, and Close.  A secondary window Menu can include Restore above Move, Maximize below Size, and Lower above Close, but the lower option on a secondary window lowers all the windows secondary to that window's primary window.  A secondary window Menu should not include Restore if it does not include Maximize.  A secondary window must not include an entry for Minimize.  A secondary window resulting from a Menu being torn off must have the following entries in the order listed: Move, Lower, and Close.  It must not include entries for Restore, Size, Minimize, or Maximize.  Additional Menu items can be added to the window Menus of both primary and secondary windows according to the guidelines for Menus described in IDREF="20011" TYPE="TITLE"Chapter 6, "Application Design Principles."LBL="7.4" HELPID=""ID="33250"Window NavigationID="ch0798"ID="ch0799"Moving the focus among windows using the keyboard is called window navigation.  Because applications should not warp the mouse pointer, a window manager need not support window navigation when the focus policy is in pointer mode.  Window managers must support window navigation when the focus policy is in explicit mode.  The window navigation model can be divided into two levels: Moving among window families (among primary windows) Moving within a window family (among secondary windows) A window family consists of a single primary window and all of its associated secondary windows.  A window manager must support moving the keyboard focus among windows in a window family using the <Alt> <F6> key.  A window manager can support moving the keyboard focus in the opposite direction from <Alt> <F6> using the <Alt> <Shift> <F6> key.  Moving the focus between window families must be done using <Alt> <Tab> and <Alt> <Shift> <Tab>.<Alt> <Shift> <Tab> should move the focus among the windows in the opposite direction from <Alt> <Tab>.If there is no icon box, <Alt> <Tab> and <Alt> <Shift> <Tab> must move among the icons as well as the windows.  When focus moves into a window family, the focus should go to the window in the window family that last had the focus.  If no window in the family has ever had the focus, it should go to the most recently opened secondary window.  LBL="7.5" HELPID=""ID="32482"IconsID="ch07100"An icon is a stylized representation of an object.  A window icon is a minimized representation of a window or window family that can help organize windows and tasks in the display.  Iconifying a window is also known as minimizing a window.  The window manager must iconify all windows of a window family together.  It must not iconify any single window, primary or secondary, from a window family without also iconifying all the other windows in the window family.  The iconic representation of a window family should not change any state in the windows, except the visual representation of the window.  The application running inside of a window must continue running even when the application is iconified.  The application can adjust its own state when it is iconified.  LBL="7.5.1" HELPID=""Icon DecorationAn icon is made up of an image and a label.  IDREF="16734" TYPE="GRAPHIC"Figure 7-4
 shows a typical Motif icon.  LBL="7-4" FILE="termicon.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-4"Figure 7-4 
ID="16734"A Typical OSF/Motif IconThe image should be surrounded by a border that indicates when the icon has the keyboard focus.  The image area can contain text or a bitmap.  The label should be located just below the image and its border.  The label can also indicate when the icon has the keyboard focus by highlighting with the image area.  The label should contain the same text as the title area of the corresponding primary window, or an abbreviated form of it.  When the icon does not have the keyboard focus, the width of the label must be the same as the width of the image area and its border, truncating text if necessary.  When the icon has the keyboard focus, the width of the label can expand to display the entire text.  LBL="7.5.2" HELPID=""Icon MenuID="ch07101"ID="ch07102"Clicking BSelect in an icon must give the icon the keyboard focus and post the icon Menu.  The icon Menu must be the same Menu as the window Menu for the associated primary window.  Size should not be available from the icon Menu.  Navigating to the icon must also give the icon the keyboard focus and should post the icon Menu.  Double-clicking BSelect anywhere in the icon must restore the window family, just as the icon Menu item Restore does.  If the window is currently minimized, but its previous state was maximized, double-clicking BSelect returns it to the maximized state.  Selecting Maximize from the icon Menu always maximizes the corresponding window.  If the window is minimized, Minimize must not be available in the icon Menu; otherwise, selecting it minimizes the window family.  Pressing BSelect or BTransfer anywhere in the icon and dragging the mouse pointer must move the icon to track the pointer, just as the icon Menu item Move does.  If the window manager has been customized by the user so that the icon Menu does not pop up when the icon gets the focus, <Shift> <Escape>,<Alt> <Space>,<Menu>,and BMenu must pop up the icon Menu.  LBL="7.5.3" HELPID=""Icon BoxID="ch07103"ID="ch07104"An icon box is a specialized window that acts as a storage location for icons.  An icon box acts like a typical window in the sense that it has a window frame and frame components.  The client area of an icon box must have an area for holding icons and can have horizontal and vertical scroll bars for moving around the icon area.  IDREF="29497" TYPE="GRAPHIC"Figure 7-5
 shows a typical icon box.  LBL="7-5" FILE="iconbox.gif" POSITION="INLINE" SCALE="FALSE"LBL="7-5"Figure 7-5 
ID="29497"A Typical OSF/Motif Icon BoxThe icon box must have all the same components as any other primary window.  Like other windows it can be sized, moved, minimized, maximized, restored, and lowered.  However, the window manager must not allow the icon box to be closed.  The system Menu action Close must be replaced with the system Menu action Pack Icons in an icon box.  Double-clicking BSelect in the icon box system Menu must only open the icon box system Menu.  It must not close the icon box.  Pack Icons arranges the icons as close as possible together in the visible icon area if possible.  Pack Icons must have the mnemonic P.  If Pack Icons has an accelerator, it should be <Alt> <F12> if <F12> is available.  When the input focus is in the icon box, <Shift> <Escape> or <Alt> <Space> must pop up the icon box system Menu if the Menu is unposted.  If the Menu is already posted, <Shift> <Escape> or <Alt> <Space> must unpost the Menu.  ID="ch07105"The icon box can contain an icon for each window family, even if it is active.  The icon for minimized window families must be the same as the icon would be outside of the icon box.  The icon for an active window family should be similar to the minimized icon, deemphasized somehow.  Clicking BSelect in an icon must give the icon keyboard focus and post the icon Menu.  The icon Menu must be the same Menu as the window Menu for the associated primary window.  If the icon represents an active window family, Restore and Size must not be available from the icon Menu.  If the icon represents a minimized window family, Size must not be available from the icon Menu.  If the window manager is customized so that the icon with the focus does not have its window Menu automatically posted, BMenu or <Menu> must post its Menu.  Double-clicking BSelect anywhere in an icon that represents a minimized window family must restore the window family, just as the icon Menu item Restore does.  Double-clicking BSelect anywhere in an icon that represents an active window family must raise the window family to the top of the window hierarchy.  If the window is currently minimized, but its previous state was maximized, double-clicking BSelect returns it to the maximized state.  Selecting Maximize from the icon Menu always maximizes the corresponding window.  If the window is minimized, Minimize must not be available in the icon Menu; otherwise, selecting it minimizes the window family.  Pressing BSelect or BTransfer anywhere in the icon and dragging the mouse pointer must move the icon within the icon area to track the pointer, just as the icon Menu item Move does.  The directional keys <Down arrow>,<Up arrow>,<Right arrow>,and <Left arrow> must navigate among the icons in the icon box.  Icon navigation must behave as described in the following text.  Note that <Down arrow> and <Right arrow> do not need to traverse icons in the same order.  <Down arrow> In a left-to-right language environment, this key must move the location cursor through the icons in the icon box, starting at the upper-left icon and ending at the lower-right icon, then wrapping back up to the upper left.  In a right-to-left language environment, the location cursor can move, starting at the upper right and moving to the lower left.  <Left arrow> This key must move the location cursor through the icons in the opposite direction of <Right arrow>.<Right arrow> In a left-to-right language environment, this key must move the location cursor through the icons in the icon box, starting at the upper-left icon and ending at the lower-right icon, then wrapping back up to the upper left.  In a right-to-left language environment, the location cursor can move, starting at the upper right and moving to the lower left.  <Up arrow> This key must move the location cursor through the icons in the opposite direction of <Down arrow>.LBL="8"ID="38166"Designing for International MarketsThis chapter provides basic guidelines for producing applications for international markets.  Internationalization is the process of generalizing programs or systems so that they can handle a variety of languages, character sets, and national customs.  Localization is the process of providing language-specific or country-specific information or support for programs.  ID="ch081"ID="ch082"ID="ch083"ID="ch084"ID="ch085"ID="ch086"In general, internationalization issues are handled by tools available to programmers on their system.  For example, the ANSI C standard (ANS X3.159-1989) and POSIX 1003.1 have defined internationalization in terms of locale.  The locale can then be set as part of the user's environment, allowing the program to access locale-specific information, such as data formats, collating sequences, and system messages, from system-specific or application-specific databases.  You should use any internationalization tools available on your system to support internationalization in your application.  Following are some of the issues that need to be addressed in an internationalized application.  In most cases, these issues are addressed by the internationalization tools available on your system.  They are provided here primarily to increase your awareness of issues that can affect your programming.  In a few cases, you may need to adjust your program to allow for size and layout changes of data in different locales.  IDREF="33660" TYPE="TITLE"Section 8.1, "Internationalized Text Input"IDREF="20054" TYPE="TITLE"Section 8.2, "Collating Sequences"IDREF="49063" TYPE="TITLE"Section 8.3, "Country-Specific Data Formats"IDREF="44264" TYPE="TITLE"Section 8.4, "Icons, Symbols, and Pointer Shapes"IDREF="42433" TYPE="TITLE"Section 8.5, "Scanning Direction"IDREF="65123" TYPE="TITLE"Section 8.6, "Designing Modularized Software"IDREF="26432" TYPE="TITLE"Section 8.7, "Translating Screen Text"LBL="8.1" HELPID=""ID="33660"Internationalized Text InputID="ch087"Ideally, text is input from a keyboard that can directly produce all the characters needed for that language.  It is sometimes the case, however, that text input requires a pre-edit step, whereby text is typed into a pre-edit area using a set of characters, later converted to another set of characters, and passed to the application.  An input method is used to convert keyboard input to an encoding suitable for a Text control.  Fortunately, application developers do not need to worry about the input method as long as the Text controls in the application support the display and input of text in the writing system supported by the underlying system.  Furthermore, defining how keyboard actions convert into characters suitable for text input and the display is the responsibility of the underlying system.  Designers of Text controls should create Text controls that support display and input of text in any writing system supported by the underlying system.  Text controls can also support input and display of multiple writing systems.  System designers need to create input methods that address the following issues of internationalized text input: IDREF="18345" TYPE="TITLE"Section 8.1.1, "Locating the Pre-Edit Area"IDREF="39315" TYPE="TITLE"Section 8.1.2, "Displaying Status"IDREF="19279" TYPE="TITLE"Section 8.1.3, "Converting Pre-Edit Characters to Final Characters"The following subsections describe these issues and provide some guidelines for addressing them, but there is currently too much variation in systems, and the field is too new for this guide to make many firm recommendations about these issues.  LBL="8.1.1" HELPID=""ID="18345"Locating the Pre-Edit AreaID="ch088"ID="ch089"ID="ch0810"ID="ch0811"ID="ch0812"The trend over time is for pre-edit areas to move closer to the location of the final text.  Ideally, pre-edit should occur in place in the Text control being edited (known as an on-the-spot input method).  This is technically difficult to do without fully integrating the Text control with the input method.  In the absence of an on-the-spot input method, systems should use an over-the-spot input method.  An over-the-spot input method places the pre-edit area above but separate from the Text control.  In the absence of on-the-spot or over-the-spot input methods, systems can create input methods where the pre-edit area is separate on the display from the Text control that it sends input to.  These models are know as off-the-spot input methods.  In these input methods, a single pre-edit area can apply to a single Text control, a group of Text controls, an entire application window, or the whole screen.  An input method where a single pre-edit area is responsible for all the Text controls on a screen is known as a root window input method.  Systems should support in-place or per-window input methods.  They can support per-control, per-group, or per-screen input methods.  When using an off-the-spot input method, converted text obviously goes to the Text control with the input focus.  The pre-edit area itself does not get the input focus.  It only acts as an intermediary for the Text control.  The contents of the pre-edit area prior to conversion can be maintained separately for each Text control; that is, when moving the focus from one Text control to another, the unconverted text from the pre-edit area can be maintained in the first Text control and any existing unconverted pre-edit text for the second Text control can be restored to the pre-edit area.  LBL="8.1.2" HELPID=""ID="39315"Displaying StatusID="ch0813"ID="ch0814"After a block of text is input to the pre-edit area, the user performs some action, usually a key sequence, that causes the system to convert the pre-edit text into the final characters and pass it to Text control.  Using an in-place input method, it is important to show the user which text is pre-edit text and which text has already been converted; that is, the system should give the user some idea of the status of input.  In an in-place input method, this status is usually provided by some visual effect such as a font or color difference.  Using any input method including an in-place input method, the method can include an additional off-the-spot status area that displays input method status information such as input and output text formats.  LBL="8.1.3" HELPID=""ID="19279"Converting Pre-Edit Characters to Final CharactersID="ch0815"ID="ch0816"When the user requests that the pre-edit text be converted to the final text format, the system may still not have enough information to unambiguously convert the text.  In this case, the next step of the conversion depends on the system, the pre-edit format, and the final text format.  The conversion can either fail, prompt for more pre-edit text, or present a list of possible choices and let the user pick one.  An input method can present conversion choices to the user in a number of ways including the following: Listing the choices in a DialogBox Presenting the choices in an Option Menu Presenting the choices in a Popup Menu Allowing the user to cycle through choices using key sequences LBL="8.2" HELPID=""ID="20054"Collating SequencesID="ch0817"ID="ch0818"ID="ch0819"ID="ch0820"To produce an alphanumeric list, printable characters are sorted according to a collating sequence.  Printable characters include letters possibly with accents, numbers, punctuation characters, and other symbols such as an * (asterisk) or & (ampersand).  The collating sequence defines the value and position of a character relative to the other characters.  Many applications make frequent use of collating sequences to produce alphanumeric lists.  Examples of alphanumeric lists include the following: A directory listing of filenames The output from a sorting utility An index produced by a text-processing application The lists produced by a database application, such as lists of names or addresses LBL="8.3" HELPID=""ID="49063"Country-Specific Data FormatsID="ch0821"ID="ch0822"ID="ch0823"ID="ch0824"ID="ch0825"Country-specific data formats include the following: IDREF="33565" TYPE="TITLE"Section 8.3.1, "Thousands Separators"IDREF="27232" TYPE="TITLE"Section 8.3.2, "Decimal Separators"IDREF="26502" TYPE="TITLE"Section 8.3.3, "Grouping Separators"IDREF="31350" TYPE="TITLE"Section 8.3.4, "Positive and Negative Values"IDREF="30956" TYPE="TITLE"Section 8.3.5, "Currency"IDREF="37988" TYPE="TITLE"Section 8.3.6, "Date Formats"IDREF="34656" TYPE="TITLE"Section 8.3.7, "Time Formats"IDREF="32883" TYPE="TITLE"Section 8.3.8, "Telephone Numbers"IDREF="30868" TYPE="TITLE"Section 8.3.9, "Proper Names and Addresses"LBL="8.3.1" HELPID=""ID="33565"Thousands SeparatorsID="ch0826"ID="ch0827"The comma, period, space, and apostrophe are examples of valid separators for units of thousands as shown in the following examples: 1 234 567
1.234.567
1'234'567
1,234,567LBL="8.3.2" HELPID=""ID="27232"Decimal SeparatorsID="ch0828"ID="ch0829"The period, comma, and the center dot are examples of valid separators for decimal fractions as shown in the following examples: 5,324
5.324
5 324
5.324LBL="8.3.3" HELPID=""ID="26502"Grouping SeparatorsID="ch0830"ID="ch0831"Grouping may not be restricted to thousands separators as shown in the following examples: 400,001.00
40,0001,00LBL="8.3.4" HELPID=""ID="31350"Positive and Negative ValuesID="ch0832"ID="ch0833"ID="ch0834"ID="ch0835"Various countries indicate positive and negative values differently.  The symbols + (plus) and - (minus) can appear either before or after the number.  Negative numbers can be enclosed in parentheses in applications such as a spreadsheet.  LBL="8.3.5" HELPID=""ID="30956"CurrencyID="ch0836"ID="ch0837"ID="ch0838"Currency formats differ among various countries.  The comma, period, and colon are examples of valid separators for currency.  There can be one or no space between the currency symbol and the amount.  The currency symbol can be up to four characters.  The following example shows valid currency values: Sch3.50
SFr. 5.-
3.50FIM
25 c
3F50
760 Ptas
Esc. 3.50
kr. 3,50LBL="8.3.6" HELPID=""ID="37988"Date FormatsID="ch0839"ID="ch0840"ID="ch0841"ID="ch0842"ID="ch0843"Most countries use the Gregorian calendar, but some do not.  Dates can be formatted differently based on the locale.  Separators can be different in different locales or left out altogether.  The hyphen, comma, period, space, and slash are all examples of valid separators for the day, month, and year.  In numeric date formats, the month and day fields can be reversed, and, in some cases, the year field can come first.  For example, the 4th of August 1992 can be written as either 4/8/92 or 8/4/92 depending on locale.  In addition, users in other countries sometimes place the year first, so June 11, 1992 could be 920611 or 921106.  LBL="8.3.7" HELPID=""ID="34656"Time FormatsID="ch0844"ID="ch0845"Time formats can change based on locale.  The colon, period, and space are examples of valid separators for hours, minutes, and seconds.  The letter h can separate hours and minutes.  There is both 12-hour or 24-hour notation.  For 12-hour notation, a.m. or p.m. can appear after the time, separated by a space.  The following example shows a number of valid time formats: 1830
18:30
04 56
08h15
11.45 a.m.
11.45 p.m.
13:07:31.30
13:07:31LBL="8.3.8" HELPID=""ID="32883"Telephone NumbersID="ch0846"ID="ch0847"ID="ch0848"ID="ch0849"ID="ch0850"Telephone numbers can contain blanks, commas, hyphens, periods, and brackets as valid separators, for example.  Telephone numbers can be displayed in local, national, and international formats.  Local formats vary widely.  National formats can have an area code in parentheses, while the international format can drop the parentheses but add a + (plus sign) at the  beginning of the number to indicate the country code.  The following examples show valid telephone number formats: (038) 473589
+44 (038) 473549
617.555.2199
(617) 555-2199
1 (617) 555-5525
(1) 617 555 5525
911
1-800-ORDERMELBL="8.3.9" HELPID=""ID="30868"Proper Names and AddressesID="ch0851"ID="ch0852"ID="ch0853"Addresses can vary from two to six lines long and can include any character used in the locale's character set.  The post code (zip code) can be in various positions in the address and can include alphabetic characters and separators as well as numbers.  LBL="8.4" HELPID=""ID="44264"Icons, Symbols, and Pointer ShapesID="ch0854"ID="ch0855"ID="ch0856"ID="ch0857"ID="ch0858"ID="ch0859"ID="ch0860"It may not always be possible to design an icon, pointer shape, or other graphical symbol that adequately represents the same object or function in different countries.  Culture is inherent even in seemingly universal symbols.  For example, sending and receiving mail is a commonly understood function, but representing that function with an icon of a mail box can be inappropriate because the appearance of mail boxes varies widely among countries.  Therefore, an envelope may be a more appropriate icon.  You should make sure that graphical symbols are localizable.  When used correctly, graphical symbols offer the following advantages: They are language independent and do not need to be translated.  In some cases, you may not be able to avoid changing an icon or symbol for a culture that is vastly different.  However, design icons and symbols with the entire user population in mind so that you can try to avoid redesigning.  They can be used instead of computer terms that have no national-language equivalent.  They may have more impact when used with text as warnings than the text alone.  Here are a few guidelines to follow when creating icons, symbols, or pointer shapes: Use an already existing international icon, if possible.  Make your icons, symbols, or pointer shapes represent basic, concrete concepts.  The more abstract the icon, the more explanatory documentation is needed.  Check your icons and symbols for conflicts with existing icons or symbols for that function.  Do not incorporate text in icons because the text will need to be translated.  Translated text often expands and might no longer fit the icon.  Test and retest your symbols and icons in context with real users.  LBL="8.5" HELPID=""ID="42433"Scanning DirectionID="ch0861"ID="ch0862"Readers of Western languages scan from left to right across the page (or display screen) and from top to bottom.  In other languages, particularly Eastern ones such as Hebrew and Arabic, this is not the case; readers scan from right to left.  The scanning direction of the country can have an impact on the location of components in DialogBoxes, the order of selections in Menus, and other areas.  If your application will be used in environments other than those that scan from left to right, remember that the the scanning direction should match the input direction.  LBL="8.6" HELPID=""ID="65123"Designing Modularized SoftwareModularizing software allows for easier localization; that is, a properly modularized application requires that fewer files be modified to localize the application.  Guidelines for designing modularized software are as follows: Create separate modules for text, code, and input/output components that need to be changed to accommodate different markets.  Separate all user interface text from the code that presents it.  Use standard (registered) data formats, such as ISO and IEEE.  Use standard processing algorithms for all processing, storage, and interchange.  In general, you should modularize your application so that elements that need to be translated to different languages are in separate files, and that those files are the only files that will need changes for localization.  Furthermore, you should have a different set of language-dependent text files for each locale that are read in at run time using the internationalization tools available on your system.  LBL="8.7" HELPID=""ID="26432"Translating Screen TextID="ch0863"ID="ch0864"ID="ch0865"ID="ch0866"ID="ch0867"ID="ch0868"ID="ch0869"ID="ch0870"ID="ch0871"Well-written screen text makes an application easier for users to understand.  It also makes translation easier.  Use the following guidelines to write screen text for translation: Write brief and simple sentences; they are easy to understand and translate.  Write affirmative statements; they  are easier to understand than negative statements.  For example, use "Would you like to continue?" rather than "Wouldn't you like to continue?" Use active voice; it is easier for both application users and application translators to understand.  For example, use "Press the Help button." rather than "The Help button should be pressed." Use prepositions to clarify the relationship of nouns; avoid stringing three or more nouns together.  Use simple vocabulary; avoid using jargon unless it is a part of your audience's working vocabulary.  Allow space for text expansion. Text translated from English is likely to expand 30% to 50%, or even more.  LBL="9"ID="10478"Controls, Groups, and Models Reference PagesThis chapter presents detailed information about components, user interface models, and concepts in reference format.  Each topic starts on a new page and is organized alphabetically.  Details on user interface models and concepts are provided in the earlier chapters of this guide.  The model and concepts reference pages are provided here only as a quick reference to information provided earlier and are not complete in every detail.  Therefore, they should not be used as the definitive source for information about user interface models and concepts.  This chapter includes the following model and concepts reference pages: ID="ch091"ID="ch092"ID="ch093"ID="ch094"COLUMNS="3"LEFT="0" WIDTH="113"AcceleratorsLEFT="120" WIDTH="113"FocusLEFT="240" WIDTH="356"NavigationLEFT="0" WIDTH="113"ActivationLEFT="120" WIDTH="113"Framing GroupsLEFT="240" WIDTH="356"Pointer ShapesLEFT="0" WIDTH="113"Basic ControlsLEFT="120" WIDTH="113"Help MenuLEFT="240" WIDTH="356"Popup MenusLEFT="0" WIDTH="113"Basic GroupsLEFT="120" WIDTH="113"Icon MenuLEFT="240" WIDTH="356"Primary SelectionLEFT="0" WIDTH="113"Default ActivationLEFT="120" WIDTH="113"IconBoxLEFT="240" WIDTH="356"Quick TransferLEFT="0" WIDTH="113"Drag and DropLEFT="120" WIDTH="113"IconsLEFT="240" WIDTH="356"SelectionLEFT="0" WIDTH="113"Edit MenuLEFT="120" WIDTH="113"Input DevicesLEFT="240" WIDTH="356"Window MenuLEFT="0" WIDTH="113"Field ControlsLEFT="120" WIDTH="113" Layout GroupsLEFT="240" WIDTH="356"LEFT="0" WIDTH="113"File MenuLEFT="120" WIDTH="113"MnemonicsLEFT="240" WIDTH="356"LBL="9-1."Table 9-1. The reference pages for components are provided for designers to use when implementing the components described in this guide or when creating new components.  Remember, when designing new components, you should follow the same rules that application designers follow.  As such, you should be familiar with all the chapters of this guide, not just this reference-page section.  New components must follow the guidelines for designing applications.  This chapter contains the following control and group reference pages: COLUMNS="3"LEFT="0" WIDTH="113"CanvasLEFT="120" WIDTH="113"ListLEFT="240" WIDTH="356"ScaleLEFT="0" WIDTH="113"CascadeButtonLEFT="120" WIDTH="113"MainWindowLEFT="240" WIDTH="356"ScrollBarLEFT="0" WIDTH="113"CheckButtonLEFT="120" WIDTH="113"MenuBarLEFT="240" WIDTH="356"ScrolledWindowLEFT="0" WIDTH="113"CommandBoxLEFT="120" WIDTH="113"MenusLEFT="240" WIDTH="356"SelectionBoxLEFT="0" WIDTH="113"CommandDialogLEFT="120" WIDTH="113"MessageDialogLEFT="240" WIDTH="356"SelectionDialogLEFT="0" WIDTH="113"CompositionLEFT="120" WIDTH="113"OptionButtonLEFT="240" WIDTH="356"SeparatorLEFT="0" WIDTH="113"DialogBoxLEFT="120" WIDTH="113"PanedWindowLEFT="240" WIDTH="356"TearOffButtonLEFT="0" WIDTH="113"ErrorDialogLEFT="120" WIDTH="113"PanelLEFT="240" WIDTH="356"ToggleButtonLEFT="0" WIDTH="113"FileSelectionBoxLEFT="120" WIDTH="113"PromptDialogLEFT="240" WIDTH="356"WarningDialogLEFT="0" WIDTH="113"FileSelectionDialogLEFT="120" WIDTH="113"PushButtonLEFT="240" WIDTH="356"WorkingDialogLEFT="0" WIDTH="113"FrameLEFT="120" WIDTH="113"QuestionDialogLEFT="240" WIDTH="356"LabelLEFT="0" WIDTH="113"InformationDialogLEFT="120" WIDTH="113"RadioButtonLEFT="240" WIDTH="356"LBL="9-2."Table 9-2. When designing a new component, compare its features with those of other components.  If the new component has a feature that is the same as another component, the mechanisms for using the feature, layout, key bindings, graphics, and so on, must be similar to the existing component.  Each component reference page may contain the following information about the component: Description A description of the use and appearance of each component, group, or model.  Illustration An illustration of a typical component.  The illustrations in this guide use the OSF/Motif reference appearance with 3-dimensional beveled edges.  Although it is important to be consistent in the placement of the elements in a component, the appearance, or rendering, of the component is not an issue of OSF/Motif Style Guide compliance.  Navigation A description of the methods for navigating within a component.  Other Operations A description of other operations available within the component.  Common Bindings A list of the virtual keys used by this component and the common substitutions for each virtual key.  Related Information A list of sections and related reference pages in this OSF/Motif Style Guide with additional information.  LBL="9.1" HELPID=""AcceleratorsLBL="9.1.1" HELPID=""DescriptionID="ch095"An accelerator is a key or key combination that invokes the action of some component without the location cursor being on the component when the accelerator is pressed.  Accelerators are most commonly used to activate Menu items without first posting the Menu.  You should provide accelerators primarily as a matter of utility, not for design conformity.  If the button with the accelerator is within a primary or secondary window, or within a Pulldown Menu system from its MenuBar, it must be activatable whenever the input focus is in the window or the MenuBar system.  If the button with the accelerator is within a Popup Menu system, it must be activatable whenever the focus is in the Popup Menu system or the component with the Popup Menu.  Applications can provide accelerators for any button component.  Implementations must support accelerators in PushButtons and ToggleButtons that are in Menus.  If a button has an accelerator, the accelerator must be shown following the label of the button.  LBL="9.2" HELPID=""ActivationLBL="9.2.1" HELPID=""DescriptionID="ch096"This reference page only provides a short description of the various types of activation.  IDREF="15303" TYPE="TITLE"Chapter 5, "Component Activation"
 describes each type in detail.  Basic Activation The basic activation model mimics real-life button activation in that pressing on a button activates it.  Clicking ID="ch097"ID="ch098"ID="ch099"BSelect on the button must activate the button.  <Select> or <Space> on a button with the focus must activate the button.  <Enter> or <Return> on an activatable Menu entry with the focus must activate the entry.  In explicit mode, clicking <Ctrl> BSelect on a traversable component should move the focus to it.  In activatable components, it should have no other effect.  In collections, it can change the cursored element or the selection as described in IDREF="12200" TYPE="TITLE"Section 4.1, "Selection Models."Accelerators An accelerator is a key or key combination that invokes the action of some component without the location cursor on the component when the accelerator is pressed.  Accelerators are most commonly used to activate Menu items without first posting the Menu.  ID="ch0910"Mnemonics A mnemonic is a single character that can be associated with any component that contains a text label.  When the location cursor is on a component within a Menu, a MenuBar, or the same field as a component with a mnemonic, typing the mnemonic character must move the location cursor to the component and activate it.  If a mnemonic is used for an OptionButton, for a CascadeButton in a MenuBar, or a PushButton that is not in a basic group (that is, not in a Panel, a Menu, or a MenuBar), pressing ID="ch0911"<Alt> and the mnemonic anywhere in the window or its Menus must move the cursor to the component with that mnemonic and must activate it.  TearOff Activation  Some Menus have TearOffButtons as their first elements.  A TearOffButton is like a PushButton with the special interaction of converting a Menu into a DialogBox; that is, tearing off the Menu from its CascadeButton.  TearOffButtons must follow the basic activation model.  TearOffButtons have a second activation mechanism.  Once a Menu with a TearOffButton is posted, pressing ID="ch0912"ID="ch0913"BTransfer in the TearOffButton must start a tear-off action.  As long as BTransfer is held, a representation of the Menu must follow the movements of the pointer.  Releasing BTransfer must end the tear-off action by unposting the Menu system, creating a new window at the current pointer location with the contents of the Menu, and in explicit pointer mode give focus to the new window.  Help Activation Pressing ID="ch0914"ID="ch0915"<Help> on a component must invoke any context-sensitive help for the component or its nearest ancestor with context-sensitive help available.  Within DialogBoxes, context-sensitive help should provide help information on the DialogBox as a whole.  <Shift> <Help> should invoke the context-sensitive help mode if it is available.  Popup Menu Activation  If the pointer is in an element with an inactive Popup Menu and the context of the element allows a Popup Menu to be displayed, ID="ch0916"BMenu Press must post (activate) the Menu in a spring-loaded manner, and clicking BMenu must post (activate) the Menu.  Default Activation  In a DialogBox, pressing ID="ch0917"<Enter> or <Return> (except in Text), or double-clicking BSelect must activate the default PushButton in the DialogBox.  If the double-click is in a component used for making selections or choices, such as List or RadioBox, the element under the pointer must be selected or should be chosen before the default PushButton is activated.  Expert Activation  Some elements, usually PushButtons and ToggleButtons, can have expert actions associated with them.  ID="ch0918"ID="ch0919"ID="ch0920"ID="ch0921"BSelect Click 2 must activate any expert action for the element.  Expert action should only be available in a Panel, and the expert action of all the buttons should be similar.  The expert action should include the regular action of the component in a more global manner.  Cancel Activation  ID="ch0922"ID="ch0923"<Cancel> is available in most context to stop the current interaction, including canceling drag and drop operations, unposting TearOff Menus, canceling DialogBoxes, unposting Menu systems, and canceling scrolling operations.  LBL="9.2.2" HELPID=""Related InformationSee IDREF="15303" TYPE="TITLE"Chapter 5, "Component Activation"
 for more information about the activation model.  LBL="9.3" HELPID=""Basic ControlsLBL="9.3.1" HELPID=""DescriptionBasic controls are components that only take simple input.  They are distinct from field controls in that they are usually elements of navigation fields rather than fields themselves.  Basic controls must have no internal navigation.  The following text describes the basic controls: Separator Draws a separating line within windows, between Menu items, and between Panes of a PanedWindow.  A Separator allows no application interaction.  ID="ch0924"Label Displays static text and images.  A Label presents application information to users.  ID="ch0925"PushButton A button used to activate an operation.  A PushButton contains a Label that indicates the operation of the button.  The Label can contain text or an image.  ID="ch0926"CascadeButton A button used to display a Pulldown Menu.  A CascadeButton contains a Label that indicates the Menu displayed.  CascadeButtons can also contain an arrow graphic after the Label to distinguish it from PushButtons and to indicate the direction of the cascading Menu.  ID="ch0927"OptionButton A button used to display an Option Menu.  An Option Menu allows for a one-of-many selection.  An OptionButton contains a Label that indicates the current state of the Option Menu, and a bar graphic to distinguish it from a PushButton.  ID="ch0928"ToggleButton A button with two states: on and off.  A ToggleButton contains a Label that indicates the state of the ToggleButton when it is set.  Normally, preceding the Label is a graphic indicator of the state of the ToggleButton.  ID="ch0929"CheckButton A ToggleButton in a group of ToggleButtons where any number of the ToggleButtons can be on at a time.  The graphic indicator for a CheckButton is usually a filled square to indicate the on state or an empty square to indicate the off state.  ID="ch0930"RadioButton A ToggleButton in a group of ToggleButtons where only one of the ToggleButtons can be on at a time.  The graphic indicator for a RadioButton is usually a filled diamond or circle to indicate the on state or an empty diamond or circle to indicate the off state.  ID="ch0931"TearOffButton A button used for tearing off a Menu to create a dialog representation of the Menu contents.  A TearOffButton tears off a Menu in place when activated, or is dragged to tear off and move in one action.  A TearOffButton usually contains a dashed line graphic representing perforations.  ID="ch0932"A single-line Text control can be configured to act like a basic control.  LBL="9.3.2" HELPID=""NavigationBasic controls must have no internal navigation.  LBL="9.3.3" HELPID=""Other OperationsActivatable basic controls follow the basic activation model described in IDREF="10735" TYPE="TITLE"Section 5.1, "Basic Activation."LBL="9.3.4" HELPID=""Related InformationFor more information, see the reference pages for each basic control.  LBL="9.4" HELPID=""Basic GroupsLBL="9.4.1" HELPID=""DescriptionBasic groups of controls are used to organize groups of basic controls.  The following text describes the basic groups: Panel Organizes a collection of basic controls in a horizontal, vertical, or 2-dimensional layout.  A Panel is usually composed of just one type of control.  ID="ch0933"Menu Organizes a collection of buttons, labels, and separators in a horizontal, vertical, or 2-dimensional layout within a separate Menu window.  There are three types of Menus: Pulldown, Popup, and Option.  A Menu is only available while it is popped up or pulled down.  ID="ch0934"MenuBar Organizes a collection of CascadeButtons in a horizontal layout at the top of a MainWindow.  ID="ch0935"LBL="9.4.2" HELPID=""NavigationThe <Down arrow>,<Left arrow>,<Right arrow>,and <Up arrow> direction keys must navigate within a basic group according to the navigation model described in IDREF="31210" TYPE="TITLE"Chapter 3, "Navigation."LBL="9.4.3" HELPID=""Related InformationFor more information, see the reference pages for each basic group.  LBL="9.5" HELPID=""CanvasLBL="9.5.1" HELPID=""DescriptionID="ch0936"A Canvas is used to present and edit graphics.  LBL="9.5.2" HELPID=""NavigationCanvas navigation is unspecified.  LBL="9.5.3" HELPID=""Other OperationsMost Canvas operations are unspecified.  A description of the specified Canvas operations follows: <Help> Must provide any available help for the Canvas.  LBL="9.6" HELPID=""ID="12408"CascadeButtonLBL="9.6.1" HELPID=""DescriptionID="ch0937"A CascadeButton should be used to post a Pulldown Menu.  This component must be composed of a button, with either a text or graphics Label.  Following the Label, this component should also include an arrow graphic, pointing in the direction that the Menu will be posted to distinguish it from a PushButton.  The graphic is usually not shown in a MenuBar.  LBL="9.6.2" HELPID=""IllustrationLBL="9-3" FILE="cascade.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-3"Figure 9-3 
A CascadeButtonLBL="9.6.3" HELPID=""NavigationA CascadeButton must have no internal navigation.  LBL="9.6.4" HELPID=""Other OperationsCascadeButtons follow the Menu activation model described in IDREF="40574" TYPE="TITLE"Section 3.3, "Menu Traversal."
 The following text describes the other operations of this component: <Help> Must provide any available help for the CascadeButton.  LBL="9.6.5" HELPID=""Related InformationFor more information, see the reference pages in IDREF="34167" TYPE="TITLE"Section 9.34, "Menus."LBL="9.7" HELPID=""ID="34612"CheckButtonLBL="9.7.1" HELPID=""DescriptionID="ch0938"ID="ch0939"A CheckButton should be used to set options in the application.  A CheckButton is a special case of a ToggleButton.  Any number of CheckButtons can be set at the same time.  This component must be composed of a text or graphic Label, and a graphic that indicates the state of the CheckButton.  The graphic indicator for a CheckButton is usually a filled square to indicate the on state or an empty square to indicate the off state.  On color systems, the on state color can be distinct from general application colors to visually distinguish the on state.  LBL="9.7.2" HELPID=""IllustrationLBL="9-4" FILE="checkbut.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-4"Figure 9-4 
A CheckButtonLBL="9.7.3" HELPID=""NavigationCheckButtons must have no internal navigation.  LBL="9.7.4" HELPID=""Other OperationsThe following text describes the CheckButton operations: BSelect Press Must arm the CheckButton.  If the CheckButton was previously unset, it must show the CheckButton in the set state.  If the CheckButton was previously set, it must show the CheckButton in the unset state.  BSelect Release If the release happens in the same CheckButton that the press occurred in: If the CheckButton was previously unset, it must be set.  If the CheckButton was previously set, it must be unset.  In all cases the CheckButton must be disarmed, and, if the CheckButton is in a Menu, the Menu must be unposted.  BSelect Release 2 If the CheckButton was previously unset, it should be set.  If the CheckButton was previously set, it should be unset.  If the CheckButton is in a window, the default action of the window should be activated.  <Enter> or <Return> If the CheckButton is in a window with a default action, the default action must be activated.  If the CheckButton is in a Menu: If the CheckButton was previously unset, it must be set.  If the CheckButton was previously set, it must be unset.  In both cases, the CheckButton must be disarmed, and the Menu must be unposted.  <Select> or <Space> If the CheckButton was previously unset, it must be set.  If the CheckButton was previously set, it must be unset.  In both cases, the CheckButton must be disarmed, and, if the CheckButton is in a Menu, the Menu must be unposted.  <Help> Must provide any available help for the CheckButton.  LBL="9.7.5" HELPID=""Related InformationFor more information, see the reference pages in IDREF="39382" TYPE="TITLE"Section 9.48, "RadioButton"
 and IDREF="15890" TYPE="TITLE"Section 9.59, "ToggleButton."LBL="9.8" HELPID=""CommandBoxLBL="9.8.1" HELPID=""DescriptionID="ch0940"A CommandBox is a special-purpose composite component for command entry that provides a built-in command history mechanism.  The CommandBox must be composed of a Text component with a command line prompt for command input, and a List component above the Text component for a command history area.  The List must use either the single or browse selection model.  When a List element is selected, its contents must be placed in the Text area.  The default action of the CommandBox must be to pass the command in the Text area to the application for execution and to add the command to the end of the List.  The List component can be scrollable.  The List navigation actions <Up arrow>,<Down arrow>,<Ctrl> <Begin>,and <Ctrl> <End> must be available from the Text component for moving the cursored element within the List and thus changing the contents of the Text.  The List navigation actions <PageUp> and <PageDown> should also be available from the Text component for moving the cursored element within the List.  LBL="9.8.2" HELPID=""IllustrationLBL="9-5" FILE="commandb.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-5"Figure 9-5 
A CommandBoxLBL="9.8.3" HELPID=""Related InformationFor more information, see the reference page in IDREF="35462" TYPE="TITLE"Section 9.9, "CommandDialog."LBL="9.9" HELPID=""ID="35462"CommandDialogLBL="9.9.1" HELPID=""DescriptionID="ch0941"ID="ch0942"A CommandDialog should be used to enter commands for processing.  It should not interrupt the user's interaction with the application.  It should include a CommandBox.  LBL="9.9.2" HELPID=""IllustrationLBL="9-6" FILE="commandb.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-6"Figure 9-6 
A CommandDialogLBL="9.9.3" HELPID=""Related InformationFor more information, see the reference page in IDREF="17953" TYPE="TITLE"Section 9.12, "DialogBox."LBL="9.10" HELPID=""CompositionLBL="9.10.1" HELPID=""DescriptionID="ch0943"The Composition group should be used to organize components in an arbitrary layout.  The layout style can be either arbitrary, in even rows and columns, or so that the position of components is relative to the Composition component and the components it contains.  This component is composed of an area for organizing components.  LBL="9.10.2" HELPID=""NavigationThis group must follow the navigation model as described in IDREF="31210" TYPE="TITLE"Chapter 3, "Navigation."LBL="9.10.3" HELPID=""Related InformationFor more information, see the reference pages for each layout group.  LBL="9.11" HELPID=""Default ActivationLBL="9.11.1" HELPID=""DescriptionID="ch0944"ID="ch0945"ID="ch0946"Any window can have a default action, although default actions are most frequently used in DialogBoxes.  A DialogBox should have a default action associated with it.  The default action in a window can change depending upon which component has the focus.  The current default action should correspond to the action of some PushButton, called the current default PushButton of the window.  The current default PushButton must be highlighted in some way, usually by displaying a border around it.  When the focus is on a PushButton, its action must be the default action, and the PushButton must show default highlighting.  If the default action in a window varies, some PushButton must always have default highlighting, except when there is no current default action.  In a DialogBox, default PushButtons should be in the bottom area of PushButtons of the DialogBox.  However, if a particular default action is associated with a cluster of controls in a window, the corresponding default PushButton can be located adjacent to the cluster.  When an explicit focus policy is in use, and the focus is outside the window, default highlighting should be placed on the PushButton whose action corresponds to the default action that would result from moving the focus to the window by using keyboard navigation among windows.  The default action of a DialogBox is activated according to the following rules: If the focus is in a window, <Enter> and <Ctrl> <Return> must invoke the default action, and, if the focus is in a component in a window other than multiline Text, <Return> must invoke the default action.  These actions must have no other effect on the component with the focus, unless the default action has some effect.  In list-like and graphics-like collections, when the location cursor is not on an activatable element, BSelect Click 2 should act like BSelect Click, followed by invocation of the default action.  When the focus is on a ToggleButton not used for expert activation, BSelect Click 2 should activate the ToggleButton and then perform the default action.  Except in the middle of a button motion operation, <Cancel> anywhere in a DialogBox must be equivalent to activating the Cancel PushButton in the DialogBox.  LBL="9.11.2" HELPID=""Related InformationSee IDREF="15303" TYPE="TITLE"Chapter 5, "Component Activation"
 for general information about the activation model and default activation.  LBL="9.12" HELPID=""ID="17953"DialogBoxLBL="9.12.1" HELPID=""DescriptionID="ch0947"A DialogBox should be used to group components in a window secondary to the main tasks of the application.  Although a DialogBox can contain any components, a simple DialogBox is composed of a Label and PushButtons for supplying a response to the DialogBox.  The OSF/Motif toolkit provides a number of ready-designed DialogBoxes for common uses: CommandDialog, FileSelectionDialog, MessageDialog, PromptDialog, and SelectionDialog.  There are also a number of different types of MessageDialogs: ErrorDialog, InformationDialog, QuestionDialog, WorkingDialog, and WarningDialog.  The illustration on this reference page shows a typical DialogBox.  ID="ch0948"DialogBox PushButtons should use the following common labels and actions.  The actions are in the approximate sequence in which they should appear in DialogBoxes.  YesMust indicate an affirmative response to a question posed in the DialogBox and then close the window.  While ID="ch0949"Yes is not an active-voice label, it implies a positive response to a question in a QuestionDialog or a WarningDialog.  Only use Yes if it is a clear answer to the question.  NoMust indicate a negative response to a question posed in the DialogBox and then close the window.  While ID="ch0950"No is not an active-voice label, it implies a negative response to a question in a QuestionDialog.  Only use No if it is a clear answer to the question.  OKMust cause the application to apply any changes and perform related actions specified by components in the DialogBox, and then dismiss the DialogBox.  While ID="ch0951"OK is not an active-voice label, its usage is too common to change.  CloseShould cause the current DialogBox to be closed without performing any of the actions specified by components in the DialogBox.  This action is usually only available in DialogBoxes that provide status information such as a Working DialogBox.  This label can also be used if the actions in the DialogBox cannot be reversed, in which case this label replaces ID="ch0952"Cancel after the first irreversible action is performed.  ApplyMust apply any changes and perform the related actions specified by the components in the DialogBox.  ID="ch0953"RetryMust cause the task in progress to be attempted again.  This action is commonly found in message boxes that report an error.  ID="ch0954"StopMust end the task in progress at the next possible breaking point.  This action is commonly found in a Working DialogBox.  ID="ch0955"PauseMust cause the task in progress to be paused.  This action is commonly found in a Working DialogBox and should be used in combination with ID="ch0956"Resume.  ResumeMust cause a previously paused task to resume.  This action is commonly found in a Working DialogBox and should be used in combination with ID="ch0957"Pause.  ResetMust cancel any user changes that have not been applied to the application.  It must also reset the status of the DialogBox to the state since the last time the DialogBox action was applied or to the initial state of the DialogBox.  ID="ch0958"CancelMust close the DialogBox without performing any DialogBox actions not yet applied to the application.  Pressing ID="ch0959"<Cancel> anywhere in the DialogBox, except during a cancelable drag operation, must perform the action of this button.  HelpMust provide any help for the DialogBox.  ID="ch0960"You should arrange PushButton actions in DialogBoxes like other PushButtons, according to order and frequency of use.  The common action PushButtons should be ordered as presented in the previous list.  Positive responses to the DialogBox should be presented first, followed by negative responses and canceling responses.  Help should always be the last action on the right.  LBL="9.12.2" HELPID=""IllustrationLBL="9-7" FILE="multirep.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-7"Figure 9-7 
A DialogBoxLBL="9.12.3" HELPID=""NavigationA DialogBox must follow the navigation model described in IDREF="31210" TYPE="TITLE"Chapter 3, "Navigation."LBL="9.12.4" HELPID=""Related InformationFor more information, see the reference pages in IDREF="35462" TYPE="TITLE"Section 9.9, "CommandDialog,"IDREF="35612" TYPE="TITLE"Section 9.15, "ErrorDialog,"IDREF="33976" TYPE="TITLE"Section 9.19, "FileSelectionDialog,"IDREF="28265" TYPE="TITLE"Section 9.27, "InformationDialog,"IDREF="23864" TYPE="TITLE"Section 9.35, "MessageDialogs,"IDREF="16087" TYPE="TITLE"Section 9.44, "PromptDialog,"IDREF="15041" TYPE="TITLE"Section 9.46, "QuestionDialog,"IDREF="41952" TYPE="TITLE"Section 9.55, "SelectionDialog,"IDREF="21595" TYPE="TITLE"Section 9.60, "WarningDialog,"
 and IDREF="14357" TYPE="TITLE"Section 9.62, "WorkingDialog."LBL="9.13" HELPID=""Drag and DropLBL="9.13.1" HELPID=""DescriptionID="ch0961"ID="ch0962"Drag and drop provides a quick and simple model for transferring data within and between applications.  A drag and drop interaction is accomplished in four steps: The user selects elements to drag and grabs them with the pointer, or grabs an unselected element.  The user drags elements to the drop location.  The user drops the elements on the drop location.  The component dropped on processes the drop action.  Pressing Transfer in a draggable element and moving the pointer must start a drag and drop interaction.  If a drag is initiated in an unselected region and the pointer is over two possible draggable elements, the drag must occur on the highest draggable element in the stacking order.  This also implies that in nested draggable elements the drag occurs from the smallest draggable element under the pointer.  When BSelect is used for dragging operations, its use must supersede the use of BSelect Motion in the selection models described in IDREF="12200" TYPE="TITLE"Section 4.1, "Selection Models."Any successful drag and drop transfer from a read-only component should by default result in a copy of the data, but it can result in a link.  Transfers from writable components can by default result in a copy, a link, or a move.  <Shift> BTransfer Release must force a move operation if possible; otherwise, the operation must fail.  <Ctrl> BTransfer Release must force a copy operation if possible; otherwise, the operation must fail.  <Ctrl> <Shift> BTransfer Release must force a link operation if possible; otherwise, the operation must fail.  If a system provides drag and drop help, pressing <Help> during a drag and drop operation should allow the posting of a DialogBox with the help information and the possible choices for continuing the drag and drop operation.  Pressing <Cancel> during a drag operation must cancel the current drag operation and return the system to the state prior to the start of the drag operation.  Releasing BTransfer must end a drag and drop operation.  When a user releases BTransfer, the drop operation must occur at the location of the hotspot of the drag icon pointer.  The drop must occur into the highest drop site in the stacking order.  This also implies that in a group of nested drop sites the drop occurs into the smallest drop site under the pointer.  LBL="9.13.2" HELPID=""Related InformationSee IDREF="21864" TYPE="TITLE"Section 4.3, "Transfer Models."
 for more information on the drag and drop model, and for information on quick transfer and the selection models.  LBL="9.14" HELPID=""ID="36374"Edit MenuLBL="9.14.1" HELPID=""DescriptionID="ch0963"ID="ch0964"The common Edit Menu contents are described as follows.  Note that you should only include those functions actually supported by your application.  The Edit Menu can contain a TearOffButton.  The illustration on this reference page shows an Edit Menu.  Undo   Alt+Backspace Must reverse the most recently executed action.  To provide a visual cue to the user, the ID="ch0965"Undo selection title should be dynamically modified to indicate what is being undone.  For example, if the most recently executed action was a paste, the action name would be Undo paste.  Your application should be able to undo all of the actions in the Edit Menu.  This action must have the mnemonic U.  Cut   Shift+DelMust remove the selected portion of data from the client area to the clipboard.  This action must choose the component to act on by following the rules in ID="ch0966"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets"
 for operations that act on selections.  This action must have the mnemonic T.  Copy   Ctrl+InsMust copy the selected portion of data to the clipboard without removing the original data from the client area.  This action must choose the component to act on by following the rules in ID="ch0967"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets"
 for operations that act on selections.  This action must have the mnemonic C.  Copy LinkMust copy a link of the selected portion of data to the clipboard without removing the original data from the client area.  This action must choose the component to act on by following the rules in ID="ch0968"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets"
 for operations that act on selections.  This action must have the mnemonic K.  Paste   Shift+Ins Must paste the contents of the clipboard into a client area.  This action must choose the component to act on by following the rules in ID="ch0969"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets"
 for operations that do not act on selections.  This action must have the mnemonic P.  Paste LinkMust paste a link of the data represented by the contents of the clipboard into a client area.  This action must choose the component to act on by following the rules in ID="ch0970"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets"
 for operations that do not act on selections.  This action must have the mnemonic L.  ClearMust remove a selected portion of data from the client area without copying it to the clipboard.  The remaining data is not compressed to fill the space that was occupied by the cleared data.  This action must choose the component to act on by following the rules in ID="ch0971"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets"
 for operations that act on selections.  This action must have the mnemonic E.  DeleteMust remove a selected portion of data from the client area without copying it to the clipboard.  This action must choose the component to act on by following the rules in ID="ch0972"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets"
 for operations that act on selections.  This action must have the mnemonic D.  Select All   Ctrl+/ Must make the primary selection consist of all the elements in a component of the client area.  This action must choose the component to act on by following the rules in ID="ch0973"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets"
 for operations that do not act on selections.  If the action uses an accelerator, it should be <Ctrl> </>.Deselect All   Ctrl+\ Must remove from the primary selection all the elements in a component of the client area.  This action must choose the component to act on by following the rules in ID="ch0974"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets"
 for operations that do not act on selections.  If the action uses an accelerator, it should be <Ctrl> <\>.Select PastedMust make the primary selection consist of the last element or elements pasted into a component of the client area.  This action must choose the component to act on by following the rules in ID="ch0975"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets"
 for operations that do not act on selections.  Reselect   Alt+Insert Must make the primary selection consist of the last selected element or elements in a component of the client area.  This action must choose the component to act on by following the rules in ID="ch0976"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets"
 for operations that do not act on selections.  The action must be available only in components that do not support persistent selections and only when the current selection is empty.  If the action uses an accelerator, it should be <Alt> <Insert>.Promote   Alt+Insert Must promote to the primary selection the current selection of a component of the client area.  This action must choose the component to act on by following the rules in ID="ch0977"IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets"
 for operations that act on selections.  This action must only be available for components that support persistent selections.  If the action uses an accelerator, it should be <Alt> <Insert>.You should include Menu items in the order described.  If you add new Menu items, you should insert them near similar elements.  If you use accelerators for Undo, Cut, Copy, and Paste, you must use either one or both of the models presented in the following two tables.  COLUMNS="2"LEFT="0" WIDTH="72"Edit Menu ItemLEFT="80" WIDTH="356"AcceleratorLEFT="0" WIDTH="72"UndoLEFT="80" WIDTH="356"<Alt><BackSpace>LEFT="0" WIDTH="72"CutLEFT="80" WIDTH="356"<Shift><Delete>LEFT="0" WIDTH="72"CopyLEFT="80" WIDTH="356"<Ctrl><Insert>LEFT="0" WIDTH="72"PasteLEFT="80" WIDTH="356"<Shift><Insert>LBL="9-1"Table 9-1 
Edit Menu Accelerators, Model 1COLUMNS="2"LEFT="0" WIDTH="126"Edit Menu ItemLEFT="135" WIDTH="356"AcceleratorLEFT="0" WIDTH="126"UndoLEFT="135" WIDTH="356"<Ctrl><Z>LEFT="0" WIDTH="126"CutLEFT="135" WIDTH="356"<Ctrl><X>LEFT="0" WIDTH="126"CopyLEFT="135" WIDTH="356"<Ctrl><C>LEFT="0" WIDTH="126"PasteLEFT="135" WIDTH="356"<Ctrl><V>LBL="9-2"Table 9-2 
Edit Menu Accelerators, Model 2In addition, if your keyboard has <Undo>,<Cut>,<Copy>,and <Paste> keys, these should be supported as accelerators for the corresponding Menu items as well.  LBL="9.14.2" HELPID=""IllustrationLBL="9-8" FILE="editmenu.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-8"Figure 9-8 
An Edit MenuLBL="9.14.3" HELPID=""Related InformationSee IDREF="20011" TYPE="TITLE"Chapter 6, "Application Design Principles"
 for more information on the MenuBar system and for general information about Menu design.  LBL="9.15" HELPID=""ID="35612"ErrorDialogLBL="9.15.1" HELPID=""DescriptionID="ch0978"ID="ch0979"An ErrorDialog should be used to convey a message about a user error.  It should stop user interaction with the application until it is dismissed.  It should include an error symbol, a message, and one of the following button arrangements: OK CancelOK Cancel HelpLBL="9.15.2" HELPID=""IllustrationLBL="9-9" FILE="errorbox.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-9"Figure 9-9 
An ErrorDialogLBL="9.15.3" HELPID=""Related InformationFor more information, see the reference page in IDREF="17953" TYPE="TITLE"Section 9.12, "DialogBox."LBL="9.16" HELPID=""Field ControlsLBL="9.16.1" HELPID=""DescriptionID="ch0980"Field controls are components that use internal navigation controls.  Field controls should be navigation fields.  The following text describes the field controls: Sash Used to set the boundary between two components.  A Sash is usually a small square on the boundary between two components.  The separated components are called Panes, and a group of Panes, Separators, and Sashes is called a PanedWindow.  ID="ch0981"ID="ch0982"Scale Used to set or display a value in a range.  A Scale is usually composed of a slider, moving within an element that indicates the size of the range, and a Label that indicates the current value.  The position of the slider indicates the value relative to the range.  The slider is moved directly by using the mouse pointer or by using the arrow keys.  A Scale can also have buttons with arrow graphics for moving the slider with the mouse.  ID="ch0983"ID="ch0984"ScrollBar Used to scroll the visible area of a component.  A ScrollBar is usually composed of a slider, moving within an element that indicates the full size of the component, and buttons with arrow graphics for moving the slider with the mouse.  The slider indicates the relative position and size of the visible area of the component.  The slider is moved directly by using the mouse pointer or by using the arrow keys.  ID="ch0985"ID="ch0986"List Used for selecting elements from a list of elements.  A List can allow multiple items to be selected or can be constrained to allow only one item to be selected at a time.  A List is usually composed of a vertical list of items.  A List can also have both horizontal and vertical ScrollBars for scrolling the visible portion of the list of items.  ID="ch0987"ID="ch0988"Text Used for displaying, entering, and modifying text.  There are single-line and multiple-line variants.  Multiline Text can have both horizontal and vertical ScrollBars for scrolling the visible portion of the text area.  ID="ch0989"ID="ch0990"Canvas Used for displaying, entering, and modifying graphics.  A Canvas can have both horizontal and vertical ScrollBars for scrolling the visible portion of the drawing area.  ID="ch0991"ID="ch0992"LBL="9.16.2" HELPID=""NavigationField controls have navigation that is specific to the component.  See the reference pages for each field control for information about its navigation.  LBL="9.16.3" HELPID=""Other OperationsField controls have operations that are specific to the component.  See the reference pages for each field control for information about its operations.  LBL="9.16.4" HELPID=""Related InformationFor more information, see the reference pages for each field control.  LBL="9.17" HELPID=""ID="37347"File MenuLBL="9.17.1" HELPID=""DescriptionID="ch0993"ID="ch0994"The common File Menu contents are described as follows.  Note that you should only include those functions actually supported by your application.  If the label File is not appropriate to the context of your application, you can choose a different, more appropriate label.  The File Menu can contain a TearOffButton.  The illustration on this reference page shows a File Menu.  NewMust create a new file.  The ID="ch0995"New operation must clear existing data from the client area.  If completion of the operation will obliterate current changes to the file, you must display a DialogBox, asking the user about saving changes.  This action must have the mnemonic N.  Open . . .Must open an existing file.  The ID="ch0996"Open operation must prompt the user for the name of the file with a DialogBox.  The title bar should be updated with the name of the newly opened file.  If completion of the operation will obliterate current changes to the file, you must display a DialogBox, asking the user about saving changes.  This DialogBox should be displayed after the user selects a new file.  This action must have the mnemonic O.  SaveMust save the currently opened file without removing the existing contents of the client area.  If the currently opened file has no name, ID="ch0997"Save must prompt for a filename with a DialogBox.  This action must have the mnemonic S.  Save As . . .Must save the currently opened file under a new name without removing the existing contents of the client area.  The ID="ch0998"Save As operation must prompt for the name of the file with a DialogBox.  If the user tries to save the new file under an existing name, Save As must alert the user with a DialogBox of a possible loss of data.  This action must have the mnemonic A.  PrintMust schedule a file for printing.  If your application requires specific printing information before printing, the operation must first request that information with a DialogBox, and the entry title must be followed by an ellipsis.  Printing information can also be specified for the application in the ID="ch0999"Options Menu.  This action must have the mnemonic P.  CloseCan be supplied in applications that have multiple independent primary windows.  This action must not be supplied in applications with a single primary window or multiple dependent primary windows.  This action must only close the current primary window and its associated secondary windows; that is, the window family.  This action must have the mnemonic ID="ch09100"C.  You can include this action even though it is similar to the Close action in the window Menu.  This ensures that users have a way to close the primary window even if they are not running a compliant window manager.  Applications should prompt the user to save any unsaved changes if the action would cause loss of data.  ExitMust end the current application and all windows associated with it.  This action is equivalent to closing all primary windows of the application.  If completion of the operation will obliterate current changes to the file, you must display a DialogBox, asking the user about saving changes.  This action must have the mnemonic ID="ch09101"X.  You should include this action even though it is similar to the Close action in the window Menu.  This ensures that users have a way to end the application even if they are not running a compliant window manager.  Applications should prompt the user to save any unsaved changes if the action would cause loss of data.  If your application does not have a File Menu, put Exit at the end of the first Pulldown Menu.  LBL="9.17.2" HELPID=""IllustrationLBL="9-10" FILE="filemenu.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-10"Figure 9-10 
A File MenuLBL="9.17.3" HELPID=""Related InformationSee IDREF="20011" TYPE="TITLE"Chapter 6, "Application Design Principles"
 for more information on the MenuBar system and for general information about Menu design.  LBL="9.18" HELPID=""FileSelectionBoxLBL="9.18.1" HELPID=""DescriptionID="ch09102"A FileSelectionBox is a special-purpose composite component for file selection.  It can be used to traverse through directories, view the files and subdirectories in them, and then select files.  The FileSelectionBox must be composed of at least the following components: A Text component for displaying and editing a directory mask used to select the files to be displayed.  The directory mask must be a string specifying the base directory to be examined and a search pattern.  A List component for displaying filenames.  The file list should display all files and subdirectories in the base directory that match the search pattern.  The List must use either the single or browse selection model.  A List component for displaying subdirectories.  The directory list should display the subdirectories of the base directory, as well as the base directory itself and its parent directory.  The List must use either the single or browse selection model.  A Text component for displaying and editing a filename.  A group of PushButtons, labeled OK, Filter, Cancel, and Help.  If the FileSelectionBox is used to perform a specific action to the selected files, OK can be replaced by a label describing the action to be done.  Additional elements can be added by an application.  The user must be able to select a new directory to examine by scrolling through the list of directories and selecting the desired directory or by editing the directory mask.  Selecting a new directory from the directory list must not change the search pattern.  A user must be able to select a new search pattern by editing the directory mask.  The List navigation actions <Up arrow>,<Down arrow>,<Ctrl> <Begin>,and <Ctrl> <End> must be available from the Text components for moving the cursored element within each List and thus changing the contents of the Text.  The List navigation actions <PageUp> and <PageDown> should also be available from the Text components for moving the cursored element within each List.  The contents of the directory Text must correspond to the contents of the directory List, and the contents of the filename Text must correspond to the contents of the filename List.  The user must be able to select a file by scrolling through the list of filenames and selecting the desired file or by entering the filename directly into the Text component.  Selecting a file from the list causes that filename to appear in the file selection Text component.  The user can select a new file as many times as desired.  The application must not be notified until one of the following events occurs: The user activates the OK PushButton.  The user presses <Enter> or <Return> while the filename Text component has the keyboard focus.  The user presses <Enter> or <Return> while the location cursor is on an item in the file List.  The user double-clicks BSelect on an item in the file List.  The FileSelectionBox must initiate a directory and file search when any of the following occurs: The FileSelectionBox is initialized.  The user activates the Filter PushButton.  The user double-clicks or presses <Enter> or <Return> on an item in the directory List.  The user presses <Enter> or <Return> while the directory mask Text edit area has the keyboard focus.  LBL="9.18.2" HELPID=""IllustrationLBL="9-11" FILE="fileselb.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-11"Figure 9-11 
A FileSelectionBoxLBL="9.18.3" HELPID=""Related InformationFor more information, see the reference page in IDREF="33976" TYPE="TITLE"Section 9.19, "FileSelectionDialog."LBL="9.19" HELPID=""ID="33976"FileSelectionDialogLBL="9.19.1" HELPID=""DescriptionID="ch09103"ID="ch09104"A FileSelectionDialog should be used to enter the name of a file for processing.  It should not interrupt the user's interaction with the application.  It should include a FileSelectionBox.  LBL="9.19.2" HELPID=""IllustrationLBL="9-12" FILE="fileselb.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-12"Figure 9-12 
A FileSelectionDialogLBL="9.19.3" HELPID=""Related InformationFor more information, see the reference page in IDREF="17953" TYPE="TITLE"Section 9.12, "DialogBox."LBL="9.20" HELPID=""FocusLBL="9.20.1" HELPID=""DescriptionID="ch09105"ID="ch09106"ID="ch09107"ID="ch09108"ID="ch09109"ID="ch09110"The keyboard focus model is defined by a focus policy.  A focus policy is a specific mechanism for moving the focus among windows and components.  The implicit and explicit focus policies must be supported.  ID="ch09111"ID="ch09112"In the implicit focus policy, also called the pointer, real-estate driven, or point-to-type policy, the keyboard focus moves to the window or component into which a user moves the mouse pointer.  No explicit action is performed to set the keyboard focus in the implicit focus model.  Keyboard events are sent to the window or component that the mouse pointer is in, more specifically to the component that the mouse pointer is in.  In implicit mode, the keyboard focus tracks the mouse pointer.  Because of this, there is no way to move the keyboard focus from the keyboard using implicit mode.  In this focus policy, the location cursor for keyboard events does not need to be shown; however, the application can show it.  ID="ch09113"ID="ch09114"ID="ch09115"The explicit focus policy requires the user to explicitly select which window or component receives the keyboard focus.  In explicit focus mode at the window level, a user moves the keyboard focus to a window by pressing BSelect while the mouse pointer is over the window.  Simply moving the mouse pointer over a window does not give the window the keyboard focus.  Because of this, explicit mode is often called click-to-type.  In explicit mode within a window, a user generally moves the keyboard focus to a specific component within a window by pressing BSelect over the component.  Pressing BSelect must not move focus to a component that is not traversable or does not accept input.  Pressing BSelect in a component that is used only to change the visible portion of another component, such as a ScrollBar or Sash, should act on that component but should not move focus to it.  In this focus policy, the location of keyboard focus must be shown by a location cursor.  LBL="9.20.2" HELPID=""Related InformationSee IDREF="16621" TYPE="TITLE"Chapter 2, "Input Models"
 for more information about the focus model.  LBL="9.21" HELPID=""FrameLBL="9.21.1" HELPID=""DescriptionID="ch09116"A Frame should be used to frame other components.  It simply provides a decorative border.  LBL="9.21.2" HELPID=""Other OperationsThis component can indicate the input focus.  LBL="9.22" HELPID=""Framing GroupsLBL="9.22.1" HELPID=""DescriptionID="ch09117"Framing groups are used to frame groups of components as the following text describes: Frame Draws framing decorations around a component.  ID="ch09118"ScrolledWindow Frames a component and adds ScrollBars for scrolling the visible area of the component.  ID="ch09119"MainWindow Organizes the contents of a primary window.  A MainWindow frames the client area and can optionally include ScrollBars, a MenuBar, a command area, and a message area.  ID="ch09120"LBL="9.22.2" HELPID=""NavigationThese groups must follow the navigation model as described in IDREF="31210" TYPE="TITLE"Chapter 3, "Navigation."LBL="9.22.3" HELPID=""Related InformationFor more information, see the reference pages for each framing group.  LBL="9.23" HELPID=""ID="40804"Help MenuLBL="9.23.1" HELPID=""DescriptionID="ch09121"ID="ch09122"There are two acceptable models for the contents of the Help Menu.  The OSF/Motif Style Guide allows either model.  The common Menu contents for this model are described in the following text.  Note that you should only include those functions actually supported by your application.  The Help Menu can contain a TearOffButton.  The illustration on this reference page shows this first model of a Help Menu.  On Context   Shift+Help Must initiate context-sensitive help by changing the shape of the pointer to the question pointer described in ID="ch09123"ID="ch09124"IDREF="11954" TYPE="TITLE"Section 2.2.2, "Pointer Shapes."
  When the user moves the pointer to the component help is wanted on and presses BSelect, any available context-sensitive help for the component must be presented, and the pointer reverts from the question pointer.  This action must have the mnemonic C.  If the action uses an accelerator, it should be <Shift> <Help>.On HelpMust provide information on how to use the application's help facility.  This action must have the mnemonic ID="ch09125"H.  On WindowMust provide general information about the window from which help was requested.  This action must have the mnemonic ID="ch09126"W.  On KeysMust provide information about the application's use of function keys, mnemonics, and keyboard accelerators.  This action must have the mnemonic ID="ch09127"K.  IndexMust provide an index for all help information in the application.  This action must have the mnemonic ID="ch09128"ID="ch09129"I.  The index can provide search capabilities.  TutorialMust provide access to the application's tutorial.  This action must have the mnemonic ID="ch09130"ID="ch09131"T.  On VersionMust provide the name and version of the application.  This action must have the mnemonic ID="ch09132"ID="ch09133"V.  It can provide other information as well.  The common Menu contents in the second model are described in the following text.  Note that you should only include those functions actually supported by your application.  The Help Menu can contain a TearOffButton.  Context-Sensitive Help   Shift+Help Must initiate context-sensitive help by changing the shape of the pointer to the question pointer described in ID="ch09134"ID="ch09135"IDREF="11954" TYPE="TITLE"Section 2.2.2, "Pointer Shapes."
 When the user moves the pointer to the component help is wanted on and presses BSelect, any available context-sensitive help for the component must be presented, and the pointer reverts from the question pointer.  This action should be followed by a separator.  This action must have the mnemonic C.  If the action uses an accelerator, it should be <Shift> <Help>.OverviewMust provide general information about the application window from which help was requested.  This action must have the mnemonic ID="ch09136"ID="ch09137"O.  IndexMust provide an index for all help information in the application.  This action must have the mnemonic ID="ch09138"ID="ch09139"I.  The index can provide search capabilities.  KeyboardMust provide information about the application's use of function keys, mnemonics, and keyboard accelerators.  This action must have the mnemonic ID="ch09140"ID="ch09141"K.  TutorialMust provide access to the application's tutorial.  This action must have the mnemonic ID="ch09142"ID="ch09143"T.  Using 'HelpMust provide information on how to use the application's help facility.  This action must have the mnemonic ID="ch09144"ID="ch09145"H.  Product Information Must provide the name and version of the application.  This action must have the mnemonic ID="ch09146"ID="ch09147"P.  It can provide other information as well.  Applications should place additional Help Menu items between Index and Using Help.  Help is usually provided in DialogBoxes but can also appear in the message area.  You should include Menu items in the order described.  If you add new Menu items, you should insert them near similar elements.  LBL="9.23.2" HELPID=""IllustrationLBL="9-13" FILE="helpmenu.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-13"Figure 9-13 
A Help MenuLBL="9.23.3" HELPID=""Related InformationSee IDREF="20011" TYPE="TITLE"Chapter 6, "Application Design Principles"
 for more information on the MenuBar system and for general information about Menu design.  LBL="9.24" HELPID=""Icon MenuLBL="9.24.1" HELPID=""DescriptionID="ch09148"ID="ch09149"Clicking BSelect in an icon must give the icon the keyboard focus and post the icon Menu.  The icon Menu must be the same Menu as the window Menu for the associated primary window.  Size should not be available from the icon Menu.  Navigating to the icon must also give the icon the keyboard focus and should post the icon Menu.  Double-clicking BSelect anywhere in the icon must restore the window family, just as the icon Menu item Restore does.  If the window is currently minimized, but its previous state was maximized, double-clicking BSelect returns it to the maximized state.  Selecting Maximize from the icon Menu always maximizes the corresponding window.  If the window is minimized, Minimize must not be available in the icon Menu; otherwise, selecting it minimizes the window family.  Pressing BSelect or BTransfer anywhere in the icon and dragging the mouse pointer must move the icon to track the pointer, just as the icon Menu item Move does.  If the window manager has been customized by the user so that the icon Menu does not pop up when the icon gets the focus, <Shift> <Escape>,<Alt> <Space>,<Menu>,and BMenu must pop up the icon Menu.  LBL="9.24.2" HELPID=""Related InformationSee IDREF="24491" TYPE="TITLE"Chapter 7, "Window Manager Design Principles"
 for more information on the icon Menu and the window manager in general.  See IDREF="20011" TYPE="TITLE"Chapter 6, "Application Design Principles"
 for information about Menu design.  LBL="9.25" HELPID=""IconBoxLBL="9.25.1" HELPID=""DescriptionID="ch09150"ID="ch09151"An icon box is a specialized window that acts as a storage location for icons.  An icon box acts like a typical window in the sense that it has a window frame and frame components.  The client area of an icon box must have an area for holding icons and can have horizontal and vertical scroll bars for moving around the icon area.  The icon box must have all the same components as any other primary window.  Like other windows it can be sized, moved, minimized, maximized, restored, and lowered.  However, the window manager must not allow the icon box to be closed.  The system Menu action Close must be replaced with the system Menu action Pack Icons in an icon box.  Double-clicking BSelect in the icon box system Menu must only open the icon box system Menu.  It must not close the icon box.  Pack Icons arranges the icons as close as possible together in the visible icon area if possible.  Pack Icons must have the mnemonic P.  If Pack Icons has an accelerator, it should be <Alt> <F12> if <F12 > is available.  When the input focus is in the icon box, <Shift> <Escape> or <Alt> <Space> must pop up the icon box system Menu if the Menu is unposted.  If the Menu is already posted, <Shift> <Escape> or <Alt> <Space> must unpost the Menu.  ID="ch09152"The icon box can contain an icon for each window family, even if it is active.  The icon for minimized window families must be the same as the icon would be outside of the icon box.  The icon for an active window family should be similar to the minimized icon, deemphasized somehow.  Clicking BSelect in an icon must give the icon keyboard focus and post the icon Menu.  The icon Menu must be the same Menu as the window Menu for the associated primary window.  If the icon represents an active window family, Restore and Size must not be available from the icon Menu.  If the icon represents a minimized window family, Size must not be available from the icon Menu.  If the window manager is customized so that the icon with the focus does not have its window Menu automatically posted, BMenu or <Menu> must post its Menu.  Double-clicking BSelect anywhere in an icon that represents a minimized window family must restore the window family, just as the icon Menu item Restore does.  Double-clicking BSelect anywhere in an icon that represents an active window family must raise the window family to the top of the window hierarchy.  If the window is currently minimized, but its previous state was maximized, double-clicking BSelect returns it to the maximized state.  Selecting Maximize from the icon Menu always maximizes the corresponding window.  If the window is minimized, Minimize must not be available in the icon Menu; otherwise, selecting it minimizes the window family.  Pressing BSelect or BTransfer anywhere in the icon and dragging the mouse pointer must move the icon within the icon area to track the pointer, just as the icon Menu item Move does.  The <Down arrow>,<Up arrow>,<Right arrow>,and <Left arrow> directional keys must navigate among the icons in the icon box.  Icon navigation must behave as described in the following text.  Note that <Down arrow> and <Right arrow> do not need to traverse icons in the same order.  <Down arrow> In a left-to-right language environment, this key must move the location cursor through the icons in the icon box, starting at the upper-left icon and ending at the lower-right icon, then wrapping back up to the upper left.  In a right-to-left language environment, the location cursor can move, starting at the upper right and moving to the lower left.  <Left arrow> This key must move the location cursor through the icons in the opposite direction of <Right arrow>.<Right arrow> In a left-to-right language environment, this key must move the location cursor through the icons in the icon box, starting at the upper-left icon and ending at the lower-right icon, then wrapping back up to the upper left.  In a right-to-left language environment, the location cursor can move, starting at the upper right and moving to the lower left.  <Up arrow> This key must move the location cursor through the icons in the opposite direction of <Down arrow>.LBL="9.25.2" HELPID=""IllustrationLBL="9-14" FILE="iconbox.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-14"Figure 9-14 
An IconBoxLBL="9.25.3" HELPID=""Related InformationSee IDREF="24491" TYPE="TITLE"Chapter 7, "Window Manager Design Principles"
 for more information about icons and the window manager.  LBL="9.26" HELPID=""IconsLBL="9.26.1" HELPID=""DescriptionID="ch09153"An icon is a stylized representation of an object.  A window icon is a minimized representation of a window or window family that can help organize windows and tasks in the display.  Iconifying a window is also known as minimizing a window.  The window manager must iconify all windows of window family together.  It must not iconify any single window, primary or secondary, from a window family without also iconifying all the other windows in the window family.  The iconic representation of a window family should not change any state in the windows, except the visual representation of the window.  The application running inside of a window must continue running even when the application is iconified.  The application can adjust its own state when it is iconified.  An icon is made up of an image and a label.  The illustration on this reference page shows a typical Motif icon.  The image should be surrounded by a border that indicates when the icon has the keyboard focus.  The image area can contain text or a bitmap.  The label should be located just below the image and its border.  The label can also indicate when the icon has the keyboard focus by highlighting with the image area.  The label should contain the same text as the title area of the corresponding primary window, or an abbreviated form of it.  When the icon does not have the keyboard focus, the width of the label must be the same as the width of the image area and its border, truncating text if necessary.  When the icon has the keyboard focus, the width of the label can expand to display the entire text.  Clicking BSelect in an icon must give the icon keyboard focus and should post the icon Menu.  Navigating to the icon must also give the icon the keyboard focus and should post the icon Menu.  Double-clicking BSelect anywhere in the icon must restore the window family, just as the icon Menu item Restore does.  If the window is currently minimized, but its previous state was maximized, double-clicking BSelect returns it to the maximized state.  Selecting Maximize from the icon Menu always maximizes the corresponding window.  If the window is minimized, Minimize must not be available in the icon Menu; otherwise, selecting it minimizes the window family.  Pressing BSelect or BTransfer anywhere in the icon and dragging the mouse pointer must move the icon to track the pointer, just as the icon Menu item Move does.  If the window manager has been customized by the user so that the icon Menu does not pop up when the icon gets the focus, <Shift> <Escape>,<Alt> <Space>,<Menu>,and BMenu must pop up the icon Menu.  LBL="9.26.2" HELPID=""IllustrationLBL="9-15" FILE="termicon.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-15"Figure 9-15 
An IconLBL="9.26.3" HELPID=""Related InformationSee IDREF="24491" TYPE="TITLE"Chapter 7, "Window Manager Design Principles"
 for more information about icons and the window manager.  LBL="9.27" HELPID=""ID="28265"InformationDialogLBL="9.27.1" HELPID=""DescriptionID="ch09154"ID="ch09155"An InformationDialog should be used to convey information to the user.  It must not interrupt the user's interaction with the application.  It should include an information symbol, a message, and one of the following button arrangements: OKOK HelpLBL="9.27.2" HELPID=""IllustrationLBL="9-16" FILE="infobox.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-16"Figure 9-16 
An InformationDialogLBL="9.27.3" HELPID=""Related InformationFor more information, see the reference page in IDREF="17953" TYPE="TITLE"Section 9.12, "DialogBox."LBL="9.28" HELPID=""Input DevicesLBL="9.28.1" HELPID=""DescriptionID="ch09156"ID="ch09157"ID="ch09158"ID="ch09159"ID="ch09160"ID="ch09161"ID="ch09162"ID="ch09163"ID="ch09164"ID="ch09165"ID="ch09166"ID="ch09167"The most typical pointing device is a mouse, although a graphics tablet, track ball, joystick, and other tools also work as pointing devices.  You can use any pointing device in place of a mouse.  This guide assumes that a mouse, or any pointing device, has the following three buttons.  IDREF="16621" TYPE="TITLE"Chapter 2, "Input Models"
 describes the button bindings for pointing devices that do not have three buttons.  BSelect Used for selection, activation, and setting the location cursor.  This button must be the leftmost button, except for left-handed users where it can be the rightmost button.  BTransfer Used for moving and copying elements.  This button must be the middle mouse button, unless dragging is integrated with selection.  Details about the effects of integrating BTransfer with BSelect are described in IDREF="12570" TYPE="TITLE"Chapter 4, "Selection."BMenu Used for popping up Menus.  This button must be the rightmost button, except for left-handed users where it can be the leftmost button.  ID="ch09168"ID="ch09169"ID="ch09170"ID="ch09171"ID="ch09172"Since not all keyboards are the same, it is difficult to give style guidelines that are correct for every manufacturer's keyboard.  To solve this problem, this guide describes keys using a model keyboard mechanism.  Wherever keyboard input is specified, the keys are indicated by the engraving they have on the OSF/Motif model keyboard.  The model keyboard does not correspond directly to any existing keyboard; rather, it assumes a keyboard with an ideal set of keys.  In addition to the standard letter, number, and character keys, the OSF/Motif model keyboard is composed of the following special keys: The special printing characters </>,<\>,and <!> The standard modifier keys <Ctrl>,<Alt>,and <Shift> Ten function keys <F1> through <F10> The arrow keys <Down arrow>,<Left arrow>,<Right arrow>,and <Up arrow> <BackSpace> <Cancel> <Delete> <End> <Escape> <Help> <Home> <Insert> <Menu> <PageDown> <PageUp> <Return> <Space> <Tab> The OSF/Motif model keyboard also contains the following optional keys, which although useful, either are not necessary or can be replaced by combinations of other keys: <CapsLock> <Copy> <Cut> <Enter> <ModeSwitch> <NumLock> <PageLeft> <PageRight> <Paste> <ScrollLock> <Select> <Undo> Throughout this guide, behavior is described in terms of model keyboard keys.  When a behavior takes advantage of an optional key from the model keyboard, it is also described in terms of the required special keys.  Each of the nonoptional keys described on the OSF/Motif model keyboard must be available either as specified or by using other keys or key combinations if the specified key is unavailable.  LBL="9.28.2" HELPID=""Related InformationSee IDREF="16621" TYPE="TITLE"Chapter 2, "Input Models"
 for a more information about input devices.  LBL="9.29" HELPID=""LabelLBL="9.29.1" HELPID=""DescriptionID="ch09173"A Label should be used to display text or graphics that label other components.  This component must be composed of an area for displaying a text or graphics label.  LBL="9.29.2" HELPID=""IllustrationLBL="9-17" FILE="label.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-17"Figure 9-17 
A LabelLBL="9.29.3" HELPID=""NavigationA Label must have no internal navigation.  LBL="9.30" HELPID=""Layout GroupsLBL="9.30.1" HELPID=""DescriptionID="ch09174"Layout groups are used for organizing components into groups as described in the following text: Composition Organizes a collection of components, including groups, in an arbitrary layout.  ID="ch09175"PanedWindow A linear grouping of components and Sashes.  Sashes are used to set the boundary between two components.  The separated components are called Panes and can contain any components.  ID="ch09176"ID="ch09177"ID="ch09178"LBL="9.30.2" HELPID=""NavigationLayout groups must follow the navigation model as described in IDREF="31210" TYPE="TITLE"Chapter 3, "Navigation."LBL="9.30.3" HELPID=""Related InformationFor more information, see the reference pages for each layout group.  LBL="9.31" HELPID=""ListLBL="9.31.1" HELPID=""DescriptionID="ch09179"A List should be used to present a list of elements for selection.  The List elements can be selected using either the single selection model, the browse selection model, the multiple selection model, or the discontiguous selection model.  This component must be composed of an area for presenting a list of text or graphics elements.  It can optionally have vertical and horizontal ScrollBars, which show different views of the List elements.  The location cursor in a List should differentiate between normal mode and add mode.  The location cursor should be a solid box in normal mode and a dashed box in add mode.  LBL="9.31.2" HELPID=""IllustrationLBL="9-18" FILE="itemcurs.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-18"Figure 9-18 
A ListLBL="9.31.3" HELPID=""NavigationThe following text describes the navigation actions of this component: <Ctrl> <Begin> Must move the location cursor to the first item in the List.  <Ctrl> <End> Must move the location cursor to the last item in the List.  <Up arrow> Must move the location cursor to the previous item in the List.  <Down arrow> Must move the location cursor to the next item in the List.  <PageDown> In a scrollable List, must move the location cursor to the item one page down in the List.  <PageUp> In a scrollable List, must move the location cursor to the item one page up in the List.  LBL="9.31.4" HELPID=""Other OperationsThe following text describes the operations of this component: BSelect Click 2 Must select the current List item and cause any default action for the window to occur.  <Begin> In a scrollable List, must move the horizontal scroll region so that the leftmost edge of the List is visible.  <End> In a scrollable List, must move the horizontal scroll region so that the rightmost edge of the List is visible.  <Left arrow> In a scrollable List, must scroll the List one character to the left.  <PageLeft> or <Ctrl> <PageUp> In a scrollable List, must scroll the List one page to the left.  <Right arrow> In a scrollable List, must scroll the List one character to the right.  <PageRight> or <Ctrl> <PageDown> In a scrollable List, must scroll the List one page to the right.  <Help> Must provide any available help for the List.  LBL="9.31.5" HELPID=""Related InformationFor more information on List element selection, see the description of the selection models in IDREF="12570" TYPE="TITLE"Chapter 4, "Selection."
  For more information about the ScrollBars, see the reference page in IDREF="31889" TYPE="TITLE"Section 9.51, "ScrollBar."LBL="9.32" HELPID=""MainWindowLBL="9.32.1" HELPID=""DescriptionID="ch09180"ID="ch09181"ID="ch09182"A MainWindow should be used to organize the contents of a primary window.  A MainWindow must frame the client area and can optionally include ScrollBars, a MenuBar, a command area, and a message area.  LBL="9.32.2" HELPID=""IllustrationLBL="9-19" FILE="mainw.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-19"Figure 9-19 
A MainWindowLBL="9.32.3" HELPID=""NavigationA MainWindow must follow the navigation model described in IDREF="31210" TYPE="TITLE"Chapter 3, "Navigation."LBL="9.32.4" HELPID=""Related InformationFor more information about the components of the MainWindow, see the reference pages in IDREF="34153" TYPE="TITLE"Section 9.33, "MenuBar,"IDREF="31889" TYPE="TITLE"Section 9.51, "ScrollBar,"
 and IDREF="15561" TYPE="TITLE"Section 9.58, "Text."LBL="9.33" HELPID=""ID="34153"MenuBarLBL="9.33.1" HELPID=""DescriptionID="ch09183"ID="ch09184"A MenuBar is a basic group that organizes the most common features of an application.  The MenuBar must be a horizontal bar at the top edge of the application just below the title area of the window frame.  The MenuBar contains a list of Menu topics in CascadeButtons with Pulldown Menus connected to them.  A MenuBar must contain only CascadeButtons, because other buttons inhibit Menu browsing.  Each Menu topic should have a single-letter mnemonic indicated by underlining.  The following Pulldown Menus provide general functions common to most applications.  Remember that these Menu guidelines, like all the guidelines in this OSF/Motif Style Guide, apply only in a left-to-right language environment in an English-language locale.  You need to make the appropriate changes for other locales.  File The ID="ch09185"ID="ch09186"File Menu should contain components for performing actions on the files, such as opening, saving, closing, and printing.  It should also contain components for performing actions on the application as a whole, such as quitting.  If the Label File is not appropriate to the context of your application, you can choose a different, more appropriate Label.  The File Menu should have a mnemonic of F.  Selected The ID="ch09187"ID="ch09188"Selected Menu should contain components for performing actions on the objects represented by the current selection of the application, such as opening or printing a selected item.  This Menu is often similar to the File Menu, except that it acts on the objects denoted by the current selection.  For example, in a directory browser, Open in the File Menu could (using a DialogBox) prompt the user for the name of a directory to open for browsing, while Open in the Selected Menu opens the file whose icon is currently selected in the browser.  The Selected Menu should not contain editing functions normally found in the Edit Menu.  The Selected Menu should have a mnemonic of S.  Edit The ID="ch09189"ID="ch09190"Edit Menu should contain components for performing actions on the current data of the application, such as an undo action or making global substitutions in a block of text.  It should also include components for interacting with the system clipboard, such as cut, copy, and paste.  The Edit Menu should have a mnemonic of E.  View The ID="ch09191"ID="ch09192"View Menu should contain components for changing the user's view on the data.  Components in the View Menu should not actually change the data.  The exact contents of the View Menu are application specific but can include components that change the appearance of the data, the amount of data that is displayed, or the order in which the data is displayed.  The View Menu should have a mnemonic of V.  Options The ID="ch09193"ID="ch09194"Options Menu should contain components for a user to customize the application.  The exact contents of the Options Menu are application specific.  The Options Menu should have a mnemonic of O.  Help The ID="ch09195"ID="ch09196"Help Menu should contain components that provide user help facilities.  The components in the Help Menu usually bring up a DialogBox with help information.  Every application should have a Help Menu.  The Help Menu should have a mnemonic of H.  While we recommend that you include the common Menus in the MenuBar of your application, your choice of Menu titles and items depends on the nature of your application.  If your application requires it, you should design more relevant titles and selections, but do not change the meanings of items used in the common Menus.  If any of the common Menus are present, they must be arranged in the following order with respect to each other, ranging from left to right across the MenuBar in a left-to-right language environment: File Menu
Selected Menu
Edit Menu
View Menu
Options Menu
Help MenuYou can omit any of these Menus if they are not relevant to the application.  You can also intersperse other, application-specific, Menus among these Menus.  However, if a File Menu is present, it must be the first Menu and must be placed at the far left of the MenuBar.  If a Help Menu is present, it must be the last Menu and must be placed at the far right of the MenuBar.  The recommended contents of the File, Edit, and Help Menus are described on their own reference pages.  The contents of the View and Options Menus are application specific and are not specified here.  Each of these common Menus can contain a TearOffButton.  LBL="9.33.2" HELPID=""IllustrationLBL="9-20" FILE="menubar.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-20"Figure 9-20 
A MenuBarLBL="9.33.3" HELPID=""NavigationThe MenuBar follows the navigation model described in IDREF="31210" TYPE="TITLE"Chapter 3, "Navigation."LBL="9.33.4" HELPID=""Other OperationsThe following text describes the operations of this component: <Help> Must provide any available help for the current CascadeButton.  LBL="9.33.5" HELPID=""Related InformationFor information about the suggested contents of these Menus, see the reference pages in IDREF="37347" TYPE="TITLE"Section 9.17, "File Menu,"IDREF="36374" TYPE="TITLE"Section 9.14, "Edit Menu,"
 and IDREF="40804" TYPE="TITLE"Section 9.23, "Help Menu."LBL="9.34" HELPID=""ID="34167"MenusLBL="9.34.1" HELPID=""DescriptionID="ch09197"ID="ch09198"ID="ch09199"ID="ch09200"ID="ch09201"ID="ch09202"ID="ch09203"ID="ch09204"Menus should be used to organize a collection of basic controls in a horizontal, vertical, or 2-dimensional layout within a separate Menu window.  There are three types of Menus: Pulldown, Popup, and Option.  A Menu is only available while it is posted.  LBL="9.34.2" HELPID=""IllustrationLBL="9-21" FILE="menuanat.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-21"Figure 9-21 
A MenuLBL="9.34.3" HELPID=""NavigationMenus follow the navigation model described in IDREF="31210" TYPE="TITLE"Chapter 3, "Navigation."LBL="9.34.4" HELPID=""Other OperationsThe following text describes the operations of this component: <Help> Must provide any available help for the Menu.  LBL="9.34.5" HELPID=""Related InformationFor more information, see the reference pages in IDREF="12408" TYPE="TITLE"Section 9.6, "CascadeButton,"IDREF="27187" TYPE="TITLE"Section 9.38, "OptionButton,"
 and IDREF="34153" TYPE="TITLE"Section 9.33, "MenuBar."LBL="9.35" HELPID=""ID="23864"MessageDialogsLBL="9.35.1" HELPID=""DescriptionID="ch09205"ID="ch09206"ID="ch09207"ID="ch09208"ID="ch09209"ID="ch09210"MessageDialogs should be used to convey a message to the user.  They must not interrupt the user's interaction with the application.  They should include a message and one of the following button arrangements: OKOK HelpOK CancelOK Cancel HelpYes NoYes No HelpYes No CancelYes No Cancel HelpCancelCancel HelpRetry CancelRetry Cancel HelpThere are a number of different types of MessageDialogs: ErrorDialog, InformationDialog, QuestionDialog, WorkingDialog, and WarningDialog.  LBL="9.35.2" HELPID=""Related InformationFor more information, see the reference pages in IDREF="17953" TYPE="TITLE"Section 9.12, "DialogBox,"IDREF="35612" TYPE="TITLE"Section 9.15, "ErrorDialog,"IDREF="28265" TYPE="TITLE"Section 9.27, "InformationDialog,"IDREF="15041" TYPE="TITLE"Section 9.46, "QuestionDialog,"IDREF="14357" TYPE="TITLE"Section 9.62, "WorkingDialog,"
 and IDREF="21595" TYPE="TITLE"Section 9.60, "WarningDialog."LBL="9.36" HELPID=""MnemonicsLBL="9.36.1" HELPID=""DescriptionID="ch09211"A mnemonic is a single character that can be associated with any component that contains a text label.  The label must contain the character, and the character must be underlined within the label.  The mnemonic should be the first character of the label.  If a label does not naturally contain the character of the mnemonic, the mnemonic must be placed in parentheses following the label.  Labels can also be sequentially numbered, and the number can serve as the mnemonic.  Labels that are duplicated within an application should be given the same mnemonic.  Mnemonics must be case insensitive for activation.  Either an uppercase or lowercase letter can be underlined in the label.  When the location cursor is within a Menu, or a MenuBar, typing the mnemonic character of a component within that Menu or MenuBar must move the location cursor to the component and activate it.  If a mnemonic is used for an OptionButton or for a CascadeButton in a MenuBar, pressing <Alt> and the mnemonic anywhere in the window or its Menus must move the cursor to the component with that mnemonic and must activate it.  Collections can also support mnemonics associated with its elements.  Pressing a mnemonic key while the collection has the keyboard focus must be equivalent to moving the location cursor to the element and pressing <Select> or <Space>.LBL="9.37" HELPID=""NavigationLBL="9.37.1" HELPID=""DescriptionID="ch09212"ID="ch09213"Using a mouse, navigation is a simple matter of moving the mouse pointer.  Using the keyboard, the following component navigation actions must be available: <Tab> or <Ctrl> <Tab> <Tab> (if not used for internal navigation) and <Ctrl> <Tab> must move the location cursor forward through fields.  If the next field is a control, <Tab> (if not used for internal navigation) and <Ctrl> <Tab> must move the location cursor to that control.  If the next field is a group, <Tab> (if not used for internal navigation) and <Ctrl> <Tab> must move the location cursor to a traversable component within the group.  If the field contains a button that currently shows default highlighting, the location cursor should be placed on that button; otherwise, the first control in the field (the top-leftmost one in a left-to-right language environment) should get focus.  If the next field contains no traversable components, <Tab> (if not used for internal navigation) and <Ctrl> <Tab> must skip the field.  <Shift> <Tab> or <Ctrl> <Shift> <Tab> <Shift> <Tab> (if not used for internal navigation) and <Ctrl> <Shift> <Tab> must move the location cursor backward through fields in the order opposite to that of <Tab> (if not used for internal navigation) and <Ctrl> <Tab>.<Down arrow> When used for component navigation within a field, in a left-to-right language environment, <Down arrow> must move the location cursor through all traversable controls in the field, starting at the upper left and ending at the lower right, then wrapping to the upper left.  If the controls are aligned in a matrix-like arrangement, <Down arrow> must first traverse one column from top to bottom, then traverse the column to its right, and so on.  In a right-to-left language environment, <Down arrow> must move the location cursor through all traversable controls, starting at the upper right and ending at the lower left.  This key can also be used for internal purposes within a component.  <Up arrow> When used for component navigation within a field, <Up arrow> must move the location cursor through all traversable components or elements in the order opposite to that of <Down arrow>.This key can also be used for internal purposes within a component.  <Right arrow> When used for component navigation within a field, in a left-to-right language environment, <Right arrow> must move the location cursor through all traversable controls in the field, starting at the upper left and ending at the lower right, then wrapping to the upper left.  If the controls are aligned in a matrix-like arrangement, <Right arrow> must first traverse one row from left to right, then traverse the row below it, and so on.  In a right-to-left language environment, <Right arrow> must move the location cursor through all traversable controls, starting at the lower left and ending at the upper right.  This key can also be used for internal purposes within a component.  <Left arrow> When used for component navigation within a field, <Left arrow> must move the location cursor through all traversable components or elements in the order opposite to that of <Right arrow>.This key can also be used for internal purposes within a component.  <Ctrl> <Down arrow> This key can be used for component navigation within a field, following the same rules as <Down arrow>.It can also be used for internal purposes within a component.  When <Down arrow> causes a change that is based on some unit, <Ctrl> <Down arrow> can cause a change based on a larger unit.  <Ctrl> <Up arrow> This key can be used for component navigation within a field, following the same rules as <Up arrow>.It can also be used for internal purposes within a component.  When <Up arrow> causes a change that is based on some unit, <Ctrl> <Up arrow> can cause a change based on a larger unit.  <Ctrl> <Right arrow> This key can be used for component navigation within a field, following the same rules as <Right arrow>.It can also be used for internal purposes within a component.  When <Right arrow> causes a change that is based on some unit, <Ctrl> <Right arrow> can cause a change based on a larger unit.  <Ctrl> <Left arrow> This key can be used for component navigation within a field, following the same rules as <Left arrow>.It can also be used for internal purposes within a component.  When <Left arrow> causes a change that is based on some unit, <Ctrl> <Left arrow> can cause a change based on a larger unit.  <Begin> If a control uses <Right arrow> and <Left arrow> for internal navigation, <Begin> must behave as follows: In a left-to-right language environment, this action must move the location cursor to the leftmost edge of the data or the leftmost element.  In a right-to-left language environment, this action must move the location cursor to the rightmost edge of the data or the rightmost element.  In a group that is a field, this key can move the location cursor to an appropriate control within the group.  <End> If a control uses <Right arrow> and <Left arrow> for internal navigation, <End> must behave as follows: In a left-to-right language environment, this action must move the location cursor to the rightmost edge of the data or the rightmost element.  In a right-to-left language environment, this action must move the location cursor to the leftmost edge of the data or the leftmost element.  In a group that is a field, this key can move the location cursor to an appropriate control within the group.  <Ctrl> <Begin> If a control uses <Up arrow> and <Down arrow> for internal navigation, <Ctrl> <Begin> must move the location cursor to one of the following: The first element The topmost edge of the data In a left-to-right language environment, the topmost left edge of the data; in a right-to-left language environment, the topmost right edge of the data In a group that is a field, this key can move the location cursor to an appropriate control within the group.  <Ctrl> <End> If a control uses <Up arrow> and <Down arrow> for internal navigation, <Ctrl> <End> must move the location cursor to one of the following: The last element The bottommost edge of the data In a left-to-right language environment, the bottommost right edge of the data; in a right-to-left language environment, the bottommost left edge of the data In a group that is a field, this key can move the location cursor to an appropriate control within the group.  <PageDown> In a vertically scrollable component, <PageDown> must scroll the visible region down by one page increment.  <PageUp> In a vertically scrollable component, <PageUp> must scroll the visible region up by one page increment.  <PageRight> or <Ctrl> <PageDown> In a horizontally scrollable component, <PageRight> or <Ctrl> <PageDown> must scroll the visible region to the right by one page increment.  <PageLeft> or <Ctrl> <PageUp> In a horizontally scrollable component, <PageLeft> or <Ctrl> <PageUp> must scroll the visible region to the left by one page increment.  <F10> If the MenuBar is inactive, <F10> must traverse to the MenuBar system.  The location cursor must be placed on the first traversable CascadeButton in the MenuBar.  If there are no traversable CascadeButtons in the MenuBar, <F10> must do nothing.  If the MenuBar system is active, <F10> should unpost all Menus in the MenuBar system.  If <F10> is used to unpost all Menus in the MenuBar system and if the focus policy is explicit, the location cursor must be moved back to the component that had it before the Menu system was posted.  <Shift> <Menu> must replace <F10> if <F10> is not available.  <Menu> If the keyboard focus is on an element with an inactive Popup Menu and the context of the element allows a Popup Menu to be displayed, ID="ch09214"ID="ch09215"<Menu> must post (activate) the Popup Menu.  The location cursor must be placed on the default item of the Menu, or the first traversable item if there is no default item.  Note that the availability of the Popup Menu can depend on the location of the cursor within the element, the contents of the element, or the selection state of the element.  If there are no traversable items in the Popup Menu, it is up to the system and the application whether to post the Menu or not.  If there is an active Popup Menu, <Menu> should unpost all Menus in the Popup Menu system.  If <Menu> is used to unpost all Menus in the Popup Menu system and if the focus policy is explicit, the location cursor must be moved back to the component that had it before the Menu system was posted.  <Shift> <F10> must replace <Menu> if <Menu> is not available.  <Alt> <F6> Must move the focus to the next window in the window family.  ID="ch09216"<Alt> <Shift> <F6> Can move the focus to the previous window in the window family.  ID="ch09217"ID="ch09218"<Alt> <Tab> Must move the focus to the last window that had the input focus in the next window family in the window hierarchy.  ID="ch09219"<Alt> <Shift> <Tab> Can move the focus to the previous window that had the input focus in the next window family in the window hierarchy.  ID="ch09220"ID="ch09221"ID="ch09222"LBL="9.37.2" HELPID=""Related InformationSee IDREF="31210" TYPE="TITLE"Chapter 3, "Navigation"
 for more information about internal window navigation.  See IDREF="24491" TYPE="TITLE"Chapter 7, "Window Manager Design Principles"
 for more information about navigation among windows.  LBL="9.38" HELPID=""ID="27187"OptionButtonLBL="9.38.1" HELPID=""DescriptionID="ch09223"ID="ch09224"ID="ch09225"An OptionButton should be used to post an Option Menu.  This component must be composed of a button, with either a text or graphics Label.  Following the Label, this component should also include a bar graphic to distinguish it from a PushButton.  The Label must be the last selection made from the OptionButton.  LBL="9.38.2" HELPID=""IllustrationLBL="9-22" FILE="optionb.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-22"Figure 9-22 
An OptionButtonLBL="9.38.3" HELPID=""NavigationAn OptionButton must have no internal navigation.  LBL="9.38.4" HELPID=""Other OperationsThe following text describes the operations of this component: BSelect Press Must post the associated Option Menu.  BSelect Release If the release is within the same OptionButton as the press: If the associated Option Menu was posted at the time of the press, it should be unposted.  If the associated Option Menu was not posted at the time of the press, it must be posted.  If the release is outside of the OptionButton, the associated Option Menu must be unposted.  <Select> or <Space> Must post the associated Option Menu.  <Cancel> Must unpost the last posted Menu in the Menu system without changing the value of the OptionButton.  <Help> Must provide any available help for the OptionButton.  LBL="9.38.5" HELPID=""Related InformationFor more information, see the reference page in IDREF="34167" TYPE="TITLE"Section 9.34, "Menus."LBL="9.39" HELPID=""ID="22363"PanedWindowLBL="9.39.1" HELPID=""DescriptionID="ch09226"ID="ch09227"ID="ch09228"ID="ch09229"A PanedWindow should be used to group components into Panes separated by Sashes and Separators for adjusting the relative size of each Pane.  This component must be composed of any number of groups of components, called Panes, each separated by a Sash and a Separator.  The Panes, Sashes, and Separators must be grouped linearly, either horizontally or vertically.  A Sash must be composed of a handle on the Separator between two Panes for adjusting the position of the Separator, and therefore the size of the Panes next to it.  As a Sash is moved, the Pane in the direction of the Sash movement must get smaller and the other Pane must get larger by an equal amount.  If a Pane is adjusted to its minimum size, adjustment should continue with the next Pane in the direction of the Sash movement.  LBL="9.39.2" HELPID=""IllustrationLBL="9-23" FILE="panedw2.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-23"Figure 9-23 
A PanedWindowLBL="9.39.3" HELPID=""NavigationThis component must follow the navigation model described in IDREF="31210" TYPE="TITLE"Chapter 3, "Navigation."LBL="9.39.4" HELPID=""Related InformationFor information about activating a Sash, see the reference page for Sash.  LBL="9.40" HELPID=""PanelLBL="9.40.1" HELPID=""DescriptionID="ch09230"A Panel group should be used to organize a collection of basic controls in a horizontal, vertical, or 2-dimensional layout.  This component is usually composed of just one type of basic control.  This component is composed of an area for organizing basic controls.  LBL="9.40.2" HELPID=""IllustrationLBL="9-24" FILE="radiobts.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-24"Figure 9-24 
A PanelLBL="9.40.3" HELPID=""NavigationThe <Down arrow>,<Left arrow>,<Right arrow>,and <Up arrow> direction keys must navigate among components in the Panel according to the navigation model described in IDREF="31210" TYPE="TITLE"Chapter 3, "Navigation."LBL="9.41" HELPID=""Pointer ShapesLBL="9.41.1" HELPID=""DescriptionID="ch09231"ID="ch09232"ID="ch09233"ID="ch09234"You should not create new mouse pointer shapes for functions that already have mouse pointer shapes associated with them, except for localization; however, you can create new mouse pointer shapes for functions not already associated with a pointer shape.  You should not use a predefined shape to symbolize a function it was not designed to represent.  ID="ch09235"A list of the defined pointer shapes follows, along with their usage and hotspots.  The hotspot of a pointer is the actual position on the pointer that tracks the movements of the mouse.  As the pointer changes from one shape to another, the location of the hotspot must not move on the screen.  The hotspot is the precise location on the pointer where mouse actions occur.  LBL="9-25" FILE="arrowp.gif" POSITION="INLINE" SCALE="FALSE"ID="ch09236"ID="ch09237"LBL="9-25"Figure 9-25 
The upper-left pointing arrowThe upper-left pointing arrow pointer is a general-purpose pointer.  It is used in most window areas for single-object selection and activation.  The hotspot for the arrow pointer should be in the point of the arrow.  LBL="9-26" FILE="ibeamp.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-26"Figure 9-26 
The I-beam pointerYou can optionally use an I-beam pointer in any Text component.  It is used to change the location of the text insertion cursor and to perform actions on text.  If the I-beam is used, it can be hidden during the time between any keyboard action and a mouse movement.  This helps the user distinguish the I-beam pointer from the text insertion cursor, which can also be an I-beam.  The hotspot for the I-beam pointer should be on the vertical bar of the I-beam about one-third up from the bottom.  ID="ch09238"ID="ch09239"LBL="9-27" FILE="xp.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-27"Figure 9-27 
The X pointer The X pointer can indicate when the pointer is outside of any application area.  The hotspot for the X pointer should be where the lines intersect.  ID="ch09240"ID="ch09241"LBL="9-28" FILE="8sizep.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-28"Figure 9-28 
The resize pointersThe resize pointers indicate positions for area resize, and they remain during a resize operation.  The direction of the arrow in the pointer indicates the direction of increasing size.  The horizontal and vertical pointers indicate resize in either the horizontal or vertical direction.  The diagonal pointers indicate resize in both the horizontal and vertical directions simultaneously.  The hotspot for the resizing pointers should be on the elbow or the line at the position pointed to by the arrow.  LBL="9-29" FILE="hourglas.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-29"Figure 9-29 
The hourglass pointerThe hourglass pointer, a working pointer, indicates that an action is in progress in the area, and that the pointer has no effect in the area.  While the hourglass pointer is active, all mouse button and keyboard events are ignored in the area.  The hotspot for the hourglass pointer should be located at the center of the hourglass, although it should not be used for activation.  The hourglass pointer can be used interchangeably with the watch pointer.  LBL="9-30" FILE="watchp.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-30"Figure 9-30 
The watch pointerThe watch pointer, a working pointer, indicates that an action is in progress in the area, and that the pointer has no effect in the area.  While the watch pointer is active, all mouse button and keyboard events are ignored in the area.  The hotspot for the watch pointer should be located at the top of the watch, although it should not be used for activation.  The watch pointer can be used interchangeably with the hourglass pointer.  LBL="9-31" FILE="movingp.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-31"Figure 9-31 
The 4-directional arrow pointer The 4-directional arrow pointer indicates a move operation is in progress, or a resize operation before the resize direction has been determined.  During a move operation, the object, or an outline of the object should move to track the location of the pointer.  During a resize operation, the pointer is used to indicate a direction for resizing.  The 4-directional arrow pointer should change to the appropriate resize arrow when the resize direction is determined, either by crossing an object boundary with the pointer or by pressing a keyboard direction key.  The hotspot for the 4-directional arrow pointer should be at the spot where the arrows intersect.  ID="ch09242"ID="ch09243"ID="ch09244"LBL="9-32" FILE="sightp.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-32"Figure 9-32 
The sighting ponterThe sighting pointer is used to make fine position selections.  For example, in a drawing program it can be used to indicate a pixel to fill or the connecting points of lines.  The hotspot for the sighting pointer should be at the spot where the lines intersect.  ID="ch09245"ID="ch09246"LBL="9-33" FILE="cautionp.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-33"Figure 9-33 
The caution pointerThe caution pointer is used to indicate that action is expected in another area before input can be given to the current area, and that the pointer has no effect in the area.  While the caution pointer is active, all mouse button and keyboard events are ignored in the area.  The hotspot for the caution pointer should be located at the center of the caution symbol, although it should not be used for activation.  LBL="9-34" FILE="questp.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-34"Figure 9-34 
The question pointerThe question pointer is used to request an input position or component from the user.  This is often used to input an object for interactive help.  The user requests interactive help, then the question pointer is displayed to allow the user to indicate what position or component help is requested for.  The hotspot for the question pointer should be at the bottom of the question mark.  LBL="9-35" FILE="menuarro.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-35"Figure 9-35 
The upper-right arrow pointer You can optionally use an arrow pointing to the upper-right corner to indicate a pending Menu action.  This shape indicates that a Menu is popped up or pulled down and waiting for a Menu item to be activated or the Menu to be removed.  The hotspot for this arrow pointer should be in the point of the arrow.  ID="ch09247"LBL="9.41.2" HELPID=""Related InformationSee IDREF="16621" TYPE="TITLE"Chapter 2, "Input Models"
 for information on the input device model and designing new pointer shapes.  LBL="9.42" HELPID=""Popup MenusLBL="9.42.1" HELPID=""DescriptionID="ch09248"ID="ch09249"The common Popup Menu contents are described as follows.  Note that you should only include those functions actually supported by your application.  The illustration on this reference page shows a Popup Menu.  PropertiesMust display a properties DialogBox that the user can use to set the properties of the component.  If the Menu is popped up over a selection, it can display the properties of the selection.  If the Menu is popped up over an unselected item, it can display the properties of that item.  If the Menu is popped up over the background, it should display the properties of the collection, except over a part of the background considered to be in the selection.  This action should have the mnemonic ID="ch09250"S.  Undo   Alt+Backspace Must reverse the most recently executed action.  To provide a visual cue to the user, the ID="ch09251"Undo selection title should be dynamically modified to indicate what is being undone.  For example, if the most recently executed action was a paste, the action name would be Undo paste.  This action should have the mnemonic U.  This action should have the same  accelerator as the corresponding entry in the Edit Menu.  Primary Move   Alt+Shift+DeleteMust move the contents of the primary selection to the component.  This action must only be used in an editable component.  If the action uses an accelerator, it should be ID="ch09252"<Alt> <Shift> <Delete>,<Alt> <Ctrl> <X>,or both.  In addition, if the keyboard has a <Cut> key, this action should support <Alt> <Cut> as an accelerator.  If more than one format can be moved from the primary selection, Primary Copy can cascade a Menu of possible transfer formats, in which case it should not have an accelerator.  Primary Copy   Alt+Ctrl+InsertMust copy the contents of the primary selection to the component.  This action must only be used in an editable component.  If the action uses an accelerator, it should be ID="ch09253"<Alt> <Ctrl> <Insert>,<Alt> <Ctrl> <C>,or both.  In addition, if the keyboard has a <Copy> key, this action should support <Alt> <Copy> as an accelerator.  If more than one format can be copied from the primary selection, Primary Copy can cascade a Menu of possible transfer formats, in which case it should not have an accelerator.  Primary LinkMust place a link to the primary selection in the component.  This action must only be used in an editable component.  If the link can be viewed in more than one way, ID="ch09254"Primary Link can cascade a Menu of possible viewing representations.  CutMust cut elements to the clipboard and can mark them for use in a subsequent ID="ch09255"Paste Link operation.  If the Menu is popped up in a selection, the entire selection must be cut.  If the Menu is popped up over an unselected element, just that element should be cut.  If the Menu is popped up in the background, the entire collection can be cut.  This action should have the mnemonic T.  CopyMust copy elements to the clipboard and can mark them for use in a subsequent ID="ch09256"Paste Link operation.  If the Menu is popped up in a selection, the entire selection must be copied.  If the Menu is popped up over an unselected element, just that element should be copied.  If the Menu is popped up in the background, the entire collection can be copied.  This action should have the mnemonic C.  Copy LinkMust copy a link of elements to the clipboard and can mark them for use in a subsequent ID="ch09257"Paste Link operation.  If the Menu is popped up in a selection, a link to the entire selection must be copied.  If the Menu is popped up over an unselected element, a link to just that element should be copied.  If the Menu is popped up in the background, a link to the entire collection can be copied.  This action should have the mnemonic K.  Paste   Shift+Insert Must paste the contents of the clipboard to the component.  This action must only be used in an editable component.  This action should have the mnemonic ID="ch09258"P.  This action should have the same accelerator as the corresponding entry in the Edit Menu.  Paste LinkMust paste a link of the contents of the clipboard to the component.  This action must only be used in an editable component.  This action should have the mnemonic ID="ch09259"L.  ClearMust remove a selected portion of data from the client area without copying it to the clipboard.  If the Menu is popped up in a selection, it must delete the selection.  If the Menu is popped up over an unselected element, it should delete that element.  If the Menu is popped up over the background, except over a part of the background considered to be in the selection, it can delete all the elements.  The remaining data is not compressed to fill the space that was occupied by the cleared data.  This action should have the mnemonic ID="ch09260"E.  DeleteMust remove a selected portion of data from the client area without copying it to the clipboard.  If the Menu is popped up in a selection, it must delete the selection.  If the Menu is popped up over an unselected element, it should delete that element.  If the Menu is popped up over the background, except over a part of the background considered to be in the selection, it can delete all the elements.  This action should have the mnemonic ID="ch09261"D.  Select All   Ctrl+/ Must make the primary selection consist of all the elements in the collection with the Popup Menu.  If the action uses an accelerator, it should be ID="ch09262"<Ctrl> </>.Deselect All   Ctrl+\ Must deselect the current selection in the collection with the Popup Menu.  If the action uses an accelerator, it should be ID="ch09263"<Ctrl> <\>.Select PastedMust make the primary selection consist of the last element or elements pasted into the collection with the Popup Menu.  ID="ch09264"Reselect   Alt+Insert Must make the primary selection consist of the last selected element or elements in the component with the Popup Menu.  The action must be available only in components that do not support persistent selections and only when the current selection is empty.  If the action uses an accelerator, it should be ID="ch09265"<Alt> <Insert>.Promote   Alt+Insert Must promote the current selection to the primary selection.  This action must only be available in components that support persistent selections.  If the action uses an accelerator, it should be ID="ch09266"<Alt> <Insert>.Appropriate words, such as Selection or words denoting the type of a single element of the collection as a whole, should be added to a Label to specify which elements are affected.  For example, if a Popup Menu contains the entry Copy Selection, the current selection is copied to the clipboard regardless of where in the collection the Menu is popped up.  A Popup Menu item should only have an accelerator if the result of typing the accelerator would be equivalent to popping up the Menu by typing <Menu>,and then selecting the Menu item.  If Cut Selection is included in a Popup Menu, it should use the same accelerators as Cut in the Edit Menu.  If Copy Selection is included in a Popup Menu, it should use the same accelerators as Copy in the Edit Menu.  LBL="9.42.2" HELPID=""IllustrationLBL="9-36" FILE="editmenu.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-36"Figure 9-36 
A Popup MenuLBL="9.42.3" HELPID=""Related InformationSee IDREF="20011" TYPE="TITLE"Chapter 6, "Application Design Principles"
 for more information on Popup Menus and for general information about Menu design.  LBL="9.43" HELPID=""Primary SelectionLBL="9.43.1" HELPID=""DescriptionID="ch09267"ID="ch09268"ID="ch09269"Each collection maintains its own selection.  A selection need not contain any elements, in which case it is said to be an empty selection.  At any time, there is one selection called the primary selection, which is the last selection explicitly started by the user.  Clicking BSelect or <Ctrl> BSelect only moves the primary selection to a collection when it results in making a selection that is not empty.  When <Shift> BSelect is clicked, an implementation can move the primary selection to the component even if the resulting selection is empty.  Dragging BSelect, <Shift> BSelect, or <Ctrl> BSelect must move the primary selection to the component if a button release during the pointer motion could have potentially selected any element.  A selection is said to be persistent if it is highlighted even when it is not the primary selection.  Persistent There are two variants of persistent selections: persistent always, in which the current selection is always highlighted, and persistent on focus, in which the current selection is only highlighted when it is the primary selection or when the collection has the keyboard focus.  In either case, stronger highlighting should be used when the current selection is also the primary selection.  When focus is in the collection, <Alt> <Insert> can be used to promote the current selection to the primary selection.  Nonpersistent The collection only highlights a primary selection.  When the primary selection is lost to another collection, the current selection is set to empty.  When focus is in the collection, and it does not have the primary selection, <Alt> <Insert> can be used to restore the previous selection and make it the primary selection.  Collections that are never editable (such as noneditable Lists) should always use persistent selections.  Collections that are editable can either use persistent or nonpersistent selections.  ID="ch09270"ID="ch09271"ID="ch09272"ID="ch09273"Primary transfer can be invoked by clicking BTransfer or through standard keyboard bindings.  There are three primary transfer operations: Primary Copy In an editable collection, ID="ch09274"ID="ch09275"ID="ch09276"BTransfer Click, <Ctrl> BTransfer Click, <Alt> <Copy>,and <Alt> <Ctrl> <Insert> must copy the primary selection to the insertion position, as defined in IDREF="21864" TYPE="TITLE"Section 4.3, "Transfer Models."
  (Note that the insertion position is usually different for mouse and keyboard operations.) Primary Move In an editable collection, ID="ch09277"ID="ch09278"ID="ch09279"<Shift> BTransfer Click, <Alt> <Cut>,and <Alt> <Shift> <Delete> must move the primary selection to the insertion position, as defined in IDREF="21864" TYPE="TITLE"Section 4.3, "Transfer Models."
  (Note that the insertion position is usually different for mouse and keyboard operations.) Primary Link In an editable collection, ID="ch09280"ID="ch09281"ID="ch09282"<Ctrl> <Shift> BTransfer Click must place a link to the primary selection at the insertion position, as defined in IDREF="21864" TYPE="TITLE"Section 4.3, "Transfer Models."LBL="9.43.2" HELPID=""Related InformationSee IDREF="21835" TYPE="TITLE"Section 4.2, "Selection Actions"
 and IDREF="21864" TYPE="TITLE"Section 4.3, "Transfer Models"
 for more information about the primary selection.  LBL="9.44" HELPID=""ID="16087"PromptDialogLBL="9.44.1" HELPID=""DescriptionID="ch09283"ID="ch09284"A PrompDialog should be used to prompt the user for input.  It can interrupt the user's interaction with the application.  It should include a message, a text input area, and one of the following button arrangements: OK CancelOK Cancel HelpOK Apply CancelOK Apply Cancel HelpOK Apply Reset CancelOK Apply Reset Cancel HelpLBL="9.44.2" HELPID=""IllustrationLBL="9-37" FILE="promptbo.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-37"Figure 9-37 
A PromptDialogLBL="9.44.3" HELPID=""Related InformationFor more information, see the reference page in IDREF="17953" TYPE="TITLE"Section 9.12, "DialogBox."LBL="9.45" HELPID=""PushButtonLBL="9.45.1" HELPID=""DescriptionID="ch09285"A PushButton should be used to start an operation.  A PushButton must contain either a text or graphic Label that indicates the operation of the button.  LBL="9.45.2" HELPID=""IllustrationLBL="9-38" FILE="pushbtn.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-38"Figure 9-38 
A PushButtonLBL="9.45.3" HELPID=""NavigationA PushButton must have no internal navigation.  LBL="9.45.4" HELPID=""Other OperationsThe following text describes the operations of this component: BSelect Press Must arm the PushButton.  BSelect Release If the release is within the same PushButton as the press, BSelect Release must disarm the PushButton and activate it.  If the release is outside of the PushButton, BSelect Release must disarm the PushButton without activating it.  <Enter> or <Return> If the PushButton is in a window with a default action, the PushButton must be activated.  If the PushButton is in a Menu, this action must activate the PushButton and unpost the Menu.  <Select> or <Space> Must activate the PushButton.  If the PushButton is in a Menu, the Menu must be unposted.  <Help> Must provide any available help for the PushButton.  LBL="9.46" HELPID=""ID="15041"QuestionDialogLBL="9.46.1" HELPID=""DescriptionID="ch09286"ID="ch09287"A QuestionDialog should be used to get a user response to a question.  It should interrupt the user's interaction with the application.  It should include a question symbol, a message, and one of the following button arrangements: Yes NoYes No HelpIt is possible that both the Yes and No actions of a Question DialogBox will perform an action.  If this is the case, the Question DialogBox should use one of the following button arrangements: Yes No CancelYes No Cancel HelpLBL="9.46.2" HELPID=""IllustrationLBL="9-39" FILE="questbox.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-39"Figure 9-39 
A QuestionDialogLBL="9.46.3" HELPID=""Related InformationFor more information, see the reference page in IDREF="17953" TYPE="TITLE"Section 9.12, "DialogBox."LBL="9.47" HELPID=""Quick TransferLBL="9.47.1" HELPID=""DescriptionID="ch09288"ID="ch09289"ID="ch09290"Quick transfer is used to make a temporary (or secondary) selection and then immediately copy, move, or link that selection to the insertion position of the destination component.  Quick transfer is implemented using <Alt> BTransfer Motion, with the standard modifiers used to force the various transfer operations.  Text components must support quick transfer.  There are three quick transfer operations: Quick Copy If a component supports quick transfer, ID="ch09291"ID="ch09292"ID="ch09293"<Alt> BTransfer Motion or <Alt> <Ctrl> BTransfer Motion must temporarily select elements in the specified range and, on release, must copy them to the insertion position of the destination component.  Quick Cut If a component supports quick transfer, ID="ch09294"ID="ch09295"ID="ch09296"<Alt> <Shift> BTransfer Motion must temporarily select elements in the specified range and, on release, must move them to the insertion position of the destination component.  Quick Link If a component supports quick transfer, ID="ch09297"ID="ch09298"ID="ch09299"<Alt> <Ctrl> <Shift> BTransfer Motion must temporarily select elements in the specified range and, on release, must place a link to them at the insertion position of the destination component.  The range of the temporary selection must be determined by using exactly the same model used when BSelect Motion determines the range of a primary selection.  LBL="9.47.2" HELPID=""Related InformationIDREF="21864" TYPE="TITLE"Section 4.3, "Transfer Models" for more information about quick transfer.  LBL="9.48" HELPID=""ID="39382"RadioButtonLBL="9.48.1" HELPID=""DescriptionID="ch09300"ID="ch09301"A RadioButton should be used to select one option from a number of options.  A RadioButton is a special case of a ToggleButton.  Only one RadioButton can be set at a time.  This component must be composed of a text or graphic label, and a graphic that indicates the state of the RadioButton.  The graphic indicator for a RadioButton is usually a filled diamond or circle to indicate the on state or an empty diamond or circle to indicate the off state.  On color systems, the on state color can be distinct from general application colors to visually distinguish the on state.  LBL="9.48.2" HELPID=""IllustrationLBL="9-40" FILE="single.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-40"Figure 9-40 
A RadioButtonLBL="9.48.3" HELPID=""NavigationRadioButtons must have no internal navigation.  LBL="9.48.4" HELPID=""Other OperationsThe following text describes the operations of this component: BSelect Press Must arm the RadioButton.  If the RadioButton was previously unset, it must show the RadioButton in the set state.  BSelect Release If the release happens in the same RadioButton that the press occurred in and if the RadioButton was previously unset, it must be set, and any other RadioButton in the same Panel that was previously set must be unset.  The RadioButton must be disarmed, and, if the RadioButton is in a Menu, the Menu must be unposted.  BSelect Release 2 If the RadioButton was previously unset, it should be set, and any other RadioButton in the same Panel that was previously set should be unset.  If the RadioButton is in a window, the default action of the window should be activated.  <Enter> or <Return> If the RadioButton is in a window with a default action, the default action must be activated.  If the RadioButton is in a Menu: If the RadioButton was previously unset, it must be set, and any other RadioButton in the same Panel that was previously set must be unset.  The RadioButton must be disarmed, and the Menu must be unposted.  <Select> or <Space> If the RadioButton was previously unset, it must be set, and any other RadioButton in the same Panel that was previously set must be unset.  The RadioButton must be disarmed, and, if the RadioButton is in a Menu, the Menu must be unposted.  <Help> Must provide any available help for the RadioButton.  LBL="9.48.5" HELPID=""Related InformationFor more information, see the reference pages in IDREF="34612" TYPE="TITLE"Section 9.7, "CheckButton"
 and IDREF="15890" TYPE="TITLE"Section 9.59, "ToggleButton."LBL="9.49" HELPID=""SashLBL="9.49.1" HELPID=""DescriptionID="ch09302"ID="ch09303"ID="ch09304"A Sash should be used to adjust the border between groups of components in a PanedWindow.  A Sash must be composed of a handle on the Separator between two Panes for adjusting the position of the Separator, and therefore the size of the Panes next to it.  As a Sash is moved, the Pane in the direction of the Sash movement must get smaller and the other Pane must get larger by an equal amount.  If a Pane is adjusted to its minimum size, adjustment should continue with the next Pane in the direction of the Sash movement.  The PanedWindow can optionally support movement of the Pane in the initial direction of mouse movement with the modifier <Shift> on button events, rather than resizing the Pane.  LBL="9.49.2" HELPID=""IllustrationLBL="9-41" FILE="panedw2.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-41"Figure 9-41 
A SashLBL="9.49.3" HELPID=""NavigationA Sash must have no internal navigation.  LBL="9.49.4" HELPID=""Other OperationsThe following text describes the operations of this component: BSelect or BTransfer Motion Must cause the Sash to track the movement of the pointer.  In a vertically oriented PanedWindow, the Sash must track the vertical position of the pointer.  In a horizontally oriented PanedWindow, the Sash must track the horizontal position of the pointer.  BSelect or BTransfer Motion Can cause the Pane in the initial direction of movement to track the movement of the pointer.  In a vertically oriented PanedWindow, the Pane must track the vertical position of the pointer.  In a horizontally oriented PanedWindow, the Pane must track the horizontal position of the pointer.  <Up arrow> and <Down arrow> For a Sash that can move vertically, must cause the Sash to move in the specified direction one increment.  <Right arrow> and <Left arrow> For a Sash that can move horizontally, must cause the Sash to move in the specified direction one increment.  <Shift> <Up arrow> and <Shift> <Down arrow> For a Sash that can move vertically, can cause the Pane in the initial direction to move one increment in the specified direction.  <Shift> <Right arrow> and <Shift> <Left arrow> For a Sash that can move horizontally, can cause the Pane in the initial direction to move one increment in the specified direction.  <Ctrl> <Up arrow> and <Ctrl> <Down arrow> For a Sash that can move vertically, must cause the Sash to move in the specified direction one large increment.  <Ctrl> <Right arrow> and <Ctrl> <Left arrow> For a Sash that can move horizontally, must cause the Sash to move in the specified direction one large increment.  <Ctrl> <Shift> <Up arrow> and <Ctrl> <Shift> <Down arrow> For a Sash that can move vertically, can cause the Pane in the initial direction to move one large increment in the specified direction.  <Ctrl> <Shift> <Right arrow> and <Ctrl> <Shift> <Left arrow> For a Sash that can move horizontally, can cause the Pane in the initial direction to move one large increment in the specified direction.  <Help> Must provide any available help for the Sash.  LBL="9.49.5" HELPID=""Related InformationFor more information, see the reference page in IDREF="22363" TYPE="TITLE"Section 9.39, "PanedWindow."LBL="9.50" HELPID=""ScaleLBL="9.50.1" HELPID=""DescriptionID="ch09305"A Scale should be used to select a value from a range.  This component should be composed of a slider, moving within an element that indicates the size of the range, called the trough, and a Label that indicates the current value.  The position of the slider indicates the value relative to the range.  A Scale can also have buttons with arrow graphics for moving the slider.  LBL="9.50.2" HELPID=""IllustrationLBL="9-42" FILE="scale.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-42"Figure 9-42 
A ScaleLBL="9.50.3" HELPID=""Other OperationsThe following text describes the operations of this component: BSelect Press In an arrow button, this action must move the slider one increment in the direction of the side of the slider on which the button was pressed, and autorepeat until the button is released.  In the trough, if the Scale has tick marks, BSelect Press must move the slider one major tick mark in the direction of the side of the slider on which the trough was pressed, and autorepeat until the button is released.  It can stop when the slider reaches the position of the pointer.  If the Scale does not have tick marks, BSelect Press in the trough must move the slider one large increment in the direction of the side of the slider on which the trough was pressed, and autorepeat until the button is released.  It can stop when the slider reaches the position of the pointer.  BSelect Motion If the button is pressed in the slider, must cause the slider to track the position of the pointer.  In a vertical Scale, the slider must track the vertical position of the pointer.  In a horizontal Scale, the slider must track the horizontal position of the pointer.  <Ctrl> BSelect Press In the slider trough or an arrow button, this action should move the slider to the end of the Scale on which the button was pressed.  BTransfer Press In the trough, this action should directly position the slider to the position of the button press.  BTransfer Motion If the button is pressed in the slider or the trough, must directly position the slider to the point of the button press and then cause the slider to track the position of the pointer.  In a vertical Scale, the slider must track the vertical position of the pointer.  In a horizontal Scale, the slider must track the horizontal position of the pointer.  <Cancel> If a mouse-based sliding action is in progress, <Cancel> must cancel the sliding action and return the slider to its position prior to the start of the sliding operation.  <Down arrow> For vertical Scales, this action must move the slider one increment down.  <Up arrow> For vertical Scales, this action must move the slider one increment up.  <Left arrow>For horizontal Scales, this action must move the slider one increment left.  <Right arrow> For horizontal Scales, this action must move the slider one increment right.  <Ctrl> <Down arrow> For vertical Scales, this action must move the slider one large increment down.  <Ctrl> <Up arrow> For vertical Scales, this action must move the slider one large increment up.  <Ctrl> <Left arrow> For horizontal Scales, this action must move the slider one large increment left.  <Ctrl> <Right arrow> For horizontal Scales, this action must move the slider one large increment right.  <Begin> or <Ctrl> <Begin> Must move the slider to the minimum value.  <End> or <Ctrl> <End> Must move the slider to the maximum value.  <Help> Must provide any available help for the Scale.  LBL="9.51" HELPID=""ID="31889"ScrollBarLBL="9.51.1" HELPID=""DescriptionID="ch09306"A ScrollBar should be used to scroll the visible area of another component.  A ScrollBar should be composed of a slider, moving within an element that indicates the full size of the scrolled component, and two buttons with arrow graphics for moving the slider.  The slider indicates the relative position and size of the visible area of the scrolled component.  LBL="9.51.2" HELPID=""IllustrationLBL="9-43" FILE="scrollba.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-43"Figure 9-43 
A ScrollBarLBL="9.51.3" HELPID=""Other OperationsThe following text describes the operations of this component: BSelect Press In an arrow button, this action must move the slider one increment in the direction of the side of the slider on which the button was pressed, and autorepeat until the button is released.  In the trough, this action must move the slider one page in the direction of the side of the slider on which the trough was pressed, and autorepeat until the button is released.  It can stop when the slider reaches the position of the pointer.  BSelect Motion If the button is pressed in the slider, must cause the slider to track the position of the pointer.  In a vertical ScrollBar, the slider must track the vertical position of the pointer.  In a horizontal ScrollBar, the slider must track the horizontal position of the pointer.  <Ctrl> BSelect Press In the slider trough or an arrow button, this action should move the slider to the end of the ScrollBar on which the button was pressed.  <Shift> BSelect Press Can scroll the view so that the cursor within that view is positioned at the edge of the view region on the side of the ScrollBar on which the button was pressed.  BTransfer Press In the trough, this action can directly position the slider to the position of the button press.  BTransfer Motion If the button is pressed in the slider or the trough, must directly position the slider to the point of the button press and then cause the slider to track the position of the pointer.  In a vertical ScrollBar, the slider must track the vertical position of the pointer.  In a horizontal ScrollBar, the slider must track the horizontal position of the pointer.  <Cancel> If a mouse-based scrolling action is in progress, <Cancel> must cancel the scrolling action and return the slider to its position prior to the start of the scrolling operation.  <Down arrow> For vertical ScrollBars, this action must move the slider one increment down.  <Up arrow> For vertical ScrollBars, this action must move the slider one increment up.  <Left arrow> For horizontal ScrollBars, this action must move the slider one increment left.  <Right arrow> For horizontal ScrollBars, this action must move the slider one increment right.  <Ctrl> <Down arrow> For vertical ScrollBars, this action must move the slider one large increment down.  <Ctrl> <Up arrow> For vertical ScrollBars, this action must move the slider one large increment up.  <Ctrl> <Left arrow> For horizontal ScrollBars, this action must move the slider one large increment left.  <Ctrl> <Right arrow> For horizontal ScrollBars, this action must move the slider one large increment right.  <PageDown> For vertical ScrollBars, this action must move the slider one page down.  <PageUp> For vertical ScrollBars, this action must move the slider one page up.  <PageLeft> or <Ctrl> <PageUp> For horizontal ScrollBars, this action must move the slider one page left.  <PageRight> or <Ctrl> <PageDown> For horizontal ScrollBars, this action must move the slider one page right.  <Begin> or <Ctrl> <Begin> Must move the slider to the minimum value.  <End> or <Ctrl> <End> Must move the slider to the maximum value.  <Help> Must provide any available help for the ScrollBar.  LBL="9.52" HELPID=""ScrolledWindowLBL="9.52.1" HELPID=""DescriptionID="ch09307"A ScrolledWindow should be used to frame other components and to provide ScrollBars as necessary to scroll the visible area of the framed components.  When the area framed by the ScrolledWindow is completely displayed, the ScrollBars need not be displayed.  When the area provided in the ScrolledWindow is too small to display the entire component area, the ScrollBars must be displayed and must then allow scrolling of the visible area.  LBL="9.52.2" HELPID=""IllustrationLBL="9-44" FILE="scrolled.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-44"Figure 9-44 
A ScrolledWindowLBL="9.52.3" HELPID=""NavigationA ScrolledWindow must follow the navigation model that is described in IDREF="31210" TYPE="TITLE"Chapter 3, "Navigation."LBL="9.52.4" HELPID=""Related InformationFor information about the activation of the ScrollBars, see the reference page for ScrollBar.  For more information about navigation within general scrollable components, see IDREF="29873" TYPE="TITLE"Section 3.4, "Scrollable Component Navigation."LBL="9.53" HELPID=""SelectionLBL="9.53.1" HELPID=""DescriptionID="ch09308"The selection model determines how elements are selected from a group of elements.  OSF/Motif compliant systems must support the five different selection models.  The five selection models are as follows: Single Selection Used to select a single element in a collection.  Clicking ID="ch09309"ID="ch09310"BSelect on a deselected element selects it and deselects the previously selected element in the collection.  Single selection is described in IDREF="40662" TYPE="TITLE"Section 4.1.1, "Mouse-Based Single Selection."Browse Selection Used to allow browsing through single selection collections.  Browse selection is also used to select a single element of a collection.  Browse selection works just like single selection, but additionally allows the user to browse through the elements by dragging ID="ch09311"ID="ch09312"BSelect through the elements in the collection.  Browse select highlights each element as it is traversed, and gives the application an opportunity to provide information about each element as it is highlighted.  Releasing BSelect on an element selects it and deselects the previously selected element.  Browse selection is described in IDREF="35080" TYPE="TITLE"Section 4.1.2, "Mouse-Based Browse Selection."Multiple Selection Used to select or deselect multiple elements of a collection.  Clicking ID="ch09313"ID="ch09314"BSelect on an unselected element adds that element to the current selection.  Clicking BSelect on a selected element removes that element from the current selection.  Multiple selection is described in IDREF="17616" TYPE="TITLE"Section 4.1.3, "Mouse-Based Multiple Selection."Range Selection Used to select a contiguous range of elements in a collection.  Clicking ID="ch09315"ID="ch09316"BSelect on an element selects the single element and deselects any previous selection.  BSelect Motion over a range of elements selects all the elements within the range and deselects any previous selection.  Range selection is described in IDREF="35475" TYPE="TITLE"Section 4.1.4, "Mouse-Based Range Selection."Discontiguous Selection Used for selecting multiple discontiguous ranges of elements in a collection.  Clicking or dragging ID="ch09317"ID="ch09318"BSelect operates the same as for range selection.  Discontiguous selection also allows <Ctrl> BSelect to be used to add new selection ranges to or remove selection ranges from the selection.  Discontiguous selection is described in IDREF="37548" TYPE="TITLE"Section 4.1.5, "Mouse-Based Discontiguous Selection."LBL="9.53.2" HELPID=""Related InformationSee IDREF="12570" TYPE="TITLE"Chapter 4, "Selection"
 for more information about the selection models.  LBL="9.54" HELPID=""SelectionBoxLBL="9.54.1" HELPID=""DescriptionID="ch09319"A SelectionBox is a special-purpose composite component for making selections from a list of choices.  The SelectionBox must be composed of at least a Text component for the selected alternative and a List component above the Text component for presenting the alternatives.  Both the List and Text components should have a Label above them.  The List component can be scrollable.  The SelectionBox should also include one of the following button arrangements: OK Cancel HelpOK Cancel Apply HelpThe List must use either the single or browse selection model.  Selecting an element from the list must place the selected element in the Text component.  Entering an item name into the Text component should make that element visible in the List component.  The List navigation actions <Up arrow>,<Down arrow>,<Ctrl> <Begin>,and <Ctrl> <End> must be available from the Text component for moving the cursored element within the List and thus changing the contents of the Text.  The List navigation actions <PageUp> and <PageDown> should also be available from the Text component for moving the cursored element within the List.  LBL="9.54.2" HELPID=""IllustrationLBL="9-45" FILE="selbox.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-45"Figure 9-45 
A SelectionBoxLBL="9.54.3" HELPID=""Related InformationFor more information, see the reference page in IDREF="41952" TYPE="TITLE"Section 9.55, "SelectionDialog."LBL="9.55" HELPID=""ID="41952"SelectionDialogLBL="9.55.1" HELPID=""DescriptionID="ch09320"ID="ch09321"A SelectionDialog should be used to allow a user to make a selection from a list of choices.  It can interrupt the user's interaction with the application.  It should contain a SelectionBox.  LBL="9.55.2" HELPID=""IllustrationLBL="9-46" FILE="selbox.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-46"Figure 9-46 
A SelectionDialogLBL="9.55.3" HELPID=""Related InformationFor more information, see the reference page in IDREF="17953" TYPE="TITLE"Section 9.12, "DialogBox."LBL="9.56" HELPID=""SeparatorLBL="9.56.1" HELPID=""DescriptionID="ch09322"A Separator should be used to separate elements of the application.  It should be composed of a vertical or horizontal line.  LBL="9.56.2" HELPID=""IllustrationLBL="9-47" FILE="progbox.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-47"Figure 9-47 
A SeparatorLBL="9.56.3" HELPID=""NavigationA Separator must have no internal navigation.  LBL="9.57" HELPID=""TearOffButtonLBL="9.57.1" HELPID=""DescriptionID="ch09323"A TearOffButton should be used to tear off a Menu to create a dialog representation of the Menu contents.  A TearOffButton tears off a Menu in place when activated, or it is dragged to tear off and move in one action.  This component must be composed of a button with a graphic that indicates the tear-off action.  The graphic should be a dashed line representing perforations.  LBL="9.57.2" HELPID=""IllustrationLBL="9-48" FILE="tearoff.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-48"Figure 9-48 
A TearOffButtonLBL="9.57.3" HELPID=""NavigationA TearOffButton must have no internal navigation.  LBL="9.57.4" HELPID=""Other OperationsThe following text describes the operations of this component: BSelect Press Must arm the TearOffButton.  BSelect Release If the release is within the same TearOffButton as the press, BSelect Release must disarm the TearOffButton and activate it.  If the release is outside of the TearOffButton, BSelect Release must disarm the TearOffButton without activating it.  BTransfer Press Must activate the TearOffButton and cause the newly torn off Menu or its representation to start to track the position of the pointer.  BTransfer Motion Must cause the newly torn off Menu or its representation to track the position of the pointer.  BTransfer Release Must cause the newly torn off Menu or its representation to stop tracking the position of the pointer and become a torn off Menu.  <Enter> or <Return> Must activate the TearOffButton.  <Select> or <Space> Must activate the TearOffButton.  <Help> Must provide any available help for the TearOffButton.  LBL="9.57.5" HELPID=""Related InformationSee IDREF="20011" TYPE="TITLE"Chapter 6, "Application Design Principles"
 for more information on TearOff Menus and for general information about Menu design.  LBL="9.58" HELPID=""ID="15561"TextLBL="9.58.1" HELPID=""DescriptionID="ch09324"ID="ch09325"A Text component should be used to display and enter text.  A Text component must be composed of an area for displaying and entering text.  The text can be either a single line or multiple lines.  Text must support the range selection model as described in IDREF="12570" TYPE="TITLE"Chapter 4, "Selection"
 and can support the discontiguous selection model.  LBL="9.58.2" HELPID=""IllustrationLBL="9-49" FILE="text.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-49"Figure 9-49 
TextLBL="9.58.3" HELPID=""NavigationThe following text describes the navigation actions of this component: <Up arrow> In multiline Text components, <Up arrow> must move the location cursor up one line.  In single-line Text components, <Up arrow> must navigate upward to the previous component if the Text component is designed to act like a basic control.  <Down arrow> In multiline Text components, <Down arrow> must move the location cursor down one line.  In single-line Text components, <Down arrow> must navigate downward to the next component if the Text component is designed to act like a basic control.  <Left arrow> Must move the location cursor left one character.  <Right arrow> Must move the location cursor right one character.  <PageUp> In multiline Text components, <PageUp> must move the location cursor up one page.  <PageDown> In multiline Text components, <PageDown> must move the location cursor down one page.  <PageLeft> or <Ctrl> <PageUp> Must move the location cursor left one page.  <PageRight> or <Ctrl> <PageDown> Must move the location cursor right one page.  <Ctrl> <Right arrow> In a Text component used generally to hold multiple words, must move the location cursor to the right by a word.  That is, <Ctrl> <Right arrow> must place the location cursor before the first character that is not a space, tab, or newline character after the next space, tab, or newline character.  In short single-line Text controls, <Ctrl> <Right arrow> can navigate rightward to the next component if the Text is designed to act like a basic control.  <Ctrl> <Left arrow> In a Text component used generally to hold multiple words, must move the location cursor to the left by a word.  That is, <Ctrl> <Left arrow> must place the location cursor after the first space, tab, or newline character preceding the first previous character that is not a space, tab, or newline.  In short single-line Text controls, <Ctrl> <Left arrow> can navigate leftward to the next component if the Text is designed to act like a basic control.  <Ctrl> <Down arrow> In multiline Text components, <Ctrl> <Down arrow> can optionally move the location cursor to the beginning of the next paragraph.  <Ctrl> <Up arrow> In multiline Text components, <Ctrl> <Up arrow> can optionally move the location cursor to the beginning of the previous paragraph.  <Begin> In a Text component used generally to hold multiple words, must move the location cursor to the beginning of the line.  <End> In a Text component used generally to hold multiple words, must move the location cursor to the end of the line.  <Ctrl> <Begin> In multiline Text components, <Ctrl> <Begin> must move the location cursor to the beginning of the file.  <Ctrl> <End> In multiline Text components, <Ctrl> <End> must move the location cursor to the end of the file.  LBL="9.58.4" HELPID=""Other OperationsThe following text describes the operations of this component: <Space> or <Shift> <Space> Must insert a space.  Modifying these with <Ctrl> must evoke its normal selection function.  <Return> In multiline Text components, <Return> must insert a carriage return.  <Ctrl> <Return> and <Enter> Must invoke the default action.  <Tab> and <Shift> <Tab> In multiline Text, <Tab> must be used for tabbing (either inserting a tab or moving to the next tab stop).  In single-line Text, <Tab> must be used either for tabbing or to move to the next field.  If <Tab> is used for tabbing and the location cursor is at the end of the text, <Tab> can optionally move to the next field.  <Shift> <Tab> must be used to move to the previous field if <Tab> is used to move to the next field.  Otherwise, <Shift> <Tab> should be used for tabbing backward.  If <Shift> <Tab> is used for tabbing backward and the location cursor is at the beginning of the text, <Shift> <Tab> can optionally move to the previous field.  Modifying <Tab> or <Shift> <Tab> with <Ctrl> must evoke the same field navigation function as <Tab> or <Shift> <Tab>.<BackSpace> When the selection is empty or when the component is in add mode with the cursor disjoint from the selection, <BackSpace> must delete one character backward.  Otherwise, <BackSpace> must delete the selection.  <Delete> When the selection is empty or when the component is in add mode with the cursor disjoint from the selection, <Delete> must delete one character forward.  Otherwise, <Delete> must delete the selection.  <Ctrl> <Delete> When the selection is empty or when the component is in add mode with the cursor disjoint from the selection, <Ctrl> <Delete> can delete the character following the location cursor to the end of the line.  Otherwise, <Ctrl> <Delete> can delete the selection.  <Insert> If the Text component supports replace mode, must toggle between insert mode and replace mode.  By default, Text components must start in insert mode, where the location cursor is between two characters.  In insert mode, typing a character must insert the character at the position of the location cursor.  Text components can also implement replace mode, where the location cursor is on a character.  In replace mode, typing a character must replace the current character with that newly entered character and move the location cursor to the next character, selecting it.  Many of the requirements for a text-like collection in this guide assume that the collection is in insert mode and do not apply in replace mode.  BSelect Click 2+ Selects text a block at a time.  A double-click must select text a word at a time.  A triple-click can optionally select text a line or sentence at a time.  Larger numbers of clicks can optionally select increasingly larger blocks of text.  BSelect Motion 2+ Can drag out a new selection by blocks as described for BSelect Click 2+.  <Shift> BSelect Click 2+ Can extend the selection to a block boundary as described for BSelect Click 2+<Shift> BSelect Motion 2+ Can extend the selection by blocks as described for BSelect Click 2+.  <Ctrl> BSelect Click 2+ If the Text component supports discontiguous selection, this can extend the discontiguous selection by blocks as described for BSelect Click 2+.  <Ctrl> BSelect Motion 2+ If the Text component supports discontiguous selection, this can drag out the discontiguous selection by blocks as described for BSelect Click 2+.  <Help> Must provide any available help for the Text control.  LBL="9.58.5" HELPID=""Related InformationFor more information on Text selection, see the description of the selection models in IDREF="12570" TYPE="TITLE"Chapter 4, "Selection."LBL="9.59" HELPID=""ID="15890"ToggleButtonLBL="9.59.1" HELPID=""DescriptionID="ch09326"ID="ch09327"ID="ch09328"A ToggleButton should be used to select options in an application.  When the choice is one of many, the ToggleButton is called a RadioButton.  When the choice is any of many, the ToggleButton is called a CheckButton.  The ToggleButton must be composed of a text or graphic label, and it can contain a graphic that indicates the state of the ToggleButton.  The graphic should precede the label and should have two distinctive states that indicate the set and unset states of the ToggleButton.  LBL="9.59.2" HELPID=""IllustrationLBL="9-50" FILE="checkbut.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-50"Figure 9-50 
A ToggleButtonLBL="9.59.3" HELPID=""NavigationToggleButtons must have no internal navigation.  LBL="9.59.4" HELPID=""Related InformationFor a description of the activation of the two types of ToggleButtons, see the reference pages in IDREF="34612" TYPE="TITLE"Section 9.7, "CheckButton"
 andIDREF="39382" TYPE="TITLE"Section 9.48, "RadioButton."LBL="9.60" HELPID=""ID="21595"WarningDialogLBL="9.60.1" HELPID=""DescriptionID="ch09329"ID="ch09330"A WarningDialog should be used to alert the user to a possible danger.  It should interrupt the user's interaction with the application.  It should contain a warning symbol, a message, and one of the following button arrangements: Yes NoYes No HelpOK CancelOK Cancel HelpLBL="9.60.2" HELPID=""IllustrationLBL="9-51" FILE="warnbox.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-51"Figure 9-51 
A WarningDialogLBL="9.60.3" HELPID=""Related InformationFor more information, see the reference page in IDREF="17953" TYPE="TITLE"Section 9.12, "DialogBox."LBL="9.61" HELPID=""Window MenuLBL="9.61.1" HELPID=""DescriptionID="ch09331"ID="ch09332"ID="ch09333"ID="ch09334"The window Menu, sometimes called the system Menu, is used to display the list of window actions.  All actions possible for a window should be displayed in the window Menu, since keyboard-only users interact with the window manager through this Menu.  The window Menu button must be located in the upper-left corner of the window.  Double-clicking the window Menu button must close the window.  Pressing <Shift> <Escape> or <Alt> <Space> must activate the window Menu button for the window with the focus.  The illustration on this reference page shows a posted window Menu.  A primary window Menu must have the following selections in the order listed: Restore Alt+F5 Restores a minimized or maximized window to the previous size and location of the window.  This selection must be deemphasized (grayed out) when the window is in its normal state.  This action must have the mnemonic ID="ch09335"R.  If this action has an accelerator, it must be <Alt> <F5> if <F5> is available.  Move Alt+F7Moves a window around the workspace.  This action must have the mnemonic ID="ch09336"M.  If this action has an accelerator, it must be <Alt> <F7> if <F7> is available.  Size Alt+F8Changes the height and width of the window in the direction indicated by the pointer.  This action must have the mnemonic ID="ch09337"S.  If this action has an accelerator, it must be <Alt> <F8> if <F8> is available.  Minimize Alt+F9 Changes a window into an icon.  This action must have the mnemonic ID="ch09338"N.  If this action has an accelerator, it must be <Alt> <F9> if <F9> is available.  Maximize Alt+F10 Enlarges a window to its maximum size.  This action must have the mnemonic ID="ch09339"X.  If this action has an accelerator, it must be <Alt> <F10> if <F10> is available.  Lower Alt+F3Moves a window to the bottom of the window hierarchy.  This action can be omitted.  This action must have the mnemonic ID="ch09340"ID="ch09341"ID="ch09342"ID="ch09343"ID="ch09344"L.  If this action has an accelerator, it must be <Alt> <F3> if <F3> is available.  Close Alt+F4Closes a window and removes it from the workspace.  This action must have the mnemonic ID="ch09345"C.  If this action has an accelerator, it must be <Alt> <F4> if <F4> is available.  A secondary window Menu must have the following selections in the order listed: Move, Size, and Close.  A secondary window Menu can include Restore above Move, Maximize below Size, and Lower above Close, but the lower option on a secondary window lowers all the windows secondary to that window's primary window.  A secondary window Menu should not include Restore if it does not include Maximize.  A secondary window must not include an entry for Minimize.  A secondary window resulting from a Menu being torn off must have the following entries in the order listed: Move, Lower, and Close.  It must not include entries for Restore, Size, Minimize, or Maximize.  LBL="9.61.2" HELPID=""IllustrationLBL="9-52" FILE="osfmenu.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-52"Figure 9-52 
A Window MenuLBL="9.61.3" HELPID=""Related InformationSee IDREF="24491" TYPE="TITLE"Chapter 7, "Window Manager Design Principles"
 for more information on the window Menu and the window manager in general.  See IDREF="20011" TYPE="TITLE"Chapter 6, "Application Design Principles"
 for information about Menu design.  LBL="9.62" HELPID=""ID="14357"WorkingDialogLBL="9.62.1" HELPID=""DescriptionID="ch09346"ID="ch09347"A WorkingDialog should be used to show work in progress and give the user an opportunity to cancel the operation.  It should not interrupt the user's interaction with the application.  It should contain a working symbol, a message, and one of the following button arrangements: OK CancelOK Cancel HelpLBL="9.62.2" HELPID=""IllustrationLBL="9-53" FILE="progbox.gif" POSITION="INLINE" SCALE="FALSE"LBL="9-53"Figure 9-53 
A WorkingDialogLBL="9.62.3" HELPID=""Related InformationFor more information, see the reference page in IDREF="17953" TYPE="TITLE"Section 9.12, "DialogBox."LBL="A"ID="36096"OSF/Motif Widgets and Components CorrespondenceThis appendix shows how actual OSF/Motif widgets correspond to the components described in this guide.  Gadgets, which are essentially performance-oriented versions of widgets, are not listed in this appendix but correspond closely to their widget counterparts.  ID="appa1"ID="appa2"ID="appa3"ID="appa4"ID="appa5"ID="appa6"ID="appa7"ID="appa8"ID="appa9"ID="appa10"ID="appa11"ID="appa12"ID="appa13"ID="appa14"ID="appa15"ID="appa16"ID="appa17"ID="appa18"ID="appa19"ID="appa20"ID="appa21"ID="appa22"ID="appa23"ID="appa24"ID="appa25"ID="appa26"ID="appa27"ID="appa28"ID="appa29"ID="appa30"ID="appa31"COLUMNS="2"LEFT="0" WIDTH="97"ComponentsLEFT="105" WIDTH="356"Motif WidgetsLEFT="0" WIDTH="97"Basic Controls:LEFT="105" WIDTH="356"LEFT="0" WIDTH="97"SeparatorLEFT="105" WIDTH="356"XmSeparatorLEFT="0" WIDTH="97"LabelLEFT="105" WIDTH="356"XmLabelLEFT="0" WIDTH="97"PushButtonLEFT="105" WIDTH="356"XmPushButtonLEFT="0" WIDTH="97"LEFT="105" WIDTH="356"XmArrowButtonLEFT="0" WIDTH="97"LEFT="105" WIDTH="356"XmDrawnButtonLEFT="0" WIDTH="97"ToggleButtonLEFT="105" WIDTH="356"XmToggleButtonIt can also be simulated by XmPushButton andXmDrawnButtonLEFT="0" WIDTH="97"CheckButtonLEFT="105" WIDTH="356"XmToggleButton with XmNindicatorType set to 
XmN_OF_MANYLEFT="0" WIDTH="97"RadioButtonLEFT="105" WIDTH="356"XmToggleButton with XmNindicatorType set to 
XmONE_OF_MANYLEFT="0" WIDTH="97"CascadeButtonLEFT="105" WIDTH="356"XmCascadeButtonLEFT="0" WIDTH="97"OptionButtonLEFT="105" WIDTH="356"An XmCascadeButton within an XmRowColumn with 
XmNrowColumnType set to XmMENU_OPTIONLEFT="0" WIDTH="97"Field Controls:LEFT="105" WIDTH="356"LEFT="0" WIDTH="97"ScrollBarLEFT="105" WIDTH="356"XmScrollBarLEFT="0" WIDTH="97"ScaleLEFT="105" WIDTH="356"XmScaleLEFT="0" WIDTH="97"SashLEFT="105" WIDTH="356"Private element of XmPanedWindowLEFT="0" WIDTH="97"TextLEFT="105" WIDTH="356"XmText and XmTextFieldLEFT="0" WIDTH="97"CanvasLEFT="105" WIDTH="356"XmDrawingArea (without children), XmDrawnButtonLEFT="0" WIDTH="97"ListLEFT="105" WIDTH="356"XmListLEFT="0" WIDTH="97"Basic Groups:LEFT="105" WIDTH="356"LEFT="0" WIDTH="97"PanelLEFT="105" WIDTH="356"XmRowColumn with XmNrowColumnType set to 
XmWORK_AREA and composed of basic controls LEFT="0" WIDTH="97"MenuLEFT="105" WIDTH="356"XmRowColumn with XmNrowColumnType set to 
XmMENU_PULLDOWN or XmMENU_POPUPLEFT="0" WIDTH="97"MenuBarLEFT="105" WIDTH="356"XmRowColumn with XmNrowColumnType set to 
XmMENU_BARLEFT="0" WIDTH="97"Layout Groups:LEFT="105" WIDTH="356"LEFT="0" WIDTH="97"CompositeLEFT="105" WIDTH="356"XmBulletinBoard, XmDrawingArea (with children), 
XmForm, XmRowColumn when XmNrowColumnType is 
set to XmWORK_AREA and it is not a basic group LEFT="0" WIDTH="97"PanedWindowLEFT="105" WIDTH="356"XmPanedWindowLEFT="0" WIDTH="97"Framing Groups:LEFT="105" WIDTH="356"LEFT="0" WIDTH="97"FrameLEFT="105" WIDTH="356"XmFrameLEFT="0" WIDTH="97"ScrolledWindowLEFT="105" WIDTH="356"XmScrolledWindowLEFT="0" WIDTH="97"MainWindowLEFT="105" WIDTH="356"XmMainWindowLEFT="0" WIDTH="97"DialogBoxes:LEFT="105" WIDTH="356"LEFT="0" WIDTH="97"CommandDialogLEFT="105" WIDTH="356"XmCommandLEFT="0" WIDTH="97"ErrorDialogLEFT="105" WIDTH="356"XmMessageBoxLEFT="0" WIDTH="97"FileSelectionDialogLEFT="105" WIDTH="356"XmFileSelectionBoxLEFT="0" WIDTH="97"InformationDialogLEFT="105" WIDTH="356"XmMessageBoxLEFT="0" WIDTH="97"MessageDialogLEFT="105" WIDTH="356"XmMessageBoxLEFT="0" WIDTH="97"PromptDialogLEFT="105" WIDTH="356"XmSelectionBoxLEFT="0" WIDTH="97"QuestionDialogLEFT="105" WIDTH="356"XmMessageBoxLEFT="0" WIDTH="97"SelectionDialogLEFT="105" WIDTH="356"XmSelectionBoxLEFT="0" WIDTH="97"WarningDialogLEFT="105" WIDTH="356"XmMessageBoxLEFT="0" WIDTH="97"WorkingDialogLEFT="105" WIDTH="356"XmMessageBoxLBL="A-1"Table A-1 
Component to Widget CorrespondenceLBL="B"ID="15733"OSF/Motif Level One Certification ChecklistThe OSF/Motif Level One Certification Checklist (Revision 1.2) provides the list of requirements for OSF/Motif application-level certification.  In order for your application to be certified  compliant, it must behave according to these requirements.  You certify your own application by comparing its behavior with that specified in the Checklist.  For each Checklist item, check Yes only if your application performs exactly as described for that item.  If you have not implemented a specified type of behavior in any manner anywhere in your application, you may mark N/A (not applicable) for the items pertaining to that behavior.  The Checklist describes keys using a model keyboard mechanism.  Wherever keyboard input is specified, the keys are indicated by the engravings that they have on the OSF/Motif model keyboard.  Mouse buttons are described using a virtual button mechanism to better describe behavior independent from the number of buttons on the mouse.  For more information on the model keyboard and virtual button mechanisms, consult the IDREF="18097" TYPE="TITLE", "Preface"
 and IDREF="42447" TYPE="TITLE"Section 2.2.1, "Pointing Devices"
 of this guide.  By default, this Checklist assumes that your application is being designed for a left-to-right language environment in an English-language locale.  Some sections of the Checklist may require appropriate changes for other locales.  As you compare the behavior of your application to the requirements in the Checklist, we recommend that you follow along in the OSF/Motif Style Guide(Revision 1.2).  For each Checklist item, corresponding section numbers in the guide have been provided for your convenience.  Each item in the Checklist is also followed by a brief explanation and/or justification.  If you do not understand a particular item, refer to the appropriate section in the guide and check the glossary in the guide for any terms that are unclear.  LBL="B.1" HELPID=""PrefaceYes  N/A  No___   ___   ___ 1-1:Each of the nonoptional keys described on the OSF/Motif model keyboard is available either as specified or by using other keys or key combinations if the specified key is unavailable (Preface).  The model keyboard does not correspond directly to any existing keyboard; rather, it assumes a keyboard with an ideal set of keys.  However, to ensure consistency across applications, the nonoptional keys or substitutes for them must always be available. LBL="B.2" HELPID=""Input ModelsLBL="B.2.1" HELPID=""The Keyboard Focus ModelYes  N/A  No___   ___   ___ 2-1:Only one window at a time has the keyboard focus.  The window that has the focus is highlighted.  Within the window that has the keyboard focus, only one component at a time has the focus (IDREF="31977" TYPE="TITLE"Section 2.1, "The Keyboard Focus Model"
).  The keyboard focus determines which component on the screen receives keyboard events.  This rule prevents confusion about which window and component have the focus. ___   ___   ___ 2-2:When your application uses an explicit focus policy, pressing BSelect does not move focus to a component that is not traversable or does not accept input (IDREF="37103" TYPE="TITLE"Section 2.1.2, "Explicit Focus"
).  An explicit focus policy requires the user to explicitly select which window or component receives the keyboard focus.  Generally, the user gives the focus to a window or component by pressing BSelect over it.  However, this policy must not allow the user to give focus to a component that is not traversable or does not accept input. ___   ___   ___ 2-3:When your application uses an explicit focus policy, the component with the keyboard focus is highlighted by a location cursor (IDREF="37103" TYPE="TITLE"Section 2.1.2, "Explicit Focus"
).  The user needs to know the location of the keyboard focus to be able to control an application. LBL="B.2.2" HELPID=""The Input Device ModelYes  N/A  No___   ___   ___ 2-4:Your application supports methods of interaction for keyboard-only users.  All features of your application are available from the keyboard (IDREF="28826" TYPE="TITLE"Section 2.2, "The Input Device Model"
).  Some users may not have access to a pointing device.  These users need to be able to access the full functionality of the application from the keyboard.  Additionally, advanced users will be able to use the keyboard to perform some tasks more quickly than with a pointing device. ___   ___   ___ 2-5:Your application uses the following bindings for mouse buttons (IDREF="42447" TYPE="TITLE"Section 2.2.1, "Pointing Devices"
): BSelect, used for selection, activation, and setting the location cursor, is the leftmost button, except for left-handed users, where it can be the rightmost button.  BTransfer, used for moving and copying elements, is the middle mouse button, unless dragging is integrated with selection or the mouse has fewer than three buttons.  BMenu, used for popping up Menus, is the rightmost button, except for left-handed users, where is can be the leftmost button, or unless the mouse has fewer than three buttons.  If the mouse has one button, BMenu is bound to <Alt> BSelect.  These bindings ensure a consistent interface for using standard mouse-based operations across applications. ___   ___   ___ 2-6:Your application does not warp the pointer unless you have given the user a means of disabling the behavior (IDREF="30055" TYPE="TITLE"Section 2.2.4, "Warp Pointer Only If Explicitly Enabled"
).  The pointer position is intended only as input to applications, not as an output mechanism.  An application warps the pointer when it changes the pointer's position.  This practice is confusing to users and reduces their sense of control over an application.  Warping the pointer can also cause problems for users of absolute location pointing devices. LBL="B.3" HELPID=""NavigationLBL="B.3.1" HELPID=""Mouse-Based NavigationYes  N/A  No___   ___   ___ 3-1:When the keyboard focus policy is explicit, pressing BSelect on a component moves focus to it, except for components, such as ScrollBars, that are used to adjust the size and location of other elements (IDREF="26768" TYPE="TITLE"Section 3.1, "Mouse-Based Navigation"
).  BSelect provides a convenient mechanism for using the mouse to move focus when the keyboard focus policy is explicit. ___   ___   ___ 3-2:When the pointer is on a Menu, your application uses BSelect Press to activate the Menu in a spring-loaded manner (IDREF="26768" TYPE="TITLE"Section 3.1, "Mouse-Based Navigation"
).  A spring-loaded Menu is one that appears when the user presses a mouse button, remains on the screen for as long as the button is pressed, and disappears when the user releases the button.  BSelect, the first mouse button, provides a means of activating spring-loaded Menus that is consistent across applications. ___   ___   ___ 3-3:When the pointer is in an element with an inactive Popup Menu and the context of the element allows the Popup Menu to be displayed, your application uses BMenu Press to activate the Popup Menu in a spring-loaded manner (IDREF="26768" TYPE="TITLE"Section 3.1, "Mouse-Based Navigation"
).  The availability of a Popup Menu can depend on the location of the pointer within an element, the contents of an element, or the selection state of an element.  BMenu, the third mouse button, provides a consistent means of activating a spring-loaded Popup Menu. ___   ___   ___ 3-4:If the user takes an action to post a Popup Menu, and a Menu can be posted for both an inner element and an outer element that contains the inner element, the Popup Menu for the internal element is posted (IDREF="26768" TYPE="TITLE"Section 3.1, "Mouse-Based Navigation"
).  This specification ensures that the Popup Menu for an internal element is always accessible. ___   ___   ___ 3-5:Once a Popup Menu is posted, BMenu behaves just as BSelect does for any Menu system (IDREF="26768" TYPE="TITLE"Section 3.1, "Mouse-Based Navigation"
).  The specified operation of BMenu is for manipulating Popup Menus. ___   ___   ___ 3-6:BSelect is also available from within posted Popup Menus and behaves just as in any Menu system (IDREF="26768" TYPE="TITLE"Section 3.1, "Mouse-Based Navigation"
).  Once a Popup Menu is posted, the user can select an element from it using the standard selection mechanism, BSelect.___   ___   ___ 3-7:When a Menu is popped up or pulled down in a posted manner, your application places the location cursor on the Menu's default entry, or on the first entry in the Menu if there is no default entry (IDREF="26768" TYPE="TITLE"Section 3.1, "Mouse-Based Navigation"
).  A posted Menu remains visible until it is explicitly unposted.  Placing the location cursor on the default entry allows the user to select the default operation easily.  When there is no default entry, placing the location cursor on the first entry yields uniform behavior across applications. ___   ___   ___ 3-8:Your application removes a spring-loaded Menu system when the mouse button that activated it is released, except when the button is released on a CascadeButton in the Menu hierarchy (IDREF="26768" TYPE="TITLE"Section 3.1, "Mouse-Based Navigation"
).  The concept of a spring-loaded Menu system requires that the Menu disappear when the mouse button is released. ___   ___   ___ 3-9:While a spring-loaded Menu system is popped up or pulled down, moving the pointer within the Menu system moves the location cursor to track the pointer (IDREF="26768" TYPE="TITLE"Section 3.1, "Mouse-Based Navigation"
).  Once a spring-loaded Menu system has appeared on the screen, the user needs to be able to maneuver the location cursor through the Menu system using the mouse. ___   ___   ___ 3-10:When a spring-loaded Menu system is popped up or pulled down and the pointer rests on a CascadeButton, the associated Menu is pulled down and becomes traversable.  The associated Menu is removed, possibly after a short delay, when the pointer moves to a Menu item outside of the Menu or its CascadeButton (IDREF="26768" TYPE="TITLE"Section 3.1, "Mouse-Based Navigation"
).  The user needs to be able to use the mouse to access all of the associated Menus of a Menu system.  This feature allows the user to move quickly to any Menu in a Menu system. ___   ___   ___ 3-11:When a spring-loaded Menu system that is part of the MenuBar is pulled down, moving the pointer to any other element on the MenuBar unposts the current Menu system and posts the Pulldown Menu associated with the new element (IDREF="26768" TYPE="TITLE"Section 3.1, "Mouse-Based Navigation"
).  This feature of a spring-loaded Menu system allows the user to browse quickly through all of the Menus attached to a MenuBar. ___   ___   ___ 3-12:When a spring-loaded Menu system is popped up or pulled down, and the button that activated the Menu system is released within a component in the Menu system, that component is activated.  If the release is on a CascadeButton or an OptionButton, the associated Menu is activated in a posted manner if it was not posted prior to the associated button press (IDREF="26768" TYPE="TITLE"Section 3.1, "Mouse-Based Navigation"
).  Releasing the mouse button that activated a spring-loaded Menu provides a means of activating a Menu element that is consistent across applications. ___   ___   ___ 3-13:When the pointer is in an area with a Popup Menu, your application uses BMenu Click to activate the Menu in a posted manner if it was not posted prior to the BMenu Click (IDREF="26768" TYPE="TITLE"Section 3.1, "Mouse-Based Navigation"
).  BMenu Click provides a means of posting a Popup Menu that is consistent across applications. ___   ___   ___ 3-14:Once a Pulldown or Option Menu is posted, BSelect Press in the Menu system causes the Menu to behave as a spring-loaded Menu (IDREF="26768" TYPE="TITLE"Section 3.1, "Mouse-Based Navigation"
).  This feature of a posted Pulldown or Option Menu allows the user to switch easily between using a posted Menu and a spring-loaded Menu. ___   ___   ___ 3-15:If a button press unposts a Menu and that button press is not also passed to the underlying component, subsequent events up to and including the button release are not passed to the underlying component (IDREF="26768" TYPE="TITLE"Section 3.1, "Mouse-Based Navigation"
).  When a button press unposts a Menu, the press can be passed to the underlying component.  Whether or not it is passed to the underlying component, the press can have additional effects, such as raising and giving focus to the underlying window.  If the press is not passed to the underlying component, events up to and including the release must not be passed to that component. ___   ___   ___ 3-16:Once a Popup Menu is posted, BSelect Press or BMenu Press in the Menu system causes the Menu to behave as a spring-loaded Menu (IDREF="26768" TYPE="TITLE"Section 3.1, "Mouse-Based Navigation"
).  This feature of a posted Popup Menu allows the user to switch easily between using a posted Menu and a spring-loaded Menu. LBL="B.3.2" HELPID=""Keyboard-Based NavigationYes  N/A  No___   ___   ___ 3-17:In a Text component, the text cursor is shown differently when the component does and does not have the keyboard focus (IDREF="18305" TYPE="TITLE"Section 3.2.1, "Location Cursor"
).  In a Text component, the text cursor serves as the location cursor and therefore must indicate whether or not the component has keyboard focus. ___   ___   ___ 3-18:If a Text component indicates that it has lost the keyboard focus by hiding the text cursor and if the component subsequently regains the focus, the cursor reappears at the same position it had when the component lost focus (IDREF="18305" TYPE="TITLE"Section 3.2.1, "Location Cursor"
).  To ensure predictability, it is important that the text cursor not change position when a Text component loses and then regains the keyboard focus. ___   ___   ___ 3-19:If a small component, such as a Sash, indicates that it has the keyboard focus by filling, no other meaning is associated with the filled state (IDREF="18305" TYPE="TITLE"Section 3.2.1, "Location Cursor"
).  This rule reduces possible confusion about the significance of filling in a small component. ___   ___   ___ 3-20:All components are designed and positioned within your application so that adding and removing each component's location cursor do not change the amount of space that the component takes up on the screen (IDREF="18305" TYPE="TITLE"Section 3.2.1, "Location Cursor"
).  For visual consistency, the sizes and positions of components should not change when keyboard focus moves from one component to another. ___   ___   ___ 3-21:<Ctrl> <Tab> moves the location cursor to the next field, and <Ctrl> <Shift> <Tab> moves the location cursor to the previous field.  Unless <Tab> and <Shift> <Tab> are used for internal navigation within a field, <Tab> also moves the location cursor to the next field, and <Shift> <Tab> also moves the location cursor to the previous field (IDREF="22203" TYPE="TITLE"Section 3.2.3, "Component Navigation"
).  These keys provide a consistent means of navigating among fields in a window. ___   ___   ___ 3-22:<Tab> (if not used for internal navigation) and <Ctrl> <Tab> move the location cursor forward through fields in a window according to the following rules (IDREF="22203" TYPE="TITLE"Section 3.2.3, "Component Navigation"
): If the next field is a control, <Tab> (if not used for internal navigation) and <Ctrl> <Tab> move the location cursor to that control.  If the next field is a group, <Tab> (if not used for internal navigation) and <Ctrl> <Tab> move the location cursor to a traversable component within the group.  If the next field contains no traversable components, <Tab> (if not used for internal navigation) and <Ctrl> <Tab> skip the field.  These rules ensure the consistent operation of <Tab> (if not      used for internal navigation) and <Ctrl> <Tab> across   applications. ___   ___   ___ 3-23:<Shift> <Tab> (if not used for internal navigation) and <Ctrl> <Shift> <Tab> move the location cursor backward through fields in the order opposite to that of <Tab> (if not used for internal navigation) and <Ctrl> <Tab> (IDREF="22203" TYPE="TITLE"Section 3.2.3, "Component Navigation"
).  These rules result in the uniform operation of <Shift> <Tab> (if not used for internal navigation) and<Ctrl> <Shift> <Tab> across applications. ___   ___   ___ 3-24:When a window acquires focus, the location cursor is placed on the control that last had focus in the window, providing that all the following conditions are met (IDREF="22203" TYPE="TITLE"Section 3.2.3, "Component Navigation"
): The window uses an explicit keyboard focus policy.  The window acquires the focus through keyboard navigation or through a button press other than within the client area of the window.  The window had the focus at some time in the past.  The control that last had focus in the window is still traversable.This rule ensures that when the user returns to a window after navigating away, the focus returns to the component where the user left it. ___   ___   ___ 3-25:Field navigation wraps between the first and last fields in the window.  (IDREF="22203" TYPE="TITLE"Section 3.2.3, "Component Navigation"
).  This feature of field navigation provides the user with a convenient way to move through all of the fields in a window. ___   ___   ___ 3-26:When <Down arrow> and <Up arrow> are used for component navigation within a field, they behave according to the following rules (IDREF="22203" TYPE="TITLE"Section 3.2.3, "Component Navigation"
): In a left-to-right language environment, <Down arrow> moves the location cursor through all traversable controls in the field, starting at the upper left and ending at the lower right, then wrapping to the upper left.  If the controls are aligned in a matrix-like arrangement, <Down arrow> first traverses one column from top to bottom, then traverses the column to its right, and so on.  In a right-to-left language environment, <Down arrow> moves the location cursor through all traversable controls, starting at the upper right and ending at the lower left.  <Up arrow> moves the location cursor through all traversable controls in the field in the order opposite to that of <Down arrow>.These rules ensure a consistent means of navigating among components using the directional keys. ___   ___   ___ 3-27:When <Right arrow> and <Left arrow> are used for component navigation within a field, they behave according to the following rules (IDREF="22203" TYPE="TITLE"Section 3.2.3, "Component Navigation"
): In a left-to-right language environment, <Right arrow> moves the location cursor through all traversable controls in the field, starting at the upper left and ending at the lower right, then wrapping to the upper left.  If the controls are aligned in a matrix-like arrangement, <Right arrow> first traverses one row from left to right, then traverses the row below it, and so on.  In a right-to-left language environment, <Right arrow> moves the location cursor through all traversable controls, starting at the lower left and ending at the upper right.  <Left arrow> moves the location cursor through all traversable controls in the field in the order opposite to that of <Right arrow>.These rules ensure a consistent means of navigating among components using the directional keys. ___   ___   ___ 3-28:If a control uses <Right arrow> and <Left arrow> for internal navigation, <Begin> moves the location cursor to the leftmost edge of the data or the leftmost element in a left-to-right language environment.  In a right-to-left language environment, <Begin> moves the location cursor to the rightmost edge of the data or the rightmost element (IDREF="22203" TYPE="TITLE"Section 3.2.3, "Component Navigation"
).  This rule permits convenient navigation to the left or right edge of the data or the left or right element in a control. ___   ___   ___ 3-29:If a control uses <Right arrow> and <Left arrow> for internal navigation, <End> moves the location cursor to the rightmost edge of the data or the rightmost element in a left-to-right language environment.  In a right-to-left language environment, <End> moves the location cursor to the leftmost edge of the data or the leftmost element (IDREF="22203" TYPE="TITLE"Section 3.2.3, "Component Navigation"
).  This rule permits convenient navigation to the left or right edge of the data or the left or right element in a control. ___   ___   ___ 3-30:If a control uses <Up arrow> and <Down arrow> for internal navigation, <Ctrl> <Begin> moves the location cursor to one of the following (IDREF="22203" TYPE="TITLE"Section 3.2.3, "Component Navigation"
): The first element The topmost edge of the data In a left-to-right language environment, the topmost left edge of the data; in a right-to-left language environment, the topmost right edge of the data This rule permits convenient navigation to the beginning of the data in a control. ___   ___   ___ 3-31:If a control uses <Up arrow> and <Down arrow> for internal navigation, <Ctrl> <End> moves the location cursor to one of the following (IDREF="22203" TYPE="TITLE"Section 3.2.3, "Component Navigation"
): The last element The bottommost edge of the data In a left-to-right language environment, the bottommost right edge of the data; in a right-to-left language environment, the bottommost left edge of the data This rule permits convenient navigation to the end of the data in a control. LBL="B.3.3" HELPID=""Menu TraversalYes  N/A  No___   ___   ___ 3-32:If the user traverses to a Menu while the keyboard focus policy is implicit, the focus policy temporarily changes to explicit and reverts to implicit whenever the user traverses out of the Menu system (IDREF="40574" TYPE="TITLE"Section 3.3, "Menu Traversal"
).  Menus must always be traversable, even when the keyboard focus policy is generally implicit. ___   ___   ___ 3-33:Your application uses <F10> to activate the MenuBar system if it is inactive.  The location cursor is placed on the first traversable CascadeButton in the MenuBar.  If there are no traversable CascadeButtons, the key does nothing (IDREF="40574" TYPE="TITLE"Section 3.3, "Menu Traversal"
).  <F10> provides a consistent means of traversing to the MenuBar using the keyboard. ___   ___   ___ 3-34:When the keyboard focus is in an element with an inactive Popup Menu and the context of the element allows the Popup Menu to be displayed, your application uses <Menu> to activate the Popup Menu.  The location cursor is placed on the default item of the Menu, or on the first traversable item in the Popup Menu if there is no default item (IDREF="40574" TYPE="TITLE"Section 3.3, "Menu Traversal"
).  <Menu> provides a uniform way of activating a Popup Menu from the keyboard. ___   ___   ___ 3-35:When the keyboard focus is in an OptionButton, your application uses <Select> or <Space> to post the Option Menu.  The location cursor is placed on the previously selected item in the Option Menu; or, if the Option Menu has been pulled down for the first time, the location cursor is placed on the default item in the Menu.  If there is an active Option Menu, <Enter>,<Return>,<Select>,or <Space> selects the current item in the Option Menu, unposts the Menu system, and returns the location cursor to the OptionButton (IDREF="40574" TYPE="TITLE"Section 3.3, "Menu Traversal"
).  These keys provide a means of posting an Option Menu from the keyboard that is consistent across applications. ___   ___   ___ 3-36:Your application uses <Down arrow>,<Left arrow>,<Right arrow>,and <Up arrow> to traverse through the items in a Menu system (IDREF="40574" TYPE="TITLE"Section 3.3, "Menu Traversal"
).  The<Down arrow>,<Left arrow>,<Right arrow>,and <Up arrow> directional keys provide a consistent means of navigating among items in a Menu system. ___   ___   ___ 3-37:When a Menu traversal action traverses to the next or previous component in a Menu or MenuBar, the order of traversal and the wrapping behavior are the same as that of the corresponding component navigation action within a field, as described in IDREF="22203" TYPE="TITLE"Section 3.2.3, "Component Navigation"
 (IDREF="40574" TYPE="TITLE"Section 3.3, "Menu Traversal"
).  This specification provides consistency between Menu traversal and component navigation within a field. ___   ___   ___ 3-38:If your application uses any 2-dimensional Menus, they do not contain any CascadeButtons (IDREF="40574" TYPE="TITLE"Section 3.3, "Menu Traversal"
).  CascadeButtons in a 2-dimensional Menu would restrict the user's ability to navigate to all of the elements of the Menu using the keyboard. ___   ___   ___ 3-39:When focus is on a component in a Menu or MenuBar system, <Down arrow> behaves in the following way (IDREF="40574" TYPE="TITLE"Section 3.3, "Menu Traversal"
): If the component is in a vertical or 2-dimensional Menu, traverse down to the next traversable component, wrapping within the Menu if necessary.  If the component is in a MenuBar, and the component with the keyboard focus is a CascadeButton, post its associated Pulldown Menu and traverse to the default entry in the Menu or, if the Menu has no default, to the first traversable entry in the Menu.  This rule results in consistent operation of the directional keys in a Menu or MenuBar system. ___   ___   ___ 3-40:When focus is on a component in a Menu or MenuBar system, <Up arrow> behaves in the following way (IDREF="40574" TYPE="TITLE"Section 3.3, "Menu Traversal"
): If the component is in a vertical or 2-dimensional Menu, this action traverses up to the previous traversable component, wrapping within the Menu if necessary, and proceeding in the order opposite to that of <Down arrow>.This rule results in consistent operation of the directional keys in a Menu or MenuBar system. ___   ___   ___ 3-41:When focus is on a component in a Menu or MenuBar system, <Left arrow> behaves in the following way (IDREF="40574" TYPE="TITLE"Section 3.3, "Menu Traversal"
): If the component is in a MenuBar or 2-dimensional Menu, but not at the left edge, traverse left to the previous traversable component.  If the component is at the left edge of a MenuBar, wrap within the MenuBar.  If the component is at the left edge of a vertical or 2-dimensional Menu that is the child of a vertical or 2-dimensional Menu, unpost the current Menu and traverse to the parent CascadeButton.  If the component is at the left edge of a vertical or 2-dimensional Menu that is the child of a MenuBar, unpost the current Menu and traverse left to the previous traversable entry in the MenuBar.  If that entry is a CascadeButton, post its associated Pulldown Menu and traverse to the default entry in the Menu or, if the Menu has no default, to the first traversable entry in the Menu.  This rule results in consistent operation of the directional keys in a Menu or MenuBar system. ___   ___   ___ 3-42:When focus is on a component in a Menu or MenuBar system, <Right arrow> behaves in the following way (IDREF="40574" TYPE="TITLE"Section 3.3, "Menu Traversal"
): If the component is a CascadeButton in a vertical Menu, post its associated Pulldown Menu and traverse to the default entry in the Menu or, if the Menu has no default, to the first traversable entry in the Menu.  If the component is in a MenuBar or 2-dimensional Menu, but not at the right edge, traverse right to the next traversable component.  If the component is at the right edge of a MenuBar, wrap within the MenuBar.  If the component is not a CascadeButton and is at the right edge of a vertical or 2-dimensional Menu, and if the current Menu has an ancestor CascadeButton (typically in a MenuBar) from which <Down arrow> posts its associated Pulldown Menu, unpost the Menu system pulled down from the nearest such ancestor CascadeButton and traverse right from that CascadeButton to the next traversable component.  If that component is a CascadeButton, post its associated Pulldown Menu and traverse to the default entry in the Menu or, if the Menu has no default, to the first traversable entry in the Menu.  This rule results in consistent operation of the directional keys in a Menu or MenuBar system. ___   ___   ___ 3-43:All Menu traversal actions, with the exception of Menu posting, traverse to TearOffButtons in the same way as for other Menu entries (IDREF="40574" TYPE="TITLE"Section 3.3, "Menu Traversal"
).  Traversal of TearOffButtons needs to be consistent with traversal of other Menu items. ___   ___   ___ 3-44:If your application uses <F10>,<Menu>,or <Cancel> to unpost an entire Menu system and an explicit focus policy is in use, the location cursor is moved back to the component that had it before the Menu system was posted (IDREF="40574" TYPE="TITLE"Section 3.3, "Menu Traversal"
).  Returning the location cursor to the component that had it previously allows the user to resume a task without disruption. LBL="B.3.4" HELPID=""Scrollable Component NavigationYes  N/A  No___   ___   ___ 3-45:Any scrollable components within your application support the appropriate navigation and scrolling operations.  Your application uses the page navigation keys <PageUp>,<PageDown>,<PageLeft> or <Ctrl> <PageUp>,and <PageRight> or <Ctrl> <PageDown> for scrolling the visible region by a page increment (IDREF="29873" TYPE="TITLE"Section 3.4, "Scrollable Component Navigation"
).  A user needs to be able to view and access the entire contents of a scrollable component. ___   ___   ___ 3-46:When scrolling by a page, your application leaves at least one unit of overlap between the old and new pages (IDREF="29873" TYPE="TITLE"Section 3.4, "Scrollable Component Navigation"
).  The overlap between one page and the next yields visual continuity for the user. ___   ___   ___ 3-47:Any keyboard operation that moves the cursor to or in the component, or that inserts, deletes, or modifies items at the cursor location scrolls the component so that the cursor is visible when the operation is complete (IDREF="29873" TYPE="TITLE"Section 3.4, "Scrollable Component Navigation"
).  The user needs to be able to see the results of moving the location cursor or operating on the contents of the scrollable component. ___   ___   ___ 3-48:If a mouse-based scrolling action is in progress, <Cancel> cancels the scrolling action and returns the scrolling device to its state prior to the start of the scrolling operation (IDREF="29873" TYPE="TITLE"Section 3.4, "Scrollable Component Navigation"
).  <Cancel> provides a convenient way for the user to cancel a scrolling operation. LBL="B.4" HELPID=""SelectionLBL="B.4.1" HELPID=""Selection ModelsYes  N/A  No___   ___   ___ 4-1:Your system supports five selection models: single selection, browse selection, multiple selection, range selection, and discontiguous selection (IDREF="12200" TYPE="TITLE"Section 4.1, "Selection Models"
).  Each collection has one or more appropriate selection models.  The model limits the kinds of choices the user can make in the collection.  Some collections enforce a selection model, while others allow the user or application to change it. LBL="" HELPID=""Mouse-Based Single SelectionYes  N/A  No___   ___   ___ 4-2:In a collection that uses single selection, when BSelect is clicked in a deselected element, the location cursor moves to that element, that element is selected, and any other selection in the collection is deselected (IDREF="40662" TYPE="TITLE"Section 4.1.1, "Mouse-Based Single Selection"
).  Single selection is the simplest selection model, used to select a single element.  BSelect, the first mouse button, provides a consistent means of selecting an object within a group using the mouse. LBL="" HELPID=""Mouse-Based Browse SelectionYes  N/A  No___   ___   ___ 4-3:In a collection that uses browse selection, when BSelect is released in a selectable element, that element is selected, and any other selection in the collection is deselected.  As BSelect is dragged through selectable elements, each element under the pointer is selected, and the previously selected element is deselected.  The selection remains on the element where BSelect is released, and the location cursor is moved there (IDREF="35080" TYPE="TITLE"Section 4.1.2, "Mouse-Based Browse Selection"
).  Browse selection is used to select a single element.  It also allows the user to browse through the collection by dragging BSelect.  LBL="" HELPID=""Mouse-Based Multiple SelectionYes  N/A  No___   ___   ___ 4-4:In a collection that uses multiple selection, clicking BSelect on an unselected element adds that element to the current selection in the collection.  Clicking BSelect on a selected element removes that element from the current selection in the collection.  Clicking BSelect on an element moves the location cursor to that element (IDREF="17616" TYPE="TITLE"Section 4.1.3, "Mouse-Based Multiple Selection"
).  Multiple selection allows the user to select or deselect multiple elements of a collection, one at a time, by using BSelect Click.  LBL="" HELPID=""ID="14760"Mouse-Based Range SelectionYes  N/A  No___   ___   ___ 4-5:In a collection that uses range selection, pressing BSelect sets an anchor on the element, or at the position where BSelect was pressed, and deselects all elements in the collection.  The anchor and the current position of the pointer determine the current range.  As BSelect is dragged through the collection, the current range is highlighted.  When BSelect is released, the anchor does not move, and all the elements within the current range are selected (IDREF="35475" TYPE="TITLE"Section 4.1.4, "Mouse-Based Range Selection"
).  Range selection allows the user to select multiple contiguous elements of a collection by pressing and dragging BSelect.  ___   ___   ___ 4-6:In a text-like collection that uses range selection, the anchor point is the text pointer position when BSelect is pressed, and the current range consists of all elements between the anchor point and the current text pointer position (IDREF="35475" TYPE="TITLE"Section 4.1.4, "Mouse-Based Range Selection"
).  In text-like collections, elements are ordered linearly, and a text pointer is always considered to be between elements at a point near the actual pointer position. ___   ___   ___ 4-7:In a graphics-like or list-like collection that uses a marquee to indicate the range of a range selection, the current range consists of those elements that fall completely within the marquee.  If there is an anchor element, the marquee is always made large enough to enclose it completely.  Otherwise, an anchor point is used and is the point at which BSelect was pressed; the anchor point determines one corner of the marquee.  If the collection is not arranged as a list or matrix, the marquee is extended to the pointer position.  If the collection is arranged as a list or matrix, the marquee is either extended to completely enclose the element under the pointer or extended to the pointer position.  Clicking BSelect on a selectable element makes it an anchor element, selects it, and deselects all other elements (IDREF="35475" TYPE="TITLE"Section 4.1.4, "Mouse-Based Range Selection"
).  A marquee, or highlighted rectangle, is often used to indicate the range of a selection in graphics-like and list-like collections. ___   ___   ___ 4-8:In a collection that uses range selection, when the user presses <Shift> BSelect, the anchor remains unchanged, and an extended range for the selection is determined, based on one of the following extension models (IDREF="35475" TYPE="TITLE"Section 4.1.4, "Mouse-Based Range Selection"
): ReselectThe extended range is determined by the anchor and the current pointer position, in exactly the same manner as when the selection was initially made.  Enlarge OnlyThe selection can only be enlarged.  The extended range is determined by the anchor and the current pointer position, but then is enlarged to include the current selection.  Balance BeamA balance point is defined at the midpoint of the current selection.  When the user presses <Shift> BSelect on the opposite side of the balance point from the anchor, this model works exactly like the Reselect model.  When the user presses <Shift> BSelect or starts a navigation action modified by <Shift> on the same side of the balance point as the anchor, this model moves the anchor to the opposite end of the selection and then works exactly like the Reselect model.  When the user releases BSelect, the anchor does not move, all the elements within the extended range are selected, and all the elements outside of it are deselected (IDREF="35475" TYPE="TITLE"Section 4.1.4, "Mouse-Based Range Selection"
).  <Shift> BSelect provides a convenient means of extending the range of a selection. LBL="" HELPID=""ID="22248"Mouse-Based Discontiguous SelectionYes  N/A  No___   ___   ___ 4-9:In a collection that uses discontiguous selection, the behavior of BSelect is exactly the same as in the range selection model.  After the user sets the anchor with BSelect, <Shift> BSelect works exactly as in the range selection model (IDREF="37548" TYPE="TITLE"Section 4.1.5, "Mouse-Based Discontiguous Selection"
).  Discontiguous selection is an extension of range selection that allows the user to select multiple discontiguous ranges of elements. ___   ___   ___ 4-10:In a collection that uses discontiguous selection, when the current selection is not empty and the user clicks <Ctrl> BSelect, the anchor and location cursor move to that point.  If the current selection is not empty and the user clicks <Ctrl> BSelect on an element, the selection state of that element is toggled, and that element becomes the anchor element (IDREF="37548" TYPE="TITLE"Section 4.1.5, "Mouse-Based Discontiguous Selection"
).  In discontiguous selection, <Ctrl> BSelect Click provides a convenient means of moving the anchor and toggling the selection state of the element under the pointer. ___   ___   ___ 4-11:In a collection that uses discontiguous selection, <Ctrl> BSelect Motion toggles the selection state of a range of elements.  The range itself is determined exactly as for BSelect Motion.  Releasing <Ctrl> BSelect toggles the selection state of the elements in the range according to one of two models (IDREF="37548" TYPE="TITLE"Section 4.1.5, "Mouse-Based Discontiguous Selection"
): Anchor ToggleToggling is based on an anchor element.  If the range is anchored by a point, and is not empty, the anchor element is set to the element within the range that is nearest to the anchor point.  Toggling sets the selection state of all elements in the range to the inverse of the initial state of the anchor element.  Full ToggleThe selection state of each element in the extended range is toggled.  In discontiguous selection, <Ctrl> BSelect provides a convenient means of toggling the selection state of elements in a range. ___   ___   ___ 4-12:In a collection that uses discontiguous selection, after <Ctrl> BSelect toggles a selection, <Shift> BSelect or <Ctrl> <Shift> BSelect extends the range of toggled elements.  The extended range is determined in exactly the same way as when <Shift> BSelect is used to extend a range selection.  When the user releases <Ctrl> <Shift> BSelect the selection state of elements added to the range is determined by the toggle model in use (either Anchor Toggle or Full Toggle).  If elements are removed from the range, they either revert to their state prior to the last use of <Ctrl> BSelect or change to the state opposite that of the elements remaining within the extended range (IDREF="37548" TYPE="TITLE"Section 4.1.5, "Mouse-Based Discontiguous Selection"
).  <Shift> BSelect and <Ctrl> <Shift> BSelect provide a convenient means of extending the range of toggled elements. LBL="" HELPID=""Keyboard SelectionYes  N/A  No___   ___   ___ 4-13:The selection models support keyboard selection modes according to the following rules (IDREF="22109" TYPE="TITLE"Section 4.1.6, "Keyboard Selection"
): Single selection supports only add mode.  Browse selection supports only normal mode.  Multiple selection supports only add mode.  Range selection supports normal mode.  If it also supports add mode, normal mode is the default.  Discontiguous selection supports both normal mode and add mode.  Normal mode is the default.  Selection must be available from the keyboard.  In normal mode, used for making simple contiguous selections from the keyboard, the location cursor is never disjoint from the current selection.  In add mode, used for making more complex and possibly disjoint selections, the location cursor can move independent of the current selection. ___   ___   ___ 4-14:If a collection supports both normal mode and add mode, <Shift> <F8> switches from one mode to the other.  Mouse-based selection does not change when the keyboard selection mode changes.  In editable components, add mode is a temporary mode that is exited when the user performs an operation on the selection or deselects the selection (IDREF="22109" TYPE="TITLE"Section 4.1.6, "Keyboard Selection"
).  <Shift> <F8> provides a convenient means of switching between normal mode and add mode. Keyboard-Based Single SelectionYes  N/A  No___   ___   ___ 4-15:In a collection that uses single selection, the navigation keys move the location cursor independent from the selected element.  If the user presses <Select> or <Space> on an unselected element, the element with the location cursor is selected, and any other selection in the collection is deselected (IDREF="23133" TYPE="TITLE""Keyboard-Based Single Selection" in Chapter 4
).  Single selection supports only add mode.  Pressing <Select> or<Space> is similar to clickingBSelect.Keyboard-Based Browse SelectionYes  N/A  No___   ___   ___ 4-16:In a collection that uses browse selection, the navigation keys move the location cursor and select the cursored element, deselecting any other element.  If the application has deselected all elements or if the cursor is left disjoint from the selection, <Select> or <Space> selects the cursored element and deselects any other element (IDREF="10369" TYPE="TITLE""Keyboard-Based Browse Selection" in Chapter 4
).  Browse selection supports only normal mode.  A navigation operation is similar to dragging BSelect.Keyboard-Based Multiple SelectionYes  N/A  No___   ___   ___ 4-17:In a collection that uses multiple selection, the navigation keys move the location cursor independent from the current selection.  <Select> or <Space> on an unselected element adds the element to the current selection.  <Select> or <Space> on a selected element removes the element from the current selection (IDREF="41052" TYPE="TITLE""Keyboard-Based Multiple Selection" in Chapter 4
).  Multiple selection supports only add mode.  Pressing <Select> or<Space> is similar to clickingBSelect.Keyboard-Based Range SelectionYes  N/A  No___   ___   ___ 4-18:In a collection that uses range selection and is in normal mode, the navigation keys move the location cursor and deselect the current selection.  If the cursor is on an element, it is selected.  The anchor moves with the location cursor.  Text-like collections can use a different model in which the navigation keys leave the anchor at its current location, except that, if the current selection is not empty, it is deselected and the anchor is moved to the location of the cursor prior to navigation (IDREF="13340" TYPE="TITLE""Keyboard-Based Range Selection" in Chapter 4
).  Range selection supports normal mode, and, if the collection also supports add mode, normal mode is the default. ___   ___   ___ 4-19:In a collection that uses range selection, whether in normal mode or add mode, <Select> or <Space> (except in a Text component) moves the anchor to the cursor, deselects the current selection, and, if the cursor is on an element, selects the element.  Unless the anchor is on a deselected item, <Shift> <Select> or <Shift> <Space> (except in Text) extends the selection from the anchor to the cursor, based on the extension model used by <Shift> BSelect (Reselect, Enlarge Only, or Balance Beam) (IDREF="13340" TYPE="TITLE""Keyboard-Based Range Selection" in Chapter 4
).  In range selection, pressing <Select> or<Space> is similar to clickingBSelect, and pressing <Shift> <Select> or<Shift> <Space> extends the range as with<Shift> BSelect.___   ___   ___ 4-20:In a collection that uses range selection and is in normal mode, using <Shift> in conjunction with the navigation keys extends the selection, based on the extension model used by <Shift> BSelect.  If the current selection is empty, the anchor is first moved to the cursor.  The cursor is then moved according to the navigation keys, and the selection is extended based on the extension model used by <Shift> BSelect (IDREF="13340" TYPE="TITLE""Keyboard-Based Range Selection" in Chapter 4
).  In range selection, shifted navigation extends the selection in a similar manner to dragging <Shift> BSelect.___   ___   ___ 4-21:In a collection that uses range selection and is in add mode, the navigation keys move the location cursor but leave the anchor unchanged.  Shifted navigation moves the location cursor according to the navigation keys, and the selection is extended based on the extension model used by <Shift> BSelect (IDREF="13340" TYPE="TITLE""Keyboard-Based Range Selection" in Chapter 4
).  Shifted navigation in add mode is similar to shifted navigation in normal mode, except that when the selection is empty the anchor does not move to the cursor prior to navigation. Keyboard-Based Discontiguous SelectionYes  N/A  No___   ___   ___ 4-22:In a collection that uses discontiguous selection and is in normal mode, all keyboard operations have the same effect as in the range selection model (IDREF="18552" TYPE="TITLE""Keyboard-Based Discontiguous Selection" in Chapter 4
).  Normal mode does not permit multiple discontiguous selections. ___   ___   ___ 4-23:In a collection that uses discontiguous selection and is in add mode, <Select> or <Space> moves the anchor to the location cursor and initiates toggling.  If the cursor is on an element, the selection state of that element is toggled, but the selection state of all other elements remains unchanged.  <Shift> <Select> or <Shift> <Space> and shifted navigation operations extend the selection between the anchor and the location cursor, based on the toggle mechanism used by <Ctrl> BSelect (Anchor Toggle or Full Toggle) (IDREF="18552" TYPE="TITLE""Keyboard-Based Discontiguous Selection" in Chapter 4
).  Add mode permits use of the keyboard to make multiple discontiguous selections. LBL="" HELPID=""Canceling a SelectionYes  N/A  No___   ___   ___ 4-24:Your application uses <Cancel> to cancel or undo any incomplete motion operation used for selection.  Once the user presses <Cancel> to cancel a motion operation, the application ignores subsequent key and button releases until after all buttons and keys are released.  <Cancel> while extending or toggling leaves the selection state of all elements as they were prior to the button press (IDREF="19005" TYPE="TITLE"Section 4.1.7, "Canceling a Selection"
).  <Cancel> allows the user to cancel an incomplete selection operation quickly and consistently. LBL="" HELPID=""Autoscrolling and SelectionYes  N/A  No___   ___   ___ 4-25:If the user drags the pointer out of a scrollable collection during a motion-based selection operation, autoscrolling is used to scroll the collection in the direction of the pointer.  If the user presses <Cancel> with BSelect pressed, the selection operation is canceled as described in IDREF="19005" TYPE="TITLE"Section 4.1.7, "Canceling a Selection"
 (IDREF="20267" TYPE="TITLE"Section 4.1.8, "Autoscrolling and Selection"
).  Autoscrolling provides a convenient means of extending a selection to elements outside the viewport of a scrollable collection. LBL="" HELPID=""Selecting and Deselecting All ElementsYes  N/A  No___   ___   ___ 4-26:In a collection that uses multiple, range, or discontiguous selection, <Ctrl> </> selects all the elements in the collection, places the anchor at the beginning of the collection, and leaves the location cursor at its previous position (IDREF="15181" TYPE="TITLE"Section 4.1.9, "Selecting and Deselecting All Elements"
).  <Ctrl> </> provides the user with a convenient means of selecting all of the objects in a collection. ___   ___   ___ 4-27:In a collection that is in add mode, <Ctrl> <\> deselects all the elements in the collection.  In a collection that is in normal mode, <Ctrl> <\> deselects all the elements in the collection, except the element with the location cursor if the location cursor is being displayed.  In either mode, <Ctrl> <\> leaves the location cursor at its current position and moves the anchor to the location cursor (IDREF="15181" TYPE="TITLE"Section 4.1.9, "Selecting and Deselecting All Elements"
).  <Ctrl> <\> allows the user to deselect all of the selected objects quickly and uniformly. LBL="" HELPID=""Using Mnemonics for ElementsYes  N/A  No___   ___   ___ 4-28:If your application supports mnemonics associated with selectable elements, typing a mnemonic while the collection has the keyboard focus is equivalent to moving the location cursor to the element and pressing <Select> or <Space> (IDREF="22746" TYPE="TITLE"Section 4.1.10, "Using Mnemonics for Elements"
).  Mnemonics within a collection of selectable elements provide an additional selection method. LBL="B.4.2" HELPID=""Selection ActionsYes  N/A  No___   ___   ___ 4-29:When the keyboard focus policy is explicit, the destination component is the editable component that last had the keyboard focus.  When the keyboard focus policy is implicit, the destination component is the editable component that last received mouse button or keyboard input (IDREF="24375" TYPE="TITLE"Section 4.2.1, "Destination Component"
).  The destination component is used to identify the component on which certain operations, primarily data transfer operations, act.  There is only one destination component at a time. ___   ___   ___ 4-30:If the keyboard focus is in a component (or a Popup Menu of a component) that supports selections, operations that act on a selection act on the selection in that component (IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets"
).  A selection operation acts on the component that has focus, if that component supports selections. ___   ___   ___ 4-31:If the keyboard focus is in a component (or a Popup Menu of a component) that supports some operation that does not act on a selection, invoking the operation acts on that component (IDREF="29313" TYPE="TITLE"Section 4.2.2, "Operation Targets"
).  An operation that does not act on a selection acts on the component that has focus, if that component supports the operation. ___   ___   ___ 4-32:Inserting or pasting elements into a selection, except for a primary transfer operation at the bounds of the primary selection, first deletes the selection if pending delete is enabled (IDREF="14005" TYPE="TITLE"Section 4.2.3, "Selection Operations"
).  Pending delete controls the conditions under which the selection is deleted.  It is enabled by default. ___   ___   ___ 4-33:In normal mode, inserting or pasting elements disjoint from the selection also deselects the selection, except for primary transfer operations whose source and destination are in the same collection.  In add mode, the selection is not deselected (IDREF="14005" TYPE="TITLE"Section 4.2.3, "Selection Operations"
).  In add mode, a transfer operation that is disjoint from the selection does not affect the selection. ___   ___   ___ 4-34:In editable list-like and graphics-like collections, <Delete> deletes the selected elements (IDREF="14005" TYPE="TITLE"Section 4.2.3, "Selection Operations"
).  <Delete> provides a consistent means of deleting the selection. ___   ___   ___ 4-35:In editable text-like collections, <Delete> and <BackSpace> behave as follows: If the selection is not empty and the control is in normal mode, the selection is deleted.  If the selection is not empty, the control is in add mode, and the cursor is not disjoint from the selection, the selection is deleted.  If the selection is not empty and the control is in add mode, but the cursor is disjoint from the selection, <Delete> deletes one character forward, and <BackSpace> deletes one character backward.  If the selection is empty, <Delete> deletes one character forward, and <BackSpace> deletes one character backward.  In text, <Delete> and<BackSpace> provide a convenient way to delete the entire selection or single characters. LBL="B.4.3" HELPID=""Transfer ModelsYes  N/A  No___   ___   ___ 4-36:If the move, copy, or link operation the user requests is not available, the transfer operation fails (IDREF="21864" TYPE="TITLE"Section 4.3, "Transfer Models"
).  Three transfer operations are generally available: copy, move, and link.  The user requests one of these operations by pressing the buttons or keys appropriate for the type of transfer.  In general, for mouse-based operations, the modifier <Ctrl> forces a copy,<Shift> forces a move, and<Ctrl> <Shift> forces a link.  However, any requested transfer operation must fail if that operation is not available. ___   ___   ___ 4-37:If a collection does not have a fixed insertion point or keep elements ordered in a specific way, the insertion position for transferred data is determined as follows (IDREF="21864" TYPE="TITLE"Section 4.3, "Transfer Models"
): For BTransfer-based primary and drag transfer operations, the insertion position is the position at which the user releases BTransfer.  In a text-like collection, the insertion position for other transfer operations is the location cursor, and the data is pasted before it.  In a list-like collection, the insertion position for other transfer operations is the element with the location cursor, and the data is pasted before it.  The insertion position is the position in the destination where transferred data is placed.  Some mouse-based transfer operations place data at the pointer position if possible.  Other operations, including keyboard-based transfer, generally place the data at the location cursor. LBL="" HELPID=""Clipboard TransferYes  N/A  No___   ___   ___ 4-38:Keyboard-based clipboard selection actions are available in every editable collection in your application (IDREF="12791" TYPE="TITLE"Section 4.3.1, "Clipboard Transfer"
).  Clipboard selection actions need to be available from the keyboard. ___   ___   ___ 4-39:Your application uses <Cut> or <Shift> <Delete> and the Cut entry on the Edit Menu to cut the selected elements from an editable component to the clipboard (IDREF="12791" TYPE="TITLE"Section 4.3.1, "Clipboard Transfer"
).  <Cut> or <Shift> <Delete> and theCut entry on the Edit Menu offer a consistent means of cutting the selection to the clipboard from the keyboard. ___   ___   ___ 4-40:Your application uses <Copy> or <Ctrl> <Insert> and the Copy entry on the Edit Menu to copy the selected elements to the clipboard (IDREF="12791" TYPE="TITLE"Section 4.3.1, "Clipboard Transfer"
).  <Copy> or <Ctrl> <Insert> and theCopy entry on the Edit Menu offer a consistent means of copying the selection to the clipboard from the keyboard. ___   ___   ___ 4-41:Your application uses <Paste> or <Shift> <Insert> to paste the contents of the clipboard into an editable component (IDREF="12791" TYPE="TITLE"Section 4.3.1, "Clipboard Transfer"
).  <Paste> or <Shift> <Insert> offers a consistent way of pasting the contents of the clipboard from the keyboard. ___   ___   ___ 4-42:If Paste or Paste Link is invoked using a component's Popup Menu, the data is pasted at the insertion position of the component.  However, if the Popup Menu is popped up over a selection, the selection is first deleted, even if pending delete is disabled, and the pasted data replaces it, if possible (IDREF="12791" TYPE="TITLE"Section 4.3.1, "Clipboard Transfer"
).  Popping up a Popup Menu over a selection indicates that a Paste or Paste Link operation should replace the selection. ___   ___   ___ 4-43:If Paste or Paste Link is invoked from the Edit Menu or by a keyboard operation, and the insertion position in the target component is not disjoint from a selection, the pasted data replaces the selection contents if pending delete is enabled (IDREF="12791" TYPE="TITLE"Section 4.3.1, "Clipboard Transfer"
).  Pending delete determines whether the selection is deleted when the insertion position is not disjoint from the selection and Paste or Paste Link is invoked from the Edit Menu or by a keyboard operation. LBL="" HELPID=""Primary TransferYes  N/A  No___   ___   ___ 4-44:In an editable collection, BTransfer Click, <Ctrl> BTransfer Click, <Alt> <Copy>,and <Alt> <Ctrl> <Insert> copy the primary selection to the insertion position, as defined in IDREF="21864" TYPE="TITLE"Section 4.3, "Transfer Models."
  (Note that the insertion position is usually different for mouse and keyboard operations.) (IDREF="39087" TYPE="TITLE"Section 4.3.2, "Primary Transfer"
).These operations provide a convenient way for the user to force a copy operation. ___   ___   ___ 4-45:In an editable collection, <Shift> BTransfer Click, <Alt> <Cut>,and <Alt> <Shift> <Delete> move the primary selection to the insertion position, as defined in IDREF="21864" TYPE="TITLE"Section 4.3, "Transfer Models."
  (Note that the insertion position is usually different for mouse and keyboard operations.) (IDREF="39087" TYPE="TITLE"Section 4.3.2, "Primary Transfer"
) These operations provide a convenient way for the user to force a move operation. ___   ___   ___ 4-46:In an editable collection, <Ctrl> <Shift> BTransfer Click places a link to the primary selection at the insertion position, as defined in IDREF="21864" TYPE="TITLE"Section 4.3, "Transfer Models."
 (IDREF="39087" TYPE="TITLE"Section 4.3.2, "Primary Transfer"
).  <Ctrl> <Shift> BTransfer provides a convenient way for the user to force a link operation. ___   ___   ___ 4-47:A Primary Move moves the primary selection as well as the elements selected; that is, the element moved to the destination becomes selected as the primary selection.  Primary Copy and Primary Link do not select transferred data at the destination (IDREF="39087" TYPE="TITLE"Section 4.3.2, "Primary Transfer"
).  This rule provides the expected treatment of the selection in move, copy, and link operation. LBL="" HELPID=""Quick TransferYes  N/A  No___   ___   ___ 4-48:All Text components support quick transfer (IDREF="33280" TYPE="TITLE"Section 4.3.3, "Quick Transfer"
).  Quick transfer is used to make a temporary selection and then immediately move, copy, or link that selection to the insertion position of the destination component.  In Text quick transfer provides a convenient way to move, copy, or link text without disturbing the primary selection. ___   ___   ___ 4-49:If a component supports quick transfer, <Alt> BTransfer Motion or <Alt> <Ctrl> BTransfer Motion temporarily selects elements in the specified range and, on release, copies them to the insertion position of the destination component (IDREF="33280" TYPE="TITLE"Section 4.3.3, "Quick Transfer"
).  These operations provide a convenient way to perform a quick copy. ___   ___   ___ 4-50:If a component supports quick transfer, <Alt> <Shift> BTransfer Motion temporarily selects elements in the specified range and, on release, moves them to the insertion position of the destination component (IDREF="33280" TYPE="TITLE"Section 4.3.3, "Quick Transfer"
).  This operation provides a convenient way to perform a quick cut. ___   ___   ___ 4-51:If a component supports quick transfer, <Alt> <Ctrl> <Shift> BTransfer Motion temporarily selects elements in the specified range and, on release, places a link to them at the insertion position of the destination component (IDREF="33280" TYPE="TITLE"Section 4.3.3, "Quick Transfer"
).  This operation provides a convenient way to perform a quick link. ___   ___   ___ 4-52:Quick transfer does not disturb the primary selection or affect the clipboard, except when the destination of the transfer is within or on the boundaries of the primary selection and pending delete is enabled.  In this case, quick transfer deletes the contents of the primary selection, leaving an empty primary selection, before pasting the transferred elements (IDREF="33280" TYPE="TITLE"Section 4.3.3, "Quick Transfer"
).  Quick transfer is a secondary selection mechanism, so it cannot disrupt the primary selection.  When the destination of the transfer is in the primary selection, quick transfer replaces the primary selection with the secondary selection. ___   ___   ___ 4-53:With quick transfer, the range of the temporary selection is determined by using the same model as when BSelect Motion determines the range of a primary selection (IDREF="33280" TYPE="TITLE"Section 4.3.3, "Quick Transfer"
).  This rule provides consistency between primary selection and quick transfer operations. ___   ___   ___ 4-54:If the user drags the pointer out of a scrollable collection while making the temporary selection, autoscrolling is used to scroll the collection in the direction of the pointer.  If the user releases BTransfer with the pointer outside of the collection, or if the user presses <Cancel> with BTransfer pressed, the highlighting is removed and a transfer is not performed (IDREF="33280" TYPE="TITLE"Section 4.3.3, "Quick Transfer"
).  Autoscrolling provides a convenient means of extending a temporary selection to elements outside the viewport of a scrollable collection. LBL="" HELPID=""Drag TransferYes  N/A  No___   ___   ___ 4-55:In a collection that supports selection, <Shift> BTransfer Release forces a drag move operation.  If a move is not possible, the operation fails (IDREF="14546" TYPE="TITLE"Section 4.3.4, "Drag Transfer"
).  This mechanism offers a convenient way for the user to force a move operation. ___   ___   ___ 4-56:In a collection that supports selection, <Ctrl> BTransfer Release forces a drag copy operation.  If a copy is not possible, the operation fails (IDREF="14546" TYPE="TITLE"Section 4.3.4, "Drag Transfer"
).  This mechanism offers a convenient way for the user to force a copy operation. ___   ___   ___ 4-57:In a collection that supports selection, <Ctrl> <Shift> BTransfer Release forces a drag link operation.  If a link is not possible, the operation fails (IDREF="14546" TYPE="TITLE"Section 4.3.4, "Drag Transfer"
).  This mechanism offers a convenient way for the user to force a link operation. ___   ___   ___ 4-58:When a drag move operation moves a selection within the same component, the selection moves along with the elements selected (IDREF="14546" TYPE="TITLE"Section 4.3.4, "Drag Transfer"
).  This mechanism offers a convenient way to move the selection within a component. ___   ___   ___ 4-59:In text-like collections, initiating a drag within a selected region drags the entire text selection (IDREF="14546" TYPE="TITLE"Section 4.3.4, "Drag Transfer"
 and IDREF="37315" TYPE="TITLE"Section 4.3.5, "Integrating Selection and Transfer"
).  To be consistent, drag and drop actions need to operate on the entire selection. ___   ___   ___ 4-60:In list-like and graphics-like collections, initiating a drag on a selected element drags the entire selection (IDREF="14546" TYPE="TITLE"Section 4.3.4, "Drag Transfer"
 and IDREF="37315" TYPE="TITLE"Section 4.3.5, "Integrating Selection and Transfer"
).  To be consistent, drag and drop actions need to operate on the entire selection. ___   ___   ___ 4-61:In list-like and graphics-like collections, initiating a drag with BTransfer on an unselected element drags just that element and leaves the selection unaffected (IDREF="14546" TYPE="TITLE"Section 4.3.4, "Drag Transfer"
).  Unselected elements can be dragged without affecting the selection. ___   ___   ___ 4-62:When a drag is initiated in an unselected region and the pointer is over two possible draggable elements, the drag uses the highest draggable element in the stacking order (IDREF="14546" TYPE="TITLE"Section 4.3.4, "Drag Transfer"
).  This guideline ensures the consistency of drag operations. ___   ___   ___ 4-63:When your application starts a drag operation, the pointer is replaced with a drag icon (IDREF="29854" TYPE="TITLE""Drag Icons" in Chapter 4
).  A drag icon provides visual feedback that a drag operation is in progress. ___   ___   ___ 4-64:All drag icons used by your application include a source indicator (IDREF="29854" TYPE="TITLE""Drag Icons" in Chapter 4
).  A source indicator gives a visual representation of the elements being dragged. ___   ___   ___ 4-65:Pressing <Cancel> ends a drag and drop operation by canceling the drag in progress (IDREF="33182" TYPE="TITLE""During a Drag" in Chapter 4
).  <Cancel> provides a consistent way for the user to cancel a drag operation. ___   ___   ___ 4-66:Releasing BTransfer ends a drag and drop operation (IDREF="10867" TYPE="TITLE""Ending a Drag" in Chapter 4
).  Releasing BTransfer offers a consistent means of ending a drag operation. ___   ___   ___ 4-67:When BTransfer is released, the drop operation ordinarily occurs at the location of the hotspot of the drag icon pointer and into the highest drop site in the stacking order.  However, if a drop occurs within a selection and pending delete is enabled, the transferred data replaces the contents of the entire selection (IDREF="10867" TYPE="TITLE""Ending a Drag" in Chapter 4
).  This rule provides consistency in the treatment of mouse-based transfer operations. ___   ___   ___ 4-68:After a successful transfer, the data is placed in the drop site, and any transfer icon used by your application is removed (IDREF="29666" TYPE="TITLE""Drop Results" in Chapter 4
).  A transfer icon can be used to represent the type of data being transferred during a drop operation.  A successful drop operation results in the transfer of data. ___   ___   ___ 4-69:After a failed transfer, the data remains at the drag source and is not placed in the drop site.  Any transfer icon used by your application is removed (IDREF="29666" TYPE="TITLE""Drop Results" in Chapter 4
).  A failed drop operation does not result in the transfer of data. LBL="B.5" HELPID=""Component ActivationLBL="B.5.1" HELPID=""Basic ActivationYes  N/A  No___   ___   ___ 5-1:Your application uses BSelect to activate a button (IDREF="10735" TYPE="TITLE"Section 5.1, "Basic Activation"
).  BSelect, the first mouse button, provides a consistent means of activating a button using the mouse. ___   ___   ___ 5-2:When a button has the focus, your application uses <Select> or <Space> to activate the button (IDREF="10735" TYPE="TITLE"Section 5.1, "Basic Activation"
).  <Select> and <Space> provide a uniform way of selecting a button.  Selecting a button is equivalent to activating the button. ___   ___   ___ 5-3:When an activatable Menu entry has the focus, your application uses <Select>,<Space>,<Enter>,or <Return> to activate the entry (IDREF="10735" TYPE="TITLE"Section 5.1, "Basic Activation"
).  <Select>,<Space>,<Enter>, and <Return> offer a consistent means of activating a Menu entry using the keyboard. ___   ___   ___ 5-4:When BSelect is pressed over a button, the appearance of the button changes to indicate that releasing BSelect will activate the button.  If while BSelect is pressed the pointer is moved outside of the button, the visual state is restored.  If while BSelect is still pressed the pointer is moved back inside of the button, the visual state is again changed to indicate the pending activation.  If BSelect is pressed and released within a button, the button is activated, regardless of whether the pointer has moved out of the button while it was pressed (IDREF="10735" TYPE="TITLE"Section 5.1, "Basic Activation"
).  The visual state of a button offers a cue to the user about whether or not the button will be activated when the mouse button is released. ___   ___   ___ 5-5:If a selectable element of a collection is activatable, BSelect Click, <Select>,and <Space> (except in Text) select it.  BSelect Click 2 selects and activates it (IDREF="10735" TYPE="TITLE"Section 5.1, "Basic Activation"
).  This rule provides for consistent integration of activation and selection in a collection where elements can be both selected and activated. LBL="B.5.2" HELPID=""AcceleratorsYes  N/A  No___   ___   ___ 5-6:If your application uses accelerators, the component with the accelerator displays the accelerator key or key combination following the Label of the component (IDREF="39548" TYPE="TITLE"Section 5.2, "Accelerators"
).  An accelerator is a key or key combination that invokes the action of some component regardless of the position of the location cursor when the accelerator is pressed.  So that the user knows that there is an accelerator associated with a component, the accelerator needs to be displayed. ___   ___   ___ 5-7:If a button with an accelerator is within a primary or secondary window, or within a Pulldown Menu system from its MenuBar, it is activatable whenever the input focus is in the window or the MenuBar system.  If a button with an accelerator is within a Popup Menu system, it is activatable whenever the focus is in the Popup Menu system or the component with the Popup Menu (IDREF="39548" TYPE="TITLE"Section 5.2, "Accelerators"
).  An accelerator must be activatable from the window or component associated with the accelerator. LBL="B.5.3" HELPID=""MnemonicsYes  N/A  No___   ___   ___ 5-8:If your application uses mnemonics, the Label for the component with the mnemonic contains the character that is its mnemonic.  If the Label does not naturally contain the character, the mnemonic is placed in parentheses following the Label (IDREF="34761" TYPE="TITLE"Section 5.3, "Mnemonics"
).  A mnemonic is a single character that can be associated with any component that contains a text Label.  Mnemonics provide a fast way of selecting a component from the keyboard.  So that the user knows that there is a mnemonic associated with a selection, the mnemonic is underlined in the Label of the selection by the toolkit.  In order for a mnemonic to be underlined, the Label for a selection needs to contain the mnemonic character.  Putting the mnemonic in parentheses following the Label provides visual consistency. ___   ___   ___ 5-9:All mnemonics are case insensitive for activation (IDREF="34761" TYPE="TITLE"Section 5.3, "Mnemonics"
).  The user must be able to activate a mnemonic by pressing either the lowercase or the uppercase variant of the mnemonic key.___   ___   ___ 5-10:When the location cursor is within a Menu or a MenuBar, pressing the mnemonic key of a component within that Menu or MenuBar moves the location cursor to the component and activates it.  If a mnemonic is used for an OptionButton or for a CascadeButton in a MenuBar, pressing <Alt> and the mnemonic anywhere in the window or its Menus moves the cursor to the component with that mnemonic and activates it (IDREF="34761" TYPE="TITLE"Section 5.3, "Mnemonics"
).  A mnemonic is generally activatable when the location cursor is within the component that contains the mnemonic.  Pressing <Alt> and the mnemonic provides a way to activate a visible mnemonic when the location cursor is within the window that contains the mnemonic. LBL="B.5.4" HELPID=""TearOff ActivationYes  N/A  No___   ___   ___ 5-11:Activating a TearOffButton tears off the Menu that contains the button (IDREF="23279" TYPE="TITLE"Section 5.4, "TearOff Activation"
).  A TearOffButton is like a PushButton with the special interaction of tearing off the Menu from its CascadeButton.  TearOffButtons use the same basic activation as other buttons. ___   ___   ___ 5-12:When a Menu with a TearOffButton is posted, pressing BTransfer in the TearOffButton starts a TearOff action.  As long as BTransfer is held, a representation of the Menu follows the movement of the pointer.  Releasing BTransfer ends the TearOff action by unposting the Menu system, creating a new window at the current pointer location that contains the contents of the Menu, and giving focus to the new window in explicit pointer mode (IDREF="23279" TYPE="TITLE"Section 5.4, "TearOff Activation"
).  BTransfer, the second mouse button, provides a consistent means of activating a TearOffButton. LBL="B.5.5" HELPID=""Help ActivationYes  N/A  No___   ___   ___ 5-13:Your application uses <Help> on a component to invoke any context-sensitive help for the component or its nearest ancestor with context-sensitive help available (IDREF="23175" TYPE="TITLE"Section 5.5, "Help Activation"
).  <Help> offers the user a consistent mechanism for invoking context-sensitive help. LBL="B.5.6" HELPID=""Default ActivationYes  N/A  No___   ___   ___ 5-14:If your application uses default PushButtons in a window, the current default PushButton is highlighted.  When the focus is on a PushButton, its action is the default action, and the PushButton shows default highlighting.  If the default action in a window varies, some PushButton always has default highlighting, except when there is no current default action (IDREF="21012" TYPE="TITLE"Section 5.6, "Default Activation"
).  Placing emphasis on the default PushButton in a DialogBox provides the user with a visual cue about the expected reply to the dialog. ___   ___   ___ 5-15:When focus is in a window with a default action, <Enter> and <Ctrl> <Return> invoke the default action.  If focus is in a component other than multiline Text, <Return> also invokes the default action.  These actions have no other effect on the component with the focus, unless the default action has some effect on that component (IDREF="21012" TYPE="TITLE"Section 5.6, "Default Activation"
).  These rules ensure that the means of invoking a default action are consistent across applications. ___   ___   ___ 5-16:Except in the middle of a button motion operation, <Cancel> anywhere in a DialogBox is equivalent to activating the Cancel PushButton in the DialogBox (IDREF="21012" TYPE="TITLE"Section 5.6, "Default Activation"
).  <Cancel> provides a uniform means of canceling a DialogBox from the keyboard. LBL="B.5.7" HELPID=""Expert ActivationYes  N/A  No___   ___   ___ 5-17If your application supports expert activation, expert actions exist only as shortcuts to application features that are available through another mechanism (IDREF="42018" TYPE="TITLE"Section 5.7, "Expert Activation"
).  Expert activation, using mouse double-clicking on buttons, provides a convenient way for experienced users to perform certain tasks quickly.  However, new users and keyboard-only users need to be able to perform the same tasks. ___   ___   ___ 5-18:When the focus is on a button used for expert activation, no default action is available, unless the default and expert actions are the same (IDREF="42018" TYPE="TITLE"Section 5.7, "Expert Activation"
).  This rule minimizes possible confusion between default and expert activation. ___   ___   ___ 5-19:If a component with an expert action is selectable, activating the expert action first selects the component and then performs the expert action (IDREF="42018" TYPE="TITLE"Section 5.7, "Expert Activation"
).  A user needs to be able to select a component, even if it has an expert action associated with it. LBL="B.5.8" HELPID=""Previewing and AutorepeatYes  N/A  No___   ___   ___ 5-20:If your application supports activation preview using BSelect, the previewing information is removed when the user releases BSelect (IDREF="28868" TYPE="TITLE"Section 5.8, "Previewing and Autorepeat"
).  Activation preview presents the user with additional information that describes the effect of activating a button.  This information cannot interfere with the normal operation of the application. LBL="B.5.9" HELPID=""Cancel ActivationYes  N/A  No___   ___   ___ 5-21:Pressing <Cancel> stops the current interaction in the following contexts (IDREF="15274" TYPE="TITLE"Section 5.9, "Cancel Activation"
): During a mouse-based selection or drag operation, it cancels the operation.  During a mouse-based scrolling operation, it cancels the scrolling action and returns the system to its state prior to the start of the scrolling operation.  Anywhere in a DialogBox that has a Cancel PushButton, it is equivalent to activating that PushButton, except during a mouse-based selection or drag operation.  In a Pulldown Menu, it either dismisses the Menu and moves the location cursor to the CascadeButton used to pull it down, or unposts the entire Menu system.  In a Popup Menu, Option Menu, TearOff Menu, or MenuBar, it unposts the Menu system.  When the focus is in a torn off Menu window, it closes the torn off Menu window.  These guidelines for <Cancel> ensure the consistent operation of the key across applications. LBL="B.6" HELPID=""Application Design PrinciplesLBL="B.6.1" HELPID=""LayoutLBL="" HELPID=""MainWindowYes  N/A  No___   ___   ___ 6-1:Your application has at least one MainWindow (IDREF="11199" TYPE="TITLE""MainWindow" in Chapter 6
).  A MainWindow contains a client area and, optionally, a MenuBar, a command area, a message area, and ScrollBars.  The client area contains the framework of the application.  The use of a MainWindow ensures interapplication consistency. ___   ___   ___ 6-2:If your application has multiple MainWindows that serve the same primary function, each window closes and iconifies separately (IDREF="11199" TYPE="TITLE""MainWindow" in Chapter 6
).  For example, a text editor might allow the user to edit multiple documents, each in its own MainWindow.  Each window is then treated as a separate application and can be closed or iconified when it is not being used. ___   ___   ___ 6-3:If your application has multiple MainWindows that serve different primary functions, each window iconifies separately (IDREF="11199" TYPE="TITLE""MainWindow" in Chapter 6
).  For example, a debugger might provide separate MainWindows for editing source code, examining data values, and viewing results.  Each window can be iconified when it is not being used, but it is up to the application to decide whether each window closes separately or whether closing one window closes the entire application. LBL="" HELPID=""MenuBarThese requirements apply only in a left-to-right language environment in an English-language locale.  You need to make the appropriate changes for other locales.  Yes  N/A  No___   ___   ___ 6-4:If your application has a MenuBar, it is a horizontal bar at the top edge of the application, just below the title area of the window frame, if present (IDREF="29052" TYPE="TITLE""MenuBar" in Chapter 6
).  A MenuBar organizes the most common features of an application.  It contains a list of Menu topics in CascadeButtons; each button is associated with a distinct Pulldown Menu containing commands that are grouped by common functionality.  The use of a MenuBar yields consistency across applications. ___   ___   ___ 6-5:The MenuBar for your application contains only CascadeButtons (IDREF="29052" TYPE="TITLE""MenuBar" in Chapter 6
).  When other buttons are included as topics in a MenuBar, they inhibit Menu browsing. ___   ___   ___ 6-6:If any of the common Menus are present in the MenuBar, they are arranged in the following order with respect to each other, ranging from left to right across the MenuBar (IDREF="29052" TYPE="TITLE""MenuBar" in Chapter 6
):  File Menu
   Selected Menu
   Edit Menu
   View Menu
   Options Menu
   Help MenuIf a File Menu is present, it is the first Menu and is placed at the far left of the MenuBar.  If a Help Menu is present, it is the last Menu and is placed at the far right of the MenuBar.  The ordering of common Menus in the MenuBar ensures consistency among applications.  You can omit any of these Menus if they are not relevant to the application.  You can also intersperse other, application-specific, Menus among these Menus. File Menu ContentsThese requirements apply only in a left-to-right language environment in an English-language locale.  You need to make the appropriate changes for other locales.  Yes  N/A  No___  ___  ___ 6-7:If your application uses a File Menu, it contains the following choices, with the specified functionality, when the actions are actually supported by your application ("File Menu Contents").  NewCreates a new file.  If the current client area will be used to display the new file, your application clears the existing data from the client area.  If changes made to the current file will be lost, your application displays a DialogBox, asking the user about saving changes.  Has the mnemonic N.  Open...Opens an existing file by prompting the user for a filename with a DialogBox.  If changes made to the current file will be lost, your application displays a DialogBox asking the user about saving changes.  Has the mnemonic O.  SaveSaves the currently opened file without removing the existing contents of the client area.  If the file has no name, your application displays a DialogBox, prompting the user to enter a filename.  Has the mnemonic S.  Save As...Saves the currently opened file under a new name by prompting the user for a filename with a DialogBox.  If the user tries to save the file using an existing name, your application displays a DialogBox that warns the user about a possible loss of data.  Does not remove the existing contents of the client area.  Has the mnemonic A.  PrintSchedules a file for printing.  If your application needs specific information in order to print, it displays a DialogBox, requesting the information from the user.  In this case, the Menu entry is followed by an ellipsis (Print...).  Has the mnemonic P.  CloseCloses the current primary window and its associated secondary windows.  If your application uses only a single primary window or multiple dependent primary windows, this action is not supplied.  Has the mnemonic C.  ExitEnds the current application and all windows associated with it.  If changes made to the current file will be lost, your application displays a DialogBox, asking the user about saving changes.  Has the mnemonic X.  The use of a File Menu with these common file operations yields consistency across applications. ID="26964"Edit Menu ContentsThese requirements apply only in a left-to-right language environment in an English-language locale.  You need to make the appropriate changes for other locales.  Yes  N/A  No___  ___  ___ 6-8:If your application uses an Edit Menu, it contains the following choices, with the specified functionality, when the actions are actually supported by your application ("Edit Menu Contents"): UndoReverses the most recently executed action.  Has the mnemonic U.  CutRemoves the selected portion of data from the client area and puts it on the clipboard.  Has the mnemonic T.  CopyCopies the selected portion of data from the client area and puts it on the clipboard.  Has the mnemonic C.  Copy LinkCopies a link of the selected portion of data from the client area and puts it on the clipboard.  Has the mnemonic K.  PastePastes the contents of the clipboard into the client area.  Has the mnemonic P.  Paste LinkPastes a link of the data represented by the contents of the clipboard into the client area.  Has the mnemonic L.  ClearRemoves a selected portion of data from the client area without copying it to the clipboard and does not compress the remaining data.  Has the mnemonic E.  DeleteRemoves a selected portion of data from the client area without copying it to the clipboard.  Has the mnemonic D.  Select AllSets the primary selection to be all the elements in a component of the client area.  Deselect AllRemoves from the primary selection all the elements in a component of the client area.  Select PastedSets the primary selection to the last element or elements pasted into a component of the client area.  ReselectSets the primary selection to the last selected element or elements in a component of the client area.  This action is available only in components that do not support persistent selections and only when the current selection is empty.  PromotePromotes to the primary selection the current selection of a component of the client area.  This action is available only for components that support persistent selections.  The use of an Edit Menu with these common editing operations yields consistency across applications. ___   ___   ___ 6-9:If your application uses accelerators for Undo, Cut, Copy, and Paste in an Edit Menu, it uses either one or both of the models presented in the following two tables ("Edit Menu Contents").  COLUMNS="2"LEFT="0" WIDTH="108"Edit Menu ItemLEFT="115" WIDTH="356"AcceleratorLEFT="0" WIDTH="108"UndoLEFT="115" WIDTH="356"<Alt><BackSpace>LEFT="0" WIDTH="108"CutLEFT="115" WIDTH="356"<Shift><Delete>LEFT="0" WIDTH="108"CopyLEFT="115" WIDTH="356"<Ctrl><Insert>LEFT="0" WIDTH="108"PasteLEFT="115" WIDTH="356"<Shift><Insert>LBL="B-1"Table B-1 
Edit Menu Accelerators, Model 1COLUMNS="2"LEFT="0" WIDTH="108"Edit Menu ItemLEFT="115" WIDTH="356"AcceleratorLEFT="0" WIDTH="108"UndoLEFT="115" WIDTH="356"<Ctrl><Z>LEFT="0" WIDTH="108"CutLEFT="115" WIDTH="356"<Ctrl><X>LEFT="0" WIDTH="108"CopyLEFT="115" WIDTH="356"<Ctrl><C>LEFT="0" WIDTH="108"PasteLEFT="115" WIDTH="356"<Ctrl><V>LBL="B-2"Table B-2 
Edit Menu Accelerators, Model 2These models provide consistent sets of accelerators for common editing operations in an Edit Menu. Help Menu ContentsThese requirements apply only in a left-to-right language environment in an English-language locale.  You need to make the appropriate changes for other locales.  Yes  N/A  No___  ___  ___ 6-10:If your application uses a Help Menu, it contains either of the following two sets of choices, with the specified functionality, when the actions are actually supported by your application ("Help Menu Contents"): On ContextInitiates context-sensitive help by changing the shape of the pointer to the question pointer, described in IDREF="11954" TYPE="TITLE"Section 2.2.2, "Pointer Shapes."
  When the user moves the pointer to a component and presses BSelect, any available context-sensitive help for the component is presented, and the pointer returns to its original shape.  Has the mnemonic C.  If this action uses an accelerator, it is <Shift> <Help>.On HelpProvides information on how to use your application's help facility.  Has the mnemonic H.  On WindowProvides general information about the window from which help was requested.  Has the mnemonic W.  On KeysProvides information about your application's use of function keys, mnemonics, and keyboard accelerators.  Has the mnemonic K.  IndexProvides an index for all help information in your application.  Has the mnemonic I.  TutorialProvides access to your application's tutorial.  Has the mnemonic T.  On VersionProvides at least the name and version of your application.  Has the mnemonic V.  If your application uses a Help Menu, and it does not use the previous set of choices, the Help Menu contains the following choices, with the specified functionality, when the actions are actually supported by your application ("Help Menu Contents"): Context-Sensitive HelpInitiates context-sensitive help by changing the shape of the pointer to the question pointer, described in IDREF="11954" TYPE="TITLE"Section 2.2.2, "Pointer Shapes."
  When the user moves the pointer to a component and presses BSelect, any available context-sensitive help for the component is presented and the pointer returns to its original shape.  Has the mnemonic C.  If this action uses an accelerator, it is <Shift> <Help>.OverviewProvides general information about the application window from which help was requested.  Has the mnemonic O.  IndexProvides an index for all help information in your application.  Has the mnemonic I.  KeyboardProvides information about your application's use of function keys, mnemonics, and keyboard accelerators.  Has the mnemonic K.  TutorialProvides access to your application's tutorial.  Has the mnemonic T.  Using HelpProvides information on how to use your application's help facility.  Has the mnemonic H.  Product InformationProvides at least the name and version of your application.  Has the mnemonic P.  The use of a Help Menu with these common help operations yields consistency across applications. LBL="" HELPID=""Popup MenusThese requirements apply only in a left-to-right language environment in an English-language locale.  You need to make the appropriate changes for other locales.  Yes  N/A  No___  ___  ___ 6-11:If your application uses any of the common Popup Menu actions, the actions function according to the following specifications (IDREF="14825" TYPE="TITLE""Popup Menus" in Chapter 6
): PropertiesDisplays a properties DialogBox that the user can use to set the properties of the component.  UndoReverses the most recently executed action.  Primary MoveMoves the contents of the primary selection to the component.  This action is available only in editable components.  Primary CopyCopies the contents of the primary selection to the component.  This action is available only in editable components.  Primary LinkPlaces a link to the primary selection in the component.  This action is available only in editable components.  CutCuts elements to the clipboard.  If the Menu is popped up in a selection, cuts the entire selection to the clipboard.  CopyCopies elements to the clipboard.  If the Menu is popped up in a selection, copies the entire selection to the clipboard.  Copy LinkCopies a link of elements to the clipboard.  If the Menu is popped up in a selection, copies a link to the entire selection to the clipboard.  PastePastes the contents of the clipboard to the component.  This action is available only in editable components.  Paste LinkPastes a link of the contents of the clipboard to the component.  This action is available only in editable components.  ClearRemoves a selected portion of data from the client area without copying it to the clipboard.  If the Menu is popped up in a selection, deletes the selection.  DeleteRemoves a selected portion of data from the client area without copying it to the clipboard.  If the Menu is popped up in a selection, deletes the selection.  Select AllSets the primary selection to be all of the elements in the collection with the Popup Menu.  Deselect AllDeselects the current selection in the collection with the Popup Menu.  Select PastedSets the primary selection to be the last element or elements pasted into the collection with the Popup Menu.  ReselectSets the primary selection to be the last selected element or elements in the component with the Popup Menu.  This action is available only in components that do not support persistent selections and only when the current selection is empty.  PromotePromotes the current selection to the primary selection.  It is available only in components that support persistent selections.  The use of Popup Menus with these common actions yields consistency across applications. ___   ___   ___ 6-12:When a Popup Menu is popped up in the context of a selection, any action that acts on elements acts on the entire selection (IDREF="14825" TYPE="TITLE""Popup Menus" in Chapter 6
).  In the context of a selection, Popup Menu actions affect the entire selection. LBL="" HELPID=""DialogBoxesYes  N/A  No___   ___   ___ 6-13:InformationDialogs do not interrupt the user's interaction with your application ("MessageDialog").  An InformationDialog conveys information to the user that does not require immediate attention, so it does not need to be modal. LBL="" HELPID=""Menu DesignYes  N/A  No___   ___   ___ 6-14:If your application uses a TearOffButton in a Menu, the TearOffButton is the first element in the Menu (IDREF="40202" TYPE="TITLE"Section 6.2.3, "Menu Design"
).  When a TearOffButton is activated, the Menu changes into a DialogBox.  The TearOffButton needs to be the first item in the Menu so that the entire contents of the Menu are torn off. ___   ___   ___ 6-15:All Menus are wide enough to accommodate their widest elements (IDREF="40202" TYPE="TITLE"Section 6.2.3, "Menu Design"
).  The ability to see the full Label of each Menu element allows the user to browse through a Menu. LBL="" HELPID=""DialogBox DesignThese requirements apply only in a left-to-right language environment in an English-language locale.  You need to make the appropriate changes for other locales.  Yes  N/A  No___  ___  ___ 6-16:If your application uses common DialogBox actions, the actions have the following specified functionality (IDREF="28469" TYPE="TITLE""Common DialogBox Actions" in Chapter 6
): YesIndicates an affirmative response to a question posed in the DialogBox.  NoIndicates a negative response to a question posed in the DialogBox.  OKApplies any changes made to components in the DialogBox and dismisses the DialogBox.  ApplyApplies any changes made to components in the DialogBox.  RetryCauses the task in progress to be attempted again.  StopEnds the task in progress at the next possible breaking point.  PauseCauses the task in progress to pause.  ResumeCauses a task that has paused to resume.  ResetCancels any user changes that have not been applied to your application.  Resets the status of the DialogBox to the state since the last time the DialogBox action was applied or to the initial state of the DialogBox.  CancelCloses the DialogBox without performing any DialogBox actions not yet applied to your application.  Pressing <Cancel> anywhere in the DialogBox, except during a cancelable drag operation, also performs the action of this button.  HelpProvides any help for the DialogBox.  The use of common actions provides a consistent way for the user to respond quickly to DialogBoxes and get back to primary application tasks. LBL="" HELPID=""Designing Drag and DropYes  N/A  No___   ___   ___ 6-17:If your application provides any drag and drop help DialogBoxes, they contain a Cancel button for canceling the drag and drop operation in progress (IDREF="11865" TYPE="TITLE""Providing Help on Drop Sites" in Chapter 6
).  The Cancel button in the help DialogBox provides a convenient way for the user to cancel a drag and drop operation.  LBL="B.6.2" HELPID=""InteractionYes  N/A  No___   ___   ___ 6-18:A WarningDialog allows the user to cancel the destructive action about which it is providing a warning (IDREF="29352" TYPE="TITLE""Providing Warnings" in Chapter 6
).  The user needs to have a way to cancel an operation that can cause destructive results. LBL="B.7" HELPID=""Controls, Groups, and ModelsLBL="B.7.1" HELPID=""CheckButtonYes  N/A  No___   ___   ___ 7-1:If your application uses CheckButtons, each button graphically indicates its state (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  A CheckButton is used to select settings that are not mutually exclusive.  The user needs to know whether the button is set or not. ___   ___   ___ 7-2:When the user presses BSelect in a CheckButton, the CheckButton is armed.  If the CheckButton was previously unset, it is shown in the set state.  If the CheckButton was previously set, it is shown in the unset state (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  BSelect Press arms a CheckButton and shows the result of activating it by releasing BSelect. ___   ___   ___ 7-3:When the user releases BSelect in the same CheckButton that the press occurred in: If the CheckButton was previously unset, it is set.  If the CheckButton was previously set, it is unset.  In all cases the CheckButton is disarmed, and, if the CheckButton is in a Menu, the Menu is unposted (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  BSelect Release activates a CheckButton. ___   ___   ___ 7-4:When the user presses <Enter> or <Return> in a CheckButton, if the CheckButton is in a window with a default action, the default action is activated.  If the CheckButton is in a Menu: If the CheckButton was previously unset, it is set.  If the CheckButton was previously set, it is unset.  In both cases, the CheckButton is disarmed, and the Menu is unposted (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  <Enter> and <Return> perform the default action of a window or activate a CheckButton in a Menu. ___   ___   ___ 7-5:When the user presses <Select> or <Space> in a CheckButton, if the CheckButton was previously unset, it is set.  If the CheckButton was previously set, it is unset.  In both cases, the CheckButton is disarmed, and, if the CheckButton is in a Menu, the Menu is unposted (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  <Select> and <Space> activate a CheckButton.LBL="B.7.2" HELPID=""CommandBoxYes  N/A  No___   ___   ___ 7-6:If your application uses a CommandBox, it is composed of a Text component with a command line prompt for text input and a List component for a command history area.  The List uses either the single selection or browse selection model (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  This specification ensures the consistent appearance and operation of a CommandBox across applications. ___   ___   ___ 7-7:When an element of a CommandBox List is selected, its contents are placed in the Text area (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  This specification provides a convenient way of selecting a previously entered command. ___   ___   ___ 7-8:The List navigation actions <Up arrow>,<Down arrow>,<Ctrl> <Begin>,and <Ctrl> <End> are available from the Text component for moving the cursored element within the List and thus changing the contents of the Text (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  These actions provide a convenient way to choose a command from the List while focus remains in the Text component. ___   ___   ___ 7-9:The default action of the CommandBox passes the command in the Text area to the application for execution and adds the command to the end of the List (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  Maintaining a history of commands provides a convenient means of entering often-used commands. LBL="B.7.3" HELPID=""FileSelectionBoxYes  N/A  No___   ___   ___ 7-10:If your application uses a FileSelectionBox, it is composed of at least the following components (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
): A Text component for displaying and editing a directory mask used to select files to be displayed.  The directory mask is a string specifying the base directory to be examined and a search pattern.  A List component for displaying filenames.  The List uses either the single selection or browse selection model.  A List component for displaying subdirectories.  The List uses either the single selection or browse selection model.  A Text component for displaying and editing a filename.  A group of PushButtons, labeled OK, Filter, Cancel, and Help.  This specification ensures the uniform appearance of a FileSelectionBox across applications. ___   ___   ___ 7-11:Your application allows the user to select a new directory to examine by scrolling through the List of directories and selecting the desired directory or by editing the directory mask.  Selecting a new directory from the directory List does not change the search pattern (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  The method for selecting a new directory to examine needs to be consistent across applications. ___   ___   ___ 7-12:Your application allows the user to select a new search pattern by editing the directory mask (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  The method for specifying a new search pattern needs to be uniform across applications. ___   ___   ___ 7-13:The List navigation actions <Up arrow>,<Down arrow>,<Ctrl> <Begin>,and <Ctrl> <End> are available from the Text components for moving the cursored element within each List and thus changing the contents of the Text.  The contents of the directory Text correspond to the contents of the directory List, and the contents of the filename Text correspond to the contents of the filename List (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  These actions provide a convenient way to choose a directory or filename from the corresponding List while focus remains in the Text component. ___   ___   ___ 7-14:The FileSelectionBox initiates a directory and file search when any of the following occurs (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
): The FileSelectionBox is initialized.  The user activates the Filter PushButton.  The user double-clicks or presses <Enter> or <Return> on an item in the directory List.  The user presses <Enter> or <Return> while the directory mask Text edit area has the keyboard focus.  The method for initiating a search needs to be uniform across applications. ___   ___   ___ 7-15:Your application allows the user to select a file by scrolling through the List of filenames and selecting the desired file or by entering the filename directly into the file selection Text component.  Selecting a file from the List causes that filename to appear in the file selection Text area (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  The method for selecting a file needs to be consistent across applications. ___   ___   ___ 7-16:Your application allows the user to select a new file as many times as desired.  Your application does not make use of the selection until one of the following occurs (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
): The user activates the OK PushButton.  The user presses <Enter> or <Return> while the filename Text component has the keyboard focus.  The user presses <Enter> or <Return> while the location cursor is on an item in the file List.  The user double-clicks BSelect on an item in the file List.  This specification results in the uniform operation of a FileSelectionBox across applications. ___   ___   ___ 7-17:The FileSelectionBox initiates a directory and file search when the FileSelectionBox is initialized, the user activates the Filter PushButton, the user double-clicks BSelect or presses <Enter> or <Return> on an item in the directory List, or the user presses <Enter> or <Return> while the directory mask Text edit area has the keyboard focus (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  This specification ensures the consistent operation of a directory and file search in a FileSelectionBox. LBL="B.7.4" HELPID=""ListYes  N/A  No___   ___   ___ 7-18:Within a List component, your application uses <Up arrow> to move the location cursor to the previous item in the List and <Down arrow> to move the location cursor to the next item in the List.  In a scrollable List, <Left arrow> scrolls the List one character to the left, and <Right arrow> scrolls the List one character to the right (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  The arrow keys provide a consistent means of moving the location cursor within a List component. ___   ___   ___ 7-19:Within a List component, your application uses <Ctrl> <Begin> to move the location cursor to the first item in the List and <Ctrl> <End> to move the location cursor to the last item in the List.  In a scrollable List, <Begin> moves the horizontal scroll region so that the leftmost edge of the List is visible, and <End> moves the horizontal scroll region so that the rightmost edge of the List is visible (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  These keys offer a convenient mechanism for moving the location cursor quickly through a List. ___   ___   ___ 7-20:Within a scrollable List, <PageUp> moves the location cursor to the item one page up in the List, and <PageDown> moves the location cursor to the item one page down in the List.  In a scrollable list, <PageLeft> or <Ctrl> <PageUp> scrolls the List one page to the left, and <PageRight> or <Ctrl> <PageDown> scrolls the List one page to the right (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  These keys offer a convenient mechanism for paging through a List. ___   ___   ___ 7-21:Within a List component, your application uses BSelect Click 2 to select the item that was double-clicked and then initiate any default action for the window (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  Double-clicking using BSelect provides a consistent way of activating the default action for a List. LBL="B.7.5" HELPID=""OptionButtonYes  N/A  No___   ___   ___ 7-22:If your application uses OptionButtons, the Label for the button is the last selection made from the OptionButton (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  An OptionButton is used to post an Option Menu which allows the user to select from a number of choices.  The Label of an OptionButton needs to display the most recent selection from the associated Option Menu. ___   ___   ___ 7-23:When the user presses BSelect in an OptionButton, the associated Option Menu is posted (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  BSelect Press is a consistent way of activating an OptionButton. ___   ___   ___ 7-24:When the user releases BSelect within the same OptionButton that the press occurred in, the associated Option Menu is posted if it was not posted at the time of the press.  When the user releases BSelect outside of the OptionButton, the associated Option Menu is unposted (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  BSelect Release posts or unposts an Option Menu, depending on whether the release occurs inside the OptionButton and whether the Option Menu was posted at the time of the press. ___   ___   ___ 7-25:When the user presses <Select> or <Space> in an OptionButton, the associated Option Menu is posted (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  <Select> or <Space> posts an Option Menu from the keyboard. LBL="B.7.6" HELPID=""PanedWindowYes  N/A  No___   ___   ___ 7-26:If your application uses PanedWindows, they are composed of any number of groups of components, called Panes, each separated by a Sash and a Separator.  The Panes, Sashes, and Separators are grouped linearly, either horizontally or vertically.  A Sash is the handle on a Separator between two Panes that is used to adjust the position of the Separator (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  This specification ensures the consistent appearance of a PanedWindow across applications. LBL="B.7.7" HELPID=""PanelYes  N/A  No___   ___   ___ 7-27:The <Down arrow>,<Left arrow>,<Right arrow>,and <Up arrow> directional keys navigate among components in a Panel (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  A Panel group organizes a collection of basic controls in a horizontal, vertical, or 2-dimensional layout.  The directional keys are used to navigate among the controls. LBL="B.7.8" HELPID=""PushButtonYes  N/A  No___   ___   ___ 7-28:When the user presses BSelect in a PushButton, the PushButton is armed.  When the user releases BSelect in the same PushButton that the press occurred in, the PushButton is disarmed and activated.  When the user releases BSelect outside the PushButton, the PushButton is disarmed but not activated (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  BSelect provides a consistent means of activating a PushButton. ___   ___   ___ 7-29:When the user presses <Enter> or <Return> in a PushButton that is in a window with a default action, the PushButton is activated.  When the user presses <Enter> or <Return> in a PushButton in a Menu, the PushButton is activated and the Menu is unposted (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  <Enter> and <Return> activate a DialogBox or a PushButton in a Menu. ___   ___   ___ 7-30:When the user presses <Select> or <Space> in a PushButton, the PushButton is activated.  If the PushButton is in a Menu, the Menu is unposted (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  <Select> and <Space> activate a PushButton. LBL="B.7.9" HELPID=""RadioButtonYes  N/A  No___   ___   ___ 7-31:If your application uses RadioButtons, each button graphically indicates its state (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  RadioButtons are used to represent a panel of mutually exclusive selections.  The user needs to know which button in the panel is set. ___   ___   ___ 7-32:When the user presses BSelect in a RadioButton, the RadioButton is armed.  If the RadioButton was previously unset, it is shown in the set state (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  BSelect Press arms a RadioButton and shows the result of activating it by releasing BSelect. ___   ___   ___ 7-33:When the user releases BSelect in the same RadioButton that the press occurred in and the RadioButton was previously unset, it is set, and any other RadioButton in the same Panel that was previously set is unset.  The RadioButton is disarmed, and, if the RadioButton is in a Menu, the Menu is unposted (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  BSelect Release activates a RadioButton. ___   ___   ___ 7-34:When the user presses <Enter> or <Return> in a RadioButton, if the RadioButton is in a window with a default action, the default action is activated.  If the RadioButton is in a Menu (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
): If the RadioButton was previously unset, it is set, and any other RadioButton in the same Panel that was previously set is unset.  The RadioButton is disarmed, and the Menu is unposted.  <Enter> and <Return> perform the default action of a window or activate a RadioButton in a Menu. ___   ___   ___ 7-35:When the user presses <Select> or <Space> in a RadioButton, if the RadioButton was previously unset, it is set, and any other RadioButton in the same Panel that was previously set is unset.  The RadioButton is disarmed, and, if the RadioButton is in a Menu, the Menu is unposted (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  <Select> and <Space> activate a RadioButton. LBL="B.7.10" HELPID=""SashYes  N/A  No___   ___   ___ 7-36:Within a PanedWindow, your application uses a Sash to adjust the position of a Separator, which adjusts the sizes of the Panes next to it.  As a Sash is moved, the Pane in the direction of the Sash movement gets smaller and the opposite Pane gets larger by an equal amount (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  This specification results in the uniform operation of a PanedWindow across applications. ___   ___   ___ 7-37:Within a Sash, BSelect Motion or BTransfer Motion causes the Sash to track the movement of the pointer.  In a vertically oriented PanedWindow, the Sash tracks the vertical position of the pointer.  In a horizontally oriented PanedWindow, the Pane tracks the horizontal position of the pointer (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  BSelect, the first mouse button, and BTransfer, the second mouse button, provide a consistent means of moving a Sash in a PanedWindow using the mouse. ___   ___   ___ 7-38:<Up arrow> and <Down arrow> (for a Sash that can move vertically) and <Left arrow> and <Right arrow> (for a Sash that can move horizontally) move the Sash one increment in the specified direction (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  The arrow keys offer a uniform means of moving a Sash in a PanedWindow. ___   ___   ___ 7-39:<Ctrl> <Up arrow> and <Ctrl> <Down arrow> (for a Sash that can move vertically) and <Ctrl> <Left arrow> and <Ctrl> <Right arrow> (for a Sash that can move horizontally) move the Sash one large increment in the specified direction (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  These keys provide a convenient way of moving a Sash quickly in a PanedWindow. LBL="B.7.11" HELPID=""ScaleYes  N/A  No___   ___   ___ 7-40:If a Scale has arrow buttons, your application uses BSelect Press in an arrow button to move the slider one increment in the direction of the side of the slider on which the button was pressed and autorepeats until the button is released (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  BSelect Press provides a consistent means of adjusting a Scale component using the mouse. ___   ___   ___ 7-41:In a Scale trough, if the Scale has tick marks, BSelect Press moves the slider one major tick mark in the direction of the side of the slider on which the trough was pressed and autorepeats until the button is released.  If the Scale does not have tick marks, BSelect Press in the trough moves the slider one large increment in the direction of the side of the slider on which the trough was pressed and autorepeats until the button is released (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  BSelect Press provides a consistent means of adjusting a Scale component using the mouse. ___   ___   ___ 7-42:Within a Scale slider, BSelect Motion causes the slider to track the position of the pointer.  In a vertical Scale, the slider tracks the vertical position of the pointer.  In a horizontal Scale, the slider tracks the horizontal position of the pointer (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  BSelect Motion offers a convenient way to adjust a Scale component precisely using the mouse. ___   ___   ___ 7-43:Within a Scale slider or trough, BTransfer Motion positions the slider to the point of the button press and then causes the slider to track the position of the pointer.  In a vertical Scale, the slider tracks the vertical position of the pointer.  In a horizontal Scale, the slider tracks the horizontal position of the pointer (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  BTransfer Motion provides another convenient way to adjust a Scale component precisely using the mouse. ___   ___   ___ 7-44:If a mouse-based sliding action is in progress, <Cancel> cancels the sliding action and returns the slider to its position prior to the start of the sliding operation (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  <Cancel> provides a consistent way for the user to cancel a mouse-based sliding action. ___   ___   ___ 7-45:In a vertical Scale, <Up arrow> and <Down arrow> move the slider one increment in the specified direction.  In a horizontal Scale, <Left arrow> and <Right arrow> move the slider one increment in the specified direction (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  The arrow keys provide a uniform way of adjusting the slider in a Scale component using the keyboard. ___   ___   ___ 7-46:In a vertical Scale, <Ctrl> <Up arrow> and <Ctrl> <Down arrow> move the slider one large increment in the specified direction.  In a horizontal Scale, <Ctrl> <Left arrow> and <Ctrl> <Right arrow> move the slider one large increment in the specified direction (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  These keys provide a convenient way of adjusting the slider in a Scale component quickly using the keyboard. ___   ___   ___ 7-47:Your application uses <Begin> or <Ctrl> <Begin> to move the slider to its minimum value.  <End> or <Ctrl> <End> moves the slider to its maximum value (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  These keys provide a convenient mechanism for setting a Scale to its minimum or maximum value using the keyboard. LBL="B.7.12" HELPID=""ScrollBarYes  N/A  No___   ___   ___ 7-48:Within a ScrollBar, your application uses BSelect Press in an arrow button to move the slider one increment in the direction of the side of the slider on which the button was pressed and autorepeats until the button is released (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  BSelect Press provides a consistent means of adjusting a ScrollBar using the mouse. ___   ___   ___ 7-49:In the trough of a ScrollBar, BSelect Press moves the slider one page in the direction of the side of the slider on which the trough was pressed and autorepeats until the button is released (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  BSelect Press provides a consistent means of adjusting a ScrollBar using the mouse. ___   ___   ___ 7-50:Within a ScrollBar slider, BSelect Motion causes the slider to track the position of the pointer.  In a vertical ScrollBar, the slider tracks the vertical position of the pointer.  In a horizontal ScrollBar, the slider tracks the horizontal position of the pointer (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  BSelect Motion offers a convenient way to adjust a ScrollBar precisely using the mouse. ___   ___   ___ 7-51:Within a ScrollBar slider or trough, BTransfer Motion positions the slider to the point of the button press and then causes the slider to track the position of the pointer.  In a vertical ScrollBar, the slider tracks the vertical position of the pointer.  In a horizontal ScrollBar, the slider tracks the horizontal position of the pointer (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  BTransfer Motion offers another convenient way to adjust a ScrollBar precisely using the mouse. ___   ___   ___ 7-52:If a mouse-based scrolling action is in progress, <Cancel> cancels the scrolling action and returns the slider to its position prior to the start of the scrolling operation (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  <Cancel> provides a consistent way for the user to cancel a mouse-based scrolling action. ___   ___   ___ 7-53:In a vertical ScrollBar, <Up arrow> and <Down arrow> move the slider one increment in the specified direction.  In a horizontal ScrollBar, <Left arrow> and <Right arrow> move the slider one increment in the specified direction (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  The arrow keys provide a uniform means of adjusting a ScrollBar using the keyboard. ___   ___   ___ 7-54:In a vertical ScrollBar, <Ctrl> <Up arrow> and <Ctrl> <Down arrow> move the slider one large increment in the specified direction.  <Ctrl> <Left arrow> and <Ctrl> <Right arrow> move the slider one large increment in the specified direction (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  These keys provide a convenient way of adjusting a ScrollBar quickly using the keyboard. ___   ___   ___ 7-55:Your application uses <PageUp> and <PageDown> to move the slider in a vertical ScrollBar one page in the specified direction.  <PageLeft> or <Ctrl> <PageUp> and <PageRight> or <Ctrl> <PageDown> move the slider in a horizontal ScrollBar one page in the specified direction (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  These keys allow for the convenient movement of the slider in a ScrollBar using the keyboard. ___   ___   ___ 7-56:Your application uses <Begin> or <Ctrl> <Begin> to move the slider to the minimum value.  <End> or <Ctrl> <End> moves the slider to the maximum value (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  These keys offer a convenient mechanism for setting a ScrollBar to its minimum or maximum value using the keyboard. LBL="B.7.13" HELPID=""SelectionBoxYes  N/A  No___   ___   ___ 7-57:If your application uses a SelectionBox, it is composed of at least a Text component for the selected alternative and a List component above the Text component for presenting alternatives.  The List uses either the single selection or browse selection model.  Selecting an element from the List places the selected element in the Text component (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  This specification ensures the consistent appearance and operation of a SelectionBox across applications. ___   ___   ___ 7-58:The List navigation actions <Up arrow>,<Down arrow>,<Ctrl> <Begin>,and <Ctrl> <End> are available from the Text component for moving the cursored element within the List and thus changing the contents of the Text (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  These actions provide a convenient way to choose an element from the List while focus remains in the Text component. LBL="B.7.14" HELPID=""TextYes  N/A  No___   ___   ___ 7-59:In a multiline Text component, <Up arrow> moves the location cursor up one line, and <Down arrow> moves the location cursor down one line.  In a single-line Text component, <Up arrow> navigates upward to the previous component, and <Down arrow> navigates downward to the next component, if the Text component is designed to act like a basic control (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  The up and down arrow keys provide a uniform means of navigation within Text components. ___   ___   ___ 7-60:<Left arrow> moves the location cursor left one character, and <Right arrow> moves the location cursor right one character (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  The left and right arrow keys offer a consistent way of navigating within Text components. ___   ___   ___ 7-61:In a Text component used generally to hold multiple words, <Ctrl> <Right arrow> moves the location cursor to the right by a word, and <Ctrl> <Left arrow> moves the location cursor to the left by a word (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  <Ctrl> <Right arrow> and <Ctrl> <Left arrow> provide a uniform way of navigating by words in a Text component.  Moving right by a word means that the location cursor is placed before the first character that is not a space, tab, or newline character after the next space, tab, or newline.  Moving left by a word means that the location cursor is placed after the first space, tab, or newline character preceding the first previous character that is not a space, tab, or newline. ___   ___   ___ 7-62:In a Text component used generally to hold multiple words, <Begin> moves the location cursor to the beginning of the line, and <End> moves the location cursor to the end of the line (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  These keys allow the user to move quickly to the beginning or end of a line of text in a Text component. ___   ___   ___ 7-63:In a multiline Text component, <Ctrl> <Begin> moves the location cursor to the beginning of the file, and <Ctrl> <End> moves the location cursor to the end of the file (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  These keys permit the user to move quickly to the beginning or end of a file in a Text component. ___   ___   ___ 7-64:Your application uses <Space> or <Shift> <Space> to insert a space in a Text component.  Modifying these with <Ctrl> invokes the normal selection function (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  This specification ensures that selection is available from the keyboard in a Text component. ___   ___   ___ 7-65:<Return> in a multiline Text component inserts a carriage return.  <Enter> or <Ctrl> <Return> invokes the default action (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  This specification ensures that activation is available from the keyboard in a Text component. ___   ___   ___ 7-66:In a multiline Text component, <Tab> is used for tabbing.  In a single-line Text component, <Tab> is used either for tabbing or to move to the next field (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  <Tab> is used for tabbing in multiline Text. ___   ___   ___ 7-67:If a Text component supports replace mode, <Insert> toggles between insert mode and replace mode.  By default, the component starts in insert mode, where the location cursor is between two characters.  In insert mode, typing a character inserts the character at the position of the location cursor.  In replace mode, the location cursor is on a character.  Typing a character replaces the current character with that newly entered character and moves the location cursor to the next character, selecting it (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  These rules ensure the uniform operation of a Text component with a replace mode. ___   ___   ___ 7-68:Your application uses BSelect Click 2 to select text a word at a time (IDREF="10478" TYPE="TITLE"Chapter 9, "Controls, Groups, and Models Reference Pages"
).  Double clicking with the first mouse button provides a convenient mechanism for selecting words in a Text component. GlossaryaccelerationA temporary change in the mouse pointer gain.acceleratorA key or sequence of keys (typically a modifier key and some other key) that provides a shortcut, immediately accessing a program function.activationInvocation of a component's primary action. For example, the user activates a PushButton by pressing BSelect on the PushButton.A position in a collection of selectable objects that marks one endpoint of an extended selection range.application modalA state of a window in which interaction is limited to that window and windows outside of that window's application.applyA label given to a PushButton in some DialogBoxes that performs the action of applying the current changes in the DialogBox without closing the DialogBox.autorepeatA means of PushButton activation where a mouse button is pressed and held on a PushButton and the PushButton continues to activate at regular intervals until the mouse button is released.browse selectionA selection model that allows browsing through single selection collections.buttonA button on a mouse pointing device; mouse buttons can be mapped to the keyboard. A graphical component on a window frame or in a DialogBox that works by pressing it.cancelA label given to a PushButton in some DialogBoxes that performs the action of closing the DialogBox without implementing any changes.cascading MenuA submenu that provides selections that amplify the parent selection on a Pulldown or Popup Menu.CheckButtonA component used to select settings that are not mutually exclusive. The visual cue to the selection is frequently that the button is filled in or checked.clickTo press and release a mouse button. The term comes from the fact that pressing and releasing most mouse buttons makes a clicking sound.client areaThe area within the borders of a primary window's frame that is controlled by an application.clipboardAny device used to store text or graphics during cut-and-paste operations.closeA label given to a PushButton in some DialogBoxes that performs the action of closing the DialogBox. Close is also used as a selection in Menus to close the window associated with the Menu. control panelAn area of a window, similar to the control panels in real life, that is used to hold PushButtons and other graphical components.cursorA graphical image, usually a pipe (|) or block, that shows the location where text will appear on the screen when keys on the keyboard are pressed or where a selection can be made.desktopSeeworkspace.destinationThe location at which transfer actions place data.DialogBoxA secondary window that the user can display and that contains application components.dimmed selectionA selection that is not currently available.discontiguous selectionA selection model that allows multiple discontiguous selections.double-clickTo press and release a mouse button twice in rapid succession.ID="20088"drag and dropA transfer mechanism where data is dragged from a source to a drop site using mouse motion.drag iconA graphic that is generated using pixmaps and is moved during a drag operation. The drag icon is composed of a source pixmap, a state cursor, and an operation cursor.drag transferSeedrag and drop.drop siteAn area of the screen on which the user can drop a drag icon.expert activationA means of activation where double-clicking on a PushButton activates a different action from clicking the PushButton.ID="26234"explicit focusA keyboard focus model that sends keyboard events to the window or component that was specified explicitly with a mouse button press or a keyboard event.focus A state of the system that indicates which component receives keyboard events. A component is said to have the focus if keyboard events are sent to that component.focus policyThe model by which keyboard focus is moved among components. See alsoexplicit focus.gainThe ratio of the distance the pointer moves to the distance the mouse moves.grayed selectionA Menu selection that is not currently available and so has been dimmed.helpA label given to a PushButton in some DialogBoxes that performs the action of providing help for the DialogBox.highlight A graphic technique used to provide a visual cue to the current selection or to the current location of the input focus. Highlighting is frequently accomplished by reversing the video of the selection.hotspot The area of a graphical image used as a pointer or cursor that is defined as the point of the pointer or cursor.hourglass A graphical image used to symbolize the passage of time and provide a visual cue that the application is currently performing an operation.I-beamA graphical image used to represent the location of the mouse pointer in a text entry box and providing a visual cue that text can be entered in an area.iconA small graphical image used to represent a window. Windows can be turned into icons or minimized to save room or unclutter the workspace.icon boxA window for organizing icons.implicit focusA keyboard focus model that sends keyboard events to the window or component that the mouse pointer is over.ID="10936"insertion cursorThe graphical symbol that provides the visual cue to the location of the insertion point.keyboardAn input device consisting of various keys that allows the user to input data, control cursor and pointer locations, and to control the dialog with the workstation.keyboard focusIndicates the window or component within a window that receives keyboard input. It is sometimes called the input focus.LabelThe text part of an icon or graphical component.list boxA component that provides users with a scrollable list of options from which to choose.location cursor A graphical symbol that marks the current location of the keyboard input focus for selection. Typically, this symbol is a box that surrounds the current object.lowerTo move a window to the bottom of the window stack on the workspace.maximizeTo enlarge a window to its maximum size.maximize buttonA control button placed on a window manager window frame and used to initiate the maximize function.MenuA list of available selections from which a user chooses.Menu systemA collection of Menus cascading from a single CascadeButton.Menu windowAn application window used to contain a Menu. Menu windows are transitory.MenuBarA rectangular area at the top of the client area of a window that contains the titles of the standard Pulldown Menus for that application.MenuBar systemA collection of Menus associated with a MenuBar and the MenuBar itself.MessageBox The generic name for any DialogBox that provides information, gives the current state of a work in progress, asks a question, issues a warning, or draws attention to an error.minimize (iconfiy)To turn a window into an icon.minimize buttonA control button placed on a window manager window frame and used to initiate the minimize function.mnemonicA single character (frequently the initial character) of a Menu selection. When the Menu is displayed and the user presses the key that corresponds to that character, the Menu selection is chosen.model keyboardA fictional keyboard that contains the keys and key labels described by this guide.modifier keyA key that, when pressed with another key, changes the meaning of the other key. <Ctrl>, <Alt>, and <Shift> are modifier keys.motionMovement of the mouse.mouseA pointing device commonly used in conjunction with a keyboard in point-and-click, object- oriented user interfaces.mouse buttonA button on a mouse pointing device. Mouse buttons can be pressed, released, moved, clicked, and double-clicked.multiclickTo click a mouse button multiple times without moving the pointer.multimotionTo press a mouse button multiple times without moving the pointer and then move the mouse pointer.multiple selectionA selection model that allows multiple single selections.multipressTo press a mouse button multiple times without moving the pointer.ID="11512"navigation (traversal)An action that causes the focus to move to another component.noA label given to a PushButton in some DialogBoxes that performs the action of answering "no" and closing the DialogBox.OKA label given to a PushButton in some DialogBoxes that performs the action of answering "OK" and closing the DialogBox without implementing any changes.open To start an action or begin working with a text, data, or graphics file.pasteInserting data into an area. Pasting is commonly used in reference to text files where a block of text is cut from one area and pasted into another area.pauseA label given to a PushButton in some DialogBoxes that performs the action of pausing the action of the DialogBox.pointerThe graphical image that appears on the workspace and represents the current location of a mouse or other pointing device.pointing deviceA device such as a mouse, trackball, or graphics tablet that allows users to move a pointer about on the workspace and point to graphical objects.Popup MenuA Menu that provides no visual cue to its presence, but simply pops up when a user performs a particular action. Popup Menus are associated with a particular area of the workspace, such as the client area of an application, and a user must memorize where these areas are.postedA state of a Menu where it remains in a visible state even though a mouse button is not being held down. See alsospring-loaded.pressTo hold down a mouse button or a key.previewingA means of PushButton activation where information about the impending action of a button release is displayed on the button press action.primary modalA state of a window in which interaction is limited to that window and windows that are not ancestors of that window.primary transferA transfer mechanism where the primary selection is transferred to the destination.primary windowA top-level window of an application. Primary windows can be minimized.Pulldown MenuA Menu that is pulled down from a client application's title bar.PushButtonA graphic component that simulates a real-life push button. When a user pushes the PushButton, by pressing a key or a mouse button, an action takes place.quick transferA transfer mechanism where selected data is immediately transferred to the destination.RadioButtonA graphic component that simulates the buttons on a real-life car radio. Each button represents a mutually exclusive selection. RadioButtons are typically used for setting states or modes.range selectionA selection model that allows selection of a range of elements.releaseTo let up on a mouse button or key that has been pressed. Sometimes it is the press that initiates the action; sometimes it is the release.resetA label given to a PushButton in some DialogBoxes that performs the action of resetting the initial state of the DialogBox.resizeTo change the height or width of a window.resize borderThe window manager window frame part that surrounds the client area of an application and that is used to change the height or width of the window.restoreTo return an icon or maximized window to its normal size.resumeA label given to a PushButton in some DialogBoxes that performs the action of resuming the action of a DialogBox previously paused.retryA label given to a PushButton in some DialogBoxes that performs the action of retrying the action whose failure posted the DialogBox.saveTo write changes to a data file to a storage device for safekeeping.ScrollBarA graphical device used to change a user's view of the contents of a window. A ScrollBar consists of a slider, a trough, and scroll arrows. A user changes the view by sliding the slider up or down in the scroll area or by pressing one of the scroll arrows. These actions cause the view to scroll up or down in the window adjacent to the ScrollBar.secondary windowA child window of a primary window.selectTo choose an object to be acted upon or an action to be performed.selectionThe object or action that is selected. Menus are composed of selection items. DialogBoxes contain components, each of which represents a selection.single selectionA selection model that allows selection of a single element.sliderOne of the graphical components of a ScrollBar or Scale. The slider is the object that is dragged along the scroll area to cause a change.spring-loadedA state of a Menu where it remains only as long as a mouse button is being held down. See alsoposted.stopA label given to a PushButton in some DialogBoxes that performs the action of stopping the work in progress indicated by the DialogBox.submenuA cascading Menu.system MenuSeewindow Menu.system modalA state of a window in which interaction is limited to that window.text cursorSeeinsertion cursor.title areaThe area at the top of the window frame immediately beneath the resize border. The title bar has two functions: it contains a title or name that identifies the window, and it can be grabbed and dragged to relocate the window.title barThe bar across the top of a window manager window that consists of the window Menu button, the title area, and the window-control buttons.transient windowA window of short duration such as a DialogBox. The window is displayed for only a short time, usually just long enough to convey some information or get some operational directions.traversalSeenavigation (traversal).virtual buttonA model, used by this style guide, which defines mouse button bindings independent of the actual number of buttons on the mouse.windowA data structure that represents all or part of the display screen. Visually, a window is represented as a subarea of the display screen.window decorationThe frame and window-control buttons that surround windows managed by the window manager.window frameThe area surrounding a window. A window frame can consist of a resize border, a window Menu button, a title bar, and window-control buttons.window managerA program that controls the size, placement, and operation of windows on the workspace. The window manager includes the functional window frames that surround each window object and may include a separate Menu for the workspace.ID="23596"window MenuThe Menu that appears when the window Menu button is pressed. The window Menu typically contains selections for restoring, moving, sizing, minimizing, maximizing, and closing the window.window Menu buttonThe graphical control button that appears at the left side of the title bar in the window frame.window navigationMoving the keyboard focus among windows.workspaceThe CRT screen. The area on which the windows of a user's environment appear. The workspace is sometimes called the desk, desktop, or root window.yesA label given to a PushButton in some DialogBoxes that performs the action of answering "yes" and closing the DialogBox.accelerationIDREF="ch02105"Gain and AccelerationIDREF="ch02101"Gain and AccelerationacceleratorsIDREF="ch0910"DescriptionIDREF="ch06275"Providing Mnemonics and AcceleratorsIDREF="ch06261"Menu DesignIDREF="ch0512"AcceleratorsIDREF="ch095"DescriptionactionsIDREF="ch06287"Common DialogBox ActionsactivationIDREF="ch051"Component ActivationIDREF="ch0945"DescriptionIDREF="ch098"DescriptionIDREF="ch0530"Previewing and AutorepeatIDREF="ch0520"Help ActivationIDREF="ch0513"MnemonicsIDREF="ch0913"DescriptionIDREF="ch054"Component ActivationIDREF="ch0915"DescriptionIDREF="ch0523"Default ActivationIDREF="ch058"Basic ActivationIDREF="ch0536"Cancel ActivationIDREF="ch0525"Expert ActivationIDREF="ch0920"DescriptionIDREF="ch0362"Menu TraversalIDREF="ch0510"AcceleratorsIDREF="ch0923"DescriptionIDREF="ch0518"TearOff ActivationIDREF="ch096"Descriptionactive voiceIDREF="ch0869"Translating Screen Textactive windowIDREF="ch027"The Keyboard Focus Modelacts requiring actionsIDREF="ch0123"Anticipate Errorsadd modeIDREF="ch0450"Keyboard SelectionaddressesIDREF="ch0852"Proper Names and Addressesaffirmative statementsIDREF="ch0868"Translating Screen TextalignmentIDREF="ch06249"Arranging Components for Aligned LayoutIDREF="ch06247"Arranging Components for Aligned Layoutalphanumeric date formatsIDREF="ch0841"Date Formatsalphanumeric listsIDREF="ch0820"Collating SequencesanchorIDREF="ch0445"Mouse-Based Discontiguous SelectionIDREF="ch0461"Keyboard-Based Range SelectionIDREF="ch0435"Mouse-Based Range SelectionANS X3.159-1989IDREF="ch085"Designing for International MarketsANSI CIDREF="ch084"Designing for International Marketsapplication designIDREF="ch062"Application Design Principlesapplication modalIDREF="ch06283"DialogBox DesignIDREF="ch0744"Secondary Windows (Dialog)application titleIDREF="ch0766"Title AreaApplyIDREF="ch06292"Common DialogBox ActionsIDREF="ch0953"Descriptionarrow pointerIDREF="ch0299"Pointer ShapesIDREF="ch09247"DescriptionIDREF="ch0295"Pointer ShapesIDREF="ch09243"DescriptionIDREF="ch0288"Pointer ShapesIDREF="ch09236"DescriptionautorepeatIDREF="ch0533"Previewing and AutorepeatBalance BeamIDREF="ch0442"Mouse-Based Range SelectionbaseIDREF="ch081"Designing for International Marketsbasic activationIDREF="ch056"Basic ActivationIDREF="ch097"Descriptionbasic controlsIDREF="ch0619"Choosing ComponentsIDREF="ch0611"Choosing ComponentsIDREF="ch0621"Choosing ComponentsIDREF="ch0615"Choosing ComponentsIDREF="ch0623"Choosing ComponentsIDREF="ch065"Choosing ComponentsIDREF="ch0691"Choosing a Single-Choice ComponentIDREF="ch0625"Choosing ComponentsIDREF="ch0617"Choosing ComponentsIDREF="ch0627"Choosing ComponentsIDREF="ch0613"Choosing ComponentsIDREF="ch0629"Choosing Componentsbasic groupsIDREF="ch0644"Choosing ComponentsIDREF="ch0648"Choosing ComponentsIDREF="ch067"Choosing ComponentsIDREF="ch0650"Choosing ComponentsIDREF="appa16"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0646"Choosing ComponentsBMenuIDREF="ch09166"DescriptionIDREF="ch0268"Pointing DevicesIDREF="ch0271"Pointing DevicesboxIDREF="ch09151"DescriptionIDREF="ch07104"Icon Boxbrowse selectionsIDREF="ch09311"DescriptionIDREF="ch0455"Keyboard-Based Browse SelectionIDREF="ch0429"Mouse-Based Browse SelectionIDREF="ch0418"Selection ModelsBSelectIDREF="ch09164"DescriptionIDREF="ch0272"Pointing DevicesIDREF="ch0273"Pointing DevicesIDREF="ch059"Basic ActivationIDREF="ch099"DescriptionIDREF="ch0266"Pointing DevicesBTransferIDREF="ch0267"Pointing DevicesIDREF="ch09165"DescriptionIDREF="ch0270"Pointing DevicesbuttonsIDREF="ch0777"Minimize ButtonIDREF="ch0773"Maximize ButtonIDREF="ch0789"Window MenuIDREF="ch0790"Window MenuCancelIDREF="ch06298"Common DialogBox ActionsIDREF="ch0959"Descriptioncancel activationIDREF="ch0922"DescriptionIDREF="ch0534"Cancel Activationcanceling a selectionIDREF="ch0467"Canceling a SelectionCanvasIDREF="appa14"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0685"Guidelines for Choosing Interactive MethodsIDREF="ch0642"Choosing ComponentsIDREF="ch06112"Choosing Between Text or Canvas, and a LabelIDREF="ch0991"DescriptionIDREF="ch0936"DescriptionCascadeButtonIDREF="ch0618"Choosing ComponentsIDREF="ch0318"Mouse-Based NavigationIDREF="ch0937"DescriptionIDREF="appa7"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0927"DescriptionCheckBoxIDREF="ch06100"Choosing a Multiple-Choice ComponentCheckButtonIDREF="ch0930"DescriptionIDREF="appa5"OSF/Motif Widgets and Components CorrespondenceIDREF="ch09328"DescriptionIDREF="ch0624"Choosing ComponentsIDREF="ch0938"Descriptionchoosing componentsIDREF="ch064"Choosing ComponentsClearIDREF="ch06207"Popup MenusIDREF="ch0971"DescriptionIDREF="ch09260"DescriptionIDREF="ch06161"MenuBarClickIDREF="ch0276"Pointing Devicesclick-to-typeIDREF="ch09115"DescriptionIDREF="ch0243"Explicit Focusclient areasIDREF="ch0763"Client AreaIDREF="ch06115"Common Client Areasclipboard selection actionsIDREF="ch0480"Clipboard TransferIDREF="ch0474"Clipboard TransferIDREF="ch0486"Clipboard TransferIDREF="ch0477"Clipboard TransferIDREF="ch0483"Clipboard TransferIDREF="ch0489"Clipboard Transferclipboard transferIDREF="ch0490"Clipboard TransferIDREF="ch0478"Clipboard TransferIDREF="ch0484"Clipboard TransferIDREF="ch0475"Clipboard TransferIDREF="ch0487"Clipboard TransferIDREF="ch0481"Clipboard TransferCloseIDREF="ch0797"Window MenuIDREF="ch06291"Common DialogBox ActionsIDREF="ch09345"DescriptionIDREF="ch06151"MenuBarIDREF="ch09100"DescriptionIDREF="ch0952"Descriptioncollating sequencesIDREF="ch0818"Collating SequencescollectionsIDREF="ch045"Selection ModelsIDREF="ch049"Selection ModelsIDREF="ch0414"Selection ModelsIDREF="ch047"Selection ModelsIDREF="ch0411"Selection ModelscolorsIDREF="ch0116"Provide Natural Shades and ColorscolumnsIDREF="ch06245"Arranging Components for Aligned Layoutcommand areaIDREF="ch06126"Command AreaIDREF="ch06119"Common Client AreasCommand DialogBoxIDREF="ch06215"DialogBoxesIDREF="ch0941"DescriptionCommandBoxIDREF="ch0940"Descriptioncommon actionsIDREF="ch0948"Descriptioncommon DialogBox actionsIDREF="ch06285"Common DialogBox Actionscomponent activationIDREF="ch052"Component ActivationIDREF="ch0531"Previewing and AutorepeatIDREF="ch053"Component ActivationIDREF="ch0535"Cancel ActivationIDREF="ch0517"TearOff ActivationIDREF="ch055"Component ActivationIDREF="ch0521"Help ActivationIDREF="ch057"Basic ActivationIDREF="ch0946"DescriptionIDREF="ch0524"Default ActivationIDREF="ch0511"AcceleratorsIDREF="ch0527"Expert ActivationIDREF="ch0514"Mnemonicscomponent navigationIDREF="ch0349"Component NavigationcomponentsIDREF="ch09325"DescriptionIDREF="ch06308"Avoiding Component ModesIDREF="ch0756"Window DecorationsIDREF="ch06236"Grouping ComponentsIDREF="ch06237"Grouping ComponentsIDREF="ch0699"Choosing a Multiple-Choice ComponentIDREF="ch0679"Guidelines for Choosing Interactive MethodsIDREF="ch0675"Guidelines for Choosing Interactive MethodsIDREF="ch0694"Choosing a Single-Choice ComponentIDREF="ch063"Choosing ComponentsIDREF="ch0688"Choosing a Single-Choice ComponentIDREF="ch0677"Guidelines for Choosing Interactive MethodsIDREF="ch06318"Component DesignIDREF="ch039"NavigationIDREF="ch06307"Avoiding Component ModesCompositeIDREF="appa21"OSF/Motif Widgets and Components CorrespondenceCompositionIDREF="ch09175"DescriptionIDREF="ch0943"DescriptionIDREF="ch0651"Choosing ComponentsconfigurabilityIDREF="ch073"ConfigurabilityconsistencyIDREF="ch0120"Keep Interfaces ConsistentIDREF="ch0118"Keep Interfaces ConsistentIDREF="ch0117"Keep Interfaces Consistentcontext-sensitive helpIDREF="ch0126"Anticipate ErrorsIDREF="ch06181"MenuBarIDREF="ch09134"DescriptioncontrastIDREF="ch0115"Provide Natural Shades and Colorscontrol panelIDREF="ch06239"Grouping Similar ComponentscontrolsIDREF="ch091"Controls, Groups, and Models Reference PagesCopyIDREF="ch06203"Popup MenusIDREF="ch06157"MenuBarIDREF="ch0498"Primary TransferIDREF="ch0482"Clipboard TransferIDREF="ch09276"DescriptionIDREF="ch09293"DescriptionIDREF="ch0967"DescriptionIDREF="ch04112"Quick TransferIDREF="ch09256"DescriptionCopy LinkIDREF="ch09257"DescriptionIDREF="ch0485"Clipboard TransferIDREF="ch0968"DescriptionIDREF="ch06158"MenuBarIDREF="ch06204"Popup Menuscorner handlesIDREF="ch0782"Resize Borderscountry-specific data formatsIDREF="ch0821"Country-Specific Data FormatscurrencyIDREF="ch0838"CurrencycursorIDREF="ch0452"Keyboard SelectionIDREF="ch036"NavigationIDREF="ch0329"Location CursorIDREF="ch0321"Keyboard-Based NavigationIDREF="ch0352"Component NavigationIDREF="ch0331"Location CursorIDREF="ch0242"Explicit FocusIDREF="ch0323"Location CursorIDREF="ch0324"Location CursorIDREF="ch0210"The Keyboard Focus ModelIDREF="ch0326"Location CursorIDREF="ch0359"Component NavigationIDREF="ch0215"The Keyboard Focus ModelCutIDREF="ch06202"Popup MenusIDREF="ch0966"DescriptionIDREF="ch06156"MenuBarIDREF="ch04115"Quick TransferIDREF="ch0479"Clipboard TransferIDREF="ch09296"DescriptionIDREF="ch09255"Descriptiondata formatsIDREF="ch0836"CurrencyIDREF="ch0837"CurrencyIDREF="ch0823"Country-Specific Data Formatsdate formatsIDREF="ch0839"Date Formatsdecimal separatorsIDREF="ch0828"Decimal SeparatorsdecorationIDREF="ch0752"Window Decorationsdefault actionIDREF="ch0944"DescriptionIDREF="ch0917"DescriptionIDREF="ch0522"Default Activationdefault PushButtonIDREF="ch06305"Showing Default ActionsdefaultsIDREF="ch06306"Showing Default ActionsdelayIDREF="ch06313"Showing ProgressDeleteIDREF="ch06208"Popup MenusIDREF="ch0972"DescriptionIDREF="ch06162"MenuBarIDREF="ch09261"DescriptionDeselect AllIDREF="ch0974"DescriptionIDREF="ch09263"DescriptionIDREF="ch06210"Popup MenusIDREF="ch06164"MenuBardeselectingIDREF="ch0468"Selecting and Deselecting All ElementsdesignIDREF="ch06280"DialogBox DesignIDREF="ch0284"Pointer ShapesIDREF="ch09234"DescriptionIDREF="ch011"User Interface Design PrinciplesIDREF="ch06319"Component DesignIDREF="ch071"Window Manager Design PrinciplesIDREF="ch0856"Icons, Symbols, and Pointer ShapesIDREF="ch0857"Icons, Symbols, and Pointer ShapesIDREF="ch0858"Icons, Symbols, and Pointer ShapesIDREF="ch061"Application Design Principlesdestructive actionsIDREF="ch06273"Separating Destructive ActionsDialogBoxIDREF="appa27"OSF/Motif Widgets and Components CorrespondenceIDREF="ch06286"Common DialogBox ActionsIDREF="ch0342"Window NavigationIDREF="ch0979"DescriptionIDREF="ch06222"DialogBoxesIDREF="ch06117"Common Client AreasIDREF="ch0942"DescriptionIDREF="ch0947"DescriptionIDREF="ch06224"DialogBoxesIDREF="ch06266"Keeping Menu Structures SimpleIDREF="ch0671"Guidelines for Choosing a Main Component GroupIDREF="ch09206"DescriptionIDREF="ch06226"DialogBoxesIDREF="ch09347"DescriptionIDREF="ch0610"Choosing ComponentsIDREF="ch06228"DialogBoxesIDREF="ch06300"Determining DialogBox Location and SizeIDREF="ch06301"Determining DialogBox Location and SizeIDREF="ch06214"DialogBoxesIDREF="ch0715"Window SupportIDREF="ch06230"DialogBoxesIDREF="ch09284"DescriptionIDREF="ch06216"DialogBoxesIDREF="ch09155"DescriptionIDREF="ch09321"DescriptionIDREF="ch09287"DescriptionIDREF="ch06232"DialogBoxesIDREF="ch0673"Guidelines for Choosing a Main Component GroupIDREF="ch06234"DialogBoxesIDREF="ch06279"DialogBox DesignIDREF="ch06218"DialogBoxesIDREF="ch09330"DescriptionIDREF="ch0669"Guidelines for Choosing a Main Component GroupIDREF="ch09104"DescriptionIDREF="ch06220"DialogBoxesDialogBox groupsIDREF="ch0662"Choosing Componentsdirect manipulationIDREF="ch0269"Pointing DevicesIDREF="ch018"Allow Direct ManipulationIDREF="ch0110"Allow Direct Manipulationdisabling componentsIDREF="ch06310"Showing Unavailable Componentsdiscontiguous selectionIDREF="ch0462"Keyboard-Based Discontiguous SelectionIDREF="ch0443"Mouse-Based Discontiguous SelectionIDREF="ch0424"Selection ModelsIDREF="ch09317"Descriptiondouble-clickingIDREF="ch0921"DescriptionIDREF="ch0529"Expert Activationdrag and dropIDREF="ch0962"DescriptionIDREF="ch04119"Drag Transferdrag and drop modelIDREF="ch0961"Descriptiondrag transferIDREF="ch04120"Drag Transferedge handlesIDREF="ch0783"Resize BordersEdit MenuIDREF="ch06136"MenuBarIDREF="ch06153"MenuBarIDREF="ch09189"DescriptionIDREF="ch0963"DescriptionEnlarge OnlyIDREF="ch0441"Mouse-Based Range SelectionError DialogBoxIDREF="ch06225"DialogBoxesIDREF="ch0978"DescriptionErrorDialogIDREF="ch09207"DescriptionerrorsIDREF="ch0124"Anticipate ErrorsExitIDREF="ch09101"DescriptionIDREF="ch06152"MenuBarexpert actionIDREF="ch0918"DescriptionIDREF="ch0528"Expert Activationexpert activationIDREF="ch0526"Expert ActivationIDREF="ch0919"Descriptionexplicit destructionIDREF="ch0128"Use Explicit Destructionexplicit focusIDREF="ch0235"Explicit FocusIDREF="ch09106"DescriptionIDREF="ch09113"Descriptionextension modelsIDREF="ch0447"Mouse-Based Discontiguous SelectionIDREF="ch0439"Mouse-Based Range SelectionfeedbackIDREF="ch06303"InteractionIDREF="ch06311"Providing FeedbackIDREF="ch0122"Give the User Feedbackfield controlsIDREF="ch0984"DescriptionIDREF="ch0643"Choosing ComponentsIDREF="ch0986"DescriptionIDREF="ch066"Choosing ComponentsIDREF="ch0988"DescriptionIDREF="ch0637"Choosing ComponentsIDREF="appa9"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0990"DescriptionIDREF="ch0992"DescriptionIDREF="ch0630"Choosing ComponentsIDREF="ch0639"Choosing ComponentsIDREF="ch0980"DescriptionIDREF="ch0635"Choosing ComponentsIDREF="ch0982"DescriptionIDREF="ch0641"Choosing Componentsfield navigationIDREF="ch0356"Component NavigationfieldsIDREF="ch0354"Component NavigationFile MenuIDREF="ch09185"DescriptionIDREF="ch06132"MenuBarIDREF="ch06144"MenuBarIDREF="ch0993"DescriptionFileSelection DialogBoxIDREF="ch09103"DescriptionIDREF="ch06217"DialogBoxesFileSelectionBoxIDREF="appa29"OSF/Motif Widgets and Components CorrespondenceIDREF="ch09102"DescriptionfillIDREF="ch0332"Location Cursorfixed layoutIDREF="ch06241"Arranging Components for Fixed LayoutflexibilityIDREF="ch06317"Allowing User FlexibilityIDREF="ch013"Keep Interfaces FlexiblefocusIDREF="ch09112"DescriptionIDREF="ch09114"DescriptionIDREF="ch0221"Implicit FocusIDREF="ch0252"Explicit FocusIDREF="ch0218"The Keyboard Focus ModelIDREF="ch0233"Implicit FocusIDREF="ch024"Input ModelsIDREF="ch0236"Explicit FocusIDREF="ch0224"Implicit FocusIDREF="ch09107"DescriptionIDREF="ch09108"DescriptionIDREF="ch0238"Explicit FocusIDREF="ch0217"The Keyboard Focus ModelIDREF="ch0250"Explicit Focusfocus policiesIDREF="ch0232"Implicit FocusIDREF="ch0219"The Keyboard Focus ModelIDREF="ch0237"Explicit FocusIDREF="ch0249"Explicit FocusIDREF="ch0251"Explicit FocusIDREF="ch0222"Implicit FocusIDREF="ch09109"DescriptionformatsIDREF="ch0870"Translating Screen TextIDREF="ch0824"Country-Specific Data FormatsIDREF="ch0846"Telephone NumbersIDREF="ch0843"Date FormatsIDREF="ch0853"Proper Names and AddressesIDREF="ch0844"Time Formatsfour-directional arrow pointerIDREF="ch09242"DescriptionIDREF="ch0294"Pointer ShapesFrameIDREF="ch09118"DescriptionIDREF="ch09116"DescriptionIDREF="appa24"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0656"Choosing Componentsframing groupsIDREF="ch0659"Choosing ComponentsIDREF="ch09117"DescriptionIDREF="appa23"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0655"Choosing ComponentsIDREF="ch0661"Choosing ComponentsIDREF="ch0657"Choosing ComponentsIDREF="ch069"Choosing ComponentsgainIDREF="ch02102"Gain and AccelerationIDREF="ch02100"Gain and AccelerationgraphicsIDREF="ch06304"Using Graphics to Show Actiongraphics tabletIDREF="ch0263"Pointing DevicesIDREF="ch09158"Descriptiongraphics-like collectionsIDREF="ch0413"Selection ModelsIDREF="ch048"Selection Modelsgroup referenceIDREF="ch092"Controls, Groups, and Models Reference PagesgroupingIDREF="ch06238"Grouping Similar ComponentsIDREF="ch0830"Grouping SeparatorsIDREF="ch06235"Grouping ComponentsIDREF="ch06267"Grouping Like Menu Elements TogetherhandlesIDREF="ch0784"Resize BordershelpIDREF="ch09147"DescriptionIDREF="ch06184"MenuBarIDREF="ch06315"Providing HelpIDREF="ch06316"Providing HelpIDREF="ch0125"Anticipate ErrorsIDREF="ch06186"MenuBarIDREF="ch0519"Help ActivationIDREF="ch06188"MenuBarIDREF="ch09124"DescriptionIDREF="ch09195"DescriptionIDREF="ch06176"MenuBarIDREF="ch06190"MenuBarIDREF="ch06171"MenuBarIDREF="ch06192"MenuBarIDREF="ch09129"DescriptionIDREF="ch06178"MenuBarIDREF="ch09131"DescriptionIDREF="ch06194"MenuBarIDREF="ch09133"DescriptionIDREF="ch09135"DescriptionIDREF="ch06142"MenuBarIDREF="ch09137"DescriptionIDREF="ch06299"Common DialogBox ActionsIDREF="ch09139"DescriptionIDREF="ch06180"MenuBarIDREF="ch09141"DescriptionIDREF="ch06182"MenuBarIDREF="ch09143"DescriptionIDREF="ch0960"DescriptionIDREF="ch09145"DescriptionIDREF="ch06168"MenuBarhelp activationIDREF="ch0914"DescriptionHelp MenuIDREF="ch09121"Descriptionhorizontal alignmentIDREF="ch06248"Arranging Components for Aligned Layouthot keyIDREF="ch074"ConfigurabilityhotspotIDREF="ch09235"DescriptionIDREF="ch0285"Pointer ShapesI-beam pointerIDREF="ch09238"DescriptionIDREF="ch0290"Pointer Shapesicon boxIDREF="ch09150"DescriptionIDREF="ch07103"Icon Boxicon MenuIDREF="ch07101"Icon MenuIDREF="ch09148"Descriptioniconized windowIDREF="ch0728"Primary WindowiconsIDREF="ch0854"Icons, Symbols, and Pointer ShapesIDREF="ch09153"DescriptionIDREF="ch07100"IconsIDREF="ch0734"Primary Windowimmediacy of responseIDREF="ch0112"Provide Rapid Responseimplicit focusIDREF="ch09105"DescriptionIDREF="ch0220"Implicit FocusIDREF="ch09111"DescriptionIDREF="ch0234"Implicit FocusIndexIDREF="ch06175"MenuBarIDREF="ch09128"DescriptionIDREF="ch09138"DescriptionIDREF="ch06185"MenuBarInformation DialogBoxIDREF="ch06227"DialogBoxesInformationDialogIDREF="ch09154"DescriptionIDREF="ch09208"DescriptioninputIDREF="ch09171"Descriptioninput devicesIDREF="ch023"Input ModelsIDREF="ch09156"DescriptionIDREF="ch0253"The Input Device Modelinput focusIDREF="ch025"The Keyboard Focus ModelinteractionsIDREF="ch06302"Interactioninteractive methodsIDREF="ch0674"Guidelines for Choosing Interactive MethodsinterapplicationIDREF="ch0121"Keep Interfaces Consistentinternal window navigationIDREF="ch0244"Explicit FocusinternationalizationIDREF="ch0822"Country-Specific Data FormatsIDREF="ch0840"Date FormatsIDREF="ch0825"Country-Specific Data FormatsIDREF="ch0865"Translating Screen TextIDREF="ch0813"Displaying StatusIDREF="ch087"Internationalized Text InputIDREF="ch0848"Telephone NumbersIDREF="ch0849"Telephone NumbersIDREF="ch0815"Converting Pre-Edit Characters to Final CharactersIDREF="ch088"Locating the Pre-Edit AreaIDREF="ch0817"Collating SequencesIDREF="ch082"Designing for International MarketsIDREF="ch0860"Icons, Symbols, and Pointer ShapesIDREF="ch0834"Positive and Negative Valuesintraapplication consistencyIDREF="ch0119"Keep Interfaces Consistentitem cursorIDREF="ch0330"Location CursorjoystickIDREF="ch09159"DescriptionIDREF="ch0265"Pointing DeviceskeyboardIDREF="ch0223"Implicit FocusIDREF="ch09215"DescriptionIDREF="ch026"The Keyboard Focus ModelIDREF="ch0213"The Keyboard Focus ModelIDREF="ch032"NavigationIDREF="ch0257"The Input Device ModelIDREF="ch034"NavigationIDREF="ch09163"DescriptionIDREF="ch09222"DescriptionIDREF="ch0214"The Keyboard Focus ModelIDREF="ch09168"DescriptionIDREF="ch09169"DescriptionIDREF="ch06187"MenuBarIDREF="ch09140"DescriptionIDREF="ch09110"DescriptionIDREF="ch022"Input ModelsIDREF="ch0353"Component NavigationIDREF="ch09213"Descriptionkeyboard-based operationsIDREF="ch0247"Explicit FocuskeyboardsIDREF="ch09172"DescriptionLabelIDREF="ch09173"DescriptionIDREF="ch0686"Guidelines for Choosing Interactive MethodsIDREF="ch06113"Choosing Between Text or Canvas, and a LabelIDREF="ch0925"DescriptionIDREF="ch0614"Choosing ComponentsIDREF="appa2"OSF/Motif Widgets and Components Correspondencelanguage independentIDREF="ch0859"Icons, Symbols, and Pointer ShapeslayoutIDREF="ch06244"Arranging Components for Resizing LayoutIDREF="ch06242"Arranging Components for Fixed LayoutIDREF="ch06114"Layoutlayout groupsIDREF="ch0654"Choosing ComponentsIDREF="ch09174"DescriptionIDREF="ch0652"Choosing ComponentsIDREF="ch068"Choosing ComponentsIDREF="appa20"OSF/Motif Widgets and Components CorrespondencelinkIDREF="ch04104"Primary TransferIDREF="ch09282"DescriptionIDREF="ch09299"DescriptionIDREF="ch04118"Quick TransferListIDREF="ch0697"Choosing a Single-Choice ComponentIDREF="ch0987"DescriptionIDREF="ch0692"Choosing a Single-Choice ComponentIDREF="ch09179"DescriptionIDREF="ch06101"Choosing a Multiple-Choice ComponentIDREF="ch0638"Choosing ComponentsIDREF="appa15"OSF/Motif Widgets and Components Correspondencelist-like collectionsIDREF="ch0410"Selection ModelsIDREF="ch0412"Selection ModelsIDREF="ch044"Selection ModelslocalizationIDREF="ch083"Designing for International Marketslocation cursorIDREF="ch0325"Location CursorIDREF="ch0351"Component NavigationIDREF="ch035"NavigationIDREF="ch0451"Keyboard SelectionIDREF="ch029"The Keyboard Focus ModelIDREF="ch0358"Component NavigationIDREF="ch0241"Explicit FocusIDREF="ch0320"Keyboard-Based NavigationIDREF="ch0322"Location CursorLowerIDREF="ch09340"DescriptionIDREF="ch0796"Window Menumain component groupsIDREF="ch0663"Guidelines for Choosing a Main Component Groupmain windowsIDREF="ch0726"Primary WindowIDREF="ch0334"Window NavigationIDREF="ch078"Window SupportMainWindowIDREF="ch0660"Choosing ComponentsIDREF="ch06125"MainWindowIDREF="ch0665"Guidelines for Choosing a Main Component GroupIDREF="ch0672"Guidelines for Choosing a Main Component GroupIDREF="ch09120"DescriptionIDREF="ch06116"Common Client AreasIDREF="appa26"OSF/Motif Widgets and Components CorrespondenceIDREF="ch09180"DescriptionIDREF="ch06123"MainWindowmanipulationIDREF="ch019"Allow Direct ManipulationIDREF="ch0111"Allow Direct Manipulationmarquee selectionIDREF="ch0437"Mouse-Based Range SelectionMaximizeIDREF="ch0795"Window MenuIDREF="ch09339"Descriptionmaximize buttonIDREF="ch0771"Maximize ButtonIDREF="ch0759"Window DecorationsMenuIDREF="ch0670"Guidelines for Choosing a Main Component GroupIDREF="ch0664"Guidelines for Choosing a Main Component GroupIDREF="ch0934"DescriptionIDREF="ch0666"Guidelines for Choosing a Main Component GroupIDREF="ch06102"Choosing Among Menus and PanelsIDREF="ch09198"DescriptionIDREF="ch0680"Guidelines for Choosing Interactive MethodsIDREF="ch0667"Guidelines for Choosing a Main Component GroupIDREF="ch06118"Common Client AreasIDREF="appa18"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0647"Choosing ComponentsMenu systemIDREF="ch0361"Menu TraversalMenu traversalIDREF="ch0360"Menu TraversalMenuBarIDREF="ch0649"Choosing ComponentsIDREF="ch06129"MenuBarIDREF="ch06122"Common Client AreasIDREF="ch09183"DescriptionIDREF="ch0363"Menu TraversalIDREF="appa19"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0935"DescriptionIDREF="ch0316"Mouse-Based NavigationMenusIDREF="ch06133"MenuBarIDREF="ch09225"DescriptionIDREF="ch07102"Icon MenuIDREF="ch06141"MenuBarIDREF="ch06259"Menu DesignIDREF="ch06143"MenuBarIDREF="ch06262"Keeping Menu Structures SimpleIDREF="ch09331"DescriptionIDREF="ch09332"DescriptionIDREF="ch09186"DescriptionIDREF="ch09122"DescriptionIDREF="ch09188"DescriptionIDREF="ch09190"DescriptionIDREF="ch0750"Menu WindowsIDREF="ch09192"DescriptionIDREF="ch09341"DescriptionIDREF="ch09342"DescriptionIDREF="ch06145"MenuBarIDREF="ch09194"DescriptionIDREF="ch09196"DescriptionIDREF="ch09197"DescriptionIDREF="ch0317"Mouse-Based NavigationIDREF="ch09249"DescriptionIDREF="ch09200"DescriptionIDREF="ch06135"MenuBarIDREF="ch09202"DescriptionIDREF="ch0964"DescriptionIDREF="ch09204"DescriptionIDREF="ch06268"Grouping Like Menu Elements TogetherIDREF="ch06137"MenuBarIDREF="ch06169"MenuBarIDREF="ch06196"Popup MenusIDREF="ch0787"Window MenuIDREF="ch09149"DescriptionIDREF="ch0788"Window MenuIDREF="ch06272"Listing Menu Selections by Order of UseIDREF="ch037"NavigationIDREF="ch06139"MenuBarIDREF="ch0722"Window SupportIDREF="ch06154"MenuBarIDREF="ch0994"Descriptionmessage areaIDREF="ch06127"Message AreaIDREF="ch06120"Common Client AreasMessage DialogBoxIDREF="ch09205"DescriptionIDREF="ch06223"DialogBoxesMessageBoxIDREF="appa31"OSF/Motif Widgets and Components CorrespondencemessagesIDREF="ch0871"Translating Screen TextmetaphorsIDREF="ch016"Use Real-World MetaphorsMinimizeIDREF="ch0794"Window MenuIDREF="ch09338"Descriptionminimize buttonIDREF="ch0775"Minimize ButtonIDREF="ch0760"Window Decorationsminimized windowIDREF="ch0729"Primary WindowmnemonicsIDREF="ch0472"Using Mnemonics for ElementsIDREF="ch09211"DescriptionIDREF="ch06260"Menu DesignIDREF="ch0515"MnemonicsIDREF="ch06276"Providing Mnemonics and AcceleratorsIDREF="ch0911"Descriptionmodel keyboardIDREF="ch09170"DescriptionmodelessIDREF="ch06281"DialogBox DesignIDREF="ch0742"Secondary Windows (Dialog)modelsIDREF="ch042"SelectionIDREF="ch093"Controls, Groups, and Models Reference PagesIDREF="ch021"Input ModelsmodesIDREF="ch06309"Avoiding Component ModesMotionIDREF="ch0277"Pointing DevicesmouseIDREF="ch0262"Pointing DevicesIDREF="ch0212"The Keyboard Focus ModelIDREF="ch033"NavigationIDREF="ch09157"Descriptionmouse inputIDREF="ch0258"The Input Device Modelmouse pointerIDREF="ch0225"Implicit FocusIDREF="ch0239"Explicit Focusmouse pointer shapesIDREF="ch09233"DescriptionIDREF="ch0283"Pointer Shapesmouse-based navigationIDREF="ch0311"Mouse-Based NavigationMoveIDREF="ch0792"Window MenuIDREF="ch04101"Primary TransferIDREF="ch09279"DescriptionIDREF="ch09336"DescriptionMultiClickIDREF="ch0278"Pointing DevicesMultiMotionIDREF="ch0280"Pointing Devicesmultiple cascading submenusIDREF="ch06264"Keeping Menu Structures Simplemultiple MainWindowsIDREF="ch06124"MainWindowmultiple selectionIDREF="ch0420"Selection ModelsIDREF="ch0457"Keyboard-Based Multiple SelectionIDREF="ch0431"Mouse-Based Multiple Selectionmultiple selectionsIDREF="ch09313"Descriptionmultiple windowsIDREF="ch0769"Title AreaIDREF="ch0767"Title Areamultiple-choice componentsIDREF="ch0678"Guidelines for Choosing Interactive MethodsIDREF="ch0698"Choosing a Multiple-Choice ComponentMultiPressIDREF="ch0279"Pointing Devicesnational numbersIDREF="ch0850"Telephone NumbersnavigationIDREF="ch0310"Mouse-Based NavigationIDREF="ch09218"DescriptionIDREF="ch0366"Scrollable Component NavigationIDREF="ch0245"Explicit FocusIDREF="ch09221"DescriptionIDREF="ch0350"Component NavigationIDREF="ch0369"Scrollable Component NavigationIDREF="ch0799"Window NavigationIDREF="ch031"NavigationIDREF="ch0357"Component NavigationIDREF="ch09212"DescriptionIDREF="ch09214"DescriptionIDREF="ch0114"Make Navigation EasyNewIDREF="ch0995"DescriptionIDREF="ch06146"MenuBarNoIDREF="ch06289"Common DialogBox ActionsIDREF="ch0950"Descriptionnormal modeIDREF="ch0449"Keyboard SelectionnumbersIDREF="ch0835"Positive and Negative Valuesnumeric date formatsIDREF="ch0842"Date Formatsobject-action selection modelIDREF="ch043"SelectionOKIDREF="ch0951"DescriptionIDREF="ch06290"Common DialogBox ActionsOn ContextIDREF="ch09123"DescriptionIDREF="ch06170"MenuBarOn HelpIDREF="ch06172"MenuBarIDREF="ch09125"DescriptionOn KeysIDREF="ch06174"MenuBarIDREF="ch09127"DescriptionOn VersionIDREF="ch06179"MenuBarIDREF="ch09132"DescriptionOn WindowIDREF="ch09126"DescriptionIDREF="ch06173"MenuBarOpenIDREF="ch0996"DescriptionIDREF="ch06147"MenuBaroperationIDREF="ch09161"DescriptionIDREF="ch09162"DescriptionIDREF="ch0248"Explicit FocusIDREF="ch0254"The Input Device ModelIDREF="ch0255"The Input Device ModelOption MenusIDREF="ch06257"Menu DesignOptionButtonIDREF="ch0690"Choosing a Single-Choice ComponentIDREF="appa8"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0696"Choosing a Single-Choice ComponentIDREF="ch0928"DescriptionIDREF="ch09223"DescriptionIDREF="ch0620"Choosing ComponentsOptions MenuIDREF="ch0315"Mouse-Based NavigationIDREF="ch09224"DescriptionIDREF="ch06140"MenuBarIDREF="ch09203"DescriptionIDREF="ch09193"DescriptionorderingIDREF="ch014"Use Progressive DisclosureIDREF="ch06270"Listing Menu Selections by Frequency of Useordering Menu selectionsIDREF="ch06271"Listing Menu Selections by Order of Useoutline highlightIDREF="ch0327"Location CursorOverviewIDREF="ch09136"DescriptionIDREF="ch06183"MenuBarPack IconsIDREF="ch09152"DescriptionIDREF="ch07105"Icon BoxPanedWindowIDREF="ch06251"Arranging Components in PanedWindowsIDREF="ch09176"DescriptionIDREF="ch09303"DescriptionIDREF="ch09226"DescriptionIDREF="appa22"OSF/Motif Widgets and Components CorrespondenceIDREF="ch06252"Arranging Components in PanedWindowsIDREF="ch0653"Choosing ComponentsIDREF="ch0633"Choosing ComponentsPanelIDREF="ch06108"Choosing Among Menus and PanelsIDREF="ch06109"Choosing Among Menus and PanelsIDREF="ch0683"Guidelines for Choosing Interactive MethodsIDREF="ch09230"DescriptionIDREF="appa17"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0645"Choosing ComponentsIDREF="ch0933"DescriptionIDREF="ch06107"Choosing Among Menus and PanelspanelsIDREF="ch06240"Grouping Similar ComponentsPanesIDREF="ch06254"Arranging Components in PanedWindowsIDREF="ch09177"DescriptionIDREF="ch09228"DescriptionIDREF="ch0632"Choosing Componentsparent windowsIDREF="ch0737"Secondary Windows (Dialog)partsIDREF="ch0755"Window DecorationsPasteIDREF="ch06205"Popup MenusIDREF="ch0969"DescriptionIDREF="ch06159"MenuBarIDREF="ch0488"Clipboard TransferIDREF="ch09258"DescriptionPaste LinkIDREF="ch09259"DescriptionIDREF="ch0491"Clipboard TransferIDREF="ch06160"MenuBarIDREF="ch0970"DescriptionIDREF="ch06206"Popup MenusPauseIDREF="ch0956"DescriptionIDREF="ch06295"Common DialogBox Actionspointer navigationIDREF="ch0312"Mouse-Based Navigationpointer shapesIDREF="ch0281"Pointer ShapesIDREF="ch0855"Icons, Symbols, and Pointer ShapesIDREF="ch0286"Pointer ShapesIDREF="ch09231"DescriptionpointersIDREF="ch09241"DescriptionIDREF="ch09244"DescriptionIDREF="ch0291"Pointer ShapesIDREF="ch09246"DescriptionIDREF="ch0227"Implicit FocusIDREF="ch0293"Pointer ShapesIDREF="ch0296"Pointer ShapesIDREF="ch0230"Implicit FocusIDREF="ch0298"Pointer ShapesIDREF="ch0226"Implicit FocusIDREF="ch0240"Explicit FocusIDREF="ch02106"Warp Pointer Only If Explicitly EnabledIDREF="ch0261"Pointing DevicesIDREF="ch09237"DescriptionIDREF="ch09239"DescriptionIDREF="ch0289"Pointer Shapespointing devicesIDREF="ch0260"Pointing DevicesIDREF="ch0259"The Input Device ModelIDREF="ch09167"DescriptionPopup MenusIDREF="ch09201"DescriptionIDREF="ch06195"Popup MenusIDREF="ch06105"Choosing Among Menus and PanelsIDREF="ch06256"Menu DesignIDREF="ch0916"DescriptionIDREF="ch0314"Mouse-Based NavigationIDREF="ch09248"Descriptionpositive and negative valuesIDREF="ch0832"Positive and Negative ValuesPOSIX 1003.1IDREF="ch086"Designing for International Marketspre-edit areaIDREF="ch089"Locating the Pre-Edit AreaIDREF="ch0816"Converting Pre-Edit Characters to Final CharactersIDREF="ch0810"Locating the Pre-Edit AreaIDREF="ch0811"Locating the Pre-Edit AreaIDREF="ch0812"Locating the Pre-Edit AreaPressIDREF="ch0274"Pointing DevicespreviewingIDREF="ch0532"Previewing and AutorepeatPrimary CopyIDREF="ch06200"Popup MenusIDREF="ch09253"DescriptionPrimary LinkIDREF="ch09254"DescriptionIDREF="ch06201"Popup Menusprimary modalIDREF="ch0743"Secondary Windows (Dialog)IDREF="ch06282"DialogBox DesignPrimary MoveIDREF="ch09252"DescriptionIDREF="ch06199"Popup Menusprimary selectionIDREF="ch0496"Primary TransferIDREF="ch0494"Primary TransferIDREF="ch0499"Primary TransferIDREF="ch09271"DescriptionIDREF="ch09272"DescriptionIDREF="ch0493"Primary TransferIDREF="ch09274"DescriptionIDREF="ch04102"Primary TransferIDREF="ch09277"DescriptionIDREF="ch09267"DescriptionIDREF="ch09280"Descriptionprimary transferIDREF="ch09273"DescriptionIDREF="ch09275"DescriptionIDREF="ch09278"DescriptionIDREF="ch09281"DescriptionIDREF="ch0495"Primary TransferIDREF="ch0497"Primary TransferIDREF="ch09268"DescriptionIDREF="ch04100"Primary TransferIDREF="ch04103"Primary Transferprimary windowsIDREF="ch077"Window SupportIDREF="ch0716"Window SupportIDREF="ch0335"Window NavigationIDREF="ch0344"Window NavigationIDREF="ch0724"Primary WindowPrintIDREF="ch0999"DescriptionIDREF="ch06150"MenuBarProduct InformationIDREF="ch06193"MenuBarIDREF="ch09146"DescriptionprogressIDREF="ch06312"Showing Progressprogressive disclosureIDREF="ch015"Use Progressive DisclosurePromoteIDREF="ch0977"DescriptionIDREF="ch06167"MenuBarIDREF="ch09266"DescriptionIDREF="ch06213"Popup MenusPrompt DialogBoxIDREF="ch06219"DialogBoxesIDREF="ch09283"DescriptionPromptBoxIDREF="appa30"OSF/Motif Widgets and Components Correspondenceproper namesIDREF="ch0851"Proper Names and AddressesPropertiesIDREF="ch09250"DescriptionIDREF="ch06197"Popup MenusprototypesIDREF="ch012"Adopt the User's PerspectivePulldownIDREF="ch09199"DescriptionPulldown MenuIDREF="ch06130"MenuBarIDREF="ch09184"DescriptionPulldown MenusIDREF="ch0313"Mouse-Based NavigationIDREF="ch06106"Choosing Among Menus and PanelsIDREF="ch06255"Menu DesignPushButtonIDREF="appa3"OSF/Motif Widgets and Components CorrespondenceIDREF="ch09285"DescriptionIDREF="ch0616"Choosing ComponentsIDREF="ch0926"DescriptionQuestion DialogBoxIDREF="ch09286"DescriptionIDREF="ch06229"DialogBoxesQuestionDialogIDREF="ch09209"Descriptionquick selectionIDREF="ch04110"Quick TransferIDREF="ch09291"DescriptionIDREF="ch04116"Quick TransferIDREF="ch09294"DescriptionIDREF="ch04105"Quick TransferIDREF="ch09297"DescriptionIDREF="ch09288"DescriptionIDREF="ch04113"Quick Transferquick transferIDREF="ch04114"Quick TransferIDREF="ch04117"Quick TransferIDREF="ch09289"DescriptionIDREF="ch04106"Quick TransferIDREF="ch09292"DescriptionIDREF="ch09295"DescriptionIDREF="ch09298"DescriptionIDREF="ch04111"Quick TransferRadioBoxIDREF="ch0695"Choosing a Single-Choice ComponentIDREF="ch0689"Choosing a Single-Choice ComponentRadioButtonIDREF="ch0626"Choosing ComponentsIDREF="appa6"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0931"DescriptionIDREF="ch09327"DescriptionIDREF="ch09300"Descriptionrange selectionIDREF="ch0459"Keyboard-Based Range SelectionIDREF="ch0433"Mouse-Based Range SelectionIDREF="ch09315"DescriptionIDREF="ch0422"Selection Modelsreading directionIDREF="ch0862"Scanning Directionreal world metaphorsIDREF="ch017"Use Real-World Metaphorsreal-estate drivenIDREF="ch0231"Implicit Focusreference pagesIDREF="ch094"Controls, Groups, and Models Reference Pagesrelated itemsIDREF="ch06269"Grouping Like Menu Elements TogetherReleaseIDREF="ch0275"Pointing DevicesReselectIDREF="ch06166"MenuBarIDREF="ch06212"Popup MenusIDREF="ch0976"DescriptionIDREF="ch0440"Mouse-Based Range SelectionIDREF="ch09265"DescriptionResetIDREF="ch06297"Common DialogBox ActionsIDREF="ch0958"Descriptionresize borderIDREF="ch0780"Resize BordersIDREF="ch0761"Window Decorationsresizing layoutIDREF="ch06243"Arranging Components for Resizing Layoutresponse immediacyIDREF="ch0113"Provide Rapid ResponseRestoreIDREF="ch0791"Window MenuIDREF="ch09335"DescriptionIDREF="ch0774"Maximize ButtonResumeIDREF="ch06296"Common DialogBox ActionsIDREF="ch0957"DescriptionRetryIDREF="ch0954"DescriptionIDREF="ch06293"Common DialogBox ActionsSashIDREF="ch09302"DescriptionIDREF="appa12"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0631"Choosing ComponentsIDREF="ch09229"DescriptionIDREF="ch0981"DescriptionSaveIDREF="ch06148"MenuBarIDREF="ch0997"DescriptionSave AsIDREF="ch0998"DescriptionIDREF="ch06149"MenuBarScaleIDREF="ch09305"DescriptionIDREF="ch0983"DescriptionIDREF="appa11"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0634"Choosing Componentsscanning directionIDREF="ch0861"Scanning Directionscrollable component navigationIDREF="ch038"NavigationIDREF="ch0365"Scrollable Component NavigationIDREF="ch0367"Scrollable Component NavigationScrollBarIDREF="ch09306"DescriptionIDREF="ch0636"Choosing ComponentsIDREF="ch06121"Common Client AreasIDREF="ch06128"ScrollBarsIDREF="appa10"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0985"DescriptionScrolledWindowIDREF="ch0658"Choosing ComponentsIDREF="ch09119"DescriptionIDREF="appa25"OSF/Motif Widgets and Components CorrespondenceIDREF="ch09307"DescriptionscrollingIDREF="ch0368"Scrollable Component NavigationIDREF="ch0364"Scrollable Component Navigationsecondary selectionIDREF="ch04107"Quick Transfersecondary windowsIDREF="ch0746"Secondary Windows (Dialog)IDREF="ch0747"Secondary Windows (Dialog)IDREF="ch0748"Secondary Windows (Dialog)IDREF="ch0749"Secondary Windows (Dialog)IDREF="ch0733"Primary WindowIDREF="ch0735"Secondary Windows (Dialog)IDREF="ch0338"Window NavigationIDREF="ch0712"Window SupportIDREF="ch0718"Window SupportIDREF="ch0740"Secondary Windows (Dialog)IDREF="ch0741"Secondary Windows (Dialog)IDREF="ch0345"Window NavigationSelect AllIDREF="ch06163"MenuBarIDREF="ch0973"DescriptionIDREF="ch09262"DescriptionIDREF="ch06209"Popup MenusSelect PastedIDREF="ch0975"DescriptionIDREF="ch06165"MenuBarIDREF="ch06211"Popup MenusIDREF="ch09264"DescriptionSelectAllIDREF="ch0469"Selecting and Deselecting All ElementsSelected MenuIDREF="ch06134"MenuBarIDREF="ch09187"DescriptionselectionIDREF="ch0463"Keyboard-Based Discontiguous SelectionIDREF="ch0464"Canceling a SelectionIDREF="ch0417"Selection ModelsIDREF="ch0466"Canceling a SelectionIDREF="ch0470"Selecting and Deselecting All ElementsIDREF="ch0471"Using Mnemonics for ElementsIDREF="ch0419"Selection ModelsIDREF="ch09269"DescriptionIDREF="ch09270"DescriptionIDREF="ch09290"DescriptionIDREF="ch0428"Mouse-Based Single SelectionIDREF="ch0492"Primary TransferIDREF="ch09308"DescriptionIDREF="ch04108"Quick TransferIDREF="ch09310"DescriptionIDREF="ch09312"DescriptionIDREF="ch09314"DescriptionIDREF="ch09316"DescriptionIDREF="ch09318"DescriptionIDREF="ch04109"Quick TransferIDREF="ch0430"Mouse-Based Browse SelectionIDREF="ch0432"Mouse-Based Multiple SelectionIDREF="ch0434"Mouse-Based Range SelectionIDREF="ch0421"Selection ModelsIDREF="ch0438"Mouse-Based Range SelectionIDREF="ch0444"Mouse-Based Discontiguous SelectionIDREF="ch0423"Selection ModelsIDREF="ch0448"Keyboard SelectionIDREF="ch06274"Separating Destructive ActionsIDREF="ch0425"Selection ModelsIDREF="ch0454"Keyboard-Based Single SelectionIDREF="ch0456"Keyboard-Based Browse SelectionIDREF="ch0458"Keyboard-Based Multiple SelectionIDREF="ch0460"Keyboard-Based Range Selectionselection actionsIDREF="ch0473"Clipboard TransferSelection DialogBoxIDREF="ch06221"DialogBoxesIDREF="ch09320"Descriptionselection modelIDREF="ch041"SelectionIDREF="ch0426"Selection ModelsIDREF="ch0415"Selection ModelsSelectionBoxIDREF="ch09319"DescriptionIDREF="appa28"OSF/Motif Widgets and Components CorrespondenceSeparatorIDREF="ch0612"Choosing ComponentsIDREF="appa1"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0924"DescriptionIDREF="ch09322"DescriptionseparatorsIDREF="ch0831"Grouping SeparatorsIDREF="ch0827"Thousands SeparatorsIDREF="ch0829"Decimal SeparatorssequencesIDREF="ch0819"Collating SequencesshapesIDREF="ch0282"Pointer ShapesIDREF="ch0287"Pointer ShapesIDREF="ch09232"Descriptionsighting pointerIDREF="ch09245"DescriptionIDREF="ch0297"Pointer Shapessingle selectionIDREF="ch0427"Mouse-Based Single SelectionIDREF="ch0453"Keyboard-Based Single SelectionIDREF="ch09309"DescriptionIDREF="ch0416"Selection Modelssingle-choice componentsIDREF="ch0693"Choosing a Single-Choice ComponentIDREF="ch0676"Guidelines for Choosing Interactive MethodsIDREF="ch0687"Choosing a Single-Choice ComponentSizeIDREF="ch09337"DescriptionIDREF="ch0793"Window Menuspring-loadedIDREF="ch0319"Mouse-Based Navigationstatus areaIDREF="ch0814"Displaying StatusStopIDREF="ch0955"DescriptionIDREF="ch06294"Common DialogBox ActionsstructuresIDREF="ch06263"Keeping Menu Structures SimplesubmenusIDREF="ch06265"Keeping Menu Structures Simplesystem Menu buttonIDREF="ch0786"Window Menusystem MenusIDREF="ch09334"DescriptionIDREF="ch09344"Descriptionsystem modalIDREF="ch06284"DialogBox DesignIDREF="ch0745"Secondary Windows (Dialog)tab groupsIDREF="ch0355"Component NavigationTearOffIDREF="ch0516"TearOff ActivationTearOff activationIDREF="ch0912"DescriptionTearOff MenuIDREF="ch0682"Guidelines for Choosing Interactive MethodsIDREF="ch06104"Choosing Among Menus and PanelsTearOff MenusIDREF="ch06278"Using TearOffButtonsIDREF="ch0668"Guidelines for Choosing a Main Component GroupIDREF="ch06258"Menu DesignIDREF="ch06110"Choosing Among Menus and PanelsIDREF="ch0751"Menu WindowsTearOffButtonIDREF="ch0932"DescriptionIDREF="ch06103"Choosing Among Menus and PanelsIDREF="ch0681"Guidelines for Choosing Interactive MethodsIDREF="ch09323"DescriptionIDREF="ch0628"Choosing ComponentsTearOffButtonsIDREF="ch06277"Using TearOffButtonstelephone numbersIDREF="ch0847"Telephone NumberstextIDREF="ch0864"Translating Screen TextIDREF="ch0216"The Keyboard Focus ModelIDREF="ch09324"DescriptionIDREF="ch0867"Translating Screen TextIDREF="ch0328"Location CursorIDREF="ch0640"Choosing ComponentsIDREF="ch0684"Guidelines for Choosing Interactive MethodsIDREF="ch06111"Choosing Between Text or Canvas, and a LabelIDREF="ch0989"DescriptionIDREF="appa13"OSF/Motif Widgets and Components Correspondencetext pointerIDREF="ch0436"Mouse-Based Range Selectiontext-like collectionsIDREF="ch046"Selection Modelsthousands separatorsIDREF="ch0826"Thousands Separatorstime formatsIDREF="ch0845"Time Formatstitle areaIDREF="ch0764"Title AreaIDREF="ch0758"Window Decorationstitle barIDREF="ch0765"Title Areatoggle modelsIDREF="ch0446"Mouse-Based Discontiguous SelectionToggleButtonIDREF="ch09326"DescriptionIDREF="ch0929"DescriptionIDREF="ch0939"DescriptionIDREF="ch09301"DescriptionIDREF="ch0622"Choosing ComponentsIDREF="appa4"OSF/Motif Widgets and Components Correspondencetrack ballIDREF="ch09160"DescriptionIDREF="ch0264"Pointing Devicestrack listenerIDREF="ch0229"Implicit Focustrack pointerIDREF="ch0228"Implicit FocustransferIDREF="ch0476"Clipboard Transfertransient windowsIDREF="ch0720"Window SupportIDREF="ch0713"Window SupportIDREF="ch0339"Window Navigationtranslating textIDREF="ch0863"Translating Screen TextIDREF="ch0866"Translating Screen TexttraversalIDREF="ch0256"The Input Device ModelTutorialIDREF="ch09142"DescriptionIDREF="ch06177"MenuBarIDREF="ch06189"MenuBarIDREF="ch09130"Descriptiontypes of windowsIDREF="ch076"Window SupportundoIDREF="ch0465"Canceling a SelectionIDREF="ch06155"MenuBarIDREF="ch09251"DescriptionIDREF="ch0127"Anticipate ErrorsIDREF="ch06198"Popup MenusIDREF="ch0965"DescriptionUsing HelpIDREF="ch06191"MenuBarIDREF="ch09144"DescriptionvaluesIDREF="ch0833"Positive and Negative Valuesvertical alignmentIDREF="ch06246"Arranging Components for Aligned Layoutvertical panesIDREF="ch06253"Arranging Components in PanedWindowsView MenuIDREF="ch09191"DescriptionIDREF="ch06138"MenuBarvisual cueIDREF="ch0211"The Keyboard Focus ModelWarning DialogBoxIDREF="ch09329"DescriptionIDREF="ch06231"DialogBoxeswarningsIDREF="ch0129"Use Explicit DestructionIDREF="ch06314"Providing WarningswarpingIDREF="ch02107"Warp Pointer Only If Explicitly Enabledwindow control buttonsIDREF="ch0778"Other Buttonswindow familyIDREF="ch0348"Window Navigationwindow managerIDREF="ch072"Window Manager Design PrinciplesIDREF="ch0779"Other ButtonsIDREF="ch0757"Window Decorationswindow Menu buttonIDREF="ch0762"Window DecorationsIDREF="ch0785"Window Menuwindow MenusIDREF="ch09343"DescriptionIDREF="ch09333"Descriptionwindow navigationIDREF="ch0333"Window NavigationIDREF="ch0343"Window Navigationwindow panesIDREF="ch09304"DescriptionIDREF="ch09227"DescriptionIDREF="ch09178"DescriptionwindowsIDREF="ch09216"DescriptionIDREF="ch09217"DescriptionIDREF="ch09219"DescriptionIDREF="ch09220"DescriptionIDREF="ch0340"Window NavigationIDREF="ch0341"Window NavigationIDREF="ch0346"Window NavigationIDREF="ch0347"Window NavigationIDREF="ch06131"MenuBarIDREF="ch0246"Explicit FocusIDREF="ch06250"Arranging Components in PanedWindowsIDREF="ch028"The Keyboard Focus ModelIDREF="ch075"Window SupportIDREF="ch079"Window SupportIDREF="ch0710"Window SupportIDREF="ch0711"Window SupportIDREF="ch0714"Window SupportIDREF="ch0717"Window SupportIDREF="ch0719"Window SupportIDREF="ch0721"Window SupportIDREF="ch0723"Window SupportIDREF="ch0725"Primary WindowIDREF="ch0727"Primary WindowIDREF="ch0730"Primary WindowIDREF="ch0731"Primary WindowIDREF="ch0732"Primary WindowIDREF="ch0736"Secondary Windows (Dialog)IDREF="ch0738"Secondary Windows (Dialog)IDREF="ch0739"Secondary Windows (Dialog)IDREF="ch0753"Window DecorationsIDREF="ch0754"Window DecorationsIDREF="ch0768"Title AreaIDREF="ch0770"Title AreaIDREF="ch0772"Maximize ButtonIDREF="ch0776"Minimize ButtonIDREF="ch0781"Resize BordersIDREF="ch0798"Window NavigationIDREF="ch0336"Window NavigationIDREF="ch09181"DescriptionIDREF="ch09182"DescriptionIDREF="ch0337"Window NavigationWorking DialogBoxIDREF="ch06233"DialogBoxesIDREF="ch09346"DescriptionWorkingDialogIDREF="ch09210"DescriptionX pointerIDREF="ch09240"DescriptionIDREF="ch0292"Pointer ShapesYesIDREF="ch0949"DescriptionIDREF="ch06288"Common DialogBox Actionszoom featureIDREF="ch02104"Gain and AccelerationIDREF="ch02103"Gain and AccelerationaccelerationIDREF="ch02105"Gain and AccelerationIDREF="ch02101"Gain and AccelerationacceleratorsIDREF="ch0910"DescriptionIDREF="ch06275"Providing Mnemonics and AcceleratorsIDREF="ch06261"Menu DesignIDREF="ch0512"AcceleratorsIDREF="ch095"DescriptionactionsIDREF="ch06287"Common DialogBox ActionsactivationIDREF="ch051"Component ActivationIDREF="ch0945"DescriptionIDREF="ch098"DescriptionIDREF="ch0530"Previewing and AutorepeatIDREF="ch0520"Help ActivationIDREF="ch0513"MnemonicsIDREF="ch0913"DescriptionIDREF="ch054"Component ActivationIDREF="ch0915"DescriptionIDREF="ch0523"Default ActivationIDREF="ch058"Basic ActivationIDREF="ch0536"Cancel ActivationIDREF="ch0525"Expert ActivationIDREF="ch0920"DescriptionIDREF="ch0362"Menu TraversalIDREF="ch0510"AcceleratorsIDREF="ch0923"DescriptionIDREF="ch0518"TearOff ActivationIDREF="ch096"Descriptionactive voiceIDREF="ch0869"Translating Screen Textactive windowIDREF="ch027"The Keyboard Focus Modelacts requiring actionsIDREF="ch0123"Anticipate Errorsadd modeIDREF="ch0450"Keyboard SelectionaddressesIDREF="ch0852"Proper Names and Addressesaffirmative statementsIDREF="ch0868"Translating Screen TextalignmentIDREF="ch06249"Arranging Components for Aligned LayoutIDREF="ch06247"Arranging Components for Aligned Layoutalphanumeric date formatsIDREF="ch0841"Date Formatsalphanumeric listsIDREF="ch0820"Collating SequencesanchorIDREF="ch0445"Mouse-Based Discontiguous SelectionIDREF="ch0461"Keyboard-Based Range SelectionIDREF="ch0435"Mouse-Based Range SelectionANS X3.159-1989IDREF="ch085"Designing for International MarketsANSI CIDREF="ch084"Designing for International Marketsapplication designIDREF="ch062"Application Design Principlesapplication modalIDREF="ch06283"DialogBox DesignIDREF="ch0744"Secondary Windows (Dialog)application titleIDREF="ch0766"Title AreaApplyIDREF="ch06292"Common DialogBox ActionsIDREF="ch0953"Descriptionarrow pointerIDREF="ch0299"Pointer ShapesIDREF="ch09247"DescriptionIDREF="ch0295"Pointer ShapesIDREF="ch09243"DescriptionIDREF="ch0288"Pointer ShapesIDREF="ch09236"DescriptionautorepeatIDREF="ch0533"Previewing and AutorepeatBalance BeamIDREF="ch0442"Mouse-Based Range SelectionbaseIDREF="ch081"Designing for International Marketsbasic activationIDREF="ch056"Basic ActivationIDREF="ch097"Descriptionbasic controlsIDREF="ch0619"Choosing ComponentsIDREF="ch0611"Choosing ComponentsIDREF="ch0621"Choosing ComponentsIDREF="ch0615"Choosing ComponentsIDREF="ch0623"Choosing ComponentsIDREF="ch065"Choosing ComponentsIDREF="ch0691"Choosing a Single-Choice ComponentIDREF="ch0625"Choosing ComponentsIDREF="ch0617"Choosing ComponentsIDREF="ch0627"Choosing ComponentsIDREF="ch0613"Choosing ComponentsIDREF="ch0629"Choosing Componentsbasic groupsIDREF="ch0644"Choosing ComponentsIDREF="ch0648"Choosing ComponentsIDREF="ch067"Choosing ComponentsIDREF="ch0650"Choosing ComponentsIDREF="appa16"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0646"Choosing ComponentsBMenuIDREF="ch09166"DescriptionIDREF="ch0268"Pointing DevicesIDREF="ch0271"Pointing DevicesboxIDREF="ch09151"DescriptionIDREF="ch07104"Icon Boxbrowse selectionsIDREF="ch09311"DescriptionIDREF="ch0455"Keyboard-Based Browse SelectionIDREF="ch0429"Mouse-Based Browse SelectionIDREF="ch0418"Selection ModelsBSelectIDREF="ch09164"DescriptionIDREF="ch0272"Pointing DevicesIDREF="ch0273"Pointing DevicesIDREF="ch059"Basic ActivationIDREF="ch099"DescriptionIDREF="ch0266"Pointing DevicesBTransferIDREF="ch0267"Pointing DevicesIDREF="ch09165"DescriptionIDREF="ch0270"Pointing DevicesbuttonsIDREF="ch0777"Minimize ButtonIDREF="ch0773"Maximize ButtonIDREF="ch0789"Window MenuIDREF="ch0790"Window MenuCancelIDREF="ch06298"Common DialogBox ActionsIDREF="ch0959"Descriptioncancel activationIDREF="ch0922"DescriptionIDREF="ch0534"Cancel Activationcanceling a selectionIDREF="ch0467"Canceling a SelectionCanvasIDREF="appa14"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0685"Guidelines for Choosing Interactive MethodsIDREF="ch0642"Choosing ComponentsIDREF="ch06112"Choosing Between Text or Canvas, and a LabelIDREF="ch0991"DescriptionIDREF="ch0936"DescriptionCascadeButtonIDREF="ch0618"Choosing ComponentsIDREF="ch0318"Mouse-Based NavigationIDREF="ch0937"DescriptionIDREF="appa7"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0927"DescriptionCheckBoxIDREF="ch06100"Choosing a Multiple-Choice ComponentCheckButtonIDREF="ch0930"DescriptionIDREF="appa5"OSF/Motif Widgets and Components CorrespondenceIDREF="ch09328"DescriptionIDREF="ch0624"Choosing ComponentsIDREF="ch0938"Descriptionchoosing componentsIDREF="ch064"Choosing ComponentsClearIDREF="ch06207"Popup MenusIDREF="ch0971"DescriptionIDREF="ch09260"DescriptionIDREF="ch06161"MenuBarClickIDREF="ch0276"Pointing Devicesclick-to-typeIDREF="ch09115"DescriptionIDREF="ch0243"Explicit Focusclient areasIDREF="ch0763"Client AreaIDREF="ch06115"Common Client Areasclipboard selection actionsIDREF="ch0480"Clipboard TransferIDREF="ch0474"Clipboard TransferIDREF="ch0486"Clipboard TransferIDREF="ch0477"Clipboard TransferIDREF="ch0483"Clipboard TransferIDREF="ch0489"Clipboard Transferclipboard transferIDREF="ch0490"Clipboard TransferIDREF="ch0478"Clipboard TransferIDREF="ch0484"Clipboard TransferIDREF="ch0475"Clipboard TransferIDREF="ch0487"Clipboard TransferIDREF="ch0481"Clipboard TransferCloseIDREF="ch0797"Window MenuIDREF="ch06291"Common DialogBox ActionsIDREF="ch09345"DescriptionIDREF="ch06151"MenuBarIDREF="ch09100"DescriptionIDREF="ch0952"Descriptioncollating sequencesIDREF="ch0818"Collating SequencescollectionsIDREF="ch045"Selection ModelsIDREF="ch049"Selection ModelsIDREF="ch0414"Selection ModelsIDREF="ch047"Selection ModelsIDREF="ch0411"Selection ModelscolorsIDREF="ch0116"Provide Natural Shades and ColorscolumnsIDREF="ch06245"Arranging Components for Aligned Layoutcommand areaIDREF="ch06126"Command AreaIDREF="ch06119"Common Client AreasCommand DialogBoxIDREF="ch06215"DialogBoxesIDREF="ch0941"DescriptionCommandBoxIDREF="ch0940"Descriptioncommon actionsIDREF="ch0948"Descriptioncommon DialogBox actionsIDREF="ch06285"Common DialogBox Actionscomponent activationIDREF="ch052"Component ActivationIDREF="ch0531"Previewing and AutorepeatIDREF="ch053"Component ActivationIDREF="ch0535"Cancel ActivationIDREF="ch0517"TearOff ActivationIDREF="ch055"Component ActivationIDREF="ch0521"Help ActivationIDREF="ch057"Basic ActivationIDREF="ch0946"DescriptionIDREF="ch0524"Default ActivationIDREF="ch0511"AcceleratorsIDREF="ch0527"Expert ActivationIDREF="ch0514"Mnemonicscomponent navigationIDREF="ch0349"Component NavigationcomponentsIDREF="ch09325"DescriptionIDREF="ch06308"Avoiding Component ModesIDREF="ch0756"Window DecorationsIDREF="ch06236"Grouping ComponentsIDREF="ch06237"Grouping ComponentsIDREF="ch0699"Choosing a Multiple-Choice ComponentIDREF="ch0679"Guidelines for Choosing Interactive MethodsIDREF="ch0675"Guidelines for Choosing Interactive MethodsIDREF="ch0694"Choosing a Single-Choice ComponentIDREF="ch063"Choosing ComponentsIDREF="ch0688"Choosing a Single-Choice ComponentIDREF="ch0677"Guidelines for Choosing Interactive MethodsIDREF="ch06318"Component DesignIDREF="ch039"NavigationIDREF="ch06307"Avoiding Component ModesCompositeIDREF="appa21"OSF/Motif Widgets and Components CorrespondenceCompositionIDREF="ch09175"DescriptionIDREF="ch0943"DescriptionIDREF="ch0651"Choosing ComponentsconfigurabilityIDREF="ch073"ConfigurabilityconsistencyIDREF="ch0120"Keep Interfaces ConsistentIDREF="ch0118"Keep Interfaces ConsistentIDREF="ch0117"Keep Interfaces Consistentcontext-sensitive helpIDREF="ch0126"Anticipate ErrorsIDREF="ch06181"MenuBarIDREF="ch09134"DescriptioncontrastIDREF="ch0115"Provide Natural Shades and Colorscontrol panelIDREF="ch06239"Grouping Similar ComponentscontrolsIDREF="ch091"Controls, Groups, and Models Reference PagesCopyIDREF="ch06203"Popup MenusIDREF="ch06157"MenuBarIDREF="ch0498"Primary TransferIDREF="ch0482"Clipboard TransferIDREF="ch09276"DescriptionIDREF="ch09293"DescriptionIDREF="ch0967"DescriptionIDREF="ch04112"Quick TransferIDREF="ch09256"DescriptionCopy LinkIDREF="ch09257"DescriptionIDREF="ch0485"Clipboard TransferIDREF="ch0968"DescriptionIDREF="ch06158"MenuBarIDREF="ch06204"Popup Menuscorner handlesIDREF="ch0782"Resize Borderscountry-specific data formatsIDREF="ch0821"Country-Specific Data FormatscurrencyIDREF="ch0838"CurrencycursorIDREF="ch0452"Keyboard SelectionIDREF="ch036"NavigationIDREF="ch0329"Location CursorIDREF="ch0321"Keyboard-Based NavigationIDREF="ch0352"Component NavigationIDREF="ch0331"Location CursorIDREF="ch0242"Explicit FocusIDREF="ch0323"Location CursorIDREF="ch0324"Location CursorIDREF="ch0210"The Keyboard Focus ModelIDREF="ch0326"Location CursorIDREF="ch0359"Component NavigationIDREF="ch0215"The Keyboard Focus ModelCutIDREF="ch06202"Popup MenusIDREF="ch0966"DescriptionIDREF="ch06156"MenuBarIDREF="ch04115"Quick TransferIDREF="ch0479"Clipboard TransferIDREF="ch09296"DescriptionIDREF="ch09255"Descriptiondata formatsIDREF="ch0836"CurrencyIDREF="ch0837"CurrencyIDREF="ch0823"Country-Specific Data Formatsdate formatsIDREF="ch0839"Date Formatsdecimal separatorsIDREF="ch0828"Decimal SeparatorsdecorationIDREF="ch0752"Window Decorationsdefault actionIDREF="ch0944"DescriptionIDREF="ch0917"DescriptionIDREF="ch0522"Default Activationdefault PushButtonIDREF="ch06305"Showing Default ActionsdefaultsIDREF="ch06306"Showing Default ActionsdelayIDREF="ch06313"Showing ProgressDeleteIDREF="ch06208"Popup MenusIDREF="ch0972"DescriptionIDREF="ch06162"MenuBarIDREF="ch09261"DescriptionDeselect AllIDREF="ch0974"DescriptionIDREF="ch09263"DescriptionIDREF="ch06210"Popup MenusIDREF="ch06164"MenuBardeselectingIDREF="ch0468"Selecting and Deselecting All ElementsdesignIDREF="ch06280"DialogBox DesignIDREF="ch0284"Pointer ShapesIDREF="ch09234"DescriptionIDREF="ch011"User Interface Design PrinciplesIDREF="ch06319"Component DesignIDREF="ch071"Window Manager Design PrinciplesIDREF="ch0856"Icons, Symbols, and Pointer ShapesIDREF="ch0857"Icons, Symbols, and Pointer ShapesIDREF="ch0858"Icons, Symbols, and Pointer ShapesIDREF="ch061"Application Design Principlesdestructive actionsIDREF="ch06273"Separating Destructive ActionsDialogBoxIDREF="appa27"OSF/Motif Widgets and Components CorrespondenceIDREF="ch06286"Common DialogBox ActionsIDREF="ch0342"Window NavigationIDREF="ch0979"DescriptionIDREF="ch06222"DialogBoxesIDREF="ch06117"Common Client AreasIDREF="ch0942"DescriptionIDREF="ch0947"DescriptionIDREF="ch06224"DialogBoxesIDREF="ch06266"Keeping Menu Structures SimpleIDREF="ch0671"Guidelines for Choosing a Main Component GroupIDREF="ch09206"DescriptionIDREF="ch06226"DialogBoxesIDREF="ch09347"DescriptionIDREF="ch0610"Choosing ComponentsIDREF="ch06228"DialogBoxesIDREF="ch06300"Determining DialogBox Location and SizeIDREF="ch06301"Determining DialogBox Location and SizeIDREF="ch06214"DialogBoxesIDREF="ch0715"Window SupportIDREF="ch06230"DialogBoxesIDREF="ch09284"DescriptionIDREF="ch06216"DialogBoxesIDREF="ch09155"DescriptionIDREF="ch09321"DescriptionIDREF="ch09287"DescriptionIDREF="ch06232"DialogBoxesIDREF="ch0673"Guidelines for Choosing a Main Component GroupIDREF="ch06234"DialogBoxesIDREF="ch06279"DialogBox DesignIDREF="ch06218"DialogBoxesIDREF="ch09330"DescriptionIDREF="ch0669"Guidelines for Choosing a Main Component GroupIDREF="ch09104"DescriptionIDREF="ch06220"DialogBoxesDialogBox groupsIDREF="ch0662"Choosing Componentsdirect manipulationIDREF="ch0269"Pointing DevicesIDREF="ch018"Allow Direct ManipulationIDREF="ch0110"Allow Direct Manipulationdisabling componentsIDREF="ch06310"Showing Unavailable Componentsdiscontiguous selectionIDREF="ch0462"Keyboard-Based Discontiguous SelectionIDREF="ch0443"Mouse-Based Discontiguous SelectionIDREF="ch0424"Selection ModelsIDREF="ch09317"Descriptiondouble-clickingIDREF="ch0921"DescriptionIDREF="ch0529"Expert Activationdrag and dropIDREF="ch0962"DescriptionIDREF="ch04119"Drag Transferdrag and drop modelIDREF="ch0961"Descriptiondrag transferIDREF="ch04120"Drag Transferedge handlesIDREF="ch0783"Resize BordersEdit MenuIDREF="ch06136"MenuBarIDREF="ch06153"MenuBarIDREF="ch09189"DescriptionIDREF="ch0963"DescriptionEnlarge OnlyIDREF="ch0441"Mouse-Based Range SelectionError DialogBoxIDREF="ch06225"DialogBoxesIDREF="ch0978"DescriptionErrorDialogIDREF="ch09207"DescriptionerrorsIDREF="ch0124"Anticipate ErrorsExitIDREF="ch09101"DescriptionIDREF="ch06152"MenuBarexpert actionIDREF="ch0918"DescriptionIDREF="ch0528"Expert Activationexpert activationIDREF="ch0526"Expert ActivationIDREF="ch0919"Descriptionexplicit destructionIDREF="ch0128"Use Explicit Destructionexplicit focusIDREF="ch0235"Explicit FocusIDREF="ch09106"DescriptionIDREF="ch09113"Descriptionextension modelsIDREF="ch0447"Mouse-Based Discontiguous SelectionIDREF="ch0439"Mouse-Based Range SelectionfeedbackIDREF="ch06303"InteractionIDREF="ch06311"Providing FeedbackIDREF="ch0122"Give the User Feedbackfield controlsIDREF="ch0984"DescriptionIDREF="ch0643"Choosing ComponentsIDREF="ch0986"DescriptionIDREF="ch066"Choosing ComponentsIDREF="ch0988"DescriptionIDREF="ch0637"Choosing ComponentsIDREF="appa9"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0990"DescriptionIDREF="ch0992"DescriptionIDREF="ch0630"Choosing ComponentsIDREF="ch0639"Choosing ComponentsIDREF="ch0980"DescriptionIDREF="ch0635"Choosing ComponentsIDREF="ch0982"DescriptionIDREF="ch0641"Choosing Componentsfield navigationIDREF="ch0356"Component NavigationfieldsIDREF="ch0354"Component NavigationFile MenuIDREF="ch09185"DescriptionIDREF="ch06132"MenuBarIDREF="ch06144"MenuBarIDREF="ch0993"DescriptionFileSelection DialogBoxIDREF="ch09103"DescriptionIDREF="ch06217"DialogBoxesFileSelectionBoxIDREF="appa29"OSF/Motif Widgets and Components CorrespondenceIDREF="ch09102"DescriptionfillIDREF="ch0332"Location Cursorfixed layoutIDREF="ch06241"Arranging Components for Fixed LayoutflexibilityIDREF="ch06317"Allowing User FlexibilityIDREF="ch013"Keep Interfaces FlexiblefocusIDREF="ch09112"DescriptionIDREF="ch09114"DescriptionIDREF="ch0221"Implicit FocusIDREF="ch0252"Explicit FocusIDREF="ch0218"The Keyboard Focus ModelIDREF="ch0233"Implicit FocusIDREF="ch024"Input ModelsIDREF="ch0236"Explicit FocusIDREF="ch0224"Implicit FocusIDREF="ch09107"DescriptionIDREF="ch09108"DescriptionIDREF="ch0238"Explicit FocusIDREF="ch0217"The Keyboard Focus ModelIDREF="ch0250"Explicit Focusfocus policiesIDREF="ch0232"Implicit FocusIDREF="ch0219"The Keyboard Focus ModelIDREF="ch0237"Explicit FocusIDREF="ch0249"Explicit FocusIDREF="ch0251"Explicit FocusIDREF="ch0222"Implicit FocusIDREF="ch09109"DescriptionformatsIDREF="ch0870"Translating Screen TextIDREF="ch0824"Country-Specific Data FormatsIDREF="ch0846"Telephone NumbersIDREF="ch0843"Date FormatsIDREF="ch0853"Proper Names and AddressesIDREF="ch0844"Time Formatsfour-directional arrow pointerIDREF="ch09242"DescriptionIDREF="ch0294"Pointer ShapesFrameIDREF="ch09118"DescriptionIDREF="ch09116"DescriptionIDREF="appa24"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0656"Choosing Componentsframing groupsIDREF="ch0659"Choosing ComponentsIDREF="ch09117"DescriptionIDREF="appa23"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0655"Choosing ComponentsIDREF="ch0661"Choosing ComponentsIDREF="ch0657"Choosing ComponentsIDREF="ch069"Choosing ComponentsgainIDREF="ch02102"Gain and AccelerationIDREF="ch02100"Gain and AccelerationgraphicsIDREF="ch06304"Using Graphics to Show Actiongraphics tabletIDREF="ch0263"Pointing DevicesIDREF="ch09158"Descriptiongraphics-like collectionsIDREF="ch0413"Selection ModelsIDREF="ch048"Selection Modelsgroup referenceIDREF="ch092"Controls, Groups, and Models Reference PagesgroupingIDREF="ch06238"Grouping Similar ComponentsIDREF="ch0830"Grouping SeparatorsIDREF="ch06235"Grouping ComponentsIDREF="ch06267"Grouping Like Menu Elements TogetherhandlesIDREF="ch0784"Resize BordershelpIDREF="ch09147"DescriptionIDREF="ch06184"MenuBarIDREF="ch06315"Providing HelpIDREF="ch06316"Providing HelpIDREF="ch0125"Anticipate ErrorsIDREF="ch06186"MenuBarIDREF="ch0519"Help ActivationIDREF="ch06188"MenuBarIDREF="ch09124"DescriptionIDREF="ch09195"DescriptionIDREF="ch06176"MenuBarIDREF="ch06190"MenuBarIDREF="ch06171"MenuBarIDREF="ch06192"MenuBarIDREF="ch09129"DescriptionIDREF="ch06178"MenuBarIDREF="ch09131"DescriptionIDREF="ch06194"MenuBarIDREF="ch09133"DescriptionIDREF="ch09135"DescriptionIDREF="ch06142"MenuBarIDREF="ch09137"DescriptionIDREF="ch06299"Common DialogBox ActionsIDREF="ch09139"DescriptionIDREF="ch06180"MenuBarIDREF="ch09141"DescriptionIDREF="ch06182"MenuBarIDREF="ch09143"DescriptionIDREF="ch0960"DescriptionIDREF="ch09145"DescriptionIDREF="ch06168"MenuBarhelp activationIDREF="ch0914"DescriptionHelp MenuIDREF="ch09121"Descriptionhorizontal alignmentIDREF="ch06248"Arranging Components for Aligned Layouthot keyIDREF="ch074"ConfigurabilityhotspotIDREF="ch09235"DescriptionIDREF="ch0285"Pointer ShapesI-beam pointerIDREF="ch09238"DescriptionIDREF="ch0290"Pointer Shapesicon boxIDREF="ch09150"DescriptionIDREF="ch07103"Icon Boxicon MenuIDREF="ch07101"Icon MenuIDREF="ch09148"Descriptioniconized windowIDREF="ch0728"Primary WindowiconsIDREF="ch0854"Icons, Symbols, and Pointer ShapesIDREF="ch09153"DescriptionIDREF="ch07100"IconsIDREF="ch0734"Primary Windowimmediacy of responseIDREF="ch0112"Provide Rapid Responseimplicit focusIDREF="ch09105"DescriptionIDREF="ch0220"Implicit FocusIDREF="ch09111"DescriptionIDREF="ch0234"Implicit FocusIndexIDREF="ch06175"MenuBarIDREF="ch09128"DescriptionIDREF="ch09138"DescriptionIDREF="ch06185"MenuBarInformation DialogBoxIDREF="ch06227"DialogBoxesInformationDialogIDREF="ch09154"DescriptionIDREF="ch09208"DescriptioninputIDREF="ch09171"Descriptioninput devicesIDREF="ch023"Input ModelsIDREF="ch09156"DescriptionIDREF="ch0253"The Input Device Modelinput focusIDREF="ch025"The Keyboard Focus ModelinteractionsIDREF="ch06302"Interactioninteractive methodsIDREF="ch0674"Guidelines for Choosing Interactive MethodsinterapplicationIDREF="ch0121"Keep Interfaces Consistentinternal window navigationIDREF="ch0244"Explicit FocusinternationalizationIDREF="ch0822"Country-Specific Data FormatsIDREF="ch0840"Date FormatsIDREF="ch0825"Country-Specific Data FormatsIDREF="ch0865"Translating Screen TextIDREF="ch0813"Displaying StatusIDREF="ch087"Internationalized Text InputIDREF="ch0848"Telephone NumbersIDREF="ch0849"Telephone NumbersIDREF="ch0815"Converting Pre-Edit Characters to Final CharactersIDREF="ch088"Locating the Pre-Edit AreaIDREF="ch0817"Collating SequencesIDREF="ch082"Designing for International MarketsIDREF="ch0860"Icons, Symbols, and Pointer ShapesIDREF="ch0834"Positive and Negative Valuesintraapplication consistencyIDREF="ch0119"Keep Interfaces Consistentitem cursorIDREF="ch0330"Location CursorjoystickIDREF="ch09159"DescriptionIDREF="ch0265"Pointing DeviceskeyboardIDREF="ch0223"Implicit FocusIDREF="ch09215"DescriptionIDREF="ch026"The Keyboard Focus ModelIDREF="ch0213"The Keyboard Focus ModelIDREF="ch032"NavigationIDREF="ch0257"The Input Device ModelIDREF="ch034"NavigationIDREF="ch09163"DescriptionIDREF="ch09222"DescriptionIDREF="ch0214"The Keyboard Focus ModelIDREF="ch09168"DescriptionIDREF="ch09169"DescriptionIDREF="ch06187"MenuBarIDREF="ch09140"DescriptionIDREF="ch09110"DescriptionIDREF="ch022"Input ModelsIDREF="ch0353"Component NavigationIDREF="ch09213"Descriptionkeyboard-based operationsIDREF="ch0247"Explicit FocuskeyboardsIDREF="ch09172"DescriptionLabelIDREF="ch09173"DescriptionIDREF="ch0686"Guidelines for Choosing Interactive MethodsIDREF="ch06113"Choosing Between Text or Canvas, and a LabelIDREF="ch0925"DescriptionIDREF="ch0614"Choosing ComponentsIDREF="appa2"OSF/Motif Widgets and Components Correspondencelanguage independentIDREF="ch0859"Icons, Symbols, and Pointer ShapeslayoutIDREF="ch06244"Arranging Components for Resizing LayoutIDREF="ch06242"Arranging Components for Fixed LayoutIDREF="ch06114"Layoutlayout groupsIDREF="ch0654"Choosing ComponentsIDREF="ch09174"DescriptionIDREF="ch0652"Choosing ComponentsIDREF="ch068"Choosing ComponentsIDREF="appa20"OSF/Motif Widgets and Components CorrespondencelinkIDREF="ch04104"Primary TransferIDREF="ch09282"DescriptionIDREF="ch09299"DescriptionIDREF="ch04118"Quick TransferListIDREF="ch0697"Choosing a Single-Choice ComponentIDREF="ch0987"DescriptionIDREF="ch0692"Choosing a Single-Choice ComponentIDREF="ch09179"DescriptionIDREF="ch06101"Choosing a Multiple-Choice ComponentIDREF="ch0638"Choosing ComponentsIDREF="appa15"OSF/Motif Widgets and Components Correspondencelist-like collectionsIDREF="ch0410"Selection ModelsIDREF="ch0412"Selection ModelsIDREF="ch044"Selection ModelslocalizationIDREF="ch083"Designing for International Marketslocation cursorIDREF="ch0325"Location CursorIDREF="ch0351"Component NavigationIDREF="ch035"NavigationIDREF="ch0451"Keyboard SelectionIDREF="ch029"The Keyboard Focus ModelIDREF="ch0358"Component NavigationIDREF="ch0241"Explicit FocusIDREF="ch0320"Keyboard-Based NavigationIDREF="ch0322"Location CursorLowerIDREF="ch09340"DescriptionIDREF="ch0796"Window Menumain component groupsIDREF="ch0663"Guidelines for Choosing a Main Component Groupmain windowsIDREF="ch0726"Primary WindowIDREF="ch0334"Window NavigationIDREF="ch078"Window SupportMainWindowIDREF="ch0660"Choosing ComponentsIDREF="ch06125"MainWindowIDREF="ch0665"Guidelines for Choosing a Main Component GroupIDREF="ch0672"Guidelines for Choosing a Main Component GroupIDREF="ch09120"DescriptionIDREF="ch06116"Common Client AreasIDREF="appa26"OSF/Motif Widgets and Components CorrespondenceIDREF="ch09180"DescriptionIDREF="ch06123"MainWindowmanipulationIDREF="ch019"Allow Direct ManipulationIDREF="ch0111"Allow Direct Manipulationmarquee selectionIDREF="ch0437"Mouse-Based Range SelectionMaximizeIDREF="ch0795"Window MenuIDREF="ch09339"Descriptionmaximize buttonIDREF="ch0771"Maximize ButtonIDREF="ch0759"Window DecorationsMenuIDREF="ch0670"Guidelines for Choosing a Main Component GroupIDREF="ch0664"Guidelines for Choosing a Main Component GroupIDREF="ch0934"DescriptionIDREF="ch0666"Guidelines for Choosing a Main Component GroupIDREF="ch06102"Choosing Among Menus and PanelsIDREF="ch09198"DescriptionIDREF="ch0680"Guidelines for Choosing Interactive MethodsIDREF="ch0667"Guidelines for Choosing a Main Component GroupIDREF="ch06118"Common Client AreasIDREF="appa18"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0647"Choosing ComponentsMenu systemIDREF="ch0361"Menu TraversalMenu traversalIDREF="ch0360"Menu TraversalMenuBarIDREF="ch0649"Choosing ComponentsIDREF="ch06129"MenuBarIDREF="ch06122"Common Client AreasIDREF="ch09183"DescriptionIDREF="ch0363"Menu TraversalIDREF="appa19"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0935"DescriptionIDREF="ch0316"Mouse-Based NavigationMenusIDREF="ch06133"MenuBarIDREF="ch09225"DescriptionIDREF="ch07102"Icon MenuIDREF="ch06141"MenuBarIDREF="ch06259"Menu DesignIDREF="ch06143"MenuBarIDREF="ch06262"Keeping Menu Structures SimpleIDREF="ch09331"DescriptionIDREF="ch09332"DescriptionIDREF="ch09186"DescriptionIDREF="ch09122"DescriptionIDREF="ch09188"DescriptionIDREF="ch09190"DescriptionIDREF="ch0750"Menu WindowsIDREF="ch09192"DescriptionIDREF="ch09341"DescriptionIDREF="ch09342"DescriptionIDREF="ch06145"MenuBarIDREF="ch09194"DescriptionIDREF="ch09196"DescriptionIDREF="ch09197"DescriptionIDREF="ch0317"Mouse-Based NavigationIDREF="ch09249"DescriptionIDREF="ch09200"DescriptionIDREF="ch06135"MenuBarIDREF="ch09202"DescriptionIDREF="ch0964"DescriptionIDREF="ch09204"DescriptionIDREF="ch06268"Grouping Like Menu Elements TogetherIDREF="ch06137"MenuBarIDREF="ch06169"MenuBarIDREF="ch06196"Popup MenusIDREF="ch0787"Window MenuIDREF="ch09149"DescriptionIDREF="ch0788"Window MenuIDREF="ch06272"Listing Menu Selections by Order of UseIDREF="ch037"NavigationIDREF="ch06139"MenuBarIDREF="ch0722"Window SupportIDREF="ch06154"MenuBarIDREF="ch0994"Descriptionmessage areaIDREF="ch06127"Message AreaIDREF="ch06120"Common Client AreasMessage DialogBoxIDREF="ch09205"DescriptionIDREF="ch06223"DialogBoxesMessageBoxIDREF="appa31"OSF/Motif Widgets and Components CorrespondencemessagesIDREF="ch0871"Translating Screen TextmetaphorsIDREF="ch016"Use Real-World MetaphorsMinimizeIDREF="ch0794"Window MenuIDREF="ch09338"Descriptionminimize buttonIDREF="ch0775"Minimize ButtonIDREF="ch0760"Window Decorationsminimized windowIDREF="ch0729"Primary WindowmnemonicsIDREF="ch0472"Using Mnemonics for ElementsIDREF="ch09211"DescriptionIDREF="ch06260"Menu DesignIDREF="ch0515"MnemonicsIDREF="ch06276"Providing Mnemonics and AcceleratorsIDREF="ch0911"Descriptionmodel keyboardIDREF="ch09170"DescriptionmodelessIDREF="ch06281"DialogBox DesignIDREF="ch0742"Secondary Windows (Dialog)modelsIDREF="ch042"SelectionIDREF="ch093"Controls, Groups, and Models Reference PagesIDREF="ch021"Input ModelsmodesIDREF="ch06309"Avoiding Component ModesMotionIDREF="ch0277"Pointing DevicesmouseIDREF="ch0262"Pointing DevicesIDREF="ch0212"The Keyboard Focus ModelIDREF="ch033"NavigationIDREF="ch09157"Descriptionmouse inputIDREF="ch0258"The Input Device Modelmouse pointerIDREF="ch0225"Implicit FocusIDREF="ch0239"Explicit Focusmouse pointer shapesIDREF="ch09233"DescriptionIDREF="ch0283"Pointer Shapesmouse-based navigationIDREF="ch0311"Mouse-Based NavigationMoveIDREF="ch0792"Window MenuIDREF="ch04101"Primary TransferIDREF="ch09279"DescriptionIDREF="ch09336"DescriptionMultiClickIDREF="ch0278"Pointing DevicesMultiMotionIDREF="ch0280"Pointing Devicesmultiple cascading submenusIDREF="ch06264"Keeping Menu Structures Simplemultiple MainWindowsIDREF="ch06124"MainWindowmultiple selectionIDREF="ch0420"Selection ModelsIDREF="ch0457"Keyboard-Based Multiple SelectionIDREF="ch0431"Mouse-Based Multiple Selectionmultiple selectionsIDREF="ch09313"Descriptionmultiple windowsIDREF="ch0769"Title AreaIDREF="ch0767"Title Areamultiple-choice componentsIDREF="ch0678"Guidelines for Choosing Interactive MethodsIDREF="ch0698"Choosing a Multiple-Choice ComponentMultiPressIDREF="ch0279"Pointing Devicesnational numbersIDREF="ch0850"Telephone NumbersnavigationIDREF="ch0310"Mouse-Based NavigationIDREF="ch09218"DescriptionIDREF="ch0366"Scrollable Component NavigationIDREF="ch0245"Explicit FocusIDREF="ch09221"DescriptionIDREF="ch0350"Component NavigationIDREF="ch0369"Scrollable Component NavigationIDREF="ch0799"Window NavigationIDREF="ch031"NavigationIDREF="ch0357"Component NavigationIDREF="ch09212"DescriptionIDREF="ch09214"DescriptionIDREF="ch0114"Make Navigation EasyNewIDREF="ch0995"DescriptionIDREF="ch06146"MenuBarNoIDREF="ch06289"Common DialogBox ActionsIDREF="ch0950"Descriptionnormal modeIDREF="ch0449"Keyboard SelectionnumbersIDREF="ch0835"Positive and Negative Valuesnumeric date formatsIDREF="ch0842"Date Formatsobject-action selection modelIDREF="ch043"SelectionOKIDREF="ch0951"DescriptionIDREF="ch06290"Common DialogBox ActionsOn ContextIDREF="ch09123"DescriptionIDREF="ch06170"MenuBarOn HelpIDREF="ch06172"MenuBarIDREF="ch09125"DescriptionOn KeysIDREF="ch06174"MenuBarIDREF="ch09127"DescriptionOn VersionIDREF="ch06179"MenuBarIDREF="ch09132"DescriptionOn WindowIDREF="ch09126"DescriptionIDREF="ch06173"MenuBarOpenIDREF="ch0996"DescriptionIDREF="ch06147"MenuBaroperationIDREF="ch09161"DescriptionIDREF="ch09162"DescriptionIDREF="ch0248"Explicit FocusIDREF="ch0254"The Input Device ModelIDREF="ch0255"The Input Device ModelOption MenusIDREF="ch06257"Menu DesignOptionButtonIDREF="ch0690"Choosing a Single-Choice ComponentIDREF="appa8"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0696"Choosing a Single-Choice ComponentIDREF="ch0928"DescriptionIDREF="ch09223"DescriptionIDREF="ch0620"Choosing ComponentsOptions MenuIDREF="ch0315"Mouse-Based NavigationIDREF="ch09224"DescriptionIDREF="ch06140"MenuBarIDREF="ch09203"DescriptionIDREF="ch09193"DescriptionorderingIDREF="ch014"Use Progressive DisclosureIDREF="ch06270"Listing Menu Selections by Frequency of Useordering Menu selectionsIDREF="ch06271"Listing Menu Selections by Order of Useoutline highlightIDREF="ch0327"Location CursorOverviewIDREF="ch09136"DescriptionIDREF="ch06183"MenuBarPack IconsIDREF="ch09152"DescriptionIDREF="ch07105"Icon BoxPanedWindowIDREF="ch06251"Arranging Components in PanedWindowsIDREF="ch09176"DescriptionIDREF="ch09303"DescriptionIDREF="ch09226"DescriptionIDREF="appa22"OSF/Motif Widgets and Components CorrespondenceIDREF="ch06252"Arranging Components in PanedWindowsIDREF="ch0653"Choosing ComponentsIDREF="ch0633"Choosing ComponentsPanelIDREF="ch06108"Choosing Among Menus and PanelsIDREF="ch06109"Choosing Among Menus and PanelsIDREF="ch0683"Guidelines for Choosing Interactive MethodsIDREF="ch09230"DescriptionIDREF="appa17"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0645"Choosing ComponentsIDREF="ch0933"DescriptionIDREF="ch06107"Choosing Among Menus and PanelspanelsIDREF="ch06240"Grouping Similar ComponentsPanesIDREF="ch06254"Arranging Components in PanedWindowsIDREF="ch09177"DescriptionIDREF="ch09228"DescriptionIDREF="ch0632"Choosing Componentsparent windowsIDREF="ch0737"Secondary Windows (Dialog)partsIDREF="ch0755"Window DecorationsPasteIDREF="ch06205"Popup MenusIDREF="ch0969"DescriptionIDREF="ch06159"MenuBarIDREF="ch0488"Clipboard TransferIDREF="ch09258"DescriptionPaste LinkIDREF="ch09259"DescriptionIDREF="ch0491"Clipboard TransferIDREF="ch06160"MenuBarIDREF="ch0970"DescriptionIDREF="ch06206"Popup MenusPauseIDREF="ch0956"DescriptionIDREF="ch06295"Common DialogBox Actionspointer navigationIDREF="ch0312"Mouse-Based Navigationpointer shapesIDREF="ch0281"Pointer ShapesIDREF="ch0855"Icons, Symbols, and Pointer ShapesIDREF="ch0286"Pointer ShapesIDREF="ch09231"DescriptionpointersIDREF="ch09241"DescriptionIDREF="ch09244"DescriptionIDREF="ch0291"Pointer ShapesIDREF="ch09246"DescriptionIDREF="ch0227"Implicit FocusIDREF="ch0293"Pointer ShapesIDREF="ch0296"Pointer ShapesIDREF="ch0230"Implicit FocusIDREF="ch0298"Pointer ShapesIDREF="ch0226"Implicit FocusIDREF="ch0240"Explicit FocusIDREF="ch02106"Warp Pointer Only If Explicitly EnabledIDREF="ch0261"Pointing DevicesIDREF="ch09237"DescriptionIDREF="ch09239"DescriptionIDREF="ch0289"Pointer Shapespointing devicesIDREF="ch0260"Pointing DevicesIDREF="ch0259"The Input Device ModelIDREF="ch09167"DescriptionPopup MenusIDREF="ch09201"DescriptionIDREF="ch06195"Popup MenusIDREF="ch06105"Choosing Among Menus and PanelsIDREF="ch06256"Menu DesignIDREF="ch0916"DescriptionIDREF="ch0314"Mouse-Based NavigationIDREF="ch09248"Descriptionpositive and negative valuesIDREF="ch0832"Positive and Negative ValuesPOSIX 1003.1IDREF="ch086"Designing for International Marketspre-edit areaIDREF="ch089"Locating the Pre-Edit AreaIDREF="ch0816"Converting Pre-Edit Characters to Final CharactersIDREF="ch0810"Locating the Pre-Edit AreaIDREF="ch0811"Locating the Pre-Edit AreaIDREF="ch0812"Locating the Pre-Edit AreaPressIDREF="ch0274"Pointing DevicespreviewingIDREF="ch0532"Previewing and AutorepeatPrimary CopyIDREF="ch06200"Popup MenusIDREF="ch09253"DescriptionPrimary LinkIDREF="ch09254"DescriptionIDREF="ch06201"Popup Menusprimary modalIDREF="ch0743"Secondary Windows (Dialog)IDREF="ch06282"DialogBox DesignPrimary MoveIDREF="ch09252"DescriptionIDREF="ch06199"Popup Menusprimary selectionIDREF="ch0496"Primary TransferIDREF="ch0494"Primary TransferIDREF="ch0499"Primary TransferIDREF="ch09271"DescriptionIDREF="ch09272"DescriptionIDREF="ch0493"Primary TransferIDREF="ch09274"DescriptionIDREF="ch04102"Primary TransferIDREF="ch09277"DescriptionIDREF="ch09267"DescriptionIDREF="ch09280"Descriptionprimary transferIDREF="ch09273"DescriptionIDREF="ch09275"DescriptionIDREF="ch09278"DescriptionIDREF="ch09281"DescriptionIDREF="ch0495"Primary TransferIDREF="ch0497"Primary TransferIDREF="ch09268"DescriptionIDREF="ch04100"Primary TransferIDREF="ch04103"Primary Transferprimary windowsIDREF="ch077"Window SupportIDREF="ch0716"Window SupportIDREF="ch0335"Window NavigationIDREF="ch0344"Window NavigationIDREF="ch0724"Primary WindowPrintIDREF="ch0999"DescriptionIDREF="ch06150"MenuBarProduct InformationIDREF="ch06193"MenuBarIDREF="ch09146"DescriptionprogressIDREF="ch06312"Showing Progressprogressive disclosureIDREF="ch015"Use Progressive DisclosurePromoteIDREF="ch0977"DescriptionIDREF="ch06167"MenuBarIDREF="ch09266"DescriptionIDREF="ch06213"Popup MenusPrompt DialogBoxIDREF="ch06219"DialogBoxesIDREF="ch09283"DescriptionPromptBoxIDREF="appa30"OSF/Motif Widgets and Components Correspondenceproper namesIDREF="ch0851"Proper Names and AddressesPropertiesIDREF="ch09250"DescriptionIDREF="ch06197"Popup MenusprototypesIDREF="ch012"Adopt the User's PerspectivePulldownIDREF="ch09199"DescriptionPulldown MenuIDREF="ch06130"MenuBarIDREF="ch09184"DescriptionPulldown MenusIDREF="ch0313"Mouse-Based NavigationIDREF="ch06106"Choosing Among Menus and PanelsIDREF="ch06255"Menu DesignPushButtonIDREF="appa3"OSF/Motif Widgets and Components CorrespondenceIDREF="ch09285"DescriptionIDREF="ch0616"Choosing ComponentsIDREF="ch0926"DescriptionQuestion DialogBoxIDREF="ch09286"DescriptionIDREF="ch06229"DialogBoxesQuestionDialogIDREF="ch09209"Descriptionquick selectionIDREF="ch04110"Quick TransferIDREF="ch09291"DescriptionIDREF="ch04116"Quick TransferIDREF="ch09294"DescriptionIDREF="ch04105"Quick TransferIDREF="ch09297"DescriptionIDREF="ch09288"DescriptionIDREF="ch04113"Quick Transferquick transferIDREF="ch04114"Quick TransferIDREF="ch04117"Quick TransferIDREF="ch09289"DescriptionIDREF="ch04106"Quick TransferIDREF="ch09292"DescriptionIDREF="ch09295"DescriptionIDREF="ch09298"DescriptionIDREF="ch04111"Quick TransferRadioBoxIDREF="ch0695"Choosing a Single-Choice ComponentIDREF="ch0689"Choosing a Single-Choice ComponentRadioButtonIDREF="ch0626"Choosing ComponentsIDREF="appa6"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0931"DescriptionIDREF="ch09327"DescriptionIDREF="ch09300"Descriptionrange selectionIDREF="ch0459"Keyboard-Based Range SelectionIDREF="ch0433"Mouse-Based Range SelectionIDREF="ch09315"DescriptionIDREF="ch0422"Selection Modelsreading directionIDREF="ch0862"Scanning Directionreal world metaphorsIDREF="ch017"Use Real-World Metaphorsreal-estate drivenIDREF="ch0231"Implicit Focusreference pagesIDREF="ch094"Controls, Groups, and Models Reference Pagesrelated itemsIDREF="ch06269"Grouping Like Menu Elements TogetherReleaseIDREF="ch0275"Pointing DevicesReselectIDREF="ch06166"MenuBarIDREF="ch06212"Popup MenusIDREF="ch0976"DescriptionIDREF="ch0440"Mouse-Based Range SelectionIDREF="ch09265"DescriptionResetIDREF="ch06297"Common DialogBox ActionsIDREF="ch0958"Descriptionresize borderIDREF="ch0780"Resize BordersIDREF="ch0761"Window Decorationsresizing layoutIDREF="ch06243"Arranging Components for Resizing Layoutresponse immediacyIDREF="ch0113"Provide Rapid ResponseRestoreIDREF="ch0791"Window MenuIDREF="ch09335"DescriptionIDREF="ch0774"Maximize ButtonResumeIDREF="ch06296"Common DialogBox ActionsIDREF="ch0957"DescriptionRetryIDREF="ch0954"DescriptionIDREF="ch06293"Common DialogBox ActionsSashIDREF="ch09302"DescriptionIDREF="appa12"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0631"Choosing ComponentsIDREF="ch09229"DescriptionIDREF="ch0981"DescriptionSaveIDREF="ch06148"MenuBarIDREF="ch0997"DescriptionSave AsIDREF="ch0998"DescriptionIDREF="ch06149"MenuBarScaleIDREF="ch09305"DescriptionIDREF="ch0983"DescriptionIDREF="appa11"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0634"Choosing Componentsscanning directionIDREF="ch0861"Scanning Directionscrollable component navigationIDREF="ch038"NavigationIDREF="ch0365"Scrollable Component NavigationIDREF="ch0367"Scrollable Component NavigationScrollBarIDREF="ch09306"DescriptionIDREF="ch0636"Choosing ComponentsIDREF="ch06121"Common Client AreasIDREF="ch06128"ScrollBarsIDREF="appa10"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0985"DescriptionScrolledWindowIDREF="ch0658"Choosing ComponentsIDREF="ch09119"DescriptionIDREF="appa25"OSF/Motif Widgets and Components CorrespondenceIDREF="ch09307"DescriptionscrollingIDREF="ch0368"Scrollable Component NavigationIDREF="ch0364"Scrollable Component Navigationsecondary selectionIDREF="ch04107"Quick Transfersecondary windowsIDREF="ch0746"Secondary Windows (Dialog)IDREF="ch0747"Secondary Windows (Dialog)IDREF="ch0748"Secondary Windows (Dialog)IDREF="ch0749"Secondary Windows (Dialog)IDREF="ch0733"Primary WindowIDREF="ch0735"Secondary Windows (Dialog)IDREF="ch0338"Window NavigationIDREF="ch0712"Window SupportIDREF="ch0718"Window SupportIDREF="ch0740"Secondary Windows (Dialog)IDREF="ch0741"Secondary Windows (Dialog)IDREF="ch0345"Window NavigationSelect AllIDREF="ch06163"MenuBarIDREF="ch0973"DescriptionIDREF="ch09262"DescriptionIDREF="ch06209"Popup MenusSelect PastedIDREF="ch0975"DescriptionIDREF="ch06165"MenuBarIDREF="ch06211"Popup MenusIDREF="ch09264"DescriptionSelectAllIDREF="ch0469"Selecting and Deselecting All ElementsSelected MenuIDREF="ch06134"MenuBarIDREF="ch09187"DescriptionselectionIDREF="ch0463"Keyboard-Based Discontiguous SelectionIDREF="ch0464"Canceling a SelectionIDREF="ch0417"Selection ModelsIDREF="ch0466"Canceling a SelectionIDREF="ch0470"Selecting and Deselecting All ElementsIDREF="ch0471"Using Mnemonics for ElementsIDREF="ch0419"Selection ModelsIDREF="ch09269"DescriptionIDREF="ch09270"DescriptionIDREF="ch09290"DescriptionIDREF="ch0428"Mouse-Based Single SelectionIDREF="ch0492"Primary TransferIDREF="ch09308"DescriptionIDREF="ch04108"Quick TransferIDREF="ch09310"DescriptionIDREF="ch09312"DescriptionIDREF="ch09314"DescriptionIDREF="ch09316"DescriptionIDREF="ch09318"DescriptionIDREF="ch04109"Quick TransferIDREF="ch0430"Mouse-Based Browse SelectionIDREF="ch0432"Mouse-Based Multiple SelectionIDREF="ch0434"Mouse-Based Range SelectionIDREF="ch0421"Selection ModelsIDREF="ch0438"Mouse-Based Range SelectionIDREF="ch0444"Mouse-Based Discontiguous SelectionIDREF="ch0423"Selection ModelsIDREF="ch0448"Keyboard SelectionIDREF="ch06274"Separating Destructive ActionsIDREF="ch0425"Selection ModelsIDREF="ch0454"Keyboard-Based Single SelectionIDREF="ch0456"Keyboard-Based Browse SelectionIDREF="ch0458"Keyboard-Based Multiple SelectionIDREF="ch0460"Keyboard-Based Range Selectionselection actionsIDREF="ch0473"Clipboard TransferSelection DialogBoxIDREF="ch06221"DialogBoxesIDREF="ch09320"Descriptionselection modelIDREF="ch041"SelectionIDREF="ch0426"Selection ModelsIDREF="ch0415"Selection ModelsSelectionBoxIDREF="ch09319"DescriptionIDREF="appa28"OSF/Motif Widgets and Components CorrespondenceSeparatorIDREF="ch0612"Choosing ComponentsIDREF="appa1"OSF/Motif Widgets and Components CorrespondenceIDREF="ch0924"DescriptionIDREF="ch09322"DescriptionseparatorsIDREF="ch0831"Grouping SeparatorsIDREF="ch0827"Thousands SeparatorsIDREF="ch0829"Decimal SeparatorssequencesIDREF="ch0819"Collating SequencesshapesIDREF="ch0282"Pointer ShapesIDREF="ch0287"Pointer ShapesIDREF="ch09232"Descriptionsighting pointerIDREF="ch09245"DescriptionIDREF="ch0297"Pointer Shapessingle selectionIDREF="ch0427"Mouse-Based Single SelectionIDREF="ch0453"Keyboard-Based Single SelectionIDREF="ch09309"DescriptionIDREF="ch0416"Selection Modelssingle-choice componentsIDREF="ch0693"Choosing a Single-Choice ComponentIDREF="ch0676"Guidelines for Choosing Interactive MethodsIDREF="ch0687"Choosing a Single-Choice ComponentSizeIDREF="ch09337"DescriptionIDREF="ch0793"Window Menuspring-loadedIDREF="ch0319"Mouse-Based Navigationstatus areaIDREF="ch0814"Displaying StatusStopIDREF="ch0955"DescriptionIDREF="ch06294"Common DialogBox ActionsstructuresIDREF="ch06263"Keeping Menu Structures SimplesubmenusIDREF="ch06265"Keeping Menu Structures Simplesystem Menu buttonIDREF="ch0786"Window Menusystem MenusIDREF="ch09334"DescriptionIDREF="ch09344"Descriptionsystem modalIDREF="ch06284"DialogBox DesignIDREF="ch0745"Secondary Windows (Dialog)tab groupsIDREF="ch0355"Component NavigationTearOffIDREF="ch0516"TearOff ActivationTearOff activationIDREF="ch0912"DescriptionTearOff MenuIDREF="ch0682"Guidelines for Choosing Interactive MethodsIDREF="ch06104"Choosing Among Menus and PanelsTearOff MenusIDREF="ch06278"Using TearOffButtonsIDREF="ch0668"Guidelines for Choosing a Main Component GroupIDREF="ch06258"Menu DesignIDREF="ch06110"Choosing Among Menus and PanelsIDREF="ch0751"Menu WindowsTearOffButtonIDREF="ch0932"DescriptionIDREF="ch06103"Choosing Among Menus and PanelsIDREF="ch0681"Guidelines for Choosing Interactive MethodsIDREF="ch09323"DescriptionIDREF="ch0628"Choosing ComponentsTearOffButtonsIDREF="ch06277"Using TearOffButtonstelephone numbersIDREF="ch0847"Telephone NumberstextIDREF="ch0864"Translating Screen TextIDREF="ch0216"The Keyboard Focus ModelIDREF="ch09324"DescriptionIDREF="ch0867"Translating Screen TextIDREF="ch0328"Location CursorIDREF="ch0640"Choosing ComponentsIDREF="ch0684"Guidelines for Choosing Interactive MethodsIDREF="ch06111"Choosing Between Text or Canvas, and a LabelIDREF="ch0989"DescriptionIDREF="appa13"OSF/Motif Widgets and Components Correspondencetext pointerIDREF="ch0436"Mouse-Based Range Selectiontext-like collectionsIDREF="ch046"Selection Modelsthousands separatorsIDREF="ch0826"Thousands Separatorstime formatsIDREF="ch0845"Time Formatstitle areaIDREF="ch0764"Title AreaIDREF="ch0758"Window Decorationstitle barIDREF="ch0765"Title Areatoggle modelsIDREF="ch0446"Mouse-Based Discontiguous SelectionToggleButtonIDREF="ch09326"DescriptionIDREF="ch0929"DescriptionIDREF="ch0939"DescriptionIDREF="ch09301"DescriptionIDREF="ch0622"Choosing ComponentsIDREF="appa4"OSF/Motif Widgets and Components Correspondencetrack ballIDREF="ch09160"DescriptionIDREF="ch0264"Pointing Devicestrack listenerIDREF="ch0229"Implicit Focustrack pointerIDREF="ch0228"Implicit FocustransferIDREF="ch0476"Clipboard Transfertransient windowsIDREF="ch0720"Window SupportIDREF="ch0713"Window SupportIDREF="ch0339"Window Navigationtranslating textIDREF="ch0863"Translating Screen TextIDREF="ch0866"Translating Screen TexttraversalIDREF="ch0256"The Input Device ModelTutorialIDREF="ch09142"DescriptionIDREF="ch06177"MenuBarIDREF="ch06189"MenuBarIDREF="ch09130"Descriptiontypes of windowsIDREF="ch076"Window SupportundoIDREF="ch0465"Canceling a SelectionIDREF="ch06155"MenuBarIDREF="ch09251"DescriptionIDREF="ch0127"Anticipate ErrorsIDREF="ch06198"Popup MenusIDREF="ch0965"DescriptionUsing HelpIDREF="ch06191"MenuBarIDREF="ch09144"DescriptionvaluesIDREF="ch0833"Positive and Negative Valuesvertical alignmentIDREF="ch06246"Arranging Components for Aligned Layoutvertical panesIDREF="ch06253"Arranging Components in PanedWindowsView MenuIDREF="ch09191"DescriptionIDREF="ch06138"MenuBarvisual cueIDREF="ch0211"The Keyboard Focus ModelWarning DialogBoxIDREF="ch09329"DescriptionIDREF="ch06231"DialogBoxeswarningsIDREF="ch0129"Use Explicit DestructionIDREF="ch06314"Providing WarningswarpingIDREF="ch02107"Warp Pointer Only If Explicitly Enabledwindow control buttonsIDREF="ch0778"Other Buttonswindow familyIDREF="ch0348"Window Navigationwindow managerIDREF="ch072"Window Manager Design PrinciplesIDREF="ch0779"Other ButtonsIDREF="ch0757"Window Decorationswindow Menu buttonIDREF="ch0762"Window DecorationsIDREF="ch0785"Window Menuwindow MenusIDREF="ch09343"DescriptionIDREF="ch09333"Descriptionwindow navigationIDREF="ch0333"Window NavigationIDREF="ch0343"Window Navigationwindow panesIDREF="ch09304"DescriptionIDREF="ch09227"DescriptionIDREF="ch09178"DescriptionwindowsIDREF="ch09216"DescriptionIDREF="ch09217"DescriptionIDREF="ch09219"DescriptionIDREF="ch09220"DescriptionIDREF="ch0340"Window NavigationIDREF="ch0341"Window NavigationIDREF="ch0346"Window NavigationIDREF="ch0347"Window NavigationIDREF="ch06131"MenuBarIDREF="ch0246"Explicit FocusIDREF="ch06250"Arranging Components in PanedWindowsIDREF="ch028"The Keyboard Focus ModelIDREF="ch075"Window SupportIDREF="ch079"Window SupportIDREF="ch0710"Window SupportIDREF="ch0711"Window SupportIDREF="ch0714"Window SupportIDREF="ch0717"Window SupportIDREF="ch0719"Window SupportIDREF="ch0721"Window SupportIDREF="ch0723"Window SupportIDREF="ch0725"Primary WindowIDREF="ch0727"Primary WindowIDREF="ch0730"Primary WindowIDREF="ch0731"Primary WindowIDREF="ch0732"Primary WindowIDREF="ch0736"Secondary Windows (Dialog)IDREF="ch0738"Secondary Windows (Dialog)IDREF="ch0739"Secondary Windows (Dialog)IDREF="ch0753"Window DecorationsIDREF="ch0754"Window DecorationsIDREF="ch0768"Title AreaIDREF="ch0770"Title AreaIDREF="ch0772"Maximize ButtonIDREF="ch0776"Minimize ButtonIDREF="ch0781"Resize BordersIDREF="ch0798"Window NavigationIDREF="ch0336"Window NavigationIDREF="ch09181"DescriptionIDREF="ch09182"DescriptionIDREF="ch0337"Window NavigationWorking DialogBoxIDREF="ch06233"DialogBoxesIDREF="ch09346"DescriptionWorkingDialogIDREF="ch09210"DescriptionX pointerIDREF="ch09240"DescriptionIDREF="ch0292"Pointer ShapesYesIDREF="ch0949"DescriptionIDREF="ch06288"Common DialogBox Actionszoom featureIDREF="ch02104"Gain and AccelerationIDREF="ch02103"Gain and Acceleration