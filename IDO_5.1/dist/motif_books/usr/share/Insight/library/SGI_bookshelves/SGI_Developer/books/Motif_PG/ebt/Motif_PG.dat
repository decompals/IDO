#EDIR DATA#
OSF/Motif Programmer's GuideRevision 1.2 (For OSF/Motif Release 1.2)Copyright  1989, 1990, 1992 Open  Software  Foundation, Inc.Copyright  1989 Digital Equipment Corporation.Copyright   1987,  1988,  1989,  1992   Hewlett-Packard Company.Copyright  1988 Massachusetts Institute of Technology.Copyright  1988 Microsoft Corporation.ALL RIGHTS RESERVED The  information  contained  within  these documents is subject to change without notice.OSF MAKES NO WARRANTY OF ANY KIND WITH REGARD  TO  THIS MATERIAL,  INCLUDING,  BUT  NOT LIMITED TO, THE IMPLIED WARRANTIES  OF  MERCHANTABILITY  AND  FITNESS   FOR   A PARTICULAR PURPOSE.OSF shall not be liable for errors contained herein  or for incidental consequential damages in connection with the furnishing, performance, or use of this material.All rights are reserved.  No part of these publications may  be  photocopied,  reproduced,  or  translated into another language without the prior written  consent  of the Open Software Foundation, Inc. THIS  DOCUMENT  AND THE  SOFTWARE DESCRIBED  HEREIN ARE  FURNISHED UNDER  A LICENSE, AND MAY  BE USED AND COPIED ONLY IN ACCORDANCE WITH  THE TERMS OF  SUCH LICENSE AND  WITH THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE. TITLE TO AND OWNERSHIP  OF THE  DOCUMENT AND  SOFTWARE REMAIN WITH OSF OR ITS LICENSORS.FOR   U.S.   GOVERNMENT   CUSTOMERS   REGARDING    THIS DOCUMENTATION AND THE ASSOCIATED SOFTWAREThese notices shall be marked on  any  reproduction  of data, in whole or in part.NOTICE: Notwithstanding any other lease or license that may  pertain  to,  or  accompany  the delivery of, this computer  software,  the  rights  of   the   Government regarding  its  use, reproduction and disclosure are as set  forth  in  Section  52.227-19  of  FARS   Computer Software-Restricted Rights clause.RESTRICTED  RIGHTS   NOTICE:   Use,   duplication,   or disclosure by the Government is subject to restrictions as set forth in subparagraph (c)(1)(ii) of  the  Rights in Technical Data and Computer Software clause of DFARS 52.227-7013.PrefaceThe OSF/Motif  Programmer's Guide describes how to use the OSF/Motif‘ application programming interface to create Motif‘ applications.  The book gives an overview of the architecture of the Motif widget set, explains features of the Motif toolkit, and presents a model and examples for constructing Motif applications.  LBL="" HELPID=""AudienceThis document is written for designers and developers of Motif programs.  It does not provide sufficient information to develop new Motif widgets, although widget developers need to be familiar with the facilities and the issues discussed in this book.  This document assumes that the reader is familiar with the American National Standards Institute (ANSI) C programming language.  It also assumes that the reader has a general understanding of the X Window System, the Xlib library, and the X Toolkit Intrinsics (Xt).  LBL="" HELPID=""ApplicabilityThis is Revision 1.2 of this document.  It applies to Release 1.2 of the OSF/Motif software system.  LBL="" HELPID=""PurposeThe purpose of this guide is to explain how to write application programs using the Motif toolkit.  After reading this book, you should have a general understanding of the Motif toolkit and the Motif widget set and should be able to write applications that use them.  This guide is not intended to explain how to develop new classes of widgets.  LBL="" HELPID=""Document UsageThis document is organized into 16 chapters and two appendixes: IDREF="38059" TYPE="TITLE"Chapter 1, "Introduction," introduces the book and gives an overview of the X Window System, Xlib, Xt, and Motif.  IDREF="41387" TYPE="TITLE"Chapter 2, "The Motif Programming Model," summarizes the structure of the Motif widget hierarchy and discusses general principles for writing Motif programs.  IDREF="11935" TYPE="TITLE"Chapter 3, "Structure of a Motif Program," explains the structure and general elements of a Motif application.  IDREF="19352" TYPE="TITLE"Chapter 4, "Structure of a Program Using UIL and MRM," describes the structure of a program that uses the User Interface Language (UIL) and Motif Resource Manager (MRM).  IDREF="18979" TYPE="TITLE"Chapter 5, "Basic Controls," discusses most of the primitive widgets that form the building blocks of a Motif application.  IDREF="11089" TYPE="TITLE"Chapter 6, "Menus and Options," describes how to use the RowColumn widget to build menus, radio boxes, and check boxes.  IDREF="39367" TYPE="TITLE"Chapter 7, "Dialogs," describes the widgets most appopriate for conducting dialogs with the user.  IDREF="24337" TYPE="TITLE"Chapter 8, "Text," explains the Motif Text and TextField widgets, which provide general display and editing of text.  IDREF="21296" TYPE="TITLE"Chapter 9, "Scrolling, Panes, and Frames," discusses composite widgets commonly used to contain other widgets in the application.  IDREF="18723" TYPE="TITLE"Chapter 10, "Managing Geometry," discusses the process of negotiating the layout of widgets and describes the layout-management policies of particular Motif widgets.  IDREF="22857" TYPE="TITLE"Chapter 11, "Internationalization," is a guide to internationalizing applications and providing text, font, and other information that is specific to particular language environments.  IDREF="35125" TYPE="TITLE"Chapter 12, "Color and Pixmaps," explains how Motif uses colors and pixmaps and how an application can provide its own.  IDREF="11820" TYPE="TITLE"Chapter 13, "Input, Focus, and Keyboard Navigation," discusses issues in handling input, including keyboard focus and traversal, translations, and actions.  IDREF="13837" TYPE="TITLE"Chapter 14, "Graphics and Text in a DrawingArea," describes DrawingArea, a general-purpose widget for displaying graphics and handling user input at a low level.  IDREF="41117" TYPE="TITLE"Chapter 15, "Drag and Drop," is an extensive discussion of the Motif drag and drop interface, with which the user transfers data by manipulating iconic representations with the pointer.  IDREF="22739" TYPE="TITLE"Chapter 16, "Interclient Communication," discusses communication between an application and other clients, including the Motif Window Manager (MWM), by means of resources, selections, protocols, and properties.  IDREF="87449" TYPE="TITLE"Appendix A, "The Widget Meta-Language Facility," describes the Widget Meta-Language (WML) facility, which generates portions of the UIL compiler to support new widget sets.  IDREF="61196" TYPE="TITLE"Appendix B, "Drag and Drop Example Program," is an extended example program using the drag and drop interface.  LBL="" HELPID=""Related DocumentsFor additional information about OSF/Motif, refer to the following documents: The OSF/Motif Programmer's Reference provides detailed reference information for programmers writing Motif applications.  The Application Enviroment Specification (AES) name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' User Enviroment Volume defines a stable set of routines for creating user interface applications.  The OSF/Motif Style Guide explains the principles of user interface design for application developers.  The OSF/Motif User's Guide explains how to interact with OSF/Motif applications.  For additional information about Xlib and Xt, refer to the following X Window System documents: Xlibname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'C Language X Interfaceis the specification for Xlib.  X Toolkit Intrinsicsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'C Language Interfaceis the specification for Xt.  LBL="" HELPID=""Typographic and Keying ConventionsThis document uses the following typographic conventions: BoldBold words or characters represent system elements that an application or user must use literally, such as functions, data types, commands, flags, and pathnames.  Bold words also indicate the first use of a term included in the glossary.  ItalicItalic words or characters represent variable values and arguments that an application or user must supply.  Constant widthExamples and information that the system displays appear in this typeface.  < >Angle brackets enclose the name of a key on the keyboard.  ComponentNameComponents of the user interface are represented by uppercase letters for each major word in the name of the component, such as PushButton.  LBL="" HELPID=""Keyboard ConventionsBecause not all keyboards are the same, it is difficult to specify keys that are correct for every manufacturer's keyboard.  To solve this problem, this guide describes keys using a virtual key mechanism.  The term virtual implies that the keys as described do not necessarily correspond to a fixed set of actual keys.  Instead, virtual keys are linked to actual keys by means of virtual bindings.  A given virtual key may be bound to different physical keys for different keyboards.  See IDREF="11820" TYPE="TITLE"Chapter 13, "Input, Focus, and Keyboard Navigation,"
 of this book for information on the mechanism for binding virtual keys to actual keys.  For details see the VirtualBindings(3X) reference page in the OSF/Motif Programmer's Reference.  Since not all keyboards are the same, it is difficult to specify keys that are correct for every manufacturer's keyboard.  To solve this problem, this guide describes keys using a model keyboard† †mechanism.  Wherever keyboard input is specified, the keys are indicated by the engraving they have on the OSF/Motif model keyboard.  The model keyboard does not correspond directly to any existing keyboard; rather, it assumes a keyboard with an ideal set of keys.  In addition to the standard letter, number, and character keys, the OSF/Motif model keyboard is composed of the following special keys: The special printing characters </>,<\>,and <!> The standard modifier keys <Ctrl>,<Alt>,and <Shift> Ten function keys <F1> through <F10> The arrow keys <Up arrow>,<Down arrow>,<Left arrow>,and <Right arrow> <Backspace> <Cancel> <Delete> <End> <Escape> <Help> Either <Home>,<Begin> or both <Insert> <Menu> <PageDown> <PageUp> <Return> <Space> <Tab> The OSF/Motif model keyboard also contains the following optional keys, which, although useful, either are not necessary or may be created by combinations of other keys: <CapsLock> <Copy> <Cut> <Enter> <ModeSwitch> <NumLock> <PageLeft> <PageRight> <Paste> <ScrollLock> <Select> <Undo> Throughout this guide, behavior is described in terms of model keyboard keys.  When a behavior takes advantage of an optional key from the model keyboard, it is also described in terms of the required special keys.  Each of the keys described on the OSF/Motif model keyboard must be available either as specified or using other keys or key combinations if the specified key is unavailable.  A few of the more important alternative key bindings are described here.  If <Cancel> does not exist, <Escape> can be used in its place.  If <Help> does not exist, <F1> can be used in its place.  If <Menu> does not exist, <Shift> <F10> can be used in its place.  If <F10> does not exist, <Shift> <Menu> can be used in its place.  If <Home> or <Begin> does not exist, <Alt> <Left arrow> can be used in its place.  If <End> does not exist, <Alt> <Right arrow> can be used in its place Wherever <Select> and <Space> can be used for a selection action, <Ctrl> <Space> can be used as well.  LBL="1"ID="38059"IntroductionOSF/Motif is a graphical user interface, a means by which an application program can obtain input from and display output to a user of the application.  Motif provides the intermediary mechanisms for communication between the application and the user.  To both sides, these mechanisms appear as a set of objects with graphical representations on the ID="ch011"screen.  The program creates and displays objects of a variety of types provided by Motif for showing the user particular kinds of output and requesting particular kinds of input.  The user supplies input by manipulating the screen representations of these objects with the pointer, the keyboard, or both.  This book explains the Motif application programming interface.  This is the set of facilities that Motif gives an application developer to create and interact with a Motif interface for the application.  This book is not a reference work; that is, it does not attempt to describe the API in exhaustive detail.  Its focus is on giving an overview of the Motif architecture, explaining the concepts and conventions required to use the API, and providing examples.  This book complements other volumes in the OSF/Motif documentation set: ID="ch012"The OSF/Motif Programmer's Reference describes each element of the Motif programming interface in detail.  It is organized into reference pages, one for each element of the interface.  The Application Enviroment Specification (AES) User Enviroment Volume describes which elements of the interface an application should use for maximum portability.  All implementations of OSF/Motif must support the interfaces described in the AES.  The OSF/Motif Style Guide describes how an application should use the interface for maximum consistency with other Motif applications.  The OSF/Motif User's Guide describes the appearance and interaction style of Motif from the user's point of view.  The Motif API as supplied by OSF is implemented in the C programming language.  Motif requires that an application written in C conform to American National Standards Institute (ANSI) C.  This book assumes knowledge of ANSI C, which is explained by other published reference and tutorial books.  It is also possible to write applications in other languages, including C++, but this book gives explanations and examples only for applications written in C.  LBL="1.1" HELPID=""The X Window SystemID="ch013"ID="ch014"Motif is based on the X Window System, often abbreviated as X.  The X Window System is fundamentally a protocol by which an application can generate output on a computer that has a bitmapped display and can receive input from devices associated with the display.  X is based on a client-server computing model.  The application program is the ID="ch015"client, communicating through the X protocol with a server that handles the direct output to and input from the display.  This model has several important features: The client and server may be running on the same machine or on different machines, communicating over a network.  Only the server need concern itself with the display hardware.  The X protocol is hardware independent, so a client can run without alteration using any kind of display that supports the protocol.  A server may handle multiple clients on the same display at the same time.  These clients may communicate with each other, using the server to transfer information.  A client may communicate with multiple servers.  A display is an abstraction that represents the input and output devices controlled by a single server.  Usually a display consists of a keyboard, a pointing device, and one or more ID="ch016"screens.  A screen is an abstraction that represents a single bitmapped output device.  ID="ch017"Each client creates one or more windows on one or more screens of a given display.  A ID="ch018"window is a rectangular area of the screen on which the client displays output.  Windows are arranged in hierarchies of children and parents.  The server maintains a tree of windows for each screen.  The top-level window is the root window of the screen.  Each client typically creates at least one window as a child of the root window, and any other client windows are descendants of these top-level client windows.  Windows may overlap, and the server maintains a stacking order for all windows on a screen.  A child window may extend beyond the boundaries of its parent, but output is ID="ch019"ID="ch0110"clipped or suppressed outside the parent's borders.  ID="ch0111"A client asks the server to create and destroy windows, but the windows themselves are resources controlled by the server.  The server maintains other resources, including the following: A pixmap is a rectangular off-screen area into which an application can draw output.  Both windows and pixmaps are ID="ch0112"drawables or entities on which a client can display output.  The units of height and width in windows and pixmaps are ID="ch0113"pixels.  Each ID="ch0114"pixel has a given depth, represented as a number of bits or planes.  Thus, each pixel has an integral value whose range depends on the depth of the ID="ch0115"drawable.  A one-bit-deep pixmap is called a bitmap.  Each pixel in a bitmap has two possible values, 0 and 1.  ID="ch0116"A colormap is an association between pixel values and colors.  Each color is represented by a triple of red, green, and blue values that result in a particular color on a particular screen.  Each window has an associated colormap that determines what color is used to display each pixel.  ID="ch0117"A font is a collection of glyphs usually used to display text.  ID="ch0118"A cursor is an object containing information needed for a graphical representation of the position of the pointer.  It consists of a source bitmap, a shape bitmap, a ID="ch0119"hotspot or location representing the actual pointer position, and two colors.  ID="ch0120"A graphics context or GC is a collection of attributes that determine how any given graphics operation affects a drawable.  Each graphics operation on a drawable is executed using a given GC specified by the client.  Some attributes of a GC are the foreground pixel, background pixel, line width, and ID="ch0121"ID="ch0122"clipping region.  A property is a named data structure associated with a window.  Clients often use properties to communicate with each other.  ID="ch0123"Each client opens a connection to one or more servers.  Clients and servers interact by means of requests, replies, ID="ch0124"ID="ch0125"errors, and events.  A client sends a request to the server asking it to take some ID="ch0126"ID="ch0127"action, such as creating a window or drawing a line into a pixmap.  Some requests, such as requests for information, cause the server to generate replies to the client.  A request that results in an error condition may cause the server to generate an error report to the client.  The server executes requests from each client in the order in which it receives the requests from that client, although the server may execute requests from other clients at any time.  The server notifies clients of changes of state by means of events.  An ID="ch0128"event may be a side effect of a client request, or it may have a completely asynchronous cause, such as the user's pressing a key or moving the pointer.  In addition, a client may send an event, through the server, to another client.  Each client asks the server to send that client events of particular types that occur with respect to particular windows.  The server generally reports an event with respect to some window.  For example, the keyboard is conceptually attached to a window, known as the focus window.  When the user presses a key, the server usually reports an event with respect to the focus window.  If a client has asked the server to send it events of type ID="ch0129"ID="ch0130"KeyPress occurring with respect to some window, the server sends that client an event whenever the user presses a key while that window has the focus.  ID="ch0131"From the point of view of a client reading events from the server, events that result from that client's own requests arrive in the order in which it makes the requests.  However, those events may be interspersed with events that result from other causes, such as user input or another client's actions.  Furthermore, the client may buffer requests and the server may buffer events before actually transmitting them, so an event may arrive long after the client makes the request that generates the event.  The point is that for the most part event processing in X is inherently asynchronous.  Most client applications continually loop, reading an event, processing the event (possibly making requests during the processing), and then reading another event.  The client cannot assume, for example, that a given input event was generated after a given client request just because the client read the event after it made the request.  Many events have timestamps that indicate when the server actually generated the events.  A client that depends on the temporal ordering of events must often examine these timestamps.  ID="ch0132"LBL="1.2" HELPID=""Xlib, Xt, and MotifApplications do not communicate with the X server directly.  Instead, they use one or more libraries that provide high-level interfaces to the X protocol.  The three principal libraries available to a Motif application are Xlib, the X Toolkit Intrinsics (Xt), and the Motif toolkit.  LBL="1.2.1" HELPID=""XlibID="ch0133"X clients do not have to deal with the server at the level of the X protocol.  X includes a C language client interface to the protocol, called Xlib.  Among the Xlib facilities are the following: Routines for creating and managing the basic server resources, including windows, pixmaps, fonts, cursors, GCs, and properties Routines for rendering text and graphics into drawables Buffering of requests to the server and queuing of events from the server Data structures representing events of all types, and routines for selecting and reading events Routines for handling colormaps and for using device-independent color spaces Routines for generating text input and output in different locales The X resource manager (Xrm), a database of options specified by the user or the application The resource manager is the keystone of a fundamental tenet of X: that the user and application should control the appearance, interaction style, and other optional characteristics of a client.  For example, the background and foreground colors and the fonts used by an application might be represented as resources.  Typically, an application provides default values for such resources but allows the user to override the defaults.  ID="ch0134"ID="ch0135"ID="ch0136"A† †resource is a triple consisting of a name, a class, and a value.  A class may include a set of resources with different names.  Resources may be arranged hierarchically; a name and class may consist of components, each identifying the name or class of a particular level of the hierarchy.  The ID="ch0137"ID="ch0138"ID="ch0139"ID="ch0140"ID="ch0141"ID="ch0142"ID="ch0143"fully qualified name or class of a resource is the list of names or classes at all levels, starting with the name or class of the application and ending with the name or class of the resource itself.  ID="ch0144"ID="ch0145"The resource manager permits a user or application to specify resource values in a file, on the command line while starting the application, or by calling an Xrm routine in the program.  A resource specification must include either the name or the class of the resource, but it may be either partially or fully qualified according to name, class, or a mixture of name and class components.  The resulting resource database may include a variety of general and specific resource specifications.  When an application queries the database for a resource value, it supplies a fully qualified name and class.  The resource manager uses a search algorithm that returns the value from the most specific specification that matches the requested name and class.  LBL="1.2.2" HELPID=""XtID="ch0146"ID="ch0147"ID="ch0148"Although Xlib provides the fundamental means of interacting with the X server, developing a complex application using only Xlib would be a formidable task.  Xlib essentially supplies the primitives for an X client.  A complex application needs to combine these primitives into constructs that handle aspects of interaction with the server in a more general way.  X includes a library, the X Toolkit Intrinsics (abbreviated Xt), that supplies some of these higher-level interfaces.  Three of the most important Xt contributions are the following: Objects, known as widgets, used to hold data and present an interface to the user Management of widget geometry Dispatching and handling of events LBL="" HELPID=""WidgetsID="ch0149"At the heart of Xt is a set of data abstractions built on an object metaphor.  Each of these objects, called a widget, is a combination of state and procedure.  Each instance of a widget is a member of a class.  A widget ID="ch0150"class holds a set of procedures and data structures that are common to all widgets of that class.  A widget ID="ch0151"ID="ch0152"instance contains the procedures and data structures that are particular to that single widget.  A widget instance also has a pointer to its class.  ID="ch0153"ID="ch0154"Each widget class typically provides the general behavior associated with a particular kind of interaction with the user.  For example, Motif has a widget class designed to let the user enter and edit text.  This class provides the general behavior to support text input and display, including editing, selection, cutting, and pasting of text.  The class has data structures related not only to the content of the text but also to the appearance of the widget's on-screen representation.  To use this class, an application creates an instance of this class of widget and provides some of its own data and procedures for the widget instance.  Xt supports single inheritance of widget classes.  That is, a widget class may be a subclass of another class, its superclass.  A subclass is often a specialized variant of a more general superclass.  The subclass may inherit, override, or supplement the procedures and data structures of its superclass.  Xt generally supplies widget classes designed to be superclasses for other classes.  Motif supplies the subclasses of which the the application constructs widget instances.  IDREF="33140" TYPE="TITLE"Section 1.3, "Widget Classes and Hierarchy,"
 summarizes the Motif and Xt widget class hierarchy.  Widget instances form another, separate hierarchy.  Every widget except the top-level widget (or widgets) in an application has a parent widget.  Widgets of some classes, called composites, may have children.  Other kinds of widgets, often called either ID="ch0155"primitives or ID="ch0156"gadgets, generally do not have children.  An application constructs one or more trees of widget instances made up of composites, primitives, and gadgets.  For example, a ID="ch0157"menu may consist of a composite parent representing the menu and a number of primitive children representing buttons.  The menu and its children are one branch of the overall widget tree of the application.  Xt and Motif provide all the widget classes that most applications need.  It is possible for an application to define new widget classes, but this requires knowledge of Xt and of Motif internals that is beyond the scope of this book.  A typical application creates widget instances of the built-in classes, providing its own procedures and data for its widgets.  Xt uses an extension of the resource mechanism to represent the widget instance data that is available to an application.  Each widget class defines a set of resources that apply to widgets of that class.  A class may inherit or override the resources of its superclasses as well.  A widget class declares a name and a class for each of its resources.  Xt and Motif give each widget class a name, and the application gives each widget instance a name.  Finally, the application developer provides a name and a class for the application itself.  For a given resource of a given widget, the fully qualified name is the list of names beginning with the application name, continuing with the name of the top-level widget and then with the names of descendant widgets down to the name of the given widget, and ending with the name of the resource.  The fully qualified class is the list of classes beginning with the application class, continuing with the class of the top-level widget and then with the classes of descendant widgets down to the class of the given widget, and ending with the class of the resource.  The user, the application, and the widget class combine to provide values for resources and thus to control the appearance and other attributes of components of the application.  Both the user and the application developer can provide either specific or general specifications for widget resources in several resource files and on the command line.  They can also supply different resource specifications depending on the locale, the characteristics of the screen, or arbitrary customization criteria.  When the application starts up, Xt combines these specifications into an initial resource database.  When the application creates a widget, Xt assigns initial values to the widget's resources using a specification from the database, from values supplied by the application at creation time, or from defaults supplied by the widget class.  After creating a widget, the application can use the XtGetValues† †routine to retrieve the value of a widget resource and the ID="ch0158"XtSetValues routine to supply a new value for a resource.  ID="ch0159"LBL="" HELPID=""Widget GeometryID="ch0160"Most widgets either have an associated window or occupy a defined rectangular area of their parent's window.  Each widget has a height, width, and a position with respect to its parent, expressed as the x and y coordinates of the upper left corner of the widget.  Specification of the dimensions of widgets and their positions with respect to each other constitutes the layout or geometry of the application.  ID="ch0161"Application geometry results from the interaction of several factors: The user or application may supply values for resources that influence geometry, such as the height and width of a widget.  A window manager, a special client that controls the positions and sizes of top-level windows, runs on most displays.  Motif provides a window manager called the Motif Window Manager (MWM).  The user can change the size of most top-level windows by means of window manager facilities.  ID="ch0162"A child widget may have preferences about its size.  For example, a widget that displays a label may wish to be wide enough to display all the text of the label.  A parent widget may have preferences about the sizes and locations of its children.  For example, a menu widget may wish to lay out its button children aligned in a given number of rows or columns.  The process of accounting for all these factors and determining widget layout is known as geometry management.  Xt provides the essential means of handling geometry management: ID="ch0163"All widgets have resources that specify, either directly or indirectly, the geometry intended by the user or the application.  Xt has special widgets known as shells whose function is largely to handle interaction between the application and outside agents such as window managers.  ID="ch0164"Widget class procedures may ask the widget's parent to change the widget's geometry, may calculate a preferred size, and may recalculate the widget's layout when the widget is given a new size.  Parent widgets have ultimate control over the geometry of their children.  A widget class procedure of a parent may accept or reject a child's request to change its geometry.  In general a parent may change a child's geometry at any time.  A child is managed when it and its parent are prepared to negotiate geometry.  In general, widgets are eligible to appear on the screen only after they are managed.  ID="ch0165"ID="ch0166"See IDREF="18723" TYPE="TITLE"Chapter 10, "Managing Geometry,"
 for more information on geometry management and the specific management policies of Motif widgets.  LBL="" HELPID=""Event HandlingID="ch0167"Xt has an event-handling procedure that reads events from the server and dispatches them to appropriate widgets.  Each widget that has an associated window may also have a translation table.  This table maps descriptions of events to names of procedures, known as actions.  When Xt reads an event associated with a widget, it looks up the event description in the ID="ch0168"translation table and dispatches the event to the associated action routine.  An application can provide its own action routine, but most such routines are supplied by the widget class.  An action routine often takes some action on its own and then notifies the application by invoking an application procedure known as a callback.  Many widgets have resources whose value is a list of callback procedures.  The widget invokes the procedures on these lists at specified times, often when the widget receives certain kinds of events.  Xt supplies other means for an application to receive and respond to events, but many applications need only add appropriate callback procedures.  These callbacks do most of the "work" of the application in the course of interacting with the user.  ID="ch0169"The Xt event-handling mechanism leads naturally to an event-driven structure for an application program.  Most applications have the same general form: Initialize the application Create and manage the application widgets Provide callback procedures to be invoked by widgets Enter the Xt event-dispatching loop, which usually does not return See IDREF="11935" TYPE="TITLE"Chapter 3, "Structure of a Motif Program,"
 for more information about the structure of a Motif application.  LBL="1.2.3" HELPID=""MotifID="ch0170"ID="ch0171"Xt provides the substrate for creating a set of widgets responsible for specific aspects of a user interface.  Motif uses the Xt substrate to build both base classes and specialized subclasses of widgets for a variety of purposes.  IDREF="33140" TYPE="TITLE"Section 1.3, "Widget Classes and Hierarchy,"
 outlines the Motif widget set.  In addition to supplying widgets, Motif adds a number of features that are of general use to applications and users.  The following sections summarize some of these features.  LBL="" HELPID=""Visual StyleID="ch0172"Motif widgets have a distinctive visual style.  Many widgets have shadows with a three-dimensional look that makes the widget appear to be raised above or depressed below the background.  A widget that has keyboard focus may have a rectangular ID="ch0173"highlight† †border.  When the user presses the ID="ch0174"BSelect mouse button and focus is in a button, the color of the button face changes to indicate that the user has selected or "pressed" the button.  ID="ch0175"Motif automatically generates default colors for widget foregrounds, shadows, highlights, and selections states.  The user or application can supply its own colors or pixmaps as values for widget resources.  See IDREF="35125" TYPE="TITLE"Chapter 12, "Color and Pixmaps,"
 for more information on colors and pixmaps in Motif.  LBL="" HELPID=""Selections and Drag and DropID="ch0176"ID="ch0177"The X Window System establishes conventions for clients to follow in allowing the user to transfer data from one application to another.  These transfers operate through selections of several kinds, including primary, secondary, and clipboard selections.  A selection is a shared resource that can be owned by only one client at a time for a given display.  When the user wants to transfer data from one application to another, the receiving client asks the selection owner to convert the data into a form the receiving client understands, and then the ID="ch0178"receiver inserts the data.  This mechanism can also transfer data between one widget and another in the same application.  The Motif Text and TextField widgets support primary, secondary, and clipboard selections.  Motif also has routines that handle the ID="ch0179"ID="ch0180"clipboard selection, allowing an application to copy data easily to and from the clipboard.  Xt provides more general routines for transferring data by means of selections.  Motif has an extensive drag and drop mechanism for transferring data.  The user begins a transfer by pressing the ID="ch0181"BTransfer mouse button with the pointer over a data source.  The user then drags an iconic representation of the data to a spot that can receive the data, called a ID="ch0182"drop site.  When the user releases BTransfer the data is moved, copied, or linked to the drop site.  ID="ch0183"The Motif Text, TextField, List, and Label subclasses automatically support drag and drop transfer of textual and some pixmap data.  Motif includes an extensive programming interface of objects and routines that allow an application to establish its own drag sources and drop sites, control negotiation between sender and receiver, customize the visual elements, and convert arbitrary kinds of data.  ID="ch0184"ID="ch0185"ID="ch0186"ID="ch0187"See IDREF="22739" TYPE="TITLE"Chapter 16, "Interclient Communication,"
 for information on selections and the Motif clipboard interface.  See IDREF="41117" TYPE="TITLE"Chapter 15, "Drag and Drop,"
 for an extensive discussion of drag and drop.  LBL="" HELPID=""Keyboard TraversalID="ch0188"ID="ch0189"Motif provides two styles of transferring keyboard focus from widget to widget.  In one style, the widget that contains the pointer has focus.  In the other style, the user presses a key or the BSelect button to move focus to another widget, and the pointer location does not otherwise affect the focus.  ID="ch0190"In the second style, Motif distinguishes between traversal to a composite or a widget with internal navigation, called a tab group, and navigation to a widget or element within a tab group.  Motif has a number of resources and routines to control traversal using this style.  See IDREF="11820" TYPE="TITLE"Chapter 13, "Input, Focus, and Keyboard Navigation,"
 for more information on keyboard traversal and other input issues.  LBL="" HELPID=""Compound Strings and Font ListsID="ch0191"ID="ch0192"Motif represents much textual data using a data type called a compound string.  This is a byte stream consisting of components representing text, a display direction, and aID="ch0193"† †font list element tag.  A compound string can have multiple text segments, possibly with different directions and font list element tags.  Motif uses compound strings to represent all text except that in the Text and TextField widgets.  ID="ch0194"ID="ch0195"ID="ch0196"For each widget that can contain text, Motif maintains font information using a data type called a† †font list.  This is a list of entries, each consisting of a font list element tag and either a font or a ID="ch0197"font set.  A font set is a construct representing a group of fonts needed to display text in the locale of the application.  When Motif displays the text of a compound string segment, it matches the segment's font list element tag with a font list element tag from the widget's font list.  It then uses the associated font or font set to display the text of the segment.  A special font list element tag indicates text to be parsed in the encoding of the locale and displayed using the fonts needed in that locale.  See IDREF="22857" TYPE="TITLE"Chapter 11, "Internationalization,"
 for more information on compound strings and font lists, particularly for information on preparing an application for different language environments.  LBL="" HELPID=""Motif Window ManagerID="ch0198"ID="ch0199"The Motif Window Manager (MWM) is a Motif client that is capable of managing windows of either Motif or non-Motif applications.  MWM provides window decorations and functions for moving, resizing, raising, lowering, maximizing, and minimizing windows.  The user can display icons either on the root window or in an icon box.  MWM has many resources that permit the user to customize its appearance and behavior.  See IDREF="22739" TYPE="TITLE"Chapter 16, "Interclient Communication,"
 for more information on the application interfaces to MWM.  See the mwm(1X) reference page in the OSF/Motif Programmer's Reference for information on MWM resources and functions.  LBL="" HELPID=""UIL and MRMID="ch01100"ID="ch01101"ID="ch01102"ID="ch01103"Motif has a specification language called the User Interface Language (UIL).  The developer uses UIL to define widgets and data in a text file.  The developer then compiles this file into a binary format.  At run time the application, using Motif Resource Manager (MRM) routines, retrieves the widget descriptions and data definitions from the binary file, and MRM creates the widgets and data structures from these descriptions.  UIL and MRM work in conjunction with the Motif toolkit.  The application defines callback procedures and interacts with the widgets as if it were using the Motif toolkit alone.  By using UIL to define the program's widget hierarchies, the developer can separate the user interface specification from the application code.  A developer can change the interface by editing and recompiling a text file without recompiling and relinking the application program.  As with resource files, a developer can use separate UIL files to contain text, font lists, and other data specific to particular locales.  See IDREF="19352" TYPE="TITLE"Chapter 4, "Structure of a Program Using UIL and MRM,"
 for information on using UIL and MRM in an application.  See the UIL(5X) reference page in the OSF/Motif Programmer's Reference for information on UIL syntax.  LBL="1.2.4" HELPID=""Using Xlib, Xt, and MotifID="ch01104"ID="ch01105"ID="ch01106"ID="ch01107"Xt is built atop Xlib, and Motif is built atop Xt.  One goal of Xt is to give applications a set of high-level interfaces and objects that relieve the program of the need to deal with many primitive Xlib routines.  A goal of Motif is to give applications still higher-level interfaces and, particularly, a versatile set of widgets to relieve the program of the need to define its own widgets for most tasks.  However, Xt does not strive to replace all Xlib interfaces, and Motif does not strive to replace all Xt interfaces.  Even a simple Motif application must use basic Xt routines to initialize the toolkit, manage widgets, create windows for widgets, get and set resources, add callback routines, and enter the event-dispatching loop.  Many Motif applications do not need to call Xlib routines.  However, Motif does not have its own graphics routines, color-space facilities, or support for application management of input methods.  Programs that need these features must either use vendor-supplied tools or call Xlib routines directly.  As a general rule, an application should use the highest-level interfaces sufficient for the tasks at hand.  Not only does this usually result in a concise program, but it also ensures that the program functions as intended when a higher-level procedure supersedes a lower-level procedure.  For example, Xlib, Xt, and Motif all have routines to set keyboard focus to a window or widget.  Xt and Motif both maintain internal state that keeps track of focus changes.  If a Motif application uses the Xt or Xlib routine, it may cause Motif or Xt to become internally inconsistent.  By convention, the names of Xlib routines and data structures begin with "X"; the names of Xt routines and data structures begin with "Xt"; and the names of Motif routines and data structures begin with "Xm".  This book does not document Xlib or Xt interfaces.  A Motif application developer must have a working knowledge of basic Xt application interfaces and should have at least general familiarity with Xlib.  For more information on Xlib, see the X Consortium Standard Xlibname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'C Language X Interface.  For more information on Xt, see the X Window System document X Toolkit Intrinsicsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'C Language Interface.  LBL="1.3" HELPID=""ID="33140"Widget Classes and HierarchyID="ch01108"ID="ch01109"This section gives a brief overview of the hierarchy of widget classes in Xt and Motif.  IDREF="41387" TYPE="TITLE"Chapter 2, "The Motif Programming Model,"
 discusses this hierarchy in more detail.  LBL="1.3.1" HELPID=""Xt ClassesXt defines the base classes for all widgets.  Core is the fundamental class for all widgets that can have windows.  ID="ch01110"Core has basic resources for a widget's geometry, background color, translations, and sensitivity to input.  Widgetlike objectsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'called ID="ch01111"gadgets in Motifname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'that do not have windows are subclasses of ID="ch01112"RectObj.  This class has geometry resources but no colors or translations.  ID="ch01113"Composite is the base class for all widgets that can have children.  This class maintains a list of its children and is responsible for managing their geometry.  ID="ch01114"Constraint is a subclass of Composite that maintains additional data for each child, represented by ID="ch01115"ID="ch01116"constraint resources for the child.  Shell is the base class for shell widgets.  Shells envelop other widgets whose windows are children of the root window.  Shells are responsible for interaction with the window manager.  ID="ch01117"Shell is a subclass of Composite.  Xt has the following subclasses of ID="ch01118"ID="ch01119"Shell: ID="ch01120"OverrideShellEnvelops widgets that the window manager should ignore, such as menus ID="ch01121"WMShellSuperclass for shells that need to interact specifically with the window manager ID="ch01122"VendorShellSubclass of ID="ch01123"WMShell that implements toolkit-specific behavior ID="ch01124"TransientShellSubclass of ID="ch01125"VendorShell for widgets such as dialogs that appear briefly on behalf of other widgets ID="ch01126"TopLevelShellSubclass of ID="ch01127"VendorShell for top-level widgets for components of the application ID="ch01128"ApplicationShellSubclass of ID="ch01129"TopLevelShell for the top-level widget that represents the application as a whole ID="ch01130"LBL="1.3.2" HELPID=""Motif ClassesMotif has three broad groups of widgets: primitives and gadgets, managers, and shells.  LBL="" HELPID=""Primitives and GadgetsID="ch01131"ID="ch01132"Primitives are widgets that have no children.  They are commonly the fundamental units of input and output, and they are usually building blocks for composite widgets.  XmPrimitive, a subclass of Core, is the base class for all primitives.  ID="ch01133"ID="ch01134"ID="ch01135"XmPrimitive has basic color resources and provides keyboard traversal behavior.  ID="ch01136"ID="ch01137"XmPrimitive is used only as a superclass for classes with more specific behavior.  Following are the subclasses of Motif primitives: ID="ch01138"ID="ch01139"XmSeparatorUsed to separate other widgets; usually appears as a line.  ID="ch01140"ID="ch01141"XmLabelDisplays text or a pixmap.  As a superclass for buttons, provides specialized behavior, such as keyboard traversal, inside menus.  ID="ch01142"ID="ch01143"XmLabel subclasses XmCascadeButton, XmDrawnButton, ID="ch01144"ID="ch01145"ID="ch01146"ID="ch01147"ID="ch01148"ID="ch01149"XmPushButton, and XmToggleButton perform some action when activated or "pressed" by the user.  Subclasses have roles as menu activators, toggles, pushbuttons, and small graphics areas.  ID="ch01150"ID="ch01151"ID="ch01152"ID="ch01153"XmScrollBarControl that moves a scroll widget horizontally or vertically with respect to a fixed viewport on the scroll.  ID="ch01154"ID="ch01155"XmListArray of textual items from which the user can select one or more entries.  ID="ch01156"ID="ch01157"XmTextWidget for display and possible editing of text.  ID="ch01158"ID="ch01159"XmText may be multiline or constrained to a single line.  XmTextField is a variant optimized for single-line text.  ID="ch01160"ID="ch01161"Gadgets are variants of primitives that have no windows.  Gadgets have geometry, but they inherit colors from their parents and depend on their parents to dispatch input events to them.  XmGadget, a subclass of RectObj, is the base class for gadgets.  ID="ch01162"ID="ch01163"ID="ch01164"Gadget variants exist for separators, labels, and most button classes.  ID="ch01165"See IDREF="24337" TYPE="TITLE"Chapter 8, "Text,"
 for more information on the Text and TextField widgets.  See ID="ch01166"ID="ch01167"IDREF="18979" TYPE="TITLE"Chapter 5, "Basic Controls,"
 for more information on other primitives.  LBL="" HELPID=""ManagersID="ch01168"A manager is a widget that generally has children and manages their geometry.  XmManager, a subclass of Constraint, is the base class for managers.  This class has special responsibilities when it has gadget children.  It provides color resources that its gadget children inherit, and it dispatches input events to appropriate gadgets.  Following are the subclasses of Motif managers: ID="ch01169"ID="ch01170"ID="ch01171"XmFrameSurrounds a child with a shadow and a margin.  ID="ch01172"ID="ch01173"XmScaleDisplays a value within a range and optionally allows the user to supply a new value.  ID="ch01174"ID="ch01175"XmPanedWindowArranges children, called panes, vertically from top to bottom.  May insert a control called a ID="ch01176"ID="ch01177"sash that lets the user adjust the size of a pane.  XmScrolledWindowProvides a viewport onto a child widget that behaves as a virtual scroll.  Manages ScrollBars to move the scroll with respect to the viewport.  ID="ch01178"ID="ch01179"XmMainWindowSubclass of ScrolledWindow that provides support for a MenuBar and other specialized areas.  ID="ch01180"ID="ch01181"ID="ch01182"ID="ch01183"XmRowColumnImplements menus, RadioBoxes, and CheckBoxes, usually consisting of button children.  Can be used to lay out arbitrary widgets in rows, columns, or two-dimensional formations.  ID="ch01184"ID="ch01185"XmBulletinBoardSuperclass for dialogs, widgets that present information to the user or seek information from the user.  The ID="ch01186"ID="ch01187"dialog widget may be a BulletinBoard, which provides general behavior, or a specialized subclass.  Common subclasses present a list from which the user makes a selection, display filenames and allow the user to choose one, ask the user to enter a command, and display a message.  One subclass, ID="ch01188"XmForm, performs general constraint-based geometry management for its children.  ID="ch01189"ID="ch01190"XmDrawingAreaGeneral-purpose manager suitable for use as a canvas for graphics operations.  ID="ch01191"ID="ch01192"See the following chapters for more information on Motif manager widgets: RowColumnIDREF="11089" TYPE="TITLE"Chapter 6, "Menus and Options"
 ; IDREF="18723" TYPE="TITLE"Chapter 10, "Managing Geometry"BulletinBoard subclassesIDREF="39367" TYPE="TITLE"Chapter 7, "Dialogs"
; IDREF="18723" TYPE="TITLE"Chapter 10, "Managing Geometry"ScrolledWindow, MainWindow, PanedWindow, FrameIDREF="21296" TYPE="TITLE"Chapter 9, "Scrolling, Panes, and Frames"
† †DrawingAreaIDREF="13837" TYPE="TITLE"Chapter 14, "Graphics and Text in a DrawingArea"
† †LBL="" HELPID=""ShellsID="ch01193"Motif has three shell classes: VendorShellMotif-specific implementation of the Xt class.  Among other responsibilities, manages communication with MWM.  ID="ch01194"XmDialogShellSubclass of ID="ch01195"ID="ch01196"TransientShell that envelops dialogs.  Cooperates with BulletinBoard in popping up and positioning transient dialogs.  ID="ch01197"ID="ch01198"XmMenuShellSubclass of ID="ch01199"ID="ch01200"OverrideShell that envelops menus.  ID="ch01201"LBL="" HELPID=""Other Motif ClassesMotif uses a number of specialized objects that are not intended to be used in creating widgets.  These objects exist primarily to hold resources and other information that would be difficult to make available in another way.  XmDisplay holds resources specific to a given display, and ID="ch01202"XmScreen holds resources specific to each screen on which the application has created a widget.  The drag and drop interface includes objects representing several aspects of a drag and drop transaction, including the general context, drop sites, drag icons, and data transfers.  ID="ch01203"LBL="1.4" HELPID=""Header Files and LibrariesID="ch01204"ID="ch01205"ID="ch01206"Xlib, Xt, and Motif all have header files that an application must include.  However, the Motif header files themselves include the required Xt files, which in turn include the required Xlib files.  An application usually needs to include only the proper Motif files.  All Motif applications must include the file <Xm/Xm.h>.  This file contains definitions that all applications need.  Each Motif widget also has an include file.  An application must include the header files for all widgets it creates.  In addition, some groups of Motif routines have their own header files.  Required include files for each Motif widget and routine are documented in the OSF/Motif Programmer's Reference.  Instead of using a large number of include files for particular widgets and routines, an application can include <Xm/XmAll.h>.  This file incorporates all documented Motif header files.  When building a Motif application, a developer must link the program with the appropriate libraries.  Xlib, Xt, the Motif toolkit, and MRM have separate libraries.  An application that does not use MRM must be linked with the Motif toolkit, Xt, and Xlib libraries.  An application that uses MRM must be linked with these libraries and also with the MRM library.  A developer might also need to link the application with additional libraries, depending on the platform and operating system.  Consult your system administrator and vendor documentation for more information on the libraries required for Motif applications.  LBL="2"ID="41387"The Motif Programming ModelOSF/Motif accommodates a variety of application programming styles.  An application can accomplish most tasks, such as handling a particular kind of user input or displaying a particular kind of output, in more than one way.  While this flexibility is one of the strengths of OSF/Motif, the toolkit has been designed with a set of programming principles in mind.  This chapter explains at a general level the intended uses of Motif widgets and other features of the toolkit.  The next chapter outlines the structure of common Motif programs, and succeeding chapters explain toolkit features in more detail.  The following general principles make sense in writing any Motif program: Adopt a user-centered perspective.  In most Motif programs, the application does its work in response to commands or other input from the user.  An important part of interface design is deciding precisely which commands, options, and other information the user can give the application.  The interface then consists largely of procedures that execute the user's commands or otherwise respond to the user's input.  Separate the design of the core application and the user interface.  The core application should not depend on a particular user interface.  Often it's a good idea to specify a set of generic routines and data structures for obtaining input and displaying output.  The developer can then implement these routines in different ways to provide different user interfaces for the application.  Follow the OSF/Motif Style Guide in designing the user interface.  Although an application can use Motif widgets in many configurations, users find some more common, intuitive, and comfortable than others.  The OSF/Motif Style Guide contains requirements and recommendations for compliant applications, and it offers more advice on application design.  Outline the widget hierarchy.  Once you have settled on one or more combinations of widgets, you may find the implementation more tractable if you sketch a genealogy of all the widgets the program uses.  Constructing a widget tree can reveal gaps and awkwardness in the design.  Attaching dialogs and menus to the hierarchy may help ensure consistency and completeness in the presentation and solicitation of information.  Use high-level interfaces when possible.  A Motif application must use some X Toolkit Intrinsics (Xt) interfaces, and it may call other public Xt and Xlib routines.  For some tasks, such as drawing graphics, an application must call lower-level routines.  However, Motif provides interfaces such as resources, callback lists, and convenience routines to handle many common tasks.  Motif also includes both simple and composite widgets that do most of the work related to their specific functions, such as text editing or constraint-based geometry management.  Using a high-level Motif interface instead of a comparable series of lower-level calls can make code simpler and more maintainable.  Use resource files and the User Interface Language (UIL) to specify characteristics of the interface.  Avoid locking the user-interface specification and data into the application code.  Using resources gives the user the power to override application-supplied default behavior.  UIL provides the opportunity to separate the widget hierarchy from the application.  With both resources and UIL, the developer can change the interface without recompiling the application code.  These mechanisms also provide the means to tailor the interface and data for particular language environments.  LBL="2.1" HELPID=""A User-Centered ModelA basic principle of Motif and Xt programming is that the user is in charge of the application.  Except in unusual circumstances, the program takes action in response to commands or other input from the user.  In fact, a typical Motif program spends most of its real time waiting for the user to provide input.  The fundamental object type in a Motif interface is the widget.  Some widgets can display output or process input or both; some widgets serve to contain other widgets.  A widget is usually associated with a ID="ch021"window or a rectangular area of the screen.  A widget also has attributes, called ID="ch022"resources, which can often be set by the user or the application.  An application organizes widgets into one or more hierarchies or trees of parent widgets and their children.  ID="ch023"Motif and Xt define a set of widget types or classes.  A widget class may be a subclass of another class; in that case it inherits some of the attributes and behavior of the superclass.  Motif has three basic classes of widgets: ID="ch024"ID="ch025"Primitives are the basic units of input and output.  Primitives usually do not have children.  Specialized Motif primitives include labels, separators, buttons, scroll bars, lists, and text widgets.  Some primitive classes have equivalent objects called ID="ch026"gadgets.  These are just like primitives except that, to enhance performance, they have no associated windows.  ID="ch027"Managers are composite widgets that contain primitives, gadgets, or other managers.  Managers are responsible for the geometrical arrangement of their children.  They also process and dispatch input to their gadget children.  Specialized Motif managers include frames, scrolled and paned windows, menus, constraint-based geometry managers, and several kinds of dialogs.  ID="ch028"Shells are widgets whose main purpose is to communicate with the window manager.  Most shells have only one child, and they maintain the same size and position as the child.  Specialized Motif shells exist to envelop applications, dialogs, and menus.  ID="ch029"Defining a widget hierarchy is one of the two main tasks of a Motif application.  The other is to define a set of callback procedures.  Callbacks are the primary means by which the application responds to user input.  When the user takes an action like pressing a key or a mouse button, the X server sends the application an ID="ch0210"event.  Xt dispatches these events to the appropriate widget, usually the one to which the user directed the input.  Xt maps the event to one or more widget ID="ch0211"action routines.  The action may change the state of the widget and, if the application has asked to be notified of that action, may "call back" to the program by invoking an application callback procedure.  ID="ch0212"Many Motif widgets have resources that are lists of callback procedures.  Motif invokes a list of callbacks when the user takes an action that has a particular meaning.  For example, most buttons have callbacks that Motif invokes when the user activates the button.  The user may activate the button in a number of ways, such as by pressing the ID="ch0213"KSelect key or the BSelect mouse button.  The events that constitute ID="ch0214"ID="ch0215"activation and other meaningful user actions are defined in a general way in the OSF/Motif Style Guide and are documented for specific widgets in the OSF/Motif Programmer's Reference.  The user action may cause Motif to change to the state and appearance of a widget.  For example, when the user presses KSelect in a PushButton, Motif may make the button appear to be depressed and then released, like a mechanical push button.  The action may have other effects depending on the context.  For example, Motif has a dialog widget called a FileSelectionBox, used for finding and selecting files.  When the user activates the "filter" PushButton in a FileSelectionBox, Motif searches for and displays the names of files that match a pattern displayed elsewhere in the FileSelectionBox.  ID="ch0216"ID="ch0217"ID="ch0218"In general Motif takes care of changing the state and appearance of a widget to correspond to the user's action.  By default, though, this action has no effect on the application.  The application programmer must interpret the meaning of the action for the application by providing a callback routine, which Motif invokes when the user takes that action.  The callback routine may change the state of the application, for example, by changing the value of a variable when the user selects a new value from a Scale widget.  The callback may cause the application to take an action.  It may also change the state of one or more widgets itself, or it may create an entirely new widget hierarchy.  ID="ch0219"When both Motif and the application have finished responding to a user action, the application waits for the user to provide more input.  Xt provides a routine in which applications spend most of their time.  This routine waits for an event, dispatches it to the appropriate widget, and then waits for another event.  After initializing the toolkit and creating the initial widget hierarchy, most applications enter this loop and remain there until the user terminates the program.  Motif and Xt provide other ways for applications to direct and respond to events, but for simple programs, virtually the entire interface between the user and the application consists of callback routines.  LBL="2.2" HELPID=""Separating Interface from ApplicationA widely accepted principle of application design is that a core application should not rely on a specific user interface.  Separating the application from the interface allows developers to work on the two components independently.  It also allows the program to run with different interfaces without changes in the core application.  This makes it easier to port the application to more than one interface and to experiment with different configurations of a single interface.  Many applications need to collect input from the user and to display output in some form.  It may be easier to separate the core application from the user interface if the developer specifies a set of generic input and output routines along with any necessary data structures.  If these generic interfaces have no dependence on specific user interfaces, they can be implemented in different ways for different interfaces without changing the core application.  They form a module for communication between the core application and the interface.  The Motif implementation of the interface module consists of code to perform the following tasks: Initialize the Intrinsics Create the widget hierarchy Define callback procedures Make widgets visible Enter a loop that waits for and responds to user input These steps are explained in detail in IDREF="11935" TYPE="TITLE"Chapter 3, "Structure of a Motif Program."
† †The User Interface Language (UIL) helps enforce the separation of the interface from the core application.  With UIL, the developer defines widgets and their characteristics in a text file and then compiles the text file into a binary format.  At run time, the application uses Motif Resource Manager (MRM) routines to retrieve the widget descriptions from the binary file, and MRM creates the widgets from these descriptions.  The UIL file can also define data such as text strings and colors, and MRM can retrieve the data at run time.  ID="ch0220"ID="ch0221"ID="ch0222"ID="ch0223"In this way, an application can remove the description of the widget hierarchy from the program code.  In its source code, the application defines callback procedures and interacts with the widgets as if it were using the Motif toolkit alone.  If the application has defined all the callback procedures it needs, a developer can change the widget hierarchy by editing and recompling the UIL file without recompiling and relinking the source program.  LBL="2.3" HELPID=""Building Blocks: Primitive Widgets and GadgetsID="ch0224"ID="ch0225"Primitive widgets are the fundamental units of input and output in Motif.  Primitives are commonly the widgets at the leaves of an application's widget hierarchy.  These widgets do not have children of their own.  The name ID="ch0226"primitive does not imply simplicity; some primitives, such as the Text widget, have quite complicated behavior.  Primitive is meant to contrast with manager, a widget that usually has children.  It also suggests a basic component from which composite widgets are built.  Primitives are often referred to as controls.  ID="ch0227"The XmPrimitive Motif widget class is the superclass for all primitives.  ID="ch0228"ID="ch0229"XmPrimitive is itself a subclass of the fundamental Xt widget class, Core.  ID="ch0230"Core has resources that describe the widget's width, height, and x and y coordinates with respect to its parent.  Other Core resources control characteristics of the window, such as its background color; whether or not the widget can receive input events; and the mapping that Xt uses to translate events into calls to the widget's action routines.  XmPrimitive adds two groups of features to the Core class.  One group consists of resources to control additional visual characteristics, including the characteristic three-dimensional shadow and a highlighting rectangle that can appear when the widget is the focus for keyboard input.  The second group controls ID="ch0231"ID="ch0232"ID="ch0233"keyboard traversal, the use of the keyboard to move focus from one widget to another.  This group includes several resources and a set of translations and actions that allow the user to move the keyboard focus to another widget by pressing an arrow key.  ID="ch0234"ID="ch0235"XmPrimitive also provides callbacks to let the application provide help information when the user presses KHelp.  ID="ch0236"The XmGadget widget class is the superclass for all gadgets.  ID="ch0237"ID="ch0238"XmGadget is a subclass of the Xt widget class RectObj.  This class provides resources to determine the dimensions and position of the gadget's rectangular area inside its parent.  ID="ch0239"XmGadget is equivalent to XmPrimitive, with two exceptions: ID="ch0240"ID="ch0241"Gadgets have no color or pixmap resources; they inherit these from their parents.  ID="ch0242"Gadgets do not have translations or actions.  A gadget's parent controls keyboard traversal from the gadget to another widget, and it dispatches events to the gadget when appropriate.  ID="ch0243"XmPrimitive and XmGadget are used only as superclasses for other classes of widgets.  ID="ch0244"ID="ch0245"ID="ch0246"ID="ch0247"XmPrimitive and XmGadget are not instantiable; that is, an application cannot create an actual widget that is an instance of either of these classes.  Motif has several specialized subclasses of primitives and gadgets, summarized in the following sections.  ID="ch0248"ID="ch0249"LBL="2.3.1" HELPID=""Label and SeparatorID="ch0250"ID="ch0251"Labels provide the ability to display static (uneditable) text or a pixmap.  A Label or LabelGadget itself is useful for displaying a message, title, or description.  Label and LabelGadgets are also superclasses for buttons used as menu items, toggles, or controls.  ID="ch0252"ID="ch0253"A Label can display either text or a pixmap.  When a Label displays text, it uses a construct called a ID="ch0254"compound string.  This is a stream of bytes that represents zero or more pieces of text, each with an associated tag and display direction.  When Motif displays the compound string, it matches each tag with a tag in the widget's ID="ch0255"font list and uses the corresponding font or fonts from the font list to display the text.  ID="ch0256"A Separator or SeparatorGadget separates controls or groups of controls.  It usually appears as a horizontal or vertical line and supports several styles of line drawing.  ID="ch0257"ID="ch0258"Labels and Separators are described in more detail in IDREF="18979" TYPE="TITLE"Chapter 5, "Basic Controls."LBL="2.3.2" HELPID=""ButtonsID="ch0259"A button is a basic control that performs some action when the user activates it.  Buttons commonly appear in menus, RadioBoxes and CheckBoxes, SelectionBoxes and MessageBoxes.  Motif has the following classes of buttons: ID="ch0260"ID="ch0261"ID="ch0262"ID="ch0263"A CascadeButton or CascadeButtonGadget is used inside a menu and, when activated, usually causes a PulldownMenu to appear.  ID="ch0264"ID="ch0265"ID="ch0266"A PushButton or PushButtonGadget can appear either inside or outside a menu.  It performs some action determined by the application.  When a PushButton is armed, or ready to be activated, it changes its appearance so that it looks as if the user has pressed it in.  When it is disarmed, it reverts to the appearance of extending out.  ID="ch0267"ID="ch0268"ToggleButtons and ToggleButtonGadgets have one of two states: like toggle switches, they are either on or off.  They can appear in menus or in nonmenu RowColumn WorkAreas, including RadioBoxes and CheckBoxes.  ID="ch0269"ID="ch0270"ID="ch0271"ID="ch0272"ID="ch0273"ID="ch0274"A DrawnButton is an empty button surrounded by a shadow border.  It is intended to be used as a PushButton but with graphics drawn by the application.  ID="ch0275"ID="ch0276"Buttons are described in more detail in IDREF="18979" TYPE="TITLE"Chapter 5, "Basic Controls."LBL="2.3.3" HELPID=""ScrollBarID="ch0277"A widget can act as a viewport onto a virtual scroll.  The scroll is a plane with text, graphics, a list of items, or other contents.  The viewport is a fixed-size window onto a portion of the scroll.  A ScrollBar is the control that moves the viewport horizontally or vertically relative to the underlying scroll.  A ScrollBar consists of a rectangle, called the scroll region, representing the full size of the scroll.  It has a smaller rectangle, called the slider, within the scroll region, representing the position and size of the viewport relative to the full scroll.  The ScrollBar usually has arrow graphics at both ends of the larger rectangle.  ID="ch0278"ScrollBars are described in more detail in IDREF="18979" TYPE="TITLE"Chapter 5, "Basic Controls."LBL="2.3.4" HELPID=""ListID="ch0279"A List is an array of textual items from which the user selects one or more entries.  Each item is a compound string.  A List has four modes for selecting items: two that allow the user to select one item at a time, and two that allow the user to select more than one item in either contiguous or discontiguous ranges.  ID="ch0280"Lists are described in more detail in IDREF="18979" TYPE="TITLE"Chapter 5, "Basic Controls."
† †ID="ch0281"LBL="2.3.5" HELPID=""TextText is a widget for displaying and possibly editing text.  When the Text is editable and the user presses a key that represents a text character, that character is inserted into the text.  Other translations and actions allow the user to navigate or to select, cut, copy, paste, or scroll the text.  ID="ch0282"The text in a Text widget can be multiline or constrained to be a single line.  In a single-line widget, actions that move up and down one line in a multiline widget instead traverse to another widget, and pressing ID="ch0283"KTab moves the keyboard focus to another group of widgets instead of inserting a ID="ch0284"Tab character.  A TextField is essentially the same as a Text widget in single-line mode, except that its performance is optimized for single-line text operations.  ID="ch0285"Text is described in more detail in IDREF="18979" TYPE="TITLE"Chapter 5, "Basic Controls,"
 and IDREF="24337" TYPE="TITLE"Chapter 8, "Text."LBL="2.4" HELPID=""ManagersID="ch0286"A manager is a widget that usually contains children, either primitives or other managers.  One responsibility of a manager is to position and shape its children so that the configuration of the children is appropriate for the manager's specialized purpose.  Another responsibility is to determine whether a gadget child should process an input event and, if so, to dispatch the event to that child.  The XmManager Motif widget class is the superclass for all managers.  ID="ch0287"ID="ch0288"XmManager is a subclass of Core.  Like ID="ch0289"XmPrimitive, XmManager has resources to control colors or pixmaps used for the foreground, shadows, and highlighting rectangle.  Most managers do not have shadows or highlighting rectangles, but gadget children inherit the related resources.  Managers also have resources that control keyboard traversal, and they provide callbacks for processing user requests for help.  In addition, they have translations and actions for dispatching input events to gadget children, usually to the child that is the current focus of keyboard events.  XmManager is not an instantiable widget class; it is used only as a subclass for other widgets.  Motif has several specialized subclasses of managers, summarized in the following sections.  ID="ch0290"ID="ch0291"LBL="2.4.1" HELPID=""FrameID="ch0292"A Frame is a simple manager that surrounds a single child with a shadow and a margin.  A Frame can also have another child that appears as a title for the Frame.  ID="ch0293"Frames are discussed in more detail in IDREF="21296" TYPE="TITLE"Chapter 9, "Scrolling, Panes, and Frames."LBL="2.4.2" HELPID=""ScaleID="ch0294"A Scale is a manager that functions as a control.  It displays a value within a range and optionally allows the user to supply a new value.  Its appearance and behavior are much like those of a ScrollBar without arrows.  It also has a title and can display the current value next to the slider.  If the application adds other children to a Scale, the Scale positions them evenly along the rectangular area that represents the range of values, and these children then act as tic marks or value labels.  ID="ch0295"ID="ch0296"Scales are discussed in more detail in IDREF="18979" TYPE="TITLE"Chapter 5, "Basic Controls."LBL="2.4.3" HELPID=""PanedWindowID="ch0297"A PanedWindow arranges its children vertically from top to bottom and forces them all to have the same width.  Each child is a ID="ch0298"pane of the window.  Between each pair of panes, PanedWindow inserts an optional Separator and a control called a ID="ch0299"ID="ch02100"sash.  By manipulating a sash with the mouse or keyboard, the user can increase or decrease the height of the pane above.  PanedWindow has resources to control the margins, the spacing between panes, and the appearance of the sashes.  Each pane of a PanedWindow has resources specifying a maximum and minimum height and whether or not either the pane itself or the PanedWindow should be allowed to resize the pane without user intervention.  ID="ch02101"PanedWindow is discussed in more detail in IDREF="21296" TYPE="TITLE"Chapter 9, "Scrolling, Panes, and Frames."LBL="2.4.4" HELPID=""ScrolledWindow and MainWindowID="ch02102"ID="ch02103"A ScrolledWindow manages a viewport and ScrollBars to implement a window onto a virtual scroll.  The user can move the viewport to display different portions of the underlying scroll using the ScrollBars or keyboard scrolling commands.  ID="ch02104"ID="ch02105"ScrolledWindow is capable of performing scrolling operations automatically.  In this mode, the application creates the widget that represents the scroll as a child of the ScrolledWindow.  The ScrolledWindow then creates a clipping window to act as the viewport, creates and manages the ScrollBars, and moves the viewport with respect to the scroll when the user issues a scrolling command.  ID="ch02106"ID="ch02107"ScrolledWindow can also allow the application to perform scrolling operations.  In this mode, the application must create and manage the ScrollBars and must change the contents of the viewport in response to the user's scrolling commands.  ID="ch02108"ID="ch02109"List and Text widgets are often used as virtual scrolls.  Motif has convenience routines to create List and Text widgets inside ScrolledWindows, and the resulting ScrolledList and ScrolledText widgets perform scrolling operations without intervention by the application.  ID="ch02110"ID="ch02111"ID="ch02112"ID="ch02113"ID="ch02114"MainWindow is a subclass of ScrolledWindow that is intended as the primary window in an application.  In addition to a viewport and ScrollBars, MainWindow includes an optional MenuBar and an optional command window and message window.  ID="ch02115"ID="ch02116"ID="ch02117"ID="ch02118"The ScrolledWindow and MainWindow widgets are described in more detail in IDREF="21296" TYPE="TITLE"Chapter 9, "Scrolling, Panes, and Frames."LBL="2.4.5" HELPID=""RowColumnID="ch02119"RowColumn implements both menus and nonmenu WorkAreas.  Menus are widgets that allow the user to make choices among actions or states.  Motif offers four basic kinds of menu: ID="ch02120"ID="ch02121"A MenuBar usually appears in the application's MainWindow and sometimes in other components.  It most often consists of a row of CascadeButtons that, when activated, cause PulldownMenus to appear.  ID="ch02122"ID="ch02123"ID="ch02124"ID="ch02125"A PopupMenu contains a set of choices that apply to a component of the application.  The menu is not visible until the user takes an action that posts it, It can contain buttons that take action directly or CascadeButtons that cause PulldownMenus to appear.  ID="ch02126"ID="ch02127"ID="ch02128"A PulldownMenu is associated with a CascadeButton in a MenuBar, a PopupMenu, or another PulldownMenu.  The menu is not visible until the user posts it by activating the associated CascadeButton.  Like a PopupMenu, a PulldownMenu can contain buttons that take action directly or CascadeButtons that cause other PulldownMenus to appear.  ID="ch02129"ID="ch02130"ID="ch02131"ID="ch02132"An OptionMenu allows the user to choose among one set of choices, usually mutually exclusive attributes or states.  It consists of a label, a CascadeButtonGadget whose label shows the currently selected option, and a PulldownMenu containing buttons that represent the set of options.  ID="ch02133"ID="ch02134"ID="ch02135"One use for a nonmenu RowColumn WorkArea is to contain a set of ToggleButtons constituting a RadioBox or a CheckBox.  When the user selects a ToggleButton, its state changes from on to off or from off to on.  Another use is to lay out an arbitrary set of widgets in a row, column, or two-dimensional formation.  ID="ch02136"ID="ch02137"ID="ch02138"ID="ch02139"ID="ch02140"RowColumn is discussed in more detail in IDREF="11089" TYPE="TITLE"Chapter 6, "Menus and Options."LBL="2.4.6" HELPID=""BulletinBoard, Form, MessageBox, SelectionBoxID="ch02141"ID="ch02142"ID="ch02143"ID="ch02144"Dialogs are container widgets that provide a means of communicating between the user and the application.  A dialog widget usually asks a question or presents some information to the user.  In some cases, the application is suspended until the user provides a response.  The usual superclass for a dialog widget is XmBulletinBoard.  The dialog widget can be either a BulletinBoard itself or one of its more specialized subclasses.  BulletinBoard is a container with no automatically created children; it supplies general behavior needed by most dialogs.  Its subclasses provide child widgets and specific behavior tailored to particular types of dialogs: ID="ch02145"ID="ch02146"A SelectionBox is a BulletinBoard subclass that allows the user to select a choice from a list.  It usually contains a List, an editable text field displaying the choice, and three or four buttons for accepting or canceling the choice and seeking help.  ID="ch02147"ID="ch02148"ID="ch02149"A FileSelectionBox is a specialized SelectionBox for choosing a file from a directory.  It contains two text fields, one containing a file search pattern and the other containing the selected filename; two lists, one displaying filenames and the other displaying subdirectories; and a set of buttons.  ID="ch02150"ID="ch02151"A Command is a specialized SelectionBox for entering a command.  Its main components are a text field for editing the command and a list representing the command history.  ID="ch02152"ID="ch02153"A MessageBox is a BulletinBoard subclass for displaying messages to the user.  It usually contains a message symbol, a message label, and up to three buttons.  Motif provides distinct symbols for several kinds of messages: errors, warnings, information, questions, and notifications that the application is busy.  ID="ch02154"ID="ch02155"A TemplateDialog is a specialized MessageBox that allows the application to build a custom dialog with additional children, such as a MenuBar and added buttons.  ID="ch02156"ID="ch02157"ID="ch02158"A Form is a BulletinBoard subclass that performs constraint-based geometry management.  The children of a Form have resources that represent attachments to other children or to the Form, offsets from the attachments, and relative positions within the Form.  The Form calculates the positions and sizes of its children based partly on these constraints.  This layout function makes Form useful outside dialogs as well.  ID="ch02159"ID="ch02160"Dialogs are discussed in more detail in IDREF="39367" TYPE="TITLE"Chapter 7, "Dialogs."LBL="2.4.7" HELPID=""DrawingAreaID="ch02161"A DrawingArea is a manager suited for use as a canvas containing graphical objects.  An application must interact with a DrawingArea at a somewhat lower level than with other Motif widgets, but a DrawingArea provides the application with more fine-grained information about events.  DrawingArea has callbacks to notify the application when the widget is exposed or resized and when it receives keyboard or mouse input.  An application generally must use Xlib routines to draw into the DrawingArea, and the application is responsible for updating the contents when necessary.  The flexibility of a DrawingArea makes it a useful widget for implementing both graphical and text features not provided by other Motif widgets.  ID="ch02162"DrawingArea is discussed in more detail in IDREF="41117" TYPE="TITLE"Chapter 15, "Drag and Drop."LBL="2.5" HELPID=""ShellsID="ch02163"Users of X Window System applications normally employ a window manager, a special application that may control the positions, sizes, and border decorations of top-level windows on the display.  Motif supplies its own window manager, the Motif Window Manager (MWM), but Motif applications can cooperate with other window managers as well.  ID="ch02164"A window manager communicates with other applications through a protocol defined in an X Window System document, the Inter-Client Communication Conventions Manual (ICCCM).  Xt and Motif define a group of widgets whose main responsibility is to envelop other widgets and communicate with the window manager.  These widgets are called shells.  A shell is nearly invisible to the application.  Each shell has a single managed child, and the shell's window usually remains coincident with the child's window.  The application must create shells when needed, but many Motif convenience routines that create widgets also create shells automatically.  Once it has created a shell, the application may not need to handle the shell again.  For example, an application can position or resize a Motif shell by positioning or resizing the child widget.  Each widget with a top-level windowname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'that is, a window whose parent is the root window of the screenname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'needs to be enclosed in a shell.  This is true of the main application widget, but it is also true of dialogs, menus, and any top-level widgets other than the main application widget.  Motif provides three classes of shell: VendorShell, DialogShell, and MenuShell.  ID="ch02165"ID="ch02166"ID="ch02167"LBL="2.5.1" HELPID=""VendorShellID="ch02168"VendorShell is the shell class that provides Motif-specific behavior for shells other than those surrounding menus.  It is responsible for communication between the application and MWM.  VendorShell is a superclass for other classes.  TopLevelShell is an Xt subclass of VendorShell that surrounds a top-level widget in an application.  ApplicationShell is another Xt subclass of VendorShell that surrounds the main widget in the application.  ID="ch02169"ID="ch02170"ID="ch02171"Many applications create only one ApplicationShell.  A program can create this shell explicitly, or it can use the Xt convenience routine ID="ch02172"XtAppInitialize to initialize the application and automatically create the ApplicationShell.  ID="ch02173"LBL="2.5.2" HELPID=""DialogShellID="ch02174"XmDialogShell is a VendorShell subclass that envelops dialogs.  Although the window manager takes account of dialogs, they are usually transient; they appear to provide information to or solicit information from the user, and then they disappear.  DialogShell is a subclass of the Xt TransientShell class, which keeps track of the application to which the dialog belongs.  Users cannot iconify a dialog separately from the main application window.  ID="ch02175"ID="ch02176"ID="ch02177"ID="ch02178"DialogShell is designed to have a child that is a subclass of BulletinBoard.  Most Motif convenience routines that create dialogs create DialogShell parents automatically.  ID="ch02179"ID="ch02180"LBL="2.5.3" HELPID=""MenuShellID="ch02181"XmMenuShell is the class of shell that surrounds PopupMenus and PulldownMenus.  MenuShell is a subclass of the Xt OverrideShell class.  This class enables the shell to bypass the window manager.  Most Motif convenience routines that create PopupMenus and PulldownMenus create MenuShell parents automatically.  ID="ch02182"ID="ch02183"ID="ch02184"ID="ch02185"ID="ch02186"LBL="2.6" HELPID=""Applications, Top-Level Widgets, and DialogsID="ch02187"ID="ch02188"Primitives, managers, and shells are the components Motif provides for building an interface.  A developer assembles these components into the broadest units of the program: dialogs, top-level widgets, and the application itself.  One approach to this construction is to specify the connection between the core application and the user interface.  The developer determines what information the application needs to obtain from and present to the user.  From this assessment, the developer specifies a generic interface to the application and then implements a Motif version using particular combinations of widgets.  Another approach is to design the user interface from the application level down to specific widgets.  The developer decides what the top-level components of the application should be and how they relate to each other.  From this assessment, the developer designs a combination of widgets that presents the application clearly to the user and permits a graceful transition from one task to another.  The developer can then finely adjust the visual appearance of the interface.  In practice, a developer is likely to use both the bottom-up and top-down approaches at different stages of the program design.  The approaches converge at the level of the application.  LBL="2.6.1" HELPID=""ApplicationsID="ch02189"The application is the highest level of abstraction of a Motif program.  In one sense the application embodies the entire program.  In another sense, the application is the primary widget in the program.  The user may cause other widgets to appear, but the application is the focus of activity and is usually the first widget to appear when the user starts the program.  The widget that represents the application is commonly a MainWindow.  For many applications, the essential operations should be available from the MenuBar at the top of the MainWindow.  By browsing through the MenuBar, the user can quickly determine what general functions the application provides.  The activation callbacks for the buttons in menus that are pulled down from the MenuBar initiate the general operations of the application.  The ID="ch02190"ID="ch02191"OSF/Motif Style Guide contains requirements and recommendations for the contents of the application MenuBar and its PulldownMenus.  ID="ch02192"The MainWindow usually contains a large scrollable work area.  Single-component applications usually perform most of their work using this region.  Other applications may require more than one work area.  ID="ch02193"An ApplicationShell encloses the main widget of an application.  The developer can use the Xt function ID="ch02194"XtAppCreateShell to create an ApplicationShell directly or can let Xt create the shell during a call to ID="ch02195"XtAppInitialize.  ID="ch02196"Usually a program has only one application, but sometimes a program is made up of multiple logical applications.  In this case, the program may have more than one main window, each enveloped in a separate ApplicationShell.  ID="ch02197"LBL="2.6.2" HELPID=""Top-Level WidgetsID="ch02198"ID="ch02199"Although it is unusual for a program to have more than one logical application, it is more common for an application to require multiple top-level widgets.  For example, a mail-processing program may consist of a component for reading mail and another for composing and sending it.  Each major component of an application may reside in a top-level widget.  Each top-level widget must be enclosed in a TopLevelShell or an ApplicationShell.  One approach is to have a single ApplicationShell for the application, with each TopLevelShell a ID="ch02200"ID="ch02201"popup child of the ApplicationShell.  The program does not create a window for the ApplicationShell.  Another approach is to designate one top-level widget the application, enclosed in an ApplicationShell, and make the other TopLevelShells popup children of the ApplicationShell.  A popup child is one whose window is a child of the root window and whose geometry is not managed by its parent widget.  ID="ch02202"Multiple top-level widgets are discussed in more detail in IDREF="11935" TYPE="TITLE"Chapter 3, "Structure of a Motif Program."LBL="2.6.3" HELPID=""DialogsID="ch02203"Dialogs are transient components used to display information about the current state of the application or to obtain specific information from the user.  A dialog widget is usually a BulletinBoard or one of its subclasses, enclosed in a DialogShell.  The DialogShell is a popup child of another widget in the hierarchy.  Its window is a child of the root window, but the user cannot iconify a dialog separately from the main application.  ID="ch02204"ID="ch02205"A dialog can be modalname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'that is, it can prevent other parts of the application from processing input while the dialog is active.  It can also be ID="ch02206"modeless, so that the user can interact with the rest of the application while the dialog is visible.  Motif has convenience routines that create both the dialog widget and the DialogShell for several kinds of information.  ID="ch02207"ID="ch02208"Dialogs are discussed in more detail in IDREF="39367" TYPE="TITLE"Chapter 7, "Dialogs."LBL="2.7" HELPID=""Resources: User and Program CustomizationID="ch02209"A widget, a class of widgets, and an application as a whole have a set of attributes that the program can examine and that the user and program may be able to specify.  These attributes are implemented as X resources.  Xlib has a facility called the X resource manager (Xrm) whose purpose is to establish and query databases of resources.  Xt and Motif build on Xrm to make resources the repository of publicly available attributes of widgets as well as applications.  ID="ch02210"Xt maintains databases of resources that apply to several levels: To the application as a whole To the display on which an application is running To the screen on which a widget hierarchy is created To a class of widgets To an individual widget The user can specify resources at any of these levels through resource files or the command line used to start the program.  The application can also specify resources through resource files.  Each application has a name and a class; each widget within an application has a name and a class; and each resource has a name and a class.  When supplying resource values in a file or on the command line, the user or the application specifies the scope of the resource value by qualifying the resource according to its name or class.  For example, a user might specify that all resources of the class Background should have a particular value for all widgets; or the user might specify that only the resource named background within a particular hierarchy of named widgets should have a particular value.  The qualification mechanism allows resource values to be specified at any level.  Most widget classes define a set of resources, by name and class, that apply to those classes.  Subclasses inherit superclass resources, unless a subclass overrides the superclass resource specification.  A widget class also defines a default value for each of its resources, used in case the user and the application do not provide another value.  When an application starts up, Xt constructs an initial database of resource values.  This database is derived from a combination of user and application resource files and the command line.  Some resources in the database may have different values depending on the display or the screen on which the application is running.  When an application creates a widget, Xt uses this initial database in combination with the widget class resource defaults to supply values for the widget's resources.  The application can override these values by supplying arguments to the routine that creates the widget.  It can set a resource value after creating the widget by using the Xt function XtSetValues.  ID="ch02211"Setting resources is the primary means by which an application changes the attributes of a widget.  However, an application should be careful not to override the user's specification of many resources governing characteristics such as visual appearance and the policy for determining which widget has keyboard focus.  In general, the application should set only those resources necessary for the proper functioning of the program.  An application can specify preferences for other resource values in an application defaults file.  Xt reads this file when an application starts up, but a user can override the values supplied there.  The process by which Xt creates the initial resource database is discussed in more detail in IDREF="11935" TYPE="TITLE"Chapter 3, "Structure of a Motif Program."
† †LBL="2.8" HELPID=""Handling Input and OutputID="ch02212"ID="ch02213"The X server communicates input to a client through input events† †associated with a window.  In the simplest case, when a keyboard or pointer event occurs, the X server sends the event to the client that has expressed interest in events of that type on the window that contains the pointer.  However, processing can be more complex.  A client can ID="ch02214"grab a pointer button or key, the pointer or keyboard, or the entire server; the client then receives the relevant events.  A client can set the ID="ch02215"input focus to some window, and the X server then reports events with respect to this window even if the pointer is outside this window.  ID="ch02216"ID="ch02217"To insulate applications from such complexities, Xt and Motif supply facilities for low-level processing of user input to an application: A VendorShell resource, XmNkeyboardFocusPolicy, allows the user or application to determine whether keyboard events go to the widget that contains the pointer or the widget in which the user presses ID="ch02218"ID="ch02219"BSelect (a "click-to-type" policy).  ID="ch02220"In the click-to-type model, the user can also use keys to navigate from widget to widget or from one group of widgets to another.  Xt provides the basic event-dispatching loop used by most applications.  Xt takes events out of the application's queue and dispatches them to the appropriate widget, usually the widget that has input focus.  Xt usually invokes an action associated with the particular event through a table of ID="ch02221"translations from event specifications to action routines.  The action, in turn, often invokes a callback list.  ID="ch02222"Motif and Xt provide mnemonics and accelerators, which are shortcuts for taking actions associated with a widget when the widget does not have input focus.  A ID="ch02223"ID="ch02224"mnemonic is a keysym for a key that activates a visible button in a menu.  An ID="ch02225"accelerator is a description for an event that invokes an action routine through a translation.  ID="ch02226"Most applications can use these high-level interfaces, allowing Xt and Motif to process user input at lower levels.  If an application needs more control, it can also provide its own event handler, a routine invoked by the Xt dispatching loop when the widget receives events of the specified type.  An application can also provide its own event-dispatching loop.  ID="ch02227"ID="ch02228"Issues of input, focus, and keyboard navigation are discussed in more detail in IDREF="11820" TYPE="TITLE"Chapter 13, "Input, Focus, and Keyboard Navigation."For most widgets, Xt and Motif handle low-level output processing as well.  For example, in a Label or Text widget, when an application changes the text to be displayed, Motif automatically redisplays the contents of the widget.  Most widgets have resources that control the appearance of the output, such as the fonts used to display text.  ID="ch02229"ID="ch02230"Motif provides the DrawingArea widget for applications that need to produce graphic output or that need more control or flexibility in displaying text.  DrawingArea is discussed in more detail in ID="ch02231"IDREF="41117" TYPE="TITLE"Chapter 15, "Drag and Drop."LBL="3"ID="11935"Structure of a Motif ProgramOSF/Motif uses the same event-driven programming model as the X Toolkit Intrinsics.  At its core, a Motif application waits for the user to provide input, usually by pressing a key, moving the mouse, or clicking a mouse button.  Such an action by the user causes the X server to generate one or more X Window System events.  Xt listens for these events and dispatches them to the appropriate Motif widget, usually the widget to which the user directed the input.  The widget may take some action as a result of the user input.  If the application has asked to be notified of that action, the widget "calls back" to the applicationname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'that is, it invokes an application callback procedure.  When both Motif and the application have finished responding to the user input, the application waits for the user to provide more input.  This cycle of user-initiated events and application response, called the event loop, continues until the user terminates the application.  ID="ch031"For simple applications, the Intrinsics and Motif toolkits do everything necessary for dispatching user input to widgets.  The application must take the following actions: Include the required header files Initialize the Intrinsics Create one or more widgets Define callback procedures and attach them to widgets Make the widgets visible Enter the event loop This chapter discusses each of these actions.  The following table summarizes these steps and some of the procedures the application needs to call.  Note that some of these steps are different when the application uses UIL and MRM.  See IDREF="19352" TYPE="TITLE"Chapter 4, "Structure of a Program Using UIL and MRM,"
 for more information.  COLUMNS="3"LEFT="0" WIDTH="36"StepLEFT="45" WIDTH="99"DescriptionLEFT="150" WIDTH="356"Related FunctionsLEFT="0" WIDTH="36"1LEFT="45" WIDTH="99"Include required 
header files.  LEFT="150" WIDTH="356"#include <Xm/Xm.h>#include <Xm/widget.h>LEFT="0" WIDTH="36"2LEFT="45" WIDTH="99"Initialize Xt IntrinsicsLEFT="150" WIDTH="356"XtAppInitialize() LEFT="0" WIDTH="36"LEFT="45" WIDTH="99"Do steps 3 and 4 for each widget.  LEFT="150" WIDTH="356"LEFT="0" WIDTH="36"3LEFT="45" WIDTH="99"Create widgetLEFT="150" WIDTH="356"XtSetArg()XtCreateManagedWidget()or† †XmCreate<WidgetName>()followed byXtManageChild(widget)† †LEFT="0" WIDTH="36"4LEFT="45" WIDTH="99"Add callback routinesLEFT="150" WIDTH="356"XtAddCallback()LEFT="0" WIDTH="36"5LEFT="45" WIDTH="99"Realize widgetsLEFT="150" WIDTH="356"XtRealizeWidget(parent)LEFT="0" WIDTH="36"6LEFT="45" WIDTH="99"Enter event loopLEFT="150" WIDTH="356"XtAppMainLoop()LBL="3-1"Table 3-1 Steps in Writing Widget ProgramsLBL="3.1" HELPID=""Including Header FilesID="ch032"ID="ch033"All Motif applications must include the file <Xm/Xm.h>.  This file contains definitions that all applications need.  It also includes the Xt header files <X11/Intrinsic.h> and <X11/StringDefs.h>.  Each Motif widget also has an include file.  An application must include the header files for all widgets it creates.  In addition, some groups of Motif routines have their own header files.  For example, an application that uses any of the Motif clipboard routines must include the file <Xm/CutPaste.h>.  Required include files for each Motif widget and routine are documented in the OSF/Motif Programmer's Reference.  Following is an example of including header files for an application that uses only a Text widget: ID="ch034"#include <Xm/Xm.h>
#include <Xm/Text.h>LBL="3.2" HELPID=""Initializing the IntrinsicsID="ch035"ID="ch036"ID="ch037"ID="ch038"The first task of a Motif application is to initialize the Intrinsics.  Most applications can perform the initialization by calling the routine XtAppInitialize.  This is a convenience routine that combines several initialization steps, each of which the application can take separately by calling a specialized Xt routine: ID="ch039"Initialize the state of the Intrinsics.  An application can also do this by calling XtToolkitInitialize.  ID="ch0310"Create an application context.  Xt uses this construct to contain the information it associates with each instance of an application.  Its purpose is to allow multiple instances of an application to run in a single address space.  Most applications need only create an application context and pass it to Intrinsics routines that take an application context as an argument.  The data type is XtAppContext.  An application can create an application context explicitly by calling ID="ch0311"XtCreateApplicationContext.  ID="ch0312"Open a connection to a display and attach it to an application context.  When an application uses XtAppInitialize, the display specification comes from the command line invoking the application or from the user's environment.  After opening the display, Xt builds a resource database by processing resource defaults and command-line options.  The construction of this database is described in the next section,  ID="ch0313"IDREF="37526" TYPE="TITLE"Section 3.2.1, "The Initial Resource Database."
  An application can perform these steps explicitly by calling XtOpenDisplay.  If an application already has an open display as a result of calling ID="ch0314"XOpenDisplay, it can attach the display to an application context and build the initial resource database by calling ID="ch0315"XtDisplayInitialize.  ID="ch0316"Create a top-level shell widget for the application.  XtAppInitialize creates an ApplicationShell and returns it as the function's return value.  An application can create a top-level shell by calling ID="ch0317"ID="ch0318"XtAppCreateShell.  ID="ch0319"Following is an example of a simple call to XtAppInitialize: ID="ch0320"int main(int argc, char **argv)
{
† †   Widget         app_shell;
† †   XtAppContext   app;
† †   app_shell = XtAppInitialize(&app, "Example",
† †       (XrmOptionDescList) NULL, 0, &argc, argv,
† †       (String *) NULL, (ArgList) NULL, 0);
}LBL="3.2.1" HELPID=""ID="37526"The Initial Resource DatabaseID="ch0321"ID="ch0322"The XtDisplayInitialize routine builds the initial resource database for the application.  An application rarely needs to call this routine directly; it is called by ID="ch0323"XtOpenDisplay, which in turn is called by ID="ch0324"XtAppInitialize.  ID="ch0325"XtDisplayInitialize builds a separate resource database for each display connection.  The initial database combines resource settings from the command line, the display, an application class defaults file, and user defaults files that may be specialized according to the application or the host on which the application is running.  The application class defaults and the user's per-application defaults may be further specialized according to the language environment and possibly according to a general-purpose ID="ch0326"customization resource.  The resources in the initial database may pertain to particular widgets or widget classes or to the application as a whole.  When the application creates widgets, the resource settings from the database are often the source for the initial values of widget resources.  ID="ch0327"ID="ch0328"The remainder of this section describes the order in which XtDisplayInitialize loads each component of the database and how it derives the location of that component.  ID="ch0329"LBL="" HELPID=""File Search PathsID="ch0330"ID="ch0331"In loading the application class defaults and the user's per-application defaults, XtDisplayInitialize calls XtResolvePathname to determine which files to read.  ID="ch0332"ID="ch0333"XtResolvePathname uses file search paths.  Each path is a set of patterns that may contain special character sequences for which XtResolvePathname substitutes runtime values when it searches for a file.  It uses the following substitutions in building the path: %N is replaced by class name of the application, as specified by the application_class argument to XtAppInitialize, ID="ch0334"XtOpenDisplay, or XtDisplayInitialize.  ID="ch0335"ID="ch0336"%C is replaced by the value of the customization resource.  ID="ch0337"ID="ch0338"%L is replaced by the display's language specification.  This may come from the xnlLanguage resource, the locale of the application, or an application callback procedure.  See ID="ch0339"IDREF="22857" TYPE="TITLE"Chapter 11, "Internationalization,"
 for more information.  The format of the language specification is implementation dependent; it may have language, territory, and codeset components.  %l is replaced by the language part of the language specification.  %t is replaced by the territory part of the language specification.  %c is replaced by the codeset part of the language specification.  %% is replaced by %.  If the language specification is not defined, or if one of its parts is missing, a % element that references it is replaced by NULL.  The paths contain a series of elements separated by colons.  Each element denotes a filename, and the filenames are looked up left-to-right until one of them succeeds.  Before doing the lookup, substitutions are performed.  The Intrinsics use the X/Open convention of collapsing multiple adjoining slashes in a filename into one slash.  LBL="" HELPID=""Initial Database ComponentsID="ch0340"The XtDisplayInitalize function loads the resource database by merging in resources from these sources, in order of precedence (that is, each component takes precedence over the following components): ID="ch0341"The application command line Per-host user environment resource file on the local host Screen-specific resources for the default screen of the display Resource property on the server or user preference resource file on the local host Application-specific user resource file on the local host Application-specific class resource file on the local host  LBL="" HELPID=""Command-Line SpecificationsXtDisplayInitialize calls the X Resource Manager function ID="ch0342"XrmParseCommand to extract resource settings from the command line by which the user invoked the application.  The arguments and number of arguments on the command line come from the ID="ch0343"argv and argc arguments to XtAppInitialize, ID="ch0344"XtOpenDisplay, or XtDisplayInitialize.  Xt maintains a standard set of command-line options, such as ID="ch0345"ID="ch0346"-background and -geometry, for specifying resource settings.  An application can specify additional options in arguments to XtAppInitialize, XtOpenDisplay, or XtDisplayInitialize.  The user can supply the -xrm option to set any resource in the database.  LBL="" HELPID=""Per-Host User ResourcesTo load the per-host user environment resources, XtDisplayInitialize uses the filename specified by the ID="ch0347"XENVIRONMENT environment variable.  If ID="ch0348"XENVIRONMENT is not defined, XtDisplayInitialize looks for the file $HOME/.Xdefaults-host, where host is the name of the host on which the application is running (that is, the name of the client host, not the server host).  ID="ch0349"LBL="" HELPID=""Screen-Specific ResourcesID="ch0350"ID="ch0351"To load screen-specific resources, XtDisplayInitialize looks for a SCREEN_RESOURCES property on the root window of the default screen of the display.  The SCREEN_RESOURCES property typically results from invoking the ID="ch0352"ID="ch0353"xrdb command when some resources are not defined for all screens. † †When Xt needs to fetch resources for a screen other than the default screen of the displayname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for example, when the application creates a widget on another screenname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'it uses the SCREEN_RESOURCES property of that screen instead of the SCREEN_RESOURCES property of the default screen.  ID="ch0354"LBL="" HELPID=""Server or User-Preference ResourcesTo load the server resource property or user preference file, XtDisplayInitialize first looks for a RESOURCE_MANAGER property on the root window of the display's screen 0.  The RESOURCE_MANAGER property typically results from invoking the ID="ch0355"ID="ch0356"xrdb command when some resources are defined for all screens.  If that property does not exist, ID="ch0357"XtDisplayInitialize looks for the file $HOME/.Xdefaults.  ID="ch0358"LBL="" HELPID=""User Application FileID="ch0359"To load the user's application resource file, XtDisplayInitialize† †performs the following steps: ID="ch0360"Use XUSERFILESEARCHPATH to look up the file, performing appropriate substitutions.  ID="ch0361"If that fails, or if XUSERFILESEARCHPATH is not defined, and if ID="ch0362"XAPPLRESDIR is defined, use an implementation-dependent search path containing at least seven entries, in the following order and with the following directory prefixes and substitutions: ID="ch0363"$XAPPLRESDIR with %C, %N, %L or with %C, %N, %l, %t, %c
$XAPPLRESDIR with %C, %N, %l
$XAPPLRESDIR with %C, %N
$XAPPLRESDIR with %N, %L or with %N, %l, %t, %c
$XAPPLRESDIR with %N, %l
$XAPPLRESDIR with %N
$HOME with %Nwhere $XAPPLRESDIR is the value of the XAPPLRESDIR† †environment variable and ID="ch0364"$HOME is the user's home directory.  ID="ch0365"If XAPPLRESDIR is not defined, use an implementation-dependent search path containing at least six entries, in the following order and with the following directory prefixes and substitutions: ID="ch0366"$HOME with %C, %N, %L or with %C, %N, %l, %t, %c
$HOME with %C, %N, %l
$HOME with %C, %N
$HOME with %N, %L or with %N, %l, %t, %c
$HOME with %N, %l
$HOME with %NLBL="" HELPID=""Application Class Resource FileID="ch0367"To load the application-specific class resource file, XtDisplayInitialize performs the appropriate substitutions on the path specified by the ID="ch0368"XFILESEARCHPATH environment variable.  If that fails, or if ID="ch0369"XFILESEARCHPATH is not defined, XtDisplayInitialize uses an implementation-dependent search path containing at least six entries, in the following order and with the following substitutions: %C, %N, %S, %T, %L or %C, %N, %S, %T, %l, %t, %c
%C, %N, %S, %T, %l
%C, %N, %S, %T
%N, %S, %T, %L or %N, %S, %T, %l, %t, %c
%N, %S, %T, %l
%N, %S, %Twhere the substitution for %S is usually NULL and the substitution for %T is usually app-defaults.  If no application-specific class resource file is found, XtDisplayInitialize looks for any fallback resources that may have been defined by a call to ID="ch0370"XtAppInitialize or ID="ch0371"XtAppSetFallbackResources.  ID="ch0372"LBL="3.3" HELPID=""Creating WidgetsID="ch0373"ID="ch0374"The top-level widget returned by XtAppInitialize or ID="ch0375"XtAppCreateShell is the root of a program's widget hierarchy for a given display or logical application.  After initializing the Intrinsics, the application can proceed to create the remainder of the widget hierarchy it needs to start the program.  ID="ch0376"Widget creation is a two-stage process.  In the first stage, the application creates the widget hierarchy but does not assign windows to the widgets.  In the second stage, the application assigns windows and makes them visible.  These stages are separate because, otherwise, window geometry might have to be recomputed each time a child is added.  This computation can require a great deal of communication with the X server and take a long time.  Instead, initial window geometry is computed only once.  For more information, see IDREF="16009" TYPE="TITLE"Section 3.5, "Making Widgets Visible."The general routine for creating a widget is XtCreateWidget.  The required arguments to this routine are the widget's name, class, and parent widget.  You can also provide initial resource values for the widget, as discussed in the next section, ID="ch0377"IDREF="41729" TYPE="TITLE"Section 3.3.1, "Specifying Resource Values."XtVaCreateWidget is a version of XtCreateWidget that uses a variable-length argument list.  ID="ch0378"Motif has a convenience routine for creating a widget of each Motif class.  The name of such a routine is usually XmCreate<widget>, where widget represents the widget class.  For example, the convenience routine for creating a Text widget is ID="ch0379"XmCreateText.  These routines do not require the widget-class argument.  ID="ch0380"Some convenience routines, such as XmCreateMenuBar, create specialized widgets.  These routines usually set some initial resource values to configure the widget for a particular usename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for example, to configure a RowColumn widget for use as a MenuBar.  In some cases, such as ID="ch0381"ID="ch0382"ID="ch0383"XmCreatePulldownMenu and ID="ch0384"ID="ch0385"XmCreateScrolledList, these routines create a widget hierarchy rather than a single widget.  The documentation for each convenience routine in the ID="ch0386"ID="ch0387"OSF/Motif Programmer's Reference explains what the routine does.  Using a Motif creation routine is generally preferable to calling XtCreateWidget.  In addition to creating multiple widgets and setting appropriate resources, these routines sometimes perform optimizations.  For example, some convenience routines add ID="ch0388"XmNdestroyCallback† †procedures to free memory when the widget is destroyed. ID="ch0389"Every widget except a top-level widget must have a parent at the time the widget is created.  An application can use XtDestroyWidget to destroy a widget.  ID="ch0390"LBL="3.3.1" HELPID=""ID="41729"Specifying Resource ValuesID="ch0391"An application can specify values for resources when it creates a widget and anytime thereafter.  It can retrieve resource values after creating a widget.  LBL="" HELPID=""Widget InitializationID="ch0392"ID="ch0393"When an application creates a widget, the creation routine sets the widget's initial resource values from the following sources, in order (that is, each succeeding component takes precedence over preceding components): Default values for resources specified by the widget class and its superclasses Resource values from the initial resource database Resource values specified by the application in its call to the widget creation routine Each widget class can have its own initialize procedure.  After setting the initial resource values, the widget creation routine calls the ID="ch0394"ID="ch0395"initialize procedure for each class in the widget's class hierarchy, in superclass-to-subclass order.  The initialize procedure can set new values for resources, possibly based on other resource values in the widget or its ancestors.  In some cases, an initialize procedure forces a resource to have a particular value, regardless of whether the user or application has specified another value.  In other cases, the initialize procedure might set a resource value only if the user or application has not specified another value.  The documentation for each widget class in the OSF/Motif Programmer's Reference lists the data type and default value for each resource.  For resources whose default values are computed dynamically, the documentation describes how the default values are determined.  LBL="" HELPID=""Arguments that Specify Resource ValuesID="ch0396"To specify initial resource values in a call to a widget creation routine, an application supplies two arguments: a list of elements representing resource settings and an integer specifying the number of elements in the list.  Each element in the list is a structure of type Arg.  This structure has two members: a string representing the name of the resource, and a value specifier representing the resource value.  The value specifier is of type ID="ch0397"XtArgVal.  This is a data type large enough to hold a ID="ch0398"long or one of several types of pointers to other data.  If the resource value is of a type small enough to fit into an XtArgVal, the value specifier contains the resource value itself; otherwise, it contains a pointer to the actual value.  For most resources, an application supplies integer values (including such types as Position and Dimension) directly in the value specifier; otherwise, the application supplies a pointer to the value.  ID="ch0399"ID="ch03100"The most common way to set up a list of resource specifications is to declare a list of Arg elements large enough to hold all the specifications and then to use ID="ch03101"XtSetArg to insert each specification into the list.  An application should always use a sequence of calls to ID="ch03102"XtSetArg in the following way to avoid mistakes in building the list: ...
Widget      text;
Arg         args[10];
Cardinal    n;
n = 0;
XtSetArg(args[n], XmNrows, 10);         n++;
XtSetArg(args[n], XmNcolumns, 80);      n++;
text = XmCreateText("text", parent, args, n);Instead of using lists of Arg structures, the variable-argument routines that specify resource values take a variable number of pairs of resource names and values as arguments.  The resource value in each pair is of type ID="ch03103"XtArgVal, with the same meaning as the value in an ID="ch03104"Arg structure.  The application can provide two special strings in place of a resource name.  If the name is XtVaNestedList, the next argument is interpreted as a nested list of name-value pairs.  If the name is ID="ch03105"XtVaTypedArg, the next four arguments supply the resource value and cause it to be converted from one data type to another, as described in the following sections.  ID="ch03106"LBL="" HELPID=""Setting Resource ValuesTo specify resource values after a widget has been created, an application uses XtSetValues or XtVaSetValues.  ID="ch03107"ID="ch03108"XtSetValues takes a list of resource specifications in the same format as that used when creating a widget: ...
Arg         args[10];
Cardinal    n;
n = 0;
XtSetArg(args[n], XmNrows, 10);         n++;
XtSetArg(args[n], XmNcolumns, 80);      n++;
XtSetValues(text, args, n);Each widget class can have its own set_values procedure.  After setting the values specified in the argument list, ID="ch03109"ID="ch03110"XtSetValues calls the set_values procedure for each class in the widget's class hierarchy, in superclass-to-subclass order.  The ID="ch03111"set_values procedure can set new values for resources other than those specified in the arguments to XtSetValues.  This usually happens when the value of one resource depends on the value of another.  Setting a new value for a resource that affects the widget's geometry can also cause Motif to recompute the widget's layout.  In some cases a set_values procedure forces a resource to have a particular value, regardless of whether the application has specified another value.  LBL="" HELPID=""Retrieving Resource ValuesID="ch03112"To retrieve resource values, an application uses XtGetValues or ID="ch03113"XtVaGetValues.  The arguments are the same as those for ID="ch03114"XtSetValues, except that in place of a value for each resource is an address in which Motif stores the requested value: ID="ch03115"...
Arg         args[10];
Cardinal    n;
short       nrows, ncolumns;
n = 0;
XtSetArg(args[n], XmNrows, &nrows);            n++;
XtSetArg(args[n], XmNcolumns, &ncolumns);      n++;
XtGetValues(text, args, n);LBL="" HELPID=""Resource Value Data TypesID="ch03116"ID="ch03117"The documentation for each widget class in the OSF/Motif Programmer's Reference lists the data types to use when setting and retrieving values for resources.  The user and application do not always have to supply data of the type documented.  Motif has routines, called converters, that convert resource values from one data type to another.  For example, when a value for the resource database comes from a file or the command line, Motif processes the value as a string.  Motif and Xt have routines to convert strings to most common resource types, including Boolean, Dimension, Position, ID="ch03118"ID="ch03119"ID="ch03120"Pixel, and XmFontList.  ID="ch03121"ID="ch03122"When using the standard widget creation routines, XtSetValues, and ID="ch03123"XtGetValues, an application must supply resource values or addresses of the types the widget expects.  But when using the variable-argument versions of these routines, the application can supply values of any types for which routines exist to convert data of those types into values of the expected types.  To provide for a resource conversion, the application supplies ID="ch03124"XtVaTypedArg in place of a resource name in the argument list.  In place of the resource value, the application supplies four arguments: ID="ch03125"The resource name A string representing the type of the value supplied The value itself (of type XtArgVal) ID="ch03126"An integer representing the number of bytes in the value For example, the following call converts the string supplied into the compound string that Motif expects for a PushButton label: ID="ch03127"...
char *label = "Button";
XtVaSetValues(button, XtVaTypedArg, XmNlabelString,
† †   XmRString, label, strlen(label) + 1, NULL);LBL="" HELPID=""Resource Values and Memory ManagementID="ch03128"ID="ch03129"The application is responsible for allocating and freeing memory needed for resource values it supplies when initializing a widget or setting new values.  For most resources whose values are not immediate data, including strings, compound strings, and font lists, Motif makes copies of values the application supplies when it creates a widget or calls XtSetValues.  The application can free the allocated memory anytime after the widget creation routine executes or ID="ch03130"XtSetValues returns: ...
char     *label = "Button";
XmString  label_cs;
label_cs = XmStringCreateSimple(label);
XtVaSetValues(button, XmNlabelString, label_cs, NULL);
XmStringFree(label_cs);For resources whose values are not immediate data, XtGetValues† †sometimes makes a copy of values and sometimes does not.  For example, Motif always makes copies of compound strings retrieved by ID="ch03131"XtGetValues, but it does not make copies of lists of compound strings (data of type XmStringTable).  Motif usually copies simple strings retrieved by ID="ch03132"XtGetValues.  An application should free compound strings retrieved by XtGetValues, but in general it should not free values of other types unless the documentation for the particular resource in the OSF/Motif Programmer's Reference says the application must free that value.  The standard routines an application should use to allocate memory are XtMalloc and XtNew.  The standard routine to free memory is ID="ch03133"ID="ch03134"XtFree.  Some Motif data types have memory-management routines that an application should use instead of the more general Xt routines.  For example, use ID="ch03135"XmStringFree to free memory for a compound string, and use ID="ch03136"XmFontListFree to free memory for a font list.  ID="ch03137"LBL="3.4" HELPID=""Adding Callback ProceduresID="ch03138"Callback routines are the heart of a Motif application.  Many widget classes have resources whose values are lists of callback procedures.  When the user acts on a widgetname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for example, pressing a PushButtonname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Motif invokes the callback routines in the corresponding callback list.  If an application needs to take some action when the user presses a PushButton, it supplies a callback routine and adds that routine to the appropriate callback list.  ID="ch03139"ID="ch03140"Callbacks are not the only means Motif uses to notify an application of a user action.  An application can also supply its own action routines and event handlers.  The main difference between these kinds of procedures is the level of abstraction at which Motif or Xt invokes the procedures: The Xt event dispatcher calls an event handler whenever an event of a particular type occurs in a specified widget.  The Xt translation manager calls an action routine when an event sequence matches an event specification in a widget translation table.  In a translation table, actions are associated with event specifications.  More than one event sequence can invoke the same action routine.  A Motif widget invokes callback procedures when user input signifies an action that is meaningful to the widget, such as activating a PushButton.  Widgets often invoke callbacks from action routines.  More than one action can invoke the same callback list.  ID="ch03141"Most applications use only callback procedures.  Action routines and event handlers are discussed in IDREF="11820" TYPE="TITLE"Chapter 13, "Input, Focus, and Keyboard Navigation."Each callback procedure is a function of type XtCallbackProc.  The procedure takes three arguments: a widget and two pointers to data.  The first pointer is to data that the application has told the widget to pass back to the application when the callback procedure is invoked.  The second pointer is to data that the widget passes to all callbacks on the callback list.  A callback procedure returns no value.  ID="ch03142"ID="ch03143"The application data argument is primarily for passing data that the application maintains separately from the widget itself.  The widget data argument for most Motif widgets is a pointer to a structure containing information that varies by widget class.  For example, when the user changes the value of a ToggleButton, Motif invokes callback procedures with a pointer to an ID="ch03144"XmToggleButtonCallbackStruct structure as the third argument.  This structure has three members: ID="ch03145"An integer indicating the reason for invoking the callback.  When the user changes the value, the reason is XmCR_VALUE_CHANGED.  Usually the reason is identified by a symbol beginning with the characters ID="ch03146"XmCR.  A pointer to the XEvent that triggered the callback.  ID="ch03147"An integer that indicates the new state of the ToggleButton, either selected or unselected.  ID="ch03148"The documentation for each widget class in the OSF/Motif Programmer's Reference describes any callback structures that the widget passes to callback procedures as widget data.  Note that a callback procedure can change the values of some members of these structures.  Because the order of procedures in a callback list is unspecified, an application that uses multiple callback procedures in the same list must use caution in changing these values.  Following is a simple callback procedure that an application might use to set the state of a valve when the user changes the value of a ToggleButton.  The application data passed in the callback in this example might be a pointer to a valve object associated with the ToggleButton: ID="ch03149"ID="ch03150"void ToggleValueChangedCB(Widget toggle, XtPointer app_data,
† †   XtPointer widget_data)
{
† †   Valve *valve_p = (Valve *) app_data;
† †   XmToggleButtonCallbackStruct *toggle_info =
† †       (XmToggleButtonCallbackStruct *) widget_data;
† †   ChangeValveState(*valve_p,
† †       ((Boolean) toggle_info->set == TRUE) ?
† †                              VALVE_ON : VALVE_OFF);
}To register a callback procedure with a widget, an application uses XtAddCallback or XtAddCallbacks after declaring the callback procedure and creating the widget.  The following code fragment creates a ToggleButton for each valve in a global list of valves: ID="ch03151"ID="ch03152"ID="ch03153"...
† †   char      name[20];
† †   Widget    toggles[N_VALVES];
† †   int       i;
† †   Valve    *valve_p;
† †   for(i = 0, valve_p = valves; i < N_VALVES;
† †                                       i++, valve_p++) {
† †       sprintf(name, "valve_state_%d", i);
† †       toggles[i] = XmCreateToggleButton(parent, name, 
† †           (ArgList) NULL, 0);
† †       XtAddCallback(toggles[i], XmNvalueChangedCallback,
† †           (XtCallbackProc) ToggleValueChangedCB,
† †           (XtPointer) valve_p);
† †   }To remove a callback procedure from a callback list, use XtRemoveCallback or XtRemoveCallbacks.  Because Motif sometimes adds its own callbacks to callback lists, do not use ID="ch03154"ID="ch03155"XtRemoveAllCallbacks to remove all callbacks from a list.  ID="ch03156"LBL="3.5" HELPID=""ID="16009"Making Widgets VisibleCreating a widget does not by itself make the widget visible.  Widgets become visible when the following conditions exist: The widget and its ancestors are managed.  A widget is managed when the Xt and Motif geometry managers take account of the widget when computing the positions and sizes of widgets they display.  ID="ch03157"ID="ch03158"The widget and its ancestors are realized.  A widget is realized when it has an associated window.  ID="ch03159"ID="ch03160"The widget and its ancestors are mapped.  A widget is mapped when its window is displayed.  ID="ch03161"ID="ch03162"An application can manage, realize, and map widgets in separate steps, but each of these actions affects the others.  LBL="3.5.1" HELPID=""Managing WidgetsID="ch03163"ID="ch03164"Parent widgets are responsible for managing the geometry of their children.  A child can ask the parent to be given some size or position, but the parent decides whether or not to grant the request.  A parent can move or resize a child without the child's permission.  The process by which parent and child widgets interact to determine widget geometry is described in IDREF="18723" TYPE="TITLE"Chapter 10, "Managing Geometry."An application tells a widget to manage a child widget's geometry by calling XtManageChild or XtManageChildren.  If the parent is realized, ID="ch03165"ID="ch03166"XtManageChild calls the parent class's change_managed procedure.  This procedure can change the size or position of any of the parent's children.  After calling the parent's ID="ch03167"ID="ch03168"change_managed procedure, XtManageChild realizes the child and, if the child's ID="ch03169"XmNmappedWhenManaged resource is True, maps it.  ID="ch03170"If the parent is not realized, XtManageChild marks the child as managed.  Xt defers calling the parent's ID="ch03171"change_managed procedure until the parent is realized.  ID="ch03172"ID="ch03173"When managing more than one child of a realized parent, it is more efficient for an application to call XtManageChildren than to call ID="ch03174"XtManageChild separately for each child being managed.  Widget layout can be computationally expensive, and ID="ch03175"XtManageChild invokes the parent's change_managed procedure each time it is called.  ID="ch03176"ID="ch03177"XtManageChildren calls the parent's change_managed procedure only once for all children being managed.  An application tells a widget not to manage a child widget's geometry by calling XtUnmanageChild or XtUnmanageChildren.  By managing and unmanaging widgets, an application can alternately display more than one set of children without having to create and destroy widgets each time the configuration of the application changes.  In addition, managing a Motif dialog or PopupMenu causes the widget to pop up, and unmanaging it causes the widget to pop down.  ID="ch03178"ID="ch03179"ID="ch03180"To create a widget and then manage it in the same call, an application can use XtCreateManagedWidget or XtVaCreateManagedWidget.  The Motif routines that create widgets of particular classes return unmanaged widgets.  When using these routines, the application must manage the widgets using ID="ch03181"ID="ch03182"XtUnmanageChild or XtUnmanageChildren.  ID="ch03183"ID="ch03184"LBL="3.5.2" HELPID=""Realizing WidgetsID="ch03185"ID="ch03186"An application uses XtRealizeWidget to realize a widget.  This routine does the following: ID="ch03187"In post-order, traverses the tree whose root is the widget and calls the class change_managed procedure for any widget in the tree that has managed children.  ID="ch03188"ID="ch03189"Recursively traverses the tree whose root is the widget and calls the class realize procedure for any widget in the tree that is managed.  The ID="ch03190"ID="ch03191"realize procedure creates the widget's window.  Maps the widget's managed children whose XmNmappedWhenManaged† †resource is True.  If the widget is a top-level widget whose ID="ch03192"XmNmappedWhenManaged resource is True, XtRealizeWidget maps the widget.  ID="ch03193"Note these implications: Geometry negotiation proceeds from the bottom up; then window creation proceeds from the top down.  After a widget is realized, all its managed descendants are realized and, by default, mapped.  If no widget in the tree is realized, all geometry negotiation between parents and their managed children takes place before any widget is realized.  When making a widget tree visible for the first time, an application should usually manage all children before realizing any widgets, then realize only the top-level widget.  This causes all initial sizing and positioning of children to take place and the overall size of the top-level window to be determined before any windows exist, minimizing interaction with the X server.  It also allows the application to realize all widgets with a single call to XtRealizeWidget.  ID="ch03194"LBL="3.5.3" HELPID=""Mapping WidgetsID="ch03195"ID="ch03196"Most applications do not explicitly map or unmap widgets' windows.  Mapping usually takes place as part of the process of managing or realizing widgets.  But it is possible to keep Xt from mapping windows at these times by setting a widget's XmNmappedWhenManaged to False.  In this case, the application must explicitly use ID="ch03197"XtMapWidget to map the widget.  An application can use ID="ch03198"XtUnmapWidget to unmap a widget.  ID="ch03199"The effect of making a widget managed but unmapped is different from the effect of making a widget unmanaged.  When a widget is unmanaged, its parent takes no account of it in laying out its children.  When a widget is managed, its parent is likely to leave room for it in the widget layout.  When the parent is mapped, the space allocated for a managed but unmapped child is filled with the parent's background rather than the child's window.  LBL="3.5.4" HELPID=""Multiple Screens, Displays, and ApplicationsID="ch03200"ID="ch03201"ID="ch03202"ID="ch03203"ID="ch03204"ID="ch03205"An application can run on more than one display.  In this case, it must use XOpenDisplay to open a connection to each display and must then call ID="ch03206"XtDisplayInitialize separately for each display connection.  It need not create a separate application context for each display.  ID="ch03207"XtDisplayInitialize modifies its argv and argc† †arguments.  If an application needs to call ID="ch03208"XtDisplayInitialize more than once, it must save these arguments before the first call and use a copy of the saved arguments on each call.  XtDisplayInitialize modifies its argv and argc arguments.  If an application needs to call XtDisplayInitialize more than once, it must save these arguments before the first call and use a copy of the saved arguments on each call.The application should use XtAppCreateShell to create at least one top-level widget for each display on which it runs.  Because Xt maintains a separate resource database for each display, a child widget running on a different display from that of its parent would use incorrect initial resource settings.  ID="ch03209"An application can also run on more than one screen within a display.  Such an application opens and initializes the display only once, no matter how many screens it uses within the display.  However, the application also needs a widget on each screen, whose window is a child of the root window for that screen, to serve as the root of the widget hierarchy for the screen.  One approach to using multiple screens is to create a single, unrealized ApplicationShell for the display.  The application then creates one TopLevelShell for each screen as a ID="ch03210"ID="ch03211"popup child of the ApplicationShell.  Although a shell normally has only one managed child, it can have more than one popup child.  The application uses ID="ch03212"XtAppCreateShell to create the ApplicationShell and ID="ch03213"XtCreatePopupShell to create each TopLevelShell.  If no screen is specified for the ApplicationShell, ID="ch03214"ID="ch03215"XtAppCreateShell sets the XmNscreen resource for this widget to the default screen of the display.  In the argument list passed to ID="ch03216"XtCreatePopupShell, the application must specify the proper value for XmNscreen for each TopLevelShell so that the shell is created on the intended screen.  The application does not manage the TopLevelShells.  To realize and map the TopLevelShells, the program uses ID="ch03217"XtPopup† †with a ID="ch03218"grab_kind argument of XtGrabNone.  ID="ch03219"int main(int argc, char **argv)
{
† †   Widget         app_shell, top_shell;
† †   XtAppContext   app;
† †   Display        *display;
† †   char           name[20];
† †   Arg            args[5];
† †   Cardinal       n;
† †   int            i;
† †   app_shell = XtAppInitialize(&app, "Example",
† †       (XrmOptionDescList) NULL, 0, &argc, argv,
† †       (String *) NULL, (ArgList) NULL, 0);
† †   display = XtDisplay(app_shell);
† †   for (i = 0; i < ScreenCount(display); i++) {
† †       sprintf(name, "top_shell_%d", i);
† †       n = 0;
† †       XtSetArg(args[n], XmNscreen,
† †           ScreenOfDisplay(display, i));    n++;
† †       top_shell = XtCreatePopupShell(name,
† †                       topLevelShellWidgetClass, app_shell,
† †                       args, n);
† †       /* Create and manage descendants of top shell */
† †       ...
† †       /* Realize and map the top shell */
† †       XtPopup(top_shell, XtGrabNone);
† †   }
† †   ...
}It is possible for a program to have multiple logical applications on the same display.  In this case, it can use XtAppCreateShell to create a separate top-level widget for each logical application.  ID="ch03220"LBL="3.6" HELPID=""Entering the Event LoopID="ch03221"The last step in a Motif application is to enter the event loop.  Most applications simply call XtAppMainLoop.  This routine waits for user input and dispatches the resulting events to the appropriate event-handling procedures, usually in the widget in which the input occurs.  ID="ch03222"XtAppMainLoop is an infinite loop; it never returns.  An application should provide for a user action to terminate the program and should exit as a result of that action, usually in a callback routine.  LBL="4"ID="19352"Structure of a Program Using UIL and MRMThe User Interface Language (UIL) allows an application developer to separate the specification of particular widget hierarchies from the application source code.  The application defines widgets and their characteristics in a text file, which the developer compiles into a User Interface Definition (UID) file in binary format.  At run time the application, using Motif Resource Manager (MRM) routines, retrieves the widget descriptions from the binary file, and MRM creates the widgets from these descriptions.  The application defines callback procedures and interacts with the widgets as if it were using the Motif toolkit alone.  ID="ch041"ID="ch042"ID="ch043"ID="ch044"ID="ch045"ID="ch046"UIL offers several advantages over toolkit-only applications: UIL enforces the separation of the user interface specification from the application.  A developer can change the interface by editing and recompiling a text file without recompiling and relinking the application program.  The UIL compiler generates warnings for errors that the developer otherwise would not discover until running the program, if then.  For example, the UIL compiler checks the spelling of resource names.  The toolkit may handle large databases more efficiently when they are represented as UID files rather than resource files.  An application that uses UIL has two separate components: the UIL file and the application program.  The UIL file consists mainly of definitions of the application's widget hierarchy.  The declaration for each widget typically includes the following components: Widget type Widget children Initial resource values Declarations for callback procedures The UIL file can also define values for data such as compound strings, colors, and icons.  The structure of the application program is similar to that of a toolkit-only program.  The chief difference is that instead of explicitly creating each widget, the program uses MRM routines to retrieve widget definitions from the UID file and to create the widgets themselves.  The program might also use MRM routines to retrieve data values defined in the UIL file.  An application program using UIL must take the following actions: Include the required header files Initialize the Intrinsics Initialize MRM Open the UID file Register the names of callback procedures and values of identifiers specified in the UID file Retrieve and create widgets and data defined in the UID file Close the UID file Define callback procedures Make the widgets visible Enter the event loop LBL="4.1" HELPID=""Structure of a UIL ModuleID="ch047"ID="ch048"A UIL module is a block of declarations and definitions for the values, procedures, literals, and objects that make up a user interface specification.  Each UIL file contains either one complete module or, if the file is to be included in another UIL file, at least one complete top-level construct within a module.  Each module has the following structure: module clause ID="ch049"ID="ch0410"Zero or more declarations for the module as a whole Zero or more include directives ID="ch0411"ID="ch0412"Zero or more value declarations ID="ch0413"ID="ch0414"Zero or more identifier declarations ID="ch0415"ID="ch0416"Zero or more procedure declarations ID="ch0417"ID="ch0418"Zero or more object declarations ID="ch0419"ID="ch0420"Zero or more list declarations ID="ch0421"ID="ch0422"end module clause ID="ch0423"ID="ch0424"This section discusses the components of a UIL module, but it does not describe the UIL syntax in detail.  For more information, see the UIL(5X) reference page in the OSF/Motif Programmer's Reference.  LBL="4.1.1" HELPID=""module ClauseEach module begins with the declaration module† †name.  The keyword ID="ch0425"ID="ch0426"module must be in lowercase.  LBL="4.1.2" HELPID=""Module-Level DeclarationsSeveral optional declarations at the beginning of the module modify characteristics of the module as a whole: namesThe ID="ch0427"ID="ch0428"names declaration specifieso whether names in the UIL file are stored in a case-sensitive or case-insensitive way.  The following declaration, the default, means that names are stored as they appear in the UIL file, and all UIL keywords must be in lowercase: names = case_sensitiveThe following declaration means that all names are stored in uppercase, and UIL keywords can be in uppercase, lowercase, or mixed case: names = case_insensitiveThe entire names declaration itself must be in lowercase, and it affects only the part of the module that follows it.  ID="ch0429"ID="ch0430"character_setThe ID="ch0431"ID="ch0432"character_set clause declares the default character set for strings and compound strings specified in the module by double quotes ("string").  If this clause is not present, UIL derives the default character set from the language environment in which the UIL file is compiled.  This does not affect the character set of strings specified in the module by single quotes ('string').  UIL derives the character set of these strings from the language environment in which the UIL file is compiled.  The character set in this clause must be either a keyword representing one of the character sets UIL knows about or a character set returned by the character_set function.  objectsThe ID="ch0433"ID="ch0434"objects clause specifies whether UIL should define objects of the specified types as widgets or gadgets.  For example, this declaration specifies that UIL should define objects of type XmPushButton to be gadgets: objects = { XmPushButton = gadget; }A declaration for an individual object can override this specification.  LBL="4.1.3" HELPID=""include DirectiveThe include directive includes the contents of a file in the current module.  The directive consists of the keywords ID="ch0435"ID="ch0436"include file followed by a string representing the filename.  If the filename has a full directory specification, UIL searches that directory for the file.  Otherwise, UIL searches the directory of the main UIL source file and then the directory of the current UIL source file.  The -I option to the uil command adds a directory to the search list.  ID="ch0437"Included files are useful for definitions common to more than one UIL module.  In conjunction with the -I option to uil, they are also useful in internationalizing applications.  Localized definitions for strings, font lists, and the like can reside in files included from different directories depending on language environment.  In this case, the ID="ch0438"include directives should not specify the directories; instead, you can use the ID="ch0439"ID="ch0440"-I option to uil to compile files for different language environments without editing or duplicating UIL files.  LBL="4.1.4" HELPID=""value DeclarationThe value clause defines one or more names and associates them with values.  The names can stand for values elsewhere in the module.  ID="ch0441"ID="ch0442"The specification for each value is either a literal expression or a call to a UIL function that generates a value.  Each value has a UIL type that depends on the representation of the literal or the type of value returned by the UIL function.  For more information on UIL types, literals, and functions, see the UIL(5X) reference page in the OSF/Motif Programmer's Reference.  By default, the names and their associated values are private to the module.  The value declaration can also export a value to other modules or import a value from another module.  For each name declared to be imported, MRM assigns the value from the corresponding exported declaration at run time.  ID="ch0443"ID="ch0444"In this example, the value id_1 is exported: value
† †   id_1          : exported 1;
† †   label_1       : compound_string('Off');Another module can use the value id_1 as follows: value
† †   id_1          : imported integer;LBL="4.1.5" HELPID=""identifier DeclarationAn identifier clause declares one or more names that can appear elsewhere in the module.  At run time, MRM assigns values to these names from data defined in the application program.  The application uses the ID="ch0445"ID="ch0446"MrmRegisterNames or ID="ch0447"MrmRegisterNamesInHierarchy routine to establish the correspondence between UIL identifier names and application-defined data.  The UIL compiler performs no type checking on identifiers.  ID="ch0448"The following example identifies names for x and y values that the application defines at run time: identifier
† †   app_x_value;
† †   app_y_value;LBL="4.1.6" HELPID=""procedure DeclarationA procedure clause declares names of callback procedures or of creation routines for user-defined widgets.  The application program itself defines the actual procedures.  As with identifiers, the application must use ID="ch0449"ID="ch0450"MrmRegisterNames or ID="ch0451"MrmRegisterNamesInHierarchy to associate the procedure names with the actual procedures at run time.  ID="ch0452"For a callback procedure, the procedure declaration can also specify the type of data represented by the second argument (the application data pointer) to the callback routine: ID="ch0453"ID="ch0454"procedure
† †   toggle_cb (integer);
† †   push_button_cb (integer);LBL="4.1.7" HELPID=""object DeclarationAn object clause defines a widget or gadget and assigns a name that can stand for the object elsewhere in the UIL module.  As with values, an object definition by default is private to the UIL module, but the ID="ch0455"ID="ch0456"object clause can declare it to be exported or imported.  In addition to the UIL name, the ID="ch0457"ID="ch0458"object clause specifies the object's type and a list (enclosed in braces) that can define children, initial resource values, and callback procedures.  LBL="" HELPID=""Object TypeID="ch0459"ID="ch0460"The object type specification is a keyword that is usually the same as the name of the corresponding toolkit widget class.  For example, the type keyword for a MainWindow is XmMainWindow and for a PushButton is XmPushButton.  UIL also allows type specifications that correspond to toolkit convenience routines for creating some kinds of specialized widgets, including menus, dialogs, ScrolledList, and ScrolledText.  For example, the keyword ID="ch0461"ID="ch0462"XmPulldownMenu specifies a PulldownMenu, and the keyword XmPromptDialog specifies a PromptDialog.  The object clause can also specify that the object is to be either a widget or a gadget, overriding the default specified by the ID="ch0463"ID="ch0464"objects clause.  For example, the following defines a PushButtonGadget: ID="ch0465"ID="ch0466"ID="ch0467"object
† †   pb : XmPushButton gadget {};Alternately, an object clause can specify a gadget by using the gadget class name (for example, ID="ch0468"ID="ch0469"XmPushButtonGadget) as the type specification.  LBL="" HELPID=""ChildrenAn object clause can specify the children of a composite widget.  This specification appears inside the object list section and consists of the keyword ID="ch0470"ID="ch0471"controls followed by a list of child declarations.  The declaration for each child consists of an object type and, usually, a name that refers to the definition for the child widget in its own ID="ch0472"ID="ch0473"object clause.  Instead of a name for the child, the declaration can contain an entire local definition for the child widget in the form of an object list section.  The child declaration can optionally begin with the keyword ID="ch0474"ID="ch0475"managed or unmanaged, which specifies whether or not MRM should manage the child after creating it.  The default is to manage the child.  ID="ch0476"ID="ch0477"ID="ch0478"ID="ch0479"Some manager widgets automatically create children.  For example, MainWindow creates three separators to separate its main components.  The ID="ch0480"controls list can contain declarations for these children so that the UIL file can specify resource values for them.  The declaration for an automatically created child begins with a specification of the name of the child, formed by prepending ID="ch0481"ID="ch0482"Xm_ to the actual name of the child widget.  The names of automatically created children are documented in the reference pages for the manager widgets in the OSF/Motif Programmer's Reference.  Following is an example of specifications for child widgets: object
† †   main_win : XmMainWindow {
† †       controls {
† †           XmMenuBar main_menu;
† †           Xm_Separator1 sep_1;
† †           XmScrolledText text_win;
† †       };
† †   };In general, a child widget can be of any type the Motif toolkit allows for a child of the parent widget.  In some cases, the type of the child differs from the Motif toolkit class.  For example, dialogs and menus require shells as their parents, but in UIL a dialog or menu is declared to be a direct child of its parent, with no intervening shell.  MRM creates the shell at run time.  In this way, UIL and MRM act like the Motif convenience routines for creating dialogs and menus.  Some widget hierarchies in UIL are slightly different from the corresponding hierarchies in the toolkit.  For example, in UIL a PulldownMenu in an OptionMenu is described as a child of the OptionMenu, not of the OptionMenu's parent as it is in the toolkit.  In a PulldownMenu system from a MenuBar or a PopupMenu, each PulldownMenu is a child of the associated CascadeButton, not of the CascadeButton's parent as it is in the toolkit.  For more information, see ID="ch0483"ID="ch0484"ID="ch0485"ID="ch0486"ID="ch0487"ID="ch0488"IDREF="11089" TYPE="TITLE"Chapter 6, "Menus and Options."LBL="" HELPID=""Resource ValuesID="ch0489"An object clause can specify resource values for MRM to pass to the widget's creation function.  This specification appears inside the object list section and consists of the keyword ID="ch0490"ID="ch0491"arguments followed by a list of resource declarations.  The declaration for each resource consists of the name of the resource as in the toolkit (for example, ID="ch0492"ID="ch0493"XmNheight) followed by = (equals sign) and a value for the resource.  The type of the value must be of the proper UIL type for that resource.  For information on the required UIL type for each resource, see Appendix C of the OSF/Motif Programmer's Reference.  Following is an example of specifications for initial resource values: object
† †   main_win : XmScrolledText {
† †       arguments {
† †           XmNrows = 10;
† †           XmNwordWrap = true;
† †           XmNbackground = color('red');
† †       };
† †   };In some cases, UIL provides a value for a resource related to a resource that appears in a specification.  For example, if a specification contains a value for XmNitems in a List, UIL provides the appropriate value for XmNitemCount.  LBL="" HELPID=""Callback ProceduresID="ch0494"An object clause can specify procedures to appear in callback lists for the object.  This specification appears inside the object list section and consists of the keyword ID="ch0495"ID="ch0496"callbacks followed by a list of callback list declarations.  The declaration for each callback list consists of the name of the callback resource as in the toolkit (for example, ID="ch0497"ID="ch0498"XmNactivateCallback) followed by = (equals sign) and a value specification for the resource.  In addition to appropriate toolkit resources, the specification can include the special callback list name MrmNcreateCallback.  MRM invokes callback procedures on this list when it creates the widget.  These procedures provide a means for the application to identify the widget ID of a widget created by MRM.  ID="ch0499"The value specification can be one of two forms: If the callback list contains only one procedure, the specification consists of the keyword procedure followed by the procedure name and, optionally, a value in parentheses for the application data argument to the procedure.  ID="ch04100"ID="ch04101"If the callback list contains more than one procedure, the specification consists of the keyword procedures followed by a list of procedure specifications.  Each specification consists of the procedure name and, optionally, a value in parentheses for the application data argument to the procedure.  ID="ch04102"ID="ch04103"The UIL compiler issues a warning if a procedure specification contains an application data argument whose type does not match the argument type in the corresponding procedure declaration.  ID="ch04104"ID="ch04105"The application uses the MrmRegisterNames routine or the ID="ch04106"MrmRegisterNamesInHierarchy routine to establish the correspondence between UIL procedure names and the application-defined procedures.  ID="ch04107"Following is an example of specifications for a callback list: object
† †   pb : XmPushButton {
† †       callbacks {
† †           XmNactivateCallback =
† †               procedure pb_activate_cb (pb_ident);
† †       };
† †   };LBL="4.1.8" HELPID=""list DeclarationA list clause defines one or more lists of specifications for resources, callbacks, procedures, or widget children.  Each list has a symbolic name that the application can use to refer to the list elsewhere in the UIL file, usually in an ID="ch04108"ID="ch04109"object† †declaration.  The main use for this clause is to define lists of specifications that are common to more than one object definition.  ID="ch04110"ID="ch04111"A list clause consists of the keyword list followed by one or more list specifications.  Each list specification contains the name, type, and contents of the list.  Following are the four kinds of lists: ID="ch04112"ID="ch04113"A list of resources consists of the keyword arguments followed by a list of resource specifications.  ID="ch04114"ID="ch04115"A list of callbacks consists of the keyword callbacks followed by a list of callback specifications.  ID="ch04116"ID="ch04117"A list of procedures consists of the keyword procedures followed by a list of procedure specifications.  ID="ch04118"ID="ch04119"A list of widget children consists of the keyword controls† †followed by a list of specifications for the children.  ID="ch04120"ID="ch04121"In each case, the form of the list is the same as that of the corresponding clause of an object declaration.  ID="ch04122"ID="ch04123"Following is an example of a list declaration: ID="ch04124"ID="ch04125"list
† †   pb_activate_procs : procedures {
† †       pb_ac_proc_1 ();
† †       pb_ac_proc_2 ();
† †   };
list
† †   pb_callbacks : callbacks {
† †       XmNactivateCallback = pb_activate_procs;
† †       XmNarmCallback = procedure pb_arm_proc ();
† †   };
list
† †   pb_args : arguments {
† †       XmNheight = 10;
† †       XmNbackground = color('red');
† †   };
object
† †   pb_1 : XmPushButton {
† †       arguments {
† †           arguments pb_args;
† †           XmNlabelString = pb_label_1;
† †       };
† †       callbacks pb_callbacks;
† †    };
object
† †   pb_2 : XmPushButton {
† †       arguments {
† †           arguments pb_args;
† †           XmNlabelString = pb_label_2;
† †       };
† †       callbacks pb_callbacks;
† †    };
list
† †   menu_items : controls {
† †       XmPushButton pb_1;
† †       XmPushButton pb_2;
† †   };
object
† †   menu_1 : XmPulldownMenu {
† †       controls menu_items;
† †   };LBL="4.1.9" HELPID=""end module ClauseEach UIL module must end with an end module clause.  ID="ch04126"ID="ch04127"LBL="4.2" HELPID=""Structure of a Program Using MRMLBL="4.2.1" HELPID=""Including Header FilesID="ch04128"ID="ch04129"An application that uses MRM must include all the header files it would need if it did not use MRM.  These include <Xm/Xm.h>, header files specific to each widget the program uses, and any header files needed by Motif routines.  In addition, the application must include the file <Mrm/MrmPublic.h>.  This file contains definitions that the MRM routines need.  Following is an example of including header files for an application that uses only a Text widget and MRM: ID="ch04130"#include <Mrm/MrmPublic.h>
#include <Xm/Xm.h>
#include <Xm/Text.h>LBL="4.2.2" HELPID=""Initializing the IntrinsicsID="ch04131"ID="ch04132"ID="ch04133"ID="ch04134"An application initializes the Intrinsics as in any other program, usually by calling XtAppInitialize.  The application must call ID="ch04135"XtDisplayInitialize either directly or indirectly before opening any UID files.  ID="ch04136"LBL="4.2.3" HELPID=""Initializing MRMID="ch04137"ID="ch04138"ID="ch04139"An application that uses MRM must initialize MRM by calling MrmInitialize before fetching any widgets from UID files.  It is a good idea to call ID="ch04140"MrmInitialize before using any other MRM routines.  ID="ch04141"LBL="4.2.4" HELPID=""Opening UID FilesID="ch04142"ID="ch04143"After initializing MRM and the Intrinsics, an application uses MrmOpenHierarchyPerDisplay to find and open one or more UID files that contain the widget definitions and other information to be loaded.  ID="ch04144"MrmOpenHierarchyPerDisplay uses search paths in much the same way ID="ch04145"XtDisplayInitialize uses them to build the initial resource database.  One argument to ID="ch04146"MrmOpenHierarchyPerDisplay is a list of UID filenames, each of which represents either a full pathname or a name to be substituted in a file search path.  The search path comes from the ID="ch04147"UIDPATH environment variable or, if ID="ch04148"UIDPATH is not set, from a series of default paths.  MrmOpenHierarchyPerDisplay calls XtResolvePathname to search these paths.  When it uses a search path, ID="ch04149"ID="ch04150"MrmOpenHierarchyPerDisplay looks for files first using a suffix of .uid and then using a NULL suffix.  As with the initial resource database, UID files can reside in different directories depending on the language environment.  The search paths can include these substitutions, as well as others recognized by XtResolvePathname: ID="ch04151"%N is replaced by the class name of the application.  %L is replaced by the display's language specification.  %l is replaced by the language part of the language specification.  %U is replaced by the current filename from the list of filenames passed as an argument to MrmOpenHierarchyPerDisplay.  ID="ch04152"MrmOpenHierarchyPerDisplay returns an ID that identifies the list of open UID files for subsequent calls to routines that load data from the files.  On each request to load data, MRM searches the list of files in order.  This ordered list of open files is the UID hierarchy.  The program can retrieve data from the hierarchy until it calls ID="ch04153"MrmCloseHierarchy.  ID="ch04154"Following is an example of a call to MrmOpenHierarchyPerDisplay.  The example initializes MRM and the Intrinsics, opens a UID hierarchy, and closes the hierarchy.  ID="ch04155"int main(int argc, char **argv)
{
† †   Widget         app_shell;
† †   XtAppContext   app;
† †   static String  file_names[] = { "app_1", "app_2" };
† †   MrmHierarchy   hierarchy_id;
† †   app_shell = XtAppInitialize(&app, "Example",
† †       (XrmOptionDescList) NULL, 0, (Cardinal *) &argc, argv,
† †       (String *) NULL, (ArgList) NULL, 0);
† †   MrmInitialize();
† †   switch (MrmOpenHierarchyPerDisplay(XtDisplay(app_shell),
† †            (MrmCount) XtNumber(file_names), file_names,
† †            (MrmOsOpenParamPtr *) NULL, &hierarchy_id)) {
† †   case MrmSUCCESS:
† †       if (MrmCloseHierarchy(hierarchy_id) == MrmSUCCESS) {
† †           exit 0;
† †       } else {
† †           fprintf(stderr,
† †                    "Unable to close UID hierarchy.\n");
† †           exit 1;
† †       }
† †   case MrmNOT_FOUND:
† †       fprintf(stderr, "Unable to open UID files.\n");
† †       exit 1;
† †   default:
† †       fprintf(stderr, "Unable to open UID hierarchy.\n");
† †       exit 1;
† †   }
}LBL="4.2.5" HELPID=""Registering Callbacks and IdentifiersID="ch04156"The application must register the names of all callback procedures and identifiers defined in the UIL files.  Registering the names associates the symbolic names in the UIL files with procedures and data defined in the program.  MrmRegisterNames and MrmRegisterNamesInHierarchy accomplish this task.  Names registered by ID="ch04157"ID="ch04158"MrmRegisterNames are global to all UID hierarchies, whereas names registered by MrmRegisterNamesInHierarchy are local to a particular hierarchy.  When MRM looks up the program-defined value associated with a name in a given hierarchy, it searches first for an association local to the hierarchy and then for a global association.  Following is an example using MrmRegisterNames: ID="ch04159"void PBActivateCB_1(Widget pb, XtPointer app_data,
† †   XtPointer widget_data);
void PBActivateCB_2(Widget pb, XtPointer app_data,
† †   XtPointer widget_data);
void PBArmCB(Widget pb, XtPointer app_data,
† †   XtPointer widget_data);
static MrmRegisterArg cb_list[] = {
† †   { "pb_ac_proc_1",   (XtPointer) PBActivateCB_1 },
† †   { "pb_ac_proc_2",   (XtPointer) PBActivateCB_2 },
† †   { "pb_arm_proc",    (XtPointer) PBArmCB }
};
...
† †   if (MrmRegisterNames(cb_list,
† †                        (MrmCount) XtNumber(cb_list))
† †        == MrmSUCCESS) {
† †       ...
† †   } else {
† †       ...
† †   }LBL="4.2.6" HELPID=""Fetching Information from UID FilesID="ch04160"ID="ch04161"MRM can fetch the following information from UID files: Named widgets, defined by object clauses, and their descendants.  Use ID="ch04162"ID="ch04163"MrmFetchWidget or MrmFetchWidgetOverride.  ID="ch04164"ID="ch04165"Named color literals, defined by color or rbg functions and appearing in ID="ch04166"ID="ch04167"ID="ch04168"ID="ch04169"value clauses.  Use ID="ch04170"ID="ch04171"MrmFetchColorLiteral.  ID="ch04172"Named icon literals, defined by icon functions and appearing in ID="ch04173"ID="ch04174"value clauses.  Use ID="ch04175"ID="ch04176"MrmFetchIconLiteral.  ID="ch04177"Other named literals appearing in value clauses.  Use ID="ch04178"ID="ch04179"MrmFetchLiteral or MrmFetchSetValues.  ID="ch04180"ID="ch04181"MRM can fetch literals appearing in value clauses only if they are defined as ID="ch04182"ID="ch04183"exported.  ID="ch04184"ID="ch04185"After creating a top-level shell, using XtAppInitialize or ID="ch04186"XtAppCreateShell, the application can use MrmFetchWidget to fetch the child of the top-level shell and its descendants.  For each widget in the tree, ID="ch04187"ID="ch04188"MrmFetchWidget does the following: Calls the appropriate widget creation routine, passing it the initial resource values defined in the arguments specification in the ID="ch04189"ID="ch04190"object clause ID="ch04191"ID="ch04192"Adds the callback routines defined in the callbacks specification of the ID="ch04193"ID="ch04194"object clause ID="ch04195"ID="ch04196"Calls any MrmNcreateCallback callbacks ID="ch04197"Manages all child widgets unless they are defined to be unmanaged† †ID="ch04198"ID="ch04199"The application does not have to fetch all widgets at the beginning of the program.  To create widgets such as menus and dialogs as needed, the application can call MrmFetchWidget at any time.  ID="ch04200"The application can fetch the same widget definition more than once.  MRM creates a new widget each time, essentially using the UIL definition as a template.  MrmFetchWidgetOverride is useful here, as it allows the application to override the initial resource values specified in the UIL file.  ID="ch04201"Following is a simple example using MrmFetchWidget to create the main widget hierarchy for an application: ID="ch04202"int main(int argc, char **argv)
{
† †   Widget         app_shell, top_level;
† †   XtAppContext   app;
† †   static String  file_names[] = { "app_1", "app_2" };
† †   MrmHierarchy   hierarchy_id;
† †   MrmType        top_level_class;
† †   MrmInitialize();
† †   app_shell = XtAppInitialize(&app, "Example",
† †       (XrmOptionDescList) NULL, 0, (Cardinal *) &argc, argv,
† †       (String *) NULL, (ArgList) NULL, 0);
† †   switch (MrmOpenHierarchyPerDisplay(XtDisplay(app_shell),
† †            (MrmCount) XtNumber(file_names), file_names,
† †            (MrmOsOpenParamPtr *) NULL, &hierarchy_id)) {
† †   case MrmSUCCESS:
† †       if (MrmFetchWidget(hierarchy_id, "top_level",
† †             app_shell, &top_level, &top_level_class)
† †                                           != MrmSUCCESS) {
† †           fprintf(stderr,
† †                     "Unable to fetch top-level widget.\n");
† †       }
† †       if (MrmCloseHierarchy(hierarchy_id) == MrmSUCCESS) {
† †           exit 0;
† †       } else {
† †           fprintf(stderr,
† †                     "Unable to close UID hierarchy.\n");
† †           exit 1;
† †       }
† †   case MrmNOT_FOUND:
† †       fprintf(stderr, "Unable to open UID files.\n");
† †       exit 1;
† †   default:
† †       fprintf(stderr, "Unable to open UID hierarchy.\n");
† †       exit 1;
† †   }
}LBL="4.2.7" HELPID=""Closing the UID FileID="ch04203"ID="ch04204"MrmCloseHierarchy closes all files in the specified UID hierarchy.  The application can close and reopen a hierarchy, but usually it does not close a hierarchy until it is finished reading data from the UID files.  When the application uses multiple hierarchies, operating system limits on the number of open files may make it necessary to close one hierarchy before opening another.  ID="ch04205"LBL="4.2.8" HELPID=""Defining Callback ProceduresID="ch04206"An application that uses MRM defines callback procedures in the same way as an application that uses only the toolkit.  For callbacks delared in UIL files, the application must use MrmRegisterNames or MrmRegisterNamesInHierarchy to associate the UIL callback procedure names with the actual procedures defined in the program.  ID="ch04207"ID="ch04208"An application can create widgets, such as dialogs and PopupMenus, as the program needs them.  If these widgets are defined in UIL files, a callback procedure can call ID="ch04209"MrmFetchWidget to fetch them from UID files.  ID="ch04210"LBL="4.2.9" HELPID=""Making Widgets VisibleID="ch04211"ID="ch04212"MrmFetchWidget never manages the widget the application is fetching.  It does manage all other widgets in the tree whose root is the widget being fetched, except for widgets declared ID="ch04213"unmanaged in the UIL file.  ID="ch04214"ID="ch04215"MrmFetchWidget does not realize any widgets in the tree.  ID="ch04216"The application must manage any unmanaged widgets created by MrmFetchWidget, and it must realize all widgets it wants to make visible.  In the simple case where the application fetches the entire widget hierarchy at the beginning of the program, it typically manages the widget it fetches and then realizes the top-level shell: ID="ch04217"int main(int argc, char **argv)
{
† †   Widget         app_shell, top_level;
† †   XtAppContext   app;
† †   static String  file_names[] = { "app_1", "app_2" };
† †   MrmHierarchy   hierarchy_id;
† †   MrmType        top_level_class;
† †   MrmInitialize();
† †   app_shell = XtAppInitialize(&app, "Example",
† †       (XrmOptionDescList) NULL, 0, (Cardinal *) &argc, argv,
† †       (String *) NULL, (ArgList) NULL, 0);
† †   switch (MrmOpenHierarchyPerDisplay(XtDisplay(app_shell),
† †            (MrmCount) XtNumber(file_names), file_names,
† †            (MrmOsOpenParamPtr *) NULL, &hierarchy_id)) {
† †   case MrmSUCCESS:
† †       if (MrmFetchWidget(hierarchy_id, "top_level",app_shell,
† †             &top_level, &top_level_class) == MrmSUCCESS) {
† †           XtManageChild(top_level);
† †           XtRealizeWidget(app_shell);
† †       } else {
† †           fprintf(stderr,
† †                    "Unable to fetch top-level widget.\n");
† †       }
† †       if (MrmCloseHierarchy(hierarchy_id) == MrmSUCCESS) {
† †           exit 0;
† †       } else {
† †           fprintf(stderr,
† †                     "Unable to close UID hierarchy.\n");
† †           exit 1;
† †       }
† †   case MrmNOT_FOUND:
† †       fprintf(stderr, "Unable to open UID files.\n");
† †       exit 1;
† †   default:
† †       fprintf(stderr, "Unable to open UID hierarchy.\n");
† †       exit 1;
† †   }
}LBL="4.2.10" HELPID=""Entering the Event LoopID="ch04218"As with toolkit applications that do not use MRM, a program using MRM typically calls XtAppMainLoop to enter the event loop after realizing the top-level shell.  ID="ch04219"LBL="5"ID="18979"Basic ControlsControls are widgets and gadgets with which the user interacts directly.  They form the leaves of the widget tree whose root is the application's top-level shell.  In most cases, controls are subclasses of ID="ch051"XmPrimitive or ID="ch052"ID="ch053"XmGadget, and their parents are subclasses of XmManager.  (ID="ch054"ID="ch055"ID="ch056"ID="ch057"XmScale is a manager, but in many ways the application treats it as a primitive.) Motif provides the following basic controls: ID="ch058"ID="ch059"Labels, buttons, and separators ID="ch0510"ScrollBar ID="ch0511"Scale ID="ch0512"List ID="ch0513"Text and TextField ID="ch0514"ID="ch0515"LBL="5.1" HELPID=""Core, RectObj, XmPrimitive, and XmGadget ClassesID="ch0516"ID="ch0517"ID="ch0518"ID="ch0519"Nearly all the basic controls are subclasses of XmPrimitive or ID="ch0520"XmGadget.  ID="ch0521"XmPrimitive, in turn, is a subclass of the Intrinsics Core class, and XmGadget is a subclass of the Intrinsics RectObj class.  LBL="5.1.1" HELPID=""CoreID="ch0522"The Core class provides basic attributes of all widgets that have associated windows.  It has the following groups of resources: Specifications of the widget's x and y coordinates, width and height, and border width A resource specifying whether or not the widget is sensitive or able to receive input events from the Intrinsics event manager Characteristics of the window, including background and border color or pixmap, colormap, depth, and screen A resource controlling whether or not the Intrinsics map the window when the widget is managed A table associating translations with actions A set of accelerators, which is a translation table bound in the context of a particular widget LBL="5.1.2" HELPID=""RectObjID="ch0523"RectObj is the foundation for gadget classes; it is essentially Core without the attributes related to having a window.  ID="ch0524"RectObj resources control the position and dimensions of the gadget's rectangular area within its parent widget.  A RectObj resource also determines whether or not the gadget is sensitive.  LBL="5.1.3" HELPID=""XmPrimitiveID="ch0525"XmPrimitive is the fundamental Motif class for all basic control widgetsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'widgets that do not have children.  It includes the following resources and behavior: ID="ch0526"Foreground color, top and bottom shadow colors or pixmaps, and shadow thickness Thickness and color or pixmap for the highlighting rectangle, which is displayed when the widget has keyboard focus Resources to determine whether the user can traverse to the widget and whether or not it is a tab group A resource to determine what unit of measurement the widget uses for size and position resources Callbacks for the widget to invoke when the user presses KHelp† †ID="ch0527"A resource for the application to use in associating arbitrary data with the widget Translations and actions for keyboard traversal to another widget LBL="5.1.4" HELPID=""XmGadgetID="ch0528"XmGadget is the fundamental Motif class for all basic control gadgets.  It is equivalent to ID="ch0529"XmPrimitive, with two major exceptions: ID="ch0530"ID="ch0531"It has no resources for colors or pixmaps.  A gadget inherits these from its parent; therefore, all gadgets within a Manager have the same colors or pixmaps.  ID="ch0532"It has no translations or actions.  The Manager parent controls traversal between its gadget children, keeps track of gadgets that have input focus, and dispatches events to them.  ID="ch0533"LBL="5.2" HELPID=""Labels, Buttons, and SeparatorsID="ch0534"ID="ch0535"ID="ch0536"Labels, buttons, and separators are simple widgets built on XmPrimitive.  ID="ch0537"ID="ch0538"LBL="5.2.1" HELPID=""LabelsID="ch0539"Labels provide the ability to display static (uneditable) text or a pixmap.  A Label or LabelGadget itself is useful for displaying a message, title, or description.  Label and LabelGadget are also superclasses for buttons used as menu items, toggles, or controls.  ID="ch0540"The application can specify the following characteristics of Labels, LabelGadgets, and their subclasses: ID="ch0541"ID="ch0542"A compound string or pixmap to be displayed.  When using a pixmap, the application can supply a separate pixmap to be displayed when the widget is insensitive.  A font list for displaying the compound string.  Resources to determine the positioning of the text or pixmap within the widget.  One sets of resources determines the space allocated for the margins; another determines the distance between the margins and the text or pixmap inside.  The XmNalignment and XmNstringDirection resources together determine whether the text or pixmap is centered or is left or right justified within the widget.  ID="ch0543"ID="ch0544"A resource, XmNrecomputeSize, that determines whether the widget attempts to remain large enough to contain the text or pixmap.  When this resource is True and a resource that affects the size of the text or pixmap, the margins, or the widget itself is changed, the widget tries to resize itself to be just large enough to contain the text or pixmap.  ID="ch0545"In addition, Label and LabelGadget provide the following facilities for button subclasses in menus: ID="ch0546"ID="ch0547"A keysym used as a mnemonic to select the button.  The user can activate the button by pressing the mnemonic key when the button is visible.  An accelerator, a KeyPress event by which the user can activate the button whether or not it is visible.  Accelerators are supported only for PushButtons and ToggleButtons in PulldownMenus and PopupMenus.  ID="ch0548"ID="ch0549"ID="ch0550"ID="ch0551"ID="ch0552"Translations and actions for keyboard traversal within the menu or menu system.  LBL="5.2.2" HELPID=""ButtonsID="ch0553"A button is a basic control that performs some action when the user activates it.  Buttons commonly appear in menus, RadioBoxes, CheckBoxes, SelectionBoxes, and MessageBoxes.  This section describes some of the functions of each subclass.  ID="ch0554"ID="ch0555"ID="ch0556"ID="ch0557"LBL="" HELPID=""CascadeButtonsID="ch0558"A CascadeButton or CascadeButtonGadget is used inside a menu and, when activated, usually causes a PulldownMenu to appear.  CascadeButtons have the following resources and behavior: ID="ch0559"ID="ch0560"A pixmap displayed at one end of the widget in a PopupMenu or PulldownMenu to indicate that activating the CascadeButton posts another menu.  ID="ch0561"ID="ch0562"ID="ch0563"A resource, XmNsubMenuId, that holds the widget ID of the PulldownMenu posted when the user activates the button.  ID="ch0564"ID="ch0565"XmNactivateCallback callbacks, which the widget invokes when the user activates it, and ID="ch0566"XmNcascadingCallback callbacks, which the widget invokes just before posting a PulldownMenu.  ID="ch0567"ID="ch0568"A resource to provide a delay between the time the mouse enters the widget and the time it posts a menu.  Translations and actions to activate the widget and to post and unpost PulldownMenus.  In general, pressing ID="ch0569"BSelect or dragging BSelect into the widget posts the PulldownMenu.  Releasing ID="ch0570"BSelect in the widget causes the PulldownMenu to remain posted and enables keyboard traversal.  When keyboard traversal is enabled, pressing KActivate or ID="ch0571"KSelect in the widget posts the PulldownMenu and enables keyboard traversal in that menu.  ID="ch0572"LBL="" HELPID=""PushButtonsID="ch0573"A PushButton or PushButtonGadget can appear either inside or outside a menu.  It performs some action determined by the application.  When a PushButton is armed, or ready to be activated, it changes its appearance so that it looks as if the user has pressed it in.  When it is disarmed it reverts to the appearance of extending out.  PushButtons provide the following behavior: ID="ch0574"Callbacks that the widget invokes when it is armed, disarmed, and activated.  The application usually provides only an XmNactivateCallback† †procedure to perform the action associated with the button.  ID="ch0575"Resources to provide a color or pixmap to be displayed when the button is armed and not inside a menu.  When a button in a menu is armed, the top and bottom shadows switch colors.  A resource to determine whether or not the widget considers multiple mouse clicks distinct from single mouse clicks.  A resource to determine whether or not the button is marked as the default button when outside a menu.  In a BulletinBoard, the default button is the one activated when the user presses ID="ch0576"KActivate and no other button has keyboard focus.  The default button has a distinctive shadow whose thickness is controlled by the ID="ch0577"XmNdefaultButtonShadowThickness resource.  ID="ch0578"Translations to arm, disarm, and activate the button.  In general, pressing BSelect on a button or, in a menu, dragging ID="ch0579"BSelect or traversing to a button arms it.  Releasing BSelect or pressing KActivate (in a menu) or ID="ch0580"KSelect in the widget activates and disarms it.  ID="ch0581"LBL="" HELPID=""ToggleButtonsID="ch0582"ToggleButtons and ToggleButtonGadgets have one of two states: like toggle switches, they are either "on" or "off".  They can appear in menus or in nonmenu RowColumn WorkAreas, including RadioBoxes and CheckBoxes.  In a RadioBox only one ToggleButton at a time can be on; in a CheckBox more than one ToggleButton can be on.  ToggleButtons can have indicators with distinctive shapes to distinguish whether or not more than one button at a time can be set.  However, it is the RowColumn parent, not the ToggleButton, that controls this behavior.  ID="ch0583"ID="ch0584"ID="ch0585"ID="ch0586"ID="ch0587"ToggleButtons have the following characteristics: ID="ch0588"Callbacks that the widget invokes when it is armed or disarmed and when it changes state.  The widget invokes the XmNvalueChangedCallback callbacks when the button's state changes from on to off or from off to on.  ID="ch0589"Resources to control the appearance of the indicator.  If XmNindicatorOn is False or if XmNvisibleWhenOff is False and the button is in the off state, no indicator is displayed.  Otherwise, ID="ch0590"ID="ch0591"XmNindicatorType determines whether the indicator shows that only one or more than one button at a time can be on.  ID="ch0592"A color or pixmap to be displayed when the button is armed and XmNfillOnSelect is True.  ID="ch0593"Pixmaps to be displayed when the button is selected and the Label or LabelGadget superclass's ID="ch0594"XmNlabelType is XmPIXMAP.  ID="ch0595"ID="ch0596"ID="ch0597"Translations to arm and disarm the button and to change its state.  In general, pressing BSelect on a button or, in a menu, dragging ID="ch0598"BSelect or traversing to a button arms it.  Releasing BSelect or pressing KActivate (in a menu) or ID="ch0599"KSelect in the widget changes its state and disarms it.  ID="ch05100"LBL="" HELPID=""DrawnButtonsID="ch05101"A DrawnButton is an empty button surrounded by a shadow border.  It is intended to be used as a PushButton but with graphics drawn by the application.  Like a PushButton, it has translations and actions to arm, disarm, and activate the button and invoke the corresponding callbacks.  If ID="ch05102"XmNpushButtonEnabled is True, it draws the shadow so that the button appears pressed in when armed and popped out when disarmed.  ID="ch05103"Other than this, the application must manage the button's visual appearance.  It has XmNexposeCallback and XmNresizeCallback callbacks to notify the application that the button has been exposed or resized and therefore needs to be redrawn.  The application must be careful not to draw within the button's shadows or highlight areas.  The application can use a clipping rectangle in the widget's graphics context that takes account of the button's ID="ch05104"ID="ch05105"XmNhighlightThickness† †and ID="ch05106"XmNshadowThickness.  ID="ch05107"LBL="" HELPID=""ArrowButtonsID="ch05108"An ArrowButton or ArrowButtonGadget is a button with an arrow graphic and a shadow.  A resource controls the direction of the arrow.  Unlike other buttons, it is not a subclass of ID="ch05109"XmLabel or ID="ch05110"ID="ch05111"XmLabelGadget, but is has some of the same behavior as other buttons.  It has callbacks that the widget invokes when armed, disarmed, or activated.  It has translations and actions similar to those of other buttons to arm, disarm, or activate the button.  ID="ch05112"ID="ch05113"LBL="5.2.3" HELPID=""SeparatorsID="ch05114"A Separator or SeparatorGadget separates controls or groups of controls.  It usually appears as a horizontal or vertical line and supports several styles of line drawing.  Resources control its orientation and the type of line it draws.  One line style consists of no line at all.  This allows the application to control the appearance of the separator by setting its ID="ch05115"XmNbackgroundColor or XmNbackgroundPixmap.  ID="ch05116"ID="ch05117"LBL="5.3" HELPID=""ScrollBarID="ch05118"A widget can act as a viewport onto a virtual scroll.  The ScrollBar is the control that moves the viewport horizontally or vertically relative to the underlying scroll.  A ScrollBar consists of a rectangle, called the scroll region, representing the full size of the scroll.  It has a smaller rectangle, called the slider, within the scroll region, representing the position and size of the viewport relative to the full scroll.  The ScrollBar usually has arrow graphics at both ends of the larger rectangle.  A ScrollBar has translations and actions that allow the user to move the slider.  By clicking on an arrow, the user moves the slider one small increment in the direction of the arrow.  By clicking in the scroll region between an arrow and the slider, the user moves the slider a larger increment (the page increment) in the direction of the arrow.  When the ScrollBar has keyboard focus the user can use the keyboard to move the slider in this way.  The user can also drag the slider using the mouse.  ID="ch05119"By itself, the ScrollBar does not have an association with a widget acting as a viewport onto a scroll.  Most applications use a ScrolledWindow, a Manager widget with a child to be scrolled and possibly with one or two ScrollBars to control the scrolling.  ScrolledWindow can automatically control the interaction between the scrolled child and the ScrollBars, or it can allow the application to control the interaction.  For more information see ID="ch05120"ID="ch05121"ID="ch05122"IDREF="21296" TYPE="TITLE"Chapter 9, "Scrolling, Panes, and Frames."ScrollBar has a number of resources that allow the application to use it to control scrolling: ID="ch05123"A minimum value (XmNminimum), representing the position of the slider at one end of the scroll region, and a maximum value (ID="ch05124"XmNmaximum), representing the position of the slider at the other end of the scroll region.  These values can be in any integral units the application chooses so long as the maximum is greater than the minimum.  ID="ch05125"The length of the slider (XmNsliderSize) between 1 and (ID="ch05126"XmNmaximum - XmNminimum).  ID="ch05127"ID="ch05128"A value (XmNvalue), ranging between XmNminimum and (ID="ch05129"ID="ch05130"XmNmaximum - XmNsliderSize), representing the current position of the slider between the maximum and minimum values.  ID="ch05131"ID="ch05132"Values for the increment (XmNincrement) and page increment (ID="ch05133"XmNpageIncrement) by which the user can move the slider.  ID="ch05134"A resource (XmNprocessingDirection) that determines whether the minimum value is on the left or right for horizontal ScrollBars or is on the bottom or top for vertical ScrollBars.  ID="ch05135"ID="ch05136"Distinct callbacks that the widget invokes when the user moves the slider by one increment in either direction, by one page increment in either direction, or all the way to either end of the scroll region.  The widget invokes other callbacks as the user drags the slider and when the user stops dragging the slider.  The application does not have to provide routines for all these callback lists; if it provides only an XmNvalueChangedCallback procedure, the widget invokes that procedure whenever the ScrollBar value changes (except during interactive dragging of the slider).  ID="ch05137"ID="ch05138"Resources to control the color of the scroll region, whether the ScrollBar is horizontal or vertical, and whether or not the ScrollBar has arrows.  ID="ch05139"Resources to control the delays before the widget moves the slider continuously as the user presses and holds BSelect on an arrow or the scroll region.  ID="ch05140"Two convenience routines, XmScrollBarGetValues and ID="ch05141"XmScrollBarSetValues, allow the application to get and set the value, slider size, increment, and page increment in one call.  ID="ch05142"LBL="5.4" HELPID=""ScaleID="ch05143"A Scale displays a value within a range and optionally allows the user to supply a new value.  Its appearance and behavior are much like those of a ScrollBar without arrows.  It also has a title and can display the current value next to the slider.  ID="ch05144"Like a ScrollBar, a Scale has minimum, maximum, and current integral values.  The application has no access to the slider size, and the current value ranges between the minimum and maximum.  The increment by which the arrow keys move the slider is always 1, but the application can supply a multiple increment (ID="ch05145"ID="ch05146"XmNscaleMultiple) analogous to ScrollBar's ID="ch05147"XmNpageIncrement.  Scale has two callback lists: ID="ch05148"XmNvalueChangedCallback is invoked when the user changes the value but is not in the process of dragging the slider, and ID="ch05149"XmNdragCallback is invoked when the user changes the value while dragging the slider.  ID="ch05150"Scale also has resources controlling whether the orientation is vertical or horizontal and which end of the Scale represents the minimum value.  Other resources control aspects of the Scale's appearance, including the width and height, the title string, whether or not the Scale displays the current value next to the slider, the number of decimal places in the displayed value, and a font list for the title and value.  ID="ch05151"Two convenience routines, XmScaleGetValue and ID="ch05152"XmScaleSetValue, allow the application to get and set the value.  ID="ch05153"By default, a Scale has no labels or tic marks along the rectangle in which the slider moves.  The application can add these by creating a series of widgetsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'such as LabelGadgets or SeparatorGadgetsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'as children of the Scale.  For example, LabelGadgets could display values at intervals between the minimum and maximum, or SeparatorGadgets could display short lines as tic marks.  The Scale positions any children, in order of creation, along the rectangle containing the slider, as follows: ID="ch05154"ID="ch05155"ID="ch05156"A single child appears in the middle of the rectangle If there are two children, the first appears at the top (for a vertical Scale) or left (for a horizontal scale) of the rectangle, and the other child appears at the bottom or right of the rectangle ID="ch05157"If there are more than three children, they appear at equal intervals along the rectangle ranging from top to bottom or from left to right The following example creates a Scale with five tic marks: ID="ch05158"#define NUM_TICS 5
Widget          parent, scale, tics[NUM_TICS];
Arg             args[10];
Cardinal        i, n;
unsigned char   scale_orientation, tic_orientation;
Dimension       tic_long_dim = 10, tic_short_dim = 5;
Dimension       tic_width, tic_height;
char            tic_name[10];
...
scale = XmCreateScale(parent, "scale", args, n);
XtManageChild(scale);
...
n = 0;
XtSetArg(args[n], XmNorientation, &scale_orientation);   n++;
XtGetValues(scale, args, n);
if (scale_orientation == XmHORIZONTAL) {
† †   tic_orientation = XmVERTICAL;
† †   tic_width = tic_short_dim;
† †   tic_height = tic_long_dim;
} else {
† †   tic_orientation = XmHORIZONTAL;
† †   tic_width = tic_long_dim;
† †   tic_height = tic_short_dim;
}
for (i = 0; i < NUM_TICS; i++) {
† †   sprintf(tic_name, "tic_%d", i);
† †   n = 0;
† †   XtSetArg(args[n], XmNseparatorType, XmSINGLE_LINE);  n++;
† †   XtSetArg(args[n], XmNorientation, tic_orientation);  n++;
† †   XtSetArg(args[n], XmNwidth, tic_width);              n++;
† †   XtSetArg(args[n], XmNheight, tic_height);            n++;
† †   tics[i] = XmCreateSeparatorGadget(scale, tic_name,
† †                                       args, n);
}
XtManageChildren(tics, NUM_TICS);
...LBL="5.5" HELPID=""ListID="ch05159"A List is an array of textual items from which the user selects one or more entries.  Each item is a compound string.  List has four modes, controlled by the XmNselectionPolicy† †resource, for selecting items: ID="ch05160"Single SelectAt most one item is selected.  Performing the selection action on an item toggles the selection state of the item and deselects any other selected item.  Browse SelectAt most one item is selected.  Performing the selection action on an item selects the item and deselects any other selected item.  Dragging BSelect through the list moves the selection along with the cursor.  ID="ch05161"Multiple SelectAny number of items can be selected.  Performing the selection action on an item toggles the selection state of the item but does not deselect any other selected item.  Extended SelectAny number of items can be selected.  The user can select either continuous or discontinuous ranges of items, depending on the mouse buttons used or, when using the keyboard, on whether the List is in Normal Mode or Add Mode: ID="ch05162"Pressing BSelect or, in Normal Mode, KSelect on an item selects the item and deselects any other selected item.  Dragging ID="ch05163"ID="ch05164"BSelect or pressing or dragging BExtend following a ID="ch05165"BSelect action selects all items between the item under the pointer and the item on which BSelect was pressed.  In Normal Mode, KExtend and shifted navigation have the same effect as pressing ID="ch05166"BExtend following a BSelect action.  Pressing BToggle or, in Add Mode, KSelect on an item toggles the selection state of the item but does not deselect any selected item.  Dragging ID="ch05167"ID="ch05168"BToggle or pressing or dragging BExtend following a ID="ch05169"BToggle action sets the selection state of all items between the item under the pointer and the item on which BToggle was pressed to the state of the item on which BToggle was pressed.  In Add Mode, KExtend and shifted navigation have the same effect as pressing ID="ch05170"BExtend following a BToggle action.  When the user makes a selection, the List invokes one of four callback lists, depending on the selection policy: ID="ch05171"COLUMNS="2"LEFT="0" WIDTH="126"Selection PolicyLEFT="135" WIDTH="356"Callback ListLEFT="0" WIDTH="126"Single SelectLEFT="135" WIDTH="356"XmNsingleSelectionCallbackID="ch05172"LEFT="0" WIDTH="126"Browse SelectLEFT="135" WIDTH="356"XmNbrowseSelectionCallbackLEFT="0" WIDTH="126"Multiple SelectID="ch05173"LEFT="135" WIDTH="356"XmNmultipleSelectionCallbackLEFT="0" WIDTH="126"Extended SelectID="ch05174"LEFT="135" WIDTH="356"XmNextendedSelectionCallbackID="ch05175"By default, the List does not invoke a callback list when the List is in Single Select or Extended Select mode and the user drags the mouse cursor over a new item.  It does invoke the callbacks when the user releases the mouse button.  If ID="ch05176"XmNautomaticSelection is True, the List invokes the callbacks while the user is dragging the mouse.  ID="ch05177"ID="ch05178"The widget data passed to selection callback routines contains both the selected itemsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the compound stringsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'and integers representing the positions within the list of the selected items.  The first item in the list is at position 1, the second item at position 2, and so on.  List has another callback list, XmNdefaultActionCallback, which it invokes when the user double clicks or presses ID="ch05179"ID="ch05180"KActivate on an item.  The widget data passed to these callback routines contains only the item at the location cursor and its position, not the selected items.  When the user performs the default action via a double click, the List calls the appropriate selection callbacks on the first click and the ID="ch05181"ID="ch05182"XmNdefaultActionCallback callbacks on the second click.  ID="ch05183"List includes several other sets of resources: ID="ch05184"Arrays and counts of the List items and selected items ID="ch05185"The number of items, XmNvisibleItemCount, that the list can display at one time, and the position in the List of the first visible item ID="ch05186"ID="ch05187"Several resources that affect the appearance of the list items: font list, justification (XmNstringDirection), spacing between items, and margins between the items and the List border ID="ch05188"ID="ch05189"The maximum time interval between clicks for a double click A resource (XmNlistSizePolicy) that determines what the List does when an item is too wide to fit into the List: it can keep its size and, if it is a ScrolledList, add a horizontal ScrollBar; grow to accommodate the item; or try to grow and, if it fails to accommodate the item but is a ScrolledList, add a ScrollBar ID="ch05190"ID="ch05191"ID="ch05192"ID="ch05193"A resource that determines whether the ScrollBars in a ScrolledList are displayed at all times or only when needed.  ID="ch05194"ID="ch05195"A ScrolledList is a List inside a ScrolledWindow.  The application can use ID="ch05196"ID="ch05197"ID="ch05198"XmCreateScrolledList to create one.  ID="ch05199"In addition to its resources, List has a variety of convenience routines that allow the application to add, remove, select, and deselect items; specify the first or last visible item; find the position of an item or the positions of the selected items; set Add Mode; and scroll the List horizontally.  ID="ch05200"LBL="5.6" HELPID=""Text and TextFieldID="ch05201"ID="ch05202"Text is a widget for displaying and, optionally, editing text.  When the Text is editable and the user presses a key that represents a text character, that character is inserted into the text.  Other translations and actions allow the user to navigate or to select, cut, copy, paste, or scroll the text.  For more information on Text and TextField, see IDREF="24337" TYPE="TITLE"Chapter 8, "Text."LBL="6"ID="11089"Menus and OptionsID="ch061"A menu is a widget that allows the user to make a choice among actions or states.  When the menu is visible, the user makes a choice by activating a button in the menu, usually by pressing BSelect, KSelect, or ID="ch062"ID="ch063"KActivate on the button.  Some buttons also have mnemonics that allow the user to activate them by pressing the mnemonic keys when the menu is visible.  Buttons can also have accelerators, which activate the buttons whether or not the menu is visible.  ID="ch064"Motif has four basic kinds of menu: MenuBar.  This menu is normally always managed within some component of an application, often the MainWindow.  It usually consists of a row of CascadeButtons.  When the user activates a button in the menu, a PulldownMenu menu appears with one set of top-level choices that apply to the application component.  ID="ch065"ID="ch066"ID="ch067"ID="ch068"PopupMenu.  This menu contains a set of choices that apply to a component of the application.  The menu is not visible until the user takes an action that posts it, usually pressing ID="ch069"BMenu in the associated component or pressing ID="ch0610"KMenu when the component has keyboard focus.  A PopupMenu can contain buttons that take action or change state directly.  It can also contain CascadeButtons that cause PulldownMenus to appear.  ID="ch0611"ID="ch0612"ID="ch0613"PulldownMenu.  This menu is associated with a CascadeButton in a MenuBar, a PopupMenu, or another PulldownMenu.  The menu is not visible until the user posts it by activating the associated CascadeButton.  Like a PopupMenu, a PulldownMenu can contain buttons that take action or change state directly.  It can also contain CascadeButtons that cause other PulldownMenus to appear.  ID="ch0614"ID="ch0615"ID="ch0616"ID="ch0617"OptionMenu.  This menu allows the user to choose among one set of choices, usually mutually exclusive attributes or states.  It consists of a label, a selection area, and a PulldownMenu.  The selection area is a CascadeButtonGadget whose label shows the currently selected option.  The PulldownMenu contains the set of options.  The user posts the PulldownMenu by activating the CascadeButtonGadget or by pressing ID="ch0618"ID="ch0619"ID="ch0620"MAlt along with a mnemonic.  When the user activates a button in the PulldownMenu, that button becomes the newly selected option.  RowColumn is the widget that Motif uses as a menu.  A RowColumn can also be a nonmenu WorkArea.  One use for a WorkArea is to contain a set of ToggleButtons constituting a RadioBox or a CheckBox.  When the user selects a ToggleButton, its state changes from on to off or from off to on.  In a RadioBox, only one ToggleButton at a time can be on; in a CheckBox, more than one ToggleButton can be on.  ID="ch0621"ID="ch0622"ID="ch0623"ID="ch0624"ID="ch0625"RowColumn performs special geometry management to align and lay out its children in a variety of ways.  An application can use a RowColumn WorkArea to take advantage of the RowColumn geometry management for a set of widgets.  For details see ID="ch0626"ID="ch0627"IDREF="18723" TYPE="TITLE"Chapter 10, "Managing Geometry."LBL="6.1" HELPID=""Menu Components: Buttons, RowColumn, MenuShellID="ch0628"ID="ch0629"ID="ch0630"A menu is a three-level hierarchy: Buttons represent the menu selections.  A RowColumn widget is the manager that contains the buttons.  A MenuShell envelops each PulldownMenu and PopupMenu.  LBL="6.1.1" HELPID=""ButtonsID="ch0631"The user makes a choice in a menu by activating one of the buttons in the menu.  CascadeButtons, PushButtons, and ToggleButtons and their gadget variants are most commonly used in menus.  ID="ch0632"ID="ch0633"ID="ch0634"Motif does not support DrawnButtons or ArrowButtons in menus, though they can appear in a RowColumn WorkArea.  To give a menu button a distinctive appearance, use a PushButton with a label type of ID="ch0635"ID="ch0636"ID="ch0637"ID="ch0638"ID="ch0639"XmPIXMAP and supply XmNlabelPixmap and ID="ch0640"ID="ch0641"XmNlabelInsensitivePixmap resources.  ID="ch0642"The application learns of the user's choice through the appropriate button callback lists: When the user activates a CascadeButton, the button calls the ID="ch0643"XmNcascadingCallback callbacks.  If the button has an attached PulldownMenu after these callbacks return, the button posts the menu.  Otherwise, the button calls the ID="ch0644"ID="ch0645"XmNactivateCallback callbacks.  ID="ch0646"When the user activates a PushButton, the button calls the ID="ch0647"XmNactivateCallback callbacks.  ID="ch0648"When the user activates a ToggleButton, the button calls the ID="ch0649"XmNvalueChangedCallback callbacks.  ID="ch0650"Buttons in a menu have translations and actions that arm, disarm, and activate the buttons.  These actions also post and unpost menus in the hierarchy at appropriate times.  The buttons inherit menu traversal translations and actions from XmLabel.  These actions allow the user to move from button to button within a menu and from menu to menu within the menu hierarchy.  ID="ch0651"ID="ch0652"LBL="6.1.2" HELPID=""RowColumnID="ch0653"The parent of the buttons in a menu is a RowColumn widget.  RowColumn interacts with its button children in these ways: In a menu (but not a WorkArea), it ensures that all children are CascadeButtons, PushButtons, ToggleButtons, Labels, or Separators (or their gadget variants).  If the ID="ch0654"ID="ch0655"ID="ch0656"ID="ch0657"ID="ch0658"ID="ch0659"XmNisHomogeneous resource is True, it ensures that all children are of the class specified by ID="ch0660"XmNentryClass.  ID="ch0661"It lays out its children and, if XmNisAligned is True, aligns the labels of children that are ID="ch0662"XmLabel or XmLabelGadget† †subclasses.  ID="ch0663"ID="ch0664"ID="ch0665"ID="ch0666"It stores the widget ID of the last menu item selected in the XmNmenuHistory resource.  ID="ch0667"It allows the application to supply a single callback list for all button children.  If XmNentryCallback is not NULL, it disables the ID="ch0668"XmNactivateCallback and XmNvalueChangedCallback callbacks for its button children and arranges for the buttons to call the ID="ch0669"ID="ch0670"XmNentryCallback callbacks instead.  If XmNradioBehavior is True, it ensures that only one ToggleButton at a time is normally selected.  It also changes the default values for ID="ch0671"ID="ch0672"XmNindicatorType and ID="ch0673"XmNvisibleWhenOff for its ToggleButton children to the one-of-many, always-displayed style.  ID="ch0674"It has additional resources for MenuBars and OptionMenus, described in the following sections.  ID="ch0675"ID="ch0676"In addition to XmNentryCallback, RowColumn also has ID="ch0677"ID="ch0678"XmNmapCallback and XmNunmapCallback callbacks.  These callbacks apply only to PopupMenus and PulldownMenus.  The ID="ch0679"ID="ch0680"ID="ch0681"ID="ch0682"XmNmapCallback callbacks are called just before the menu is posted, and the XmNunmapCallback callbacks are called just after the menu is unposted.  They are useful for changing the menu to reflect the current state of the application.  For example, an XmNmapCallback callback can use XtSetSensitive to make some menu items insensitive if they are not applicable in the current state of the program.  ID="ch0683"LBL="6.1.3" HELPID=""MenuShellID="ch0684"The windows associated with PopupMenus and PulldownMenus are top-level windows.  That is, the parent window of such a menu is the root window of the screen, not the window associated with the parent widget.  This allows the menu to appear anywhere on the screen without being clipped by the parent widget's window.  ID="ch0685"ID="ch0686"The parent widget of each PopupMenu and PulldownMenu RowColumn must be a MenuShell.  It is actually the MenuShell's window that is the top-level window.  ID="ch0687"ID="ch0688"ID="ch0689"ID="ch0690"XmMenuShell is a subclass of OverrideShell, so the window manager ignores MenuShell's windows.  ID="ch0691"ID="ch0692"A MenuShell is often invisible to the application.  The Motif convenience routines for creating PopupMenus and PulldownMenus automatically create MenuShell parents for these menus.  When a PulldownMenu is the child of a PopupMenu or another PulldownMenu, the child's MenuShell is actually the child of the parent's MenuShell.  The convenience routines for creating PulldownMenus manage these relations automatically.  ID="ch0693"ID="ch0694"ID="ch0695"Motif arranges for the RowColumn's window to coincide with the MenuShell's window.  Setting ID="ch0696"ID="ch0697"XmNheight, XmNwidth, or XmNborderWidth for either a MenuShell or its child sets that resource to the same value in both the parent and the child.  For a child of a MenuShell, setting ID="ch0698"ID="ch0699"ID="ch06100"XmNx or XmNy sets the corresponding resource of the parent but does not change the child's position relative to the parent.  ID="ch06101"ID="ch06102"XtGetValues for the child's XmNx or XmNy yields the value of the corresponding resource in the parent.  The x and y coordinates of the child's upper left outside corner relative to the parent's upper left inside corner are both zero minus the value of ID="ch06103"XmNborderWidth.  To change any geometry-related resources of a PopupMenu or PulldownMenu, an application should always specify these resources for the RowColumn child, not the MenuShell parent.  ID="ch06104"ID="ch06105"ID="ch06106"ID="ch06107"If an application needs to create a MenuShell explicitly, it should create the MenuShell as a popup child of its parent (using ID="ch06108"XtCreatePopupShell or XtVaCreatePopupShell).  All Motif convenience routines that create MenuShells do this automatically, and an application rarely needs to create a MenuShell directly.  ID="ch06109"ID="ch06110"LBL="6.2" HELPID=""MenuBarID="ch06111"All children of a MenuBar must be CascadeButtons or CascadeButtonGadgets.  The MenuBar attempts to place its button children in a single row.  If it does not have enough room, it tries to wrap the remaining children into additional rows.  ID="ch06112"ID="ch06113"An application should treat specially the button, if any, that pulls down a help menu.  The application should set the MenuBar RowColumn's ID="ch06114"ID="ch06115"XmNmenuHelpWidget to the widget ID of this button.  The MenuBar attempts to place this button at one of the lower corners of the MenuBar, as specified by the ID="ch06116"† †OSF/Motif Style Guide.In a MenuBar, all buttons typically have associated PulldownMenus.  Each PulldownMenu associated with a button in a MenuBar must be a child of the MenuBar.  (More precisely, each PulldownMenu's MenuShell must be a child of the MenuBar.) Each button's ID="ch06117"ID="ch06118"ID="ch06119"XmNsubMenuId resource must be set to the widget ID of the associated PulldownMenu.  Set ID="ch06120"XmNsubMenuId to the widget ID of the PulldownMenu RowColumn, not of the PulldownMenu's MenuShell.  ID="ch06121"The routines XmCreateMenuBar, ID="ch06122"XmCreateSimpleMenuBar, and XmVaCreateSimpleMenuBar all create MenuBars.  ID="ch06123"ID="ch06124"ID="ch06125"LBL="6.3" HELPID=""PopupMenuID="ch06126"A PopupMenu is normally invisible.  When the user takes some actionname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'usually pressing BMenu or ID="ch06127"KMenuname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in a widget that has a PopupMenu, the menu is posted.  The user moves from item to item in the menu by dragging ID="ch06128"BMenu or, when keyboard traversal is enabled, by keyboard traversal actions.  Motif unposts the menu when the user activates an item in the menu system (other than a CascadeButton), presses KCancel, or releases or clicks ID="ch06129"ID="ch06130"BMenu outside a menu item.  A PopupMenu RowColumn must have a MenuShell parent.  The parent of the MenuShell is the widget with which the PopupMenu is associated.  Because the MenuShell is a popup child of its parent, the parent can be any widget (but not a gadget); it does not have to be a subclass of ID="ch06131"ID="ch06132"ID="ch06133"Composite.  The Motif convenience routines that create PopupMenus automatically create a MenuShell as the parent of the PopupMenu RowColumn.  ID="ch06134"The PopupMenu's XmNmenuPost resource specifies the button event that posts the menu.  The event can be any button press, possibly with modifiers.  To allow the user to post a PopupMenu using the mouse, the application has to take these actions: ID="ch06135"ID="ch06136"Provide an event handler (using XtAddEventHandler) for button press events for the widget with which the PopupMenu is associated.  The second argument (the ID="ch06137"ID="ch06138"client_data argument) to the event handler should be the PopupMenu RowColumn.  ID="ch06139"In the event handler, call XmMenuPosition to locate the PopupMenu at the point where the user pressed the mouse button, or position the menu itself.  ID="ch06140"ID="ch06141"In the event handler, manage the PopupMenu RowColumn.  If the button event matches the event description in the RowColumn's ID="ch06142"ID="ch06143"XmNmenuPost resource, Motif makes the PopupMenu visible when the application manages it.  Otherwise, Motif unmanages the PopupMenu and does not post it.  ID="ch06144"The PopupMenu is realized, if necessary, the first time it is posted.  ID="ch06145"Following is an example: void ButtonEventHandler(Widget widget, XtPointer popup,
† †    XEvent *event, Boolean *continue)
† †{
† †  XmMenuPosition((Widget) popup, (XButtonPressedEvent *)
† †      event);
† †  XtManageChild((Widget) popup);
† †}
...
† †  Widget       parent, popup;
† †  popup = XmCreatePopupMenu(parent, "popup", args, n);
† †  XtAddEventHandler(parent, ButtonPressMask, False,
† †                    (XtEventHandler) ButtonEventHandler,
† †                    (XtPointer) popup);
...Posting a PopupMenu through the keyboard is controlled by the PopupMenu's ID="ch06146"XmNmenuAccelerator and XmNpopupEnabled resources.  ID="ch06147"ID="ch06148"XmNmenuAccelerator specifies a key event that may post the menu.  XmNpopupEnabled specifies whether or not this event actually posts the menu.  It also determines whether or not accelerators and mnemonics in the PopupMenu and its submenus are enabled.  An application can have only one active PopupMenu at a time for a particular widget.  If the widget has more than one PopupMenu, the application should set ID="ch06149"XmNpopupEnabled to True for the active menu and set ID="ch06150"XmNpopupEnabled to False for all inactive menus.  The application must also arrange for its button event handler to manage the proper PopupMenu on a popup button event.  One possible implementation is for the event handler to call a function that returns the appropriate PopupMenu, depending on the state of the application.  LBL="6.4" HELPID=""PulldownMenuID="ch06151"A PulldownMenu is always associated with another RowColumn.  It becomes visible when the user activates a CascadeButton in the associated RowColumn.  It becomes invisible when the user traverses upward or laterally in the menu hierarchy, activates a button in the hierarchy (other than a CascadeButton in the menu or a descendant), presses ID="ch06152"ID="ch06153"KCancel, or clicks or releases a mouse button outside a menu item.  ID="ch06154"A PulldownMenu must have the following relations with other widgets: ID="ch06155"It must be the value of the XmNsubMenuId resource of the CascadeButton that is to post the menu.  ID="ch06156"ID="ch06157"It must have a MenuShell as its parent.  The Motif convenience routines that create PulldownMenus create MenuShell parents automatically.  ID="ch06158"ID="ch06159"The MenuShell must have the proper parent, depending on the kind of RowColumn with which the PulldownMenu is associated.  The MenuShell is a popup child of its own parent.  Following are the required parents of the MenuShell: ID="ch06160"ID="ch06161"ID="ch06162"If the PulldownMenu is to be pulled down from a MenuBar, the parent must be the MenuBar.  ID="ch06163"ID="ch06164"If the PulldownMenu is to be pulled down from a PopupMenu or another PulldownMenu, the parent must be that PopupMenu or PulldownMenu.  Actually, the parent is the other menu's MenuShell; but the ID="ch06165"ID="ch06166"parent† †parameter to the Motif convenience routines that create PopupMenus must be the other menu itself (the RowColumn), not its MenuShell parent.  ID="ch06167"ID="ch06168"If the PulldownMenu is to be pulled down from an OptionMenu, the parent must be the parent of the OptionMenu.  ID="ch06169"ID="ch06170"LBL="6.5" HELPID=""OptionMenuID="ch06171"An OptionMenu lets the user choose among a set of usually mutually exclusive options.  The OptionMenu is always visible.  It consists of a label (a LabelGadget), a selection area (a CascadeButtonGadget), and an associated PulldownMenu.  The label of the CascadeButtonGadget displays the currently selected option, one of the items in the PulldownMenu.  When the user activates the CascadeButtonGadget, the PulldownMenu becomes visible with the currently selected item directly above the selection area.  When the user activates an item in the PulldownMenu, the PulldownMenu is unposted and the item the user chose becomes the currently selected option.  ID="ch06172"ID="ch06173"ID="ch06174"The PulldownMenu normally contains only PushButtons.  It must not contain any ToggleButtons, and Motif does not support CascadeButtons.  ID="ch06175"ID="ch06176"ID="ch06177"ID="ch06178"RowColumn has a number of resources for use specifically with an OptionMenu: ID="ch06179"ID="ch06180"XmNlabelString The text of the label.  Setting this resource also sets the ID="ch06181"XmNlabelString of the LabelGadget.  ID="ch06182"XmNmnemonic  A keysym that, when pressed along with the ID="ch06183"MAlt modifier, posts the PulldownMenu.  Motif underlines the first character in the label string that matches the mnemonic and that is in a segment whose font list element tag matches ID="ch06184"XmNmnemonicCharSet.  Setting this resource also sets the ID="ch06185"XmNmnemonic of the LabelGadget.  ID="ch06186"XmNmnemonicCharSet The font list element tag used for underlining the mnemonic.  Setting this resource also sets the ID="ch06187"XmNmnemonicCharSet of the LabelGadget.  ID="ch06188"XmNsubMenuId The widget ID of the PulldownMenu.  Setting this resource also sets the ID="ch06189"ID="ch06190"XmNsubMenuId of the CascadeButtonGadget.  ID="ch06191"If the application needs to get or set any of these four resources for the LabelGadget or CascadeButtonGadget, it should always get or set it in the OptionMenu RowColumn, not the gadget itself.  To get or set other resources for the gadgets, the application should use ID="ch06192"ID="ch06193"ID="ch06194"ID="ch06195"XmOptionLabelGadget or XmOptionButtonGadget and then call ID="ch06196"ID="ch06197"XtGetValues or XtSetValues on the returned widget ID.  A user or application can also specify resource values in resource files by using the names of the gadgets, "OptionLabel" and "OptionButton".  ID="ch06198"ID="ch06199"ID="ch06200"ID="ch06201"Setting the XmNmenuHistory resource also has a special effect in OptionMenus.  Setting ID="ch06202"ID="ch06203"XmNmenuHistory to an item in the PulldownMenu makes that item the currently selected option.  It updates the label of the CascadeButtonGadget and causes the PulldownMenu to appear, when posted, with the selected item over the CascadeButtonGadget.  ID="ch06204"ID="ch06205"XmCreateOptionMenu creates an OptionMenu RowColumn and its LabelGadget and CascadeButtonGadget children.  It does not create the associated PulldownMenu.  ID="ch06206"ID="ch06207"ID="ch06208"ID="ch06209"ID="ch06210"ID="ch06211"The following example creates a simple OptionMenu with three options: ID="ch06212"† † Widget         parent, pulldown, option, pb1, pb2, pb3;
† † Arg            args[10];
† † Cardinal       n;
...
† † n = 0;
† † pulldown = XmCreatePulldownMenu(parent, "option_pd",
† †                                   args, n);
† † pb1 = XmCreatePushButtonGadget(pulldown, "option_pb1",
† †                                   args, n);
† † pb2 = XmCreatePushButtonGadget(pulldown, "option_pb2",
† †                                   args, n);
† † pb3 = XmCreatePushButtonGadget(pulldown, "option_pb3",
† †                                   args, n);
† † XtSetArg(args[n], XmNsubMenuId, pulldown);       n++;
† † XtSetArg(args[n], XmNmenuHistory, pb2);          n++;
† † option = XmCreateOptionMenu(parent, "option_rc", args, n);
...The following application-class defaults file provides labels and mnemonics for an English-language locale: *option_pb1.labelString   :   Option 1
*option_pb2.labelString   :   Option 2
*option_pb3.labelString   :   Option 3
*option_rc.labelString    :   Options
*option_rc.mnemonic       :   OLBL="6.6" HELPID=""RadioBox and CheckBoxID="ch06213"ID="ch06214"RadioBoxes and CheckBoxes are collections of ToggleButtons.  The difference is that in a RadioBox only one ToggleButton at a time can be set; in a CheckBox more than one ToggleButton can be set.  ID="ch06215"RadioBoxes and CheckBoxes are usually implemented as WorkAreas, though it is possible to implement them as menus.  Usually the application intends for the box to remain visible after the user sets a ToggleButton, particularly in a CheckBox.  The application can implement a transient RadioBox or CheckBox by placing a WorkArea inside a dialog.  ID="ch06216"ID="ch06217"ID="ch06218"ID="ch06219"The following RowColumn resources specifically control the behavior of a RadioBox or CheckBox: ID="ch06220"ID="ch06221"ID="ch06222"XmNradioBehavior When True, the RowColumn ensures that at most one ToggleButton is set at a time.  Setting this resource to True also causes the ToggleButton resource ID="ch06223"ID="ch06224"ID="ch06225"XmNindicatorType to default to XmONE_OF_MANY and ID="ch06226"ID="ch06227"XmNvisibleWhenOff to default to True.  ID="ch06228"XmNradioAlwaysOne When both this resource and ID="ch06229"XmNradioBehavior are True, RowColumn ensures that one ToggleButton is always set.  The user is not allowed to unset a ToggleButton when no other ToggleButton is set.  ID="ch06230"ID="ch06231"ID="ch06232"For a RadioBox implemented as a WorkArea, the default value for ID="ch06233"ID="ch06234"XmNisHomogeneous is True, and by default RowColumn allows only ToggleButton and ToggleButtonGadget children.  ID="ch06235"ID="ch06236"ID="ch06237"ID="ch06238"Note that the application can foil the RowColumn's enforcement of ID="ch06239"XmNradioBehavior and XmNradioAlwaysOne, even when these resources are True.  The application can use ID="ch06240"ID="ch06241"XtSetValues to set the state of the ToggleButtons, and it can manage and unmanage ToggleButtons regardless of their state.  The behavior of a RadioBox is undefined if the application takes actions that contradict ID="ch06242"ID="ch06243"ID="ch06244"XmNradioBehavior or XmNradioAlwaysOne.  XmCreateRadioBox creates a WorkArea RadioBox and initializes ID="ch06245"ID="ch06246"ID="ch06247"XmNradioBehavior to True.  ID="ch06248"A CheckBox is most often a collection of ToggleButtons in a WorkArea with ID="ch06249"ID="ch06250"ID="ch06251"XmNradioBehavior set to False.  By default, the ToggleButton ID="ch06252"XmNindicatorType is XmN_OF_MANY† †and ID="ch06253"ID="ch06254"XmNvisibleWhenOff is True.  ID="ch06255"LBL="6.7" HELPID=""TearOffMenusID="ch06256"An application can allow the user to "tear off" a PulldownMenu or PopupMenu.  When the user tears off a menu, Motif unposts that menu and any posted menu descendants.  It gives the menu a TransientShell parent and then maps the parent as a top-level window.  The torn-off menu has window-manager decorations, and its title is the label of the CascadeButton that posts the menu in the original menu system.  ID="ch06257"ID="ch06258"ID="ch06259"ID="ch06260"The user can interact with the torn-off menu just as in the menu hierarchy.  When the user activates buttons in a torn-off menu, the actions take effect but the torn-off menu remains posted.  When the user takes an action that unposts the torn-off menu, such as pressing KCancel, the menu returns to its original position in the menu hierarchy.  If the user reposts the original menu from the menu hierarchy while the torn-off menu is posted, an inactive representation of the torn-off menu remains visible, but the menu itself is unposted and then reposted within the menu hierarchy.  ID="ch06261"When a menu in a menu system can be torn off, a distinctive tear-off button appears at the beginning of the menu.  The user can tear off the menu by activating the tear-off button as with any other button in the menu.  The user can also tear off the menu by pressing BTransfer in the tear-off button.  The user can then drag the torn-off menu to another position on the screen and fix its position by releasing ID="ch06262"BTransfer.  Menus cannot be torn off by default.  The application must allow the user to tear off a menu by setting the RowColumn resource XmNtearOffModel to XmTEAR_OFF_ENABLED.  When the user tears off a menu, the ID="ch06263"ID="ch06264"ID="ch06265"XmNtearOffMenuActivateCallback† †callbacks are invoked just before the ID="ch06266"XmNmapCallback callbacks.  When the user unposts a torn-off menu, the ID="ch06267"XmNtearOffMenuDeactivateCallback callbacks are invoked just after the ID="ch06268"XmNunmapCallback callbacks.  ID="ch06269"LBL="7"ID="39367"DialogsID="ch071"Dialogs are container widgets that provide a means of communicating between the user and the application.  A dialog widget usually asks a question or presents some information to the user.  In some cases, the application is suspended until the user provides a response.  Dialogs are similar to menus.  Both seek input from the user.  Like PopupMenus and PulldownMenus, dialogs appear in top-level windows and are more or less transient.  Making a selection typically unposts a PopupMenu or PulldownMenu and often pops down a dialog.  There are two chief differences: ID="ch072"ID="ch073"Unless torn off, menus are usually modal: the user must make a selection from the menu or unpost it before interacting with other parts of the application.  Dialogs can be either modal or ID="ch074"modeless.  In a modeless dialog, the user can interact with other parts of the application before returning to the dialog.  ID="ch075"Menu components are limited to buttons, labels, and separators.  Dialogs can contain other, sometimes arbitrary, kinds of widgets, such as List and Text.  Dialogs permit more complex interaction with the user and allow the application to solicit a broader range of information.  Menus are well suited to allowing the user to make a single choice from a constrained set.  Dialogs are appropriate for displaying information about a transient or unusual state of the program and for obtaining complex input from the user.  Whether to use a dialog or a menu is not always clear.  In fact, a TearOffMenu combines aspects of both.  For more information on using menus and dialogs, see the ID="ch076"OSF/Motif Style Guide.  LBL="7.1" HELPID=""BulletinBoard and DialogShellID="ch077"ID="ch078"From the application's point of view, a dialog is a widget that is a subclass of XmBulletinBoard inside a DialogShell.  BulletinBoard is intended to be the usual superclass for a dialog widget.  The dialog widget can be either a BulletinBoard itself or one of its more specialized subclasses.  BulletinBoard is a container with no automatically created children; it supplies general behavior needed by most dialogs.  Its subclasses provide child widgets and specific behavior tailored to particular types of dialogs.  ID="ch079"ID="ch0710"ID="ch0711"BulletinBoard and its subclasses can also function outside a DialogShell, as part of the application's main window.  One subclass, Form, is particularly useful in providing constraint-based geometry management for a collection of child widgets.  ID="ch0712"ID="ch0713"ID="ch0714"LBL="7.1.1" HELPID=""BulletinBoardID="ch0715"BulletinBoard provides the following resources and behavior: Activation and cancellation of the dialog.  BulletinBoard installs accelerators for KActivate and ID="ch0716"ID="ch0717"KCancel.  Unless focus is in another button, ID="ch0718"KActivate activates the XmNdefaultButton if it is sensitive.  ID="ch0719"KCancel activates the XmNcancelButton if it is sensitive.  Subclasses set the ID="ch0720"XmNdefaultButton and XmNcancelButton.  ID="ch0721"A resource, XmNdialogStyle, that determines whether the dialog is modal or modeless.  Three modal styles exist: ID="ch0722"Primary application modalAmong the dialog and its ancestors, input goes only to the dialog, but the user can iteract with other parts of the application or with other applications.  Full application modalWithin the application, input goes only to the dialog, but the user can interact with other applications.  System modalInput goes only to the dialog; the user cannot interact with other applications.  Callbacks invoked when the BulletinBoard is mapped and unmapped and when it gains input focus.  ID="ch0723"Geometry-management resources and class methods that implement several resizing policies and that allow the BulletinBoard to interact with its subclasses in managing complex collections of descendant widgets.  The geometry-related resources are ID="ch0724"XmNmarginHeight, ID="ch0725"XmNmarginWidth and XmNresizePolicy.  For more information on BulletinBoard's geometry management, see ID="ch0726"ID="ch0727"IDREF="18723" TYPE="TITLE"Chapter 10, "Managing Geometry."LBL="7.1.2" HELPID=""Activation, Cancellation, and HelpID="ch0728"ID="ch0729"ID="ch0730"Often a dialog has one or more actions, associated with buttons, that apply to the dialog as a whole.  Some common actions are "activate," "cancel," and "help." BulletinBoard deals specially with activation and cancellation.  BulletinBoard allows the user to "activate" or "cancel" the dialog from anywhere within the BulletinBoard (except, in the case of activation, when a button has the focus).  ID="ch0731"BulletinBoard has a resource, XmNdefaultButton, whose value is a button descendant that represents the default activation action.  When the user presses ID="ch0732"ID="ch0733"KActivate in a button that has keyboard focus, that button's ID="ch0734"KActivate actions are called.  If the user presses KActivate and no button has focus, BulletinBoard calls the KActivate actions for the XmNdefaultButton if it is sensitive.  If the user presses KActivate in a List, Text, or TextField descendant, the ID="ch0735"ID="ch0736"ID="ch0737"KActivate actions for that widget are invoked first, and then BulletinBoard calls the KActivate actions for the XmNdefaultButton.  BulletinBoard has another resource, XmNcancelButton, whose value is a button descendant that represents the default cancellation action.  When the user presses ID="ch0738"ID="ch0739"KCancel anywhere within the BulletinBoard, BulletinBoard calls the ID="ch0740"KActivate actions for the ID="ch0741"XmNcancelButton if it is sensitive.  The help action works differently.  Often the application represents help for the dialog as a whole by providing a Help button.  When the user activates this button, the application provides help for the dialog.  In general the application can provide help through an XmNactivateCallback procedure for the Help button.  Some BulletinBoard subclasses create Help buttons automatically.  These widgets add a procedure to the Help button's ID="ch0742"ID="ch0743"XmNactivateCallback list that invokes the dialog's XmNhelpCallback procedures when the Help button is activated.  In these cases, the application can provide help through the dialog's ID="ch0744"XmNhelpCallback procedures.  If the user presses KHelp elsewhere in the BulletinBoard, this action usually invokes the ID="ch0745"ID="ch0746"XmNhelpCallback callbacks for the widget with the focus.  If this widget has no ID="ch0747"XmNhelpCallback procedures, Motif looks up the widget hierarchy for the first ancestor with a non-NULL XmNhelpCallback list and invokes those procedures.  By providing an XmNhelpCallback procedure for the dialog itself, the application can ensure that the user sees help for the dialog as a whole when the descendant widget with focus has no help information of its own.  LBL="7.1.3" HELPID=""DialogShellID="ch0748"DialogShell is the Motif shell widget that contains dialogs.  It is a subclass of TransientShell, which is a subclass of VendorShell.  DialogShell inherits much of VendorShell's behavior in interacting with the window manager and in providing geometry management for ID="ch0749"ID="ch0750"off-the-spot input methods.  DialogShell cooperates extensively with BulletinBoard, and some of DialogShell's features for containing dialogs assume that its child is a BulletinBoard or BulletinBoard subclass.  Often the application does not need to deal directly with the DialogShell at all.  The Motif convenience routines that create dialogs automatically create a DialogShell as the popup child of the parent shell.  ID="ch0751"ID="ch0752"To pop up the dialog, the application does not call XtPopup on the DialogShell, but instead manages the child of the DialogShell.  DialogShell's ID="ch0753"ID="ch0754"change_managed procedure pops up the dialog when the child is managed and pops it down when the child is unmanaged, providing that the child's ID="ch0755"ID="ch0756"XmNmappedWhenManaged resource is True.  If a BulletinBoard child's ID="ch0757"XmNautoUnmanage resource is initialized to True, the BulletinBoard is automatically unmanaged when its OK and cancel buttons are activated.  ID="ch0758"ID="ch0759"DialogShell notifies its BulletinBoard child using the ID="ch0760"ID="ch0761"XmNmapCallback and XmNunmapCallback procedures when the child is about to be mapped and unmapped.  ID="ch0762"ID="ch0763"Like VendorShell, DialogShell ensures that when no off-the-spot input  methodID="ch0764"ID="ch0765" exists the DialogShell window remains coincident with the child window.  Setting XmNx and XmNy for the child sets these resources for the shell, without changing the child's position relative to the child.  Setting ID="ch0766"ID="ch0767"XmNheight, XmNwidth and XmNborderWidth for the child usually sets these resources to the same value in the DialogShell.  When a BulletinBoard child is managed with its ID="ch0768"ID="ch0769"ID="ch0770"XmNdefaultPosition† †resource set to True, DialogShell centers the dialog with respect to the parent.  ID="ch0771"ID="ch0772"BulletinBoard has two resources that allow the user or application to customize a parent DialogShell's interaction with the window manager.  ID="ch0773"ID="ch0774"XmNdialogTitle provides a title for the window manager, and ID="ch0775"XmNnoResize determines whether or not the dialog MWM frame includes resize controls.  To affect other aspects of interaction with the window manager, the user or application must set the appropriate DialogShell resources.  ID="ch0776"XmCreateBulletinBoardDialog creates a BulletinBoard and a parent DialogShell.  ID="ch0777"ID="ch0778"ID="ch0779"ID="ch0780"LBL="7.1.4" HELPID=""Initial FocusID="ch0781"ID="ch0782"When the XmNkeyboardFocusPolicy of a shell is XmEXPLICIT, Motif uses the Manager resource ID="ch0783"ID="ch0784"XmNinitialFocus in determining which component of a manager receives initial focus in these circumstances: ID="ch0785"ID="ch0786"When the manager is the child of a shell and the shell hierarchy receives focus for the first time When focus is inside the shell hierarchy, the manager is a composite tab group, and the user traverses to the manager using the keyboard Following are the default values of XmNinitialFocus for BulletinBoard and its subclasses: ID="ch0787"ID="ch0788"For BulletinBoard, Form, and MessageBox, the default is the value of ID="ch0789"ID="ch0790"ID="ch0791"XmNdefaultButton† †ID="ch0792"For SelectionBox and its subclasses, the default is the text edit area ID="ch0793"LBL="7.2" HELPID=""Making a Selection: SelectionBoxID="ch0794"SelectionBox is a BulletinBoard subclass that generally allows the user to select an item from a list.  By default, a SelectionBox includes the following children: ID="ch0795"A scrolling list of alternatives An editable text field for the selected alternative Labels for the list and text field Three or four buttons The default buttons are OK, Cancel, and Help.  By default, an Apply button is also created.  If the parent of the SelectionBox is a DialogShell, it is managed; otherwise, it is unmanaged.  ID="ch0796"ID="ch0797"An application can add additional children to the SelectionBox.  The first child is used as a work area.  The value of ID="ch0798"XmNchildPlacement determines whether the work area is placed above or below the Text area, or above or below the List area.  Additional children are laid out in the following manner: ID="ch0799"MenuBarThe first MenuBar child is placed at the top of the window ID="ch07100"ButtonsAll XmPushButton widgets or gadgets and their subclasses are placed after the OK button in the order of their creation ID="ch07101"ID="ch07102"OthersThe layout of additional children that are not in these categories is undefined The user can select an item in two ways: by scrolling through the list and selecting the desired item or by entering the item name directly into the text edit area.  Selecting an item from the list causes that item name to appear in the selection text edit area.  SelectionBox installs accelerators, the value of ID="ch07103"XmNtextAccelerators, on the text edit widget.  The default accelerators bind ID="ch07104"KUp, KDown, KBeginLine, ID="ch07105"ID="ch07106"ID="ch07107"KEndLine, and KRestore events in the text edit widget to SelectionBox actions that select an item in the List and replace the text edit widget value with that List item.  ID="ch07108"ID="ch07109"ID="ch07110"ID="ch07111"SelectionBox provides XmNokCallback, XmNcancelCallback, ID="ch07112"ID="ch07113"ID="ch07114"XmNhelpCallback, and XmNapplyCallback lists, which the SelectionBox invokes when the corresponding button is activated.  Activation of the OK button may invoke either the ID="ch07115"ID="ch07116"XmNokCallback list or the XmNnoMatchCallback list.  When the user activates the OK button and either the ID="ch07117"XmNmustMatch† †resource is False or the text in the text edit area matches a List item, SelectionBox invokes the ID="ch07118"ID="ch07119"XmNokCallback procedures.  When the user activates the OK button, XmNmustMatch is True, and the text in the text edit area does not match a List item, SelectionBox invokes the XmNnoMatchCallback procedures.  SelectionBox has two subclasses, FileSelectionBox and Command, which are described in later sections.  ID="ch07120"ID="ch07121"ID="ch07122"XmCreateSelectionDialog creates a standard SelectionBox and a DialogShell parent.  ID="ch07123"ID="ch07124"ID="ch07125"XmCreatePromptDialog creates a variant SelectionBox dialog containing a text edit area and label and OK, Cancel, and Help buttons.  A PromptDialog has an unmanaged Apply button, and it has no List or List label.  It is intended for the application to prompt the user for brief text input.  ID="ch07126"ID="ch07127"The XmNdialogType resource determines which of the standard SelectionBox children are created and managed.  The value usually depends on the application's use of the SelectionBox: ID="ch07128"ID="ch07129"XmDIALOG_SELECTION usually indicates a standard SelectionBox dialog.  ID="ch07130"ID="ch07131"XmDIALOG_WORK_AREA indicates a SelectionBox outside a DialogShell.  The Apply button is unmanaged.  ID="ch07132"ID="ch07133"ID="ch07134"XmDIALOG_PROMPT indicates a PromptDialog.  ID="ch07135"ID="ch07136"XmDIALOG_COMMAND indicates a Command subclass.  ID="ch07137"ID="ch07138"XmDIALOG_FILE_SELECTION indicates a FileSelectionBox subclass.  ID="ch07139"ID="ch07140"SelectionBox has resources for supplying text, label strings, and list items for its children.  The widget IDs of the children of a SelectionBox and its subclasses are not available as resources.  The application can retrieve the widget IDs of the automatically created children by using ID="ch07141"XtNameToWidget or by calling one of the convenience routines Motif provides for this purpose: ID="ch07142"XmSelectionBoxGetChild, XmFileSelectionBoxGetChild, and ID="ch07143"ID="ch07144"XmCommandGetChild.  ID="ch07145"LBL="7.3" HELPID=""Choosing a Pathname: FileSelectionBoxID="ch07146"FileSelectionBox is a subclass of SelectionBox designed for finding and selecting files.  By default, a FileSelectionBox contains the same children as a standard SelectionBox, with the addition of a second ScrolledList, a second text edit area, and the corresponding labels.  By default, the Apply button is labeled "Filter".  ID="ch07147"ID="ch07148"One of the text areas, the directory mask area, holds a directory mask specifying a base directory to be searched and a search pattern.  The other text area, the selection area, holds the name of the selected file.  One of the Lists, the directory list, displays the subdirectories of the current base directory.  The other List, the file list, displays all the files, subdirectories, or both in the base directory that match the search pattern.  ID="ch07149"The user can select a new base directory to examine by scrolling through the list of directories and selecting the desired directory or by editing the directory mask.  Selecting a new directory from the directory list does not change the search pattern.  A user can select a new search pattern by editing the directory mask.  Double clicking or pressing KActivate on a directory in the directory list initiates a search for files and subdirectories in the new directory, using the current search pattern.  ID="ch07150"Activating the Filter button, the directory list, or the directory mask text area causes the FileSelectionBox to initiate a file search.  The FileSelectionBox uses three procedures, each the value of a resource, in conducting the search: the ID="ch07151"XmNqualifySearchDataProc, the ID="ch07152"XmNdirSearchProc and the XmNfileSearchProc.  The ID="ch07153"ID="ch07154"XmNqualifySearchDataProc extracts the base directory and the search pattern from the directory mask.  The XmNdirSearchProc uses the data returned by the XmNqualifySearchDataProc to update the directory list.  The XmNfileSearchProc uses the data returned by the XmNqualifySearchDataProc to update the file list.  The user can select a file by scrolling through the list of filenames and selecting the desired file or by entering the filename directly into the text edit area.  Selecting a file from the list causes that filename to appear in the file selection text edit area.  The user confirms the selection by activating the OK button, the file list, or the selection text area.  FileSelectionBox uses the SelectionBox callback lists to notify the application when the user activates one of the buttons.  The application can also provide one or more of the three procedures that FileSelectionBox uses to conduct a search.  For a specification of the input to and output from these routines, see the ID="ch07155"ID="ch07156"XmFileSelectionBox(3X) reference page in the OSF/Motif Programmer's Reference.  The application can remove the directory list, the file list, or both.  The application must unmanage the ScrolledWindow parent of the List and the corresponding label.  An application can also add additional children to a FileSelectionBox, which manages any additional children in the same way as SelectionBox.  ID="ch07157"ID="ch07158"ID="ch07159"ID="ch07160"XmCreateFileSelectionDialog creates a FileSelectionBox and a parent DialogShell.  ID="ch07161"ID="ch07162"ID="ch07163"ID="ch07164"LBL="7.4" HELPID=""CommandID="ch07165"Command is a SelectionBox subclass intended for entering a command.  It contains the SelectionBox text edit area, List, and List label, but no buttons.  The application can add only one additional work area child to the Command.  A Command usually appears as part of the application's main window rather than as a dialog.  ID="ch07166"ID="ch07167"The user specifies a command by adding text to the text area or by selecting an item from the List, which represents the command history.  Whenever the text edit area changes, Command invokes the ID="ch07168"ID="ch07169"XmNcommandChangedCallback procedures.  The user enters a command by activating the List or the text edit area.  When the user enters a command, Command appends the command to the history list and invokes the ID="ch07170"XmNcommandEnteredCallback procedures.  ID="ch07171"Command has a number of resources that are aliases for SelectionBox resources dealing with the List and text edit area.  Command also has an ID="ch07172"ID="ch07173"ID="ch07174"XmNhistoryMaxItems resource, which specifies the maximum length of the history list.  After the list reaches this length, Command deletes the first item in the list before appending a newly entered command.  ID="ch07175"LBL="7.5" HELPID=""MessageBoxID="ch07176"MessageBox is a BulletinBoard subclass intended for a dialog consisting of a single user interaction.  By default, a MessageBox has the following components: ID="ch07177"A LabelGadget with a pixmap label symbolizing the type of interaction the MessageBox represents ID="ch07178"ID="ch07179"A LabelGadget with a compound string label representing the text of the message ID="ch07180"A SeparatorGadget separating the message symbol and text from the other children ID="ch07181"Three buttons: OK, Cancel, and Help Typically the message symbol and text are on top and the buttons on the bottom, with the separator between.  The application can add additional children to a MessageBox.  Additional children are laid out in the following manner: ID="ch07182"The first MenuBar child is placed at the top of the window.  ID="ch07183"All XmPushButton widgets or gadgets, and their subclasses are placed after the OK button in the order of their creation.  ID="ch07184"ID="ch07185"A child that is not in these categories is treated as a work area and is placed above the row of buttons.  If a message label exists, the child is placed below the label.  If a message pixmap exists, but a message label is absent, the child is placed on the same row as the pixmap.  The child behaves as a work area and grows or shrinks to fill the space above the row of buttons.  The layout of multiple work area children is undefined.  Several convenience routines create MessageBox widgets with DialogShell parents for particular kinds of interactions.  For most of these routines, the principal difference in the type of MessageBox they create is that each uses a distinct default symbol pixmap.  When it creates the symbol pixmap, MessageBox uses ID="ch07186"ID="ch07187"XmGetPixmapByDepth to find a pixmap with a name that corresponds to the type of interaction.  Each dialog type is also associated with a value of the ID="ch07188"XmNdialogType resource.  The following table shows the correspondence between creation routine, ID="ch07189"XmNdialogType, and symbol pixmap name:ID="ch07190"ID="ch07191"ID="ch07192"ID="ch07193"ID="ch07194"ID="ch07195"ID="ch07196"ID="ch07197"ID="ch07198"ID="ch07199"ID="ch07200"ID="ch07201"ID="ch07202"ID="ch07203"COLUMNS="3"LEFT="0" WIDTH="129"Convenience RoutineLEFT="135" WIDTH="136"XmNdialogTypeLEFT="280" WIDTH="356"Pixmap NameLEFT="0" WIDTH="129"XmCreateErrorDialogLEFT="135" WIDTH="136"XmDIALOG_ERRORLEFT="280" WIDTH="356"xm_errorLEFT="0" WIDTH="129"XmCreateInformationDialogLEFT="135" WIDTH="136"XmDIALOG_INFORMATIONLEFT="280" WIDTH="356"xm_informationLEFT="0" WIDTH="129"XmCreateMessageDialogLEFT="135" WIDTH="136"XmDIALOG_MESSAGELEFT="280" WIDTH="356"LEFT="0" WIDTH="129"XmCreateQuestionDialogLEFT="135" WIDTH="136"XmDIALOG_QUESTIONLEFT="280" WIDTH="356"xm_questionLEFT="0" WIDTH="129"XmCreateTemplateDialogLEFT="135" WIDTH="136"XmDIALOG_TEMPLATELEFT="280" WIDTH="356"LEFT="0" WIDTH="129"XmCreateWarningDialogLEFT="135" WIDTH="136"XmDIALOG_WARNINGLEFT="280" WIDTH="356"xm_warningLEFT="0" WIDTH="129"XmCreateWorkingDialogLEFT="135" WIDTH="136"XmDIALOG_WORKINGLEFT="280" WIDTH="356"xm_workingLBL="7-1"Table 7-1 MessageBox Routines, Dialog Types, and PixmapsA MesssageDialog and a TemplateDialog have no default symbol pixmap.  A TemplateDialog is a special MessageBox variant that is intended for application customization and that, by default, has no children except the separator. ID="ch07204"ID="ch07205"Like SelectionBox, MessageBox has XmNokCallback, XmNcancelCallback, and XmNhelpCallback lists to inform the application when the user activates a button.  MessageBox has resources for supplying label strings and the symbol pixmap for its children.  The widget IDs of the children of a MessageBox are not available as resources.  The application can retrieve the widget IDs of the automatically created children by using XtNameToWidget or by calling XmMessageBoxGetChildID="ch07206".LBL="7.6" HELPID=""FormID="ch07207"Form is a BulletinBoard subclass whose main purpose is to provide constraint-based geometry management for arbitrary children.  Form has a number of constraint resources that it uses to place children with respect to the Form, positions within the form, and other children.  Most Form-specific behavior is related to this geometry management.  Form has no default children of its own.  But as a BulletinBoard subclass, Form is an appropriate container for use in dialogs.  ID="ch07208"XmCreateFormDialog creates a Form and a DialogShell parent.  ID="ch07209"ID="ch07210"ID="ch07211"For information on Form's geometry management, see IDREF="18723" TYPE="TITLE"Chapter 10, "Managing Geometry."
† †LBL="8"ID="24337"TextID="ch081"OSF/Motif has widgets for displaying two kinds of text: static text, as in labels and messages, and editable text.  Static text usually appears in Label widgets or Label subclasses, including buttons, and in Lists.  The application or user can specify initial text for Labels or Lists using resource or UIL files, but the user cannot edit the text.  The application can replace the text during the program by setting the appropriate resources.  In Labels and Label subclasses and in Lists, Motif represents text as compound strings.  These are byte streams that contain the text itself and tags that the toolkit matches with tags in font lists in order to select the appropriate fonts or font sets to display the text.  ID="ch082"ID="ch083"For editing text, Motif provides Text and TextField widgets.  The displayed text in these widgets may or may not be editable, depending on the value of the ID="ch084"ID="ch085"XmNeditable resource.  When the Text is editable and the user enters a text character, that character is inserted into the text.  Other translations and actions allow the user to navigate or to select, cut, copy, paste, or scroll the text.  In Text and TextField widgets, Motif represents text as strings of either multibyte (ID="ch086"char) or wide (wchar_t) characters.  The Text widget uses a single font or font set from a font list to display the text.  ID="ch087"ID="ch088"This chapter discusses the Text and TextField widgets.  Labels and their subclasses are discussed in ID="ch089"ID="ch0810"IDREF="18979" TYPE="TITLE"Chapter 5, "Basic Controls,"
 and compound strings, font lists, and ID="ch0811"localization of text are discussed in IDREF="22857" TYPE="TITLE"Chapter 11, "Internationalization."
  It is possible for an application to construct its own text-editing widget using a DrawingArea.  This is discussed in ID="ch0812"IDREF="13837" TYPE="TITLE"Chapter 14, "Graphics and Text in a DrawingArea."LBL="8.1" HELPID=""Text and TextFieldID="ch0813"ID="ch0814"The text in a Text widget can be multiline or constrained to be a single line, depending on the value of the XmNeditMode resource.  In multiline Text, pressing ID="ch0815"KUp moves the insertion cursor, the point at which new text is inserted, to the previous line, and pressing ID="ch0816"KDown moves the insertion cursor to the next line.  Other actions move the insertion cursor forward and backward by paragraphs.  Pressing ID="ch0817"KSpace, KTab, or KEnter causes the corresponding character to be inserted into the text.  For this reason, some virtual key bindings are different in Text from those in other widgets, as shown in the following table: ID="ch0818"ID="ch0819"ID="ch0820"COLUMNS="2"LEFT="0" WIDTH="72"Virtual KeyLEFT="80" WIDTH="356"Actual Key EventsLEFT="0" WIDTH="72"KActivateLEFT="80" WIDTH="356"Ctrl<Key>Return<Key>osfActivateLEFT="0" WIDTH="72"KExtendLEFT="80" WIDTH="356"Ctrl Shift<Key>spaceShift<Key>osfSelectLEFT="0" WIDTH="72"KNextFieldLEFT="80" WIDTH="356"Ctrl<Key>TabLEFT="0" WIDTH="72"KSelectLEFT="80" WIDTH="356"Ctrl<Key>space<Key>osfSelectLBL="8-1"Table 8-1 Text Virtual Key BindingsIn a single-line widget, pressing KSpace still inserts a space into the text.  However, ID="ch0821"KUp and KDown now move keyboard focus to the previous or next traversable widget, and ID="ch0822"ID="ch0823"KTab traverses to the next tab group.  ID="ch0824"KEnter invokes the XmNactivateCallback callbacks.  The actions for moving by paragraphs have no effect.  In other words, a single-line Text widget acts more as a simple control than a field control.  ID="ch0825"ID="ch0826"ID="ch0827"A TextField is essentially the same as a Text widget in single-line mode, except that its performance is optimized for single-line text operations.  Although TextField has a complete set of convenience routines of its own, the widget argument to the Text convenience routines can be either a Text or a TextField widget.  ID="ch0828"ID="ch0829"LBL="8.2" HELPID=""SelectionID="ch0830"Both Text and TextField allow the user to cut, copy, and paste text using the clipboard, primary transfer, or secondary transfer.  The user can also drag and drop text within a widget, between widgets, or from a Label or List widget to a Text or TextField widget.  In all cases, the user first selects text in some widget and then inserts the selected text into a Text or TextField widget.  ID="ch0831"ID="ch0832"ID="ch0833"ID="ch0834"This section explains how selection works in Text and TextField.  Understanding selection requires understanding of several concepts: ID="ch0835"ID="ch0836"primary selection, secondary selection, clipboard selectionID="ch0837"ID="ch0838"ID="ch0839"ID="ch0840", the destination widget, the insertion cursor, the selection ID="ch0841"ID="ch0842"ID="ch0843"ID="ch0844"ID="ch0845"anchor, and pending delete.  ID="ch0846"ID="ch0847"Selections are the primary means of exchanging data between X clients.  A selection is a piece of data.  Each display may have several kinds of selections, but only one selection of each kind can exist at any time on the display.  A client owns each selection, and the selection is attached to a window.  Clients can acquire or give up ownership of a selection and can request that the owner convert the selection into some data type and place the results on a property of a particular window.  This mechanism makes it possible to select and then cut, copy, or paste data from one client to another.  Selections are discussed in detail in the X Window System ID="ch0848"Inter-Client Communication Conventions Manual (ICCCM).  Text and TextField support transfers using the three kinds of selection common to all X clients: ID="ch0849"ID="ch0850"PrimaryThe primary selection is the principal selection on the display.  Unless they are qualified, the terms ID="ch0851"ID="ch0852"selecting text and the selection refer to the primary selection.  SecondaryThe secondary selection is used to transfer data without disturbing the primary selection.  Text and TextField use the secondary selection for ID="ch0853"ID="ch0854"quick transfer, in which the user selects and then moves or copies text using a single series of mouse gestures.  ID="ch0855"ID="ch0856"ClipboardThe clipboard selection usually holds data cut or copied from one client and available to be pasted into another.  Text and TextField provide actions for cutting and copying text to the clipboard and for pasting text from the clipboard.  ID="ch0857"ID="ch0858"ID="ch0859"ID="ch0860"The destination is the widget that, at any particular time, would receive the selection if the user were to invoke a move, copy, or paste operation.  A Text or TextField widget must be both sensitive and editable to become the destination.  When the ID="ch0861"ID="ch0862"ID="ch0863"XmNkeyboardFocusPolicy of the shell is XmEXPLICIT, an editable widget becomes the destination when it receives keyboard focus.  When the ID="ch0864"ID="ch0865"XmNkeyboardFocusPolicy is XmPOINTER, an editable widget becomes the destination when it receives any mouse button or keyboard input.  If the destination widget becomes insensitive or uneditable, there is no destination widget.  ID="ch0866"The insertion cursor is an I-beam cursor that shows where text, including a selection, would be inserted in a Text or TextField widget.  The insertion cursor appears as a solid I-beam when the widget is in ID="ch0867"ID="ch0868"ID="ch0869"ID="ch0870"normal mode (explained below) and when it is either the widget with keyboard focus or the destination widget.  Otherwise, the insertion cursor appears as a stippled I-beam.  ID="ch0871"The anchor is a position in the text of a widget that marks one boundary of a selection or a potential selection.  For example, the user can select a range of text by pressing, dragging, and releasing ID="ch0872"BSelect.  The anchor is set at the point of the button press, and the selection extends to the point of the button release.  When the user takes an action to extend an existing selection, Motif first adjusts the anchor using a balance-beam method: it moves the anchor to the end of the existing selection that is farthest from the point of the button or key press that initiates the extend action.  ID="ch0873"Text and TextField have an XmNpendingDelete resource.  When the value of this resource is True, as it is by default, some user actions cause a selection to be deleted.  When a selection exists and the insertion cursor is not disjoint from it, an operation that inserts text, including a transfer of the secondary or clipboard selection, deletes the primary selection before inserting the text.  Also, when a selection exists and the insertion cursor is not disjoint from it, an operation that deletes text deletes the primary selection instead of the text that would otherwise be removed.  When ID="ch0874"ID="ch0875"ID="ch0876"XmNpendingDelete is False, these operations do not delete the selection.  LBL="8.2.1" HELPID=""Mouse SelectionID="ch0877"ID="ch0878"The user makes a primary selection with BSelect.  Pressing ID="ch0879"BSelect deselects any existing selection and moves the insertion cursor and the anchor to the position in the text where the button is pressed.  Dragging BSelect selects all text between the anchor and the pointer position, deselecting any text outside that range.  Releasing BSelect moves the insertion cursor to the position where the button is released.  Clicking BSelect deselects any existing selection and moves the insertion cursor and the anchor to the position where BSelect is released.  BExtend extends a selection using the balance-beam method.  When the user presses ID="ch0880"BExtend, the selection becomes anchored at the edge of the selection farthest from the pointer position.  When the user releases BExtend, the selection extends from the anchor to the position where BExtend is released, and any text outside that range is deselected.  The insertion cursor moves to the position where BExtend is released.  Clicking BToggle moves the insertion cursor to the position where ID="ch0881"BToggle is released without affecting the selection.  Clicking BTransfer moves the insertion cursor to the position where ID="ch0882"BTransfer is released.  Then, unless the insertion cursor is in the midst of the selection, it copies the primary selection to the insertion cursor and moves the insertion cursor to the end of the copied text.  The original selection remains selected.  Clicking MShift BTransfer has the same effect except that it moves the primary selection to the insertion cursor, deleting the original selection if possible.  ID="ch0883"Dragging MAlt BTransfer outside of the primary selection starts a secondary selection consisting of all text between the position of the pointer and the position where ID="ch0884"MAlt BTransfer was pressed.  Releasing MAlt BTransfer copies the secondary selection to the insertion cursor in the destination widget.  Before copying the secondary selection, if the destination contains the primary selection and the insertion cursor is not disjoint from it, releasing MAlt BTransfer deletes the primary selection.  Dragging MAlt MShift BTransfer also makes a secondary selection, and releasing ID="ch0885"MAlt MShift BTransfer moves the secondary selection to the destination widget.  Dragging BTransfer with the insertion cursor positioned within a primary selection initiates a drag operation.  The user may press a modifier key to indicate whether the drag is a copy, move, or link operation.  Releasing ID="ch0886"BTransfer either in the same Text widget or a different widget moves the insertion cursor to the position where ID="ch0887"BTransfer is released, drops the selected text at that point, and moves the insertion cursor to the end of the dropped text.  Pressing KCancel during the operation aborts the operation and no data exchange occurs.  If the user presses ID="ch0888"KHelp over a drop site, the user has the option to continue or to cancel the drop operation in response to the help information that the application provides.  ID="ch0889"LBL="8.2.2" HELPID=""Keyboard SelectionID="ch0890"ID="ch0891"Selection operations available with the mouse, except secondary selection, are also available from the keyboard.  Text has two keyboard selection modes, Normal Mode and Add Mode.  In Normal Mode, if text is selected, a navigation operation deselects the selected text and moves the anchor to the current position of the insertion cursor before navigating.  In Add Mode, navigation operations have no effect other than navigation.  In both modes, pressing ID="ch0892"ID="ch0893"ID="ch0894"KSelect has the same effect as pressing ID="ch0895"BSelect at that position.  ID="ch0896"In Normal mode, when the widget contains the primary selection and the insertion cursor is disjoint from it, any operation that inserts or pastes text into the widget (except a transfer of the primary selection from the same widget) first deselects the primary selection.  In Add Mode, such an operation does not deselect the primary selection.  Pressing KExtend extends the current selection to the insertion cursor using the balance-beam method.  The current selection becomes anchored at the edge of the selection farthest from the insertion cursor.  The selection then extends from the anchor to the insertion cursor, and any text outside that range is deselected.  ID="ch0897"Shifted navigation operations also extend a selection.  In Normal Mode, if no text is selected, a shifted navigation operation moves the anchor to the insertion cursor, navigates, selects the navigated text, and deselects any text outside that range.  In the remaining casesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Normal Mode and Add Mode with any selectionname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'a shifted navigation operation extends the selection using the balance-beam method.  Before navigation, the current selection becomes anchored at the edge of the selection farthest from the insertion cursor.  After navigation, the selection extends from the anchor to the insertion cursor, and any text outside that range is deselected.  KPrimaryCopy copies the primary selection to the insertion cursor.  ID="ch0898"KPrimaryCut cuts the primary selection to the insertion cursor.  ID="ch0899"KCopy copies the current selection in the Text widget to the clipboard; ID="ch08100"ID="ch08101"KCut cuts the selection; and KPaste inserts the contents of the clipboard at the insertion cursor.  ID="ch08102"ID="ch08103"LBL="8.3" HELPID=""Text Editing and CallbacksID="ch08104"ID="ch08105"Text has a number of callback lists for communication with the application.  Text invokes callbacks whenever the widget gains or loses focus, when it gains or loses the primary selection, before the insertion cursor is moved or text is modified, and when the text string changes or the activate() action is invoked.  ID="ch08106"Text passes these callbacks a pointer to either an ID="ch08107"XmAnyCallbackStruct or an XmTextVerifyCallbackStruct (or ID="ch08108"ID="ch08109"XmTextVerifyCallbackStructWcs) structure.  The two verification structures contain the current and new positions of the insertion cursor, the starting and ending positions of the text to be modified, a pointer to an ID="ch08110"XmTextBlockRec (or ID="ch08111"XmTextBlockRecWcs) structure with information about the text to be modified, and a Boolean in/out ID="ch08112"doit member that the callback procedure can set to tell the widget whether or not to go ahead with the modification.  Following is a summary of the callbacks: XmNmotionVerifyCallback Text invokes this list, passing a pointer to an ID="ch08113"ID="ch08114"XmTextVerifyCallbackStruct as the widget data, before moving the insertion cursor.  The application can prevent the action by setting the ID="ch08115"doit member of the callback struct to False.  XmNmodifyVerifyCallback or XmNmodifyVerifyCallbackWcs Text invokes this list, passing a pointer to an ID="ch08116"ID="ch08117"ID="ch08118"XmTextVerifyCallbackStruct structure (or an ID="ch08119"XmTextVerifyCallbackStructWcs structure) as the widget data, before deleting or inserting any text.  The application can prevent the action by setting the ID="ch08120"doit member of the callback struct to False.  XmNvalueChangedCallback Text invokes this list, passing a pointer to an ID="ch08121"ID="ch08122"XmAnyCallbackStruct as the widget data, after text is inserted or deleted.  ID="ch08123"XmNfocusCallback Text invokes this list, passing a pointer to an ID="ch08124"ID="ch08125"XmAnyCallbackStruct as the widget data, when the widget gains input focus.  ID="ch08126"XmNlosingFocusCallback Text invokes this list, passing a pointer to an ID="ch08127"ID="ch08128"XmTextVerifyCallbackStruct as the widget data, before the widget loses input focus.  The application can prevent the action by setting the ID="ch08129"doit member of the callback struct to False.  XmNgainPrimaryCallback Text invokes this list, passing a pointer to an ID="ch08130"ID="ch08131"XmAnyCallbackStruct as the widget data, when the widget gains ownership of the primary selection.  ID="ch08132"XmNlosePrimaryCallback Text invokes this list, passing a pointer to an ID="ch08133"ID="ch08134"XmAnyCallbackStruct as the widget data, when the widget loses ownership of the primary selection.  ID="ch08135"XmNactivateCallback Text invokes this list, passing a pointer to an ID="ch08136"ID="ch08137"XmAnyCallbackStruct as the widget data, when the activate()† †action is invoked.  By default no translations are bound to this action, but in a single-line Text widget or a TextField widget, pressing ID="ch08138"ID="ch08139"KEnter† †invokes theID="ch08140"ID="ch08141"XmNactivateCallback  callbacks.  ID="ch08142"These callbacks provide a great deal of flexibility for an application to alter the behavior of the Text widget.  For example, an application can prevent text from being inserted, as when the user types a password, using the ID="ch08143"XmNmodifyVerifyCallback or XmNmodifyVerifyCallbackWcs† †callbacks.  The application can prevent any text from appearing by setting the ID="ch08144"ID="ch08145"doit member of the XmTextVerifyCallbackStruct (or ID="ch08146"XmTextVerifyCallbackStructWcs) to False.  The application can also alter the text that will appear by creating a new text string and setting the ID="ch08147"ptr member of the XmTextBlockRec† †structure (or the ID="ch08148"wcsptr member of the XmTextBlockRecWcs† †structure) to the new string.  ID="ch08149"Following is an example of an XmNmodifyVerifyCallback that substitutes a string of characters for any text a user enters.  Because the ID="ch08150"XmNmodifyVerifyCallback procedures are most commonly invoked after the user enters a character, this routine usually substitutes the replacement string for each character the user types.  This example could be used with a single-line Text widget as part of a simple password-entry program.  In this case, the ID="ch08151"XmNmodifyVerifyCallback procedure would need additional code to save the characters the user types, and the program would need an XmNactivateCallback procedure to check whether the saved characters match the password.  ID="ch08152"/* XmNmodifyVerifyCallback procedure that
† †* replaces text the user enters
† †* with a replacement string passed in as
† †* application data. */
void ModifyVerifyCB(Widget w, XtPointer app_data,
† †        XtPointer widget_data)
{
† † char *replace_string = (char *) app_data;
† † XmTextVerifyCallbackStruct *widget_info =
† †   (XmTextVerifyCallbackStruct *) widget_data;
† † if (widget_info->text->length > 0) {
† †   widget_info->text->length = strlen(replace_string);
† †   widget_info->text->ptr = replace_string;
† † }
}Text and TextField differ from most other Motif widgets in that calling some convenience routines and setting some resources causes the widget to invoke callback procedures.  In general ID="ch08153"ID="ch08154"Setting resources or calling convenience routines that change the contents of the text invokes the XmNmodifyVerifyCallback and ID="ch08155"XmNmodifyVerifyCallbackWcs callbacks.  If these procedures allow the text to be modified, the ID="ch08156"XmNvalueChangedCallback callbacks are invoked.  ID="ch08157"Setting resources or calling convenience routines that change the position of the insertion cursor invokes the XmNmotionVerifyCallback callbacks.  ID="ch08158"Setting resources or calling convenience routines that cause the widget to gain the primary selection invokes the XmNgainPrimaryCallback† †callbacks.  ID="ch08159"Setting resources or calling convenience routines that cause the widget to lose the primary selection invokes the XmNlosePrimaryCallback† †callbacks.  ID="ch08160"If the application needs to distinguish between callbacks invoked as a result of user action and callbacks invoked as a result of application action (such as setting a resource or calling a convenience routine), it needs to set a flag before taking the application action and clear the flag afterward.  LBL="8.4" HELPID=""Text Resources and GeometryID="ch08161"ID="ch08162"In addition to the resources discussed in the previous section, Text has many others, including the following: The text itself, XmNvalue or XmNvalueWcs.  The text is represented to the application as an array of either ID="ch08163"ID="ch08164"char elements (for XmNvalue) or wchar_t elements (for ID="ch08165"ID="ch08166"ID="ch08167"XmNvalueWcs).  The application can set or get either resource.  Resources representing the insertion cursor position and blink rate, the position of text at the top of the window, and whether the insertion cursor is always visible.  A text position (of type XmTextPosition) is an integer representing the number of characters from the beginning of the buffer.  ID="ch08168"A resource (XmNmaxLength) representing the maximum length of the text string that the user can enter.  ID="ch08169"A resource (XmNwordWrap) that specifies whether lines are broken at word boundaries.  Breaking a line at a word boundary does not insert a newline into the text.  ID="ch08170"In addition, Text and TextField have several resources that determine the geometry of the widget: ID="ch08171"ID="ch08172"Two resources, XmNmarginHeight and XmNmarginWidth, that determine the margins between the text and the shadow, if present.  Text and TextField also use the Primitive resources that determine shadow and highlight appearance.  ID="ch08173"ID="ch08174"ID="ch08175"ID="ch08176"ID="ch08177"The font list (XmNfontList) that the widget uses to select a font or font set to display the text.  ID="ch08178"Resources that specify the number of rows of text (XmNrows) and the number of horizontal character positions (ID="ch08179"XmNcolumns).  Single-line Text and TextField always have one row.  ID="ch08180"ID="ch08181"ID="ch08182"Resources that determine whether or not the widget grows vertically (XmNresizeHeight) or horizontally (XmNresizeWidth) to accommodate all its text.  ID="ch08183"ID="ch08184"XmNresizeHeight does not apply to single-line Text or TextField.  ID="ch08185"ID="ch08186"ID="ch08187"Resources that apply only when the widget is inside a ScrolledWindow whose XmNvisualPolicy is ID="ch08188"XmVARIABLE.  ID="ch08189"XmNscrollHorizontal determines whether or not the widget should have a horizontal ScrollBar and should scroll horizontally instead of growing when the text expands beyond the width allocated for it.  ID="ch08190"ID="ch08191"XmNscrollVertical determines whether or not the widget should have a vertical ScrollBar and should scroll vertically instead of growing when the text expands beyond the height allocated for it.  ID="ch08192"XmNscrollLeftSide and XmNscrollTopSide determine which side of the widget receives the corresponding ScrollBar.  These resources do not apply to TextField, and ID="ch08193"ID="ch08194"XmNscrollVertical† †and ID="ch08195"XmNscrollLeftSide do not apply to single-line Text.  ID="ch08196"XmNresizeWidth is initialized to False when ID="ch08197"XmNscrollHorizontal is True or XmNwordWrap is True.  ID="ch08198"ID="ch08199"XmNresizeHeight is initialized to False when ID="ch08200"XmNscrollVertical is True.  ID="ch08201"If the user or application initializes or sets a specific height (XmNheight) or width (XmNwidth), that value is used as the corresponding dimension of the widget.  In addition, if a height is specified, ID="ch08202"ID="ch08203"XmNrows is recalculated based on that height, and if a width is specified, ID="ch08204"XmNcolumns is recalculated based on that width.  ID="ch08205"If the user or application initializes or sets XmNrows but not ID="ch08206"XmNheight, the geometry calculation depends on the value of ID="ch08207"XmNresizeHeight.  If ID="ch08208"XmNresizeHeight is True, the height of the widget is the greater of the height needed to display XmNrows of text and the height needed to display all the text.  If  XmNresizeHeight is False, as it is by default, the height of the widget is the height needed to display all the text.  The same relations hold for XmNcolumns, XmNwidth, and ID="ch08209"ID="ch08210"XmNresizeWidth.  ID="ch08211"If the user or application does not initialize either XmNrows or ID="ch08212"XmNheight, the geometry calculation depends on the value of ID="ch08213"XmNresizeHeight.  If ID="ch08214"XmNresizeHeight is True, the height of the widget is the height needed to display all the text.  If  XmNresizeHeight is False, the height of the widget is the height needed to display the default for XmNrows, which is one row of text.  The same relations hold for XmNcolumns, XmNwidth, and ID="ch08215"ID="ch08216"XmNresizeWidth, except that the default number of columns is 20.  ID="ch08217"If the contents of the text (XmNvalue or XmNvalueWcs) change, as a result of user editing or an action by the application, the geometry calculation depends on the value of ID="ch08218"ID="ch08219"XmNresizeHeight.  If ID="ch08220"XmNresizeHeight is True, the height of the widget is the height needed to display all the text.  If  ID="ch08221"XmNresizeHeight is False, the height of the widget does not change.  The same relations hold for XmNvalue, XmNvalueWcs, XmNresizeWidth, and the width of the widget.  ID="ch08222"If the application sets another resource that affects the height needed by the widget, such as XmNmarginHeight or XmNfontList, the geometry calculation depends on the value of ID="ch08223"ID="ch08224"XmNresizeHeight.  If ID="ch08225"XmNresizeHeight is True, the height of the widget is the height needed to display all the text with the new resource values.  If  XmNresizeHeight is False, the height of the widget is the height needed to display XmNrows of text using the new resources.  The same relations hold for these resources, ID="ch08226"XmNresizeWidth, ID="ch08227"XmNcolumns, and the width of the widget.  ID="ch08228"LBL="8.5" HELPID=""Convenience RoutinesText has convenience routines to permit the application to perform many functions, including these: ID="ch08229"Insert and replace text.  Cut, copy, and paste using the clipboard.  Get and set the editable state, the insertion cursor position, the maximum length of text, the primary selection and its position, the source, the text string, and the position of the first character displayed.  All routines that have parameters or return values that are strings have both char * and wchar_t * versions.  ID="ch08230"ID="ch08231"Convert between a text position and x and y coordinates.  Display text at a given position and scroll the text.  LBL="8.6" HELPID=""ScrolledTextID="ch08232"ScrolledText is a Text widget inside a ScrolledWindow.  The application can use ID="ch08233"ID="ch08234"XmCreateScrolledText to create one.  This routine creates both Text and ScrolledWindow widgets and forces the following initial values for ScrolledWindow resources: ID="ch08235"XmNscrollingPolicy is set to XmAPPLICATION_DEFINED.  ID="ch08236"ID="ch08237"XmNvisualPolicy is set to XmVARIABLE.  ID="ch08238"ID="ch08239"XmNscrollBarDisplayPolicy is set to XmSTATIC.  ID="ch08240"ID="ch08241"XmNshadowThickness is set to 0.  ID="ch08242"LBL="8.7" HELPID=""Storing Text in a FileID="ch08243"A common requirement of many text editors is the ability to read text from a file, allow the user to edit the text, and then store the text in a file.  An application usually obtains pathnames from the user by means of a FileSelectionBox, often invoked as a dialog from a MenuBar File Menu.  Following are very simple routines that use ANSI C input/output facilities to read text from a file into a Text widget and save text from a Text widget into a file: ID="ch08244"ID="ch08245"void ReadTextFromFile(Widget w, char *filename)
{
† † FILE           *file;
† † char            buffer[MAXSIZE];
† † char           *ptr, *end;
† † XmTextPosition  last_pos;
† † if (file = fopen(filename, "r")) {
† †   XmTextSetString(w, "");
† †   ptr = buffer;
† †   end = buffer + MAXSIZE - 1;
† †   while((val = getc(file)) != EOF) {
† †     if (ptr < end) {
† †       *ptr++ = (char) val;
† †     } else {
† †       *ptr = '\0';
† †       last_pos = XmTextGetLastPosition(w);
† †       XmTextReplace(w, last_pos, last_pos, buffer);
† †       ptr = buffer;
† †     }
† †   }
† †   if (ptr > buffer) {
† †     *ptr = '\0';
† †     last_pos = XmTextGetLastPosition(w);
† †     XmTextReplace(w, last_pos, last_pos, buffer);
† †   }
† †   (void) fclose(file);
† † }
}
void SaveTextToFile(Widget w, char *filename)
{
† † FILE     *file;
† † char     *text;
† † if (file = fopen(filename, "w")) {
† †   text = XmTextGetString(w);
† †   (void) fputs(text, file);
† †   (void) fclose(file);
† †   XtFree(text);
† † }
}LBL="8.8" HELPID=""Sharing Text SourcesID="ch08246"Each Text widget has a data structure of type XmTextSource that functions as the source and sink of text for the widget.  The source is the value of the ID="ch08247"XmNsource resource.  ID="ch08248"Two or more Text widgets can share the same source.  In this case, editing of Text in one widget changes the text of the source and therefore the text of all widgets that share that source.  For example, an application might use a PanedWindow with multiple text widgets, each functioning as a "window" onto a single text source.  Editing changes in one pane are reflected in all Text panes that share the same source.  ID="ch08249"ID="ch08250"An application creates a Text source by creating a Text widget.  The program uses ID="ch08251"XmTextGetSource or XtGetValues for the ID="ch08252"ID="ch08253"XmNsource resource to obtain that widget's source.  The application then creates another Text widget, supplying the source obtained from the first widget using ID="ch08254"XmTextSetSource, the initialization argument list, or ID="ch08255"XtSetValues of the ID="ch08256"XmNsource resource.  Setting a Text source destroys the existing source of the widget if no other widgets are sharing that source.  To replace a Text source but keep it for later use, the application can create an unmanaged Text widget and set its source to the Text source the program wants to keep.  ID="ch08257"If the application does not supply a source, Text creates a default string source.  ID="ch08258"LBL="9"ID="21296"Scrolling, Panes, and FramesIDREF="11089" TYPE="TITLE"Chapter 6, "Menus and Options" and IDREF="39367" TYPE="TITLE"Chapter 7, "Dialogs"
 discuss the OSF/Motif Manager widgets used to construct menus and dialogs.  Motif also provides more general-purpose managers intended for use in main application windows and some dialogs.  This chapter discusses widgets that perform the following functions: Establishing a viewport for a larger underlying scroll Providing a main application window with a combination of standard and custom components Placing a shadowed frame around a widget and an optional title at the top Creating multiple subwindows for a composite with adjustable boundaries between the subwindows LBL="9.1" HELPID=""ScrolledWindowID="ch091"Frequently a collection occupies an area that is too large to display within an application or that may grow or shrink as the user adds or deletes data.  Examples include text in a Text widget, items in a List, and graphical objects in a DrawingArea or other canvas.  Three approaches exist for handling this problem: Set a fixed size for the widget.  The disadvantage of this approach is that when the collection grows beyond the bounds of the widget, part of the collection is not visible.  Allow the widget to make geometry requests to expand or contract, perhaps up to some maximum or down to some minimum size.  The disadvantages of this approach are that it may disrupt the application's visual layout and that the widget is able to grow only within limits, perhaps not at all.  Treat the collection as a virtual scroll, with the widget acting as a (more or less) fixed-size viewport onto the scroll.  The user can move the viewport to expose obscured portions of the scroll.  The ScrolledWindow widget implements the last approach.  It is a Manager with one or two ScrollBar children, a child widget that acts as the virtual scroll, and in some cases another child that acts as a viewport onto the scroll.  By using the ScrollBars or keyboard scrolling commands, the user moves the viewport to expose part of the scroll.  ID="ch092"ID="ch093"LBL="9.1.1" HELPID=""Automatic and Application-Defined ScrollingID="ch094"ID="ch095"ID="ch096"ID="ch097"ScrolledWindow implements two scrolling models: automatic and application defined.  ID="ch098"In automatic scrolling, the application creates a widget to serve as the virtual scroll, and the ScrolledWindow creates the ScrollBars and a widget to serve as a fixed-size viewport onto the scroll.  The application adjusts the size of the scroll widget as necessary to contain the entire collection.  The ScrolledWindow adjusts the appropriate ScrollBar resources so that the size and position of the slider reflect the position of the viewport in relation to the scroll and the proportion of the scroll's entire size that the viewport represents.  The ScrolledWindow also handles the user's interaction with the ScrollBars, moving the viewport in relation to the scroll as the user manipulates the ScrollBars.  Usually the application need have no interaction with the ScrollBars or the widget that serves as the viewport.  ID="ch099"ID="ch0910"In application-defined scrolling, the application must create the ScrollBars as well as the widget that acts as the virtual scroll and, if necessary, a separate viewport widget.  The application must determine how large to make the viewport widget and what portion of the data to display in the viewport.  The application handles all interaction with the ScrollBars.  It must adjust the appropriate ScrollBar resources if it wants the size and position of the slider to reflect the relation of the viewport to the underlying scroll.  It must also move the viewport in relation to the scroll as the user interacts with the ScrollBars.  ID="ch0911"The ScrolledWindow resource XmNscrollingPolicy determines the scrolling model.  Possible values for this resource are ID="ch0912"ID="ch0913"XmAUTOMATIC and ID="ch0914"XmAPPLICATION_DEFINED.  The default value is ID="ch0915"XmAPPLICATION_DEFINED.  LBL="9.1.2" HELPID=""Other ResourcesIn addition to XmNscrollingPolicy, ScrolledWindow has two sets of resources.  ID="ch0916"ID="ch0917"One set of resources holds the components of the ScrolledWindow.  An application usually does not have to set any of these resources; the ScrolledWindow examines the class and other characteristics of each child as it is created and sets the appropriate resource.  If the application needs to supply a new ScrollBar or scroll widget after creating the initial component, it can use either ID="ch0918"ID="ch0919"XtSetValues or XmScrolledWindowSetAreas.  ID="ch0920"ID="ch0921"Following are the resources that hold components of the ScrolledWindow: XmNclipWindow The value is the ID of the viewport widget created by the ScrolledWindow in automatic scrolling.  This resource applies only when the ID="ch0922"ID="ch0923"XmNscrollingPolicy is ID="ch0924"XmAUTOMATIC.  It is a read-only resource; the application cannot set a new value.  ID="ch0925"XmNhorizontalScrollBar The value is the ID of the horizontal ScrollBar.  The ScrolledWindow creates this ScrollBar and sets the value of this resource when the ID="ch0926"ID="ch0927"ID="ch0928"XmNscrollingPolicy is XmAUTOMATIC.  In application-defined scrolling, the application must create and manage the ScrollBar, but the ScrolledWindow automatically sets the value of this resource to its widget ID.  ID="ch0929"ID="ch0930"XmNverticalScrollBar The value is the ID of the vertical ScrollBar.  The ScrolledWindow creates this ScrollBar and sets the value of this resource when the ID="ch0931"ID="ch0932"ID="ch0933"XmNscrollingPolicy is XmAUTOMATIC.  In application-defined scrolling, the application must create and manage the ScrollBar, but the ScrolledWindow automatically sets the value of this resource to its widget ID.  ID="ch0934"ID="ch0935"XmNworkWindow The value is the ID of the widget that serves as the scroll.  The application has to create and manage this widget, but it usually does not have to set this resource.  When the application creates a child of the ScrolledWindow that is not a ScrollBar, the ScrolledWindow automatically sets the value of this resource to its widget ID.  ID="ch0936"ID="ch0937"ID="ch0938"The second set of resources specifies the layout of the ScrolledWindow: ID="ch0939"XmNscrollBarDisplayPolicy This resource determines whether the ScrolledWindow always displays managed ScrollBars or displays them only when the corresponding dimensions of the scroll exceed those of the viewport.  Possible values are ID="ch0940"ID="ch0941"ID="ch0942"XmAS_NEEDED and XmSTATIC.  The value is forced to ID="ch0943"ID="ch0944"XmSTATIC when the scrolling policy is XmAPPLICATION_DEFINED and defaults to XmAS_NEEDED when the scrolling policy is ID="ch0945"XmAUTOMATIC.  ID="ch0946"XmNscrollBarPlacement This resource determines where the ScrolledWindow places the horizontal and vertical ScrollBars.  The possible values are constants that specify on which sides of the viewport the ScrolledWindow places the two ScrollBars: ID="ch0947"ID="ch0948"ID="ch0949"XmTOP_LEFT, ID="ch0950"XmTOP_RIGHT, XmBOTTOM_LEFT, and XmBOTTOM_RIGHT.  ID="ch0951"ID="ch0952"ID="ch0953"XmNscrolledWindowMarginHeight This resource specifies the margins between the top and bottom sides of the ScrolledWindow and the first child on each side.  ID="ch0954"ID="ch0955"XmNscrolledWindowMarginWidth This resource specifies the margins between the left and right sides of the ScrolledWindow and the first child on each side.  ID="ch0956"ID="ch0957"XmNspacingThis resource specifies the distance between each ScrollBar and the viewport.  ID="ch0958"ID="ch0959"LBL="9.2" HELPID=""Automatic ScrollingID="ch0960"ID="ch0961"In the automatic scrolling model, the ScrolledWindow creates a fixed-size viewport and handles all interaction with the ScrollBars.  The application usually needs to take only the following steps: ID="ch0962"ID="ch0963"Create and manage a ScrolledWindow, supplying a value of ID="ch0964"XmAUTOMATIC for XmNscrollingPolicy in the argument list passed to the creation function ID="ch0965"ID="ch0966"Create and manage a widget child of the ScrolledWindow to serve as the scroll ID="ch0967"Adjust the size of the scroll widget, typically using XtSetValues† †of ID="ch0968"XmNheight and XmNwidth, as necessary to contain all the data in the scroll ID="ch0969"ID="ch0970"The ScrolledWindow automatically creates a widget to serve as the viewport and sets ID="ch0971"XmNclipWindow to the ID of this widget.  It also creates horizontal and vertical ScrollBars and sets ID="ch0972"ID="ch0973"XmNhorizontalScrollBar and XmNverticalScrollBar to the appropriate IDs of the ScrollBars.  The ScrolledWindow attaches callback procedures to the ScrollBars to handle user interaction with the ScrollBars.  ID="ch0974"ID="ch0975"The ScrolledWindow sets the ScrollBar resource XmNincrement to a small fraction of the height or width of the viewport.  It sets the ScrollBar resource ID="ch0976"ID="ch0977"ID="ch0978"XmNpageIncrement to a large fraction of the height or width of the viewport.  If the ScrolledWindow resizes the viewport, it recomputes the values of these resources.  ID="ch0979"The ScrolledWindow sets the ScrollBar resources XmNmaximum, ID="ch0980"ID="ch0981"ID="ch0982"XmNminimum, and XmNsliderSize so that the size of the slider reflects the proportion of the entire scroll that the viewport represents.  If the application resizes the scroll or if the ScrolledWindow resizes the viewport, the ScrolledWindow recomputes the values of some or all of these resources.  ID="ch0983"ID="ch0984"If the value of XmNscrollBarDisplayPolicy is XmAS_NEEDED, as it is by default in automatic scrolling, the ScrolledWindow displays a ScrollBar only if the size of the scroll exceeds the size of the viewport in the relevant dimension.  If the value of ID="ch0985"ID="ch0986"ID="ch0987"ID="ch0988"XmNscrollBarDisplayPolicy is XmSTATIC, the ScrolledWindow always displays both ScrollBars.  ID="ch0989"As the user manipulates a ScrollBar and changes its XmNvalue, the ScrolledWindow moves the scroll with respect to the viewport.  For example, if the user moves the slider down in a vertical ScrollBar, the ScrolledWindow moves the scroll up with respect to the viewport.  ID="ch0990"ID="ch0991"ID="ch0992"The ScrolledWindow may need to move the scroll (and set a ScrollBar's ID="ch0993"ID="ch0994"XmNvalue) in circumstances other than the user's interaction with the ScrollBar.  For example, if the viewport is at the bottom of the scroll and the application reduces the height of the scroll, the ScrolledWindow must move the scroll down with respect to the viewport.  In this case, it reduces the ScrollBar's ID="ch0995"XmNmaximum and ID="ch0996"XmNvalue.  ID="ch0997"In automatic scrolling, the application should not try to set any of the following resources: The XmNx or XmNy of any child of the ScrolledWindow ID="ch0998"ID="ch0999"ID="ch09100"Any geometry resources of the viewport (the XmNclipWindow) ID="ch09101"The XmNmaximum, XmNminimum, XmNvalue, ID="ch09102"ID="ch09103"ID="ch09104"XmNincrement, or XmNpageIncrement of a ScrollBar ID="ch09105"ID="ch09106"ID="ch09107"The application can add callbacks of its own to a ScrollBar, but because the ScrolledWindow adds its own callbacks, the application must not call ID="ch09108"ID="ch09109"XtRemoveAllCallbacks for a ScrollBar.  ID="ch09110"The application or user can specify other resources, such as those that determine appearance, for the ScrolledWindow or its children.  The names of the automatically created ScrollBars are "HorScrollBar" and "VertScrollBar".  ID="ch09111"ID="ch09112"LBL="9.2.1" HELPID=""Traversing to Obscured WidgetsID="ch09113"ID="ch09114"By default, it is not possible to use keyboard traversal to move to a widget that is inside the scroll but outside the viewport.  For example, if the user presses KNextField and the next field is not within the viewport, focus does not move to that field.  The user must first use the ScrollBars or a scrolling command to position the viewport so that the target widget is no longer obscured.  ID="ch09115"ScrolledWindow has a callback list, XmNtraverseObscuredCallback, that allows an application to make it possible to traverse to widgets that are in the scroll but not in the viewport.  The callback list is invoked when the user tries to traverse to such a widget in a ScrolledWindow with automatic scrolling.  The callback procedure is passed a pointer to an ID="ch09116"ID="ch09117"XmTraverseObscuredCallbackStruct structure, which contains the reason (ID="ch09118"XmCR_OBSCURED_TRAVERSAL), the event, the widget that is the target of the traversal, and the traversal direction passed to ID="ch09119"XmProcessTraversal.  ID="ch09120"Usually the callback procedure can allow traversal to the target widget simply by calling XmScrollVisible.  This function takes as arguments the ScrolledWindow, the target widget, and requested margins between the target widget and the edges of the viewport.  The function moves the work area with respect to the viewport to make the obscured widget visible.  This function applies only to ScrolledWidgets with automatic scrolling.  ID="ch09121"ID="ch09122"When ScrolledWindows are nested and focus is in an inner ScrolledWindow, the ID="ch09123"XmNtraverseObscuredCallback callbacks of the inner ScrolledWindow are invoked first if necessary.  If the destination widget remains outside the viewport of the first ancestor ScrolledWindow, that ScrolledWindow's ID="ch09124"XmNtraverseObscuredCallback callbacks are invoked, and so on up the widget hierarchy.  LBL="9.2.2" HELPID=""Example of Automatic ScrollingID="ch09125"ID="ch09126"This section contains the scrolling-related portions of an example program that uses a ScrolledWindow with an automatic scrolling policy.  The ScrolledWindow is actually a MainWindow, a subclass of ScrolledWindow that is often the containing manager for the primary window of an application.  (MainWindow is discussed in ID="ch09127"ID="ch09128"IDREF="24592" TYPE="TITLE"Section 9.4, "MainWindow."
) The scroll widget is a DrawingArea.  ID="ch09129"The application allows the user to create a simple map in the DrawingArea.  The user can use the mouse to establish points representing cities and to draw lines between the cities.  The application contains a TextField that allows the user to enter the name of a city and then to create a button child of the DrawingArea located at the city and containing the city's name as its label.  The user can adjust the size of the DrawingArea by manipulating two Scales, one for the height of the DrawingArea and the other for the width.  Other parts of the application save and retrieve the map data.  ID="ch09130"ID="ch09131"ID="ch09132"ID="ch09133"This section contains only the portions of the application that relate directly to creating and maintaining the ScrolledWindow.  These include: ID="ch09134"Creating the MainWindow with an automatic scrolling policy ID="ch09135"Creating the DrawingArea child of the ScrolledWindow ID="ch09136"ID="ch09137"Resizing the DrawingArea in response to the user's interaction with the Scales ID="ch09138"ID="ch09139"Establishing an XmNtraverseObscuredCallback procedure ID="ch09140"/*-------------------------------------------------------------
**  Create a Main Window with a menubar, a command panel
**  containing 2 scales and a textfied, and a workarea.
**  Also put in the graphic structure the workarea info and the
**  textfield ids.
*/
void CreateApplication (
Widget          parent,
Graphic *       graph )
{
† †   Widget main_window, menu_bar, menu_pane, cascade, 
† †          button, comw, scale ;
† †   Arg args[5];        
† †   int n ;                
† †   /*  Create automatic MainWindow.
† †    */
† †   n = 0;
† †   XtSetArg (args[n], XmNscrollingPolicy, XmAUTOMATIC);  n++;
† †   main_window = XmCreateMainWindow (parent, "main_window",
† †                   args, n);
† †   XtAddCallback (main_window, XmNtraverseObscuredCallback, 
† †                  TravCB, NULL);
† †   XtManageChild (main_window);
...
† †   /*  Create work_area in MainWindow 
† †    */
† †   n = 0;
† †   XtSetArg (args[n], XmNresizePolicy, XmRESIZE_NONE); n++ ;
† †   XtSetArg (args[n], XmNmarginWidth, 0); n++ ;
† †   XtSetArg (args[n], XmNmarginHeight, 0); n++ ;
† †   graph->work_area = XmCreateDrawingArea(main_window, 
† †                                      "work_area", args, n);
† †   XtAddCallback (graph->work_area, XmNexposeCallback, DrawCB, 
† †                  (XtPointer)graph);
† †   XtAddCallback (graph->work_area, XmNresizeCallback, DrawCB, 
† †                  (XtPointer)graph);
† †   XtAddCallback (graph->work_area, XmNinputCallback, DrawCB, 
† †                  (XtPointer)graph);
† †   XtManageChild (graph->work_area);
† †   /*  Create a commandWindow in MainWindow with text and
† †       scales */
† †   n = 0;
† †   comw = XmCreateRowColumn(main_window, "comw", args, n);
† †   XtManageChild (comw);
† †   n = 0;
† †   XtSetArg (args[n], XmNcommandWindow, comw);  n++;
† †   XtSetValues (main_window, args, n);
† †   /* find initial size of the work_area and report to the
† †      scales */
† †   n = 0;
† †   XtSetArg (args[n], XmNwidth, &graph->old_width);  n++;
† †   XtSetArg (args[n], XmNheight, &graph->old_height);  n++;
† †   XtGetValues (graph->work_area, args, n);
† †   n = 0;
† †   XtSetArg (args[n], XmNorientation, XmHORIZONTAL);  n++;
† †   XtSetArg (args[n], XmNvalue, graph->old_width);  n++;
† †   /* scale_w is the name */
† †   scale = XmCreateScale(comw, "scale_w", args, n);
† †   XtAddCallback (scale, XmNvalueChangedCallback, ValueCB, 
† †                  (XtPointer)graph->work_area);
† †   XtManageChild (scale);
† †   n = 0;
† †   XtSetArg (args[n], XmNorientation, XmHORIZONTAL);  n++;
† †   XtSetArg (args[n], XmNvalue, graph->old_height);  n++;
† †   scale = XmCreateScale(comw, "scale_h", args, n);
† †   XtAddCallback (scale, XmNvalueChangedCallback, ValueCB, 
† †                  (XtPointer)graph->work_area);
† †   XtManageChild (scale);
† †   n = 0;
† †   graph->textf = XmCreateTextField(comw, "textf", args, n);
† †   XtManageChild (graph->textf);
† †   /*  Set MainWindow areas 
† †    */
† †   XmMainWindowSetAreas (main_window, menu_bar, comw, NULL,
† †                         NULL, graph->work_area);
}
/*-------------------------------------------------------------
**      TravCB          - callback for traverseObscure
*/
void TravCB (
Widget          w,              /*  widget id           */
XtPointer       client_data,    /*  data from application   */
XtPointer       call_data )     /*  data from widget class  */
{
† †   XmTraverseObscuredCallbackStruct * tocs =
† †       (XmTraverseObscuredCallbackStruct *) call_data ;
† †   XmScrollVisible(w, tocs->traversal_destination, 20, 20) ; 
}
/*-------------------------------------------------------------
**      ValueCB         - callback for scales
*/
void ValueCB (
Widget          w,              /*  widget id           */
XtPointer       client_data,    /*  data from application   */
XtPointer       call_data )     /*  data from widget class  */
{
† †   Arg args[5];        
† †   int n ;                
† †   int value ;
† †   Widget workarea = (Widget) client_data ;
† †   /* get the value outof the Scale */
† †   n = 0;
† †   XtSetArg (args[n], XmNvalue, &value);  n++;
† †   XtGetValues (w, args, n);
† †   n = 0;
† †   if (strcmp(XtName(w), "scale_w") == 0 ) { /* width scale */
† †       XtSetArg (args[n], XmNwidth, value);  n++;
† †   } else {
† †       XtSetArg (args[n], XmNheight, value);  n++;
† †   }
† †   XtSetValues (workarea, args, n);
}LBL="9.3" HELPID=""Application-Defined ScrollingID="ch09141"ID="ch09142"In application-defined scrolling, the application is responsible for all aspects of the interactions among the scroll, the viewport, and the ScrollBars.  The ScrolledWindow remains responsible for geometry and layout, but the application must adjust both the ScrollBars and the scroll position in response to the user's scrolling actions.  ID="ch09143"ID="ch09144"Because this model requires more work on the part of the application, it is most suitable for programs in which automatic scrolling is not adequate.  For example, an application may contain a text editor or browser that reads only enough of a file to fill the viewport.  This application must be informed of the user's scrolling actions so that it can read more of the file when necessary.  The application implements a scheme of its choosing for the relationship between the scroll and the viewport.  Following are two common models: A fixed-size viewport widget as the parent of a variable-sized scroll widget that contains the data.  The application resizes the scroll widget as necessary to contain all the data.  As the user interacts with the ScrollBar, the application moves the scroll widget with respect to the viewport, which clips the scroll.  This is the model that ScrolledWindow uses for automatic scrolling.  ID="ch09145"ID="ch09146"A single widget that serves as the viewport, with the scroll contained in internal data structures or a combination of data structures and files.  The application expands the internal structures as necessary to contain all the data.  As the user interacts with the ScrollBar, the application retrieves the appropriate portion of the data from the internal structures or files and displays that portion of the data in the viewport.  This is the model that the Motif ScrolledList and ScrolledText widgets use.  ID="ch09147"ID="ch09148"ID="ch09149"In both models, the application must be notified when the viewport is resized.  It may need to adjust the scroll with respect to the viewport, and it must recompute ScrollBar resources to reflect the new relation between the viewport and the scroll.  If the viewport is a DrawingArea the application can use the ID="ch09150"ID="ch09151"XmNresizeCallback callbacks for this purpose.  Otherwise, the application can establish an event handler for ID="ch09152"ConfigureNotify events.  ID="ch09153"The application needs to take the following steps to use application-defined scrolling: Create and manage a ScrolledWindow, horizontal and vertical ScrollBar children, and a child to serve as the viewport.  ID="ch09154"ID="ch09155"If the application is using a separate widget as the scroll, create and manage that widget as a child of the viewport widget.  Add callbacks to the ScrollBars to notify the application when the user interacts with the ScrollBars.  The application should at least provide a procedure for the ID="ch09156"XmNvalueChangedCallback list.  ID="ch09157"Add a callback (such as the DrawingArea XmNresizeCallback) or an event handler to the viewport widget to notify the application when the widget is resized.  ID="ch09158"ID="ch09159"Based on the initial relationship between the viewport and the scroll, supply initial values for the ScrollBars' XmNincrement, ID="ch09160"ID="ch09161"XmNpageIncrement, XmNmaximum, XmNminimum, ID="ch09162"ID="ch09163"ID="ch09164"XmNvalue, and XmNsliderSize resources.  ID="ch09165"ID="ch09166"Adjust the size of the scroll widget or internal data structures as necessary to contain the data in the scroll.  As the data in the scroll changes, recompute the ScrollBars' ID="ch09167"XmNmaximum and XmNsliderSize and perhaps XmNminimum† †and ID="ch09168"ID="ch09169"ID="ch09170"XmNvalue to reflect the new relation between the viewport and the scroll.  ID="ch09171"When the viewport is resized, reposition and resize the scroll with respect to the viewport if necessary.  Recompute the ScrollBars' XmNsliderSize and XmNpageIncrement† †and possibly other resources to reflect the new relationship between the viewport and the scroll.  ID="ch09172"ID="ch09173"ID="ch09174"As the user interacts with the ScrollBars, if a separate scroll widget exists, reposition the scroll with respect to the viewport.  If no separate scroll widget exists, bring in additional data from files if necessary, recompute which portion of the data to make visible, and redisplay the viewport.  If the size of the scroll has changed, recompute the ScrollBar resources to reflect the new relationship between the viewport and the scroll.  ID="ch09175"LBL="9.3.1" HELPID=""Example of Application-Defined ScrollingID="ch09176"ID="ch09177"This section contains the scrolling-related portions of an example program that uses a ScrolledWindow with an application-defined scrolling policy.  As in the example of automatic scrolling, the ScrolledWindow is a MainWindow, and the scroll widget is a DrawingArea.  In this example, the scroll widget also serves as the viewport widget, and the scroll data is maintained in internal data structures.  ID="ch09178"ID="ch09179"ID="ch09180"The application is a simple file browser for C source code.  The user selects a filename.  The program reads the file and parses it (in the C locale) into an internal table of lines.  The application displays in the DrawingArea as many lines as will fit into the current dimensions of the DrawingArea.  ID="ch09181"The application uses only a vertical ScrollBar, which allows the user to browse through the file.  After reading the file, the program sets the ScrollBar's ID="ch09182"XmNminimum and XmNvalue to 0, its XmNmaximum to the number of lines in the file, and its ID="ch09183"ID="ch09184"ID="ch09185"XmNsliderSize to the lesser of the number of lines in the file and the number of lines that can be displayed in the viewport.  ID="ch09186"The program establishes a ScrollBar XmNvalueChangedCallback and a DrawingArea ID="ch09187"ID="ch09188"XmNexposeCallback that redisplay the lines in the viewport.  The redisplay procedure fetches and displays lines from the internal data structure, starting with the line indicated by the ScrollBar's ID="ch09189"ID="ch09190"XmNvalue and proceeding to the last line that fits in the viewport.  The program also establishes a DrawingArea ID="ch09191"XmNresizeCallback that recomputes the ScrollBar's ID="ch09192"XmNsliderSize and XmNvalue based on the number of lines that can be displayed in the viewport.  The application does not resize the DrawingArea itself.  ID="ch09193"This section contains only the portions of the application that relate directly to creating and maintaining the ScrolledWindow.  These include: ID="ch09194"Creating the MainWindow with an application-defined scrolling policy ID="ch09195"Creating the DrawingArea and vertical ScrollBar children of the ScrolledWindow ID="ch09196"ID="ch09197"ID="ch09198"Establishing an XmNactivateCallback callback for the OK button of the FileSelectionBox invoked from the file menu Open button ID="ch09199"ID="ch09200"Establishing a ScrollBar XmNvalueChangedCallback callback ID="ch09201"ID="ch09202"Establishing a DrawingArea XmNexposeCallback callback and an ID="ch09203"ID="ch09204"XmNresizeCallback callback ID="ch09205"/*------------------------------------------------------------
**      Internal data structure to hold file info.
*/
typedef struct {
† †   Widget work_area  ;
† †   Widget v_scrb ;
† †   String file_name ;
† †   XFontStruct * font_struct ;
† †   GC draw_gc ;
† †   char ** lines ;
† †   int num_lines ;
} FileData ;
/*------------------------------------------------------------
** Create a MainWindow with a MenuBar to load a file.
** Add the vertical scrollbar and the workarea to filedata.
*/
void CreateApplication (
Widget          parent,
FileData *      filedata )
{
† †   Widget main_window, menu_bar, menu_pane, cascade, 
† †          button ;
† †   Arg args[5];        
† †   int n ;                
† †   /*  Create app_defined MainWindow.
† †    *  XmAPPLICATION_DEFINED is the default; not necessary
† †    *  to specify it here.
† †    */
† †   n = 0;
† †   XtSetArg (args[n], XmNscrollingPolicy,
† †             XmAPPLICATION_DEFINED);  n++;
† †   main_window = XmCreateMainWindow (parent,
† †                               "main_window", args, n);
† †   XtManageChild (main_window);
† †   /*  Create MenuBar in MainWindow.
† †    */
...
† †   /* Create "File" PulldownMenu with Open and Quit buttons
† †    */
† †   n = 0;
† †   menu_pane = XmCreatePulldownMenu (menu_bar, 
† †                                     "menu_pane", args, n);
† †   n = 0;
† †   button = XmCreatePushButton (menu_pane, "Open...", 
† †                                args, n);
† †   XtManageChild (button);
† †   /* pass the file data to the Open callback */
† †   XtAddCallback (button, XmNactivateCallback,
† †                  OpenCB, (XtPointer)filedata);
† †   n = 0;
† †   button = XmCreatePushButton (menu_pane, "Quit", args, n);
† †   XtManageChild (button);
† †   XtAddCallback (button, XmNactivateCallback, QuitCB, NULL);
† †   n = 0;
† †   XtSetArg (args[n], XmNsubMenuId, menu_pane);  n++;
† †   cascade = XmCreateCascadeButton (menu_bar, "File", 
† †                                    args, n);
† †   XtManageChild (cascade);
† †   /*  Create "Help" PulldownMenu with Help button.
† †    */
† †   /*  Create vertical scrollbar only
† †    */
† †    n = 0;
† †   XtSetArg (args[n], XmNorientation, XmVERTICAL);  n++;
† †   filedata->v_scrb = XmCreateScrollBar (main_window, 
† †                                         "v_scrb", args, n);
† †   XtAddCallback (filedata->v_scrb, XmNvalueChangedCallback, 
† †                  ValueCB, (XtPointer)filedata);
† †   XtManageChild (filedata->v_scrb);
† †   /*  Create work_area in MainWindow 
† †    */
† †   n = 0;
† †   filedata->work_area = XmCreateDrawingArea(main_window,
† †                                     "work_area", args, n);
† †   XtAddCallback (filedata->work_area, XmNexposeCallback,
† †                  DrawCB, (XtPointer)filedata);
† †   XtAddCallback (filedata->work_area, XmNresizeCallback,
† †                  DrawCB, (XtPointer)filedata);
† †   XtManageChild (filedata->work_area);
† †   /*  Set MainWindow areas 
† †    */
† †   XmMainWindowSetAreas (main_window, menu_bar, NULL, NULL, 
† †                         filedata->v_scrb,
† †                         filedata->work_area);
}
/*-------------------------------------------------------------
**      OpenCB                  - callback for Open button
*/
void OpenCB (
Widget          w,              /*  widget id           */
XtPointer       client_data,    /*  data from application   */
XtPointer       call_data )     /*  data from widget class  */
{
† †       static Widget fsb_box = NULL ;
† †       if (!fsb_box) {
† †           fsb_box = XmCreateFileSelectionDialog (w,
† †                                      "Load file", NULL, 0);
† †           /* just propagate the file information */
† †           XtAddCallback (fsb_box, XmNokCallback, ReadCB,
† †                                               client_data);
† †       }    
† †       XtManageChild (fsb_box);
}
/*-------------------------------------------------------------
**      ReadCB  - callback for fsb activate
*/
void ReadCB (
Widget          w,              /*  widget id           */
XtPointer       client_data,    /*  data from application   */
XtPointer       call_data )     /*  data from widget class  */
{
† †   FileData * filedata = (FileData *) client_data ;
† †   String file_name ;
† †   Arg args[5];        
† †   int n, slider_size ;        
† †   Dimension height ;
† †   file_name = XmTextGetString(
† †               XmFileSelectionBoxGetChild(w, XmDIALOG_TEXT));
† †   if (!BuildLineTable(filedata, file_name)) {
† †       WarnUser (w, "Cannot open %s, file_name);
† †   } else {
† †       filedata->file_name = file_name ;
† †       /* ok, we have a new file, so reset some values */
† †       n = 0;
† †       XtSetArg (args[n], XmNheight, &height);  n++;
† †       XtGetValues (filedata->work_area, args, n);
† †       slider_size = (height - 4) /
† †                            (filedata->font_struct->ascent
† †                           + filedata->font_struct->descent);
† †       if (slider_size <= 0) slider_size = 1 ;
† †       if (slider_size > filedata->num_lines) 
† †           slider_size = filedata->num_lines ;
† †       n = 0 ;
† †       XtSetArg (args[n], XmNsliderSize, slider_size);  n++;
† †       XtSetArg (args[n], XmNmaximum, filedata->num_lines);
† †                   n++;
† †       XtSetArg (args[n], XmNvalue, 0);  n++;
† †       XtSetValues (filedata->v_scrb, args, n);
† †       /* clear and redraw */
† †       XClearWindow(XtDisplay(filedata->work_area),
† †                    XtWindow(filedata->work_area));
† †       ReDraw (filedata);
† †   }
}
/*-------------------------------------------------------------
**      ValueCB         - callback for scrollbar
*/
void ValueCB (
Widget          w,              /*  widget id           */
XtPointer       client_data,    /*  data from application   */
XtPointer       call_data )     /*  data from widget class  */
{
† †   FileData * filedata = (FileData *) client_data ;
† †   /* clear and redraw, dumb dumb.. */
† †   XClearWindow(XtDisplay(filedata->work_area),
† †                XtWindow(filedata->work_area));
† †   ReDraw(filedata);
}
/*-------------------------------------------------------------
**      DrawCB                  - callback for drawing area
*/
void DrawCB (
Widget          w,              /*  widget id           */
XtPointer       client_data,    /*  data from application   */
XtPointer       call_data )     /*  data from widget class  */
{
† †   XmDrawingAreaCallbackStruct * dacs =
† †       (XmDrawingAreaCallbackStruct *) call_data ;
† †   FileData * filedata = (FileData *) client_data ;
† †   XSetWindowAttributes xswa;
† †   static Boolean first_time = True ;
† †   switch (dacs->reason) {
† †   case XmCR_EXPOSE: 
† †       if (first_time) {
† †           /* Change once the bit gravity of the
† †              Drawing Area; default is north west and we
† †              want forget, so that resize always
† †              generates exposure events */
† †           first_time = False ;
† †           xswa.bit_gravity = ForgetGravity ;
† †           XChangeWindowAttributes(XtDisplay(w), XtWindow(w),
† †                                   CWBitGravity, &xswa);
† †       }
† †       ReDraw(filedata) ;
† †       break ;
† †   case XmCR_RESIZE: 
† †       ReSize(filedata) ;
† †       break ;
† †   }
}
void ReDraw(
FileData * filedata )
{
† †   /* Display as many line as slider_size actually shows,
† †      since slider_size is computed relative to the
† †      work_area height */
† †   Cardinal i ;
† †   int value, slider_size ;
† †   Arg args[5];        
† †   int n ;     
† †   Position y ;
† †   if (filedata->num_lines == 0) return ;
† †   n = 0;
† †   XtSetArg (args[n], XmNvalue, &value);  n++;
† †   XtSetArg (args[n], XmNsliderSize, &slider_size);  n++;
† †   XtGetValues (filedata->v_scrb, args, n);
† †   for (i = value, y = 2 + filedata->font_struct->ascent; 
† †        i < value + slider_size ; 
† †        i++, y += (filedata->font_struct->ascent
† †                   + filedata->font_struct->descent)) {
† †       XDrawString(XtDisplay(filedata->work_area),
† †                   XtWindow(filedata->work_area),
† †                   filedata->draw_gc,
† †                   4, y,
† †                   filedata->lines[i],
† †                   strlen(filedata->lines[i]));
† †   }
}
void ReSize(
FileData * filedata )
{
† †   /* Just update the scrollbar internals here, don't
† †      bother to redisplay since the gravity is none */
† †   Arg args[5];        
† †   int n ;     
† †   int value, slider_size ;
† †   Dimension height ;
† †   if (filedata->num_lines == 0) return ;
† †   n = 0;
† †   XtSetArg (args[n], XmNheight, &height);  n++;
† †   XtGetValues (filedata->work_area, args, n);
† †   /* sliderSize is the number of visible lines */
† †   slider_size = (height - 4) /
† †                         (filedata->font_struct->ascent
† †                        + filedata->font_struct->descent);
† †   if (slider_size <= 0) slider_size = 1 ;
† †   if (slider_size > filedata->num_lines) 
† †       slider_size = filedata->num_lines ;
† †   n = 0;
† †   XtSetArg (args[n], XmNvalue, &value);  n++;
† †   XtGetValues (filedata->v_scrb, args, n);
† †   /* value shouldn't change that often but there are cases
† †      where it matters */
† †   if (value > filedata->num_lines - slider_size) 
† †       value = filedata->num_lines - slider_size;
† †   n = 0;
† †   XtSetArg (args[n], XmNsliderSize, slider_size);  n++;
† †   XtSetArg (args[n], XmNvalue, value);  n++;
† †   XtSetArg (args[n], XmNmaximum, filedata->num_lines); n++;
† †   XtSetValues (filedata->v_scrb, args, n);
}LBL="9.4" HELPID=""ID="24592"MainWindowID="ch09206"Motif provides a widget, MainWindow, that serves as a template for the primary window of most applications.  MainWindow is a subclass of ScrolledWindow.  In addition to the viewport and ScrollBar components of the ScrolledWindow, MainWindow has an optional MenuBar, Command window, and Message window.  ID="ch09207"ID="ch09208"ID="ch09209"ID="ch09210"MainWindow lays out these components in a manner compliant with the ID="ch09211"OSF/Motif Style Guide specifications for the primary window of an application.  The MenuBar, if present, spans the top of the MainWindow horizontally.  By default, the Command window, if present, spans the MainWindow horizontally just below the MenuBar.  The ScrolledWindow viewport and ScrollBars are below the Command window, and the Message window is below the ScrolledWindow viewport or horizontal ScrollBar.  If the MainWindow resource ID="ch09212"ID="ch09213"ID="ch09214"ID="ch09215"XmNcommandWindowLocation is set to ID="ch09216"XmCOMMAND_BELOW_WORKSPACE at the time the MainWindow is created, the Command window is located below the ScrolledWindow viewport or horizontal ScrollBar.  ID="ch09217"If the MainWindow resource XmNshowSeparator is True, the MainWindow automatically creates up to three SeparatorGadgets to separate the components.  The names of these automatically created SeparatorGadgets are "Separator1", "Separator2", and "Separator3".  The application can retrieve the widget IDs of the SeparatorGadgets by using the functions ID="ch09218"ID="ch09219"ID="ch09220"XmMainWindowSep1, XmMainWindowSep2, and ID="ch09221"ID="ch09222"XmMainWindowSep3.  ID="ch09223"In addition to the ScrolledWindow resources that hold the widget IDs of the ScrollBars, scroll widget, and viewport widget, MainWindow has resources that hold the widget IDs of the other MainWindow components: ID="ch09224"ID="ch09225"ID="ch09226"XmNcommandWindow The value is the widget ID of the Command window.  If a child is a Command widget and no Command window exists, MainWindow automatically sets the value of this resource to the child's widget ID.  ID="ch09227"ID="ch09228"ID="ch09229"XmNmenuBar The value is the widget ID of the MenuBar.  If a child is a MenuBar and no MainWindow MenuBar exists, MainWindow automatically sets the value of this resource to the child's widget ID.  ID="ch09230"ID="ch09231"XmNmessageWindow The value is the widget ID of the Message window.  After creating the Message window, the application must use ID="ch09232"XtSetValues to set the value of this resource to the child's widget ID.  ID="ch09233"MainWindow has a convenience routine, XmMainWindowSetAreas, to establish both the MainWindow and the ScrolledWindow components.  ID="ch09234"ID="ch09235"ID="ch09236"XmMainWindowSetAreas does not set the Message window; an application must use XtSetValues of XmNmessageWindow to set the Message window.  An application that has no Message window and uses only standard components for the other MainWindow children may not need to call ID="ch09237"ID="ch09238"XmMainWindowSetAreas or XtSetValues for the component resources, but it is good practice to make these calls.  If an application uses a Message window or has additional MainWindow children beyond the standard components, it must call XmMainWindowSetAreas and XtSetValues for XmNmessageWindow.  An application takes the following steps to use MainWindow: ID="ch09239"Create and manage the MainWindow, usually as a child of the ApplicationShell.  If the scrolling mode is to be automatic, supply an initial value of ID="ch09240"ID="ch09241"XmAUTOMATIC for XmNscrollingPolicy.  ID="ch09242"ID="ch09243"Create and manage the components of the MainWindow.  ID="ch09244"If necessary, call XmMainWindowSetAreas or XtSetValues for the MainWindow components.  ID="ch09245"ID="ch09246"ID="ch09247"Take any other actions needed to regulate the ScrolledWindow components.  These actions are discussed in the previous descriptions of automatic and application-defined scrolling.  ID="ch09248"For examples of using MainWindow with both automatic and application-defined scrolling policies, see the ScrolledWindow examples in the previous sections.  ID="ch09249"ID="ch09250"LBL="9.5" HELPID=""FrameID="ch09251"Frame is a simple manager that encloses a child and displays a shadow around it.  An application usually uses a Frame to provide a shadow for a widget, such as a RowColumn WorkArea, that does not display a shadow itself.  The Frame resource ID="ch09252"ID="ch09253"XmNshadowType determines the type of shadow to draw.  The resources ID="ch09254"XmNmarginHeight and XmNmarginWidth specify the margin between the shadow and the border of the child.  ID="ch09255"ID="ch09256"Frame can also have one other child that serves as a title.  Frame places the title above the principal child of the Frame.  The following constraint resources determine the Frame's treatment of the child: ID="ch09257"XmNchildType The value is a constant that tells the Frame whether the child is the work area child, the title, or another kind of child.  Following are the possible values: ID="ch09258"ID="ch09259"XmFRAME_WORKAREA_CHILD -- This value specifies that the child is the principal (work area) component.  This is the default.  ID="ch09260"XmFRAME_TITLE_CHILD --† †This value specifies that the child is the Frame title.  ID="ch09261"XmFRAME_GENERIC_CHILD† †--This value specifies that the child is a component other than the work area and the title.  When the value is ID="ch09262"XmFRAME_GENERIC_CHILD, Frame does not include the child in its layout.  XmNchildHorizontalAlignment The value specifies the alignment of the title with respect to the left and right inner edges of the Frame (determined by the child's ID="ch09263"ID="ch09264"XmNchildHorizontalSpacing).  Following are the possible values: ID="ch09265"XmALIGNMENT_BEGINNING -- This value specifies that the title is placed at the left inner edge when the Frame's ID="ch09266"XmNstringDirection has the value ID="ch09267"ID="ch09268"XmSTRING_DIRECTION_L_TO_R; otherwise, the title is placed at the right inner edge.  This is the default.  ID="ch09269"XmALIGNMENT_END -- This value specifies that the title is placed at the right inner edge when the Frame's XmNstringDirection has the value ID="ch09270"ID="ch09271"XmSTRING_DIRECTION_L_TO_R; otherwise, the title is placed at the left inner edge.  ID="ch09272"XmALIGNMENT_CENTER -- This value specifies that the title is centered between the edges.  XmNchildHorizontalSpacing The value is the minimum distance between the title and the shadow along the left and right edges of the Frame.  The default is the Frame's ID="ch09273"ID="ch09274"XmNmarginWidth.  ID="ch09275"XmNchildVerticalAlignment The value specifies the alignment of the title with respect to the shadow along the top edge of the Frame.  Following are the possible values: ID="ch09276"XmALIGNMENT_BASELINE_BOTTOM --† †The baseline of the last line of text in the title is even with the shadow along the top edge of the Frame.  ID="ch09277"ID="ch09278"XmALIGNMENT_BASELINE_TOP --† †The baseline of the first line of text in the title is even with the shadow along the top edge of the Frame.  ID="ch09279"ID="ch09280"XmALIGNMENT_CENTER -- The center of the title is even with the shadow along the top edge of the Frame.  This is the default.  ID="ch09281"XmALIGNMENT_WIDGET_BOTTOM --† †The bottom edge of the title is even with the shadow along the top edge of the Frame.  ID="ch09282"ID="ch09283"XmALIGNMENT_WIDGET_TOP -- The top edge of the title is even with the shadow along the top edge of the Frame.  ID="ch09284"Following is a UIL specification for an example Frame with a Label title and a Form child (not defined here): ID="ch09285"ID="ch09286"ID="ch09287"object exampleFrame : XmFrame {
† † controls {
† †     XmLabel  { arguments {
† †       XmNchildType = XmFRAME_TITLE_CHILD;
† †       XmNchildHorizontalSpacing = 4;
† †       XmNchildVerticalAlignment = XmALIGNMENT_WIDGET_BOTTOM;
† †     }; }; 
† †     XmForm exampleForm;
† †  };
};LBL="9.6" HELPID=""PanedWindowID="ch09288"PanedWindow is a manager that lays out its children vertically from top to bottom and, by default, places a separator between each pair of children.  Each child spans the width of the PanedWindow, which resizes children to be as wide as the widest child.  When possible, the PanedWindow grows to accommodate the width of the widest child and the heights of all the children.  Usually PanedWindow allows the user to adjust the height of each pane.  When a pane is adjustable, PanedWindow creates a control called a sash and places it below the pane that it controls.  By manipulating the sash with the mouse or keyboard commands, the user changes the height of the pane above.  This may also change the height of a pane below the sash.  ID="ch09289"PanedWindow has the following resources to control general appearance: ID="ch09290"XmNmarginHeight The value specifies the margin between the PanedWindow's top and bottom shadows and the children nearest those shadows.  ID="ch09291"XmNmarginWidth The value specifies the margin between the PanedWindow's left and right shadows and the children nearest those shadows.  ID="ch09292"ID="ch09293"XmNseparatorOn The value determines whether or not PanedWindow displays a separator between each pair of panes.  ID="ch09294"ID="ch09295"XmNspacingThe value is the distance between each pane.  ID="ch09296"The following PanedWindow resources control the appearance of the sashes: ID="ch09297"XmNsashHeight The value specifies the height of each sash.  ID="ch09298"XmNsashIndent The value specifies the distance between each sash and the inner margin of the left or right side of the PanedWindow.  If the value is positive, the sash is offset from the near (left) side of the PanedWindow.  If the value is negative, the sash is offset from the far (right) side of the PanedWindow.  If the value is greater than the width of the PanedWindow minus the width of the sash, the sash is placed flush against the near side of the PanedWindow.  ID="ch09299"ID="ch09300"XmNsashShadowThickness The value specifies the shadow thickness for each sash.  ID="ch09301"XmNsashWidth The value specifies the width of each sash.  ID="ch09302"PanedWindow has one other resource, XmNrefigureMode.  When this resource is set to False, the PanedWindow does not recompute its layout when either the user or the application resizes a pane or when the PanedWindow is resized.  ID="ch09303"ID="ch09304"PanedWindow children have a number of constraint resources that PanedWindow uses to determine the positions and size limitations of the panes: ID="ch09305"XmNallowResize The value specifies whether the PanedWindow grants resize requests from the pane.  When the value is False (the default) and the pane is realized, PanedWindow refuses such requests, but it allows the user to resize the pane if it is adjustable.  For example, if the application attempts to change the height or width of the pane using ID="ch09306"ID="ch09307"XtSetValues, PanedWindow does not allow the change.  If the value is True or if the pane is not realized, PanedWindow grants requests by the pane to change its size if possible.  ID="ch09308"XmNpaneMaximum The value is the maximum height to which the user or application can resize the pane.  If this value is the same as the value of ID="ch09309"XmNpaneMinimum, the pane cannot be resized at all, and PanedWindow does not display a sash at the bottom of the pane.  ID="ch09310"ID="ch09311"XmNpaneMinimum The value is the minimum height to which the user or application can resize the pane.  If this value is the same as the value of ID="ch09312"XmNpaneMaximum, the pane cannot be resized at all, and PanedWindow does not display a sash at the bottom of the pane.  ID="ch09313"ID="ch09314"XmNpositionIndex The value is the ordinal position of the pane in the PanedWindow's list of pane children.  The application or user can specify the value as an integer between 0 and the number of children already in the list, or as the value ID="ch09315"ID="ch09316"XmLAST_POSITION (the default), which means the child is inserted at the end of the list.  If specifying a new value causes the order of children in the list to change, PanedWindow recomputes its layout according to the new order of children: the first pane is displayed at the top of the PanedWindow, the second child below the first, and so on.  ID="ch09317"XmNskipAdjust The value specifies whether or not the PanedWindow resizes the pane when the PanedWindow itself is resized or when the user resizes another pane.  When the value is True, PanedWindow does not resize this pane under these circumstances, but the user can still resize the pane if ID="ch09318"ID="ch09319"XmNpaneMaximum is greater than XmNpaneMinimum.  The default is False.  ID="ch09320"ID="ch09321"LBL="10"ID="18723"Managing GeometryThe geometry of a widget consists of its size, location, and stacking order.  Widgets often have preferred sizes and perhaps locations.  For example, a Label widget may prefer to be just large enough to display the text of the label.  But composite widgets usually have preferences or constraints in laying out their children, and these may conflict with the preferences of the child widgets.  Furthermore, the user or the application can change a widget's geometry at any time, for example, by resizing the top-level window.  Geometry management is the process by which the user, parent widgets, and child widgets negotiate the actual sizes and locations of the widgets in the application.  ID="ch101"ID="ch102"ID="ch103"Following are some common occasions for geometry changes: The application manages or unmanages a child widget.  The application sets a geometry resource.  The application sets a resource that causes one of the geometry resources to change.  For example, setting a new label for a Label widget may cause a geometry change.  ID="ch104"The user resizes a top-level window using the window manager.  The user resizes a pane of a PanedWindow.  ID="ch105"Following are the basic Core and RectObj resources that determine widget geometry: ID="ch106"ID="ch107"XmNxSpecifies the x coordinate of the upper left outside corner (outside the border) of the widget's window.  The value is relative to the upper left inside corner (inside the border) of the parent window.  ID="ch108"XmNySpecifies the y coordinate of the upper left outside corner (outside the border) of the widget's window.  The value is relative to the upper left inside corner (inside the border) of the parent window.  ID="ch109"XmNwidthSpecifies the inside width (excluding the border) of the widget's window.  ID="ch1010"XmNheightSpecifies the inside height (excluding the border) of the widget's window.  ID="ch1011"XmNborderWidth Specifies the width of the border that surrounds the widget's window on all four sides.  ID="ch1012"LBL="10.1" HELPID=""Xt and Geometry ManagementThe Intrinsics provide the basic mechanisms and policies that underlie geometry management in Motif.  The fundamental principle of geometry management is that parent widgets control the geometry of their children.  Child widgets request changes to their geometry; parent widgets respond to requests from their children and change the geometry of their children directly.  LBL="10.1.1" HELPID=""Widget Class ProceduresID="ch1013"ID="ch1014"Six widget class procedures, two in the parent and four in the child, handle most of the work of geometry management: The parent's change_managed procedure.  When a child is managed or unmanaged, the parent often must move or resize some of its children.  In the ID="ch1015"ID="ch1016"change_managed procedure, the parent can move a child by calling XtMoveWidget, resize a child by calling ID="ch1017"XtResizeWidget, or both move and resize a child by calling ID="ch1018"XtConfigureWidget.  These functions update the appropriate geometry resources of the child and, if the child is realized, reconfigure the child's window.  ID="ch1019"The parent's geometry_manager procedure.  This function receives and acts on requests from child widgets to change their geometry.  The ID="ch1020"ID="ch1021"geometry_manager procedure can grant a request, deny a request, or suggest a compromise to the child.  If the procedure grants the request, it updates the appropriate geometry resources of the child.  If the child is realized, the parent can either reconfigure the child's window itself or let the Intrinsics reconfigure the window.  To make all geometry changes itself, the procedure can call XtMoveWidget, XtResizeWidget, or XtConfigureWidget.  ID="ch1022"ID="ch1023"ID="ch1024"The child's set_values procedure.  Whenever the application or user sets one of the basic geometry resourcesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'ID="ch1025"ID="ch1026"XmNx, XmNy, XmNwidth, XmNheight, or ID="ch1027"ID="ch1028"ID="ch1029"ID="ch1030"XmNborderWidthname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Xt automatically makes a request to the widget's parent for the geometry change.  In the ID="ch1031"set_values procedure the widget can determine whether a change to another resource requires a geometry change.  If so, it can simply change one or more of the geometry resources, and Xt makes the appropriate geometry request of the parent.  If the parent denies the request, Xt restores the geometry resources to the values they had before the call to XtSetValues.  ID="ch1032"The child's set_values_almost procedure.  When the user or the application sets one of the widget's geometry resources, the parent may suggest a compromise geometry change.  The child's ID="ch1033"ID="ch1034"set_values_almost procedure determines whether to accept the compromise, reject the compromise, or request an alternate geometry change.  The child's resize procedure.  When a parent calls ID="ch1035"ID="ch1036"XtResizeWidget or XtConfigureWidget with a size change, Xt makes the changes to the child's geometry resources and window and then invokes the child's ID="ch1037"ID="ch1038"resize procedure to inform the child of the size change.  This procedure makes any internal changes necessary to conform to the new dimensions.  If the child is itself a composite widget, its resize procedure may move or resize its own children.  The child's query_geometry procedure.  A parent widget may take account of a child's preferred geometry in determining its layout.  The parent calls ID="ch1039"ID="ch1040"XtQueryGeometry, which invokes the child's ID="ch1041"query_geometry procedure.  The child can accept the parent's intended geometry change, inform the parent of the child's preferred geometry, or indicate that the child's current geometry is its preferred geometry.  The parent can use the results however it wants.  LBL="10.1.2" HELPID=""Geometry Change RequestsA widget uses XtMakeGeometryRequest to make a request to its parent for a change in its geometry.  The widget can also use ID="ch1042"XtMakeResizeRequest, a simple interface to ID="ch1043"XtMakeGeometryRequest for requests to change width or height.  Primitive widgets seldom invoke ID="ch1044"XtMakeGeometryRequest directly.  They usually generate geometry requests indirectly when the application sets a resource that requires a geometry change.  Composite widgets often make geometry requests when they try to accommodate requests from their children.  For example, when a child asks to grow, the parent may ask its own parent to grow as well.  In such cases the parent's ID="ch1045"ID="ch1046"ID="ch1047"geometry_manager procedure invokes ID="ch1048"ID="ch1049"XtMakeGeometryRequest directly.  ID="ch1050"If the requesting widget is unmanaged, its parent is not realized, or the requested geometry resource values are the same as the current values, XtMakeGeometryRequest makes the requested changes and returns ID="ch1051"XtGeometryYes.  If the widget is being destroyed, it returns ID="ch1052"XtGeometryNo.  Otherwise, it invokes the parent's ID="ch1053"geometry_manager procedure.  If the ID="ch1054"ID="ch1055"geometry_manager procedure approves the request, XtMakeGeometryRequest returns XtGeometryYes.  If the geometry_manager procedure denies the request, XtMakeGeometryRequest returns XtGeometryNo.  If the geometry_manager procedure suggests a compromise geometry, XtMakeGeometryRequest returns XtGeometryAlmost.  In this case the widget can accept the compromise by immediately making another geometry request with the compromise parameters.  ID="ch1056"The second argument to XtMakeGeometryRequest is a pointer to an ID="ch1057"XtWidgetGeometry structure.  This structure contains the parameters of the widget's geometry request: the intended x, y, width, height, border width, and stacking mode.  The structure also contains a bitmask with a bit for each parameter.  If a bit is set, the widget intends to set the corresponding parameter to the intended value.  If a bit is not set, the widget does not care about the corresponding parameter, and the parent is free to change it.  ID="ch1058"The third argument to XtMakeGeometryRequest is a pointer to another ID="ch1059"XtWidgetGeometry structure.  This argument is valid only when the return value is ID="ch1060"XtGeometryAlmost.  In that case the argument, if not NULL, returns the parameters of the parent's compromise geometry.  ID="ch1061"LBL="10.1.3" HELPID=""The geometry_manager ProcedureID="ch1062"ID="ch1063"When a managed child widget makes a geometry request of a realized parent, XtMakeGeometryRequest invokes the parent's ID="ch1064"geometry_manager procedure.  The arguments are the same as those to XtMakeGeometryRequest.  This routine examines the bitmask (the request_mode member) and the requested geometry parameters in the XtWidgetGeometry† †structure provided by the child.  If the ID="ch1065"geometry_manager routine can satisfy the request, it has two choices: Change the appropriate geometry resources of the child and return XtGeometryYes to XtMakeGeometryRequest.  If the child is a widget, ID="ch1066"ID="ch1067"XtMakeGeometryRequest then calls XConfigureWindow to change the geometry of the child's window.  If the child is not a widget, ID="ch1068"XtMakeGeometryRequest clears both the old and the new areas occupied by the child.  XtMakeGeometryRequest does not call the child's resize† †procedure.  It returns ID="ch1069"ID="ch1070"XtGeometryYes to the child.  Call XtConfigureWidget, XtMoveWidget, or ID="ch1071"ID="ch1072"XtResizeWidget on the child, and return XtGeometryDone to ID="ch1073"ID="ch1074"XtMakeGeometryRequest.  ID="ch1075"XtConfigureWidget, XtMoveWidget, and XtResizeWidget configure the child's window or clear the old and new areas occupied by the child, and when the child's size changes, they call its resize† †procedure.  ID="ch1076"ID="ch1077"XtMakeGeometryRequest returns XtGeometryYes to the child.  ID="ch1078"To satisfy a child's geometry request, the geometry_manager† †routine may need to move or resize other children.  It uses ID="ch1079"ID="ch1080"XtConfigureWidget, XtMoveWidget, or ID="ch1081"ID="ch1082"XtResizeWidget to do this.  A ID="ch1083"geometry_manager procedure that returns XtGeometryDone† †calls these routines on the child making the request as well.  The difference between answers of ID="ch1084"XtGeometryDone and XtGeometryYes is as follows: ID="ch1085"XtGeometryDone means that the geometry_manager routine has called the child's ID="ch1086"resize procedure if the child's size changes.  ID="ch1087"ID="ch1088"XtGeometryYes means that neither the geometry_manager† †routine nor ID="ch1089"ID="ch1090"ID="ch1091"XtMakeGeometryRequest calls the child's resize† †procedure.  The caller of ID="ch1092"XtMakeGeometryRequest must call the child's resize procedure if necessary.  XtGeometryDone means that the geometry_manager routine has configured the child's window or cleared the old and new areas occupied by the child.  ID="ch1093"ID="ch1094"ID="ch1095"XtGeometryYes means that XtMakeGeometryRequest should do this.  ID="ch1096"ID="ch1097"The geometry_manager procedures for Motif widgets return ID="ch1098"ID="ch1099"XtGeometryYes, not XtGeometryDone, and they do not call the ID="ch10100"ID="ch10101"resize procedure of the child making the geometry request.  ID="ch10102"ID="ch10103"The geometry_manager procedure may be able to satisfy some but not all of a child's request.  For example, it may be able to grant the requested width, but not the requested height.  In this case the ID="ch10104"ID="ch10105"geometry_manager procedure may offer the child a compromise geometry.  It fills in the reply XtWidgetGeometry structure with the parameters it intends to allow, and it sets the corresponding bit in the reply bitmask for any parameter it intends to change from the value requested.  It then caches these parameters and returns ID="ch10106"XtGeometryAlmost to the child.  If the child immediately makes another geometry request using the compromise parameters, the ID="ch10107"geometry_manager procedure must grant the request if it can.  LBL="10.1.4" HELPID=""Intermediate Geometry RequestsOften a parent widget must change its own geometry in order to satisfy a child's request.  The parent's geometry_manager procedure uses ID="ch10108"ID="ch10109"XtMakeGeometryRequest to ask its own parent for a geometry change.  If ID="ch10110"XtMakeGeometryRequest to the grandparent returns XtGeometryYes, the parent's actions depend on whether the widget set's policy is for a ID="ch10111"geometry_manager procedure to return XtGeometryDone or XtGeometryYes when it grants a request: ID="ch10112"With an XtGeometryDone policy, the geometry_manager† †procedure calls the requesting widget's ID="ch10113"ID="ch10114"ID="ch10115"resize procedure.  During a successful intermediate request, the grandparent's ID="ch10116"ID="ch10117"geometry_manager procedure calls the parent's resize procedure.  The parent widget's geometry_manager and resize procedures must cooperate to ensure that, before the child's request is granted, the child is given the geometry it requested and the child's resize procedure is called.  The parent's geometry_manager procedure then returns XtGeometryDone.  ID="ch10118"With an XtGeometryYes policy, the geometry_manager procedure does not call the requesting widget's ID="ch10119"ID="ch10120"ID="ch10121"resize procedure.  During a successful intermediate request, the grandparent's ID="ch10122"ID="ch10123"geometry_manager procedure does not call the parent's resize procedure.  The parent widget's geometry_manager procedure updates the requesting child's geometry fields and may resize other children, but it should not call the requesting child's resize procedure.  The parent may call its own resize procedure so long as that routine does not call the requesting child's resize procedure.  The parent's geometry_manager procedure then returns XtGeometryYes.  Sometimes the parent needs to make a geometry request to its own parent just to find out whether the grandparent will accept a proposed change.  For example, the parent may intend to offer a compromise geometry to the child but must first determine whether the grandparent will allow the parent to change its own geometry in order to offer the compromise.  In this case the parent does not want the grandparent actually to make the proposed change; it just wants the grandparent to tell the parent whether the change is acceptable.  In making its own geometry request to the grandparent, the parent sets the XtCWQueryOnly bit in the request bitmask.  The grandparent can return ID="ch10124"XtGeometryYes, but it must not actually change any of its children.  The parent then returns ID="ch10125"XtGeometryAlmost to the child, along with its compromise parameters.  If the child accepts the compromise, the parent repeats its request to the grandparent without setting ID="ch10126"XtCWQueryOnly.  The grandparent should grant the parent's request, and the parent can then grant the child's request.  If the grandparent's response is XtGeometryAlmost and the parent still wishes to offer a compromise to the child, it caches the grandparent's reply and returns ID="ch10127"XtGeometryAlmost to the child.  If the child accepts this compromise, the parent then makes another request of the grandparent, using the cached compromise parameters from the grandparent and without setting XtCWQueryOnly.  The grandparent should grant the parent's request, and the parent can then grant the child's request.  ID="ch10128"LBL="10.1.5" HELPID=""XtSetValuesWhen a user or application invokes XtSetValues on a geometry resource, ID="ch10129"XtSetValues makes a geometry request.  After invoking all the widget's set_values procedures, ID="ch10130"ID="ch10131"XtSetValues checks for changes to any geometry resources.  If any of those resources have changed, it sets their values to those in effect before XtSetValues was called and then makes a geometry request with the new values as the requested geometry parameters.  If the geometry request returns XtGeometryYes, XtSetValues† †calls the widget's ID="ch10132"resize procedure.  If the parent's ID="ch10133"ID="ch10134"geometry_manager procedure returns ID="ch10135"ID="ch10136"XtGeometryDone, XtSetValues does not call the widget's ID="ch10137"resize procedure.  If the geometry request returns XtGeometryNo or ID="ch10138"XtGeometryAlmost, XtSetValues calls the widget's ID="ch10139"ID="ch10140"set_values_almost procedure, passing it the request and reply ID="ch10141"ID="ch10142"XtWidgetGeometry structures.  If the request returns ID="ch10143"XtGeometryNo, the bitmask in the reply structure is 0.  The set_values_almost procedure can accept a compromise geometry by copying the reply parameters into the request structure.  It can also construct another request by altering the request structure, or it can end the negotiation by setting the request bitmask to 0.  If the request bitmask is nonzero when the set_values_almost procedure returns, XtSetValues makes another geometry request and treats the result in the same way as for the original request.  A widget's set_values procedure can initiate a geometry request by changing any of the geometry resources.  For example, if ID="ch10144"ID="ch10145"XtSetValues is invoked on a Label's text, the ID="ch10146"ID="ch10147"set_values procedure can calculate how large the widget should be to contain the new text and then set the relevant geometry fields accordingly.  The set_values procedure should not do any resizing itself; in particular, it should not resize any child widgets, because the geometry request might be denied.  Resizing is usually done in the widget's resize procedure.  The widget's ID="ch10148"ID="ch10149"set_values_almost procedure may need to restore some widget state in the event the geometry request is denied.  ID="ch10150"ID="ch10151"LBL="10.1.6" HELPID=""The resize ProcedureID="ch10152"ID="ch10153"A widget's resize procedure is invoked in the following circumstances: By XtConfigureWidget or XtResizeWidget when the parent resizes the widget ID="ch10154"ID="ch10155"By XtSetValues when the widget's geometry resources are changed and the resulting geometry request returns ID="ch10156"XtGeometryYes† †ID="ch10157"By the parent's geometry_manager procedure when it grants the widget's geometry request and is about to return ID="ch10158"ID="ch10159"XtGeometryDone† †ID="ch10160"In addition, a shell's resize procedure is invoked when the size of the shell is changed, often by a user through the window manager.  ID="ch10161"ID="ch10162"When the resize procedure is called, the widget's geometry resources contain the new values.  The ID="ch10163"ID="ch10164"resize procedure uses these values to recalculate the widget's layout.  In the process, it may move or resize child widgets.  The resize procedure must take its geometry resource values as given; it may not issue a geometry request.  A composite widget's resize procedure may need coordination with its ID="ch10165"ID="ch10166"geometry_manager procedure in handling a geometry request from a child when the parent must make its own geometry request to accommodate the child.  If the widget set's ID="ch10167"ID="ch10168"geometry_manager procedures return XtGeometryYes, a parent's geometry_manager procedure may call the parent's ID="ch10169"resize procedure after a successful request to the grandparent.  In this case, the resize procedure should not resize the child widget making the original geometry request.  This problem can be avoided if the geometry_manager and resize procedures call a common subroutine that performs layout, taking as an argument the child that is making the request (if any) so that the layout routine can avoid resizing that child.  If the widget set's geometry_manager procedures return ID="ch10170"ID="ch10171"XtGeometryDone, the grandparent's geometry_manager procedure calls the parent's ID="ch10172"resize procedure during a successful request to the grandparent.  In this case, the child's geometry resources may be different from the geometry parameters it is requesting at the time the parent's ID="ch10173"ID="ch10174"resize procedure is called.  This problem can be avoided if the parent's geometry_manager procedure sets the child's geometry resources to the requested values before making its own geometry request, setting them back to the original values if the parent's request is refused.  LBL="10.1.7" HELPID=""Preferred Size and LocationWhen calculating its layout, a parent widget may take account of a child's preferred size and location.  The parent uses XtQueryGeometry to inquire about a child's preferred geometry.  The parent passes to ID="ch10175"XtQueryGeometry pointers to two XtWidgetGeometry structures, one containing the parameters that the parent intends to impose and the other containing the preferred parameters returned by the child.  ID="ch10176"XtQueryGeometry then calls the child's query_geometry† †procedure with pointers to these two ID="ch10177"ID="ch10178"XtWidgetGeometry structures.  The child's query_geometry procedure determines the widget's preferred geometry and stores the parameters into the return ID="ch10179"ID="ch10180"XtWidgetGeometry structure, setting corresponding bits in the bitmask for fields that it cares about.  It then returns one of these values: ID="ch10181"If the parent's intended geometry is acceptable, it returns XtGeometryYes.  ID="ch10182"If the parent's and child's parameters differ for some field that both widget care about, or if the child has expressed interest in a field that the parent does not care about, it returns XtGeometryAlmost.  ID="ch10183"If the child's preferred geometry is the same as its current geometry, it returns XtGeometryNo.  ID="ch10184"After the query_geometry procedure returns, XtQueryGeometry† †fills in any fields in the return ID="ch10185"ID="ch10186"ID="ch10187"XtWidgetGeometry structure that the child does not care about with the current values of the resources in the child widget.  ID="ch10188"XtQueryGeometry returns the value returned by the query_geometry procedure.  Most composite widgets should call XtQueryGeometry whenever they intend to change the geometry of a child that is not in the process of making a geometry request.  A ID="ch10189"geometry_manager procedure should not call XtQueryGeometry† †for the child making the request.  For a widget making a geometry request, the requested geometry is the preferred geometry.  ID="ch10190"ID="ch10191"ID="ch10192"This can be problem for widget sets whose geometry_manager† †procedures call the ID="ch10193"ID="ch10194"resize procedure for the child making the request and then return ID="ch10195"ID="ch10196"XtGeometryDone.  During a successful intermediate geometry request, the grandparent calls the parent's ID="ch10197"resize procedure.  This procedure in turn may resize the child making the original request, but it cannot reliably use XtQueryGeometry to determine the child's preferred geometry.  Indeed, the parent's ID="ch10198"resize procedure may not know which child is making the request or even that it is being invoked as a result of a child's geometry request.  The parent widget's geometry_manager procedure may need to arrange to communicate this information to the parent's resize procedure.  LBL="10.1.8" HELPID=""Exposure and RedisplayA widget may recompute its layout in its resize, set_values, or ID="ch10199"ID="ch10200"ID="ch10201"ID="ch10202"geometry_manager procedure, but usually it does not actually generate the window contents in those procedures.  A widget usually regenerates its window contents in response to an ID="ch10203"ID="ch10204"Expose event, which causes the widget's expose procedure to be invoked.  This procedure takes as arguments the widget, the event, and the set of rectangles to be redisplayed.  Using the current state of the widget (including its geometry resources), the ID="ch10205"ID="ch10206"ID="ch10207"expose procedure generates the contents of either the affected rectangles or the window as a whole.  XtConfigureWidget, XtResizeWidget, and XtMoveWidget† †call ID="ch10208"ID="ch10209"ID="ch10210"XConfigureWindow, XMoveWindow, or XClearArea as appropriate.  These functions cause the server to generate ID="ch10211"ID="ch10212"ID="ch10213"Expose events when necessary.  ID="ch10214"XtMakeGeometryRequest also calls XConfigureWindow or ID="ch10215"XClearArea when the parent's geometry_manager procedure returns ID="ch10216"ID="ch10217"XtGeometryYes.  When the ID="ch10218"geometry_manager procedure returns XtGeometryDone† †it must call ID="ch10219"XConfigureWindow or XClearArea itself (perhaps indirectly).  LBL="10.2" HELPID=""Shells and Their ChildrenID="ch10220"Shell widgets encapsulate application widgets, principally to communicate with the window manager.  Motif has three shell classes based on Intrinsics shell classes: VendorShellSubclass of ID="ch10221"WMShell and superclass for other shell classes that contain both persistent top-level widgets and dialogs ID="ch10222"XmDialogShell Subclass of ID="ch10223"ID="ch10224"TransientShell (which is a subclass of ID="ch10225"VendorShell) used to contain dialog widgets, commonly subclasses of ID="ch10226"XmBulletinBoard† †ID="ch10227"ID="ch10228"XmMenuShell Subclass of ID="ch10229"ID="ch10230"OverrideShell used to contain RowColumn PulldownMenu and PopupMenu widgets ID="ch10231"ID="ch10232"ID="ch10233"ID="ch10234"A shell has only one managed child.  Except when a shell contains an off-the-spot input method, the shell's window is coincident with the child's window.  The geometry_manager procedures of the shell classes treat geometry requests from the child as geometry requests for the shell, and the ID="ch10235"ID="ch10236"resize procedures of the shell classes make the child the same size as the shell.  Applications should usually change the geometry of the child, not of the shell.  ID="ch10237"ID="ch10238"In particular, setting XmNheight, XmNwidth, or ID="ch10239"ID="ch10240"XmNborderWidth for either a shell or its child sets that resource to the same value in both the parent and the child.  For a child of a shell, setting ID="ch10241"XmNx or XmNy sets the corresponding resource of the parent but does not change the child's position relative to the parent.  ID="ch10242"ID="ch10243"XtGetValues for the child's XmNx or XmNy yields the value of the corresponding resource in the parent.  The x and y coordinates of the child's upper left outside corner relative to the parent's upper left inside corner are both zero minus the value of ID="ch10244"XmNborderWidth.  The exception is a VendorShell or DialogShell that contains an off-the-spot input method.  In this case, the input method appears inside the shell and below the application widget.  The conventions for geometry parameters are the same as for other shells, except that the values of ID="ch10245"ID="ch10246"ID="ch10247"XmNheight for the child and the shell are not identical.  The height of the shell is the sum of the height and border width of the application window and the height of the area occupied by the input method.  ID="ch10248"When the Shell resource XmNallowShellResize is False, a shell's ID="ch10249"ID="ch10250"geometry_manager procedure returns XtGeometryNo for all geometry requests from a realized child.  ID="ch10251"ID="ch10252"ID="ch10253"LBL="10.3" HELPID=""Manager Widgets and Their ChildrenID="ch10254"Each Primitive widget has resources that determine its layout or contents.  For example, the size of a Text widget depends on the values of the ID="ch10255"ID="ch10256"XmNrows, XmNcolumns, XmNmarginHeight, and ID="ch10257"ID="ch10258"ID="ch10259"XmNmarginWidth Text resources; the XmNhighlightThickness and ID="ch10260"ID="ch10261"XmNshadowThickness Primitive resources; and the basic Core geometry resources.  In addition, when the Text ID="ch10262"ID="ch10263"ID="ch10264"XmNresizeHeight or XmNresizeWidth† †resource is True, the size of the widget can depend on the size of the text (the ID="ch10265"ID="ch10266"XmNvalue resource).  Setting any of these resources can cause Text to generate a geometry request.  ID="ch10267"Manager widgets have their own layout policies, which they use in responding to geometry requests from their children or to resizing by their parents.  These policies are determined by the Manager's own resources and, for some Managers, by its constraint resources.  ID="ch10268"Constraints are resources defined by the Manager but associated with each child.  An application or user initializes, sets, or gets constraint resources for the child as if they were resources defined by the child's class.  Initialization, ID="ch10269"ID="ch10270"XtSetValues, and XtGetValues for the child operate on the parent's constraint resources associated with that child.  The Manager has constraint ID="ch10271"ID="ch10272"initialize and set_values† †procedures that allow it to set other constraints and recompute its layout.  ID="ch10273"ID="ch10274"ID="ch10275"ID="ch10276"ID="ch10277"ID="ch10278"Motif uses constraints in determining the layout of Form, PanedWindow, and Frame widgets.  Motif also uses constraints to adjust the positions of child widgets in PanedWindow and RowColumn.  The Form widget is discussed in ID="ch10279"ID="ch10280"ID="ch10281"ID="ch10282"IDREF="24431" TYPE="TITLE"Section 10.6, "Managing Geometry Using Form."
  PanedWindow and Frame are discussed in IDREF="21296" TYPE="TITLE"Chapter 9, "Scrolling, Panes, and Frames."
† †LBL="10.4" HELPID=""Managing Geometry Using RowColumnID="ch10283"In addition to its role as the menu widget, RowColumn provides general-purpose layout and geometry management for child widgets arranged in rows, columns, or grids.  The default RowColumn type, XmWORK_AREA, provides the layout features but not the menu semantics.  ID="ch10284"RowColumn's layout is controlled by two sets of resources.  One set determines the position of children within the parent.  The other set specifies whether RowColumn adjusts the internal layout characteristics of the children, such as margins and text alignment.  ID="ch10285"The two primary resources that control child positioning are XmNorientation and XmNpacking.  ID="ch10286"ID="ch10287"XmNorientation determines whether RowColumn lays out its children in rows or columns.  When ID="ch10288"XmNorientation is XmVERTICALname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the default for a WorkAreaname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the layout is column-major.  When ID="ch10289"ID="ch10290"XmNorientation is XmHORIZONTAL the layout is row-major.  ID="ch10291"XmNpacking controls the general style of the layout.  The resource has three possible values: ID="ch10292"XmPACK_TIGHT RowColumn places children one after the other along the major dimension (for example, in a column when ID="ch10293"XmNorientation is XmVERTICAL).  It proceeds until no more children fit along that dimension and then begins a new row or column.  When ID="ch10294"ID="ch10295"XmNorientation is XmVERTICAL and the vertical distance remaining in the current column is too small to accommodate the child being placed, RowColumn begins a new column if XmNresizeHeight is False or the RowColumn cannot become larger.  When placing children in a column, RowColumn does not alter their heights, but it makes the width of each child in the column equal to the width of the widest child in that column.  Analogous rules apply to row-major layouts.  ID="ch10296"ID="ch10297"XmPACK_TIGHT is the default value for XmNpacking in a WorkArea.  ID="ch10298"ID="ch10299"XmPACK_COLUMN RowColumn makes the width and height of each child identical.  The width is the maximum width of all children, and the height is the maximum height.  RowColumn uses the value of ID="ch10300"XmNnumColumns to determine the maximum number of columns (in ID="ch10301"ID="ch10302"XmVERTICAL orientation) or rows (in ID="ch10303"XmHORIZONTAL orientation) to produce.  RowColumn tries to create ID="ch10304"XmNnumColumns columns (or rows) with an equal number of children in each column (or row).  XmPACK_NONE RowColumn does not change the position of any child.  Unless ID="ch10305"XmNresizeWidth is False, it tries to grow large enough to enclose the greatest x extent of any child.  Unless ID="ch10306"XmNresizeHeight is False, it tries to grow large enough to enclose the greatest y extent of any child.  ID="ch10307"Several other resources influence the position and size of children: XmNadjustLast This resource applies only when ID="ch10308"XmNpacking is XmPACK_TIGHT† †or ID="ch10309"ID="ch10310"XmPACK_COLUMN.  When this resource is True and the orientation is vertical, RowColumn increases the widths of children in the last column when necessary so that all children extend to the right edge of the RowColumn.  When this resource is True and the orientation is horizontal, RowColumn increases the heights of children in the last row when necessary so that all children extend to the bottom edge of the RowColumn.  ID="ch10311"ID="ch10312"XmNentryBorder When this resource is nonzero, it specifies the border width for all children of the RowColumn.  When this resource is zero, RowColumn does not alter the border width of its children.  ID="ch10313"ID="ch10314"XmNmarginHeight This resource specifies the amount of space between the top edge of the RowColumn and the first item in each column, and between the bottom edge of the RowColumn and the last item in each column.  ID="ch10315"ID="ch10316"XmNmarginWidth This resource specifies the amount of space between the left edge of the RowColumn and the first item in each row, and between the right edge of the RowColumn and the last item in each row.  ID="ch10317"ID="ch10318"XmNresizeHeight When this resource is True, RowColumn adjusts its own height when possible to accommodate its children.  When this resource is False, RowColumn does not request a new height during layout.  ID="ch10319"ID="ch10320"XmNresizeWidthWhen this resource is True, RowColumn adjusts its own width when possible to accommodate its children.  When this resource is False, RowColumn does not request a new width during layout.  ID="ch10321"ID="ch10322"XmNspacingThis resource applies only when ID="ch10323"XmNpacking is XmPACK_TIGHT† †or ID="ch10324"ID="ch10325"XmPACK_COLUMN.  It specifies the amount of vertical space between each child in a vertical orientation and the amount of horizontal space between each child in a horizontal orientation.  ID="ch10326"RowColumn also has several resources that can cause the RowColumn to change the internal layout of some classes of children: ID="ch10327"XmNadjustMargin This resource applies only to children that are subclasses of ID="ch10328"XmLabel and XmLabelGadget.  When this resource is True and the orientation is vertical, RowColumn sets the ID="ch10329"ID="ch10330"ID="ch10331"ID="ch10332"ID="ch10333"XmNmarginLeft and XmNmarginRight for all children to the maximum values for those resources among all children.  When this resource is True and the orientation is horizontal, RowColumn sets the ID="ch10334"ID="ch10335"XmNmarginTop and XmNmarginBottom for all children to the maximum values for those resources among all children.  In PopupMenus and PulldownMenus RowColumn this resource is adjusts the margins only for button children, not for labels.  ID="ch10336"ID="ch10337"ID="ch10338"ID="ch10339"XmNentryAlignment This resource applies only to children that are subclasses of ID="ch10340"XmLabel and XmLabelGadget.  When ID="ch10341"ID="ch10342"ID="ch10343"ID="ch10344"XmNisAligned is True, RowColumn sets the XmNalignment† †of all children to the value specified by ID="ch10345"ID="ch10346"ID="ch10347"XmNentryAlignment.  Following are the possible values: XmALIGNMENT_BEGINNING -- The child's text or pixmap is aligned with the left edge of the child's window.  ID="ch10348"XmALIGNMENT_CENTER -- The child's text or pixmap is aligned with the center of the child's window.  ID="ch10349"XmALIGNMENT_END -- The child's text or pixmap is aligned with the right edge of the child's window.  ID="ch10350"In menus RowColumn sets the alignment only for button children, not for labels.  ID="ch10351"XmNentryVerticalAlignment This resource applies only to children that are subclasses of ID="ch10352"XmLabel, XmLabelGadget, XmText, and XmTextField.  It also applies only when ID="ch10353"ID="ch10354"ID="ch10355"ID="ch10356"ID="ch10357"ID="ch10358"ID="ch10359"ID="ch10360"XmNpacking is XmPACK_COLUMN (in either orientation) or when ID="ch10361"ID="ch10362"XmNpacking is XmPACK_TIGHT and the orientation is horizontal.  The value specifies a reference point for aligning the children in any row: ID="ch10363"XmALIGNMENT_BASELINE_BOTTOM -- Causes the last baseline of each child in a row to align with the last baseline of the tallest child in the row.  This value is applicable only when all children in a row contain textual data.  ID="ch10364"XmALIGNMENT_BASELINE_TOP -- Causes the first baseline of each child in a row to align with the first baseline of the tallest child in the row.  This value is applicable only when all children in a row contain textual data.  ID="ch10365"XmALIGNMENT_BOTTOM -- Causes the bottom edge of the last line of text contained in each child to align with the bottom edge of the last line of text of the tallest child in the row.  ID="ch10366"XmALIGNMENT_CENTER -- Causes the center of each child to align vertically with the center point established by the tallest child in the row.  ID="ch10367"XmALIGNMENT_TOP -- Causes the top edge of the first line of text contained in each child to align with the top edge of the first line of text of the tallest child in the row.  ID="ch10368"XmNisAligned When True, RowColumn sets the ID="ch10369"XmNalignment resources of children that are subclasses of ID="ch10370"ID="ch10371"XmLabel or XmLabelGadget to the value specified by ID="ch10372"ID="ch10373"ID="ch10374"ID="ch10375"XmNentryAlignment.  ID="ch10376"LBL="10.5" HELPID=""Managing Geometry Using BulletinBoard and DrawingAreaID="ch10377"ID="ch10378"BulletinBoard and DrawingArea are two container widgets with similar geometry policies.  These widgets have three geometry-related resources in common: XmNmarginHeight Specifies the amount of space between the top shadow of the widget and the top edge of any child, and between the bottom shadow of the widget and the bottom edge of any child.  When the value of this resource is greater than 0, the widget ensures that the top edges of all children are below the widget's top margin.  ID="ch10379"XmNmarginWidth Specifies the amount of space between the left shadow of the widget and the left edge of any child, and between the right shadow of the widget and the right edge of any child.  When the value of this resource is greater than 0, the widget ensures that the left edges of all children are to the right of the widget's left margin.  ID="ch10380"XmNresizePolicy Determines the widget's policy with regard to resize requests from its children.  Following are the possible values: ID="ch10381"XmRESIZE_NONE -- The widget has a fixed size determined by its ID="ch10382"XmNwidth and ID="ch10383"XmNheight.  The widget does not accept any geometry requests that would cause it to grow, but it may accept requests (without changing its own size) that would not cause it to grow.  The widget also reports its current size as its own preferred size.  ID="ch10384"XmRESIZE_GROW -- The widget can grow but not shrink.  If its own parent approves, the widget accepts geometry requests that cause it to grow in order to enclose its children.  It may accept requests (without changing its own size) that would not cause it to grow.  When queried about its own preferred size, the widget calculates its layout and reports as its preference the greater of the calculated width and height and the current width and height.  ID="ch10385"XmRESIZE_ANY -- The widget tries to accommodate geometry requests that would cause it to grow or shrink in order to enclose its children, requesting changes to its own size when necessary.  When queried about its own preferred size, the widget calculates its layout and reports the calculated width and height as its preference.  ID="ch10386"In addition to these policies, BulletinBoard has geometry facilities that allow it to interact with subclasses in laying out complex collections of children.  For example, SelectionBox has a List containing choices, a Text selection area, labels for the list and selection area, and three or four buttons.  Usually the list appears above the selection area.  The buttons appear equally spaced in a row below the selection area.  ID="ch10387"ID="ch10388"ID="ch10389"ID="ch10390"Additional children may be added to the SelectionBox after creation.  The first child is used as a work area.  The value of ID="ch10391"XmNchildPlacement determines if the work area is placed above or below the Text area, or above or below the List area.  Additional children are laid out in the following manner: ID="ch10392"ID="ch10393"ID="ch10394"MenuBarThe first MenuBar child is placed at the top of the window.  ID="ch10395"ButtonsAll XmArrowButton, XmDrawnButton, ID="ch10396"ID="ch10397"ID="ch10398"ID="ch10399"XmPushButton, and XmToggleButton widgets or gadgets, and their subclasses are placed after the OK button in the order of their creation.  ID="ch10400"ID="ch10401"ID="ch10402"ID="ch10403"OthersThe layout of additional children that are not in the above categories is undefined.  LBL="10.6" HELPID=""ID="24431"Managing Geometry Using FormID="ch10404"Form is a container widget that provides the most comprehensive facilities for controlling the layout of children.  Constraints are placed on children of the Form to define attachments for each of the child's four sides.  These attachments can be to the Form, to another child widget or gadget, to a relative position within the Form, or to the initial position of the child.  The attachments determine the layout behavior of the Form when resizing occurs.  Form is a subclass of BulletinBoard, so the resources and general geometry policies of BulletinBoard apply to Form as well.  ID="ch10405"ID="ch10406"Each child has 17 Form constraint resources, four for each side of the child and one, ID="ch10407"XmNresizable, that applies to the child as a whole.  Following is a description of ID="ch10408"XmNresizable and the constraint resources that apply to the top side of a child: XmNresizableThis Boolean resource specifies whether or not a child's request for a new size is (conditionally) granted by the Form.  If this resource is set to True, the request is granted if possible.  If this resource is set to False, the request is always refused.  ID="ch10409"ID="ch10410"If a child has both left and right attachments, its width is completely controlled by the Form, regardless of the value of the child's ID="ch10411"XmNresizable resource.  If a child has a left or right attachment but not both, the child's ID="ch10412"XmNwidth is used in setting its width if the value of the child's ID="ch10413"XmNresizable resource is True.  These conditions are also true for top and bottom attachments, with height acting like width.  XmNtopAttachment Specifies attachment of the top side of the child.  It can have following values: ID="ch10414"XmATTACH_NONE -- Do not attach the top side of the child.  If ID="ch10415"XmNbottomAttachment is also XmATTACH_NONE, this value is ignored and the child is given a default top attachment.  ID="ch10416"ID="ch10417"XmATTACH_FORM -- Attach the top side of the child to the top side of the Form.  ID="ch10418"ID="ch10419"XmATTACH_OPPOSITE_FORM -- Attach the top side of the child to the bottom side of the Form.  ID="ch10420"ID="ch10421"XmNtopOffset can be used to determine the visibility of the child.  ID="ch10422"XmATTACH_WIDGET -- Attach the top side of the child to the bottom side of the widget or gadget specified in the ID="ch10423"XmNtopWidget resource.  If ID="ch10424"XmNtopWidget is NULL, XmATTACH_WIDGET is replaced by ID="ch10425"ID="ch10426"XmATTACH_FORM, and the child is attached to the top side of the Form.  ID="ch10427"ID="ch10428"XmATTACH_OPPOSITE_WIDGET -- Attach the top side of the child to the top side of the widget or gadget specified in the ID="ch10429"XmNtopWidget resource.  ID="ch10430"XmATTACH_POSITION -- Attach the top side of the child to a position that is relative to the top side of the Form and in proportion to the height of the Form.  This position is determined by the ID="ch10431"ID="ch10432"XmNtopPosition and ID="ch10433"XmNfractionBase resources.  ID="ch10434"XmATTACH_SELF  -- Attach the top side of the child to a position that is proportional to the current y value of the child divided by the height of the Form.  This position is determined by the ID="ch10435"ID="ch10436"XmNtopPosition and ID="ch10437"XmNfractionBase resources.  ID="ch10438"XmNtopPosition is set to a value proportional to the current y value of the child divided by the height of the Form.  XmNtopOffsetSpecifies the constant offset between the top side of the child and the object to which it is attached.  The relationship established remains, regardless of any resizing operations that occur.  ID="ch10439"XmNtopPosition This resource is used to determine the position of the top side of the child when the child's ID="ch10440"XmNtopAttachment is set to ID="ch10441"XmATTACH_POSITION.  In this case, the position of the top side of the child is relative to the top side of the Form and is a fraction of the height of the Form.  This fraction is the value of the child's ID="ch10442"ID="ch10443"XmNtopPosition resource divided by the value of the Form's XmNfractionBase.  For example, if the child's ID="ch10444"XmNtopPosition is 50, the Form's XmNfractionBase is 100, and the Form's height is 200, the position of the top side of the child is 100.  XmNtopWidget Specifies the widget or gadget to which the top side of the child is attached.  This resource is used if ID="ch10445"XmNtopAttachment is set to either ID="ch10446"XmATTACH_WIDGET or XmATTACH_OPPOSITE_WIDGET.  ID="ch10447"ID="ch10448"These constraint resources interact with the following resources of the Form itself: ID="ch10449"XmNfractionBaseSpecifies the denominator used in calculating the relative position of a child widget using ID="ch10450"XmATTACH_POSITION constraints.  The value must not be 0.  ID="ch10451"If the value of a child's XmNleftAttachment (or ID="ch10452"XmNrightAttachment) is XmATTACH_POSITION, the position of the left (or right) side of the child is relative to the left side of the Form and is a fraction of the width of the Form.  This fraction is the value of the child's ID="ch10453"ID="ch10454"ID="ch10455"XmNleftPosition (or ID="ch10456"XmNrightPosition) resource divided by the value of the Form's ID="ch10457"XmNfractionBase.  ID="ch10458"If the value of a child's XmNtopAttachment (or ID="ch10459"XmNbottomAttachment) is XmATTACH_POSITION, the position of the top (or bottom) side of the child is relative to the top side of the Form and is a fraction of the height of the Form.  This fraction is the value of the child's ID="ch10460"ID="ch10461"ID="ch10462"XmNtopPosition (or ID="ch10463"XmNbottomPosition) resource divided by the value of the Form's ID="ch10464"XmNfractionBase.  ID="ch10465"XmNhorizontalSpacing Specifies the offset for right and left attachments.  ID="ch10466"XmNrubberPositioning Indicates the default near (left) and top attachments for a child of the Form.  Whether this resource actually applies to the left or right side of the child and its attachment may depend on the value of the ID="ch10467"ID="ch10468"XmNstringDirection resource.) ID="ch10469"Whether this resource actually applies to the left or right side of the child and its attachment may depend on the value of the XmNstringDirection resource.The default left attachment is applied whenever initialization or XtSetValues leaves the child without either a left or right attachment.  The default top attachment is applied whenever initialization or ID="ch10470"XtSetValues leaves the child without either a top or bottom attachment.  If this Boolean resource is set to False, XmNleftAttachment and ID="ch10471"XmNtopAttachment default to XmATTACH_FORM, ID="ch10472"ID="ch10473"XmNleftOffset defaults to the current x value of the left side of the child, and ID="ch10474"XmNtopOffset defaults to the current y value of the child.  The effect is to position the child according to its absolute distance from the left or top side of the Form.  ID="ch10475"ID="ch10476"If this resource is set to True, XmNleftAttachment and ID="ch10477"XmNtopAttachment default to XmATTACH_POSITION, ID="ch10478"ID="ch10479"XmNleftPosition defaults to a value proportional to the current x value of the left side of the child divided by the width of the Form, and ID="ch10480"XmNtopPosition defaults to a value proportional to the current y value of the child divided by the height of the Form.  The effect is to position the child relative to the left or top side of the Form and in proportion to the width or height of the Form.  ID="ch10481"ID="ch10482"XmNverticalSpacingSpecifies the offset for top and bottom attachments.  ID="ch10483"Following are some important considerations in using a Form: ID="ch10484"Every child must have an attachment on either the left or the right.  If initialization or XtSetValues leaves a widget without such an attachment, the result depends upon the value of ID="ch10485"XmNrubberPositioning.  ID="ch10486"If XmNrubberPositioning is False, the child is given an ID="ch10487"XmNleftAttachment of XmATTACH_FORM and an ID="ch10488"ID="ch10489"XmNleftOffset equal to its current x value.  ID="ch10490"If XmNrubberPositioning is True, the child is given an ID="ch10491"XmNleftAttachment of XmATTACH_POSITION and an ID="ch10492"ID="ch10493"XmNleftPosition proportional to the current x value divided by the width of the Form.  ID="ch10494"ID="ch10495"In either case, if the child has not been previously given an x value, its x value is taken to be 0, which places the child at the left side of the Form.  ID="ch10496"If you want to create a child without any attachments, and then later (for example, after creating and managing it, but before realizing it) give it a right attachment using XtSetValues, you must set its ID="ch10497"XmNleftAttachment to XmATTACH_NONE at the same time.  ID="ch10498"ID="ch10499"The XmNresizable resource controls only whether a geometry request by the child will be granted.  It has no effect on whether the child's size can be changed because of changes in geometry of the Form or of other children. ID="ch10500"Every child has a preferred width, based on geometry requests it makes (whether they are granted or not).  If a child has attachments on both the left and the right sides, its size is completely controlled by the Form.  It can be shrunk below its preferred width or enlarged above it, if necessary, due to other constraints.  In addition, the child's geometry requests to change its own width may be refused.  ID="ch10501"If a child has attachments on only its left or right side, it will always be at its preferred width (if resizable, otherwise at is current width).  This may cause it to be clipped by the Form or by other children.  ID="ch10502"If a child's left (or right) attachment is set to XmATTACH_SELF, its corresponding left (or right) offset is forced to 0.  The attachment is then changed to ID="ch10503"XmATTACH_POSITION, with a position that corresponds to the x value of the child's left (or right) edge.  To fix the position of a side at a specific x value, use ID="ch10504"XmATTACH_FORM or XmATTACH_OPPOSITE_FORM with the x value as the left (or right) offset.  ID="ch10505"ID="ch10506"Unmapping a child has no effect on the Form except that the child is not mapped.  ID="ch10507"Unmanaging a child unmaps it.  If no other child is attached to it, or if all children attached to it and all children recursively attached to them are also all unmanaged, all of those children are treated as if they did not exist in determining the size of the Form.  ID="ch10508"When using XtSetValues to change the XmNx resource of a child, you must simultaneously set its left attachment to either ID="ch10509"ID="ch10510"XmATTACH_SELF or XmATTACH_NONE.  Otherwise, the request is not granted.  If ID="ch10511"ID="ch10512"XmNresizable is False, the request is granted only if the child's size can remain the same.  ID="ch10513"A left (or right) attachment of XmATTACH_WIDGET, where ID="ch10514"XmNleftWidget (or XmNrightWidget) is NULL, acts like an attachment of ID="ch10515"ID="ch10516"XmATTACH_FORM.  ID="ch10517"If an attachment is made to a widget that is not a child of the Form, but an ancestor of the widget is a child of the Form, the attachment is made to the ancestor.  ID="ch10518"All these considerations are true of top and bottom attachments as well, with top acting like left, bottom acting like right, y acting like x, and height acting like width.  LBL="11"ID="22857"InternationalizationID="ch111"Internationalization is a method of application development that allows the application to be run in many different languages without having to be rewritten or recompiled.  This chapter describes how to design applications to use Motif's internationalization capability.  It is not a general discussion of internationalization.  LBL="11.1" HELPID=""Issues in Internationalized ApplicationsThere are several important issues to keep in mind when designing an application so that it takes advantage of Motif's internationalization capabilities.  LBL="11.1.1" HELPID=""Internationalization and LocalizationAn internationalized application contains no code that is dependent on the user's language, the characters needed to represent that language, or any formats (such as date and currency) that the user expects to see and interact with.  Motif accomplishes this by storing language and custom dependent information outside the application.  The following figure  shows the kinds of information that should be external to an application to simplify internationalization. † †LBL="11-1" FILE="applsrc.gif" POSITION="INLINE" SCALE="FALSE"LBL="11-1"Figure 11-1 ID="16391"Information External to the ApplicationBecause the language and culture dependent information is separate from the application source code, the application does not need to be rewritten or recompiled to be marketed in a different countries.  Instead, the only requirement is for the external information to be localized to accommodate local language and custom.  ID="ch112"Localizing the application includes the process of translating certain parts of the external information into the appropriate language and storing the translated information in files that are then accessed by the application.  In addition, the application may be told the format to use to display time, date, and the other language or culture dependent formats shown in the previous figure.  ID="ch113"ID="ch114"Every language consists of a set of characters that, either individually or in combination, represents meaningful words or concepts in the language.  The set of characters is called a character set.  The set of binary values needed to represent all the characters in a language is called a coded character set or, more simply, a ID="ch115"code set.  ID="ch116"Several attempts were started long ago to standardize character sets and continue to this day.  The most commonly used code set for English is the American National Standard Code for Information Interchange (ASCII).  It originally used a 7-bit encoding scheme plus an eighth bit for error control.  Using 7 bits for character representation allows 128 unique binary values.  Later versions use the eighth bit as a code bit allowing 255 characters.  Both are fine for English and some other alphabetic languages, but neither is suitable for ideographic languages such as Chinese, Japanese, and Korean.  Ideographic languages represent a concept or an idea as a single character; consequently, there are thousands of characters in these languages, and two or more bytes are needed to represent the characters.  ID="ch117"ID="ch118"ID="ch119"Other standard code sets have been developed to accommodate other languages.  The ISO8859 standard is perhaps the most commonly used of these.  Different versions of the ISO8859 standard exist for various areas of the world.  The following table shows a typical language and character set relationship for various areas.  COLUMNS="2"LEFT="0" WIDTH="90"Area or LanguageLEFT="95" WIDTH="356"Character SetLEFT="0" WIDTH="90"EnglishLEFT="95" WIDTH="356"ASCII, 
ISO8859-1LEFT="0" WIDTH="90"Western EuropeLEFT="95" WIDTH="356"ISO8859-1LEFT="0" WIDTH="90"Eastern EuropeLEFT="95" WIDTH="356"ISO8859-2LEFT="0" WIDTH="90"Northern EuropeLEFT="95" WIDTH="356"ISO8859-3LEFT="0" WIDTH="90"Russia (Cyrillic)LEFT="95" WIDTH="356"ISO8859-5LEFT="0" WIDTH="90"HebrewLEFT="95" WIDTH="356"ISO8859-6LEFT="0" WIDTH="90"GreekLEFT="95" WIDTH="356"ISO8859-7, 8, 9 LEFT="0" WIDTH="90"JapanLEFT="95" WIDTH="356"Shift JISLEFT="0" WIDTH="90"JapanLEFT="95" WIDTH="356"UJISLBL="11-1"Table 11-1 Areas and Typical Character SetsSee the specifications for the American National Standards Institute (ANSI) C programming language and the X/Open Portability Guide, Issue 3 (XPG3) for more information on standards involved in internationalization.  LBL="11.1.2" HELPID=""Obtaining InputSpecial considerations must be made for the user of an application to input characters in the local written language.  Virtually all applications require some action on the part of the user, often asking for input in one form or another.  For example, an application can ask the user to input information in text form, such as name, home address, and so on.  The user must then enter this information by typing it on the keyboard in the normal manner.  This is done with relative ease in an English-based application but can become more complex when other language text is desired.  Motif uses Xlib functions to provide the basic support for obtaining input in a Text widget.  ID="ch1110"LBL="" HELPID=""The ProblemsMany languages are expressed by means of an alphabet made up of characters or letters.  The letters are arranged in groups to form meaningful words.  A keyboard suitable for the language normally contains all the letters of the alphabet, plus the standard numerals and punctuation marks.  The problem arises when the keyboard does not have all the alphabet characters.  This can happen when a German user is using an English-based keyboard and needs a German character such as "ﬂ" . ID="ch1111"A far more involved example is the case of defining a keyboard to use for the ideographic languages.  Because thousands of characters are needed to represent an ideographic language, no reasonable keyboard can be constructed with a single key for each character.  LBL="" HELPID=""The SolutionMotif solves these input problems by using an input method, which is a layer of mapping between the keyboard keys (or combinations of keys) that the user types and the text data that is passed to the application.  For example, the Swedish user with an English keyboard who needs the letter "ÿ" must enter a combination of keystrokes (this varies among vendors but could be ID="ch1112"<Extend char> <O> </> as an example) rather than just one keystroke.  This is very similar to the act of using the <Shift> key to access uppercase letters.  An ideographic language's input method is often based on the language's phonetics, but there are also input methods based on a common graphics property of certain characters.  The graphics method involves defining a key to map to a common graphic symbol that is the basis for multiple characters.  The phonetic method is more commonly used.  It requires a phonetic (alphabet-based) writing system.  The number of phonetic signs or characters is few enough that a unique key is assigned to each phoneme.  Characters are entered by pressing the appropriate phonetic keys.  In several popular input methods, the user types a phonetic representation of a spoken word and the input method determines which characters are pronounced that way.  If only one character meets this criterion, it is displayed.  If more than one character meets the criterion, a list of all characters found is displayed and the user chooses the desired one.  It is then passed to the application.  See IDREF="18588" TYPE="TITLE"Section 11.4.1, "Internationalization and Text Input,"
 for more information on input methods.  LBL="11.1.3" HELPID=""Displaying OutputDisplaying the output produced by an application intended for international use also requires some consideration.  To display text, it must have the appropriate content, encoding and fonts.  For example, many languages, especially ideographic ones, require more than one font.  Bitmaps and pixmaps must be localized as well.  An icon that is an appropriate or meaningful symbol in one country may be totally inappropriate or meaningless in another.  LBL="11.1.4" HELPID=""Locales and LocalizationID="ch1113"A locale is the language environment determined by the application at run time.  XPG3 defines locale as a means of specifying three characteristics of a language environment that may be needed for localization: language, territory, and code set.  Motif supports only one locale per application; that is, an application can set the locale only once, at start-up time.  Motif uses the locale to help find: Resource files UID files Bitmap files Fonts used to display text and labels Text input method The ANSI C method of setting the locale in an application is to use the function setlocale.  How setlocale obtains a language when the language is not explicitly referenced in the call to ID="ch1114"setlocale is system dependent.  For example, on POSIX systems, the environment variable LANG is used.  The locale name is also used to establish a path to the localized files of information.  How this is actually accomplished is explained in ID="ch1115"IDREF="42055" TYPE="TITLE"Section 11.3, "Localizing Applications."LBL="11.2" HELPID=""Compound Strings, Fonts, and Text DisplayID="ch1116"A compound string is a means of encoding text so that it can be displayed in many different languages or fonts without changing anything in the program.  Motif uses compound strings to display all text except that in the Text and TextField widgets.  This section describes the structure of a compound string and the interaction between a compound string and a font list that determines how the compound string is displayed.  ID="ch1117"ID="ch1118"LBL="11.2.1" HELPID=""Compound String ComponentsA compound string is a byte stream in ASN.1 encoding, consisting of tag-length-value segments.  Semantically, a compound string has components that contain the text to be displayed, a tag (called a font list element tag) that will be matched with an element of a font list, and an indicator denoting the direction in which it is to be displayed.  ID="ch1119"ID="ch1120"A compound string component can be one of four types: A font list element tag.  The font list element tag XmFONTLIST_DEFAULT_TAG indicates that the text is encoded in the codeset of the current locale.  ID="ch1121"Other font list element tags are used later to match text with particular entries in a font list.  A direction identifier.  The text of the string.  For internationalized applications, the text falls into two broad categories: either the text requires localized treatment or it does not.  A separator.  The following section describes each of the compound string components: ID="ch1122"Font list element tag The font list element tag is a string value that correlates the text component of a compound string to a font or a font set in a font list.  ID="ch1123"DirectionThe relationship between the order in which characters are entered on the keyboard and the order in which the characters are displayed on the screen.  For example, the display order is left to right in English, French, German, and Italian and right to left in Hebrew and Arabic.  TextThe text to be displayed.  ID="ch1124"SeparatorA separator is a special form of a compound string component that has no value.  It is used to separate other segments.  ID="ch1125"ID="ch1126"ID="ch1127"Motif uses the specified font list element tag identified in the text component to display the compound string.  A specified font list element tag is used until a new font list element tag is encountered.  Motif provides a special font list element tag, XmFONTLIST_DEFAULT_TAG, that matches a font that is correct for the current codeset.  It identifies the default entry in a font list.  See ID="ch1128"IDREF="15618" TYPE="TITLE"Section 11.2.3, "Compound Strings and Font Lists,"
 for more information.  The direction segment of a compound string specifies the direction in which the text is displayed.  Direction can be left-to-right or right-to-left.  LBL="" HELPID=""Compound Strings and ResourcesID="ch1129"ID="ch1130"Compound strings are used to display all text except that in the Text and TextField widgets.  The compound string is set into the appropriate widget resource so that it can be displayed.  For example, the label for the PushButton widget is inherited from the Label widget, and the resource is ID="ch1131"ID="ch1132"XmNlabelString, which is type ID="ch1133"XmString.  This means that the resource expects a value that is a compound string.  A compound string can be created programmatically or defined in a resource file.  ID="ch1134"LBL="" HELPID=""Setting a Compound String ProgrammaticallyAn application can set this resource programmatically by creating the compound string using one of the compound string convenience functions.  There are several such functions: XmStringCreate This function creates a compound string with text and a font list element tag, both of which are arguments in the function call.  ID="ch1135"XmStringCreateLocalized This function creates a compound string in the encoding of the current locale and automatically sets the font list entry tag to ID="ch1136"XmFONTLIST_DEFAULT_TAG.  ID="ch1137"The following code segment shows one way to set XmNlabelString for a PushButton programmatically: ID="ch1138"ID="ch1139"ID="ch1140"Widget    button;
Args      args[10];
int       n;  
XmString  button_label;
† †    .
† †    .
button_label = XmStringCreateLocalized (locvar,
† †                XmFONTLIST_DEFAULT_TAG);
/* locvar is a variable assumed to contain
† †* locale-encoded text.
† †* Create an argument list for the button */
n = 0;
XtSetArg (args[n], XmNlabelString, button_label); n++;
/* Create and manage the button */
button = XmCreatePushButton (toplevel, "button", args, n);
XtManageChild (button);
XmStringFree (button_label);LBL="" HELPID=""Setting a Compound String in a Defaults FileIn an internationalized program, the label string for the button label should be obtained from an external source.  For example, the button label can come from a resource file instead of the program.  For this example, assume that the PushButton is a child of a Form widget called "form1".  ID="ch1141"ID="ch1142"*form1.button.labelString:  Push HereHere, Motif's string-to-compound-string converter produces a compound string from the resource file text.  This converter always uses XmFONTLIST_DEFAULT_TAG.  ID="ch1143"LBL="" HELPID=""Compound Strings in UILID="ch1144"ID="ch1145"Three basic mechanisms exist for specifying strings in UIL files: String literals, which may be stored in UID files as either NULL-terminated strings or compound strings Compound strings Wide-character strings Both string literals and compound strings consist of text, a character set, and a writing direction.  For string literals and for compound strings with no explicit direction, UIL infers the writing direction from the character set.  The UIL concatenation operator (&) concatenates both string literals and compound strings.  Whether UIL stores string literals in UID files as NULL-terminated strings or as compound strings, it stores information about each string's character set and writing direction along with the text.  In general, UIL stores string literals or string expressions as compound strings in UID files under the following conditions: When a string expression consists of two or more literals with different character sets or writing directions When the literal or expression is used as a value that has a compound string data type (such as the value of a resource whose data type is compound string) UIL recognizes a number of keywords specifying character sets.  UIL associates parsing rules, including parsing direction and whether characters have 8 or 16 bits, for each character set it recognizes.  It is also possible to define a character set using the UIL character_set function.  ID="ch1146"ID="ch1147"The syntax of a string literal is one of the following: † †   '[character_string]'
† †   [#char_set]"[character_string]"For each syntax, the character set of the string is determined as follows: For a string declared as 'string', the character set is the codeset component of the LANG environment variable if it is set in the UIL compilation environment, or the value of ID="ch1148"XmFALLBACK_CHARSET if LANG is not set or has no codeset.  By default, the value of ID="ch1149"ID="ch1150"XmFALLBACK_CHARSET is ISO8859-1, but vendors may supply different values.  For a string declared as #char_set"string", the character set is char_set.  For a string declared as "string", the character set depends on whether or not the module has a character_set clause and on whether or not the UIL compiler's ID="ch1151"ID="ch1152"use_setlocale_flag is set: If the module has a character_set clause, the character set is the one specified in that clause.  ID="ch1153"ID="ch1154"If the module has no character_set clause but the uil† †command was invoked with the ID="ch1155"ID="ch1156"ID="ch1157"-s option or the Uil function was invoked with the ID="ch1158"use_setlocale_flag set, UIL calls setlocale and parses the string in the current locale.  The character set of the resulting string is ID="ch1159"XmFONTLIST_DEFAULT_TAG.  ID="ch1160"If the module has no character_set clause and the uil† †command was invoked without the ID="ch1161"ID="ch1162"ID="ch1163"-s option or the Uil† †function was invoked without the ID="ch1164"use_setlocale_flag, the character set is the codeset component of the LANG environment variable if it is set in the UIL compilation environment; if ID="ch1165"LANG is not set or has no codeset, the character set is the value of XmFALLBACK_CHARSET.  ID="ch1166"ID="ch1167"UIL always stores a string specified using the compound_string† †function as a compound string.  This function takes as arguments a string expression and optional specifications of a character set, direction, and whether or not to append a separator to the string.  If no character set or direction is specified, UIL derives it from the string expression, as described above.  ID="ch1168"ID="ch1169"Note that certain predefined escape sequences, beginning with a backslash, may appear in string literals, with these exceptions: A string in single quotes can span multiple lines, with each newline escaped by a backslash.  A string in double quotes cannot span multiple lines.  Escape sequences are processed literally inside a string that is parsed in the current locale (a localized string).  For more information on UIL string and compound string syntax, see the UIL(5X) reference page in the OSF/Motif Programmer's Reference.  LBL="11.2.2" HELPID=""Fonts, Font Lists, and Font SetsID="ch1170"ID="ch1171"ID="ch1172"Motif uses font sets and font lists to display text.  A font defines set of glyphs that represent the characters in a given language.  A font set is a group of fonts that are needed to display text for a given locale.  A font list is a list of fonts, font sets, or a combination of the two, that may be used.  Motif has convenience functions to create a font list.  LBL="" HELPID=""Font List StructureID="ch1173"Motif requires a font list for text display.  A font list is a list of font structures, font sets, or both, each of which has a tag to identify it.  A font set ensures that all characters in the current language can be displayed.  With font structures, the responsibility for ensuring that all characters can be displayed rests with the programmer.  Each entry in a font list is in the form of a {tag, element} pair, where element can be either a single font or a font set.  The application can create a font list entry from either a single font or a font set.  For example, the following code segment creates a font list entry for a font set: ID="ch1174"char font1[] = 
† †  "-adobe-courier-medium-r-normal--10-100-75-75-M-60";
XmFontListEntry font_list_entry;
font_list_entry = XmFontListEntryLoad (display,
† †                    font1, XmFONT_IS_FONT, "font_tag");XmFontListEntryLoad loads a font or creates and loads a font set.  There are four arguments to the function: ID="ch1175"displayThe display on which the font list is to be used font_nameA string that represents either a font name or a base font name list, depending on the type argument typeA value that specifies whether font_name refers to a font name or a base font name list tagA string that represents the tag for this font list entry If type is XmFONT_IS_FONTSET, XmFontListEntryLoad creates a font set in the current locale from the value in ID="ch1176"ID="ch1177"font_name.  The character set(s) of the fonts specified in the font set are dependent on the locale.  If type is XmFONT_IS_FONT, XmFontListEntryLoad† †opens the font found in ID="ch1178"font_name.  In either case, the font or font set is placed into a font list entry.  Now, the following code creates a font list, using the font list entry just created: XmFontList font_list;
XmFontListEntry font_list_entry;
† †  .
† †  .
font_list = XmFontListAppendEntry (NULL, font_list_entry);
XmFontListEntryFree (font_list_entry);The code example above creates a new font list and appends the entry font_list_entry to it.  Once a font list has been created, XmFontListEntryAppend adds a new entry to it.  The following example uses ID="ch1179"XmFontListEntryCreate to create a new font list entry for an existing font list: ID="ch1180"XFontSet font2;
char *font_tag;
XmFontListEntry font_list_entry2;
† †  .
† †  .
font_list_entry2 = XmFontListEntryCreate (font_tag,
† †                     XmFONT_IS_FONT_SET,
† †                     (XtPointer) font2);font2 specifies an XFontSet returned by ID="ch1181"XCreateFontSet.  The arguments to ID="ch1182"XmFontListEntryCreate are font_tag, ID="ch1183"XmFONT_IS_FONTSET, and font2, which are the tag, type, and font, respectively.  The tag and the font set are the {tag, element} pair of the font list entry.  ID="ch1184"Now, to add this entry to the font list, use XmFontListAppendEntry again, only this time its first parameter specifies the existing font list: ID="ch1185"font_list = XmFontListAppendEntry(font_list, font_list_entry2);
XmFontListEntryFree(font_list_entry2);LBL="" HELPID=""Font Lists and ResourcesID="ch1186"ID="ch1187"The syntax for specifying a font list in a resource file depends on whether the list contains fonts, font sets, or both.  To obtain a font, specify a font and an optional font list element tag.  If the tag is present, it should be preceded by an equal sign (=).  If the tag is not present, do not use the equal sign.  Entries specifying more than one font are separated by commas.  To obtain a font set, specify a base font list and an optional font list element tag.  The tag should be preceded by a colon (:) instead of an equal sign.  If the tag is not present, the colon must still be present, because this is what distinguishes a font from a font set in the resource declaration.  Fonts specified in the base font list are separated by semicolons (;).  Entries specifying more than one font set are separated by commas.  If the font list element tag is not present in either case, Motif uses the default XmFONTLIST_DEFAULT_TAG.  Here are some examples: ID="ch1188"Specifying a font: Using the default font list element tag: *fontList:  fixed
*fontList:\
† †  -adobe-courier-medium-r-normal--10-100-75-75-M-60-iso8859-1Specifying a font list element tag: *fontList:  fixed=ROMAN, 8x13bold=BOLDSpecifying two fonts, one with the default font list element tag and one with an explicit tag: *fontList:  fixed, 8x13bold=BOLDSpecifying a font set: List the fonts explicitly without specifying a font list element tag: *fontList:\
† † -JIS-Fixed-Medium-R-Normal--26-180-100-100-C-240;\
† † -JIS-Fixed-Medium-R-Normal--26-180-100-100-C-120;\
† † -GB-Fixed-Medium-R-Normal--26-180-100-100-C-240;\
† † -Adobe-Courier-Bold-R-Normal--25-180-100-100-M-150:Let Xlib select the fonts without specifying a font list element tag: *fontList:  -*-*-*-R-Normal--*-180-100-100-*-*:List the fonts explicitly and specify a font list element tag as MY_TAG: *fontList:\
† † -JIS-Fixed-Medium-R-Normal--26-180-100-100-C-240;\
† † -JIS-Fixed-Medium-R-Normal--26-180-100-100-C-120;\
† † -GB-Fixed-Medium-R-Normal--26-180-100-100-C-240;\
† † -Adobe-Courier-Bold-R-Normal--25-180-100-100-M-150:MY_TAGLet Xlib select the fonts and specify a font list element tag as MY_TAG: *fontList:  -*-*-*-R-Normal--*-180-100-100-*-*:MY_TAGList the fonts explicitly and specify a font list element tag for bold fonts, but use the default font list element tag for medium fonts: *fontList:\
† † -JIS-Fixed-Medium-R-Normal--26-180-100-100-C-240;\
† † -JIS-Fixed-Medium-R-Normal--26-180-100-100-C-120;\
† † -GB-Fixed-Medium-R-Normal--26-180-100-100-C-240;\
† † -Adobe-Courier-Bold-R-Normal--25-180-100-100-M-150:,\
† † -JIS-Fixed-Medium-R-Normal--26-180-100-100-C-240;\
† † -JIS-Fixed-Medium-R-Normal--26-180-100-100-C-120;\
† † -GB-Fixed-Medium-R-Normal--26-180-100-100-C-240;\
† † -Adobe-Courier-Bold-R-Normal--25-180-100-100-M-150:BOLDLet Xlib select the fonts and specify a font list element tag for bold fonts and use the default font list element tag for the others: *fontList:  -*-*-*-R-Normal--*-180-100-100-*-*:,\
† †           -*-*-Bold-R-Normal--*-180-100-100-*-*:BOLDLBL="" HELPID=""Font List Resource DefaultsID="ch1189"ID="ch1190"A font list resource exists for a number of different widgets.  Motif uses a hierarchy system to determine the font list it should use.  There are several font list resources for VendorShell, XmBulletinBoard, and ID="ch1191"ID="ch1192"ID="ch1193"XmMenuShell.  These resources can be set, either programmatically or in resource files.  ID="ch1194"ID="ch1195"VendorShell and XmMenuShell have some common font list resources but one of them, ID="ch1196"ID="ch1197"ID="ch1198"XmNdefaultFontList, exists only for compatibility with earlier Motif releases.  The widgets that have a font list resource (or resources) are listed in the following table.  Note that in some cases the resource is ID="ch1199"not named XmNfontList.  ID="ch11100"COLUMNS="2"LEFT="0" WIDTH="99"WidgetLEFT="105" WIDTH="356"Resource NameLEFT="0" WIDTH="99"VendorShellLEFT="105" WIDTH="356"XmNbuttonFontListLEFT="0" WIDTH="99"VendorShellLEFT="105" WIDTH="356"XmNdefaultFontListLEFT="0" WIDTH="99"VendorShellLEFT="105" WIDTH="356"XmNlabelFontListLEFT="0" WIDTH="99"VendorShellLEFT="105" WIDTH="356"XmNtextFontListLEFT="0" WIDTH="99"XmBulletinBoardLEFT="105" WIDTH="356"XmNbuttonFontListLEFT="0" WIDTH="99"XmBulletinBoardLEFT="105" WIDTH="356"XmNlabelFontListLEFT="0" WIDTH="99"XmBulletinBoardLEFT="105" WIDTH="356"XmNtextFontListLEFT="0" WIDTH="99"XmLabelLEFT="105" WIDTH="356"XmNfontListLEFT="0" WIDTH="99"XmLabelGadgetLEFT="105" WIDTH="356"XmNfontListLEFT="0" WIDTH="99"XmListLEFT="105" WIDTH="356"XmNfontListLEFT="0" WIDTH="99"XmMenuShellLEFT="105" WIDTH="356"XmNbuttonFontListLEFT="0" WIDTH="99"XmMenuShellLEFT="105" WIDTH="356"XmNdefaultFontListLEFT="0" WIDTH="99"XmMenuShellLEFT="105" WIDTH="356"XmNlabelFontListLEFT="0" WIDTH="99"XmScaleLEFT="105" WIDTH="356"XmNfontListLEFT="0" WIDTH="99"XmTextLEFT="105" WIDTH="356"XmNfontListLEFT="0" WIDTH="99"XmTextFieldLEFT="105" WIDTH="356"XmNfontListLBL="11-2"Table 11-2 Widgets With Font List ResourcesThe three resources XmNbuttonFontList, XmNlabelFontList, and ID="ch11101"ID="ch11102"XmNtextFontList are used to specify a font list for descendants of a type associated with the resource.  For example, ID="ch11103"XmNbuttonFontList specifies the font list used for button descendants of VendorShell, XmBulletinBoard, and ID="ch11104"ID="ch11105"ID="ch11106"XmMenuShell.  If a button's ID="ch11107"ID="ch11108"XmNfontList is NULL at initialization, the font list for the button is set by searching the parent hierarchy of the button widget or gadget for an ancestor that is a subclass of ID="ch11109"VendorShell, XmBulletinBoard, or XmMenuShell.  If such an ancestor is found, the button's font list is set to the value of ID="ch11110"ID="ch11111"ID="ch11112"ID="ch11113"ID="ch11114"XmNbuttonFontList in the ancestor widget.  If no such ancestor is found, the result is implementation dependent.  ID="ch11115"LBL="" HELPID=""Font Lists in UILID="ch11116"ID="ch11117"ID="ch11118"UIL has three functions for use in creating font lists: font, ID="ch11119"ID="ch11120"fontset, and font_table.  The ID="ch11121"ID="ch11122"ID="ch11123"ID="ch11124"font and fontset functions create font list entries.  The font_table function creates a font list from these font list entries.  The font function creates a font list entry containing a font specification.  The argument is a string representing an XLFD font name.  The ID="ch11125"ID="ch11126"fontset function creates a font list entry containing a font set specification.  The argument is a comma-separated list of XLFD font names representing a base name font list.  ID="ch11127"ID="ch11128"Both font and fontset have optional character_set† †parameters that specify the font list element tag for the font list entry.  In both cases, if no ID="ch11129"ID="ch11130"ID="ch11131"ID="ch11132"ID="ch11133"ID="ch11134"character_set parameter is specified, UIL determines the font list element tag as follows: If the module contains no character_set declaration and if the ID="ch11135"ID="ch11136"uil command was invoked with the -s option or the Uil† †function was invoked with the ID="ch11137"ID="ch11138"use_setlocale_flag set, the font list element tag is XmFONTLIST_DEFAULT_TAG.  ID="ch11139"Otherwise, the font list element tag is the codeset component of the LANG environment variable if it is set in the UIL compilation environment, or the value of ID="ch11140"XmFALLBACK_CHARSET if LANG is not set or has no codeset.  ID="ch11141"ID="ch11142"The font_table function creates a font list from a comma-separated list of font list entries, created by ID="ch11143"ID="ch11144"FONT or FONTSET.  The resulting font list can be used as the value of a font list resource.  If a single font list entry is supplied as the value for such a resource, UIL converts the entry to a font list.  ID="ch11145"ID="ch11146"ID="ch11147"ID="ch11148"LBL="11.2.3" HELPID=""ID="15618"Compound Strings and Font ListsID="ch11149"ID="ch11150"When Motif displays a compound string, it associates each segment with a font or font set by means of the font list element tag for that segment.  The application must have loaded the desired font or font set, created a font list that contains that font or font set and its associated font list element tag, and created the compound string segment with the same tag.  Motif follows a set search procedure when when it binds a compound string to a font list entry: Motif searches the font list for an exact match with the font list element tag specified in the compound string.  If it finds a match, the compound string is bound to that font list entry.  If the above does not provide a binding between the compound string and the font list, Motif binds the compound string to the first element in the font list, regardless of its font list element tag.  For backward compatibility, if an exact match is not found, XmFONTLIST_DEFAULT_TAG in either a compound string or a font list matches the tag that would result from creating a compound string or font list entry with a tag of ID="ch11151"XmSTRING_DEFAULT_CHARSET.  ID="ch11152"The following figure shows the relationships between a compound string, a font set, and a font list when the font list element tag is set to something other than XmFONTLIST_DEFAULT_TAG.  ID="ch11153"LBL="11-2" FILE="comp1.gif" POSITION="INLINE" SCALE="FALSE"LBL="11-2"Figure 11-2 Compound String and Explicit TagThe following example shows how to use a tag called tagb.  ID="ch11154"ID="ch11155"ID="ch11156"XFontStruct     *font1;
XmFontListEntry     font_list_entry;
XmFontList font_list;
XmString  label_text;
char *tagb;  /* Font list element tag */
char *fontx; /* Initialize to XLFD or font alias */
char *button_label;   /* Contains button label text */
† †    .
† †    .
font1 = XLoadQueryFont (XtDisplay(toplevel), fontx);
font_list_entry = XmFontListEntryCreate (tagb, XmFONT_IS_FONT,
† †    (XtPointer)font1);
font_list = XmFontListAppendEntry (NULL, font_list_entry);
XmFontListEntryFree (font_list_entry);
label_text = XmStringCreate (button_label, tagb);XLoadQueryFont loads the font and then XmFontListEntryCreate† †creates a font list entry.  The application must create an entry and then append it to an existing font list or create a new font list, in either case using ID="ch11157"ID="ch11158"XmFontListAppendEntry.  Because there is no font list in place, the previous code example has NULL for the font list argument.  ID="ch11159"XmFontListAppendEntry creates a new font list called font_list with a single entry, font_list_entry.  To add another entry to font_list, the application can follow the same procedure but supply a non-NULL font list argument.  The following figure shows the relationships between a compound string, a font set, and a font list when the font list element tag is set to XmFONTLIST_DEFAULT_TAG.  In this case, the value field is locale text.  ID="ch11160"LBL="11-3" FILE="comp2.gif" POSITION="INLINE" SCALE="FALSE"LBL="11-3"Figure 11-3 Compound String and XmFONTLIST_DEFAULT_TAGID="ch11161"ID="ch11162"ID="ch11163"LBL="11.2.4" HELPID=""Text and TextField Widgets and Font ListsID="ch11164"ID="ch11165"ID="ch11166"The Text and TextField widgets display text information.  To do so, they must be able to select the correct font in which to display the information.  The Text and TextField widgets follow a set search pattern to find the correct font: ID="ch11167"ID="ch11168"Search the font list for an entry that is a font set and has a font list element tag of XmFONTLIST_DEFAULT_TAG.  If a match is found, use that font list entry.  No further searching occurs.  ID="ch11169"Search the font list for an entry that specifies a font set.  Use the first one found.  If no font set is found, use the first font in the font list.  A font set is desired because that insures that there are glyphs for every character in the locale.  LBL="11.3" HELPID=""ID="42055"Localizing ApplicationsID="ch11170"An internationalized application can be tailored to operate in many areas of the world, each with its own requirements for the language and customs to be used.  This section explains some methods for localizing an application.  The following section describes how the user, the application developer, and the implementation combine to establish the language environment of the application.  It then discusses two general approaches to localizing applications.  Succeeding sections focus on four aspects of localizing information in Motif programs: Resource files UID files Message catalogs X bitmap files Many aspects of localization depend on the particular operating system, Motif implementation, and user environment in which the application runs.  The following must all cooperate for correct localization to occur: The operating system's locale mechanism, if any The Motif implementation The application itself The user's system administrator The user's language environment LBL="11.3.1" HELPID=""Techniques for LocalizationAlthough there are different methods for localizing an application, there are some common considerations: The application should not explicitly code any language-dependent information in the application.  This includes strings, fonts, and language-dependent pixmaps.  The application should isolate text, fonts, and pixmaps, and translate them into the languages needed.  Usually this information is stored in separate directories by language.  LBL="" HELPID=""Establishing the Language EnvironmentID="ch11171"The term language environment refers to the set of localized data that the application needs in order to run correctly in the user specified locale.  A language environment supplies the rules associated with a specific language.  In addition, the language environment consists of any externally stored data, such as localized strings or text used by the application.  For example, the menu items displayed by an application might be stored in separate files for each language supported by the application.  This type of data can be stored in resource files, UID files, or, on XPG3-compliant systems, message catalogs.  A single language environment is established when an application executes.  The actual language environment in which an application operates is specified by the application user, often either by setting an environment variable (LANG on POSIX-based systems) or by setting the ID="ch11172"xnlLanguage resource.  The application then sets the language environment based on the user's specification.  The application can do this either by using ID="ch11173"setlocale in a language procedure established by ID="ch11174"XtSetLanguageProc, or by using a method that does not call ID="ch11175"setlocale.  In either case, Xt caches a per-display language string that is used by XtResolvePathname to find resource, bitmap, and UIL files.  ID="ch11176"An application that supplies a language procedure may either provide its own or use an Xt default procedure.  In either case, the application establishes the language procedure by calling XtSetLanguageProc before calling XtAppInitialize.  When a language procedure is installed, Xt calls it in the process of constructing the initial resource database.  Xt uses the value returned by the language procedure as its per-display language string.  ID="ch11177"ID="ch11178"The default language procedure performs the following tasks: Sets the locale.  On ANSI C-based systems, this is done by using the following code: setlocale(LC_ALL, language);where language is the value of xnlLanguage or the empty string ("") if ID="ch11179"xnlLanguage is not set.  When xnlLanguage is not set, the locale is generally derived from an environment variable (LANG on POSIX-based systems).  ID="ch11180"Calls XSupportsLocale to verify that the locale just set is supported.  If not, a warning message is issued and the locale is set to "C." ID="ch11181"Calls XSetLocaleModifiers specifying the empty string.  ID="ch11182"Returns the value of the current locale.  On ANSI C-based systems, this is the result of calling: setlocale(LC_ALL, NULL);The application can use the default language procedure by making the call to XtSetLanguageProc in this manner: ID="ch11183"XtSetLanguageProc(NULL, NULL, NULL);
† †  .
† †  .
toplevel = XtAppinitialize(...);By default, Xt does not install any language procedure.  If the application does not call XtSetLanguageProc, Xt uses as its per-display language string the value of the ID="ch11184"xnlLanguage resource if it is set.  If ID="ch11185"xnlLanguage is not set, Xt derives the language string from the environment.  On POSIX-based systems, this is the value of the LANG environment variable.  ID="ch11186"It is important to note that the per-display language string that results from this process is implementation dependent and that Xt provides no public means of examining the language string once it is established.  The following vary by operating system and by Motif implementation: The mechanism, if any, used to set the locale On ANSI C-based systems, the value returned by setlocale† †ID="ch11187"The possible values of any environment variables used to establish the language environment Whether or not xnlLanguage is used and, if so, its possible values ID="ch11188"Furthermore, by supplying its own language procedure, an application may use any procedure it wants for setting the language string.  LBL="" HELPID=""Using LocalesID="ch11189"The locale provides local information to an application based on the user's language, territory, and codeset.  Both language and territory are needed because some languages are spoken in more than one country and more than one language may be spoken in some countries (Belgium, Canada, and Switzerland are examples).  Information in resource, UID, and image files can be localized and stored in separate directories by language.  The Xt function XtResolvePathname uses the run-time locale to determine the proper directory to use.  ID="ch11190"On XPG3-compliant systems, an application can use message catalogs to localize text and messages.  A message catalog file exists for each language, and each is usually stored in a separate directory by language.  The locale method of localizing compound strings and font lists consists of the following steps: Establish a language procedure before calling XtAppInitialize.  The language procedure calls ID="ch11191"setlocale.  ID="ch11192"Localize the compound strings and font lists using resource files, message catalogs, or UID files.  Normally, do not specify any font list element tags other than XmFONTLIST_DEFAULT_TAG.  ID="ch11193"Use font sets in resource or UID file font lists.  Use XmStringCreateLocalized to create compound strings in the program.  This function only has one argument, a text string, and automatically sets the font list element tag to ID="ch11194"XmFONTLIST_DEFAULT_TAG.  ID="ch11195"The run-time locale determines which fonts are used to display text.  This is accomplished in the following manner: Motif calls XtResolvePathname to load resource or UID files that specify the names of fonts for font sets.  ID="ch11196"XtResolvePathname uses a file search path that may vary depending on the display's language string.  XCreateFontSet uses the locale to determine the fonts to be used from the base font name and the locale charset.  ID="ch11197"In this method, the application usually does not specify font list element tags other than XmFONTLIST_DEFAULT_TAG.  It is possible to supply explicit font list element tags with locale-dependent text.  For example, text might be displayed using large and small fonts or bold and italic fonts.  The application can do this with special tags in both the compound string and the font list associated with it.  In the font list, match the tag with a font set specification that supplies the desired attribute (point size, for example).  When the application creates the font set, the charset comes from the locale.  For example, a resource file might specify a font list in the following manner to obtain fonts with a different point size: ID="ch11198"*fontList:  -*-*-*-R-Normal--*-120-100-100-*-*:,\
† †           -*-*-*-R-Normal--*-180-100-100-*-*:BIG,\
† †           -*-*-*-R-Normal--*-80-100-100-*-*:SMALLIn this case, the application should also map the tags to XmFONTLIST_DEFAULT_TAG in the Motif registry of font list element tags.  See ID="ch11199"IDREF="35152" TYPE="TITLE"Section 11.4.2, "Compound Strings and Compound Text,"
 for more information.  LBL="" HELPID=""Localization Without LocalesIn this method, the locale is not set in the program, and a language procedure is not needed.  Instead, the user specifies the language environment using either xnlLanguage or an environment variable such as LANG.  Resource, UID, and image files are localized and stored in separate directories by language, as they are when the application uses locales.  ID="ch11200"ID="ch11201"XtResolvePathname uses the display's language string in the same way to determine the proper locations of these files.  Message catalogs are not used in this method.  Also, in this case Text and TextField cannot accommodate 16-bit data.  The nonlocale method of localizing compound strings and font lists consists of these steps: ID="ch11202"ID="ch11203"ID="ch11204"Localize compound strings using UIL files.  Note that resource files cannot be used for compound strings because the string-to-compound-string converter always uses the font list element tag XmFONTLIST_DEFAULT_TAG.  Localized font lists can appear in resource files.  ID="ch11205"Specify explicit font list element tags other than XmFONTLIST_DEFAULT_TAG in both compound strings and font lists.  ID="ch11206"Use font names with explicit charset components in resource or UIL files.  Do not use font sets.  To create compound strings in the program, use XmStringCreate† †with the font list element tag set to something other than ID="ch11207"XmFONTLIST_DEFAULT_TAG.  ID="ch11208"LBL="11.3.2" HELPID=""Resources and LocalizationID="ch11209"ID="ch11210"The resources used in an application that are subject to internationalization are stored in files external to the application.  These resources include All labels, particularly those that identify controls.  Such labels are defined as type XmString, meaning they are compound strings.  ID="ch11211"Text strings; that is, strings of text that are not compound strings.  Font lists.  LBL="" HELPID=""Initial Resource DatabaseID="ch11212"The information in the external resource files is used when Xt builds the initial resource database.  The XtDisplayInitalize function loads the resource database by merging in resources from the following sources, in order of precedence (that is, each component takes precedence over the following components): ID="ch11213"The application command line A per-host user environment resource file on the local host Screen-specific resources for the default screen of the display A resource property on the server or user preference resource file on the local host An application-specific user resource file on the local host An application-specific class resource file on the local host  Localization applies to two components of the initial resource databasename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the application-specific user and class resources.  Localized resources that are controlled by the programmer are in the application class resource file, and localized resources that are controlled by the user are in the user resource file.  Note that the user resources take precedence over the application class resources.  LBL="" HELPID=""Resource File LocationsXtDisplayInitialize calls XtResolvePathname to load both the user and the class resources.  ID="ch11214"ID="ch11215"To load the user's application resource file, XtDisplayInitialize† †uses the value of the ID="ch11216"XUSERFILESEARCHPATH environment variable as the search path.  If that variable is not set or if the search path fails to find the file, and if the environment variable ID="ch11217"XAPPLRESDIR is defined, ID="ch11218"XtDisplayInitialize next tries an implementation-dependent search path with a number of entries that include ID="ch11219"XAPPLRESDIR and the user's home directory.  If ID="ch11220"XAPPLRESDIR is not set or if that search path fails, ID="ch11221"XtDisplayInitialize tries another implementation-dependent search path with a number of entries that include the user's home directory.  ID="ch11222"To load the application-specific class resource file, XtDisplayInitialize uses the value of the XFILESEARCHPATH† †environment variable as the search path.  If that variable is not set or if the search path fails to find the file, ID="ch11223"ID="ch11224"XtDisplayInitialize tries an implementation-dependent search path.  ID="ch11225"The search paths for both resource files may contain any substitutions recognized by XtResolvePathname.  That routine substitutes the display's language string for ID="ch11226"%L.  In an implementation-dependent manner, it substitutes the language, territory, and codeset components of the language string for %l, %t, and %c, respectively.  This mechanism allows Xt to load different resource files for different languages, as specified by the display's language string.  The display's language string is determined by the application's language procedure, if present, or else by the value of the xnlLanguage resource or by the environment.  The language string associated with any particular language and the search paths used to find the resource files depend on the system vendor, the Motif vendor, the application, and the user's system administrator.  Determining the actual directories in which localized resource files reside requires coordination among all these sources.  ID="ch11227"In general, an application developer prepares a set of localized application class resource files, one for each language the application supports.  The developer may also need to supply a language procedure appropriate for one or more of the systems on which the application will run.  The application vendor must arrange for the resource files to be installed in the correct directories, depending on the operating system and the Motif implementation on which the application will run.  LBL="" HELPID=""An ExampleFollowing is an example of an application class defaults file for a simple program that creates a MainWindow with a Text widget.  The font list specification includes a single font set with a default tag.  This resource file would be appropriate for an application that uses locales.  ID="ch11228"ID="ch11229"*fontList:                 -*-*-*-R-Normal--*-180-100-100-*-*:
*Text1.value:\
Hier ist etwas Text fur das Text Widget.\n\
Gemischter 8-und 16-bit Text.
*version_box.messageString:     Dies ist i18n Demo Version
*version_box.okLabelString:     Schliessen
*version_box.dialogTitle:       I18n Demo Version
*pgm_ver_btn.labelString:       I18n Demo Version 
*events_btn.labelString:        Aktionen
*help_btn_menu.labelString:     Hilfe
*help_btn_cascade.labelString:  Hilfe
*help_box.messageString:        Leider ist keine Hilfe hier.
*help_box.okLabelString:        Schliessen
*help_box.dialogTitle:          i18n Demo Hilfe
*stop_btn.labelString:          EndenLBL="11.3.3" HELPID=""UIL and LocalizationID="ch11230"ID="ch11231"The general models for localizing applications using UIL are the same as those for applications that do not use UIL.  An application developer creates separate UIL files, each containing string and resource values for a particular language.  UIL files can also be used in conjuction with localized resource and pixmap files.  As with localization of resource files, there are two basic approaches to localizing UIL files: one that uses locales and one that does not.  LBL="" HELPID=""Preparing Localized UID FilesWhen using locales with UIL, an application developer should take the following steps: Do not use a character_set declaration for the module.  ID="ch11232"ID="ch11233"When creating compound strings in a UIL file, use double quotes and no character set specification for the text.  When creating font lists in a UIL file, use font sets, not fonts.  Do not specify character sets for the font sets.  Before compiling a UIL file using the uil command, set up any environment variables (such as ID="ch11234"LANG) or other mechanisms the system vendor recommends to establish the locale that is appropriate for the UIL file to be compiled.  Invoke the ID="ch11235"uil command with the -s option.  This enables the UIL compiler to set the locale and parse double quoted strings without explicit character sets in the locale's encoding.  It also ensures that localized compound strings and font list entries are created with font list element tags of ID="ch11236"XmFONTLIST_DEFAULT_TAG.  ID="ch11237"Before using the Uil function to compile a UIL file, set the locale that is appropriate for the UIL file to be compiled.  In the ID="ch11238"Uil_command_type structure that is the first argument to the Uil function, set the use_setlocale_flag member to 1.  This has the same effect as invoking the ID="ch11239"uil command with the ID="ch11240"-s option.  When localizing UIL files without using locales, an application developer should take the following steps: When using single quotes for the text of compound strings, supply a character_set declaration for the module.  ID="ch11241"ID="ch11242"When using double quotes for the text of compound strings, supply an explicit character set for each segment.  When creating font lists in a UIL file, use fonts, not font sets.  Specify an explicit character set for each font.  When compiling a UIL file using the uil command, do not invoke the command with the ID="ch11243"-s option.  The UIL compiler does not set the locale, and it parses each string using rules derived from the explicitly specified character set for that string.  When compiling a UIL file using the Uil function, set the ID="ch11244"use_setlocale_flag member of the Uil_command_type structure to 0.  This has the same effect as invoking the uil command without the ID="ch11245"-s option.  The UIL compiler processes a single source file for each invocation of the uil command or the Uil function.  However, UIL has an ID="ch11246"ID="ch11247"include file directive that is similar to the C preprocessor's ID="ch11248"ID="ch11249"#include directive.  If the file argument for this directive is not an absolute pathname, the compiler searches for the file in a series of directories.  These include the directory of the main UIL source file and any directories specified via the -I option to the uil command or the ID="ch11250"include_dir member of the Uil_command_type structure for the Uil function.  ID="ch11251"One strategy for maintaining localized UIL source files is to place only language-independent information in the main UIL source file and to put all language-dependent information in included files that are in separate directories for each language.  Then a developer can compile the UIL files for different languages without editing any UIL files.  When using locales, a developer first sets up the environment for the intended locale.  Whether using locales or not, the developer then invokes the UIL compiler with the proper include directory for the intended language.  In general, a developer can mix localized UIL files with localized resource files.  For example, the developer might specify compound strings in UIL files and font lists in resource files.  Note one exception: it is not practical to use resource files to localize compound strings without using locales.  This is because no resource file syntax exists for supplying an explicit font list element tag for a compound string.  For resource values that the user may override, the developer must use resource files or fallback resources, or must in some way ensure that the user's resource settings can override the developer's settings from the UIL file.  LBL="" HELPID=""MRM and Localized UID FilesID="ch11252"ID="ch11253"Once the developer has generated localized UID files, the vendor and the user's system administrator must arrange for these files to be installed in the appropriate directories for the system where the program is to run.  As with resource files, these directories depend on configurations established by the operating system vendor, the Motif vendor, and the system administrator.  MrmOpenHierarchyPerDisplay takes as an argument a list of names of UID files.  It calls ID="ch11254"XtResolvePathname to find each file the list.  If a filename is an absolute pathname, that pathname is the search path for ID="ch11255"XtResolvePathname.  Otherwise, MrmOpenHierarchyPerDisplay constructs a search path in the following way: If the environment variable UIDPATH is set, the value of that variable is the search path.  ID="ch11256"If UIDPATH is not set, but XAPPLRESDIR is set, ID="ch11257"ID="ch11258"MrmOpenHierarchyPerDisplay uses a default search path with entries that include ID="ch11259"$XAPPLRESDIR, the user's home directory, and vendor-dependent system directories.  If neither UIDPATH nor XAPPLRESDIR is set, ID="ch11260"ID="ch11261"MrmOpenHierarchyPerDisplay uses a default search path with entries that include the user's home directory and vendor-dependent system directories.  ID="ch11262"These paths may include the substitution field %U.  In each call to XtResolvePathname, ID="ch11263"MrmOpenHierarchyPerDisplay substitutes the current filename from the list of UID files for ID="ch11264"%U.  The paths may also include other substitution fields accepted by XtResolvePathname.  In particular, XtResolvePathname substitutes the display's language string for %L, and it substitutes the components of the display's language string (in a vendor-dependent way) for %l, %t, and %c.  If necessary MrmOpenHierarchyPerDisplay searches the path twice, first with %S mapped to .uid and then with %S mapped to NULL.  The substitution field %T is always mapped to uid.  The usual mechanism for employing localized UID files is to use a search path that contains one of the substitutions derived from the display's language string.  As with resource files, the vendor and system administrator must ensure that the directories where the localized UID files reside match the display's language string (or the appropriate component of the language string).  LBL="11.3.4" HELPID=""Message Catalogs and LocalizationID="ch11265"On an XPG3-compliant system, an application can use message catalogs to localize text.  The format of message catalogs is implementation dependent, and the application must take steps to coordinate the locations of the message catalogs with the locations of resource, UID, and image files.  Use of message catalogs requires the following steps: Using an implementation-dependent method, prepare a separate message catalog containing text to be localized for each language.  Arrange to have the message catalogs installed in the appropriate directories on the systems on which the application will run.  Arrange for the user's environment to be set up correctly so that the application can read the message catalog appropriate to the language.  In the program, use the catopen function to open a message catalog and the ID="ch11266"catclose function to close it.  ID="ch11267"Use the catgets function to read text from an open message catalog.  ID="ch11268"If necessary, convert the text to the target format (such as a compound string) and, for resources, supply the text in the appropriate widget creation argument list or call to XtSetValues.  ID="ch11269"The catopen function takes as an argument the name of the message catalog file.  If this is an absolute pathname, ID="ch11270"catopen opens that file.  Otherwise, catopen uses the value of the NLSPATH environment variable as a search path.  This path can contain a number of substitution fields.  The filename passed to ID="ch11271"catopen is substituted for %N.  The value of the LANG environment variable is substituted for ID="ch11272"%L, and its language, territory, and codeset components are substituted for %l, %t, and %c, respectively.  Note that these values may not be the same as the display's language string or its components.  An application and software vendor that use message catalogs must coordinate the locations of message catalogs with those of localized resource, UID, and image files, which usually depend on the display's language string.  One possible strategy is to call catopen with an absolute pathname constructed by calling ID="ch11273"XtResolvePathname with the value of ID="ch11274"NLSPATH as the search path argument.  ID="ch11275"XtResolvePathname substitutes the display's language string and its components for %L, %l, %t, and %c in $NLSPATH.  In this way, the application can use a single mechanism, the display's language string, to distinguish file locations by language.  The software vendor must still arrange for the user's system administrator to install the message catalogs in the correct locations and to ensure that NLSPATH is appropriately set in the user's environment.  LBL="11.3.5" HELPID=""Images, Pixmaps, and LocalizationID="ch11276"A pixmap is a screen image that is stored in memory so that it can be recalled and displayed when needed.  Motif has a number of pixmap resources that allow the application to supply pixmaps for backgrounds, borders, shadows, label and button faces, drag icons, and other uses.  As with text, some pixmaps may be specific to particular language environments; these pixmaps need to be localized.  Motif maintains caches of pixmaps and images.  The function XmGetPixmapByDepth searches these caches for a requested pixmap.  If the requested pixmap is not in the pixmap cache and a corresponding image is not in the image cache, ID="ch11277"XmGetPixmapByDepth searches for an X bitmap file whose name matches the requested image name.  XmGetPixmapByDepth calls XtResolvePathname to search for the file.  If the requested image name is an absolute pathname, that pathname is the search path for ID="ch11278"XtResolvePathname.  Otherwise, XmGetPixmapByDepth constructs a search path in the following way: If the environment variable XBMLANGPATH is set, the value of that variable is the search path.  ID="ch11279"If XBMLANGPATH is not set but XAPPLRESDIR is set, ID="ch11280"ID="ch11281"XmGetPixmapByDepth uses a default search path with entries that include ID="ch11282"$XAPPLRESDIR, the user's home directory, and vendor-dependent system directories.  If neither XBMLANGPATH nor XAPPLRESDIR is set, ID="ch11283"ID="ch11284"XmGetPixmapByDepth uses a default search path with entries that include the user's home directory and vendor-dependent system directories.  ID="ch11285"These paths may include the substitution field %B.  In each call to XtResolvePathname, ID="ch11286"XmGetPixmapByDepth substitutes the requested image name for ID="ch11287"%B.  The paths may also include other substitution fields accepted by XtResolvePathname.  In particular, XtResolvePathname substitutes the display's language string for %L, and it substitutes the components of the display's language string (in a vendor-dependent way) for %l, %t, and %c.  The substitution field %T is always mapped to bitmaps, and %S is always mapped to NULL.  As with resource and UID files, the usual mechanism for employing localized X bitmap files is to use a search path that contains one of the substitutions derived from the display's language string.  As with resource and UID files, the vendor and system administrator must ensure that the directories where the localized X bitmap files reside match the display's language string (or the appropriate component of the language string).  See IDREF="35125" TYPE="TITLE"Chapter 12, "Color and Pixmaps,"
 for more information on images and pixmaps.  LBL="11.3.6" HELPID=""Comparing Approaches to LocalizationThe locale approach allows an application to use existing internationalization routines.  On the other hand, the application is limited in portability to systems that support the same internationalization standards (XPG3, POSIX, or ANSI).  This approach is also only applicable to applications using a single language.  The nonlocale approach only addresses the aspect of isolating information from the application and ensuring that it uses the proper localized version of this information.  The disadvantage is that there is more work for the programmer and there may be nonstandard functionality.  The advantages are that there is guaranteed portability across all platforms that support Motif, and that it allows handling of multiple character sets for specialized applications that require this functionality.  LBL="11.4" HELPID=""Advanced Topics in InternationalizationThis section covers some advanced topics dealing with internationalization.  LBL="11.4.1" HELPID=""ID="18588"Internationalization and Text InputID="ch11288"An application subject to internationalization presents some unique problems when it deals with text input.  The application must be able to correctly interpret and process text input in any language.  This section explains how an application accomplishes this.  LBL="" HELPID=""Input MethodID="ch11289"Although there are many different keyboards in use, sometimes certain characters in an alphabetic language are not directly available on any keyboard.  In this case, the user must type a combination of keys to input the desired character.  The number of characters in an ideographic language far exceeds the capability of any keyboard and makes it impossible to have a keyboard with all of the language's symbols.  In this case, input is usually accomplished based on the language's phonetics.  These cases illustrate the concept of an input method.  An input method is simply the mechanism that is used to map between the keys typed by a user and the resulting characters that are input to the application.  A common feature of many input methods is that the application user may type combinations of keys to create a single character.  Creating characters from keystrokes is called pre-editing.  ID="ch11290"Input methods may require several areas to display the actual keystrokes.  The status area is an output-only window that identifies the style of input (phonetic, numeric, stroke and radial, and so on) and the current status of an input method interaction.  ID="ch11291"ID="ch11292"The pre-edit area displays the intermediate text for languages that are composed before the application acts on the data.  There are several possible locations for the pre-edit area: ID="ch11293"ID="ch11294"Over-the-spotDisplays the data in an input method window that is placed over the point of insertion.  ID="ch11295"ID="ch11296"Off-the-spotDisplays the pre-edit window inside the application window (usually at the bottom) but not at the point of insertion.  ID="ch11297"ID="ch11298"Root-windowUses a pre-edit window that is a child of the root window.  ID="ch11299"ID="ch11300"A VendorShell resource, XmNpreeditType determines which style is used for a Text or TextField input method.  The syntax, possible values, and default value of this resource are implementation dependent.  ID="ch11301"ID="ch11302"ID="ch11303"ID="ch11304"The auxiliary area is used for popup menus and customizing dialogs that some input methods use.  ID="ch11305"ID="ch11306"Input methods are supplied by vendors and are implementation dependent.  The VendorShell resource XmNinputMethod is an implementation-dependent string that specifies the input method portion of the locale modifiers.  If a value is supplied for this resource, Motif uses it to set the locale modifiers before opening an input method for Text or TextField.  ID="ch11307"ID="ch11308"ID="ch11309"ID="ch11310"The following figure shows one possible program window with a Text widget using over-the-spot interaction for Japanese text input.  The status area indicates that phonetic input is in use and insert mode is enabled.  The pre-edit area shows that the letter "H" has been entered.  Since there is no Hiragana phonetic equivalent, the "H" appears in the pre-edit window.  ID="ch11311"LBL="11-4" FILE="imosf1.gif" POSITION="INLINE" SCALE="FALSE"LBL="11-4"Figure 11-4 Text Widget Pre-Edit and Status Areas Using Over-the-SpotThe following figure shows the same window after a "u" has been entered following the "H" shown in the previous figure.  LBL="11-5" FILE="imosf2.gif" POSITION="INLINE" SCALE="FALSE"LBL="11-5"Figure 11-5 Text Widget Pre-Edit Area After Next Character EntryHere the pre-edit area is displaying the phonetic equivalent of the English letters "hu" in Hiragana.  LBL="" HELPID=""Input ContextAn input context is the mechanism used to provide the state information needed to manage the information flow between the application and the input method.  It is a combination of an input method, a locale specifying the encoding of character strings to be returned, an application window, and internal state information.  The following figure shows the relationships involved.  The input method is determined by the locale specified by the application user.  ID="ch11312"LBL="11-6" FILE="input.gif" POSITION="INLINE" SCALE="FALSE"LBL="11-6"Figure 11-6 Input Method and Input ContextsLBL="" HELPID=""Input ManagerID="ch11313"The input method and input context described in the previous sections are transparent to the Motif programmer.  Motif has an Input Manager that handles all necessary interface between an application and the input context and input method.  The input manager functions are performed by VendorShell.  A Motif application only needs to register a widget using ID="ch11314"XmImRegister.  As mentioned earlier, you can select the input method user interaction style  by setting the ID="ch11315"VendorShell resource ID="ch11316"XmNpreeditType.  This is shown in the example program.  ID="ch11317"A widget using the input manager must use the function XmImMbLookupString to retrieve character input from the keyboard.  ID="ch11318"LBL="" HELPID=""Input and the Motif Text WidgetID="ch11319"The Motif Text and TextField widgets, when editable, provide a transparent connection to the locale-specific input method for text input.  The application programmer specifies an appropriate font set in the Text or TextField ID="ch11320"XmNfontList resource and creates either widget as a descendant of ID="ch11321"VendorShell.  VendorShell provides geometry management of the status and pre-edit areas.  It also supplies a visual separator between the status area window and the application's top level window.  ID="ch11322"Setting the VendorShell resource XmNpreeditType dictates the location of the input method window.  With an off-the-spot input method, the pre-edit and status area windows appear at the bottom of the application window.  ID="ch11323"ID="ch11324"LBL="" HELPID=""Text Input Using a DrawingAreaID="ch11325"An application that needs special text processing may use a DrawingArea for text input and output.  For internationalized text input with any widget other than Text or TextField, the application must use the Xlib input method facilities.  These allow the application to open an input method and input context and to obtain input from the input method.  When using these facilities, an application may also need to handle input method geometry management, focus management, event filtering, and other issues.  For more information, see Xlibname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'C Language X Interface.  LBL="" HELPID=""Geometry Management of Pre-Edit and Status AreasID="ch11326"ID="ch11327"When an off-the-spot input method is used with the Text or TextField widget, the pre-edit and status areas are below the client's main window but inside the VendorShell.  VendorShell accomplishes the necessary geometry management.  If the application uses either ID="ch11328"ID="ch11329"ID="ch11330"XtGetValues or XtSetValues to get or set the height (ID="ch11331"ID="ch11332"XmNheight) of VendorShell, the height includes the height of the input method area.  ID="ch11333"The following figure shows a Text widget using an off-the-spot input method.  The distance "h" is the additional height that the input manager needs to display the status and pre-edit areas.  Note that in off-the-spot, the pre-edit area is at the bottom of the interaction.  ID="ch11334"LBL="11-7" FILE="offspot.gif" POSITION="INLINE" SCALE="FALSE"LBL="11-7"Figure 11-7 Text Widget Pre-Edit and Status Areas Using Off-the-SpotLBL="11.4.2" HELPID=""ID="35152"Compound Strings and Compound TextID="ch11335"ID="ch11336"Compound text is the standard format for exchanging textual data between X window system applications.  This is necessary when the user moves text displayed in one codeset to another window with text in a different codeset.  For example, the following figure shows two windows, one titled "UJIS" and the other titled "Shift JIS." LBL="11-8" FILE="comptext.gif" POSITION="INLINE" SCALE="FALSE"LBL="11-8"Figure 11-8 Reason for Compound TextBoth windows represent a Motif Text widget, one with some Japanese UJIS characters displayed, and the other with some Shift JIS characters.  If the user wants to cut text from one window and paste it in the other window, compound text is used to pass data between the two.  The Motif Text widget does this automatically.  ID="ch11337"If one of the widgets in the previous figure is a Label widget instead of a Text widget, a different situation exists.  This is because the Label widget has its text data in compound string format, while the text widget data is a simple character string.  In order to pass text data between a Text or TextField widget and any other widget, the application needs to convert the compound string to compound text.  ID="ch11338"ID="ch11339"ID="ch11340"Motif has two functions, XmCvtXmStringToCT and ID="ch11341"XmCvtCTToXmString, for converting between compound strings and compound text.  ID="ch11342"XmCvtXmStringToCT converts a compound string to compound text.  The converter uses the font list tag associated with a given compound string segment to select a compound text format for that segment.  A registry defines a mapping between font list tags and compound text encoding formats.  The converter uses the following algorithm for each compound string segment: ID="ch11343"If the compound string segment tag is mapped to XmFONTLIST_DEFAULT_TAG in the registry, the converter passes the text of the compound string segment to ID="ch11344"XmbTextListToTextProperty† †with an encoding style of ID="ch11345"XCompoundTextStyle and uses the resulting compound text for that segment.  ID="ch11346"If the compound string segment tag is mapped to an MIT registered charset in the registry, the converter creates the compound text for that segment using the charset (from the registry) and the text of the compound string segment as defined in the X Consortium Standard Compound Text Encoding.  If the compound string segment tag is mapped to a charset in the registry that is neither XmFONTLIST_DEFAULT_TAG nor an MIT registered charset, the converter creates the compound text for that segment using the charset (from the registry) and the text of the compound string segment as an "extended segment" with a variable number of octets per character.  ID="ch11347"If the compound string segment tag is not mapped in the registry, the result is implementation dependent.  An application can use XmRegisterSegmentEncoding to map a font list element tag to a compound text encoding format.  For example, the application may be using a font list element tag of "BOLD" to identify a compound text segment consisting of localized text to be displayed in a bold font.  To ensure that the segment is treated as localized text when converted to compound text, the tag "BOLD" should be mapped to ID="ch11348"XmFONTLIST_DEFAULT_TAG as follows: ID="ch11349"char *old_encoding = XmRegisterSegmentEncoding("BOLD",
† †                        XmFONTLIST_DEFAULT_TAG);
XtFree(old_encoding);XmCvtCTToXmString converts compound text to a compound string.  This function is implementation dependent.  ID="ch11350"See IDREF="22739" TYPE="TITLE"Chapter 16, "Interclient Communication,"
 for more information on transferring data between applications.  The compound text format is described in the X Consortium Standard Compound Text Encoding.  LBL="12"ID="35125"Color and PixmapsID="ch121"ID="ch122"Motif uses colors and pixmaps for several general purposes: To fill window backgrounds and borders To draw text and graphics in window foregrounds To generate shadows with a three-dimensional appearance To highlight the widget that has keyboard focus To indicate that a button is armed or selected Motif uses other pixmaps for specific purposes: As the application's icon for use by the window manager For drag icons and drop site animation As a CascadeButton symbol indicating that a menu is attached to the CascadeButton ID="ch123"As a MessageBox symbol indicating the type of message displayed ID="ch124"As the face of a button when the button is insensitive All of these colors and pixmaps are represented as resources.  The user or application can set the resource values using resource files, and the application can set them using XtSetValues.  ID="ch125"Motif also uses a number of pixmaps that are not represented as resources.  The user and application cannot change these.  Among these fixed pixmaps are the following: The pixmaps used to stipple insensitive widgets The pixmaps used to draw arrows in ScrollBars ID="ch126"The pixmaps used to create the default source cursor icons in Text, TextField, List, and Label subclasses ID="ch127"ID="ch128"ID="ch129"ID="ch1210"LBL="12.1" HELPID=""Default Colors and PixmapsID="ch1211"The following resources determine the colors or pixmaps generally used in Motif: BordersCore resources XmNborderColor and XmNborderPixmap† †ID="ch1212"ID="ch1213"ID="ch1214"BackgroundsCore resources XmNbackground and XmNbackgroundPixmap† †ID="ch1215"ID="ch1216"ID="ch1217"ForegroundsPrimitive and Manager resource XmNforeground; Label and LabelGadget resources ID="ch1218"ID="ch1219"ID="ch1220"ID="ch1221"XmNlabelPixmap and ID="ch1222"ID="ch1223"XmNlabelInsensitivePixmap† †ID="ch1224"ShadowsPrimitive and Manager resources XmNbottomShadowColor, ID="ch1225"ID="ch1226"ID="ch1227"XmNbottomShadowPixmap, XmNtopShadowColor, and ID="ch1228"ID="ch1229"XmNtopShadowPixmap† †ID="ch1230"Focus highlightsPrimitive and Manager resources XmNhighlightColor and ID="ch1231"ID="ch1232"ID="ch1233"XmNhighlightPixmap† †ID="ch1234"Arming and selection PushButton and PushButtonGadget resources XmNarmColor and ID="ch1235"ID="ch1236"ID="ch1237"XmNarmPixmap; ToggleButton and ToggleButtonGadget resources ID="ch1238"ID="ch1239"ID="ch1240"XmNarmColor, XmNselectPixmap, and ID="ch1241"ID="ch1242"XmNselectInsensitivePixmap; ScrollBar resource ID="ch1243"ID="ch1244"XmNtroughColor† †ID="ch1245"The following sections describe these groups of resources and their defaults.  LBL="12.1.1" HELPID=""BordersID="ch1246"The border color or border pixmap is used to fill the border of a widget if XmNborderWidth is greater than 0.  Note that the border is outside the widget; that is, it is not within the area determined by the widget's ID="ch1247"XmNheight and XmNwidth.  If the user or application supplies a value for ID="ch1248"ID="ch1249"XmNborderPixmap, that pixmap is used to fill the border; otherwise, ID="ch1250"XmNborderColor† †is used.  ID="ch1251"If the application resource reverseVideo is False or unspecified, the default for ID="ch1252"XmNborderColor is the black pixel of the widget's screen.  If ID="ch1253"reverseVideo is True, the default for XmNborderColor is the white pixel of the widget's screen.  ID="ch1254"ID="ch1255"LBL="12.1.2" HELPID=""BackgroundsID="ch1256"The background color or background pixmap is used to fill a widget before anything else is displayed in it.  If the user or application supplies a value for XmNbackgroundPixmap, that pixmap is used to fill the background; otherwise, the ID="ch1257"XmNbackground color is used.  A gadget inherits the background color and background pixmap of its parent.  ID="ch1258"The default for XmNbackground is implementation dependent.  ID="ch1259"LBL="12.1.3" HELPID=""ForegroundsID="ch1260"The foreground color is used to display text and most graphics in a widget.  Most widgets use the XmNforeground color for this purpose.  Label, LabelGadget, and their subclasses, including buttons, have pixmap resources that are used for the face of the label or button when ID="ch1261"ID="ch1262"ID="ch1263"XmNlabelType is set to XmPIXMAP.  In this case, ID="ch1264"ID="ch1265"XmNlabelPixmap is used for the face when the widget is sensitive, and ID="ch1266"XmNlabelInsensitivePixmap is used when the widget is insensitive.  A gadget inherits the foreground color of its parent.  ID="ch1267"The default for XmNforeground is a color that contrasts with the background color, based on the XmScreen resource ID="ch1268"ID="ch1269"XmNforegroundThreshold.  The value of this resource is an integer between 0 and 100, inclusive, that specifies a level of perceived brightness for a color.  If the perceived brightness of the background color is equal to or below this level, Motif treats the background as "dark" when computing the default foreground color.  If the perceived brightness of the background color is above this level, Motif treats the background as "light" when computing the default foreground color.  When the background is "dark," the default foreground is white; when the background is "light," the default foreground is black.  ID="ch1270"LBL="12.1.4" HELPID=""ShadowsID="ch1271"The top shadow color or top shadow pixmap is used to draw the top and left sides of the three-dimensional shadow at the edge of some widgets.  If the user or application supplies a value for XmNtopShadowPixmap, that pixmap is used for the top and left sides; otherwise, ID="ch1272"XmNtopShadowColor is used.  ID="ch1273"The bottom shadow color or bottom shadow pixmap is used to draw the bottom and right sides of the three-dimensional shadow.  If the user or application supplies a value for XmNbottomShadowPixmap, that pixmap is used for the bottom and right sides; otherwise, ID="ch1274"XmNbottomShadowColor is used.  ID="ch1275"A gadget inherits the top and bottom shadow colors and pixmaps of its parent.  In computing the defaults for XmNtopShadowColor and ID="ch1276"XmNbottomShadowColor, Motif uses the XmScreen resources ID="ch1277"ID="ch1278"XmNdarkThreshold and XmNlightThreshold.  The value of each resource is an integer between 0 and 100, inclusive, that specifies a level of perceived brightness for a color.  If the perceived brightness of the background color is equal to or below the ID="ch1279"ID="ch1280"XmNdarkThreshold, Motif treats the background as "dark" when computing the default shadow colors.  If the perceived brightness of the background color is above the ID="ch1281"XmNlightThreshold, Motif treats the background as "light" when computing the default shadow colors.  Otherwise, Motif treats the background as "medium" when computing the defaults.  ID="ch1282"Motif computes the defaults in the following way, depending on the perceived brightness of the background: Dark background The top and bottom shadow colors are interpolated toward white from the background, with the top shadow color shifted more toward white than the bottom shadow color.  Light background The top and bottom shadow colors are interpolated toward black from the background, with the bottom shadow color shifted more toward black than the top shadow color.  Medium background The top shadow color is interpolated toward white from the background, and the bottom shadow color is interpolated toward black from the background.  LBL="12.1.5" HELPID=""Focus HighlightsID="ch1283"ID="ch1284"ID="ch1285"The highlight color or highlight pixmap is used to draw the highlighting rectangle around widgets that have keyboard focus.  If the user or application supplies a value for XmNhighlightPixmap, that pixmap is used for the highlight; otherwise, ID="ch1286"XmNhighlightColor is used.  The highlight color is also used to draw the location cursor around List items that have keyboard focus.  A gadget inherits the highlight color and highlight pixmap of its parent.  ID="ch1287"ID="ch1288"The default highlight color is the same as the default foreground color.  LBL="12.1.6" HELPID=""Arming and SelectionID="ch1289"ID="ch1290"In PushButtons and PushButtonGadgets outside menus, ID="ch1291"ID="ch1292"XmNarmColor is used as the button background when the ID="ch1293"XmNfillOnArm resource is True and the user arms the button.  In PushButtons and PushButtonGadgets outside menus, ID="ch1294"ID="ch1295"ID="ch1296"XmNarmPixmap is used as the button face (the label area) when ID="ch1297"XmNlabelType is XmPIXMAP and the user arms the button.  ID="ch1298"ID="ch1299"In ToggleButtons and ToggleButtonGadgets outside menus, ID="ch12100"ID="ch12101"XmNselectColor is used to fill the toggle indicator when the ID="ch12102"XmNindicatorOn and XmNfillOnSelect resources are both True and the user sets the toggle.  For sensitive ToggleButtons and ToggleButtonGadgets outside menus, ID="ch12103"ID="ch12104"ID="ch12105"ID="ch12106"XmNselectPixmap is used as the button face (the label area) when ID="ch12107"XmNlabelType is XmPIXMAP and the toggle is set.  For insensitive ToggleButtons under these conditions, ID="ch12108"ID="ch12109"ID="ch12110"XmNselectInsensitivePixmap is used as the button face.  ID="ch12111"In ScrollBars, XmNtroughColor is used to fill the part of the slider area that is not taken up by the slider.  ID="ch12112"ID="ch12113"Motif computes a single default, known as the select color, for XmNarmColor, XmNselectColor, and XmNtroughColor.  Motif uses the XmScreen resources ID="ch12114"ID="ch12115"ID="ch12116"XmNdarkThreshold and ID="ch12117"ID="ch12118"XmNlightThreshold to determine whether the background is "dark," "light," or "medium" in the same way as for shadow colors.  Motif then computes the default in the following way: ID="ch12119"Dark background The select color is interpolated toward white from the background.  Light background The select color is interpolated toward black from the background.  Medium background The select color is interpolated toward black from the background.  LBL="12.2" HELPID=""Application-Defined Color GenerationMotif generates default colors whenever the application creates a widget that has no specified value for one or more of the color resources.  Motif does not regenerate default colors when an application changes the value of XmNbackground using XtSetValues.  ID="ch12120"ID="ch12121"An application can use XmChangeColor to recalculate default colors for a widget based on a new background and set the appropriate color resources in the widget.  For primitives and managers, ID="ch12122"XmChangeColor sets ID="ch12123"XmNbackground, XmNforeground, XmNtopShadowColor, and ID="ch12124"ID="ch12125"ID="ch12126"XmNbottomShadowColor.  For widgets and gadgets with select colors, ID="ch12127"XmChangeColor also sets the appropriate resources for those colors.  ID="ch12128"An application can use XmGetColors to produce default colors for a given background color without setting any resources.  ID="ch12129"XmGetColors takes as arguments a screen pointer, a colormap, and a background pixel representing a color allocated in the colormap.  XmGetColors also has return arguments that are pointers to pixel values for the foreground, top shadow, bottom shadow, and select colors.  The function generates default colors for the given background.  For each of the return arguments that is not NULL, XmGetColors allocates a color in the colormap and returns the pixel value at the address specified by the argument.  By default, XmChangeColor and XmGetColors calculate colors as described in the previous discussion of default colors.  An application can use ID="ch12130"ID="ch12131"XmSetColorCalculation to change the procedure that these routines use and that Motif uses to calculate default colors when the application creates a widget.  ID="ch12132"XmSetColorCalculation takes as its only argument a procedure of type ID="ch12133"XmColorProc.  It sets Motif's color-calculation procedure to the new ID="ch12134"XmColorProc and returns the color-calculation procedure used previously.  XmSetColorCalculation does not change the procedure used by ID="ch12135"XmChangeColor, XmGetColors, and Motif to calculate default colors for a monochrome screen.  ID="ch12136"ID="ch12137"Motif calls the XmColorProc when it needs to compute default colors or when the application calls ID="ch12138"XmChangeColor or ID="ch12139"XmGetColors.  The ID="ch12140"XmColorProc takes five arguments, all pointers to XColor† †structures.  The ID="ch12141"ID="ch12142"red, green, blue, and pixel members of the first structure are filled in with the background color.  The procedure calculates red, green, and blue values for the foreground, select, top shadow, and bottom shadow colors and fills in the other four XColor structures with these values.  ID="ch12143"The procedure should not allocate color cells for any of these colors.  Motif caches the returned XColor structures and allocates a color when it needs a pixel value.  Usually Motif allocates a color when it computes the default value for a resource, when the application calls ID="ch12144"XmChangeColor, or when the application calls ID="ch12145"XmGetColors with a non-NULL value for one of the return pixel values.  When allocating colors as a result of widget creation or a call to ID="ch12146"XmChangeColor, Motif uses the colormap of the widget.  When allocating colors as a result of a call to ID="ch12147"XmGetColors, Motif uses the colormap passed as an argument to the function.  ID="ch12148"XmGetColorCalculation returns the color-calculation procedure being used at the time of the call to that routine.  Calling ID="ch12149"XmSetColorCalculation with an argument of NULL restores the Motif default color-calculation procedure.  ID="ch12150"LBL="12.3" HELPID=""ColormapsID="ch12151"The colormap used by a widget is the value of the Core resource ID="ch12152"XmNcolormap.  An application that does not supply its own colormap does not need to set this resource.  The default for a top-level shell is the default colormap of the screen.  For other widgets, the default is copied from the parent.  ID="ch12153"An application that uses its own colormap should not use XtAppInitialize to create the top-level shell, because the shell would then use the screen's default colormap.  Instead, the application should open the display, create the colormap, and then call ID="ch12154"XtAppCreateShell with the colormap as the ID="ch12155"XmNcolormap argument.  ID="ch12156"If an application uses different colormaps for some windows in its hierarchy, it must tell the window manager about those colormaps by setting a WM_COLORMAP_WINDOWS property on the top-level window.  See ID="ch12157"IDREF="22739" TYPE="TITLE"Chapter 16, "Interclient Communication,"
 for more information.  For more information about colormaps, see Xlibname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'C Language X Interface.  LBL="12.4" HELPID=""Using PixmapsID="ch12158"Motif uses pixmaps supplied by the application or the user for widget borders, backgrounds, labels, shadows, focus highlights, and button arming or selection indicators.  Motif also uses other pixmaps that the application or user can supply for more specific purposes: as application icons, drag icons, CascadeButton menu indicators, MessageBox symbols, and labels for insensitive buttons.  ID="ch12159"ID="ch12160"Motif provides facilities for an application to install and cache images and pixmaps.  Motif also has string-to-pixmap resource converters that retrieve pixmaps from the cache or install them from files in X bitmap format.  Because of these converters both applications and users can specify pixmaps as resource values from resource files or the command line.  An application can use XmGetPixmapByDepth to retrieve or create a pixmap with a specified name, screen, foreground, background, and depth.  ID="ch12161"XmGetPixmapByDepth finds or creates a pixmap in the following way: It searches the pixmap cache for a pixmap matching the specified name, screen, foreground, background, and depth.  If it finds a matching pixmap, it returns the pixmap.  If it does not find a matching pixmap in the cache, it searches the image cache for an image matching the specified name.  If it finds a matching image, it creates and caches a pixmap of the specified depth on the specified screen, transfers the image to the pixmap, and returns the pixmap.  If it does not find a matching image in the cache, it uses XtResolvePathname to search for a file of the specified name.  The search path comes from the environment variable ID="ch12162"XBMLANGPATH or, if ID="ch12163"XBMLANGPATH is not set, from a default search path.  If it finds such a file, it assumes that the file is in X bitmap format, reads the file, and creates and caches an image in ID="ch12164"XYBitmap format.  It then creates and caches a pixmap of the specified depth on the specified screen, transfers the image to the pixmap, and returns the pixmap.  If it does not find a matching X bitmap file, it returns XmUNSPECIFIED_PIXMAP.  ID="ch12165"Motif preinstalls a number of images in the image cache.  The names and characteristics of these images are documented in the XmInstallImage(3X) reference page.  Motif offers two ways for an application to provide its own image as the source for a pixmap to be created by XmGetPixmapByDepth: ID="ch12166"The application can create its own image, usually by using XCreateImage or XGetImage.  The image can be of any depth.  The application can then call ID="ch12167"ID="ch12168"XmInstallImage to install the image in the image cache by name.  ID="ch12169"The application or user can create a file in X bitmap format and install the file under an appropriate name in a directory that is in the search path used by XmGetPixmapByDepth.  For a description of the X bitmap format, see ID="ch12170"Xlibname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'C Language X Interface.  Both of these mechanisms have advantages and disadvantages.  An application using XmInstallImage can create an image of any depth.  However, if it intends to use the image name in a resource specification, it must be sure to call ID="ch12171"XmInstallImage before creating any widgets that use the image.  ID="ch12172"An application using an X bitmap file is limited to creating an image of depth 1.  However, the image is always available for use by a resource converter, and the application can use the search path mechanism of XtResolvePathname for such purposes as supplying different images for different locales.  ID="ch12173"XmInstallImage does not make a copy of the image when it caches it.  The application must not destroy the image until it removes the image from the cache, using ID="ch12174"XmUninstallImage.  An application can use ID="ch12175"XmDestroyPixmap to free a pixmap cached by ID="ch12176"XmGetPixmapByDepth.  ID="ch12177"XmDestroyPixmap does not actually destroy the pixmap until all references to it are freed.  ID="ch12178"LBL="13"ID="11820"Input, Focus, and Keyboard NavigationID="ch131"ID="ch132"ID="ch133"ID="ch134"ID="ch135"The X server communicates with clients by means of various classes of events.  Among these are events denoting input from the keyboard and mouse (and, in some X extensions, input from other devices).  Each event is associated with a window, and the X server sends the event to any client that has expressed interest in events of that type on that window.  ID="ch136"In the simplest case, when a keyboard or pointer event occurs, the X server sends the event to the client that has expressed interest in events of that type on the window that contains the pointer.  If no such client exists, the server searches up the window's hierarchy until it finds a client that has expressed interest in events of that type on an ancestor window.  In many cases, however, event processing is more complex: A client can grab a pointer button or key, the pointer or keyboard, or the entire server.  The grabbing client then receives the relevant events for the duration of the grab.  ID="ch137"A client can set the keyboard focus to some window.  Keyboard events that would normally be reported to this window or one of its inferiors are reported as usual, but other events are reported with respect to the focus window.  Window managers typically use this technique to implement a "click-to-type" interaction style, in which the user clicks the pointer on some window, and that window retains the keyboard focus regardless of the position of the pointer.  Other clients, often in cooperation with the window manager, can set the focus to a particular window within the application hierarchy.  ID="ch138"ID="ch139"To insulate applications from the complexities of X event handling, Xt and Motif have developed higher-level facilities based on widgets: Motif supplies a VendorShell resource, XmNkeyboardFocusPolicy, to allow a user or application to control the model of keyboard focus in the VendorShell and its descendants.  Keyboard focus can be with the widget the contains the pointer or with the widget in which the user presses ID="ch1310"ID="ch1311"ID="ch1312"BSelect.  ID="ch1313"In the click-to-type model, the user can also use keys to navigate from widget to widget.  Motif provides a model of tab groups, which are widgets or sets of widgets to which the user moves using ID="ch1314"KNextField and ID="ch1315"KPrevField.  Within a tab group, the user traverses between widgets using ID="ch1316"KUp, ID="ch1317"KDown, KLeft, and KRight.  Motif supplies resources to control whether or not a widget constitutes a tab group and whether or not the user can traverse to it using the keyboard.  Motif also has a general routine, ID="ch1318"ID="ch1319"ID="ch1320"XmProcessTraversal, for use by the application in moving keyboard focus to a widget or tab group.  The Motif menu system has a specialized traversal mechanism.  ID="ch1321"Xt provides the basic event-dispatching loop used by most applications.  Xt takes events out of the application's queue and dispatches them to the appropriate widget, usually the widget that has input focus.  Xt usually invokes an action associated with the particular event through a table of ID="ch1322"translations from event specifications to action routines.  The action, in turn, often invokes a callback list.  An application primarily responds to events by means of its callback routines.  At a lower level, it can also provide its own ID="ch1323"event handler, a routine invoked by the Xt dispatching loop when the widget receives events of the specified type.  ID="ch1324"Motif and Xt provide mnemonics and accelerators, which are shortcuts for taking actions associated with a widget when the widget does not have input focus.  A ID="ch1325"ID="ch1326"mnemonic is a keysym for a key that activates a visible button in a menu.  An ID="ch1327"accelerator is a description for an event that invokes an action routine through a translation.  ID="ch1328"LBL="13.1" HELPID=""Focus ModelsID="ch1329"ID="ch1330"Motif provides two models for determining which widget within an application receives keyboard events.  The focus model is determined for all descendants of a VendorShell by the value of the VendorShell resource ID="ch1331"XmNkeyboardFocusPolicy: ID="ch1332"When the value is XmEXPLICIT, the widget under the pointer does not necessarily receive keyboard events.  The user must take an action other than moving the pointer to transfer keyboard focus to a widget.  The user can usually transfer focus to a widget by pressing ID="ch1333"BSelect on that widget or by using a keyboard navigation action to traverse to the widget.  ID="ch1334"When the value is XmEXPLICIT, a widget must be traversable† †to receive keyboard events.  In general, a widget is traversable when its ID="ch1335"ID="ch1336"ID="ch1337"XmNsensitive, ID="ch1338"XmNancestorSensitive, and XmNtraversalOn resources are True and when the widget and its ancestors are managed, realized, mapped, and viewable.  See ID="ch1339"ID="ch1340"IDREF="24840" TYPE="TITLE"Section 13.2, "Controlling Keyboard Navigation,"
 for more information.  When the value is XmPOINTER, the widget under the pointer receives keyboard events, unless that widget is insensitive.  Keyboard navigation operations are not available.  However, the user can still use the keyboard to traverse a menu system.  ID="ch1341"KMenuBar moves focus to the MenuBar, and KMenu posts a PopupMenu if available.  When the user posts a menu using ID="ch1342"ID="ch1343"ID="ch1344"KMenu or BSelect Release, ID="ch1345"ID="ch1346"KActivate, or KSelect in a CascadeButton, keyboard navigation operations are available in the menu until the menu is unposted.  When the user exits the menu system, keyboard focus returns to the widget under the pointer.  ID="ch1347"ID="ch1348"ID="ch1349"MWM provides two parallel focus models for determining which top-level window receives keyboard events.  The focus model is determined by the value of the mwm resource ID="ch1350"ID="ch1351"keyboardFocusPolicy: ID="ch1352"When the value is "explicit", the window under the pointer does not necessarily receive keyboard events.  The user must take an action other than moving the pointer to transfer keyboard focus to a window.  The user can usually transfer focus to a window by pressing BSelect on that window or by using KNextFamilyWindow, ID="ch1353"ID="ch1354"KPrevFamilyWindow, KNextWindow, or KPrevWindow to traverse to the window.  ID="ch1355"ID="ch1356"ID="ch1357"When the value is "pointer", the widget under the pointer receives keyboard events.  Keyboard window navigation operations are not available.  When the focus policy is "explicit", four Boolean mwm resources can be set to True to allow a window to receive keyboard focus automatically at specified times: autoKeyFocusWhen the window with focus is iconified or unmapped (gives focus to the window that last had it) deiconifyKeyFocus When the window is iconified raiseKeyFocus When the window is raised to the top of the stack startupKeyFocus When the window is mapped LBL="13.2" HELPID=""ID="24840"Controlling Keyboard NavigationID="ch1358"ID="ch1359"In order to receive keyboard focus when the shell's XmNkeyboardFocusPolicy is XmEXPLICIT, a widget or gadget must meet the following conditions: ID="ch1360"ID="ch1361"The widget and its ancestors must not be in the process of being destroyed.  The widget and its ancestors must be sensitive.  A widget is sensitive when its ID="ch1362"XmNsensitive and ID="ch1363"XmNancestorSensitive resources are both True.  ID="ch1364"The XmNtraversalOn resource for the widget and its ancestors must be True.  ID="ch1365"The widget must be viewable.  This means that the widget and its ancestors must be managed, realized, and (except for gadgets) mapped.  Furthermore, in general, some part of the widget's rectangular area must be unobscured by the widget's ancestors.  In a ScrolledWindow with an XmNscrollingPolicy of ID="ch1366"ID="ch1367"XmAUTOMATIC, a widget that is obscured because it is not within the clip window may be traversable if some part of the widget is within the work area and if an ID="ch1368"XmNtraverseObscuredCallback routine can make the widget unobscured by scrolling the window.  ID="ch1369"Most managers cannot receive focus even if they meet all these conditions.  In general only primitives and gadgets are eligible to receive focus.  A DrawingArea can receive focus if it meets the conditions above and if, in addition, it has no child whose ID="ch1370"XmNtraversalOn resource is True.  ID="ch1371"XmGetFocusWidget takes a widget argument that identifies a widget hierarchy, up to the nearest shell ancestor.  It returns the widget in that hierarchy that has keyboard focus or that last had focus when the user navigated away from that hierarchy.  ID="ch1372"An application can use XmIsTraversable and XmGetVisibility† †to determine whether a widget is eligible to receive focus.  ID="ch1373"ID="ch1374"XmIsTraversable returns True if the widget argument meets all the conditions described in this section.  Otherwise, it returns False.  This routine generally returns False if the widget argument is a composite, even if it has traversable children.  ID="ch1375"XmGetVisibility returns a value indicating the visibility of the widget argument: ID="ch1376"XmVISIBILITY_FULLY_OBSCURED The widget is completely obscured by its ancestors or is not visible for some other reason (such as being unmapped or unrealized).  ID="ch1377"XmVISIBILITY_PARTIALLY_OBSCURED Some part of the widget's rectangular area is obscured by its ancestors.  ID="ch1378"XmVISIBILITY_UNOBSCURED None of the widget's rectangular area is obscured by its ancestors.  ID="ch1379"Note that a fully obscured widget may be traversable if it is inside the work area of an automatic ScrolledWindow with an ID="ch1380"XmNtraverseObscuredCallback list.  See ID="ch1381"IDREF="18077" TYPE="TITLE"Section 13.2.5, "Traversing to Obscured Widgets,"
 for more information.  LBL="13.2.1" HELPID=""SensitivityID="ch1382"Unless a widget is sensitive, Xt does not dispatch keyboard or pointer events to the widget.  An insensitive widget, therefore, cannot receive keyboard focus.  A widget can be sensitive only when all its ancestors are sensitive.  Two Boolean resources determine sensitivity: XmNsensitive and ID="ch1383"XmNancestorSensitive.  ID="ch1384"XmNsensitive indicates whether the widget itself is sensitive, and XmNancestorSensitive indicates whether all ancestors are sensitive.  An application uses the function XtIsSensitive to find out whether a widget is sensitive.  This function returns True when ID="ch1385"XmNsensitive and ID="ch1386"XmNancestorSensitive are both True; otherwise, it returns False.  ID="ch1387"The function XtSetSensitive changes the sensitivity of a widget.  With an argument of False, this function sets ID="ch1388"XmNsensitive to False and sets each child's ID="ch1389"XmNancestorSensitive to False.  With an argument of True, this function sets ID="ch1390"XmNsensitive to True and, if the widget's XmNancestorSensitive is also True, it sets each child's XmNancestorSensitive to True.  The function then recursively descends the widget tree.  For each descendant whose XmNsensitive and XmNancestorSensitive are both True, it sets XmNancestorSensitive to True for that widget's children.  Otherwise, it sets XmNancestorSensitive to False for the descendant widget's children.  In this way, XtSetSensitive ensures that each widget's ID="ch1391"XmNancestorSensitive is True only when the parent's ID="ch1392"XmNsensitive and XmNancestorSensitive are both True.  In other words, the widget is sensitive only when it and all its ancestors are sensitive.  To maintain this relation, an application should always use ID="ch1393"XtSetSensitive to change a widget's sensitivity instead of calling ID="ch1394"XtSetValues on the widget's resources.  ID="ch1395"Note that XtSetSensitive does not modify any resources for pop-up children.  If the parent widget is insensitive when a pop-up child is created, the child's ID="ch1396"XmNancestorSensitive will be False.  ID="ch1397"XtSetSensitive on the parent widget will not change this value, and the child will remain insensitive.  To avoid this problem, an application that creates a DialogShell or a MenuShell should either ensure that the parent is sensitive when the child is created, or specify a value of True for the child's ID="ch1398"ID="ch1399"ID="ch13100"XmNancestorSensitive.One way to do this is in a resource file: ID="ch13101"*XmMenuShell.ancestorSensitive:   True
*XmDialogShell.ancestorSensitive: TrueWhen a widget or gadget is insensitive, Motif indicates the insensitivity to the user by stippling or graying the widget.  LBL="13.2.2" HELPID=""XmNtraversalOnXmNtraversalOn determines whether or not a widget is eligible to receive keyboard focus when ID="ch13102"XmNkeyboardFocusPolicy is ID="ch13103"XmEXPLICIT.  When ID="ch13104"XmNtraversalOn is False and XmNkeyboardFocusPolicy is XmEXPLICIT, it is not possible for the user to give keyboard focus to the widget, even if the widget is sensitive and viewable.  XmNtraversalOn has no effect when XmNkeyboardFocusPolicy is XmPOINTER.  ID="ch13105"The default value for XmNtraversalOn is True for most Motif widgets.  Following are the exceptions: ID="ch13106"Separator and SeparatorGadget, where XmNtraversalOn is forced to False ID="ch13107"ID="ch13108"ID="ch13109"ScrollBar, where XmNtraversalOn defaults to True when it is the child of a ScrolledWindow whose ID="ch13110"ID="ch13111"XmNscrollingPolicy is ID="ch13112"ID="ch13113"XmAUTOMATIC and to False otherwise ID="ch13114"Label and LabelGadget, where XmNtraversalOn is forced to False inside menus and defaults to False otherwise ID="ch13115"ID="ch13116"ID="ch13117"RowColumn, where XmNtraversalOn defaults to True in a WorkArea and is not applicable otherwise ID="ch13118"ID="ch13119"ID="ch13120"LBL="13.2.3" HELPID=""Tab GroupsID="ch13121"A tab group is a collection of traversable widgets or a single widget that contains a collection of traversable elements.  When the shell's XmNkeyboardFocusPolicy is XmEXPLICIT, the user traverses to a tab group using ID="ch13122"ID="ch13123"KNextField and ID="ch13124"KPrevField.  Within a tab group, when the focus is on a non-tab-group widget or an element, the user traverses to another non-tab-group widget or another element using ID="ch13125"KUp, KDown, KLeft, and KRight.  ID="ch13126"ID="ch13127"ID="ch13128"ID="ch13129"A tab group is always represented by a widget or gadget.  When the group is a collection of widgets, the tab group is typically the manager that is the parent of the widgets.  When the group is a single widget like List or Text, the tab group is that widget itself.  ID="ch13130"ID="ch13131"The arrow keys do not traverse to tab groups or to non-tab-group widgets or elements outside the current tab group.  To traverse to another tab group using the keyboard, the user must press KNextField or KPrevField.  ID="ch13132"ID="ch13133"To be eligible for traversal, a tab group must meet all the conditions discussed in IDREF="24840" TYPE="TITLE"Section 13.2, "Controlling Keyboard Navigation,"
 except that a manager that is a tab group and meets the other conditions is eligible for traversal as long as it contains a descendant that can receive focus.  If the tab group does not meet these conditions, the KNextField† †and ID="ch13134"KPrevField actions ignore the tab group.  ID="ch13135"Within a tab group, non-tab-group widgets must also meet all the conditions discussed in IDREF="24840" TYPE="TITLE"Section 13.2, "Controlling Keyboard Navigation,"
 to be eligible for traversal.  If they do not meet these conditions, the arrow key actions ignore the widgets.  Whether or not a widget is a tab group is determined by the value of the XmNnavigationType resource.  The two primary values for this resource are ID="ch13136"XmTAB_GROUP, which indicates that the widget is a tab group, and ID="ch13137"XmNONE, which indicates that it is not.  ID="ch13138"When the user traverses to the next or previous tab group, the direction of the traversal is usually determined by the relative locations of the current and target groups.  In a left-to-right language environment, traversal to each subsequent tab group proceeds from left to right and top to bottom.  At the bottom right, traversal wraps to the tab group at the top left.  Traversal to previous tab groups proceeds in the opposite direction.  The application can control the order of traversal by specifying an XmNnavigationType of XmEXCLUSIVE_TAB_GROUP for a widget in the hierarchy.  When any widget in a hierarchy has an ID="ch13139"ID="ch13140"XmNnavigationType of ID="ch13141"XmEXCLUSIVE_TAB_GROUP, KNextField and KPrevField do not move to any widgets in that hierarchy that have been designated tab groups by means of an ID="ch13142"ID="ch13143"ID="ch13144"XmNnavigationType of XmTAB_GROUP.  But ID="ch13145"ID="ch13146"KNextField and KPrevField do move to widgets whose ID="ch13147"ID="ch13148"XmNnavigationType is XmSTICKY_TAB_GROUP, even if some widgets are exclusive tab groups.  Thus, an application that uses ID="ch13149"ID="ch13150"XmEXCLUSIVE_TAB_GROUP to control traversal must be sure that all tab groups have an ID="ch13151"XmNnavigationType of either XmEXCLUSIVE_TAB_GROUP or ID="ch13152"ID="ch13153"XmSTICKY_TAB_GROUP.  ID="ch13154"When any widget in a hierarchy has an XmNnavigationType of ID="ch13155"XmEXCLUSIVE_TAB_GROUP, traversal to subsequent tab groups does not depend on the relative locations of the groups.  Instead, it proceeds to widgets in the order in which their ID="ch13156"XmNnavigationType resources were specified as ID="ch13157"XmEXCLUSIVE_TAB_GROUP or XmSTICKY_TAB_GROUP, either by creating the widgets with that value or by calling ID="ch13158"ID="ch13159"XtSetValues.  That is, traversal proceeds to the widget whose ID="ch13160"XmNnavigationType† †was next specified to be ID="ch13161"XmEXCLUSIVE_TAB_GROUP or ID="ch13162"XmSTICKY_TAB_GROUP.  Traversal to previous tab groups proceeds in the opposite direction.  ID="ch13163"Within a tab group whose XmNnavigationType is ID="ch13164"XmEXCLUSIVE_TAB_GROUP, the arrow keys do not behave the same way as they would if the ID="ch13165"XmNnavigationType were either ID="ch13166"XmTAB_GROUP or XmSTICKY_TAB_GROUP.  With ID="ch13167"ID="ch13168"XmTAB_GROUP or XmSTICKY_TAB_GROUP, the direction of traversal using the arrow keys depends on the relative locations of the tab group's children.  ID="ch13169"ID="ch13170"KRight moves to the next traversable child to the right of the child with the focus; ID="ch13171"KDown moves to the next traversable child below the child with the focus; and so on.  ID="ch13172"With XmEXCLUSIVE_TAB_GROUP, traversal using the arrow keys depends on the order of the tab group's list of children, not on the relative locations of the children.  ID="ch13173"KRight has the same effect as KDown: both move to the next traversable child in the tab group's list of children.  ID="ch13174"ID="ch13175"KLeft has the same effect as KUp: both move to the previous traversable child in the tab group's list of children.  ID="ch13176"ID="ch13177"There are three principal differences between XmEXCLUSIVE_TAB_GROUP and XmSTICKY_TAB_GROUP: ID="ch13178"ID="ch13179"XmEXCLUSIVE_TAB_GROUP has the effect of disabling traversal to tab groups that have an ID="ch13180"XmNnavigationType of XmTAB_GROUP.  ID="ch13181"ID="ch13182"XmSTICKY_TAB_GROUP does not; it simply ensures that traversal to that tab group is possible, even when some widget in the hierarchy has an ID="ch13183"XmNnavigationType of XmEXCLUSIVE_TAB_GROUP.  ID="ch13184"ID="ch13185"XmEXCLUSIVE_TAB_GROUP changes the order of traversal of tab groups within the widget hierarchy.  ID="ch13186"XmSTICKY_TAB_GROUP does not.  ID="ch13187"XmEXCLUSIVE_TAB_GROUP changes the order of traversal of widgets inside the tab group.  ID="ch13188"XmSTICKY_TAB_GROUP does not.  ID="ch13189"The function XmAddTabGroup has the same effect as calling ID="ch13190"XtSetValues with an XmNnavigationType of ID="ch13191"ID="ch13192"XmEXCLUSIVE_TAB_GROUP.  The function ID="ch13193"XmRemoveTabGroup has the same effect as calling ID="ch13194"XtSetValues with an XmNnavigationType of XmNONE.  ID="ch13195"ID="ch13196"ID="ch13197"XmAddTabGroup and XmRemoveTabGroup are obsolete and exist for compatibility with earlier releases of OSF/Motif.  ID="ch13198"ID="ch13199"All Motif managers except RowColumn have a default ID="ch13200"XmNnavigationType of XmTAB_GROUP.  In RowColumn, ID="ch13201"ID="ch13202"XmNnavigationType is not applicable for MenuBars, PulldownMenus, and PopupMenus.  For a WorkArea the default is ID="ch13203"ID="ch13204"ID="ch13205"ID="ch13206"ID="ch13207"XmTAB_GROUP, and for an OptionMenu the default is ID="ch13208"ID="ch13209"ID="ch13210"XmNONE.  ID="ch13211"All Motif primitives except List, ScrollBar, Text, and TextField have a default ID="ch13212"ID="ch13213"ID="ch13214"ID="ch13215"XmNnavigationType of XmNONE.  The default for List, Text, and TextField is ID="ch13216"ID="ch13217"XmTAB_GROUP, and the default for ScrollBar is ID="ch13218"ID="ch13219"ID="ch13220"ID="ch13221"XmSTICKY_TAB_GROUP.  These are all controls that have their own internal navigation.  ID="ch13222"ID="ch13223"Motif sets the navigation type of widgets in some situations.  In particular: The child of a shell always behaves as a tab group, no matter what the value of its XmNnavigationType.  ID="ch13224"Panes and sashes inside PanedWindows have a default ID="ch13225"XmNnavigationType of XmTAB_GROUP.  If the ID="ch13226"ID="ch13227"XmNnavigationType of a pane is XmNONE when the pane is created, Motif sets the value of that resource to ID="ch13228"ID="ch13229"XmTAB_GROUP.  ID="ch13230"SelectionBox and its subclasses set the XmNnavigationType of their automatically created List and Text children to ID="ch13231"ID="ch13232"ID="ch13233"ID="ch13234"XmSTICKY_TAB_GROUP.  ID="ch13235"The function XmGetTabGroup returns the tab group that contains a widget.  If the widget itself is a tab group or a shell, it returns that widget.  If neither the widget nor any ancestor up to the nearest shell is a tab group, it returns the nearest ancestor that is a shell.  Otherwise, it returns the nearest ancestor that is a tab group.  ID="ch13236"LBL="" HELPID=""Controlling Tab Group Traversal OrderBy default, KNextField and KPrevField traverse to successive tab groups in order of layout, from left to right and top to bottom, within a parent tab group, before proceeding in layout order to the next tab group that is a sibling of the parent.  Traversal order changes when any widget in a shell hierarchy has an ID="ch13237"ID="ch13238"XmNnavigationType of XmEXCLUSIVE_TAB_GROUP.  In this case, ID="ch13239"ID="ch13240"KNextField and KPrevField traverse only to widgets in the hierarchy whose ID="ch13241"ID="ch13242"XmNnavigationType is either ID="ch13243"XmEXCLUSIVE_TAB_GROUP or XmSTICKY_TAB_GROUP.  The traversal order is the order in which the widgets' ID="ch13244"ID="ch13245"XmNnavigationType was specified to be either ID="ch13246"XmEXCLUSIVE_TAB_GROUP or XmSTICKY_TAB_GROUP.  ID="ch13247"ID="ch13248"This mechanism gives an application the means to control tab group traversal order.  An application must do the following: Ensure that at least one widget in the shell hierarchy has an XmNnavigationType of XmEXCLUSIVE_TAB_GROUP† †ID="ch13249"ID="ch13250"Ensure that all widgets that the application wants to be tab groups have an XmNnavigationType of either XmEXCLUSIVE_TAB_GROUP or ID="ch13251"ID="ch13252"XmSTICKY_TAB_GROUP† †ID="ch13253"Specify values for the tab groups' XmNnavigationType, using either creation argument lists or ID="ch13254"XtSetValues, in the order in which the tab groups are to be traversed ID="ch13255"Note that, when a tab group has an XmNnavigationType of ID="ch13256"XmEXCLUSIVE_TAB_GROUP, traversal to non-tab-group widgets inside that tab group proceeds in the order in which the children appear in their parents' ID="ch13257"XmNchildren lists.  If the application wants to specify the order of tab group traversal but still wants traversal of non-tab-group widgets to proceed according to layout, it should select one widget in the hierarchy to have an ID="ch13258"XmNnavigationType of XmEXCLUSIVE_TAB_GROUP.  This tab group should contain no non-tab-group widgets.  For example, it could be the MainWindow if the MainWindow contains only tab groups, or it could be a primitive tab group, such as List or Text.  The application should then specify an ID="ch13259"ID="ch13260"ID="ch13261"ID="ch13262"XmNnavigationType of ID="ch13263"XmSTICKY_TAB_GROUP for all other tab groups in the hierarchy.  ID="ch13264"LBL="13.2.4" HELPID=""Initial FocusID="ch13265"ID="ch13266"A tab group may contain any combination of tab group and non-tab-group widgets.  A tab group that contains other widgets cannot receive focus itself.  When the user traverses to a composite tab group, Motif gives focus to some widget within the tab group.  Motif uses the Manager resource XmNinitialFocus in determining which widget receives focus.  The value of ID="ch13267"ID="ch13268"XmNinitialFocus is a widget that meets the following conditions: ID="ch13269"The widget must be either a tab group or a non-tab-group widget that can receive keyboard focus.  In general, a widget can receive keyboard focus when it is a primitive, a gadget, or a manager (such as a DrawingArea with no traversable children) that acts as a primitive.  ID="ch13270"The widget must not be a descendant of a tab group that is itself a descendant of the manager.  That is, the widget cannot be contained within a tab group that is nested inside the manager.  The widget and its ancestors must have a value of True for their XmNtraversalOn resources.  ID="ch13271"If the widget does not meet these conditions, XmNinitialFocus is treated as if the value were NULL.  ID="ch13272"Motif uses XmNinitialFocus to determine which widget receives focus in these situations: ID="ch13273"When the manager is the child of a shell and the shell hierarchy receives focus for the first time When focus is inside the shell hierarchy, the manager is a composite tab group, and the user traverses to the manager using the keyboard Motif then determines focus as follows: If XmNinitialFocus is a traversable non-tab-group widget, that widget receives focus.  ID="ch13274"If XmNinitialFocus is a traversable tab group, that tab group receives focus.  If that tab group is a composite with descendant tab groups or traversable non-tab-group widgets, these procedures are used recursively to assign focus to a descendant of that tab group.  ID="ch13275"If XmNinitialFocus is NULL, the first traversable non-tab-group widget that is not contained within a nested tab group receives focus.  ID="ch13276"If XmNinitialFocus is NULL and no traversable non-tab-group widget exists, the first traversable tab group that is not contained within a nested tab group receives focus.  If that tab group is a composite with descendant tab groups or traversable non-tab-group widgets, these procedures are used recursively to assign focus to a descendant of that tab group.  ID="ch13277"If a shell hierarchy regains focus after losing it, focus returns to the widget that had the focus at the time it left the hierarchy.  The use of XmNinitialFocus is undefined if the manager is a MenuBar, PulldownMenu, PopupMenu, or OptionMenu.  ID="ch13278"ID="ch13279"ID="ch13280"ID="ch13281"ID="ch13282"LBL="13.2.5" HELPID=""ID="18077"Traversing to Obscured WidgetsIn general, a widget is not eligible to receive focus unless some part of its rectangular area is unobscured by its ancestors.  However, it may be possible to traverse to a widget that is a descendant of a ScrolledWindow whose XmNscrollingPolicy is XmAUTOMATIC, even if that widget is not within the ScrolledWindow's clip window.  Traversal to such a widget is possible under the following conditions: ID="ch13283"ID="ch13284"ID="ch13285"ID="ch13286"Some part of the widget's rectangular area is within the bounds of the ScrolledWindow's work window.  ID="ch13287"The ScrolledWindow's clip window is completely unobscured by its ancestors.  If the ScrolledWindow is a descendant of another ScrolledWindow, it must be unobscured by the ancestor's work window but may be outside the ancestor's clip window.  ID="ch13288"The ScrolledWindow has a procedure on its ID="ch13289"XmNtraverseObscuredCallback list that can bring some part of the widget's rectangular area into the clip window.  ID="ch13290"The widget meets the other conditions for receiving focus described in IDREF="24840" TYPE="TITLE"Section 13.2, "Controlling Keyboard Navigation."Whenever the user attempts to traverse to such a widget and the widget is partially or fully obscured by the clip window, Motif calls the ScrolledWindow's XmNtraverseObscuredCallback procedures.  If the ScrolledWindow has one or more ancestor ScrolledWindows, Motif calls the ID="ch13291"ID="ch13292"XmNtraverseObscuredCallback list for each ScrolledWindow whose clip window obscures the traversal target, from the lowest level of the hierarchy to the highest.  The XmNtraverseObscuredCallback procedure can try to bring the widget into the clip window if necessary, usually by calling XmScrollVisible.  If the target widget is traversable after the ID="ch13293"XmNtraverseObscuredCallback procedures are invoked, that widget receives focus.  ID="ch13294"A procedure can determine the visibility of a widget by calling XmGetVisibility.  ID="ch13295"LBL="13.2.6" HELPID=""XmProcessTraversalID="ch13296"The principal routine for traversing to a widget is XmProcessTraversal.  Motif uses this routine to effect traversal when the user presses an arrow key, KNextField, or KPrevField.  An application can use ID="ch13297"ID="ch13298"XmProcessTraversal to implement its own traversal actions.  ID="ch13299"XmProcessTraversal takes two arguments, a widget and a constant specifying a traversal action.  The routine uses the widget argument to identify the hierarchy that contains the widget and that has its root at the nearest shell.  If that shell does not currently have the focus, any changes to the element with focus within that shell will not occur until the next time the shell receives focus.  ID="ch13300"The traversal action argument identifies one of three kinds of action to take.  The following descriptions of these actions refer to traversable non-tab-group widgets and traversable tab groups.  A traversable non-tab-group widget is a widget that is not a tab group and that meets all the conditions for receiving focus discussed in IDREF="24840" TYPE="TITLE"Section 13.2, "Controlling Keyboard Navigation."
  A traversable tab group is a tab group widget that meets the same conditions, except that a manager that is a tab group and meets the other conditions is also traversable as long as it contains a descendant that can receive focus.  The routine begins the traversal action from the widget in the hierarchy that currently has keyboard focus or that last had focus when the user traversed away from the shell hierarchy.  Traversal to a non-tab-group widget.  This kind of traversal is possible only when the widget that currently has focus is not a tab group.  Also, these actions do not move focus from one tab group to another.  The actions first determine the containing tab group.  This is the tab group containing the widget that currently has focus.  The actions traverse only to a non-tab-group widget within the containing tab group.  XmTRAVERSE_RIGHTIf the ID="ch13301"XmNnavigationType of the containing tab group is not ID="ch13302"XmEXCLUSIVE_TAB_GROUP, focus moves to the next traversable non-tab-group widget to the right of the widget that currently has focus.  At the right side of the tab group, this action wraps to the non-tab-group widget at the left side and next toward the bottom.  At the lower right corner of the tab group, this action wraps to the non-tab-group widget at the upper left.  ID="ch13303"If the XmNnavigationType of the containing tab group is ID="ch13304"XmEXCLUSIVE_TAB_GROUP, focus moves to the next traversable non-tab-group widget in the tab group, proceeding in the order in which the widgets appear in their parents' ID="ch13305"XmNchildren lists.  After the last widget in the tab group, this action wraps to the first non-tab-group widget.  ID="ch13306"XmTRAVERSE_LEFTIf the ID="ch13307"XmNnavigationType of the containing tab group is not ID="ch13308"XmEXCLUSIVE_TAB_GROUP, focus moves to the next traversable non-tab-group widget to the left of the widget that currently has focus.  At the left side of the tab group, this action wraps to the non-tab-group widget at the right side and next toward the top.  At the upper left corner of the tab group, this action wraps to the non-tab-group widget at the lower right.  ID="ch13309"If the XmNnavigationType of the containing tab group is ID="ch13310"XmEXCLUSIVE_TAB_GROUP, focus moves to the previous traversable non-tab-group widget in the tab group, proceeding in the reverse order in which the widgets appear in their parents' ID="ch13311"XmNchildren lists.  After the first widget in the tab group, this action wraps to the last non-tab-group widget.  ID="ch13312"XmTRAVERSE_DOWN If the ID="ch13313"XmNnavigationType of the containing tab group is not ID="ch13314"XmEXCLUSIVE_TAB_GROUP, focus moves to the next traversable non-tab-group widget below the widget that currently has focus.  At the bottom of the tab group, this action wraps to the non-tab-group widget at the top and next toward the right.  At the lower right corner of the tab group, this action wraps to the non-tab-group widget at the upper left.  ID="ch13315"If the XmNnavigationType of the containing tab group is ID="ch13316"XmEXCLUSIVE_TAB_GROUP, focus moves to the next traversable non-tab-group widget in the tab group, proceeding in the order in which the widgets appear in their parents' ID="ch13317"XmNchildren lists.  After the last widget in the tab group, this action wraps to the first non-tab-group widget.  ID="ch13318"XmTRAVERSE_UPIf the ID="ch13319"XmNnavigationType of the containing tab group is not ID="ch13320"XmEXCLUSIVE_TAB_GROUP, focus moves to the next traversable non-tab-group widget above the widget that currently has focus.  At the top of the tab group, this action wraps to the non-tab-group widget at the bottom and next toward the left.  At the upper left corner of the tab group, this action wraps to the non-tab-group widget at the lower right.  ID="ch13321"If the XmNnavigationType of the containing tab group is ID="ch13322"XmEXCLUSIVE_TAB_GROUP, focus moves to the previous traversable non-tab-group widget in the tab group, proceeding in the reverse order in which the widgets appear in their parents' ID="ch13323"XmNchildren lists.  After the first widget in the tab group, this action wraps to the last non-tab-group widget.  ID="ch13324"XmTRAVERSE_NEXTFocus moves to the next traversable non-tab-group widget in the tab group, proceeding in the order in which the widgets appear in their parents' ID="ch13325"XmNchildren lists.  After the last widget in the tab group, this action wraps to the first non-tab-group widget.  ID="ch13326"XmTRAVERSE_PREVFocus moves to the previous traversable non-tab-group widget in the tab group, proceeding in the reverse order in which the widgets appear in their parents' ID="ch13327"XmNchildren lists.  After the first widget in the tab group, this action wraps to the last non-tab-group widget.  ID="ch13328"XmTRAVERSE_HOMEIf the ID="ch13329"XmNnavigationType of the containing tab group is not ID="ch13330"XmEXCLUSIVE_TAB_GROUP, focus moves to the first traversable non-tab-group widget at the top left corner of the tab group.  ID="ch13331"If the XmNnavigationType of the containing tab group is ID="ch13332"XmEXCLUSIVE_TAB_GROUP, focus moves to the first traversable non-tab-group widget in the tab group, according to the order in which the widgets appear in their parents' ID="ch13333"XmNchildren lists.  ID="ch13334"Traversal to a tab group.  These actions first determine the current widget hierarchy and the containing tab group.  The current widget hierarchy is the widget hierarchy whose root is the nearest shell ancestor of the widget that currently has focus.  The containing tab group is is the tab group containing the widget that currently has focus.  XmTRAVERSE_NEXT_TAB_GROUPIf no tab group in the current widget hierarchy has a value of ID="ch13335"XmEXCLUSIVE_TAB_GROUP for XmNnavigationType, focus goes to the next traversable tab group that is to the right of the widget with current focus and is within the containing tab group.  At the right side of the containing tab group, this action wraps to the tab group at the left side and next toward the bottom.  At the lower right corner of the containing tab group, this action recursively moves up one level in the hierarchy.  Focus then goes to the next traversable tab group that is to the right of the original containing tab group and is within the tab group that contains that one.  At the lower right corner of the topmost tab group in the hierarchy, this action wraps to the first traversable tab group at the upper left corner of the topmost tab group.  ID="ch13336"ID="ch13337"If any tab group in the current widget hierarchy has a value of XmEXCLUSIVE_TAB_GROUP for XmNnavigationType, focus goes to the next traversable tab group in the hierarchy, in the order in which the ID="ch13338"ID="ch13339"XmNnavigationType resources of the tab groups were set to ID="ch13340"XmEXCLUSIVE_TAB_GROUP or XmSTICKY_TAB_GROUP.  After the last tab group in the hierarchy, this action wraps to the first tab group.  ID="ch13341"ID="ch13342"XmTRAVERSE_PREV_TAB_GROUPIf no tab group in the current widget hierarchy has a value of ID="ch13343"XmEXCLUSIVE_TAB_GROUP for XmNnavigationType, focus goes to the next traversable tab group that is to the left of the widget with current focus and is within the containing tab group.  At the left side of the containing tab group, this action wraps to the tab group at the right side and next toward the top.  At the upper left corner of the containing tab group, this action recursively moves up one level in the hierarchy.  Focus then goes to the next traversable tab group that is to the left of the original containing tab group and is within the tab group that contains that one.  At the upper left corner of the topmost tab group in the hierarchy, this action wraps to the first traversable tab group at the lower right corner of the topmost tab group.  ID="ch13344"ID="ch13345"If any tab group in the current widget hierarchy has a value of XmEXCLUSIVE_TAB_GROUP for XmNnavigationType, focus goes to the previous traversable tab group in the hierarchy, in the reverse order in which the ID="ch13346"ID="ch13347"XmNnavigationType resources of the tab groups were set to either ID="ch13348"XmEXCLUSIVE_TAB_GROUP or ID="ch13349"XmSTICKY_TAB_GROUP.  After the first tab group in the hierarchy, this action wraps to the last tab group.  ID="ch13350"Traversal to any widget.  In this case, the widget argument is the widget to which XmProcessTraversal tries to give focus.  ID="ch13351"XmTRAVERSE_CURRENTFocus goes to the widget argument if that widget is a traversable non-tab-group widget or tab group.  ID="ch13352"Note that XmProcessTraversal cannot be called recursively.  In particular, an application cannot call this routine from an ID="ch13353"XmNfocusCallback or XmNlosingFocusCallback procedure.  ID="ch13354"ID="ch13355"LBL="13.2.7" HELPID=""Focus CallbacksID="ch13356"BulletinBoard, Text, and TextField have XmNfocusMovedCallback† †callback lists.  Motif invokes the procedures on these lists when these widgets receive keyboard focus.  A callback procedure may change the widget's state to reflect the new focus, but it should not try to change the focus and, in particular, must not call ID="ch13357"ID="ch13358"ID="ch13359"ID="ch13360"XmProcessTraversal.  ID="ch13361"Text and TextField also have XmNlosingFocusCallback callback lists.  The Text and TextField traversal actions invoke these procedures before traversing to another widget.  The third argument to each procedure is a pointer to an ID="ch13362"ID="ch13363"ID="ch13364"ID="ch13365"ID="ch13366"XmTextVerifyCallbackStruct structure whose reason member is ID="ch13367"ID="ch13368"XmCR_LOSING_FOCUS.  If a callback procedure sets the ID="ch13369"doit member of this structure to False, the traversal action does not carry out the traversal.  In this way the application can prevent a user from traversing out of the widget by means of these actions.  Motif also invokes the XmNlosingFocusCallback procedures when the widget loses focus by some other means.  For example, the user might click ID="ch13370"BSelect in another traversable widget, or when the shell's ID="ch13371"XmNkeyboardFocusPolicy is ID="ch13372"XmPOINTER the user might move the pointer into another widget.  In such cases, setting the ID="ch13373"doit member of the callback structure has no effect.  LBL="13.3" HELPID=""Translations and ActionsID="ch13374"ID="ch13375"In Xt, the primary means of associating an input event with a widget-specific procedure is the combination of translations and actions.  Each widget (but not gadget) instance contains a table of translations that maps event descriptions to procedure names.  Each widget instance also has a table of actions that maps these procedure names to actual procedures.  When a widget receives an input event, the Xt event-dispatching facility looks up the event in the translation table, looks up the associated procedure in the action table, and invokes the action procedure itself.  This procedure usually takes some action to change the widget state and often invokes callback procedures.  LBL="13.3.1" HELPID=""Translation Table FormatID="ch13376"An application or user specifies a translation table as a string whose format is defined in X Toolkit Intrinsicsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'C Language Interface.  In general, the table consists of individual translations separated by "\n".  Each translation consists of an event description sequence, a colon, and one or more associated procedure names.  Each procedure name also has a list of parameters within parentheses to be passed to the procedure when it is invoked as a result of that translation.  An event description in general consists of an optional list of modifiers, an event type within angle brackets (< and >), an optional repeat count within parentheses, and an optional event detail.  Modifiers apply only to key, button, motion, enter, and leave events.  If an exclamation point (!) precedes the modifiers, then the modifiers in the list and no others must be asserted for the action to be invoked.  Otherwise, the modifiers in the list must be asserted, but others may be as well.  A tilde (~) before any modifier means that that modifier must not be asserted.  If the modifier list is empty, any modifiers may be asserted.  The detail field varies depending on the event type.  The most common use is to identify the keysym for a KeyPress or ID="ch13377"KeyRelease event.  ID="ch13378"Event descriptions in a sequence are separated by commas.  Mouse motion is discarded if it occurs between events in a sequence that does not include explicit motion events.  This allows the following sort of translation to invoke an action even if the mouse moves between button press and release: <Btn1Down>,<Btn1Up> : action()Following are some important considerations in using translations: More specific events should always precede less specific events in the table: Ctrl<Key>space : action_1()
<Key>space     : action_2()Translations with event sequences that are noninitial subsequences of other translations are not invoked when the events occur as part of the longer sequence.  For instance, up_action() in the following example would not be invoked on a button release that followed a button press: <Btn1Down>,<Btn1Up> : click_action()
<Btn1Up>            : up_action()Event descriptions that use a repeat count expand into longer sequences.  For example, the following descriptions are more or less equivalent: <Btn1Up>(2)                  : double_click()
<Btn1Up>,<Btn1Down>,<Btn1Up> : double_click()This result, combined with the implicit insertion of motion events between any two other events, means that motion translations cannot exist in a table with multiclick translations.  See X Toolkit Intrinsicsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'C Language Interface for more information on the format of translation tables.  LBL="13.3.2" HELPID=""Using TranslationsID="ch13379"One translation table frequently needs to be merged with another.  For example, a user may want to add one or more translations to a widget's default translations.  A translation table may begin with one of three directives that specifies how the table is to be merged with an existing table: #replaceThe new translation table should completely replace any existing table.  This is the default if no directive is specified.  #augmentThe new translation table should be added to any existing table.  If the two tables contain duplicate event descriptions, the translations in the existing table are used.  #overrideThe new translation table should be added to any existing table.  If the two tables contain duplicate event descriptions, the translations in the new table are used.  A widget's translation table is the value of the Core ID="ch13380"XmNtranslations resource.  The initial value is determined in the following way: ID="ch13381"If a non-NULL value is specified for XmNtranslations in the widget creation argument list, the widget class translations are merged with that value, in order, and the resulting table is used.  ID="ch13382"Otherwise, the following tables are merged, in order, and the resulting table is used: The widget class translations The value of the baseTranslations resource from the resource database ID="ch13383"The value of the XmNtranslations resource from the resource database or, if no value was specified, the default value for the widget's ID="ch13384"XmNtranslations† †ID="ch13385"To take advantage of this initialization ordering, an application should usually provide any translations of its own by specifying a value for baseTranslations rather than XmNtranslations in an application class defaults file or a fallback resource list.  This essentially reserves ID="ch13386"ID="ch13387"XmNtranslations to the user.  The application can change the widget class translations by specifying ID="ch13388"baseTranslations, and the user can change the application's translations by specifying ID="ch13389"XmNtranslations.  ID="ch13390"As the value of a widget's XmNtranslations, a translation table must be in a parsed format rather than a string.  The string-to-translation-table converter parses a resource string into a translation table.  An application can also use ID="ch13391"XtParseTranslationTable to compile a translation table string into the parsed format.  The application can then merge the parsed table with a widget's ID="ch13392"XmNtranslations in three ways: ID="ch13393"XtAugmentTranslations merges the parsed table in ID="ch13394"#augment mode XtOverrideTranslations merges the parsed table in ID="ch13395"#override mode XtSetValues of XmNtranslations replaces the existing value with the parsed table ID="ch13396"ID="ch13397"Some Motif widgets merge additional translations in their initialize and set_values methods.  This process may make it impossible for an application or user to override some translations by means of resource files.  For example, for some widgets it may not be possible to change traversal translations in this way.  ID="ch13398"ID="ch13399"ID="ch13400"ID="ch13401"LBL="13.3.3" HELPID=""ActionsID="ch13402"Each widget instance has a table that maps action procedure names, as they appear in translation tables, to actual action procedures.  When an action is invoked through a translation, Xt looks up the action procedure name in this table and calls the associated procedure.  Each widget class may have its own action table.  In addition, an application can use XtAppAddActions to add entries to an action table associated with the application context.  Only one such table exists per application context.  If a call to ID="ch13403"XtAppAddActions contains an action name that is already in the table, the action name becomes associated with the action procedure supplied in the call to XtAppAddActions, overriding the existing action.  Xt creates a widget's action table when the widget is realized.  It uses actions from the following action tables, those listed first having highest precedence: The action tables for the widget's class and its superclasses, in subclass-to-superclass order The action tables for the parent's class and its superclasses, in subclass-to-superclass order, and so on up the widget hierarchy The application context action table (created by calls to XtAppAddActions) ID="ch13404"This ordering means that an application cannot use XtAppAddActions† †to provide a new action procedure for an action name that is already registered by a widget class.  To do that, the application must supply a translation that maps the event to an action name that is not registered by the class.  The application must then call ID="ch13405"XtAppAddActions to supply a procedure for the action name.  ID="ch13406"An action procedure is a function of type XtActionProc.  This function receives four arguments: ID="ch13407"The widget The event, or the last event of a sequence, that caused the procedure to be invoked A list of strings representing the parameters specified for this action in the translation table An integer representing the number of parameters in the parameter list An application can use the parameter list to perform a number of related actions in a single action routine.  For example, a widget might have the following translations: c <Key> osfLeft  : move-object(left) \n\
c <Key> osfRight : move-object(right) \n\
c <Key> osfUp    : move-object(up) \n\
c <Key> osfDown  : move-object(down)The routine implementing the move-object() action is passed one of the strings "left", "right", "up", and "down" as the only item in the parameter list, depending on which key event invoked the action.  The routine performs the action appropriate for this parameter.  LBL="13.3.4" HELPID=""Bindings for osf KeysymsID="ch13408"ID="ch13409"Motif maintains a client-side mechanism for mapping one set of keysyms to another set.  This mapping allows Motif widgets and applications to use a single set of keysyms in translation tables and also allows applications and users to customize the keysyms used in the translations for the particular keyboard used with the display.  The names of keysyms eligible for use in translations in this way begin with the prefix "osf" and are referred to as osf keysyms.  Motif maintains a mapping between these "virtual" keysyms and the "actual" keysyms that correspond to keys on a particular keyboard.  When Xt receives a keyboard event, the function XmTranslateKey† †translates the keycode of the event to the appropriate osf keysym if a mapping exists for that keysym.  Xt then dispatches the event to the appropriate action routine if a translation exists for that osf keysym.  ID="ch13410"The mapping between osf and actual keysyms is determined at application startup based on information obtained from one of the following sources, listed in order of precedence: A defaultVirtualBindings application resource in the resource database.  ID="ch13411"A property on the root window, which can be set by mwm on startup, by the ID="ch13412"xmbind client, or on prior startup of a Motif application.  ID="ch13413"A .motifbind file in the user's home directory.  ID="ch13414"A default binding based on the vendor string and optionally the vendor release of the X server.  Motif searches the file xmbind.alias in the user's home directory, the directory specified by the environment variable XMBINDDIR, or the directory /usr/lib/Xm/bindings.  ID="ch13415"The file xmbind.alias maps combinations of vendor strings and vendor release numbers to pathnames.  Each pathname represents a file that contains keysym bindings for a particular vendor string and optional vendor release number.  If Motif fails to find a bindings file for the current display, it uses a set of hard-coded fallback bindings.  The format of the defaultVirtualBindings resource is similar to that of a string specifying translations.  Each binding consists of an osf keysym, a colon, a key event description (with optional modifiers) for the actual keysym, and "\n".  The format of a ID="ch13416".motifbind file or a file containing vendor bindings is the same, except that each binding is on a separate line.  Following is an example of a specification for the defaultVirtualBindings resource in a resource file: ID="ch13417"*defaultVirtualBindings: \
† †    osfBackSpace  :     <Key>BackSpace     \n\
† †    osfInsert     :     <Key>InsertChar     \n\
...
† †    osfDelete     :     <Key>DeleteCharThe example specification above appears as follows in a .motifbind or vendor bindings file: osfBackSpace  :     <Key>BackSpace
osfInsert     :     <Key>InsertChar
...
osfDelete     :     <Key>DeleteCharFor more information, see the VirtualBindings(3X) and xmbind(1X) reference pages in the OSF/Motif Programmer's Reference.  LBL="13.4" HELPID=""Mnemonics and AcceleratorsID="ch13418"ID="ch13419"Sometimes it is desirable for an event received by one widget to activate an action in another.  For example, the application may establish a shortcut for activating a button in a menu; the user can activate the menu item even when focus is not in the menu.  Motif has two facilities, mnemonics and accelerators, for allowing events in one widget to invoke actions in another.  A mnemonic is a keysym that identifies a key the user can press to activate a menu item when the menu is posted.  A button in a MenuBar, PulldownMenu, or PopupMenu can have a mnemonic.  When the button is in a PulldownMenu or PopupMenu that is the most recently posted menu, the user activates the button by pressing the key associated with the mnemonic.  When the button is in a MenuBar, the MenuBar must have focus for the mnemonic to activate the button.  However, the user can activate the button from within the hierarchy that contains the MenuBar, even if the MenuBar does not have focus, by pressing the key while holding the ID="ch13420"ID="ch13421"ID="ch13422"MAlt modifier.  An application or user supplies a mnemonic for a button by specifying a value for the Label or LabelGadget resource XmNmnemonic.  When the button is displayed, Motif underlines the first character in the label string that exactly matches the mnemonic in the character set specified by ID="ch13423"ID="ch13424"ID="ch13425"XmNmnemonicCharSet.  Although the mnemonic must match a character in the label string exactly in order to be underlined, the user can activate the mnemonic by pressing either the shifted or the unshifted key.  ID="ch13426"An accelerator allows the user to activate a menu item when focus is anywhere in the hierarchy containing the menu, even if the menu is not posted.  Accelerators are supported only for PushButtons and ToggleButtons (or their gadget equivalents) in PulldownMenus and PopupMenus.  ID="ch13427"ID="ch13428"ID="ch13429"ID="ch13430"An application or user supplies an accelerator for a button by specifying a value for the Label or LabelGadget resource ID="ch13431"ID="ch13432"XmNaccelerator.  The value is a string in the same format as an event description in a translation table, except that only ID="ch13433"KeyPress events are allowed.  Thus, an accelerator can have a modifier like ID="ch13434"MCtrl or MAlt.  XmNacceleratorText is a compound string that describes the accelerator event, for example, "Ctrl+A".  Motif displays the accelerator text to the side of the button's label string or pixmap.  ID="ch13435"The following example creates a button with a mnemonic and an accelerator: n = 0;
XtSetArg(args[n], XmNmnemonic, XStringToKeysym("A"); n++;
XtSetArg(args[n], XmNaccelerator, "Ctrl<Key>A"); n++;
XtSetArg(args[n], XmNacceleratorText,
† †        XmStringCreateLocalized("Ctrl+A"); n++;
button1 = XmCreatePushButton(file_pane, "Answer", args, n);
ID="ch13436"Motif's button accelerators and mnemonics are supported only for buttons in certain menus.  Xt has a more general facility, also called accelerators, for allowing events in one widget to invoke actions in another.  Xt accelerators are mappings of event descriptions to actions, in the same format as a translation table.  An application or user supplies accelerators for a widget as the value of the Core resource XmNaccelerators.  The accelerators map events to actions of this widget, called the source widget.  The application must then install the accelerators on a destination widget, using ID="ch13437"ID="ch13438"XtInstallAccelerators.  This routine takes two arguments: the source widget, whose ID="ch13439"XmNaccelerators resource contains the accelerator table; and the destination widget, where the accelerators are to be installed.  When the user produces an event in the destination widget that maps to an accelerator in the table, the event invokes the corresponding action ID="ch13440"in the source widget.  XtInstallAccelerators merges the accelerators with the destination widget's existing translations (the value of ID="ch13441"XmNtranslations).  Accelerators can be merged in either ID="ch13442"#augment mode, the default, or #override mode.  An accelerator table may begin with an #augment directive or a #override directive.  The #replace directive is ignored.  As with translations, accelerators must be in an internal format when they are the value of XmNaccelerators.  A string-to-accelerator-table converter parses an accelerator table string from a resource file.  An application can use ID="ch13443"XtParseAcceleratorTable to compile an acclerator table string explicitly.  ID="ch13444"Accelerators are often defined for a parent source widget and installed on one or more child destination widgets.  The SelectionBox and FileSelectionBox widgets install accelerators, the value of ID="ch13445"ID="ch13446"XmNtextAccelerators, on their text children.  The default accelerators bind ID="ch13447"KUp, KDown, KBeginLine, ID="ch13448"ID="ch13449"ID="ch13450"KEndLine, and KRestore events in the Text widget to SelectionBox or FileSelectionBox actions that select an item in the List and replace the Text widget value with that List item.  ID="ch13451"ID="ch13452"ID="ch13453"ID="ch13454"ID="ch13455"ID="ch13456"ID="ch13457"ID="ch13458"LBL="13.5" HELPID=""Event HandlersID="ch13459"ID="ch13460"Many applications can implement their entire input processing by adding procedures to widget callback lists and by adding mnemonics and accelerators for menu buttons.  Some applications change translations, accelerators, or actions.  More rarely, an application needs finer control over event processing.  Such an application can register an event handler with the Xt event dispatcher.  An event handler is a procedure that the Xt event dispatcher calls when the application receives events of one or more types.  An event handler procedure is of type XtEventHandler.  It receives four arguments: the widget for which the event arrived; any client data registered with the event handler; a pointer to the event; and a Boolean return argument telling the Xt dispatch facility whether or not to call the remaining event handlers registered for this event.  This argument is initialized to True and should rarely be changed.  ID="ch13461"An application usually registers an event handler using the function XtAddEventHandler.  The arguments are the widget, an event mask, an indication whether or not the hander should be called for nonmaskable events, the procedure itself, and any client data to be passed to the event handler when it is called.  The order in which event handlers are called is undefined when more than one handler exists for a given widget and event type.  However, if the application registers the event handler using ID="ch13462"XtInsertEventHandler, it can specify that the procedure is to be called either before or after all currently registered event handlers.  ID="ch13463"Motif requires an application to provide an event handler if it wants to post a PopupMenu on a button press.  The call to ID="ch13464"XtAddEventHandler should specify ButtonPressMask† †as the event mask and the popup RowColumn as the client data.  The event handler should use ID="ch13465"ID="ch13466"ID="ch13467"XmMenuPosition to position the menu at the x and y location of the button press event.  It should then manage the RowColumn.  If the button press matches the event specified by the RowColumn's ID="ch13468"XmNmenuPost resource, Motif posts the PopupMenu.  See ID="ch13469"IDREF="11089" TYPE="TITLE"Chapter 6, "Menus and Options,"
 for more information.  LBL="14"ID="13837"Graphics and Text in a DrawingAreaID="ch141"Most Motif widgets have specific functions.  A PushButton activates an action; a ScrollBar moves a scroll with respect to a viewport; a RowColumn contains a menu, a RadioBox or CheckBox, or a collection of widgets laid out in rows and columns.  In contrast, DrawingArea does not have a specific function.  It is useful for implementing a canvas, a specialized text editor, or other customized portions of an application.  ID="ch142"ID="ch143"ID="ch144"ID="ch145"ID="ch146"ID="ch147"LBL="14.1" HELPID=""DrawingArea: A General-Purpose WidgetID="ch148"DrawingArea is a manager with little specific behavior of its own.  It provides basic geometry management for widget and gadget children.  It also has callback lists that provide the application with low-level event handling.  An application can use these features to implement a canvas or a more specialized widget.  By default a DrawingArea attempts to adjust its size to contain all its children just inside its margins.  The DrawingArea resource ID="ch149"XmNresizePolicy determines how the DrawingArea responds to geometry requests from its children.  This resource has three possible values: ID="ch1410"XmRESIZE_ANY The DrawingArea tries to accept requests that would cause the DrawingArea to grow or shrink to enclose all its children.  This is the default.  ID="ch1411"ID="ch1412"XmRESIZE_GROW If its parent approves, the DrawingArea accepts requests from its children that would cause the DrawingArea to grow.  It may accept requests that would cause it to shrink, but it does not reduce its size.  ID="ch1413"ID="ch1414"XmRESIZE_NONE The DrawingArea has a fixed size determined by its ID="ch1415"ID="ch1416"XmNheight and XmNwidth resources.  It rejects geometry requests from its children that would cause the DrawingArea to grow.  It may accept requests that would cause it to shrink, but it does not reduce its size.  ID="ch1417"ID="ch1418"The DrawingArea resources XmNmarginHeight and XmNmarginWidth† †also affect geometry management.  When the value of ID="ch1419"ID="ch1420"ID="ch1421"XmNmarginHeight is greater than 0, the DrawingArea ensures that the top edges of all children are inside the top margin.  When the value of XmNmarginWidth is greater than 0, the DrawingArea ensures that the left edges of all children are inside the left margin.  See IDREF="18723" TYPE="TITLE"Chapter 10, "Managing Geometry,"
 for more information on DrawingArea's geometry management.  LBL="14.2" HELPID=""Event Handling and CallbacksID="ch1422"ID="ch1423"DrawingArea has callbacks, translations, and actions that inform the application when the DrawingArea is resized or when it receives an exposure event or one of many input events.  DrawingArea has the following callbacks: ID="ch1424"XmNexposeCallback DrawingArea invokes these callbacks whenever its ID="ch1425"expose widget class procedure is called.  The callback reason is ID="ch1426"ID="ch1427"ID="ch1428"XmCR_EXPOSE.  ID="ch1429"XmNinputCallback DrawingArea invokes these callbacks from the ID="ch1430"DrawingAreaInput()† †action.  With the default translations, this action is called when the DrawingArea receives a key press, key release, button press, or button release event.  The callback reason is ID="ch1431"XmCR_INPUT.  ID="ch1432"XmNresizeCallback DrawingArea invokes these callbacks whenever its ID="ch1433"resize widget class procedure is called.  The callback reason is ID="ch1434"ID="ch1435"ID="ch1436"XmCR_RESIZE.  ID="ch1437"Each callback procedure is passed a pointer to an XmDrawingAreaCallbackStruct, which includes the reason, the event (NULL for ID="ch1438"XmNresizeCallback), and the DrawingArea's window.  ID="ch1439"ID="ch1440"LBL="14.2.1" HELPID=""Handling Resize EventsID="ch1441"A widget's resize procedure is invoked when the widget is resized by its parent or when the widget's width or height changes as a result of ID="ch1442"ID="ch1443"XtSetValues.  DrawingArea also invokes its own ID="ch1444"resize procedure when it has made a successful geometry request of its parent to change its width or height.  ID="ch1445"ID="ch1446"ID="ch1447"For most widgets, the resize procedure recomputes the widget's layout to take account of the new size.  DrawingArea's ID="ch1448"ID="ch1449"resize procedure does no layout of its own.  It simply invokes the ID="ch1450"XmNresizeCallback callbacks.  It is the responsibility of these callback procedures to resize or reposition children or to recompute other contents of the DrawingArea.  The callback procedures essentially take the place of the DrawingArea's ID="ch1451"resize procedure.  Note that a resize procedure can be called when the widget is not realized.  ID="ch1452"ID="ch1453"LBL="" HELPID=""Moving and Resizing ChildrenAn XmNresizeCallback procedure should reposition or resize children by calling ID="ch1454"XtMoveWidget, XtResizeWidget, or ID="ch1455"ID="ch1456"XtConfigureWidget.  Use of these functions is usually restricted to widget class methods, but for DrawingArea, the ID="ch1457"XmNresizeCallback procedures act as part of the widget class ID="ch1458"ID="ch1459"resize procedure.  ID="ch1460"ID="ch1461"A callback procedure could also resize or reposition a child by invoking XtSetValues on one or more of the child's geometry resources (ID="ch1462"XmNx, XmNy, XmNheight, XmNwidth, and ID="ch1463"ID="ch1464"ID="ch1465"ID="ch1466"XmNborderWidth).  This causes ID="ch1467"XtSetValues to generate a geometry request on behalf of the child.  This request in turn might cause the DrawingArea to make a geometry request of its own parent.  In particular, when a child's request would cause the DrawingArea to change size and when the ID="ch1468"ID="ch1469"XmNresizePolicy of the DrawingArea is ID="ch1470"XmRESIZE_GROW or XmRESIZE_ANY, the DrawingArea is likely to make a geometry request.  ID="ch1471"ID="ch1472"However, the Intrinsics forbid a widget's resize procedure from making geometry requests.  Therefore, an ID="ch1473"ID="ch1474"XmNresizeCallback procedure must take care not to reposition or resize a child in such a way that the DrawingArea makes a geometry request.  The easiest way to avoid this problem is to use ID="ch1475"ID="ch1476"XtMoveWidget, ID="ch1477"XtResizeWidget, and XtConfigureWidget, which are guaranteed not to make geometry requests.  ID="ch1478"ID="ch1479"An XmNresizeCallback procedure must take care not to call the ID="ch1480"resize procedure for a child that is in the midst of making a geometry request.  This situation can arise when a child makes a geometry request, perhaps as a result of ID="ch1481"ID="ch1482"XtSetValues, that would cause the DrawingArea to change size.  If the DrawingArea's ID="ch1483"ID="ch1484"geometry_manager procedure issues a successful geometry request, it invokes its own ID="ch1485"ID="ch1486"resize procedure, which in turn calls the ID="ch1487"ID="ch1488"XmNresizeCallback procedures.  ID="ch1489"When this situation arises, the XmNresizeCallback procedure must not call the requesting child's ID="ch1490"resize procedure, whether it does this directly, as a result of calling ID="ch1491"ID="ch1492"XtResizeWidget or ID="ch1493"XtConfigureWidget, or as a result of a call to XtSetValues† †that changes the child's width or height.  If an application causes a DrawingArea child to make a geometry requestname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for example, by calling ID="ch1494"ID="ch1495"ID="ch1496"XtSetValues for one of the child's geometry resourcesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'it should store information in an internal data structure that identifies that child as making a geometry request.  The XmNresizeCallback procedure should check this information and take care not to call that child's ID="ch1497"resize procedure.  ID="ch1498"ID="ch1499"LBL="" HELPID=""Resizing and RedisplayA resize procedure often recomputes the layout of the widget but does not actually perform the redisplay.  In many cases, the act of resizing the widget generates one or more subsequent exposure events, and these in turn cause Xt to invoke the widget's ID="ch14100"ID="ch14101"expose procedure.  In general, the ID="ch14102"ID="ch14103"expose procedure is responsible for redisplay.  However, resizing a widget does not always generate exposure events, particularly when the widget is made smaller.  This is not a problem when the widget's contents consist solely of child widgets or gadgets.  The resize procedure can reposition or resize the children, and these actions generate the appropriate exposure events for both the children and the parent.  ID="ch14104"ID="ch14105"A resizing without an exposure event presents a problem when the contents of the widget include graphics, text, or other decoration outside child widgets.  For example, if the widget displays a shadow or other decoration around its inside edge, it must redisplay that decoration when the widget becomes smaller.  An application using a DrawingArea in this way must arrange to redisplay the window contents when the DrawingArea becomes smaller.  Following are two possible approaches: ID="ch14106"In an XmNresizeCallback procedure, compare the DrawingArea's width and height with their previous values.  If either width or height has decreased, redisplay the appropriate portions of the DrawingArea's contents.  In an internal data structure, store the width and height as the previous width and height for use by the next invocation of the ID="ch14107"ID="ch14108"XmNresizeCallback procedure.  ID="ch14109"In an XmNexposeCallback procedure, when the procedure is first invoked, set the window's bit gravity to ID="ch14110"ForgetGravity.  This causes the window's contents to be lost and an exposure event to be generated anytime the window is resized.  If the application does not set the bit gravity of the DrawingArea's window, the default set by the toolkit is ID="ch14111"ID="ch14112"NorthWestGravity.  This usually causes the server not to generate an exposure event when the window is made smaller.  ID="ch14113"DrawingArea itself does not draw shadows, and the default ID="ch14114"XmNshadowThickness is 0.  It is not practical for an application to draw OSF/Motif shadows itself in a DrawingArea, because the Motif shadow-drawing interface is not public.  An application that wants shadows with a DrawingArea should place the DrawingArea inside a Frame.  ID="ch14115"ID="ch14116"LBL="" HELPID=""Example of a Resize ProcedureFollowing is an XmNresizeCallback procedure for a DrawingArea that contains button children and lines connecting them.  The procedure spreads or contracts the layout of children and lines in proportion to the increase or decrease in size of the DrawingArea.  It uses an internal data structure to hold information about the end points of the lines and the previous width and height of the DrawingArea.  It assumes that an ID="ch14117"ID="ch14118"XmNexposeCallback procedure redisplays the lines.  ID="ch14119"void ReSize (
Widget          w,              /*  widget id           */
XtPointer       client_data,    /*  data from application   */
XtPointer       call_data )     /*  data from widget class  */
{
† † Graphic * graph = (Graphic *) client_data ;
† † Dimension width, height ;
† † Cardinal i,j ;
† † Arg args[5];        
† † int n ;                
† † Widget * children ;
† † Cardinal num_children ;
† † Position x,y ;
† † n = 0;
† † XtSetArg (args[n], XmNwidth, &width);  n++;
† † XtSetArg (args[n], XmNheight, &height);  n++;
† † XtGetValues (w, args, n);
† † float xratio = (float) width / graph->old_width, 
† † yratio = (float) height / graph->old_height ;
† † /* reposition and resize the graphic units */
† † for (i=0; i < graph->num_graphics; i++) {
† †   for (j=0; j < graph->graphics[i].num_points; j++) {
† †     graph->graphics[i].points[j].x *= xratio ;
† †     graph->graphics[i].points[j].y *= yratio ;
† †   }
† † }
† † /* reposition the pushbutton children */
† † n = 0;
† † XtSetArg (args[n], XmNnumChildren, &num_children);  n++;
† † XtSetArg (args[n], XmNchildren, &children);  n++;
† † XtGetValues (w, args, n);
† † for (i=0; i < num_children; i++) {
† †   n = 0;
† †   XtSetArg (args[n], XmNx, &x);  n++;
† †   XtSetArg (args[n], XmNy, &y);  n++;
† †   XtGetValues (children[i], args, n);
† †   XtMoveWidget (children[i], (Position) (x * xratio),
† †                 (Position) (y * yratio));
† † }
† † /* save width and height for next time */    
† † graph->old_width = width ;
† † graph->old_height = height ;
}LBL="14.2.2" HELPID=""Handling Exposure EventsID="ch14120"Xt calls a widget's expose procedure when the widget receives an exposure event.  The precise types of events that cause Xt to invoke the ID="ch14121"ID="ch14122"expose procedure are determined by the widget class compress_exposure† †field.  For ID="ch14123"XmDrawingArea, the value of this field is ID="ch14124"ID="ch14125"XtExposeNoCompress.  This means that Xt invokes the ID="ch14126"expose procedure when the widget receives an Expose event.  ID="ch14127"When the expose procedure is called, some part of the contents of the widget's window has been lost, and the window needs to be redisplayed.  Xt redisplays the contents of widget children by calling their ID="ch14128"ID="ch14129"expose procedures.  DrawingArea's expose procedure calls the XmNexposeCallback† †procedures.  These callbacks are responsible for redisplaying any contents of the DrawingArea that are outside the DrawingArea's children.  DrawingArea's ID="ch14130"ID="ch14131"expose procedure then redisplays the contents of gadget children by calling their expose procedures.  The X server generates Expose events when parts of a window are exposed for a variety of reasons, as when the window is raised or resized.  The server determines which portions of the window are exposed and decomposes these into a series of rectangles.  The server generates a series of ID="ch14132"Expose events, one for each rectangle.  ID="ch14133"DrawingArea does not compress exposure events.  The ID="ch14134"expose procedure, and therefore the XmNexposeCallback† †list, is called for each rectangle in an exposure series.  A simple callback procedure may redisplay the entire window on each exposure series.  Such a procedure should examine the ID="ch14135"ID="ch14136"ID="ch14137"count member of the XExposeEvent structure for the event.  A nonzero ID="ch14138"count indicates that more events are to follow in the exposure series.  The callback procedure should ignore these events and redisplay the entire window when count reaches 0.  A more complex procedure may redisplay only the exposed rectangles.  Such a procedure should extract the bounds of each rectangle from the x, y, width, and height members of each XExposeEvent structure.  The procedure can either redisplay each rectangle immediately or accumulate all the rectangles in an exposure series into a region, using ID="ch14139"XtAddExposureToRegion, and then redisplay the region.  ID="ch14140"An application that draws directly into the DrawingArea must be sure to regenerate the window contents correctly when the DrawingArea becomes smaller.  Making the DrawingArea smaller does not always generate ID="ch14141"Expose† †events.  The application can either perform the redisplay in an ID="ch14142"XmNresizeCallback procedure or, on the first invocation of the ID="ch14143"XmNexposeCallback list, set the window's bit gravity to ID="ch14144"ForgetGravity.  This ensures that each resizing of the DrawingArea generates an ID="ch14145"Expose event, so the application can safely leave all redisplay to the ID="ch14146"XmNexposeCallback procedure.  However, it also means that application must regenerate the entire contents of the window every time the window is resized.  ID="ch14147"LBL="" HELPID=""Example of an Expose ProcedureFollowing is an XmNexposeCallback procedure for a DrawingArea that contains button children and lines connecting them.  The first time the procedure is invoked, it sets the window's bit gravity to ID="ch14148"ID="ch14149"ForgetGravity so that resizing the window generates ID="ch14150"Expose events.  On the last of each series of exposure events, the procedure redraws all lines.  It uses an internal data structure to hold information about the end points of the lines.  ID="ch14151"void Redisplay (
Widget          w,              /*  widget id           */
XtPointer       client_data,    /*  data from application   */
XtPointer       call_data )     /*  data from widget class  */
{
† † XmDrawingAreaCallbackStruct * dacs =
† †   (XmDrawingAreaCallbackStruct *) call_data ;
† † Graphic * graph = (Graphic *) client_data ;
† † XExposeEvent * event = (XExposeEvent *) dacs->event;
† † XSetWindowAttributes xswa;
† † static Boolean first_time = True ;
† † if (first_time) {
† †   /* Change once the bit gravity of the Drawing Area; default
† †      is NorthWest and we want Forget, so that resize 
† †      always generates exposure events */
† †   first_time = False ;
† †   xswa.bit_gravity = ForgetGravity ;
† †   XChangeWindowAttributes(XtDisplay(w), XtWindow(w),
† †                           CWBitGravity, &xswa);
† † }
† † /* Redisplay only on last event of the series */    
† † if (! event->count) {
† †   for (i=0; i < graph->num_graphics; i++) {
† †     if (graph->graphics[i].type == POLYLINE)
† †       XDrawLines(XtDisplay(w), XtWindow(w), 
† †                  XDefaultGCOfScreen(XtScreen(w)),
† †                  graph->graphics[i].points, 
† †                  graph->graphics[i].num_points, 
† †                  CoordModeOrigin);
† †   }
† † }
}LBL="14.2.3" HELPID=""Handling Input EventsID="ch14152"ID="ch14153"As with any manager, DrawingArea may have three general kinds of input events within its borders: ID="ch14154"Events that belong to a widget child Events that belong to a gadget child Events that belong to no child Xt dispatches events to widget children when appropriate, and the DrawingArea does not process these.  DrawingArea inherits Manager's translations for dispatching events to gadget children.  Before calling any Manager action as a result of a button press or release or a key press or release, DrawingArea calls its own ID="ch14155"ID="ch14156"DrawingAreaInput() action.  DrawingArea also calls this action whenever it receives a button press or release or a key press or release that does not have an associated Manager action.  The DrawingAreaInput() action simply returns if the input event is not of type KeyPress, KeyRelease, ButtonPress, ID="ch14157"ID="ch14158"ID="ch14159"ButtonRelease, or MotionNotify.  If the event is of one of these types, and if the event does not take place within a gadget child of the DrawingArea, the action calls the ID="ch14160"ID="ch14161"ID="ch14162"XmNinputCallback callbacks.  ID="ch14163"With the default translations, the result is that the XmNinputCallback procedures are invoked whenever the DrawingArea receives a ID="ch14164"ID="ch14165"KeyPress, KeyRelease, ButtonPress, or ID="ch14166"ID="ch14167"ID="ch14168"ButtonRelease event that does not occur within a child.  ID="ch14169"The default translations do not invoke the DrawingAreaInput() action, and therefore the XmNinputCallback procedures, when the DrawingArea receives a ID="ch14170"MotionNotify event.  An application that wants its ID="ch14171"ID="ch14172"XmNinputCallback procedures invoked on pointer motion events must install the appropriate translations.  When installing a translation for ID="ch14173"BtnMotion, the application must override the existing translations.  The following translations cause a motion event to be sent to any gadget child in which it takes place.  If the event does not take place within a child, the ID="ch14174"XmNinputCallback procedures are invoked: ID="ch14175"<BtnMotion>:DrawingAreaInput() ManagerGadgetButtonMotion()\n\
<Motion>:DrawingAreaInput()There is one problem with these translations: because DrawingArea has translations for ID="ch14176"BSelect click and double click, the ID="ch14177"BtnMotion actions are not invoked when the user moves the pointer while pressing ID="ch14178"BSelect.  In order to receive these events, the application must replace the DrawingArea translations, omitting the translations for BSelect click and double click.  LBL="" HELPID=""ID="27461"Example of an Input ProcedureFollowing is an XmNinputCallback procedure for a DrawingArea that contains button children and lines connecting them.  The procedure takes action on ID="ch14179"ID="ch14180"ButtonPress and MotionNotify† †events.  When the user presses a mouse button, the procedure retrieves the text from a TextField elsewhere in the application.  If the user has entered text here, the input procedure creates a PushButton with the text as the label and places it at the point of the click.  If the TextField contains no text and the user has pressed a button over a line or PushButton while holding the Shift key, the procedure deletes the line or PushButton.  ID="ch14181"ID="ch14182"ID="ch14183"ID="ch14184"If the TextField is empty and the user presses a button without holding the Shift key, the procedure either starts or finishes drawing a line.  The application uses a rubber-banding effect for line drawing.  When it starts a line the procedure sets a flag indicating it is drawing a line; when it finishes the line, the procedure clears this flag.  When the procedure receives a MotionNotify event and is in the process of drawing a line, it erases the previous line (using XOR) and draws a new line from the anchor point to the current pointer position.  ID="ch14185"void HandleInput (
Widget          w,              /*  widget id           */
XtPointer       client_data,    /*  data from application   */
XtPointer       call_data )     /*  data from widget class  */
{
† † XmDrawingAreaCallbackStruct * dacs =
† †   (XmDrawingAreaCallbackStruct *) call_data ;
† † Graphic * graph = (Graphic *) client_data ;
† † Arg args[5];  
† † int   n ;     
† † String name ;
† † Widget newpush ;
† † if (dacs->event->type == ButtonPress) {
† †   name = XmTextFieldGetString(graph->textf); /* textfield */
† †   if (strcmp ("", name) != 0) {
† †     n = 0;
† †     XtSetArg (args[n], XmNx, dacs->event->xbutton.x);  n++;
† †     XtSetArg (args[n], XmNy, dacs->event->xbutton.y);  n++;
† †     newpush = XmCreatePushButton(w, name, args, n);
† †     XtAddCallback (newpush, XmNactivateCallback, PushCB,
† †                      NULL);
† †     XtManageChild (newpush);
† †   } else 
† †     if ((dacs->event->xbutton.state & ShiftMask) && 
† †         (!graph->in_drag)) {
† †       DeleteUnit (graph, dacs->event->xbutton.x,
† †                   dacs->event->xbutton.y);
† †     } else {
† †       if (!graph->in_drag) {
† †         StartUnit(graph, dacs->event->xbutton.x,
† †                   dacs->event->xbutton.y);
† †       } else {
† †         EndUnit(graph, dacs->event->xbutton.x,
† †                 dacs->event->xbutton.y);
† †       }
† †     }
† †   XtFree(name);
† † } else  /* need to get motion events here: app_default
† †            should modify DrawingArea translation with
† †            both Motion and BtnMotion additions */
† †   if (dacs->event->type == MotionNotify) {
† †     /* this one just exits if in_drag is False */
† †     DragUnit(graph, dacs->event->xbutton.x,
† †              dacs->event->xbutton.y);
† †   }
}LBL="14.3" HELPID=""Using a DrawingArea in a ScrolledWindowID="ch14186"ID="ch14187"The ScrolledWindow widget provides a viewport onto a virtual scroll and allows the user to move the scroll with respect to the viewport by manipulating ScrollBars.  ScrolledWindow offers two scrolling policies: automatic and application-defined.  In automatic scrolling, the application provides the scroll widget; ScrolledWindow creates a fixed-size viewport and handles user interaction with the ScrollBars.  In application-defined scrolling, the application provides the scroll widget and, if necessary, the viewport, and it handles all user interaction with the ScrollBars.  ID="ch14188"When using separate viewport and scroll widgets with either scrolling policy, an application can use a default DrawingArea as the scroll widget.  When the ID="ch14189"XmNresizePolicy is XmRESIZE_ANY, the application can use ID="ch14190"ID="ch14191"XtSetValues of XmNx and XmNy to place children within the DrawingArea.  The DrawingArea adjusts its size as necessary to enclose all the children.  The application can also use ID="ch14192"ID="ch14193"ID="ch14194"XtSetValues of the DrawingArea's XmNwidth and XmNheight to change the size of the scroll widget.  ID="ch14195"ID="ch14196"An application can also use a DrawingArea as the viewport widget in application-defined scrolling.  One approach is not to use a separate scroll widget but to maintain a virtual scroll, keeping the contents in internal data structures and displaying as much of the contents as will fit into the viewport.  The application can use a default DrawingArea as the viewport widget.  ID="ch14197"Another approach to application-defined scrolling is to create one widget as a viewport and another, a child of the viewport, as the scroll.  The application can expand the scroll widget as necessary to contain all the data.  In response to user manipulation of the ScrollBars, the application can reposition the scroll widget with respect to the viewport.  The viewport acts as a clipping region for its child, the scroll.  ID="ch14198"In this approach the application can use a DrawingArea as the viewport, the scroll widget, or both.  When using a DrawingArea as the viewport, the application must position and resize the scroll child using ID="ch14199"XtMoveWidget, ID="ch14200"XtResizeWidget, or XtConfigureWidget.  Using ID="ch14201"ID="ch14202"XtSetValues for the child's geometry resources does not work, because the parent's geometry manager does not permit the child to move or grow beyond the bounds of the parent.  ID="ch14203"When a DrawingArea is the viewport widget in a ScrolledWindow with application-defined scrolling, the ID="ch14204"ID="ch14205"XmNresizeCallback procedure must recompute the ScrollBars' ID="ch14206"XmNsliderSize and ID="ch14207"ID="ch14208"XmNpageIncrement and possibly other resources to reflect the new relation between the viewport and the scroll.  It may also need to reposition and resize the scroll with respect to the viewport.  ID="ch14209"See IDREF="21296" TYPE="TITLE"Chapter 9, "Scrolling, Panes, and Frames,"
 for more information on ScrolledWindow, including examples using DrawingAreas as scrolls in both automatic and application-defined scrolling.  ID="ch14210"ID="ch14211"LBL="14.4" HELPID=""Using a DrawingArea for GraphicsID="ch14212"DrawingArea is an appropriate widget to use as a canvas or as a manager that requires graphics operations in addition to children.  An application can use Xlib graphics facilities to draw into a DrawingArea.  See Xlibname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'C Language X Interface for more information on Xlib graphics operations.  An interactive graphics application can use the XmNinputCallback† †procedure to respond to user input.  For example, when the user presses a mouse button, drags, and then releases the button, this procedure might draw a line from the point of the button press to the point of the button release.  The ID="ch14213"XmNinputCallback procedures are invoked on button press and release events and on key press and release events.  To receive pointer motion events, the application can provide translations that invoke the DrawingAreaInput() action.  An application that needs to produce graphics but does not require children or interaction with the user in the canvas might use a DrawnButton instead of a DrawingArea.  DrawnButton has no input callbacks, but it does provide exposure and resize callbacks.  ID="ch14214"ID="ch14215"Following is some of the drawing code from the earlier example (in IDREF="27461" TYPE="TITLE""Example of an Input Procedure"
) of a DrawingArea containing button children and lines connecting them.  This example implements the rubber-band effect in which a line starts at an anchor point and follows the pointer as the user moves it.  ID="ch14216"The example maintains an internal data structure with information about the DrawingArea and its graphic objects.  The application initially stores a GC for use in drawing and erasing the rubber-band lines.  This GC uses a foreground color that results from combining the DrawingArea's foreground and background using XOR.  The GC also uses the ID="ch14217"GXxor function.  ID="ch14218"The remainder of the example code updates the internal data structures and draws lines as appropriate when the user starts a line, moves the pointer, and ends a line.  /* Initialize data structures */
void InitDraw (
Graphic            * graph,
ApplicationData    * app_data )
{
† † XGCValues val ;
† † Arg args[5];  
† † int   n ;                
† † Cardinal i ;
† † /* create the gc used for the rubber banding effect */
† † n = 0;
† † XtSetArg (args[n], XmNforeground, &val.foreground);  n++;
† † XtSetArg (args[n], XmNbackground, &val.background);  n++;
† † XtGetValues (graph->work_area, args, n);
† † val.foreground = val.foreground ^ val.background ;
† † val.function = GXxor ;
† † graph->drag_gc = 
† †    XtGetGC(graph->work_area, 
† †            GCForeground | GCBackground | GCFunction, &val);
† † graph->in_drag = False ;
† † graph->num_graphics = 0 ;
† † for (i=0; i < MAX_GRAPH; i++) {
† †   graph->graphics[i].num_points = 0 ;
† † }
}
/* Start a line */
void StartUnit (
Graphic           * graph,
Position            x,
Position            y )
{
† † Widget w = graph->work_area ;
† † graph->drag_point.x = graph->anchor_point.x = x ;
† † graph->drag_point.y = graph->anchor_point.y = y ;
† † graph->in_drag = True ;
† † XDrawLine(XtDisplay(w), XtWindow(w), 
† †           graph->drag_gc,
† †           graph->anchor_point.x, graph->anchor_point.y,
† †           graph->drag_point.x, graph->drag_point.y);
}
/* Pointer moved: if drawing a line, erase the last line
† †* and draw a new line from the anchor to the pointer
† †* position */
void DragUnit (
Graphic           * graph,
Position            x,
Position            y )
{
† † Widget w = graph->work_area ;
† † if (!graph->in_drag) return ;
† † XDrawLine(XtDisplay(w), XtWindow(w), 
† †           graph->drag_gc,
† †           graph->anchor_point.x, graph->anchor_point.y,
† †           graph->drag_point.x, graph->drag_point.y);
† † graph->drag_point.x = x ;
† † graph->drag_point.y = y ;
† † XDrawLine(XtDisplay(w), XtWindow(w), 
† †           graph->drag_gc,
† †           graph->anchor_point.x, graph->anchor_point.y,
† †           graph->drag_point.x, graph->drag_point.y);
}
/* Utility routine */
static Boolean NearPoint (
XPoint              point,
Position            x,
Position            y )
{
#define ERROR 5
† † if ((point.x > x - ERROR) &&
† †     (point.x < x + ERROR) &&
† †     (point.y > y - ERROR) &&
† †     (point.y < y + ERROR)) return True ;
† † else return False ;
}
/* End a line */
void EndUnit (
Graphic           * graph,
Position          x,
Position          y )
{
† † Widget w = graph->work_area ;
† † Cardinal num_points ;
† † /* no matter what happens, we need to remove the current
† †  * rubber band */
† † XDrawLine(XtDisplay(w), XtWindow(w), 
† †           graph->drag_gc,
† †           graph->anchor_point.x, graph->anchor_point.y,
† †           graph->drag_point.x, graph->drag_point.y);
† † /* if the given point if the same as the anchor, we're
† †    done with this polyline, exit drag mode and be ready
† †    for the next graphic unit (increment num_graphics) */
† † if (NearPoint(graph->anchor_point, x, y)) {
† †   graph->in_drag = False ;
† †   /* now see if a new unit needs to be created */
† †   if (graph->graphics[graph->num_graphics].num_points) {
† †     graph->graphics[graph->num_graphics].type = POLYLINE ;
† †     if (graph->num_graphics < MAX_GRAPH)
† †       graph->num_graphics ++ ;
† †     else BufferFullError() ;
† †   }
† † } else {
† †   /* draw the real line and store it in the structure */
† †   XDrawLine(XtDisplay(w), XtWindow(w), 
† †             XDefaultGCOfScreen(XtScreen(w)),
† †             graph->anchor_point.x, graph->anchor_point.y,
† †             x, y);
† †   /* first point in a unit is actually special */
† †   num_points =
† †         graph->graphics[graph->num_graphics].num_points ;
† †   if (num_points == 0) {
† †    graph->graphics[graph->num_graphics].points[num_points].x=
† †       graph->anchor_point.x ;
† †    graph->graphics[graph->num_graphics].points[num_points].y=
† †       graph->anchor_point.y ;
† †    graph->graphics[graph->num_graphics].num_points ++ ;
† †    num_points ++ ;
† †   }
† †   graph->graphics[graph->num_graphics].points[num_points].x
† †                                                           =x;
† †   graph->graphics[graph->num_graphics].points[num_points].y
† †                                                           =y;
† †   if (graph->graphics[graph->num_graphics].num_points
† †         < MAX_POINT) 
† †     graph->graphics[graph->num_graphics].num_points ++ ;
† †   else BufferFullError() ;
† †   /* now start the new unit */
† †   graph->drag_point.x = graph->anchor_point.x = x ;
† †   graph->drag_point.y = graph->anchor_point.y = y ;
† †   XDrawLine(XtDisplay(w), XtWindow(w), 
† †             graph->drag_gc,
† †             graph->anchor_point.x, graph->anchor_point.y,
† †             graph->drag_point.x, graph->drag_point.y);
† † }
}LBL="14.5" HELPID=""DrawingArea and Advanced Text EditingID="ch14219"Some applications may need text-editing capabilities beyond those provided by the Motif Text widget.  For example, the application may want to display text using different fonts or colors within the same editor.  Such an application might use a DrawingArea to implement a text editor based on compound strings.  LBL="14.5.1" HELPID=""Text OutputAn application that uses compound strings can use XmStringDraw or ID="ch14220"XmStringDrawImage to display the compound string text in a DrawingArea.  These functions use different Xlib routines to display compound string segments, depending on whether the segments are associated with font sets or font structs in the font list.  ID="ch14221"ID="ch14222"XmStringDraw uses XmbDrawString to display segments associated with font sets.  It uses ID="ch14223"XDrawString or XDrawString16 to display segments associated with font structs.  ID="ch14224"ID="ch14225"XmStringDrawImage uses XmbDrawImageString to display segments associated with font sets.  It uses ID="ch14226"XDrawImageString or XDrawImageString16 to display segments associated with font structs.  ID="ch14227"ID="ch14228"An application that does not use compound strings may call the Xlib text-drawing routines directly.  In addition to those mentioned previously, these include XDrawText† †for text associated with a font and ID="ch14229"XmbDrawText for text associated with a font set.  Wide-character versions exist for all the ID="ch14230"Xmb routines.  An application that draws text must determine where to place the text, what the width and height of the text will be, and how to move to the origin of the next text it will draw.  For compound strings, an application can use XmStringExtent, ID="ch14231"XmStringHeight, XmStringWidth, and XmStringBaseline to determine the extents of the text.  ID="ch14232"ID="ch14233"ID="ch14234"An application that does not use compound strings may call Xlib routines.  To determine the extents of a font struct, the application can examine the ascent, descent, max_bounds, and min_bounds members of the XFontStruct.  To determine the width and extents of text, the application can call ID="ch14235"XStringWidth, XTextExtents, and XTextExtents16.  ID="ch14236"ID="ch14237"ID="ch14238"To determine the extents of a font set, the application can call XExtentsOfFontSet.  To determine the width and extents of text, the application can call ID="ch14239"XmbTextEscapement, XmbTextExtents, and ID="ch14240"ID="ch14241"XmbTextPerCharExtents.  Wide-character versions exist for all the ID="ch14242"Xmb routines.  For more information about the Xlib text facilities, see Xlibname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'C Language X Interface.  LBL="14.5.2" HELPID=""Text InputTo obtain text input in a DrawingArea, an application should use the Xlib input method facilities.  These facilities allow the application to open an input method and an input context and to obtain input from the input method.  For more information, see ID="ch14243"IDREF="22857" TYPE="TITLE"Chapter 11, "Internationalization,"
 and Xlibname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'C Language X Interface.  LBL="15"ID="41117"Drag and DropID="ch151"Drag and drop allows the user to "pick up" objects on the screen, "drag" them around the display, and "drop" them at a new location, possibly in another application.  With drag and drop the user can Move text or other information between windows.  Cause application-specific actions to occur.  Obtain help information about drop sites.  This chapter first provides an overview of the drag and drop process and concepts from both the user's and the application developer's perspectives, then explains the actions of both initiator and receiver clients during the drag and at the drop, giving code samples.  LBL="15.1" HELPID=""User Overview of Drag and DropID="ch152"This section describes what the user does and sees during a drag and drop transaction.  LBL="15.1.1" HELPID=""Overview of User InteractionA drag and drop transaction consists of the following actions: ID="ch153"A user presses and holds BTransfer, usually mouse button 2, over a source object starting a drag transaction.  The application owning that object is the initiator of the drag.  The current pointer is replaced by a ID="ch154"drag iconname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'a picture representing the item being dragged.  ID="ch155"ID="ch156"The user moves the pointer.  From now until a drop occurs, the drag icon replaces the mouse pointer.  ID="ch157"ID="ch158"The user drops the object, usually by releasing the mouse button.  ID="ch159"Locations on the screen that can accept drops are drop sites, and the application owning that drop site is the destination or receiver.  ID="ch1510"ID="ch1511"The drag icon can be dropped anywhere on the screen.  However, only certain widgets have registered themselves as drop sites and are able to process the drop.  The receiver application usually performs some action on the information represented by the dragged icon.  The initiator application may also perform some action based on the results of a drag transaction.  A drop can be between applications or within the same application.  An application can be both source and destination of a drop, source only, destination only, or not participate in drag and drop at all.  The user can request help about a drop site, if available, by dragging to the drop site, and pressing KHelp (usually F1).  ID="ch1512"The user can cancel the drag at any time by pressing KCancel, usually ID="ch1513"Escape.  LBL="15.1.2" HELPID=""Overview of Drag-Over EffectsID="ch1514"The drag icon consists of three parts: ID="ch1515"ID="ch1516"The source icon is a picture representing the type of the source object, such as text.  ID="ch1517"ID="ch1518"The state icon can be used to show whether or not the object being dragged can be dropped at its current location on the screen.  ID="ch1519"ID="ch1520"The operation icon can be used to show what action should happen when the drop takes place.  ID="ch1521"ID="ch1522"In the following illustration, the running figure is the source icon, the arrow in the upper left is the state icon, and the rectangles with the corner folded over indicate a Copy is desired.  LBL="15-1" FILE="runner3.gif" POSITION="INLINE" SCALE="FALSE"LBL="15-1"Figure 15-1 A Drag IconThese parts can be combined (blended) and attached to each other in different ways.  The default blending and attachment are shown in the previous illustration.  ID="ch1523"ID="ch1524"ID="ch1525"ID="ch1526"Parts of the drag icon may change shape or color as it is being dragged through potential drop sites, providing visual feedback about possible drop sites to the user.  These changes are drag-over effects.  Applications can use the default drag icon effects, or provide more sophisticated or custom drag icons.  The application or user can customize these drag-over effects in resource files.  LBL="" HELPID=""Drag StatesID="ch1527"ID="ch1528"During a drag, there are three states that describe the relationship of a drag icon to what is under it at the time: Valid drop siteThe drag icon is over a drop site on which it can potentially be dropped (this is only a hint; when the drop is actually attempted, further processing may show that the drop cannot actually be done).  ID="ch1529"ID="ch1530"Invalid drop site The drag icon is over a drop site, but it cannot be dropped there.  ID="ch1531"ID="ch1532"No drop siteThe drag icon is not over a registered drop site.  ID="ch1533"ID="ch1534"The default state icon for all three states is the same: an arrow in the upper left corner of the drag icon.  Because the icon is the same for all three states, it appears not to change during the drag.  The application or the user can provide custom state icons or colors in a resource file.  ID="ch1535"ID="ch1536"LBL="" HELPID=""Drag OperationsID="ch1537"ID="ch1538"The user specifies what action is to take place when the drop occurs by pressing certain keys when the drag starts or while the drag is in process: Shift onlyForce a move from the initiator to the receiver client (Move) ID="ch1539"ID="ch1540"Ctrl onlyForce a copy from the initiator to the receiver client (Copy) ID="ch1541"ID="ch1542"Shift and CtrlForce a link between the initiator and receiver clients (Link) ID="ch1543"ID="ch1544"The operation chosen by the user must be valid for both the drag source and the drop site, or the drop site will be considered invalid.  If the user does not specify an operation, one is chosen by the toolkit.  It choses an operation that is valid for both the drag source and drop site.  Move is the first choice, Copy is the second, and Link is the third.  If the system cannot find a valid operation, the drop site is considered invalid.  The operation icon reflects the operation chosen by the user or by the system.  If the operation is changed by the user during the drag, the operation icon changes also.  The operation icon may change as the drag icon moves to different drop sites if the drop sites accept different operations.  LBL="15.1.3" HELPID=""Overview of Drag-Under EffectsID="ch1545"A widget registered as a drop site may change visually as a drag icon passes over it.  These visual cues are drag-under effects.  The sensitive area of the widget is the part that responds to drag and drop.  By default it is the whole widget, but applications can specify that only parts of the widget respond to drag and drop.  ID="ch1546"Various highlighting styles are possible: ID="ch1547"A border around the sensitive area of the drop site widget. This is the default value.  The sensitive area of the drop site widget looks pushed out.  The sensitive area of the drop site widget looks pushed in.  A special pixmap is displayed within the sensitive area of the drop site widget, overwriting what is normally there.  No drag-under effects are used for the drop site widget.  Applications can use the default drag-under visual effects, or create more sophisticated or custom effects, such as special animation or sound effects.  LBL="15.1.4" HELPID=""Overview of Drop EffectsID="ch1548"ID="ch1549"Visual effects also take place during the drop: The drag icon appears to sit over the drop site while the processing for the drop is finishing, but the standard cursor is restored and can be used normally.  The source icon appears to melt into the drop site if the drop is successful.  The source icon appears to snap back to the source if the drop is unsuccessful.  A dialog window containing information about a drop site should appear if the user has requested help and the receiver client provides help, otherwise nothing happens.  The source icon appears to snap back to the source and the previous X cursor returns if Cancel is requested.  All drag-under and drag-over effects are removed.  These drop effects cannot be changed by the application or the user.  LBL="15.2" HELPID=""Technical Overview of Drag and DropThis section explains some drag and drop concepts, and provides a general view of the initiator and receiver duties during the drag and at the drop.  The Motif toolkit for drag and drop consists of Widgets and widget classes that provide resources containing details about the source and destination of the drag Functions that applications use to manage the widgets and widget classes Protocols that specify how interactions between source and destination clients are to take place Functions that manage messages, call callbacks, decide on the valid operations for a potential drop, and keep the drop site status updated If the initiator and receiver are in the same client, they share the same toolkit.  If the initiator and receiver are different clients, each client has a version of the toolkit.  An application can allow any widget to be a drag source or initiator by specifying a translation for BTransfer Press in that widget.  The corresponding action creates a DragContext which starts the drag and drop transaction.  The toolkit on the initiator side in charge during the drag and manages all drag messages and callbacks.  ID="ch1550"ID="ch1551"An application can register any widget as a drop site.    The drop site widget may change visually as a drag icon moves in and out of it, providing drag-under visual clues to the status of the drag.  The application controlling the current drop site is known as the receiver.  The toolkit on the receiver side is in charge of the drop operation, and manages all drop messages and callbacks.  Each drag source and drop site specifies the types of data it is prepared to handle and what operations it can perform on that data.  The state of the drag indicates whether the drag icon is over a valid drop site, an invalid drop site, or no drop site.  For a drop site to be valid, there must be at least one target type and one operation in common between the drag source and drop site.  LBL="15.2.1" HELPID=""ID="30895"Complexity of Drag and Drop ProgramsApplications can use drag and drop functionality on any of several levels: Text, List, Label, and Button widgets are already defined as drag sources.  Text and TextField widgets are registered as drop sites.  Therefore, at the simplest, an application can compile with the Motif libraries, and have those widgets participate in drag and drop.  For example, text could be selected from one application and moved into a text area in another application.  ID="ch1552"ID="ch1553"ID="ch1554"ID="ch1555"ID="ch1556"On a slightly more advanced level, applications can let the toolkit do most of the work, but provide some customization.  For example, an application could register a pushbutton as a drop site, but still use default visual effects.  In this case, the application would register a widget as a DropSite and provide code to handle drop and transfer duties.  The example programs ID="ch1557"DNDlabel.c in IDREF="42149" TYPE="TITLE""A Simple Drag Receiver"
  and DNDscroll.c in IDREF="17919" TYPE="TITLE""A Simple Drag Source"
 are at this level.  A complex application can take much of the control of the drag and drop itself.  It can provide custom visuals for both drag icon and drop site.  It can manage overlapping drop sites and can include complex transfers of information.  The example program DNDdemo in IDREF="61196" TYPE="TITLE"Appendix B, "Drag and Drop Example Program,"
 contains extensive customization.  LBL="" HELPID=""ID="42149"A Simple Drag ReceiverID="ch1558"ID="ch1559"This sample program displays a Label widget and registers it as a drop site.  It accepts compound text, and supports only the Copy operation (that is, it does not support Move or Link).  ID="ch1560"When a valid drop is made on the Label widget, its HandleDrop routine changes the Label widget's label to compound text passed from the initiator.  ID="ch1561"The appropriate include files, the DropTransferCallback routine, the HandleDrop routine, and a few lines in the main routine to register the drop site are all that is needed to customize a Label widget to accept a drop and change its label in response.  The details of this additional code are covered in later sections of this chapter.  ID="ch1562"LBL="15-2" FILE="label2.gif" POSITION="INLINE" SCALE="FALSE"LBL="15-2"Figure 15-2 A Label Widget Receiver Before and After Drag/*      file: DNDlabel.c     */
#include <signal.h>
#include <stdio.h>
#include <X11/Xlib.h>
#include <Xm/Xm.h>
#include <Xm/BulletinB.h>
#include <Xm/AtomMgr.h>
#include <Xm/Label.h>
#include <Xm/DragDrop.h>
#include <X11/Xatom.h>
#define MAX_ARGS        10
/* global variables */
Widget   myDC;
Atom     COMPOUND_TEXT;
/* This routine transfers information from the initiator */
static void TransferProc(w, closure, seltype, type, value,
† †                          length, format) 
Widget           w;
XtPointer        closure;
Atom             *seltype;
Atom             *type;
XtPointer        value;
unsigned long    *length;
int              format;
{
† †  int         n;
† †  Arg         args[MAX_ARGS];
† †  /* information from the drag initiator is passed in
† †   * compound compound text format.  Convert it to compound
† †   * string and replace the  Label label. */
† †  if (*type = COMPOUND_TEXT) {
† †     n = 0;
† †     XtSetArg(args[n], XmNlabelString,
† †                XmCvtCTToXmString(value)); 
† †     n++;
† †     XtSetValues(closure, args, n);
† †     } 
}
/* This routine is performed when a drop is made.  It decides
what information it wants and uses TransferProc to transfer
the data from the initiator */
static void HandleDrop(w, client_data, call_data)
Widget          w;
XtPointer       client_data, call_data;
{
† †  XmDropProcCallback      DropData;
† †  XmDropTransferEntryRec  transferEntries[2];
† †  XmDropTransferEntry     transferList;
† †  Arg                     args[MAX_ARGS];
† †  int                     n;
† †  DropData = (XmDropProcCallback)call_data;
† †  /* set the transfer resources */
† †  n = 0; 
† †  /* if the action is not Drop or the operation is not Copy,
† †   * cancel the drop */
† †  if ((DropData->dropAction != XmDROP) || 
† †      (DropData->operation != XmDROP_COPY)) 
† †     XtSetArg(args[n], XmNtransferStatus, XmTRANSFER_FAILURE);
† †       n++;
† †  else {
† †     /* the drop can continue.  Establish the transfer list
† †      * and start the transfer */
† †     transferEntries[0].target = COMPOUND_TEXT;
† †     transferEntries[0].client_data = (XtPointer)w;
† †     transferList = transferEntries;
† †     XtSetArg(args[n], XmNdropTransfers, transferList); n++;
† †     XtSetArg(args[n], XmNnumDropTransfers, 1); n++;
† †     XtSetArg(args[n], XmNtransferProc, TransferProc); n++;
† †     }
† †  /* start the transfer or cancel */ 
† †  XmDropTransferStart(DropData->dragContext, args, n);
}
/* This program creates a Label widget, which is 
† †* registered as a drop site.  The label changes when compound 
† †* text is dropped on it.  */
void main (argc, argv)
unsigned int argc;
char **argv;
{
† †  Arg                     args[MAX_ARGS];
† †  int                     n;
† †  Widget                  topLevel, BulletinB, Label;
† †  XtAppContext            app_context;
† †  Atom                    importList[1];
† †  /* make supporting widget structure for the Label widget */
† †  topLevel = XtAppInitialize(&app_context, "XMTest", NULL, 0, 
† †                             &argc, argv, NULL, NULL, 0);
† †  n = 0;
† †  BulletinB = XmCreateBulletinBoard(topLevel, "BulletinB", 
† †                                    args, n);
† †  XtManageChild(BulletinB);
† †  COMPOUND_TEXT = XmInternAtom(XtDisplay(topLevel), 
† †                               "COMPOUND_TEXT", False);
† †  /* create a Label widget */
† †  n = 0;
† †  Label = XmCreateLabel(BulletinB, "title", args, n);
† †  XtManageChild(Label);
† †  /* register the label as a drop site */
† †  importList[0] = COMPOUND_TEXT;
† †  n = 0;
† †  XtSetArg(args[n], XmNimportTargets, importList); n++;
† †  XtSetArg(args[n], XmNnumImportTargets, 1); n++;
† †  XtSetArg(args[n], XmNdropSiteOperations, XmDROP_COPY); n++;
† †  XtSetArg(args[n], XmNdropProc, HandleDrop); n++;
† †  XmDropSiteRegister(Label, args, n);
† †  XtRealizeWidget(topLevel);
† †  XtAppMainLoop(app_context);
}LBL="" HELPID=""ID="17919"A Simple Drag SourceThis program creates a ScrollBar widget which is to be used as a drag source.  The normal action for Button 2 Press has been overridden to cause it to call the ID="ch1563"StartDrag routine, which causes the drag to begin.  The program allows only the Copy operation, and will reply to requests for compound text.  When a drag is started on the ScrollBar, the default drag icons are used.  ID="ch1564"When a transfer request is received by the DragConvertProc routine, it returns the value of the scrollbar slider converted into compound text.  The code necessary to make a normal ScrollBar widget into a source for drag and drop is the appropriate include files, the ID="ch1565"DragConvertProc routine, the StartDrag routine, and translation and action commands.  The details of this additional code are covered in later sections of this chapter.  LBL="15-3" FILE="scroll.gif" POSITION="INLINE" SCALE="FALSE"LBL="15-3"Figure 15-3 A ScrollBar Widget as Drag Source/*      file: DNDscroll.c        */
#include <signal.h>
#include <stdio.h>
#include <X11/Xlib.h>
#include <Xm/Xm.h>
#include <Xm/BulletinB.h>
#include <Xm/ScrollBar.h>
#include <Xm/AtomMgr.h>
#include <Xm/DragDrop.h>
#include <X11/Xatom.h>
#define MAX_ARGS        10
/* global variables */
Widget                  scrollbar;
Atom                    COMPOUND_TEXT;
/* this routine returns the value of the scrollbar slider, 
† †* converted into compound text. */
static
Boolean DragConvertProc(w, selection, target, typeRtn, 
† †                       valueRtn, lengthRtn, formatRtn, 
† †                       max_lengthRtn, client_data, 
† †                       request_id)
Widget              w;
Atom                *selection;
Atom                *target;
Atom                *typeRtn;
XtPointer           *valueRtn;
unsigned long       *lengthRtn;
int                 *formatRtn;
unsigned long       *max_lengthRtn;
XtPointer           client_data;
XtRequestId         *request_id;
{
† †  Widget      dc;
† †  XmString    cstring;
† †  static char tmpstring[100];
† †  int         *value;
† †  int         n;
† †  Arg         args[MAX_ARGS];
† †  char          *ctext;
† †  char        *passtext;
† †  /* this routine processes only compound text */
† †  if (*target != COMPOUND_TEXT)
† †     return(False);
† †  /* get the value of the scrollbar slider */
† †  n = 0;
† †  XtSetArg(args[n], XmNvalue, &value); n++;
† †  XtGetValues(scrollbar, args, n);
† †  /* convert the slider value to compound text */
† †  sprintf(tmpstring, "%d", value);
† †  cstring = XmStringCreateLocalized(tmpstring);
† †  ctext = XmCvtXmStringToCT(cstring);
† †  passtext = XtMalloc(strlen(ctext)+1);
† †  memcpy(passtext, ctext, strlen(ctext)+1);
† †  /* format the value for transfer.  convert the value from
† †  * compound string to compound text for the transfer */
† †  *typeRtn = COMPOUND_TEXT;
† †  *valueRtn = (XtPointer) passtext;
† †  *lengthRtn = strlen(passtext);
† †  *formatRtn = 8;
† †  return(True);
}
/* This routine is performed by the initiator when a drag
† †* starts  (in this case, when mouse button 2 was pressed).
† †* It starts  the drag processing, and establishes a drag
† †* context. */
static void StartDrag(w, event)
Widget  w;
XEvent  *event;
{
† †  Arg             args[MAX_ARGS];
† †  Cardinal        n;
† †  Atom            exportList[1];
† †  /* establish the list of valid target types */
† †  exportList[0] = COMPOUND_TEXT;
† †  n = 0; 
† †  XtSetArg(args[n], XmNexportTargets, exportList); n++;
† †  XtSetArg(args[n], XmNnumExportTargets, 1); n++;
† †  XtSetArg(args[n], XmNdragOperations, XmDROP_COPY); n++;
† †  XtSetArg(args[n], XmNconvertProc, DragConvertProc); n++;
† †  XmDragStart(w, event, args, n);
}
/* translations and actions.  Pressing mouse button 2
† †* overrides  the normal scrollbar action and calls StartDrag
† †* to start a drag transaction */
static char dragTranslations[] = 
† †    "#override <Btn2Down>: StartDrag()";
static XtActionsRec dragActions[] = 
† †    { {"StartDrag", (XtActionProc)StartDrag} };
/* This routine creates a window with a scrollbar in it. */
void main (argc, argv)
unsigned int argc;
char **argv;
{
† †  Arg                     args[MAX_ARGS];
† †  int                     n;
† †  Widget                  topLevel, BulletinB;
† †  XtAppContext            app_context;
† †  Atom                    importList[1];
† †  XtTranslations          parsed_xlations;
† †  /* create widget structure for scrollbar widget */
† †  topLevel = XtAppInitialize(&app_context, "DNDscroll", NULL,
† †                             0, &argc, argv, NULL, NULL, 0);
† †  COMPOUND_TEXT = XmInternAtom(XtDisplay(topLevel), 
† †                               "COMPOUND_TEXT", False);
† †  n = 0;
† †  BulletinB = XmCreateBulletinBoard(topLevel, "BBoard",
† †                                      args, n);
† †  XtManageChild(BulletinB);
† †  /* override button two press to start a drag */
† †  parsed_xlations = XtParseTranslationTable(dragTranslations); 
† †  XtAppAddActions(app_context, dragActions,
† †                    XtNumber(dragActions));
† †  /* create a scroll bar widget */ 
† †  n = 0;
† †  XtSetArg(args[n], XmNtranslations, parsed_xlations); n++;
† †  XtSetArg(args[n], XmNorientation, XmHORIZONTAL); n++;
† †  XtSetArg(args[n], XmNwidth, 150); n++;
† †  scrollbar = XmCreateScrollBar(BulletinB, "testscroll",
† †                                  args, n);   
† †  XtManageChild(scrollbar);
† †  XtRealizeWidget(topLevel);
† †  XtAppMainLoop(app_context);
}LBL="15.2.2" HELPID=""Drag Sources and Drop SitesText, List, Label, and Button widgets are automatically drag sources.  Applications need do nothing further to use them.  An application can allow any widget to be a drag source by establishing a callback when ID="ch1566"ID="ch1567"ID="ch1568"ID="ch1569"BTransfer is pressed within that widget.  The application that owns the widget in which the drop was started is the initiator.  ID="ch1570"A drag icon, which is a pictorial representation of the data being dragged, replaces the normal cursor while the drag is in effect.  The icon may change as it moves around the screen.  The actual data is not being dragged, only a representation of it.  The data is transferred to a new location only when the drop is made, through the drop transfer protocol.  Any widget can be registered as a drop site.  Text and TextField widgets are automatically registered as drop sites.  If an application wants to use these as drop sites, it does not need to register them separately.  ID="ch1571"ID="ch1572"The DropSite registry contains information about widgets that have been registered as drop sites.  Although the drag icon can be dropped anywhere on the screen, only widgets that have been registered as drop sites can accept information from the initiator.  The receiver is the application controlling the current drop site.  ID="ch1573"The "sensitive area" is the part of the widget that responds to drag and drop.  By default, the sensitive area is the whole widget.  However, the application can specify that only part of the widget is sensitive.  Widgets that are drop sites can be stacked on each other, with one widget partially or completely within the boundary of another.   The sensitive areas of lower drop sites are clipped if they are covered by a higher widget.  The stacking order of the widgets with drop sites can be changed by the application.  LBL="15.2.3" HELPID=""ProtocolsID="ch1574"ID="ch1575"The protocol describes how the initiator and receiver clients interact through the toolkit with each other.  LBL="" HELPID=""Drag ProtocolsThere are two types of drag protocol: ID="ch1576"ID="ch1577"PreregisterDoes not require messaging ID="ch1578"ID="ch1579"DynamicRequires messaging ID="ch1580"ID="ch1581"Applications can support either, both, or neither.  If possible, clients should support both to allow the most flexibility for users.  The Motif toolkit automatically supports both unless a user or client sets resources to force the use of one or the other.  The user can specify which drag protocol to use when the client is the initiator or receiver.  The application can specify drag protocol in an application-class defaults file.  If neither the application nor the user specifies a protocol, the preregister drag protocol is used.  The toolkit uses the requested protocols and the protocols allowed by the initiator and receiver clients to arrive at the protocol actually being used.  Therefore, the protocol can change as the drag icon moves from window to window, depending on which protocols each window supports.  If the initiator and receiver cannot agree on a protocol, no drag-over or drag-under visual effects are shown.  Even if no drag-over or drag-under visual effects are shown, a drop can still occur with the drop protocol, unless a client has specified that that window does not participate in drag and drop.  LBL="" HELPID=""Drop ProtocolID="ch1582"ID="ch1583"The drop protocol is based on the Xt Selection transfer protocol.  The transfer between either client and the toolkit can be incremental or nonincremental, regardless of how the other client is transferring.  Each client has a procedure to process transfers: XmNconvertProc for the initiator, and ID="ch1584"XmNtransferProc for the receiver.  Incremental transfer is indicated by a resource value.  ID="ch1585"The receiver creates a list of information and target types desired from the initiator, along with an XmNtransferProc to handle any processing needed during the transfer.  It then calls ID="ch1586"XmDropTransferStart to start the transfer process.  Even if there is no transfer, the receiver should call this routine, so that the status can be updated correctly for the initiator.  ID="ch1587"ID="ch1588"ID="ch1589"For each item in the transfer list, the initiator's XmNconvertProc† †is called.  This procedure reads and processes the request and returns the information.  ID="ch1590"When the transfer has finished, the toolkit on the receiver side updates the XmNtransferStatus DropTransfer resource to indicate if the transfer was successful.  The receiver's ID="ch1591"ID="ch1592"XmNtransferProc† †routine can also update this resource.  ID="ch1593"ID="ch1594"ID="ch1595"LBL="15.2.4" HELPID=""Drag and Drop Widget ClassesID="ch1596"ID="ch1597"Motif provides a number of Xt objects and widgets to encapsulate the underlying protocol; however, these are not mapped onto the screen: XmDisplayAn object that contains display-specific information, such as the initiator and receiver protocol styles.  ID="ch1598"XmScreenAn object that describes screen-specific information, such as font and default drag-over icons.  ID="ch1599"XmDragIconA widget that describes the pixmap, mask, and attachment of an icon.  The source icon, state icon, operation icon, and the resulting blended drag icon are all Drag Icons.  ID="ch15100"ID="ch15101"XmDragContext A widget that describes the resources specified by each ID="ch15102"ID="ch15103"drag initiator, such as target type, custom icons, custom colors, blending model, permitted operations, and callback routines for various situations encountered during the drag and drop transaction.  XmDropSiteA drop site database that maintains a registry of the resources unique to each drop site, such as animation for drag-under effects, valid target types and operations, and callback routines for situations encountered during a drag and drop transaction.  It is not an Xt object, although it acts like one with respect to resource fetching.  ID="ch15104"ID="ch15105"XmDropTransferA widget that describes the information desired from the initiator client and the procedure used to process the results.  ID="ch15106"ID="ch15107"LBL="15.2.5" HELPID=""Drag and Drop FunctionsMotif provides the following functions to support drag and drop processing: XmCreateDragIcon Creates any of the parts of a drag icon (status icon, operation icon, or source icon) from a cursor or pixmap.  This allows custom icons for all or part of the drag icon, rather than the default icons.  ID="ch15108"ID="ch15109"XmDragCancelCancels a drag that is in progress.  This function is called when the user presses ID="ch15110"KCancel.  ID="ch15111"XmDragStartThis function is called in the routine that is performed when the user starts a drag.  Resources describing the initiator are established.  This function creates a DragContext object, which is referenced by other functions whenever information about the drag initiator is needed.  ID="ch15112"ID="ch15113"XmDropSiteConfigureStackingOrder Sets the order of overlapping drop sites.  The default order is with the first-registered drop site on the bottom and the last-declared drop site on top.  ID="ch15114"XmDropSiteEndUpdate Causes the ID="ch15115"ID="ch15116"XmDropSiteUpdate requests made after ID="ch15117"XmDropSiteStartUpdate to take place.  ID="ch15118"XmDropSiteQueryStackingOrder Provides information about the stacking order of overlapping drop sites.  The order can be changed with ID="ch15119"XmDropSiteConfigureStackingOrder.  ID="ch15120"XmDropSiteRegister Registers a drop site.  Resources describing the drop site are defined.  ID="ch15121"XmDropSiteRetrieve Retrieves the values of drop site resources.  ID="ch15122"XmDropSiteStartUpdate Signals the toolkit to wait until ID="ch15123"XmDropSiteEndUpdate is called to process drop site changes requested by ID="ch15124"XmDropSiteUpdate.  This provides a more efficient way to update several drop sites than changing them one at a time.  ID="ch15125"ID="ch15126"XmDropSiteUpdate Updates drop site resources for a single drop site.  If a series of ID="ch15127"XmDropSiteUpdate requests are surrounded by ID="ch15128"XmDropSiteStartUpdate and XmDropSiteEndUpdate, then the changes will be made all at once after the end update request.  ID="ch15129"ID="ch15130"ID="ch15131"XmDropSiteUnregister Removes a drop site.  After a drop site has been unregistered, it is unavailable as a destination for a drag.  ID="ch15132"XmDropTransferAdd Adds additional transfer requests once a transfer has started.   ID="ch15133"XmDropTransferStart Specifies what information should be requested from the drag initiator, and starts the process to get the information.  ID="ch15134"XmGetDragContext Returns the DragContext ID associated with a particular time stamp.  ID="ch15135"ID="ch15136"XmGetXmDisplay Returns the ID for the specified display.  ID="ch15137"XmGetXmScreen Returns the ID for a specified screen.  Some resources, such as the drag icons, are screen-specific.  ID="ch15138"XmTargetsAreCompatible Checks if there are any matching targets between the initiator and destination to help determine the correct drag state.  ID="ch15139"LBL="15.2.6" HELPID=""TargetsID="ch15140"Each drag source and drop site specifies what kinds of data types it can process, called targets.  These targets are atoms, such as XA_STRING.  ID="ch15141"The DragContext resources XmNexportTargets and ID="ch15142"ID="ch15143"XmNnumExportTargets† †provide a list and number of the data types provided by the drag source.  These are export targets.  ID="ch15144"ID="ch15145"ID="ch15146"ID="ch15147"ID="ch15148"ID="ch15149"The DropSite resources XmNimportTargets and ID="ch15150"ID="ch15151"XmNnumImportTargets provide a list and number of the data types accepted by the drop site.  These are known as import targets.  ID="ch15152"ID="ch15153"ID="ch15154"ID="ch15155"ID="ch15156"Any number of targets may be listed for each source and site.  A drop site is considered valid for a particular drag if at least one of its targets matches any of the source's targets and if the source and drop site operations are compatible.  An application can define anything it wants as a target.  Be aware, however, that other applications might not recognize that target.  LBL="15.2.7" HELPID=""OperationsID="ch15157"ID="ch15158"There are three ways that the initiator and receiver can interact with each other: Data can be moved from the initiator to the receiver (Move).  Data can be copied from the initiator to the receiver (Copy).  Data can be linked from the receiver to the initiator (Link).  When a drag is started, the initiator provides a list of valid operations in the DragContext XmNdragOperations resource.  When a drop site is registered, the receiver provides a list of operations it supports in the DropSite ID="ch15159"ID="ch15160"XmNdropSiteOperations resource.  These lists are the values ID="ch15161"ID="ch15162"XmDROP_MOVE, XmDROP_COPY, or XmDROP_LINK, connected by the bitwise OR operator (|).  For example, the following value means that Move and Copy are valid operations, but Link is not: ID="ch15163"ID="ch15164"ID="ch15165"XmDROP_MOVE | XmDROP_COPYThe value XmDROP_NOOP indicates that there are no operations possible for a drop at the current site.  ID="ch15166"Callback structures for both DragContext and DropSite have ID="ch15167"ID="ch15168"operation and operations fields.  The operations field lists all valid operations if a drop were to occur at this point.  The operation field shows the operations that would happen if a drop occurred at this point.  As the drag icon moves over different potential drop sites, the values in its callback structures change in response to what operations the drop sites allow.  If there are no common operations between a drag source and a drop site, the operation and operations fields are set to XmDROP_NOOP, and the ID="ch15169"dropSiteStatus field is set to XmDROP_SITE_INVALID.  ID="ch15170"The user can specify an operation using key combinations discussed earlier in this chapter.  The user can also change the operation at any time until the drop starts.  The initiator and the receiver need to be able to handle all the operations their application supports.  If the operation is Move, the receiver first gets a copy of the data, then tells the initiator that it can delete the data.  If the operation is Copy, both applications have the data, making two copies of it.  If the operation is Link, there is only one copy of the data, and the receiver establishes a link to that copy.  LBL="" HELPID=""Drop Site StatusThe drag and drop callbacks for both receiver and initiator contain a dropSiteStatus field.  This field is initialized and maintained by the receiver through the toolkit, although the receiver's drag and drop procedures can update it if they wish.  This field is used by the toolkit to determine what drag-over and drag-under visual effects to use.  The dropSiteStatus field indicates the relationship of the drag source to the drop site over which the drag icon is located: XmDROP_SITE_VALID A drop can take place.  There is at least one matching target and operation between the drag source and the drop site.  ID="ch15171"XmDROP_SITE_INVALID A drop cannot take place.  Either there were no matching targets, no matching operations, or the receiver's ID="ch15172"XmNdragProc or ID="ch15173"XmNdropProc discovered some other problem that would make a drop impossible.  ID="ch15174"XmNO_DROP_SITE The drag icon is not over a drop site.  ID="ch15175"If the toolkit on the receiver's side has set either the operation or the operations field to XmDROP_NOOP, it also sets the dropSiteStatus field to ID="ch15176"XmDROP_SITE_INVALID.  ID="ch15177"LBL="15.2.8" HELPID=""Overview of Programmer ResponsibilitiesThis section provides an overview of the actions of the initiator client and the receiver client while a drag and drop transaction is in progress.  The actions are covered in more detail later in the chapter.  Before a drag starts The user or client uses the protocol resources to indicate the type of protocol and visual effects to be used for the initiator and receiver if possible.  The initiator client creates any special icons it wants to use for drag-over effects, using XmCreateDragIcon.  ID="ch15178"ID="ch15179"The initiator establishes translation or event handlers to react to BTransfer Press.  ID="ch15180"ID="ch15181"The receiver client registers widgets as potential drop sites using XmDropSiteRegister, providing information about ID="ch15182"The shape of the area of the widget sensitive to drag and drop, if it is not the whole widget Valid targets ID="ch15183"Optional drag-under visual effects ID="ch15184"An optional XmNdragProc to receive messages during the drag ID="ch15185"An XmNdropProc to be performed at the drop ID="ch15186"The receiver can check and change the stacking order of overlapping drop sites with XmDropSiteQueryStackingOrder and ID="ch15187"XmDropSiteConfigureStackingOrder.  ID="ch15188"ID="ch15189"ID="ch15190"ID="ch15191"The receiver can update drop site information using the functions XmDropSiteUpdate, XmDropSiteStartUpdate, and ID="ch15192"ID="ch15193"XmDropSiteEndUpdate.  ID="ch15194"The receiver can unregister a drop site with XmDropSiteUnregister.  ID="ch15195"When the drag starts (typically a BTransfer Press event) ID="ch15196"The toolkit on the initiator's side is in charge during the drag until a drop is made.  The initiator client ID="ch15197"ID="ch15198"Receives an indication that the user has started a drag Creates a DragContext using XmDragStart, specifying: ID="ch15199"ID="ch15200"-  Valid targets -   Optional callbacks to be performed during the drag -   An XmNconvertProc to process transfer requests from the receiverID="ch15201"-   Optional custom drag-over visuals -   Optional drop callbacks to be performed when a drop occurs ID="ch15202"ID="ch15203"ID="ch15204"ID="ch15205"ID="ch15206"The receiver client does nothing.  During a drag The user can cancel the drag or change operation.  The receiver is not involved unless the pointer is within one of its registered drop sites.  The toolkit on the receiver's side initializes the dropSiteStatus, operation, and operations fields in the callback structure .  The receiver's XmNdragProc routine (if one was registered) is notified of drag source actions within the drop site: drop site enter, drop site leave, drag icon motion, or change of operation.  This ID="ch15207"XmNdragProc routine is called only if the drag protocol is dynamic.  It handles any special processing and drag-under visuals.  If the protocol is preregister, drag-under visuals are handled by the toolkit on the initiator side.  By default, the initiator needs to do nothing during a drag.  If the initiator client has registered the appropriate callback routines, it is notified after the receiver's XmNdragProc† †when the drag is entering or leaving a top-level window, entering or leaving a drop site, is in motion, or the user has changed the desired operation.  The values of ID="ch15208"dropSiteStatus, operation, and operations in the drag callbacks are initialized by the toolkit on the receiver side, by the XmNdragProc, or by the toolkit on the initiator side if the pointer is not over a registered drop site.  ID="ch15209"The initiator can activate custom drag-over effects or other special processing.  ID="ch15210"The initiator can cancel the drag in progress by using XmDragCancel.  ID="ch15211"ID="ch15212"ID="ch15213"Either client can check the compatibility of export and import targets with XmTargetsAreCompatible.  ID="ch15214"Either client can obtain information about the drop site that the drag icon is over (if any) with XmDropSiteRetrieve.  ID="ch15215"When the drop occurs The toolkit on the receiver side is in charge during the drop and transfer.  The receiver's XmNdropProc routine makes a final check that a drop is possible and updates the ID="ch15216"dropSiteStatus, operations, and operation fields in the XmNdropProc callback structure for the initiator to read in its XmNdropStartCallback† †callback structure.  ID="ch15217"If the drop was the result of the user requesting help, the receiver's XmNdropProc displays information in a dialog and waits for a response from the user before either continuing or cancelling the drop.  ID="ch15218"If the drop is valid, the receiver requests transfer information from the initiator.  Only the receiver can cancel a drop.  The initiator's XmNdropStartCallback callback routine is called after the receiver's ID="ch15219"XmNdropProc has finished.  The values of the ID="ch15220"dropSiteStatus, operation, and operations fields in the callback structure were set by the toolkit on the receiver side or XmNdropProc.  When data is transferred between initiator and receiver ID="ch15221"The receiver's XmNdropProc establishes a list of data and target formats it wants to receive, and calls the ID="ch15222"XmDropTransferStart function.  The list can be updated with ID="ch15223"XmDropTransferAdd during the transfer.  ID="ch15224"The receiver registers an XmNtransferProc to process each transfer from the initiator.  ID="ch15225"The receiver can cancel the drop while the transfer is in progress.  If there is no information to be transferred, or if the drop is cancelled, the receiver must still call XmDropTransferStart.  The initiator is unable to proceed until it is notified that a transfer has ended.  Only the receiver can cancel a drop ID="ch15226"The initiator's XmNconvertProc routine is executed in response to a request from the ID="ch15227"XmDropTransferStart function called by the receiver.  It returns the information formatted according to the requested target to the receiver's ID="ch15228"XmNtransferProc.  ID="ch15229"After the drop has finished The initiator's XmNdropFinishCallback is called when the transfer is complete.  The initiator's ID="ch15230"XmNdragDropFinishCallback is called after the whole drag and drop transaction has finished.  ID="ch15231"ID="ch15232"ID="ch15233"LBL="15.3" HELPID=""Drag and Drop ProtocolsID="ch15234"ID="ch15235"The protocols refer to how the initiator and receiver clients use the toolkit to communicate with each other.  There are two drag protocol styles that are available.  The drop protocol is based on the Xt selection protocol.  LBL="15.3.1" HELPID=""Drag ProtocolsID="ch15236"ID="ch15237"The toolkit on the initiator side is in charge during the drag.  The protocol in effect determines how it will find the information about drop sites that it needs to manage visuals, and how extensively the initiator and receiver clients are involved during the drag.  There are two kinds of drag protocol styles: PreregisterStores drop site information in a database when the drop site is registered.  The receiver is not involved in the drag until a drop occurs.  All drag-over and drag-under visual effects are managed by the toolkit on the initiator side.  DynamicUses messages from the toolkit to the receiver to find out drop site information.  The toolkit on the receiver side can reply to the messages, or the application can take action based on these messages.  The receiver manages the drag-under effects.  ID="ch15238"ID="ch15239"ID="ch15240"ID="ch15241"The code for the initiator is the same regardless of the protocol.  The code for the receiver applications is the same except that in the dynamic mode, the receiver's XmNdragProc is called.  ID="ch15242"The drag protocol in use can change during the course of a drag.  When the drag icon enters or leaves a top-level window, the source and potential drop receiver negotiate a mutually acceptable drag protocol, as described in IDREF="19638" TYPE="TITLE"Section 15.3.2, "Choosing the Protocol and Visual Style."LBL="" HELPID=""The Preregister Drag ProtocolID="ch15243"ID="ch15244"When a receiver supports the preregister protocol, the toolkit on the receiver side stores drop site information in a database.  The toolkit on the initiator side manages all drag-under effects based on the information in the drop site database.  By setting some DropSite resources appropriately, the receiver can have the toolkit use different highlighting or pixmaps, but the receiver does not participate directly in the drag-under effects.  ID="ch15245"ID="ch15246"With the preregister protocol The toolkit uses pixmap source icons if the client provides them.  If not, it uses bitmap source icons if the client provides them.  If the client provides neither, the toolkit uses XmScreen icons.  The ID="ch15247"XmScreen icons can be either the default icons or ones provided by the client or user.  The server is grabbed.  The only customization a receiver can perform is providing custom values for the DropSite visual resources.  ID="ch15248"The drag icon can be any size supported by the system on which the application is running.  LBL="" HELPID=""The Dynamic Drag ProtocolID="ch15249"ID="ch15250"With the dynamic drag protocol, the initiator and receiver communicate with messages through the toolkit.  As the drag icon moves within the receiver's window, messages are sent from the toolkit on the initiator side to the toolkit on the receiver side.  Based on these messages, the receiver determines whether the drag icon is entering, within, or leaving a drop site.  Although the toolkit on the receiver side initializes state and operation information, the receiver can check and update this information further if it registers a XmNdragProc for the drop site.  The initiator receives the updated message in one of its drag-related callbacks (described later in this chapter), and can take action accordingly.  ID="ch15251"The dynamic drag protocol allows the receiver to provide more sophisticated visual effects using the XmNdragProc than the toolkit can provide alone.  ID="ch15252"With the dynamic drag procotol The receiver can provide custom drag processing and drag-under visual effects.  The drag icon must fit in the largest cursor size supported by the system running the application.  If it is too large, it will be truncated to fit.  LBL="15.3.2" HELPID=""ID="19638"Choosing the Protocol and Visual StyleThe user can specify which drag protocol to use or the application can specify the drag protocol in resource file.  The preregister drag protocol can be  used with a minimum of additional coding in an application, because the toolkit manages the drag-over visual effects using the default drag icons specified in the XmScreen† †object.  Or the application can override the default ID="ch15253"XmScreen icons with custom icons, but still allow the toolkit to manage the effects.  The dynamic drag protocol requires more work for the application program, but allows a receiver application to provide visual effects beyond the capabilities of the toolkit.  The drag protocol in use has an effect on the system performance as described later in this section.  LBL="" HELPID=""Specifying Drag ProtocolsTwo Display resources specify which protocol the toolkit should try to use when a client is an initiator or receiver.  These resources can be set by the client in a resource file or by the user.  XmNdragInitiatorProtocolStyle† †ID="ch15254"XmNdragReceiverProtocolStyle† †ID="ch15255"ID="ch15256"ID="ch15257"These resources can take the following values (the letter in brackets following the value is used in IDREF="27145" TYPE="TABLE"Table 15-1
): XmDRAG_NONE [N] Does not participate in drag and drop.  There are no drag-under effects.  The drag-over effects depend on the value of ID="ch15258"XmNdragInitiatorProtocolStyle.  ID="ch15259"XmDRAG_DROP_ONLY [X] Does not support either the preregister mode or the dynamic mode, but does data transfer after the drop occurs.  There are no drag-over or drag-under visual effects.  ID="ch15260"XmDRAG_PREREGISTER [P] Supports the preregister mode only.  The visual effects are managed by the toolkit.  ID="ch15261"XmDRAG_PREFER_PREREGISTER [PP] Supports both protocols, but prefers the preregister protocol.  This is the default for receivers.  The visual effects are determined by the protocol actually used.  ID="ch15262"XmDRAG_PREFER_RECEIVER [R] Used by initiators only.  Uses the protocol that the receiver specifies.  This is the default for initiators.  The visual effects are determined by the protocol actually used.  ID="ch15263"XmDRAG_PREFER_DYNAMIC [PD] Supports both protocols, but prefers the dynamic mode.  The visual effects are determined by the protocol actually used.  ID="ch15264"XmDRAG_DYNAMIC [D] Supports the dynamic protocol only.  The drag-over and drag-under visual effects are managed by the clients.  ID="ch15265"For example: myclient*dragInitiatorProtocolStyle: DRAG_PREFER_DYNAMIC
myclient*dragReceiverProtocolStyle:  DRAG_PREFER_DYNAMICIf the initiator and receiver have specified the same protocol, that protocol is used.  If they specify different protocols, the protocol that is used is shown in the following table.  COLUMNS="7"LEFT="0" WIDTH="63"Initiator 
ProtocolLEFT="70" WIDTH="27"LEFT="105" WIDTH="27"LEFT="140" WIDTH="45"Receiver 
Protocol  LEFT="190" WIDTH="27"LEFT="225" WIDTH="27"LEFT="260" WIDTH="356"LEFT="0" WIDTH="63"† †LEFT="70" WIDTH="27"PLEFT="105" WIDTH="27"PPLEFT="140" WIDTH="45"PDLEFT="190" WIDTH="27"DLEFT="225" WIDTH="27"XLEFT="260" WIDTH="356"NLEFT="0" WIDTH="63"PLEFT="70" WIDTH="27"PLEFT="105" WIDTH="27"PLEFT="140" WIDTH="45"PLEFT="190" WIDTH="27"XLEFT="225" WIDTH="27"XLEFT="260" WIDTH="356"NLEFT="0" WIDTH="63"PPLEFT="70" WIDTH="27"PLEFT="105" WIDTH="27"PLEFT="140" WIDTH="45"PLEFT="190" WIDTH="27"DLEFT="225" WIDTH="27"XLEFT="260" WIDTH="356"NLEFT="0" WIDTH="63"RLEFT="70" WIDTH="27"PLEFT="105" WIDTH="27"PLEFT="140" WIDTH="45"DLEFT="190" WIDTH="27"DLEFT="225" WIDTH="27"XLEFT="260" WIDTH="356"NLEFT="0" WIDTH="63"PDLEFT="70" WIDTH="27"PLEFT="105" WIDTH="27"DLEFT="140" WIDTH="45"DLEFT="190" WIDTH="27"DLEFT="225" WIDTH="27"XLEFT="260" WIDTH="356"NLEFT="0" WIDTH="63"DLEFT="70" WIDTH="27"XLEFT="105" WIDTH="27"DLEFT="140" WIDTH="45"DLEFT="190" WIDTH="27"DLEFT="225" WIDTH="27"XLEFT="260" WIDTH="356"NLEFT="0" WIDTH="63"XLEFT="70" WIDTH="27"XLEFT="105" WIDTH="27"XLEFT="140" WIDTH="45"XLEFT="190" WIDTH="27"XLEFT="225" WIDTH="27"XLEFT="260" WIDTH="356"NLEFT="0" WIDTH="63"NLEFT="70" WIDTH="27"NLEFT="105" WIDTH="27"NLEFT="140" WIDTH="45"NLEFT="190" WIDTH="27"NLEFT="225" WIDTH="27"NLEFT="260" WIDTH="356"NLBL="15-1"Table 15-1 ID="27145"Initiator and Receiver ProtocolsThe XmGetXmDisplay function returns the Display object ID associated with a specific display. ID="ch15266"XtGetValues† †can be used to check the protocol style resources.  ID="ch15267"If an XmNdragProc is specified for a drop site, it will be performed only if the protocol is dynamic.  In this case, the application should set the ID="ch15268"XmNdragReceiverProtocolStyle resource to the value ID="ch15269"XmDRAG_PREFER_DYNAMIC in the application-class defaults file rather than use the default value.  ID="ch15270"LBL="" HELPID=""Protocols and VisualsID="ch15271"When the resulting protocol is preregister, a preregister visual style is used, and the server is grabbed.  The drag-over visual can be a pixmap with an arbitrary size whose depth and colormap are the same as those of the widget associated with the drag source.  The pixmap is specified in the DragContext ID="ch15272"XmNsourcePixmapIcon resource.  ID="ch15273"ID="ch15274"When the resulting protocol is dynamic, a dynamic visual style is always used.  The drag-over visual is implemented with the X cursor, which must be a bitmap, and often has limited size (use XQueryBestSize† †to find out the largest size available per screen).  The cursor is specified using ID="ch15275"XmNsourceCursorIcon.  ID="ch15276"Users will specify one of the preregister values for XmNdragInitiatorProtocolStyle because they want good performance when network loading or context switching are problems, or because they want better drag-over visuals rather than more sophisticated drag-under visuals.  ID="ch15277"Users will specify one of the dynamic values for XmNdragInitiatorProtocolStyle because there are clients that use use the dynamic effects, and for visual consistency, they want to use a dynamic visual style whenever possible.  ID="ch15278"Consequently, when the resulting protocol is XmDRAG_NONE or XmDRAG_DROP_ONLY, the visual style depends upon the value of ID="ch15279"ID="ch15280"XmNdragInitiatorProtocolStyle.  When it is ID="ch15281"XmDRAG_DYNAMIC or XmDRAG_PREFER_DYNAMIC, the dynamic visual style is used; otherwise, the preregister visual style is used.  ID="ch15282"ID="ch15283"LBL="15.3.3" HELPID=""Drop ProtocolID="ch15284"ID="ch15285"When a drop is made, the receiver checks what action should happen: If the user requested help, the receiver should display a dialog explaining the consequences of a drop on the site and determine if the user wants to continue or cancel the drop.  If the user requests a cancel from the help dialog or presses KCancel, or if the receiver determines that the drop cannot continue, the receiver sets the number of transfers to zero and the status to failed to cancel the drop.  ID="ch15286"If the drop can continue normally, the receiver starts a transfer.  The drop protocol is a superset of the Xt incremental and nonincremental protocol, with two main differences: ID="ch15287"ID="ch15288"The receiver and initiator need only one XmNtransferProc† †and ID="ch15289"XmNconvertProc (the Xt selection process requires separate procedures for incremental and nonincremental transfer).  They each specify whether the transfer is incremental or not from their side of the transfer with DropTransfer and DragContext resources.  If the initiator and receiver use the same incremental or nonincremental protocol, the toolkit deals with each in the requested protocol.  ID="ch15290"ID="ch15291"ID="ch15292"ID="ch15293"ID="ch15294"ID="ch15295"ID="ch15296"The initiator and receiver are both notified of the completion of the entire transfer, regardless of how many subtransfers were involved.  The drop protocol is handled by a DropTransfer widget created by ID="ch15297"XmDropTransferStart in the receiver client.  The receiver creates a list of information and target types desired from the initiator, along with an ID="ch15298"XmNtransferProc to handle any processing needed during the transfer.  The toolkit processes the requests one at a time, until it has finished with the list.  ID="ch15299"The receiver must call XmDropTransferStart, even if the number of transfer requests is zero.  Otherwise, the initiator will keep waiting for a transfer request.  ID="ch15300"For each transfer request, the initiator's XmNconvertProc† †is called.  This procedure reads and processes the request and returns the information.  ID="ch15301"LBL="15.4" HELPID=""Drop Receiver Responsibilities for DraggingID="ch15302"ID="ch15303"The drop receiver responsibilities are covered first in this chapter, because in the dynamic protocol, motion messages go first to the receiver client.  The receiver evaluates the state of the drag and sends an updated message to the initiator, which then manages its drag-over visuals based on the results.  The drag receiver has some responsibilities before a drag even starts: It registers widgets as drop sites, providing information about valid operations, target types accepted, and drag-under effects (animation style).  The application can use the default values for this information, or provide its own values.  It registers an XmNdropProc that is called when a drop occurs and which starts the transfer of information from the initiator.  This ID="ch15304"XmNdropProc also processes any Help information the application provides about a drop site.  It optionally registers an XmNdragProc for use with the dynamic protocol that is called for events while a drag is within the widget's boundaries.  ID="ch15305"If the drag protocol in effect is preregister, the drop site information is put in the database as the drop sites are registered and the receiver client does nothing until a drop is made.  All visual effects are handled by the toolkit.  If the drag protocol is dynamic, messaging begins when the pointer enters the window containing the drop site.  The receiver is given the opportunity to provide additional processing in its XmNdragProc.  The ID="ch15306"XmNdragProc† †Receives messages when the drag icon enters or leaves the drop site, the operation changes, the drag icon is in motion, or the drag is cancelled.  Provides information back to the toolkit about the state of the drag (valid drop site, invalid drop site, no drop site) and the operation to be performed when a drop is made.  Manages any custom drag-under visual effects.  ID="ch15307"LBL="15.4.1" HELPID=""Establishing a Drop SiteID="ch15308"Text and TextField widgets register themselves as drop sites.  An application must register any other widgets it wants to use for drop sites.  A widget may be registered as only one drop site.  ID="ch15309"ID="ch15310"XmDropSiteRegister registers a widget as a drop site, establishes callbacks to be used when a drag is made through the drop site or a drop is made in the drop site, and provides target and operation information.  If the protocol is preregister, the information is stored in a database, which is read by the toolkit during the drag.  If the drag protocol is dynamic, messaging is used to check for possible drop sites within a widget.  ID="ch15311"ID="ch15312"The application must register an XmNdropProc routine to establish a list of transfer requests and start the transfer.  The other resources can be left at their default values if those values are acceptable to the application.  ID="ch15313"The optional XmNdragProc routine is executed only if the drag protocol is dynamic.  It is called in response to events during the drag, and allows the receiver to provide additional drag-under effects or additional drag processing.  ID="ch15314"The XmNdropSiteOperations resource lists all operations that the drop site will support, combined by the bitwise OR operations (|).  For example, the default value ID="ch15315"XmDROP_COPY | XmDROP_MOVEmeans that Copy and Move are valid operations, but Link is not.  During a drag, the toolkit on the receiver side compares this list with the DragContext's XmNdragOperations list and the user-selected operation to arrive at the operation that will be performed if a drop occurs on this site, along with a list of all operations possible between the initiator and the current drop site.  ID="ch15316"ID="ch15317"If an application wants to use only one operation, such as Copy, it should set the XmNdropSiteOperations field to just that operation to ensure that the toolkit chooses the correct operation and drag icon during the drag and drop transaction.  ID="ch15318"Drop sites that represent copying devices, such as printers, or transformation devices, such as compilers, should perform a Copy rather than a Move if both are possible.  The XmNdropSiteActivity resource indicates whether the drop site is available for use: ID="ch15319"ID="ch15320"ID="ch15321"ID="ch15322"ID="ch15323"XmDROP_SITE_ACTIVE The drop site is available for use.  This is the default value.  ID="ch15324"XmDROP_SITE_INACTIVE The drop site is not available for use.  If the drag icon is moved over the drop site, both the icon and drop site act as if the icon were not over a drop site.  ID="ch15325"The XmDropSiteUnregister function removes a widget from the DropSite registry.  Once a widget is unregistered, it displays no drag-under visual effects and cannot accept a drop.  ID="ch15326"ID="ch15327"The difference between an unregistered drop site and an inactive drop site is that the inactive drop site is still registered; it still uses memory, but does not engage in any drag and drop transactions.  One use for inactive drop sites is to provide the correct clipping on overlapping drop sites.  An unregistered drop site is no longer involved in the drag and drop system.  It is the same as a widget that was never registered.  The following code from the main routine in DNDlabel.c in IDREF="42149" TYPE="TITLE""A Simple Drag Receiver"
 generates a simple drop site on a Label widget.  The only target type it recognizes is compound text.  The only operation it will accept is Copy.  The other resources, including drag-under effects, are left at their default values.  LBL="15-4" FILE="label.gif" POSITION="INLINE" SCALE="FALSE"LBL="15-4"Figure 15-4 A Label WidgetLabel = XmCreateLabel(BulletinB, "title", args, n);
XtManageChild(Label);
/* register the label as a drop site */
importList[0] = COMPOUND_TEXT;
n = 0;
XtSetArg(args[n], XmNimportTargets, importList); n++;
XtSetArg(args[n], XmNnumImportTargets, 1); n++;
XtSetArg(args[n], XmNdropSiteOperations, XmDROP_COPY); n++;
XtSetArg(args[n], XmNdropProc, HandleDrop); n++;
XmDropSiteRegister(Label, args, n);
XtRealizeWidget(topLevel);
XtAppMainLoop(app_context);LBL="" HELPID=""Changing a Drop SiteThe XmDropSiteUpdate function is used to change drop site resources for a single drop site.  For multiple requests, ID="ch15328"XmDropSiteStartUpdate signals that a series of ID="ch15329"XmDropSiteUpdate requests will follow, and XmDropSiteEndUpdate ends the series and processes the requests at one time.  ID="ch15330"XmDropSiteUpdate can also be used to change the resource values of the widgets that register themselves as drop sites (Text and TextField).  For instance, an application can change Text's ID="ch15331"ID="ch15332"ID="ch15333"XmNdropProc to call a procedure in the application.  ID="ch15334"LBL="" HELPID=""Specially Shaped Drop SitesID="ch15335"The shape of a simple drop site can be specified as the union of a set of specified rectangles clipped by the associated widget.  If only part of the widget is to be sensitive to a drop, it is defined by a list of rectangles in the XmNdropRectangles resource.  If the resource is NULL, the drop site is the smallest enclosing widget and the shape of the drop site is the shape of the widget.  ID="ch15336"The rectangles that make up the drop site do not need to be contiguous.  All the noncontiguous segments of the drop site act as one; they are all highlighted the same way at the same time.  A drop on one segment is the same as a drop on any of the other segments.  This might look to the user as if there were several drop sites on a single widget, but the application handles nested drop sites differently from drop sites made of noncontiguous segments.  Nested drop sites, whether simulated or real, may have different drag-under effects, targets, operations, or callback procedures.  The following example establishes a sensitive area shaped like a plus sign on a DrawnButton widget named Button2.  Even if the drag icon is within the Button2 widget, no drag-under effects are shown until the drag icon is within the sensitive area.  The area is visible only when a drag icon enters it and highlighting occurs.  The sensitive area is the only part of the widget that accepts a drop.  This code is not in one of the three example programs included in ID="ch15337"IDREF="30895" TYPE="TITLE"Section 15.2.1, "Complexity of Drag and Drop Programs,"
 and IDREF="61196" TYPE="TITLE"Appendix B, "Drag and Drop Example Program."LBL="15-5" FILE="plus.gif" POSITION="INLINE" SCALE="FALSE"LBL="15-5"Figure 15-5 Specially Shaped Drop SiteXRectangle plus[] = {  
† †   {30, 0, 30, 30},   
† †   {0, 30, 90, 30},   
† †   {30, 60, 30, 30},  
† †   };
† †    .
† †    .
† †    .
n = 0;
XtSetArg(args[n], XmNimportTargets, importList); n++;
XtSetArg(args[n], XmNnumImportTargets, 1); n++;
XtSetArg(args[n], XmNdropProc, HandleDrop); n++;
XtSetArg(args[n], XmNdropRectangles, plus); n++;
XtSetArg(args[n], XmNnumDropRectangles, 3); n++;
XmDropSiteRegister(Button2, args, n);LBL="" HELPID=""Nested Drop SitesA widget can be registered as only one drop site.  However, widgets that are registered as drop sites can be nested within each other, providing nested drop sites.  The XmNdropSiteType indicates the complexity of the drop site: ID="ch15338"XmDROP_SITE_SIMPLE The drop site contains no other drop sites.  ID="ch15339"XmDROP_SITE_COMPOSITE The drop site contains other drop sites.  This value is generally associated with a Manager.  ID="ch15340"A composite drop site must be registered before any of its children are registered.  If a composite drop site is inactive, so are all of its children.  The composite and children drop sites do not need to have the same operations or targets.  A manager that contains a number of widgets with their associated drop sites does not need to be a composite drop site unless it is possible to drop in the background of the manager.  It is possible for an application to simulate nested drop sites on a single widget, for example, a DrawingArea.  The process is described as part of the discussion of the duties of the optional XmNdragProc routine in IDREF="29462" TYPE="TITLE"Section 15.4.2, "XmNdragProc."ID="ch15341"LBL="" HELPID=""Overlapping Drop SitesID="ch15342"ID="ch15343"Drop sites can overlap.  Their stacking order is assumed to correspond to the order in which they are registered, with the first-registered one on top.  XmDropSiteQueryStackingOrder checks the stacking order, whereas ID="ch15344"XmDropSiteConfigureStackingOrder changes it.  ID="ch15345"When a drop site is overlapped by another drop site, the drag-under effects of the drop site underneath are clipped as appropriate by the obscuring drop site.  A widget or gadget that is not a drop site can overlap and partially obscure a drop site.  To ensure that the drop-site's drag-under visuals are appropriately clipped by the obscuring widget, such sibling widgets should be registered as inactive drop sites.  Parent widgets, whether drop sites or not, will clip their children's drop site visuals.   If a parent has some active and some inactive drop site children, it should be registered as an active drop site.  LBL="" HELPID=""Drag-Under Visual EffectsID="ch15346"Drag-under visual effects are displayed only when the pointer is within the sensitive area of the drop site widget.  Various drag-under styles can be chosen in the XmNanimationStyle† †DropSite resource: ID="ch15347"ID="ch15348"XmDRAG_UNDER_HIGHLIGHT A solid border around the sensitive area of the drop site is used to show the drop site is valid.  This is the default value.  ID="ch15349"XmDRAG_UNDER_SHADOW_OUT The sensitive area of the drop site looks pushed out when it is valid.  ID="ch15350"XmDRAG_UNDER_SHADOW_IN The sensitive are of the drop site looks pushed in when it is valid.  ID="ch15351"XmDRAG_UNDER_PIXMAP A custom pixmap is used to indicate the drop site is valid.  The pixmap is specified in ID="ch15352"XmNanimationPixmap.  ID="ch15353"XmDRAG_UNDER_NONE No indication is given that the drop site is valid.  ID="ch15354"The following illustration shows the default drag-under animation around the Label widget drop site.  ID="ch15355"LBL="15-6" FILE="labelarm.gif" POSITION="INLINE" SCALE="FALSE"LBL="15-6"Figure 15-6 Default Drag-Under AnimationIf the value of XmNanimationStyle is XmDRAG_UNDER_PIXMAP, the resources ID="ch15356"ID="ch15357"XmNanimationPixmap, XmNanimationMask, and ID="ch15358"ID="ch15359"XmNanimationPixmapDepth are used to provide more information about the pixmap.  If the depth does not match the depth of the window controlling the drop site widget, no animation occurs.  Except for ID="ch15360"XmDRAG_UNDER_PIXMAP, the colors used for the visual effects are based on the colors of the widget associated with the drop site.  ID="ch15361"ID="ch15362"ID="ch15363"ID="ch15364"The dynamic protocol provides the most control over the drop site animation.  It is the only way to get visual effects that do not remain the same for the duration of the drag icon's stay in the drop site, for example, a background that flashes.  LBL="15.4.2" HELPID=""ID="29462"XmNdragProcID="ch15365"The procedure registered in the DropSite's XmNdragProc† †resource is called only when the dynamic protocol is in effect.  This procedure is optional.  Applications that need to provide special drag-under effects or other special processing during a drag can do so with this procedure.  ID="ch15366"ID="ch15367"The XmNdragProc procedure is called in response to messages from the toolkit, before the initiator's equivalent drag callback.  Fields in the callback structure provide information to the receiver about the drag.  ID="ch15368"The reason field in the callback structure indicates why the procedure was called.  XmCR_DROP_SITE_ENTER_MESSAGE The drag icon hotspot has entered the drop site.  ID="ch15369"XmCR_DROP_SITE_LEAVE_MESSAGE The drag icon hotspot has left the drop site.  ID="ch15370"XmCR_DRAG_MOTION_MESSAGE The drag icon hotspot has moved.  ID="ch15371"XmCR_OPERATION_CHANGED_MESSAGE The operation has changed.  ID="ch15372"The operations field lists all the operations that are valid for the drop site with the current drag source.  The operations field is initialized by the toolkit as follows: If the user has selected an operation, the value of operations is initialized to that operation if it is in the DragContext's ID="ch15373"XmNdragOperations list.  ID="ch15374"Otherwise, the operations field is initialized to the list in the DragContext's XmNdragOperations list.  ID="ch15375"ID="ch15376"The operation field indicates the type of action a successful drop will perform.  The toolkit initializes the operation field by taking the following steps, in order of precedence from highest to lowest: If Move is a valid operation (in both the operations field and the DropSite's XmNdropSiteOperations list), operation is initialized to ID="ch15377"ID="ch15378"XmDROP_MOVE.  ID="ch15379"If Copy is a valid operation, operation is initialized to XmDROP_COPY.  ID="ch15380"If Link is a valid operation, operation is initialized to XmDROP_LINK.  ID="ch15381"Otherwise, operation is initialized to XmDROP_NOOP.  ID="ch15382"The dropSiteStatus field provides an indication of whether a transfer between the initiator and this drop site could occur.  The value that the toolkit selects for the dropSiteStatus field depends on the reason the XmNdragProc† †procedure was entered: ID="ch15383"If the reason is motion or drop site leave, and the drop site is the same as in the last call to XmNdragProc, the dropSiteStatus† †field is the same as at the end of the previous call.  ID="ch15384"Otherwise, if there is at least one target in common and at least one operation in common, the value is initialized to XmDROP_SITE_VALID.  If not, the value is initialized to ID="ch15385"XmDROP_SITE_INVALID.  ID="ch15386"If the operation field is XmDROP_NOOP, the dropSiteStatus† †field is initialized to ID="ch15387"XmDROP_SITE_INVALID.  ID="ch15388"The XmNdragProc procedure can update operation, operations, or ID="ch15389"dropSiteStatus further during its execution. The final values for these fields are available to the initiator in its drag callback structures.  If the receiver's XmNdragProc procedure is called more than once while the drag icon is within the drop site (for example, because of motion events), the values used by the toolkit when it initializes the drag callback ID="ch15390"operations, operation, and dropSiteStatus fields are the ones at the end of the previous call to XmNdragProc.  ID="ch15391"The animate field tells the toolkit who should provide the drag-under visual effects.  It is initially set to True, but the XmNdragProc routine can set it to False.  ID="ch15392"TrueThe toolkit provides the drag-under visuals as if the protocol were preregister.  FalseThe receiver provides the drag-under visuals.  The application can provide special visual effects, such as a blinking background, that are not possible with the toolkit.  The DragProcCallback routine in the DNDDemo.c program in IDREF="61196" TYPE="TITLE"Appendix B, "Drag and Drop Example Program,"
 is an example of a DragProc routine.  It can process every drag message, changes the operations, operation, and dropSiteStatus as necessary, and sets the animate field to True, allowing the toolkit to manage the drag-under effects.  The DragProcCallback routine is shown in the next section of this chapter.  LBL="" HELPID=""Simulating Nested Drop SitesID="ch15393"ID="ch15394"A widget can be registered as only a single drop site.  However, if the application needs one or more drop sites entirely enclosed within another drop site, there are two ways to accomplish this: Widgets that contain other widgets that are drop sites should be registered as composite drop sites as described earlier in this chapter.            This method allows the toolkit to manage drop site messages and drag-under effects for each nested drop site.  An application can simulate multiple drop sites on a single widget in the XmNdragProc and XmNdropProc routines.  Because the ID="ch15395"ID="ch15396"XmNdragProc routine is executed only in the dynamic drag protocol mode, this method would not work if the drag procotol chosen is preregister.  This method requires that the application manage all drag-under effects, because the toolkit is not aware of the simulated nesting.  To simulate nested drop sites on a single widget: Register the widget as a single active drop site.  Set XmNdropSiteOperations to all the operations possible for any of the nested drop sites.  Set ID="ch15397"XmNimportTargets† †to all the targets possible for any of the nested drop sites.  Register an ID="ch15398"XmNdragProc routine to provide any special drag-under effects for the simulated drop sites.  ID="ch15399"The operations, operation, and dropSiteStatus fields are initialized by the toolkit only when this outer drop site is entered or left.  The simulated drop sites must be managed by the application.  When either XmNdragProc or XmNdropProc† †is called, check the ID="ch15400"ID="ch15401"x and y fields in the callback structure to determine which of the nested drop sites contains the pointer.  If the pointer is within a simulated nested drop site, update the callback fields as follows: When the pointer enters the simulated nested drop site, save the value of the operations and operation fields.  Remove any operations from the operations field that do not apply to the simulated drop site.  Set operation to the valid operation preferred by the simulated drop site, or to XmDROP_NOOP if the operations list does not contain the preferred operation.  ID="ch15402"The dropSiteStatus field must reflect the status of the simulated drop site so that the initiator can manage drag-over effects correctly: -   Set the dropSiteStatus to XmDROP_SITE_VALID if the operation† †is allowed in the simulated drop site and if there is at least one target in common between the simulated drop site and the initiator.  (Use the ID="ch15403"XmTargetsAreCompatible routine to check the targets.) ID="ch15404"-   Set the dropSiteStatus to XmDROP_SITE_INVALID if the ID="ch15405"operation is not allowed in the simulated drop site, if there are no targets in common, or if the operation is XmDROP_NOOP.  ID="ch15406"Display appropriate drag-under visual effects.  When the pointer leaves the simulated drop site, restore the original values of operations and operation that apply to the outer drop site.  If the pointer is not within a simulated drop site, but drops are allowed in the outer drop site, update the fields as described in the previous step.  If the pointer is not within a simulated drop site, and drops are not allowed in the outer drop site, set the dropSiteStatus field to XmDROP_SITE_INVALID.  ID="ch15407"If the preregister protocol is in effect, the simulated drop sites cannot be managed during the move, because XmNdragProc is not performed; but they can be managed at the drop with ID="ch15408"XmNdropProc.  ID="ch15409"In the following example, only the top-level window, DNDDemo, is registered as a drop site.  The user can create rectangles within the window that then act like drop sites themselves.  The user can drag and drop colors from one of the six buttons in the lower part of the window onto the rectangles to change the color of the rectangle.  However, these rectangles are not registered drop sites, they are simulated.  The user can also drag these rectangles to new locations.  LBL="15-7" FILE="dnddemo.gif" POSITION="INLINE" SCALE="FALSE"LBL="15-7"Figure 15-7 Simulated Drop SitesThe RegisterDropSite routine registers the DrawingArea widget as a drop site.  The list of operations and targets may not be valid for each simulated drop site, but are valid for other simulated drop sites.  ID="ch15410"RegisterDropSite(w)
Widget w;
{
† †   Display *display = XtDisplay(w);
† †   Atom    targets[3];
† †   Arg     args[5];
† †   int     n = 0;
† †   /* Only accept moves or copies */
† †   XtSetArg(args[n], XmNdragOperations,
† †              XmDROP_COPY | XmDROP_MOVE); 
† †   n++;
† †   /* set all possible targets for any of the
† †    * nested drop sites
† †    */
† †   targets[0] = XmInternAtom(display, "_MY_RECTANGLE", False);
† †   targets[1] = XmInternAtom(display, "BACKGROUND", False);
† †   targets[2] = XmInternAtom(display, "PIXMAP", False);
† †   XtSetArg(args[n], XmNimportTargets, targets); n++;
† †   XtSetArg(args[n], XmNnumImportTargets, 3); n++;
† †   /* register a dragProc - necessary for simulating nested
† †    * drop sites
† †    */
† †   XtSetArg(args[n], XmNdragProc, DragProcCallback); n++;
† †   /* register a dropProc */
† †   XtSetArg(args[n], XmNdropProc, DropProcCallback); n++;
† †   XmDropSiteRegister(w, args, n);
}The XmNdragProc routine, DragProcCallback, is called whenever a drag icon enters the registered drop site (the top level window).  The ID="ch15411"RectFind routine from DNDDraw.c in IDREF="61196" TYPE="TITLE"Appendix B, "Drag and Drop Example Program,"
 determines if the pointer is in a simulated drop site.  The CheckTargets routine determines if the object being dragged is one of the six colors (bgFound) or one of the created rectangles (rectFound).  (The value pixFound to represent a pixmap being dragged is coded in this routine, but not in the rest of the program.) The only drag-under visual is displayed when a color is dragged to a rectangle.  The outline of the rectangle is highlighted.  The entire DragProcCallback routine is too long to be listed in its entirety here.  The section dealing with the drop site enter message is used as an example.  static void DragProcCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
† †   XmDragProcCallbackStruct *cb =
† †                          (XmDragProcCallbackStruct *) call;
† †   Display                     *display = XtDisplay(w);
† †   Boolean                     rectFound, bgFound, pixFound;
† †   static unsigned char        initial_operations;
† †   static unsigned char        initial_operation;
† †   RectPtr                     rect;
† †   CheckTargets(cb->dragContext, display, &rectFound,
† †       &bgFound, &pixFound);
† †   switch(cb->reason) {
† †       case XmCR_DROP_SITE_ENTER_MESSAGE:
† †           /* save the value of the operations and operation 
† †            * fields
† †            */
† †           initial_operations = cb->operations;
† †           initial_operation = cb->operation;
† †           rect = RectFind(cb->x, cb->y);
† †           /* Remove any operations for the operations field 
† †            * which do not apply to the simulated drop site.
† †            */
† †           if (rect) {
† †               if (bgFound || pixFound) {
† †                   cb->operations = XmDROP_COPY;
† †                   RectHighlight(w, rect);
† †               }
† †               else if (rectFound) {
† †                   cb->operations = cb->operations & 
† †                                 (XmDROP_COPY | XmDROP_MOVE);
† †                   RectUnhighlight(w);
† †               }
† †           }
† †           else {
† †               cb->operations = initial_operations & 
† †                                (XmDROP_COPY | XmDROP_MOVE);
† †               RectUnhighlight(w);
† †           }
† †           /* Set operation to the valid operation preferred
† †            * by the simulated drop site or to XmDROP_NOOP
† †            * if the operations list does not contain the
† †            * preferred operation.
† †            */
† †           if (rect) {
† †               if (bgFound || pixFound) {
† †                   if (cb->operations & XmDROP_COPY)
† †                       cb->operation = XmDROP_COPY;
† †                   else
† †                       cb->operation = XmDROP_NOOP;
† †               }
† †               else if (rectFound) {
† †                   if (cb->operations & XmDROP_MOVE)
† †                       cb->operation = XmDROP_MOVE;
† †                   else if (cb->operations & XmDROP_COPY)
† †                       cb->operation = XmDROP_COPY;
† †                   else
† †                       cb->operation = XmDROP_NOOP;
† †               }
† †           }
† †           else {
† †               if (rectFound) {
† †                   if (cb->operations & XmDROP_MOVE)
† †                       cb->operation = XmDROP_MOVE;
† †                   else if (cb->operations & XmDROP_COPY)
† †                       cb->operation = XmDROP_COPY;
† †                   else
† †                       cb->operation = XmDROP_NOOP;
† †               }
† †               else
† †                   cb->operation = initial_operation;
† †           }
† †           /*
† †            * Set dropSiteStatus to XmDROP_SITE_INVALID if
† †            * the operation field is XmDROP_NOOP, or if there
† †            * are no  common targets between the source and
† †            * the nested  drop site.  Otherwise, set
† †            * dropSiteStatus to  XmDROP_SITE_VALID. 
† †            */
† †           if (cb->operation == XmDROP_NOOP ||
† †               (rect && (!rectFound && !bgFound && !pixFound))
† †               || (!rect && !rectFound))
† †               cb->dropSiteStatus = XmINVALID_DROP_SITE;
† †           else
† †               cb->dropSiteStatus = XmVALID_DROP_SITE;
† †           /*
† †            * Display appropriate drag-under visuals.  Only 
† †            * highlight the rectangle if we are changing 
† †            * rectangle attributes.
† †            */
† †           if (rect && bgFound || pixFound &&
† †               cb->dropSiteStatus == XmVALID_DROP_SITE)
† †               RectHighlight(w, rect);
† †           break;
† †       case XmCR_DROP_SITE_LEAVE_MESSAGE:
† †           .
† †           .
† †           .LBL="15.5" HELPID=""Drag Initiator Responsibilities for DraggingID="ch15412"ID="ch15413"The application in which the user initiates the drag is considered the drag initiator.  The drag initiator Recognizes the start of a drag (BTransfer Press) within a widget controlled by the application.  ID="ch15414"Establishes a DragContext for the widget, providing information about operations, targets, and drag-over visuals, using the ID="ch15415"XmDragStart function.  ID="ch15416"Optionally, provides special drag-over effects.  These steps are described in the following sections.  LBL="15.5.1" HELPID=""Recognizing a Drag Has StartedThe initiator client must be able to recognize the BTransfer Press event within a widget it allows to be a drag source.  It may have to override an already-assigned translation for the widget.  ID="ch15417"The following example from the main routine of DNDscroll.c in IDREF="17919" TYPE="TITLE""A Simple Drag Source"
 overrides the existing mouse button 2 translation for the ScrollBar widget, and maps it to the StartDrag routine, which will start the drag transaction.  ID="ch15418"static char dragTranslations[] = 
† †    "#override <Btn2Down>: StartDrag()";
static XtActionsRec dragActions[] = 
† †    { {"StartDrag", (XtActionProc)StartDrag}, };
† †    .
† †    .
XtTranslations parsed_xlations;
† †    .
† †    .
/* override button two press to start a drag */
parsed_xlations = XtParseTranslationTable(dragTranslations); 
XtAppAddActions(app_context, dragActions,
† †                 XtNumber(dragActions));
/* create a scroll bar widget */ 
n = 0;
XtSetArg(args[n], XmNtranslations, parsed_xlations); n++;
scrollbar = XmCreateScrollBar(BulletinB, "testscroll",
† †                               args, n);   
XtManageChild(scrollbar);Translation may be more complicated in some editable widgets, in which BTransfer Click† †is used for primary transfer, and ID="ch15419"BTransfer Motion is used for drag and drop.  LBL="15.5.2" HELPID=""Starting a Drag With XmDragStartNot every widget in an application can be a drag source.  Text, Label, Button, and List widgets are automatically defined as drag sources.  Other widgets must have a translation for ID="ch15420"ID="ch15421"ID="ch15422"BTransfer assigned to them, establish DragContext resources for the widget, and call the ID="ch15423"ID="ch15424"XmDragStart routine to become drag sources.  If the user tries to drag objects from a widget that is not recognized as a drag source by either the toolkit or the source application, nothing happens.  ID="ch15425"The XmDragStart function initiates a drag and creates a DragContext widget.  At a minimum, the ID="ch15426"ID="ch15427"XmNconvertProc DragContext resource, must be specified.  Other resources are optional, for example, those specifying drag-over visual effects.  ID="ch15428"The XmNdragOperations resource lists all the operations that the initiator will support for this drag source, combined by the bitwise OR operation (|).  During a drag, the toolkit compares this list with the receiver's ID="ch15429"XmNdropSiteOperations list and the user-selected operation to arrive at the operation that will be performed if a drop occurs on this site.  ID="ch15430"If an application wants to use only one operation, it should set the XmNdragOperations resource to just that operation to ensure that the correct operation and drag icon are chosen by the toolkit during the drag and drop transaction.  ID="ch15431"The following example from DNDscroll.c in IDREF="17919" TYPE="TITLE""A Simple Drag Source"
 establishes a target type of compound text and an operation of Copy, then establishes a DragContext for this transaction with ID="ch15432"XmDragStart.  This drag source does not have any custom drag icons or any drag callbacks.  ID="ch15433"static void StartDrag(w, event)
Widget  w;
XEvent  *event;
{
† †  Arg             args[MAX_ARGS];
† †  Cardinal        n;
† †  Atom            exportList[1];
† †  /* establish the list of valid target types */
† †  exportList[0] = COMPOUND_TEXT;
† †  n = 0; 
† †  XtSetArg(args[n], XmNexportTargets, exportList); n++;
† †  XtSetArg(args[n], XmNnumExportTargets, 1); n++;
† †  XtSetArg(args[n], XmNdragOperations, XmDROP_COPY); n++;
† †  XtSetArg(args[n], XmNconvertProc, DragConvertProc); n++;
† †  XmDragStart(w, event, args, n);
}If drag or drop callbacks are desired, they are added to the DragContext's callback resources.  For example, a callback procedure named ID="ch15434"EnterCallBack that is performed when the pointer enters an active drop site could be added as follows: Widget         dc;
† †  .
† †  .
† †  .
† †  dc = XmDragStart(w, event, args, n);
† †  XtAddCallback(dc, XmNdropSiteEnterCallback, EnterCallBack,
† †                  NULL); LBL="15.5.3" HELPID=""Overriding Existing Drag SourcesXtGetValues is used to check the values of widgets resources established as drag sources earlier in the application, and ID="ch15435"XtSetValues is used to update these values.  The widget ID used is the DragContext, not the source widget ID, so that the change applies only to the widget during the drag.  ID="ch15436"ID="ch15437"If the widget is a predefined drag source (Text, Label, Button, or List), overriding the default behavior becomes more complex.  The widget calls ID="ch15438"ID="ch15439"ID="ch15440"XmDragStart when the drag starts, and the application cannot call ID="ch15441"XmDragStart again for the widget.  Instead, it must update the existing DragContext.  First it must find the DragContext for the widget, then establish the new behavior.  One possible means to accomplish this is as follows: ID="ch15442"Override the existing Btn2Down translation with a new translation that calls the widget's action and also an action supplied by the application.  For the Text widget, this new translation might look as follows: ID="ch15443"<Btn2Down> : process-bdrag() my-drag-start()Register the new action, using XtAppAddActions.  ID="ch15444"In the new action procedure, call XmGetDragContext to get the DragContext, and then call ID="ch15445"XtSetValues to change resource values.  The timestamp argument to ID="ch15446"ID="ch15447"XmGetDragContext can be the timestamp from the event passed to the action routine.  ID="ch15448"For instance, Text allows the Copy and Move operations.  If an application can support only Copy, it must update the DragContext's ID="ch15449"ID="ch15450"XmNdragOperations resource.  ID="ch15451"LBL="15.5.4" HELPID=""Drag-Over Visual EffectsWhen the user moves the mouse, a drag icon representing the object being dragged moves around the screen instead of the usual pointer.  As the icon is dragged over portions of the screen, the icon may change to show the status of a possible drop.  These drag-over visual effects help the user know how to proceed with the drag.  There are four ways to provide drag-over visual effects: Use the default drag-over visuals, specified in the XmScreen† †object.  The toolkit manages all the drag-over effects.  ID="ch15452"Put custom icons and pixmaps in the XmScreen visual resources to be used as default icons for all drag and drop transactions running on that ID="ch15453"XmScreen. The toolkit manages all the drag-over effects using these new icons.  These resources can be modified by the application or the user in a resource file.  Put custom icons and pixmaps in the DragContext visual resources for source, state, or operation icons.  The application must monitor the state of the drag using the drag callbacks and update the DragContext icon values as necessary.  The default icons specified in the ID="ch15454"ID="ch15455"XmScreen object are used only if the value for the equivalent DragContext visual resource is NULL.  ID="ch15456"ID="ch15457"Manage the drag-over effects entirely in the application by drawing directly to the screen.  The toolkit is not used, nor are the XmScreen and DragContext visual resources.  ID="ch15458"ID="ch15459"If the application provides custom icons and they are unsuitable for some reason, the toolkit defaults to the XmScreen drag-over visuals.  ID="ch15460"The drag icon consists of a source icon, optionally combined with a state icon and an operation icon.  Each drag icon has a hotspot.  Since a drag icon could be quite large, the hotspot provides a single pixel that is used in providing drag-over and drag-under effects.  For example, if the drag icon moves into the area of a valid drop site, neither the drag icon or the drop site will provide visual clues until the hotspot has moved into the area.  By default, the hotspot is the upper left corner of the state icon.  In the following illustration, the running figure is the source icon, the state icon is the arrow in the corner, and the operation icon shows a Copy will happen if a drop is made.  The default blending and attachment values are used.  LBL="15-8" FILE="runner3.gif" POSITION="INLINE" SCALE="FALSE"LBL="15-8"Figure 15-8 A Drag IconLBL="" HELPID=""Source IconID="ch15461"ID="ch15462"The source icon is a picture representing the object being dragged.  It can be either a pixmap or cursor.  The client can specify a custom pixmap in the DragContext resource XmNsourcePixmapIcon or a custom cursor in the ID="ch15463"ID="ch15464"XmNsourceCursorIcon resource.  If these resources are NULL or not usable (too large, not a bitmap, or created on a different screen, for example), the default cursor given in the ID="ch15465"XmScreen resource XmNdefaultSourceCursorIcon is used.  ID="ch15466"ID="ch15467"The pixmap icon is used with the preregister visual style.  The colormap is based on the source widget.  The cursor icon is used for the dynamic visual style.  The following illustration shows the default source icons for general purpose, List, Label, and Text widgets.  ID="ch15468"ID="ch15469"ID="ch15470"LBL="15-9" FILE="source3.gif" POSITION="INLINE" SCALE="FALSE"LBL="15-9"Figure 15-9 Source IconsLBL="" HELPID=""State IconID="ch15471"ID="ch15472"The state icon is a cursor that indicates if the drag is over a valid drop site, invalid drop site, or no drop site.  The default state icons are in the XmScreen resources XmNdefaultValidCursorIcon, ID="ch15473"ID="ch15474"XmNdefaultInvalidCursorIcon, and XmNdefaultNoneCursorIcon.  ID="ch15475"ID="ch15476"A custom state icon can be specified in the DragContext resource XmNstateCursorIcon.  This icon must be changed appropriately as the state of the drag changes, using the drag callbacks.  If ID="ch15477"ID="ch15478"XmNstateCursorIcon is NULL, not a bitmap, or not defined on the same screen as XmScreen, the default XmScreen icons are used.  ID="ch15479"The default state icon for all three states is an arrow, usually shown at the upper left corner of the operation icon.  Three DragContext resources can be used to change the color of the drag icon based on the state of the drag: ID="ch15480"XmNvalidCursorForeground, ID="ch15481"XmNinvalidCursorForeground, XmNnoneCursorForeground.  This allows visual feedback about the drag to the user, without changing the icon shape.  For example, the following lines in a resource file would make the drag icon green when it was over a valid drop site, red when it was over an invalid drop site, and yellow when it was not over any drop site: ID="ch15482"ID="ch15483"*.validCursorIcon:          green
*.invalidCursorIcon:        red
*.noneCursorIcon:           yellowLBL="" HELPID=""Operation IconID="ch15484"ID="ch15485"The operation icon is a cursor that indicates what operation is to happen when the drop is made.  The default operation icons are the values of the XmScreen† †resources ID="ch15486"XmNdefaultMoveCursorIcon, ID="ch15487"XmNdefaultCopyCursorIcon, and ID="ch15488"XmNdefaultLinkCursorIcon.  ID="ch15489"A custom operation icon can be specified in the DragContext resource ID="ch15490"XmNoperationCursorIcon.  The icon should be changed as the operation changes, using the drag callbacks.  If this resource is NULL, not a bitmap, or not defined on the same screen as ID="ch15491"XmScreen, the default XmScreen icons are used.  ID="ch15492"The following illustration shows the default Copy, Link, and Move operation icons.  LBL="15-10" FILE="opicons3.gif" POSITION="INLINE" SCALE="FALSE"LBL="15-10"Figure 15-10 Operation IconsIf the operation in effect is XmDROP_NOOP, meaning that no operation is possible, then the operation icon is left blank, as shown in the following illustration.  This condition also sets the ID="ch15493"dropSiteStatus to XmDROP_SITE_INVALID.  ID="ch15494"LBL="15-11" FILE="noopicon.gif" POSITION="INLINE" SCALE="FALSE"LBL="15-11"Figure 15-11 Copy and Noop Drag IconsLBL="" HELPID=""Drag Icon Blending and AttachmentThe client can specify which of the three icons to mix together to form the drag icon with the XmNblendModel DragContext resource: ID="ch15495"ID="ch15496"XmBLEND_ALL Use the source icon, state icon, and operation icon.  The hotspot comes from the state icon.  This is the default value.  The order listed is also the order of the blend.  ID="ch15497"XmBLEND_STATE_SOURCE Use only the source icon and state icon.  The hotspot comes from the state icon.  ID="ch15498"XmBLEND_JUST_SOURCE Use only the source icon.  The hotspot comes from the source icon.  ID="ch15499"XmBLEND_NONE Do not display any drag icon.  The client handles all drag-over effects.  ID="ch15500"The XmNattachment DragIcon resource specifies where the state and operation icons will be placed on the source icon.  The default placement is both the state and operation icons at the attachment point of the source icon, with the operation icon on top.  The default value is ID="ch15501"ID="ch15502"XmATTACH_NORTH_WEST.  ID="ch15503"XmNoffsetX and XmNoffsetY are used to place the icon relative to the attachment point.  ID="ch15504"ID="ch15505"If the attachment point is XmATTACH_HOT, the state and operation icons are attached to the source icon at a point the same x and y distance from the upper left corner of the source icon as the pointer is from the upper left corner of the widget containing the source.  This attachment style is particularly useful when the application makes a custom source icon that exactly reflects the source widget at the time the drag starts.  ID="ch15506"In the following illustration, the custom source icon is an outline of the scrollbar.  When the drag was started, the pointer was on the slider.  The operation and state icons are placed at the same location on the source icon.  LBL="15-12" FILE="hoticon.gif" POSITION="INLINE" SCALE="FALSE"LBL="15-12"Figure 15-12 An Attach_Hot IconWhen the state or operation icon is blended with a source icon, a specified point of the icon's XmNpixmap is aligned with the upper left corner of the source icon.  The resulting ID="ch15507"XmNpixmap is large enough to include both, and the resulting ID="ch15508"XmNmask has 1 bits wherever either the source icon or source mask did.  ID="ch15509"If a dynamic cursor style is being used, and the resulting blended cursor is too large for the screen, the blending is done with the XmScreen† †XmNdefaultSourceCursorIcon instead of the DragContext's ID="ch15510"ID="ch15511"ID="ch15512"XmNsourceCursorIcon.  If it is still too large, it is clipped relative to the hotspot (that is, if the hotspot is at an edge, the other edge is clipped; if the hotspot is in the center, opposite edges are clipped equally).  ID="ch15513"LBL="" HELPID=""Visual Style NotesIf XmNsourcePixmapIcon is used, the colormap used for rendering is that of the DragContext's reference widget.  ID="ch15514"ID="ch15515"If the DragContext XmNblendModel is XmBLEND_NONE, and the dynamic cursor style is in use, the application must use ID="ch15516"ID="ch15517"ID="ch15518"XChangeActivePointerGrab to change the cursor.  If ID="ch15519"XmBLEND_NONE is specified, and the preregister cursor style is in use, the application can render the cursor directly onto the screen, saving and restoring the image underneath.  ID="ch15520"The cursor style can change as the pointer moves from window to window.  An application can tell which style is in use by looking at the dragProtocolStyle field in the XmNtopLevelEnterCallback† †structure, or looking at the ID="ch15521"XmNdragInitiatorProtocolStyle Display resource in the case of ID="ch15522"XmDRAG_NONE or XmDRAG_DROP_ONLY.  ID="ch15523"ID="ch15524"The resolution and best cursor size can vary from screen to screen.  This is why the default cursor icons are XmScreen resources.  An application that wants its source cursor or pixmap to be screen dependent can look for changes in the ID="ch15525"screen field in the XmNtopLevelEnterCallback struct, and update the various icon DragContext resources appropriately.  ID="ch15526"ID="ch15527"LBL="" HELPID=""Creating a Drag IconID="ch15528"ID="ch15529"Any of the three parts of a drag icon can be customized: the source icon, the state icon, and the operation icon.  Use the XmCreateDragIcon function to create any of these parts.  The ID="ch15530"ID="ch15531"XmNattachment resource is not used for the source icon.  The other resources specify pixmap, size, and hotspot details.  The DragContext ID="ch15532"XmNblendModel resource indicates which hotspot is used for the entire drag icon.  ID="ch15533"ID="ch15534"The following example from DNDDemo.c in IDREF="61196" TYPE="TITLE"Appendix B, "Drag and Drop Example Program,"
 creates a source icon from a bitmap.  The source icon is the palette and the state icon is the paintbrush.  (Actually, the state icon is not shown when the drag starts, because the blend style is XmBLEND_JUST_SOURCE.  It is shown here as if the blend style were ID="ch15535"XmBLEND_ALL.) ID="ch15536"LBL="15-13" FILE="startdra.gif" POSITION="INLINE" SCALE="FALSE"LBL="15-13"Figure 15-13 Custom Source IconThe ColorRect function is called when a drag starts from one of the color rectangles in the lower portion of the window.  Among its other duties, it establishes the drag icon from source bits from the DNDDraw.c file in IDREF="61196" TYPE="TITLE"Appendix B, "Drag and Drop Example Program."† †   /* If the server will handle a large icon, create
† †      one */
† †   if (appInfo->maxCursorWidth >= ICON_WIDTH &&
† †       appInfo->maxCursorHeight >= ICON_HEIGHT) {
† †       source_bits = SOURCE_ICON_BITS;
† †       source_mask = SOURCE_ICON_MASK;
† †       state_bits = STATE_ICON_BITS;
† †       state_mask = STATE_ICON_MASK;
† †       width = ICON_WIDTH;
† †       height = ICON_HEIGHT;
† †   }
† †   else {
† †       /* If the server will handle a small icon, create
† †          one */
† †       source_bits = SMALL_SOURCE_ICON_BITS;
† †       source_mask = SMALL_SOURCE_ICON_MASK;
† †       state_bits = SMALL_STATE_ICON_BITS;
† †       state_mask = SMALL_STATE_ICON_MASK;
† †       width = SMALL_ICON_WIDTH;
† †       height = SMALL_ICON_HEIGHT;
† †   }
† †   /* Create the drag cursor icons */
† †   sourceIcon = GetDragIconFromBits(w, source_bits,
† †                  source_mask, width, height, background,
† †                  foreground);
† †   stateIcon = GetDragIconFromBits(w, state_bits,
† †                 state_mask, width, height, background,
† †                 foreground);
† †   /* Setup the arglist for the drag context that is
† †    * created at drag start */
† †   n = 0;
† †   .
† †   .
† †   .
† †   XtSetArg(args[n], XmNsourceCursorIcon, sourceIcon); n++;
† †   XtSetArg(args[n], XmNstateCursorIcon, stateIcon); n++;
† †   .
† †   .
† †   .
† †   /* start the drag.  This creates a drag context. */
† †   myDC = XmDragStart(w, event, args, n);
}The GetDragIconFromBits function turns the bits into a bitmap.  static Widget GetDragIconFromBits(w, bits, mask, width,
† †                       height, background, foreground)
Widget w;
char *bits;
char *mask;
Dimension width;
Dimension height;
Pixel background;
Pixel foreground;
{
† †   Pixmap     icon, iconMask;
† †   Display    *display = XtDisplay(w);
† †   icon = XCreateBitmapFromData(display,
† †            DefaultRootWindow(display), bits, width,
† †            height);
† †   iconMask = XCreateBitmapFromData(display, 
† †                DefaultRootWindow(display), mask, 
† †                width, height);
† †   return(GetDragIcon(w, icon, iconMask, width, height, 
† †                      background, foreground));
}The GetDragIcon function uses the bitmap created by the GetDragIconFromBits function to create a drag icon.  static Widget GetDragIcon(w, icon, iconMask, width, height, 
† †                         background, foreground)
Widget w;
Pixmap icon;
Pixmap iconMask;
Dimension width;
Dimension height;
Pixel background;
Pixel foreground;
{
† †   Widget  dragIcon;
† †   Arg     args[10];
† †   int     n = 0;
† †   XtSetArg(args[n], XmNhotX, ICON_X_HOT); n++;
† †   XtSetArg(args[n], XmNhotY, ICON_Y_HOT); n++;
† †   XtSetArg(args[n], XmNwidth, width); n++;
† †   XtSetArg(args[n], XmNheight, height); n++;
† †   XtSetArg(args[n], XmNmaxWidth, appInfo->maxCursorWidth);
† †     n++;
† †   XtSetArg(args[n], XmNmaxHeight, appInfo->maxCursorHeight);
† †     n++;
† †   XtSetArg(args[n], XmNbackground, background); n++;
† †   XtSetArg(args[n], XmNforeground, foreground); n++;
† †   XtSetArg(args[n], XmNpixmap, icon); n++;
† †   XtSetArg(args[n], XmNmask, iconMask); n++;
† †   dragIcon = XmCreateDragIcon(w, "dragIcon", args, n);
† †   return(dragIcon);
}LBL="15.5.5" HELPID=""ID="19736"Drag CallbacksID="ch15537"Callbacks notify the initiator of how the drag is proceeding.  The receiver's XmNdragProc (if any) is first notified of the action and given a chance to update the ID="ch15538"operation, operations, and dropSiteStatus fields in its callback structure.  The new values are available to the initiator's drag callback in the appropriate callback structure.  These drag callbacks are all optional.  They enable the initiator to monitor the progress of the drag and manage its visual effects accordingly.  Otherwise, the toolkit on the initiator side handles the drag-over effects.  XmNdragMotionCallback Called when the drag icon is in motion ID="ch15539"XmNoperationChangedCallback Called when the user requests a different operation be performed on the drop than was previously in effect ID="ch15540"XmNdropSiteEnterCallback Called when the drag icon enters a drop site ID="ch15541"XmNdropSiteLeaveCallback Called when the drag icon leaves a drop site ID="ch15542"XmNtopLevelEnterCallback Called when the drag icon enters a top-level window or root window (when changing screens) ID="ch15543"XmNtopLevelLeaveCallback Called when the drag icon leaves a top-level window or root window (when changing screens) ID="ch15544"Callback structures for these routines contain information about the drag.  The callback structures for XmNdragMotionCallback, ID="ch15545"XmNoperationChangedCallback, and XmNdropSiteEnterCallback† †contain the ID="ch15546"ID="ch15547"operations, operation, and dropSiteStatus fields (among others), which are initialized by the toolkit before the callback is called.  The operations field lists all operations possible for a drop on the current site, whether the site is registered as a DropSite or not.  The toolkit initializes the ID="ch15548"operations field as follows: If the receiver's XmNdragProc was called, the value of operations† †is the list of operations common to the value of the ID="ch15549"XmNdragProc's operations field at the end of XmNdragProc and the DropSite's ID="ch15550"XmNdropSiteOperations list.  ID="ch15551"If the XmNdragProc routine was not called but the user selected an operation, operations is set to that operation if it is in the XmNdragOperations list.  If it is not in the list, ID="ch15552"operations is set to XmDROP_NOOP.  ID="ch15553"Otherwise, the operations field is initialized to the list in the DragContext's ID="ch15554"XmNdragOperations resource.  ID="ch15555"The operation field shows the operation that will occur if a drop happens at the current cursor location.  It is initialized as follows: If the receiver's XmNdragProc was called, operation is initialized to the value of ID="ch15556"operation at the end of the XmNdragProc.  If the XmNdragProc routine was not called but the pointer is in or entering an active drop site, the toolkit initializes operation by taking the following steps, in order of precedence from highest to lowest: If Move is in both the operations field and the DropSite's ID="ch15557"XmNdropSiteOperations list, operation is set to ID="ch15558"XmDROP_MOVE.  ID="ch15559"If Copy is in both the operations field and the DropSite's ID="ch15560"XmNdropSiteOperations list, operation is set to ID="ch15561"XmDROP_COPY.  ID="ch15562"If Link is in both the operations field and the DropSite's ID="ch15563"XmNdropSiteOperations list, operation is set to ID="ch15564"XmDROP_LINK.  ID="ch15565"Otherwise, operation is set to XmDROP_NOOP.  ID="ch15566"Otherwise, the toolkit initializes operation by taking the following steps, in order of precedence from highest to lowest: If Move is in the operations field, operation is set to XmDROP_MOVE.  ID="ch15567"If Copy is in the operations field, operation is set to XmDROP_COPY.  ID="ch15568"If Link is in the operations field, operation is set to XmDROP_LINK.  ID="ch15569"Otherwise, operation is set to XmDROP_NOOP.  ID="ch15570"The dropSiteStatus field in the callback structure indicates if the drag icon is over a valid drop site, an invalid drop site, or no drop site.  The callback procedure can use this information to display the appropriate drag-over visuals.  The toolkit initializes the dropSiteStatus field as follows: If the pointer is over an active drop site: If the receiver's XmNdragProc was called, dropSiteStatus is initialized to the value of ID="ch15571"dropSiteStatus at the end of the XmNdragProc procedure.  ID="ch15572"If the XmNdragProc routine was not called but the initiator and receiver have at least one target and one operation in common, dropSiteStatus is initialized to XmDROP_SITE_VALID.  ID="ch15573"Otherwise, dropSiteStatus is initialized to XmDROP_SITE_INVALID.  ID="ch15574"If the pointer is not over an active drop site, dropSiteStatus is initialized to XmNO_DROP_SITE.  ID="ch15575"If the operation field is XmDROP_NOOP, dropSiteStatus is initialized to ID="ch15576"XmDROP_SITE_INVALID.  ID="ch15577"If the application has not stored the DragContext ID in a global location, these callbacks can find the DragContext ID by passing the ID="ch15578"timeStamp field from the callback structure to the XmGetDragContext function.  ID="ch15579"This example shows a callback that is called when a new drop site is entered.  It checks the validity of the drop site, and uses one of three custom source icons, depending on the status.  static void EnterCB(w, client_data, call_data)
Widget          w;
XtPointer       client_data, call_data;
{
† †  XmDragContext                   dc;
† †  XmDropSiteEnterCallback         EnterData;
† †  Cardinal                        n;
† †  Arg                             args[MAX_ARGS];
† †  dc = (XmDragContext)w;
† †  EnterData = (XmDropSiteEnterCallback )call_data;
† †  n = 0;
† †  if (EnterData->dropSiteStatus == XmVALID_DROP_SITE) {
† †     XtSetArg(args[n], XmNsourceCursorIcon,
† †                GetValidIcon(w)); n++;
† †     XtSetValues(dc, args, n);
† †     }
† †  if (EnterData->dropSiteStatus == XmINVALID_DROP_SITE) {
† †     XtSetArg(args[n], XmNsourceCursorIcon,
† †                GetInvalidIcon(w)); n++;
† †     XtSetValues(dc, args, n);
† †     }
† †  if (EnterData->dropSiteStatus == XmNO_DROP_SITE) {
† †     XtSetArg(args[n], XmNsourceCursorIcon,
† †                GetNeutralIcon(w)); n++;
† †     XtSetValues(dc, args, n);
† †     }
}If a drag callback is desired, it is added to the DragContext's callback resources.The following example adds a callback named ID="ch15580"EnterCB that is performed when the pointer enters an active drop site: Widget       dc;
† †  dc = XmDragStart(w, event, args, n);
† †  XtAddCallback(dc, XmNdropSiteEnterCallback, EnterCB,
† †                  NULL);LBL="15.5.6" HELPID=""Getting Data about the Current Drop SiteThe initiator can find information about the current drop site with the XmDropSiteRetrieve function.  It must pass in the DragContext, so that the toolkit knows what drop site the request is for.  The initiator can find the value of any drop site resource except the callback routines ID="ch15581"ID="ch15582"The following example gets the number and list of import targets for a drop site.  The example shows a drop site enter callback, but it could be in any of the initiator's drag callbacks.  XmDropSiteEnterCallback      DragData;
† †    .
† †    .
† †    .
n = 0;
XtSetArg(args[n], XmNimportTargets, &importTargets); n++;
XtSetArg(args[n], XmNnumImportTargets,
† †          &numImportTargets); n++;
XmDropSiteRetrieve(DragData->DragContext, args, n);
ID="ch15583"LBL="15.5.7" HELPID=""Cancelling the DragID="ch15584"ID="ch15585"The drag in progress can be cancelled in either of two ways.  Both ways are treated the same by the toolkit.  The user can press KCancel.  ID="ch15586"The initiator can call the XmDragCancel function if it decides the drag should not continue for some reason.  ID="ch15587"The initiator is notified of the cancel by the XmNdropStartCallback with a dropAction field value of XmDROP_CANCEL.  ID="ch15588"The receiver is notified by a XmCR_DROP_SITE_LEAVE_MESSAGE message.  This message is processed by the ID="ch15589"XmNdragProc in the dynamic protocol mode.  This allows any drag-under effects to be undone.  ID="ch15590"LBL="15.6" HELPID=""Drop Receiver Responsibilities for DroppingID="ch15591"ID="ch15592"When the user releases the drag to start a drop, the toolkit sends a message to the receiver.  The receiver's XmNdropProc routine processes it by checking that the proposed targets and actions are valid, and updates the status and operations fields accordingly.  This information is sent back to the initiator's ID="ch15593"XmNdropStartCallback routine.  ID="ch15594"The application receiving a drop must Have registered an XmNdropProc routine to be processed when a drop is made on the site.  This is done as part of registering a widget as a drop site.  ID="ch15595"Make a list of transfer requests.  If the drop is cancelled, the number of transfer requests is set to zero.  Register a DropTransfer XmNtransferProc to process transfers from the initiator if the number of transfers is not zero.  ID="ch15596"ID="ch15597"Call XmDropTransferStart at least once, to either cancel the drop or start the transfer process.  ID="ch15598"The receiving application may also do the following: Provide drop site Help information Cancel a drop LBL="15.6.1" HELPID=""XmNdropProcWhen a drop occurs (except for a Cancel), a message is sent from the toolkit on the initiator side to the receiver, and the receiver's XmNdropProc is called.  Fields in its callback structure provide information about the drop to the receiver.  ID="ch15599"The operations, operation, and dropSiteStatus fields are initialized by the toolkit in a similar manner to that described for the receiver's XmNdragProc earlier in this chapter.  ID="ch15600"The XmNdropProc routine can update the operations, ID="ch15601"operation, and dropSiteStatus fields further.  The final values are available to the initiator in its drop callback structures.  The dropAction field indicates if a normal drop is requested, or if the user requested help.  For information about processing a help request, refer to IDREF="36065" TYPE="TITLE"Section 15.6.4, "Providing Help."If the receiver takes too long before ending the XmNdropProc† †routine, the toolkit will cause the drag to time out.  Therefore, if the receiver needs to do any processing before the transfer other than verifying that a transfer can take place, it should start a new process and end the ID="ch15602"XmNdropProc routine.  ID="ch15603"Either the XmNdropProc routine or one of its subprocedures must start a transfer by calling ID="ch15604"XmDropTransferStart.  The initiator waits for a transfer request to finish its part in the drop.  If a drop is not possible, the drop is cancelled as described below.  If a drop is possible, the ID="ch15605"XmNdropProc routine provides the appropriate details to start the transfer.  ID="ch15606"The XmNdropProc procedure creates a list of DropTransfer entries containing target and client-specific information for each transfer desired.  There is a separate entry for each data-target type combination.  For example, if the data is desired in both TEXT and COMPOUND_TEXT forms, there would be two entries on the list.  This list and the number of items in the list are used by ID="ch15607"ID="ch15608"ID="ch15609"ID="ch15610"XmDropTransferStart to start the transfer.  ID="ch15611"The receiver establishes the values of the DropTransfer resources before calling ID="ch15612"XmDropTransferStart.  Following are the DropTransfer resources: ID="ch15613"XmNdropTransfers The list of drag transfer entries.  ID="ch15614"XmNincremental Whether to use the incremental transfer mechanism.  ID="ch15615"XmNnumDropTransfers The number of transfer entries in the list.  This number is decremented each time a transfer is made.  ID="ch15616"XmNtransferProc The procedure to process transferred information.  This procedure is an ID="ch15617"XtSelectionCallbackProc procedure.  For more information about ID="ch15618"XtSelectionCallbackProc, see X Toolkit Intrinsicsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'C Language Interface.  XmNtransferStatus Whether the transfer failed or not.  The default value is ID="ch15619"XmTRANSFER_SUCCESS.  ID="ch15620"The following example from DNDlabel.c in IDREF="42149" TYPE="TITLE""A Simple Drag Receiver"
 creates a transfer request list of one transfer entry, asking that the initiator send its data in compound text format.  Copy is the only action it accepts; the rest result in a cancelled drop.  The DropTransferCallback routine receives and processes the data from the initiator.  static void HandleDrop(w, client_data, call_data)
Widget          w;
XtPointer       client_data, call_data;
{
† †  XmDropProcCallback      DropData;
† †  XmDropTransferEntryRec  transferEntries[2];
† †  XmDropTransferEntry     transferList;
† †  Arg                     args[MAX_ARGS];
† †  int                     n;
† †  DropData = (XmDropProcCallback)call_data;
† †  /* set the transfer resources */
† †  n = 0; 
† †  /* if the action is Help, or the operation is not Copy, 
† †   *cancel the drop */
† †  if ((DropData->dropAction != XmDROP) ||
† †      (DropData->operation != XmDROP_COPY)) 
† †     XtSetArg(args[n], XmNtransferStatus,
† †                XmTRANSFER_FAILURE); n++;
† †  else {
† †     /* the drop can continue.  Establish the transfer list
† †      * and start the transfer */
† †     transferEntries[0].target = COMPOUND_TEXT;
† †     transferEntries[0].client_data = (XtPointer)w;
† †     transferList = transferEntries;
† †     XtSetArg(args[n], XmNdropTransfers, transferList); n++;
† †     XtSetArg(args[n], XmNnumDropTransfers, 1); n++;
† †     XtSetArg(args[n], XmNtransferProc,
† †                DropTransferCallback); n++;
† †     }
† †  /* start the transfer or cancel */ 
† †  XmDropTransferStart(DropData->dragContext, args, n);
}If the program could accept transfers in more than one target type, for example, TEXT and COMPOUND_TEXT, then a separate transfer entry is needed for each request: ID="ch15621"ID="ch15622"transferEntries[0].target = COMPOUND_TEXT;
transferEntries[1].target = TEXT;
† †    .
† †    .
† †    .
XtSetArg(args[n], XmNnumDropTransfers, 2); n++;LBL="15.6.2" HELPID=""XmDropTransferID="ch15623"ID="ch15624"ID="ch15625"ID="ch15626"The toolkit on the receiver side is in charge of the transfer procedure.  Information about the transfer is stored in a DropTransfer widget, which is created by the ID="ch15627"XmDropTransferStart routine.  ID="ch15628"Before calling XmDropTransferStart, the receiver stores a list of DropTransfer transfer entries in the ID="ch15629"ID="ch15630"XmNdropTransfers resource.  Each entry contains target and client-specific information for each transfer desired.  It also registers a procedure to receive transfers from the initiator in the ID="ch15631"XmNtransferProc resource.  These resources, along with the other DropTransfer resources, are used by the ID="ch15632"ID="ch15633"XmDropTransferStart function.  ID="ch15634"The toolkit processes the items on the list, one at a time, decrementing XmNnumDropTransfers each time.  When the ID="ch15635"XmNnumDropTransfers value is zero, the drop is finished.  The toolkit on the receiver side sends a message to the initiator, whose ID="ch15636"XmNdropFinishCallback is then called.  ID="ch15637"If XmNincremental is True, the Xt selection incremental transfer protocol is used between the toolkit and the receiver, regardless of what the initiator sent.  Refer to the Xt documentation for details of how to use incremental transfer.  If the value is False, the transfer between the toolkit and the receiver is made in one pass, regardless of how the initiator sent it.  ID="ch15638"The XmNtransferProc routine receives each transfer from the initiator.  If more than one target type is acceptable to the receiver, this procedure needs to check which target type was used in this transfer, and process the transferred data accordingly.  ID="ch15639"The XmNtransferProc routine can examine and update the DropTransfer resources during the transfer with ID="ch15640"ID="ch15641"XtGetValues and XtSetValues.  ID="ch15642"ID="ch15643"The XmDropTransferAdd routine is used to add to the transfer list after the transfer has begun.  For example, this routine is used when a Move operation is performed, to add a new transfer entry record telling the initiator to delete the data.  It can be used in other situations where the entire transfer list is not known when ID="ch15644"XmDropTransferStart is called.  ID="ch15645"If there are problems with the drop, it can be cancelled as described later in the chapter.  The following example from DNDlabel.c in IDREF="42149" TYPE="TITLE""A Simple Drag Receiver"
 receives compound string data from the initiator, and uses it to replace the label of the Label widget.  static void TransferProc(w, closure, seltype, type,
† †                          value, length, format) 
Widget           w;
XtPointer        closure;
Atom             *seltype;
Atom             *type;
XtPointer        value;
unsigned long    *length;
int              format;
{
† †  int         n;
† †  Arg         args[MAX_ARGS];
† †  /* information from the drag initiator is passed in
† †   * compound  text format.  Convert it to compound string
† †   * and replace the Label label. */
† †  if (*type = COMPOUND_TEXT) {
† †     n = 0;
† †     XtSetArg(args[n], XmNlabelString,
† †                XmCvtCTToXmString(value)); 
† †     n++;
† †     XtSetValues(closure, args, n);
† †     } 
}If the program is able to handle more than one target type, this routine needs to check for them all.  For instance: † †  if (*type = COMPOUND_TEXT) {
† †     /* code to change the label to the compound text
† †        passed */
† †     }
† †  else if (*type = TEXT) {
† †     /* code to change the label to the text passed */
† †     }LBL="" HELPID=""Processing Each OperationThe XmNtransferProc routine must be able to process the data from the initiator correctly for each operation listed in the DropSite ID="ch15646"ID="ch15647"XmNdropSiteOperations resource: ID="ch15648"If the operation is Copy, the value field contains a pointer to the data from the initiator.  It is used to assign the value to some element in the receiver's program.  The example in the previous section shows a Copy in effect.  When the transfer is finished, both the initiator and receiver have the data in each of their applications.  If the operation is Move, data is first copied to the receiver, then deleted from the initiator.  It is important that the initiator not delete the data before the receiver has it.  Therefore, a Move is a two-step process: The first transfer is processed by the initiator like a Copy.  It returns a pointer to the data in the value field.  When the XmNtransferProc routine has the data, it uses ID="ch15649"XmDropTransferAdd to make a new transfer entry for that data, setting the ID="ch15650"target to DELETE.  The initiator will not delete the data until the receiver has issued this second transfer request.  ID="ch15651"At the end of the transfer, the receiver has the only copy of the data.  If the operation is Link, the pointer is used to link an element in the receiver to the data.  At the end of the operation, there is only one copy of the data, belonging to the initiator, but both applications have access to it.  LBL="15.6.3" HELPID=""ID="22706"Cancelling a DropID="ch15652"ID="ch15653"A drop can be cancelled only by the receiver,  from the XmNdropProc† †procedure or any subroutine it calls, such as ID="ch15654"XmNtransferProc.  To cancel a drop: ID="ch15655"Set the XmNnumDropTransfers DropTransfer resource to zero.  This tells the toolkit that there are no more transfers to make and the drop is complete.  ID="ch15656"ID="ch15657"Set the XmNtransferStatus to XmTRANSFER_FAILURE.  This information is passed to the initiator in the ID="ch15658"ID="ch15659"XmNdropFinishedCallback† †structure.  ID="ch15660"Call the XmDropTransferStart function from the ID="ch15661"XmNdropProc routine, or exit a subroutine called by the XmNdropProc procedure.  ID="ch15662"The transfer will be cancelled at the next transfer request.  The drop is over, and the initiator's XmNdropFinishCallback and ID="ch15663"XmNdragDropFinishCallback routines are called.  ID="ch15664"The following example is from a program's XmNdropProc routine: ID="ch15665"XtSetArg(args[n], XmNtransferStatus,
† †          XmTRANSFER_FAILURE); n++;
XtSetArg(args[n], XmNnumDropTransfers, 0); n++;
XmDropTransferStart(DropData->dragContext, args, n);LBL="15.6.4" HELPID=""ID="36065"Providing HelpID="ch15666"It might not always be obvious to the user what the result of dropping a particular source on a drop site might be.  The user can request more information about the drop site by pressing KHelp while the drag icon is over the drop site.  ID="ch15667"When the user presses KHelp, the receiver's XmNdropProc† †routine is called with a value of ID="ch15668"XmDROP_HELP† †in the ID="ch15669"dropAction field of its callback structure.  If the receiver supports help, it should post a dialog, providing information about the type of drop this site expects, and what it will do when a successful drop occurs.  The receiver should then exit the XmNdropProc routine without waiting for a response from the user.  When the ID="ch15670"XmNdropProc routine has finished, the initiator's XmNdropStartCallback is called with a ID="ch15671"dropAction of XmDROP_HELP if the initiator has registered that callback.  The initiator is not expected to do anything at this point, but it could provide special processing such as changing the drag icon.  ID="ch15672"Typically, the help dialog allows the user the opportunity to continue the drop or to cancel the drop.  If more than one operation is possible, the dialog should explain the consequences of each operation and let the user select one.  The dialog procedure may change the operation based on the user's selection: If the user indicates that the drop should be cancelled, the receiver's help procedure should cancel the drop by requesting no transfers, as described in the previous section, IDREF="22706" TYPE="TITLE"Section 15.6.3, "Cancelling a Drop."If the user indicates that the drop should continue, the help procedure should call XmDropTransferStart to begin the transfer of information from the initiator.  ID="ch15673"In either case, the help procedure must call XmDropTranferStart before it ends to either start the transfers or notify the initiator that no transfers will be requested.  ID="ch15674"The receiver may want to issue help information if a drop is considered invalid, even if the user has not requested it.  If so, the receiver's XmNdropProc sets the dropAction field to XmDROP_HELP, and displays the help dialog as if help had been requested.  ID="ch15675"ID="ch15676"The following example taken from DNDDemo.c in IDREF="61196" TYPE="TITLE"Appendix B, "Drag and Drop Example Program,"
 shows how the help dialog shown in the illustration was created.  LBL="15-14" FILE="dndhelp.gif" POSITION="INLINE" SCALE="FALSE"LBL="15-14"Figure 15-14 Help DialogThe XmDropProc† †DropProcCallback routine checks if the drop is normal or if there is a request for help.  static void DropProcCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
† †   XmDropProcCallbackStruct *cb = 
† †                (XmDropProcCallbackStruct *)call;
† †   if (appInfo->highlightRect != NULL)
† †       RectUnhighlight(w);
† †   if (cb->dropAction != XmDROP_HELP)
† †       HandleDrop(w, call);
† †   else
† †       HandleHelp(w, call);
}The HandleHelp routine displays the help dialog.  The text presented in the dialog depends on the drop site and the operation.  Callback routines are registered to be performed when either of the dialog pushbuttons is pressed.  static void HandleHelp(w, call)
Widget w;
XtPointer call;
{
† †   XmDropProcCallbackStruct *cb =
† †                    (XmDropProcCallbackStruct *)call;
† †   static XmDropProcCallbackStruct client;
† †   Boolean                 rectFound, bgFound, pixFound;
† †   XmString                helpStr;
† †   RectPtr                 rect;
† †   Arg                     args[5];
† †   XmString                tempStr, buttonArray[2];
† †   int                     n = 0;
† †   /* the drop is valid until it is determined invalid */
† †   cb->dropSiteStatus = XmVALID_DROP_SITE;
† †   /* if we haven't created a help dialog, create one now */
† †   if (helpDialog == NULL) {
† †       XtSetArg(args[n], XmNdialogStyle, 
† †            XmDIALOG_FULL_APPLICATION_MODAL); n++;
† †       XtSetArg(args[n], XmNtitle, "Drop Help"); n++;
† †       helpDialog = XmCreateMessageDialog(topLevel, "Help", 
† †            args, n);
† †       n = 0;
† †       buttonArray[0] = XmStringCreateSimple("Move");
† †       buttonArray[1] = XmStringCreateSimple("Copy");
† †       XtSetArg(args[n], XmNbuttons, buttonArray); n++;
† †       XtSetArg(args[n], XmNbuttonCount, 2); n++;
† †       XtSetArg(args[n], XmNbuttonSet, 0); n++;
† †       XtSetArg(args[n], XmNsimpleCallback,
† †                  ChangeOperation); n++;
† †       tempStr = XmStringCreateSimple("Operations:");
† †       XtSetArg(args[n], XmNoptionLabel, tempStr); n++;
† †       helpMenu = XmCreateSimpleOptionMenu(helpDialog,
† †                       "helpMenu", args, n);
† †       XmStringFree(tempStr);
† †       XmStringFree(buttonArray[0]);
† †       XmStringFree(buttonArray[1]);
† †       XtAddCallback(helpDialog, XmNokCallback,
† †            (XtCallbackProc) HandleOK, (XtPointer) &client);
† †       XtAddCallback(helpDialog, XmNcancelCallback,
† †            (XtCallbackProc) CancelDrop,
† †            (XtPointer) &client);
† †       XtUnmanageChild(XmMessageBoxGetChild(helpDialog, 
† †            XmDIALOG_HELP_BUTTON));
† †       XtRealizeWidget(helpDialog);
† †   }
† †   /* pass the necessary callback information along */
† †   client.dragContext = cb->dragContext;
† †   client.x = cb->x;
† †   client.y = cb->y;
† †   client.dropSiteStatus = cb->dropSiteStatus;
† †   client.operation = cb->operation;
† †   client.operations = cb->operations;
† †   /* find the valid targets */
† †   CheckTargets(cb->dragContext, XtDisplay(w),
† †                  &rectFound, &bgFound, &pixFound);
† †   /* determine the appropriate help message */
† †   if (rectFound) {
† †       if (cb->operations == XmDROP_MOVE | XmDROP_COPY) {
† †           XtManageChild(helpMenu);
† †           helpStr = XmStringCreateLtoR(HELP_MSG4, 
† †                XmFONTLIST_DEFAULT_TAG);
† †           XtManageChild(XmMessageBoxGetChild(helpDialog, 
† †                XmDIALOG_OK_BUTTON));
† †       }
† †       else if (cb->operation == XmDROP_MOVE) {
† †           XtUnmanageChild(helpMenu);
† †           helpStr = XmStringCreateLtoR(HELP_MSG2, 
† †                XmFONTLIST_DEFAULT_TAG);
† †           XtManageChild(XmMessageBoxGetChild(helpDialog, 
† †                XmDIALOG_OK_BUTTON));
† †       }
† †       else if (cb->operation == XmDROP_COPY) {
† †           XtUnmanageChild(helpMenu);
† †           helpStr = XmStringCreateLtoR(HELP_MSG3, 
† †                XmFONTLIST_DEFAULT_TAG);
† †           XtManageChild(XmMessageBoxGetChild(helpDialog, 
† †                XmDIALOG_OK_BUTTON));
† †       }
† †   }
† †   else if (bgFound ||
† †            pixFound && cb->operation == XmDROP_COPY) {
† †       XtUnmanageChild(helpMenu);
† †       rect = RectFind(cb->x, cb->y);
† †       if (rect) {
† †           helpStr = XmStringCreateLtoR(HELP_MSG1, 
† †                XmFONTLIST_DEFAULT_TAG);
† †           XtManageChild(XmMessageBoxGetChild(helpDialog, 
† †                XmDIALOG_OK_BUTTON));
† †       }
† †       else {
† †           helpStr = XmStringCreateLtoR(HELP_MSG5, 
† †                XmFONTLIST_DEFAULT_TAG);
† †           XtUnmanageChild(XmMessageBoxGetChild(helpDialog, 
† †                XmDIALOG_OK_BUTTON));
† †       }
† †   }
† †   else {
† †       XtUnmanageChild(helpMenu);
† †       helpStr = XmStringCreateLtoR(HELP_MSG5, 
† †            XmFONTLIST_DEFAULT_TAG);
† †       XtUnmanageChild(XmMessageBoxGetChild(helpDialog, 
† †            XmDIALOG_OK_BUTTON));
† †   }
† †   /* set the help message into the dialog */
† †   XtSetArg(args[0], XmNmessageString, helpStr);
† †   XtSetValues(helpDialog, args, 1);
† †   /* Free the XmString */
† †   XmStringFree(helpStr);
† †   /* map the help dialog */
† †   XtManageChild(helpDialog);
}The HandleOK callback routine is performed when the user selects the OK button.  It allows the drop to continue normally by calling the HandleDrop routine.  static void HandleOK(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
† †   XmDropProcCallbackStruct *cb =
† †               (XmDropProcCallbackStruct *)client;
† †   cb->operation = appInfo->operation;
† †   HandleDrop(w, (XtPointer) cb);
}The CancelDrop callback routine is performed when the user selects the Cancel button.  It cancels the drop by calling XmDropTransferStart† †with indicators that the drop failed.  ID="ch15677"static void CancelDrop(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
{
† †   XmDropProcCallbackStruct *cb =
† †                      (XmDropProcCallbackStruct *)client;
† †   Arg                args[2];
† †   /* On help, we need to cancel the drop transfer */
† †   XtSetArg(args[0], XmNtransferStatus,
† †              XmTRANSFER_FAILURE);
† †   XtSetArg(args[1], XmNnumDropTransfers, 0);
† †   /* we need to start the drop transfer to cancel
† †      the transfer */
† †   XmDropTransferStart(cb->dragContext, args, 2);
}LBL="15.7" HELPID=""Drag Initiator Responsibilities for DroppingID="ch15678"ID="ch15679"The drag initiator Registers an XmNconvertProc procedure to format data and send the formatted data to the receiver.  ID="ch15680"Optionally, registers an XmNdropStartCallback to be performed at the drop.  ID="ch15681"Optionally, registers an XmNdropFinishCallback to be performed after the drop and transfer have finished.  ID="ch15682"Optionally, registers an XmNdragDropFinishCallback to be performed after the entire drag and drop transaction has finished.  ID="ch15683"LBL="15.7.1" HELPID=""XmNdropStartCallbackThe receiver's XmNdropProc routine receives the drop message first if the drop occurred over a widget that was registered as a drop site.  It verifies that a drop is possible, and updates fields in its callback structure.  These fields become available to the initiator in its ID="ch15684"XmNdropStartCallback callback structure.  The initiator can perform any actions necessary before the information is transferred, for example, providing a new drag icon.  ID="ch15685"The toolkit initializes the operation, operations, and dropSiteStatus fields as described in IDREF="19736" TYPE="TITLE"Section 15.5.5, "Drag Callbacks,"
 with one difference: the initialization for the drag callbacks uses the values at the end of the receiver's XmNdragProc, while the initialization for the drop callbacks uses the values at the end of the receiver's ID="ch15686"XmNdropProc.  ID="ch15687"The dropAction field indicates the action that the receiver has taken.  XmDROP shows that a normal drop is in progress.  ID="ch15688"XmDROP_CANCEL shows that the receiver has cancelled the drop.  If the action is ID="ch15689"XmDROP_HELP, the initiator is not expected to do anything, although this callback provides the opportunity to do so if desired (for example, changing the drag icon to reflect the Help request).  ID="ch15690"This procedure will not know the resolution of the help dialog.  However, if the user chooses to continue, the initiator's XmNconvertProc routine is called as part of the transfer process, and if the user chooses to cancel, the receiver's ID="ch15691"XmNdropFinishCallback is called with a ID="ch15692"dropAction of XmDROP_CANCEL.  ID="ch15693"LBL="15.7.2" HELPID=""Dealing with Requests for TransferID="ch15694"ID="ch15695"The drag initiator must register a callback to process transfers in the XmNconvertProc DragContext resource.  This routine is called when the receiver client invokes ID="ch15696"ID="ch15697"XmDropTransferStart.  Before calling XmDropTransferStart, the receiver makes a list of the target formats it wants.  ID="ch15698"ID="ch15699"ID="ch15700"ID="ch15701"The initiator's XmNconvertProc callback routine processes transfer requests from the receiver.  The routine should be able to return information about each object being dragged in each possible target format for that item.  ID="ch15702"If the DropTransfer XmNincremental resource is True, information is transferred between the initiator and the toolkit using the Xt selection incremental protocol.  If the value is False, the information is transferred between the initiator and the toolkit in one pass.  The initiator and receiver need not be using the same incremental or nonincremental protocol.  ID="ch15703"ID="ch15704"The XmNconvertProc routine is called for each target type desired by the receiver, a single target type for each request.  The ID="ch15705"XmNconvertProc routine should be able to perform any of the operations listed in the DragContext's ID="ch15706"XmNdragOperations† †resource on data in any of the target types listed in the ID="ch15707"ID="ch15708"XmNexportTargets resource: ID="ch15709"If the operation is Copy or Link, the XmNconvertProc returns a pointer to the data.  The receiver will use this pointer to copy this data into its own storage, or establish a link using this pointer.  ID="ch15710"If the operation is Move, the first transfer request has a normal target type.  The XmNconvertProc routine should return a pointer to the data, as it would for a Copy.  ID="ch15711"A second transfer request for the data has a target type of DELETE.  The receiver does not issue this request until it has received the data and handled it appropriately (such as storing it in a file).  Only then should the initiator delete the data.  ID="ch15712"In the following example from DNDscroll.c in IDREF="17919" TYPE="TITLE""A Simple Drag Source"
 the routine returns the value of the scrollbar slider in only one target type, compound text.  This information is passed to the receiver's XmNtransferProc† †routine.  This routine is called once for each item in the receiver's ID="ch15713"XmNdropTransfers list.  Copy is the only operation allowed by the application, so this routine need not process any delete requests from the receiver.  ID="ch15714"static
Boolean DragConvertProc(w, selection, target, typeRtn, 
† †                       valueRtn, lengthRtn, formatRtn, 
† †                       max_lengthRtn, client_data, 
† †                       request_id)
Widget              w;
Atom                *selection;
Atom                *target;
Atom                *typeRtn;
XtPointer           *valueRtn;
unsigned long       *lengthRtn;
int                 *formatRtn;
unsigned long       *max_lengthRtn;
XtPointer           client_data;
XtRequestId         *request_id;
{
† †  XmString    cstring;
† †  static char tmpstring[100];
† †  int         *value;
† †  int         n;
† †  Arg         args[MAX_ARGS];
† †  char          *ctext;
† †  char        *passtext;
† †  /* this routine processes only compound text */
† †  if (*target != COMPOUND_TEXT)
† †     return(False);
† †  /* get the value of the scrollbar slider */
† †  n = 0;
† †  XtSetArg(args[n], XmNvalue, &value); n++;
† †  XtGetValues(scrollbar, args, n);
† †  /* convert the slider value to compound text */
† †  sprintf(tmpstring, "%d", value);
† †  cstring = XmStringCreateLocalized(tmpstring);
† †  ctext = XmCvtXmStringToCT(cstring);
† †  passtext = XtMalloc(strlen(ctext)+1);
† †  memcpy(passtext, ctext, strlen(ctext)+1);
† †  /* Format the value for transfer.  Convert the value
† †   * from compound string to compound text for the
† †   * transfer */
† †  *typeRtn = COMPOUND_TEXT;
† †  *valueRtn = (XtPointer) passtext;
† †  *lengthRtn = strlen(passtext);
† †  *formatRtn = 8;
† †  return(True);
}If the DNDscroll.c program in IDREF="17919" TYPE="TITLE""A Simple Drag Source"
 processed more than one target, such as text and compound text, then this routine would have to handle both types.  For example: if (*target = COMPOUND_TEXT) {
† †  /* processing to convert the slider to compound string
† †     format */
† †  }
else if (*target = TEXT) {
† †  /* processing to convert the slider to text format */
† †  }
else
† †  return(False);LBL="15.7.3" HELPID=""XmNdropFinishCallbackThe XmNdropFinishCallback is called when the receiver's ID="ch15715"XmNtransferProc routine has finished processing all the transfers desired by the receiver.  ID="ch15716"The completionStatus field indicates whether the entire drop was successful or not.  The operations, operation, dropSiteStatus, and dropAction fields are initialized as for the XmNdropStartCallback procedure.  ID="ch15717"LBL="15.7.4" HELPID=""XmNdragDropFinishCallbackThe XmdragDropFinishCallback† †routine is performed when the complete drag and drop transaction has finished.  This routine is called immediately after the initiator's ID="ch15718"XmNdropFinishCallback has finished.  The initiator frees any remaining structures it has allocated during the drag.  ID="ch15719"The following sample code destroys any cursor icons that were created during the drag: static void DnDFinishCallback(w, client_data, call_data)
Widget          w;
XtPointer       client_data, call_data;
{
† †  XmDragContext    dc;
† †  Widget           source_icon, state_icon, op_icon;
† †  Arg              args[MAX_ARGS];
† †  int              n;
† †  dc = (XmDragContext)w;
† †  source_icon = state_icon = op_icon = NULL;
† †  n = 0;
† †  XtSetArg(args[n], XmNsourceCursorIcon,
† †             &source_icon); n++;
† †  XtSetArg(args[n], XmNstateCursorIcon,
† †             &state_icon); n++;
† †  XtSetArg(args[n], XmNoperationCursorIcon,
† †             &op_icon); n++;
† †  XtGetValues(dc, args, n);
† †  if (source_icon != NULL)
† †     XtDestroyWidget(source_icon);
† †     if (state_icon != NULL)
† †        XtDestroyWidget(state_icon);
† †     if (op_icon != NULL)
† †        XtDestroyWidget(op_icon);
}LBL="16"ID="22739"Interclient CommunicationID="ch161"A Motif application can communicate with another application in a variety of circumstances: When negotiating with a window manager such as MWM When the user makes or transfers a primary, secondary, or clipboard selection When the user drags data from one application and drops it in another When the application deals with a resource that is shared with other clients on the display, such as input focus, the pointer, grabs, and colormaps The X Consortium Standard Inter-Client Communication Conventions Manual (ICCCM) defines standards by which X clients should communicate with each other.  The Motif toolkit and MWM comply with ICCCM.  Applications may define private protocols for communicating with other applications that share those protocols.  If they do so, they should also conform to ICCCM standards.  ID="ch162"ID="ch163"LBL="16.1" HELPID=""Window Managers, ICCCM, and ShellsID="ch164"ID="ch165"ICCCM defines protocols for communication between clients and window managers.  Most of the communication takes place through properties on an application's top-level windows.  The window manager can also generate events that are available to the application.  In Motif and Xt, shells handle most communication between an application and a window manager.  An application seldom has to deal directly with properties or events.  The application can usually specify properties by setting resources of a shell.  Shells also select for and handle most events from the window manager.  ID="ch166"This section discusses the relations between some shell resources, properties, and events concerned with communication between an application and any window manager.  The following section discusses resources, properties, and events that apply to MWM in particular.  LBL="16.1.1" HELPID=""Application StartupID="ch167"ID="ch168"When a top-level window is mapped, the window manager may search the resource database for information about the window.  The resource name and class come from the WM_CLASS property for the window.  This property contains two consecutive strings that identify the instance and class names.  ID="ch169"Xt sets the WM_CLASS property when a shell that is a subclass of ID="ch1610"WMShell is realized.  The instance name is the name of the shell.  For an ApplicationShell, this is generally the name of the application passed to ID="ch1611"ID="ch1612"XtDisplayInitialize.  The class name is the application class from the highest-level widget in the hierarchy.  For an ApplicationShell, this is generally the application class passed to ID="ch1613"XtDisplayInitialize.  If the root widget is not an ApplicationShell, the class name is the widget's class name.  Most window managers display a name for a top-level window, often in a title bar.  The window name comes from the WM_NAME property.  This property is a string whose encoding is identified by the type of the property.  ID="ch1614"A Motif application specifies a window name using the WMShell resources ID="ch1615"XmNtitle and XmNtitleEncoding.  If the shell is a TopLevelShell subclass and the ID="ch1616"ID="ch1617"XmNiconName† †resource is not NULL, the value of that resource is the default for ID="ch1618"ID="ch1619"XmNtitle.  Otherwise, the default title is the name of the shell.  For a dialog, an application can supply a title as the value of the BulletinBoard resource XmNdialogTitle.  ID="ch1620"ID="ch1621"XmNtitleEncoding is an atom representing the encoding of the name.  The default title encoding depends on whether or not a language procedure has been set.  If no language procedure has been set, the default is STRING.  If a language procedure has been set, the title is assumed to be in the encoding of the locale and is passed to ID="ch1622"ID="ch1623"XmbTextListToTextProperty† †with an encoding style of ID="ch1624"XStdICCTextStyle.  The returned property is used as the WM_NAME property.  If the title is fully convertible to type STRING, the encoding is STRING; otherwise, the encoding is COMPOUND_TEXT.  ID="ch1625"ID="ch1626"ID="ch1627"ID="ch1628"LBL="16.1.2" HELPID=""Window ConfigurationID="ch1629"ID="ch1630"A window manager can assign any position and size to a window.  The user and application can supply preferred positions and sizes, but the window manager is free to use or ignore these as it wishes.  The user generally specifies position and size using the -geometry option when invoking the command that starts the application.  In Motif, the value specified for -geometry becomes the value of the Shell XmNgeometry resource.  An application should never set this resource itself; it should reserve it for the user.  An application specifies size and position by supplying values for the Core resources ID="ch1631"ID="ch1632"XmNx, XmNy, XmNheight, XmNwidth, and ID="ch1633"ID="ch1634"ID="ch1635"ID="ch1636"ID="ch1637"XmNborderWidth.  When an x, y, width, or height value is specified for both ID="ch1638"XmNgeometry and one of the specific geometry resources, the value from ID="ch1639"XmNgeometry takes precedence.  The MWM positionIsFrame resource determines whether MWM interprets x and y values as referring to the upper left corner of the client window itself or the upper left corner of the frame that MWM puts around the client window.  By default x and y values refer to the frame.  ID="ch1640"ID="ch1641"ID="ch1642"When a top-level window is mapped, MWM uses the following order of precedence in determining size and position: If the user specifies position and size using the -geometry option, MWM uses those values.  If the MWM interactivePlacement resource is True, MWM waits for the user to select a position using a button press for the upper left corner of the window.  If the user drags the pointer down and to the right with the mouse button pressed, the user can then determine the size of the window by releasing the mouse button.  If the user does not determine a size in this way, MWM uses the window's ID="ch1643"XmNwidth and XmNheight.  ID="ch1644"ID="ch1645"If the MWM usePPosition resource is True, or if usePPosition† †is ID="ch1646"ID="ch1647"nonzero and the window's XmNx or XmNy is nonzero, MWM uses the window's ID="ch1648"ID="ch1649"XmNx and XmNy to position the window.  MWM uses the window's XmNwidth and XmNheight for the window's size.  If the MWM ID="ch1650"ID="ch1651"positionOnScreen resource is True and if the window would be completely off the screen, MWM alters the window position so that at least part of the window is on the screen.  ID="ch1652"If the MWM clientAutoPlace resource is True, MWM positions the window with its top left corner offset horizontally and vertically from the last client mapped.  MWM uses the window's ID="ch1653"XmNwidth and XmNheight for the window's size.  ID="ch1654"ID="ch1655"MWM positions the window in the upper left corner of the screen and uses the window's XmNwidth and XmNheight for the window's size.  ID="ch1656"ID="ch1657"Before a window is mapped, the application communicates additional position and size information to the window manager through the WM_NORMAL_HINTS property on the window.  This property is of type WM_SIZE_HINTS and contains a number of fields derived from WMShell resources: ID="ch1658"ID="ch1659"ID="ch1660"XmNminHeight, XmNminWidth Specifies the minimum height and width that the application wants the widget's window to have.  If an initial value is supplied for one of these resources but not for the other, the value of the unspecified resource is set to 1 when the widget is realized.  If no value is specified for either resource, MWM uses the values from ID="ch1661"ID="ch1662"XmNbaseHeight and XmNbaseWidth if specified.  Otherwise, MWM uses a minimum height and width of at least 1.  ID="ch1663"ID="ch1664"XmNmaxHeight, XmNmaxWidth Specifies the maximum height and width that the application wants the widget's window to have.  If an initial value is supplied for one of these resources but not for the other, the value of the unspecified resource is set to 32767 when the widget is realized.  If the MWM resource ID="ch1665"ID="ch1666"maximumClientSize is specified, MWM uses that value to determine the maximum window size.  Otherwise, MWM uses the maximum height and width from the WM_NORMAL_HINTS property, except that the window size may not exceed the height and width specified by the MWM ID="ch1667"ID="ch1668"maximumMaximumSize resource.  ID="ch1669"XmNbaseHeight, XmNbaseWidth Specifies the base for a progression of preferred heights and widths for the window manager to use in sizing the widget.  The preferred heights are ID="ch1670"ID="ch1671"XmNbaseHeight plus integral multiples of ID="ch1672"XmNheightInc, with a minimum of XmNminHeight and a maximum of ID="ch1673"ID="ch1674"XmNmaxHeight.  The preferred widths are ID="ch1675"XmNbaseWidth plus integral multiples of ID="ch1676"XmNwidthInc, with a minimum of XmNminWidth and a maximum of ID="ch1677"ID="ch1678"XmNmaxWidth.  If an initial value is supplied for one of these resources but not for the other, the value of the unspecified resource is set to 0 when the widget is realized.  If no value is specified for either resource, MWM uses the values from ID="ch1679"XmNminHeight and XmNminWidth if specified.  Otherwise, MWM uses a base height and width of at least 1.  ID="ch1680"ID="ch1681"XmNheightInc, XmNwidthInc Specifies the increment for a progression of preferred heights and widths for the window manager to use in sizing the widget.  The preferred heights are ID="ch1682"ID="ch1683"XmNbaseHeight plus integral multiples of ID="ch1684"XmNheightInc, with a minimum of XmNminHeight and a maximum of ID="ch1685"ID="ch1686"XmNmaxHeight.  The preferred widths are ID="ch1687"XmNbaseWidth plus integral multiples of ID="ch1688"XmNwidthInc, with a minimum of XmNminWidth and a maximum of ID="ch1689"ID="ch1690"XmNmaxWidth.  If an initial value is supplied for one of these resources but not for the other, the value of the unspecified resource is set to 1 when the widget is realized.  If no value is specified for either resource, MWM uses an increment of 1.  ID="ch1691"XmNminAspectX, XmNminAspectY Specifies the numerator and denominator of the minimum aspect ratio (X/Y) that the application wants the widget's window to have.  If no value is specified for either resource, MWM imposes no minimum aspect ratio.  ID="ch1692"ID="ch1693"XmNmaxAspectX, XmNmaxAspectY Specifies the numerator and denominator of the maximum aspect ratio (X/Y) that the application wants the widget's window to have.  If no value is specified for either resource, MWM imposes no maximum aspect ratio.  ID="ch1694"ID="ch1695"XmNwinGravitySpecifies the window gravity for use by the window manager in positioning the widget.  If no initial value is specified, the value is set when the widget is realized.  If ID="ch1696"XmNgeometry is not NULL, XmNwinGravity is set to the window gravity returned by ID="ch1697"ID="ch1698"XWMGeometry.  Otherwise, ID="ch1699"XmNwinGravity is set to NorthWestGravity.  ID="ch16100"ID="ch16101"After a window is mapped, an application can request changes to window size or position by calling XtSetValues for one or more of the Core geometry resources.  A user can generally employ window manager facilities to move or resize a top-level window.  ID="ch16102"ID="ch16103"Calling XtSetValues for a geometry resource generates a geometry request that may propagate up the widget hierarchy to the shell.  This may cause the shell to make its own geometry request, and this invokes the shell's ID="ch16104"root_geometry_manager procedure.  This procedure uses ID="ch16105"ID="ch16106"XConfigureWindow to ask the window manager to change the window's size or position.  ID="ch16107"If a window manager responds to a configuration request by denying it or by moving the window without resizing it, the window manager sends a synthetic ConfigureNotify event.  If the window is resized, the window receives a real ID="ch16108"ConfigureNotify event.  ID="ch16109"These events may be handled by either the root_geometry_manager† †procedure or a Shell event handler.  If the VendorShell resource ID="ch16110"ID="ch16111"ID="ch16112"XmNuseAsyncGeometry is True, the ID="ch16113"ID="ch16114"root_geometry_manager procedure does not wait for the window manager to respond to the configuration request, but instead returns XtGeometryYes.  If the WMShell resource ID="ch16115"XmNwaitForWm is True and if the window manager grants the configuration request within the ID="ch16116"ID="ch16117"XmNwmTimeout† †interval, the ID="ch16118"root_geometry_manager procedure updates the widget's geometry resources and returns XtGeometryYes.  Otherwise, the root_geometry_manager procedure returns XtGeometryNo and relies on the event handler to reconfigure the widget when it receives a subsequent ID="ch16119"ConfigureNotify event.  ID="ch16120"The shell's ConfigureNotify event handler is invoked when the user reconfigures a top-level window or when the application reconfigures a window and this reconfiguration is not handled by the ID="ch16121"root_geometry_manager procedure.  The event handler updates the shell's core geometry fields with the values allowed by the window manager.  If the size of the shell changes, the event handler calls the shell's ID="ch16122"ID="ch16123"resize procedure.  This procedure calls ID="ch16124"ID="ch16125"XtResizeWidget to change the height, width, and border width of the child to be the same as those of the shell.  ID="ch16126"LBL="16.1.3" HELPID=""IconsID="ch16127"An application uses several properties to communicate with the window manager about icons associated with top-level windows.  A Motif application can use resources of several Shell subclasses to specify values for these properties.  ID="ch16128"When a window is first mapped, it can appear in either its normal state or iconic state.  An application uses a field in the WM_HINTS property to tell the window manager which initial state it prefers.  A Motif application specifies the initial state by setting the WMShell resource ID="ch16129"XmNinitialState or the TopLevelShell resource ID="ch16130"ID="ch16131"XmNiconic.  ID="ch16132"XmNiconic takes precedence over XmNinitialState.  After a window is realized, an application can use XtSetValues for ID="ch16133"XmNiconic to either iconify or deiconify the window.  An application can supply a name, a bitmap, or a window for the window manager to use as an icon.  When a top-level window is in iconic state, the window manager usually displays the icon window if one is supplied, or else the icon pixmap if one is supplied, or else the icon name.  MWM uses the iconDecoration resource in determining what aspects of an icon to display.  ID="ch16134"The icon name comes from the WM_ICON_NAME property.  Like WM_NAME, this property is a string whose encoding is identified by the type of the property.  ID="ch16135"ID="ch16136"A Motif application specifies an icon name using the TopLevelShell resources ID="ch16137"XmNiconName and XmNiconNameEncoding.  The default icon name is the name of the shell.  ID="ch16138"ID="ch16139"XmNiconNameEncoding is an atom representing the encoding of the name.  The default encoding depends on whether or not a language procedure has been set.  If no language procedure has been set, the default is STRING.  If a language procedure has been set, the icon name is assumed to be in the encoding of the locale and is passed to XmbTextListToTextProperty with an encoding style of ID="ch16140"XStdICCTextStyle.  The returned property is used as the WM_ICON_NAME property.  If the icon name is fully convertible to type STRING, the encoding is STRING; otherwise, the encoding is COMPOUND_TEXT.  ID="ch16141"ID="ch16142"ID="ch16143"ID="ch16144"An application uses fields in the WM_HINTS property to supply an icon bitmap and an optional mask for displaying the bitmap in a nonrectangular shape.  A Motif application specifies an icon bitmap as the value of the WMShell resource ID="ch16145"ID="ch16146"XmNiconPixmap, and it specifies the mask as the value of the WMShell resource ID="ch16147"XmNiconMask.  ID="ch16148"ID="ch16149"An application uses a field in the WM_HINTS property to supply an icon window.  A Motif application specifies an icon window as the value of the WMShell resource ID="ch16150"ID="ch16151"ID="ch16152"XmNiconWindow.  The icon window must be an InputOutput child of the root window.  It must also use the root visual and the default colormap of the screen.  The application must not map, unmap, or configure this window.  It must, however, select for Expose events on the window and redisplay the contents when it receives these events.  ID="ch16153"The window manager may specify preferred maximum and minimum sizes and size increments for icon bitmaps and windows.  To do this it puts a WM_ICON_SIZE property on the root window.  MWM uses the ID="ch16154"iconImageMaximum and iconImageMinimum† †resources, with increments of 1, in setting this property.  Before an application specifies an icon bitmap or window, it should use the Xlib routine ID="ch16155"ID="ch16156"ID="ch16157"ID="ch16158"XGetIconSizes to check these constraints and then supply a bitmap or window that is of one of the preferred sizes.  ID="ch16159"An application can use two fields of the WM_HINTS property to supply preferred x and y root coordinates for the icon location.  A Motif application specifies these coordinates as the values of the WMShell resources XmNiconX and XmNiconY.  The window manager may ignore these values.  MWM uses the ID="ch16160"ID="ch16161"ID="ch16162"useIconBox, iconPlacement, and ID="ch16163"ID="ch16164"iconPlacementMargin resources in determining where to place icons.  ID="ch16165"LBL="16.1.4" HELPID=""Window GroupsID="ch16166"An application can use a field of the WM_HINTS property to supply the window ID of a window to serve as the "leader" for a group of windows.  The window manager may treat all windows in this group as a whole for certain purposes, such as showing a single icon when the entire group is iconified.  A Motif application specifies a window group leader as the value of the WMShell resource XmNwindowGroup.  For VendorShell and its subclasses, if the shell has a parent, Motif sets the ID="ch16167"ID="ch16168"ID="ch16169"XmNwindowGroup to the parent's window at the time that the shell and its parent are both realized.  Otherwise, the default value is XtUnspecifiedWindowGroup, which means that no window group is set.  ID="ch16170"LBL="16.1.5" HELPID=""Menus and DialogsID="ch16171"ID="ch16172"A window manager may treat dialogs differently from other top-level windows, and it must not interfere with menus at all.  An application tells a window manager not to decorate or otherwise interfere with a window by setting the override_redirect attribute of the window to True.  A Motif application does this by setting the Shell resource ID="ch16173"XmNoverrideRedirect to True, or by using an ID="ch16174"OverrideShell, which has a default value of True for this resource.  ID="ch16175"XmMenuShell is a subclass of OverrideShell, and MenuShells are the only widgets that should have a value of True for ID="ch16176"ID="ch16177"XmNoverrideRedirect.  An application normally does not supply a value other than the default for this resource.  An application tells a window manager to treat a window as transient or secondary by setting the window's WM_TRANSIENT_FOR property.  This property contains the window ID of another top-level window, usually the window from which the transient window was popped up.  A Motif application generally specifies this property by creating a DialogShell, a subclass of TransientShell, which has an ID="ch16178"ID="ch16179"ID="ch16180"ID="ch16181"XmNtransientFor resource.  The value is a widget, and the default is set to the shell's parent at the time that both the shell and its parent are realized.  The window of the ID="ch16182"XmNtransientFor widget is used for the WM_TRANSIENT_FOR property.  For a shell that is not a subclass of TransientShell, an application can set the WMShell ID="ch16183"ID="ch16184"XmNtransient resource to True.  The ID="ch16185"ID="ch16186"XmNwindowGroup is then used for the WM_TRANSIENT_FOR property.  An application normally does not supply a value other than the default for ID="ch16187"XmNtransient or XmNtransientFor.  ID="ch16188"ID="ch16189"MWM treats transient windows differently from other top-level windows.  By default it keeps transient windows stacked on top of their primary windows and does not allow transient windows to be iconified separately from their primary windows.  The MWM ID="ch16190"ID="ch16191"transientDecoration and transientFunctions resources determine which decorations and functions apply to transient windows.  An application can further specify these decorations and functions by using the VendorShell ID="ch16192"ID="ch16193"XmNmwmDecorations and XmNmwmFunctions† †resources, explained in ID="ch16194"ID="ch16195"ID="ch16196"IDREF="16322" TYPE="TITLE"Section 16.2, "MWM Properties and Resources."LBL="16.1.6" HELPID=""Input FocusID="ch16197"ID="ch16198"ICCCM recognizes four models for the relationship between clients and window managers in setting input focus: No inputThe client does not expect keyboard input and does not want the window manager to set focus to any of its windows.  Passive inputThe client expects keyboard input and wants the window manager to set focus to its top-level window.  It does not set focus itself.  Locally active input The client expects keyboard input and wants the window manager to set focus to its top-level window.  It may also set focus to one of its subwindows when one of its windows already has the focus.  It does not set focus itself when the current focus is in a window that the client does not own.  Globally active input The client expects keyboard input but does not want the window manager to set focus to any of its windows.  Instead, it sets focus itself, even when the current focus is in a window that the client does not own.  An application tells the window which model it prefers by using two properties: If the input field of the WM_HINTS property is True, the application wants the window manager to set focus to its top-level window.  If this field is False, the application does not want the window manager to set focus.  ID="ch16199"If the WM_PROTOCOLS property contains a WM_TAKE_FOCUS atom, the application sometimes sets focus itself.  If the WM_PROTOCOLS property does not contain a WM_TAKE_FOCUS atom, the application does not set focus itself.  ID="ch16200"ID="ch16201"These combinations are summarized in the following table: COLUMNS="3"LEFT="0" WIDTH="72"Input ModelLEFT="80" WIDTH="54"Input fieldLEFT="140" WIDTH="356"WM_TAKE_FOCUSLEFT="0" WIDTH="72"No inputLEFT="80" WIDTH="54"FalseLEFT="140" WIDTH="356"AbsentLEFT="0" WIDTH="72"PassiveLEFT="80" WIDTH="54"TrueLEFT="140" WIDTH="356"AbsentLEFT="0" WIDTH="72"Locally activeLEFT="80" WIDTH="54"TrueLEFT="140" WIDTH="356"PresentLEFT="0" WIDTH="72"Globally activeLEFT="80" WIDTH="54"FalseLEFT="140" WIDTH="356"PresentLBL="16-1"Table 16-1 Input ModelsA window manager generally does not set input focus to a window when the WM_HINTS input field is False.  A window with a WM_TAKE_FOCUS protocol may receive a ClientMessage when the window manager wants the window to accept keyboard focus.  The window may respond by setting the input focus or by ignoring the message.  ID="ch16202"ID="ch16203"A Motif application can set the input field of the WM_HINTS property by specifying a value for the WMShell resource ID="ch16204"XmNinput.  The application can install the WM_TAKE_FOCUS atom on the WM_PROTOCOLS property by calling ID="ch16205"ID="ch16206"ID="ch16207"ID="ch16208"XmAddWMProtocols or ID="ch16209"XmAddWMProtocolCallback, explained in IDREF="16427" TYPE="TITLE"Section 16.3, "Atom and Protocol Management."ID="ch16210"A Motif application normally should avoid setting input focus itself.  The application can control the location of focus within its subwindows by using the VendorShell resource XmNkeyboardFocusPolicy, the Gadget, Primitive, and Manager resource ID="ch16211"ID="ch16212"XmNtraversalOn, and the ID="ch16213"ID="ch16214"ID="ch16215"ID="ch16216"XmProcessTraversal routine.  If the application wants a widget to receive no input at all, it can use ID="ch16217"XtSetSensitive to make the widget insensitive.  If the application needs to set focus directly, it should usually use ID="ch16218"XtSetKeyboardFocus and avoid using XSetInputFocus.  For more information, see ID="ch16219"ID="ch16220"IDREF="11820" TYPE="TITLE"Chapter 13, "Input, Focus, and Keyboard Navigation."A number of MWM resources influence keyboard focus.  When ID="ch16221"ID="ch16222"keyboardFocusPolicy is "explicit" (the default), the user must press ID="ch16223"BSelect on a window or its decoration to give it focus.  When ID="ch16224"keyboardFocusPolicy is "pointer", the window that contains the pointer has the focus.  With an explicit policy, other resources determine whether a window has focus when it is first mapped (ID="ch16225"startupKeyFocus), deiconified (ID="ch16226"deiconifyKeyFocus), or raised (raiseKeyFocus).  When ID="ch16227"ID="ch16228"autoKeyFocus is True, and the window with focus is iconified or withdrawn, focus passes to the window that last had focus.  When ID="ch16229"enforceKeyFocus is True, MWM sets focus to globally active windows.  ID="ch16230"LBL="16.1.7" HELPID=""ColormapsID="ch16231"An application can create and set colormaps for its windows, but only the window manager should install colormaps.  Each window manager has a colormap focus policy that determines which top-level window has the colormap focus at a given time.  When a window has colormap focus, the window manager installs one or more colormaps associated with that window.  If all windows in an application use the same colormap, the application need take no special action to tell the window manager to use that colormap.  The window manager keeps track of the colormap attribute for each top-level window and installs that colormap when the window has colormap focus.  If an application uses different colormaps for some windows in its hierarchy, it must tell the window manager about those colormaps by setting a WM_COLORMAP_WINDOWS property on the top-level window.  This property is a list of windows whose colormaps the window manager should install when the top-level window has colormap focus.  The list should be in order of priority, with the windows whose colormaps the application would most like to have installed listed first.  The application can use ID="ch16232"XSetWMColormapWindows to set this property.  ID="ch16233"On many servers, only one hardware colormap can be installed at a time.  This may cause colors in windows that use different colormaps to be displayed incorrectly when their own colormaps are not installed.  To reduce contention for colormaps, applications should use the facilities for standard colormaps described in Xlibname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'C Language X Interface.  The MWM colormapFocusPolicy resource determines the colormap focus policy.  When the value is "keyboard", the window with keyboard focus has the colormap focus.  When the value is "pointer", the window under the pointer has the colormap focus, regardless of whether that window also has keyboard focus.  When the value is "explicit", the colormap focus changes only when the user invokes the ID="ch16234"ID="ch16235"ID="ch16236"f.focus_color function.  ID="ch16237"When a window with colormap focus has a WM_COLORMAP_WINDOWS property, the user can install the next and previous colormaps on the list by invoking the f.next_cmap and f.prev_cmap functions.  ID="ch16238"ID="ch16239"LBL="16.1.8" HELPID=""Application Shutdown and RestartID="ch16240"ID="ch16241"ID="ch16242"An application may run under a session manager with facilities for saving and restoring the state of the application.  An application communicates with a session manager by placing WM_COMMAND and WM_CLIENT_MACHINE properties on its top-level windows.  WM_COMMAND contains a string that would restart the client in its current state.  ID="ch16243"ID="ch16244"A Motif application should have only one non-NULL WM_COMMAND property for each logical application (that is, for each ApplicationShell hierarchy).  Xt sets the WM_COMMAND property for an ApplicationShell when the shell is realized, using the command that started the application.  Note that if an application is using an unrealized ApplicationShell with multiple TopLevelShell popup children, Xt will not place a WM_COMMAND property on any window, and the application must put this property on some (possibly unmapped) window in the application.  ID="ch16245"ID="ch16246"ID="ch16247"WM_CLIENT_MACHINE contains a string that represents the name of the host on which the application is running.  Xt sets the WM_CLIENT_MACHINE for a WMShell or subclass when the shell is realized.  ID="ch16248"ID="ch16249"A session manager can inform an application when a top-level window is about to be deleted or when the application should try to save its state.  An application expresses interest in these notifications by adding a WM_DELETE_WINDOW atom or a WM_SAVE_YOURSELF atom to the WM_PROTOCOLS property.  ID="ch16250"ID="ch16251"ID="ch16252"If a WM_DELETE_WINDOW protocol exists, the session manager sends a ClientMessage when it wants to delete a top-level window.  The application may ask for user confirmation and may decide to comply or not comply with the request.  If it decides to comply, the application can either unmap or destroy the window.  ID="ch16253"If a WM_SAVE_YOURSELF protocol exists, the session manager sends a ClientMessage when it wants the application to save its current state in such a way that it could be restored.  The application should do whatever is necessary to save its internal state and then update the non-NULL WM_COMMAND property with a command that will restart the application in its current state.  Finally, the application updates the WM_COMMAND property on the window that has the WM_SAVE_YOURSELF protocol if it has not already done so.  This informs the session manager that the application has finished saving its state.  ID="ch16254"ID="ch16255"Motif installs a WM_DELETE_WINDOW protocol for VendorShell and its subclasses.  It also installs a procedure to be called after any application-supplied WM_DELETE_WINDOW handlers are invoked.  This procedure destroys the widget, unmaps the window, or does nothing, depending on the value of the VendorShell resource ID="ch16256"ID="ch16257"XmNdeleteResponse.  If the procedure destroys an ApplicationShell, it then exits the application.  ID="ch16258"ID="ch16259"An application can add its own WM_DELETE_WINDOW and WM_SAVE_YOURSELF protocols by using ID="ch16260"ID="ch16261"XmAddWMProtocols or ID="ch16262"XmAddWMProtocolCallback.  ID="ch16263"When the user invokes the f.kill command, MWM sends a ClientMessage if an application has a WM_DELETE_WINDOW protocol and a separate ClientMessage if an application has a WM_SAVE_YOURSELF protocol.  If the application has no WM_DELETE_WINDOW protocol, the ID="ch16264"ID="ch16265"ID="ch16266"ID="ch16267"ID="ch16268"f.kill† †command kills the client.  In this case, if a WM_SAVE_YOURSELF protocol exists, MWM sends the ClientMessage and then waits for the time specified by the ID="ch16269"quitTimeout resource before killing the client.  ID="ch16270"LBL="16.2" HELPID=""ID="16322"MWM Properties and ResourcesID="ch16271"ID="ch16272"In addition to the properties and protocols described in ICCCM, Motif uses properties and protocols of its own.  A Motif application usually specifies these properties using VendorShell and BulletinBoard resources.  ID="ch16273"ID="ch16274"LBL="16.2.1" HELPID=""DecorationsID="ch16275"An application expresses preferences for MWM window decorations by supplying a value for the decorations field of the _MOTIF_WM_HINTS property on the window.  A Motif application does this by supplying a value for the VendorShell resource ID="ch16276"ID="ch16277"XmNmwmDecorations.  The value is the bitwise inclusive OR of one or more flag bit constants, each of which indicates a preference for or against a particular decoration.  If a value has been supplied for this resource, MWM displays only those decorations specified by both ID="ch16278"XmNmwmDecorations and the MWM clientDecoration resource (for primary windows) or specified by both ID="ch16279"XmNmwmDecorations and the MWM transientDecoration† †resource (for transient windows).  If no value has been supplied for ID="ch16280"XmNmwmDecorations, MWM displays the decorations specified by the clientDecoration or transientDecoration resource.  LBL="16.2.2" HELPID=""FunctionsID="ch16281"An application expresses preferences for MWM window functions by supplying a value for the functions field of the _MOTIF_WM_HINTS property on the window.  A Motif application does this by supplying a value for the VendorShell resource ID="ch16282"ID="ch16283"XmNmwmFunctions.  The value is the bitwise inclusive OR of one or more flag bit constants, each of which indicates a preference for or against a particular function.  If a value has been supplied for this resource, MWM displays only those functions specified by both ID="ch16284"XmNmwmFunctions and the MWM clientFunctions resource (for primary windows) or specified by both ID="ch16285"XmNmwmFunctions and the MWM transientFunctions† †resource (for transient windows).  If no value has been supplied for ID="ch16286"XmNmwmFunctions, MWM displays the functions specified by the clientFunctions or transientFunctions resource.  BulletinBoard may change the initial value of XmNmwmFunctions if its parent is a subclass of VendorShell.  The BulletinBoard resource ID="ch16287"ID="ch16288"ID="ch16289"XmNnoResize determines whether the decorations of the VendorShell parent include resize controls.  ID="ch16290"LBL="16.2.3" HELPID=""Input ModeID="ch16291"ID="ch16292"An application can inform MWM that it should impose constraints on which windows can obtain input.  It does so by setting the input_mode field of the _MOTIF_WM_HINTS property on a window.  A Motif application does this by supplying a value for the VendorShell resource ID="ch16293"ID="ch16294"XmNmwmInputMode.  For a BulletinBoard whose parent is a DialogShell, the application can set ID="ch16295"ID="ch16296"ID="ch16297"XmNmwmInputMode indirectly by specifying a value for the BulletinBoard resource XmNdialogStyle.  ID="ch16298"The possible modes are as follows: ModelessInput goes to any window.  Primary application modal Input does not go to ancestors of this window or their descendants.  Full application modal Input goes to this window or its descendants and to other applications but not to other windows in this application.  System modalInput goes only to this window or its descendants.  LBL="16.2.4" HELPID=""Window MenuID="ch16299"An application can supply items for MWM to add to the end of the window menu for a window by specifying a value for the _MOTIF_WM_MENU property.  A Motif application does this by supplying a value for the VendorShell resource ID="ch16300"ID="ch16301"XmNmwmMenu.  The window menu itself is the value of the MWM ID="ch16302"windowMenu† †resource.  ID="ch16303"LBL="16.2.5" HELPID=""MWM MessagesID="ch16304"An application can specify a message for MWM to send the application when the user invokes the f.send_msg function.  The application places a _MOTIF_WM_MESSAGES atom on the WM_PROTOCOLS property for the window.  The application also places an atom on the _MOTIF_WM_MESSAGES property.  When the ID="ch16305"ID="ch16306"ID="ch16307"f.send_msg function is invoked with this atom as the argument, MWM sends the application a ClientMessage.  The application can use ID="ch16308"XmAddWMProtocols to place a _MOTIF_WM_MESSAGES atom on the WM_PROTOCOLS property, and it can use ID="ch16309"XmAddProtocolCallback to place an atom on the _MOTIF_WM_MESSAGES property and associate it with a routine to be called when MWM sends the ClientMessage.  ID="ch16310"LBL="16.2.6" HELPID=""MWM InformationMWM maintains a _MOTIF_WM_INFO property on the root window of each screen it manages.  This property is available for applications to inspect but not to change.  The ID="ch16311"XmIsMotifWMRunning routine examines this property when determining whether or not MWM is running.  ID="ch16312"LBL="16.3" HELPID=""ID="16427"Atom and Protocol ManagementID="ch16313"ID="ch16314"Motif has two routines that can reduce overhead for applications that use atoms.  XmInternAtom returns an existing atom or (if the third argument is False) creates and returns an atom that matches the given string.  ID="ch16315"XmGetAtomName returns the string that matches the given atom.  These functions parallel ID="ch16316"XInternAtom and XGetAtomName, but they cache the atoms and names on the client side and avoid unnecessary trips to the server.  ID="ch16317"ID="ch16318"Motif has a number of routines to help an application install protocol atoms and handle ClientMessages sent when the protocols are invoked.  These routines maintain an internal registry of properties, protocol atoms associated with the properties, and callback routines associated with the protocol atoms.  The application can use these routines with shells that are subclasses of VendorShell.  ID="ch16319"XmAddProtocols associates one or more protocol atoms with a property for a given shell.  If the shell is realized, it adds those protocols to the property for the shell's window.  If the shell is not realized, it arranges for the protocols to be added to the property and for a ClientMessage event handler to be added at the time the shell is realized.  ID="ch16320"XmAddWMProtocols is a specialized version that adds protocols for the WM_PROTOCOLS property.  ID="ch16321"ID="ch16322"XmAddProtocolCallback adds a callback routine to a callback list associated with a protocol.  It calls ID="ch16323"XmAddProtocols if the protocol has not yet been registered.  When the protocol manager's ClientMessage event handler receives a ClientMessage for the protocol, it invokes the procedures on the associated callback list.  The first argument to each callback procedure is the shell associated with the protocol.  The second argument is the client data, if any, specified in the call to ID="ch16324"XmAddProtocolCallback.  The third argument is a pointer to an ID="ch16325"XmAnyCallbackStruct† †structure whose ID="ch16326"reason member is XmCR_PROTOCOLS and whose ID="ch16327"ID="ch16328"event member is a pointer to the ClientMessage event.  In the ClientMessage event, the message_type member is the property that contains the protocol, the format member is 32, and the data.l[0] member is the protocol atom.  XmAddWMProtocolCallback is a specialized version of ID="ch16329"XmAddProtocolCallback that adds a callback for a protocol on the WM_PROTOCOLS property.  ID="ch16330"ID="ch16331"An application can also use XmSetProtocolHooks to specify a routine to be called before or after a callback list is invoked for a protocol.  ID="ch16332"XmSetWMProtocolHooks is a specialized version that adds prehooks and posthooks for a protocol on the WM_PROTOCOLS property.  ID="ch16333"ID="ch16334"Once an application has registered a protocol and optional callback routines, it can make the protocol active or inactive.  A protocol is active if it has been added to the associated property for the window.  A protocol is inactive if it has been removed from the associated property.  XmActivateProtocol makes a registered protocol active, and ID="ch16335"XmDeactivateProtocol makes a protocol inactive.  ID="ch16336"XmActivateWMProtocol and XmDeactivateWMProtocol are specialized versions that activate or inactivate a protocol on the WM_PROTOCOLS property.  ID="ch16337"ID="ch16338"ID="ch16339"XmRemoveProtocolCallback removes a callback routine from the callback list associated with the protocol.  ID="ch16340"XmRemoveProtocols removes one or more protocols and all callbacks associated with those protocols from the internal registry.  If the shell is realized, it removes those protocols from the associated property.  ID="ch16341"XmRemoveWMProtocolCallback and XmRemoveWMProtocols are specialized versions that remove callbacks or protocols for the WM_PROTOCOLS property.  ID="ch16342"ID="ch16343"ID="ch16344"LBL="16.4" HELPID=""SelectionsID="ch16345"Selections are the standard ICCCM mechanism for transferring data from one application to another on the same display.  Each selection is represented by an atom.  The display contains only one selection of each type.  It is owned by a client or by no one and, if owned, is attached to a window of the owning client.  Any client may assert or remove ownership of a selection.  The data represented by the selection is internal to the client that owns the selection.  If another client wants to obtain the data in the selection, it asks the owner to convert the selection to some target type.  Each target type is represented by an atom.  The owner may or may not be able to convert the selection to the requested type or to some other type.  If it can convert the selection, the owner places the converted data into a property on the requesting client's window, using the actual target as the type of the property.  The owner sends the requestor a SelectionNotify event when the conversion (whether successful or not) is complete.  For a successful transfer, this event includes the property on the requestor's window that contains the converted selection.  When the requestor receives a SelectionNotify event for a successful conversion, it retrieves the contents of the specified property from its window and then deletes the property.  LBL="16.4.1" HELPID=""Selection TypesICCCM defines three selections that all clients should support, although clients may support other selections as well: PRIMARYThe principal selection.  ID="ch16346"ID="ch16347"SECONDARYA means of exchanging data without disturbing the primary selection.  ID="ch16348"ID="ch16349"CLIPBOARDThe selection often used to "cut" or "copy" data from one client and "paste" it into another.  A client transfers data to the clipboard by asserting ownership of this selection.  A client transfers data from the clipboard by requesting conversion of the selection.  ID="ch16350"ID="ch16351"A separate client may also represent the clipboard.  This client can notice when it loses the selection (because another client wants to transfer data to the clipboard), then request a conversion of the selection and finally reassert ownership.  The Motif Text and TextField widgets support all three of these selections.  The List widget supports only copying of selected items to the clipboard.  Motif also makes use of other selections, notably for the destination widget and for drag and drop.  For more information on drag and drop selections, see ID="ch16352"ID="ch16353"ID="ch16354"IDREF="41117" TYPE="TITLE"Chapter 15, "Drag and Drop."LBL="16.4.2" HELPID=""TargetsID="ch16355"ICCCM lists a number of suggested target atoms that clients may support.  Clients are free to request and perform conversion to these and to other targets as well.  Clients that follow ICCCM must support only three targets: TARGETSWhen a selection owner is asked to convert the selection to this type, it returns a list of the target types to which it can convert the selection.  By first requesting a conversion to TARGETS, a client can determine whether a conversion request of a particular type is likely to succeed or fail.  ID="ch16356"ID="ch16357"MULTIPLEThis target signifies a request for a series of conversions.  The requestor places in its specified window property a list of pairs of atoms.  Each pair names a target and a property.  The selection owner processes each pair in order, converting the selection to the specified target and placing the results in the specified property.  It sends the requestor a SelectionNotify event when all conversions are complete.  ID="ch16358"ID="ch16359"TIMESTAMPThe owner returns the timestamp it used to obtain ownership of the selection.  ID="ch16360"ID="ch16361"Some targets have side-effects for the owner.  Among these targets are the following: DELETEThe owner deletes the selection and, if successful, returns a zero-length property of type NULL.  ID="ch16362"ID="ch16363"INSERT_SELECTION The requestor places in its specified window property a pair of atoms that names a selection and a target.  The owner requests conversion of the specified selection to the specified target and places the result at the location of the selection named in the INSERT_SELECTION request.  The owner then returns a zero-length property of type NULL.  The Motif Text widget uses this target with the destination selection when it asks the owner of the destination selection to insert the secondary selection at the destination.  ID="ch16364"ID="ch16365"ID="ch16366"INSERT_PROPERTY The requestor places in its specified window property some data to be inserted at the location of the selection named in the request.  The owner then returns a zero-length property of type NULL.  ID="ch16367"ID="ch16368"LBL="16.4.3" HELPID=""Text ConversionID="ch16369"Conversion of textual selections raises problems, because the requesting client and the selection owner may be in different locales.  A requestor may specify a target type of TEXT, but the owner may then convert the selection into any encoding that is convenient.  The type of the returned property indicates what this encoding is; the type will never be TEXT.  The requestor may or may not be able to convert the value into a useful form.  Converted text is generally of one of three types: STRINGThe text includes only characters in ISO8859-1 plus TAB and NEWLINE.  ID="ch16370"ID="ch16371"COMPOUND_TEXT The text is in compound text format as specified by the X Consortium Standard ID="ch16372"ID="ch16373"Compound Text Encoding.  locale encodingThe text is in the encoding of the selection owner's locale.  The encoding is represented by the atom used as the type of the returned property.  ID="ch16374"A selection owner can use XmbTextListToTextProperty or ID="ch16375"XwcTextListToTextProperty to convert text in its own locale to a text property.  The type of the property is determined by the composition of the text and by the encoding style passed to ID="ch16376"XmbTextListToTextProperty.  Encoding styles exist for converting text to STRING, COMPOUND_TEXT, and the encoding of the locale.  Another encoding style specifies conversion to STRING if all the characters in the text can be so converted, or otherwise to COMPOUND_TEXT.  ID="ch16377"ID="ch16378"ID="ch16379"ID="ch16380"ID="ch16381"A Motif application that has text in compound strings can use XmCvtXmStringToCT to convert a compound string to compound text.  The application can then place the compound text in the requestor's property using type COMPOUND_TEXT.  ID="ch16382"ID="ch16383"ID="ch16384"STRING, COMPOUND_TEXT, and the locale encoding can also be selection targets.  To obtain a text selection in its own locale, an application can request conversion to one of these targets and can then call ID="ch16385"ID="ch16386"ID="ch16387"ID="ch16388"XmbTextPropertyToTextList or XwcTextPropertyToTextList to convert the returned property to text in the current locale.  An application can also request conversion to TEXT, but there is no guarantee that it can convert the returned property to text in the current locale.  ID="ch16389"ID="ch16390"ID="ch16391"ID="ch16392"One possible strategy is first to request conversion to TARGETS.  If one of the returned targets is the encoding of the current locale (as determined by a call to ID="ch16393"ID="ch16394"XmbTextListToTextProperty with an encoding style of ID="ch16395"XTextStyle), the application can request conversion to that target.  Otherwise, if one of the returned targets is COMPOUND_TEXT, the application can request conversion to that target.  If neither the locale encoding nor COMPOUND_TEXT is one of the returned targets, the application can request conversion to STRING or TEXT if the selection owner supports one of those targets.  ID="ch16396"ID="ch16397"ID="ch16398"ID="ch16399"ID="ch16400"ID="ch16401"ID="ch16402"A Motif application that has text in compound strings can request conversion of a selection to COMPOUND_TEXT and can then use ID="ch16403"ID="ch16404"XmCvtCTToXmString to convert the returned property to a compound string.  ID="ch16405"LBL="16.4.4" HELPID=""Incremental TransfersID="ch16406"ID="ch16407"ID="ch16408"When a selection contains a large quantity of data, the selection owner may place converted data into the returned property incrementally.  It signals the requestor that it intends to do this by setting the type of the returned property to INCR and placing into the property an integer that represents the minimum number of bytes of data to be transferred.  The owner and requestor must then cooperate in transferring the data.  The requestor starts the interaction by deleting the returned property.  The owner then appends the first chunk of data to the same property, giving the property the type of the converted data.  The requestor receives a PropertyNotify event for the new value of the property, retrieves the data in the property, and deletes the property.  The owner receives a PropertyNotify event for the deletion of the property and then appends the next chunk of data to the property.  This interaction continues until all that data has been transferred.  The owner then writes zero-length data to the property, and the requestor deletes the property to terminate the interaction.  LBL="16.4.5" HELPID=""The Xt Selection InterfaceID="ch16409"ID="ch16410"ID="ch16411"ID="ch16412"Xlib provides routines to set the owner of a selection (XSetSelectionOwner, get the owner of a selection (ID="ch16413"XGetSelectionOwner), and convert a selection (ID="ch16414"XConvertSelection).  Applications that use only the Xlib interface must do additional work to support selections, such as providing a handler for SelectionRequest events to convert selections that the application owns.  ID="ch16415"Xt provides a richer interface for handling selections.  This interface consists of two parallel sets of routines, one for transferring data atomically and the other for transferring data incrementally.  In an atomic data transfer, the owner converts all data for one selection request before responding to another request to convert the same selection.  In an incremental data transfer, the owner may need to start a second conversion before finishing the first conversion for a given selection.  The selection owner and the requestor need not use the same (atomic or incremental) interface.  This distinction is independent of whether the actual transfer uses the ICCCM incremental (INCR) protocol.  For an atomic transfer of a large amount of data, Xt automatically uses the ICCCM incremental protocol when necessary.  An application asserts ownership of a selection by calling XtOwnSelection for atomic transfers or ID="ch16416"XtOwnSelectionIncremental for incremental transfers.  In this call, the application can supply a procedure to convert the selection and procedures to be called when the requestor has retrieved the data and when the application loses ownership of the selection.  For an incremental transfer, the conversion routine can be called multiple times for the same request and can be called to begin a new conversion before it has transferred all data for the first request.  The conversion routine can obtain the SelectionRequest event by calling ID="ch16417"XtGetSelectionRequest.  When calling ID="ch16418"XtOwnSelectionIncremental the application can also provide a routine to be called to cancel a conversion in progress.  With either atomic or incremental transfer, an application relinquishes ownership of the selection by calling ID="ch16419"XtDisownSelection.  ID="ch16420"An application requests conversion of a selection by calling XtGetSelectionValue or XtGetSelectionValues for atomic transfers, or ID="ch16421"ID="ch16422"XtGetSelectionValueIncremental or ID="ch16423"XtGetSelectionValuesIncremental for incremental transfers.  The difference between the "Value" and "Values" form of each routine is that the "Values" form allows multiple conversions while guaranteeing that the selection owner does not change during the call.  When invoking one of these routines, the requestor supplies a routine to be called to deliver the data from the returned property.  ID="ch16424"Xt provides a timeout for the period in which a requestor and a selection owner must respond to each other.  The initial value comes from the selectionTimeout application resource.  An application can use ID="ch16425"XtAppSetSelectionTimeout to set a new value, and it can use ID="ch16426"XtAppGetSelectionTimeout to retrieve the value.  ID="ch16427"The Motif drag and drop interface uses the Xt selection mechanism.  A drag source supplies a single procedure to convert the selection, and a drop site supplies a procedure to receive the transferred data.  The drag source and the receiver can determine independently whether or not to use atomic or incremental transfer.  The drag source does this by specifying a value for the DragContext resource ID="ch16428"XmNincremental, and the receiver does this by specifying a value for the DropTransfer resource ID="ch16429"XmNincremental.  When the drag source uses atomic transfer, it ignores the arguments to the conversion routine that pertain to incremental transfers.  ID="ch16430"ID="ch16431"LBL="16.5" HELPID=""The Motif ClipboardID="ch16432"ID="ch16433"ID="ch16434"Motif provides a set of routines for dealing with the CLIPBOARD selection.  The Motif clipboard interface allows an application to assert ownership of the selection and request conversion of the selection.  The interface stores the data in the selection and other information about the selection on the server.  The owner can place the selection value in these server data structures either at the time it asserts ownership or at the time a client requests conversion.  By copying the selection value at the time it asserts ownership, an application can simplify conversion and make the data available for retrieval even if the owner is killed.  By copying the selection value when a client requests it, an application can avoid converting data that no client may request.  However, in this case, the application may need to make a copy of the data to be transferred.  With either copying mechanism, the data is stored in the Motif clipboard's server data structures the first time a client requests the data.  LBL="16.5.1" HELPID=""Copying Data to the ClipboardTo assert ownership and copy data to the clipboard, an application takes these steps: It calls XmClipboardStartCopy to begin the interaction ID="ch16435"It makes one or more calls to XmClipboardCopy to place data on the clipboard ID="ch16436"It terminates the interaction by calling XmClipboardEndCopy or ID="ch16437"XmClipboardCancelCopy† †ID="ch16438"An application begins an interaction to copy data to the clipboard by calling XmClipboardStartCopy.  The application passes the following: a display pointer and timestamp; the ID of a window in the application; a compound string that could be used to label the data; and, if the application intends to delay copying the data until it is requested, a widget ID and a function to be called to convert the data.  ID="ch16439"XmClipboardStartCopy returns in one of the arguments a data ID that the application must later pass to ID="ch16440"XmClipboardEndCopy or ID="ch16441"XmClipboardCancelCopy.  The application must also pass the same window ID to subsequent clipboard calls in this sequence that it uses in the call to ID="ch16442"XmClipboardStartCopy.  After calling XmClipboardStartCopy, the application makes one or more calls to ID="ch16443"XmClipboardCopy to place data on the clipboard.  Each call associates the data with a single target (called a format in the clipboard interface).  The application can associate the same data or different data with more than one target, but it must do so by making separate calls to ID="ch16444"XmClipboardCopy.  If the application passes a NULL data buffer to XmClipboardCopy, it asserts that it intends to transfer the actual data for that target when a client requests it.  Otherwise, ID="ch16445"XmClipboardCopy transfers data to be stored on the clipboard by XmClipboardEndCopy.  If the application makes more than one call to ID="ch16446"XmClipboardCopy for the same target, the data is appended to the previously transferred data for that target.  XmClipboardCopy returns in one of its arguments a data ID that identifies the data and target specified in this call.  An application that provides actual data at the time a client requests it uses this ID in its conversion routine to identify the data and target to be converted.  Such an application must store a mapping of the data ID to the data and target after ID="ch16447"XmClipboardCopy returns.  The application terminates the interaction by calling either XmClipboardEndCopy or XmClipboardCancelCopy.  ID="ch16448"ID="ch16449"XmClipboardEndCopy stores in the server data structures the data transferred by the calls to XmClipboardCopy during this interaction sequence.  It also asserts ownership of the CLIPBOARD selection.  If the application calls ID="ch16450"XmClipboardCancelCopy instead of XmClipboardEndCopy, the interaction is terminated without storing any of the transferred data or asserting ownership of the selection.  If a client later requests data that the owner has declared it would provide at the time of the request, the clipboard interface invokes the conversion routine that the owner registered in the call to XmClipboardStartCopy.  This routine receives the following as arguments: the widget ID passed to ID="ch16451"XmClipboardStartCopy; the data ID for this data and target returned by XmClipboardCopy; a private ID the application may have supplied in the call to ID="ch16452"XmClipboardCopy; and a reason for invoking the routine.  The conversion routine is responsible for converting the data to the requested target.  In order to do this it must consult the mapping it established between the data ID or the private ID and the data and target when it called XmClipboardCopy.  It can also determine the target from the data ID or private ID by the following procedure: ID="ch16453"Call XmClipboardInquireCount to determine the number of targets associated with the data.  ID="ch16454"Call XmClipboardInquireFormat to retrieve the first target.  ID="ch16455"Call XmClipboardInquirePendingItems for the returned target.  ID="ch16456"Repeat steps two and three until the data ID or private ID passed to the conversion routine appears in the list returned by XmClipboardInquirePendingItems.  Use the target passed to that invocation of ID="ch16457"XmClipboardInquirePendingItems.  Once the conversion routine has determined the proper target, it copies the data to the clipboard.  To do this it calls XmClipboardCopyByName, using the data ID passed to the conversion routine.  The application can call ID="ch16458"XmClipboardCopyByName more than once, if necessary, to convert all the data for this target.  Once an application has copied data to the clipboard in this way, it no longer asserts that it will convert the same data to the same target in the future.  It can remove the data ID from its mapping of data IDs to data and targets, and it can free any data it has associated with this ID if it is not needed for any other purpose.  The clipboard interface calls the conversion routine when a data item intended for later conversion has been removed from the clipboard and is no longer needed.  For example, another application may have copied new data to the clipboard.  In this case, the conversion routine can remove the data ID from its mapping of data IDs to data and targets, and it can free any data it has associated with this ID if it is not needed for any other purpose.  If the conversion routine is being called because an item has been removed from the clipboard, the reason argument to the conversion routine is XmCR_CLIPBOARD_DATA_DELETE.  If the conversion routine is being called because a client has requested data conversion, the ID="ch16459"reason argument is XmCR_CLIPBOARD_DATA_REQUEST.  ID="ch16460"An application can use XmClipboardWithdrawFormat to rescind its assertion that it will convert data to a particular target on request.  ID="ch16461"XmClipboardUndoCopy removes the last item placed on the clipboard by an application using the same ID="ch16462"display and window arguments.  This function also restores to the clipboard the item that was on the clipboard before the cancelled copy was done.  If the application calls XmClipboardUndoCopy a second time, the function restores to the clipboard the item that was removed by the first call to XmClipboardUndoCopy.  LBL="16.5.2" HELPID=""Retrieving Data from the ClipboardTo retrieve data from the clipboard, an application takes these steps: It calls XmClipboardStartRetrieve to begin the interaction.  ID="ch16463"It makes one or more calls to XmClipboardRetrieve to retrieve data from the clipboard.  ID="ch16464"It terminates the interaction by calling XmClipboardEndRetrieve.  ID="ch16465"An application begins an interaction to retrieve data from the clipboard by calling XmClipboardStartRetrieve.  The application passes a display pointer, a timestamp, and the ID of a window in the application.  The application must pass the same window ID to subsequent clipboard calls in this sequence that it uses in the call to ID="ch16466"XmClipboardStartRetrieve.  XmClipboardStartRetrieve locks the clipboard.  After calling XmClipboardStartRetrieve, the application makes one or more calls to ID="ch16467"XmClipboardRetrieve to retrieve data from the clipboard, converted to a given target.  The application passes ID="ch16468"XmClipboardRetrieve a buffer to receive the data.  If this buffer is not large enough to contain all the data for the given target, XmClipboardRetrieve returns XmClipboardTruncate.  The application can make repeated calls to ID="ch16469"XmClipboardRetrieve to retrieve the remainder of the data.  The function XmClipboardInquireLength returns the length of the data on the clipboard for the given target.  This allows the application to allocate a buffer of the correct size.  ID="ch16470"XmClipboardEndRetrieve unlocks the clipboard and ends the interaction.  ID="ch16471"LBL="16.5.3" HELPID=""Utility RoutinesThe Motif clipboard interface has routines to lock and unlock the clipboard, to make inquiries about its contents, and to register new targets.  XmClipboardLock prevents another application from gaining access to the Motif clipboard.  ID="ch16472"XmClipboardUnlock allows other applications to gain access.  The clipboard interface automatically locks the clipboard during calls to ID="ch16473"XmClipboardStartRetrieve and XmClipboardEndRetrieve.  At other times, an application can use ID="ch16474"ID="ch16475"XmClipboardLock and XmClipboardUnlock to lock the clipboard explicitly.  The clipboard interface includes four routines for making inquiries about the clipboard contents: XmClipboardInquireCount returns the number of targets for which data exists on the clipboard.  ID="ch16476"XmClipboardInquireFormat returns the name of the target for a given index of targets on the clipboard.  An application could retrieve the names of all the targets associated with data on the clipboard by first calling ID="ch16477"XmClipboardInquireCount to find out how many such targets exist and then calling ID="ch16478"XmClipboardInquireFormat with indices from 1 to the number of targets, inclusive.  Note that the first index for XmClipboardInquireFormat is 1, not 0.  XmClipboardInquireLength returns the number of bytes of data associated with a given target on the clipboard.  ID="ch16479"XmClipboardInquirePendingItems returns a list of pairs of data ID and private ID for a given target if that target exists on the clipboard and if the owner has asserted that it will supply the actual data on request (but has not yet done so).  ID="ch16480"An application that makes more than one call to an inquiry function at a time should use XmClipboardLock and XmClipboardUnlock to lock the clipboard for the duration of the interaction.  ID="ch16481"ID="ch16482"XmClipboardRegisterFormat registers a new target with the clipboard interface.  The application supplies the length of the data in bits along with the name of the target so that the correct byte order will be maintained when transferring data across platforms.  All targets defined in ICCCM are preregistered; the application does not have to call ID="ch16483"XmClipboardRegisterFormat for these.  LBL="A"ID="87449"The Widget Meta-Language FacilityThe Widget Meta-Language (WML) facility generates the components of the User Interface Language (UIL) compiler that can change depending on the widget set.  WML adds support in UIL for additional widgets that are not in the OSF/Motif widget set or for a totally new widget set.  ID="appa1"ID="appa2"ID="appa3"ID="appa4"UIL is made up of the following: Static syntax Dynamic syntax Data types The static syntax elements are the basic syntax and keywords of UIL.  These elements do not change when the widget set is modified.  The static syntax elements of UIL are defined in the file Uil.y in the WML source directory.  The dynamic syntax elements are the parts of UIL that change with the widget set.  These elements describe the widget and gadget classes supported by UIL, including their resources and hierarchy.  The dynamic elements of UIL are defined in WML files.  For the OSF/Motif widget set, these elements are defined in the file motif.wml in the WML source directory.  The data type elements describe the allowable data types for each widget and gadget resource.  Although the data types do not change, the resources that they are assigned to change with the widget set.  The allowable data types for each resource are defined in the same file as the dynamic syntax elements.  The WML facility combines the static syntax, dynamic syntax, and data type elements to produce new source code for UIL.  This allows a developer to modify the dynamic elements of UIL, adding resources, widgets, gadgets, or even new widget sets.  A developer can use WML files to modify UIL in two ways: Build a new UIL compiler by running the WML facility with a customized WML file.  Compile a customized WML file into a Widget Meta-Language Database (WMD) file.  The UIL compiler reads this file at run time and processes the new or modified widget definitions dynamically.  ID="appa5"ID="appa6"LBL="A.1" HELPID=""Using WMLWhen Motif is built, the WML facility uses the file motif.wml to produce UIL source files.  The motif.wml file contains definitions for the OSF/Motif widget set.  A developer can create a new WML file in the directory tools/wml to use in place of motif.wml.  By convention, WML files have a suffix of .wml.  For information on the syntax of WML files, see the WML(5X) reference page in the OSF/Motif Programmer's Reference.  A developer uses a customized WML file to build UIL in a four-step process: Build WML Run WML with the customized WML file Install the UIL source files Build UIL All four steps are done as needed each time Motif is built.  By default, UIL is built using the motif.wml file from the tools/wml directory.  The command-line make variable TABLE specifies the WML file to use in building UIL: make TABLE=anyfile.wmlwhere anyfile.wml is the name of a WML file in the tools/wml directory of the Motif build tree.  When Motif is built, a default WMD file named motif.wmd is created.  By convention, WMD files use the suffix .wmd.  WMD files provide a method for including new widget definitions into the UIL compiler without rebuilding the compiler.  Rebuilding this file or building a new WMD file is a two-step process that closely parallels the first two steps of creating a new UIL compiler: Build WML Run WML with the customized WML file The following make command line rebuilds motif.wmd based on a given WML file:make TABLE=anyfile.wml† †motif.wmd† †The following make command line creates a new WMD file based on a given WML file: make TABLE=anyfile.wml† †WMDTABLE=anyfile.wmd anyfile.wmd† †where anyfile.wmd is the name of the WMD file to create.  In both of the preceding make commands, the make variable TABLE specifies the WML file to use as the source for the WMD file.  A developer of a UIL application specifies a WMD file for the UIL compiler in one of two ways: By using the -wmd option to the uil command ID="appa7"By supplying values for the database and database_flag members of the Uil_command_type structure whose address is the first argument to the Uil function ID="appa8"See the OSF/Motif Release Notes for more information about building Motif.  The following sections describe how to do each of the four steps involved in rebuilding UIL independently.  LBL="A.1.1" HELPID=""Building WMLBuilding Motif builds WML by default, but a developer can also build WML separately.  A developer must build WML in order to build the UIL compiler or new WMD files.  The WML source is located in the subdirectory tools/wml.  Before WML is built, the directory should contain the following files: COLUMNS="3"LEFT="0" WIDTH="72"ImakefileLEFT="80" WIDTH="72"wml.hLEFT="160" WIDTH="356"wmlparse.yLEFT="0" WIDTH="72"MakefileLEFT="80" WIDTH="72"wmldbcreate.cLEFT="160" WIDTH="356"wmlresolve.cLEFT="0" WIDTH="72"READMELEFT="80" WIDTH="72"wmllex.lLEFT="160" WIDTH="356"wmlsynbld.cLEFT="0" WIDTH="72"Uil.yLEFT="80" WIDTH="72"wmlouth.cLEFT="160" WIDTH="356"wmluiltok.lLEFT="0" WIDTH="72"UilDBDef.hLEFT="80" WIDTH="72"wmloutkey.cLEFT="160" WIDTH="356"wmlutils.cLEFT="0" WIDTH="72"motif.wmlLEFT="80" WIDTH="72"wmloutmm.cLEFT="160" WIDTH="356"LEFT="0" WIDTH="72"wml.cLEFT="80" WIDTH="72"wmloutp1.cLEFT="160" WIDTH="356"LBL="A-1"Table A-1 The files Imakefile and Makefile are used to build and run the WML facility.  The README file contains instructions for building and using WML.  The files Uil.y and motif.wml are the data files for the static syntax, dynamic syntax, and data type elements of UIL.  The files with the wml prefix are the source files for the WML facility.  The following commands change to the directory tools/wml, build the makefile, and build WML: cd tools/wml 
make Makefile 
make depend 
make wmltools The make Makefile and make depend commands build the makefile using the Imake facility.  The make Makefile command produces a machine-dependent makefile.  The make depend command adds include file dependencies to the new makefile.  After WML is built, the tools/wml directory should contain the following additional files: COLUMNS="3"LEFT="0" WIDTH="72"lex.yy.cLEFT="80" WIDTH="72"wmloutkey.oLEFT="160" WIDTH="356"wmlresolve.oLEFT="0" WIDTH="72"libwml.aLEFT="80" WIDTH="72"wmloutmm.oLEFT="160" WIDTH="356"wmlsynbld.oLEFT="0" WIDTH="72"wmlLEFT="80" WIDTH="72"wmloutp1.oLEFT="160" WIDTH="356"wmluiltokLEFT="0" WIDTH="72"wml.oLEFT="80" WIDTH="72"wmlparse.cLEFT="160" WIDTH="356"wmlutils.oLEFT="0" WIDTH="72"wmllex.cLEFT="80" WIDTH="72"wmlparse.hLEFT="160" WIDTH="356"LEFT="0" WIDTH="72"wmlouth.oLEFT="80" WIDTH="72"wmlparse.oLEFT="160" WIDTH="356"LBL="A-2"Table A-2 LBL="A.1.2" HELPID=""ID="41774"Running WMLBuilding Motif runs WML, installs the resulting files in the UIL source directory, and builds the UIL compiler.  A developer who does not want to install or build UIL can also run WML separately.  Running WML automatically builds the WML source files if necessary.  The make motif.wmd command from the tools/wml directory runs the WML facility.  The make variable TABLE specifies the WML file to use, as in the following example:make motif.wmd TABLE=anyfile.wml† †where anyfile.wml is a WML file in the tools/wml directory.  The default WML file is motif.wml.  Running WML produces the following files: UIL source filesWML produces the following files, which make copy copies to the clients/uil directory to be used in building UIL: COLUMNS="3"LEFT="0" WIDTH="72"UilConst.hLEFT="80" WIDTH="72"UilSymArTy.hLEFT="160" WIDTH="356"UilSymRArg.hLEFT="0" WIDTH="72"UilDBDef.hLEFT="80" WIDTH="72"UilSymCSet.hLEFT="160" WIDTH="356"UilSymReas.hLEFT="0" WIDTH="72"UilKeyTab.hLEFT="80" WIDTH="72"UilSymCtl.hLEFT="160" WIDTH="356"UilTokName.hLEFT="0" WIDTH="72"UilLexPars.cLEFT="80" WIDTH="72"UilSymEnum.hLEFT="160" WIDTH="356"UilUrmClas.hLEFT="0" WIDTH="72"UilLexPars.hLEFT="80" WIDTH="72"UilSymGen.hLEFT="160" WIDTH="356"LEFT="0" WIDTH="72"UilSymArTa.hLEFT="80" WIDTH="72"UilSymNam.hLEFT="160" WIDTH="356"LBL="A-3"Table A-3 wml.reportThis report describes the widget set supported by the newly created UIL sources.  It is intended to help validate the WML source file.  It is organized as follows: Class names are ordered alphabetically by name.  Resources are ordered by ancestor, from the top down.  Resources are listed alphabetically within ancestor, along with data types and default values.  Reasons are ordered alphabetically within ancestor.  Controls are ordered alphabetically.  Automatically created children are ordered alphabetically.  wml-uil.mmThis file contains the information in Appendix B of the OSF/Motif Programmer's Reference.  This file can be processed by tbl, troff, and the mm macro package to produce three tables for each supported widget class: Controls and reasons supported by the class Resources for the class, including their types and default values Automatically created children of the class motif.wmdThis is the default WMD file.  These files overwrite any existing WML output files in the tools/wml directory.  LBL="A.1.3" HELPID=""Installing UILA developer can use the make command from the tools/wml directory to install the UIL source files in the clients/uil directory without rebuilding UIL.  The make all and make copy commands are synonyms for the make command.  This command automatically builds the WML source files and runs WML if necessary.  It overwrites the existing source files in the clients/uil directory.  See the previous section, IDREF="41774" TYPE="TITLE"Section A.1.2, "Running WML,"
 for more information on using the make command in the tools/wml directory.  LBL="A.1.4" HELPID=""Building UILA developer can use the make command from the clients/uil directory to build UIL, as in the following example: cd clients/uil† †
make† †See the OSF/Motif Release Notes for more information about building UIL.  LBL="B"ID="61196"Drag and Drop Example ProgramID="appb1"The DNDDemo program is a complex drag and drop application.  It uses many of the features covered in IDREF="41117" TYPE="TITLE"Chapter 15, "Drag and Drop."
  The application uses both drag source and drop sites.  The window, shown in IDREF="40102" TYPE="GRAPHIC"Figure B-1
, consists of an array of 6 colors in the lower section, with an empty drawing area in the upper section.  The user can create a black box within the drawing area by pressing and holding mouse button 1 while moving the mouse until the desired size rectangle is outlined, then releasing the button.  There can be as many rectangles as desired and they can overlap each other.  A rectangle can be raised to the top by clicking mouse button 1 on it.  The user can change the color of a particular rectangle by moving the pointer to one of the six color choices, pressing button 2, and moving the pointer to the rectangle.  A palette in that color becomes the drag icon.  The state icon does not appear while the drag icon is in the lower section.  It shows as a slashed circle in the background of the upper section, and as a paintbrush in the rectangles.  When the mouse button is released to make a drop, the rectangle changes to the color chosen.  If the rectangle is overlapped by another, the whole rectangle is changed, but only the unobscured part is shown in the new color.  The user can move the rectangles around the drawing area by pressing button 2 when the pointer is over the rectangle, holding it, and moving the mouse until the new location is reached.  If the rectangle is small enough, it is used to create a pixmap for the source drag icon; otherwise, a similarly shaped, smaller pixmap is used for the source icon.  The program demonstrates the following drag and drop features: Drag Source Establishes translations Establishes custom drag source targets Starts a drag and creates a drag context Creates custom drag icons Transfers information to the receiver (about color or location) Drop Site Establishes simulated drop sites Establishes custom drop site targets Follows the progress of the drag with an XmNdragProc routine.  ID="appb2"Requests transfer of information from the source (about color or location) The demonstration program consists of three files: DNDDemo.h contains header information, global constants, and forward declarations of procedures.  DNDDemo.c creates the windows and manages the drag and drop functions.  DNDDraw.c does not have any drag and drop specific code in it.  It manages creating, coloring, and destroying the rectangles and bitmaps within the window.  LBL="B-1" FILE="dnddemo2.gif" POSITION="INLINE" SCALE="FALSE"LBL="B-1"Figure B-1 ID="40102"Drag and Drop DemonstrationLBL="B.1" HELPID=""DNDDemo.h/*
† †*    file: DNDDemo.h
† †*
† †*     Header file for the program DNDDemo.
† †*/
#include <stdio.h>
#include <X11/Xatom.h>
#include <X11/Intrinsic.h>
#include <Xm/Xm.h>
#include <Xm/AtomMgr.h>
#include <Xm/MainW.h>
#include <Xm/DrawingA.h>
#include <Xm/SeparatoG.h>
#include <Xm/Form.h>
#include <Xm/RowColumn.h>
#include <Xm/PushB.h>
#include <Xm/MessageB.h>
#include <Xm/DragDrop.h>
#include <Xm/Screen.h>
/* The following is used to layout the color labels */
#define BOX_WIDTH       85
#define BOX_HEIGHT      25
#define BOX_X_OFFSET    95
#define BOX_Y_OFFSET    35
#define BOX_X_MARGIN    10
#define BOX_Y_MARGIN    10
/* The following are used in setting up the drag icons */
#define ICON_WIDTH          32
#define ICON_HEIGHT         32
#define SMALL_ICON_WIDTH    16
#define SMALL_ICON_HEIGHT   16
#define ICON_X_HOT          0
#define ICON_Y_HOT          0
/* Some scales or text entry field could be added to change 
† †* this value */
#define RECT_WIDTH  20
#define RECT_HEIGHT 50
/* The following defines could be setup as application resources */
#define RECT_START_COLOR    "black"
#define HIGHLIGHT_THICKNESS 3
#define HIGHLIGHT_COLOR     "Black"   /* this is equivalent to 
† †                                        gray60 in the R5
† †                                        rgb.txt */
#define DRAW_AREA_BG_COLOR "white"
#define DRAW_AREA_FG_COLOR "white"
#define LABEL1_COLOR       "#ff5026"     /* a soft shade of
† †                                           red */
#define LABEL2_COLOR    "orange"
#define LABEL3_COLOR    "yellow"
#define LABEL4_COLOR    "violet"
#define LABEL5_COLOR    "#00C3ff"           /* a blue green color */
#define LABEL6_COLOR    "green"
#define VALID_CURSOR_FG_COLOR   "black"
#define INVALID_CURSOR_FG_COLOR "maroon"
#define NONE_CURSOR_FG_COLOR    "maroon"
/*
† †* This struct is used to contain information about each rectangle 
† †* to use in the dislay routines
† †*/
typedef struct _RectStruct {
† †   Position x;
† †   Position y;
† †   Dimension width;
† †   Dimension height;
† †   Pixel color;
† †   Pixmap pixmap;   /* currently not in use */
} RectStruct, *RectPtr;
/* This struct is used to hold global application information */
typedef struct _AppInfoRec {
† †   GC rectGC;              /* graphic context used to draw the 
† †                              rectangles */
† †   Pixel currentColor;     /* color that is currently in the
† †                              GC */
† †   RectPtr *rectDpyTable;  /* the rectangle display table */
† †   int rectsAllocd;        /* keeps track of how much the
† †                              above
† †                              table has been alloc'd */
† †   int numRects;           /* number of rects that are
† †                              visible */
† †   RectPtr highlightRect;  /* the current highlighted
† †                              rectangle */
† †   RectPtr clearRect;      /* the rectangle that is being
† †                              moved */
† †   Boolean doMove;         /* indicates that a move is being 
† †                              performed */
† †   Boolean creatingRect;   /* indicates that a rect create is
† †                              being 
† †                              performed */
† †   unsigned char operation;/* indicates the drop help
† †                              operation */
† †   unsigned int maxCursorWidth;  /* the maximum allowable
† †                                    cursor width */
† †   unsigned int maxCursorHeight; /* the maximum allowable
† †                                    cursor height */
† †   Position rectX;
† †   Position rectY;
† †   Position rectX2;
† †   Position rectY2;
} AppInfoRec, *AppInfo;
/*
† †* This struct is used to pass information
† †* from the dropProc to the transferProc
† †*/
typedef struct _DropTransferRec {
† †   Widget widget;
† †   Position x;
† †   Position y;
} DropTransferRec, *DropTransfer;
/*
† †* This struct is used to pass information
† †* from the rectangle dragStart proc to it's associated
† †* callback procs.
† †*/
typedef struct _DragConvertRec {
† †   Widget widget;
† †   RectPtr rect;
} DragConvertRec, *DragConvertPtr;
#ifdef _NO_PROTO
extern void     InitializeAppInfo();
extern void     StartRect();
extern void     ExtendRect();
extern void     EndRect();
extern RectPtr  RectCreate();
extern RectPtr  RectFind();
extern void     RectSetColor();
extern Pixel    RectGetColor();
extern Pixmap   GetBitmapFromRect();
extern void     RectHide();
extern void     RectFree();
extern void     RedrawRectangles();
extern void     RectDrawStippled();
extern void     RectHighlight();
extern void     RectUnhighlight();
extern void     RectSetPixmap();
extern void     RectRegister();
extern void     InitializeRectDpyTable();
extern void     CreateLayout();
extern void     CreateRectGC();
extern Pixel    GetColor();
extern void     ColorRect();
#else
extern void     InitializeAppInfo(void);
extern void     StartRect(Widget, XEvent *, String *,
† †                                           Cardinal *);
extern void     ExtendRect(Widget, XEvent *, String *,
† †                                            Cardinal *);
extern void     EndRect(Widget, XEvent *, String *,
† †                                         Cardinal*);
extern RectPtr  RectCreate(Position, Position, Dimension,
† †                            Dimension, Pixel, Pixmap);
extern RectPtr  RectFind(Position, Position);
extern void     RectSetColor(RectPtr, Display *, Window,
† †                                                 Pixel);
extern Pixel    RectGetColor(RectPtr);
extern Pixmap   GetBitmapFromRect(Widget, RectPtr, Pixel,
† †                             Pixel, Dimension *, Dimension *);
extern void     RectHide(Display *, Window, RectPtr);
extern void     RectFree(RectPtr);
extern void     RedrawRectangles(Widget);
extern void     RectDrawStippled(Display *, Window, RectPtr);
extern void     RectHighlight(Widget, RectPtr);
extern void     RectUnhighlight(Widget);
extern void     RectSetPixmap(RectPtr, Display *, Window,
† †                                                 Pixmap);
extern void     RectRegister(RectPtr, Position, Position);
extern void     InitializeRectDpyTable(void);
extern void     CreateLayout(void);
extern void     CreateRectGC(void);
extern Pixel    GetColor(char *);
extern void     ColorRect(Widget, XEvent *, String *,
† †                                           Cardinal *);
#endif    /* _NO_PROTO */
/* The following character arrays hold the bits for the source
† †* and state icons for both 32x32 and 16x16 drag icons.  The
† †* source is a color palette icon and the state is a paint
† †* brush icon.
† †*/
extern char SOURCE_ICON_BITS[];
extern char SOURCE_ICON_MASK[];
extern char STATE_ICON_BITS[];
extern char STATE_ICON_MASK[];
extern char INVALID_ICON_BITS[];
extern char SMALL_SOURCE_ICON_BITS[];
extern char SMALL_SOURCE_ICON_MASK[];
extern char SMALL_STATE_ICON_BITS[];
extern char SMALL_STATE_ICON_MASK[];
extern char SMALL_INVALID_ICON_BITS[];
/* The folowing character arrays are for use with the drop help
† †* dialogs.  For internationalization, message catalogs should
† †* replace these static declarations.
† †*/
extern char HELP_MSG1[];
extern char HELP_MSG2[];
extern char HELP_MSG3[];
extern char HELP_MSG4[];
extern char HELP_MSG5[];
/* Globals variables */
extern AppInfo      appInfo;
extern Widget       topLevel;
extern Widget       drawingArea;
extern Widget       helpDialog;
extern Widget       helpLabel, helpMenu;
extern XtAppContext appContext;LBL="B.2" HELPID=""DNDDemo.c/*
† †*    file: DNDDemo.c
† †*
† †*     A demo program showing the basic Drag And Drop operations.
† †*/
#include "DNDDemo.h"
/*
† †* The folowing character arrays are for use with the drop help
† †* dialogs.  For internationalization, message catalogs should
† †* replace these static declarations.
† †*/
char HELP_MSG1[] = 
"This drop action will change the color\n\
of the rectangle that the paint palette\n\
icon is dropped on. To accept this drop\n\
press the o.k. button, otherwise press\n\
cancel";
char HELP_MSG2[] = 
"This drop action will move the rectangle\n\
to the new position.  To accept this drop\n\
press the o.k. button, otherwise press\n\
cancel";
char HELP_MSG3[] = 
"This drop action will copy the rectangle\n\
to the new position.  To accept this drop\n\
press the o.k. button, otherwise press\n\
cancel";
char HELP_MSG4[] = 
"This drop action can either copy or\n\
move the rectangle to the new position.\n\
Select the operation that you desire.\n\
In the future, use Ctrl with Btn2 to\n\
perform copy operations.  The default\n\
operation is move.  To accept this drop\n\
press the o.k. button, otherwise press\n\
cancel";
char HELP_MSG5[] = 
"This drop action is at an Invalid drop\n\
position.  Please cancel this drop \n\
by pressing the cancel button.";
/* Globals variables */
Widget          topLevel;
Widget          drawingArea;
Widget          helpDialog = NULL;
Widget          helpLabel, helpMenu;
Widget          myDC;
XtAppContext    appContext;
/* This function creates the Drag Icon. */
static Widget
#ifdef _NO_PROTO
GetDragIcon(w, icon, iconMask, width, height, background, 
† †           foreground)
Widget w;
Pixmap icon;
Pixmap iconMask;
Dimension width;
Dimension height;
Pixel background;
Pixel foreground;
#else
GetDragIcon(Widget w, Pixmap icon, Pixmap iconMask, Dimension width,
Dimension height, Pixel background, Pixel foreground)
#endif /* _NO_PROTO */
{
† †   Widget  dragIcon;
† †   Arg     args[10];
† †   int     n = 0;
† †   XtSetArg(args[n], XmNhotX, ICON_X_HOT); n++;
† †   XtSetArg(args[n], XmNhotY, ICON_Y_HOT); n++;
† †   XtSetArg(args[n], XmNwidth, width); n++;
† †   XtSetArg(args[n], XmNheight, height); n++;
† †   XtSetArg(args[n], XmNmaxWidth, appInfo->maxCursorWidth);
† †                                                       n++;
† †   XtSetArg(args[n], XmNmaxHeight, appInfo->maxCursorHeight);
† †                                                         n++;
† †   XtSetArg(args[n], XmNbackground, background); n++;
† †   XtSetArg(args[n], XmNforeground, foreground); n++;
† †   XtSetArg(args[n], XmNpixmap, icon); n++;
† †   XtSetArg(args[n], XmNmask, iconMask); n++;
† †   dragIcon = XmCreateDragIcon(w, "dragIcon", args, n);
† †   return(dragIcon);
}
/* This function creates the bitmaps for the icon and the mask
† †* and then calls GetDragIcon() to  create the drag icon.
† †*/
static Widget
#ifdef _NO_PROTO
GetDragIconFromBits(w, bits, mask, width, height, background, 
† †                   foreground)
Widget w;
char *bits;
char *mask;
Dimension width;
Dimension height;
Pixel background;
Pixel foreground;
#else
GetDragIconFromBits(Widget w, char *bits, char *mask, 
† †                   Dimension width, Dimension height, 
† †                   Pixel background, Pixel foreground)
#endif /* _NO_PROTO */
{
† †   Pixmap     icon, iconMask;
† †   Display    *display = XtDisplay(w);
† †   icon = XCreateBitmapFromData(display, 
† †               DefaultRootWindow(display), bits, width,
† †                                                 height);
† †   iconMask = XCreateBitmapFromData(display, 
† †               DefaultRootWindow(display), mask, width,
† †                                                 height);
† †   return(GetDragIcon(w, icon, iconMask, width, height, 
† †                      background, foreground));
}
/* This function creates the rectangle bitmaps for the icon and
† †* the mask based on the maximum server allowable cursor size
† †* and then calls GetDragIcon() to create the drag icon.
† †*/
static Widget
#ifdef _NO_PROTO
GetDragIconFromRect(w, rect, background)
Widget w;
RectPtr rect;
Pixel background;
#else
GetDragIconFromRect(Widget w, RectPtr rect, Pixel background)
#endif /* _NO_PROTO */
{
† †   Pixmap      icon, icon_mask;
† †   Pixel       foreground = RectGetColor(rect);
† †   Dimension   width, height;
† †   /* Create a depth 1 pixmap (bitmap) for use with the drag 
† †      icon */
† †   icon = icon_mask = GetBitmapFromRect(w, rect, background, 
† †                           foreground, &width, &height);
† †   /* use bitmap for both the bitmap and mask */
† †   return(GetDragIcon(w, icon, icon_mask, width, height, 
† †                      background, foreground));
}
/* This is a selection conversion function that is used in
† †* converting drag/drop export background color targets.
† †* The return types follow ICCC standards.
† †*/
/* ARGSUSED */
Boolean
#ifdef _NO_PROTO
ColorConvert(w, selection, target, type, value, length, format)
Widget w ;
Atom *selection ;
Atom *target ;
Atom *type ;
XtPointer *value ;
unsigned long *length ;
int *format ;
#else
ColorConvert(Widget w, Atom *selection, Atom *target, Atom *type,
XtPointer *value, unsigned long *length, int *format)
#endif /* _NO_PROTO */
{
† †   Display     *display = XtDisplay(w);
† †   Atom        BACKGROUND = XmInternAtom(display,
† †                                         "BACKGROUND", False);
† †   Atom        PIXEL = XmInternAtom(display, "PIXEL", False);
† †   Atom        TARGETS = XmInternAtom(display, "TARGETS",
† †                                                    False);
† †   Atom        MULTIPLE = XmInternAtom(display, "MULTIPLE",
† †                                                    False);
† †   Atom        TIMESTAMP = XmInternAtom(display, "TIMESTAMP", 
† †                                                    False);
† †   int         MAX_TARGS = 5;
† †   Widget      widget;
† †   XtPointer   client;
† †   Arg         args[1];
† †   /* get the widget that initiated the drag */
† †   XtSetArg(args[0], XmNclientData, &client);
† †   XtGetValues(w, args, 1);
† †   widget = (Widget) client;
† †   /* Make sure we are doing a motif drag by checking if the 
† †    * widget that is passed in is a drag context. Make sure
† †    * the widget in the client data is not NULL.
† †    */
† †   if (!XmIsDragContext(w) || widget == NULL)
† †       return False;
† †   if (*target == BACKGROUND) {
† †       /* Get widget's background */
† †       Pixel *background;
† †       background = (Pixel *) XtMalloc(sizeof(Pixel));
† †       XtSetArg(args[0], XmNbackground, background);
† †       XtGetValues(widget, args, 1);
† †       /* value, type, length, and format must be set */
† †       *value = (XtPointer) background;
† †       *type = PIXEL;
† †       *length = sizeof(Pixel);
† †       *format = 32;
† †   }
† †   else if (*target == TARGETS) {
† †       /* This target is required by ICCC */
† †       Atom *targs = (Atom *)XtMalloc((unsigned) 
† †                                (MAX_TARGS * sizeof(Atom)));
† †       int target_count = 0;
† †       *value = (XtPointer) targs;
† †       *targs++ = BACKGROUND; 
† †       target_count++;
† †       *targs++ = TARGETS; 
† †       target_count++;
† †       *targs++ = MULTIPLE; 
† †       target_count++;  /* supported in the Intrinsics */
† †       *targs++ = TIMESTAMP; 
† †       target_count++; /* supported in the Intrinsics */
† †       *type = XA_ATOM;
† †       *length = (target_count * sizeof(Atom)) >> 2;
† †       *format = 32;
† †   }
† †   else
† †       return False;
† †   return True;
}
/* This callback procedure resets the drag icon cursor to show
† †* when the drag is in a valid region .  It cause the
† †* state icon to become visible when a drop is at a valid
† †* position for drag over effects.
† †*/
static void
#ifdef _NO_PROTO
DragMotionCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
#else
DragMotionCallback(Widget w, XtPointer client, XtPointer call)
#endif /* _NO_PROTO */
{
† †   XmDragMotionCallback    cb = (XmDragMotionCallback) call;
† †   Arg                     args[2];
† †   Widget                  stateIcon, invalidIcon;
† †   if (cb->dropSiteStatus == XmVALID_DROP_SITE) {
† †       stateIcon = (Widget) client;
† †       XtSetArg(args[0], XmNblendModel, XmBLEND_STATE_SOURCE);
† †       XtSetArg(args[1], XmNstateCursorIcon, stateIcon);
† †       XtSetValues(w, args, 2);
† †   }
† †   else if (cb->dropSiteStatus == XmINVALID_DROP_SITE) {
† †       XtSetArg(args[0], XmNdefaultInvalidCursorIcon, 
† †                &invalidIcon);
† †       XtGetValues(XmGetXmScreen(XtScreen(w)), args, 1);
† †       XtSetArg(args[0], XmNblendModel, XmBLEND_STATE_SOURCE);
† †       XtSetArg(args[1], XmNstateCursorIcon, invalidIcon);
† †       XtSetValues(w, args, 2);
† †   }
† †   else {
† †       XtSetArg(args[0], XmNblendModel, XmBLEND_JUST_SOURCE);
† †       XtSetValues(w, args, 1);
† †   }
}
/* This callback procedure resets the drag icon cursor to show
† †* when the drag is in a valid region .  It cause the
† †* state icon to become visible when a drop is at a valid
† †* position for drag over effects.
† †*/
/* ARGSUSED */
static void
#ifdef _NO_PROTO
DropSiteLeaveCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
#else
DropSiteLeaveCallback(Widget w, XtPointer client, XtPointer call)
#endif /* _NO_PROTO */
{
† †   Arg    args[1];
† †   XtSetArg(args[0], XmNblendModel, XmBLEND_JUST_SOURCE);
† †   XtSetValues(w, args, 1);
}
/* This callback procedure removes the icons when the drop is 
† †* complete */
/* ARGSUSED */
static void
#ifdef _NO_PROTO
ColorDragDropFinishCB(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
#else
ColorDragDropFinishCB(Widget w, XtPointer client, XtPointer call)
#endif /* _NO_PROTO */
{
† †   Widget  sourceIcon;
† †   Widget  stateIcon = (Widget) client;
† †   Arg     args[1];
† †   XtSetArg(args[0], XmNsourceCursorIcon, &sourceIcon);
† †   XtGetValues(w, args, 1);
† †   XtDestroyWidget(sourceIcon);
† †   XtDestroyWidget(stateIcon);
}
/* This action procedure sets up the drag data and begins the drag 
† †* operation */
/* ARGSUSED */
void
#ifdef _NO_PROTO
ColorRect(w, event, params, num_params)
Widget w;
XEvent *event;
String *params;
Cardinal *num_params;
#else
ColorRect(Widget w, XEvent *event, String *params, 
† †         Cardinal *num_params)
#endif /* _NO_PROTO */
{
† †   static XtCallbackRec dragDropFinishCB[] = { 
† †       {ColorDragDropFinishCB, NULL},
† †       {NULL, NULL} 
† †   };
† †   static XtCallbackRec dragMotionCB[] = { 
† †       {DragMotionCallback, NULL},
† †       {NULL, NULL} 
† †   };
† †   static XtCallbackRec dropSiteLeaveCB[] = { 
† †       {DropSiteLeaveCallback, NULL},
† †       {NULL, NULL} 
† †   };
† †   Atom        targets[1];
† †   Widget      sourceIcon, stateIcon;
† †   Pixel       background, foreground;
† †   char        *source_bits, *source_mask;
† †   char        *state_bits, *state_mask;
† †   Dimension   width, height;
† †   Arg         args[16];
† †   int         n = 0;
† †   n = 0;
† †   XtSetArg(args[n], XmNbackground, &background); n++;
† †   XtSetArg(args[n], XmNforeground, &foreground); n++;
† †   XtGetValues(w, args, n);
† †   /* If the server will handle a large icon, create one */
† †   if (appInfo->maxCursorWidth >= ICON_WIDTH &&
† †       appInfo->maxCursorHeight >= ICON_HEIGHT) {
† †       source_bits = SOURCE_ICON_BITS;
† †       source_mask = SOURCE_ICON_MASK;
† †       state_bits = STATE_ICON_BITS;
† †       state_mask = STATE_ICON_MASK;
† †       width = ICON_WIDTH;
† †       height = ICON_HEIGHT;
† †   }
† †   else {
† †       /*If the server will handle a small icon, create one*/
† †       source_bits = SMALL_SOURCE_ICON_BITS;
† †       source_mask = SMALL_SOURCE_ICON_MASK;
† †       state_bits = SMALL_STATE_ICON_BITS;
† †       state_mask = SMALL_STATE_ICON_MASK;
† †       width = SMALL_ICON_WIDTH;
† †       height = SMALL_ICON_HEIGHT;
† †   }
† †   /* Create the drag cursor icons */
† †   sourceIcon = GetDragIconFromBits(w, source_bits,
† †                     source_mask, width, height, background,
† †                     foreground);
† †   stateIcon = GetDragIconFromBits(w, state_bits, state_mask, 
† †                     width, height, background, foreground);
† †   /* Setup the arglist for the drag context that is created
† †    * at drag start */
† †   n = 0;
† †   /* initially only show the source icon */
† †   XtSetArg(args[n], XmNblendModel, XmBLEND_JUST_SOURCE); n++;
† †   /* set cursor colors for the drag states */
† †   XtSetArg(args[n], XmNvalidCursorForeground, 
† †            GetColor(VALID_CURSOR_FG_COLOR)); n++;
† †   XtSetArg(args[n], XmNinvalidCursorForeground,
† †            GetColor(INVALID_CURSOR_FG_COLOR)); n++;
† †   XtSetArg(args[n], XmNnoneCursorForeground,
† †            GetColor(NONE_CURSOR_FG_COLOR)); n++;
† †   /* set args for the drag cursor icons */
† †   XtSetArg(args[n], XmNcursorBackground, background); n++;
† †   XtSetArg(args[n], XmNcursorForeground, foreground); n++;
† †   XtSetArg(args[n], XmNsourceCursorIcon, sourceIcon); n++;
† †   XtSetArg(args[n], XmNstateCursorIcon, stateIcon); n++;
† †   /*
† †    * set up the available export targets.  These are targets
† †    * that we wish to provide data on
† †    */
† †   targets[0] = XmInternAtom(XtDisplay(w), "BACKGROUND",
† †                                            False);
† †   XtSetArg(args[n], XmNexportTargets, targets); n++;
† †   XtSetArg(args[n], XmNnumExportTargets, 1); n++;
† †   /*
† †    * identify the conversion procedure and
† †    * the client data passed to the procedure
† †    */
† †   XtSetArg(args[n], XmNclientData, w); n++;
† †   XtSetArg(args[n], XmNconvertProc, ColorConvert); n++;
† †   /* identify the necessary callbacks */
† †   dragDropFinishCB[0].closure = (XtPointer) stateIcon;
† †   XtSetArg(args[n], XmNdragDropFinishCallback,
† †                     dragDropFinishCB); 
† †   n++;
† †   dragMotionCB[0].closure = (XtPointer) stateIcon;
† †   XtSetArg(args[n], XmNdragMotionCallback, dragMotionCB);
† †   n++;
† †   XtSetArg(args[n], XmNdropSiteLeaveCallback, dragMotionCB);
† †   n++;
† †   /* set the drag operations that are supported */
† †   XtSetArg(args[n], XmNdragOperations, XmDROP_COPY); n++;
† †   /* start the drag.  This creates a drag context. */
† †   myDC = XmDragStart(w, event, args, n);
}
/*
† †* This is a selection conversion function that is used in
† †* converting requests for rectangle targets.  The return types 
† †* follow ICCC standards.
† †*/
/* ARGSUSED */
Boolean
#ifdef _NO_PROTO
RectConvert( w, selection, target, type, value, length, format)
Widget w ;
Atom *selection ;
Atom *target ;
Atom *type ;
XtPointer *value ;
unsigned long *length ;
int *format ;
#else
RectConvert(Widget w, Atom *selection, Atom *target, Atom *type,
XtPointer *value, unsigned long *length, int *format)
#endif /* _NO_PROTO */
{
† †   Display  *display = XtDisplay(w);
† †   Atom     MY_RECT = XmInternAtom(display, "_MY_RECTANGLE",
† †                                                     False);
† †   Atom     RECT_INFO = XmInternAtom(display, "RECT_INFO",
† †                                                     False);
† †   Atom     DELETE = XmInternAtom(display, "DELETE", False);
† †   Atom     TARGETS = XmInternAtom(display, "TARGETS", False);
† †   Atom     MULTIPLE = XmInternAtom(display, "MULTIPLE",
† †                                                     False);
† †   Atom     TIMESTAMP = XmInternAtom(display, "TIMESTAMP",
† †                                                     False);
† †   Atom     *targs;
† †   int      MAX_TARGS = 6;
† †   int      target_count;
† †   DragConvertPtr  conv;
† †   Widget   widget;
† †   Arg      args[1];
† †   RectPtr  rect, oldRect;
† †   /* get the widget that initiated the drag */
† †   XtSetArg(args[0], XmNclientData, &conv);
† †   XtGetValues(w, args, 1);
† †   widget = (Widget) conv->widget;
† †   /* Make sure we are doing a motif drag by checking if the 
† †    * widget that is passed in is a drag context. Make sure
† †    * the widget in the client data is not NULL.
† †    */
† †   if (!XmIsDragContext(w) || widget == NULL)
† †       return False;
† †   if (*target == MY_RECT) {
† †       /* Create a new rectangle using information from the
† †          old retangle */
† †       oldRect = conv->rect;
† †       /* We create create a new rectangle and wait for a
† †        * delete target on the old rectangle instead of just
† †        * moving the old rectangle because the rectangle
† †        * movement might be an interclient move.
† †        */
† †       rect = RectCreate(oldRect->x, oldRect->y,
† †                         oldRect->width, oldRect->height,
† †                         oldRect->color, oldRect->pixmap);
† †       /* value, type, length, and format must be assigned
† †          values */
† †       *value = (XtPointer) rect;
† †       *type = RECT_INFO;
† †       *length = sizeof(Pixel);
† †       *format = 32;
† †   }
† †   else if (*target == DELETE) {
† †       /* delete the old rectangle */
† †       RectHide(XtDisplay(widget), XtWindow(widget),
† †                                        conv->rect);
† †       RectFree(conv->rect);
† †       conv->rect = NULL;
† †       /*
† †        * DELETE target return parameters MUST be assigned as 
† †        * follows to ICCC compliant.
† †        */
† †       *value = NULL;
† †       *type = XmInternAtom(XtDisplay(w), "NULL", False);
† †       *length = 0;
† †       *format = 8;
† †   }
† †   else if (*target == TARGETS) {
† †       /* This target is required by ICCC */
† †       targs = (Atom *)XtMalloc((unsigned)
† †                                (MAX_TARGS * sizeof(Atom)));
† †       target_count = 0;
† †       *value = (XtPointer) targs;
† †       *targs++ = MY_RECT; 
† †       target_count++;
† †       *targs++ = DELETE; 
† †       target_count++;
† †       *targs++ = TARGETS; 
† †       target_count++;
† †       *targs++ = MULTIPLE; 
† †       target_count++;  /* supported in the Intrinsics */
† †       *targs++ = TIMESTAMP; 
† †       target_count++; /* supported in the Intrinsics */
† †       *type = XA_ATOM;
† †       *length = (target_count * sizeof(Atom)) >> 2;
† †       *format = 32;
† †   }
† †   else
† †       return False;
† †   return True;
}
/* This callback procedure removes the old cursor icon */
/* ARGSUSED */
static void
#ifdef _NO_PROTO
RectDragDropFinishCB(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
#else
RectDragDropFinishCB(Widget w, XtPointer client, XtPointer call)
#endif /* _NO_PROTO */
{
† †   DragConvertPtr  conv = (DragConvertPtr) client;
† †   Widget          sourceCursorIcon;
† †   Arg             args[1];
† †   XtSetArg(args[0], XmNsourceCursorIcon, &sourceCursorIcon);
† †   XtGetValues(w, args, 1);
† †   XtFree((char *) conv);
† †   XtDestroyWidget(sourceCursorIcon);
}
/* This callback procedure redraws the rectangles once the drop 
† †* is completed */
/* ARGSUSED */
static void
#ifdef _NO_PROTO
RectDropFinishCB(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
#else
RectDropFinishCB(Widget w, XtPointer client, XtPointer call)
#endif /* _NO_PROTO */
{
† †   DragConvertPtr    conv = (DragConvertPtr) client;
† †   appInfo->clearRect = NULL;
† †   appInfo->doMove = True;
† †   RedrawRectangles(conv->widget);
}
/* This callback procedure handle the drawing of the target
† †* rectangle depending of the dropSiteStatus for drag over
† †* effects.
† †*/
/* ARGSUSED */
static void
#ifdef _NO_PROTO
RectDragMotionCB(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
#else
RectDragMotionCB(Widget w, XtPointer client, XtPointer call)
#endif /* _NO_PROTO */
{
† †   XmDragMotionCallback    cb = (XmDragMotionCallback) call;
† †   DragConvertPtr          conv = (DragConvertPtr) client;
† †   Display                 *display;
† †   Window                  window;
† †   RectPtr                 rect;
† †   if (cb->dropSiteStatus == XmVALID_DROP_SITE) {
† †       /* re-stipple the rectangle when the pointer is inside
† †        * the drop site */
† †       if ( appInfo->clearRect == NULL && appInfo->doMove) {
† †           display = XtDisplay(conv->widget);
† †           window = XtWindow(conv->widget);
† †           rect = conv->rect;
† †           RectHide(display, window, rect);
† †           RectDrawStippled(display, window, rect);
† †       }
† †   }
† †   else {
† †       /* re-fill the rectangle when the pointer is outside
† †        * the drop site */
† †       if (appInfo->clearRect != NULL && appInfo->doMove) {
† †           appInfo->clearRect = NULL;
† †           RedrawRectangles(conv->widget);
† †       }
† †   }
}
/* This callback procedure handle the drawing of the target
† †* rectangle When the operation changes.
† †*/
/* ARGSUSED */
static void
#ifdef _NO_PROTO
RectOperationChangedCB(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
#else
RectOperationChangedCB(Widget w, XtPointer client, XtPointer call)
#endif /* _NO_PROTO */
{
† †   XmDragMotionCallback    cb = (XmDragMotionCallback) call;
† †   DragConvertPtr          conv = (DragConvertPtr) client;
† †   Display                 *display;
† †   Window                  window;
† †   RectPtr                 rect;
† †   /* re-stipple the rectangle when the pointer is inside the
† †    * drop site */
† †   if ( appInfo->clearRect == NULL && appInfo->doMove) {
† †       display = XtDisplay(conv->widget);
† †       window = XtWindow(conv->widget);
† †       rect = conv->rect;
† †       RectHide(display, window, rect);
† †       RectDrawStippled(display, window, rect);
† †   }
† †   /* re-fill the rectangle when the operation changes to
† †    * copy */
† †   if (appInfo->clearRect != NULL && !appInfo->doMove) {
† †       appInfo->clearRect = NULL;
† †       RedrawRectangles(conv->widget);
† †   }
}
/* This action procedure sets up the drag data and begins the
† †* drag operation */
/* ARGSUSED */
static void
#ifdef _NO_PROTO
StartMove(w, event, params, num_params)
Widget w;
XEvent *event;
String *params;
Cardinal *num_params;
#else
StartMove(Widget w, XEvent *event, String *params, 
† †         Cardinal *num_params)
#endif /* _NO_PROTO */
{
† †   RectPtr     rect;
† †   Position    x = event->xbutton.x;
† †   Position    y = event->xbutton.y;
† †   static XtCallbackRec dragDropFinishCB[] = { 
† †       {RectDragDropFinishCB, NULL},
† †       {NULL, NULL} 
† †   };
† †   static XtCallbackRec dropFinishCB[] = { 
† †       {RectDropFinishCB, NULL},
† †       {NULL, NULL} 
† †   };
† †   static XtCallbackRec dragMotionCB[] = { 
† †       {RectDragMotionCB, NULL},
† †       {NULL, NULL} 
† †   };
† †   static XtCallbackRec operationChangedCB[] = { 
† †       {RectOperationChangedCB, NULL},
† †       {NULL, NULL} 
† †   };
† †   Atom            targets[1];
† †   Display         *display = XtDisplay(w);
† †   Widget          sourceCursorIcon;
† †   DragConvertPtr  conv;
† †   Pixel           background, foreground;
† †   Arg             args[16];
† †   int             n = 0;
† †   /* find a rectangle at the given x,y position */
† †   rect = RectFind(x, y);
† †   /* start move only if it begins on a rectangle */
† †   if (rect) {
† †       XtSetArg(args[0], XmNbackground, &background);
† †       XtGetValues(w, args, 1);
† †       foreground = RectGetColor(rect);
† †       sourceCursorIcon = GetDragIconFromRect(w, rect,
† †                                              background);
† †       /*
† †        * Set up information to pass to the convert
† †        * function and callback procs.
† †        */
† †       conv = (DragConvertPtr)
† †              XtMalloc(sizeof(DragConvertRec));
† †       conv->widget = w;
† †       conv->rect = rect;
† †       /* On a move operation, draw the current
† †      * rectangle as a stippled outline.
† †      */
† †       if (!(event->xbutton.state & ControlMask)) {
† †           RectHide(display, XtWindow(w), rect);
† †           RectDrawStippled(display, XtWindow(w), rect);
† †       }
† †       else
† †           appInfo->doMove = False;
† †       /* Setup arglist for the drag context that is created
† †        * at drag start */
† †       n = 0;
† †       /* initially only show the source icon */
† †       XtSetArg(args[n], XmNblendModel, XmBLEND_JUST_SOURCE);
† †       n++;
† †       /* set args for the drag cursor icons */
† †       XtSetArg(args[n], XmNcursorBackground, background);
† †       n++;
† †       XtSetArg(args[n], XmNcursorForeground, foreground);
† †       n++;
† †       XtSetArg(args[n], XmNsourceCursorIcon,
† †                             sourceCursorIcon); 
† †       n++;
† †       /*
† †        * set up the available export targets.  These are
† †        * targets that we wish to provide data on
† †        */
† †       targets[0] = XmInternAtom(display, "_MY_RECTANGLE",
† †                                                     False);
† †       XtSetArg(args[n], XmNexportTargets, targets); n++;
† †       XtSetArg(args[n], XmNnumExportTargets, 1); n++;
† †       /*
† †        * identify the conversion procedure and
† †        * the client data passed to the procedure 
† †        */
† †       XtSetArg(args[n], XmNclientData, conv); n++;
† †       XtSetArg(args[n], XmNconvertProc, RectConvert); n++;
† †       /* identify the necessary callbacks and the client
† †        * data to be passed */
† †       dragDropFinishCB[0].closure = (XtPointer) conv;
† †       XtSetArg(args[n], XmNdragDropFinishCallback, 
† †                                           dragDropFinishCB);
† †       n++;
† †       dropFinishCB[0].closure = (XtPointer) conv;
† †       XtSetArg(args[n], XmNdropFinishCallback,
† †                                   dropFinishCB); n++;
† †       dragMotionCB[0].closure = (XtPointer) conv;
† †       XtSetArg(args[n], XmNdragMotionCallback,
† †                                   dragMotionCB); n++;
† †       operationChangedCB[0].closure = (XtPointer) conv;
† †       XtSetArg(args[n], XmNoperationChangedCallback,
† †                                   operationChangedCB); n++;
† †       /* set the drag operations that are supported */
† †       XtSetArg(args[n], XmNdragOperations, 
† †                                   XmDROP_COPY |
† †                                   XmDROP_MOVE); n++;
† †       /* start the drag. This creates a drag context. */
† †       myDC = XmDragStart(w, event, args, n);
† †   }
}
/* This procedure searches through the export targets and
† †* returns flags to indicate which targets were found
† †*/
/* ARGSUSED */
static void
#ifdef _NO_PROTO
CheckTargets(w, display, rectFound, bgFound, pixFound)
Widget w;
Display *display;
Boolean *rectFound;
Boolean *bgFound;
Boolean *pixFound;
#else
CheckTargets(Widget w, Display *display, Boolean *rectFound,
Boolean *bgFound, Boolean *pixFound)
#endif /* _NO_PROTO */
{
† †   Atom        MY_RECT = XmInternAtom(display,"_MY_RECTANGLE", 
† †                                      False);
† †   Atom        BACKGROUND = XmInternAtom(display,"BACKGROUND", 
† †                                         False);
† †   Atom        PIXMAP = XmInternAtom(display, "PIXMAP",
† †                                                 False);
† †   Atom        *exportTargets;
† †   Cardinal    numExportTargets;
† †   Arg         args[2];
† †   int         n;
† †   /* Get list of transfer targets */
† †   n = 0;
† †   XtSetArg(args[0], XmNexportTargets, &exportTargets);
† †   XtSetArg(args[1], XmNnumExportTargets, &numExportTargets);
† †   XtGetValues(w, args, 2);
† †   /* initialize targets found flags */
† †   *rectFound = *bgFound = *pixFound = False;
† †   /* search through the export targets */
† †   for (n = 0; n < numExportTargets; n++) {
† †       if (exportTargets[n] == MY_RECT)
† †           *rectFound = True;
† †       else if (exportTargets[n] == BACKGROUND)
† †           *bgFound = True;
† †       else if (exportTargets[n] == PIXMAP)
† †           *pixFound = True;
† †   }
}
/* This procedure handles drop site messages and performs the
† †* appropriate drag under effects.
† †*/
/* ARGSUSED */
static void
#ifdef _NO_PROTO
DragProcCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
#else
DragProcCallback(Widget w, XtPointer client, XtPointer call)
#endif /* _NO_PROTO */
{
† †   XmDragProcCallbackStruct *cb = (XmDragProcCallbackStruct *) 
† †                                      call;
† †   Display                     *display = XtDisplay(w);
† †   Boolean                     rectFound, bgFound, pixFound;
† †   static unsigned char        initial_operations;
† †   static unsigned char        initial_operation;
† †   RectPtr                     rect;
† †   CheckTargets(cb->dragContext, display, &rectFound,
† †                 &bgFound, 
† †                &pixFound);
† †   switch(cb->reason) {
† †       case XmCR_DROP_SITE_ENTER_MESSAGE:
† †           /* save the value of the operations and operation 
† †            * fields */
† †           initial_operations = cb->operations;
† †           initial_operation = cb->operation;
† †           rect = RectFind(cb->x, cb->y);
† †           /* Remove any operations for the operations field 
† †            * which do not apply to the simulated drop site.
† †            */
† †           if (rect) {
† †               if (bgFound || pixFound) {
† †                   cb->operations = XmDROP_COPY;
† †                   RectHighlight(w, rect);
† †               }
† †               else if (rectFound) {
† †                   cb->operations = cb->operations & 
† †                                    (XmDROP_COPY |
† †                                     XmDROP_MOVE);
† †                   RectUnhighlight(w);
† †               }
† †           }
† †           else {
† †               cb->operations = initial_operations & 
† †                                (XmDROP_COPY | XmDROP_MOVE);
† †               RectUnhighlight(w);
† †           }
† †           /* Set operation to the valid operation preferred
† †            * by the simulated drop site or to XmDROP_NOOP if
† †            * the operations list does not * contain the
† †            * preferred operation.
† †            */
† †           if (rect) {
† †               if (bgFound || pixFound) {
† †                   if (cb->operations & XmDROP_COPY)
† †                       cb->operation = XmDROP_COPY;
† †                   else
† †                       cb->operation = XmDROP_NOOP;
† †               }
† †               else if (rectFound) {
† †                   if (cb->operations & XmDROP_MOVE)
† †                       cb->operation = XmDROP_MOVE;
† †                   else if (cb->operations & XmDROP_COPY)
† †                       cb->operation = XmDROP_COPY;
† †                   else
† †                       cb->operation = XmDROP_NOOP;
† †               }
† †           }
† †           else {
† †               if (rectFound) {
† †                   if (cb->operations & XmDROP_MOVE)
† †                       cb->operation = XmDROP_MOVE;
† †                   else if (cb->operations & XmDROP_COPY)
† †                       cb->operation = XmDROP_COPY;
† †                   else
† †                       cb->operation = XmDROP_NOOP;
† †               }
† †               else
† †                   cb->operation = initial_operation;
† †           }
† †           /*
† †            * Set dropSiteStatus to XmDROP_SITE_INVALID if the 
† †            * operation field is XmDROP_NOOP, or if there are
† †            * no common targets between the source and the
† †            * nested drop site.  Otherwise, set 
† †            * dropSiteStatus to XmDROP_SITE_VALID. 
† †            */
† †           if (cb->operation == XmDROP_NOOP ||
† †               (rect && (!rectFound && !bgFound &&
† †                         !pixFound)) ||
† †                        (!rect && !rectFound))
† †               cb->dropSiteStatus = XmINVALID_DROP_SITE;
† †           else
† †               cb->dropSiteStatus = XmVALID_DROP_SITE;
† †           /*
† †            * Display appropriate drag under visuals.  Only 
† †            * highlight the rectangle if we are changing
† †            * rectangle attributes.
† †            */
† †           if (rect && bgFound || pixFound &&
† †               cb->dropSiteStatus == XmVALID_DROP_SITE)
† †               RectHighlight(w, rect);
† †           break;
† †       case XmCR_DROP_SITE_LEAVE_MESSAGE:
† †           /* Only unhighlight the rectangle if previously 
† †            * highlighted */
† †           if (appInfo->highlightRect != NULL)
† †               RectUnhighlight(w);
† †           break;
† †       case XmCR_DROP_SITE_MOTION_MESSAGE:
† †           rect = RectFind(cb->x, cb->y);
† †           /*
† †            * Remove any operations for the operations field 
† †            * which do not 
† †            * apply to the simulated drop site.
† †            */
† †           if (rect) {
† †               if (bgFound || pixFound) {
† †                   cb->operations = XmDROP_COPY;
† †                   RectHighlight(w, rect);
† †               }
† †               else if (rectFound) {
† †                   cb->operations = cb->operations & 
† †                                    (XmDROP_COPY |
† †                                     XmDROP_MOVE);
† †                   RectUnhighlight(w);
† †               }
† †           }
† †           else {
† †               cb->operations = initial_operations & 
† †                                (XmDROP_COPY | XmDROP_MOVE);
† †               RectUnhighlight(w);
† †           }
† †           /*
† †            * Set operation to the valid operation preferred
† †            * by the simulated drop site or to XmDROP_NOOP if
† †            * the operations list does not * contain the
† †            * preferred operation.
† †            */
† †           if (rect) {
† †               if (bgFound || pixFound) {
† †                   if (cb->operations & XmDROP_COPY)
† †                       cb->operation = XmDROP_COPY;
† †                   else
† †                       cb->operation = XmDROP_NOOP;
† †               }
† †               else if (rectFound) {
† †                   if (cb->operations & XmDROP_MOVE)
† †                       cb->operation = XmDROP_MOVE;
† †                   else if (cb->operations & XmDROP_COPY)
† †                       cb->operation = XmDROP_COPY;
† †                   else
† †                       cb->operation = XmDROP_NOOP;
† †               }
† †           }
† †           else {
† †               if (rectFound) {
† †                   if (cb->operations & XmDROP_MOVE)
† †                       cb->operation = XmDROP_MOVE;
† †                   else if (cb->operations & XmDROP_COPY) 
† †                       cb->operation = XmDROP_COPY;
† †                   else 
† †                       cb->operation = XmDROP_NOOP;
† †               }
† †               else
† †                   cb->operation = initial_operation;
† †           }
† †           /*
† †            * Set dropSiteStatus to XmDROP_SITE_INVALID if the 
† †            * operation field is XmDROP_NOOP, or if there are
† †            * no common targets between the source and the
† †            * nested drop site.  Otherwise, set
† †            * dropSiteStatus to XmDROP_SITE_VALID.
† †            */
† †           if (cb->operation == XmDROP_NOOP ||
† †               (rect && (!rectFound && !bgFound &&
† †                         !pixFound)) ||
† †               (!rect && !rectFound))
† †               cb->dropSiteStatus = XmINVALID_DROP_SITE;
† †           else
† †               cb->dropSiteStatus = XmVALID_DROP_SITE;
† †           /*
† †            * Display appropriate drag under visuals.  Only 
† †            * highlight the rectangle if we are changing
† †            * rectangle attributes.
† †            */
† †           if (rect && bgFound || pixFound &&
† †               cb->dropSiteStatus == XmVALID_DROP_SITE)
† †               RectHighlight(w, rect);
† †           break;
† †       case XmCR_OPERATION_CHANGED:
† †           if (rectFound) {
† †               if (cb->operation == XmDROP_MOVE)
† †                   appInfo->doMove = True;
† †               else
† †                   appInfo->doMove = False;
† †           }
† †           break;
† †       default:
† †           /* other messages we consider invalid */
† †           cb->dropSiteStatus = XmINVALID_DROP_SITE;
† †           break;
† †   }
† †   /* allow animation to be performed */
† †   cb->animate = True;
}
/* This procedure handles the data that is being transfer */
/* ARGSUSED */
static void
#ifdef _NO_PROTO
TransferProcCallback(w, closure, seltype, type, value, length, 
† †                    format)
Widget w;
XtPointer closure ;
Atom *seltype ;
Atom *type ;
XtPointer value ;
unsigned long *length ;
int *format ;
#else
TransferProcCallback(Widget w, XtPointer closure, Atom *seltype, 
Atom *type, XtPointer value, unsigned long *length, int *format)
#endif /* _NO_PROTO */
{
† †   DropTransfer    transferRec = (DropTransfer) closure;
† †   Widget          wid = transferRec->widget;
† †   Display         *display = XtDisplay(wid);
† †   Atom    RECT_INFO = XmInternAtom(display, "RECT_INFO",
† †                                     False);
† †   Atom    PIXEL = XmInternAtom(display, "PIXEL", False);
† †   Atom    NULL_ATOM = XmInternAtom(display, "NULL", False);
† †   Arg             args[10];
† †   RectPtr         rect;
† †   int              n;
† †   /*
† †    * The delete target returns a NULL_ATOM type and value
† †    * equal to NULL so it isn't a failure.  Otherwise, check
† †    * for NULL value or targets that we don't support and set
† †    * transfer failure.
† †    */
† †   if (*type != NULL_ATOM && (!value ||
† †       (*type != RECT_INFO && *type != PIXEL && 
† †            *type != XA_DRAWABLE))) {
† †       n = 0;
† †       /*
† †        * On failures set both transferStatus to 
† †        * XmTRANSFER_FAILURE and numDropTransfers to 0.
† †        */
† †       XtSetArg(args[n], XmNtransferStatus,
† †                         XmTRANSFER_FAILURE); 
† †       n++;
† †       XtSetArg(args[n], XmNnumDropTransfers, 0); n++;
† †       XtSetValues(w, args, n);
† †       /* Free the value if there is one, or we would have a 
† †        * memory leak */
† †       if (value)
† †           XtFree(value);
† †       return;
† †   }
† †   /* Handle pixel type (i.e. change in background) */
† †   if (*type == PIXEL) {
† †       rect = RectFind(transferRec->x, transferRec->y);
† †       RectSetColor(rect, display, XtWindow(wid), 
† †                    *((Pixel*)value));
† †   }
† †   /* Handle drawable type (i.e. change in pixmap) */
† †   else if (*type == XA_DRAWABLE) {
† †       rect = RectFind(transferRec->x, transferRec->y);
† †       RectSetPixmap(rect, display, XtWindow(wid), 
† †                     *((Pixmap *)value));
† †   }
† †   /* Handle rect_info type (i.e. new rectangle) */
† †   else if (*type == RECT_INFO) {
† †       rect = (RectPtr) value;
† †       RectRegister(rect, transferRec->x, transferRec->y);
† †       value = NULL;
† †       /* No need to free, it is being stored in RecTable */
† †   }
† †   /* Free the value if there is one, or we would have a
† †    * memory leak */
† †   if (value)
† †       XtFree(value);
}
/* This procedure frees the data used the data transfer proc
† †* that was passed from the drop procedure.
† †*/
/* ARGSUSED */
static void
#ifdef _NO_PROTO
DropDestroyCB(w, clientData, callData)
Widget      w;
XtPointer   clientData;
XtPointer   callData;
#else
DropDestroyCB(Widget w, XtPointer clientData, XtPointer callData)
#endif /* NO_PROTO */
{
† †   XtFree((char *)clientData);
}
/* This procedure initiates the drop transfer. */
/* ARGSUSED */
static void
#ifdef _NO_PROTO
HandleDrop(w, call)
Widget w;
XtPointer call;
#else
HandleDrop(Widget w, XtPointer call)
#endif /* _NO_PROTO */
{
† †   static XtCallbackRec dropDestroyCB[] = {
† †       {DropDestroyCB, NULL},
† †       {NULL, NULL}
† †   };
† †   XmDropProcCallbackStruct *cb = (XmDropProcCallbackStruct 
† †                                                       *)call;
† †   Display                     *display = XtDisplay(w);
† †   Arg                         args[10];
† †   int                         n;
† †   Boolean                     rectFound, bgFound, pixFound;
† †   DropTransfer                transferRec;
† †   XmDropTransferEntryRec      transferEntries[2];
† †   XmDropTransferEntryRec      *transferList = NULL;
† †   Cardinal                    numTransfers = 0;
† †   Boolean                     transferValid = False;
† †   RectPtr                     rect;
† †   /* Cancel the drop on invalid drop operations */
† †   if (!(cb->operations & XmDROP_MOVE || cb->operations 
† †         & XmDROP_COPY)) {
† †       n = 0;
† †       cb->operation = XmDROP_NOOP;
† †       cb->dropSiteStatus = XmINVALID_DROP_SITE;
† †       XtSetArg(args[n], XmNtransferStatus,
† †                         XmTRANSFER_FAILURE); 
† †       n++;
† †       XtSetArg(args[n], XmNnumDropTransfers, 0); n++;
† †   }
† †   else {
† †       /*Find out which nested dropsite contains the pointer*/
† †       rect = RectFind(cb->x, cb->y);
† †       CheckTargets(cb->dragContext, display, &rectFound,
† †                     &bgFound, &pixFound);
† †       /* rect !NULL indicates we are within a nested
† †        * dropsite */
† †       if (rect) {
† †           /* MY_RECT is a possible target, support it first
† †            */
† †           if (rectFound)
† †               transferValid = True;
† †           else if (bgFound || pixFound) {
† †               /* support only copy with the BACKGROUND and
† †                * PIXMAP targets */
† †               if (cb->operation != XmDROP_COPY)
† †                   cb->operation = XmDROP_COPY;
† †               transferValid = True;
† †           }
† †       }
† †       else {
† †           if (rectFound)
† †               transferValid = True;
† †       }
† †       if (transferValid) {
† †           /* initialize data to send to drop transfer
† †            * callback */
† †           transferRec = (DropTransfer) 
† †                          XtMalloc(sizeof(DropTransferRec));
† †           transferRec->widget = w;
† †           transferRec->x = cb->x;
† †           transferRec->y = cb->y;
† †           /* order of support is MY_RECT, then BACKGROUND,
† †            * then PIXMAP */
† †           if (rectFound)
† †               transferEntries[0].target =
† †                                      XmInternAtom(display, 
† †                                      "_MY_RECTANGLE", False);
† †           else if (bgFound)
† †               transferEntries[0].target =
† †                                      XmInternAtom(display, 
† †                                      "BACKGROUND", False);
† †           else if (pixFound)
† †               transferEntries[0].target =
† †                                       XmInternAtom(display, 
† †                                       "PIXMAP", False);
† †           transferEntries[0].client_data = 
† †               (XtPointer) transferRec;
† †           /* Set up move targets */
† †           if (cb->operation == XmDROP_MOVE) {
† †               transferEntries[1].client_data = 
† †                     (XtPointer) transferRec;
† †               transferEntries[1].target =
† †                      XmInternAtom(display, 
† †                     "DELETE", False);
† †               numTransfers = 2;
† †           }
† †           else if (cb->operation == XmDROP_COPY)
† †               numTransfers = 1;
† †           transferList = transferEntries;
† †           /* Setup transfer list */
† †           n = 0;
† †           cb->dropSiteStatus = XmVALID_DROP_SITE;
† †           XtSetArg(args[n], XmNdropTransfers, transferList);
† †           n++;
† †           XtSetArg(args[n], XmNnumDropTransfers,
† †                                    numTransfers); 
† †           n++;
† †           /* Setup destroy callback to free transferRec */
† †           dropDestroyCB[0].closure = (XtPointer) transferRec;
† †           XtSetArg(args[n], XmNdestroyCallback,
† †                                  dropDestroyCB); 
† †           n++;
† †           /* Setup transfer proc to accept the drop transfer
† †            * data */
† †           XtSetArg(args[n], XmNtransferProc,
† †                             TransferProcCallback); 
† †           n++;
† †       }
† †       else {
† †           n = 0;
† †           cb->operation = XmDROP_NOOP;
† †           cb->dropSiteStatus = XmINVALID_DROP_SITE;
† †           XtSetArg(args[n], XmNtransferStatus, 
† †                XmTRANSFER_FAILURE); n++;
† †           XtSetArg(args[n], XmNnumDropTransfers, 0); n++;
† †       }
† †   }
† †   XmDropTransferStart(cb->dragContext, args, n);
}
/* This procedure is used with the drop help dialog to continue 
† †* with the drop */
/* ARGSUSED */
static void
#ifdef _NO_PROTO
HandleOK(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
#else
HandleOK(Widget w, XtPointer client, XtPointer call)
#endif /* _NO_PROTO */
{
† †   XmDropProcCallbackStruct *cb = (XmDropProcCallbackStruct
† †                                                     *)client;
† †   cb->operation = appInfo->operation;
† †   HandleDrop(w, (XtPointer) cb);
}
/* This procedure is used with the drop help dialog to cancel
† †* the drop */
/* ARGSUSED */
static void
#ifdef _NO_PROTO
CancelDrop(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
#else
CancelDrop(Widget w, XtPointer client, XtPointer call)
#endif /* _NO_PROTO */
{
† †   XmDropProcCallbackStruct *cb = (XmDropProcCallbackStruct
† †                                                     *)client;
† †   Arg                         args[2];
† †   /* On help, we need to cancel the drop transfer */
† †   XtSetArg(args[0], XmNtransferStatus, XmTRANSFER_FAILURE);
† †   XtSetArg(args[1], XmNnumDropTransfers, 0);
† †   /* we need to start the drop transfer to cancel the
† †    * transfer */
† †   XmDropTransferStart(cb->dragContext, args, 2);
}
#ifdef _NO_PROTO
XtCallbackProc ChangeOperation(widget, client_data, call_data)
Widget widget;
caddr_t client_data;
XmAnyCallbackStruct *call_data;
#else
XtCallbackProc ChangeOperation(Widget widget, caddr_t client_data,
XmAnyCallbackStruct *call_data)
#endif
{
† †   if (client_data == 0)
† †       appInfo->operation = XmDROP_MOVE;
† †   else
† †       appInfo->operation = XmDROP_COPY;
}
/* This procedure manages the help dialog and determines which
† †* message is displayed in the dialog depending on the position
† †* and the type of drop.
† †*/
/* ARGSUSED */
static void
#ifdef _NO_PROTO
HandleHelp(w, call)
Widget w;
XtPointer call;
#else
HandleHelp(Widget w, XtPointer call)
#endif /* _NO_PROTO */
{
† †   XmDropProcCallbackStruct *cb = (XmDropProcCallbackStruct
† †                                                       *)call;
† †   static XmDropProcCallbackStruct client;
† †   Boolean                         rectFound, bgFound,
† †                                   pixFound;
† †   XmString                        helpStr;
† †   RectPtr                         rect;
† †   Arg                             args[5];
† †   XmString                        tempStr, buttonArray[2];
† †   int                             n = 0;
† †   /* the drop is valid until it is determined invalid */
† †   cb->dropSiteStatus = XmVALID_DROP_SITE;
† †   /* if we haven't created a help dialog, create one now */
† †   if (helpDialog == NULL) {
† †       XtSetArg(args[n], XmNdialogStyle, 
† †             XmDIALOG_FULL_APPLICATION_MODAL); n++;
† †       XtSetArg(args[n], XmNtitle, "Drop Help"); n++;
† †       helpDialog = XmCreateMessageDialog(topLevel, "Help", 
† †             args, n);
† †       n = 0;
† †       buttonArray[0] = XmStringCreateSimple("Move");
† †       buttonArray[1] = XmStringCreateSimple("Copy");
† †       XtSetArg(args[n], XmNbuttons, buttonArray); n++;
† †       XtSetArg(args[n], XmNbuttonCount, 2); n++;
† †       XtSetArg(args[n], XmNbuttonSet, 0); n++;
† †       XtSetArg(args[n], XmNsimpleCallback, ChangeOperation);
† †       n++;
† †       tempStr = XmStringCreateSimple("Operations:");
† †       XtSetArg(args[n], XmNoptionLabel, tempStr); n++;
† †       helpMenu = XmCreateSimpleOptionMenu(helpDialog,
† †                                         "helpMenu", args, n);
† †       XmStringFree(tempStr);
† †       XmStringFree(buttonArray[0]);
† †       XmStringFree(buttonArray[1]);
† †       XtAddCallback(helpDialog, XmNokCallback,
† †            (XtCallbackProc) HandleOK, (XtPointer) &client);
† †       XtAddCallback(helpDialog, XmNcancelCallback,
† †            (XtCallbackProc) CancelDrop, (XtPointer) &client);
† †       XtUnmanageChild(XmMessageBoxGetChild(helpDialog, 
† †             XmDIALOG_HELP_BUTTON));
† †       XtRealizeWidget(helpDialog);
† †   }
† †   /* pass the necessary callback information along */
† †   client.dragContext = cb->dragContext;
† †   client.x = cb->x;
† †   client.y = cb->y;
† †   client.dropSiteStatus = cb->dropSiteStatus;
† †   client.operation = cb->operation;
† †   client.operations = cb->operations;
† †   /* find the valid targets */
† †   CheckTargets(cb->dragContext, XtDisplay(w), &rectFound, 
† †                &bgFound, &pixFound);
† †   /* determine the appropriate help message */
† †   if (rectFound) {
† †       if (cb->operations == XmDROP_MOVE | XmDROP_COPY) {
† †           XtManageChild(helpMenu);
† †           helpStr = XmStringCreateLtoR(HELP_MSG4, 
† †                                      XmFONTLIST_DEFAULT_TAG);
† †           XtManageChild(XmMessageBoxGetChild(helpDialog, 
† †                                         XmDIALOG_OK_BUTTON));
† †       }
† †       else if (cb->operation == XmDROP_MOVE) {
† †           XtUnmanageChild(helpMenu);
† †           helpStr = XmStringCreateLtoR(HELP_MSG2,
† †                                      XmFONTLIST_DEFAULT_TAG);
† †           XtManageChild(XmMessageBoxGetChild(helpDialog, 
† †                         XmDIALOG_OK_BUTTON));
† †       }
† †       else if (cb->operation == XmDROP_COPY) {
† †           XtUnmanageChild(helpMenu);
† †           helpStr = XmStringCreateLtoR(HELP_MSG3, 
† †                                      XmFONTLIST_DEFAULT_TAG);
† †           XtManageChild(XmMessageBoxGetChild(helpDialog, 
† †                         XmDIALOG_OK_BUTTON));
† †       }
† †   }
† †   else if (bgFound || pixFound && cb->operation ==
† †                                                XmDROP_COPY) {
† †       XtUnmanageChild(helpMenu);
† †       rect = RectFind(cb->x, cb->y);
† †       if (rect) {
† †           helpStr = XmStringCreateLtoR(HELP_MSG1, 
† †                                     XmFONTLIST_DEFAULT_TAG);
† †           XtManageChild(XmMessageBoxGetChild(helpDialog, 
† †                         XmDIALOG_OK_BUTTON));
† †       }
† †       else {
† †           helpStr = XmStringCreateLtoR(HELP_MSG5, 
† †                                      XmFONTLIST_DEFAULT_TAG);
† †           XtUnmanageChild(XmMessageBoxGetChild(helpDialog, 
† †                           XmDIALOG_OK_BUTTON));
† †       }
† †   }
† †   else {
† †       XtUnmanageChild(helpMenu);
† †       helpStr = XmStringCreateLtoR(HELP_MSG5, 
† †                                    XmFONTLIST_DEFAULT_TAG);
† †       XtUnmanageChild(XmMessageBoxGetChild(helpDialog, 
† †                       XmDIALOG_OK_BUTTON));
† †   }
† †   /* set the help message into the dialog */
† †   XtSetArg(args[0], XmNmessageString, helpStr);
† †   XtSetValues(helpDialog, args, 1);
† †   /* Free the XmString */
† †   XmStringFree(helpStr);
† †   /* map the help dialog */
† †   XtManageChild(helpDialog);
}
/* The procedure either begins the drop of initiates the help 
† †* dialog depending on the dropAction.
† †*/
/* ARGSUSED */
static void
#ifdef _NO_PROTO
DropProcCallback(w, client, call)
Widget w;
XtPointer client;
XtPointer call;
#else
DropProcCallback(Widget w, XtPointer client, XtPointer call)
#endif /* _NO_PROTO */
{
† †   XmDropProcCallbackStruct *cb = 
† †                             (XmDropProcCallbackStruct *)call;
† †   if (appInfo->highlightRect != NULL)
† †       RectUnhighlight(w);
† †   if (cb->dropAction != XmDROP_HELP)
† †       HandleDrop(w, call);
† †   else
† †       HandleHelp(w, call);
}
/* This procedure registers the drop targets and the drop site */
static void
#ifdef _NO_PROTO
RegisterDropSite(w)
Widget w;
#else
RegisterDropSite(Widget w)
#endif /* _NO_PROTO */
{
† †   Display *display = XtDisplay(w);
† †   Atom    targets[3];
† †   Arg     args[5];
† †   int     n = 0;
† †   /* Only accept moves or copies */
† †   XtSetArg(args[n], XmNdragOperations, XmDROP_COPY |
† †                                        XmDROP_MOVE); 
† †   n++;
† †   /* set all possible targets for any of the nested drop
† †    * sites */
† †   targets[0] = XmInternAtom(display, "_MY_RECTANGLE", False);
† †   targets[1] = XmInternAtom(display, "BACKGROUND", False);
† †   targets[2] = XmInternAtom(display, "PIXMAP", False);
† †   XtSetArg(args[n], XmNimportTargets, targets); n++;
† †   XtSetArg(args[n], XmNnumImportTargets, 3); n++;
† †   /* register a dragProc - necessary for simulating nested
† †    * drop sites */
† †   XtSetArg(args[n], XmNdragProc, DragProcCallback); n++;
† †   /* register a dropProc */
† †   XtSetArg(args[n], XmNdropProc, DropProcCallback); n++;
† †   XmDropSiteRegister(w, args, n);
}
static void
#ifdef _NO_PROTO
SetInvalidIcon(w)
Widget w;
#else
SetInvalidIcon(Widget w)
#endif /* _NO_PROTO */
{
† †   Widget      invalidIcon;
† †   char        *invalid_bits;
† †   Dimension   width, height;
† †   Arg         args[1];
† †   if (appInfo->maxCursorWidth >= ICON_WIDTH &&
† †       appInfo->maxCursorHeight >= ICON_HEIGHT) {
† †       invalid_bits = INVALID_ICON_BITS;
† †       width = ICON_WIDTH;
† †       height = ICON_HEIGHT;
† †   } else {
† †       /* If the server will handle a small icon, create one
† †        */
† †       invalid_bits = SMALL_INVALID_ICON_BITS;
† †       width = SMALL_ICON_WIDTH;
† †       height = SMALL_ICON_HEIGHT;
† †   }
† †   invalidIcon = GetDragIconFromBits(w, invalid_bits,
† †                         invalid_bits, width,
† †                         height, GetColor(DRAW_AREA_FG_COLOR),
† †                         GetColor(DRAW_AREA_BG_COLOR));
† †   XtSetArg(args[0], XmNdefaultInvalidCursorIcon,
† †                         invalidIcon);
† †   XtSetValues(XmGetXmScreen(XtScreen(w)), args, 1);
}
/* This procedure initializes the toolkit and other application 
† †* information */
static void
#ifdef _NO_PROTO
InitializeApplication(argc, argv)
int *argc;
String *argv;
#else
InitializeApplication(int *argc, String *argv)
#endif /* _NO_PROTO */
{
† †   static XtActionsRec new_actions[] = {
† †       {"StartRect", StartRect},
† †       {"ExtendRect", ExtendRect},
† †       {"EndRect", EndRect},
† †       {"StartMove", StartMove},
† †       {"ColorRect", ColorRect},
† †   };
† †   Arg         args[5];
† †   Cardinal    n = 0;
† †   /* Ininialize struct that hold global information */
† †   InitializeAppInfo();
† †   /* Initialize Toolkit and create shell */
† †   XtSetArg(args[n], XmNwidth, 295); n++;
† †   XtSetArg(args[n], XmNheight, 270); n++;
† †   topLevel = XtAppInitialize(&appContext, "DNDDemo", NULL, 0, 
† †                              argc, argv, NULL, args, n);
† †   /* Set drag protocol styles */
† †   n = 0;
† †   XtSetArg(args[n], XmNdragInitiatorProtocolStyle, 
† †            XmDRAG_PREFER_RECEIVER); n++;
† †   XtSetArg(args[n], XmNdragReceiverProtocolStyle,
† †                                     XmDRAG_DYNAMIC); 
† †   n++;
† †   XtSetValues(XmGetXmDisplay(XtDisplay(topLevel)), args, n);
† †   /* Initialize tables for holding rectangle information */
† †   InitializeRectDpyTable();
† †   /* Add new actions for use with translation tables */
† †   XtAppAddActions(appContext, new_actions, 5);
† †   /* Get the display server's best cursor size */
† †   XQueryBestCursor(XtDisplay(topLevel), 
† †        RootWindowOfScreen(XtScreen(topLevel)), 64, 64, 
† †        &appInfo->maxCursorWidth, &appInfo->maxCursorHeight);
}
/* This the program start procedure */
void
#ifdef _NO_PROTO
main (argc, argv)
int argc;
String *argv;
#else
main (int argc, String *argv)
#endif /* _NO_PROTO */
{
† †   /* Initialize toolkit and application global values */
† †   InitializeApplication(&argc, argv);
† †   /* Create main window, drawing area, and color labels */
† †   CreateLayout();
† †   /* Register the drawing area as a drop site */
† †   RegisterDropSite(drawingArea);
† †   SetInvalidIcon(drawingArea);
† †   /* Realize and map widget hiearchy */
† †   XtRealizeWidget(topLevel);
† †   /* Create GC for drawing rectangles */
† †   CreateRectGC();
† †   /* Begin event loop processing */
† †   XtAppMainLoop(appContext);
}LBL="B.3" HELPID=""DNDDraw.c/*
† †*    file: DNDDraw.c
† †*
† †*     File containing all the drawing routines needed to run 
† †*     DNDDemo program.
† †*
† †*/
#include "DNDDemo.h"
/* The following character arrays hold the bits for
† †* the source and state icons for both 32x32 and 16x16 drag
† †* icons. The source is a color palette icon and the state is
† †* a paint brush icon.
† †*/
char SOURCE_ICON_BITS[] = {
† †   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 
† †   0xaa, 0x02, 0x00, 0x50, 0x55, 0x07, 0x00, 0x28, 0x00, 0x0c, 
† †   0x00, 0x94, 0x42, 0x19, 0x00, 0xca, 0xe5, 0x33, 0x00, 0x85, 
† †   0xc6, 0x33, 0x80, 0x42, 0xe7, 0x33, 0x40, 0x81, 0xc3, 0x31, 
† †   0xa0, 0x00, 0x00, 0x38, 0x50, 0x00, 0x00, 0x1c, 0x28, 0x00, 
† †   0x00, 0x0e, 0x90, 0x02, 0x00, 0x07, 0xc8, 0x05, 0x80, 0x03,
† †   0x90, 0x07, 0xc0, 0x01, 0x48, 0x05, 0xe0, 0x00, 0x90, 0x03, 
† †   0x70, 0x00, 0x08, 0x00, 0x30, 0x00, 0x10, 0x14, 0x30, 0x00, 
† †   0x08, 0x2a, 0x30, 0x00, 0x10, 0x34, 0x30, 0x00, 0x28, 0x2a, 
† †   0x60, 0x00, 0x50, 0x9c, 0xe2, 0x00, 0xa0, 0x40, 0xc4, 0x01, 
† †   0x40, 0x01, 0x84, 0x01, 0x80, 0x42, 0x84, 0x03, 0x00, 0x85, 
† †   0x03, 0x03, 0x00, 0x0a, 0x00, 0x03, 0x00, 0xf4, 0xff, 0x03,
† †   0x00, 0xf8, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00};
char SOURCE_ICON_MASK[] = {
† †   0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0x07, 0x00, 0xf8, 
† †   0xff, 0x0f, 0x00, 0xfc, 0xff, 0x1f, 0x00, 0xfe, 0xff, 0x3f, 
† †   0x00, 0xff, 0xff, 0x7f, 0x80, 0xff, 0xff, 0x7f, 0xc0, 0xff, 
† †   0xff, 0x7f, 0xe0, 0xff, 0xff, 0x7f, 0xf0, 0xff, 0xff, 0x7f, 
† †   0xf8, 0xff, 0xff, 0x7f, 0xfc, 0xff, 0xff, 0x7f, 0xfc, 0xff, 
† †   0xff, 0x3f, 0xfc, 0xff, 0xff, 0x1f, 0xfc, 0xff, 0xff, 0x0f,
† †   0xfc, 0xff, 0xff, 0x07, 0xfc, 0xff, 0xff, 0x03, 0xfc, 0xff, 
† †   0xff, 0x01, 0xfc, 0xff, 0xff, 0x00, 0xfc, 0xff, 0x7f, 0x00, 
† †   0xfc, 0xff, 0x7f, 0x00, 0xfc, 0xff, 0xff, 0x00, 0xfc, 0xff, 
† †   0xff, 0x01, 0xfc, 0xff, 0xff, 0x03, 0xf8, 0xff, 0xff, 0x03, 
† †   0xf0, 0xff, 0xff, 0x07, 0xe0, 0xff, 0xff, 0x07, 0xc0, 0xff, 
† †   0xff, 0x07, 0x80, 0xff, 0xff, 0x07, 0x00, 0xff, 0xff, 0x07,
† †   0x00, 0xfe, 0xff, 0x07, 0x00, 0xfc, 0xff, 0x03};
char STATE_ICON_BITS[] = {
† †   0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x78, 0x00, 
† †   0x00, 0x00, 0xf8, 0x01, 0x00, 0x00, 0xf8, 0x01, 0x00, 0x00, 
† †   0xf8, 0x03, 0x00, 0x00, 0xf0, 0x03, 0x00, 0x00, 0xf0, 0x07, 
† †   0x00, 0x00, 0xc0, 0x0d, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 
† †   0x00, 0x3e, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0xfc, 
† †   0x00, 0x00, 0x00, 0xf8, 0x01, 0x00, 0x00, 0xf0, 0x03, 0x00,
† †   0x00, 0xe0, 0x07, 0x00, 0x00, 0xc0, 0x0f, 0x00, 0x00, 0x80, 
† †   0x1f, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x7e, 0x00, 
† †   0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0xf8, 0x01, 0x00, 0x00, 
† †   0xf0, 0x01, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0xc0, 0x07, 
† †   0x00, 0x00, 0x80, 0x0f, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 
† †   0x00, 0x1e, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x38,
† †   0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0xc0};
char STATE_ICON_MASK[] = {
† †   0x3f, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x03, 
† †   0x00, 0x00, 0xfc, 0x03, 0x00, 0x00, 0xfc, 0x07, 0x00, 0x00, 
† †   0xfc, 0x07, 0x00, 0x00, 0xfc, 0x07, 0x00, 0x00, 0xf8, 0x07, 
† †   0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00, 0xe0, 0x1f, 0x00, 0x00, 
† †   0x00, 0x3e, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0xfc, 
† †   0x00, 0x00, 0x00, 0xf8, 0x01, 0x00, 0x00, 0xf0, 0x03, 0x00,
† †   0x00, 0xe0, 0x07, 0x00, 0x00, 0xc0, 0x0f, 0x00, 0x00, 0x80, 
† †   0x1f, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0xfe, 0x01, 
† †   0x00, 0x00, 0xfc, 0x03, 0x00, 0x00, 0xf8, 0x03, 0x00, 0x00, 
† †   0xf0, 0x07, 0x00, 0x00, 0xe0, 0x0f, 0x00, 0x00, 0xc0, 0x1f, 
† †   0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 
† †   0x00, 0x7e, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0xfe,
† †   0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0xf0};
char INVALID_ICON_BITS[] = {
† †   0x00, 0xe0, 0x0f, 0x00, 0x00, 0xfc, 0x7f, 0x00, 0x00, 0xff, 
† †   0xff, 0x01, 0x80, 0xff, 0xff, 0x03, 0xc0, 0x1f, 0xf0, 0x07, 
† †   0xe0, 0x07, 0xc0, 0x0f, 0xf0, 0x07, 0x00, 0x1f, 0xf8, 0x0f, 
† †   0x00, 0x3e, 0xf8, 0x1f, 0x00, 0x3c, 0xfc, 0x3f, 0x00, 0x7c, 
† †   0x3c, 0x7f, 0x00, 0x78, 0x3c, 0xfe, 0x00, 0x78, 0x1e, 0xfc, 
† †   0x01, 0xf0, 0x1e, 0xf8, 0x03, 0xf0, 0x1e, 0xf0, 0x07, 0xf0,
† †   0x1e, 0xe0, 0x0f, 0xf0, 0x1e, 0xc0, 0x1f, 0xf0, 0x1e, 0x80, 
† †   0x3f, 0xf0, 0x1e, 0x00, 0x7f, 0xf0, 0x3c, 0x00, 0xfe, 0x78, 
† †   0x3c, 0x00, 0xfc, 0x79, 0x7c, 0x00, 0xf8, 0x7f, 0x78, 0x00, 
† †   0xf0, 0x3f, 0xf8, 0x00, 0xe0, 0x3f, 0xf0, 0x01, 0xc0, 0x1f, 
† †   0xe0, 0x07, 0xc0, 0x0f, 0xc0, 0x1f, 0xf0, 0x07, 0x80, 0xff, 
† †   0xff, 0x03, 0x00, 0xff, 0xff, 0x01, 0x00, 0xfc, 0x7f, 0x00,
† †   0x00, 0xe0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00};
char SMALL_SOURCE_ICON_BITS[] = {
† †   0x80, 0x1f, 0x40, 0x60, 0x20, 0x91, 0x90, 0xaa, 0x08, 0x91, 
† †   0x08, 0x40, 0x08, 0x20, 0x08, 0x10, 0x28, 0x10, 0x78, 0x10, 
† †   0x28, 0x20, 0x08, 0x41, 0x90, 0x43, 0x20, 0x21, 0x40, 0x10, 
† †   0x80, 0x0f};
char SMALL_SOURCE_ICON_MASK[] = {
† †   0x80, 0x1f, 0xc0, 0x7f, 0xe0, 0xff, 0xf0, 0xff, 0xf8, 0xff, 
† †   0xf8, 0x7f, 0xf8, 0x3f, 0xf8, 0x1f, 0xf8, 0x1f, 0xf8, 0x1f, 
† †   0xf8, 0x3f, 0xf8, 0x7f, 0xf0, 0x7f, 0xe0, 0x3f, 0xc0, 0x1f, 
† †   0x80, 0x0f};
char SMALL_STATE_ICON_BITS[] = {
† †   0x0f, 0x00, 0x1e, 0x00, 0x1e, 0x00, 0x3c, 0x00, 0x50, 0x00, 
† †   0xe0, 0x00, 0xc0, 0x01, 0x80, 0x03, 0x00, 0x07, 0x00, 0x0e, 
† †   0x00, 0x1c, 0x00, 0x18, 0x00, 0x20, 0x00, 0x40, 0x00, 0x80, 
† †   0x00, 0x00};
char SMALL_STATE_ICON_MASK[] = {
† †   0x0f, 0x00, 0x1e, 0x00, 0x1e, 0x00, 0x3c, 0x00, 0x70, 0x00, 
† †   0xe0, 0x00, 0xc0, 0x01, 0x80, 0x03, 0x00, 0x07, 0x00, 0x0e, 
† †   0x00, 0x1c, 0x00, 0x18, 0x00, 0x20, 0x00, 0x40, 0x00, 0x80, 
† †   0x00, 0x00};
char SMALL_INVALID_ICON_BITS[] = {
† †   0xe0, 0x03, 0xf8, 0x0f, 0x1c, 0x1c, 0x1e, 0x30, 0x3e, 0x30, 
† †   0x73, 0x60, 0xe3, 0x60, 0xc3, 0x61, 0x83, 0x63, 0x03, 0x67, 
† †   0x06, 0x3e, 0x06, 0x3c, 0x1c, 0x1c, 0xf8, 0x0f, 0xe0, 0x03, 
† †   0x00, 0x00};
/* Globals variables */
AppInfo appInfo;
/* This is a string to pixel conversion function. */
Pixel 
#ifdef _NO_PROTO
GetColor(colorstr)
char *colorstr;
#else
GetColor(char *colorstr)
#endif /* _NO_PROTO */
{
† †   XrmValue    from, to;
† †   from.size = strlen(colorstr) +1;
† †   if (from.size < sizeof(String))
† †       from.size = sizeof(String);
† †   from.addr = colorstr;
† †   to.addr = NULL;
† †   XtConvert(topLevel, XmRString, &from, XmRPixel, &to);
† †   if (to.addr != NULL)
† †       return ((Pixel) *((Pixel *) to.addr));
† †   else
† †       return ( (XtArgVal) NULL);
}
/* This procedure is used to initialize the application
† †* information structure */
void
#ifdef _NO_PROTO
InitializeAppInfo()
#else /* _NO_PROTO */
InitializeAppInfo(void)
#endif /* _NO_PROTO */
{
† †   if (!appInfo) {
† †       appInfo = (AppInfo) XtMalloc(sizeof(AppInfoRec));
† †       appInfo->rectGC = NULL;
† †       appInfo->currentColor = 0;
† †       appInfo->rectDpyTable = NULL;
† †       appInfo->rectsAllocd = 0;
† †       appInfo->numRects = 0;
† †       appInfo->highlightRect = NULL;
† †       appInfo->clearRect = NULL;
† †       appInfo->doMove = True;
† †       appInfo->creatingRect = True;
† †       appInfo->operation = XmDROP_MOVE;
† †       appInfo->maxCursorWidth = 64;
† †       appInfo->maxCursorHeight = 64;
† †       appInfo->rectX = 0;
† †       appInfo->rectY = 0;
† †       appInfo->rectX2 = 0;
† †       appInfo->rectY2 = 0;
† †   }
}
/* This procedure sets the color in the GC for drawing the 
† †* rectangles in a new color.
† †*/
void
#ifdef _NO_PROTO
SetColor(display, color)
Display *display;
Pixel color;
#else
SetColor(Display *display, Pixel color)
#endif /* _NO_PROTO */
{
† †   /*
† †    * if the GC already has a foreground of this color,
† †    * it would be wasteful to reset the color
† †    */
† †   if (color != appInfo->currentColor) {
† †       XSetForeground(display, appInfo->rectGC, 
† †                      (unsigned long) color);
† †       appInfo->currentColor = color;
† †   }
}
/* This function draws the rectangle in the color provided */
static int
#ifdef _NO_PROTO
RectDraw(display, window, rect)
Display *display;
Window window;
RectPtr rect;
#else
RectDraw(Display *display, Window window, RectPtr rect)
#endif /* _NO_PROTO */
{
† †   SetColor(display, rect->color);
† †   XFillRectangle(display, window, appInfo->rectGC, rect->x,
† †                  rect->y, rect->width, rect->height);
}
/* This procedure draws the rectangle highlight in a specified 
† †* color */
static void
#ifdef _NO_PROTO
RectDrawHighlight(w, rect, color )
Widget w;
RectPtr rect;
Pixel color;
#else
RectDrawHighlight( Widget w, RectPtr rect, Pixel color )
#endif /* _NO_PROTO */
{
† †   Display *display = XtDisplay(w);
† †   Window window = XtWindow(w);
† †   Pixel currentColor = rect->color;
† †   XGCValues values;
† †   values.foreground = color;
† †   XChangeGC(display, appInfo->rectGC, GCForeground, &values);
† †   XDrawRectangle(display, window, appInfo->rectGC,
† †                  rect->x + 1, rect->y + 1,
† †                  rect->width - HIGHLIGHT_THICKNESS,
† †                  rect->height - HIGHLIGHT_THICKNESS);
† †   /* Return the GC to it's previous state */
† †   values.foreground = appInfo->currentColor = currentColor;
† †   XChangeGC(display, appInfo->rectGC, GCForeground, &values);
}
/* This procedure handles redrawing the rectangles.  It draws
† †* them according to the order in the rectangle display table.
† †* The rectangles at the top of the table are drawn first.
† †*/
void
#ifdef _NO_PROTO
RedrawRectangles(w)
Widget w;
#else
RedrawRectangles(Widget w)
#endif /* _NO_PROTO */
{
† †   Display *display = XtDisplay(w);
† †   RectPtr rect;
† †   Window window = XtWindow(w);
† †   int i;
† †   for (i = 0; i < appInfo->numRects; i++) {
† †       rect = appInfo->rectDpyTable[i];
† †       /* Only draw the rectangles that haven't been cleared
† †        */
† †       if (rect != appInfo->clearRect) {
† †           RectDraw(display, window, rect);
† †       }
† †       /* Draw the rectangle highlight of the highlight 
† †        * rectangle */
† †       if (rect == appInfo->highlightRect) {
† †           RectDrawHighlight(w, rect,
† †                                GetColor(HIGHLIGHT_COLOR));
† †       }
† †   }
}
/* This procedure will clear the current rectangle and redraw
† †* any rectangles that were partially cleared by the rectangle
† †* that was deleted.
† †*/
/* ARGSUSED */
void
#ifdef _NO_PROTO
RectHide(display, window, rect)
Display *display;
Window window;
RectPtr rect;
#else
RectHide(Display *display, Window window, RectPtr rect)
#endif /* _NO_PROTO */
{
† †   Pixel background, oldColor;
† †   Arg args[1];
† †   /* Get the background of the drawing area. */
† †   XtSetArg(args[0], XmNbackground, &background);
† †   XtGetValues(drawingArea, args, 1);
† †   /* Save the old color for restoration purposes. */
† †   oldColor = rect->color;
† †   /* Clear the rectangle */
† †   rect->color = background;
† †   RectDraw(display, window, rect);
† †   appInfo->clearRect = rect;
† †   /* redraw the rest of the rectangles */
† †   RedrawRectangles(drawingArea);
† †   /* restore the rectangle color */
† †   rect->color = oldColor;
}
/* This procedure draws the stipple rectangle that is used in 
† †* marking the old rectangle position during a rectangle move 
† †* operation.
† †*/
/* ARGSUSED */
void
#ifdef _NO_PROTO
RectDrawStippled(display, window, rect)
Display *display;
Window window;
RectPtr rect;
#else
RectDrawStippled(Display *display, Window window, RectPtr rect)
#endif /* _NO_PROTO */
{
† †   register int x = rect->x;
† †   register int y = rect->y;
† †   register Dimension width = rect->width;
† †   register Dimension height = rect->height;
† †   XGCValues values;
† †   XSegment segments[4];
† †   /* Set the rectangle color */
† †   values.foreground = appInfo->currentColor = rect->color;
† †   XChangeGC(display, appInfo->rectGC, GCForeground ,
† †                                                    &values);
† †   /* Create the segments for drawing the stippled rectangle
† †    */
† †   segments[0].x1 = segments[2].x1 = x;
† †   segments[0].y1 = segments[0].y2 = y;
† †   segments[0].x2 = x + width - 1;
† †   segments[1].x1 = segments[1].x2 = x + width - 1;
† †   segments[1].y1 = segments[3].y1 = y;
† †   segments[3].y2 = y + height;
† †   segments[2].y1 = segments[2].y2 = y + height - 1;
† †   segments[3].x1 = segments[3].x2 = x;
† †   segments[2].x2 = x + width;
† †   segments[1].y2 = y + height;
† †   /* Set the line attributes and draw */
† †   XSetLineAttributes(display, appInfo->rectGC, 1,
† †                      LineOnOffDash, CapButt, JoinMiter);
† †   XDrawSegments (display, window, appInfo->rectGC, segments,
† †                      4);
† †   /* restore the default line settings */
† †   values.line_width = HIGHLIGHT_THICKNESS;
† †   values.line_style = LineSolid;
† †   XChangeGC(display, appInfo->rectGC, GCLineWidth |
† †                                       GCLineStyle, &values);
}
/* This procedure sets the highlight rectangle and
† †* redraws the rectangles.  The expose routine will draw
† †* the highlight around the highlighted rectangle.
† †*/
/* ARGSUSED */
void
#ifdef _NO_PROTO
RectHighlight(w, rect)
Widget w;
RectPtr rect;
#else
RectHighlight(Widget w, RectPtr rect)
#endif /* _NO_PROTO */
{
† †   if (appInfo->highlightRect != rect) {
† †       appInfo->highlightRect = rect;
† †       RedrawRectangles(w);
† †   }
}
/* This procedure sets the highlight rectangle to NULL and
† †* redraws the rectangles.  The expose routine will clear
† †* the highlight around the highlighted rectangle.
† †*/
/* ARGSUSED */
void
#ifdef _NO_PROTO
RectUnhighlight(w)
Widget w;
#else
RectUnhighlight(Widget w)
#endif /* _NO_PROTO */
{
† †   if (appInfo->highlightRect) {
† †       appInfo->highlightRect = NULL;
† †       RedrawRectangles(w);
† †   }
}
/* This function creates and initialized a new rectangle */
RectPtr 
#ifdef _NO_PROTO
RectCreate(x, y, width, height, color, pixmap)
Position x;
Position y;
Dimension width;
Dimension height;
Pixel color;
Pixmap pixmap;
#else
RectCreate(Position x, Position y, Dimension width,
Dimension height, Pixel color, Pixmap pixmap)
#endif /* _NO_PROTO */
{
† †   RectPtr rect;
† †   rect = (RectPtr)  XtMalloc(sizeof(RectStruct));
† †   rect->x = x;
† †   rect->y = y;
† †   rect->width = width;
† †   rect->height = height;
† †   rect->color = color;
† †   rect->pixmap = pixmap;
† †   return(rect);
}
/* This procedure will move the rectangle to the end of the 
† †* rectangle display table (effectively raising it to top of 
† †* the displayed rectangles).
† †*/
static void
#ifdef _NO_PROTO
RectToTop(rect)
RectPtr rect;
#else
RectToTop(RectPtr rect)
#endif /* _NO_PROTO */
{
† †   int    i, j;
† †   if (rect) {
† †       /* Get the index to the target rectangle */
† †       for (i = 0; i < appInfo->numRects; i++) {
† †           if (appInfo->rectDpyTable[i] == rect)
† †               break;
† †       }
† †       /* Shift the other rectangles downward */
† †       for (j = i; j < appInfo->numRects - 1; j++)
† †           appInfo->rectDpyTable[j] = 
† †                                 appInfo->rectDpyTable[j + 1];
† †       /* Place the target rectangle at the end */
† †       appInfo->rectDpyTable[j] = rect;
† †   }
}
/* This procedure raises the rectangle to the top of the
† †* drawing area */
/* ARGSUSED */
static void
#ifdef _NO_PROTO
RectRaise(w, rect)
Widget w;
RectPtr rect;
#else
RectRaise(Widget w, RectPtr rect)
#endif /* _NO_PROTO */
{
† †   RectToTop(rect);
† †   RedrawRectangles(w);
}
/* This procedure moves the rectangle the the end of the
† †* display stack, decrements the number of rectangles, and
† †* then frees the rectangle.
† †*/
void
#ifdef _NO_PROTO
RectFree(rect)
RectPtr rect;
#else
RectFree(RectPtr rect)
#endif /* _NO_PROTO */
{
† †   /* if the rectangle is registered */
† †   if (rect) {
† †       RectToTop(rect);
† †       appInfo->numRects--;
† †       XtFree((char *)rect);
† †   }
}
/* This procedure added the rectangle to the rectangle display 
† †* table (reallocing the table if necessary).
† †*/
void
#ifdef _NO_PROTO
RectRegister(rect, x, y)
RectPtr rect;
#else
RectRegister(RectPtr rect, Position x, Position y)
#endif /* _NO_PROTO */
{
† †   appInfo->numRects++;
† †   /* rectangles can have their x and y values reset at 
† †    * registration time */
† †   rect->x = x;
† †   rect->y = y;
† †   /* realloc the table if it is too small */
† †   if (appInfo->numRects > appInfo->rectsAllocd) {
† †       /* grow geometrically */
† †       appInfo->rectsAllocd *= 2;
† †       appInfo->rectDpyTable = (RectPtr *) 
† †            XtRealloc((char *) appInfo->rectDpyTable,
† †            (unsigned) (sizeof(RectPtr) *
† †             appInfo->rectsAllocd));
† †   }
† †   /* Add to end of display table */
† †   appInfo->rectDpyTable[appInfo->numRects - 1] = rect;
}
/* This function find the top most rectangle at the given x,y 
† †* position */
RectPtr 
#ifdef _NO_PROTO
RectFind(x, y)
Position x;
Position y;
#else
RectFind(Position x, Position y)
#endif /* _NO_PROTO */
{
† †   RectPtr rect;
† †   int     i;
† †   /*
† †    * Search from the end of the rectangle display table
† †       * to find the top most rectangle.
† †       */
† †   for (i = appInfo->numRects - 1; i >= 0; i--) {
† †       rect = appInfo->rectDpyTable[i];
† †       if (rect->x <= x && rect->x + rect->width >= x &&
† †           rect->y <= y && rect->y + rect->height >= y) {
† †           return(rect);
† †       }
† †   }
† †   /* If a rectangle is not found return NULL */
† †   return(NULL);
}
/* This procedure sets the retangle's color */
void
#ifdef _NO_PROTO
RectSetColor(rect, display, window, color)
RectPtr rect;
Display *display;
Window window;
Pixel color;
#else
RectSetColor(RectPtr rect, Display *display, Window window, 
† †            Pixel color)
#endif /* _NO_PROTO */
{
† †   rect->color = color;
† †   RectDraw(display, window, rect);
}
/* This function gets the retangle's color */
Pixel
#ifdef _NO_PROTO
RectGetColor(rect)
RectPtr rect;
#else
RectGetColor(RectPtr rect)
#endif /* _NO_PROTO */
{
† †   return(rect->color);
}
/* This procedure sets the retangle's pixmap. The pixmap
† †* portion of the rectangle is not currently being used.
† †*/
/* ARGSUSED */
void
#ifdef _NO_PROTO
RectSetPixmap(rect, display, window, pixmap)
RectPtr rect;
Display *display;
Window window;
Pixmap pixmap;
#else
RectSetPixmap(RectPtr rect, Display *display, Window window, 
† †             Pixmap pixmap)
#endif /* _NO_PROTO */
{
† †   rect->pixmap = pixmap; /* not currently being looked at */
† †   RectDraw(display, window, rect);
}
/* This function gets the retangle's pixmap. The pixmap
† †* portion of the rectangle is not currently being used.
† †*/
/* ARGSUSED */
static Pixmap
#ifdef _NO_PROTO
RectGetPixmap(rect)
RectPtr rect;
#else
RectGetPixmap(RectPtr rect)
#endif /* _NO_PROTO */
{
† †   return (rect->pixmap);
}
/* This procedure gets the retangle's height and width.  */
/* ARGSUSED */
static void
#ifdef _NO_PROTO
RectGetDimensions(rect, width, height)
RectPtr rect;
Dimension *width;
Dimension *height;
#else
RectGetDimensions(RectPtr rect, Dimension *width, 
† †                 Dimension *height)
#endif /* _NO_PROTO */
{
† †   *width = rect->width;
† †   *height = rect->height;
}
/* This function creates the rectangle bitmaps for the icon. */
Pixmap
#ifdef _NO_PROTO
GetBitmapFromRect(w, rect, background, foreground, widthRtn, 
† †                 heightRtn)
Widget w;
RectPtr rect;
Pixel background;
Pixel foreground;
Dimension *widthRtn;
Dimension *heightRtn;
#else
GetBitmapFromRect(Widget w, RectPtr rect, Pixel background, 
Pixel foreground, Dimension *widthRtn, Dimension *heightRtn)
#endif /* _NO_PROTO */
{
† †   Dimension width, height, maxHeight, maxWidth;
† †   GC fillGC;
† †   Pixmap icon_pixmap;
† †   Display *display = XtDisplay(w);
† †   XGCValues values;
† †   RectGetDimensions(rect, &width, &height);
† †   /* Get the maximum allowable width and height allowed by
† †    * the cursor */
† †   maxWidth = appInfo->maxCursorWidth;
† †   maxHeight = appInfo->maxCursorHeight;
† †   /* if the dimensions aren't within the allowable dimensions 
† †    * resize then proportionally
† †    */
† †   if (maxWidth < width || maxHeight < height) {
† †       if (width > height) {
† †           height = (height * maxWidth) / width;
† †           width = appInfo->maxCursorWidth;
† †       } else {
† †           width = (width * maxHeight) / height;
† †           height = appInfo->maxCursorHeight;
† †       }
† †   }
† †   /* Create a depth 1 pixmap (bitmap) for use with the drag 
† †    * icon */
† †   icon_pixmap = XCreatePixmap(display, XtWindow(w), width, 
† †                               height, 1);
† †   /* create a GC for drawing into the bitmap */
† †   fillGC = XCreateGC(display, icon_pixmap, 0, 
† †                      (XGCValues *)NULL);
† †   /* fill the bitmap with 0's as a starting point */
† †   XFillRectangle(display, icon_pixmap, fillGC, 0, 0, width, 
† †                  height);
† †   /* Change GC to be able to create the rectangle with 1's on 
† †    * the bitmap */
† †   values.foreground = 1;
† †   XChangeGC(display, fillGC, GCForeground, &values);
† †   /*
† †    * This draw a filled rectangle.  If only a outline is
† †    * desired use the XDrawRectangle() call.  Note: the
† †    * outline does not produce very effect icon melting.
† †    */
† †   XFillRectangle(display, icon_pixmap, fillGC, 0, 0, width, 
† †                  height);
† †   /* Free the fill GC */
† †   XFreeGC(display, fillGC);
† †   *widthRtn = width;
† †   *heightRtn = height;
† †   return(icon_pixmap);
}
/*************************************************************
† †*************************************************************
† †             Functions used in Drawing Outlines:
† †*************************************************************
† †*************************************************************/
/*
† †* This procedure changes the GC to do rubberband
† †* drawing of a rectangle frame .
† †*/
static void
#ifdef _NO_PROTO
SetXorGC(w)
Widget w;
#else
SetXorGC(Widget w)
#endif /* _NO_PROTO */
{
† †   unsigned long valueMask = GCFunction | GCForeground | 
† †                             GCLineWidth;
† †   XGCValues values;
† †   values.function = GXxor;
† †   values.foreground = GetColor(DRAW_AREA_BG_COLOR);
† †   values.line_width = 1;
† †   XChangeGC(XtDisplay(w), appInfo->rectGC, valueMask,
† †                                            &values);
}
/* This procedure returns the GC to it's initial state.  */
static void
#ifdef _NO_PROTO
SetNormGC(w)
Widget w;
#else
SetNormGC(Widget w)
#endif /* _NO_PROTO */
{
† †   unsigned long valueMask = GCFunction | GCLineWidth | 
† †                             GCForeground;
† †   XGCValues values;
† †   values.function = GXcopy;
† †   values.foreground = appInfo->currentColor;
† †   values.line_width = HIGHLIGHT_THICKNESS;
† †   XChangeGC(XtDisplay(w), appInfo->rectGC, valueMask,
† †                                             &values);
}
/* This procedure returns the values of the current rectangle 
† †* outline */
static void
#ifdef _NO_PROTO
OutlineGetDimensions(x, y, width, height)
Position *x;
Position *y;
Dimension *width;
Dimension *height;
#else
OutlineGetDimensions(Position *x, Position *y, Dimension *width,
Dimension *height)
#endif /* _NO_PROTO */
{
† †   if (appInfo->rectX < appInfo->rectX2) {
† †       *x = appInfo->rectX;
† †       *width = appInfo->rectX2 - *x;
† †   } else {
† †       *x = appInfo->rectX2;
† †       *width = appInfo->rectX - *x;
† †   }
† †   if (appInfo->rectY < appInfo->rectY2) {
† †       *y = appInfo->rectY;
† †       *height = appInfo->rectY2 - *y;
† †   } else {
† †       *y = appInfo->rectY2;
† †       *height = appInfo->rectY - *y;
† †   }
† †   if (*width < 0)
† †       *width = 1;
† †   if (*height < 0)
† †       *height = 1;
}
static void
#ifdef _NO_PROTO
OutlineDraw(w)
Widget w;
#else
OutlineDraw(Widget w)
#endif /* _NO_PROTO */
{
† †   Position    x, y;
† †   Dimension    width, height;
† †   OutlineGetDimensions(&x, &y, &width, &height);
† †   XDrawRectangle(XtDisplay(w), XtWindow(w), appInfo->rectGC,
† †                  x, y, width, height);
}
/* This procedure sets initializes the drawing positions */
static void
#ifdef _NO_PROTO
OutlineSetPosition(x, y)
Position x;
Position y;
#else
OutlineSetPosition(Position x, Position y)
#endif /* _NO_PROTO */
{
† †   appInfo->rectX = appInfo->rectX2 = x;
† †   appInfo->rectY = appInfo->rectY2 = y;
}
/* This procedure resets outline end position */
static void
#ifdef _NO_PROTO
OutlineResetPosition(x, y)
Position x;
Position y;
#else
OutlineResetPosition(Position x, Position y)
#endif /* _NO_PROTO */
{
† †   appInfo->rectX2 = x;
† †   appInfo->rectY2 = y;
}
/* This action procedure begins creating a rectangle at the x,y 
† †* position of the button event if a rectangle doesn't already 
† †* exist at that position.  Otherwise is raises the rectangle 
† †* to the top of the drawing area.
† †*/
/* ARGSUSED */
void
#ifdef _NO_PROTO
StartRect(w, event, params, num_params)
Widget w;
XEvent *event;
String *params;
Cardinal *num_params;
#else
StartRect(Widget w, XEvent *event, String *params, 
† †         Cardinal *num_params)
#endif /* _NO_PROTO */
{
† †   Display *display = XtDisplay(w);
† †   RectPtr rect;
† †   Position x = event->xbutton.x;
† †   Position y = event->xbutton.y;
† †   rect = RectFind(x, y);
† †   /* if there isn't a rectangle at this position, begin
† †    * creating one */
† †   if (!rect) {
† †       appInfo->creatingRect = True;
† †       /* set gc for drawing rubberband outline for
† †        * rectangles */
† †       SetXorGC(w);
† †       /* set the initial outline positions */
† †       OutlineSetPosition(x, y);
† †       /* Draw the rectangle */
† †       OutlineDraw(w);
† †   }
† †   else
† †       RectRaise(w, rect);
}
/* This action procedure extends the drawing of the outline
† †* for the rectangle to be created.
† †*/
/* ARGSUSED */
void
#ifdef _NO_PROTO
ExtendRect(w, event, params, num_params)
Widget w;
XEvent *event;
String *params;
Cardinal *num_params;
#else
ExtendRect(Widget w, XEvent *event, String *params, 
† †          Cardinal *num_params)
#endif /* _NO_PROTO */
{
† †   if (appInfo->creatingRect) {
† †       /* erase the old outline */
† †       OutlineDraw(w);
† †       /* set the new outline end positions */
† †       OutlineResetPosition(event->xbutton.x,
† †                            event->xbutton.y);
† †       /* redraw the outline */
† †       OutlineDraw(w);
† †   }
}
/* This action procedure creates a rectangle depending on the
† †* dimensions set in the StartRect and ExtendRect action procs.
† †*/
/* ARGSUSED */
void
#ifdef _NO_PROTO
EndRect(w, event, params, num_params)
Widget w;
XEvent *event;
String *params;
Cardinal *num_params;
#else
EndRect(Widget w, XEvent *event, String *params, 
† †       Cardinal *num_params)
#endif /* _NO_PROTO */
{
† †   Position     x, y;
† †   Dimension    width, height;
† †   RectPtr     rect;
† †   if (appInfo->creatingRect) {
† †       /* erase the last outline */
† †       OutlineDraw(w);
† †       /* return GC to original state */
† †       SetNormGC(w);
† †       /* Get the outline dimensions for creating the
† †        * rectangle */
† †       OutlineGetDimensions(&x, &y, &width, &height);
† †       /* don't want to create zero width or height
† †        * rectangles */
† †       if (width == 0 || height == 0){
† †           appInfo->creatingRect = False;
† †           return;
† †       }
† †       rect = RectCreate(x, y, width, height,
† †              GetColor(RECT_START_COLOR),
† †              XmUNSPECIFIED_PIXMAP);
† †       RectDraw(XtDisplay(w), XtWindow(w), rect);
† †       RectRegister(rect, x, y);
† †       appInfo->creatingRect = False;
† †   }
}
/* The procedure assigns new translations the the given widget */
static void
#ifdef _NO_PROTO
SetupTranslations(widget, new_translations)
Widget widget;
char *new_translations;
#else
SetupTranslations(Widget widget, char *new_translations)
#endif /* _NO_PROTO */
{
† †   XtTranslations new_table;
† †   new_table = XtParseTranslationTable(new_translations);
† †   XtOverrideTranslations(widget, new_table);
}
/* This procedure handles exposure events and makes a call to 
† †* RedrawRectangles() to redraw the rectangles
† †* The rectangles at the top of the table are drawn first.
† †*/
/* ARGSUSED */
static void
#ifdef _NO_PROTO
HandleExpose(w, closure, call_data)
Widget w;
XtPointer closure;
XtPointer call_data;
#else
HandleExpose(Widget w, XtPointer closure, XtPointer call_data)
#endif /* _NO_PROTO */
{
† †   RedrawRectangles(w);
}
/* This procedure sets up the drawing area */
static void
#ifdef _NO_PROTO
CreateDrawingArea(parent)
Widget parent;
#else
CreateDrawingArea(Widget parent)
#endif /* _NO_PROTO */
{
† †   static char da_translations[] = 
† †       "#replace <Btn2Down>: StartMove() \\
† †       <Btn1Down>: StartRect() \\
† †       <Btn1Motion>: ExtendRect() \\
† †       <Btn1Up>: EndRect() \\
† †       c <Key>t: XtDisplayTranslations()";
† †   Arg             args[10];
† †   int             n = 0;
† †   XtTranslations    new_table;
† †   new_table = XtParseTranslationTable(da_translations);
† †   /* create drawing area at the top of the form */
† †   n = 0;
† †   XtSetArg(args[n], XmNtranslations, new_table); n++;
† †   XtSetArg(args[n], XmNtopAttachment, XmATTACH_FORM); n++;
† †   XtSetArg(args[n], XmNleftAttachment, XmATTACH_FORM); n++;
† †   XtSetArg(args[n], XmNrightAttachment, XmATTACH_FORM); n++;
† †   XtSetArg(args[n], XmNwidth, 295); n++;
† †   XtSetArg(args[n], XmNheight, 180); n++;
† †   XtSetArg(args[n], XmNresizePolicy, XmRESIZE_NONE); n++;
† †   XtSetArg(args[n], XmNbackground,
† †             GetColor(DRAW_AREA_BG_COLOR)); 
† †   n++;
† †   XtSetArg(args[n], XmNforeground,
† †             GetColor(DRAW_AREA_FG_COLOR)); 
† †   n++;
† †   drawingArea = XmCreateDrawingArea(parent, "drawingArea",
† †                                      args, n);
† †   XtManageChild(drawingArea);
† †   /* add expose callback to redisplay rectangles */
† †   XtAddCallback(drawingArea, XmNexposeCallback, HandleExpose, 
† †                 (XtPointer) NULL);
}
/* This procedure sets up the area for obtaining rectangle colors */
static void
#ifdef _NO_PROTO
CreateColorPushButtons(parent, separator)
Widget parent;
Widget separator;
#else
CreateColorPushButtons(Widget parent, Widget separator)
#endif /* _NO_PROTO */
{
† †   static char label_translations[] = "<Btn2Down>:
† †                                       ColorRect()";
† †   Widget         bulletinBoard;
† †   Widget         children[6];
† †   XmString    csString;
† †   Arg         args[10];
† †   int         n = 0;
† †   /* Creating an empty compound string so the labels will
† †    * have no text. */
† †   csString = XmStringCreateSimple("");
† †   /* Creating 6 color labels */
† †   n = 0;
† †   XtSetArg(args[n], XmNtopAttachment, XmATTACH_WIDGET); n++;
† †   XtSetArg(args[n], XmNtopWidget, separator); n++;
† †   XtSetArg(args[n], XmNtopOffset, 2); n++;
† †   XtSetArg(args[n], XmNleftAttachment, XmATTACH_FORM); n++;
† †   XtSetArg(args[n], XmNrightAttachment, XmATTACH_FORM); n++;
† †   XtSetArg(args[n], XmNwidth, 295); n++;
† †   bulletinBoard = XmCreateBulletinBoard(parent,
† †                                     "buletinBoard", args, n);
† †   XtManageChild(bulletinBoard);
† †   n = 0;
† †   XtSetArg(args[n], XmNx, BOX_X_MARGIN); n++;
† †   XtSetArg(args[n], XmNy, BOX_Y_MARGIN); n++;
† †   XtSetArg(args[n], XmNwidth, BOX_WIDTH); n++;
† †   XtSetArg(args[n], XmNheight, BOX_HEIGHT); n++;
† †   XtSetArg(args[n], XmNlabelString, csString); n++;
† †   XtSetArg(args[n], XmNbackground, GetColor(LABEL1_COLOR));
† †   n++;
† †   XtSetArg(args[n], XmNborderWidth, 1); n++;
† †   children[0] = XmCreatePushButton(bulletinBoard,
† †                                     "PushButton1", args, n);
† †   /* add translations for manipulating rectangles */
† †   SetupTranslations(children[0], label_translations);
† †   n = 0;
† †   XtSetArg(args[n], XmNx, BOX_X_MARGIN + BOX_X_OFFSET); n++;
† †   XtSetArg(args[n], XmNy, BOX_Y_MARGIN); n++;
† †   XtSetArg(args[n], XmNwidth, BOX_WIDTH); n++;
† †   XtSetArg(args[n], XmNheight, BOX_HEIGHT); n++;
† †   XtSetArg(args[n], XmNlabelString, csString); n++;
† †   XtSetArg(args[n], XmNbackground, GetColor(LABEL2_COLOR));
† †   n++;
† †   XtSetArg(args[n], XmNborderWidth, 1); n++;
† †   children[1] = XmCreatePushButton(bulletinBoard,
† †                                     "PushButton1", args, n);
† †   /* add translations for manipulating rectangles */
† †   SetupTranslations(children[1], label_translations);
† †   n = 0;
† †   XtSetArg(args[n], XmNx, BOX_X_MARGIN + (2 *
† †                                          BOX_X_OFFSET)); n++;
† †   XtSetArg(args[n], XmNy, BOX_Y_MARGIN); n++;
† †   XtSetArg(args[n], XmNwidth, BOX_WIDTH); n++;
† †   XtSetArg(args[n], XmNheight, BOX_HEIGHT); n++;
† †   XtSetArg(args[n], XmNlabelString, csString); n++;
† †   XtSetArg(args[n], XmNbackground, GetColor(LABEL3_COLOR));
† †   n++;
† †   XtSetArg(args[n], XmNborderWidth, 1); n++;
† †   children[2] = XmCreatePushButton(bulletinBoard,
† †                                     "PushButton3", args, n);
† †   /* add translations for manipulating rectangles */
† †   SetupTranslations(children[2], label_translations);
† †   n = 0;
† †   XtSetArg(args[n], XmNx, BOX_X_MARGIN); n++;
† †   XtSetArg(args[n], XmNy, BOX_Y_MARGIN + BOX_Y_OFFSET); n++;
† †   XtSetArg(args[n], XmNwidth, BOX_WIDTH); n++;
† †   XtSetArg(args[n], XmNheight, BOX_HEIGHT); n++;
† †   XtSetArg(args[n], XmNlabelString, csString); n++;
† †   XtSetArg(args[n], XmNbackground, GetColor(LABEL4_COLOR));
† †   n++;
† †   XtSetArg(args[n], XmNborderWidth, 1); n++;
† †   children[3] = XmCreatePushButton(bulletinBoard,
† †                                     "PushButton4", args, n);
† †   /* add translations for manipulating rectangles */
† †   SetupTranslations(children[3], label_translations);
† †   n = 0;
† †   XtSetArg(args[n], XmNx, BOX_X_MARGIN + BOX_X_OFFSET); n++;
† †   XtSetArg(args[n], XmNy, BOX_Y_MARGIN + BOX_Y_OFFSET); n++;
† †   XtSetArg(args[n], XmNwidth, BOX_WIDTH); n++;
† †   XtSetArg(args[n], XmNheight, BOX_HEIGHT); n++;
† †   XtSetArg(args[n], XmNtopWidget, children[0]); n++;
† †   XtSetArg(args[n], XmNlabelString, csString); n++;
† †   XtSetArg(args[n], XmNbackground, GetColor(LABEL5_COLOR));
† †   n++;
† †   XtSetArg(args[n], XmNborderWidth, 1); n++;
† †   children[4] = XmCreatePushButton(bulletinBoard,
† †                                     "PushButton5", args, n);
† †   /* add translations for manipulating rectangles */
† †   SetupTranslations(children[4], label_translations);
† †   n = 0;
† †   XtSetArg(args[n], XmNx, BOX_X_MARGIN + (2 *
† †                                          BOX_X_OFFSET)); n++;
† †   XtSetArg(args[n], XmNy, BOX_Y_MARGIN + BOX_Y_OFFSET); n++;
† †   XtSetArg(args[n], XmNwidth, BOX_WIDTH); n++;
† †   XtSetArg(args[n], XmNheight, BOX_HEIGHT); n++;
† †   XtSetArg(args[n], XmNlabelString, csString); n++;
† †   XtSetArg(args[n], XmNbackground, GetColor(LABEL6_COLOR));
† †   n++;
† †   XtSetArg(args[n], XmNborderWidth, 1); n++;
† †   children[5] = XmCreatePushButton(bulletinBoard,
† †                                     "PushButton6", args, n);
† †   /* add translations for manipulating rectangles */
† †   SetupTranslations(children[5], label_translations);
† †   /* Managing the children all at once helps performance */
† †   XtManageChildren(children, 6);
† †   /* Freeing compound string.  It is no longer necessary. */
† †   XmStringFree(csString);
}
/* This procedure initializes the rectangle display table */
void
#ifdef _NO_PROTO
InitializeRectDpyTable()
#else
InitializeRectDpyTable(void)
#endif /* _NO_PROTO */
{
† †   /*
† †    * Initialize display table.  This is used to maintain the
† †    * order in which the rectangles are displayed
† †    */
† †   appInfo->rectDpyTable = 
† †          (RectPtr *) XtMalloc((unsigned)sizeof(RectPtr));
† †   /* Initialize rectangle counter.  This is used in
† †    * reallocing the tables */
† †   appInfo->rectsAllocd = 1;
}
/* This procedure creates the components to be displayed */
void
#ifdef _NO_PROTO
CreateLayout()
#else
CreateLayout(void)
#endif /* _NO_PROTO */
{
† †   Widget    mainWindow, form, separator;
† †   Arg     args[10];
† †   int     n = 0;
† †   /* Create main window */
† †   mainWindow = XmCreateMainWindow(topLevel, "mainWindow",
† †                                                  args, n);
† †   XtManageChild(mainWindow);
† †   /* Create form for hold drawing area, separator, and color 
† †    * labels */
† †   n = 0;
† †   XtSetArg(args[n], XmNwidth, 300); n++;
† †   form = XmCreateForm(mainWindow, "form", args, n);
† †   XtManageChild(form);
† †   /* Create area for drawing rectangles */
† †   CreateDrawingArea(form);
† †   /* Create separator to separate drawing area from color
† †    * labels */
† †   n = 0;
† †   XtSetArg(args[n], XmNtopAttachment, XmATTACH_WIDGET); n++;
† †   XtSetArg(args[n], XmNtopWidget, drawingArea); n++;
† †   XtSetArg(args[n], XmNtopOffset, 5); n++;
† †   XtSetArg(args[n], XmNleftAttachment, XmATTACH_FORM); n++;
† †   XtSetArg(args[n], XmNrightAttachment, XmATTACH_FORM); n++;
† †   XtSetArg(args[n], XmNwidth, 300); n++;
† †   separator = XmCreateSeparatorGadget(form, "separator",
† †                                                 args, n);
† †   XtManageChild(separator);
† †   /* Create color labels for changing colors of buttons */
† †   CreateColorPushButtons(form, separator);
† †   /* Make form the work window of the main window */
† †   n = 0;
† †   XtSetArg(args[n], XmNworkWindow, form); n++;
† †   XtSetValues(mainWindow, args, n);
}
/* This procedure initializes the GC for drawing rectangles */
void
#ifdef _NO_PROTO
CreateRectGC()
#else
CreateRectGC(void)
#endif /* _NO_PROTO */
{
† †   XGCValues    values;
† †   values.line_style = LineSolid;
† †   values.line_width = HIGHLIGHT_THICKNESS;
† †   values.foreground = appInfo->currentColor = 
† †                       GetColor(RECT_START_COLOR);
† †   appInfo->rectGC = XCreateGC(XtDisplay(topLevel), 
† †                       XtWindow(drawingArea), 
† †                       GCLineStyle | GCLineWidth |
† †                       GCForeground, &values);
}GlossaryacceleratorA key or sequence of keys (typically a modifier key and some other key) that provides a shortcut, immediately accessing a program function.actionA procedure associated with a widget and invoked by the Xt event dispatcher when the widget receives an event of a given type.  The widget's translation table associates event descriptions with actions.activationInvocation of a component's primary action.  For example, the user activates a PushButton by pressing BSelect on the PushButton.anchorA position in a collection of selectable objects that marks one endpoint of an extended selection range.atomAn identifier that is unique to the display and is associated with a given name.  Common uses are to identify properties, types, and selections.bitmapA pixmap with a depth of one bit. callback An application-defined procedure that a widget invokes at some specified time.  Often the widget invokes a callback from an action routine when the widget receives an event of a given type.  Widgets that invoke callbacks have resources whose value is a list of callback procedures.character setA set of characters that, either individually or in combination, represents meaningful words in a language.classA group of elements all of the same type.  A resource class represents a group of resources with different names.  A widget class represents the procedures and data structures shared by all widgets of that class.clientA program written specifically for use with the X Window System.  Clients create their own windows and know how to resize themselves.clipboard selectionA selection often used to cut or copy data from one client and paste it into another client or another window of the same client.clippingThe restriction of output to a particular area ofthe screen by a given boundary.  For example, windows are clipped by their parents.code setThe set of binary values needed to represent all the characters in a language.colormapAn association between pixel values and colors. Each color is represented by a triple of red, green, and blue values that result in a particular color on a particular screen.  Each window has an associated colormap that determines what color is used to display each pixel.compositeOne of a group of widgets that can have child widgets and can manage their children's geometry.compound stringA byte stream consisting of tag-length-value segments and representing zero or more pieces of text.  A compound string has components that contain the text to be displayed, a tag (called a font list element tag) to be matched with an element of a font list, and an indicator denotingthe direction in which the text is to be displayed.cursorA graphical image, usually a pipe (|) or block, that shows the location where text will appear on the screen when keys on the keyboard are pressed or where a selection can be made.destinationThe location at which transfer actions place data.dialogA widget that provides a means of communicating between the user and the application.  A dialog is a popup that usually asks a question or presents some information to the user.  A dialog can be modal, suspending the application until the user provides a response, or modeless, allowing the user to interact with the application during the dialog.displayAn abstraction that represents the input and output devices controlled by a single server. Usually a display consists of a keyboard, a pointing device, and one or more screens.drag and dropA transfer mechanism where data is dragged from a source to a drop site using mouse motion.drag iconA graphic that is generated using pixmaps and is moved during a drag operation.  The drag icon is composed of a source pixmap, a state cursor, and an operation cursor.drag initiatorThe client within whose window the user starts a drag transaction.  See also drag source.drag sourceThe object whose graphical representation is being dragged and whose data the user wishes to transfer.drawableAn entity that can be the source or destination for a graphics operation.  Both windows and pixmaps are drawables.drop siteAn area of the screen on which the user can drop a drag icon.eventA means by which the server notifies clients of changes of state.  An event may be a side effect of a client request, or it may have a completely asynchronous cause, such as the user's pressing a key or moving the pointer.  In addition, a client may send an event, via the server, to another client.event handlerA procedure called by the Xt event dispatcher when a widget receives an event of a given type.  Event handlers provide input processing at a lower level than callbacks or action routines.event loopA program loop in which the application receives an event, handles the event, and then waits for the next event.  An event loop usually does not end until the user terminates the application.  Xt provides an event-dispatching loop suitable for most applications.export targetA type of object that a drag source can process.focusSee keyboard focus.fontA collection of glyphs and associated metrics usually used to display text.font listA list of entries, each of which consists of a font list element tag and either a font or a font set.  When Motif displays text, it associates the text with a font list element tag in a font list and uses the corresponding font or font set to render the text.font list element tagA string associated with a text segment of a compound string or with a font or font set in a font list.  When Motif displays text, it associates the text with a font list element tag in a font list and uses the corresponding font or font set to render the text.font setA group of fonts often representing the fonts needed to display text in the encoding of a particular locale.gadgetAn object that is like a primitive widget in most respects except that it has no associated window or translations.  A gadget depends on a manager parent for its colors and for input dispatching.GCSee graphics context.geometryThe elements of a widget's layout, including its size, location, and stacking order.geometry managementThe process by which the user, parent widgets, and child widgets negotiate the actual sizes and locations of the widgets in an application.  In general, a child widget can ask its parent to change its geometry but cannot make any changes on its own.  A parent can grant or reject a request from its child and can force changes on the child at other times.grabA client's assertion of exclusive use of a keyboard key, the keyboard, a pointer button, the pointer, or the server.  Applications usually do not use explicit grabs, but toolkits and window managers often use them to implement such features as menus and accelerators.graphics context (GC)A collection of attributes that determine how any given graphics operation affects a drawable.  Each graphics operation on a drawable is executed using a given graphics context specified by the client. Some attributes of a graphics context are the foreground pixel, background pixel, line width, and clipping region.hotspotThe location in a cursor that corresponds to the coordinates of the pointer position.I18NSee internationalization.import targetA type of object that a drop site can process.input contextThe mechanism used to provide the state information flow between an application and the input method.input focusSee keyboard focus.input methodA layer of mapping between the keyboard keys (or combination of keys) that the user types and the text data that is passed to the application.insertion cursorThe graphical symbol that provides the visual cue to the location of the insertion point in a Text component.internationalization (I18N)The process of generalizing programs or systems so that they can handle a variety of languages, character sets, and national customs.keyboard focusA state of the system that indicates which component receives keyboard events.  A component is said to have the focus if keyboard events are sent to that component.keyboard traversalThe set of actions, usually invoked from the keyboard, that cause focus to move from one component to another within an application or between applications.localizationThe process of providing language-specific or country-specific information and support for programs.manageTo place the geometry of a child widget under the control of its parent.  In general widgets are eligible to appear on the screen only after they are managed.managerOne of a group of widgets that can have children and can manage their geometry.  Managers provide colors and input dispatching for gadget children.mapTo mark a window as eligible to be visible on the screen.  A window actually becomes visible when all of its ancestors are mapped and when it is not obscured by an ancestor or by another window.menuA popup widget usually allowing the user to make a single selection from a constrained set of choices.  A menu is usually modal, suspending the application until the user makes a selection or dismisses the menu.  When torn off, a menu becomes modeless, allowing the user to interact with the application while the menu remains visible.mnemonicA single character (frequently the initial character) of a Menu selection.  When the Menu is displayed and the user presses the key that corresponds to that character, the Menu selection is chosen.modalA state of a dialog that requires the user to interact with the dialog before interacting with other parts of the application or with other applications.  Three modal styles exist: primary application modal, full application modal, and system modal.  See also modeless.modelessA state of a dialog that does not require the user to interact with the dialog before interacting with other parts of the application or with other applications.  See also modal.off-the-spotA location for the pre-edit area in an input method.  The input data is displayed in a window within the application window but not at the point of insertion.over-the-spotA location for the pre-edit area in an input method.  The input data is displayed in a window immediately above the point of insertion.paneA widget that is a child of a PanedWindow.  The user adjusts the size of a pane by means of a sash.pending deleteA state of a Text component in which some user actions cause the current selection to be deleted.pixelA unit of height and width for a window or pixmap. Each pixel has a number of bits or planes equal to the depth of the window or pixmap.  Thus, each pixel has an integral value whose range depends on the depth of the drawable.  The pixel value is used as an index into a colormap to determine the color to display for that pixel.pixmapA two-dimensional array of pixels, all of the same depth.  Like a window, a pixmap is a drawable, an entity that can be the source or destination for a graphics operation.popupA widget that is outside the normal widget hierarchy.  Any widget can have popup children, and the widget does not manage these children.  A popup's window is a descendant of the root window, and the popup is not clipped by the parent widget. A popup usually appears on the screen temporarily in behalf of its parent.  Dialogs and menus are the most common popups.pre-edit areaAn area that displays the intermediate text characters for languages whose characters may require more than one keystroke to complete.pre-editingCreating characters in a particular language by using individual keystrokes  or combinations of keystrokes.primary selectionThe principal selection, used to transfer data from one client to another or to another window of the same client.primitiveOne of a group of widgets that usually do not have children.propertyAn entity associated with a window and consisting of a name, a type, a data format, and data. Properties are often used for communicating between clients and between a client and the window manager.realizeTo create windows for a widget and its managed children.receiverThe client containing the destination of a drag and drop transaction.resourceAn element of a database representing options or values for attributes of an application.  A resource is a triple consisting of a name, a class, and a value.  A name and class may consist of components, each identifying the name or class of a particular level of a hierarchy.  A widget can also have resources, whose values are derived from the resource database or set directly by the application.root windowA window that covers the entire viewable extent of the screen and is the ancestor of all other windows on the screen.root-windowA pre-edit area (or window) that is a child of the root window and not a part of the application window.sashA control with which the user changes the sizes of panes in a PanedWindow.screenAn abstraction that represents a single bitmapped output device on a display.secondary selectionA selection, usually transitory, used to transfer data from one client to another or to another window of the same client without disturbing the primary selection.selectionA mechanism for transferring data from one client to another or to another window of the same client.  The principal types of selection are primary, secondary, and clipboard.  The display contains only one selection of each type.  It is owned by a client or by no one and, if owned, is attached to a window of the owning client.sensitiveEligible to receive input events.  Xt does not dispatch most input events to insensitive widgets.serverThe component of the X Window System that manages input and the visual display.shellOne of a group of widgets that envelop the top-level widgets, including dialogs and menus, in an application.  A shell usually has only one managed child, and its window is often coincident with the managed child's window.  A shell usually handles communication with the window manager.status areaAn input method output-only window thaqt identifies the input style (phonetic, numeric, stroke and radial, etc.) and the current status of an input method interaction.tab groupA widget or set of widgets to which the user traverses by means of the <Tab> key.  Within a tab group, the user traverses to non-tab-group descendants by means of the arrow keys.translationA mapping from an event description to one or more actions.  When a widget receives an event, Xt searches the widget's translation table for a matching event description.  If it finds such a description, it invokes the associated action or actions.traversalSee keyboard traversal.virtual bindingAn assocation between an abstract key or pointer button, known as a virtual key or virtual button, and a physical key or button on the display.virtual buttonAn abstract representation of a pointer button that is independent of any physical button.  A virtual button is associated with a physical button by means of a virtual binding.virtual keyAn abstract representation of a key that is independent of any physical key.  A virtual key is associated with a physical key by means of a virtual binding.widgetAn object used to hold data and present an interface to the user.  A widget is a combination of state and procedure.  Each widget is a member of a class, which holds the procedures and data structures common to all widgets of that class.  A widget instance holds the procedures and data structures particular to that single widget.  Each widget class typically provides the general behavior associated with a particular kind of interaction with the user.windowA data structure that represents all or part of the display screen.  Visually, a window is represented as a subarea of the display screen.window managerA program that controls the size, placement, and operation of windows on the workspace.  The window manager includes the functional window frames that surround each window object and may include a separate Menu for the workspace._MOTIF_WM_MESSAGESIDREF="ch16306"MWM MessagesacceleratorIDREF="ch02224"Handling Input and OutputIDREF="ch1326"Input, Focus, and Keyboard NavigationIDREF="ch13419"Mnemonics and AcceleratorsIDREF="ch02226"Handling Input and OutputIDREF="ch1328"Input, Focus, and Keyboard NavigationactionIDREF="ch02221"Handling Input and OutputIDREF="ch13402"ActionsIDREF="ch1322"Input, Focus, and Keyboard NavigationIDREF="ch13375"Translations and ActionsIDREF="ch0212"A User-Centered ModelactivationIDREF="ch0213"A User-Centered ModelIDREF="ch08139"Text Editing and CallbacksIDREF="ch0728"Activation, Cancellation, and Helpactive drop siteIDREF="ch15322"Establishing a Drop Siteadd modeIDREF="ch0894"Keyboard SelectionanchorIDREF="ch0846"SelectionIDREF="ch0872"SelectionapplicationIDREF="ch03205"Multiple Screens, Displays, and ApplicationsIDREF="ch16240"Application Shutdown and RestartIDREF="ch02187"Applications, Top-Level Widgets, and DialogsIDREF="ch167"Application StartupIDREF="ch02189"Applicationsapplication programming interfaceIDREF="ch012"Introductionapplication-defined scrollingIDREF="ch09176"Example of Application-Defined ScrollingIDREF="ch09141"Application-Defined ScrollingIDREF="ch096"Automatic and Application-Defined ScrollingApplicationShellIDREF="ch16246"Application Shutdown and RestartIDREF="ch02201"Top-Level WidgetsIDREF="ch16259"Application Shutdown and RestartIDREF="ch03210"Multiple Screens, Displays, and ApplicationsIDREF="ch09241"MainWindowIDREF="ch01129"Xt ClassesIDREF="ch02197"ApplicationsIDREF="ch0317"Initializing the IntrinsicsIDREF="ch02171"VendorShellIDREF="ch02194"ApplicationsIDREF="ch02172"VendorShellIDREF="ch1612"Application StartupArgIDREF="ch03103"Arguments that Specify Resource ValuesIDREF="ch03101"Arguments that Specify Resource ValuesargumentsIDREF="ch04114"list DeclarationIDREF="ch04189"Fetching Information from UID FilesIDREF="ch0492"Resource ValuesarmingIDREF="ch1289"Arming and SelectionArrowButtonIDREF="ch05108"ArrowButtonsIDREF="ch0635"ButtonsIDREF="ch10396"Managing Geometry Using BulletinBoard and DrawingAreaatomIDREF="ch16313"Atom and Protocol Managementattaching iconsIDREF="ch1525"Overview of Drag-Over EffectsautoKeyFocusIDREF="ch16229"Input Focusautomatic scrollingIDREF="ch0960"Automatic ScrollingIDREF="ch09125"Example of Automatic ScrollingIDREF="ch094"Automatic and Application-Defined Scrollingauxiliary areaIDREF="ch11305"Input MethodbackgroundIDREF="ch1256"BackgroundsbaseTranslationsIDREF="ch13386"Using TranslationsIDREF="ch13389"Using TranslationsIDREF="ch13383"Using TranslationsBExtendIDREF="ch05165"ListIDREF="ch05169"ListIDREF="ch0880"Mouse SelectionbitmapIDREF="ch0116"The X Window Systemblending iconsIDREF="ch1523"Overview of Drag-Over EffectsBMenuIDREF="ch0610"Menus and OptionsborderIDREF="ch1246"BordersBSelectIDREF="ch0570"CascadeButtonsIDREF="ch0873"SelectionIDREF="ch1313"Input, Focus, and Keyboard NavigationIDREF="ch0175"Visual StyleIDREF="ch05161"ListIDREF="ch0598"ToggleButtonsIDREF="ch16224"Input FocusIDREF="ch1346"Focus ModelsIDREF="ch05163"ListIDREF="ch1334"Focus ModelsIDREF="ch13371"Focus CallbacksIDREF="ch02220"Handling Input and OutputIDREF="ch05140"ScrollBarIDREF="ch0215"A User-Centered ModelIDREF="ch14177"Handling Input EventsIDREF="ch0579"PushButtonsIDREF="ch1353"Focus ModelsIDREF="ch0896"Keyboard SelectionBtnMotionIDREF="ch14178"Handling Input EventsIDREF="ch14174"Handling Input EventsBToggleIDREF="ch05167"ListIDREF="ch0881"Mouse SelectionBTransferIDREF="ch1570"Drag Sources and Drop SitesIDREF="ch15414"Drag Initiator Responsibilities for DraggingIDREF="ch15196"Overview of Programmer ResponsibilitiesIDREF="ch0182"Selections and Drag and DropIDREF="ch0886"Mouse SelectionIDREF="ch15419"Recognizing a Drag Has StartedIDREF="ch15180"Overview of Programmer ResponsibilitiesIDREF="ch0882"Mouse SelectionIDREF="ch15423"Starting a Drag With XmDragStartIDREF="ch0183"Selections and Drag and DropIDREF="ch1550"Technical Overview of Drag and DropIDREF="ch154"Overview of User InteractionIDREF="ch06262"TearOffMenusBulletinBoardIDREF="ch10387"Managing Geometry Using BulletinBoard and DrawingAreaIDREF="ch0716"BulletinBoardIDREF="ch11104"Font List Resource DefaultsIDREF="ch0758"DialogShellIDREF="ch0576"PushButtonsIDREF="ch0760"DialogShellIDREF="ch16287"FunctionsIDREF="ch0788"Initial FocusIDREF="ch0789"Initial FocusIDREF="ch11110"Font List Resource DefaultsIDREF="ch01198"ShellsIDREF="ch0738"Activation, Cancellation, and HelpIDREF="ch01188"ManagersIDREF="ch01186"ManagersIDREF="ch16296"Input ModeIDREF="ch02180"DialogShellIDREF="ch077"BulletinBoard and DialogShellIDREF="ch0743"Activation, Cancellation, and HelpIDREF="ch0723"BulletinBoardIDREF="ch0745"Activation, Cancellation, and HelpIDREF="ch0724"BulletinBoardIDREF="ch10406"Managing Geometry Using FormIDREF="ch0771"DialogShellIDREF="ch10227"Shells and Their ChildrenIDREF="ch02145"BulletinBoard, Form, MessageBox, SelectionBoxIDREF="ch0773"DialogShellIDREF="ch10377"Managing Geometry Using BulletinBoard and DrawingAreaIDREF="ch02159"BulletinBoard, Form, MessageBox, SelectionBoxIDREF="ch02141"BulletinBoard, Form, MessageBox, SelectionBoxIDREF="ch0751"DialogShellIDREF="ch0777"DialogShellIDREF="ch0712"BulletinBoard and DialogShellIDREF="ch1620"Application StartupIDREF="ch16274"MWM Properties and ResourcesIDREF="ch02147"BulletinBoard, Form, MessageBox, SelectionBoxIDREF="ch0732"Activation, Cancellation, and HelpIDREF="ch02154"BulletinBoard, Form, MessageBox, SelectionBoxIDREF="ch0715"BulletinBoardBulletinBoardDialogIDREF="ch0778"DialogShellbuttonIDREF="ch0553"ButtonsIDREF="ch0631"ButtonsIDREF="ch0535"Labels, Buttons, and SeparatorsIDREF="ch0628"Menu Components: Buttons, RowColumn, MenuShellIDREF="ch1569"Drag Sources and Drop SitesIDREF="ch0259"ButtonsButtonPressIDREF="ch14168"Handling Input EventsIDREF="ch14181"Example of an Input ProcedureIDREF="ch14159"Handling Input EventsButtonPressMaskIDREF="ch13466"Event HandlersButtonReleaseIDREF="ch14169"Handling Input EventsIDREF="ch14160"Handling Input EventscallbackIDREF="ch03138"Adding Callback ProceduresIDREF="ch0210"A User-Centered ModelIDREF="ch15204"Overview of Programmer ResponsibilitiesIDREF="ch04206"Defining Callback ProceduresIDREF="ch15537"Drag CallbacksIDREF="ch0169"Event HandlingIDREF="ch04156"Registering Callbacks and IdentifiersIDREF="ch1423"Event Handling and CallbacksIDREF="ch13356"Focus CallbacksIDREF="ch15210"Overview of Programmer ResponsibilitiesIDREF="ch08104"Text Editing and CallbacksIDREF="ch03142"Adding Callback ProceduresIDREF="ch0494"Callback ProcedurescallbacksIDREF="ch04116"list DeclarationIDREF="ch04193"Fetching Information from UID FilesIDREF="ch0497"Callback ProcedurescancelIDREF="ch15212"Overview of Programmer ResponsibilitiesIDREF="ch15653"Cancelling a DropIDREF="ch0729"Activation, Cancellation, and HelpIDREF="ch15584"Cancelling the DragCascadeButtonIDREF="ch02129"RowColumnIDREF="ch06157"PulldownMenuIDREF="ch067"Menus and OptionsIDREF="ch0562"CascadeButtonsIDREF="ch06129"PopupMenuIDREF="ch06178"OptionMenuIDREF="ch01146"Primitives and GadgetsIDREF="ch0264"ButtonsIDREF="ch0612"Menus and OptionsIDREF="ch02127"RowColumnIDREF="ch1347"Focus ModelsIDREF="ch0488"ChildrenIDREF="ch0615"Menus and OptionsIDREF="ch0558"CascadeButtonsIDREF="ch0655"RowColumnIDREF="ch06153"PulldownMenuIDREF="ch0643"ButtonsIDREF="ch02124"RowColumnIDREF="ch123"Color and PixmapsIDREF="ch06260"TearOffMenusCascadeButtonGadgetIDREF="ch02134"RowColumnIDREF="ch06173"OptionMenuIDREF="ch0265"ButtonsIDREF="ch06205"OptionMenuIDREF="ch06191"OptionMenuIDREF="ch06192"OptionMenuIDREF="ch0620"Menus and OptionsIDREF="ch06209"OptionMenuIDREF="ch06113"MenuBarcatcloseIDREF="ch11267"Message Catalogs and LocalizationcatgetsIDREF="ch11268"Message Catalogs and LocalizationcatopenIDREF="ch11273"Message Catalogs and LocalizationIDREF="ch11266"Message Catalogs and LocalizationIDREF="ch11270"Message Catalogs and Localizationchange_managed methodIDREF="ch03188"Realizing WidgetsIDREF="ch03167"Managing WidgetsIDREF="ch1015"Widget Class ProceduresIDREF="ch03176"Managing WidgetsIDREF="ch03172"Managing WidgetsIDREF="ch0755"DialogShellcharIDREF="ch087"TextIDREF="ch08230"Convenience RoutinesIDREF="ch08165"Text Resources and Geometrycharacter setIDREF="ch118"Internationalization and LocalizationIDREF="ch115"Internationalization and LocalizationIDREF="ch113"Internationalization and LocalizationIDREF="ch117"Internationalization and Localizationcharacter_setIDREF="ch1146"Compound Strings in UILIDREF="ch1155"Compound Strings in UILIDREF="ch11241"Preparing Localized UID FilesIDREF="ch11232"Preparing Localized UID FilesIDREF="ch1161"Compound Strings in UILIDREF="ch1151"Compound Strings in UILIDREF="ch11133"Font Lists in UILIDREF="ch0431"Module-Level DeclarationsIDREF="ch11135"Font Lists in UILIDREF="ch1153"Compound Strings in UILCheckBoxIDREF="ch06216"RadioBox and CheckBoxIDREF="ch0273"ButtonsIDREF="ch02138"RowColumnIDREF="ch0586"ToggleButtonsIDREF="ch06213"RadioBox and CheckBoxIDREF="ch06249"RadioBox and CheckBoxIDREF="ch06221"RadioBox and CheckBoxIDREF="ch146"Graphics and Text in a DrawingAreaIDREF="ch0624"Menus and OptionsclassIDREF="ch0151"WidgetsIDREF="ch024"A User-Centered ModelIDREF="ch1014"Widget Class ProceduresIDREF="ch1597"Drag and Drop Widget ClassesIDREF="ch01108"Widget Classes and HierarchyIDREF="ch0141"Xlibclient-server modelIDREF="ch015"The X Window SystemclientAutoPlaceIDREF="ch1653"Window ConfigurationclientDecorationIDREF="ch16279"DecorationsclientFunctionsIDREF="ch16285"FunctionsclipboardIDREF="ch16432"The Motif Clipboardclipboard selectionIDREF="ch16350"Selection TypesIDREF="ch16434"The Motif ClipboardIDREF="ch0857"SelectionIDREF="ch0841"SelectionclippingIDREF="ch0111"The X Window Systemcode setIDREF="ch116"Internationalization and LocalizationIDREF="ch114"Internationalization and LocalizationcolorIDREF="ch1211"Default Colors and PixmapsIDREF="ch04166"Fetching Information from UID FilesIDREF="ch121"Color and PixmapscolormapIDREF="ch15274"Protocols and VisualsIDREF="ch0117"The X Window SystemIDREF="ch12151"ColormapsIDREF="ch16231"ColormapscolormapFocusPolicyIDREF="ch16236"ColormapsCommandIDREF="ch02152"BulletinBoard, Form, MessageBox, SelectionBoxIDREF="ch07169"CommandIDREF="ch09228"MainWindowIDREF="ch07120"Making a Selection: SelectionBoxIDREF="ch09213"MainWindowIDREF="ch07165"CommandIDREF="ch07172"CommandIDREF="ch07137"Making a Selection: SelectionBoxIDREF="ch09209"MainWindowCompositeIDREF="ch01114"Xt ClassesIDREF="ch1047"Geometry Change RequestsIDREF="ch0155"WidgetsIDREF="ch06134"PopupMenuIDREF="ch01119"Xt ClassesIDREF="ch01116"Xt Classescompound stringIDREF="ch1123"Compound String ComponentsIDREF="ch1124"Compound String ComponentsIDREF="ch1125"Compound String ComponentsIDREF="ch11335"Compound Strings and Compound TextIDREF="ch0255"Label and SeparatorIDREF="ch1127"Compound String ComponentsIDREF="ch11149"Compound Strings and Font ListsIDREF="ch0191"Compound Strings and Font ListsIDREF="ch1129"Compound Strings and ResourcesIDREF="ch1116"Compound Strings, Fonts, and Text DisplayIDREF="ch1122"Compound String Componentscompound textIDREF="ch11336"Compound Strings and Compound Textcompound_stringIDREF="ch1168"Compound Strings in UILCOMPOUND_TEXTIDREF="ch16372"Text ConversionIDREF="ch16144"IconsIDREF="ch16403"Text ConversionIDREF="ch1628"Application StartupIDREF="ch16387"Text ConversionIDREF="ch16380"Text ConversionIDREF="ch16397"Text ConversionIDREF="ch15622"XmNdropProcIDREF="ch15610"XmNdropProcIDREF="ch16383"Text Conversioncompress_exposureIDREF="ch14123"Handling Exposure EventsConfigureNotifyIDREF="ch16120"Window ConfigurationIDREF="ch16121"Window ConfigurationIDREF="ch16108"Window ConfigurationIDREF="ch16109"Window ConfigurationIDREF="ch09153"Application-Defined ScrollingConstraintIDREF="ch10269"Manager Widgets and Their ChildrenIDREF="ch01171"ManagersIDREF="ch10277"Manager Widgets and Their ChildrenIDREF="ch10278"Manager Widgets and Their ChildrenIDREF="ch01115"Xt ClassescontrolIDREF="ch0227"Building Blocks: Primitive Widgets and GadgetscontrolsIDREF="ch0472"ChildrenIDREF="ch04120"list DeclarationIDREF="ch0481"Childrencopy operationIDREF="ch1541"Drag OperationsCoreIDREF="ch0289"ManagersIDREF="ch10262"Manager Widgets and Their ChildrenIDREF="ch13380"Using TranslationsIDREF="ch0522"CoreIDREF="ch01135"Primitives and GadgetsIDREF="ch0516"Core, RectObj, XmPrimitive, and XmGadget ClassesIDREF="ch13437"Mnemonics and AcceleratorsIDREF="ch16103"Window ConfigurationIDREF="ch106"Managing GeometryIDREF="ch1633"Window ConfigurationIDREF="ch1212"Default Colors and PixmapsIDREF="ch0233"Building Blocks: Primitive Widgets and GadgetsIDREF="ch0230"Building Blocks: Primitive Widgets and GadgetsIDREF="ch1215"Default Colors and PixmapsIDREF="ch01111"Xt Classescreating widgetsIDREF="ch0374"Creating WidgetscursorIDREF="ch0845"SelectionIDREF="ch0868"SelectionIDREF="ch0119"The X Window SystemcustomizationIDREF="ch0327"The Initial Resource DatabaseIDREF="ch0337"File Search Pathsdata transferIDREF="ch15221"Overview of Programmer ResponsibilitiesIDREF="ch15625"XmDropTransferIDREF="ch15694"Dealing with Requests for TransferIDREF="ch16407"Incremental Transfersdata typeIDREF="ch03117"Resource Value Data TypesdefaultVirtualBindingsIDREF="ch13417"Bindings for osf KeysymsIDREF="ch13411"Bindings for osf KeysymsIDREF="ch13416"Bindings for osf KeysymsdeiconifyKeyFocusIDREF="ch16227"Input FocusDELETEIDREF="ch16362"TargetsIDREF="ch15712"Dealing with Requests for TransferIDREF="ch15651"Processing Each OperationdestinationIDREF="ch0861"SelectionIDREF="ch0843"SelectiondialogIDREF="ch02188"Applications, Top-Level Widgets, and DialogsIDREF="ch02203"DialogsIDREF="ch16292"Input ModeIDREF="ch16172"Menus and DialogsIDREF="ch071"DialogsDialogShellIDREF="ch078"BulletinBoard and DialogShellIDREF="ch0752"DialogShellIDREF="ch0710"BulletinBoard and DialogShellIDREF="ch0754"DialogShellIDREF="ch07132"Making a Selection: SelectionBoxIDREF="ch16297"Input ModeIDREF="ch0796"Making a Selection: SelectionBoxIDREF="ch10245"Shells and Their ChildrenIDREF="ch0774"DialogShellIDREF="ch02179"DialogShellIDREF="ch10223"Shells and Their ChildrenIDREF="ch0713"BulletinBoard and DialogShellIDREF="ch16180"Menus and DialogsIDREF="ch02165"ShellsIDREF="ch0780"DialogShellIDREF="ch0761"DialogShellIDREF="ch07186"MessageBoxIDREF="ch07209"FormIDREF="ch02208"DialogsIDREF="ch01195"ShellsIDREF="ch0764"DialogShellIDREF="ch07164"Choosing a Pathname: FileSelectionBoxIDREF="ch02174"DialogShellIDREF="ch07125"Making a Selection: SelectionBoxIDREF="ch1399"SensitivityIDREF="ch02205"DialogsIDREF="ch0748"DialogShellDimensionIDREF="ch03100"Arguments that Specify Resource ValuesIDREF="ch03119"Resource Value Data TypesdisplayIDREF="ch016"The X Window SystemIDREF="ch03203"Multiple Screens, Displays, and ApplicationsdragIDREF="ch1558"A Simple Drag ReceiverIDREF="ch1527"Drag StatesIDREF="ch15237"Drag ProtocolsIDREF="ch15585"Cancelling the DragIDREF="ch156"Overview of User InteractionIDREF="ch15678"Drag Initiator Responsibilities for DroppingIDREF="ch1537"Drag OperationsIDREF="ch15412"Drag Initiator Responsibilities for DraggingIDREF="ch15528"Creating a Drag IconIDREF="ch157"Overview of User InteractionIDREF="ch15591"Drop Receiver Responsibilities for DroppingIDREF="ch155"Overview of User InteractionIDREF="ch15198"Overview of Programmer ResponsibilitiesIDREF="ch1575"ProtocolsIDREF="ch15302"Drop Receiver Responsibilities for DraggingIDREF="ch15157"OperationsIDREF="ch15213"Overview of Programmer Responsibilitiesdrag and dropIDREF="ch0181"Selections and Drag and DropIDREF="appb1"Drag and Drop Example ProgramIDREF="ch0177"Selections and Drag and DropIDREF="ch15234"Drag and Drop ProtocolsIDREF="ch151"Drag and DropIDREF="ch152"User Overview of Drag and Dropdrag-over effectIDREF="ch15206"Overview of Programmer ResponsibilitiesIDREF="ch15271"Protocols and VisualsIDREF="ch1514"Overview of Drag-Over EffectsIDREF="ch1548"Overview of Drop Effectsdrag-under effectIDREF="ch15246"The Preregister Drag ProtocolIDREF="ch15346"Drag-Under Visual EffectsIDREF="ch15307"Drop Receiver Responsibilities for DraggingIDREF="ch15184"Overview of Programmer ResponsibilitiesIDREF="ch1545"Overview of Drag-Under EffectsIDREF="ch1549"Overview of Drop EffectsDragContextIDREF="ch15113"Drag and Drop FunctionsIDREF="ch15515"Visual Style NotesIDREF="ch15516"Visual Style NotesIDREF="ch15454"Drag-Over Visual EffectsIDREF="ch15554"Drag CallbacksIDREF="ch15455"Drag-Over Visual EffectsIDREF="ch15432"Starting a Drag With XmDragStartIDREF="ch15457"Drag-Over Visual EffectsIDREF="ch15375"XmNdragProcIDREF="ch16428"The Xt Selection InterfaceIDREF="ch15459"Drag-Over Visual EffectsIDREF="ch15490"Operation IconIDREF="ch15434"Starting a Drag With XmDragStartIDREF="ch1551"Technical Overview of Drag and DropIDREF="ch15437"Overriding Existing Drag SourcesIDREF="ch15527"Visual Style NotesIDREF="ch15415"Drag Initiator Responsibilities for DraggingIDREF="ch15136"Drag and Drop FunctionsIDREF="ch15142"TargetsIDREF="ch15701"Dealing with Requests for TransferIDREF="ch15159"OperationsIDREF="ch15533"Creating a Drag IconIDREF="ch15442"Overriding Existing Drag SourcesIDREF="ch15291"Drop ProtocolIDREF="ch15424"Starting a Drag With XmDragStartIDREF="ch15707"Dealing with Requests for TransferIDREF="ch15102"Drag and Drop Widget ClassesIDREF="ch15446"Overriding Existing Drag SourcesIDREF="ch15426"Starting a Drag With XmDragStartIDREF="ch15199"Overview of Programmer ResponsibilitiesIDREF="ch15167"OperationsIDREF="ch15578"Drag CallbacksIDREF="ch15477"State IconIDREF="ch15580"Drag CallbacksIDREF="ch15582"Getting Data about the Current Drop SiteIDREF="ch15583"Getting Data about the Current Drop SiteIDREF="ch15450"Overriding Existing Drag SourcesIDREF="ch15316"Establishing a Drop SiteIDREF="ch15480"State IconIDREF="ch15373"XmNdragProcIDREF="ch15512"Drag Icon Blending and AttachmentDragIconIDREF="ch15178"Overview of Programmer ResponsibilitiesIDREF="ch15501"Drag Icon Blending and AttachmentIDREF="ch15100"Drag and Drop Widget ClassesIDREF="ch15108"Drag and Drop FunctionsIDREF="ch15530"Creating a Drag IcondrawableIDREF="ch0113"The X Window SystemDrawingAreaIDREF="ch14164"Handling Input EventsIDREF="ch09130"Example of Automatic ScrollingIDREF="ch09189"Example of Application-Defined ScrollingIDREF="ch1431"Event Handling and CallbacksIDREF="ch1469"Moving and Resizing ChildrenIDREF="ch14171"Handling Input EventsIDREF="ch14112"Resizing and RedisplayIDREF="ch13270"Initial FocusIDREF="ch14114"Resizing and RedisplayIDREF="ch14176"Handling Input EventsIDREF="ch09151"Application-Defined ScrollingIDREF="ch1434"Event Handling and CallbacksIDREF="ch02231"Handling Input and OutputIDREF="ch141"Graphics and Text in a DrawingAreaIDREF="ch10378"Managing Geometry Using BulletinBoard and DrawingAreaIDREF="ch14186"Using a DrawingArea in a ScrolledWindowIDREF="ch1476"Moving and Resizing ChildrenIDREF="ch14189"Using a DrawingArea in a ScrolledWindowIDREF="ch14124"Handling Exposure EventsIDREF="ch09132"Example of Automatic ScrollingIDREF="ch1439"Event Handling and CallbacksIDREF="ch09179"Example of Application-Defined ScrollingIDREF="ch147"Graphics and Text in a DrawingAreaIDREF="ch15410"Simulating Nested Drop SitesIDREF="ch148"DrawingArea: A General-Purpose WidgetIDREF="ch14130"Handling Exposure EventsIDREF="ch14197"Using a DrawingArea in a ScrolledWindowIDREF="ch149"DrawingArea: A General-Purpose WidgetIDREF="ch14199"Using a DrawingArea in a ScrolledWindowIDREF="ch1483"Moving and Resizing ChildrenIDREF="ch1445"Handling Resize EventsIDREF="ch14134"Handling Exposure EventsIDREF="ch01191"ManagersIDREF="ch14204"Using a DrawingArea in a ScrolledWindowIDREF="ch11325"Text Input Using a DrawingAreaIDREF="ch1412"DrawingArea: A General-Purpose WidgetIDREF="ch09181"Example of Application-Defined ScrollingIDREF="ch1450"Handling Resize EventsIDREF="ch1414"DrawingArea: A General-Purpose WidgetIDREF="ch14141"Handling Exposure EventsIDREF="ch14211"Using a DrawingArea in a ScrolledWindowIDREF="ch14212"Using a DrawingArea for GraphicsIDREF="ch09196"Example of Application-Defined ScrollingIDREF="ch14214"Using a DrawingArea for GraphicsIDREF="ch1416"DrawingArea: A General-Purpose WidgetIDREF="ch14216"Using a DrawingArea for GraphicsIDREF="ch14217"Using a DrawingArea for GraphicsIDREF="ch0812"TextIDREF="ch14219"DrawingArea and Advanced Text EditingIDREF="ch02161"DrawingAreaIDREF="ch14222"Text OutputIDREF="ch1419"DrawingArea: A General-Purpose WidgetIDREF="ch1496"Moving and Resizing ChildrenIDREF="ch1458"Moving and Resizing ChildrenIDREF="ch09158"Application-Defined ScrollingIDREF="ch09136"Example of Automatic ScrollingIDREF="ch1370"Controlling Keyboard NavigationIDREF="ch09129"Example of Automatic ScrollingIDREF="ch14155"Handling Input EventsIDREF="ch1426"Event Handling and CallbacksIDREF="ch09138"Example of Automatic ScrollingIDREF="ch09203"Example of Application-Defined ScrollingIDREF="ch14106"Resizing and RedisplayIDREF="ch14162"Handling Input EventsIDREF="ch14107"Resizing and RedisplayDrawnButtonIDREF="ch10397"Managing Geometry Using BulletinBoard and DrawingAreaIDREF="ch01147"Primitives and GadgetsIDREF="ch0275"ButtonsIDREF="ch15337"Specially Shaped Drop SitesIDREF="ch0636"ButtonsIDREF="ch14215"Using a DrawingArea for GraphicsIDREF="ch05101"DrawnButtonsdropIDREF="ch15652"Cancelling a DropIDREF="ch1583"Drop ProtocolIDREF="ch159"Overview of User InteractionIDREF="ch15284"Drop Protocoldrop siteIDREF="ch15321"Establishing a Drop SiteIDREF="ch15323"Establishing a Drop SiteIDREF="ch15189"Overview of Programmer ResponsibilitiesIDREF="ch15335"Specially Shaped Drop SitesIDREF="ch1534"Drag StatesIDREF="ch1547"Overview of Drag-Under EffectsIDREF="ch15308"Establishing a Drop SiteIDREF="ch1511"Overview of User InteractionIDREF="ch1532"Drag StatesIDREF="ch1530"Drag StatesIDREF="ch15343"Overlapping Drop SitesIDREF="ch15394"Simulating Nested Drop SitesDropSiteIDREF="ch15348"Drag-Under Visual EffectsIDREF="ch1573"Drag Sources and Drop SitesIDREF="ch15326"Establishing a Drop SiteIDREF="ch15150"TargetsIDREF="ch15161"OperationsIDREF="ch15647"Processing Each OperationIDREF="ch15557"Drag CallbacksIDREF="ch15168"OperationsIDREF="ch1557"Complexity of Drag and Drop ProgramsIDREF="ch15560"Drag CallbacksIDREF="ch15104"Drag and Drop Widget ClassesIDREF="ch15377"XmNdragProcIDREF="ch15563"Drag CallbacksIDREF="ch15548"Drag CallbacksIDREF="ch15248"The Preregister Drag ProtocolIDREF="ch15550"Drag CallbacksDropTransferIDREF="ch15703"Dealing with Requests for TransferIDREF="ch1591"Drop ProtocolIDREF="ch15633"XmDropTransferIDREF="ch15292"Drop ProtocolIDREF="ch15607"XmNdropProcIDREF="ch15624"XmDropTransferIDREF="ch15596"Drop Receiver Responsibilities for DroppingIDREF="ch15106"Drag and Drop Widget ClassesIDREF="ch15656"Cancelling a DropIDREF="ch15297"Drop ProtocolIDREF="ch15630"XmDropTransferIDREF="ch15641"XmDropTransferIDREF="ch16430"The Xt Selection InterfaceIDREF="ch15612"XmNdropProcdynamic protocolIDREF="ch15239"Drag ProtocolsIDREF="ch15249"The Dynamic Drag ProtocolIDREF="ch1580"Drag Protocolsend moduleIDREF="ch0423"Structure of a UIL ModuleenforceKeyFocusIDREF="ch16230"Input FocuserrorIDREF="ch0126"The X Window SystemErrorDialogIDREF="ch07190"MessageBoxeventIDREF="ch0127"The X Window SystemIDREF="ch0167"Event HandlingIDREF="ch02228"Handling Input and OutputIDREF="ch14153"Handling Input EventsIDREF="ch13460"Event HandlersIDREF="ch14120"Handling Exposure EventsIDREF="ch1441"Handling Resize EventsIDREF="ch0128"The X Window SystemIDREF="ch1422"Event Handling and CallbacksIDREF="ch0211"A User-Centered Modelevent handlerIDREF="ch13459"Event HandlersIDREF="ch02227"Handling Input and OutputIDREF="ch1324"Input, Focus, and Keyboard Navigationevent loopIDREF="ch04218"Entering the Event LoopIDREF="ch03221"Entering the Event Loopexport targetIDREF="ch15146"TargetsexportedIDREF="ch04184"Fetching Information from UID FilesExposeIDREF="ch14127"Handling Exposure EventsIDREF="ch14132"Handling Exposure EventsIDREF="ch14146"Handling Exposure EventsIDREF="ch14133"Handling Exposure EventsIDREF="ch10205"Exposure and RedisplayIDREF="ch14142"Handling Exposure EventsIDREF="ch14151"Example of an Expose ProcedureIDREF="ch10214"Exposure and Redisplayexpose methodIDREF="ch10206"Exposure and RedisplayIDREF="ch1427"Event Handling and CallbacksIDREF="ch14135"Handling Exposure EventsIDREF="ch14102"Resizing and RedisplayIDREF="ch14128"Handling Exposure Eventsf.focus_colorIDREF="ch16237"Colormapsf.killIDREF="ch16269"Application Shutdown and RestartIDREF="ch16266"Application Shutdown and Restartf.next_cmapIDREF="ch16238"Colormapsf.prev_cmapIDREF="ch16239"Colormapsf.send_msgIDREF="ch16308"MWM Messagesfile search pathIDREF="ch0330"File Search PathsFileSelectionBoxIDREF="ch07139"Making a Selection: SelectionBoxIDREF="ch07121"Making a Selection: SelectionBoxIDREF="ch07151"Choosing a Pathname: FileSelectionBoxIDREF="ch07159"Choosing a Pathname: FileSelectionBoxIDREF="ch13454"Mnemonics and AcceleratorsIDREF="ch0218"A User-Centered ModelIDREF="ch07161"Choosing a Pathname: FileSelectionBoxIDREF="ch13445"Mnemonics and AcceleratorsIDREF="ch09200"Example of Application-Defined ScrollingIDREF="ch07146"Choosing a Pathname: FileSelectionBoxIDREF="ch02150"BulletinBoard, Form, MessageBox, SelectionBoxIDREF="ch07155"Choosing a Pathname: FileSelectionBoxFileSelectionDialogIDREF="ch07162"Choosing a Pathname: FileSelectionBoxfocusIDREF="ch16197"Input FocusIDREF="ch132"Input, Focus, and Keyboard NavigationIDREF="ch02217"Handling Input and OutputIDREF="ch0129"The X Window SystemIDREF="ch1329"Focus ModelsIDREF="ch13265"Initial FocusIDREF="ch0782"Initial FocusIDREF="ch1284"Focus HighlightsIDREF="ch138"Input, Focus, and Keyboard NavigationfontIDREF="ch11125"Font Lists in UILIDREF="ch11129"Font Lists in UILIDREF="ch0118"The X Window SystemIDREF="ch11145"Font Lists in UILIDREF="ch1170"Fonts, Font Lists, and Font Setsfont listIDREF="ch1186"Font Lists and ResourcesIDREF="ch11150"Compound Strings and Font ListsIDREF="ch1171"Fonts, Font Lists, and Font SetsIDREF="ch0256"Label and SeparatorIDREF="ch1189"Font List Resource DefaultsIDREF="ch1173"Font List StructureIDREF="ch0197"Compound Strings and Font ListsIDREF="ch11116"Font Lists in UILIDREF="ch11166"Text and TextField Widgets and Font ListsIDREF="ch0192"Compound Strings and Font Listsfont list element tagIDREF="ch1120"Compound String ComponentsIDREF="ch0194"Compound Strings and Font ListsIDREF="ch1126"Compound String Componentsfont setIDREF="ch1172"Fonts, Font Lists, and Font Setsfont_tableIDREF="ch11123"Font Lists in UILIDREF="ch11143"Font Lists in UILfontsetIDREF="ch11121"Font Lists in UILIDREF="ch11127"Font Lists in UILIDREF="ch11147"Font Lists in UILIDREF="ch11131"Font Lists in UILforegroundIDREF="ch1260"ForegroundsForgetGravityIDREF="ch14150"Example of an Expose ProcedureIDREF="ch14111"Resizing and RedisplayIDREF="ch14145"Handling Exposure EventsFormIDREF="ch10518"Managing Geometry Using FormIDREF="ch10462"Managing Geometry Using FormIDREF="ch10411"Managing Geometry Using FormIDREF="ch10443"Managing Geometry Using FormIDREF="ch07207"FormIDREF="ch0714"BulletinBoard and DialogShellIDREF="ch10428"Managing Geometry Using FormIDREF="ch10468"Managing Geometry Using FormIDREF="ch0790"Initial FocusIDREF="ch10495"Managing Geometry Using FormIDREF="ch10496"Managing Geometry Using FormIDREF="ch09287"FrameIDREF="ch10449"Managing Geometry Using FormIDREF="ch01189"ManagersIDREF="ch10432"Managing Geometry Using FormIDREF="ch10501"Managing Geometry Using FormIDREF="ch10502"Managing Geometry Using FormIDREF="ch02160"BulletinBoard, Form, MessageBox, SelectionBoxIDREF="ch10404"Managing Geometry Using FormIDREF="ch10476"Managing Geometry Using FormIDREF="ch10419"Managing Geometry Using FormIDREF="ch10507"Managing Geometry Using FormIDREF="ch10508"Managing Geometry Using FormIDREF="ch10455"Managing Geometry Using FormIDREF="ch10436"Managing Geometry Using FormIDREF="ch10407"Managing Geometry Using FormIDREF="ch10481"Managing Geometry Using FormIDREF="ch10421"Managing Geometry Using FormIDREF="ch02142"BulletinBoard, Form, MessageBox, SelectionBoxIDREF="ch10484"Managing Geometry Using FormIDREF="ch10279"Manager Widgets and Their ChildrenIDREF="ch10410"Managing Geometry Using FormFormDialogIDREF="ch07210"FormFrameIDREF="ch09284"FrameIDREF="ch09285"FrameIDREF="ch0292"FrameIDREF="ch09264"FrameIDREF="ch14116"Resizing and RedisplayIDREF="ch09259"FrameIDREF="ch09274"FrameIDREF="ch09251"FrameIDREF="ch09267"FrameIDREF="ch01172"ManagersIDREF="ch10281"Manager Widgets and Their ChildrenIDREF="ch09278"FrameIDREF="ch09257"FrameIDREF="ch09280"FrameIDREF="ch09281"FrameIDREF="ch09270"FrameIDREF="ch09283"FrameGadgetIDREF="ch0517"Core, RectObj, XmPrimitive, and XmGadget ClassesIDREF="ch054"Basic ControlsIDREF="ch01165"Primitives and GadgetsIDREF="ch0157"WidgetsIDREF="ch0225"Building Blocks: Primitive Widgets and GadgetsIDREF="ch0237"Building Blocks: Primitive Widgets and GadgetsIDREF="ch027"A User-Centered ModelIDREF="ch0528"XmGadgetIDREF="ch01162"Primitives and GadgetsIDREF="ch01112"Xt ClassesIDREF="ch01132"Primitives and GadgetsIDREF="ch0242"Building Blocks: Primitive Widgets and GadgetsIDREF="ch16213"Input FocusIDREF="ch0243"Building Blocks: Primitive Widgets and GadgetsIDREF="ch0244"Building Blocks: Primitive Widgets and GadgetsGCIDREF="ch0122"The X Window SystemgeometryIDREF="ch11327"Geometry Management of Pre-Edit and Status AreasIDREF="ch102"Managing GeometryIDREF="ch08161"Text Resources and GeometryIDREF="ch1630"Window Configurationgeometry managementIDREF="ch11326"Geometry Management of Pre-Edit and Status AreasIDREF="ch0163"Widget Geometrygeometry_manager methodIDREF="ch10114"Intermediate Geometry RequestsIDREF="ch10104"The geometry_manager ProcedureIDREF="ch1079"The geometry_manager ProcedureIDREF="ch1090"The geometry_manager ProcedureIDREF="ch10167"The resize ProcedureIDREF="ch1098"The geometry_manager ProcedureIDREF="ch10203"Exposure and RedisplayIDREF="ch1062"The geometry_manager ProcedureIDREF="ch10170"The resize ProcedureIDREF="ch10251"Shells and Their ChildrenIDREF="ch10120"Intermediate Geometry RequestsIDREF="ch1020"Widget Class ProceduresIDREF="ch10158"The resize ProcedureIDREF="ch10190"Preferred Size and LocationIDREF="ch1054"Geometry Change RequestsIDREF="ch10235"Shells and Their ChildrenIDREF="ch10135"XtSetValuesIDREF="ch10193"Preferred Size and LocationIDREF="ch10216"Exposure and RedisplayIDREF="ch1094"The geometry_manager ProcedureIDREF="ch1485"Moving and Resizing ChildrenIDREF="ch1048"Geometry Change RequestsgrabIDREF="ch137"Input, Focus, and Keyboard NavigationIDREF="ch02215"Handling Input and Outputgraphics contextIDREF="ch0121"The X Window SystemGXxorIDREF="ch14218"Using a DrawingArea for Graphicsheader fileIDREF="ch01204"Header Files and LibrariesIDREF="ch032"Including Header FilesIDREF="ch04129"Structure of a Program Using MRMhelpIDREF="ch15666"Providing HelpIDREF="ch0730"Activation, Cancellation, and HelphighlightIDREF="ch1283"Focus HighlightsIDREF="ch0174"Visual StyleHOMEIDREF="ch0365"User Application FilehotspotIDREF="ch0120"The X Window SystemICCCMIDREF="ch163"Interclient CommunicationiconIDREF="ch1516"Overview of Drag-Over EffectsIDREF="ch15472"State IconIDREF="ch16127"IconsIDREF="ch16145"IconsIDREF="ch1536"Drag StatesIDREF="ch15462"Source IconIDREF="ch1522"Overview of Drag-Over EffectsIDREF="ch1524"Overview of Drag-Over EffectsIDREF="ch1526"Overview of Drag-Over EffectsIDREF="ch16151"IconsIDREF="ch158"Overview of User InteractionIDREF="ch16135"IconsIDREF="ch1518"Overview of Drag-Over EffectsIDREF="ch15529"Creating a Drag IconIDREF="ch04173"Fetching Information from UID FilesIDREF="ch1520"Overview of Drag-Over EffectsIDREF="ch15485"Operation IconiconDecorationIDREF="ch16134"IconsiconImageMaximumIDREF="ch16157"IconsiconImageMinimumIDREF="ch16158"IconsiconPlacementIDREF="ch16164"IconsiconPlacementMarginIDREF="ch16165"IconsidentifierIDREF="ch0415"Structure of a UIL Moduleimport targetIDREF="ch15154"Targetsinactive drop siteIDREF="ch15320"Establishing a Drop SiteincludeIDREF="ch0439"include DirectiveIDREF="ch0411"Structure of a UIL ModuleIDREF="ch11248"Preparing Localized UID Filesinclude fileIDREF="ch033"Including Header FilesIDREF="ch01205"Header Files and Librariesincremental transferIDREF="ch15293"Drop ProtocolInformationDialogIDREF="ch07192"MessageBoxinitial focusIDREF="ch13266"Initial FocusinitializationIDREF="ch04134"Initializing the IntrinsicsIDREF="ch04139"Initializing MRMIDREF="ch038"Initializing the IntrinsicsIDREF="ch168"Application StartupIDREF="ch0393"Widget Initializationinitialize methodIDREF="ch10273"Manager Widgets and Their ChildrenIDREF="ch0394"Widget InitializationIDREF="ch13398"Using TranslationsinitiatorIDREF="ch15413"Drag Initiator Responsibilities for DraggingIDREF="ch15197"Overview of Programmer ResponsibilitiesIDREF="ch15679"Drag Initiator Responsibilities for DroppinginputIDREF="ch131"Input, Focus, and Keyboard NavigationIDREF="ch02212"Handling Input and OutputIDREF="ch14152"Handling Input Eventsinput focusIDREF="ch02216"Handling Input and OutputIDREF="ch0781"Initial Focusinput managerIDREF="ch11313"Input Managerinput methodIDREF="ch11289"Input MethodIDREF="ch11300"Input MethodIDREF="ch11294"Input MethodIDREF="ch10247"Shells and Their ChildrenIDREF="ch11296"Input MethodIDREF="ch11292"Input MethodIDREF="ch11306"Input MethodIDREF="ch11298"Input MethodINSERT_PROPERTYIDREF="ch16367"TargetsINSERT_SELECTIONIDREF="ch16364"Targetsinsertion cursorIDREF="ch0867"SelectionIDREF="ch0844"SelectioninstanceIDREF="ch0248"Building Blocks: Primitive Widgets and GadgetsIDREF="ch0153"WidgetsInter-Client Communication Conventions Manual (ICCCM)IDREF="ch162"Interclient CommunicationinteractivePlacementIDREF="ch1643"Window Configurationinterclient communicationIDREF="ch161"Interclient CommunicationinternationalizationIDREF="ch111"InternationalizationIntrinsicsIDREF="ch037"Initializing the IntrinsicsIDREF="ch16410"The Xt Selection InterfaceIDREF="ch04133"Initializing the IntrinsicsIDREF="ch0148"XtIDREF="ch01107"Using Xlib, Xt, and Motifinvalid drop siteIDREF="ch1531"Drag StatesISO character setIDREF="ch119"Internationalization and LocalizationKActivateIDREF="ch064"Menus and OptionsIDREF="ch0717"BulletinBoardIDREF="ch0741"Activation, Cancellation, and HelpIDREF="ch0599"ToggleButtonsIDREF="ch05181"ListIDREF="ch07150"Choosing a Pathname: FileSelectionBoxIDREF="ch0734"Activation, Cancellation, and HelpIDREF="ch0577"PushButtonsIDREF="ch1348"Focus ModelsIDREF="ch0571"CascadeButtonsIDREF="ch0580"PushButtonsKBeginLineIDREF="ch07107"Making a Selection: SelectionBoxIDREF="ch13450"Mnemonics and AcceleratorsKCancelIDREF="ch0888"Mouse SelectionIDREF="ch06154"PulldownMenuIDREF="ch0718"BulletinBoardIDREF="ch15111"Drag and Drop FunctionsIDREF="ch0740"Activation, Cancellation, and HelpIDREF="ch15586"Cancelling the DragIDREF="ch15286"Drop ProtocolIDREF="ch06130"PopupMenuIDREF="ch06261"TearOffMenusIDREF="ch1513"Overview of User InteractionKCopyIDREF="ch08101"Keyboard SelectionKCutIDREF="ch08102"Keyboard SelectionKDownIDREF="ch07106"Making a Selection: SelectionBoxIDREF="ch1318"Input, Focus, and Keyboard NavigationIDREF="ch13172"Tab GroupsIDREF="ch13127"Tab GroupsIDREF="ch0823"Text and TextFieldIDREF="ch13449"Mnemonics and AcceleratorsIDREF="ch13175"Tab GroupsIDREF="ch0817"Text and TextFieldKEndLineIDREF="ch07108"Making a Selection: SelectionBoxIDREF="ch13452"Mnemonics and AcceleratorsKEnterIDREF="ch0820"Text and TextFieldIDREF="ch0825"Text and TextFieldKExtendIDREF="ch05170"ListIDREF="ch05166"ListIDREF="ch0897"Keyboard Selectionkeyboard focusIDREF="ch1330"Focus ModelsIDREF="ch0130"The X Window SystemIDREF="ch1285"Focus HighlightsIDREF="ch139"Input, Focus, and Keyboard NavigationIDREF="ch133"Input, Focus, and Keyboard NavigationIDREF="ch16198"Input Focuskeyboard selectionIDREF="ch0890"Keyboard Selectionkeyboard traversalIDREF="ch0234"Building Blocks: Primitive Widgets and GadgetsIDREF="ch09113"Traversing to Obscured WidgetsIDREF="ch1359"Controlling Keyboard NavigationIDREF="ch135"Input, Focus, and Keyboard NavigationIDREF="ch0188"Keyboard TraversalIDREF="ch1337"Focus ModelskeyboardFocusPolicyIDREF="ch1352"Focus ModelsIDREF="ch16223"Input FocusIDREF="ch16225"Input FocusKeyPressIDREF="ch0548"LabelsIDREF="ch13377"Translation Table FormatIDREF="ch14166"Handling Input EventsIDREF="ch14157"Handling Input EventsIDREF="ch0131"The X Window SystemIDREF="ch13434"Mnemonics and AcceleratorsKeyReleaseIDREF="ch14167"Handling Input EventsIDREF="ch14158"Handling Input EventsIDREF="ch13378"Translation Table FormatkeysymIDREF="ch13408"Bindings for osf KeysymsKHelpIDREF="ch0889"Mouse SelectionIDREF="ch1512"Overview of User InteractionIDREF="ch0746"Activation, Cancellation, and HelpIDREF="ch0236"Building Blocks: Primitive Widgets and GadgetsIDREF="ch0527"XmPrimitiveKLeftIDREF="ch13128"Tab GroupsIDREF="ch1319"Input, Focus, and Keyboard NavigationIDREF="ch13176"Tab GroupsKMenuIDREF="ch1345"Focus ModelsIDREF="ch06128"PopupMenuIDREF="ch0611"Menus and OptionsIDREF="ch1344"Focus ModelsKMenuBarIDREF="ch1343"Focus ModelsKNextFamilyWindowIDREF="ch1354"Focus ModelsKNextFieldIDREF="ch13147"Tab GroupsIDREF="ch13134"Tab GroupsIDREF="ch13143"Tab GroupsIDREF="ch1315"Input, Focus, and Keyboard NavigationIDREF="ch13132"Tab GroupsIDREF="ch13124"Tab GroupsIDREF="ch13241"Controlling Tab Group Traversal OrderKNextWindowIDREF="ch1356"Focus ModelsKPasteIDREF="ch08103"Keyboard SelectionKPrevFamilyWindowIDREF="ch1355"Focus ModelsKPrevFieldIDREF="ch13242"Controlling Tab Group Traversal OrderIDREF="ch13135"Tab GroupsIDREF="ch1316"Input, Focus, and Keyboard NavigationIDREF="ch13298"XmProcessTraversalIDREF="ch13148"Tab GroupsIDREF="ch13125"Tab GroupsIDREF="ch13238"Controlling Tab Group Traversal OrderIDREF="ch13133"Tab GroupsIDREF="ch13144"Tab GroupsKPrevWindowIDREF="ch1357"Focus ModelsKPrimaryCopyIDREF="ch0898"Keyboard SelectionKPrimaryCutIDREF="ch0899"Keyboard SelectionKRestoreIDREF="ch07109"Making a Selection: SelectionBoxIDREF="ch13453"Mnemonics and AcceleratorsKRightIDREF="ch13171"Tab GroupsIDREF="ch13129"Tab GroupsIDREF="ch13174"Tab GroupsIDREF="ch1320"Input, Focus, and Keyboard NavigationKSelectIDREF="ch0214"A User-Centered ModelIDREF="ch05100"ToggleButtonsIDREF="ch0572"CascadeButtonsIDREF="ch0581"PushButtonsIDREF="ch063"Menus and OptionsIDREF="ch0217"A User-Centered ModelIDREF="ch0895"Keyboard SelectionIDREF="ch1349"Focus ModelsIDREF="ch05164"ListIDREF="ch05168"ListKSpaceIDREF="ch0821"Text and TextFieldIDREF="ch0818"Text and TextFieldKTabIDREF="ch0824"Text and TextFieldIDREF="ch0819"Text and TextFieldIDREF="ch0284"TextKUpIDREF="ch13126"Tab GroupsIDREF="ch1317"Input, Focus, and Keyboard NavigationIDREF="ch07105"Making a Selection: SelectionBoxIDREF="ch0816"Text and TextFieldIDREF="ch0822"Text and TextFieldIDREF="ch13177"Tab GroupsIDREF="ch13448"Mnemonics and AcceleratorsLabelIDREF="ch02229"Handling Input and OutputIDREF="ch1262"ForegroundsIDREF="ch10353"Managing Geometry Using RowColumnIDREF="ch10329"Managing Geometry Using RowColumnIDREF="ch0656"RowColumnIDREF="ch0539"LabelsIDREF="ch103"Managing GeometryIDREF="ch104"Managing GeometryIDREF="ch05110"ArrowButtonsIDREF="ch0811"TextIDREF="ch15355"Drag-Under Visual EffectsIDREF="ch1552"Complexity of Drag and Drop ProgramsIDREF="ch13423"Mnemonics and AcceleratorsIDREF="ch0541"LabelsIDREF="ch09286"FrameIDREF="ch01144"Primitives and GadgetsIDREF="ch0254"Label and SeparatorIDREF="ch15468"Source IconIDREF="ch1561"A Simple Drag ReceiverIDREF="ch1562"A Simple Drag ReceiverIDREF="ch0594"ToggleButtonsIDREF="ch128"Color and PixmapsIDREF="ch1567"Drag Sources and Drop SitesIDREF="ch10341"Managing Geometry Using RowColumnIDREF="ch13431"Mnemonics and AcceleratorsIDREF="ch0663"RowColumnIDREF="ch01142"Primitives and GadgetsIDREF="ch0250"Label and SeparatorIDREF="ch0546"LabelsIDREF="ch0833"SelectionIDREF="ch1218"Default Colors and PixmapsIDREF="ch10372"Managing Geometry Using RowColumnIDREF="ch0510"Basic ControlsIDREF="ch0651"ButtonsIDREF="ch11338"Compound Strings and Compound TextIDREF="ch0534"Labels, Buttons, and SeparatorsIDREF="ch15438"Overriding Existing Drag SourcesIDREF="ch0184"Selections and Drag and DropIDREF="ch13115"XmNtraversalOnIDREF="ch10146"XtSetValuesLabelGadgetIDREF="ch06186"OptionMenuIDREF="ch1222"Default Colors and PixmapsIDREF="ch0547"LabelsIDREF="ch06188"OptionMenuIDREF="ch0542"LabelsIDREF="ch13432"Mnemonics and AcceleratorsIDREF="ch10354"Managing Geometry Using RowColumnIDREF="ch10373"Managing Geometry Using RowColumnIDREF="ch0253"Label and SeparatorIDREF="ch06193"OptionMenuIDREF="ch07178"MessageBoxIDREF="ch0595"ToggleButtonsIDREF="ch07180"MessageBoxIDREF="ch10342"Managing Geometry Using RowColumnIDREF="ch13116"XmNtraversalOnIDREF="ch06182"OptionMenuIDREF="ch05155"ScaleIDREF="ch06210"OptionMenuIDREF="ch1263"ForegroundsIDREF="ch05112"ArrowButtonsIDREF="ch10330"Managing Geometry Using RowColumnIDREF="ch13424"Mnemonics and AcceleratorsIDREF="ch0664"RowColumnLANGIDREF="ch11272"Message Catalogs and LocalizationIDREF="ch1167"Compound Strings in UILIDREF="ch1150"Compound Strings in UILIDREF="ch1148"Compound Strings in UILIDREF="ch11140"Font Lists in UILIDREF="ch11186"Establishing the Language EnvironmentIDREF="ch11235"Preparing Localized UID FilesIDREF="ch1165"Compound Strings in UILIDREF="ch11142"Font Lists in UILIDREF="ch1115"Locales and LocalizationIDREF="ch11201"Localization Without LocalesIDREF="ch11180"Establishing the Language EnvironmentIDREF="ch11172"Establishing the Language Environmentlanguage environmentIDREF="ch11171"Establishing the Language EnvironmentlibraryIDREF="ch01206"Header Files and Librarieslink operationIDREF="ch1543"Drag OperationsListIDREF="ch07119"Making a Selection: SelectionBoxIDREF="ch0735"Activation, Cancellation, and HelpIDREF="ch0279"ListIDREF="ch07167"CommandIDREF="ch07168"CommandIDREF="ch16354"Selection TypesIDREF="ch05179"ListIDREF="ch1553"Complexity of Drag and Drop ProgramsIDREF="ch083"TextIDREF="ch1288"Focus HighlightsIDREF="ch15439"Overriding Existing Drag SourcesIDREF="ch13455"Mnemonics and AcceleratorsIDREF="ch02110"ScrolledWindow and MainWindowIDREF="ch13457"Mnemonics and AcceleratorsIDREF="ch05182"ListIDREF="ch1568"Drag Sources and Drop SitesIDREF="ch07174"CommandIDREF="ch02149"BulletinBoard, Form, MessageBox, SelectionBoxIDREF="ch10388"Managing Geometry Using BulletinBoard and DrawingAreaIDREF="ch05184"ListIDREF="ch13212"Tab GroupsIDREF="ch05185"ListIDREF="ch04112"list DeclarationIDREF="ch05187"ListIDREF="ch13261"Controlling Tab Group Traversal OrderIDREF="ch10393"Managing Geometry Using BulletinBoard and DrawingAreaIDREF="ch01156"Primitives and GadgetsIDREF="ch13218"Tab GroupsIDREF="ch129"Color and PixmapsIDREF="ch05189"ListIDREF="ch15469"Source IconIDREF="ch05190"ListIDREF="ch13130"Tab GroupsIDREF="ch05159"ListIDREF="ch05162"ListIDREF="ch05171"ListIDREF="ch0834"SelectionIDREF="ch07110"Making a Selection: SelectionBoxIDREF="ch04124"list DeclarationIDREF="ch0421"Structure of a UIL ModuleIDREF="ch05196"ListIDREF="ch0185"Selections and Drag and DropIDREF="ch07149"Choosing a Pathname: FileSelectionBoxIDREF="ch13233"Tab GroupsIDREF="ch0513"Basic ControlsIDREF="ch05176"ListIDREF="ch05200"ListIDREF="ch05177"ListIDREF="ch07157"Choosing a Pathname: FileSelectionBoxIDREF="ch15421"Starting a Drag With XmDragStartlocaleIDREF="ch1113"Locales and LocalizationIDREF="ch16374"Text ConversionIDREF="ch11189"Using LocaleslocalizationIDREF="ch11170"Localizing ApplicationsIDREF="ch11210"Resources and LocalizationIDREF="ch112"Internationalization and LocalizationMainWindowIDREF="ch09244"MainWindowIDREF="ch09135"Example of Automatic ScrollingIDREF="ch02190"ApplicationsIDREF="ch09247"MainWindowIDREF="ch02103"ScrolledWindow and MainWindowIDREF="ch09249"MainWindowIDREF="ch09206"MainWindowIDREF="ch09225"MainWindowIDREF="ch01180"ManagersIDREF="ch02193"ApplicationsIDREF="ch13260"Controlling Tab Group Traversal OrderIDREF="ch09229"MainWindowIDREF="ch09211"MainWindowIDREF="ch09231"MainWindowIDREF="ch09180"Example of Application-Defined ScrollingIDREF="ch066"Menus and OptionsIDREF="ch09234"MainWindowIDREF="ch09195"Example of Application-Defined ScrollingIDREF="ch09128"Example of Automatic ScrollingIDREF="ch02122"RowColumnIDREF="ch09218"MainWindowIDREF="ch09239"MainWindowIDREF="ch09240"MainWindowIDREF="ch0480"ChildrenIDREF="ch02115"ScrolledWindow and MainWindowMAlt BTransferIDREF="ch0884"Mouse SelectionMAlt MShift BTransferIDREF="ch0885"Mouse SelectionmanagedIDREF="ch0476"Childrenmanaged widgetIDREF="ch03163"Managing WidgetsIDREF="ch04211"Making Widgets VisibleIDREF="ch03157"Making Widgets VisibleIDREF="ch0165"Widget GeometryManagerIDREF="ch0286"ManagersIDREF="ch10254"Manager Widgets and Their ChildrenIDREF="ch16214"Input FocusIDREF="ch10268"Manager Widgets and Their ChildrenIDREF="ch10270"Manager Widgets and Their ChildrenIDREF="ch1219"Default Colors and PixmapsIDREF="ch0287"ManagersIDREF="ch028"A User-Centered ModelIDREF="ch0532"XmGadgetIDREF="ch0533"XmGadgetIDREF="ch1225"Default Colors and PixmapsIDREF="ch0290"ManagersIDREF="ch0785"Initial FocusIDREF="ch13267"Initial FocusIDREF="ch05121"ScrollBarIDREF="ch01168"ManagersIDREF="ch055"Basic ControlsIDREF="ch14156"Handling Input EventsIDREF="ch1231"Default Colors and Pixmapsmapped widgetIDREF="ch03195"Mapping WidgetsIDREF="ch03161"Making Widgets VisiblemaximumClientSizeIDREF="ch1667"Window ConfigurationmaximumMaximumSizeIDREF="ch1669"Window Configurationmemory managementIDREF="ch03129"Resource Values and Memory ManagementmenuIDREF="ch16171"Menus and DialogsIDREF="ch061"Menus and OptionsMenuBarIDREF="ch065"Menus and OptionsIDREF="ch06125"MenuBarIDREF="ch07183"MessageBoxIDREF="ch0675"RowColumnIDREF="ch02191"ApplicationsIDREF="ch13420"Mnemonics and AcceleratorsIDREF="ch07100"Making a Selection: SelectionBoxIDREF="ch06111"MenuBarIDREF="ch06114"MenuBarIDREF="ch09210"MainWindowIDREF="ch13279"Initial FocusIDREF="ch09212"MainWindowIDREF="ch02158"BulletinBoard, Form, MessageBox, SelectionBoxIDREF="ch02118"ScrolledWindow and MainWindowIDREF="ch06117"MenuBarIDREF="ch08245"Storing Text in a FileIDREF="ch1342"Focus ModelsIDREF="ch02123"RowColumnIDREF="ch0616"Menus and OptionsIDREF="ch02130"RowColumnIDREF="ch13203"Tab GroupsIDREF="ch10395"Managing Geometry Using BulletinBoard and DrawingAreaIDREF="ch0381"Creating WidgetsIDREF="ch0486"ChildrenIDREF="ch01182"ManagersIDREF="ch06163"PulldownMenuMenuShellIDREF="ch06119"MenuBarIDREF="ch11111"Font List Resource DefaultsIDREF="ch02167"ShellsIDREF="ch13100"SensitivityIDREF="ch16176"Menus and DialogsIDREF="ch0697"MenuShellIDREF="ch0690"MenuShellIDREF="ch06107"MenuShellIDREF="ch1194"Font List Resource DefaultsIDREF="ch06158"PulldownMenuIDREF="ch1196"Font List Resource DefaultsIDREF="ch06108"MenuShellIDREF="ch06160"PulldownMenuIDREF="ch0684"MenuShellIDREF="ch06131"PopupMenuIDREF="ch0629"Menu Components: Buttons, RowColumn, MenuShellIDREF="ch10229"Shells and Their ChildrenIDREF="ch0693"MenuShellIDREF="ch02181"MenuShellIDREF="ch06167"PulldownMenuIDREF="ch11107"Font List Resource DefaultsIDREF="ch01199"ShellsmessageIDREF="ch16304"MWM Messagesmessage catalogIDREF="ch11265"Message Catalogs and LocalizationMessageBoxIDREF="ch12160"Using PixmapsIDREF="ch0262"ButtonsIDREF="ch07176"MessageBoxIDREF="ch07179"MessageBoxIDREF="ch07205"MessageBoxIDREF="ch02155"BulletinBoard, Form, MessageBox, SelectionBoxIDREF="ch07182"MessageBoxIDREF="ch124"Color and PixmapsIDREF="ch02156"BulletinBoard, Form, MessageBox, SelectionBoxIDREF="ch02143"BulletinBoard, Form, MessageBox, SelectionBoxIDREF="ch07187"MessageBoxIDREF="ch0791"Initial FocusIDREF="ch0556"ButtonsMessageDialogIDREF="ch07194"MessageBoxmethodIDREF="ch1486"Moving and Resizing ChildrenIDREF="ch10121"Intermediate Geometry RequestsIDREF="ch1488"Moving and Resizing ChildrenIDREF="ch1063"The geometry_manager ProcedureIDREF="ch10174"The resize ProcedureIDREF="ch10123"Intermediate Geometry RequestsIDREF="ch1492"Moving and Resizing ChildrenIDREF="ch16106"Window ConfigurationIDREF="ch1016"Widget Class ProceduresIDREF="ch10252"Shells and Their ChildrenIDREF="ch16111"Window ConfigurationIDREF="ch10178"Preferred Size and LocationIDREF="ch03110"Setting Resource ValuesIDREF="ch10180"Preferred Size and LocationIDREF="ch1499"Moving and Resizing ChildrenIDREF="ch14101"Resizing and RedisplayIDREF="ch14103"Resizing and RedisplayIDREF="ch1088"The geometry_manager ProcedureIDREF="ch14105"Resizing and RedisplayIDREF="ch03189"Realizing WidgetsIDREF="ch16123"Window ConfigurationIDREF="ch1091"The geometry_manager ProcedureIDREF="ch16125"Window ConfigurationIDREF="ch03177"Managing WidgetsIDREF="ch10131"XtSetValuesIDREF="ch10186"Preferred Size and LocationIDREF="ch1049"Geometry Change RequestsIDREF="ch1095"The geometry_manager ProcedureIDREF="ch14122"Handling Exposure EventsIDREF="ch10134"XtSetValuesIDREF="ch10191"Preferred Size and LocationIDREF="ch14129"Handling Exposure EventsIDREF="ch10136"XtSetValuesIDREF="ch14136"Handling Exposure EventsIDREF="ch10274"Manager Widgets and Their ChildrenIDREF="ch10194"Preferred Size and LocationIDREF="ch10276"Manager Widgets and Their ChildrenIDREF="ch1070"The geometry_manager ProcedureIDREF="ch10196"Preferred Size and LocationIDREF="ch1021"Widget Class ProceduresIDREF="ch1099"The geometry_manager ProcedureIDREF="ch10200"Exposure and RedisplayIDREF="ch1428"Event Handling and CallbacksIDREF="ch03191"Realizing WidgetsIDREF="ch10202"Exposure and RedisplayIDREF="ch10204"Exposure and RedisplayIDREF="ch10207"Exposure and RedisplayIDREF="ch1034"Widget Class ProceduresIDREF="ch1436"Event Handling and CallbacksIDREF="ch10142"XtSetValuesIDREF="ch13399"Using TranslationsIDREF="ch03168"Managing WidgetsIDREF="ch1443"Handling Resize EventsIDREF="ch13401"Using TranslationsIDREF="ch10103"The geometry_manager ProcedureIDREF="ch1447"Handling Resize EventsIDREF="ch10145"XtSetValuesIDREF="ch1449"Handling Resize EventsIDREF="ch10105"The geometry_manager ProcedureIDREF="ch1055"Geometry Change RequestsIDREF="ch1453"Handling Resize EventsIDREF="ch10217"Exposure and RedisplayIDREF="ch10149"XtSetValuesIDREF="ch1036"Widget Class ProceduresIDREF="ch10151"XtSetValuesIDREF="ch10109"Intermediate Geometry RequestsIDREF="ch1461"Moving and Resizing ChildrenIDREF="ch10153"The resize ProcedureIDREF="ch1077"The geometry_manager ProcedureIDREF="ch03173"Managing WidgetsIDREF="ch1080"The geometry_manager ProcedureIDREF="ch0756"DialogShellIDREF="ch10159"The resize ProcedureIDREF="ch10115"Intermediate Geometry RequestsIDREF="ch1026"Widget Class ProceduresIDREF="ch10162"The resize ProcedureIDREF="ch10117"Intermediate Geometry RequestsIDREF="ch10236"Shells and Their ChildrenIDREF="ch1474"Moving and Resizing ChildrenIDREF="ch10164"The resize ProcedureIDREF="ch10238"Shells and Their ChildrenIDREF="ch1040"Widget Class ProceduresIDREF="ch10166"The resize ProcedureIDREF="ch10168"The resize ProcedureIDREF="ch0395"Widget InitializationIDREF="ch1482"Moving and Resizing ChildrenIDREF="ch10171"The resize ProceduremnemonicIDREF="ch1325"Input, Focus, and Keyboard NavigationIDREF="ch1327"Input, Focus, and Keyboard NavigationIDREF="ch13418"Mnemonics and AcceleratorsIDREF="ch02225"Handling Input and OutputIDREF="ch02223"Handling Input and Outputmodal dialogIDREF="ch02206"DialogsIDREF="ch074"DialogsIDREF="ch16291"Input Modemodeless dialogIDREF="ch02207"DialogsIDREF="ch075"DialogsmoduleIDREF="ch049"Structure of a UIL ModuleIDREF="ch048"Structure of a UIL ModuleMotifIDREF="ch0170"MotifMotif Resource Manager (MRM)IDREF="ch0222"Separating Interface from ApplicationIDREF="ch04137"Initializing MRMIDREF="ch045"Structure of a Program Using UIL and MRMIDREF="ch01102"UIL and MRMIDREF="ch11252"MRM and Localized UID FilesMotif Window Manager (MWM)IDREF="ch1640"Window ConfigurationIDREF="ch16271"MWM Properties and ResourcesIDREF="ch16190"Menus and DialogsIDREF="ch0198"Motif Window ManagerIDREF="ch16234"ColormapsIDREF="ch16264"Application Shutdown and RestartIDREF="ch16221"Input FocusIDREF="ch16155"IconsIDREF="ch1350"Focus Models.motifbindIDREF="ch13414"Bindings for osf KeysymsMotionNotifyIDREF="ch14172"Handling Input EventsIDREF="ch14161"Handling Input EventsIDREF="ch14182"Example of an Input Proceduremouse selectionIDREF="ch0877"Mouse Selectionmove operationIDREF="ch1539"Drag OperationsMRMIDREF="ch046"Structure of a Program Using UIL and MRMIDREF="ch0223"Separating Interface from ApplicationIDREF="ch04138"Initializing MRMIDREF="ch11253"MRM and Localized UID FilesIDREF="ch01103"UIL and MRMMrmCloseHierarchyIDREF="ch04154"Opening UID FilesMrmFetchColorLiteralIDREF="ch04172"Fetching Information from UID FilesMrmFetchIconLiteralIDREF="ch04177"Fetching Information from UID FilesMrmFetchLiteralIDREF="ch04180"Fetching Information from UID FilesMrmFetchSetValuesIDREF="ch04181"Fetching Information from UID FilesMrmFetchWidgetIDREF="ch04200"Fetching Information from UID FilesIDREF="ch04188"Fetching Information from UID FilesIDREF="ch04216"Making Widgets VisibleIDREF="ch04217"Making Widgets VisibleIDREF="ch04202"Fetching Information from UID FilesIDREF="ch04210"Defining Callback ProceduresIDREF="ch04164"Fetching Information from UID FilesMrmFetchWidgetOverrideIDREF="ch04165"Fetching Information from UID FilesIDREF="ch04201"Fetching Information from UID FilesMrmInitializeIDREF="ch04141"Initializing MRMMrmNcreateCallbackIDREF="ch04197"Fetching Information from UID FilesIDREF="ch0499"Callback ProceduresMrmOpenHierarchyPerDisplayIDREF="ch11262"MRM and Localized UID FilesIDREF="ch11254"MRM and Localized UID FilesIDREF="ch11264"MRM and Localized UID FilesIDREF="ch04145"Opening UID FilesIDREF="ch04152"Opening UID FilesIDREF="ch04153"Opening UID FilesIDREF="ch04155"Opening UID FilesIDREF="ch11259"MRM and Localized UID FilesIDREF="ch04149"Opening UID FilesIDREF="ch04147"Opening UID FilesMrmRegisterNamesIDREF="ch0447"identifier DeclarationIDREF="ch04106"Callback ProceduresIDREF="ch0451"procedure DeclarationIDREF="ch04159"Registering Callbacks and IdentifiersMrmRegisterNamesInHierarchyIDREF="ch04158"Registering Callbacks and IdentifiersIDREF="ch04107"Callback ProceduresIDREF="ch04208"Defining Callback ProceduresIDREF="ch0448"identifier DeclarationIDREF="ch0452"procedure DeclarationMShift BTransferIDREF="ch0883"Mouse SelectionmultipleIDREF="ch03200"Multiple Screens, Displays, and ApplicationsIDREF="ch03202"Multiple Screens, Displays, and ApplicationsIDREF="ch16358"TargetsIDREF="ch03204"Multiple Screens, Displays, and ApplicationsMWMIDREF="ch1641"Window ConfigurationIDREF="ch13412"Bindings for osf KeysymsIDREF="ch16156"IconsIDREF="ch16272"MWM Properties and ResourcesIDREF="ch16235"ColormapsIDREF="ch16191"Menus and DialogsIDREF="ch0199"Motif Window ManagerIDREF="ch16222"Input FocusIDREF="ch1351"Focus ModelsIDREF="ch16265"Application Shutdown and RestartnameIDREF="ch0139"XlibnamesIDREF="ch0429"Module-Level DeclarationsIDREF="ch0427"Module-Level Declarationsnested drop sitesIDREF="ch15393"Simulating Nested Drop SitesNLSPATHIDREF="ch11271"Message Catalogs and LocalizationIDREF="ch11275"Message Catalogs and Localizationno drop siteIDREF="ch1533"Drag Statesnonincremental transferIDREF="ch15295"Drop Protocolnormal modeIDREF="ch0893"Keyboard SelectionIDREF="ch0871"SelectionNorthWestGravityIDREF="ch14113"Resizing and RedisplayIDREF="ch16101"Window ConfigurationobjectIDREF="ch04195"Fetching Information from UID FilesIDREF="ch04110"list DeclarationIDREF="ch0457"object DeclarationIDREF="ch04122"list DeclarationIDREF="ch0463"Object TypeIDREF="ch04162"Fetching Information from UID FilesIDREF="ch0419"Structure of a UIL ModuleIDREF="ch04191"Fetching Information from UID FilesIDREF="ch0474"ChildrenIDREF="ch0468"Object Typeobject typeIDREF="ch0459"Object TypeobjectsIDREF="ch0465"Object TypeIDREF="ch0433"Module-Level Declarationsoff-the-spot input methodIDREF="ch11297"Input MethodoperationIDREF="ch1542"Drag OperationsIDREF="ch15158"OperationsIDREF="ch1544"Drag OperationsIDREF="ch1538"Drag OperationsIDREF="ch1540"Drag Operationsoperation iconIDREF="ch15484"Operation IconIDREF="ch1521"Overview of Drag-Over EffectsOptionButtonIDREF="ch06200"OptionMenuOptionLabelIDREF="ch06201"OptionMenuOptionMenuIDREF="ch0618"Menus and OptionsIDREF="ch13280"Initial FocusIDREF="ch0483"ChildrenIDREF="ch06203"OptionMenuIDREF="ch02133"RowColumnIDREF="ch06206"OptionMenuIDREF="ch06169"PulldownMenuIDREF="ch06194"OptionMenuIDREF="ch06180"OptionMenuIDREF="ch13208"Tab GroupsIDREF="ch06212"OptionMenuIDREF="ch0676"RowColumnIDREF="ch06171"OptionMenuIDREF="ch0485"Childrenosf keysymIDREF="ch13409"Bindings for osf KeysymsOSF/MotifIDREF="ch0171"MotifoutputIDREF="ch02213"Handling Input and Outputover-the-spot input methodIDREF="ch11295"Input Methodoverlapping drop sitesIDREF="ch15342"Overlapping Drop SitesOverrideShellIDREF="ch01121"Xt ClassesIDREF="ch10233"Shells and Their ChildrenIDREF="ch0691"MenuShellIDREF="ch16175"Menus and DialogsIDREF="ch02186"MenuShellIDREF="ch01201"ShellspaneIDREF="ch0299"PanedWindowPanedWindowIDREF="ch08249"Sharing Text SourcesIDREF="ch09319"PanedWindowIDREF="ch09303"PanedWindowIDREF="ch09293"PanedWindowIDREF="ch105"Managing GeometryIDREF="ch09305"PanedWindowIDREF="ch13225"Tab GroupsIDREF="ch01176"ManagersIDREF="ch09307"PanedWindowIDREF="ch09295"PanedWindowIDREF="ch09288"PanedWindowIDREF="ch09297"PanedWindowIDREF="ch09311"PanedWindowIDREF="ch10280"Manager Widgets and Their ChildrenIDREF="ch09289"PanedWindowIDREF="ch09290"PanedWindowIDREF="ch09314"PanedWindowIDREF="ch09300"PanedWindowIDREF="ch09316"PanedWindowIDREF="ch0297"PanedWindowpending deleteIDREF="ch0847"SelectionPixelIDREF="ch03121"Resource Value Data TypesIDREF="ch0114"The X Window SystempixmapIDREF="ch0112"The X Window SystemIDREF="ch12158"Using PixmapsIDREF="ch11276"Images, Pixmaps, and LocalizationIDREF="ch122"Color and PixmapsplaneIDREF="ch0115"The X Window SystempopupIDREF="ch03212"Multiple Screens, Displays, and ApplicationsIDREF="ch02202"Top-Level WidgetsPopupMenuIDREF="ch06142"PopupMenuIDREF="ch02132"RowColumnIDREF="ch0694"MenuShellIDREF="ch06145"PopupMenuIDREF="ch06146"PopupMenuIDREF="ch04209"Defining Callback ProceduresIDREF="ch13464"Event HandlersIDREF="ch03180"Managing WidgetsIDREF="ch06149"PopupMenuIDREF="ch0561"CascadeButtonsIDREF="ch06258"TearOffMenusIDREF="ch0487"ChildrenIDREF="ch0681"RowColumnIDREF="ch13421"Mnemonics and AcceleratorsIDREF="ch069"Menus and OptionsIDREF="ch02126"RowColumnIDREF="ch06126"PopupMenuIDREF="ch06132"PopupMenuIDREF="ch0551"LabelsIDREF="ch13429"Mnemonics and AcceleratorsIDREF="ch06165"PulldownMenuIDREF="ch072"DialogsIDREF="ch13281"Initial FocusIDREF="ch13206"Tab GroupsIDREF="ch06135"PopupMenuIDREF="ch10338"Managing Geometry Using RowColumnIDREF="ch06104"MenuShellIDREF="ch10234"Shells and Their ChildrenIDREF="ch0687"MenuShellIDREF="ch06138"PopupMenuIDREF="ch0617"Menus and OptionsIDREF="ch02183"MenuShellIDREF="ch06141"PopupMenuPositionIDREF="ch03120"Resource Value Data TypesIDREF="ch0399"Arguments that Specify Resource ValuespositionIsFrameIDREF="ch1642"Window ConfigurationpositionOnScreenIDREF="ch1652"Window Configurationpre-edit areaIDREF="ch11293"Input Methodpreregister protocolIDREF="ch15243"The Preregister Drag ProtocolIDREF="ch15238"Drag ProtocolsIDREF="ch1578"Drag Protocolsprimary selectionIDREF="ch0851"SelectionIDREF="ch16346"Selection TypesIDREF="ch0837"SelectionPrimitiveIDREF="ch01138"Primitives and GadgetsIDREF="ch0156"WidgetsIDREF="ch1220"Default Colors and PixmapsIDREF="ch01136"Primitives and GadgetsIDREF="ch1045"Geometry Change RequestsIDREF="ch0518"Core, RectObj, XmPrimitive, and XmGadget ClassesIDREF="ch1226"Default Colors and PixmapsIDREF="ch026"A User-Centered ModelIDREF="ch052"Basic ControlsIDREF="ch16215"Input FocusIDREF="ch0240"Building Blocks: Primitive Widgets and GadgetsIDREF="ch0525"XmPrimitiveIDREF="ch1232"Default Colors and PixmapsIDREF="ch0530"XmGadgetIDREF="ch0224"Building Blocks: Primitive Widgets and GadgetsIDREF="ch08175"Text Resources and GeometryIDREF="ch0245"Building Blocks: Primitive Widgets and GadgetsIDREF="ch0538"Labels, Buttons, and SeparatorsIDREF="ch0228"Building Blocks: Primitive Widgets and GadgetsIDREF="ch01131"Primitives and GadgetsIDREF="ch10263"Manager Widgets and Their ChildrenIDREF="ch0231"Building Blocks: Primitive Widgets and GadgetsprocedureIDREF="ch0453"procedure DeclarationIDREF="ch04100"Callback ProceduresIDREF="ch04104"Callback ProceduresIDREF="ch0417"Structure of a UIL ModuleproceduresIDREF="ch04102"Callback ProceduresIDREF="ch04118"list DeclarationPromptDialogIDREF="ch07135"Making a Selection: SelectionBoxIDREF="ch07126"Making a Selection: SelectionBoxpropertyIDREF="ch0123"The X Window SystemprotocolIDREF="ch1582"Drop ProtocolIDREF="ch16314"Atom and Protocol ManagementIDREF="ch15285"Drop ProtocolIDREF="ch15244"The Preregister Drag ProtocolIDREF="ch15288"Drop ProtocolIDREF="ch1574"ProtocolsIDREF="ch15250"The Dynamic Drag ProtocolIDREF="ch1577"Drag ProtocolsIDREF="ch1579"Drag ProtocolsIDREF="ch1581"Drag ProtocolsIDREF="ch15235"Drag and Drop ProtocolsIDREF="ch15236"Drag ProtocolsIDREF="ch15240"Drag ProtocolsIDREF="ch15241"Drag ProtocolsPulldownMenuIDREF="ch0266"ButtonsIDREF="ch06159"PulldownMenuIDREF="ch06161"PulldownMenuIDREF="ch02125"RowColumnIDREF="ch06164"PulldownMenuIDREF="ch13282"Initial FocusIDREF="ch06166"PulldownMenuIDREF="ch0552"LabelsIDREF="ch06170"PulldownMenuIDREF="ch06174"OptionMenuIDREF="ch06175"OptionMenuIDREF="ch02128"RowColumnIDREF="ch06105"MenuShellIDREF="ch068"Menus and OptionsIDREF="ch0645"ButtonsIDREF="ch0613"Menus and OptionsIDREF="ch06184"OptionMenuIDREF="ch0614"Menus and OptionsIDREF="ch0619"Menus and OptionsIDREF="ch06118"MenuBarIDREF="ch06190"OptionMenuIDREF="ch02131"RowColumnIDREF="ch0560"CascadeButtonsIDREF="ch0563"CascadeButtonsIDREF="ch02185"MenuShellIDREF="ch0565"CascadeButtonsIDREF="ch0682"RowColumnIDREF="ch10339"Managing Geometry Using RowColumnIDREF="ch06204"OptionMenuIDREF="ch13422"Mnemonics and AcceleratorsIDREF="ch02192"ApplicationsIDREF="ch10231"Shells and Their ChildrenIDREF="ch0686"MenuShellIDREF="ch06211"OptionMenuIDREF="ch13430"Mnemonics and AcceleratorsIDREF="ch0688"MenuShellIDREF="ch0484"ChildrenIDREF="ch13207"Tab GroupsIDREF="ch0568"CascadeButtonsIDREF="ch0695"MenuShellIDREF="ch0569"CascadeButtonsIDREF="ch02135"RowColumnIDREF="ch0384"Creating WidgetsIDREF="ch06151"PulldownMenuIDREF="ch073"DialogsIDREF="ch06155"PulldownMenuPushButtonIDREF="ch01150"Primitives and GadgetsIDREF="ch0549"LabelsIDREF="ch0267"ButtonsIDREF="ch07184"MessageBoxIDREF="ch1235"Default Colors and PixmapsIDREF="ch0276"ButtonsIDREF="ch1295"Arming and SelectionIDREF="ch03140"Adding Callback ProceduresIDREF="ch1132"Compound Strings and ResourcesIDREF="ch07101"Making a Selection: SelectionBoxIDREF="ch0647"ButtonsIDREF="ch13427"Mnemonics and AcceleratorsIDREF="ch03141"Adding Callback ProceduresIDREF="ch10400"Managing Geometry Using BulletinBoard and DrawingAreaIDREF="ch0633"ButtonsIDREF="ch13436"Mnemonics and AcceleratorsIDREF="ch0216"A User-Centered ModelIDREF="ch1139"Setting a Compound String ProgrammaticallyIDREF="ch03127"Resource Value Data TypesIDREF="ch1142"Setting a Compound String in a Defaults FileIDREF="ch0573"PushButtonsIDREF="ch14184"Example of an Input ProcedureIDREF="ch0639"ButtonsIDREF="ch0657"RowColumnIDREF="ch06176"OptionMenuPushButtonGadgetIDREF="ch1296"Arming and SelectionIDREF="ch1236"Default Colors and PixmapsIDREF="ch1292"Arming and SelectionIDREF="ch0268"ButtonsIDREF="ch0467"Object Typequalified resource nameIDREF="ch0145"Xlibquery_geometry methodIDREF="ch10177"Preferred Size and LocationIDREF="ch10179"Preferred Size and LocationIDREF="ch1039"Widget Class ProceduresIDREF="ch10185"Preferred Size and LocationQuestionDialogIDREF="ch07196"MessageBoxquitTimeoutIDREF="ch16270"Application Shutdown and RestartRadioBoxIDREF="ch0274"ButtonsIDREF="ch0625"Menus and OptionsIDREF="ch06214"RadioBox and CheckBoxIDREF="ch06217"RadioBox and CheckBoxIDREF="ch0555"ButtonsIDREF="ch0261"ButtonsIDREF="ch0587"ToggleButtonsIDREF="ch144"Graphics and Text in a DrawingAreaIDREF="ch06222"RadioBox and CheckBoxIDREF="ch02139"RowColumnIDREF="ch06233"RadioBox and CheckBoxIDREF="ch06244"RadioBox and CheckBoxIDREF="ch06245"RadioBox and CheckBoxraiseKeyFocusIDREF="ch16228"Input FocusrbgIDREF="ch04168"Fetching Information from UID Filesrealize methodIDREF="ch03190"Realizing Widgetsrealized widgetIDREF="ch03185"Realizing WidgetsIDREF="ch03159"Making Widgets VisiblereasonIDREF="ch16327"Atom and Protocol ManagementIDREF="ch13368"Focus CallbacksreceiverIDREF="ch15592"Drop Receiver Responsibilities for DroppingIDREF="ch1559"A Simple Drag ReceiverIDREF="ch1510"Overview of User InteractionIDREF="ch15303"Drop Receiver Responsibilities for DraggingRectObjIDREF="ch01113"Xt ClassesIDREF="ch107"Managing GeometryIDREF="ch0523"RectObjIDREF="ch01164"Primitives and GadgetsIDREF="ch0239"Building Blocks: Primitive Widgets and GadgetsIDREF="ch0519"Core, RectObj, XmPrimitive, and XmGadget ClassesreplyIDREF="ch0125"The X Window SystemrequestIDREF="ch0124"The X Window Systemresize methodIDREF="ch10133"XtSetValuesIDREF="ch10173"The resize ProcedureIDREF="ch1435"Event Handling and CallbacksIDREF="ch10148"XtSetValuesIDREF="ch10237"Shells and Their ChildrenIDREF="ch1473"Moving and Resizing ChildrenIDREF="ch1069"The geometry_manager ProcedureIDREF="ch10152"The resize ProcedureIDREF="ch1446"Handling Resize EventsIDREF="ch1448"Handling Resize EventsIDREF="ch10102"The geometry_manager ProcedureIDREF="ch1481"Moving and Resizing ChildrenIDREF="ch1452"Handling Resize EventsIDREF="ch1487"Moving and Resizing ChildrenIDREF="ch1087"The geometry_manager ProcedureIDREF="ch10116"Intermediate Geometry RequestsIDREF="ch1491"Moving and Resizing ChildrenIDREF="ch1035"Widget Class ProceduresIDREF="ch1076"The geometry_manager ProcedureIDREF="ch1460"Moving and Resizing ChildrenIDREF="ch10161"The resize ProcedureIDREF="ch1498"Moving and Resizing ChildrenIDREF="ch16124"Window ConfigurationIDREF="ch14104"Resizing and RedisplayIDREF="ch10195"Preferred Size and LocationIDREF="ch10163"The resize ProcedureIDREF="ch10165"The resize ProcedureIDREF="ch10122"Intermediate Geometry RequestsresourceIDREF="ch0328"The Initial Resource DatabaseIDREF="ch03112"Retrieving Resource ValuesIDREF="ch0144"XlibIDREF="ch0138"XlibIDREF="ch03116"Resource Value Data TypesIDREF="ch0367"Application Class Resource FileIDREF="ch1130"Compound Strings and ResourcesIDREF="ch023"A User-Centered ModelIDREF="ch0140"XlibIDREF="ch0351"Screen-Specific ResourcesIDREF="ch0391"Specifying Resource ValuesIDREF="ch03128"Resource Values and Memory ManagementIDREF="ch11209"Resources and LocalizationIDREF="ch0489"Resource ValuesIDREF="ch11212"Initial Resource DatabaseIDREF="ch0321"The Initial Resource DatabaseIDREF="ch0396"Arguments that Specify Resource ValuesIDREF="ch0322"The Initial Resource DatabaseIDREF="ch0338"File Search PathsIDREF="ch0142"XlibIDREF="ch0340"Initial Database ComponentsIDREF="ch0359"User Application FileIDREF="ch0137"XlibIDREF="ch1187"Font Lists and ResourcesIDREF="ch02209"Resources: User and Program CustomizationIDREF="ch1190"Font List Resource Defaultsresource managerIDREF="ch0136"XlibreverseVideoIDREF="ch1254"BordersIDREF="ch1252"Bordersroot windowIDREF="ch019"The X Window Systemroot-window input methodIDREF="ch11299"Input Methodroot_geometry_manager methodIDREF="ch16105"Window ConfigurationIDREF="ch16110"Window ConfigurationIDREF="ch16122"Window ConfigurationRowColumnIDREF="ch13204"Tab GroupsIDREF="ch10314"Managing Geometry Using RowColumnIDREF="ch06121"MenuBarIDREF="ch10316"Managing Geometry Using RowColumnIDREF="ch06195"OptionMenuIDREF="ch10318"Managing Geometry Using RowColumnIDREF="ch01184"ManagersIDREF="ch10320"Managing Geometry Using RowColumnIDREF="ch0689"MenuShellIDREF="ch10322"Managing Geometry Using RowColumnIDREF="ch0637"ButtonsIDREF="ch06133"PopupMenuIDREF="ch0696"MenuShellIDREF="ch06207"OptionMenuIDREF="ch10327"Managing Geometry Using RowColumnIDREF="ch10282"Manager Widgets and Their ChildrenIDREF="ch10283"Managing Geometry Using RowColumnIDREF="ch10285"Managing Geometry Using RowColumnIDREF="ch10333"Managing Geometry Using RowColumnIDREF="ch0653"RowColumnIDREF="ch06139"PopupMenuIDREF="ch10288"Managing Geometry Using RowColumnIDREF="ch02136"RowColumnIDREF="ch06220"RadioBox and CheckBoxIDREF="ch06143"PopupMenuIDREF="ch06263"TearOffMenusIDREF="ch10345"Managing Geometry Using RowColumnIDREF="ch06224"RadioBox and CheckBoxIDREF="ch10232"Shells and Their ChildrenIDREF="ch0271"ButtonsIDREF="ch10296"Managing Geometry Using RowColumnIDREF="ch0621"Menus and OptionsIDREF="ch10351"Managing Geometry Using RowColumnIDREF="ch13467"Event HandlersIDREF="ch02119"RowColumnIDREF="ch0383"Creating WidgetsIDREF="ch06106"MenuShellIDREF="ch145"Graphics and Text in a DrawingAreaIDREF="ch10301"Managing Geometry Using RowColumnIDREF="ch06230"RadioBox and CheckBoxIDREF="ch06162"PulldownMenuIDREF="ch13118"XmNtraversalOnIDREF="ch06168"PulldownMenuIDREF="ch0677"RowColumnIDREF="ch06235"RadioBox and CheckBoxIDREF="ch06179"OptionMenuIDREF="ch0626"Menus and OptionsIDREF="ch06115"MenuBarIDREF="ch06239"RadioBox and CheckBoxIDREF="ch0584"ToggleButtonsIDREF="ch10312"Managing Geometry Using RowColumnIDREF="ch13200"Tab GroupsIDREF="ch0630"Menu Components: Buttons, RowColumn, MenuShellIDREF="ch10370"Managing Geometry Using RowColumnsashIDREF="ch02101"PanedWindowScaleIDREF="ch058"Basic ControlsIDREF="ch01174"ManagersIDREF="ch05151"ScaleIDREF="ch05143"ScaleIDREF="ch05145"ScaleIDREF="ch05154"ScaleIDREF="ch0219"A User-Centered ModelIDREF="ch05157"ScaleIDREF="ch09133"Example of Automatic ScrollingIDREF="ch05158"ScaleIDREF="ch0512"Basic ControlsIDREF="ch09139"Example of Automatic ScrollingIDREF="ch0294"ScalescreenIDREF="ch0350"Screen-Specific ResourcesIDREF="ch03201"Multiple Screens, Displays, and ApplicationsIDREF="ch017"The X Window SystemSCREEN_RESOURCESIDREF="ch0353"Screen-Specific ResourcesScrollBarIDREF="ch0511"Basic ControlsIDREF="ch09156"Application-Defined ScrollingIDREF="ch05192"ListIDREF="ch0959"Other ResourcesIDREF="ch1243"Default Colors and PixmapsIDREF="ch09160"Application-Defined ScrollingIDREF="ch093"ScrolledWindowIDREF="ch1564"A Simple Drag SourceIDREF="ch1565"A Simple Drag SourceIDREF="ch0963"Automatic ScrollingIDREF="ch0932"Other ResourcesIDREF="ch0278"ScrollBarIDREF="ch05194"ListIDREF="ch13213"Tab GroupsIDREF="ch099"Automatic and Application-Defined ScrollingIDREF="ch09167"Application-Defined ScrollingIDREF="ch143"Graphics and Text in a DrawingAreaIDREF="ch02117"ScrolledWindow and MainWindowIDREF="ch09105"Automatic ScrollingIDREF="ch0911"Automatic and Application-Defined ScrollingIDREF="ch0938"Other ResourcesIDREF="ch09172"Application-Defined ScrollingIDREF="ch13222"Tab GroupsIDREF="ch09108"Automatic ScrollingIDREF="ch02109"ScrolledWindow and MainWindowIDREF="ch09175"Application-Defined ScrollingIDREF="ch05118"ScrollBarIDREF="ch09182"Example of Application-Defined ScrollingIDREF="ch0973"Automatic ScrollingIDREF="ch09112"Automatic ScrollingIDREF="ch05119"ScrollBarIDREF="ch0942"Other ResourcesIDREF="ch14198"Using a DrawingArea in a ScrolledWindowIDREF="ch09187"Example of Application-Defined ScrollingIDREF="ch0976"Automatic ScrollingIDREF="ch05120"ScrollBarIDREF="ch01154"Primitives and GadgetsIDREF="ch05123"ScrollBarIDREF="ch0980"Automatic ScrollingIDREF="ch14207"Using a DrawingArea in a ScrolledWindowIDREF="ch0919"Other ResourcesIDREF="ch09197"Example of Application-Defined ScrollingIDREF="ch05136"ScrollBarIDREF="ch0277"ScrollBarIDREF="ch09201"Example of Application-Defined ScrollingIDREF="ch0949"Other ResourcesIDREF="ch126"Color and PixmapsIDREF="ch05138"ScrollBarIDREF="ch05139"ScrollBarIDREF="ch09208"MainWindowIDREF="ch09214"MainWindowIDREF="ch15418"Recognizing a Drag Has StartedIDREF="ch08191"Text Resources and GeometryIDREF="ch0988"Automatic ScrollingIDREF="ch0296"ScaleIDREF="ch0990"Automatic ScrollingIDREF="ch09145"Application-Defined ScrollingIDREF="ch02107"ScrolledWindow and MainWindowIDREF="ch09147"Application-Defined ScrollingIDREF="ch0927"Other ResourcesIDREF="ch12112"Arming and SelectionIDREF="ch0993"Automatic ScrollingIDREF="ch09226"MainWindowIDREF="ch09150"Application-Defined ScrollingIDREF="ch05146"ScaleIDREF="ch09154"Application-Defined ScrollingIDREF="ch13110"XmNtraversalOnScrolledListIDREF="ch09148"Application-Defined ScrollingIDREF="ch05195"ListIDREF="ch05197"ListIDREF="ch02112"ScrolledWindow and MainWindowIDREF="ch0386"Creating WidgetsIDREF="ch07148"Choosing a Pathname: FileSelectionBoxIDREF="ch05193"ListScrolledTextIDREF="ch08232"ScrolledTextIDREF="ch0462"Object TypeIDREF="ch02113"ScrolledWindow and MainWindowIDREF="ch09149"Application-Defined ScrollingScrolledWindowIDREF="ch0967"Automatic ScrollingIDREF="ch09116"Traversing to Obscured WidgetsIDREF="ch0933"Other ResourcesIDREF="ch09215"MainWindowIDREF="ch02108"ScrolledWindow and MainWindowIDREF="ch0910"Automatic and Application-Defined ScrollingIDREF="ch0971"Automatic ScrollingIDREF="ch0912"Automatic and Application-Defined ScrollingIDREF="ch09122"Traversing to Obscured WidgetsIDREF="ch09123"Traversing to Obscured WidgetsIDREF="ch0937"Other ResourcesIDREF="ch13112"XmNtraversalOnIDREF="ch09224"MainWindowIDREF="ch0939"Other ResourcesIDREF="ch0977"Automatic ScrollingIDREF="ch09134"Example of Automatic ScrollingIDREF="ch09137"Example of Automatic ScrollingIDREF="ch01183"ManagersIDREF="ch09236"MainWindowIDREF="ch0941"Other ResourcesIDREF="ch09144"Application-Defined ScrollingIDREF="ch09146"Application-Defined ScrollingIDREF="ch0981"Automatic ScrollingIDREF="ch13286"Traversing to Obscured WidgetsIDREF="ch13287"Traversing to Obscured WidgetsIDREF="ch13288"Traversing to Obscured WidgetsIDREF="ch13289"Traversing to Obscured WidgetsIDREF="ch09155"Application-Defined ScrollingIDREF="ch13291"Traversing to Obscured WidgetsIDREF="ch02114"ScrolledWindow and MainWindowIDREF="ch1366"Controlling Keyboard NavigationIDREF="ch09248"MainWindowIDREF="ch09250"MainWindowIDREF="ch05198"ListIDREF="ch07158"Choosing a Pathname: FileSelectionBoxIDREF="ch0918"Other ResourcesIDREF="ch02116"ScrolledWindow and MainWindowIDREF="ch0987"Automatic ScrollingIDREF="ch0948"Other ResourcesIDREF="ch01178"ManagersIDREF="ch0992"Automatic ScrollingIDREF="ch0994"Automatic ScrollingIDREF="ch02102"ScrolledWindow and MainWindowIDREF="ch14187"Using a DrawingArea in a ScrolledWindowIDREF="ch1380"Controlling Keyboard NavigationIDREF="ch0923"Other ResourcesIDREF="ch05122"ScrollBarIDREF="ch0998"Automatic ScrollingIDREF="ch08188"Text Resources and GeometryIDREF="ch0955"Other ResourcesIDREF="ch02105"ScrolledWindow and MainWindowIDREF="ch0957"Other ResourcesIDREF="ch0928"Other ResourcesIDREF="ch091"ScrolledWindowIDREF="ch0964"Automatic ScrollingIDREF="ch14205"Using a DrawingArea in a ScrolledWindowIDREF="ch092"ScrolledWindowIDREF="ch09109"Automatic ScrollingIDREF="ch02106"ScrolledWindow and MainWindowIDREF="ch14210"Using a DrawingArea in a ScrolledWindowIDREF="ch09194"Example of Application-Defined ScrollingIDREF="ch09198"Example of Application-Defined ScrollingIDREF="ch09111"Automatic ScrollingscrollingIDREF="ch09142"Application-Defined ScrollingIDREF="ch09177"Example of Application-Defined ScrollingIDREF="ch0961"Automatic ScrollingIDREF="ch09126"Example of Automatic ScrollingIDREF="ch097"Automatic and Application-Defined ScrollingIDREF="ch095"Automatic and Application-Defined Scrollingsearch pathIDREF="ch0331"File Search Pathssecondary selectionIDREF="ch0839"SelectionIDREF="ch0853"SelectionIDREF="ch16348"Selection TypesselectionIDREF="ch16369"Text ConversionIDREF="ch16345"SelectionsIDREF="ch16347"Selection TypesIDREF="ch16349"Selection TypesIDREF="ch16351"Selection TypesIDREF="ch0848"SelectionIDREF="ch0830"SelectionIDREF="ch0878"Mouse SelectionIDREF="ch0176"Selections and Drag and DropIDREF="ch0891"Keyboard SelectionIDREF="ch1290"Arming and SelectionIDREF="ch0852"SelectionIDREF="ch0854"SelectionIDREF="ch16406"Incremental TransfersIDREF="ch0838"SelectionIDREF="ch16433"The Motif ClipboardIDREF="ch0840"SelectionIDREF="ch0858"SelectionIDREF="ch16412"The Xt Selection InterfaceIDREF="ch0842"SelectionSelectionBoxIDREF="ch02153"BulletinBoard, Form, MessageBox, SelectionBoxIDREF="ch13231"Tab GroupsIDREF="ch0557"ButtonsIDREF="ch07141"Making a Selection: SelectionBoxIDREF="ch02144"BulletinBoard, Form, MessageBox, SelectionBoxIDREF="ch0793"Initial FocusIDREF="ch0794"Making a Selection: SelectionBoxIDREF="ch0797"Making a Selection: SelectionBoxIDREF="ch07122"Making a Selection: SelectionBoxIDREF="ch0798"Making a Selection: SelectionBoxIDREF="ch0263"ButtonsIDREF="ch13446"Mnemonics and AcceleratorsIDREF="ch07156"Choosing a Pathname: FileSelectionBoxIDREF="ch07160"Choosing a Pathname: FileSelectionBoxIDREF="ch13456"Mnemonics and AcceleratorsIDREF="ch10389"Managing Geometry Using BulletinBoard and DrawingAreaIDREF="ch02148"BulletinBoard, Form, MessageBox, SelectionBoxIDREF="ch10391"Managing Geometry Using BulletinBoard and DrawingAreaIDREF="ch07103"Making a Selection: SelectionBoxIDREF="ch07129"Making a Selection: SelectionBoxIDREF="ch07173"CommandIDREF="ch07130"Making a Selection: SelectionBoxIDREF="ch02151"BulletinBoard, Form, MessageBox, SelectionBoxIDREF="ch07133"Making a Selection: SelectionBoxIDREF="ch07111"Making a Selection: SelectionBoxIDREF="ch07112"Making a Selection: SelectionBoxSelectionDialogIDREF="ch07123"Making a Selection: SelectionBoxselectionTimeoutIDREF="ch16425"The Xt Selection InterfacesensitivityIDREF="ch1362"Controlling Keyboard NavigationIDREF="ch1382"SensitivitySeparatorIDREF="ch05114"SeparatorsIDREF="ch01140"Primitives and GadgetsIDREF="ch0251"Label and SeparatorIDREF="ch0257"Label and SeparatorIDREF="ch0536"Labels, Buttons, and SeparatorsIDREF="ch13107"XmNtraversalOnIDREF="ch0658"RowColumnIDREF="ch02100"PanedWindowSeparatorGadgetIDREF="ch0258"Label and SeparatorIDREF="ch09220"MainWindowIDREF="ch07181"MessageBoxIDREF="ch05156"ScaleIDREF="ch13108"XmNtraversalOnsession managerIDREF="ch16242"Application Shutdown and Restartset_values methodIDREF="ch10275"Manager Widgets and Their ChildrenIDREF="ch03109"Setting Resource ValuesIDREF="ch10130"XtSetValuesIDREF="ch13400"Using TranslationsIDREF="ch1025"Widget Class ProceduresIDREF="ch10144"XtSetValuesIDREF="ch10201"Exposure and Redisplayset_values_almost methodIDREF="ch10150"XtSetValuesIDREF="ch1033"Widget Class ProceduresIDREF="ch10141"XtSetValuessetlocaleIDREF="ch11174"Establishing the Language EnvironmentIDREF="ch1159"Compound Strings in UILIDREF="ch11192"Using LocalesIDREF="ch11187"Establishing the Language EnvironmentIDREF="ch1114"Locales and LocalizationshadowIDREF="ch1271"ShadowsShellIDREF="ch02163"ShellsIDREF="ch01117"Xt ClassesIDREF="ch01193"ShellsIDREF="ch01118"Xt ClassesIDREF="ch1631"Window ConfigurationIDREF="ch01120"Xt ClassesIDREF="ch10249"Shells and Their ChildrenIDREF="ch10220"Shells and Their ChildrenIDREF="ch16112"Window ConfigurationIDREF="ch16173"Menus and DialogsIDREF="ch165"Window Managers, ICCCM, and ShellsIDREF="ch166"Window Managers, ICCCM, and ShellsIDREF="ch0164"Widget GeometryIDREF="ch029"A User-Centered ModelshutdownIDREF="ch16241"Application Shutdown and Restartsource iconIDREF="ch1517"Overview of Drag-Over EffectsIDREF="ch15461"Source IconstackingIDREF="ch15190"Overview of Programmer ResponsibilitiesstartupKeyFocusIDREF="ch16226"Input FocusstateIDREF="ch1528"Drag Statesstate iconIDREF="ch15471"State IconIDREF="ch1519"Overview of Drag-Over EffectsIDREF="ch1535"Drag Statesstatus areaIDREF="ch11291"Input MethodSTRINGIDREF="ch16385"Text ConversionIDREF="ch16378"Text ConversionIDREF="ch16143"IconsIDREF="ch1623"Application StartupIDREF="ch16370"Text ConversionIDREF="ch1627"Application StartupIDREF="ch16399"Text Conversiontab groupIDREF="ch13121"Tab GroupsIDREF="ch1314"Input, Focus, and Keyboard NavigationtargetIDREF="ch16400"Text ConversionIDREF="ch15203"Overview of Programmer ResponsibilitiesIDREF="ch16402"Text ConversionIDREF="ch16404"Text ConversionIDREF="ch16368"TargetsIDREF="ch16371"Text ConversionIDREF="ch16373"Text ConversionIDREF="ch15153"TargetsIDREF="ch15145"TargetsIDREF="ch16355"TargetsIDREF="ch16379"Text ConversionIDREF="ch16381"Text ConversionIDREF="ch15140"TargetsIDREF="ch16384"Text ConversionIDREF="ch16386"Text ConversionIDREF="ch16388"Text ConversionIDREF="ch16357"TargetsIDREF="ch16359"TargetsIDREF="ch15183"Overview of Programmer ResponsibilitiesIDREF="ch16392"Text ConversionIDREF="ch16361"TargetsIDREF="ch16394"Text ConversionIDREF="ch16363"TargetsIDREF="ch16365"TargetsIDREF="ch16398"Text ConversionTARGETSIDREF="ch16356"TargetsIDREF="ch16393"Text ConversionTearOffMenuIDREF="ch06256"TearOffMenusIDREF="ch076"DialogsTemplateDialogIDREF="ch07204"MessageBoxIDREF="ch07198"MessageBoxIDREF="ch02157"BulletinBoard, Form, MessageBox, SelectionBoxTextIDREF="ch11203"Localization Without LocalesIDREF="ch08181"Text Resources and GeometryIDREF="ch0379"Creating WidgetsIDREF="ch08131"Text Editing and CallbacksIDREF="ch11319"Input and the Motif Text WidgetIDREF="ch0862"SelectionIDREF="ch08185"Text Resources and GeometryIDREF="ch08243"Storing Text in a FileIDREF="ch15470"Source IconIDREF="ch15332"Changing a Drop SiteIDREF="ch10256"Manager Widgets and Their ChildrenIDREF="ch08246"Sharing Text SourcesIDREF="ch15609"XmNdropProcIDREF="ch1554"Complexity of Drag and Drop ProgramsIDREF="ch1555"Complexity of Drag and Drop ProgramsIDREF="ch10355"Managing Geometry Using RowColumnIDREF="ch1571"Drag Sources and Drop SitesIDREF="ch0195"Compound Strings and Font ListsIDREF="ch13358"Focus CallbacksIDREF="ch1110"Obtaining InputIDREF="ch13262"Controlling Tab Group Traversal OrderIDREF="ch08250"Sharing Text SourcesIDREF="ch15621"XmNdropProcIDREF="ch13362"Focus CallbacksIDREF="ch11334"Geometry Management of Pre-Edit and Status AreasIDREF="ch11337"Compound Strings and Compound TextIDREF="ch13365"Focus CallbacksIDREF="ch11339"Compound Strings and Compound TextIDREF="ch08251"Sharing Text SourcesIDREF="ch08134"Text Editing and CallbacksIDREF="ch0281"ListIDREF="ch0283"TextIDREF="ch08137"Text Editing and CallbacksIDREF="ch081"TextIDREF="ch08257"Sharing Text SourcesIDREF="ch16352"Selection TypesIDREF="ch11229"An ExampleIDREF="ch08258"Sharing Text SourcesIDREF="ch16366"TargetsIDREF="ch08140"Text Editing and CallbacksIDREF="ch0869"SelectionIDREF="ch08196"Text Resources and GeometryIDREF="ch127"Color and PixmapsIDREF="ch084"TextIDREF="ch08143"Text Editing and CallbacksIDREF="ch16391"Text ConversionIDREF="ch0874"SelectionIDREF="ch0179"Selections and Drag and DropIDREF="ch16401"Text ConversionIDREF="ch02230"Handling Input and OutputIDREF="ch0887"Mouse SelectionIDREF="ch08100"Keyboard SelectionIDREF="ch08105"Text Editing and CallbacksIDREF="ch08107"Text Editing and CallbacksIDREF="ch08151"Text Editing and CallbacksIDREF="ch04130"Structure of a Program Using MRMIDREF="ch08153"Text Editing and CallbacksIDREF="ch089"TextIDREF="ch10390"Managing Geometry Using BulletinBoard and DrawingAreaIDREF="ch11164"Text and TextField Widgets and Font ListsIDREF="ch034"Including Header FilesIDREF="ch10394"Managing Geometry Using BulletinBoard and DrawingAreaIDREF="ch0813"Text and TextFieldIDREF="ch01158"Primitives and GadgetsIDREF="ch01166"Primitives and GadgetsIDREF="ch08114"Text Editing and CallbacksIDREF="ch0827"Text and TextFieldIDREF="ch08162"Text Resources and GeometryIDREF="ch0828"Text and TextFieldIDREF="ch13214"Tab GroupsIDREF="ch02111"ScrolledWindow and MainWindowIDREF="ch08118"Text Editing and CallbacksIDREF="ch0736"Activation, Cancellation, and HelpIDREF="ch13219"Tab GroupsIDREF="ch0835"SelectionIDREF="ch13451"Mnemonics and AcceleratorsIDREF="ch13458"Mnemonics and AcceleratorsIDREF="ch05201"Text and TextFieldIDREF="ch08122"Text Editing and CallbacksIDREF="ch08171"Text Resources and GeometryIDREF="ch15422"Starting a Drag With XmDragStartIDREF="ch0849"SelectionIDREF="ch0186"Selections and Drag and DropIDREF="ch08125"Text Editing and CallbacksIDREF="ch11288"Internationalization and Text InputIDREF="ch08176"Text Resources and GeometryIDREF="ch0855"SelectionIDREF="ch13234"Tab GroupsIDREF="ch11303"Input MethodIDREF="ch15440"Overriding Existing Drag SourcesIDREF="ch13131"Tab GroupsIDREF="ch15443"Overriding Existing Drag SourcesIDREF="ch08234"ScrolledTextIDREF="ch0514"Basic ControlsIDREF="ch08128"Text Editing and CallbacksIDREF="ch11309"Input MethodIDREF="ch15449"Overriding Existing Drag SourcesIDREF="ch0859"SelectionIDREF="ch11311"Input MethodTextFieldIDREF="ch0856"SelectionIDREF="ch0860"SelectionIDREF="ch11340"Compound Strings and Compound TextIDREF="ch08195"Text Resources and GeometryIDREF="ch14183"Example of an Input ProcedureIDREF="ch15310"Establishing a Drop SiteIDREF="ch14185"Example of an Input ProcedureIDREF="ch09131"Example of Automatic ScrollingIDREF="ch0863"SelectionIDREF="ch16353"Selection TypesIDREF="ch0196"Compound Strings and Font ListsIDREF="ch11165"Text and TextField Widgets and Font ListsIDREF="ch11168"Text and TextField Widgets and Font ListsIDREF="ch01167"Primitives and GadgetsIDREF="ch0737"Activation, Cancellation, and HelpIDREF="ch0870"SelectionIDREF="ch0875"SelectionIDREF="ch10356"Managing Geometry Using RowColumnIDREF="ch13359"Focus CallbacksIDREF="ch1210"Color and PixmapsIDREF="ch1118"Compound Strings, Fonts, and Text DisplayIDREF="ch15333"Changing a Drop SiteIDREF="ch13363"Focus CallbacksIDREF="ch0187"Selections and Drag and DropIDREF="ch13366"Focus CallbacksIDREF="ch05202"Text and TextFieldIDREF="ch0515"Basic ControlsIDREF="ch08141"Text Editing and CallbacksIDREF="ch08172"Text Resources and GeometryIDREF="ch085"TextIDREF="ch0285"TextIDREF="ch08177"Text Resources and GeometryIDREF="ch11304"Input MethodIDREF="ch01160"Primitives and GadgetsIDREF="ch13215"Tab GroupsIDREF="ch0810"TextIDREF="ch11310"Input MethodIDREF="ch13220"Tab GroupsIDREF="ch0814"Text and TextFieldIDREF="ch08182"Text Resources and GeometryIDREF="ch0180"Selections and Drag and DropIDREF="ch0829"Text and TextFieldIDREF="ch08186"Text Resources and GeometryIDREF="ch0832"SelectionIDREF="ch0836"SelectionIDREF="ch11204"Localization Without LocalesIDREF="ch1556"Complexity of Drag and Drop ProgramsIDREF="ch1572"Drag Sources and Drop SitesIDREF="ch11329"Geometry Management of Pre-Edit and Status AreasIDREF="ch08154"Text Editing and CallbacksIDREF="ch0850"SelectiontimestampIDREF="ch0132"The X Window SystemIDREF="ch16360"TargetsToggleButtonIDREF="ch10401"Managing Geometry Using BulletinBoard and DrawingAreaIDREF="ch03150"Adding Callback ProceduresIDREF="ch06177"OptionMenuIDREF="ch12105"Arming and SelectionIDREF="ch0588"ToggleButtonsIDREF="ch06232"RadioBox and CheckBoxIDREF="ch03144"Adding Callback ProceduresIDREF="ch0671"RowColumnIDREF="ch12110"Arming and SelectionIDREF="ch06237"RadioBox and CheckBoxIDREF="ch02140"RowColumnIDREF="ch0649"ButtonsIDREF="ch0550"LabelsIDREF="ch1238"Default Colors and PixmapsIDREF="ch03153"Adding Callback ProceduresIDREF="ch06243"RadioBox and CheckBoxIDREF="ch01151"Primitives and GadgetsIDREF="ch0659"RowColumnIDREF="ch0623"Menus and OptionsIDREF="ch06250"RadioBox and CheckBoxIDREF="ch0269"ButtonsIDREF="ch0634"ButtonsIDREF="ch06219"RadioBox and CheckBoxIDREF="ch03148"Adding Callback ProceduresIDREF="ch06225"RadioBox and CheckBoxIDREF="ch03149"Adding Callback ProceduresIDREF="ch12100"Arming and SelectionIDREF="ch13428"Mnemonics and AcceleratorsIDREF="ch0582"ToggleButtonsToggleButtonGadgetIDREF="ch12101"Arming and SelectionIDREF="ch06238"RadioBox and CheckBoxIDREF="ch0270"ButtonsIDREF="ch1239"Default Colors and PixmapsIDREF="ch12106"Arming and Selectiontop-level widgetIDREF="ch02199"Top-Level WidgetsTopLevelShellIDREF="ch03215"Multiple Screens, Displays, and ApplicationsIDREF="ch16137"IconsIDREF="ch02200"Top-Level WidgetsIDREF="ch03217"Multiple Screens, Displays, and ApplicationsIDREF="ch02170"VendorShellIDREF="ch03211"Multiple Screens, Displays, and ApplicationsIDREF="ch16247"Application Shutdown and RestartIDREF="ch16130"IconsIDREF="ch1618"Application StartupIDREF="ch01130"Xt ClassesIDREF="ch01127"Xt ClassestransferIDREF="ch16408"Incremental TransfersIDREF="ch15296"Drop ProtocolIDREF="ch15294"Drop ProtocolIDREF="ch15626"XmDropTransferIDREF="ch15695"Dealing with Requests for Transfertransfer protocolIDREF="ch15287"Drop ProtocoltransientDecorationIDREF="ch16280"DecorationsIDREF="ch16192"Menus and DialogstransientFunctionsIDREF="ch16286"FunctionsIDREF="ch16193"Menus and DialogsTransientShellIDREF="ch06259"TearOffMenusIDREF="ch16184"Menus and DialogsIDREF="ch10225"Shells and Their ChildrenIDREF="ch02178"DialogShellIDREF="ch01125"Xt ClassesIDREF="ch16181"Menus and DialogsIDREF="ch01197"ShellstranslationIDREF="ch13376"Translation Table FormatIDREF="ch13379"Using TranslationsIDREF="ch02222"Handling Input and OutputIDREF="ch1323"Input, Focus, and Keyboard NavigationIDREF="ch13374"Translations and ActionstraversalIDREF="ch1358"Controlling Keyboard NavigationIDREF="ch1336"Focus ModelsIDREF="ch134"Input, Focus, and Keyboard NavigationIDREF="ch09114"Traversing to Obscured WidgetsIDREF="ch0189"Keyboard TraversalIDREF="ch0235"Building Blocks: Primitive Widgets and GadgetsUID fileIDREF="ch04161"Fetching Information from UID FilesIDREF="ch04143"Opening UID FilesIDREF="ch04204"Closing the UID FileIDREF="ch044"Structure of a Program Using UIL and MRMUIDPATHIDREF="ch11257"MRM and Localized UID FilesIDREF="ch04148"Opening UID FilesIDREF="ch11260"MRM and Localized UID FilesIDREF="ch11256"MRM and Localized UID FilesUilIDREF="ch11138"Font Lists in UILIDREF="ch1164"Compound Strings in UILIDREF="ch0460"Object TypeIDREF="ch11118"Font Lists in UILIDREF="ch0438"include DirectiveIDREF="ch11231"UIL and LocalizationIDREF="ch042"Structure of a Program Using UIL and MRMIDREF="ch11234"Preparing Localized UID FilesIDREF="appa4"The Widget Meta-Language FacilityIDREF="ch11236"Preparing Localized UID FilesIDREF="ch01101"UIL and MRMIDREF="appa7"Using WMLIDREF="appa8"Using WMLIDREF="ch11238"Preparing Localized UID FilesIDREF="ch11239"Preparing Localized UID FilesIDREF="ch11240"Preparing Localized UID FilesIDREF="ch0221"Separating Interface from ApplicationIDREF="ch11243"Preparing Localized UID FilesIDREF="ch11244"Preparing Localized UID FilesIDREF="ch11245"Preparing Localized UID FilesIDREF="ch11246"Preparing Localized UID FilesIDREF="ch11247"Preparing Localized UID FilesIDREF="ch1157"Compound Strings in UILIDREF="ch11250"Preparing Localized UID FilesIDREF="ch11251"Preparing Localized UID FilesIDREF="ch1158"Compound Strings in UILIDREF="ch0437"include DirectiveIDREF="ch1145"Compound Strings in UILIDREF="ch1163"Compound Strings in UILIDREF="ch11137"Font Lists in UILUIL moduleIDREF="ch047"Structure of a UIL ModuleUIL syntaxIDREF="ch04179"Fetching Information from UID FilesIDREF="ch0436"include DirectiveIDREF="ch04183"Fetching Information from UID FilesIDREF="ch04185"Fetching Information from UID FilesIDREF="ch0440"include DirectiveIDREF="ch0442"value DeclarationIDREF="ch04190"Fetching Information from UID FilesIDREF="ch04192"Fetching Information from UID FilesIDREF="ch04194"Fetching Information from UID FilesIDREF="ch04196"Fetching Information from UID FilesIDREF="ch0412"Structure of a UIL ModuleIDREF="ch04199"Fetching Information from UID FilesIDREF="ch0444"value DeclarationIDREF="ch0446"identifier DeclarationIDREF="ch0450"procedure DeclarationIDREF="ch04215"Making Widgets VisibleIDREF="ch0454"procedure DeclarationIDREF="ch11233"Preparing Localized UID FilesIDREF="ch0456"object DeclarationIDREF="ch11242"Preparing Localized UID FilesIDREF="ch11249"Preparing Localized UID FilesIDREF="ch0458"object DeclarationIDREF="ch0464"Object TypeIDREF="ch0466"Object TypeIDREF="ch0469"Object TypeIDREF="ch0471"ChildrenIDREF="ch0473"ChildrenIDREF="ch0475"ChildrenIDREF="ch0477"ChildrenIDREF="ch0410"Structure of a UIL ModuleIDREF="ch0479"ChildrenIDREF="ch0482"ChildrenIDREF="ch11120"Font Lists in UILIDREF="ch11122"Font Lists in UILIDREF="ch11124"Font Lists in UILIDREF="ch11126"Font Lists in UILIDREF="ch11128"Font Lists in UILIDREF="ch11130"Font Lists in UILIDREF="ch11132"Font Lists in UILIDREF="ch11134"Font Lists in UILIDREF="ch11136"Font Lists in UILIDREF="ch0491"Resource ValuesIDREF="ch0493"Resource ValuesIDREF="ch11144"Font Lists in UILIDREF="ch11146"Font Lists in UILIDREF="ch11148"Font Lists in UILIDREF="ch0496"Callback ProceduresIDREF="ch0498"Callback ProceduresIDREF="ch04101"Callback ProceduresIDREF="ch04103"Callback ProceduresIDREF="ch04105"Callback ProceduresIDREF="ch04109"list DeclarationIDREF="ch04111"list DeclarationIDREF="ch04113"list DeclarationIDREF="ch04115"list DeclarationIDREF="ch04117"list DeclarationIDREF="ch04119"list DeclarationIDREF="ch04121"list DeclarationIDREF="ch04123"list DeclarationIDREF="ch04125"list DeclarationIDREF="ch04127"end module ClauseIDREF="ch0414"Structure of a UIL ModuleIDREF="ch0416"Structure of a UIL ModuleIDREF="ch0418"Structure of a UIL ModuleIDREF="ch0420"Structure of a UIL ModuleIDREF="ch0422"Structure of a UIL ModuleIDREF="ch0424"Structure of a UIL ModuleIDREF="ch0426"module ClauseIDREF="ch0428"Module-Level DeclarationsIDREF="ch04163"Fetching Information from UID FilesIDREF="ch04167"Fetching Information from UID FilesIDREF="ch04169"Fetching Information from UID FilesIDREF="ch1147"Compound Strings in UILIDREF="ch0430"Module-Level DeclarationsIDREF="ch1152"Compound Strings in UILIDREF="ch1154"Compound Strings in UILIDREF="ch1156"Compound Strings in UILIDREF="ch04171"Fetching Information from UID FilesIDREF="ch1162"Compound Strings in UILIDREF="ch04174"Fetching Information from UID FilesIDREF="ch1169"Compound Strings in UILIDREF="ch0432"Module-Level DeclarationsIDREF="ch04176"Fetching Information from UID FilesIDREF="ch0434"Module-Level DeclarationsunmanagedIDREF="ch04214"Making Widgets VisibleIDREF="ch0478"ChildrenIDREF="ch04198"Fetching Information from UID FilesuseIconBoxIDREF="ch16163"IconsusePPositionIDREF="ch1646"Window ConfigurationIDREF="ch1647"Window ConfigurationUser Interface Definition (UID) fileIDREF="ch043"Structure of a Program Using UIL and MRMIDREF="ch04160"Fetching Information from UID FilesIDREF="ch04203"Closing the UID FileIDREF="ch04142"Opening UID FilesUser Interface Language (UIL)IDREF="ch0220"Separating Interface from ApplicationIDREF="ch11117"Font Lists in UILIDREF="ch11230"UIL and LocalizationIDREF="ch01100"UIL and MRMIDREF="ch1144"Compound Strings in UILIDREF="appa3"The Widget Meta-Language Facilityvalid drop siteIDREF="ch1529"Drag StatesvalueIDREF="ch04182"Fetching Information from UID FilesIDREF="ch0143"XlibIDREF="ch0413"Structure of a UIL ModuleIDREF="ch0443"value DeclarationIDREF="ch04170"Fetching Information from UID FilesIDREF="ch04175"Fetching Information from UID FilesIDREF="ch04178"Fetching Information from UID FilesVendorShellIDREF="ch02176"DialogShellIDREF="ch11307"Input MethodIDREF="ch01126"Xt ClassesIDREF="ch01128"Xt ClassesIDREF="ch16257"Application Shutdown and RestartIDREF="ch11316"Input ManagerIDREF="ch1310"Input, Focus, and Keyboard NavigationIDREF="ch16113"Window ConfigurationIDREF="ch11105"Font List Resource DefaultsIDREF="ch1312"Input, Focus, and Keyboard NavigationIDREF="ch01123"Xt ClassesIDREF="ch02166"ShellsIDREF="ch11322"Input and the Motif Text WidgetIDREF="ch16277"DecorationsIDREF="ch11323"Input and the Motif Text WidgetIDREF="ch16211"Input FocusIDREF="ch16283"FunctionsIDREF="ch16169"Window GroupsIDREF="ch0765"DialogShellIDREF="ch16289"FunctionsIDREF="ch11330"Geometry Management of Pre-Edit and Status AreasIDREF="ch16294"Input ModeIDREF="ch11112"Font List Resource DefaultsIDREF="ch02168"VendorShellIDREF="ch01194"ShellsIDREF="ch16301"Window MenuIDREF="ch1192"Font List Resource DefaultsIDREF="ch10246"Shells and Their ChildrenIDREF="ch10221"Shells and Their ChildrenIDREF="ch1197"Font List Resource DefaultsIDREF="ch02218"Handling Input and OutputIDREF="ch0750"DialogShellIDREF="ch10226"Shells and Their ChildrenIDREF="ch16194"Menus and DialogsIDREF="ch11301"Input MethodIDREF="ch16319"Atom and Protocol Managementvisual styleIDREF="ch0172"Visual StyleWarningDialogIDREF="ch07200"MessageBoxwchar_tIDREF="ch08167"Text Resources and GeometryIDREF="ch08231"Convenience RoutinesIDREF="ch088"TextwidgetIDREF="ch0149"WidgetsIDREF="ch0392"Widget InitializationIDREF="ch0373"Creating WidgetsIDREF="ch0152"WidgetsIDREF="ch0160"Widget GeometryIDREF="ch01109"Widget Classes and HierarchyIDREF="ch021"A User-Centered ModelIDREF="ch0249"Building Blocks: Primitive Widgets and GadgetsIDREF="ch03158"Making Widgets VisibleIDREF="ch1013"Widget Class ProceduresIDREF="ch03186"Realizing WidgetsIDREF="ch03160"Making Widgets VisibleIDREF="ch03162"Making Widgets VisibleIDREF="ch03164"Managing WidgetsIDREF="ch03196"Mapping WidgetsIDREF="ch0154"WidgetsIDREF="ch1596"Drag and Drop Widget ClassesIDREF="ch04212"Making Widgets VisibleIDREF="ch025"A User-Centered ModelIDREF="ch02198"Top-Level WidgetsIDREF="ch0166"Widget GeometryWidget Meta-Language Database (WMD) fileIDREF="appa5"The Widget Meta-Language FacilitywindowIDREF="ch16299"Window MenuIDREF="ch164"Window Managers, ICCCM, and ShellsIDREF="ch022"A User-Centered ModelIDREF="ch16166"Window GroupsIDREF="ch16275"DecorationsIDREF="ch1629"Window ConfigurationIDREF="ch16281"FunctionsIDREF="ch0110"The X Window SystemIDREF="ch018"The X Window SystemIDREF="ch1614"Application StartupIDREF="ch0162"Widget GeometryIDREF="ch16178"Menus and DialogswindowMenuIDREF="ch16303"Window MenuWM_CLASSIDREF="ch1610"Application StartupWM_CLIENT_MACHINEIDREF="ch16248"Application Shutdown and RestartIDREF="ch16244"Application Shutdown and RestartWM_COLORMAP_WINDOWSIDREF="ch16232"ColormapsIDREF="ch12157"ColormapsWM_COMMANDIDREF="ch16245"Application Shutdown and RestartIDREF="ch16255"Application Shutdown and RestartWM_DELETE_WINDOWIDREF="ch16260"Application Shutdown and RestartIDREF="ch16250"Application Shutdown and RestartIDREF="ch16256"Application Shutdown and RestartIDREF="ch16253"Application Shutdown and RestartIDREF="ch16267"Application Shutdown and RestartWM_HINTSIDREF="ch16204"Input FocusIDREF="ch16199"Input FocusIDREF="ch16202"Input FocusIDREF="ch16150"IconsWM_ICON_NAMEIDREF="ch16136"IconsIDREF="ch16142"IconsWM_ICON_SIZEIDREF="ch16154"IconsWM_NAMEIDREF="ch1626"Application StartupWM_NORMAL_HINTSIDREF="ch1658"Window ConfigurationIDREF="ch1668"Window ConfigurationWM_PROTOCOLSIDREF="ch16252"Application Shutdown and RestartIDREF="ch16331"Atom and Protocol ManagementIDREF="ch16339"Atom and Protocol ManagementIDREF="ch16200"Input FocusIDREF="ch16307"MWM MessagesIDREF="ch16334"Atom and Protocol ManagementIDREF="ch16322"Atom and Protocol ManagementIDREF="ch16344"Atom and Protocol ManagementIDREF="ch16207"Input FocusWM_SAVE_YOURSELFIDREF="ch16251"Application Shutdown and RestartIDREF="ch16268"Application Shutdown and RestartIDREF="ch16261"Application Shutdown and RestartIDREF="ch16254"Application Shutdown and RestartWM_SIZE_HINTSIDREF="ch1659"Window ConfigurationWM_TAKE_FOCUSIDREF="ch16201"Input FocusIDREF="ch16203"Input FocusIDREF="ch16208"Input FocusWM_TRANSIENT_FORIDREF="ch16179"Menus and DialogsIDREF="ch16183"Menus and DialogsWMD fileIDREF="appa6"The Widget Meta-Language FacilityWMLIDREF="appa2"The Widget Meta-Language FacilityWMShellIDREF="ch1615"Application StartupIDREF="ch16205"Input FocusIDREF="ch01124"Xt ClassesIDREF="ch16167"Window GroupsIDREF="ch01122"Xt ClassesIDREF="ch1611"Application StartupIDREF="ch16146"IconsIDREF="ch16129"IconsIDREF="ch16148"IconsIDREF="ch16185"Menus and DialogsIDREF="ch10222"Shells and Their ChildrenIDREF="ch16152"IconsIDREF="ch16249"Application Shutdown and RestartIDREF="ch1660"Window ConfigurationIDREF="ch16116"Window ConfigurationIDREF="ch16160"IconsWorkAreaIDREF="ch0654"RowColumnIDREF="ch0272"ButtonsIDREF="ch06218"RadioBox and CheckBoxIDREF="ch02121"RowColumnIDREF="ch10299"Managing Geometry Using RowColumnIDREF="ch06246"RadioBox and CheckBoxIDREF="ch0585"ToggleButtonsIDREF="ch0622"Menus and OptionsIDREF="ch06251"RadioBox and CheckBoxIDREF="ch13209"Tab GroupsIDREF="ch0627"Menus and OptionsIDREF="ch09253"FrameIDREF="ch10290"Managing Geometry Using RowColumnIDREF="ch0638"ButtonsIDREF="ch13119"XmNtraversalOnIDREF="ch02137"RowColumnIDREF="ch06234"RadioBox and CheckBoxWorkingDialogIDREF="ch07202"MessageBoxXIDREF="ch014"The X Window SystemX resource managerIDREF="ch0134"XlibX Toolkit IntrinsicsIDREF="ch01105"Using Xlib, Xt, and MotifIDREF="ch036"Initializing the IntrinsicsIDREF="ch0147"XtIDREF="ch16409"The Xt Selection InterfaceIDREF="ch04132"Initializing the IntrinsicsX Window SystemIDREF="ch013"The X Window SystemXAPPLRESDIRIDREF="ch11281"Images, Pixmaps, and LocalizationIDREF="ch11261"MRM and Localized UID FilesIDREF="ch11218"Resource File LocationsIDREF="ch11284"Images, Pixmaps, and LocalizationIDREF="ch0366"User Application FileIDREF="ch11220"Resource File LocationsIDREF="ch11221"Resource File LocationsIDREF="ch0363"User Application FileIDREF="ch0364"User Application FileIDREF="ch11258"MRM and Localized UID FilesXBMLANGPATHIDREF="ch11279"Images, Pixmaps, and LocalizationIDREF="ch11283"Images, Pixmaps, and LocalizationIDREF="ch11280"Images, Pixmaps, and LocalizationIDREF="ch12163"Using PixmapsIDREF="ch12164"Using PixmapsXChangeActivePointerGrabIDREF="ch15519"Visual Style NotesXClearAreaIDREF="ch10213"Exposure and RedisplayXColorIDREF="ch12142"Application-Defined Color GenerationIDREF="ch12143"Application-Defined Color GenerationIDREF="ch12144"Application-Defined Color GenerationXCompoundTextStyleIDREF="ch11346"Compound Strings and Compound TextXConfigureWindowIDREF="ch1068"The geometry_manager ProcedureIDREF="ch16107"Window ConfigurationIDREF="ch10211"Exposure and RedisplayXConvertSelectionIDREF="ch16415"The Xt Selection InterfaceXCreateFontSetIDREF="ch1182"Font List StructureIDREF="ch11197"Using LocalesXCreateImageIDREF="ch12167"Using Pixmaps.XdefaultsIDREF="ch0349"Per-Host User ResourcesIDREF="ch0358"Server or User-Preference ResourcesXDrawImageStringIDREF="ch14227"Text OutputXDrawImageString16IDREF="ch14228"Text OutputXDrawStringIDREF="ch14224"Text OutputXDrawString16IDREF="ch14225"Text OutputXDrawTextIDREF="ch14229"Text OutputXENVIRONMENTIDREF="ch0348"Per-Host User ResourcesXEventIDREF="ch03147"Adding Callback ProceduresXExposeEventIDREF="ch14139"Handling Exposure EventsIDREF="ch14138"Handling Exposure EventsXExtentsOfFontSetIDREF="ch14239"Text OutputXFILESEARCHPATHIDREF="ch11224"Resource File LocationsIDREF="ch0369"Application Class Resource FileXFontSetIDREF="ch1181"Font List StructureXFontStructIDREF="ch14235"Text OutputXGetAtomNameIDREF="ch16318"Atom and Protocol ManagementXGetIconSizesIDREF="ch16159"IconsXGetImageIDREF="ch12168"Using PixmapsXGetSelectionOwnerIDREF="ch16414"The Xt Selection InterfaceXInternAtomIDREF="ch16317"Atom and Protocol ManagementXlibIDREF="ch01104"Using Xlib, Xt, and MotifIDREF="ch0133"XlibXLoadQueryFontIDREF="ch11157"Compound Strings and Font ListsIDREF="ch11154"Compound Strings and Font ListsXmActivateProtocolIDREF="ch16335"Atom and Protocol ManagementXmActivateWMProtocolIDREF="ch16337"Atom and Protocol ManagementXmAddProtocolCallbackIDREF="ch16325"Atom and Protocol ManagementIDREF="ch16330"Atom and Protocol ManagementIDREF="ch16323"Atom and Protocol ManagementIDREF="ch16310"MWM MessagesXmAddProtocolsIDREF="ch16324"Atom and Protocol ManagementIDREF="ch16320"Atom and Protocol ManagementXmAddTabGroupIDREF="ch13190"Tab GroupsIDREF="ch13198"Tab GroupsXmAddWMProtocolCallbackIDREF="ch16210"Input FocusIDREF="ch16329"Atom and Protocol ManagementIDREF="ch16263"Application Shutdown and RestartXmAddWMProtocolsIDREF="ch16321"Atom and Protocol ManagementIDREF="ch16309"MWM MessagesIDREF="ch16262"Application Shutdown and RestartIDREF="ch16209"Input FocusXmALIGNMENT_BASELINE_\BOTTOMIDREF="ch10364"Managing Geometry Using RowColumnIDREF="ch09277"FrameXmALIGNMENT_BASELINE_\TOPIDREF="ch09279"FrameIDREF="ch10365"Managing Geometry Using RowColumnXmALIGNMENT_BEGINNINGIDREF="ch09266"FrameIDREF="ch10348"Managing Geometry Using RowColumnXmALIGNMENT_BOTTOMIDREF="ch10366"Managing Geometry Using RowColumnXmALIGNMENT_CENTERIDREF="ch10350"Managing Geometry Using RowColumnIDREF="ch10367"Managing Geometry Using RowColumnIDREF="ch10349"Managing Geometry Using RowColumnXmALIGNMENT_TOPIDREF="ch10368"Managing Geometry Using RowColumnXmALIGNMENT_WIDGET_\BOTTOMIDREF="ch09282"FrameXmAnyCallbackStructIDREF="ch08123"Text Editing and CallbacksIDREF="ch08135"Text Editing and CallbacksIDREF="ch08108"Text Editing and CallbacksIDREF="ch08138"Text Editing and CallbacksIDREF="ch08126"Text Editing and CallbacksIDREF="ch16326"Atom and Protocol ManagementIDREF="ch08132"Text Editing and CallbacksXmAPPLICATION_DEFINEDIDREF="ch0915"Automatic and Application-Defined ScrollingIDREF="ch0945"Other ResourcesIDREF="ch08237"ScrolledTextXmArrowButtonIDREF="ch10398"Managing Geometry Using BulletinBoard and DrawingAreaXmAS_NEEDEDIDREF="ch0986"Automatic ScrollingIDREF="ch0943"Other ResourcesXmATTACH_FORMIDREF="ch10505"Managing Geometry Using FormIDREF="ch10489"Managing Geometry Using FormIDREF="ch10427"Managing Geometry Using FormIDREF="ch10418"Managing Geometry Using FormIDREF="ch10473"Managing Geometry Using FormIDREF="ch10517"Managing Geometry Using FormXmATTACH_HOTIDREF="ch15506"Drag Icon Blending and AttachmentXmATTACH_NONEIDREF="ch10415"Managing Geometry Using FormIDREF="ch10512"Managing Geometry Using FormIDREF="ch10417"Managing Geometry Using FormIDREF="ch10499"Managing Geometry Using FormXmATTACH_NORTH_WESTIDREF="ch15503"Drag Icon Blending and AttachmentXmATTACH_OPPOSITE_\FORMIDREF="ch10506"Managing Geometry Using FormIDREF="ch10420"Managing Geometry Using FormXmATTACH_OPPOSITE_\WIDGETIDREF="ch10448"Managing Geometry Using FormIDREF="ch10429"Managing Geometry Using FormXmATTACH_POSITIONIDREF="ch10461"Managing Geometry Using FormIDREF="ch10442"Managing Geometry Using FormIDREF="ch10504"Managing Geometry Using FormIDREF="ch10431"Managing Geometry Using FormIDREF="ch10493"Managing Geometry Using FormIDREF="ch10454"Managing Geometry Using FormIDREF="ch10479"Managing Geometry Using FormIDREF="ch10451"Managing Geometry Using FormXmATTACH_SELFIDREF="ch10511"Managing Geometry Using FormIDREF="ch10435"Managing Geometry Using FormIDREF="ch10503"Managing Geometry Using FormXmATTACH_WIDGETIDREF="ch10514"Managing Geometry Using FormIDREF="ch10447"Managing Geometry Using FormIDREF="ch10426"Managing Geometry Using FormIDREF="ch10423"Managing Geometry Using FormXmAUTOMATICIDREF="ch13285"Traversing to Obscured WidgetsIDREF="ch09242"MainWindowIDREF="ch0930"Other ResourcesIDREF="ch13114"XmNtraversalOnIDREF="ch0914"Automatic and Application-Defined ScrollingIDREF="ch0965"Automatic ScrollingIDREF="ch0925"Other ResourcesIDREF="ch0946"Other ResourcesIDREF="ch1368"Controlling Keyboard NavigationIDREF="ch0935"Other ResourcesXmbDrawImageStringIDREF="ch14226"Text OutputXmbDrawStringIDREF="ch14223"Text OutputXmbDrawTextIDREF="ch14230"Text OutputxmbindIDREF="ch13413"Bindings for osf KeysymsXMBINDDIRIDREF="ch13415"Bindings for osf KeysymsXmBLEND_ALLIDREF="ch15497"Drag Icon Blending and AttachmentIDREF="ch15536"Creating a Drag IconXmBLEND_JUST_SOURCEIDREF="ch15499"Drag Icon Blending and AttachmentIDREF="ch15535"Creating a Drag IconXmBLEND_NONEIDREF="ch15520"Visual Style NotesIDREF="ch15500"Drag Icon Blending and AttachmentIDREF="ch15518"Visual Style NotesXmBLEND_STATE_SOURCEIDREF="ch15498"Drag Icon Blending and AttachmentXmBOTTOM_LEFTIDREF="ch0952"Other ResourcesXmBOTTOM_RIGHTIDREF="ch0953"Other ResourcesXmbTextEscapementIDREF="ch14240"Text OutputXmbTextExtentsIDREF="ch14241"Text OutputXmbTextListToTextPropertyIDREF="ch16377"Text ConversionIDREF="ch11345"Compound Strings and Compound TextIDREF="ch1624"Application StartupIDREF="ch16375"Text ConversionIDREF="ch16395"Text ConversionIDREF="ch16140"IconsXmbTextPerCharExtentsIDREF="ch14242"Text OutputXmbTextPropertyToTextListIDREF="ch16389"Text ConversionXmBulletinBoardIDREF="ch11106"Font List Resource DefaultsIDREF="ch02146"BulletinBoard, Form, MessageBox, SelectionBoxIDREF="ch10228"Shells and Their ChildrenIDREF="ch11113"Font List Resource DefaultsIDREF="ch1193"Font List Resource DefaultsIDREF="ch01187"ManagersIDREF="ch0711"BulletinBoard and DialogShellXmCascadeButtonIDREF="ch01148"Primitives and GadgetsXmChangeColorIDREF="ch12122"Application-Defined Color GenerationIDREF="ch12139"Application-Defined Color GenerationIDREF="ch12130"Application-Defined Color GenerationIDREF="ch12123"Application-Defined Color GenerationIDREF="ch12145"Application-Defined Color GenerationIDREF="ch12136"Application-Defined Color GenerationIDREF="ch12147"Application-Defined Color GenerationIDREF="ch12128"Application-Defined Color GenerationXmClipboardCancelCopyIDREF="ch16438"Copying Data to the ClipboardIDREF="ch16442"Copying Data to the ClipboardIDREF="ch16449"Copying Data to the ClipboardXmClipboardCopyIDREF="ch16453"Copying Data to the ClipboardIDREF="ch16436"Copying Data to the ClipboardIDREF="ch16447"Copying Data to the ClipboardIDREF="ch16444"Copying Data to the ClipboardIDREF="ch16450"Copying Data to the ClipboardIDREF="ch16445"Copying Data to the ClipboardIDREF="ch16452"Copying Data to the ClipboardXmClipboardCopyByNameIDREF="ch16458"Copying Data to the ClipboardXmClipboardEndCopyIDREF="ch16437"Copying Data to the ClipboardIDREF="ch16446"Copying Data to the ClipboardIDREF="ch16448"Copying Data to the ClipboardIDREF="ch16441"Copying Data to the ClipboardXmClipboardEndRetrieveIDREF="ch16465"Retrieving Data from the ClipboardIDREF="ch16475"Utility RoutinesIDREF="ch16471"Retrieving Data from the ClipboardXmClipboardInquireCountIDREF="ch16454"Copying Data to the ClipboardIDREF="ch16478"Utility RoutinesIDREF="ch16476"Utility RoutinesXmClipboardInquireFormatIDREF="ch16455"Copying Data to the ClipboardIDREF="ch16477"Utility RoutinesXmClipboardInquireLengthIDREF="ch16479"Utility RoutinesIDREF="ch16470"Retrieving Data from the ClipboardXmClipboardInquirePendingItemsIDREF="ch16457"Copying Data to the ClipboardIDREF="ch16456"Copying Data to the ClipboardIDREF="ch16480"Utility RoutinesXmClipboardLockIDREF="ch16472"Utility RoutinesIDREF="ch16481"Utility RoutinesXmClipboardRegisterFormatIDREF="ch16483"Utility RoutinesXmClipboardRetrieveIDREF="ch16468"Retrieving Data from the ClipboardIDREF="ch16464"Retrieving Data from the ClipboardXmClipboardStartCopyIDREF="ch16443"Copying Data to the ClipboardIDREF="ch16451"Copying Data to the ClipboardIDREF="ch16435"Copying Data to the ClipboardIDREF="ch16439"Copying Data to the ClipboardIDREF="ch16440"Copying Data to the ClipboardXmClipboardStartRetrieveIDREF="ch16474"Utility RoutinesIDREF="ch16467"Retrieving Data from the ClipboardIDREF="ch16463"Retrieving Data from the ClipboardIDREF="ch16466"Retrieving Data from the ClipboardXmClipboardTruncateIDREF="ch16469"Retrieving Data from the ClipboardXmClipboardUndoCopyIDREF="ch16462"Copying Data to the ClipboardXmClipboardUnlockIDREF="ch16473"Utility RoutinesIDREF="ch16482"Utility RoutinesXmClipboardWithdrawFormatIDREF="ch16461"Copying Data to the ClipboardXmColorProcIDREF="ch12138"Application-Defined Color GenerationIDREF="ch12134"Application-Defined Color GenerationIDREF="ch12141"Application-Defined Color GenerationXmCOMMAND_BELOW_\WORKSPACEIDREF="ch09217"MainWindowXmCommandGetChildIDREF="ch07145"Making a Selection: SelectionBoxXmCR_CLIPBOARD_DATA_\DELETEIDREF="ch16459"Copying Data to the ClipboardXmCR_CLIPBOARD_DATA_\REQUESTIDREF="ch16460"Copying Data to the ClipboardXmCR_DRAG_MOTION_\MESSAGEIDREF="ch15371"XmNdragProcXmCR_DROP_SITE_ENTER_\MESSAGEIDREF="ch15369"XmNdragProcXmCR_DROP_SITE_LEAVE_\MESSAGEIDREF="ch15370"XmNdragProcIDREF="ch15589"Cancelling the DragXmCR_EXPOSEIDREF="ch1429"Event Handling and CallbacksXmCR_INPUTIDREF="ch1432"Event Handling and CallbacksXmCR_LOSING_FOCUSIDREF="ch13369"Focus CallbacksXmCR_OBSCURED_\TRAVERSALIDREF="ch09119"Traversing to Obscured WidgetsXmCR_OPERATION_CHANGED_\MESSAGEIDREF="ch15372"XmNdragProcXmCR_PROTOCOLSIDREF="ch16328"Atom and Protocol ManagementXmCR_RESIZEIDREF="ch1437"Event Handling and CallbacksXmCR_VALUE_CHANGEDIDREF="ch03146"Adding Callback ProceduresXmCreateBulletinBoardDialogIDREF="ch0779"DialogShellXmCreateDragIconIDREF="ch15181"Overview of Programmer ResponsibilitiesIDREF="ch15109"Drag and Drop FunctionsIDREF="ch15179"Overview of Programmer ResponsibilitiesIDREF="ch15531"Creating a Drag IconXmCreateErrorDialogIDREF="ch07191"MessageBoxXmCreateFileSelectionDialogIDREF="ch07163"Choosing a Pathname: FileSelectionBoxXmCreateFormDialogIDREF="ch07211"FormXmCreateInformationDialogIDREF="ch07193"MessageBoxXmCreateMenuBarIDREF="ch06122"MenuBarIDREF="ch0382"Creating WidgetsXmCreateMessageDialogIDREF="ch07195"MessageBoxXmCreateOptionMenuIDREF="ch06208"OptionMenuXmCreatePromptDialogIDREF="ch07127"Making a Selection: SelectionBoxXmCreatePulldownMenuIDREF="ch0385"Creating WidgetsXmCreateQuestionDialogIDREF="ch07197"MessageBoxXmCreateRadioBoxIDREF="ch06247"RadioBox and CheckBoxXmCreateScrolledListIDREF="ch05199"ListIDREF="ch0387"Creating WidgetsXmCreateScrolledTextIDREF="ch08235"ScrolledTextXmCreateSelectionDialogIDREF="ch07124"Making a Selection: SelectionBoxXmCreateSimpleMenuBarIDREF="ch06123"MenuBarXmCreateTemplateDialogIDREF="ch07199"MessageBoxXmCreateTextIDREF="ch0380"Creating WidgetsXmCreateWarningDialogIDREF="ch07201"MessageBoxXmCreateWorkingDialogIDREF="ch07203"MessageBoxXmCvtCTToXmStringIDREF="ch11350"Compound Strings and Compound TextIDREF="ch11342"Compound Strings and Compound TextIDREF="ch16405"Text ConversionXmCvtXmStringToCTIDREF="ch16382"Text ConversionIDREF="ch11341"Compound Strings and Compound TextIDREF="ch11343"Compound Strings and Compound TextXmDeactivateProtocolIDREF="ch16336"Atom and Protocol ManagementXmDeactivateWMProtocolIDREF="ch16338"Atom and Protocol ManagementXmDestroyPixmapIDREF="ch12178"Using PixmapsIDREF="ch12176"Using PixmapsXmDIALOG_COMMANDIDREF="ch07138"Making a Selection: SelectionBoxXmDIALOG_FILE_SELECTIONIDREF="ch07140"Making a Selection: SelectionBoxXmDIALOG_PROMPTIDREF="ch07136"Making a Selection: SelectionBoxXmDIALOG_SELECTIONIDREF="ch07131"Making a Selection: SelectionBoxXmDIALOG_WORK_AREAIDREF="ch07134"Making a Selection: SelectionBoxXmDialogShellIDREF="ch02177"DialogShellIDREF="ch01196"ShellsIDREF="ch10224"Shells and Their ChildrenXmDisplayIDREF="ch1598"Drag and Drop Widget ClassesXmDRAG_DROP_ONLYIDREF="ch15260"Specifying Drag ProtocolsIDREF="ch15524"Visual Style NotesIDREF="ch15280"Protocols and VisualsXmDRAG_DYNAMICIDREF="ch15265"Specifying Drag ProtocolsIDREF="ch15282"Protocols and VisualsXmDRAG_NONEIDREF="ch15279"Protocols and VisualsIDREF="ch15258"Specifying Drag ProtocolsIDREF="ch15523"Visual Style NotesXmDRAG_PREFER_\DYNAMICIDREF="ch15270"Specifying Drag ProtocolsIDREF="ch15283"Protocols and VisualsIDREF="ch15264"Specifying Drag ProtocolsXmDRAG_PREFER_\PREREGISTERIDREF="ch15262"Specifying Drag ProtocolsXmDRAG_PREFER_\RECEIVERIDREF="ch15263"Specifying Drag ProtocolsXmDRAG_PREREGISTERIDREF="ch15261"Specifying Drag ProtocolsXmDRAG_UNDER_HIGHLIGHTIDREF="ch15349"Drag-Under Visual EffectsXmDRAG_UNDER_NONEIDREF="ch15354"Drag-Under Visual EffectsXmDRAG_UNDER_PIXMAPIDREF="ch15357"Drag-Under Visual EffectsIDREF="ch15352"Drag-Under Visual EffectsIDREF="ch15361"Drag-Under Visual EffectsXmDRAG_UNDER_SHADOW_\INIDREF="ch15351"Drag-Under Visual EffectsXmDRAG_UNDER_SHADOW_\OUTIDREF="ch15350"Drag-Under Visual EffectsXmDragCancelIDREF="ch15110"Drag and Drop FunctionsIDREF="ch15587"Cancelling the DragIDREF="ch15211"Overview of Programmer ResponsibilitiesXmDragContextIDREF="ch15103"Drag and Drop Widget ClassesIDREF="ch15149"TargetsXmDragIconIDREF="ch15101"Drag and Drop Widget ClassesXmDragStartIDREF="ch15112"Drag and Drop FunctionsIDREF="ch15202"Overview of Programmer ResponsibilitiesIDREF="ch15416"Drag Initiator Responsibilities for DraggingIDREF="ch15433"Starting a Drag With XmDragStartIDREF="ch15425"Starting a Drag With XmDragStartIDREF="ch15441"Overriding Existing Drag SourcesIDREF="ch15427"Starting a Drag With XmDragStartIDREF="ch15200"Overview of Programmer ResponsibilitiesXmDrawingAreaIDREF="ch14125"Handling Exposure EventsIDREF="ch01192"ManagersXmDrawingAreaCallbackStructIDREF="ch1438"Event Handling and CallbacksXmDrawnButtonIDREF="ch01149"Primitives and GadgetsIDREF="ch10399"Managing Geometry Using BulletinBoard and DrawingAreaXmDROPIDREF="ch15688"XmNdropStartCallbackXmDROP_CANCELIDREF="ch15689"XmNdropStartCallbackIDREF="ch15588"Cancelling the DragIDREF="ch15693"XmNdropStartCallbackXmDROP_COPYIDREF="ch15562"Drag CallbacksIDREF="ch15380"XmNdragProcIDREF="ch15568"Drag CallbacksIDREF="ch15164"OperationsXmDROP_HELPIDREF="ch15669"Providing HelpIDREF="ch15690"XmNdropStartCallbackIDREF="ch15676"Providing HelpIDREF="ch15672"Providing HelpXmDROP_LINKIDREF="ch15565"Drag CallbacksIDREF="ch15381"XmNdragProcIDREF="ch15165"OperationsIDREF="ch15569"Drag CallbacksXmDROP_MOVEIDREF="ch15163"OperationsIDREF="ch15379"XmNdragProcIDREF="ch15559"Drag CallbacksIDREF="ch15567"Drag CallbacksXmDROP_NOOPIDREF="ch15169"OperationsIDREF="ch15402"Simulating Nested Drop SitesIDREF="ch15176"Drop Site StatusIDREF="ch15566"Drag CallbacksIDREF="ch15570"Drag CallbacksIDREF="ch15382"XmNdragProcIDREF="ch15387"XmNdragProcIDREF="ch15406"Simulating Nested Drop SitesIDREF="ch15553"Drag CallbacksIDREF="ch15166"OperationsIDREF="ch15576"Drag CallbacksIDREF="ch15493"Operation IconXmDROP_SITE_ACTIVEIDREF="ch15324"Establishing a Drop SiteXmDROP_SITE_COMPOSITEIDREF="ch15340"Nested Drop SitesXmDROP_SITE_INACTIVEIDREF="ch15325"Establishing a Drop SiteXmDROP_SITE_INVALIDIDREF="ch15574"Drag CallbacksIDREF="ch15405"Simulating Nested Drop SitesIDREF="ch15577"Drag CallbacksIDREF="ch15407"Simulating Nested Drop SitesIDREF="ch15494"Operation IconIDREF="ch15386"XmNdragProcIDREF="ch15388"XmNdragProcIDREF="ch15177"Drop Site StatusIDREF="ch15172"Drop Site StatusIDREF="ch15170"OperationsXmDROP_SITE_SIMPLEIDREF="ch15339"Nested Drop SitesXmDROP_SITE_VALIDIDREF="ch15573"Drag CallbacksIDREF="ch15385"XmNdragProcIDREF="ch15171"Drop Site StatusIDREF="ch15403"Simulating Nested Drop SitesXmDropSiteIDREF="ch15105"Drag and Drop Widget ClassesXmDropSiteConfigureStacking\OrderIDREF="ch15345"Overlapping Drop SitesIDREF="ch15188"Overview of Programmer ResponsibilitiesIDREF="ch15120"Drag and Drop FunctionsIDREF="ch15114"Drag and Drop FunctionsXmDropSiteEndUpdateIDREF="ch15115"Drag and Drop FunctionsIDREF="ch15126"Drag and Drop FunctionsIDREF="ch15130"Drag and Drop FunctionsIDREF="ch15330"Changing a Drop SiteIDREF="ch15194"Overview of Programmer ResponsibilitiesIDREF="ch15124"Drag and Drop FunctionsXmDropSiteQueryStackingOrderIDREF="ch15191"Overview of Programmer ResponsibilitiesIDREF="ch15119"Drag and Drop FunctionsIDREF="ch15187"Overview of Programmer ResponsibilitiesXmDropSiteRegisterIDREF="ch15182"Overview of Programmer ResponsibilitiesIDREF="ch15311"Establishing a Drop SiteIDREF="ch15312"Establishing a Drop SiteIDREF="ch15121"Drag and Drop FunctionsXmDropSiteRetrieveIDREF="ch15131"Drag and Drop FunctionsIDREF="ch15122"Drag and Drop FunctionsIDREF="ch15215"Overview of Programmer ResponsibilitiesXmDropSiteStartUpdateIDREF="ch15129"Drag and Drop FunctionsIDREF="ch15116"Drag and Drop FunctionsIDREF="ch15118"Drag and Drop FunctionsIDREF="ch15123"Drag and Drop FunctionsIDREF="ch15193"Overview of Programmer ResponsibilitiesIDREF="ch15329"Changing a Drop SiteXmDropSiteUnregisterIDREF="ch15132"Drag and Drop FunctionsIDREF="ch15195"Overview of Programmer ResponsibilitiesIDREF="ch15327"Establishing a Drop SiteXmDropSiteUpdateIDREF="ch15125"Drag and Drop FunctionsIDREF="ch15127"Drag and Drop FunctionsIDREF="ch15128"Drag and Drop FunctionsIDREF="ch15331"Changing a Drop SiteIDREF="ch15117"Drag and Drop FunctionsIDREF="ch15192"Overview of Programmer ResponsibilitiesXmDropTranferStartIDREF="ch15674"Providing HelpXmDropTransferIDREF="ch15107"Drag and Drop Widget ClassesIDREF="ch15623"XmDropTransferXmDropTransferAddIDREF="ch15644"XmDropTransferIDREF="ch15650"Processing Each OperationIDREF="ch15133"Drag and Drop FunctionsIDREF="ch15224"Overview of Programmer ResponsibilitiesXmDropTransferStartIDREF="ch15698"Dealing with Requests for TransferIDREF="ch15634"XmDropTransferIDREF="ch15700"Dealing with Requests for TransferIDREF="ch15228"Overview of Programmer ResponsibilitiesIDREF="ch15300"Drop ProtocolIDREF="ch15611"XmNdropProcIDREF="ch15613"XmNdropProcIDREF="ch1587"Drop ProtocolIDREF="ch1588"Drop ProtocolIDREF="ch15673"Providing HelpIDREF="ch15598"Drop Receiver Responsibilities for DroppingIDREF="ch15677"Providing HelpIDREF="ch15223"Overview of Programmer ResponsibilitiesIDREF="ch15645"XmDropTransferIDREF="ch15134"Drag and Drop FunctionsIDREF="ch15226"Overview of Programmer ResponsibilitiesIDREF="ch1594"Drop ProtocolIDREF="ch15628"XmDropTransferIDREF="ch15629"XmDropTransferIDREF="ch15298"Drop ProtocolIDREF="ch15605"XmNdropProcIDREF="ch15661"Cancelling a DropXmEXCLUSIVE_TAB_GROUPIDREF="ch13303"XmProcessTraversalIDREF="ch13186"Tab GroupsIDREF="ch13305"XmProcessTraversalIDREF="ch13337"XmProcessTraversalIDREF="ch13240"Controlling Tab Group Traversal OrderIDREF="ch13339"XmProcessTraversalIDREF="ch13142"Tab GroupsIDREF="ch13341"XmProcessTraversalIDREF="ch13244"Controlling Tab Group Traversal OrderIDREF="ch13309"XmProcessTraversalIDREF="ch13188"Tab GroupsIDREF="ch13345"XmProcessTraversalIDREF="ch13311"XmProcessTraversalIDREF="ch13347"XmProcessTraversalIDREF="ch13151"Tab GroupsIDREF="ch13349"XmProcessTraversalIDREF="ch13247"Controlling Tab Group Traversal OrderIDREF="ch13162"Tab GroupsIDREF="ch13315"XmProcessTraversalIDREF="ch13173"Tab GroupsIDREF="ch13317"XmProcessTraversalIDREF="ch13250"Controlling Tab Group Traversal OrderIDREF="ch13193"Tab GroupsIDREF="ch13252"Controlling Tab Group Traversal OrderIDREF="ch13321"XmProcessTraversalIDREF="ch13178"Tab GroupsIDREF="ch13323"XmProcessTraversalIDREF="ch13156"Tab GroupsIDREF="ch13180"Tab GroupsIDREF="ch13140"Tab GroupsIDREF="ch13257"Controlling Tab Group Traversal OrderIDREF="ch13165"Tab GroupsIDREF="ch13158"Tab GroupsIDREF="ch13153"Tab GroupsIDREF="ch13331"XmProcessTraversalIDREF="ch13185"Tab GroupsIDREF="ch13333"XmProcessTraversalXmEXPLICITIDREF="ch1335"Focus ModelsIDREF="ch13123"Tab GroupsIDREF="ch1361"Controlling Keyboard NavigationIDREF="ch0784"Initial FocusIDREF="ch0865"SelectionIDREF="ch1333"Focus ModelsIDREF="ch13104"XmNtraversalOnXmFALLBACK_CHARSETIDREF="ch1166"Compound Strings in UILIDREF="ch1149"Compound Strings in UILIDREF="ch11141"Font Lists in UILXmFileSelectionBoxGetChildIDREF="ch07144"Making a Selection: SelectionBoxXmFONT_IS_FONTIDREF="ch1178"Font List StructureXmFONT_IS_FONTSETIDREF="ch1176"Font List StructureIDREF="ch1184"Font List StructureXmFontListIDREF="ch03122"Resource Value Data TypesXmFONTLIST_DEFAULT_TAGIDREF="ch11208"Localization Without LocalesIDREF="ch1121"Compound String ComponentsIDREF="ch11139"Font Lists in UILIDREF="ch11151"Compound Strings and Font ListsIDREF="ch11169"Text and TextField Widgets and Font ListsIDREF="ch1188"Font Lists and ResourcesIDREF="ch11153"Compound Strings and Font ListsIDREF="ch1128"Compound String ComponentsIDREF="ch11193"Using LocalesIDREF="ch1143"Setting a Compound String in a Defaults FileIDREF="ch11195"Using LocalesIDREF="ch11237"Preparing Localized UID FilesIDREF="ch1160"Compound Strings in UILIDREF="ch11344"Compound Strings and Compound TextIDREF="ch11347"Compound Strings and Compound TextIDREF="ch11198"Using LocalesIDREF="ch11349"Compound Strings and Compound TextIDREF="ch11199"Using LocalesIDREF="ch1137"Setting a Compound String ProgrammaticallyIDREF="ch11205"Localization Without LocalesIDREF="ch11206"Localization Without LocalesIDREF="ch11160"Compound Strings and Font ListsXmFontListAppendEntryIDREF="ch1185"Font List StructureIDREF="ch11159"Compound Strings and Font ListsIDREF="ch11156"Compound Strings and Font ListsXmFontListEntryAppendIDREF="ch1179"Font List StructureXmFontListEntryCreateIDREF="ch11158"Compound Strings and Font ListsIDREF="ch1180"Font List StructureIDREF="ch1183"Font List StructureIDREF="ch11155"Compound Strings and Font ListsXmFontListEntryLoadIDREF="ch1174"Font List StructureIDREF="ch1175"Font List StructureIDREF="ch1177"Font List StructureXmFontListFreeIDREF="ch03137"Resource Values and Memory ManagementXmFormIDREF="ch01190"ManagersXmFrameIDREF="ch01173"ManagersXmFRAME_GENERIC_CHILDIDREF="ch09262"FrameXmFRAME_TITLE_CHILDIDREF="ch09261"FrameXmFRAME_WORKAREA_\CHILDIDREF="ch09260"FrameXmGadgetIDREF="ch0238"Building Blocks: Primitive Widgets and GadgetsIDREF="ch056"Basic ControlsIDREF="ch0247"Building Blocks: Primitive Widgets and GadgetsIDREF="ch01163"Primitives and GadgetsIDREF="ch0521"Core, RectObj, XmPrimitive, and XmGadget ClassesXmGetAtomNameIDREF="ch16316"Atom and Protocol ManagementXmGetColorCalculationIDREF="ch12149"Application-Defined Color GenerationXmGetColorsIDREF="ch12131"Application-Defined Color GenerationIDREF="ch12129"Application-Defined Color GenerationIDREF="ch12137"Application-Defined Color GenerationIDREF="ch12140"Application-Defined Color GenerationIDREF="ch12146"Application-Defined Color GenerationIDREF="ch12148"Application-Defined Color GenerationXmGetDragContextIDREF="ch15445"Overriding Existing Drag SourcesIDREF="ch15135"Drag and Drop FunctionsIDREF="ch15448"Overriding Existing Drag SourcesIDREF="ch15579"Drag CallbacksXmGetFocusWidgetIDREF="ch1372"Controlling Keyboard NavigationXmGetPixmapByDepthIDREF="ch11277"Images, Pixmaps, and LocalizationIDREF="ch12161"Using PixmapsIDREF="ch11287"Images, Pixmaps, and LocalizationIDREF="ch07188"MessageBoxIDREF="ch12177"Using PixmapsIDREF="ch12166"Using PixmapsIDREF="ch11282"Images, Pixmaps, and LocalizationIDREF="ch12170"Using PixmapsIDREF="ch11285"Images, Pixmaps, and LocalizationXmGetTabGroupIDREF="ch13236"Tab GroupsXmGetVisibilityIDREF="ch13295"Traversing to Obscured WidgetsIDREF="ch1376"Controlling Keyboard NavigationIDREF="ch1374"Controlling Keyboard NavigationXmGetXmDisplayIDREF="ch15137"Drag and Drop FunctionsIDREF="ch15266"Specifying Drag ProtocolsXmGetXmScreenIDREF="ch15138"Drag and Drop FunctionsXmHORIZONTALIDREF="ch10291"Managing Geometry Using RowColumnIDREF="ch10304"Managing Geometry Using RowColumnXmImMbLookupStringIDREF="ch11318"Input ManagerXmImRegisterIDREF="ch11315"Input ManagerXmInstallImageIDREF="ch12172"Using PixmapsIDREF="ch12169"Using PixmapsIDREF="ch12174"Using PixmapsIDREF="ch12171"Using PixmapsXmIsMotifWMRunningIDREF="ch16312"MWM InformationXmIsTraversableIDREF="ch1375"Controlling Keyboard NavigationIDREF="ch1373"Controlling Keyboard NavigationXmLabelIDREF="ch01145"Primitives and GadgetsIDREF="ch10357"Managing Geometry Using RowColumnIDREF="ch10374"Managing Geometry Using RowColumnIDREF="ch0665"RowColumnIDREF="ch10331"Managing Geometry Using RowColumnIDREF="ch10343"Managing Geometry Using RowColumnIDREF="ch0652"ButtonsIDREF="ch05111"ArrowButtonsIDREF="ch01143"Primitives and GadgetsXmLabelGadgetIDREF="ch10375"Managing Geometry Using RowColumnIDREF="ch0666"RowColumnIDREF="ch05113"ArrowButtonsIDREF="ch10358"Managing Geometry Using RowColumnIDREF="ch10344"Managing Geometry Using RowColumnIDREF="ch10332"Managing Geometry Using RowColumnXmLAST_POSITIONIDREF="ch09317"PanedWindowXmListIDREF="ch01157"Primitives and GadgetsXmMainWindowIDREF="ch01181"ManagersXmMainWindowSep1IDREF="ch09221"MainWindowXmMainWindowSep2IDREF="ch09222"MainWindowXmMainWindowSep3IDREF="ch09223"MainWindowXmMainWindowSetAreasIDREF="ch09245"MainWindowIDREF="ch09235"MainWindowXmManagerIDREF="ch01170"ManagersIDREF="ch0288"ManagersIDREF="ch0291"ManagersIDREF="ch057"Basic ControlsXmMenuPositionIDREF="ch13468"Event HandlersIDREF="ch06140"PopupMenuXmMenuShellIDREF="ch02184"MenuShellIDREF="ch01200"ShellsIDREF="ch1195"Font List Resource DefaultsIDREF="ch11108"Font List Resource DefaultsIDREF="ch1198"Font List Resource DefaultsIDREF="ch11114"Font List Resource DefaultsIDREF="ch16177"Menus and DialogsIDREF="ch0692"MenuShellIDREF="ch10230"Shells and Their ChildrenXmN_OF_MANYIDREF="ch06254"RadioBox and CheckBoxXmNacceleratorIDREF="ch13433"Mnemonics and AcceleratorsXmNacceleratorsIDREF="ch13440"Mnemonics and AcceleratorsIDREF="ch13443"Mnemonics and AcceleratorsIDREF="ch13438"Mnemonics and AcceleratorsXmNacceleratorTextIDREF="ch13435"Mnemonics and AcceleratorsXmNactivateCallbackIDREF="ch0575"PushButtonsIDREF="ch0826"Text and TextFieldIDREF="ch0669"RowColumnIDREF="ch09199"Example of Application-Defined ScrollingIDREF="ch0742"Activation, Cancellation, and HelpIDREF="ch0646"ButtonsIDREF="ch0648"ButtonsIDREF="ch0566"CascadeButtonsIDREF="ch08152"Text Editing and CallbacksIDREF="ch08136"Text Editing and CallbacksIDREF="ch08142"Text Editing and CallbacksXmNadjustLastIDREF="ch10308"Managing Geometry Using RowColumnXmNadjustMarginIDREF="ch10328"Managing Geometry Using RowColumnXmNalignmentIDREF="ch10347"Managing Geometry Using RowColumnIDREF="ch0543"LabelsIDREF="ch10371"Managing Geometry Using RowColumnXmNallowResizeIDREF="ch09306"PanedWindowXmNallowShellResizeIDREF="ch10250"Shells and Their ChildrenXmNancestorSensitiveIDREF="ch1397"SensitivityIDREF="ch1339"Focus ModelsIDREF="ch13101"SensitivityIDREF="ch1392"SensitivityIDREF="ch1387"SensitivityIDREF="ch1384"SensitivityIDREF="ch1364"Controlling Keyboard NavigationIDREF="ch1390"SensitivityXmNanimationMaskIDREF="ch15363"Drag-Under Visual EffectsIDREF="ch15359"Drag-Under Visual EffectsXmNanimationPixmapIDREF="ch15353"Drag-Under Visual EffectsIDREF="ch15362"Drag-Under Visual EffectsIDREF="ch15358"Drag-Under Visual EffectsXmNanimationPixmapDepthIDREF="ch15364"Drag-Under Visual EffectsIDREF="ch15360"Drag-Under Visual EffectsXmNanimationStyleIDREF="ch15356"Drag-Under Visual EffectsXmNapplyCallbackIDREF="ch07116"Making a Selection: SelectionBoxXmNarmColorIDREF="ch1293"Arming and SelectionIDREF="ch12114"Arming and SelectionIDREF="ch1241"Default Colors and PixmapsIDREF="ch1237"Default Colors and PixmapsXmNarmPixmapIDREF="ch1240"Default Colors and PixmapsIDREF="ch1297"Arming and SelectionXmNattachmentIDREF="ch15502"Drag Icon Blending and AttachmentIDREF="ch15532"Creating a Drag IconXmNautomaticSelectionIDREF="ch05178"ListXmNautoUnmanageIDREF="ch0759"DialogShellXmNbackgroundIDREF="ch12124"Application-Defined Color GenerationIDREF="ch1259"BackgroundsIDREF="ch1216"Default Colors and PixmapsIDREF="ch1258"BackgroundsXmNbackgroundColorIDREF="ch05116"SeparatorsXmNbackgroundPixmapIDREF="ch1217"Default Colors and PixmapsIDREF="ch05117"SeparatorsXmNbaseHeightIDREF="ch1663"Window ConfigurationIDREF="ch1684"Window ConfigurationIDREF="ch1672"Window ConfigurationIDREF="ch1670"Window ConfigurationXmNbaseWidthIDREF="ch1671"Window ConfigurationIDREF="ch1688"Window ConfigurationIDREF="ch1664"Window ConfigurationIDREF="ch1676"Window ConfigurationXmNblendModelIDREF="ch15534"Creating a Drag IconIDREF="ch15496"Drag Icon Blending and AttachmentIDREF="ch15517"Visual Style NotesXmNborderColorIDREF="ch1251"BordersIDREF="ch1253"BordersIDREF="ch1255"BordersIDREF="ch1213"Default Colors and PixmapsXmNborderPixmapIDREF="ch1250"BordersIDREF="ch1214"Default Colors and PixmapsXmNborderWidthIDREF="ch1012"Managing GeometryIDREF="ch10241"Shells and Their ChildrenIDREF="ch1467"Moving and Resizing ChildrenIDREF="ch06100"MenuShellIDREF="ch1031"Widget Class ProceduresIDREF="ch1638"Window ConfigurationIDREF="ch0770"DialogShellXmNbottomAttachmentIDREF="ch10460"Managing Geometry Using FormIDREF="ch10416"Managing Geometry Using FormXmNbottomPositionIDREF="ch10464"Managing Geometry Using FormXmNbottomShadowColorIDREF="ch1275"ShadowsIDREF="ch1278"ShadowsIDREF="ch12127"Application-Defined Color GenerationIDREF="ch1227"Default Colors and PixmapsXmNbottomShadowPixmapIDREF="ch1274"ShadowsIDREF="ch1228"Default Colors and PixmapsXmNbrowseSelectionCallbackIDREF="ch05173"ListXmNbuttonFontListIDREF="ch11101"Font List Resource DefaultsIDREF="ch11115"Font List Resource DefaultsXmNcancelButtonIDREF="ch0720"BulletinBoardIDREF="ch0739"Activation, Cancellation, and HelpXmNcancelCallbackIDREF="ch07114"Making a Selection: SelectionBoxXmNcascadingCallbackIDREF="ch0567"CascadeButtonsIDREF="ch0644"ButtonsXmNchildHorizontalAlignmentIDREF="ch09263"FrameXmNchildHorizontalSpacingIDREF="ch09265"FrameIDREF="ch09273"FrameXmNchildPlacementIDREF="ch0799"Making a Selection: SelectionBoxIDREF="ch10392"Managing Geometry Using BulletinBoard and DrawingAreaXmNchildrenIDREF="ch13334"XmProcessTraversalIDREF="ch13318"XmProcessTraversalIDREF="ch13326"XmProcessTraversalIDREF="ch13306"XmProcessTraversalIDREF="ch13328"XmProcessTraversalIDREF="ch13258"Controlling Tab Group Traversal OrderIDREF="ch13312"XmProcessTraversalIDREF="ch13324"XmProcessTraversalXmNchildTypeIDREF="ch09258"FrameXmNchildVerticalAlignmentIDREF="ch09276"FrameXmNclipWindowIDREF="ch0972"Automatic ScrollingIDREF="ch0922"Other ResourcesIDREF="ch09101"Automatic ScrollingXmNcolormapIDREF="ch12156"ColormapsIDREF="ch12153"ColormapsXmNcolumnsIDREF="ch08205"Text Resources and GeometryIDREF="ch08180"Text Resources and GeometryIDREF="ch08215"Text Resources and GeometryIDREF="ch08228"Text Resources and GeometryIDREF="ch10258"Manager Widgets and Their ChildrenIDREF="ch08209"Text Resources and GeometryXmNcommandChangedCallbackIDREF="ch07170"CommandXmNcommandEnteredCallbackIDREF="ch07171"CommandXmNcommandWindowIDREF="ch09227"MainWindowXmNcommandWindowLocationIDREF="ch09216"MainWindowXmNconvertProcIDREF="ch15697"Dealing with Requests for TransferIDREF="ch15699"Dealing with Requests for TransferIDREF="ch15702"Dealing with Requests for TransferIDREF="ch15680"Drag Initiator Responsibilities for DroppingIDREF="ch15705"Dealing with Requests for TransferIDREF="ch15706"Dealing with Requests for TransferIDREF="ch15428"Starting a Drag With XmDragStartIDREF="ch15201"Overview of Programmer ResponsibilitiesIDREF="ch15710"Dealing with Requests for TransferIDREF="ch15711"Dealing with Requests for TransferIDREF="ch15227"Overview of Programmer ResponsibilitiesIDREF="ch15205"Overview of Programmer ResponsibilitiesIDREF="ch15290"Drop ProtocolIDREF="ch1590"Drop ProtocolIDREF="ch15691"XmNdropStartCallbackIDREF="ch15301"Drop ProtocolXmNdarkThresholdIDREF="ch1279"ShadowsIDREF="ch1281"ShadowsIDREF="ch12118"Arming and SelectionXmNdefaultActionCallbackIDREF="ch05180"ListIDREF="ch05183"ListXmNdefaultButtonIDREF="ch0733"Activation, Cancellation, and HelpIDREF="ch0792"Initial FocusIDREF="ch0719"BulletinBoardIDREF="ch0721"BulletinBoardXmNdefaultButtonShadow\ThicknessIDREF="ch0578"PushButtonsXmNdefaultCopyCursorIconIDREF="ch15488"Operation IconXmNdefaultFontListIDREF="ch1199"Font List Resource DefaultsXmNdefaultInvalidCursorIconIDREF="ch15475"State IconXmNdefaultLinkCursorIconIDREF="ch15489"Operation IconXmNdefaultMoveCursorIconIDREF="ch15487"Operation IconXmNdefaultNoneCursorIconIDREF="ch15476"State IconXmNdefaultPositionIDREF="ch0772"DialogShellXmNdefaultSourceCursorIconIDREF="ch15511"Drag Icon Blending and AttachmentIDREF="ch15467"Source IconXmNdefaultValidCursorIconIDREF="ch15474"State IconXmNdeleteResponseIDREF="ch16258"Application Shutdown and RestartXmNdestroyCallbackIDREF="ch0389"Creating WidgetsXmNdialogStyleIDREF="ch16298"Input ModeIDREF="ch0722"BulletinBoardXmNdialogTitleIDREF="ch0775"DialogShellIDREF="ch1621"Application StartupXmNdialogTypeIDREF="ch07128"Making a Selection: SelectionBoxIDREF="ch07189"MessageBoxXmNdirSearchProcIDREF="ch07153"Choosing a Pathname: FileSelectionBoxXmNdragCallbackIDREF="ch05150"ScaleXmNdragDropFinishCallbackIDREF="ch15231"Overview of Programmer ResponsibilitiesIDREF="ch15664"Cancelling a DropIDREF="ch15233"Overview of Programmer ResponsibilitiesIDREF="ch15683"Drag Initiator Responsibilities for DroppingXmNdragInitiatorProtocolStyleIDREF="ch15281"Protocols and VisualsIDREF="ch15256"Specifying Drag ProtocolsIDREF="ch15254"Specifying Drag ProtocolsIDREF="ch15522"Visual Style NotesIDREF="ch15259"Specifying Drag ProtocolsIDREF="ch15277"Protocols and VisualsIDREF="ch15278"Protocols and VisualsXmNdragMotionCallbackIDREF="ch15539"Drag CallbacksIDREF="ch15545"Drag CallbacksXmNdragOperationsIDREF="ch15552"Drag CallbacksIDREF="ch15555"Drag CallbacksIDREF="ch15451"Overriding Existing Drag SourcesIDREF="ch15429"Starting a Drag With XmDragStartIDREF="ch15708"Dealing with Requests for TransferIDREF="ch15374"XmNdragProcIDREF="ch15431"Starting a Drag With XmDragStartIDREF="ch15376"XmNdragProcIDREF="ch15317"Establishing a Drop SiteIDREF="ch15160"OperationsXmNdragProcIDREF="ch15600"XmNdropProcIDREF="ch15209"Overview of Programmer ResponsibilitiesIDREF="ch15305"Drop Receiver Responsibilities for DraggingIDREF="ch15306"Drop Receiver Responsibilities for DraggingIDREF="ch15399"Simulating Nested Drop SitesIDREF="ch15400"Simulating Nested Drop SitesIDREF="ch15185"Overview of Programmer ResponsibilitiesIDREF="ch15314"Establishing a Drop SiteIDREF="ch15686"XmNdropStartCallbackIDREF="ch15408"Simulating Nested Drop SitesIDREF="ch15268"Specifying Drag ProtocolsIDREF="ch15411"Simulating Nested Drop SitesIDREF="ch15242"Drag ProtocolsIDREF="ch15173"Drop Site StatusIDREF="ch15251"The Dynamic Drag ProtocolIDREF="ch15252"The Dynamic Drag ProtocolIDREF="ch15207"Overview of Programmer ResponsibilitiesIDREF="ch15341"Nested Drop SitesIDREF="ch15365"XmNdragProcIDREF="ch15367"XmNdragProcIDREF="ch15368"XmNdragProcIDREF="ch15549"Drag CallbacksIDREF="ch15208"Overview of Programmer ResponsibilitiesIDREF="ch15556"Drag CallbacksIDREF="ch15383"XmNdragProcIDREF="ch15384"XmNdragProcIDREF="ch15389"XmNdragProcIDREF="ch15571"Drag CallbacksIDREF="ch15572"Drag CallbacksIDREF="ch15390"XmNdragProcIDREF="ch15590"Cancelling the DragIDREF="ch15391"XmNdragProcIDREF="ch15392"XmNdragProcIDREF="appb2"Drag and Drop Example ProgramIDREF="ch15395"Simulating Nested Drop SitesXmNdragReceiverProtocolStyleIDREF="ch15255"Specifying Drag ProtocolsIDREF="ch15269"Specifying Drag ProtocolsIDREF="ch15257"Specifying Drag ProtocolsXmNdropFinishCallbackIDREF="ch15682"Drag Initiator Responsibilities for DroppingIDREF="ch15230"Overview of Programmer ResponsibilitiesIDREF="ch15663"Cancelling a DropIDREF="ch15692"XmNdropStartCallbackIDREF="ch15719"XmNdragDropFinishCallbackIDREF="ch15232"Overview of Programmer ResponsibilitiesIDREF="ch15637"XmDropTransferXmNdropFinishedCallbackIDREF="ch15660"Cancelling a DropXmNdropProcIDREF="ch15220"Overview of Programmer ResponsibilitiesIDREF="ch15675"Providing HelpIDREF="ch15409"Simulating Nested Drop SitesIDREF="ch15222"Overview of Programmer ResponsibilitiesIDREF="ch15687"XmNdropStartCallbackIDREF="ch15216"Overview of Programmer ResponsibilitiesIDREF="ch15334"Changing a Drop SiteIDREF="ch15186"Overview of Programmer ResponsibilitiesIDREF="ch15218"Overview of Programmer ResponsibilitiesIDREF="ch15174"Drop Site StatusIDREF="ch15595"Drop Receiver Responsibilities for DroppingIDREF="ch15396"Simulating Nested Drop SitesIDREF="ch15601"XmNdropProcIDREF="ch15602"XmNdropProcIDREF="ch15603"XmNdropProcIDREF="ch15604"XmNdropProcIDREF="ch15606"XmNdropProcIDREF="ch15608"XmNdropProcIDREF="ch15304"Drop Receiver Responsibilities for DraggingIDREF="ch15313"Establishing a Drop SiteIDREF="ch15401"Simulating Nested Drop SitesIDREF="ch15662"Cancelling a DropIDREF="ch15665"Cancelling a DropIDREF="ch15668"Providing HelpIDREF="ch15670"Providing HelpXmNdropRectanglesIDREF="ch15336"Specially Shaped Drop SitesXmNdropSiteActivityIDREF="ch15319"Establishing a Drop SiteXmNdropSiteEnterCallbackIDREF="ch15547"Drag CallbacksIDREF="ch15541"Drag CallbacksXmNdropSiteLeaveCallbackIDREF="ch15542"Drag CallbacksXmNdropSiteOperationsIDREF="ch15397"Simulating Nested Drop SitesIDREF="ch15315"Establishing a Drop SiteIDREF="ch15318"Establishing a Drop SiteIDREF="ch15430"Starting a Drag With XmDragStartIDREF="ch15162"OperationsIDREF="ch15378"XmNdragProcIDREF="ch15551"Drag CallbacksIDREF="ch15558"Drag CallbacksIDREF="ch15561"Drag CallbacksIDREF="ch15648"Processing Each OperationIDREF="ch15564"Drag CallbacksXmNdropSiteTypeIDREF="ch15338"Nested Drop SitesXmNdropStartCallbackIDREF="ch15219"Overview of Programmer ResponsibilitiesIDREF="ch15671"Providing HelpIDREF="ch15681"Drag Initiator Responsibilities for DroppingIDREF="ch15717"XmNdropFinishCallbackIDREF="ch15685"XmNdropStartCallbackIDREF="ch15217"Overview of Programmer ResponsibilitiesIDREF="ch15594"Drop Receiver Responsibilities for DroppingXmNdropTransfersIDREF="ch15614"XmNdropProcIDREF="ch15631"XmDropTransferIDREF="ch15714"Dealing with Requests for TransferXmNeditableIDREF="ch086"TextXmNentryAlignmentIDREF="ch10376"Managing Geometry Using RowColumnIDREF="ch10340"Managing Geometry Using RowColumnXmNentryBorderIDREF="ch10313"Managing Geometry Using RowColumnXmNentryCallbackIDREF="ch0668"RowColumnIDREF="ch0678"RowColumnXmNentryClassIDREF="ch0661"RowColumnXmNentryVerticalAlignmentIDREF="ch10352"Managing Geometry Using RowColumnXmNexportTargetsIDREF="ch15147"TargetsIDREF="ch15143"TargetsIDREF="ch15709"Dealing with Requests for TransferXmNexposeCallbackIDREF="ch09190"Example of Application-Defined ScrollingIDREF="ch14119"Example of a Resize ProcedureIDREF="ch09204"Example of Application-Defined ScrollingIDREF="ch14131"Handling Exposure EventsIDREF="ch14137"Handling Exposure EventsIDREF="ch1425"Event Handling and CallbacksIDREF="ch14110"Resizing and RedisplayIDREF="ch14144"Handling Exposure EventsIDREF="ch14147"Handling Exposure EventsIDREF="ch14149"Example of an Expose ProcedureIDREF="ch05104"DrawnButtonsXmNextendedSelectionCallbackIDREF="ch05175"ListXmNfileSearchProcIDREF="ch07154"Choosing a Pathname: FileSelectionBoxXmNfillOnArmIDREF="ch1294"Arming and SelectionXmNfillOnSelectIDREF="ch0593"ToggleButtonsIDREF="ch12104"Arming and SelectionXmNfocusCallbackIDREF="ch13354"XmProcessTraversalIDREF="ch08124"Text Editing and CallbacksXmNfocusMovedCallbackIDREF="ch13360"Focus CallbacksXmNfontListIDREF="ch08178"Text Resources and GeometryIDREF="ch08224"Text Resources and GeometryIDREF="ch11109"Font List Resource DefaultsIDREF="ch11100"Font List Resource DefaultsIDREF="ch11321"Input and the Motif Text WidgetXmNforegroundIDREF="ch12125"Application-Defined Color GenerationIDREF="ch1221"Default Colors and PixmapsIDREF="ch1268"ForegroundsXmNforegroundThresholdIDREF="ch1270"ForegroundsXmNfractionBaseIDREF="ch10444"Managing Geometry Using FormIDREF="ch10438"Managing Geometry Using FormIDREF="ch10465"Managing Geometry Using FormIDREF="ch10434"Managing Geometry Using FormIDREF="ch10450"Managing Geometry Using FormIDREF="ch10458"Managing Geometry Using FormXmNgainPrimaryCallbackIDREF="ch08130"Text Editing and CallbacksIDREF="ch08159"Text Editing and CallbacksXmNgeometryIDREF="ch1632"Window ConfigurationIDREF="ch1697"Window ConfigurationIDREF="ch1639"Window ConfigurationXmNheightIDREF="ch1465"Moving and Resizing ChildrenIDREF="ch10248"Shells and Their ChildrenIDREF="ch0698"MenuShellIDREF="ch1248"BordersIDREF="ch1636"Window ConfigurationIDREF="ch11333"Geometry Management of Pre-Edit and Status AreasIDREF="ch08202"Text Resources and GeometryIDREF="ch1645"Window ConfigurationIDREF="ch08207"Text Resources and GeometryIDREF="ch14196"Using a DrawingArea in a ScrolledWindowIDREF="ch10384"Managing Geometry Using BulletinBoard and DrawingAreaIDREF="ch1651"Window ConfigurationIDREF="ch0969"Automatic ScrollingIDREF="ch1655"Window ConfigurationIDREF="ch10239"Shells and Their ChildrenIDREF="ch1657"Window ConfigurationIDREF="ch1011"Managing GeometryIDREF="ch08213"Text Resources and GeometryIDREF="ch0768"DialogShellIDREF="ch1417"DrawingArea: A General-Purpose WidgetIDREF="ch1030"Widget Class ProceduresXmNheightIncIDREF="ch1685"Window ConfigurationIDREF="ch1682"Window ConfigurationIDREF="ch1673"Window ConfigurationXmNhelpCallbackIDREF="ch07115"Making a Selection: SelectionBoxIDREF="ch0747"Activation, Cancellation, and HelpIDREF="ch0744"Activation, Cancellation, and HelpXmNhighlightColorIDREF="ch1287"Focus HighlightsIDREF="ch1233"Default Colors and PixmapsXmNhighlightPixmapIDREF="ch1234"Default Colors and PixmapsXmNhighlightThicknessIDREF="ch10261"Manager Widgets and Their ChildrenIDREF="ch05106"DrawnButtonsXmNhistoryMaxItemsIDREF="ch07175"CommandXmNhorizontalScrollBarIDREF="ch0974"Automatic ScrollingIDREF="ch0926"Other ResourcesXmNhorizontalSpacingIDREF="ch10466"Managing Geometry Using FormXmNiconicIDREF="ch16132"IconsXmNiconMaskIDREF="ch16149"IconsXmNiconNameIDREF="ch1619"Application StartupIDREF="ch16138"IconsXmNiconNameEncodingIDREF="ch16139"IconsXmNiconPixmapIDREF="ch16147"IconsXmNiconWindowIDREF="ch16153"IconsXmNiconXIDREF="ch16161"IconsXmNiconYIDREF="ch16162"IconsXmNimportTargetsIDREF="ch15398"Simulating Nested Drop SitesIDREF="ch15155"TargetsIDREF="ch15151"TargetsXmNincrementIDREF="ch0978"Automatic ScrollingIDREF="ch05133"ScrollBarIDREF="ch09161"Application-Defined ScrollingIDREF="ch09106"Automatic ScrollingXmNincrementalIDREF="ch15704"Dealing with Requests for TransferIDREF="ch15638"XmDropTransferIDREF="ch16429"The Xt Selection InterfaceIDREF="ch16431"The Xt Selection InterfaceIDREF="ch15615"XmNdropProcXmNindicatorOnIDREF="ch0590"ToggleButtonsIDREF="ch12103"Arming and SelectionXmNindicatorTypeIDREF="ch06226"RadioBox and CheckBoxIDREF="ch0673"RowColumnIDREF="ch06253"RadioBox and CheckBoxIDREF="ch0592"ToggleButtonsXmNinitialFocusIDREF="ch13275"Initial FocusIDREF="ch13276"Initial FocusIDREF="ch13277"Initial FocusIDREF="ch13278"Initial FocusIDREF="ch0787"Initial FocusIDREF="ch13268"Initial FocusIDREF="ch13269"Initial FocusIDREF="ch0786"Initial FocusIDREF="ch13272"Initial FocusIDREF="ch13273"Initial FocusIDREF="ch13274"Initial FocusXmNinitialStateIDREF="ch16131"IconsXmNinputIDREF="ch16206"Input FocusXmNinputCallbackIDREF="ch14180"Example of an Input ProcedureIDREF="ch1430"Event Handling and CallbacksIDREF="ch14163"Handling Input EventsIDREF="ch14165"Handling Input EventsIDREF="ch14170"Handling Input EventsIDREF="ch14173"Handling Input EventsIDREF="ch14175"Handling Input EventsIDREF="ch14213"Using a DrawingArea for GraphicsXmNinputMethodIDREF="ch11308"Input MethodXmNinvalidCursorForegroundIDREF="ch15482"State IconXmNisAlignedIDREF="ch10346"Managing Geometry Using RowColumnIDREF="ch0662"RowColumnIDREF="ch10369"Managing Geometry Using RowColumnXmNisHomogeneousIDREF="ch06236"RadioBox and CheckBoxIDREF="ch0660"RowColumnXmNkeyboardFocusPolicyIDREF="ch02219"Handling Input and OutputIDREF="ch13372"Focus CallbacksIDREF="ch13103"XmNtraversalOnIDREF="ch1332"Focus ModelsIDREF="ch0864"SelectionIDREF="ch1311"Input, Focus, and Keyboard NavigationIDREF="ch16212"Input FocusXmNlabelFontListIDREF="ch11102"Font List Resource DefaultsXmNlabelInsensitivePixmapIDREF="ch0642"ButtonsIDREF="ch1267"ForegroundsIDREF="ch1224"Default Colors and PixmapsXmNlabelPixmapIDREF="ch1223"Default Colors and PixmapsIDREF="ch1266"ForegroundsIDREF="ch0641"ButtonsXmNlabelStringIDREF="ch1138"Setting a Compound String ProgrammaticallyIDREF="ch1133"Compound Strings and ResourcesIDREF="ch06181"OptionMenuXmNlabelTypeIDREF="ch1264"ForegroundsIDREF="ch0596"ToggleButtonsIDREF="ch1298"Arming and SelectionIDREF="ch12108"Arming and SelectionXmNleftAttachmentIDREF="ch10452"Managing Geometry Using FormIDREF="ch10477"Managing Geometry Using FormIDREF="ch10492"Managing Geometry Using FormIDREF="ch10471"Managing Geometry Using FormIDREF="ch10488"Managing Geometry Using FormIDREF="ch10498"Managing Geometry Using FormXmNleftOffsetIDREF="ch10490"Managing Geometry Using FormIDREF="ch10474"Managing Geometry Using FormXmNleftPositionIDREF="ch10456"Managing Geometry Using FormIDREF="ch10480"Managing Geometry Using FormIDREF="ch10494"Managing Geometry Using FormXmNleftWidgetIDREF="ch10515"Managing Geometry Using FormXmNlightThresholdIDREF="ch12119"Arming and SelectionIDREF="ch1282"ShadowsIDREF="ch1280"ShadowsXmNlistSizePolicyIDREF="ch05191"ListXmNlosePrimaryCallbackIDREF="ch08133"Text Editing and CallbacksIDREF="ch08160"Text Editing and CallbacksXmNlosingFocusCallbackIDREF="ch08127"Text Editing and CallbacksIDREF="ch13364"Focus CallbacksIDREF="ch13355"XmProcessTraversalIDREF="ch13370"Focus CallbacksXmNmapCallbackIDREF="ch0679"RowColumnIDREF="ch0762"DialogShellIDREF="ch06267"TearOffMenusXmNmappedWhenManagedIDREF="ch03192"Realizing WidgetsIDREF="ch0757"DialogShellIDREF="ch03170"Managing WidgetsXmNmarginBottomIDREF="ch10336"Managing Geometry Using RowColumnXmNmarginHeightIDREF="ch09291"PanedWindowIDREF="ch10315"Managing Geometry Using RowColumnIDREF="ch08173"Text Resources and GeometryIDREF="ch10379"Managing Geometry Using BulletinBoard and DrawingAreaIDREF="ch09255"FrameIDREF="ch08223"Text Resources and GeometryIDREF="ch1420"DrawingArea: A General-Purpose WidgetIDREF="ch0725"BulletinBoardIDREF="ch10259"Manager Widgets and Their ChildrenXmNmarginLeftIDREF="ch10334"Managing Geometry Using RowColumnXmNmarginRightIDREF="ch10335"Managing Geometry Using RowColumnXmNmarginTopIDREF="ch10337"Managing Geometry Using RowColumnXmNmarginWidthIDREF="ch0726"BulletinBoardIDREF="ch09256"FrameIDREF="ch10380"Managing Geometry Using BulletinBoard and DrawingAreaIDREF="ch08174"Text Resources and GeometryIDREF="ch1421"DrawingArea: A General-Purpose WidgetIDREF="ch10260"Manager Widgets and Their ChildrenIDREF="ch10317"Managing Geometry Using RowColumnIDREF="ch09275"FrameIDREF="ch09292"PanedWindowXmNmaskIDREF="ch15509"Drag Icon Blending and AttachmentXmNmaxAspectXIDREF="ch1694"Window ConfigurationXmNmaxAspectYIDREF="ch1695"Window ConfigurationXmNmaxHeightIDREF="ch1675"Window ConfigurationIDREF="ch1665"Window ConfigurationIDREF="ch1687"Window ConfigurationXmNmaximumIDREF="ch05127"ScrollBarIDREF="ch0982"Automatic ScrollingIDREF="ch05125"ScrollBarIDREF="ch09185"Example of Application-Defined ScrollingIDREF="ch09168"Application-Defined ScrollingIDREF="ch09102"Automatic ScrollingIDREF="ch05131"ScrollBarIDREF="ch0996"Automatic ScrollingIDREF="ch09163"Application-Defined ScrollingXmNmaxLengthIDREF="ch08169"Text Resources and GeometryXmNmaxWidthIDREF="ch1679"Window ConfigurationIDREF="ch1691"Window ConfigurationIDREF="ch1666"Window ConfigurationXmNmenuAcceleratorIDREF="ch06147"PopupMenuXmNmenuBarIDREF="ch09230"MainWindowXmNmenuHelpWidgetIDREF="ch06116"MenuBarXmNmenuHistoryIDREF="ch0667"RowColumnIDREF="ch06202"OptionMenuXmNmenuPostIDREF="ch06136"PopupMenuIDREF="ch06144"PopupMenuIDREF="ch13469"Event HandlersXmNmessageWindowIDREF="ch09232"MainWindowIDREF="ch09238"MainWindowXmNminAspectXIDREF="ch1692"Window ConfigurationXmNminAspectYIDREF="ch1693"Window ConfigurationXmNminHeightIDREF="ch1661"Window ConfigurationIDREF="ch1674"Window ConfigurationIDREF="ch1686"Window ConfigurationIDREF="ch1680"Window ConfigurationXmNminimumIDREF="ch09170"Application-Defined ScrollingIDREF="ch05124"ScrollBarIDREF="ch05130"ScrollBarIDREF="ch09164"Application-Defined ScrollingIDREF="ch09183"Example of Application-Defined ScrollingIDREF="ch0983"Automatic ScrollingIDREF="ch09103"Automatic ScrollingIDREF="ch05128"ScrollBarXmNminWidthIDREF="ch1690"Window ConfigurationIDREF="ch1681"Window ConfigurationIDREF="ch1662"Window ConfigurationIDREF="ch1678"Window ConfigurationXmNmnemonicIDREF="ch13425"Mnemonics and AcceleratorsIDREF="ch06183"OptionMenuXmNmnemonicCharSetIDREF="ch06185"OptionMenuIDREF="ch06187"OptionMenuIDREF="ch13426"Mnemonics and AcceleratorsXmNmodifyVerifyCallbackIDREF="ch08155"Text Editing and CallbacksIDREF="ch08144"Text Editing and CallbacksIDREF="ch08116"Text Editing and CallbacksIDREF="ch08150"Text Editing and CallbacksXmNmodifyVerifyCallbackWcsIDREF="ch08156"Text Editing and CallbacksIDREF="ch08117"Text Editing and CallbacksIDREF="ch08145"Text Editing and CallbacksXmNmotionVerifyCallbackIDREF="ch08158"Text Editing and CallbacksIDREF="ch08113"Text Editing and CallbacksXmNmultipleSelectionCallbackIDREF="ch05174"ListXmNmustMatchIDREF="ch07118"Making a Selection: SelectionBoxXmNmwmDecorationsIDREF="ch16195"Menus and DialogsIDREF="ch16278"DecorationsXmNmwmFunctionsIDREF="ch16196"Menus and DialogsIDREF="ch16284"FunctionsIDREF="ch16288"FunctionsXmNmwmInputModeIDREF="ch16295"Input ModeXmNmwmMenuIDREF="ch16302"Window MenuXmNnavigationTypeIDREF="ch13322"XmProcessTraversalIDREF="ch13149"Tab GroupsIDREF="ch13164"Tab GroupsIDREF="ch13232"Tab GroupsIDREF="ch13330"XmProcessTraversalIDREF="ch13332"XmProcessTraversalIDREF="ch13192"Tab GroupsIDREF="ch13336"XmProcessTraversalIDREF="ch13338"XmProcessTraversalIDREF="ch13340"XmProcessTraversalIDREF="ch13239"Controlling Tab Group Traversal OrderIDREF="ch13243"Controlling Tab Group Traversal OrderIDREF="ch13344"XmProcessTraversalIDREF="ch13346"XmProcessTraversalIDREF="ch13348"XmProcessTraversalIDREF="ch13166"Tab GroupsIDREF="ch13246"Controlling Tab Group Traversal OrderIDREF="ch13139"Tab GroupsIDREF="ch13249"Controlling Tab Group Traversal OrderIDREF="ch13251"Controlling Tab Group Traversal OrderIDREF="ch13196"Tab GroupsIDREF="ch13254"Controlling Tab Group Traversal OrderIDREF="ch13152"Tab GroupsIDREF="ch13256"Controlling Tab Group Traversal OrderIDREF="ch13259"Controlling Tab Group Traversal OrderIDREF="ch13263"Controlling Tab Group Traversal OrderIDREF="ch13141"Tab GroupsIDREF="ch13201"Tab GroupsIDREF="ch13155"Tab GroupsIDREF="ch13205"Tab GroupsIDREF="ch13157"Tab GroupsIDREF="ch13181"Tab GroupsIDREF="ch13216"Tab GroupsIDREF="ch13145"Tab GroupsIDREF="ch13136"Tab GroupsIDREF="ch13184"Tab GroupsIDREF="ch13224"Tab GroupsIDREF="ch13302"XmProcessTraversalIDREF="ch13304"XmProcessTraversalIDREF="ch13226"Tab GroupsIDREF="ch13308"XmProcessTraversalIDREF="ch13310"XmProcessTraversalIDREF="ch13161"Tab GroupsIDREF="ch13314"XmProcessTraversalIDREF="ch13316"XmProcessTraversalIDREF="ch13228"Tab GroupsIDREF="ch13320"XmProcessTraversalXmNnoMatchCallbackIDREF="ch07117"Making a Selection: SelectionBoxXmNnoneCursorForegroundIDREF="ch15483"State IconXmNnoResizeIDREF="ch16290"FunctionsIDREF="ch0776"DialogShellXmNnumColumnsIDREF="ch10302"Managing Geometry Using RowColumnXmNnumDropTransfersIDREF="ch15657"Cancelling a DropIDREF="ch15616"XmNdropProcIDREF="ch15635"XmDropTransferIDREF="ch15636"XmDropTransferXmNnumExportTargetsIDREF="ch15144"TargetsIDREF="ch15148"TargetsXmNnumImportTargetsIDREF="ch15152"TargetsIDREF="ch15156"TargetsXmNO_DROP_SITEIDREF="ch15575"Drag CallbacksIDREF="ch15175"Drop Site StatusXmNoffsetXIDREF="ch15504"Drag Icon Blending and AttachmentXmNoffsetYIDREF="ch15505"Drag Icon Blending and AttachmentXmNokCallbackIDREF="ch07113"Making a Selection: SelectionBoxXmNONEIDREF="ch13211"Tab GroupsIDREF="ch13229"Tab GroupsIDREF="ch13217"Tab GroupsIDREF="ch13197"Tab GroupsIDREF="ch13138"Tab GroupsXmNoperationChangedCallbackIDREF="ch15546"Drag CallbacksIDREF="ch15540"Drag CallbacksXmNoperationCursorIconIDREF="ch15491"Operation IconXmNorientationIDREF="ch10286"Managing Geometry Using RowColumnIDREF="ch10294"Managing Geometry Using RowColumnXmNoverrideRedirectIDREF="ch16174"Menus and DialogsXmNpackingIDREF="ch10298"Managing Geometry Using RowColumnIDREF="ch10361"Managing Geometry Using RowColumnIDREF="ch10324"Managing Geometry Using RowColumnIDREF="ch10292"Managing Geometry Using RowColumnIDREF="ch10287"Managing Geometry Using RowColumnIDREF="ch10309"Managing Geometry Using RowColumnXmNpageIncrementIDREF="ch09162"Application-Defined ScrollingIDREF="ch09174"Application-Defined ScrollingIDREF="ch0979"Automatic ScrollingIDREF="ch09107"Automatic ScrollingIDREF="ch05148"ScaleIDREF="ch14209"Using a DrawingArea in a ScrolledWindowIDREF="ch05134"ScrollBarXmNpaneMaximumIDREF="ch09320"PanedWindowIDREF="ch09309"PanedWindowIDREF="ch09313"PanedWindowXmNpaneMinimumIDREF="ch09312"PanedWindowIDREF="ch09321"PanedWindowIDREF="ch09310"PanedWindowXmNpendingDeleteIDREF="ch0876"SelectionXmNpixmapIDREF="ch15508"Drag Icon Blending and AttachmentIDREF="ch15507"Drag Icon Blending and AttachmentXmNpopupEnabledIDREF="ch06150"PopupMenuIDREF="ch06148"PopupMenuXmNpositionIndexIDREF="ch09315"PanedWindowXmNpreeditTypeIDREF="ch11324"Input and the Motif Text WidgetIDREF="ch11302"Input MethodIDREF="ch11317"Input ManagerXmNprocessingDirectionIDREF="ch05135"ScrollBarXmNpushButtonEnabledIDREF="ch05103"DrawnButtonsXmNqualifySearchDataProcIDREF="ch07152"Choosing a Pathname: FileSelectionBoxXmNradioAlwaysOneIDREF="ch06229"RadioBox and CheckBoxIDREF="ch06241"RadioBox and CheckBoxXmNradioBehaviorIDREF="ch06252"RadioBox and CheckBoxIDREF="ch06223"RadioBox and CheckBoxIDREF="ch06231"RadioBox and CheckBoxIDREF="ch06240"RadioBox and CheckBoxIDREF="ch0672"RowColumnIDREF="ch06248"RadioBox and CheckBoxXmNrecomputeSizeIDREF="ch0545"LabelsXmNrefigureModeIDREF="ch09304"PanedWindowXmNresizableIDREF="ch10513"Managing Geometry Using FormIDREF="ch10412"Managing Geometry Using FormIDREF="ch10500"Managing Geometry Using FormIDREF="ch10408"Managing Geometry Using FormIDREF="ch10409"Managing Geometry Using FormXmNresizeCallbackIDREF="ch1440"Event Handling and CallbacksIDREF="ch1489"Moving and Resizing ChildrenIDREF="ch1490"Moving and Resizing ChildrenIDREF="ch05105"DrawnButtonsIDREF="ch1451"Handling Resize EventsIDREF="ch09205"Example of Application-Defined ScrollingIDREF="ch14206"Using a DrawingArea in a ScrolledWindowIDREF="ch1497"Moving and Resizing ChildrenIDREF="ch14108"Resizing and RedisplayIDREF="ch14109"Resizing and RedisplayIDREF="ch09159"Application-Defined ScrollingIDREF="ch14118"Example of a Resize ProcedureIDREF="ch09192"Example of Application-Defined ScrollingIDREF="ch1475"Moving and Resizing ChildrenIDREF="ch14143"Handling Exposure EventsIDREF="ch1459"Moving and Resizing ChildrenIDREF="ch09152"Application-Defined ScrollingIDREF="ch1433"Event Handling and CallbacksIDREF="ch1480"Moving and Resizing ChildrenXmNresizeHeightIDREF="ch10307"Managing Geometry Using RowColumnIDREF="ch08200"Text Resources and GeometryIDREF="ch08183"Text Resources and GeometryIDREF="ch10319"Managing Geometry Using RowColumnIDREF="ch08220"Text Resources and GeometryIDREF="ch08221"Text Resources and GeometryIDREF="ch08214"Text Resources and GeometryIDREF="ch10297"Managing Geometry Using RowColumnIDREF="ch08225"Text Resources and GeometryIDREF="ch10265"Manager Widgets and Their ChildrenIDREF="ch08208"Text Resources and GeometryIDREF="ch08187"Text Resources and GeometryXmNresizePolicyIDREF="ch10381"Managing Geometry Using BulletinBoard and DrawingAreaIDREF="ch1410"DrawingArea: A General-Purpose WidgetIDREF="ch0727"BulletinBoardIDREF="ch1470"Moving and Resizing ChildrenIDREF="ch14190"Using a DrawingArea in a ScrolledWindowXmNresizeWidthIDREF="ch10266"Manager Widgets and Their ChildrenIDREF="ch08197"Text Resources and GeometryIDREF="ch08222"Text Resources and GeometryIDREF="ch10306"Managing Geometry Using RowColumnIDREF="ch08184"Text Resources and GeometryIDREF="ch08227"Text Resources and GeometryIDREF="ch10321"Managing Geometry Using RowColumnIDREF="ch08217"Text Resources and GeometryIDREF="ch08211"Text Resources and GeometryXmNrightAttachmentIDREF="ch10453"Managing Geometry Using FormXmNrightPositionIDREF="ch10457"Managing Geometry Using FormXmNrightWidgetIDREF="ch10516"Managing Geometry Using FormXmNrowsIDREF="ch10257"Manager Widgets and Their ChildrenIDREF="ch08212"Text Resources and GeometryIDREF="ch08204"Text Resources and GeometryIDREF="ch08206"Text Resources and GeometryIDREF="ch08179"Text Resources and GeometryIDREF="ch08226"Text Resources and GeometryXmNrubberPositioningIDREF="ch10491"Managing Geometry Using FormIDREF="ch10467"Managing Geometry Using FormIDREF="ch10486"Managing Geometry Using FormIDREF="ch10487"Managing Geometry Using FormXmNsashHeightIDREF="ch09298"PanedWindowXmNsashIndentIDREF="ch09299"PanedWindowXmNsashShadowThicknessIDREF="ch09301"PanedWindowXmNsashWidthIDREF="ch09302"PanedWindowXmNscaleMultipleIDREF="ch05147"ScaleXmNscreenIDREF="ch03216"Multiple Screens, Displays, and ApplicationsXmNscrollBarDisplayPolicyIDREF="ch0985"Automatic ScrollingIDREF="ch08240"ScrolledTextIDREF="ch0940"Other ResourcesXmNscrollBarPlacementIDREF="ch0947"Other ResourcesXmNscrolledWindowMarginHeightIDREF="ch0954"Other ResourcesXmNscrolledWindowMarginWidthIDREF="ch0956"Other ResourcesXmNscrollHorizontalIDREF="ch08190"Text Resources and GeometryIDREF="ch08198"Text Resources and GeometryXmNscrollingPolicyIDREF="ch13113"XmNtraversalOnIDREF="ch0934"Other ResourcesIDREF="ch08236"ScrolledTextIDREF="ch0913"Automatic and Application-Defined ScrollingIDREF="ch0924"Other ResourcesIDREF="ch0929"Other ResourcesIDREF="ch13284"Traversing to Obscured WidgetsIDREF="ch1367"Controlling Keyboard NavigationIDREF="ch09243"MainWindowIDREF="ch0917"Other ResourcesIDREF="ch0966"Automatic ScrollingXmNscrollLeftSideIDREF="ch08193"Text Resources and GeometryXmNscrollTopSideIDREF="ch08194"Text Resources and GeometryXmNscrollVerticalIDREF="ch08192"Text Resources and GeometryIDREF="ch08201"Text Resources and GeometryXmNselectColorIDREF="ch12115"Arming and SelectionIDREF="ch12102"Arming and SelectionXmNselectInsensitivePixmapIDREF="ch1244"Default Colors and PixmapsIDREF="ch12111"Arming and SelectionXmNselectPixmapIDREF="ch12107"Arming and SelectionIDREF="ch1242"Default Colors and PixmapsXmNsensitiveIDREF="ch1338"Focus ModelsIDREF="ch1389"SensitivityIDREF="ch1383"SensitivityIDREF="ch1393"SensitivityIDREF="ch1363"Controlling Keyboard NavigationIDREF="ch1386"SensitivityXmNseparatorOnIDREF="ch09294"PanedWindowXmNshadowThicknessIDREF="ch05107"DrawnButtonsIDREF="ch14115"Resizing and RedisplayIDREF="ch10264"Manager Widgets and Their ChildrenIDREF="ch08242"ScrolledTextXmNshadowTypeIDREF="ch09254"FrameXmNshowSeparatorIDREF="ch09219"MainWindowXmNsingleSelectionCallbackIDREF="ch05172"ListXmNskipAdjustIDREF="ch09318"PanedWindowXmNsliderSizeIDREF="ch0984"Automatic ScrollingIDREF="ch09186"Example of Application-Defined ScrollingIDREF="ch05126"ScrollBarIDREF="ch09166"Application-Defined ScrollingIDREF="ch09193"Example of Application-Defined ScrollingIDREF="ch14208"Using a DrawingArea in a ScrolledWindowIDREF="ch09169"Application-Defined ScrollingIDREF="ch05132"ScrollBarIDREF="ch09173"Application-Defined ScrollingXmNsourceIDREF="ch08248"Sharing Text SourcesIDREF="ch08254"Sharing Text SourcesXmNsourceCursorIconIDREF="ch15513"Drag Icon Blending and AttachmentIDREF="ch15276"Protocols and VisualsIDREF="ch15465"Source IconXmNsourcePixmapIconIDREF="ch15464"Source IconIDREF="ch15273"Protocols and VisualsXmNspacingIDREF="ch09296"PanedWindowIDREF="ch0958"Other ResourcesIDREF="ch10323"Managing Geometry Using RowColumnXmNstateCursorIconIDREF="ch15478"State IconXmNstringDirectionIDREF="ch05188"ListIDREF="ch09271"FrameIDREF="ch0544"LabelsIDREF="ch10469"Managing Geometry Using FormIDREF="ch09268"FrameXmNsubMenuIdIDREF="ch0564"CascadeButtonsIDREF="ch06120"MenuBarIDREF="ch06156"PulldownMenuIDREF="ch06189"OptionMenuXmNtearOffMenuActivateCallbackIDREF="ch06266"TearOffMenusXmNtearOffMenuDeactivate\CallbackIDREF="ch06268"TearOffMenusXmNtearOffModelIDREF="ch06264"TearOffMenusXmNtextAcceleratorsIDREF="ch13447"Mnemonics and AcceleratorsIDREF="ch07104"Making a Selection: SelectionBoxXmNtextFontListIDREF="ch11103"Font List Resource DefaultsXmNtitleIDREF="ch1616"Application StartupXmNtitleEncodingIDREF="ch1617"Application StartupIDREF="ch1622"Application StartupXmNtopAttachmentIDREF="ch10414"Managing Geometry Using FormIDREF="ch10472"Managing Geometry Using FormIDREF="ch10446"Managing Geometry Using FormIDREF="ch10478"Managing Geometry Using FormIDREF="ch10459"Managing Geometry Using FormIDREF="ch10441"Managing Geometry Using FormXmNtopLevelEnterCallbackIDREF="ch15526"Visual Style NotesIDREF="ch15543"Drag CallbacksIDREF="ch15521"Visual Style NotesXmNtopLevelLeaveCallbackIDREF="ch15544"Drag CallbacksXmNtopOffsetIDREF="ch10475"Managing Geometry Using FormIDREF="ch10422"Managing Geometry Using FormIDREF="ch10439"Managing Geometry Using FormXmNtopPositionIDREF="ch10437"Managing Geometry Using FormIDREF="ch10482"Managing Geometry Using FormIDREF="ch10440"Managing Geometry Using FormIDREF="ch10433"Managing Geometry Using FormIDREF="ch10463"Managing Geometry Using FormXmNtopShadowColorIDREF="ch1273"ShadowsIDREF="ch1276"ShadowsIDREF="ch1229"Default Colors and PixmapsIDREF="ch12126"Application-Defined Color GenerationXmNtopShadowPixmapIDREF="ch1230"Default Colors and PixmapsXmNtopWidgetIDREF="ch10424"Managing Geometry Using FormIDREF="ch10425"Managing Geometry Using FormIDREF="ch10430"Managing Geometry Using FormIDREF="ch10445"Managing Geometry Using FormXmNtransferProcIDREF="ch15229"Overview of Programmer ResponsibilitiesIDREF="ch15632"XmDropTransferIDREF="ch15639"XmDropTransferIDREF="ch15640"XmDropTransferIDREF="ch1586"Drop ProtocolIDREF="ch1589"Drop ProtocolIDREF="ch15649"Processing Each OperationIDREF="ch15655"Cancelling a DropIDREF="ch1585"Drop ProtocolIDREF="ch1593"Drop ProtocolIDREF="ch15713"Dealing with Requests for TransferIDREF="ch15716"XmNdropFinishCallbackIDREF="ch15289"Drop ProtocolIDREF="ch15597"Drop Receiver Responsibilities for DroppingIDREF="ch15617"XmNdropProcIDREF="ch15299"Drop ProtocolIDREF="ch15225"Overview of Programmer ResponsibilitiesXmNtransferStatusIDREF="ch1595"Drop ProtocolIDREF="ch1592"Drop ProtocolIDREF="ch15619"XmNdropProcIDREF="ch15658"Cancelling a DropXmNtransientIDREF="ch16188"Menus and DialogsIDREF="ch16186"Menus and DialogsXmNtransientForIDREF="ch16182"Menus and DialogsIDREF="ch16189"Menus and DialogsXmNtranslationsIDREF="ch13384"Using TranslationsIDREF="ch13442"Mnemonics and AcceleratorsIDREF="ch13385"Using TranslationsIDREF="ch13397"Using TranslationsIDREF="ch13387"Using TranslationsIDREF="ch13388"Using TranslationsIDREF="ch13390"Using TranslationsIDREF="ch13391"Using TranslationsIDREF="ch13381"Using TranslationsIDREF="ch13393"Using TranslationsIDREF="ch13382"Using TranslationsXmNtraversalOnIDREF="ch13109"XmNtraversalOnIDREF="ch16216"Input FocusIDREF="ch13111"XmNtraversalOnIDREF="ch13117"XmNtraversalOnIDREF="ch13120"XmNtraversalOnIDREF="ch13271"Initial FocusIDREF="ch1365"Controlling Keyboard NavigationIDREF="ch1340"Focus ModelsIDREF="ch1371"Controlling Keyboard NavigationIDREF="ch13106"XmNtraversalOnXmNtraverseObscuredCallbackIDREF="ch09117"Traversing to Obscured WidgetsIDREF="ch09124"Traversing to Obscured WidgetsIDREF="ch09140"Example of Automatic ScrollingIDREF="ch1381"Controlling Keyboard NavigationIDREF="ch13290"Traversing to Obscured WidgetsIDREF="ch13292"Traversing to Obscured WidgetsIDREF="ch1369"Controlling Keyboard NavigationIDREF="ch13294"Traversing to Obscured WidgetsXmNtroughColorIDREF="ch12113"Arming and SelectionIDREF="ch12116"Arming and SelectionIDREF="ch1245"Default Colors and PixmapsXmNunmapCallbackIDREF="ch0763"DialogShellIDREF="ch06269"TearOffMenusIDREF="ch0680"RowColumnXmNuseAsyncGeometryIDREF="ch16114"Window ConfigurationXmNvalidCursorForegroundIDREF="ch15481"State IconXmNvalueIDREF="ch05129"ScrollBarIDREF="ch09104"Automatic ScrollingIDREF="ch08166"Text Resources and GeometryIDREF="ch08163"Text Resources and GeometryIDREF="ch0991"Automatic ScrollingIDREF="ch0995"Automatic ScrollingIDREF="ch0997"Automatic ScrollingIDREF="ch09165"Application-Defined ScrollingIDREF="ch09171"Application-Defined ScrollingIDREF="ch09184"Example of Application-Defined ScrollingIDREF="ch08218"Text Resources and GeometryIDREF="ch09191"Example of Application-Defined ScrollingIDREF="ch10267"Manager Widgets and Their ChildrenXmNvalueChangedCallbackIDREF="ch09157"Application-Defined ScrollingIDREF="ch09188"Example of Application-Defined ScrollingIDREF="ch09202"Example of Application-Defined ScrollingIDREF="ch05137"ScrollBarIDREF="ch08157"Text Editing and CallbacksIDREF="ch08121"Text Editing and CallbacksIDREF="ch05149"ScaleIDREF="ch0589"ToggleButtonsIDREF="ch0650"ButtonsIDREF="ch0670"RowColumnXmNvalueWcsIDREF="ch08219"Text Resources and GeometryIDREF="ch08164"Text Resources and GeometryXmNverticalScrollBarIDREF="ch0931"Other ResourcesIDREF="ch0975"Automatic ScrollingXmNverticalSpacingIDREF="ch10483"Managing Geometry Using FormXmNvisibleItemCountIDREF="ch05186"ListXmNvisibleWhenOffIDREF="ch0674"RowColumnIDREF="ch06228"RadioBox and CheckBoxIDREF="ch0591"ToggleButtonsIDREF="ch06255"RadioBox and CheckBoxXmNvisualPolicyIDREF="ch08238"ScrolledTextXmNwaitForWmIDREF="ch16117"Window ConfigurationXmNwidthIDREF="ch1650"Window ConfigurationIDREF="ch1654"Window ConfigurationIDREF="ch1656"Window ConfigurationIDREF="ch14195"Using a DrawingArea in a ScrolledWindowIDREF="ch08216"Text Resources and GeometryIDREF="ch10240"Shells and Their ChildrenIDREF="ch0699"MenuShellIDREF="ch1418"DrawingArea: A General-Purpose WidgetIDREF="ch1010"Managing GeometryIDREF="ch0769"DialogShellIDREF="ch10383"Managing Geometry Using BulletinBoard and DrawingAreaIDREF="ch1029"Widget Class ProceduresIDREF="ch1249"BordersIDREF="ch08203"Text Resources and GeometryIDREF="ch0970"Automatic ScrollingIDREF="ch1466"Moving and Resizing ChildrenIDREF="ch1637"Window ConfigurationIDREF="ch1644"Window ConfigurationIDREF="ch08210"Text Resources and GeometryIDREF="ch10413"Managing Geometry Using FormXmNwidthIncIDREF="ch1689"Window ConfigurationIDREF="ch1677"Window ConfigurationIDREF="ch1683"Window ConfigurationXmNwindowGroupIDREF="ch16168"Window GroupsIDREF="ch16187"Menus and DialogsXmNwinGravityIDREF="ch1696"Window ConfigurationIDREF="ch16100"Window ConfigurationIDREF="ch1698"Window ConfigurationXmNwmTimeoutIDREF="ch16118"Window ConfigurationXmNwordWrapIDREF="ch08199"Text Resources and GeometryIDREF="ch08170"Text Resources and GeometryXmNworkWindowIDREF="ch0936"Other ResourcesXmNxIDREF="ch0999"Automatic ScrollingIDREF="ch1634"Window ConfigurationIDREF="ch06101"MenuShellIDREF="ch1648"Window ConfigurationIDREF="ch0766"DialogShellIDREF="ch10510"Managing Geometry Using FormIDREF="ch14193"Using a DrawingArea in a ScrolledWindowIDREF="ch1463"Moving and Resizing ChildrenIDREF="ch1027"Widget Class ProceduresIDREF="ch10242"Shells and Their ChildrenIDREF="ch108"Managing GeometryXmNyIDREF="ch109"Managing GeometryIDREF="ch06102"MenuShellIDREF="ch09100"Automatic ScrollingIDREF="ch10243"Shells and Their ChildrenIDREF="ch1028"Widget Class ProceduresIDREF="ch1464"Moving and Resizing ChildrenIDREF="ch14194"Using a DrawingArea in a ScrolledWindowIDREF="ch1635"Window ConfigurationIDREF="ch1649"Window ConfigurationIDREF="ch0767"DialogShellXmONE_OF_MANYIDREF="ch06227"RadioBox and CheckBoxXmOptionButtonGadgetIDREF="ch06197"OptionMenuXmOptionLabelGadgetIDREF="ch06196"OptionMenuXMoveWindowIDREF="ch10212"Exposure and RedisplayXmPACK_COLUMNIDREF="ch10362"Managing Geometry Using RowColumnIDREF="ch10326"Managing Geometry Using RowColumnIDREF="ch10311"Managing Geometry Using RowColumnIDREF="ch10300"Managing Geometry Using RowColumnXmPACK_NONEIDREF="ch10305"Managing Geometry Using RowColumnXmPACK_TIGHTIDREF="ch10363"Managing Geometry Using RowColumnIDREF="ch10325"Managing Geometry Using RowColumnIDREF="ch10293"Managing Geometry Using RowColumnIDREF="ch10310"Managing Geometry Using RowColumnXmPanedWindowIDREF="ch01177"ManagersXmPIXMAPIDREF="ch0597"ToggleButtonsIDREF="ch1299"Arming and SelectionIDREF="ch12109"Arming and SelectionIDREF="ch1265"ForegroundsIDREF="ch0640"ButtonsXmPOINTERIDREF="ch13373"Focus CallbacksIDREF="ch1341"Focus ModelsIDREF="ch13105"XmNtraversalOnIDREF="ch0866"SelectionXmPrimitiveIDREF="ch01137"Primitives and GadgetsIDREF="ch0531"XmGadgetIDREF="ch01139"Primitives and GadgetsIDREF="ch01134"Primitives and GadgetsIDREF="ch0229"Building Blocks: Primitive Widgets and GadgetsIDREF="ch0232"Building Blocks: Primitive Widgets and GadgetsIDREF="ch0241"Building Blocks: Primitive Widgets and GadgetsIDREF="ch0246"Building Blocks: Primitive Widgets and GadgetsIDREF="ch053"Basic ControlsXmProcessTraversalIDREF="ch13299"XmProcessTraversalIDREF="ch13300"XmProcessTraversalIDREF="ch1321"Input, Focus, and Keyboard NavigationIDREF="ch13351"XmProcessTraversalIDREF="ch09120"Traversing to Obscured WidgetsIDREF="ch13353"XmProcessTraversalIDREF="ch13361"Focus CallbacksIDREF="ch13296"XmProcessTraversalIDREF="ch16217"Input FocusXmPushButtonIDREF="ch07102"Making a Selection: SelectionBoxIDREF="ch07185"MessageBoxIDREF="ch10402"Managing Geometry Using BulletinBoard and DrawingAreaIDREF="ch01152"Primitives and GadgetsXmRegisterSegmentEncodingIDREF="ch11348"Compound Strings and Compound TextXmRemoveProtocolCallbackIDREF="ch16340"Atom and Protocol ManagementXmRemoveProtocolsIDREF="ch16341"Atom and Protocol ManagementXmRemoveTabGroupIDREF="ch13199"Tab GroupsIDREF="ch13194"Tab GroupsXmRemoveWMProtocolCallbackIDREF="ch16342"Atom and Protocol ManagementXmRemoveWMProtocolsIDREF="ch16343"Atom and Protocol ManagementXmRESIZE_ANYIDREF="ch10386"Managing Geometry Using BulletinBoard and DrawingAreaIDREF="ch1472"Moving and Resizing ChildrenIDREF="ch14191"Using a DrawingArea in a ScrolledWindowIDREF="ch1411"DrawingArea: A General-Purpose WidgetXmRESIZE_GROWIDREF="ch10385"Managing Geometry Using BulletinBoard and DrawingAreaIDREF="ch1471"Moving and Resizing ChildrenIDREF="ch1413"DrawingArea: A General-Purpose WidgetXmRESIZE_NONEIDREF="ch1415"DrawingArea: A General-Purpose WidgetIDREF="ch10382"Managing Geometry Using BulletinBoard and DrawingAreaXmRowColumnIDREF="ch01185"ManagersXmScaleIDREF="ch059"Basic ControlsIDREF="ch01175"ManagersXmScaleGetValueIDREF="ch05152"ScaleXmScaleSetValueIDREF="ch05153"ScaleXmScreenIDREF="ch15456"Drag-Over Visual EffectsIDREF="ch15458"Drag-Over Visual EffectsIDREF="ch15460"Drag-Over Visual EffectsIDREF="ch15466"Source IconIDREF="ch15479"State IconIDREF="ch15492"Operation IconIDREF="ch15510"Drag Icon Blending and AttachmentIDREF="ch15525"Visual Style NotesIDREF="ch15253"Choosing the Protocol and Visual StyleIDREF="ch01203"Other Motif ClassesIDREF="ch1269"ForegroundsIDREF="ch1599"Drag and Drop Widget ClassesIDREF="ch1277"ShadowsIDREF="ch12117"Arming and SelectionIDREF="ch15247"The Preregister Drag ProtocolIDREF="ch15452"Drag-Over Visual EffectsIDREF="ch15453"Drag-Over Visual EffectsXmScrollBarIDREF="ch01155"Primitives and GadgetsXmScrollBarGetValuesIDREF="ch05141"ScrollBarXmScrollBarSetValuesIDREF="ch05142"ScrollBarXmScrolledWindowIDREF="ch01179"ManagersXmScrolledWindowSetAreasIDREF="ch0921"Other ResourcesXmScrollVisibleIDREF="ch13293"Traversing to Obscured WidgetsIDREF="ch09121"Traversing to Obscured WidgetsXmSelectionBoxGetChildIDREF="ch07143"Making a Selection: SelectionBoxXmSeparatorIDREF="ch01141"Primitives and GadgetsXmSetColorCalculationIDREF="ch12150"Application-Defined Color GenerationIDREF="ch12132"Application-Defined Color GenerationIDREF="ch12133"Application-Defined Color GenerationIDREF="ch12135"Application-Defined Color GenerationXmSetProtocolHooksIDREF="ch16332"Atom and Protocol ManagementXmSetWMProtocolHooksIDREF="ch16333"Atom and Protocol ManagementXmSTATICIDREF="ch0944"Other ResourcesIDREF="ch08241"ScrolledTextIDREF="ch0989"Automatic ScrollingXmSTICKY_TAB_GROUPIDREF="ch13350"XmProcessTraversalIDREF="ch13150"Tab GroupsIDREF="ch13235"Tab GroupsIDREF="ch13245"Controlling Tab Group Traversal OrderIDREF="ch13248"Controlling Tab Group Traversal OrderIDREF="ch13253"Controlling Tab Group Traversal OrderIDREF="ch13183"Tab GroupsIDREF="ch13264"Controlling Tab Group Traversal OrderIDREF="ch13187"Tab GroupsIDREF="ch13189"Tab GroupsIDREF="ch13163"Tab GroupsIDREF="ch13154"Tab GroupsIDREF="ch13168"Tab GroupsIDREF="ch13159"Tab GroupsIDREF="ch13170"Tab GroupsIDREF="ch13223"Tab GroupsIDREF="ch13342"XmProcessTraversalIDREF="ch13179"Tab GroupsXmStringIDREF="ch11211"Resources and LocalizationIDREF="ch1134"Compound Strings and ResourcesXmSTRING_DEFAULT_\CHARSETIDREF="ch11152"Compound Strings and Font ListsXmSTRING_DIRECTION_L_\TO_RIDREF="ch09269"FrameIDREF="ch09272"FrameXmStringBaselineIDREF="ch14234"Text OutputXmStringCreateIDREF="ch11207"Localization Without LocalesIDREF="ch1135"Setting a Compound String ProgrammaticallyIDREF="ch11162"Compound Strings and Font ListsXmStringCreateLocalizedIDREF="ch11194"Using LocalesIDREF="ch1136"Setting a Compound String ProgrammaticallyIDREF="ch1140"Setting a Compound String ProgrammaticallyIDREF="ch11161"Compound Strings and Font ListsXmStringCreateLtoRIDREF="ch11163"Compound Strings and Font ListsXmStringDrawImageIDREF="ch14221"Text OutputXmStringExtentIDREF="ch14231"Text OutputXmStringFreeIDREF="ch03136"Resource Values and Memory ManagementXmStringHeightIDREF="ch14232"Text OutputXmStringTableIDREF="ch03132"Resource Values and Memory ManagementXmStringWidthIDREF="ch14233"Text OutputXmTAB_GROUPIDREF="ch13167"Tab GroupsIDREF="ch13169"Tab GroupsIDREF="ch13182"Tab GroupsIDREF="ch13146"Tab GroupsIDREF="ch13137"Tab GroupsIDREF="ch13202"Tab GroupsIDREF="ch13210"Tab GroupsIDREF="ch13221"Tab GroupsIDREF="ch13227"Tab GroupsIDREF="ch13230"Tab GroupsXmTargetsAreCompatibleIDREF="ch15214"Overview of Programmer ResponsibilitiesIDREF="ch15404"Simulating Nested Drop SitesIDREF="ch15139"Drag and Drop FunctionsXmTEAR_OFF_ENABLEDIDREF="ch06265"TearOffMenusXmTextIDREF="ch10359"Managing Geometry Using RowColumnIDREF="ch01159"Primitives and GadgetsXmTextBlockRecIDREF="ch08148"Text Editing and CallbacksIDREF="ch08111"Text Editing and CallbacksXmTextBlockRecWcsIDREF="ch08112"Text Editing and CallbacksIDREF="ch08149"Text Editing and CallbacksXmTextFieldIDREF="ch01161"Primitives and GadgetsIDREF="ch10360"Managing Geometry Using RowColumnXmTextGetSourceIDREF="ch08252"Sharing Text SourcesXmTextPositionIDREF="ch08168"Text Resources and GeometryXmTextSetSourceIDREF="ch08255"Sharing Text SourcesXmTextVerifyCallbackStructIDREF="ch08115"Text Editing and CallbacksIDREF="ch13367"Focus CallbacksIDREF="ch08119"Text Editing and CallbacksIDREF="ch08109"Text Editing and CallbacksIDREF="ch08129"Text Editing and CallbacksIDREF="ch08146"Text Editing and CallbacksXmTextVerifyCallbackStructWcsIDREF="ch08120"Text Editing and CallbacksIDREF="ch08147"Text Editing and CallbacksIDREF="ch08110"Text Editing and CallbacksXmToggleButtonIDREF="ch01153"Primitives and GadgetsIDREF="ch10403"Managing Geometry Using BulletinBoard and DrawingAreaXmToggleButtonCallbackStructIDREF="ch03145"Adding Callback ProceduresXmTOP_LEFTIDREF="ch0950"Other ResourcesXmTOP_RIGHTIDREF="ch0951"Other ResourcesXmTRANSFER_FAILUREIDREF="ch15659"Cancelling a DropXmTRANSFER_SUCCESSIDREF="ch15620"XmNdropProcXmTranslateKeyIDREF="ch13410"Bindings for osf KeysymsXmTRAVERSE_CURRENTIDREF="ch13352"XmProcessTraversalXmTRAVERSE_DOWNIDREF="ch13313"XmProcessTraversalXmTRAVERSE_HOMEIDREF="ch13329"XmProcessTraversalXmTRAVERSE_LEFTIDREF="ch13307"XmProcessTraversalXmTRAVERSE_NEXTIDREF="ch13325"XmProcessTraversalXmTRAVERSE_NEXT_TAB_\GROUPIDREF="ch13335"XmProcessTraversalXmTRAVERSE_PREVIDREF="ch13327"XmProcessTraversalXmTRAVERSE_PREV_TAB_\GROUPIDREF="ch13343"XmProcessTraversalXmTRAVERSE_RIGHTIDREF="ch13301"XmProcessTraversalXmTRAVERSE_UPIDREF="ch13319"XmProcessTraversalXmTraverseObscuredCallbackStructIDREF="ch09118"Traversing to Obscured WidgetsXmUninstallImageIDREF="ch12175"Using PixmapsXmUNSPECIFIED_PIXMAPIDREF="ch12165"Using PixmapsXmVaCreateSimpleMenuBarIDREF="ch06124"MenuBarXmVARIABLEIDREF="ch08189"Text Resources and GeometryIDREF="ch08239"ScrolledTextXmVERTICALIDREF="ch10295"Managing Geometry Using RowColumnIDREF="ch10303"Managing Geometry Using RowColumnIDREF="ch10289"Managing Geometry Using RowColumnXmVISIBILITY_FULLY_\OBSCUREDIDREF="ch1377"Controlling Keyboard NavigationXmVISIBILITY_PARTIALLY_\OBSCUREDIDREF="ch1378"Controlling Keyboard NavigationXmVISIBILITY_UNOBSCUREDIDREF="ch1379"Controlling Keyboard NavigationxnlLanguageIDREF="ch11227"Resource File LocationsIDREF="ch0339"File Search PathsIDREF="ch11185"Establishing the Language EnvironmentIDREF="ch11188"Establishing the Language EnvironmentIDREF="ch11173"Establishing the Language EnvironmentIDREF="ch11179"Establishing the Language EnvironmentXOpenDisplayIDREF="ch0315"Initializing the IntrinsicsXQueryBestSizeIDREF="ch15275"Protocols and VisualsxrdbIDREF="ch0357"Server or User-Preference ResourcesIDREF="ch0354"Screen-Specific ResourcesXrmIDREF="ch0135"XlibXrmParseCommandIDREF="ch0343"Command-Line SpecificationsXSetInputFocusIDREF="ch16220"Input FocusXSetLocaleModifiersIDREF="ch11182"Establishing the Language EnvironmentXSetWMColormapWindowsIDREF="ch16233"ColormapsXStdICCTextStyleIDREF="ch1625"Application StartupIDREF="ch16141"IconsXStringWidthIDREF="ch14236"Text OutputXSupportsLocaleIDREF="ch11181"Establishing the Language EnvironmentXtIDREF="ch16411"The Xt Selection InterfaceIDREF="ch01106"Using Xlib, Xt, and MotifIDREF="ch035"Initializing the IntrinsicsIDREF="ch04131"Initializing the IntrinsicsIDREF="ch0146"XtXtActionProcIDREF="ch13407"ActionsXtAddCallbackIDREF="ch03151"Adding Callback ProceduresXtAddCallbacksIDREF="ch03152"Adding Callback ProceduresXtAddEventHandlerIDREF="ch13465"Event HandlersIDREF="ch13462"Event HandlersIDREF="ch06137"PopupMenuXtAddExposureToRegionIDREF="ch14140"Handling Exposure EventsXtAppAddActionsIDREF="ch15444"Overriding Existing Drag SourcesIDREF="ch13403"ActionsIDREF="ch13404"ActionsIDREF="ch13405"ActionsIDREF="ch13406"ActionsXtAppContextIDREF="ch0311"Initializing the IntrinsicsXtAppCreateShellIDREF="ch02195"ApplicationsIDREF="ch04187"Fetching Information from UID FilesIDREF="ch03220"Multiple Screens, Displays, and ApplicationsIDREF="ch03209"Multiple Screens, Displays, and ApplicationsIDREF="ch03213"Multiple Screens, Displays, and ApplicationsIDREF="ch0319"Initializing the IntrinsicsIDREF="ch0376"Creating WidgetsIDREF="ch12155"ColormapsXtAppGetSelectionTimeoutIDREF="ch16427"The Xt Selection InterfaceXtAppInitializeIDREF="ch0325"The Initial Resource DatabaseIDREF="ch02196"ApplicationsIDREF="ch02173"VendorShellIDREF="ch0318"Initializing the IntrinsicsIDREF="ch11178"Establishing the Language EnvironmentIDREF="ch12154"ColormapsIDREF="ch04186"Fetching Information from UID FilesIDREF="ch0334"File Search PathsIDREF="ch0320"Initializing the IntrinsicsIDREF="ch11191"Using LocalesIDREF="ch0371"Application Class Resource FileIDREF="ch0313"Initializing the IntrinsicsIDREF="ch0344"Command-Line SpecificationsXtAppSetFallbackResourcesIDREF="ch0372"Application Class Resource FileXtAppSetSelectionTimeoutIDREF="ch16426"The Xt Selection InterfaceXtArgValIDREF="ch0398"Arguments that Specify Resource ValuesIDREF="ch03126"Resource Value Data TypesIDREF="ch03104"Arguments that Specify Resource ValuesXtAugmentTranslationsIDREF="ch13394"Using TranslationsXtCallbackProcIDREF="ch03143"Adding Callback ProceduresXtConfigureWidgetIDREF="ch10154"The resize ProcedureIDREF="ch1071"The geometry_manager ProcedureIDREF="ch1038"Widget Class ProceduresIDREF="ch14202"Using a DrawingArea in a ScrolledWindowIDREF="ch1081"The geometry_manager ProcedureIDREF="ch1479"Moving and Resizing ChildrenIDREF="ch1019"Widget Class ProceduresIDREF="ch1024"Widget Class ProceduresIDREF="ch1494"Moving and Resizing ChildrenIDREF="ch10208"Exposure and RedisplayIDREF="ch1457"Moving and Resizing ChildrenXtCreateApplicationContextIDREF="ch0312"Initializing the IntrinsicsXtCreateManagedWidgetIDREF="ch03181"Managing WidgetsXtCreatePopupShellIDREF="ch06109"MenuShellIDREF="ch03214"Multiple Screens, Displays, and ApplicationsXtCreateWidgetIDREF="ch0377"Creating WidgetsIDREF="ch0388"Creating WidgetsXtCWQueryOnlyIDREF="ch10124"Intermediate Geometry RequestsIDREF="ch10128"Intermediate Geometry RequestsXtDestroyWidgetIDREF="ch0390"Creating WidgetsXtDisownSelectionIDREF="ch16420"The Xt Selection InterfaceXtDisplayInitializeIDREF="ch0329"The Initial Resource DatabaseIDREF="ch0346"Command-Line SpecificationsIDREF="ch0356"Server or User-Preference ResourcesIDREF="ch1613"Application StartupIDREF="ch0316"Initializing the IntrinsicsIDREF="ch03207"Multiple Screens, Displays, and ApplicationsIDREF="ch03208"Multiple Screens, Displays, and ApplicationsIDREF="ch11216"Resource File LocationsIDREF="ch0326"The Initial Resource DatabaseIDREF="ch11219"Resource File LocationsIDREF="ch11222"Resource File LocationsIDREF="ch11223"Resource File LocationsIDREF="ch11225"Resource File LocationsIDREF="ch0370"Application Class Resource FileIDREF="ch04136"Initializing the IntrinsicsIDREF="ch04146"Opening UID FilesIDREF="ch0336"File Search PathsXtEventHandlerIDREF="ch13461"Event HandlersXtExposeNoCompressIDREF="ch14126"Handling Exposure EventsXTextExtentsIDREF="ch14237"Text OutputXTextExtents16IDREF="ch14238"Text OutputXTextStyleIDREF="ch16396"Text ConversionXtFreeIDREF="ch03135"Resource Values and Memory ManagementXtGeometryAlmostIDREF="ch10127"Intermediate Geometry RequestsIDREF="ch1056"Geometry Change RequestsIDREF="ch10107"The geometry_manager ProcedureIDREF="ch1061"Geometry Change RequestsIDREF="ch10139"XtSetValuesIDREF="ch10183"Preferred Size and LocationIDREF="ch10126"Intermediate Geometry RequestsXtGeometryDoneIDREF="ch10118"Intermediate Geometry RequestsIDREF="ch1074"The geometry_manager ProcedureIDREF="ch10101"The geometry_manager ProcedureIDREF="ch10197"Preferred Size and LocationIDREF="ch10160"The resize ProcedureIDREF="ch1093"The geometry_manager ProcedureIDREF="ch10172"The resize ProcedureIDREF="ch10137"XtSetValuesIDREF="ch1086"The geometry_manager ProcedureIDREF="ch10219"Exposure and RedisplayIDREF="ch1084"The geometry_manager ProcedureIDREF="ch10112"Intermediate Geometry RequestsIDREF="ch10113"Intermediate Geometry RequestsXtGeometryNoIDREF="ch16119"Window ConfigurationIDREF="ch10253"Shells and Their ChildrenIDREF="ch10138"XtSetValuesIDREF="ch10184"Preferred Size and LocationIDREF="ch1053"Geometry Change RequestsXtGeometryYesIDREF="ch1066"The geometry_manager ProcedureIDREF="ch1085"The geometry_manager ProcedureIDREF="ch10182"Preferred Size and LocationIDREF="ch10111"Intermediate Geometry RequestsIDREF="ch10119"Intermediate Geometry RequestsIDREF="ch10125"Intermediate Geometry RequestsIDREF="ch10132"XtSetValuesIDREF="ch1089"The geometry_manager ProcedureIDREF="ch16115"Window ConfigurationIDREF="ch1078"The geometry_manager ProcedureIDREF="ch1096"The geometry_manager ProcedureIDREF="ch1052"Geometry Change RequestsIDREF="ch10218"Exposure and RedisplayIDREF="ch10100"The geometry_manager ProcedureIDREF="ch10157"The resize ProcedureIDREF="ch10169"The resize ProcedureXtGetSelectionRequestIDREF="ch16418"The Xt Selection InterfaceXtGetSelectionValueIDREF="ch16421"The Xt Selection InterfaceXtGetSelectionValueIncrementalIDREF="ch16423"The Xt Selection InterfaceXtGetSelectionValuesIDREF="ch16422"The Xt Selection InterfaceXtGetSelectionValuesIncrementalIDREF="ch16424"The Xt Selection InterfaceXtGetValuesIDREF="ch03131"Resource Values and Memory ManagementIDREF="ch03124"Resource Value Data TypesIDREF="ch11331"Geometry Management of Pre-Edit and Status AreasIDREF="ch10244"Shells and Their ChildrenIDREF="ch15267"Specifying Drag ProtocolsIDREF="ch06103"MenuShellIDREF="ch10272"Manager Widgets and Their ChildrenIDREF="ch0158"WidgetsIDREF="ch15642"XmDropTransferIDREF="ch06198"OptionMenuIDREF="ch08253"Sharing Text SourcesXtGrabNoneIDREF="ch03219"Multiple Screens, Displays, and ApplicationsXtInsertEventHandlerIDREF="ch13463"Event HandlersXtInstallAcceleratorsIDREF="ch13439"Mnemonics and AcceleratorsIDREF="ch13441"Mnemonics and AcceleratorsXtIsSensitiveIDREF="ch1385"SensitivityXtMakeGeometryRequestIDREF="ch1067"The geometry_manager ProcedureIDREF="ch1051"Geometry Change RequestsIDREF="ch10215"Exposure and RedisplayIDREF="ch1057"Geometry Change RequestsIDREF="ch1075"The geometry_manager ProcedureIDREF="ch1044"Geometry Change RequestsIDREF="ch1059"Geometry Change RequestsIDREF="ch1092"The geometry_manager ProcedureIDREF="ch1097"The geometry_manager ProcedureIDREF="ch1046"Geometry Change RequestsIDREF="ch10110"Intermediate Geometry RequestsIDREF="ch1050"Geometry Change RequestsXtMakeResizeRequestIDREF="ch1043"Geometry Change RequestsXtMallocIDREF="ch03133"Resource Values and Memory ManagementXtManageChildIDREF="ch03175"Managing WidgetsIDREF="ch03169"Managing WidgetsIDREF="ch03171"Managing WidgetsIDREF="ch03165"Managing WidgetsXtManageChildrenIDREF="ch03174"Managing WidgetsIDREF="ch03166"Managing WidgetsXtMapWidgetIDREF="ch03198"Mapping WidgetsXtMoveWidgetIDREF="ch1072"The geometry_manager ProcedureIDREF="ch1022"Widget Class ProceduresIDREF="ch14200"Using a DrawingArea in a ScrolledWindowIDREF="ch10210"Exposure and RedisplayIDREF="ch1477"Moving and Resizing ChildrenIDREF="ch1082"The geometry_manager ProcedureIDREF="ch1017"Widget Class ProceduresIDREF="ch1455"Moving and Resizing ChildrenXtNameToWidgetIDREF="ch07206"MessageBoxIDREF="ch07142"Making a Selection: SelectionBoxXtNewIDREF="ch03134"Resource Values and Memory ManagementXtOpenDisplayIDREF="ch0314"Initializing the IntrinsicsIDREF="ch0335"File Search PathsIDREF="ch0345"Command-Line SpecificationsIDREF="ch0324"The Initial Resource DatabaseXtOverrideTranslationsIDREF="ch13395"Using TranslationsXtOwnSelectionIDREF="ch16416"The Xt Selection InterfaceXtOwnSelectionIncrementalIDREF="ch16419"The Xt Selection InterfaceIDREF="ch16417"The Xt Selection InterfaceXtParseAcceleratorTableIDREF="ch13444"Mnemonics and AcceleratorsXtParseTranslationTableIDREF="ch13392"Using TranslationsXtPopupIDREF="ch03218"Multiple Screens, Displays, and ApplicationsIDREF="ch0753"DialogShellXtQueryGeometryIDREF="ch10198"Preferred Size and LocationIDREF="ch10187"Preferred Size and LocationIDREF="ch1041"Widget Class ProceduresIDREF="ch10189"Preferred Size and LocationIDREF="ch10192"Preferred Size and LocationXtRealizeWidgetIDREF="ch03194"Realizing WidgetsIDREF="ch03193"Realizing WidgetsXtRemoveAllCallbacksIDREF="ch03156"Adding Callback ProceduresIDREF="ch09110"Automatic ScrollingXtRemoveCallbackIDREF="ch03154"Adding Callback ProceduresXtRemoveCallbacksIDREF="ch03155"Adding Callback ProceduresXtResizeWidgetIDREF="ch1493"Moving and Resizing ChildrenIDREF="ch16126"Window ConfigurationIDREF="ch1073"The geometry_manager ProcedureIDREF="ch10155"The resize ProcedureIDREF="ch14201"Using a DrawingArea in a ScrolledWindowIDREF="ch1083"The geometry_manager ProcedureIDREF="ch1023"Widget Class ProceduresIDREF="ch1456"Moving and Resizing ChildrenIDREF="ch1018"Widget Class ProceduresIDREF="ch1037"Widget Class ProceduresIDREF="ch1478"Moving and Resizing ChildrenIDREF="ch10209"Exposure and RedisplayXtResolvePathnameIDREF="ch12173"Using PixmapsIDREF="ch11196"Using LocalesIDREF="ch11202"Localization Without LocalesIDREF="ch11215"Resource File LocationsIDREF="ch11176"Establishing the Language EnvironmentIDREF="ch11226"Resource File LocationsIDREF="ch11255"MRM and Localized UID FilesIDREF="ch11263"MRM and Localized UID FilesIDREF="ch04151"Opening UID FilesIDREF="ch11274"Message Catalogs and LocalizationIDREF="ch11278"Images, Pixmaps, and LocalizationIDREF="ch11286"Images, Pixmaps, and LocalizationIDREF="ch0333"File Search PathsIDREF="ch04150"Opening UID FilesIDREF="ch11190"Using LocalesIDREF="ch12162"Using PixmapsXtSelectionCallbackProcIDREF="ch15618"XmNdropProcXtSetArgIDREF="ch03102"Arguments that Specify Resource ValuesXtSetKeyboardFocusIDREF="ch16219"Input FocusXtSetLanguageProcIDREF="ch11177"Establishing the Language EnvironmentIDREF="ch11183"Establishing the Language EnvironmentIDREF="ch11184"Establishing the Language EnvironmentIDREF="ch11175"Establishing the Language EnvironmentXtSetSensitiveIDREF="ch1391"SensitivityIDREF="ch16218"Input FocusIDREF="ch1394"SensitivityIDREF="ch0683"RowColumnIDREF="ch1396"SensitivityIDREF="ch1398"SensitivityIDREF="ch1388"SensitivityXtSetValuesIDREF="ch10470"Managing Geometry Using FormIDREF="ch10485"Managing Geometry Using FormIDREF="ch10497"Managing Geometry Using FormIDREF="ch10509"Managing Geometry Using FormIDREF="ch0920"Other ResourcesIDREF="ch11269"Message Catalogs and LocalizationIDREF="ch11332"Geometry Management of Pre-Edit and Status AreasIDREF="ch125"Color and PixmapsIDREF="ch12121"Application-Defined Color GenerationIDREF="ch1395"SensitivityIDREF="ch13160"Tab GroupsIDREF="ch13191"Tab GroupsIDREF="ch13195"Tab GroupsIDREF="ch13255"Controlling Tab Group Traversal OrderIDREF="ch13396"Using TranslationsIDREF="ch1444"Handling Resize EventsIDREF="ch1462"Moving and Resizing ChildrenIDREF="ch1468"Moving and Resizing ChildrenIDREF="ch1484"Moving and Resizing ChildrenIDREF="ch1495"Moving and Resizing ChildrenIDREF="ch14192"Using a DrawingArea in a ScrolledWindowIDREF="ch14203"Using a DrawingArea in a ScrolledWindowIDREF="ch15436"Overriding Existing Drag SourcesIDREF="ch15447"Overriding Existing Drag SourcesIDREF="ch15643"XmDropTransferIDREF="ch0968"Automatic ScrollingIDREF="ch16102"Window ConfigurationIDREF="ch16104"Window ConfigurationIDREF="ch16133"IconsIDREF="ch09233"MainWindowIDREF="ch09237"MainWindowIDREF="ch09246"MainWindowIDREF="ch09308"PanedWindowIDREF="ch1032"Widget Class ProceduresIDREF="ch03115"Retrieving Resource ValuesIDREF="ch03123"Resource Value Data TypesIDREF="ch0159"WidgetsIDREF="ch03111"Setting Resource ValuesIDREF="ch10140"XtSetValuesIDREF="ch02211"Resources: User and Program CustomizationIDREF="ch10147"XtSetValuesIDREF="ch10156"The resize ProcedureIDREF="ch06199"OptionMenuIDREF="ch06242"RadioBox and CheckBoxIDREF="ch08256"Sharing Text SourcesIDREF="ch10271"Manager Widgets and Their ChildrenXtToolkitInitializeIDREF="ch0310"Initializing the IntrinsicsXtUnmanageChildIDREF="ch03183"Managing WidgetsIDREF="ch03178"Managing WidgetsXtUnmanageChildrenIDREF="ch03179"Managing WidgetsIDREF="ch03184"Managing WidgetsXtUnmapWidgetIDREF="ch03199"Mapping WidgetsXtUnspecifiedWindowGroupIDREF="ch16170"Window GroupsXtVaCreateManagedWidgetIDREF="ch03182"Managing WidgetsXtVaCreatePopupShellIDREF="ch06110"MenuShellXtVaCreateWidgetIDREF="ch0378"Creating WidgetsXtVaGetValuesIDREF="ch03114"Retrieving Resource ValuesXtVaNestedListIDREF="ch03105"Arguments that Specify Resource ValuesXtVaSetValuesIDREF="ch03108"Setting Resource ValuesXtVaTypedArgIDREF="ch03125"Resource Value Data TypesIDREF="ch03106"Arguments that Specify Resource ValuesXtWidgetGeometryIDREF="ch10188"Preferred Size and LocationIDREF="ch1058"Geometry Change RequestsIDREF="ch1060"Geometry Change RequestsIDREF="ch1065"The geometry_manager ProcedureIDREF="ch10106"The geometry_manager ProcedureIDREF="ch10143"XtSetValuesIDREF="ch10176"Preferred Size and LocationIDREF="ch10181"Preferred Size and LocationXUSERFILESEARCHPATHIDREF="ch0362"User Application FileIDREF="ch11217"Resource File LocationsIDREF="ch0361"User Application FileXwcTextListToTextPropertyIDREF="ch16376"Text ConversionXwcTextPropertyToTextListIDREF="ch16390"Text ConversionXWMGeometryIDREF="ch1699"Window Configuration