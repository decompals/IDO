#EDIR DATA#
IRIX‘ System Programming GuideDocument Number 007-1794-020ContributorsWritten by Marcia Allen, Patricia Creek, Arthur Evans, Wendy Ferguson, Jed Hartman, Melissa Heinrich, Chris HogueEdited by Nancy SchweigerProduction by Laura CooperEngineering contributions by Dave Anderson, Rick Avila, Dave Babcock, Ivan Bach, Greg Boyd, Julia Chow, David Ciemiewicz, David Frederick, Jay Gischer, Bob Green, W. Wilson Ho, Ajit Mayya, Paul Mielke, Bron Nelson, Ankur Saha, John Wilkinson© Copyright 1992-93 Silicon Graphics, Inc.name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' All Rights ReservedThis document contains proprietary and confidential information of Silicon Graphics, Inc. The contents of this document may not be disclosed to third parties, copied, or duplicated in any form, in whole or in part, without the prior written permission of Silicon Graphics, Inc.Restricted Rights LegendUse, duplication, or disclosure of the technical data contained in this document by the Government is subject to restrictions as set forth in subdivision (c) (1) (ii) of the Rights in Technical Data and Computer Software clause at DFARS 52.227-7013 and/or in similar or successor clauses in the FAR, or in the DOD or NASA FAR Supplement. Unpublished rights reserved under the Copyright Laws of the United States. Contractor/manufacturer is Silicon Graphics, Inc., 2011 N. Shoreline Blvd., Mountain View, CA 94039-7311.Silicon Graphics and IRIS are registered trademarks and IRIX, CASEVision, IRIS IM, IRIS Showcase, Impressario, Inventor, IRIS-4D, POWER Series, RealityEngine, Challenge, Onyx and WorkShop are trademarks of Silicon Graphics, Inc. UNIX is a registered trademark of UNIX System Laboratories. OSF/Motif is a trademark of Open Software Foundation, Inc. The X Window System is a trademark of the Massachusetts Institute of Technology. PostScript is a registered trademark and Display PostScript is a trademark of Adobe Systems, Inc. NFS is a trademark of Sun Microsystems, Inc. Speedo is a trademark of Bitstream, IncIntroductionThis guide discusses a variety of issues and tools involved in programming under the IRIX‘ operating system. It describes the components of the IRISÆ-4D‘ compiler system, and other programming tools and interfaces.LBL="" HELPID=""Audience This guide is intended for anyone who wants to program effectively under IRIX. The material is intended as an introduction to the topics covered; more advanced features are discussed in more detail in the relevant manual pages. However, this guide is not an introduction to programming; there are a wide variety of good texts available for anyone wanting to learn C, for instance, and we do not cover such topics here. Most of our examples are written in C; we assume a basic familiarity with that language.LBL="" HELPID=""OrganizationThis guide contains the following chapters:IDREF="48687" TYPE="TITLE"Chapter 1, "Using the Compiler System," describes the components of the IRIS-4D Series compiler system and explains how to use them.IDREF="92826" TYPE="TITLE"Chapter 2, "Dynamic Shared Objects," explains how to build and use dynamic shared objects, which replace the static shared libraries used by previous versions of IRIX.IDREF="68557" TYPE="TITLE"Chapter 3, "Improving Program Performance," explains how to reduce program execution time using profiling and optimization tools.IDREF="80096" TYPE="TITLE"Chapter 4, "lex," describes how to use the lex program generator to develop a lexical analyzer.IDREF="82425" TYPE="TITLE"Chapter 5, "yacc," describes the yacc program generator, a tool that simplifies the task of developing parsers.IDREF="48026" TYPE="TITLE"Chapter 6, "Inter-Process Communication," describes System V and IRIX inter-process communication mechanisms.IDREF="82678" TYPE="TITLE"Chapter 7, "File and Record Locking," describes how to lock and unlock files and parts of files from within a program.IDREF="24034" TYPE="TITLE"Chapter 8, "Using Real-Time Programming Features," describes features available for real-time programming.IDREF="16251" TYPE="TITLE"Chapter 9, "Working with Fonts," discusses typography and font use on Silicon Graphics computers, and describes the Font Manager library,IDREF="10407" TYPE="TITLE"Chapter 10, "Internationalization," explains how to create an application that can be adapted for use in different countries.IDREF="78479" TYPE="TITLE"Chapter 11, "Localization and Creating New Locales," describes the process of creating a databases of country-specific information for use with internationalized programs.IDREF="27381" TYPE="TITLE"Appendix A, "Position-Independent Coding in Assembly Language," describes assembly language coding techniques required by this version of IRIX.IDREF="67532" TYPE="TITLE"Appendix B, "ISO 3166 Country Names and Abbreviations," lists country codes for use with internationalization and localization.IDREF="72283" TYPE="TITLE"Appendix C, "Changing Default Xsgi Settings," explains how to direct the X Window System server to use alternate keyboard mappings and fonts.IDREF="46986" TYPE="TITLE"Appendix D, "Internationalized Commands," lists the IRIX commands which have been internationalized.LBL="" HELPID=""Further ReadingThe following references provide more information on internationalization:Nye, Adrian: Xlib Programming Manual for Version 11 of the X Window System, Volume One, third edition (covers Release 4 and Release 5), O'Reilly & Associates, ISBN 1-56592-002-3Scheifler, Robert and Gettys, Jim: X Window System, Third Edition, Digital Press, ISBN 1-55558-088-2X/Open Company, Ltd.: X/Open Portability Guide, Prentice Hall, ISBN 0-13-685819-8 (Set of 7 Volumes)LBL="" HELPID=""ConventionsThis guide uses the following conventions and symbols:ID="intro1"CourierIn text the Courier font represents function names, file names, and keywords. It is also used for command syntax, output, and program listings.boldBoldface is used along with Courier font to distinguish user input from system output.italicsWords in italics represent characters or numerical values that you define. Replace the abbreviation with the defined value. Also, italics are used for manual page names and commands. The section number, in parentheses, follows the name. [ ]Brackets enclose optional items.{ }Braces enclose two or more items of which you must specify at least one.|The OR symbol separates two or more optional items.name='hellip' font=symbol charset=fontspecific code=188A horizontal ellipsis in a syntax statement indicates that the preceding optional items can appear more than once in succession.( )Parentheses enclose entities and must be written as shown.The following two examples illustrate the syntax conventions:DIMENSION a(d) [,a(d)] name='hellip' font=symbol charset=fontspecific code=188indicates that the Fortran keyword DIMENSION must be written as shown, that the user-defined entity a(d) is required, and that one or more of a(d) can be specified. The parentheses ( ) enclosing d are required.{STATIC | AUTOMATIC} v [,v] name='hellip' font=symbol charset=fontspecific code=188indicates that either the STATIC or AUTOMATIC keyword must be written as shown, that the user-defined entity v is required, and that one or more v items can be specified.LBL="1"ID="48687"Using the Compiler SystemThis chapter contains these sections:IDREF="23108" TYPE="TITLE""Overview" lists the components of the IRIS-4D compiler system.IDREF="37532" TYPE="TITLE""Object File Format and Dynamic Linking" discusses the major differences between the latest version of IRIX and previous versions.IDREF="67353" TYPE="TITLE""Source File Considerations" explains source file naming conventions and the procedure for including header files.IDREF="39676" TYPE="TITLE""Compiler Drivers" lists and explains the general compiler-driver options.IDREF="72868" TYPE="TITLE""Linking" explains how to manually link-edit programs (using ld or a compiler driver) and how to compile multilanguage programs. It also describes Dynamic Shared Objects and how to link them into your programs.IDREF="15589" TYPE="TITLE""Debugging" explains the compiler-driver options for debugging.IDREF="65767" TYPE="TITLE""Getting Information about Object Files" explains how to use the object file tools to analyze object files.IDREF="94723" TYPE="TITLE""Using the Archiver to Create Libraries" explains how to use the archiver, ar.LBL="" HELPID=""ID="23108"OverviewThe IRIS-4D compiler system consists of a set of components that enable you to create executable programs using such languages as C, Fortran 77, and Pascal. ID="01.compiler1"IDREF="85855" TYPE="TABLE"Table 1-1
 summarizes the IRIS-4D compiler system components and the task each performs.COLUMNS="3"LBL="1-1"Table 1-1 Compiler System Functional ComponentsID="85855"LEFT="0" WIDTH="93"ToolLEFT="100" WIDTH="126"TaskLEFT="235" WIDTH="356"ExamplesLEFT="0" WIDTH="93"Text editorLEFT="100" WIDTH="126"Write and edit programsLEFT="235" WIDTH="356"vi, jot, emacsLEFT="0" WIDTH="93"Compiler driverLEFT="100" WIDTH="126"Compile, link, and load 
programsLEFT="235" WIDTH="356"cc, f77, pcLEFT="0" WIDTH="93"Object file analyzerLEFT="100" WIDTH="126"Analyze object filesLEFT="235" WIDTH="356"elfdump, file, nm, odump, sizeLEFT="0" WIDTH="93"ProfilerLEFT="100" WIDTH="126"Analyze program 
performanceLEFT="235" WIDTH="356"prof, pixieLEFT="0" WIDTH="93"OptimizerLEFT="100" WIDTH="126"Improve program 
performanceLEFT="235" WIDTH="356"uoptLEFT="0" WIDTH="93"ArchiverLEFT="100" WIDTH="126"Produce object-file librariesLEFT="235" WIDTH="356"arLEFT="0" WIDTH="93"Runtime loaderLEFT="100" WIDTH="126"Link Dynamic Shared Objects 
at runtimeLEFT="235" WIDTH="356"rldLEFT="0" WIDTH="93"DebuggerLEFT="100" WIDTH="126"Debug programsLEFT="235" WIDTH="356"dbxA single program called a compiler driver (such as ID="01.compiler2"cc, f77, or pc) invokes the following major components of the compiler system (refer to IDREF="69332" TYPE="GRAPHIC"Figure 1-1
):ID="01.compiler3"Macro preprocessor (ID="01.compiler4"cfe)Parallel analyzer (ID="01.compiler5"pca, pfa)Compiler front end (ID="01.compiler6"cfe, fcom, upas)Ucode tools (ID="01.compiler7"ujoin, uld, umerge)Optimizer (ID="01.compiler8"uopt)Code generator (ID="01.compiler9"ugen)Assembler (ID="01.compiler10"as1)Link editor (ID="01.compiler11"ld)C++ has a specialized driver,† †CC, with slightly different options from cc, f77, and pc. Refer to the C++ Programming Guide for details.† †You can invoke a compiler driver with various options (described later in this chapter) and with one or more source files as arguments. All specified source files are automatically sent to the macro preprocessor.Preprocessing is now done by cfe, but the old preprocessors (cpp for "traditional" Kernighan & Ritchie C, or acpp for ANSI C) are still available for non-compilation preprocessing in case you want to use them.† †Although the macro preprocessor was originally designed for C programs, it is now run by default as part of almost all compilations. To prevent the preprocessor from being run, specify the ID="01.compiler12"≠nocpp† †option on the driver command line.If available, the parallel analyzers pca and pfa produce parallelized source code from standard source code. The result takes advantage of multiple CPUs (when present) to achieve higher computation rates. pca and pfa are part of the Power C and Power Fortran packages; for more information about these packages and how to obtain them, contact your dealer or sales representative.The compilers proper, often called "front ends," translate source code into intermediate code. The available compiler front ends are cfe (C), fcom (Fortran 77), and upas (Pascal). ujoin, uld, umerge, and uopt comprise the optimization subsystem of the compiler system. (For more information about optimization and profiling, see IDREF="68557" TYPE="TITLE"Chapter 3, "Improving Program Performance."
) ugen and as1 make up the code-generation subsystem of the compiler system. The link editor ld combines several object files into one, performs relocation, resolves external symbols, and merges symbol table information for symbolic debugging. The driver automatically runs ld unless you specify the ≠c option to skip the linking step.To see the various utilities a program passes through during compilation, invoke the appropriate driver with the ID="01.compiler13"≠v option (or +v for the C++ driver CC).LBL="1-1" FILE="1.1.cmplr.sys.ps" POSITION="INLINE" SCALE="FALSE"LBL="1-1"Figure 1-1 ID="69332"Compiler System FlowchartLBL="" HELPID=""ID="37532"Object File Format and Dynamic LinkingA new object file format was adopted in IRIX version 5.0. The major differences between the current compiler system and pre-5.0 compiler systems are summarized below:The compiler system uses a new format, Executable and Linking Format (ELF), for object files.The compiler system uses a new kind of shared library, the Dynamic Shared Object (DSO).The compiler system creates Position-Independent Code (PIC) by default to support dynamic linking.LBL="" HELPID=""Executable and Linking FormatPrevious versions of IRIX used an extended version of the Common Object File Format (COFF) for object files. The current compiler system produces ELF object files instead. ELF is the format specified by the System V Release 4 Applications Binary Interface (the SVR4 ABI). In addition, ELF provides support for Dynamic Shared Objects, described below.   There are three kinds of ELF object files:Relocatable files contain code and data in a format suitable for linking with other object files to make a shared object or executable.Dynamic Shared Objects contain code and data suitable for dynamic linking. Relocatable files may be linked with DSOs to create a dynamic executable. At runtime, the runtime linker combines the executable and DSOs to produce a process image.Executable files are programs ready for execution. They may or may not be dynamically linked.COFF executables will continue to run on new releases of IRIX, but the current compiler system has no facility for creating or linking COFF executables. COFF and ELF object files may not be linked together. To take advantage of new IRIX features, you must recompile your code.IRIX will execute all binaries that are compliant with the SVR4 ABI, as specified in the System V Applications Binary Interfacename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Revised Edition and the System V ABI MIPS Processor Supplement; however, binaries compiled under this version of the compiler system are not guaranteed to comply with the SVR4 ABI. The MIPS-specific version of the SVR4 ABI is referred to as the MIPS ABI. Programs that comply with the MIPS ABI can be run on any machine that supports the MIPS ABI.LBL="" HELPID=""Dynamic Shared ObjectsIRIX 5.0 introduced a new kind of shared object called a Dynamic Shared Object, or DSO. The object code of a DSO is Position-Independent Code (PIC), which can be mapped into the virtual address space of several different processes at once. DSOs are loaded at runtime instead of at linking time, by the runtime loader, rld. As is true for static shared libraries, the code for DSOs is not included in executable files; thus, executables built with DSOs are smaller than those built with non-shared libraries, and multiple programs may use the same DSO at the same time.Static shared libraries are only supported under this release for the purposes of running old (COFF) binaries. The current compiler system has no facilities for generating static shared libraries.LBL="" HELPID=""Position-Independent CodeDynamic linking requires that all object code used in the executable be Position-Independent Code. For source files in high-level languages, you just need to recompile to produce PIC. Assembly language files must be modified to produce PIC; see IDREF="27381" TYPE="TITLE"Appendix A, "Position-Independent Coding in Assembly Language,"
 for details.Position-Independent Code satisfies references indirectly by using a Global Offset Table (GOT), which allows code to be relocated simply by updating the GOT. Each executable and each DSO has its own GOT.The compiler system will now produce PIC by default when compiling higher-level language files. All of the standard libraries are now provided as DSOs, and therefore contain PIC code; if you compile a program into non-PIC, you will be unable to use those DSOs. One of the few reasons to compile non-PIC is to build a device driver, which doesn't rely on standard libraries; in this case, you should use the ≠non_shared option to the compiler driver to negate the default option, ≠KPIC. For convenience, the C library and math library are provided in non-shared format as well as in DSO format (although the non-shared versions are not installed by default). These libraries can be linked ≠non_shared with other non-PIC files.When running Position-Independent Code, the global pointer is used to point to the Global Offset Table, so you can no longer use the ≠G option to store data in the global pointer region (that is, ≠KPIC, the default, implies ≠G 0). The compiler will ignore any user-specified ≠G number other than zero. For more information about this option, see the ld(1) manual page.LBL="" HELPID=""† †ID="67353"Source File ConsiderationsThis section describes conventions for naming source files and including header files.LBL="" HELPID=""Source File Naming ConventionsEach compiler driver recognizes the type of an input file by the suffix assigned to the file name. IDREF="24314" TYPE="TABLE"Table 1-2
 describes the possible file name suffixes.COLUMNS="2"LBL="1-2"Table 1-2 Driver Input File SuffixesID="24314"LEFT="0" WIDTH="66"† †SuffixLEFT="75" WIDTH="356"DescriptionLEFT="0" WIDTH="66".sLEFT="75" WIDTH="356"Assembly sourceLEFT="0" WIDTH="66".iLEFT="75" WIDTH="356"Preprocessed source code in the language of the processing driverLEFT="0" WIDTH="66".cLEFT="75" WIDTH="356"C sourceLEFT="0" WIDTH="66".fLEFT="75" WIDTH="356"Fortran 77 sourceLEFT="0" WIDTH="66".pLEFT="75" WIDTH="356"Pascal sourceLEFT="0" WIDTH="66".uLEFT="75" WIDTH="356"Ucode object fileLEFT="0" WIDTH="66".bLEFT="75" WIDTH="356"Ucode object libraryLEFT="0" WIDTH="66".oLEFT="75" WIDTH="356"Object fileLEFT="0" WIDTH="66".aLEFT="75" WIDTH="356"Object libraryIf you purchased the C++ option, refer to the C++ Programming Guide for details about input files for the C++ driver, CC.LBL="" HELPID=""Examplescalc.p is an example of a Pascal program name.When invoked as follows, f77 assumes the file tickle.i contains Fortran statements (because the Fortran driver is specified). f77 also assumes the file has already been preprocessed (because the suffix is .i), and therefore will not invoke the cfe preprocessor:f77 -c tickle.iLBL="" HELPID=""Header FilesID="01.compiler14"Header files, also called include files, contain information about the libraries they're associated with. They define such things as data structures, symbolic constants, and prototypes and parameters for the functions in the library. For example, the stdio.h header file describes, among other things, the data types of the parameters required by printf(). To use those definitions without having to type them into each of your source files, you can use the #include command to tell the macro preprocessor to include the complete text of the given header file in the current source file. Including header files in your source files allows you to specify such definitions conveniently and consistently in each source file that uses any of the library routines.By convention, header file names have a† †.h suffix. Each programming language handles these files the same way, via the macro preprocessor.Do not put any code other than definitions in an include file, particularly if you intend to debug your program using ID="01.compiler15"dbx. The debugger recognizes an include file as only one line of source code, so source lines in an include file do not appear during debugging sessions.† †LBL="" HELPID=""Specifying a Header FileThe #include command tells the preprocessor to replace the #include line with the text of the indicated header file. The usual way to specify a header file is with the line:#include <filename>where filename is the name of the header file to be included. The angle brackets (< >) surrounding the file name tell the macro preprocessor to search for the specified file only in directories specified by command-line options and in the default header-file directory (/usr/include).There is another specification format, in which the file name is given between double quotation marks:#include "filename"In this case, the macro preprocessor searches for the specified header file in the current directory first, then (if it doesn't find the requested file) goes on and searches in the other directories as in the angle-bracket specification.When you specify header files in your source files, the #include keyword should always start in column 1 (that is, all the way over to the left) to be recognized by the preprocessor.† †LBL="" HELPID=""Creating a Header File for Multiple LanguagesID="01.compiler16"ID="01.compiler17"A single header file can contain definitions for multiple languages; this setup allows you to use the same header file for all programs that use a given library, no matter what language those programs are in. To set up a shareable header file, create a .h file and enter the definitions for the various languages as follows:#ifdef _LANGUAGE_C

C definitions

#endif

#ifdef _LANGUAGE_C_PLUS_PLUS

C++ definitions

#endif

#ifdef _LANGUAGE_FORTRAN

Fortran definitions

#endif

and so on for other language definitionsTo indicate C++ definitions you must use _LANGUAGE_C_PLUS_PLUS, not _LANGUAGE_C++.† †You can specify the various language definitions in any order, but you must specify _LANGUAGE_ before the language name.LBL="" HELPID=""ID="39676"Compiler DriversThe driver commands, such as cc, f77, and pc, call subsystems that compile, optimize, assemble, and link-edit your programs. This section describes driver options that can be used with any of the drivers.LBL="" HELPID=""Default Behavior for Compiler DriversAt compilation time, you can select one or more options that affect a variety of program development functions, including debugging, optimization, and profiling facilities. You can also specify the names assigned to output files. However, some options have default values that apply if you do not specify the option.When you invoke a compiler driver with source files as arguments, the driver calls other commands that compile your source code into object code. It then optimizes the object code (if requested to do so) and links together the object files, the default libraries, and any other libraries you specify.LBL="" HELPID=""ExampleGiven a source file foo.c, the default name for the object file is foo.o. The default name for an executable file is a.out. So the following example compiles source files foo.c and bar.c with the default options:cc foo.c bar.cThis example produces two object files (foo.o and bar.o), then links those together with the default C library libc to produce an executable called a.out.If you compile a single source directly to an executable, the compiler will not create an object file.† †LBL="" HELPID=""General Options for Compiler DriversIDREF="90644" TYPE="TABLE"Table 1-3 describes some of the command-line options for IRIS-4D compiler drivers. Note that not all of the options work with every driver.ID="01.compiler18"IDREF="90644" TYPE="TABLE"Table 1-3
 lists only the most frequently used options, not all available options. See the cc(1), pc(1), and f77(1) manual pages for a complete list of options.† †You can use the compiler system to generate profiled programs that, when executed, provide operational statistics. To perform this procedure, use the ≠p† †compiler option (for pc sampling information) and the pixie program (for profiles of basic block counts). Refer to IDREF="68557" TYPE="TITLE"Chapter 3, "Improving Program Performance,"
 for details.In addition to the general options in IDREF="90644" TYPE="TABLE"Table 1-3
, each driver also has options that you normally will not use. These options primarily aid compiler development work. For information about nonstandard driver options, consult the appropriate driver manual page.COLUMNS="2"LBL="1-3"Table 1-3 General Driver OptionsID="90644"† †LEFT="0" WIDTH="77"Option LEFT="85" WIDTH="356"PurposeLEFT="0" WIDTH="77"≠cLEFT="85" WIDTH="356"Prevents the link editor from linking your program after 
assembly code generation. This option forces the driver to 
produce a .o file after the assembler phase, and prevents the 
driver from producing an executable file.LEFT="0" WIDTH="77"≠CLEFT="85" WIDTH="356"(C driver only) Used with the ≠P or ≠E option. Prevents the 
macro preprocessor from stripping comments. Use this option 
when you suspect the preprocessor is not producing the 
intended code and you want to examine the code with its 
comments. Note that ≠C is really an option to cfe; this option 
will be passed along to cfe if you specify it with cc.LEFT="0" WIDTH="77"≠CLEFT="85" WIDTH="356"(Pascal and Fortran drivers only) Generates code that invokes 
range checking for subscripts during program execution.LEFT="0" WIDTH="77"≠Dname[=def]LEFT="85" WIDTH="356"Defines a macro name as if you had specified a #define in your 
program. If you do not specify a definition with =def, name is set 
to 1.LEFT="0" WIDTH="77"≠ELEFT="85" WIDTH="356"(C driver only) Runs only the macro preprocessor and sends 
results to the standard output. To retain comments, use the ≠C 
option as well. Use ≠E when you suspect the preprocessor is not 
producing the intended code.LEFT="0" WIDTH="77"≠IdirnameLEFT="85" WIDTH="356"Adds dirname to the list of directories to be searched for 
specified header files. These directories are always searched 
before the default directory, /usr/include.LEFT="0" WIDTH="77"≠mips1LEFT="85" WIDTH="356"Generates code using the instruction set of the MIPS 
R2000/R3000 RISC architecture. This is the default.LEFT="0" WIDTH="77"≠mips2LEFT="85" WIDTH="356"Generates code using the MIPS II instruction set (MIPS I + 
R4000 specific extensions). Note that code compiled with 
-mips2 will not run on R2000/R3000 based machines.LEFT="0" WIDTH="77"≠nocppLEFT="85" WIDTH="356"Suppresses running of the macro preprocessor on the source 
files prior to processing.LEFT="0" WIDTH="77"≠non_sharedLEFT="85" WIDTH="356"Turns off the default option, ≠KPIC, to produce non-shared 
code that thus can be linked to only a few standard libraries 
(such as libc.a and libm.a) that are provided in non-shared 
format, in the directory /usr/lib/nonshared. Should therefore 
usually be used only when building device drivers.LEFT="0" WIDTH="77"≠nostdincLEFT="85" WIDTH="356"Suppresses searching of /usr/include for the specified header 
files.LEFT="0" WIDTH="77"≠o† †filenameLEFT="85" WIDTH="356"Names the result of the compilation filename. If an executable is 
being generated, it will be named filename rather than the 
default name, a.out. If a single source file is being compiled with 
≠c, the object will be named filename (not, it should be noted, 
filename.o; if you want the object file name to end with .o, you 
should specify that in the argument to ≠o). Otherwise, this 
option will be ignored.LEFT="0" WIDTH="77"≠PLEFT="85" WIDTH="356"Runs only the macro preprocessor on the files and puts the 
result of each file in a .i file. Specify both ≠P and ≠C to retain 
comments.LEFT="0" WIDTH="77"≠SLEFT="85" WIDTH="356"Similar to ≠c, except that it produces assembly code in a .s file 
instead of object code in a .o file.LEFT="0" WIDTH="77"≠UnameLEFT="85" WIDTH="356"Overrides a definition of the macro name that you specified 
with the ≠D option, or that is defined automatically by the 
driver. Note that this option does not override a macro 
definition in a source file, only on the command line.LEFT="0" WIDTH="77"≠vLEFT="85" WIDTH="356"Lists compiler phases as they are executed. Use this option to 
see the default options for each compiler phase along with the 
options you've specified.LEFT="0" WIDTH="77"≠wLEFT="85" WIDTH="356"Suppresses warning messages.LBL="" HELPID=""ID="72868"LinkingThe link editor, ld, combines one or more object files and libraries (in the order specified) into one executable file, performing relocation, external symbol resolutions, and all other required processing. Unless directed otherwise, the link editor names the executable file ID="01.compiler19"a.out.This section summarizes the functions of the link editor. Also described here are how to link-edit a program manually (without using a compiler driver) and how to compile multilanguage programs. Refer to the ld(1) manual page for complete information on the link editor.LBL="" HELPID=""Invoking the Link Editor ManuallyUsually the link editor is invoked by the compiler driver as the final step in compilation (as explained in IDREF="39676" TYPE="TITLE""Compiler Drivers"
). If you have object files produced by previous compilations that you want to link together, you can invoke the link editor using a compiler driver instead of calling ld directly; just pass the object-file names to the compiler driver in place of source-file names. If the original source files were in a single language, simply invoke the associated driver and specify the list of object files. (For information about linking together objects derived from several languages, see IDREF="71272" TYPE="TITLE""Linking Multilanguage Programs."
)There are a few command-line options to ID="01.compiler20"ld, such as ≠p, which have different meanings when used as command-line options to cc; to pass such options to ld through an invocation of a compiler driver, use the ≠Wl option to the driver (see the manual page for details).There are a few circumstances under which you need to invoke ld directly, such as when you're doing special linking not supported by compiler drivers (such as building an embedded system). But most of the time it's simplest just to call a compiler driver and let it invoke ld as necessary. Nonetheless, a summary of ld syntax is provided here in case you need it.LBL="" HELPID=""SyntaxID="01.compiler21"ld options† †object1 [object2...objectn]optionsOne or more of the options listed in IDREF="81521" TYPE="TABLE"Table 1-4
.object Specifies the name of the object file to be link-edited.IDREF="81521" TYPE="TABLE"Table 1-4 contains only a partial list of link editor options. Many options that apply only to creating shared objects are discussed in the next chapter. For complete information on options and libraries that affect link editor processing, refer to the ld(1) manual page.COLUMNS="2"LBL="1-4"Table 1-4 Link Editor OptionsID="81521"† †LEFT="0" WIDTH="73"Option LEFT="80" WIDTH="356"PurposeLEFT="0" WIDTH="73"≠kllibnameLEFT="80" WIDTH="356"Similar to ≠llibname, but the library is a ucode library named 
liblibname.b.LEFT="0" WIDTH="73"≠llibnameLEFT="80" WIDTH="356"Specifies the name of a library, where libname is the library name. 
The link editor searches for a liblibname.so (and then 
liblibname.a) first in any directories specified by ≠L† †dirname 
options, and then in the standard directories: /lib, /usr/lib, and 
/usr/local/lib.LEFT="0" WIDTH="73"≠L dirnameLEFT="80" WIDTH="356"Adds dirname to the list of directories to be searched for along 
with libraries specified by subsequent ≠llibname options.LEFT="0" WIDTH="73"--mLEFT="80" WIDTH="356"Produces a link editor memory map, listing input and output 
sections of the code, in System V format.LEFT="0" WIDTH="73"≠MLEFT="80" WIDTH="356"Produces a link map in BSD format, listing the names of files to 
be loaded.LEFT="0" WIDTH="73"≠nostdlibLEFT="80" WIDTH="356"This option must be accompanied by the ≠L† †dirname option. If 
the link editor does not find the library in dirname, then it does 
not search any of the standard library directories.LEFT="0" WIDTH="73"≠o filenameLEFT="80" WIDTH="356"Specifies a name for your executable. If you do not specify 
filename, the link editor names the executable a.out.LEFT="0" WIDTH="73"≠sLEFT="80" WIDTH="356"Strips symbol table information from the program object, 
reducing its size. This option is useful for linking routines that 
are frequently linked into other program objects.LEFT="0" WIDTH="73"≠vLEFT="80" WIDTH="356"Prints the name of each file as it is processed by the link editor.LEFT="0" WIDTH="73"≠XsortbssLEFT="80" WIDTH="356"Sorts bss symbols (this is the default in C but not in Fortran).LEFT="0" WIDTH="73"≠XnobsschangeLEFT="80" WIDTH="356"Overrides defaults, eliminating all global bss reordering.LEFT="0" WIDTH="73"≠ysymnameLEFT="80" WIDTH="356"Reports all references to, and definitions of, the symbol symname. 
Useful for locating references to undefined symbols.LBL="" HELPID=""ExampleThe following command tells the linker to search for the DSO libcurses.so in the directory /lib. If it does not find that DSO, the linker then looks for libcurses.a in /lib; then for libcurses.so in /usr/lib, then in the same directory for libcurses.a. If it hasn't found an appropriate library by then, it looks in /usr/local/lib for libcurses.a. (Note that the linker will not look for DSOs in /usr/local/lib, so don't put shared objects there.) If found in any of those places, the DSO or library is linked with the objects foiled.o and again.o:ld foiled.o again.o -lcursesThe ≠G option, which formerly allowed you to specify which data items should be stored in the global pointer region, is no longer useful. ≠KPIC, the default, implies ≠G 0, and the compiler will ignore any user attempts to specify otherwise. Compiling ≠non_shared (to avoid ≠KPIC) is primarily useful only for creating device drivers, in which case there is no direct linking step in which to specify a ≠G number. For more information, see the cc and ld manual pages.† †LBL="" HELPID=""Linking Assembly Language ProgramsThe assembler driver ID="01.compiler22"as1 does not run the link editor. To link-edit a program written in assembly language, use one of these procedures:Assemble and link-edit using one of the other driver commands (ID="01.compiler23"cc, for example). The .s suffix of the assembly language source file causes the driver to invoke the assembler.Assemble the file using as; then link-edit the resulting object file with the ld command.LBL="" HELPID=""ID="98015"Specifying LibrariesID="01.compiler24"The link editor ID="01.compiler25"ld processes its arguments from left to right as they appear on the command line. Arguments to ld can be DSOs, object files, or libraries.When ld reads a DSO, it adds all the symbols from that DSO to a cumulative symbol table. If it encounters a symbol that's already in the symbol table, it does not change the symbol table entry; so if you define the same symbol in more than one DSO, only the first definition will be used.When ld reads an archive, usually denoted by a file name ending in .a, it uses only the object files from that archive that can resolve currently unresolved symbol references. (When a symbol is referred to but not defined in any of the object files that have been loaded so far, it's called unresolved.) Once a library has been searched in this way, it is never searched again; so libraries should come after object files on the command line in order to resolve as many references as possible. Note that if a symbol is already in the cumulative symbol table from having been encountered in a DSO, its definition in any subsequent library will be ignored.Libraries and DSOs can be specified either by explicitly stating a pathname or by use of the library search rules. To specify a library or DSO by path, simply include that path on the command line (relative to the current directory, or else absolute):ld myprog.o /usr/lib/libc.so.1 mylib.solibc.so.1 is the name of the standard C DSO, replacing the older libc.a. Similarly, libX11.so.1 is the X11 DSO. Most other DSOs are simply named name.so, with no .1 at the end.† †To use the linker's library search rules, specify the library with the ≠llibname option:ld myprog.o -lmylibWhen the ≠lmylib argument is processed, ld searches for a file called libmylib.so. If it can't find libmylib.so in a given directory, it tries to find libmylib.a there; if it can't find that either, it moves on to the next directory in its search order. The default search order is to look first in ID="01.compiler26"/lib, then in /usr/lib. After looking in both of those directories, ld will look in /usr/local/lib for archives only (DSOs should not be installed in /usr/local/lib). You can modify these defaults by specifying the ≠L† †dir and/or ≠nostdlib options. Directories specified by ≠L† †dir before the ≠llibname argument are searched in the order they appear on the command line, before the default directories are searched. If ≠nostdlib† †is specified, then ≠L† †dir must also be specified because the default directories will not be searched at all.If ld is invoked from one of the compiler drivers, all ≠L and ≠nostdlib options are moved up on the command line so that they appear before any ≠llibname option. For example:cc file1.o -lm -L mydirinvokes, at the linking stage of compilation:ld -L mydir file1.o -lmThere are three different kinds of files that contain object code files: non-shared libraries, PIC archives, and DSOs. Non-shared libraries are the old-fashioned kind of library, built using ar from .o files that were compiled with ≠non_shared. These archives must also be linked ≠non_shared. PIC archives are the default in IRIX 5.0, built using ar from .o files compiled with ≠KPIC (a default option); they can be linked with other PIC files. DSOs are built from PIC .o files by using ld ≠shared; see IDREF="92826" TYPE="TITLE"Chapter 2
 for details.† †When compiling multilanguage programs, be sure to specify any required runtime libraries using the ID="01.compiler27"≠llibname option. For a list of the libraries that a language uses, see the corresponding compiler driver manual page.If the link editor tells you that a reference to a certain function is unresolved, check that function's manual page to find out which library the function is in. If it isn't in one of the standard libraries (which ld links in by default), you may need to specify the appropriate library on the command line. For an alternative method of finding out where a function is defined, see IDREF="26263" TYPE="TITLE""Finding a symbol in an unknown library"
.Simply including the header file associated with a library routine is not enough; you also must specify the library itself when linking (unless it's a standard library). There is no magical connection between header files and libraries; header files only give prototypes for library routines, not the library code itself.† †LBL="" HELPID=""ExamplesTo link a sample program foo.c with the math DSO, libm.so, enter:cc foo.c -lmTo specify the appropriate DSOs for a graphics program foogl.c, enter:cc foogl.c -lgl -lX11LBL="" HELPID=""Linking to Dynamic Shared ObjectsID="01.compiler28"This section describes how to link your source files with previously built DSOs; for more information about how to build your own DSOs, see IDREF="92826" TYPE="TITLE"Chapter 2, "Dynamic Shared Objects."DSOs replace the older static shared libraries, which were named with the extension ID="01.compiler29"_s.a. The _s.a libraries are no longer shipped with IRIX; however, the runtime versions of those libraries, named with _s at the end (and no .a), are still present under IRIX 5.0 for backward compatibility with older executables that used static shared libraries.† †To build an executable that uses a DSO, call a compiler driver just as you would for a non-shared library. For instance,cc needle.c -lthreadlinks the resulting object file (needle.o) with the previously built DSO libthread.so (and the standard C DSO, libc.so.1), if available. If there is no libthread.so, but there is a PIC archive named libthread.a, that archive will be used with libc.so.1, and you will still get dynamic (runtime) linking. Note that even .a libraries now contain Position-Independent Code by default, though it is also possible to build non-shared .a libraries that do not contain PIC.LBL="" HELPID=""ID="71272"Linking Multilanguage ProgramsWhen the source language of the main program differs from that of a subprogram, use the following steps to link (refer to IDREF="77503" TYPE="GRAPHIC"Figure 1-2
):Compile object files from the source files of each language separately by using the ≠c option. For example, if the source consists of a Fortran main program (main.f) and two files of C functions (more.c and rest.c), use the commands:cc -c more.c rest.c
f77 -c main.fThese commands produce the object files main.o, more.o, and rest.o.Use the driver associated with the language of the main program to link the objects together:f77 main.o more.o rest.oThe compiler drivers will supply the default set of libraries necessary to produce an executable from the source of the associated language, but when producing executables from source code in several languages, you may need to explicitly specify the default libraries for one or more of the languages used. For instructions on specifying libraries, see IDREF="98015" TYPE="TITLE""Specifying Libraries."
† †LBL="1-2" FILE="1.2.cmplr.ctlflw.ps" POSITION="INLINE" SCALE="FALSE"LBL="1-2"Figure 1-2 ID="77503"Compilation Control Flow for Multilanguage ProgramsFor specific details about compiling multilanguage programs, refer to the programming guides for the appropriate languages.LBL="" HELPID=""ID="15589"DebuggingThe compiler system provides a debugging tool, dbx, which is explained in the dbx User's Guide. In addition, CASEVision/WorkShop‘ contains debugging tools. For information about obtaining WorkShop for your computer, contact your dealer or sales representative.Before using a debugging tool, you must use one of the standard driver options, listed in IDREF="42043" TYPE="TABLE"Table 1-5
, to produce executables containing information that the debugger can use.COLUMNS="2"LBL="1-5"Table 1-5 Driver Options for DebuggingID="42043"LEFT="0" WIDTH="54"Option LEFT="60" WIDTH="356"PurposeLEFT="0" WIDTH="54"≠g0LEFT="60" WIDTH="356"(Default) Produces a program object without debugging information. 
Reduces the size of the program object but retains optimizations. Use 
this option after you have finished debugging.LEFT="0" WIDTH="54"≠g1LEFT="60" WIDTH="356"Specifies accurate, but limited, source-level debugging. This option 
performs most optimizations.LEFT="0" WIDTH="54"≠g or ≠g2LEFT="60" WIDTH="356"Specifies full source-level debugging. These options suppress 
optimizations that might interfere with full debugging.LEFT="0" WIDTH="54"≠g3LEFT="60" WIDTH="356"Specifies full, but inaccurate, debugging on fully optimized code. This 
level of debugger output can be confusing or misleading. Specify this 
option only for programs that malfunction after you optimize them.LBL="" HELPID=""ID="65767"Getting Information about Object FilesID="01.compiler30"The following tools provide information on object files as indicated:ID="01.compiler31"elfdump lists the contents (including the symbol table and header information) of an ELF-format object file.ID="01.compiler32"file† †provides descriptive information on the general properties of the specified file.ID="01.compiler33"nm lists symbol table information.ID="01.compiler34"odump lists the contents of a COFF-format object file.ID="01.compiler35"size† †prints the size of each section of an object file (some such sections are named text, data, and sbss). The a.out(4) manual page describes the format of these sections.LBL="" HELPID=""Listing Selected Parts of Object Files and Libraries with elfdumpID="01.compiler36"The elfdump tool lists headers, tables, and other selected parts of an ELF-format object file or archive file.LBL="" HELPID=""SyntaxID="01.compiler37"elfdump options† †filename1† †[filename2..filenamen]options One or more of the options listed in IDREF="81698" TYPE="TABLE"Table 1-6
.filename Specifies the name of one or more object files whose contents are to be dumped.For more information, see the elfdump(1) manual page.COLUMNS="2"LBL="1-6"Table 1-6 ID="81698"Elfdump OptionsLEFT="0" WIDTH="81"† †OptionLEFT="90" WIDTH="356"DumpsLEFT="0" WIDTH="81"≠crLEFT="90" WIDTH="356"Compact relocation information.LEFT="0" WIDTH="81"≠DcLEFT="90" WIDTH="356"Conflict list in Dynamic Shared Objects.LEFT="0" WIDTH="81"≠DgLEFT="90" WIDTH="356"Global Offset Table in Dynamic Shared Objects.LEFT="0" WIDTH="81"≠DlLEFT="90" WIDTH="356"Library list in Dynamic Shared Objects.LEFT="0" WIDTH="81"≠DtLEFT="90" WIDTH="356"String table entries of the dynamic symbol table in Dynamic 
Shared Objects.LEFT="0" WIDTH="81"≠fLEFT="90" WIDTH="356"The file header.LEFT="0" WIDTH="81"≠hLEFT="90" WIDTH="356"All section headers in the file.LEFT="0" WIDTH="81"≠hashLEFT="90" WIDTH="356"Hash table entries.LEFT="0" WIDTH="81"≠LLEFT="90" WIDTH="356"Dynamic section in Dynamic Shared Objects.LEFT="0" WIDTH="81"≠oLEFT="90" WIDTH="356"Program header.LEFT="0" WIDTH="81"≠rLEFT="90" WIDTH="356"Relocation information.LEFT="0" WIDTH="81"≠regLEFT="90" WIDTH="356"Register info.LEFT="0" WIDTH="81"≠tLEFT="90" WIDTH="356"Symbol table entries.LBL="" HELPID=""Determining File Type with fileID="01.compiler38"The file tool lists the properties of program source, text, object, and other files. This tool attempts to identify the contents of files using various heuristics. It is not exact and is occasionally fooled. For example, it often erroneously recognizes command files as C programs. For more information, see the file(1) manual page.LBL="" HELPID=""SyntaxID="01.compiler39"file filename1† †[filename2..filenamen]where each filename is the name of a file to be examined.LBL="" HELPID=""ExampleInformation given by file is self-explanatory for most kinds of files, but using file on object files and executables gives somewhat cryptic output. In this example, "MSB" indicates Most Significant Byte, also called Big-Endian; "dynamic executable" means the executable was linked with DSO libraries; and "(not stripped)" means the executable contains at least some symbol table information. "Dynamic lib" indicates a DSO.file test.o a.out /lib/libc.so.1
test.o:        ELF 32-bit MSB relocatable MIPS - version 1
a.out:         ELF 32-bit MSB dynamic executable (not stripped) MIPS - version 1
/lib/libc.so.1:   ELF 32-bit MSB dynamic lib MIPS - version 1LBL="" HELPID=""ID="38022"Listing Symbol Table Information: nmID="01.compiler40"The nm tool lists symbol table information for object files and archive files.LBL="" HELPID=""SyntaxID="01.compiler41"nm options† †filename1 [filename2..filenamen]optionsOne or more of the options listed in IDREF="46733" TYPE="TABLE"Table 1-7
.filename Specifies the object files or archive files from which symbol table information is to be extracted. If you do not specify a file name, nm assumes the file is called a.out.COLUMNS="2"LBL="1-7"Table 1-7 Symbol Table Dump OptionsID="46733"LEFT="0" WIDTH="46"Option LEFT="55" WIDTH="356"PurposeLEFT="0" WIDTH="46"≠aLEFT="55" WIDTH="356"Prints debugging information. If used with ≠B, uses BSD ordering with 
System V formatting.LEFT="0" WIDTH="46"≠ALEFT="55" WIDTH="356"Prints the listing in System V format (default).LEFT="0" WIDTH="46"≠bLEFT="55" WIDTH="356"Prints the value field in octal.LEFT="0" WIDTH="46"≠BLEFT="55" WIDTH="356"Prints the listing in BSD format.LEFT="0" WIDTH="46"≠dLEFT="55" WIDTH="356"Prints the value field in decimal (the default for System V output).LEFT="0" WIDTH="46"≠eLEFT="55" WIDTH="356"Prints only external and static variables.LEFT="0" WIDTH="46"≠hLEFT="55" WIDTH="356"Suppresses printing of headers.LEFT="0" WIDTH="46"≠nLEFT="55" WIDTH="356"Sorts external symbols by name for System V format. Sorts all symbols 
by value for Berkeley format (by name is the BSD default output).LEFT="0" WIDTH="46"≠oLEFT="55" WIDTH="356"Prints value field in octal (System V output). Prints the file name 
immediately before each symbol name (BSD output).LEFT="0" WIDTH="46"≠pLEFT="55" WIDTH="356"Lists symbols in the order they appear in the symbol table.LEFT="0" WIDTH="46"≠rLEFT="55" WIDTH="356"Reverses the sort that you specified for external symbols with the ≠n and 
≠v options.LEFT="0" WIDTH="46"≠TLEFT="55" WIDTH="356"Truncates characters in exceedingly long symbol names; inserts an 
asterisk as the last character of the truncated name. This option may 
make the listing easier to read.LEFT="0" WIDTH="46"≠uLEFT="55" WIDTH="356"Prints only undefined symbols.LEFT="0" WIDTH="46"≠vLEFT="55" WIDTH="356"Sorts external symbols by value (default for Berkeley format).LEFT="0" WIDTH="46"≠VLEFT="55" WIDTH="356"Prints the version number of nm.LEFT="0" WIDTH="46"≠xLEFT="55" WIDTH="356"Prints the value field in hexadecimal.IDREF="19204" TYPE="TABLE"Table 1-8 defines the one-character codes shown in an nm listing. Refer to the example that follows the table for a sample listing.COLUMNS="2"LBL="1-8"Table 1-8 Character Code MeaningsID="19204"LEFT="0" WIDTH="37"KeyLEFT="45" WIDTH="356"DescriptionLEFT="0" WIDTH="37"aLEFT="45" WIDTH="356"Local absolute dataLEFT="0" WIDTH="37"ALEFT="45" WIDTH="356"External absolute dataLEFT="0" WIDTH="37"bLEFT="45" WIDTH="356"Local zeroed dataLEFT="0" WIDTH="37"BLEFT="45" WIDTH="356"External zeroed dataLEFT="0" WIDTH="37"CLEFT="45" WIDTH="356"Common dataLEFT="0" WIDTH="37"dLEFT="45" WIDTH="356"Local initialized dataLEFT="0" WIDTH="37"DLEFT="45" WIDTH="356"External initialized dataLEFT="0" WIDTH="37"ELEFT="45" WIDTH="356"Small common dataLEFT="0" WIDTH="37"GLEFT="45" WIDTH="356"External small initialized dataLEFT="0" WIDTH="37"NLEFT="45" WIDTH="356"Nil storage class (avoids loading of unused external references)LEFT="0" WIDTH="37"rLEFT="45" WIDTH="356"Local read-only dataLEFT="0" WIDTH="37"RLEFT="45" WIDTH="356"External read-only dataLEFT="0" WIDTH="37"sLEFT="45" WIDTH="356"Local small zeroed dataLEFT="0" WIDTH="37"SLEFT="45" WIDTH="356"External small zeroed dataLEFT="0" WIDTH="37"tLEFT="45" WIDTH="356"Local textLEFT="0" WIDTH="37"TLEFT="45" WIDTH="356"External textLEFT="0" WIDTH="37"ULEFT="45" WIDTH="356"External undefined dataLEFT="0" WIDTH="37"VLEFT="45" WIDTH="356"External small undefined dataLBL="" HELPID=""ExampleThis example demonstrates how to obtain a symbol table listing. Consider the following program, tnm.c: #include <stdio.h>
#include <math.h>
#define LIMIT 12
int unused_item = 14;
double mydata[LIMIT];

main()
{
† †   int i;
† †   for(i = 0; i < LIMIT; i++) {
† †       mydata[i] = sqrt((double)i);
† †   }
† †   return 0;
}Compile the program into an object file by entering:cc -c tnm.cTo obtain symbol table information for the object file tnm.o in BSD format, use the nm ≠B command:nm -B tnm.o0000000000 T main
0000000000 B mydata
0000000000 U sqrt
0000000000 D unused_item
00000000 N _bufendtabTo obtain symbol table information for the object file tnm.o in System V format use the nm command without any options:nm tnm.o
Symbols from tnm.o:

[Index]   Value     Size    Class    Type         Section    Name

[0]     |        0|        |File    |ref=4       |Text     | tnm.c
[1]     |        0|        |Proc    |end=3 int   |Text     | main
[2]     |      116|        |End     |ref=1       |Text     | main
[3]     |        0|        |End     |ref=0       |Text     | tnm.c
[4]     |        0|        |File    |ref=6       |Text     | /usr/include/math.h
[5]     |        0|        |End     |ref=4       |Text     | /usr/include/math.h
[6]     |        0|        |Global  |            |Data     | unused_item
[7]     |        0|        |Global  |            |Bss      | mydata
[8]     |        0|        |Proc    |ref=1       |Text     | main
[9]     |        0|        |Proc    |            |Undefined| sqrt
[10]    |        0|        |Global  |            |Undefined| _gp_disp
ID="01.compiler42"LBL="" HELPID=""ID="26263"Finding a symbol in an unknown libraryWhen ld indicates that a symbol is undefined, you can use nm to figure out which DSO or library needs to be linked in by piping nm's output through appropriate greps.LBL="" HELPID=""ExampleYou're trying to compile a program, and ld tells you that you're trying to use an undefined symbol:cc prog.c -lgl
ld:
Unresolved:
XGetPixelBut you don't know where XGetPixel is defined. So use nm to list the symbol tables for all of the available DSOs, and filter that output to find only the places where XGetPixel is mentioned. Then filter the result to find only the places where XGetPixel is actually defined, as indicated by the T character code.nm -Bo /usr/lib/lib*.so* | grep XGetPixel | grep T
/usr/lib/libX11.so.1: 0f790ff8 T XGetPixel
Some DSOs end in .so.so.1So now we now that XGetPixel is defined in /usr/lib/libX11.so.1, the X11 DSO; use the ≠l option to tell cc to link in that library, and ld won't complain any more.cc prog.c -lgl -lX11LBL="" HELPID=""Listing Selected Parts of COFF Files with odumpID="01.compiler43"The odump tool lists headers, tables, and other selected parts of a COFF-format object or archive file. It is provided with this release of IRIX for compatibility; use elfdump for ELF-format files.LBL="" HELPID=""SyntaxID="01.compiler44"odump options† †filename1† †[filename2..filenamen]options One or more of the options listed in IDREF="33884" TYPE="TABLE"Table 1-9
.filename Specifies the name of one or more object files whose contents are to be dumped.For more information, see the odump(1) manual page.COLUMNS="2"LBL="1-9"Table 1-9 ID="33884"Odump OptionsLEFT="0" WIDTH="72"OptionLEFT="80" WIDTH="356"DumpsLEFT="0" WIDTH="72"≠aLEFT="80" WIDTH="356"Archive header of each object file in the specified archive library 
file.LEFT="0" WIDTH="72"≠cLEFT="80" WIDTH="356"String table.LEFT="0" WIDTH="72"≠d numberLEFT="80" WIDTH="356"The section numbered number, or a range of sections starting 
with number and ending with the last section number available 
(or the number you specify with the +d auxiliary option).LEFT="0" WIDTH="72"+d numberLEFT="80" WIDTH="356"All sections starting with the first section (or with the section 
specified with the ≠d option) and ending with the section 
numbered number.LEFT="0" WIDTH="72"≠fLEFT="80" WIDTH="356"File header for each object file in the specified file.LEFT="0" WIDTH="72"≠FLEFT="80" WIDTH="356"File descriptor table for each object file in the specified file.LEFT="0" WIDTH="72"≠gLEFT="80" WIDTH="356"Global symbols in the symbol table of an archive library file.LEFT="0" WIDTH="72"≠hLEFT="80" WIDTH="356"Section headers.LEFT="0" WIDTH="72"≠iLEFT="80" WIDTH="356"Symbolic information header.LEFT="0" WIDTH="72"≠lLEFT="80" WIDTH="356"Line number information.LEFT="0" WIDTH="72"≠n† †nameLEFT="80" WIDTH="356"Information for section named name only. Use this option with 
the ≠h, ≠s, ≠r, ≠l, or ≠t option.LEFT="0" WIDTH="72"≠oLEFT="80" WIDTH="356"Optional header for each object file.LEFT="0" WIDTH="72"≠pLEFT="80" WIDTH="356"Suppresses the printing of headers.LEFT="0" WIDTH="72"≠PLEFT="80" WIDTH="356"Procedure descriptor table.LEFT="0" WIDTH="72"≠rLEFT="80" WIDTH="356"Relocation information.LEFT="0" WIDTH="72"≠RLEFT="80" WIDTH="356"Relative file index table.LEFT="0" WIDTH="72"≠sLEFT="80" WIDTH="356"Section contents.LEFT="0" WIDTH="72"≠tLEFT="80" WIDTH="356"Symbol table entries.LEFT="0" WIDTH="72"≠t† †indexLEFT="80" WIDTH="356"Only the indexed symbol table entry. Use the +t option with the 
≠t option to specify a range of table entries.LEFT="0" WIDTH="72"+t† †indexLEFT="80" WIDTH="356"Symbol table entries in a range that ends with the indexed entry. 
The range begins with the first symbol table entry or with the 
section that you specify with the ≠t option.LEFT="0" WIDTH="72"≠vLEFT="80" WIDTH="356"Information in symbolic rather than numeric representation. 
This option may be used with any odump option except ≠s.LEFT="0" WIDTH="72"≠z† †name, numberLEFT="80" WIDTH="356"Line number entry (or a range of entries starting at the specified 
number) for the named function.LEFT="0" WIDTH="72"+z† †numberLEFT="80" WIDTH="356"Line number entries starting with the function name or line 
number specified by the ≠z option and ending with number.ID="01.compiler45"LBL="" HELPID=""Determining Section Sizes with sizeID="01.compiler46"The size tool prints information about the sections (such as text, rdata, and sbss) of the specified object or archive files.LBL="" HELPID=""SyntaxID="01.compiler47"size options† †[filename1† †filename2..filenamen]optionsSpecifies the format of the listing (see IDREF="34039" TYPE="TABLE"Table 1-10
).filenameSpecifies the object or archive files whose properties are to be listed. If you do not specify a file name, the default is a.out.COLUMNS="2"LBL="1-10"Table 1-10 Size OptionsID="34039"LEFT="0" WIDTH="46"OptionLEFT="55" WIDTH="356"ActionLEFT="0" WIDTH="46"≠ALEFT="55" WIDTH="356"Prints data section headers in System V format.LEFT="0" WIDTH="46"≠BLEFT="55" WIDTH="356"Prints data section headers in Berkeley format.LEFT="0" WIDTH="46"≠dLEFT="55" WIDTH="356"Prints sizes in decimal (default).LEFT="0" WIDTH="46"≠FLEFT="55" WIDTH="356"Prints data on loadable segments.LEFT="0" WIDTH="46"≠nLEFT="55" WIDTH="356"Prints symbol table, global pointer, and more.LEFT="0" WIDTH="46"≠oLEFT="55" WIDTH="356"Prints sizes in octal.LEFT="0" WIDTH="46"≠sLEFT="55" WIDTH="356"Follows shared libraries, adding them as they're encountered to the list 
of files to be sized.LEFT="0" WIDTH="46"≠VLEFT="55" WIDTH="356"Prints the version of size that you are using.LEFT="0" WIDTH="46"≠xLEFT="55" WIDTH="356"Prints sizes in hexadecimal.LBL="" HELPID=""ExampleBelow are examples of the size command and the listings they produce:size -B -o test.o† †       text   data  bss    rdata  sdata  sbss  decimal  hex
test.o  31250  2010  40470  550    210    50    31232    7a00size -B -d test.o† †       text   data  bss    rdata  sdata  sbss  decimal  hex
test.o  12968  1032  16696  360    136    40    31232    7a00LBL="" HELPID=""ID="94723"Using the Archiver to Create LibrariesID="01.compiler48"An archive library is a file that includes the contents of one or more object (.o) files. When the link editor (ld) searches for a symbol in an archive library, it loads only the code from the object file where that symbol was defined (not the entire library) and links it with the calling program.The archiver (ar) creates and maintains archive libraries and has the following main functions:Copying new objects into the libraryReplacing existing objects in the libraryMoving objects around within the libraryExtracting individual objects from the libraryThe following section explains the syntax of the ar command and lists some examples of how to use it. See the ar(1) manual page for details.ar simply strings together whatever object files you tell it to archive; thus, it can be used to build either non-shared or PIC libraries, depending on how the included .o files were built in the first place. If you do create a non-shared library with ar, remember to link it ≠non_shared with your other code. For information about building DSOs and converting libraries to DSOs, see IDREF="92826" TYPE="TITLE"Chapter 2
.† †LBL="" HELPID=""SyntaxID="01.compiler49"ar options [posObject] libName [object1...objectn]options Specifies the action that the archiver is to take. IDREF="68022" TYPE="TABLE"Table 1-11
, IDREF="94696" TYPE="TABLE"Table 1-12
, and IDREF="80707" TYPE="TABLE"Table 1-13
 list the available options. To specify more than one option, don't use a dash or put spaces between the options. For example, use ar ts, not ar ≠t ≠s.posObject Specifies the name of an object within an archive library. It specifies the relative placement (either before or after posObject) of an object that is to be copied into the library or moved within the library. This parameter is required when the a, b, or i† †suboptions are specified with the m or r option. The last example in IDREF="99984" TYPE="TITLE""Examples,"
 shows the use of a posObject parameter.libName Specifies the name of the archive library you are creating, updating, or extracting information from.object Specifies the name(s) of the object file(s) to manipulate.LBL="" HELPID=""Archiver OptionsID="01.compiler50"When running the archiver, specify exactly one of the options d, m, p, q, r, t, or x (listed in IDREF="68022" TYPE="TABLE"Table 1-11
). In addition, you can optionally specify any of the modifiers in IDREF="94696" TYPE="TABLE"Table 1-12
, as well as any of the archiver suboptions listed in IDREF="80707" TYPE="TABLE"Table 1-13
.COLUMNS="2"LBL="1-11"Table 1-11 ID="68022"Archiver OptionsLEFT="0" WIDTH="37"Option LEFT="45" WIDTH="356"PurposeLEFT="0" WIDTH="37"dLEFT="45" WIDTH="356"Deletes the specified objects from the archive.LEFT="0" WIDTH="37"mLEFT="45" WIDTH="356"Moves the specified files to the end of the archive. If you want to move the 
object to a specific position in the archive library, specify an a, b, or i 
suboption together with a posObject parameter.LEFT="0" WIDTH="37"pLEFT="45" WIDTH="356"Prints the specified objects in the archive on the standard output device 
(usually the terminal screen).LEFT="0" WIDTH="37"qLEFT="45" WIDTH="356"Adds the specified object files to the end of the archive. This option is 
similar to the r option (described below), but is faster and does not remove 
any older versions of the object files that may already be in the archive. 
Use the q option when creating a new library.LEFT="0" WIDTH="37"rLEFT="45" WIDTH="356"Adds the specified object files to the end of the archive file. If an object file 
with the same name already exists in the archive, the new object file will 
overwrite it. If you want to add an object at a specific position in the 
archive library, specify an a, b, or i suboption together with a posObject 
parameter. Use the r option when updating existing libraries.LEFT="0" WIDTH="37"tLEFT="45" WIDTH="356"Prints a table of contents on the standard output (usually the screen) for 
the specified object or archive file.LEFT="0" WIDTH="37"xLEFT="45" WIDTH="356"Copies the specified objects from the archive and places them in the 
current directory. Duplicate files are overwritten. The last modified date is 
the current date (unless you specify the o suboption, in which case the date 
stamp on the archive file is the last modified date). If no objects are 
specified, copies all the library objects into the current directory.COLUMNS="2"LBL="1-12"Table 1-12 ID="94696"Archiver ModifiersLEFT="0" WIDTH="37"Option LEFT="45" WIDTH="356"PurposeLEFT="0" WIDTH="37"cLEFT="45" WIDTH="356"Suppresses the warning message that the archiver issues when it discovers 
that the archive you specified does not already exist.LEFT="0" WIDTH="37"CLEFT="45" WIDTH="356"Makes an archive compatible with pre-SVR4 IRIX.LEFT="0" WIDTH="37"ELEFT="45" WIDTH="356"The default; creates an archive matching the specifications given by the 
SVR4 ABI.LEFT="0" WIDTH="37"lLEFT="45" WIDTH="356"Puts the archiver's temporary files in the current working directory. 
Ordinarily, the archiver puts those files in /tmp (unless the STMDIR 
environment variable is set, in which case ar stores temporary files in the 
directory indicated by that variable). This option is useful when /tmp (or 
STMDIR) is full.LEFT="0" WIDTH="37"sLEFT="45" WIDTH="356"Creates a symbol table in the archive. This modifier is rarely necessary 
since the archiver updates the symbol table of the archive library 
automatically. Options m, p, q, and r, in particular, create a symbol table by 
default and thus do not require s to be specified.LEFT="0" WIDTH="37"vLEFT="45" WIDTH="356"Lists descriptive information during the process of creating or modifying 
the archive. When specified with the t option, produces a verbose table of 
contents.COLUMNS="3"LBL="1-13"Table 1-13 Archiver SuboptionsID="80707"LEFT="0" WIDTH="63"Suboption LEFT="70" WIDTH="72"Use with OptionLEFT="150" WIDTH="356"PurposeLEFT="0" WIDTH="63"aLEFT="70" WIDTH="72"m or rLEFT="150" WIDTH="356"Specifies that the object file being added should 
follow the already-archived object file specified 
by the posObject parameter on the command line.LEFT="0" WIDTH="63"bLEFT="70" WIDTH="72"m or rLEFT="150" WIDTH="356"Specifies that the object file precede the object file 
specified by the posObject parameter.LEFT="0" WIDTH="63"iLEFT="70" WIDTH="72"m or rLEFT="150" WIDTH="356"Same as b.LEFT="0" WIDTH="63"oLEFT="70" WIDTH="72"xLEFT="150" WIDTH="356"Forces the last modified date of the extracted 
object file to match that of the archive file.LEFT="0" WIDTH="63"uLEFT="70" WIDTH="72"rLEFT="150" WIDTH="356"Tells the archiver not to replace the existing 
object file in the archive if the last modified date 
indicates that the object file already in the archive 
is newer (more recently modified) than the one 
you're adding.The a and b suboptions are only useful if the same symbol is defined in two or more of the object files in the archive (in which case, the symbol table shows the first definition listed in the archive). Under other circumstances, order of object files in an archive is irrelevant (and the a and b suboptions are useless), since ld uses the archive symbol table rather than searching linearly through the file.† †LBL="" HELPID=""ID="99984"ExamplesCreate a new library, libtest.a, and add object files to it by entering:ar cq libtest.a mcount.o mon1.o string.oThe c option suppresses an archiver message during the creation process. The q option creates the library and puts mcount.o, mon1.o, and† †string.o into it.An example of replacing an object file in an existing library:ar r libtest.a mon1.oThe r option replaces mon1.o in the library libtest.a. If mon1.o does not already exist in the library libtest.a, it is added.If you specify the same file twice in an argument list of files to be added to an archive, that file will appear twice in the archive.† †To add a new file immediately before mcount.o in this library, enter:ar rb mcount.o libtest.a new.oThe r option adds new.o to the library libtest.a. The b option followed by mcount.o as the posObject causes the archiver to place new.o immediately before mcount.o in the archive.ID="01.compiler51"LBL="2"ID="92826"Dynamic Shared ObjectsID="02.dso1"Dynamic shared objects (DSOs) take the place of static shared libraries used by earlier versions of IRIX. The principle advantages of DSOs are that they do not need to be created with fixed load addresses, as did static shared libraries, and that they can be dynamically loaded under programmatic control. Both of these features are possible because of the new runtime linker, ID="02.dso2"ID="02.dso3"ID="02.dso4"rld, which can resolve external references between objects and relocate objects at runtime.This chapter contains the following major sections:IDREF="86160" TYPE="TITLE""Building DSOs" explains how to build a DSO.IDREF="17473" TYPE="TITLE""Runtime Linking" discusses the runtime linker, and how it locates DSOs at runtime.IDREF="92334" TYPE="TITLE""Dynamic Loading under Program Control" explains the use of the libdl library to control runtime linking.IDREF="51258" TYPE="TITLE""Taking Advantage of Quickstart" discusses an optimization you can use to make sure that DSOs you build load as quickly as possible.IDREF="50766" TYPE="TITLE""Versioning of DSOs" discusses a versioning mechanism for DSOs that allows binaries linked against different, incompatible versions of the same DSO to run correctly.LBL="" HELPID=""ID="86160"Building DSOsID="02.dso5"In most cases, you can build DSOs as easily as normal libraries. If your library is written in a high-level language, such as C or Fortran, you won't have to make any changes to the source code. If your code is in assembly language, it will have to be modified to produce PIC, as described in IDREF="27381" TYPE="TITLE"Appendix A, "Position-Independent Coding in Assembly Language."To create a DSO from a set of object files, use ID="02.dso6"ld with the ≠shared option:ld ≠shared stuff.o nonsense.o ≠o libdada.so The above example creates a DSO, libdada.so, from two object files, stuff.o and nonsense.o. Note that DSO names should begin with "lib" and end with ".so", for ease of use with the compiler driver's ID="02.dso7"≠llib argument. If you're already building a regular library (.a file), you can create a DSO from the library by using the ≠shared and ≠all arguments to ld:ld ≠shared ≠all libdada.a ≠o libdada.soThe ≠all argument specifies that all of the object files from the library, libdada.a, should be included in the DSO.LBL="" HELPID=""Compiling Code for DSOsAll object code that is incorporated into a DSO or linked with a DSO must be Position-Independent Code (PIC). The high-level language compilers, such as ID="02.dso8"cc and f77, generate PIC automatically, so there is no need to modify any source code to produce PIC. Assembly language sources must be modified to produce PIC, however. For instructions on how to modify assembly language files to generate PIC, see IDREF="27381" TYPE="TITLE"Appendix A
.LBL="" HELPID=""DSO DependenciesWhen mixing archives and DSOs, remember that an unresolved reference in a DSO will not cause a module of an archive to be associated with the main program. So when building a DSO, you should include any archives required by the DSO on the link line. For instance, if you want to make the archive libmine.a into a DSO, and libmine.a depends on routines in another archive, libutil.a, you should include libutil.a on the link line:ld ≠shared ≠all libmine.a ≠o libmine.so libutil.aThis will cause the modules in libutil.a that are referenced in libmine.a to be included in the DSO. Similarly, if a DSO relies on another DSO, you should include that DSO on the link line. For example:ld ≠shared ≠all libbtree.a ≠o libbtree.so ≠lmallocThis example will cause libmalloc.so to be placed in the liblist of the new DSO, libbtree.so. This ensures that libmalloc.so will be loaded whenever an executable that uses libbtree.so is launched.LBL="" HELPID=""Options for Building Shared ObjectsThere are a few special options you can use with ID="02.dso9"ld when building DSOs. When creating a DSO from a preexisting library, you can use the ≠exclude argument to prevent individual object files from the library from being included in the DSO. For example, to make libdada.a into a DSO, but exclude the nonsense.o object file, use the command:ld ≠shared ≠all libdada.a ≠exclude nonsense.o ≠o libdada.soBy default, the runtime linker will attempt to resolve symbols in a DSO by searching the main executable's symbol table first, then searching the symbol tables of other DSOs appearing earlier on the link line. This means that a symbol defined in one DSO can be redefined in the main executable or in a DSO appearing earlier on the link line. If you wish to prevent this, you can build the DSO with the ID="02.dso10"≠B symbolic argument to ld:ld ≠shared ≠B symbolic ≠all libdada.a ≠o libdada.soLBL="" HELPID=""ID="17473"Runtime LinkingID="02.dso11"When you run a dynamically linked executable, the runtime linker, rld, identifies the DSOs required by the executable, loads the required DSOs, and if necessary relocates DSOs within the process's virtual address space, so that no two DSOs occupy the same location.LBL="" HELPID=""Searching for DSOs at RuntimeThe program header of a dynamically linked executable contains a field, the liblist, which lists the DSOs required by the executable. When looking for a DSO, ID="02.dso12"rld searches directories in the following sequence:the path of the DSO in the liblist (if an explicit path is given)RPATH if it is defined in the main executableLD_LIBRARY_PATH if definedthe default path (/lib:/usr/lib)Although ld searches the directory /usr/local/lib when searching for libraries, rld does not search this directory by default, so you should not place DSOs in this directory.† †RPATH is a colon-separated list of directories stored in the main executable. You can set RPATH by using the ≠rpath argument to ld:ld ≠o myprog myprog.c ≠rpath /d/src/mylib libmylib.so ≠lcThis example link the program against libmylib.so in the current directory, and configures the executable such that rld will search the directory /d/src/mylib when searching for DSOs.The LD_LIBRARY_PATH environment variable is a colon-separated list of directories to search for DSOs. This can be very useful for testing new versions of DSOs before installing them in their final location.The environment variable _RLD_ROOT may be set to a colon-separated list of directories. The runtime linker prepends these to the paths in RPATH and the paths in the default search path. In all of the colon-separated directory lists, an empty field is interpreted as the current directory. A leading or trailing colon counts as an empty field. Thus, if you set LD_LIBRARY_PATH to:/d/src/lib1:/d/src/lib2:the runtime linker will search the directory /d/src/lib1, then the directory /d/src/lib2, then the current directory. For security reasons, if an executable is set-user-ID or set-group-ID, the runtime linker will ignore the environment variables LD_LIBRARY_PATH and _RLD_ROOT. However, it will still search the directories in RPATH and the default path.† †In most cases, the DSOs will be loaded at their default addresses, so no relocations need be done.LBL="" HELPID=""Runtime Symbol ResolutionDynamically linked executables may contain symbol references that are not resolved before runtime. Any symbol references in your main program or in an archive must be resolved at link time, unless you specify the ≠ignore_unresolved argument to cc. DSOs may contain references that are not resolved at link time. All data symbols must be resolved at exec time. If rld finds an unresolvable data symbol at exec time, it will cause the executable to exit with an error. Text symbols are only resolved when they are used, so a program can run with unresolved text symbols, as long as the unresolved symbols aren't used.You can force rld to resolve text symbols at exec time by setting the environment variable LD_BIND_NOW. If there are unresolvable text symbols in your executable, and LD_BIND_NOW is set, the executable will exit with an error, just as if there were unresolvable data symbols.Remember that when you link a program with a DSO, all of the symbols in the DSO become associated with the executable. This could cause unexpected results if archives that contain unresolved externals are converted to DSOs. When linking with a PIC archive, the linker will only link in object files that satisfy unresolved references. If an object file in an archive contains an unresolved external reference, the linker will only try to resolve the reference when that object file is linked in to your program. In contrast, if a DSO contains an external data reference that cannot be resolved at exec time, it will cause the program to fail. Therefore, you should exercise caution when converting archives with external data references into DSOs.ID="02.dso13"For example, suppose you have an archive, mylib.a, and one of the object files in the archive, has_extern.o, references an external variable, foo. As long as your program doesn't reference any symbols in has_extern.o, the program will link and run properly. If your program references a symbol in has_extern.o and doesn't define foo, then the link will fail. However, if you convert mylib.a into a DSO, then any program that uses the DSO and doesn't define foo will fail at runtime, regardless of whether the program references any symbols from has_extern.o.There are two suggested solutions to this problem. The first consists of simply adding a "dummy" definition of the data to the DSO. A data definition appearing in the main executable will preempt one appearing in the DSO itself. This may, however, be misleading for executables that use the portion of the DSO that needs the data, but that failed to define it in the main program. The second solution consists of separating the routines that use the data definition into a second DSO, and placing dummy functions for them in the first DSO. The second DSO can then be dynamically loaded the first time any of the dummy functions is accessed. Each of the dummy functions will have to verify that the second DSO was loaded before calling the real function (which must have a unique name). This way, programs will run whether or not they supply the missing external data, as long as they don't call any of the functions that require the data. The first time one of the dummy functions is called, it will try to dynamically load the second DSO. Programs that do not supply the missing data will fail at this point. For more information on dynamic loading, see IDREF="92334" TYPE="TITLE""Dynamic Loading under Program Control,"
 below.LBL="" HELPID=""ID="92334"Dynamic Loading under Program ControlID="02.dso14"IRIX provides a library interface to the runtime linker that allows programs to dynamically load and unload DSOs. This interface is called libdl, and it consists of four functions, listed in IDREF="60563" TYPE="TABLE"Table 2-1
:COLUMNS="2"LBL="2-1"Table 2-1 ID="60563" libdl functionsLEFT="0" WIDTH="39"FunctionLEFT="45" WIDTH="356"PurposeLEFT="0" WIDTH="39"dlopen()LEFT="45" WIDTH="356"load a DSOLEFT="0" WIDTH="39"dlsym()LEFT="45" WIDTH="356"find a symbol in a loaded DSOLEFT="0" WIDTH="39"dlclose()LEFT="45" WIDTH="356"unload a DSOLEFT="0" WIDTH="39"dlerror()LEFT="45" WIDTH="356"report errorsTo load a DSO, call ID="02.dso15"dlopen():include <dlfcn.h>
void *dlhandle;
 ...
dlhandle = dlopen("/usr/lib/mylib.so", RTLD_LAZY);
if (dlhandle == NULL) {
 /* couldn't open DSO */
 printf("Error: %s\n", dlerror());
}The first argument to dlopen() is the pathname of the DSO to be loaded. This may be either an absolute or a relative pathname. When you call this routine, the runtime linker will try to load the specified DSO. If you have any unresolved references in the executable that are defined in the DSO, the runtime linker will resolve these references on demand. You can also use dlsym() to access symbols in the DSO, whether the symbols are referenced in your executable or not.When a DSO is brought into the address space of a process, it may contain references to symbols whose addresses are not known until the object is loaded. These references must be relocated before the symbols can be accessed. The second argument to dlopen() governs when these relocations take place and may have the following values:† †RTLD_LAZY Under this mode, only references to data symbols are relocated when the object is loaded. References to functions are not relocated until a given function is invoked for the first time. This mode should result in better performance, since a process may not reference all of the functions in any given shared object.† †RTLD_NOW Under this mode, all necessary relocations are performed when the object is first loaded. This may result in some wasted effort, if relocations are performed for functions that are never referenced, but is useful for applications that need to know as soon as an object is loaded that all symbols referenced during execution will be available.To access symbols that are not referenced in your program, use ID="02.dso16"dlsym():#include <dlfcn.h>
void *dlhandle;
int (*funcptr)(int);
int i,j;
 ... load DSO ... 
funcptr = (int (*)(int)) dlsym(dlhandle, "factorial");
if (funcptr == NULL) {
 /* couldn't locate the symbol */
}
i = (*funcptr)(j);In this example, we look up the address of a function called factorial() and assign it to the function pointer funcptr.If you encounter an error (ID="02.dso17"dlopen() or dlsym() returns NULL), you can get diagnostic information by calling dlerror(). The dlerror() function returns a string describing the cause of the latest error. You should only call dlerror() after an error has occurred; at other times, its return value is undefined.To unload a DSO, call ID="02.dso18"dlclose():#include <dlfcn.h>
void *dlhandle;
 .. load DSO, use DSO symbols ...
dlclose(dlhandle);
ID="02.dso19"LBL="" HELPID=""ID="51258"Taking Advantage of QuickstartQuickstart is an optimization whereby each DSO is assigned a default address to load at. When you link an executable with a DSO, ld fills in addresses for references to the DSO as if the DSO were loaded at this default address. If nothing unusual happens when you start up an executable, all the shared objects map at their Quickstart addresses, and rld does not need to do any relocation.If something goes wrong, and more than one shared object wishes to be mapped at a given address, rld moves one of them to an unused address and performs a relocation pass to fix up the address references.You can make sure that your shared objects do not conflict with each other by using a Quickstart registry file. The registry files contain location information for shared objects. When creating a shared object, you can specify a registry file to ld, and ld will ensure that your shared object does not conflict with any of the shared objects listed in the registry. A registry file containing the locations of all the shared objects provided with the system is supplied in /usr/lib/so_locations.LBL="" HELPID=""Using Registry FilesThere are two options to ld that may be used to specify a registry file, ≠check_registry and ≠update_registry. When you invoke ld to build a shared object, with the argument ≠check_registry† †file, ld makes sure that the new shared object does not conflict with any of the shared objects listed in file. When invoked with ≠update_registry† †file, ld checks the registry in the same way, but when it is done, it writes an entry in file for the DSO being built. If file is not writable, ≠update_registry acts like ≠check_registry. If file is not readable, both ≠update_registry and ≠check_registry are ignored.By exchanging registry files, providers of DSOs can avoid collisions between their shared objects. You should probably start out with a copy of /usr/lib/so_locations, so that your shared objects will not conflict with any of the standard DSOs. However, you should remember that when collisions occur between shared objects, the only effect is slowing down program startup somewhat.LBL="" HELPID=""Registry File FormatThere are three types of lines in the registry file:comment lines, which begin with a pound sign (#)directive lines, which begin with a dollar sign ($)shared object specification lines, which begin with the name of a shared objectComment lines are ignored by ld. Directive lines and shared object specification lines are described below.LBL="" HELPID=""Directive LinesDirective lines specify global parameters that apply to all the DSOs listed in the registry.$text_align_size=align padding=pad-size
$data_align_size=align padding=pad-sizeThese two directives specify the alignment and padding requirements for text and data segments, respectively. The current default segment alignment is 64K, which is the minimum permissible. The size value of a segment of a DSO appearing in the registry file is calculated based on the actual section size plus padding, and is aligned to the section align size (either the default or the one specified by the above directive). The align values for text and data as well as the padding values must be aligned to the minimum alignment size (64K). If not, ld generates a warning message and aligns these values to the minimum alignment.$start_address=addrThis directive specifies where to start looking for addresses to put shared objects. The default start_address is 0x6000000.$data_after_text={ 1 | 0 }In this directive, a value of one instructs the linker to place data immediately after the text at specified text and data alignment requirements. A value of zero (the default) allows the linker to place these segments in different portions of the address space.LBL="" HELPID=""Shared Object Specification LinesShared object specification lines have the format:so_name [ :st = { .text | .data | $range } base_addr,padded_size : ] *where:so_namefull path name (or trailing component) of a shared object:st =literal string indicating the beginning of the segment description.text,.datasegment types: text or data$rangerange of addresses that can be usedbase_addraddress where the segment startspadded_sizepadded size of the segment:literal string indicating the end of the segment descriptionA shared object specification can span several lines by "escaping" the newline character (using "\" as the last character on the line that is being continued). The following is an example of a shared object specification line:libc.so.1 \
† †          :st = $range 0x5fc00000, 0x00400000:\
† †          :st = .text 0x5fe40000, 0x000a0000:\
† †          :st = .data 0x5fee0000, 0x00030000:This specification instructs ld to relocate all segments of libc.so.1 in the range 0x5fc00000 to 0x5fc00000+0x0040000, and, if possible, to place the text segment at 0x5fe40000 and the data segment at 0x5fee0000. The text segment should be padded to 0xa0000 bytes and the data segment to 0x3000 bytes. See /usr/lib/so_locations for examples of shared object specifications.† †When building a DSO with the ≠check_registry or† †≠update_registry flag, if there is already an entry corresponding to this DSO in the registry file, the linker tries to assign the indicated addresses for text and data. However, if the size of the DSO changes and no longer fits in the specified location, the linker searches for another spot that fits. If the $range option is specified, the linker places the DSO only in the specified range of addresses. If there is not enough room, an error is returned. LBL="" HELPID=""ID="50766"Versioning of DSOsIn the 5.0.1 release, a mechanism for the versioning of shared objects was introduced for SGI-specific shared objects and executables. Note that this mechanism is outside the scope of the ABI, and, thus, must not be relied on for code that must be ABI-compliant and run on non-SGI platforms. Currently, all executables produced on SGI systems are marked SGI_ONLY, which allows use of the versioning mechanism.Versioning allows the creator of a shared object to update it in a way that may be incompatible with executables previously linked against the shared object. This is accomplished by renaming the original shared object and providing it along with the (incompatible) new version. Versioning is mainly of interest only to developers of shared objects. It may not be of interest to you if you simply use shared objects. LBL="" HELPID=""What Is a Version?A version is part or all of an identifying version_string that can be associated with a shared object by using the ≠set_version† †version_string option to ld(1) when the shared object is created. A version_string consists of one or more versions separated by colons (:). A single version has the form:[comment#]sgimajor.minorwhere:commentis a comment string, which is ignored by the versioning mechanism. It consists of any sequence of characters followed by a pound sign (#). The comment is optional.sgiis the literal string \f7sgi\f1.majoris the major version number, which is a string of digits [0-9]. .is a literal period.minor is the minor version number, which is a string of digits [0-9]. Here is what to do when building your shared library:When you first build your shared library, give it an initial version, say sgi1.0. Thus, add the option ≠set_version sgi1.0 to the command to build your shared library (cc ≠shared, ld ≠shared).Whenever you make a compatible change to the shared object, create another version by changing the minor version number, for example, sgi1.1, and add it to the end of the version_string. The command to set the version of the shared library might now look like ≠set_version "sgi1.0:sgi1.1".When you make an incompatible change to the shared object:Change the file name of the old shared object by adding a dot followed by the major number of one of the versions to the file name of the shared object. Do not change the soname of the shared object or its contents. Simply rename the file.Update the major version number and set the version_string of the shared object when you create it to this new version, for example, ≠set_version sgi2.0. Here is how this versioning mechanism affects executables:When an executable is linked against a shared object, the last version in the shared object's version_string is recorded in the executable as part of the liblist. This can be examined by elfdump ≠Dl.When you run an executable, rld looks for the proper file name in its usual search routine.If a file with the correct name is found, the version specified in the executable for this shared object is compared to each of the versions in the version_string in the shared object. If one of the versions in the version_string matches the executable's version exactly (ignoring comments), then that library is used.If no proper match is found, a new file name for the shared object is built by taking the soname specified in the executable for this shared object and the major number found in the version specified in the executable for this shared object, and putting them together as soname.major. (Remember that you did not change the soname of the object, only the file name.) The new file is searched for using rld's usual search procedure.For example, suppose you have a shared object foo.so with initial version sgi10.0. Over time, you make two compatible changes for foo.so, which result in the following final version_string for foo.so:initial version#sgi10.0:upgrade#sgi10.1:new devices#sgi10.2You then link an executable that uses this shared object, useoldfoo. This executable specifies version sgi10.2 for soname† †foo.so. (Remember that the executable inherits the last version in the version_string of the shared object.) The time comes to upgrade foo.so in an incompatible way. Note that the major version of foo.so is 10, so you move the existing foo.so to the file name foo.so.10 and create a new foo.so with the version_string:efficient interfaces #sgi11.0New executables linked with foo.so use it directly. Older executables, like useoldfoo, attempt to use† †foo.so, but find that its version (sgi11.0) is not the version they need (sgi10.2). They then attempt to find a foo.so in the file name foo.so.10 with version sgi10.2.LBL="3"ID="68557"Improving Program PerformanceThis chapter explains how to reduce the execution time of your programs using the compiler system. The techniques described here comprise only a minor part of performance tuning; other areas which can be tuned, but which are outside the scope of this chapter, include graphics, I/O, the kernel, memory, and REACT (real-time) system calls. This chapter contains the following sections:IDREF="65573" TYPE="TITLE""Profiling with prof" describes how to use the profiler, prof.IDREF="13139" TYPE="TITLE""Optimization" describes the compiler optimization facility and how to use it. The section also contains examples demonstrating optimization techniques.Although it may be possible to obtain short-term speed increases by relying on unsupported or undocumented quirks of the compiler system, it's a bad idea to do so. Any such "features" may well break in future releases of the operating system. The best way to produce efficient code that can be trusted to remain efficient is to follow good programming practices; in particular, choose good algorithms and leave the details to the compiler.LBL="" HELPID=""ID="65573"Profiling with profID="03.optimize1"Profiling produces detailed information about program execution. Use profiling tools to find the areas of code where most of the execution time is spent. In a typical program, a large part of the execution time is spent in relatively few sections of code. It is a good idea to concentrate on improving code efficiency in those sections first.LBL="" HELPID=""Overview of ProfilingProfiling is a three-step process that consists of compiling the source program, executing the output, and running the profiler, prof, to analyze the data.The compiler system provides two kinds of profiling:Program counter (pc) samplingname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'measures the amount of execution time spent in various parts of the program.Basic block countingname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'measures the execution of basic blocks (a basic block is a sequence of instructions that is entered only at the beginning and exits only at the end). Basic block counting provides statistics on individual lines.LBL="" HELPID=""ID="63085"Running the ProfilerThe profiler program, prof, converts raw profiling information to either a printed listing or an output file for use by the compiler.LBL="" HELPID=""SyntaxID="03.optimize2"
prof [options] [pname] { [profile_filename ... ] |
† †     [pname.Addrs pname.Counts] }optionsOne of the keywords or keyword abbreviations shown in IDREF="43487" TYPE="TABLE"Table 3-1
. (Specify either the entire name or the initial character of the option, as indicated in the table.)pnameSpecifies the name of the program to be profiled. The default file is a.out.profile_filenameSpecifies one or more files containing the profile data gathered when the profiled program executed (defaults are explained below.) If you specify more than one file, prof sums the statistics in the resulting profile listings.pname.AddrsOutput file produced by running ID="03.optimize3"pixie.pname.CountsOutput file produced by running the ID="03.optimize4"pixie-modified version of the program pname.The prof program has these defaults:If you do not specify profile_filename, the profiler looks for the mon.out file; if that file does not exist, prof looks for profile input data files in the directory specified by the PROFDIR environment variable (refer to IDREF="84151" TYPE="TITLE""Creating Multiple Profile Data Files"
).If you do not specify profile_filename, but do specify ≠pixie, then prof looks for pname.Addrs and pname.Counts and provides basic block count information if these files are present.prof and pixie now work on programs linked with shared libraries. For details refer to the pixie(1) manual page.† †Consider using the ID="03.optimize5"≠merge option when you have more than one profile data file. This option merges the data from several profile files into one file. See IDREF="43487" TYPE="TABLE"Table 3-1
 for information on the ≠merge option.COLUMNS="2"LBL="3-1"Table 3-1 Options for profID="43487"LEFT="0" WIDTH="75"NameLEFT="80" WIDTH="356"ResultLEFT="0" WIDTH="75"≠c[lock] nLEFT="80" WIDTH="356"A basic-block-counting option. Lists the number of seconds 
spent in each routine, based on the CPU clock frequency n, 
expressed in megahertz.LEFT="0" WIDTH="75"≠e[xclude] 
procedure_nameLEFT="80" WIDTH="356"Excludes information on the procedures (and their descendants) 
specified by procedure_name. If you specify uppercase ≠E instead 
of lowercase, prof also omits that procedure from the base upon 
which it calculates percentages. This option overrides the 
≠include option.LEFT="0" WIDTH="75"≠h[eavy]LEFT="80" WIDTH="356"A basic-block-counting option. Same as the ≠lines option, but 
sorts the lines by their frequency of use.LEFT="0" WIDTH="75"≠i[nvocations]LEFT="80" WIDTH="356"A basic-block-counting option. Lists the number of times each 
procedure is invoked. The ≠exclude and ≠only options described 
below apply to callees, but not to callers.LEFT="0" WIDTH="75"≠l[ines]LEFT="80" WIDTH="356"A basic-block-counting option. Lists statistics for each line of 
source code.LEFT="0" WIDTH="75"≠m[erge] filenameLEFT="80" WIDTH="356"Merges the input files into filename, allowing you to specify the 
name of the merged file (instead of several file names) on 
subsequent profiler runs. This option is useful when using 
multiple input files of profile data (normally in mon.out).LEFT="0" WIDTH="75"≠o[nly] 
procedure_nameLEFT="80" WIDTH="356"Reports information on only the procedure specified by 
procedure_name rather than the entire program. You can specify 
more than one ≠o option. If you specify uppercase ≠O, prof uses 
only the named procedures, rather than the entire program, as 
the base upon which it calculates percentages.LEFT="0" WIDTH="75"≠pixieLEFT="80" WIDTH="356"Indicates that information is to be generated on basic block 
counting, and that the pname.Addrs and pname.Counts files 
produced by pixie are to be used by default.LEFT="0" WIDTH="75"≠p[rocedures]LEFT="80" WIDTH="356"Lists the time spent in each procedure.LEFT="0" WIDTH="75"≠q[uit] nLEFT="80" WIDTH="356"Condense output listings by truncating unwanted lines. You can 
specify n in three different ways: n, an integer, truncates 
everything after n lines; n%, an integer followed by a percent 
sign, truncates everything after the line containing n% calls in 
the %calls column; and an integer followed by "cum%" 
truncates everything after the line containing ncum% calls in the 
cum% column.LEFT="0" WIDTH="75"≠t[estcoverage]LEFT="80" WIDTH="356"A basic-block-counting option. Lists line numbers that contain 
code that is never executed.LEFT="0" WIDTH="75"≠z[ero]LEFT="80" WIDTH="356"A basic-block-counting option. Lists the procedures that are 
never invoked.LBL="" HELPID=""pc SamplingProgram counter (pc) sampling reveals the amount of execution time spent in various parts of a program. The count includes:CPU timeMemory access timeTime spent in user routinesTime spent in system routinesPc sampling does not count time spent swapping or time spent accessing external resources.This section explains how to obtain pc sampling and provides an example for clarification. It also explains how to create multiple profile data files.LBL="" HELPID=""Pc SamplingID="03.optimize6"Obtain pc sampling information by link editing the desired source modules using the ID="03.optimize7"≠p option and then executing the resulting program object, which generates raw profile data.Use the procedure below to obtain pc sampling information (refer to IDREF="44320" TYPE="GRAPHIC"Figure 3-1
).Compile the program using the appropriate compiler driver. For example, to compile a C program myprog.c:IRIS% cc -c myprog.cLink-edit the object file created in Step 1.IRIS% cc -p -o myprog myprog.oYou must specify the ≠p profiling option during this step to obtain pc sampling information.† †Execute the profiled program. (During execution, profiling data is saved in the file mon.out.)IRIS% myprogYou can run the program several times, altering the input data, to create multiple profile data files. Use the environment variable PROFDIR as explained later in this section.Run the profile formatting program prof.IRIS% prof myprog mon.outprof extracts information from mon.out and prints it in an easily readable format. For more information see the prof(1) manual page.Include or exclude information on specific procedures within your program by using the ID="03.optimize8"≠only or ≠exclude profiler options (refer to IDREF="43487" TYPE="TABLE"Table 3-1
).LBL="3-1" FILE="3.1.pc.sampling.ps" POSITION="INLINE" SCALE="FALSE"LBL="3-1"Figure 3-1 ID="44320"How pc Sampling WorksLBL="" HELPID=""ExampleThe following listing is an example of pc sampling output from a profiled version of the ANSI C preprocessor, ID="03.optimize9"acpp:Profile listing generated Sat Feb 23 15:00:10 1991 with:
† † prof acpp
---------------------------------------------------------------
*  -p[rocedures] using pc-sampling                            *
*  sorted in descending order by total time spent in each     *
*  procedure; unexecuted procedures excluded                  *
---------------------------------------------------------------

Each sample covers 8.00 byte(s) for 1.1% of 0.9000 seconds

%time  seconds  cum %  cum sec  procedure (file)

† †28.9  0.2600   28.9   0.26     rescan (cccp.c)
† †27.8  0.2500   56.7   0.51    write (sys/write.s)
† †10.0  0.0900   66.7   0.60    handle_directive (cccp.c)
† † 8.9  0.0800   75.6   0.68    read (sys/read.s)
† † 5.6  0.0500   81.1   0.73    malloc (malloc.c)
† † 5.6  0.0500   86.7   0.78    collect_expansion (cccp.c)
† † 3.3  0.0300   90.0   0.81    open (sys/open.s)
† † 2.2  0.0200   92.2   0.83    hashf (cccp.c)
† † 2.2  0.0200   94.4   0.85    skip_if_group (cccp.c)
† † 1.1  0.0100   95.6   0.86    main (cccp.c)
† † 1.1  0.0100   96.7   0.87    do_define (cccp.c)
† † 1.1  0.0100   97.8   0.88    macroexpand (cccp.c)
† † 1.1  0.0100   98.9   0.89    skip_to_end_of_comment (cccp.c)
† † 1.1  0.0100  100.0   0.90    strncmp (strncmp.c)In the above listing:0.09 seconds (10.0% of execution time) was spent in handle_directive.0.6 seconds (66.7% of total execution time) were spent cumulatively in the rescan, write, and handle_directive routines.The name of the source file containing the handle_directive routine is cccp.c.LBL="" HELPID=""ID="84151"Creating Multiple Profile Data FilesID="03.optimize10"When you run a program using pc sampling, raw data is collected and saved in the profile data file mon.out. To collect profile data in several files, or to specify a different name for the profile data file, set the environment variable PROFDIR, using the appropriate method from ID="03.optimize11"IDREF="94920" TYPE="TABLE"Table 3-2
:COLUMNS="2"LBL="3-2"Table 3-2 ID="94920"Setting the PROFDIR environment variableLEFT="0" WIDTH="162"C ShellLEFT="170" WIDTH="356"Bourne ShellLEFT="0" WIDTH="162"setenv PROFDIR dirnameLEFT="170" WIDTH="356"PROFDIR=dirname; export PROFDIRSetting this environment variable places the raw profile data of each invocation of progname in files named dirname/pid.progname. (You must create a directory called dirname before you run the program.) pid is the process ID of the executing program, and progname is the name of the program when invoked.ID="03.optimize12"LBL="" HELPID=""Basic Block CountingID="03.optimize13"Basic block counting, obtained using the program pixie, measures the execution of basic blocks. A basic block is a sequence of instructions that is entered only at the beginning and exits only at the end. pixie takes a source program and creates an equivalent program containing additional code that counts the execution of each basic block.LBL="" HELPID=""Using pixieID="03.optimize14"Before obtaining basic block counts with prof and the ≠pixie option, use pixie to translate your source program into a profiling version and generate a file of block addresses.LBL="" HELPID=""Syntaxpixie in_prog_name [options]in_prog_nameName of the input program.optionsOne of the keywords listed in IDREF="28200" TYPE="TABLE"Table 3-3
. (For a complete list of options refer to the pixie(1) manual page.)COLUMNS="2"LBL="3-3"Table 3-3 ID="28200"Options for pixieLEFT="0" WIDTH="82"NameLEFT="90" WIDTH="356"ResultLEFT="0" WIDTH="82"≠o out_prog_nameLEFT="90" WIDTH="356"Specifies a name for the equivalent program. The default is to 
remove any leading directory names from the in_prog_name 
and append .pixie.LEFT="0" WIDTH="82"≠bbaddrs† †nameLEFT="90" WIDTH="356"Specifies a name for the file of basic block addresses. The 
default is to remove any leading directory names from the 
in_prog_name and append .Addrs.LEFT="0" WIDTH="82"≠[no]quietLEFT="90" WIDTH="356"[Permits] or suppresses messages summarizing the 
binary-to-binary translation process. Default: ≠noquiet.LEFT="0" WIDTH="82"≠[no]textdataLEFT="90" WIDTH="356"Controls whether pixie puts the original text into the translated 
output. This option is required to correctly translate programs 
with data in the text section (for example, Fortran 77 format 
statements in some compiler releases). Default: ≠textdata 
(include original text).LBL="" HELPID=""Obtaining Basic Block CountsUse the procedure below to obtain basic block counts (refer to IDREF="88680" TYPE="GRAPHIC"Figure 3-2
).Compile and link edit your program normally. Do not use the ≠p† †option. For example, using the input file myprog.c:IRIS%† †cc -o myprog myprog.cThe cc compiler compiles myprog.c into an executable called myprog.Run pixie to generate the equivalent program containing basic-block-counting code.IRIS%† †pixie myprog† †-o myprog.pixiepixie takes myprog† †and writes an equivalent program containing additional code that counts the execution of each basic block. ID="03.optimize15"pixie also generates a file called myprog.Addrs which contains the address of each basic block. For more information, refer to the pixie(1) manual page.Execute the file generated by pixie, myprog.pixie, in the same way you would execute the original program.IRIS%† †myprog.pixieThis program generates a list of basic block counts in a file named ID="03.optimize16"myprog.Counts.Run the profile formatting program prof specifying the ≠pixie option and the name of the original program.prof -pixie myprog myprog.Addrs myprog.Countsprof extracts information from myprog.Addrs and myprog.Counts and prints it in an easily readable format.Specifying myprog.Addrs and myprog.Counts is optional; pixie searches by default for names having the form program_name.Addrs and program_name.Counts.† †You can run the program several times, altering the input data, to create multiple profile data files. See IDREF="17886" TYPE="TITLE""Averaging Basic Block Count Results"
 later in this section for an example.The complete output of the ID="03.optimize17"≠pixie option is often extremely large. Use the ≠quit option with prof to restrict the size of the output. Refer to IDREF="63085" TYPE="TITLE""Running the Profiler"
 for details about prof options.Include or exclude information on specific procedures within your program by using the ID="03.optimize18"≠only or ≠exclude† †prof options (explained in IDREF="28200" TYPE="TABLE"Table 3-3
). prof timings reflect only time spent in a specific procedure, not time spent including procedures called by that procedure. To show the time spent including called procedures specify the ≠g option to prof.LBL="3-2" FILE="3.2.pixie.bblock.ps" POSITION="INLINE" SCALE="FALSE"LBL="3-2"Figure 3-2 ID="88680"How Basic Block Counting WorksLBL="" HELPID=""ExamplesThe following listings are examples of basic block counting output using ID="03.optimize19"prof ≠pixie, from a profiled version of the ANSI C preprocessor, acpp.The first listing illustrates the use of the ≠invocations option. For each procedure invoked, prof produces a list of the procedures that called it:IRIS% prof -pixie -invocations acppProfile listing generated Sat Feb 23 15:00:01 1991 with:
† † prof -pixie -invocations acpp
-------------------------------------------------------------
*  -i[nvocations] using basic-block counts;                  *
*  the called procedures are sorted in descending order by   *
*  number of calls; a '?' in the columns marked '#calls'     *
*  or 'line' means that data is unavailable.                 *
-------------------------------------------------------------

called procedure #calls %calls from line, calling procedure (file):

strncmp          1112  45.22   4022  skip_if_group (cccp.c)
† †                 963  39.16   2213  handle_directive (cccp.c)
† †                 362  14.72   3368  collect_expansion (cccp.c)
† †                  22   0.89   5246  lookup (cccp.c)
† †                   0   0.00   3530  do_line (cccp.c)
† †                   0   0.00      2  parse_number (cexp.c)
† †                   0   0.00   3661  do_pragma (cccp.c)
† †                   0   0.00   3112  compare_defs (cccp.c)
† †                   0   0.00   3014  do_define (cccp.c)
† †                   0   0.00      2  parse_number (cexp.c)
malloc           1604  73.21   5690  xmalloc (cccp.c)
† †                 585  26.70   5714  xcalloc (cccp.c)
† †                   2   0.09    244  realloc (malloc.c)
† †                   0   0.00    303  setcftime (_cftime.c)
† †                   0   0.00    268  _findbuf (flsbuf.c)
† †                   0   0.00    256  realloc (malloc.c)In the previous listing:strncmp was called 1,112 times from line 4,022 of skip_if_group.Calls from skip_if_group made up 45.22% of the calls to strncmp.The file cccp.c contains the source code for skip_if_group.The following listing shows the source code lines responsible for the largest portion of execution time produced with the ≠heavy option:IRIS% prof -pixie -heavy acpp
Profile listing generated Sat Feb 23 15:00:03 1991 with:
† † prof -pixie -heavy acpp
-------------------------------------------------------------
*  -h[eavy] using basic-block counts;                         *
*  sorted in descending order by the number of cycles         *
*  executed in each line; unexecuted lines are excluded       *
-------------------------------------------------------------

procedure (file)            line bytes     cycles      %  cum %

rescan (cccp.c)             1431    40     940652  12.80  12.80
handle_directive (cccp.c)   2291    68     428379   5.83  18.63
rescan (cccp.c)             1678    16     369193   5.02  23.65
skip_if_group (cccp.c)      4067    68     280109   3.81  27.46
rescan (cccp.c)             1679    28     277812   3.78  31.24
rescan (cccp.c)             1429     8     189746   2.58  33.82
rescan (cccp.c)             1659     8     186960   2.54  36.36
rescan (cccp.c)             2014    92     149390   2.03  38.40
rescan (cccp.c)             1720    40     143226   1.95  40.34
rescan (cccp.c)             1721    12     139773   1.90  42.25
rescan (cccp.c)             1723    12     139773   1.90  44.15
handle_directive (cccp.c)   2375    72     137623   1.87  46.02
rescan (cccp.c)             1832    16     114445   1.56  47.58
handle_directive (cccp.c)   2372    20     110966   1.51  49.09
bzero (cccp.c)              5595    20     100660   1.37  50.46
collect_expansion (cccp.c)  3309    44      97100   1.32  51.78
collect_expansion (cccp.c)  3357    72      95715   1.30  53.08
rescan (cccp.c)             1428     8      94988   1.29  54.37In the above listing:The most heavily used line is line 1431 in procedure rescan, compiled from the source file cccp.c.Lines 1431, 2291, and 1678 executed 23.65% of the total program cycles.Line 1431 of cccp.c has 40 bytes of code and used 940652 cycles, which is 12.80% of the total program cycles.The following listing, produced using the ≠lines option, shows the execution time spent on each line of code, grouped by procedure:IRIS% prof -pixie -lines acppProfile listing generated Sat Feb 23 15:00:05 1991 with:
† † prof -pixie -lines acpp
-------------------------------------------------------------
*  -l[ines] using basic-block counts;                         *
*  grouped by procedure, sorted by cycles executed per        *
*  procedure;  '?' means that line number information is not  *
*  available.                                                 *
-------------------------------------------------------------
procedure (file)                  line bytes     cycles %cycles
rescan (cccp.c)                   1355    52       1495   0.02
† †                                 1360     4        115   0.00
† †                                 1363     4        115   0.00
† †                                 1383     4        115   0.00
† †                                 1415    52        230   0.00
† †                                 1416     8          0   0.00
† †                                 1418    32        920   0.01
† †                                 1419    64       1612   0.02
† †                                 1420     4        115   0.00
† †                                 1424    16        460   0.00
† †                                 1425    24        460   0.00
† †                                 1428     8      94988   1.29
† †                                 1429     8     189746   2.58
† †                                 1431    40     940652  12.80
† †                                 1433    12          0   0.00
† †                                 1434    12          0   0.00
† †                                 1435    16          0   0.00
† †                                 1438     4          0   0.00
† †                                 1439    12          0   0.00
† †                                 1440     4          0   0.00
† †                                 1441     8          0   0.00
† †                                 1446    16          0   0.00
† †                                 1447    12          0   0.00In the above listing:The statistics describe the lines of code in procedure rescan compiled from the source file cccp.c.Line 1355 in rescan contains 52 bytes of code, executed 1,495 times, using 0.02% of the total program cycles.Line 1360 in rescan contains 4 bytes of code and did not execute any recorded cycles.You can limit the output of prof to information on only the most time-consuming parts of the program by specifying the ≠quit option. You can instruct prof to quit after a particular number of lines of output, after listing the elements consuming more than a certain percentage of the total, or after the portion of each listing whose cumulative use is a certain amount.Consider the following sample listing:calls    %call    cum%
48071708  32.45   32.45  6.0090
42443503  28.65   61.10  5.3054
26457936  17.86   78.96  3.3072
20662326  13.95   92.91  2.5828
4307932    2.91   95.82  0.5385
3678408    2.48   98.30  0.4598
1573858    1.06   99.36  0.1967
362700     0.24   99.61  0.0453
279002     0.19   99.80  0.0349
251152     0.17   99.97  0.0314
30283      0.02   99.99  0.0038
13391      0.01   100.0  0.0017
2923       0.00   100.00 0.0017Any one of the following commands will eliminate everything from the line starting with 4307932 to the end of the listing:prof -quit 4
prof -quit 13%
prof -quit 92cum%The following listing, produced with the ≠procedures option, shows the percentage of execution time spent in each procedure:IRIS% prof -pixie -procedures acppProfile listing generated Sat Feb 23 15:00:01 1991 with:
† † prof -pixie -procedures acpp
-------------------------------------------------------------
*  -p[rocedures] using basic-block counts;                    *
*  sorted in descending order by the number of cycles         *
*  executed in each procedure; unexecuted procedures are      *
*  excluded                                                   *
-------------------------------------------------------------
7350305 cycles
cycles %cycles cum % cycles bytes procedure (file)
† †                     /call /line
3536769 48.12  48.12 30755   17   rescan (cccp.c)
1231455 16.75  64.87  1671   18   handle_directive (cccp.c)
684976   9.32  74.19  1616   19   collect_expansion (cccp.c)
453805   6.17  80.36  4777   17   skip_if_group (cccp.c)
258087   3.51  83.88   118   14   malloc (malloc.c)
234150   3.19  87.06   445   17   skip_to_end_of_comment (cccp.c)
111560   1.52  88.58    46   21   strncmp (strncmp.c)
109313   1.49  90.07   258   18   do_define (cccp.c)
101035   1.37  91.44  1348   14   bzero (cccp.c)
† †83969   1.14  92.58   124   13   skip_quoted_string (cccp.c)
† †71584   0.97  93.56   309   21   macroexpand (cccp.c)
† †52005   0.71  94.26    91   27   hashf (cccp.c)
† †50685   0.69  94.95   114   17   install (cccp.c)
† †49438   0.67  95.63   634   18   _doprnt (doprnt.c)
† †43520   0.59  96.22    75   13   xcalloc (cccp.c)
† †30143   0.41  96.63    63   16   bcopy (cccp.c)In the above listing:The total number of program cycles is 7,350,305.rescan used 3,536,769 cycles, which is 48.12% of the total number of program cycles.The cumulative total of all cycles used by rescan, handle_directive, and collect_expansion is 74.19% (see column 3 of the third row).rescan used an average of 30,755 cycles per call and consisted of 17 bytes of generated code per line of source text.The procedure rescan is in the source file cccp.c.You can add absolute time information to the output by specifying the clock rate, in megahertz, with the ≠clock option. The following listing shows the output:IRIS% prof -pixie -procedures -clock 20 acppProfile listing generated Sat Feb 23 15:00:01 1991 with:
† † prof -pixie -procedures -clock acpp
-------------------------------------------------------------
*  -p[rocedures] using basic-block counts;                    *
*  sorted in descending order by the number of cycles         *
*  executed in each procedure; unexecuted procedures are      *
*  excluded                                                   *
-------------------------------------------------------------
7350305 cycles (0.3675 seconds at 20.00 megahertz)
cycles %cycles cum % seconds cycles bytes procedure (file)
† †                           /call  /line
3536769 48.12  48.12 0.176 30755 17  rescan (cccp.c)
1231455 16.75  64.87 0.0616 1671 18  handle_directive (cccp.c)
684976  9.32  74.19  0.0342 1616  19  collect_expansion (cccp.c)
453805  6.17  80.36  0.022  4777  17  skip_if_group (cccp.c)
258087  3.51  83.88  0.0129  118  14  malloc (malloc.c)
111560  1.52  88.58  0.0056   46  21  strncmp (strncmp.c)
109313  1.49  90.07  0.0055  258  18  do_define (cccp.c)
101035  1.37  91.44  0.00   1348  14  bzero (cccp.c)
† †71584  0.97  93.56  0.0036   30  21  macroexpand (cccp.c)
† †52005  0.71  94.26  0.0026   91  27  hashf (cccp.c)
† †50685  0.69  94.95  0.0025  114  17  install (cccp.c)
† †49438  0.67  95.63  0.0025  634  18  _doprnt (doprnt.c)
† †43520  0.59  96.22  0.0022   75  13  xcalloc (cccp.c)
† †30143  0.41  96.63  0.0015   63  16  bcopy (cccp.c)
† †26577  0.36  96.99  0.0013   55  15  alloca (alloca.c)The above listing contains the same information as the previous listing except that this listing also contains the number of seconds spent in each procedure. The profiler computes the time, in seconds, based on the machine speed specified with the ID="03.optimize20"≠clock option (in megahertz.) In this example the speed specified is 20 megahertz.LBL="" HELPID=""ID="17886"Averaging Basic Block Count ResultsSometimes a single run of a program does not produce the results you require. You can repeatedly run the version of a program created by pixie and vary the input with each run, then use the resulting .Counts files to produce a consolidated report.Use the following procedure to average ID="03.optimize21"prof results:Compile and link-edit the input file. Do not use the ≠p option. For example, using the input file myprog.c:IRIS% cc -c myprog.c
IRIS% cc -o myprog myprog.oThe cc compiler compiles myprog.c and saves the object file as myprog.o. The second command link-edits myprog.o and saves the executable as myprog.Run the profiling program pixie.IRIS% pixie myprog -o myprog.pixiepixie generates the file myprog.Addrs that contains the address of each basic block. It also generates the modified program myprog.pixie.Run the profiled program as many times as desired. Each time you run the program, pixie creates a myprog.Counts file. Rename this file before executing the next sample run.myprog.pixie < input1 > output1
mv myprog.Counts myprog1.Counts
myprog.pixie < input2 > output2
mv myprog.Counts myprog2.Counts
myprog.pixie < input3 > output3
mv myprog.Counts myprog3.CountsCreate the report.IRIS% prof -pixie myprog myprog.Addrs myprog[123].Countsprof takes an average of the basic block data in the myprog1.Counts, myprog2.Counts, and myprog3.Counts files to produce the profile report.ID="03.optimize22"LBL="" HELPID=""Using pixstatsID="03.optimize23"Use the pixstats command to analyze a program's execution characteristics. prof-generated reports ignore time spent in floating point operations and time spent accessing memory. pixstats provides accurate floating point information by analyzing the .Addrs and the .Counts files created through pixie. The disadvantages to using pixstats are that it:Does not provide a line-by-line countProfiles only one .Counts file at a time (no averaging)Provides very little documentationDoes not show time spent in floating point exceptionsYou can also use pixstats to look for write buffer stalls and to produce disassembled code listings.LBL="" HELPID=""SyntaxID="03.optimize24"
pixstats program [options]programSpecifies the name of the program to be analyzed.optionsOne of the keywords shown in IDREF="65849" TYPE="TABLE"Table 3-4COLUMNS="2"LBL="3-4"Table 3-4 ID="65849"Options for pixstatsLEFT="0" WIDTH="54"NameLEFT="60" WIDTH="356"ResultLEFT="0" WIDTH="54"≠cycle nsLEFT="60" WIDTH="356"Assumes an ns cycle time when converting cycle counts to seconds.LEFT="0" WIDTH="54"≠r2010LEFT="60" WIDTH="356"Uses r2010 floating point chip operation times and overlap rules. This 
option is the default.LEFT="0" WIDTH="54"≠r2360LEFT="60" WIDTH="356"Uses r2360 floating point board operation times and overlap rules.LEFT="0" WIDTH="54"≠disassembleLEFT="60" WIDTH="356"Disassembles and lists the analyzed object code.Use the following procedure to run pixstats:Compile and link edit the input file myprog.c. Do not use the ≠p option. For example, using the input file myprog.c:IRIS% cc -c myprog.c
IRIS% cc -o myprog myprog.oThe cc compiler driver compiles myprog.c and saves the object file as myprog.o. The second command link-edits myprog.o and saves the executable as myprog.Run the profiling program pixie.IRIS% pixie -o myprog.pixie myprogpixie generates the file myprog.Addrs that contains the address of each basic block. It also generates the modified program myprog.pixie.Execute the file generated by pixie, myprog.pixie,† †in the same way you would execute the original program.IRIS% myprog.pixieThis program generates the file myprog.Counts which contains the basic block counts.Run pixstats to generate a detailed report.IRIS% pixstats myprogLBL="" HELPID=""ExampleThe following example shows part of a listing generated by running pixstats on the file acpp:pixstats acpp:
† †  7670434 (1.043) cycles (0.307s @ 25.0MHz)
† †  7350710 (1.000) instructions
† †  2351262 (0.320) basic blocks
† †    15581 (0.002) calls
† †  1069316 (0.145) loads
† †   499584 (0.068) stores
† †  1568900 (0.213) loads+stores
† †  1568932 (0.213) data bus use
† †   686354 (0.093) partial word references
† †  1941521 (0.264) branches
† †  1041239 (0.142) nops
† †        0 (0.000) load interlock cycles
† †   319724 (0.043) multiply/divide interlock cycles (12/35 cycles)
† †        0 (0.000) flops (0 mflop/s @ 25.0MHz)
† †        0 (0.000) floating point data interlock cycles
† †        0 (0.000) floating point add unit interlock cycles
† †        0 (0.000) floating point multiply unit interlock cycles
† †        0 (0.000) floating point divide unit interlock cycles
† †        0 (0.000) other floating point interlock cycles
† †        0 (0.000) 1 cycle interlocks (2 cycle stalls -- not counted
† †                  in total)
† †        0 (0.000) overlapped floating point cycles
† †    18400 (0.003) interlock cycles due to basic block boundary
0.272 load nops per load
0.318 stores per memory reference
0.437 partial word references per reference
† † 3.1 instructions per basic block
† † 3.8 instructions per branch
0.630 backward branches per branch
0.300 branch nops per branch
492 cycles per call
472 instructions per call
.
.
.
† †cycles %cycles  cum%   instrs  c/i   calls  c/call name
3828673  49.9%  49.9%  3536769  1.1   115    33293 rescan
1231455  16.1%  66.0%  1231455  1.0   737     1671 handle_directive
† †684976   8.9%  74.9%   684976  1.0   424     1616 collect_expansion
.
.
.
ID="03.optimize25"In the above listing the first line shows a total of 7,670,434 cycles used by acpp. This total includes floating point calculations. The second line shows a total of 7,350,710 instructions. This total does not include floating point calculations. By comparing the two totals, you can analyze floating point versus integer calculations.LBL="" HELPID=""Profiling Multiprocessed ExecutablesID="03.optimize26"You can gather both pixie and pc sampling profile data from executables that use the sproc system call, such as POWER Fortran and POWER C executables. Prepare and run the job using the same process as for uniprocessed executables. For multiprocessed executables each thread of execution writes its own separate profile data file. View these data files with prof like any other profile data files.The only difference between multiprocessed and regular executables is the way in which the data files are named. When using pc sampling, the data files for multiprocessed executables are named process_id.program_name. When using pixie, the data files are named program_name.Countsprocess_id. This naming convention avoids the potential conflict of all the threads attempting to write simultaneously to the same file.ID="03.optimize27"LBL="" HELPID=""ID="13139"OptimizationThis section describes the compiler optimization facilities and explains their benefits, the implications of optimizing and debugging, and the major optimizing techniques.LBL="" HELPID=""OverviewThis section contains an overview of optimization. It explains the global optimizer, the benefits of optimization, and other general topics.LBL="" HELPID=""Global OptimizerID="03.optimize28"The global optimizer is a single program that improves the performance of object programs by transforming existing code into more efficient coding sequences. The optimizer distinguishes between C, Pascal, and Fortran programs to take advantage of the various language semantics involved.Silicon Graphics compilers perform both machine-independent and machine-dependent optimizations. Silicon Graphics machines and other machines with reduced instruction set computing (RISC) architectures provide a better target for machine-dependent optimizations. The low-level instructions of RISC machines provide more optimization opportunities than the high-level instructions in other machines. Even optimizations that are machine-independent have been found to be effective on machines with RISC architectures. Although most optimizations performed by the global optimizer are machine-independent, they have been specifically tailored to the Silicon Graphics environment.ID="03.optimize29"LBL="" HELPID=""BenefitsThe primary benefits of optimization are faster running programs and smaller object code size. However, the optimizer can also speed up development time. For example, your coding time can be reduced by leaving it up to the optimizer to relate programming details to execution time efficiency. You can focus on the more crucial global structure of your program. Moreover, programs often yield optimizable code sequences regardless of how well you write your source program.LBL="" HELPID=""Optimization and DebuggingID="03.optimize30"Optimize your programs only when they are fully developed and debugged. The optimizer may move operations around so that the object code does not correspond to the source code. These changed sequences of code can create confusion when using a debugger.LBL="" HELPID=""Loop OptimizationID="03.optimize31"Optimizations are most useful in program areas that contain loops. The optimizer moves loop-invariant code sequences outside loops so that they are performed only once instead of multiple times. Apart from loop-invariant code, loops often contain loop-induction expressions that can be replaced with simple increments. In programs composed of mostly loops, global optimization can often reduce the running time by half.Consider the source code below.void left (a, distance)
† †   char a[];
† †   int distance;
{
† †   int j, length;
† †   length = strlen(a) - distance;
† †   for (j = 0; j < length; j++)
† †       a[j] = a[j + distance];
}The following code samples show the unoptimized and optimized code produced by the compiler. The optimized version (compiled with the ≠O option) contains fewer total instructions and fewer instructions that reference memory. Wherever possible, the optimizer replaces load and store instructions (which reference memory) with the faster computational instructions that perform operations only in registers.LBL="" HELPID=""Unoptimized CodeThe loop is 13 instructions long and uses eight memory references.#   8           for (j=0; j<length; j++)
† †        sw     $0, 36($sp)   # j = 0
† †        ble    $24, 0, $33   # length >= j
$32:
#   9           a[j] = a[j+distance];
† †        lw     $25, 36($sp)  #  j
† †        lw     $8, 44($sp)   # distance
† †        addu   $9, $25, $8   # j+ distance
† †        lw     $10, 40(4sp)  # address of a
† †        addu   $11, $10, $25 # address of a[j+distance]
† †        lbu    $12, 0($11)   # a[j+distance]
† †        addu   $13, $10, $25 # address of a[j]
† †        sb     $12, 0($13)   # a[j]
† †        lw     $14, 36($sp)  # j
† †        addu   $15, $14, 1   # j+1
† †        sw     $15, 36($sp)  # j++
† †        lw     $3, 32($sp)   #  length
† †        blt    $15, $3, $32  # j < length
$33:LBL="" HELPID=""Optimized CodeThe loop is 6 instructions long and uses two memory references.#   8           for (j=0; j<length; j++)
† †        move   $5,$0         # j = 0
† †        ble    $4, 0, $33    # length >= j
† †        move   $2, $16       # address of a[j]
† †        addu   $6, $16, $1   # address of a[j+distance]
$32:
#   9           a[j] = a[j+distance];
† †        lbu    $3, 0($6)     # a[j+distance]
† †        sb     $3, 0($2)     # a[j]
† †        addu   $5, $5, 1     # j++
† †        addu   $2, $2, 1     # address of next a[j]
† †        addu   $6, $6, 1     # address of next a[j+distance]
† †        blt    $5, $4, $32   # j < length
$33:                          # address of next a[j + distance]LBL="" HELPID=""Loop UnrollingID="03.optimize32"The optimizer performs loop unrolling to improve performance in two ways:Reduces loop overhead.Increases work performed in the loop body allowing more opportunity for optimization and register usage.For example, the Fortran loop:
do i=1,100
† †  sum = sum + a(i)*b(i)
enddowhen unrolled four times looks likedo i=1,100,4
† †  sum = sum + a(i)*b(i)
† †  sum = sum + a(i+1)*b(i+1)
† †  sum = sum + a(i+2)*b(i+2)
† †  sum = sum + a(i+3)*b(i+3)
enddoThe unrolled version runs much faster than the original. Most of the increase in execution speed is because the multiplication and addition operations are overlapped.The optimizer performs a similar sort of transformation, although the optimizer does this on its own internal representation of the program, not by rewriting the original source code.If the number of iterations of the loop is not an exact multiple of the unrolling factor (or if the number of iterations is unknown), the optimizer still performs this transformation even though the result is more complicated than the original code.† †LBL="" HELPID=""Register AllocationID="03.optimize33"The Silicon Graphics architecture emphasizes the use of registers. Therefore, register usage has a significant impact on program performance. For example, fetching a value from a register is significantly faster than fetching a value from RAM. The optimizer must therefore make the best possible use of registers.The optimizer allocates registers for the most suitable data items, taking into account their frequency of use and their locations in the program structure. In addition, the optimizer assigns values to registers in such a way as to minimize shifting around within loops and during procedure invocations.LBL="" HELPID=""Optimizing Separate Compilation UnitsID="03.optimize34"The optimizer processes one procedure at a time. Large procedures offer more opportunities for optimization, since more interrelationships are exposed in terms of constructs and regions. However, large procedures require more time to optimize than smaller ones.The uld and umerge phases of the compiler permit global optimization among code from separate files (or "modules") in the same compilation. Traditionally, program modularity restricted the optimization of code to a single compilation unit at a time rather than over the full breadth of the program. For example, it was impossible to fully optimize calling code along with the procedures called if those procedures resided in other modules.The uld and umerge phases of the compiler system overcome this deficiency. The uld phase links multiple modules into a single unit. Then, umerge orders the procedures for optimal processing by the global optimizer, uopt.LBL="" HELPID=""Optimization OptionsInvoke the optimizer by specifying a compiler driver, such as cc(1), with any of the options listed in IDREF="40504" TYPE="TABLE"Table 3-5
. IDREF="90156" TYPE="GRAPHIC"Figure 3-3
 shows the major processing phases of the compiler and how the compiler ≠On option determines the execution sequence.COLUMNS="2"LBL="3-5"Table 3-5 Optimization OptionsID="40504"LEFT="0" WIDTH="61"† †OptionLEFT="70" WIDTH="356"ResultLEFT="0" WIDTH="61"≠O0LEFT="70" WIDTH="356"No optimization. Prevents all optimizations, including the minimal 
optimization normally performed by the code generator and 
assembler. uld, umerge, and uopt are bypassed, and the assembler 
bypasses certain optimizations it normally performs.LEFT="0" WIDTH="61"≠O1LEFT="70" WIDTH="356"(Default) The assembler and code generator perform as many 
optimizations as possible without affecting compile time 
performance. Bypasses uld, umerge, and uopt. However, the code 
generator and the assembler perform basic optimizations in a more 
limited scope.LEFT="0" WIDTH="61"≠O2LEFT="70" WIDTH="356"Specifies global optimization. Optimizes within the bounds of 
individual compilation units. This option executes the global 
optimizer (uopt) phase. uld and umerge are bypassed, and only the 
uopt phase executes. It performs optimization only within the 
bounds of individual compilation units.LEFT="0" WIDTH="61"≠O3LEFT="70" WIDTH="356"This option cannot be used to compile with DSOs; it is only 
available for non-shared programs. The ≠non_shared option must 
therefore be used whenever ≠O3 is used.≠O3 specifies using all optimizations, including procedure inlining. 
This option must precede all source file arguments. It creates a 
ucode object file, which remains a .u file, for each source file. The 
runtime start-up routine, runtime libraries, and ucode versions of 
the runtime libraries are linked, as well as newly created ucode 
object files and any ucode object files specified on the command 
line. Procedure inlining is done on the resulting linked file. This file 
is then compiled as usual into an executable.The uld and umerge phases process the output from the compilation 
phase of the compiler, which produces symbol table information 
and the program text in an internal format called ucode. The uld 
phase combines all the ucode files and symbol tables, and passes 
control to umerge. umerge reorders the ucode for optimal processing 
by uopt. Upon completion, umerge passes control to uopt, which 
performs global optimizations on the program.Refer to the cc(1), pc(1), or f77(1) manual pages, as applicable, for details on the ≠O3 option and the input and output files related to this option.† †LBL="3-3" FILE="3.3.optim.phases.ps" POSITION="INLINE" SCALE="FALSE"LBL="3-3"Figure 3-3 ID="90156"Optimization Phases of the CompilerLBL="" HELPID=""Full OptimizationID="03.optimize35"This section provides examples of full optimization using the ≠O3 option. Although the examples are in C, you can substitute the C files and driver command for another source language. The following examples assume that the program foo consists of three files:† †a.c, b.c, and c.c.To perform procedure merging optimizations (≠O3) on all three files, enter the following:IRIS% cc -O3 -non_shared -o foo a.c b.c c.cIf you normally use the ≠c option to compile the .o object file, follow these steps:Compile each file separately using the ≠j option by typing in the following:IRIS% cc -j a.c
IRIS% cc -j b.c
IRIS% cc -j c.cThe ≠j option produces a .u file (the standard compiler front-end output made up of ucode; ucode is an internal language used by the compiler). None of the remaining compiling phases are executed, as illustrated in IDREF="77793" TYPE="GRAPHIC"Figure 3-4
.LBL="3-4" FILE="3.4.j.option.ps" POSITION="INLINE" SCALE="FALSE"LBL="3-4"Figure 3-4 ID="77793"Compiling with the ≠j OptionEnter the following statement to perform optimization and complete the compilation process.IRIS% cc -O3 -non_shared -o foo a.u b.u c.uIDREF="79287" TYPE="GRAPHIC"Figure 3-5 illustrates the results of executing the above statement.LBL="3-5" FILE="3.5.full.opt.ps" POSITION="INLINE" SCALE="FALSE"LBL="3-5"Figure 3-5 ID="79287"Executing Full OptimizationLBL="" HELPID=""Optimizing Frequently Used ModulesCompiling and optimizing frequently used modules reduces the compile and optimization time required when the modules are called.The following procedure explains how to compile two frequently used modules, b.c and c.c, while retaining all the necessary information to link them with future programs; future.c represents one such program.Compile b.c and c.c separately by entering the following statements:IRIS% cc -j b.c
IRIS% cc -j c.cThe ≠j option causes the front end (first phase) of the compiler to produce two ucode files b.u and c.u.Using an editor, manually create a file containing the external symbols in b.c and c.c to which future.c will refer. Each symbolic name must be separated by at least one blank. Consider the skeletal contents of b.c and c.c:File b.c               File c.c
foo()                  x()
† †{                      {
† † .                      .
† † .                      .
† †}                      }

bar()                  help()
† †{                      {
† † .                      .
† † .                      .
† † zot()                 }
† †  {
† †    .                 struct
† †    .                  {
† †  }                     .
† †                        .
† † struct                } ddata;
† †  {
† †    .                 y()
† †    .                  {
† †  } work;                .
† †}                        .
† †                       }
In this example, future.c will call or reference only foo, bar, x,† †ddata, and y in the b.c and c.c procedures. A file (named extern for this example) must be created containing the following symbolic names:foo bar x ddata yThe structure work, and the procedures help and zot are used internally only by b.c and c.c, and thus are not included in extern.If you omit an external symbolic name, an error message is generated (see Step 4 below).Optimize the b.u and c.u modules (created in Step 1) using the extern file (created in Step 2) as follows:IRIS% cc -O3 -non_shared -kp extern b.u c.u -o keep.oIn the ≠kp option, k indicates that the link editor option ≠p is to be passed to the ucode loader.IDREF="96538" TYPE="GRAPHIC"Figure 3-6 illustrates Step 3.LBL="3-6" FILE="3.6.opt.process.ps" POSITION="INLINE" SCALE="FALSE"LBL="3-6"Figure 3-6 ID="96538"Optimization ProcessCreate a ucode file and an optimized object code file (foo) for future.c as follows:IRIS% cc -j future.c
IRIS% cc -O3 -non_shared future.u keep.o -o fooIf the following message appears it means that the code in future.c is using a symbol from the code in b.c or c.c that was not specified in the file extern (go to Step 5 if this message appears.)zot: multiply defined hidden external (should have been preserved)Include zot, which the message indicates is missing, in the file extern and recompile as follows:IRIS% cc -O3 -non_shared -kp extern b.u c.u -o keep.o
IRIS% cc -O3 -non_shared future.u keep.o -o fooLBL="" HELPID=""Building a Ucode Object LibraryID="03.optimize36"Building a ucode object library is similar to building a coff(5) object library. First, compile the source files into ucode object files using the compiler driver option ≠j and using the archiver just as you would for coff object libraries. Using the above example, to build a ucode library (libfoo.b) of a source file, enter the following:IRIS% cc -j a.c
IRIS% cc -j b.c
IRIS% cc -j c.c
IRIS% ar crs libfoo.b a.u b.u c.uConventional names exist for ucode object libraries (libname.b) just as they do for coff object libraries (libname.a).LBL="" HELPID=""Using Ucode Object LibrariesID="03.optimize37"Using ucode object libraries is similar to using coff(5) object files. To load from a ucode library, specify a ≠klname option to the compiler driver or the ucode loader. For example, to load the file created in the previous example from the ucode library (assuming libfoo.a was placed in the /usr/lib directory), enter the following:IRIS% cc -O3 -non_shared file1.u file2.u -klfoo -o outputRemember that libraries are searched as they are encountered on the command line, so the order in which you specify them is important. If a library is made from both assembly and high-level language routines, the ucode object library contains code only for the high-level language routines. The library does not contain all the routines, as does a coff object library or a DSO. In this case, specify to the ucode loader first the ucode object library and then the coff object library or DSO to ensure that all modules are loaded from the proper library.If the compiler driver is to perform both a ucode load step and a final load step, the object file created after the ucode load step is placed in the position of the first ucode file specified or created on the command line in the final load step.LBL="" HELPID=""Improving Global OptimizationID="03.optimize38"This section contains coding hints recommended to increase optimizing opportunities for the global optimizer (uopt). Apply these recommendations to your code whenever possible.LBL="" HELPID=""C and Fortran ProgramsThe following suggestion applies to both C and Fortran programs:ID="03.optimize39"ID="03.optimize40"Do not use indirect calls. Avoid indirect calls (calls that use routines or pointers to functions as arguments). Indirect calls cause unknown side effects (that is, they change global variables) that can reduce the amount of optimization possible.LBL="" HELPID=""C Programs OnlyThe following suggestions apply to C programs only:ID="03.optimize41"Return values. Use functions which return values instead of pointer parameters.ID="03.optimize42"Do while. Use do while instead of while or for when possible. For do while, the optimizer does not have to duplicate the loop condition in order to move code from within the loop to outside the loop.ID="03.optimize43"Unions. Avoid unions that cause overlap between integer and floating point data types. The optimizer will not assign such fields to registers.ID="03.optimize44"Use local variables. Avoid global variables. In C programs, declare any variable outside of a function as static, unless that variable is referenced by another source file. Minimizing the use of global variables increases optimization opportunities for the compiler.ID="03.optimize45"Value parameters. Pass parameters by value instead of passing by reference (pointers) or using global variables. Reference parameters have the same degrading effects as the use of pointers (see below).ID="03.optimize46"Pointers and aliasing. You can often avoid aliases by introducing local variables to store the values obtained from dereferenced pointers. Indirect operations and calls affect dereferenced values, but do not affect local variables. Therefore, local variables can be kept in registers. The following example shows how the proper placement of pointers and the elimination of aliasing produces better code.LBL="" HELPID=""ExampleIn this example, because the statement *p++ = 0 might modify len, the compiler cannot place len in a register for optimal performance. Instead, the compiler must load it from memory on each pass through the loop.LBL="" HELPID=""Source Codeint len = 10;
char a[10];
void
zero()
{
† †  char *p;
† †  for (p= a; p != a + len; ) *p++ = 0;
}LBL="" HELPID=""Generated Assembly Code#8  for (p = a; p!= a + len; )  # p++ = 0;
† †      move   $2, $4
† †      lw     $3, len
† †      addu   $24, $4, $3
† †      beq    $24  $4  $33      # a + len != a
$32 :
† †      sb     $0, 0($2)         # *p = 0
† †      addu   $2, $2, 1         # p++
† †      lw     $25, len
† †      addu   $8, $4, $25
† †      bne    $8, $2, $32       # len + a != p
$33:Two methods for increasing the efficiency of this example might be: using subscripts instead of pointers; and using local variables to store unchanging values.ID="03.optimize47"Using subscripts instead of pointers. Using subscripts in the procedure azero (as shown below) eliminates aliasing. The compiler keeps the value of len in a register, saving two instructions. It still uses a pointer to access a efficiently, even though a pointer is not specified in the source code.LBL="" HELPID=""Source Codevoid azero()
{
† †   int i;
† †   for ( i = 0; i != len; i++ )
† †   a[i] = 0;
}LBL="" HELPID=""Generated Assembly Code† †      for (i = 0; i != len; i++ ) a[i] = 0;
† †      move   $2, $0          # i = 0
† †      beq    $4, 0, $37      # len != a
† †      la     $5, a
$36:
† †      sb     $0, 0($5)       # *a = 0
† †      addu   $2, $2, 1       # i++
† †      addu   $5, $5, 1       # a++
† †      bne    $2, $4, $36     # i != len
$37:Using local variables. Specifying len as a local variable or formal argument (as shown below) prevents aliasing and allows the compiler to place len in a register.LBL="" HELPID=""Source Codechar a[10];
void lpzero(len)
† †   int len;
{
† †   char *p;
† †   for (p = a; p != a + len; ) *p++ = 0;
}LBL="" HELPID=""Generated Assembly Code#8  for (p = a; p!= a + len; )  # p++ = 0;
† †      move   $2, $6
† †      addu   $5, $6, $4
† †      beq    $5, $6  $33       # a + len != a
$32 :
† †      sb     $0, 0($2)         # *p = 0
† †      addu   $2, $2, 1         # p++
† †      bne    $5, $2, $32       # a + len != p
$33:In the previous example, the compiler generates slightly more efficient code for the second method.Write straightforward code. For example, do not use ++ and -- operators within an expression. Using these operators for their values rather than for their side-effects, often produces bad code. For example, the following code uses the value of n-- as a condition for the while loop, which is a convoluted way of performing the loop while n is non-zero:while (n--) {
† †   ...
}In the following code it is obvious that the loop is performed when n is non-zero:while (n != O) {
† †   n--;
† †   ...
}ID="03.optimize48"Use register declarations liberally. The compiler automatically assigns variables to registers. However, specifically declaring a register type lets the compiler make more aggressive assumptions when assigning register variables.ID="03.optimize49"Addresses. Avoid taking and passing addresses (& values). Using addresses creates aliases, makes the optimizer store variables from registers to their home storage locations, and significantly reduces optimization opportunities that would otherwise be performed by the compiler.ID="03.optimize50"VARARG/STDARG.† †Avoid functions that take a variable number of arguments. The optimizer saves all parameter registers on entry to VARARG or STDARG functions.ID="03.optimize51"LBL="" HELPID=""AdaÆ ProgramsThis suggestion applies to Ada programs:ID="03.optimize52"ID="03.optimize53"Use of pragma inline.† †Use pragma inline to inline short subroutines and avoid the overhead associated with procedure calls.LBL="" HELPID=""Improving Other OptimizationThe global optimizer processes programs only when you specify the ≠O2 or ≠O3 option at compilation. However, the code generator and assembler phases of the compiler always perform certain optimizations (certain assembler optimizations are bypassed when you specify the ≠O0 option at compilation).This section contains coding hints that increase optimizing opportunities for the other passes of the compiler.LBL="" HELPID=""C and Fortran ProgramsThe following suggestions apply to both C and Fortran programs:ID="03.optimize54"Use tables rather than ID="03.optimize55"if-then-else or switch statements. For example:/* OK: */
if ( i == 1 ) c = '1';
† †   else c = '0';
/* More efficient: */
c = "01"[i];As an optimizing technique, the compiler puts the first four parameters of a parameter list into registers where they remain during execution of the called routine. Therefore, always declare as the first four parameters those variables that are most frequently manipulated in the called routine.Use word-size variables instead of smaller ones if enough space is available. This practice can take more space, but it is more efficient.LBL="" HELPID=""C Programs OnlyThe following suggestions apply to C programs only:Rely on ID="03.optimize56"libc.so functions (for example, strcpy, strlen, strcmp, bcopy, bzero, memset, and memcpy). These functions were carefully coded for efficiency.Use the ID="03.optimize57"unsigned data type for variables wherever possible (see next bulleted item for an exception to this rule, though). There are two reasons for this. First: since the compiler knows such a variable will always be greater than or equal to zero, it performs optimizations that would not otherwise be possible. Second: the compiler generates fewer instructions for multiplying and dividing unsigned numbers by a power of two. Consider the following example:int i;
unsigned j;
...
return i/2 + j/2;The compiler generates six instructions for the signed i/2 operation:000000   20010002 li       r1,2
000004   0081001a div      r4,r1
000008   14200002 bne      r1,r0,0x14
00000c   00000000 nop
000010   03fe000d break    1022
000014   00001812 mflo     r3The compiler generates only one instruction for the unsigned j/2 operation:000018   0005c042 srl      r24,r5,1   # j / 2In this example, i/2 is an expensive expression, while j/2 is inexpensive.Use a signed data type, or cast to a signed data type, for any variable which must be converted to floating-point.ID="03.optimize58"double d;
unsigned int u;
int i;
/* fast */ d = i;
/* fast */ d = (int)u;
/* slow */ d = u;Converting an unsigned type to floating-point takes significantly longer than converting signed types to floating-point; additional software support must be generated in the instruction stream for the former case.ID="03.optimize59"LBL="4"ID="80096"lexID="04.lex1"LBL="" HELPID=""An Overview of lex ProgrammingID="04.lex2"lex is a software tool that lets you solve a wide class of problems drawn from text processing, code enciphering, compiler writing, and other areas. In text processing, you may check the spelling of words for errors; in code enciphering, you may translate certain patterns of characters into others; and in compiler writing, you may determine what the tokens (smallest meaningful sequences of characters) are in the program to be compiled. The problem common to all of these tasks is recognizing different strings of characters that satisfy certain characteristics. In the compiler writing case, creating the ability to solve the problem requires implementing the compiler's lexical analyzer. Hence the name ID="04.lex3"lex.It is not essential to use lex to handle problems of this kind. You could write programs in a standard language like C to handle them, too. In fact, what lex does is produce such C programs. (lex is therefore called a program generator.) What lex offers you, once you acquire a facility with it, is typically a faster, easier way to create programs that perform these tasks. Its weakness is that it often produces C programs that are longer than necessary for the task at hand and that execute more slowly than they otherwise might. In some applications this is a minor consideration, and the advantages of using ID="04.lex4"lex considerably outweigh it.To build a lexical analyzer using you must create a lex source file, or specification. lex source consists of a list of rules specifying sequences of characters (expressions) to be searched for in an input text, and the actions to take when an expression is found. The specification is read by the lex program, which produces C source code implementing the lexical analyzer. This source code must be compiled using the C compiler to generate the executable object program that does the lexical analysis. Note that this procedure is not typically automaticname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'user intervention is required. Finally, the lexical analyzer program produced by this process takes as input any source file and produces the desired output, such as altered text or a list of tokens.lex can also be used to collect statistical data on features of the input, such as character count, word length, number of occurrences of a word, and so forth. In later sections of this chapter, we will seehow to write lex source to do some of these taskshow to translate lex sourcehow to compile, link, and execute the lexical analyzer in Chow to run the lexical analyzer programWe will then be on our way to appreciating the power that lex provides.LBL="" HELPID=""Writing lex ProgramsID="04.lex5"A† †lex specification consists of at most three sections: definitions, rules, and user subroutines. The rules section is mandatory. Sections for definitions and user subroutines are optional, but if present, must appear in the indicated order.LBL="" HELPID=""The Fundamental lex RulesID="04.lex6"The mandatory rules section opens with the delimiter %%. If a subroutines section follows, another %% delimiter ends the rules section. If there is no second delimiter, the rules section is presumed to continue to the end of the program.Each rule consists of a specification of the pattern sought and the action(s) to take on finding it. (Note the dual meaning of the term specificationname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'it may mean either the entire lex source itself or, within it, a representation of a particular pattern to be recognized.) Whenever the input consists of patterns not sought, lex writes out the input exactly as it finds it. So, the simplest lex program is just the beginning rules delimiter, %%. It writes out the entire input to the output with no changes at all. Typically, the rules are more elaborate than that.LBL="" HELPID=""SpecificationsYou specify the patterns you are interested in with a notation called regular expressions. A regular expression is formed by stringing together characters with or without operators. The simplest regular expressions are strings of text characters with no operators at all. For example,ID="04.lex7"appleorangeplutoThese three regular expressions match any occurrences of those character strings in an input text. If you want to have your lexical analyzer a.out remove every occurrence of orange, from the input text, you could specify the ruleorange ;Because you did not specify an action on the right (before the semicolon), lex does nothing but print out the original input text with every occurrence of this regular expression removed, that is, without any occurrence of the string orange at all.Most of the expressions that we want to search for, however, cannot be specified so easily. The expression itself might simply be too long. More commonly, the class of desired expressions might be too large; it may, in fact, be infinite. Thanks to the use of operators, we can form regular expressions signifying any expression of a certain class. The ID="04.lex8"+ operator, for instance, means one or more occurrences of the preceding expression, the ? means 0 or 1 occurrence(s) of the preceding expression (this is equivalent, of course, to saying that the preceding expression is optional), and * means 0 or more occurrences of the preceding expression. (It may at first seem odd to speak of 0 occurrences of an expression and to need an operator to capture the idea, but it is often quite helpful. We will see an example in a moment.) So m+ is a regular expression matching any string of ms such as each of the following:mmmmmmmmmmmand 7* is a regular expression matching any string of zero or more 7s:7777777777The string of blanks on the third line matches simply because it has no 7s in it at all.Brackets, [ ], indicate any one character from the string of characters specified between the brackets. Thus, [dgka] matches a single d, g, k, or a. Note that commas are not included within the brackets. Any comma here would be taken as a character to be recognized in the input text. Ranges within a standard alphabetic or numeric order are indicated with a hyphen, -. The sequence [a-z], for instance, indicates any lowercase letter. Somewhat more interestingly,[A-Za-z0-9*&#]is a regular expression that matches any letter (whether uppercase or lowercase), any digit, an asterisk, an ampersand, or a sharp character. Given the input text$$$$?? ????!!!*$$ $$$$$$&+====r~~# ((the lexical analyzer with the previous specification in one of its rules will recognize the *, &, r, and #, perform on each recognition whatever action the rule specifies (we have not indicated an action here), and print out the rest of the text as it stands.You can specify all the characters that are not in a given set by placing a caret (^) immediately after the opening bracket. For example:[^xyz]This expression will match any character except x, y, or z.The operators become especially powerful in combination. For example, the regular expression to recognize an identifier in ANSI C is[_a-zA-Z][_0-9a-zA-Z]*An identifier in C is defined to be a letter or underscore followed by zero or more letters, underscores, or digits, and that is just what the regular expression says. The first pair of brackets matches any letter. The second, if it were not followed by a *, would match any digit or letter. The two pairs of brackets with their enclosed characters would then match any letter followed by a digit or a letter. But with the asterisk, *, the example matches any letter followed by any number of letters or digits. In particular, it would recognize the following as identifiers:e_paydistancepHEngineNo99R2D2Note that it would not recognize the following as identifiers:5times
$hellobecause 5times starts with a digit and $hello starts with a special character. You may want to write specifications to recognize these strings as an exercise.A potential problem with operator characters is how we can refer to them as characters to look for in our search pattern. The last example, for instance, will not recognize text with an * in it. lex solves the problem in one of two ways: a character enclosed in quotation marks or a character preceded by a \ is taken literally, that is, as part of the text to be searched for. To use the backslash method to recognize, say, an * followed by any number of digits, we can use the pattern\*[1-9]*To recognize a \ itself, we need two backslashes: \\.LBL="" HELPID=""ActionsID="04.lex9"Once lex recognizes a string matching the regular expression at the start of a rule, it looks to the right of the rule for the action to be performed. Kinds of actions include recording the token type found and its value, if any; replacing one token with another; and counting the number of instances of a token or token type. What you want to do is write these actions as program fragments in the host language C. An action may consist of as many statements as are needed for the job at hand. You may want to print out a message noting that the text has been found or a message transforming the text in some way. Thus, to recognize the expression Amelia Earhart and to note such recognition, the rule"Amelia Earhart" printf("found Amelia");would do. And to replace in a text lengthy medical terms with their equivalent acronyms, a rule such asElectroencephalogram printf("EEG");would be called for. To count the lines in a text, we need to recognize end-of-lines and increment a line counter. lex uses the standard escape sequences from C like \n for end-of-line. To count lines we might have\n lineno++;where lineno, like other C variables, is declared in the definitions section of the lex specification (discussed below in the IDREF="77799" TYPE="TITLE""Definitions"
 section of this chapter).lexID="04.lex10" stores every character string that it recognizes in a character array called yytext[]. You can print or manipulate the contents of this array as you want. Sometimes your action may consist of two or more C statements and you must (or for style and clarity, you choose to) write it on several lines. To inform lex that the action is for one rule only, simply enclose the C code in braces. For example, to count the total number of all digit strings in an input text, print the running total of the number of digit strings (not their sum, here) and print out each one as soon as it is found, your lex code might be[0-9]+     { digstrngcount++;
† †               printf("%d\n", digstrngcount);
† †               printf("%s\n", yytext); }LBL="" HELPID=""Advanced lex UsageID="04.lex11"lex provides a suite of features that lets you process input text riddled with quite complicated patterns. These include rules that decide what specification is relevant, when more than one seems so at first; functions that transform one matching pattern into another; and the use of definitions and subroutines. Before considering these features, you may want to affirm your understanding thus far by examining an example drawing together several of the points already covered.%%
-[0-9]+      printf("negative integer");
\+?[0-9]+    printf("positive integer");
-0.[0-9]+    printf("negative fraction, no whole number part");
rail[ ]+road printf("railroad is one word");
crook        printf("Here's a crook");
function     subprogcount++;
G[a-zA-Z]*   { printf("may have a G word here: %s\n", yytext);
† †              Gstringcount++; }The first three rules recognize negative integers, positive integers, and negative fractions between 0 and -1. The use of the terminating + in each specification ensures that one or more digits compose the number in question. Each of the next three rules recognizes a specific pattern. The specification for railroad matches cases where one or more blanks intervene between the two syllables of the word. In the cases of railroad and crook, you could simply print a synonym rather than the messages given. The rule recognizing function simply increments a counter. The last rule illustrates several points:The brackets specify an action sequence extending over multiple lines.Its action uses the lex array yytext[ ], which stores the recognized character string.Its specification uses the * to indicate that zero or more letters may follow the G.LBL="" HELPID=""Some Special FeaturesID="04.lex12"Besides storing the recognized character string in yytext[ ], lex automatically counts the number of characters in a match and stores it in the variable yyleng. You may use this variable to refer to any specific character just placed in the array yytext[]. Remember that C numbers locations in an array starting with 0, so to print out the third digit (if there is one) in a just-recognized integer, you might write[0-9]+  { if (yyleng > 2)
† †         printf("%c", yytext[2]); }lex follows a number of high-level rules to resolve ambiguities that may arise from the set of rules that you write. For instance, the keyword "while" in C would probably match a rule designed for C identifiers, as well as the more specific rule designed to match that keyword.lexID="04.lex13" follows the rule that where there is a match with two or more rules in a specification, the first rule is the one whose action will be executed.† †So if you were writing a lexical analyzer for C, you would probably want to put the rules for "while" and the other keywords before the rule for identifiers, to ensure that the keywords would be recognized.Another potential problem arises from cases where one pattern you are searching for is the prefix of another. For instance, consider a pair of rules designed to recognize > and >=. If the text contains the string >= at one point, you might worry that the lexical analyzer would stop as soon as it recognized the > character to execute the rule for > rather than read the next character and execute the rule for >=. Instead, lex always matches the longest character string possible and executes the rule for that.Here it would recognize the >= and act accordingly. As a further example, the rule would enable you to distinguish + from ++ in a program in C.Still another potential problem exists when the analyzer must read characters beyond the string you are seeking because you cannot be sure you've in fact found it until you've read the additional characters. These cases reveal the importance of trailing context. For example, suppose you were trying to locate function references in C source code. Function namesID="04.lex14"† †can usually be identified by the parenthesis that follows them (and the optional parameter list):int onefunc(), twofunc();
i = redfunc(i) + bluefunc(i);The way to handle this is to use the forward-looking slash, / (not the backslash, \), which signifies that what follows is trailing context, something not to be stored in yytext[ ], because it is not part of the token itself. So, to recognize the function references, you might use the following rule:[_a-zA-Z][_a-zA-Z0-9]*/[ \t\n]*(    {
† †          printf("function called or declared %s\n", yytext);
† †        }The pattern before the slash will match any legitimate ANSI C identifier: a letter or underscore followed by zero or more letters, digits, or underscores. The trailing context pattern will match any number of whitespace characters, followed by an open parenthesis. Only the function name will be stored in yytext[], however. While this example demonstrates trailing context fairly well, it's worth noting that if you were trying to parse C code, you would probably want to do this particular job in the parser, not in the lexical analyzer.lex uses the $ as an operator to mark a special trailing contextname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the end of line. (It is therefore equivalent to /\n.) An example would be a rule to ignore all blanks and tabs at the end of a line:† †[ \t]+$ ;On the other hand, if you want to match a pattern only when it occurs at the beginning of a line, you can use the caret, ^, as the first character in the pattern. The formatter nroff, for example, doesn't format lines that start with a blank or a tab, so you might want to check input to nroff with some such rule as:^[ \t] printf("warning: line has leading whitespace\n");The position of the caret is crucial, since caret has three different meanings, depending on its position in a pattern. As the first character in a pattern, it matches the beginning of a line. When caret is the first character after a left bracket, ID="04.lex15"[, it acts as a negation operator, so that the bracketed set will match any character not in that set. When caret appears anywhere else in a pattern, it simply matches the caret character itself.† †Finally, some of your action statements themselves may require your reading another character, putting one back to be read again a moment later, or writing a character on an output device. lex supplies three functions to handle these tasksname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'input(), unput(), and output(), respectively. One way to ignore all characters between two special characters, say between a pair of double quotation marks, would be to use input(), thus:\" while (input() != '"');Upon finding the first double quotation mark, the generated a.out will simply continue reading all subsequent characters so long as none is a quotation mark, and not again look for a match until it finds a second double quotation mark.To handle special I/O needs, such as writing to several files, you may use standard I/O routines in C to rewrite the functions ID="04.lex16"input(), unput(), and output(). These and other programmer-defined functions should be placed in your subroutine section. Your new routines will then replace the standard ones. The standard input(), in fact, is equivalent to getchar(), and the standard output() is equivalent to putchar().There are a number of ID="04.lex17"lex routines that let you handle sequences of characters to be processed in more than one way. These include yymore(), yyless(), and REJECT. Recall that the text matching a given specification is stored in the array yytext[ ]. In general, once the action is performed for the specification, the characters in yytext[ ] are overwritten with succeeding characters in the input stream to form the next match. The function yymore(), by contrast, ensures that the succeeding characters recognized are appended to those already in yytext[]. When the size of yytext[ ] is increased in this way, yyleng is updated to reflect the new size. This lets you do one thing and then another, when one string of characters is significant and a longer one including the first is significant as well. Consider a character string bounded by Bs and interspersed with one at an arbitrary location.B...B...BIn a simple code deciphering situation, you may want to count the number of characters between the first and second Bs and add it to the number of characters between the second and third Bs. (Only the last B is not to be counted.) The code to do this is  B[^B]*     {  if (flag == 0) {
† †               flag = 1;
† †               yymore();
† †             }
† †             else {
† †               importantno = yyleng;
† †               flag = 0;
† †             }
† †           }where flag, and importantno are declared (and at least flag initialized to 0) in the definitions section. The flag distinguishes the character sequence terminating just before the second B from that terminating just before the third.The function ID="04.lex18"yyless() lets you reset the end point of the string to be considered to the nth character in the original yytext[]. Suppose you are again in the code deciphering business and the gimmick here is to work with only half the characters in a sequence ending with a certain one, say uppercase or lowercase Z. The code you want might be[a-yA-Y]+[Zz] { yyless(yyleng/2);
† †             ... process first half of string... }Finally, the function ID="04.lex19"REJECT lets you more easily process strings of characters even when they overlap or contain one another as parts. REJECT does this by immediately jumping to the next rule and its specification without changing the contents of yytext[ ]. If you want to count the number of occurrences both of the regular expression snapdragon and of its sub-expression dragon in an input text, the following will do:snapdragon          {countflowers++; REJECT;}dragon              countmonsters++;As an example of one pattern overlapping another, the following counts the number of occurrences of the expressions comedian and diana, even where the input text has sequences such as comediana:comedian      {comiccount++; REJECT;}diana         princesscount++;Note that the actions here may be considerably more complicated than simply incrementing a counter. In all cases, the counters and other necessary variables are declared in the definitions section at the beginning of the lex specification.LBL="" HELPID=""ID="77799"DefinitionsID="04.lex20"The ID="04.lex21"lex definitions section may contain any of several classes of items. The most critical are external definitions, #include statements, and abbreviations. Recall that for legal lex source this section is optional, but in most cases some of these items are necessary. External definitions have the form and function that they do in C. They declare that variables globally defined elsewhere (perhaps in another source file) will be accessed in your lex-generated a.out. Consider a declaration from an example to be developed later.extern int tokval;When you store an integer value in a variable declared in this way, it will be accessible in the routine, say a parser, that calls it. If, on the other hand, you want to define a local variable for use within the action sequence of one rule (as you might for the index variable for a loop), you can declare the variable at the start of the action itself right after the left brace, {.The purpose of the #include statement is the same as in C: to include files of importance for your program. Some variable declarations and lex definitions might be needed in more than one lex source file. It is then advantageous to place them all in one file to be included in every file that needs them. One example occurs in using lex with yacc, which generates parsers that call a lexical analyzer. In this context, you should include the file y.tab.h, whichmay contain #defines for token names. Like the declarations, #include statements should come between %{ and }%, thus:%{#include "y.tab.h"extern int tokval;int lineno;%}In the definitions section, after the ID="04.lex22"%} that ends your #includes and declarations, you place your abbreviations for regular expressions to be used in the rules section. The abbreviation appears on the left of the line and, separated by one or more spaces, its definition or translation appears on the right. When you later use abbreviations in your rules, be sure to enclose them within braces.The purpose of abbreviations is to avoid needless repetition in writing your specifications and to provide clarity in reading them.† †As an example, reconsider the lex source reviewed at the beginning of this section on advanced lex usage. The use of definitions simplifies our later reference to digits, letters, and blanks. This is especially true if the specifications appear several times:D               [0-9]
L               [a-zA-Z]
B               [ \t]
%%-{D}+           printf("negative integer");
\+?{D}+         printf("positive integer");
-0.{D}+         printf("negative fraction");
G{L}*           printf("may have a G word here");
rail{B}+road    printf("railroad is one word");
† †  .              .
† †  .              .LBL="" HELPID=""SubroutinesID="04.lex23"You may want to use subroutines in lex for much the same reason that you do so in other programming languages. Action code that is to be used for several rules can be written once and called when needed. As with definitions, this can simplify the writing and reading of programs. The function put_in_tabl(), to be discussed in the next section on lex and yacc, is a good candidate for a subroutine.Another reason to place a routine in this section is to highlight some code of interest or to simplify the rules section, even if the code is to be used for one rule only. As an example, consider the following routine to ignore comments in a language like C where comments occur between /* and */:"/*"            skipcmnts();
† †  .
† †  .        /* rest of rules */
%%
skipcmnts()
{
† †     while(1)
† †     {
† †       while (input() != '*') ;
† †       if (input() != '/') {
† †         unput(yytext[yyleng-1]);
† †       else return;
† †     }
}There are three points of interest in this example. First, the unput() function (putting back the last character read) is necessary to avoid missing the final / if the comment ends unusually with a **/. In this case, eventually having read an *, the analyzer finds that the next character is not the terminal / and must read some more. Second, the expression yytext[yyleng-1] picks out that last character read. Third, this routine assumes that the comments are not nested. (Which is true in the C language.) If, unlike in C, comments are nested in the source text, after input()ing the first */ ending the inner group of comments, the a.out will read the rest of the comments as if they were part of the input to be searched for patterns.Other examples of subroutines would be programmer-defined versions of the I/O routines input(), unput(), and output(), discussed above. Subroutines such as these that may be exploited by many different programs would probably do best to be stored in their own individual file or library to be called as needed. The appropriate #include statements would then be necessary in the definitions section.LBL="" HELPID=""Using lex with yaccID="04.lex24"If you work on a compiler project or develop a program to check the validity of an input language, you may want to use the UNIX system program tool yacc. yacc generates parsers, programs that analyze input to ensure that it is syntactically correct. (yacc is discussed in detail in IDREF="82425" TYPE="TITLE"Chapter 5
 of this guide.) lex often forms a fruitful union with yacc in the compiler development context. Whether or not you plan to use lex with yacc, be sure to read this section because it covers information of interest to all lex programmers.The lexical analyzer that ID="04.lex25"lex generates (not the file that stores it) takes the name yylex(). This name is convenient because yacc calls its lexical analyzer by this very name. To use lex to create the lexical analyzer for the parser of a compiler, you want to end each lex action with the statement return† †token, where token is a defined term whose value is an integer. The integer value of the token returned indicates to the parser what the lexical analyzer has found. The parser, whose file is called ID="04.lex26"y.tab.c by yacc, then resumes control and makes another call to the lexical analyzer when it needs another token.In a compiler, the different values of the token indicate what, if any, reserved word of the language has been found or whether an identifier, constant, arithmetic operand, or relational operator has been found. In the latter cases, the analyzer must also specify the exact value of the token: what the identifier is, whether the constant, say, is 9 or 888, whether the operand is + or * (multiply), and whether the relational operator is = or >. Consider the following piece of lex source for a lexical analyzer for some programming language perhaps slightly reminiscent of Ada:begin         return(BEGIN);
end           return(END);
while         return(WHILE);
if            return(IF);
package       return(PACKAGE);
reverse       return(REVERSE);
loop          return(LOOP);
[a-zA-Z][a-zA-Z0-9]*   { tokval = put_in_tabl();
† †                        return(IDENTIFIER); }
[0-9]+        { tokval = put_in_tabl(); \
† †               return(INTEGER); }
\+            { tokval = PLUS; return(ARITHOP); }
\-            { tokval = MINUS; return(ARITHOP); }
>             { tokval = GREATER; return(RELOP); }
>=            { tokval = GREATEREQL; return(RELOP); }Despite appearances, the tokens returned, and the values assigned to tokval, are indeed integers. Good programming style dictates that we use descriptive symbolic constants such as BEGIN, END, WHILE, and so forth to signify the integers the parser understands, rather than using the integers themselves. You establish the association by using #define statements in your parser calling routine in C. For example,#define BEGIN  1
#define END    2
#define PLUS   7If the need arises to change the integer for some token type, you then change the #define statement in the parser rather than hunt through the entire program, changing every occurrence of the particular integer. In using ID="04.lex27"yacc to generate your parser, it is helpful to insert the statement#include y.tab.hinto the definitions section of your lex source. The file y.tab.h provides #define statements that associate token names such as BEGIN, END, and so on with the integers of significance to the generated parser.To indicate the reserved words in the example, the returned integer values suffice. For the other token types, the integer value of the token type is stored in the programmer-defined variable ID="04.lex28"tokval. This variable, whose definition was an example in the definitions section, is globally defined so that the parser as well as the lexical analyzer can access it. ID="04.lex29"yacc provides the variable yylval for the same purpose.Note that the example shows two ways to assign a value to tokval. First, the user-written routine put_in_tabl() places the name and type of the identifier or constant in a symbol table so that the compiler can refer to it in this or a later stage of the compilation process. More to the present point, put_in_tabl() assigns a type value to tokval so that the parser can use the information immediately to determine the syntactic correctness of the input text. The function put_in_tabl() would be a routine that the compiler writer might place in the subroutines section discussed later. Second, in the last few actions of the example, tokval is assigned a specific integer indicating which operand or relational operator the analyzer recognized. If the variable PLUS, for instance, is associated with the integer 7 by means of the #define statement above, then when a + sign is recognized, the action assigns to tokval the value 7, which indicates the +. The analyzer indicates the general class of operator by the value it returns to the parser (in the example, the integer signified by ARITHOP or RELOP).LBL="" HELPID=""Running lex Under IRIXID="04.lex30"To produce a lexical analyzer in C, runlex lex.lwhere lex.l is the file containing your lex specification. The name lex.l is conventionally the favorite, but you may use whatever name you want. The output file that ID="04.lex31"lex produces is automatically called lex.yy.c; this is the lexical analyzer program that you created with lex. You then compile and link this as you would any C program, making sure that you invoke the ID="04.lex32"lex library with the ≠ll option:ID="04.lex33"cc lex.yy.c -llThe lex library provides a default main() program that calls the lexical analyzer under the name yylex(), so you need not supply your own main().If you have the lex specification spread across several files, you can run lex with each of them individually, but be sure to rename or move each lex.yy.c file (using mv) before you run lex on the next one. Otherwise, each will overwrite the previous one. Once you have all the generated .c files, you can compile all of them, of course, in one command line.With the executable a.out produced, you are ready to analyze any desired input text. Suppose that the text is stored under the filename textin (this name is also arbitrary). The lexical analyzer a.out by default takes input from your terminal. To have it take the file textin as input, simply use redirection, thus:a.out < textinBy default, output will appear on your terminal, but you can redirect this too:a.out < textin > textoutIn running lex with yacc, either may be run first.yacc -d grammar.y
lex lex.lspawns a parser in the file y.tab.c. (The ≠d option creates the file y.tab.h, which contains the #define statements that associate the yacc assigned integer token values with the user-defined token names.) To compile and link the output files produced, runcc lex.yy.c y.tab.c -ly -llNote that the ID="04.lex34"yacc library is loaded (with the ≠ly option) before the lex library (with the ≠ll option) to ensure that the main() program supplied will call the yacc parser.There are several options available with the lex command. If you use one or more of them, place them between the command name lex and the filename argument. If you care to see the C program, ID="04.lex35"lex.yy.c, that lex generates on your terminal (the default output device), use the ≠t option.lex -t lex.lThe ID="04.lex36"≠v option prints out for you a small set of statistics describing the so-called finite automata that lex produces with the C program lex.yy.c. (For a detailed account of finite automata and their importance for ID="04.lex37"lex, see the Aho, Sethi, and Ullman text, Compilers: Principles, Techniques, and Tools, Addison-Wesley, 1986.)lex uses a table (a two-dimensional array in C) to represent its finite automaton. The maximum number of states that the finite automaton requires is set by default to 500. If your lex source has a large number of rules or the rules are very complex, this default value may be too small. You can enlarge the value by placing another entry in the definitions section of your lex source, as follows:%n 700This entry tells lex to make the table large enough to handle as many as 700 states. (The ≠v option will indicate how large a number you should choose.) If you have need to increase the maximum number of state transitions beyond 2000, the designated parameter is a, thus:%a 2800Finally, check the manual page on lex(1) for a list of all the options available with the lex command. In addition, review the paper by Lesk (the originator of lex) and Schmidt, "Lexname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'A Lexical Analyzer Generator," in volume 5 of the UNIX Programmer's Manual, Holt, Rinehart, and Winston, 1986. It is somewhat dated, but offers several interesting examples.This tutorial has introduced you to lex programming. As with any programming language, the way to master lex is to write programs and then write some more.ID="04.lex38"LBL="5"ID="82425"yaccLBL="" HELPID=""An Overview of yacc ProgrammingID="05.yacc1"yacc provides a general tool for imposing structure on the input to a computer program. The yacc user prepares a specification that includes:a set of rules to describe the elements of the inputcode to be invoked when a rule is recognizedeither a definition or declaration of a low-level routine to examine the inputyacc then turns the specification into a C language function that examines the input stream. This function, called a parser, works by calling the low-level input scanner. The low-level input scanner, called a lexical analyzer, picks up items from the input stream. The selected items are known as tokens. Tokens are compared to the input construct rules, called grammar rules. When one of the rules is recognized, the user code supplied for this rule (an action) is invoked. Actions are fragments of C language code. They can return values and make use of values returned by other actions.ID="05.yacc2"yacc is most often used to generate a parser which will later be incorporated into a compiler. The name yacc is short for "yet another compiler-compiler."† †The heart of the yacc specification is the collection of grammar rules. Each rule describes a construct and gives it a name. For example, one grammar rule might bedate : month_name day ',' year ;where date, month_name, day, and year represent constructs of interest; presumably, month_name, day, and year are defined in greater detail elsewhere. In the example, the comma is enclosed in single quotes. This means that the comma is to appear literally in the input. The colon and semicolon merely serve as punctuation in the rule and have no significance in evaluating the input. With proper definitions, the inputJuly 4, 1776might be matched by the rule.The lexical analyzer is an important part of the parsing function. This user-supplied routine reads the input stream, recognizes the lower-level constructs, and communicates these as tokens to the parser. The lexical analyzer recognizes constructs of the input stream as terminal symbols; the parser recognizes constructs as nonterminal symbols. To avoid confusion, we will refer to terminal symbols as tokens.ID="05.yacc3"There is considerable leeway in deciding whether to recognize constructs using the lexical analyzer or grammar rules. For example, the rulesmonth_name : 'J' 'a' 'n' ;
month_name : 'F' 'e' 'b' ;
† †          ...
month_name : 'D' 'e' 'c' ;might be used in the above example. While the lexical analyzer here would only need to recognize individual letters, such low-level rules tend to waste time and space, and may complicate the specification beyond the ability of yacc to deal with it. Usually, the lexical analyzer would recognize the month names and return an indication that a month_name has been seen. In that case, month_name is a token and the detailed rules are not needed.Literal characters such as a comma must also be passed through the lexical analyzer and are also considered tokens.ID="05.yacc4"Specification files are very flexible. It is relatively easy to add to the above example the ruledate : month '/' day '/' year ;allowing7/4/1776as a synonym forJuly 4, 1776on input. In most cases, this new rule could be slipped into a working system with minimal effort and little danger of disrupting existing input.The input being read may not conform to the specifications. With a left-to-right scan input errors are detected as early as is theoretically possible. Thus, not only is the chance of reading and computing with bad input data substantially reduced, but the bad data usually can be found quickly. Error handling, provided as part of the input specifications, permits the reentry of bad data or the continuation of the input process after skipping over the bad data.In some cases, ID="05.yacc5"yacc fails to produce a parser when given a set of specifications. For example, the specifications may be self-contradictory, or they may require a more powerful recognition mechanism than that available to yacc. The former case represents a design error; the latter case often can be corrected by making the lexical analyzer more powerful or by rewriting some of the grammar rules. While yacc cannot handle all possible specifications, its power compares favorably with similar systems. Moreover, the constructs that are difficult for yacc to handle are also frequently difficult for human beings to handle. Some users have reported that the discipline of formulating valid yacc specifications for their input revealed errors of conception or design early in program development.The remainder of this chapter describes the following subjects:basic process of preparing a yacc specificationparser operationhandling ambiguitieshandling operator precedences in arithmetic expressionserror detection and recoverythe operating environment and special features of the parsers yacc producessuggestions to improve the style and efficiency of the specificationsadvanced topicsIn addition, there are two examples and a summary of the yacc input syntax.ID="05.yacc6"LBL="" HELPID=""Basic SpecificationsNames refer to either tokens or nonterminal symbols. ID="05.yacc7"yacc requires token names to be declared as such. While the lexical analyzer may be included as part of the specification file, it is more in keeping with modular design to keep it as a separate file. Like the lexical analyzer, other subroutines may be included as well. Thus, every specification file theoretically consists of three sections: declarations, (grammar) rules, and subroutines. The sections are separated by double percent signs, ID="05.yacc8"%% (the percent sign is generally used in yacc specifications as an escape character).A full specification file looks like:declarations%%rules%%subroutineswhen all sections are used. The declarations and subroutines sections are optional. The smallest legal yacc specification is%%rulesBlanks, tabs, and newlines are ignored, but they may not appear in names or multicharacter reserved symbols. Comments may appear wherever a name is legal. They are enclosed in ID="05.yacc9"/* ... */, as in the C language.The rules section is made up of one or more grammar rules. A grammar rule has the formA : BODY ;where A represents a nonterminal symbol, and BODY represents a sequence of zero or more names and literals. The colon and the semicolon are yacc punctuation.Names may be of any length and may be made up of letters, dots, underscores, and digits, although a digit may not be the first character of a name. Uppercase and lowercase letters are distinct. The names used in the body of a grammar rule may represent tokens or nonterminal symbols.ID="05.yacc10"A literal consists of a character enclosed in single quotes, ID="05.yacc11"'. As in the C language, the backslash, \, is an escape character within literals, and all the C language escapes are recognized. Thus:'\n'newline'\r'return'\''single quote ( ' )'\\'backslash ( \ )'\t'tab'\b'backspace'\f'form feed'\xxx'xxx in octal notationare understood by yacc. For a number of technical reasons, the NULL character (\0 or 0) should never be used in grammar rules.ID="05.yacc12"If there are several grammar rules with the same left-hand side, the vertical bar, ID="05.yacc13"|, can be used to avoid copying the left-hand side. In addition, the semicolon at the end of a rule is dropped before a vertical bar. Thus the grammar rulesA : B C D ;A : E F ;A : G ;can be given to yacc asA : B C D  | E F  | G  ;by using the vertical bar.It is not necessary that all grammar rules with the same left side appear together in the grammar rules section, although placing them together makes the input more readable and easier to change.† †If a nonterminal symbol matches the empty string, this can be indicated byepsilon : ;The blank space following the colon is understood by yacc to be a nonterminal symbol named epsilon.Names representing tokens must be declared. This is most simply done by writingID="05.yacc14"%token name1 name2 ...in the declarations section. Every name not defined in the declarations section is assumed to represent a nonterminal symbol. Every nonterminal symbol must appear on the left side of at least one rule.Of all the nonterminal symbols, the start symbol has particular importance. By default, the start symbol is taken to be the left-hand side of the first grammar rule in the rules section. It is a good idea to declare the start symbol explicitly in the declarations section using the ID="05.yacc15"%start keyword.%start symbolThe end of the input to the parser is signaled by a special token, called the end-marker. The end-marker is represented by either a zero or a negative number. If the tokens up to but not including the end-marker form a construct that matches the start symbol, the parser function returns to its caller after the end-marker is seen and accepts the input. If the end-marker is seen in any other context, it is an error.ID="05.yacc16"It is the job of the user-supplied lexical analyzer to return the end-marker when appropriate. Usually the end-marker represents some reasonably obvious I/O status, such as end of file or end of record.LBL="" HELPID=""ActionsWith each grammar rule, the user may associate actions to be performed when the rule is recognized. Actions may return values and may obtain the values returned by previous actions. Moreover, the lexical analyzer can return values for tokens if desired.ID="05.yacc17"An action is an arbitrary C language statement and as such can do input and output, call subroutines, and alter arrays and variables. An action is specified by one or more statements enclosed in curly braces, { ... }. For example:A : '(' B ')'
† † {    hello( 1, "abc" );  }and† †XXX : YYY ZZZ     {       (void) printf("a message\n");       flag = 25;     }are grammar rules with actions.The dollar sign symbol, ID="05.yacc18"$, is used to facilitate communication between the actions and the parser. The pseudo-variable $$ represents the value returned by the complete action. For example, the action{ $$ = 1; }returns the value of one; in fact, that's all it does.To obtain the values returned by previous actions and the lexical analyzer, the action may use the pseudo-variables $1, $2, ..., $n. These refer to the values returned by components 1 through n of the right side of a rule, with the components being numbered from left to right. If the rule isA : B C D ;then $2 has the value returned by C, and $3 the value returned by D.The ruleexpr : '(' expr ')' ;provides a common example. One would expect the value returned by this rule to be the value of the expr within the parentheses. Since the first component of the action is the literal left parenthesis, the desired logical result can be indicated byexpr : '(' expr ')'     {       $$ = $2 ;     }By default, the value of a rule is the value of the first element in it ($1). Thus, grammar rules of the form A : B ; frequently need not have an explicit action. In previous examples, all the actions came at the end of rules. Sometimes, it is desirable to get control before a rule is fully parsed. yacc permits an action to be written in the middle of a rule as well as at the end. This action is assumed to return a value accessible through the usual $ mechanism by the actions to the right of it. In turn, it may access the values returned by the symbols to its left. Thus, in the rule below the effect is to set x to 1 and y to the value returned by C.A : B
† †      {
† †         $$ = 1;
† †      }
† †      C
† † {
† †      x = $2;
† †      y = $3;
† † }
† † ;
Actions that do not terminate a rule are handled by yacc by manufacturing a new nonterminal symbol name and a new rule matching this name to the empty string. The interior action is the action triggered by recognizing this added rule. yacc treats the above example as if it had been written$ACT :   /* empty */
† †    {
† †        $$ = 1;
† †    }
† †    ;
A    :   B $ACT C
† †    {
† †        x = $2;
† †        y = $3;
† †    }
† †    ;where $ACT is an empty action.In many applications, output is not done directly by the actions. A data structure, such as a parse tree, is constructed in memory and transformations are applied to it before output is generated. Parse trees are particularly easy to construct given routines to build and maintain the tree structure desired. For example, suppose there is a C function node written so that the callnode( L, n1, n2 )creates a node with label L and descendants n1 and n2 and returns the index of the newly created node. Then a parse tree can be built by supplying actions such asexpr : expr '+' expr{$$ = node( '+', $1, $3 );}in the specification.The user may define other variables to be used by the actions. Declarations and definitions can appear in the declarations section enclosed in the marks %{ and %}. These declarations and definitions have global scope, so they are known to the action statements and can be made known to the lexical analyzer. For example:%{ int variable = 0; %}could be placed in the declarations section making variable accessible to all of the actions.Users should avoid names beginning with yy because the yacc parser uses only such names. In the examples shown thus far all the values are integers. A discussion of values of other types is found in IDREF="72113" TYPE="TITLE"Section , "Advanced yacc Features."ID="05.yacc19"LBL="" HELPID=""ID="14170"Lexical AnalysisThe user must supply a lexical analyzer to read the input stream and communicate tokens (with values, if desired) to the parser. The lexical analyzer is an integer-valued function called ID="05.yacc20"yylex(). The function returns an integer, the token number, representing the kind of token read. If there is a value associated with that token, it should be assigned to the external variable ID="05.yacc21"yylval.The parser and the lexical analyzer must agree on these token numbers in order for communication between them to take place. The numbers may be chosen by ID="05.yacc22"yacc or the user. In either case, the #define mechanism of C language is used to allow the lexical analyzer to return these numbers symbolically. For example, suppose that the token name DIGIT has been defined in the declarations section of the yacc specification file. The relevant portion of the lexical analyzer might look likeint yylex()
{
† †         extern int yylval;
† †         int c;
† †         ...
† †         c = getchar();
† †         ...
† †         switch (c)
† †         {
† †            ...
† †            case '0':
† †              case '1':
† †            ...
† †            case '9':
† †            yylval = c - '0';
† †               return (DIGIT);
† †            ...
† †          }
† †          ...
}to return the appropriate token.The intent is to return a token number of DIGIT and a value equal to the numerical value of the digit. Provided that the lexical analyzer code is placed in the subroutines section of the specification file, the identifier DIGIT is defined as the token number associated with the token DIGIT.This mechanism leads to clear, easily modified lexical analyzers. The only pitfall to avoid is using any token names in the grammar that are reserved or significant in C language or the parser. For example, the use of token names if or while will almost certainly cause severe difficulties when the lexical analyzer is compiled. The token name error is reserved for error handling and should not be used naively.In the default situation, token numbers are chosen by ID="05.yacc23"yacc. The default token number for a literal character is the numerical value of the character in the local character set. Other names are assigned token numbers starting at 257. If the yacc command is invoked with the ≠d option a file called y.tab.h is generated. y.tab.h contains #define statements for the tokens.If the user prefers to assign the token numbers, the first appearance of the token name or literal in the declarations section must be followed immediately by a nonnegative integer. This integer is taken to be the token number of the name or literal. Names and literals not defined this way are assigned default definitions by yacc. The potential for duplication exists here. Care must be taken to make sure that all token numbers are distinct.For historical reasons, the end-marker must have token number 0 or a negative token number. This token number cannot be redefined by the user. Thus, all lexical analyzers should be prepared to return 0 or a negative number as a token upon reaching the end of their input.ID="05.yacc24"A very useful tool for constructing lexical analyzers is the ID="05.yacc25"lex utility. Lexical analyzers produced by lex are designed to work in close harmony with yacc parsers. The specifications for these lexical analyzers use regular expressions instead of grammar rules. lex can be easily used to produce quite complicated lexical analyzers, but there remain some languages (such as FORTRAN), which do not fit any theoretical framework and whose lexical analyzers must be crafted by hand. For more information about lex, see IDREF="80096" TYPE="TITLE"Chapter 4, "lex."LBL="" HELPID=""Parser OperationID="05.yacc26"yacc turns a specification file into a C language procedure, which parses the input according to the specification given. The algorithm used to go from the specification to the parser is complex and will not be discussed here. The parser itself, though, is relatively simple and understanding its use will make treatment of error recovery and ambiguities easier.The parser produced by ID="05.yacc27"yacc consists of a finite-state machine with a stack. The parser is also capable of reading and remembering the next input token (called the look-ahead token). The current state is always the one on the top of the stack. The states of the finite state machine are given small integer labels. Initially, the machine is in state 0 (the stack contains only state 0) and no look-ahead token has been read.The machine has only four actions available: shift, reduce, accept, and error. A step of the parser is done as follows:Based on its current state, the parser decides if it needs a look-ahead token to choose the action to be taken. If it needs one and does not have one, it calls yylex() to obtain the next token.Using the current state and the look-ahead token if needed, the parser decides what its next action should be and carries it out. This may result in states being pushed onto the stack or popped off of the stack and in the look-ahead token being processed or left alone.The ID="05.yacc28"shift action is the most common action the parser takes. Whenever a shift action is taken, there is always a look-ahead token. For example, in state 56 there may be an actionIF shift 34which means that, in state 56, if the look-ahead token is IF, the current state (56) is pushed down on the stack, and state 34 becomes the current state (on the top of the stack). The look-ahead token is then cleared.The ID="05.yacc29"reduce action keeps the stack from growing without bounds. reduce actions are appropriate when the parser has seen the right-hand side of a grammar rule and is prepared to announce that it has seen an instance of the rule replacing the right-hand side by the left-hand side. It may be necessary to consult the look-ahead token to decide whether or not to reduce (usually it is not necessary). In fact, the default action (represented by a dot) is often a reduce action.reduce actions are associated with individual grammar rules. Grammar rules are also given small integer numbers, and this leads to some confusion. The action. reduce 18refers to grammar rule 18, while the actionIF shift 34refers to state 34.Suppose the ruleA : x y z ;is being reduced. The reduce action depends on the left-hand symbol (A in this case) and the number of symbols on the right-hand side (three in this case). To reduce, first pop off the top three states from the stack. (In general, the number of states popped equals the number of symbols on the right side of the rule.) In effect, these states were the ones put on the stack while recognizing x, y, and z and no longer serve any useful purpose. After popping these states, a state is uncovered, which was the state the parser was in before beginning to process the rule. Using this uncovered state and the symbol on the left side of the rule, perform what is in effect a ID="05.yacc30"shift of A. A new state is obtained and pushed onto the stack, and parsing continues. There are significant differences between the processing of the left-hand symbol and an ordinary shift of a token, however, so this action is called agoto action. In particular, the look-ahead token is cleared by a shift but is not affected by a goto. In any case, the uncovered state contains an entry such asA goto 20causing state 20 to be pushed onto the stack and become the current state.In effect, the reduce action turns back the clock in the parse, popping the states off the stack to go back to the state where the right-hand side of the rule was first seen. The parser then behaves as if it had seen the left side at that time. If the right-hand side of the rule is empty, no states are popped off of the stacks. The uncovered state is in fact the current state.The reduce action is also important in the treatment of user-supplied actions and values. When a rule is reduced, the code supplied with the rule is executed before the stack is adjusted. In addition to the stack holding the states, another stack running in parallel with it holds the values returned from the lexical analyzer and the actions. When a ID="05.yacc31"shift takes place, the external variable yylval is copied onto the value stack. After the return from the user code, the reduction is carried out. When the goto action is done, the external variable yyval is copied onto the value stack. The pseudo-variables $1, $2, and so on refer to the value stack.The other two parser actions are conceptually much simpler. The ID="05.yacc32"accept action indicates that the entire input has been seen and that it matches the specification. This action appears only when the look-ahead token is the end-marker and indicates that the parser has successfully done its job. The error action, on the other hand, represents a place where the parser can no longer continue parsing according to the specification. The input tokens it has seen (together with the look-ahead token) cannot be followed by anything that would result in a legal input. The parser reports an error and attempts to recover the situation and resume parsing. The error recovery (as opposed to the detection of error) will be discussed later.Consider:%token DING DONG DELL
%%
rhyme : sound place
† †     ;
sound : DING DONG
† †     ;
place : DELL
† †     ;as a yacc specification.When ID="05.yacc33"yacc is invoked with the ≠v option, a file called y.output is produced with a human-readable description of the parser. The y.output file corresponding to the above grammar (with some statistics stripped off the end) follows.state 0
† †       $accept : _rhyme $end

† †       DING shift 3
† †       . error

† †       rhyme goto 1
† †       sound goto 2

state 1
† †       $accept : rhyme_$end

† †       $end accept
† †       . error

state 2
† †       rhyme : sound_place

† †       DELL shift 5
† †       . error

† †       place goto 4

state 3
† †       sound : DING_DONG

† †       DONG shift 6
† †       . error

state 4
† †       rhyme : sound place_ (1)

† †       . reduce 1

state 5
† †       place : DELL_ (3)

† †       . reduce 3

state 6
† †       sound : DING DONG_ (2)

† †       . reduce 2The actions for each state are specified and there is a description of the parsing rules being processed in each state. The underscore character (_) is used to indicate what has been seen and what is yet to come in each rule. The following inputDING DONG DELLcan be used to track the operations of the parser. Initially, the current state is state 0. The parser needs to refer to the input in order to decide between the actions available in state 0, so the first token, DING, is read and becomes the look-ahead token. The action in state 0 on DING is shift 3; state 3 is pushed onto the stack, and the look-ahead token is cleared. State 3 becomes the current state. The next token, DONG, is read and becomes the look-ahead token. The action in state 3 on the token DONG is shift 6; state 6 is pushed onto the stack, and the look-ahead is cleared. The stack now contains 0, 3, and 6. In state 6, without even consulting the look-ahead, the parser reduces bysound : DING DONGwhich is rule 2. Two states, 6 and 3, are popped off of the stack, uncovering state 0. Consulting the description of state 0 (looking for a goto on sound),sound goto 2is obtained. State 2 is pushed onto the stack and becomes the current state.In state 2, the next token, DELL, must be read. The action is shift 5, so state 5 is pushed onto the stackname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'which now has 0, 2, and 5 on itname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'and the look-ahead token is cleared. In state 5, the only action is to reduce by rule 3. This has one symbol on the right-hand side, so one state, 5, is popped off, and state 2 is uncovered. The goto in state 2 on place (the left side of rule 3) is state 4. Now the stack contains 0, 2, and 4. In state 4, the only action is to reduce by rule 1. There are two symbols on the right, so the top two states are popped off, uncovering state 0 again. In state 0, there is a goto on rhyme, causing the parser to enter state 1. In state 1, the input is read and the end-marker is obtained, indicated by $end in the y.output file. The action in state 1 (when the end-marker is seen) successfully ends the parse.The reader is urged to consider how the parser works when confronted with such incorrect strings as DING DONG DONG; DING DONG; DING DONG DELL DELL; and so on. A few minutes spent with this and other simple examples is repaid when problems arise in more complicated contexts.ID="05.yacc34"LBL="" HELPID=""Ambiguity and ConflictsA set of grammar rules is ambiguous if there is some input string that can be structured in two or more different ways. For example, the grammar ruleID="05.yacc35"expr : expr '-' expris a natural way of expressing the fact that one way of forming an arithmetic expression is to put two other expressions together with a minus sign between them. Unfortunately, this grammar rule does not completely specify the way that all complex inputs should be structured. For example, if the input isexpr - expr - exprthe rule allows this input to be structured as either( expr - expr ) - expror asexpr - ( expr - expr )(The first is called left-association, the second right-association.)yacc detects such ambiguities when it is attempting to build a parser. Given the inputexpr - expr - exprconsider the problem that confronts the parser. When the parser has read the second expr, the input seenexpr - exprmatches the right side of the grammar rule above. The parser could reduce the input by applying this rule. After applying the rule, the input is reduced to expr (the left side of the rule). The parser would then read the final part of the input- exprand again reduce. The effect of this is to take the left-associative interpretation.Alternatively, if the parser seesexpr - exprit could defer the immediate application of the rule and continue reading the input untilexpr - expr - expris seen. It could then apply the rule to the rightmost three symbols, reducing them to expr, which results inexpr - exprbeing left. Now the rule can be reduced once more. The effect is to take the right-associative interpretation. Thus, having readexpr - exprthe parser can do one of two legal things, a shift or a reduction. It has no way of deciding between them. This is called a shift-reduce conflict. It may also happen that the parser has a choice of two legal reductions. This is called a reduce-reduce conflict. Note that there are never any shift-shift conflicts.When there are shift-reduce or reduce-reduce conflicts, yacc still produces a parser. It does this by selecting one of the valid steps wherever it has a choice. A rule describing the choice to make in a given situation is called a disambiguating rule.ID="05.yacc36"yacc invokes two default disambiguating rules:In a shift-reduce conflict, the default is to do the shift.In a reduce-reduce conflict, the default is to reduce by the earlier grammar rule (in the yacc specification).Rule 1 implies that reductions are deferred in favor of shifts when there is a choice. Rule 2 gives the user rather crude control over the behavior of the parser in this situation, but reduce-reduce conflicts should be avoided when possible.Conflicts may arise because of mistakes in input or logic or because the grammar rules (while consistent) require a more complex parser than yacc can construct. The use of actions within rules can also cause conflicts if the action must be done before the parser can be sure which rule is being recognized. In these cases, the application of disambiguating rules is inappropriate and leads to an incorrect parser. For this reason, yacc always reports the number of shift-reduce and reduce-reduce conflicts resolved by Rule 1 and Rule 2.In general, whenever it is possible to apply disambiguating rules to produce a correct parser, it is also possible to rewrite the grammar rules so that the same inputs are read but there are no conflicts. For this reason, most previous parser generators have considered conflicts to be fatal errors. Our experience has suggested that this rewriting is somewhat unnatural and produces slower parsers. Thus, yacc will produce parsers even in the presence of conflicts.As an example of the power of disambiguating rules, considerstat : IF '(' cond ')' stat     | IF '(' cond ')' stat ELSE stat     ;which is a fragment from a programming language involving an if-then-else statement. In these rules, IF and ELSE are tokens, cond is a nonterminal symbol describing conditional (logical) expressions, and stat is a nonterminal symbol describing statements. The first rule will be called the simple if rule and the second the if-else rule.These two rules form an ambiguous construction because input of the formIF ( C1 ) IF ( C2 ) S1 ELSE S2can be structured according to these rules in two ways:IF ( C1 ){     IF ( C2 )          S1}ELSE          S2orIF ( C1 ){     IF ( C2 )          S1     ELSE          S2}where the second interpretation is the one given in most programming languages having this construct; each ELSE is associated with the last preceding un-ELSEd IF. In this example, consider the situation where the parser has seenIF ( C1 ) IF ( C2 ) S1and is looking at the ELSE. It can immediately reduce by the simple if rule to getIF ( C1 ) statand then read the remaining inputELSE S2and reduceIF ( C1 ) stat ELSE S2† †by the if-else rule. This leads to the first of the above groupings of the input.On the other hand, the ELSE may be shifted and S2 read, and then the right-hand portion ofIF ( C1 ) IF ( C2 ) S1 ELSE S2can be reduced by the if-else rule to getIF ( C1 ) statwhich can be reduced by the simple if rule. This leads to the second of the above groupings of the input, which is usually desired.Once again, the parser can do two valid thingsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'there is a shift-reduce conflict. The application of disambiguating rule 1 tells the parser to shift in this case, which leads to the desired grouping.This shift-reduce conflict arises only when there is a particular current input symbol, ELSE, and particular inputs, such asIF ( C1 ) IF ( C2 ) S1have already been seen. In general, there may be many conflicts, and each one will be associated with an input symbol and a set of previously read inputs. The previously read inputs are characterized by the state of the parser.The conflict messages of yacc are best understood by examining the verbose   (≠v) option output file. For example, the output corresponding to the above conflict state might be23: shift-reduce conflict (shift 45, reduce 18) on ELSE

state 23

† † stat : IF ( cond ) stat_ (18)
† † stat : IF ( cond ) stat_ELSE stat

† † ELSE shift 45
† † . reduce 18where the first line describes the conflict, giving the state and the input symbol. The ordinary state description gives the grammar rules active in the state and the parser actions. Recall that the underline marks the portion of the grammar rules which has been seen. Thus, in the example, in state 23 the parser has seen input corresponding toIF ( cond ) statand the two grammar rules shown are active at this time. The parser can do two possible things. If the input symbol is ELSE, it is possible to shift into state 45. State 45 will have, as part of its description, the linestat : IF ( cond ) stat ELSE_statbecause the ELSE will have been shifted in this state. In state 23, the alternative action (describing a dot, .), is to be done if the input symbol is not mentioned explicitly in the actions. In this case, if the input symbol is not ELSE, the parser reduces tostat : IF '(' cond ')' statby grammar rule 18.Once again, notice that the numbers following shift commands refer to other states, while the numbers following reduce commands refer to grammar rule numbers. In the file, the rule numbers are printed in parentheses after those rules which can be reduced. In most states, there is a reduce action possible and reduce is the default command. The user who encounters unexpected shift-reduce conflicts will probably want to look at the verbose output to decide whether the default actions are appropriate.LBL="" HELPID=""PrecedenceThere is one common situation where the rules given above for resolving conflicts are not sufficient. This is in the parsing of arithmetic expressions. Most of the commonly used constructions for arithmetic expressions can be naturally described by the notion of precedence levels for operators, together with information about left or right associativity. It turns out that ambiguous grammars with appropriate disambiguating rules can be used to create parsers that are faster and easier to write than parsers constructed from unambiguous grammars. The basic notion is to write grammar rules of the formID="05.yacc37"expr : expr OP exprandexpr : UNARY exprfor all binary and unary operators desired. This creates a very ambiguous grammar with many parsing conflicts. As disambiguating rules, the user specifies the precedence or binding strength of all the operators and the associativity of the binary operators. This information is sufficient to allow yacc to resolve the parsing conflicts in accordance with these rules and construct a parser that realizes the desired precedences and associativities.The precedences and associativities are attached to tokens in the declarations section. This is done by a series of lines beginning with a ID="05.yacc38"yacc keyword: %left,† †%right, or† †%nonassoc followed by a list of tokens. All of the tokens on the same line are assumed to have the same precedence level and associativity; the lines are listed in order of increasing precedence or binding strength. Thus:%left '+' '-'%left '*' '/'describes the precedence and associativity of the four arithmetic operators. Plus and minus are left associative and have lower precedence than star and slash, which are also left associative. The keyword %right is used to describe right associative operators, and the keyword %nonassoc is used to describe operators, like the operator .LT. in FORTRAN, that may not associate with themselves. Thus:A .LT. B .LT. Cis illegal in FORTRAN and such an operator would be described with the keyword %nonassoc† †in yacc. As an example of the behavior of these declarations, the description%right '='
%left '+' '-'
%left '*' '/'
%%
expr : expr '=' expr
† †    | expr '+' expr
† †    | expr '-' expr
† †    | expr '*' expr
† †    | expr '/' expr
† †    | NAME
† †    ;might be used to structure the inputa = b = c*d - e - f*gas followsa = ( b = ( ((c*d)-e) - (f*g) ) )in order to perform the correct precedence of operators. When this mechanism is used, unary operators must, in general, be given a precedence. Sometimes a unary operator and a binary operator have the same symbolic representation but different precedences. An example is unary and binary minus, -.Unary minus may be given the same strength as multiplication, or even higher, while binary minus has a lower strength than multiplication. The keyword ID="05.yacc39"ID="05.yacc40"%prec changes the precedence level associated with a particular grammar rule. The keyword %prec appears immediately after the body of the grammar rule, before the action or closing semicolon, and is followed by a token name or literal. It causes the precedence of the grammar rule to become that of the following token name or literal. For example, the rules%left '+' '-'
%left '*' '/'

%%

expr : expr '+' expr
† †    | expr '-' expr
† †    | expr '*' expr
† †    | expr '/' expr
† †    | '-' expr %prec '*'
† †    | NAME
† †    ;might be used to give unary minus the same precedence as multiplication.A token declared by %left, %right, and %nonassoc need not be, but may be, declared by %token as well.Precedences and associativities are used by ID="05.yacc41"yacc to resolve parsing conflicts. They give rise to the following disambiguating rules:† †Precedences and associativities are recorded for those tokens and literals that have them.† †A precedence and associativity is associated with each grammar rule. It is the precedence and associativity of the last token or literal in the body of the rule. If the %prec construction is used, it overrides this default. Some grammar rules may have no precedence and associativity associated with them.When there is a reduce-reduce conflict or there is a shift-reduce conflict and either the input symbol or the grammar rule has no precedence and associativity, then the two default disambiguating rules given at the beginning of the section are used, and the conflicts are reported.If there is a shift-reduce conflict and both the grammar rule and the input character have precedence and associativity associated with them, then the conflict is resolved in favor of the actionname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'shift or reducename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'associated with the higher precedence. If precedences are equal, then associativity is used. Left associative implies reduce; right associative implies shift; nonassociating implies error.Conflicts resolved by precedence are not counted in the number of shift-reduce and reduce-reduce conflicts reported by yacc. This means that mistakes in the specification of precedences may disguise errors in the input grammar. It is a good idea to be sparing with precedences and use them in a cookbook fashion until you gain some experience. The y.output file is very useful in deciding whether the parser is actually doing what was intended.LBL="" HELPID=""Error HandlingError handling is an extremely difficult area, and many of the problems are semantic ones. When an error is found, for example, it may be necessary to reclaim parse tree storage, delete or alter symbol table entries, and/or, typically, set switches to avoid generating any further output.ID="05.yacc42"It is seldom acceptable to stop all processing when an error is found. It is more useful to continue scanning the input to find further syntax errors. This leads to the problem of getting the parser restarted after an error. A general class of algorithms to do this involves discarding a number of tokens from the input string and attempting to adjust the parser so that input can continue.To allow the user some control over this process, ID="05.yacc43"yacc provides the token name error. This name can be used in grammar rules. In effect, it suggests places where errors are expected and recovery might take place. The parser pops its stack until it enters a state where the token error is legal. It then behaves as if the token error were the current look-ahead token and performs the action encountered. The look-ahead token is then reset to the token that caused the error. If no special error rules have been specified, the processing halts when an error is detected.In order to prevent a cascade of error messages, the parser, after detecting an error, remains in error state until three tokens have been successfully read and shifted. If an error is detected when the parser is already in error state, no message is given, and the input token is quietly deleted.As an example, a rule of the formstat : errormeans that on a syntax error the parser attempts to skip over the statement in which the error was seen. More precisely, the parser scans ahead, looking for three tokens that might legally follow a statement, and starts processing at the first of these. If the beginnings of statements are not sufficiently distinctive, it may make a false start in the middle of a statement and end up reporting a second error where there is in fact no error.Actions may be used with these special error rules. These actions might attempt to reinitialize tables, reclaim symbol table space, and so on.Error rules such as the above are very general but difficult to control. Rules such asstat : error ';'are somewhat easier. Here, when there is an error, the parser attempts to skip over the statement but does so by skipping to the next semicolon. All tokens after the error and before the next semicolon cannot be shifted and are discarded. When the semicolon is seen, this rule will be reduced and any cleanup action associated with it performed.Another form of error rule arises in interactive applications where it may be desirable to permit a line to be reentered after an error. The following exampleinput : error '\n'
† †            {
† †               (void) printf( "Reenter last line: " );
† †            }
† †            input
† †     {
† †       $$ = $4;
† †     }
† †     ;is one way to do this. There is one potential difficulty with this approach. The parser must correctly process three input tokens before it admits that it has correctly resynchronized after the error. If the reentered line contains an error in the first two tokens, the parser deletes the offending tokens and gives no message. This is clearly unacceptable. Thus, there is a mechanism to force the parser to believe that error recovery has been accomplished. The statementID="05.yacc44"yyerrok ;in an action resets the parser to its normal mode. You can thus rewrite the last example in somewhat better form asinput : error '\n'
† †           {
† †               yyerrok;
† †               (void) printf( "Reenter last line: " );
† †           }
† †           input
† †     {
† †       $$ = $4;
† †     }
† †     ;As previously mentioned, the token seen immediately after the ID="05.yacc45"error symbol is the input token at which the error was discovered. Sometimes, this is inappropriate; for example, an error recovery action might take upon itself the job of finding the correct place to resume input. In this case, the previous look-ahead token must be cleared. The statementyyclearin ;in an action will have this effect. For example, suppose the action after error were to call some sophisticated resynchronization routine (supplied by the user) that attempted to advance the input to the beginning of the next valid statement. After this routine is called, the next token returned by yylex() is presumably the first token in a legal statement. The old illegal token must be discarded and the error state reset. A rule similar tostat : error
† †    {
† †      resynch();
† †      yyerrok ;
† †      yyclearin;
† †    }
† †    ;† †could perform this.These mechanisms are admittedly crude but do allow for a simple, fairly effective recovery of the parser from many errors. Moreover, the user can get control to deal with the error actions required by other portions of the program.LBL="" HELPID=""The yacc EnvironmentWhen the user inputs a specification to ID="05.yacc46"yacc, the output is a file of C language subroutines, called y.tab.c. The function produced by ID="05.yacc47"yacc is called yyparse(); it is an integer-valued function. When it is called, it in turn repeatedly calls yylex(), the lexical analyzer supplied by the user (see IDREF="14170" TYPE="TITLE"Section , "Lexical Analysis"
), to obtain input tokens. Eventually, an error is detected, yyparse() returns the value 1, and no error recovery is possible; or the lexical analyzer returns the end-marker token and the parser accepts. In that case, yyparse() returns the value 0.The user must provide a certain amount of environment for this parser in order to obtain a working program. For example, as with every C language program, a routine called main() must be defined that eventually calls yyparse(). In addition, a routine called yyerror() is needed to print a message when a syntax error is detected.These two routines must be supplied in one form or another by the user. To ease the initial effort of using yacc, a library has been provided with default versions of main() and yyerror(). The library is accessed by an argument to the cc command or to the loader. The source codesmain(){     return (yyparse());}and# include <stdio.h>yyerror(s)        char *s;{         (void) fprintf(stderr, "%s\n", s);}show the triviality of these default programs. The argument to yyerror() is a string containing an error message, usually the string syntax error. The average application wants to do better than this. Ordinarily, the program should keep track of the input line number and print it along with the message when a syntax error is detected. The external integer variable ID="05.yacc48"yychar contains the look-ahead token number at the time the error was detected. This may be of some interest in giving better diagnostics. Since the main() routine is probably supplied by the user (to read arguments, etc.), the yacc library is useful only in small projects or in the earliest stages of larger ones.The external integer variable ID="05.yacc49"yydebug is normally set to 0. If it is set to a nonzero value, the parser will output a verbose description of its actions including a discussion of the input symbols read and what the parser actions are. It is possible to set this variable by using a debugger.LBL="" HELPID=""Hints for Preparing SpecificationsThis part contains miscellaneous hints on preparing efficient, easy to change, and clear specifications. The individual subsections are more or less independent.LBL="" HELPID=""Input StyleIt is difficult to provide rules with substantial actions and still have a readable specification file. The following are a few style hints.Use all uppercase letters for token names and all lowercase letters for nonterminal names. This is useful in debugging.Put grammar rules and actions on separate lines. It makes editing easier.Put all rules with the same left-hand side together. Put the left-hand side in only once and let all following rules begin with a vertical bar.Put a semicolon only after the last rule with a given left-hand side and put the semicolon on a separate line. This allows new rules to be easily added.Indent rule bodies by one tab stop and action bodies by two tab stops.Put complicated actions into subroutines defined in separate files.Example 1 is written following this style, as are the examples in this section (where space permits). The user must decide about these stylistic questions. The central problem, however, is to make the rules visible through the morass of action code.LBL="" HELPID=""Left RecursionThe algorithm used by the ID="05.yacc50"yacc parser encourages so called left recursive grammar rules. Rules of the formname : name rest_of_rule ;match this algorithm. These rules, such aslist : item     | list ',' item     ;andseq  : item     | seq item     ;frequently arise when writing specifications of sequences and lists. In each of these cases, the first rule will be reduced for the first item only; and the second rule will be reduced for the second and all succeeding items.With right recursive rules, such as seq : item | item seq ;, the parser is a bit bigger; and the items are seen and reduced from right to left. More seriously, an internal stack in the parser is in danger of overflowing if a very long sequence is read. Thus, the user should use left recursion wherever reasonable.It is worth considering if a sequence with zero elements has any meaning; if so, consider writing the sequence specification asseq  : /* empty */     | seq item     ;using an empty rule. Once again, the first rule would always be reduced exactly once before the first item was read, and then the second rule would be reduced once for each item read. Permitting empty sequences often leads to increased generality. However, conflicts might arise if yacc is asked to decide which empty sequence it has seen when it hasn't seen enough to know.LBL="" HELPID=""ID="34418"Lexical Tie-InsSome lexical decisions depend on context. For example, the lexical analyzer might want to delete blanks normally, but not within quoted strings, or names might be entered into a symbol table in declarations but not in expressions. One way of handling these situations is to create a global flag that is examined by the lexical analyzer and set by actions. For example,%{
† †   int dflag;
%}
† †... other declarations ...

%%

prog  :  decls stats
† †     ;
decls : /* empty */
† †     {
† †          dflag = 1;
† †     }
† †     | decls declaration
† †     ;

stats : /* empty */
† †     {
† †          dflag = 0;
† †     }
† †     | stats statement
† †     ;
† †   ... other rules ...specifies a program that consists of zero or more declarations followed by zero or more statements. The flag dflag is now 0 when reading statements and 1 when reading declarations, except for the first token in the first statement. This token must be seen by the parser before it can tell that the declaration section has ended and the statements have begun. In many cases, this single token exception does not affect the lexical scan.This kind of back-door approach can be elaborated to a noxious degree. Nevertheless, it presents a way of doing some things that are difficult, if not impossible, to do otherwise.LBL="" HELPID=""Reserved WordsSome programming languages permit you to use words like ID="05.yacc51"if, which are normally reserved as label or variable names, provided that such use does not conflict with the legal use of these names in the programming language. This is extremely hard to do in the framework of yacc. It is difficult to pass information to the lexical analyzer telling it that one instance of if is a keyword while another instance is a variable. The user can make a stab at it using the mechanism described in IDREF="34418" TYPE="TITLE"Section , "Lexical Tie-Ins,"
 but it is difficult.A number of ways of making this easier are under advisement. Until then, it is better that the keywords be reservedname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'that is, forbidden for use as variable names. There are powerful stylistic reasons for preferring this.LBL="" HELPID=""ID="72113"Advanced yacc FeaturesLBL="" HELPID=""Simulating error and accept in ActionsThe parsing actions of ID="05.yacc52"error and accept can be simulated in an action by use of macros YYACCEPT and YYERROR. The YYACCEPT macro causes yyparse() to return the value 0, while YYERROR causes the parser to behave as if the current input symbol had been a syntax error: yyerror() is called, and error recovery takes place. These mechanisms can be used to simulate parsers with multiple end-markers or context-sensitive syntax checking.LBL="" HELPID=""Accessing Values in Enclosing RulesAn action may refer to values returned by actions to the left of the current rule. The mechanism is simply the same as with ordinary actions, a dollar sign followed by a digit.sent : adj noun verb adj noun
† †    {
† †      look at the sentence ...
† †    }
† †    ;
adj  : THE
† †    {
† †           $$ = THE;
† †    }
† †    | YOUNG
† †    {
† †           $$ = YOUNG;
† †    }
† †    ...
† †    ;
noun : DOG
† †    {
† †           $$ = DOG;
† †    }
† †    | CRONE
† †    {
† †      if( $0 == YOUNG )
† †      {

† †          (void) printf( "what?\n" );
† †      }
† †      $$ = CRONE;
† †    }
† †    ;
† †    ...In this case, the digit may be 0 or negative. In the action following the word CRONE, a check is made that the preceding token shifted was not YOUNG. Obviously, this is only possible when a great deal is known about what might precede the symbol noun in the input. There is also a distinctly unstructured flavor about this. Nevertheless, at times this mechanism prevents a great deal of trouble especially when a few combinations are to be excluded from an otherwise regular structure.LBL="" HELPID=""Support for Arbitrary Value TypesBy default, the values returned by actions and the lexical analyzer are integers. ID="05.yacc53"yacc can also support values of other types including structures. In addition, yacc keeps track of the types and inserts appropriate union member names so that the resulting parser is strictly type-checked. The yacc value stack is declared to be a union of the various types of values desired. The user declares the union and associates union member names with each token and nonterminal symbol having a value. When the value is referenced through a $$ or $n construction, yacc will automatically insert the appropriate union name so that no unwanted conversions take place. In addition, type-checking commands such as lint are far more silent.There are three mechanisms used to provide for this typing. First, there is a way of defining the union. This must be done by the user since other subroutines, notably the lexical analyzer, must know about the union member names. Second, there is a way of associating a union member name with tokens and nonterminals. Finally, there is a mechanism for describing the type of those few values where yacc cannot easily determine the type.To declare the union, the user includes%union{    body of union ...}in the declaration section. This declares the yacc value stack and the external variables yylval and yyval to have type equal to this union. If yacc was invoked with the ≠d option, the union declaration is copied onto the y.tab.h file as YYSTYPE.Once YYSTYPE is defined, the union member names must be associated with the various terminal and nonterminal names. The construction<name>is used to indicate a union member name. If this follows one of the keywords and the union member name is associated with the tokens listed. Thus, saying%left <optype> '+' '-'causes any reference to values returned by these two tokens to be tagged with the union member optyp. Another keyword, ID="05.yacc54"%type, is used to associate union member names with nonterminals. Thus, one might say%type <nodetype> expr statto associate the union member nodetype with the nonterminal symbols expr and stat.There remain a couple of cases where these mechanisms are insufficient. If there is an action within a rule, the value returned by this action has no default type. Similarly, reference to left context values (such as $0) leaves yacc with no easy way of knowing the type. In this case, a type can be imposed on the reference by inserting a union member name between < and > immediately after the first $. The examplerule : aaa
† †            {
† †              $<intval>$ = 3;
† †            }
† †            bbb
† †    {
† †      fun( $<intval>2, $<other>0 );
† †    }
† †    ;shows this usage. This syntax has little to recommend it, but the situation arises rarely.A sample specification is given in Example 2. The facilities in this subsection are not triggered until they are used. In particular, the use of %type will turn on these mechanisms. When they are used, there is a fairly strict level of checking. For example, use of $n or $$ to refer to something with no defined type is diagnosed. If these facilities are not triggered, the yacc value stack is used to hold ints.LBL="" HELPID=""yacc Input SyntaxThis section has a description of the ID="05.yacc55"yacc input syntax as a yacc specification. Context dependencies, etc. are not considered. Ironically, although yacc accepts an LALR(1) grammar, the yacc input specification language is most naturally specified as an LR(2) grammar; the sticky part comes when an identifier is seen in a rule immediately following an action. If this identifier is followed by a colon, it is the start of the next rule; otherwise, it is a continuation of the current rule, which just happens to have an action embedded in it. As implemented, the lexical analyzer looks ahead after seeing an identifier and decides whether the next token (skipping blanks, newlines, comments, and such) is a colon. If so, it returns the token C_IDENTIFIER. Otherwise, it returns IDENTIFIER. Literals (quoted strings) are also returned as IDENTIFIERs but never as part of C_IDENTIFIERs.† †   /* grammar for the input to yacc */

† †   /* basic entries */
%token IDENTIFIER /* includes identifiers and literals */
%token  C_IDENTIFIER /* identifier (but not literal) followed by a : */
%token NUMBER /* [0-9]+ */

† †   /* reserved words: %type=>TYPE %left=>LEFT,etc. */

%token LEFT RIGHT NONASSOC TOKEN PREC TYPE START UNION

%token MARK /* the %% mark */
%token LCURL /* the %{ mark */
%token RCURL /* the %} mark */

† †   /* ASCII character literals stand for themselves */

%token spec

%%

spec  : defs MARK rules tail
† †     ;
tail  : MARK
† †     {
† †           In this action, eat up the rest of the file
† †     }
† †     | /* empty: the second MARK is optional */
† †     ;

defs  : /* empty */
† †     | defs def
† †     ;
def   : START IDENTIFIER
† †     | UNION
† †     {
† †            Copy union definition to output
† †     }
† †     | LCURL
† †     {
† †               Copy C code to output file
† †     }
† †       RCURL
† †     | rword tag nlist
† †     ;

rword : TOKEN
† †     | LEFT
† †     | RIGHT
† †     | NONASSOC
† †     | TYPE
† †     ;

tag   :  /* empty: union tag is optional */
† †     | '<' IDENTIFIER '>'
† †     ;

nlist : nmno
† †     | nlist nmno
† †     | nlist ',' nmno
† †     ;

nmno   :  IDENTIFIER /* Note: literal illegal with % type */
† †      | IDENTIFIER NUMBER /* Note: illegal with % type */
† †     ;

† † /* rule section */

rules : C_IDENTIFIER rbody prec
† †     | rules rule
† †     ;
rule  : C_IDENTIFIER rbody prec
† †     | '|' rbody prec
† †     ;

rbody : /* empty */
† †     | rbody IDENTIFIER
† †     | rbody act
† †     ;

act   : '{'
† †       {
† †            Copy action translate $$ etc.
† †       }
† †       '}'
† †     ;

prec  : /* empty */
† †     | PREC IDENTIFIER
† †     | PREC IDENTIFIER act
† †     | prec ';'
† †     ;LBL="" HELPID=""ExamplesLBL="" HELPID=""A Simple ExampleThis example gives the complete yacc specification for a small desk calculator; the calculator has 26 registers labeled a through z and accepts arithmetic expressions made up of the operators +, -, *, /, % (mod operator), & (bitwise and), | (bitwise or), and assignments.If an expression at the top level is an assignment, only the assignment is done; otherwise, the expression is printed. As in the C language, an integer that begins with 0 (zero) is assumed to be octal; otherwise, it is assumed to be decimal.As an example of a yacc specification, the desk calculator does a reasonable job of showing how precedence and ambiguities are used and demonstrates simple recovery. The major oversimplifications are that the lexical analyzer is much simpler than for most applications, and the output is produced immediately line by line. Note the way that decimal and octal integers are read in by grammar rules. This job is probably better done by the lexical analyzer.%{
# include <stdio.h>
# include <ctype.h>

int regs[26];
int base;

%}

%start list

%token DIGIT LETTER

%left '|'
%left '&'
%left '+' '-'
%left '*' '/' '%'
%left UMINUS /* supplies precedence for unary minus */

%% /* beginning of rules section */

list   : /* empty */
† †      | list stat '\n'
† †      | list error '\n'
† †      {
† †        yyerrok;
† †      }
† †      ;

stat   : expr
† †      {
† †        (void) printf( "%d\n", $1 );
† †      }
† †      | LETTER '=' expr
† †      {
† †        regs[$1] = $3;
† †      }
† †      ;

expr   : '(' expr ')'
† †      {
† †          $$ = $2;
† †      }
† †      | expr '+' expr
† †      {
† †          $$ = $1 + $3;
† †      }
† †      | expr '-' expr
† †      {
† †          $$ = $1 - $3;
† †      {
† †      | expr '*' expr
† †      {
† †          $$ = $1 * $3;
† †      }
† †      | expr '/' expr
† †      {
† †           $$ = $1 / $3;
† †      }
† †      | expr '%' expr
† †      {
† †           $$ = $1 % $3;
† †      }
† †      | expr '&' expr
† †      {
† †          $$ = $1 & $3;
† †      }
† †      | expr '|' expr
† †      {
† †           $$ = $1 | $3;
† †      }
† †      | '-' expr %prec UMINUS
† †      {
† †           $$ = -$2;
† †      }
† †      | LETTER
† †      {
† †           $$ = reg[$1];
† †      }
† †      | number ;
number : DIGIT
† †      {
† †            $$ = $1; base = ($1==0) ? 8 ; 10;
† †      }
† †      | number DIGIT
† †      {
† †            $$ = base * $1 + $2;
† †      }
† †      ;

%%                /* beginning of subroutines section */

int yylex( )  /* lexical analysis routine */
{             /* returns LETTER for lowercase letter, */
† †             /* yylval = 0 through 25; returns DIGIT */
† †             /* for digit, yylval = 0 through 9; all */
† †             /* other characters are returned immediately */
† †      int c;
† †               /*skip blanks*/
† †      while ((c = getchar()) == ' ')
† †             ;
† †               /* c is now nonblank */
† †      if (islower(c))
† †      {
† †                 yylval = c - 'a';
† †                 return (LETTER);
† †      }
† †      if (isdigit(c))
† †      {
† †                 yylval = c - '0';
† †                 return (DIGIT);
† †      }
† †      return (c);
}
LBL="" HELPID=""An Advanced ExampleThis section gives an example of a grammar using some of the advanced features. The desk calculator from Example 1 is modified to provide a desk calculator that does floating point interval arithmetic. The calculator understands floating point constants; the arithmetic operations +, - *, /; unary -; and a through z. Moreover, it also understands intervals written(X,Y)where X is less than or equal to Y. There are 26 interval-valued variables A through Z that may also be used. The usage is similar to that in Example 1; assignments return no value and print nothing while expressions print the (floating or interval) value.This example explores a number of interesting features of yacc and C. Intervals are represented by a structure consisting of the left and right endpoint values stored as doubles. This structure is given a type name, INTERVAL, by using typedef. yacc's value stack can also contain floating point scalars and integers (used to index into the arrays holding the variable values). Notice that the entire strategy depends strongly on being able to assign structures and unions in C. In fact, many of the actions call functions that return structures as well.It is also worth noting the use of YYERROR to handle error conditions (division by an interval containing 0 and an interval presented in the wrong order). The error recovery mechanism of yacc is used to throw away the rest of the offending line.In addition to the mixing of types on the value stack, this grammar also demonstrates an interesting use of syntax to keep track of the type (for example, scalar or interval) of intermediate expressions. Note that a scalar can be automatically promoted to an interval if the context demands an interval value. This causes a large number of conflicts when the grammar is run through yacc: 18 shift-reduce and 26 reduce-reduce. The problem can be seen by looking at the two input lines.2.5 + (3.5 - 4.)and2.5 + (3.5, 4)Notice that the 2.5 is to be used in an interval-value expression in the second example, but this fact is not known until the comma is read. By this time, 2.5 is finished, and the parser cannot go back and change its mind. More generally, it might be necessary to look ahead an arbitrary number of tokens to decide whether to convert a scalar to an interval. This problem is evaded by having two rules for each binary interval valued operatorname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'one when the left operand is a scalar and one when the left operand is an interval. In the second case, the right operand must be an interval, so the conversion will be applied automatically. Despite this evasion, there are still many cases where the conversion may be applied or not, leading to the above conflicts. They are resolved by listing the rules that yield scalars first in the specification file; in this way, the conflict will be resolved in the direction of keeping scalar-valued expressions scalar-valued until they are forced to become intervals.This way of handling multiple types is very instructive. If there were many kinds of expression types instead of just two, the number of rules needed would increase dramatically and the conflicts would increase even more dramatically. Thus, while this example is instructive, it is better practice in a more normal programming language environment to keep the type information as part of the value and not as part of the grammar.Finally, a word about the lexical analysis. The only unusual feature is the treatment of floating point constants. The C language library routine atof() is used to do the actual conversion from a character string to a double-precision value. If the lexical analyzer detects an error, it responds by returning a token that is illegal in the grammar, provoking a syntax error in the parser and thence error recovery.%{

#include <stdio.h>
#include <ctype.h>

typedef struct interval
{
† †    double lo, hi;
} INTERVAL;

INTERVAL vmul(double, double, INTERVAL);
INTERVAL vdiv(double, double, INTERVAL);

double dreg[26];
INTERVAL vreg[26];

%}

%start line

%union
{
† † int ival;
† † double dval;
† † INTERVAL vval;
}

%token <ival> DREG VREG  /* indices into dreg, vreg arrays */
%token <dval> CONST      /* floating point constant */
%type <dval> dexp        /* expression */
%type <vval> vexp        /* interval expression */

† † /* precedence information about the operators */

%left '+' '-'
%left '*' '/'

%left UMINUS    /* precedence for unary minus */

%%              /* beginning of rules section */
lines  : /* empty */
† †      | lines line
† †      ;
line   : dexp '\n'
† †      {
† †               (void) printf("%15.8f\n",$1);
† †      }
† †      | vexp '\n'
† †      {
† †               (void) printf("(%15.8f, %15.8f)\n", $1.1o, $1.hi);

† †      }
† †      | DREG '=' dexp '\n'
† †      {
† †              dreg[$1] = $3;
† †      }
† †      | VREG '=' vexp '\n'
† †      {
† †              vreg[$1] = $3;
† †      }
† †      | error '\n'
† †      {
† †                yyerrok; }
† †      ;

dexp   : CONST
† †      | DREG { $$ = dreg[$1];
† †      }
† †      | dexp '+' dexp
† †      {
† †                $$ = $1 + $3;
† †      }
† †      | dexp '-' dexp
† †      {
† †                $$ = $1 - $3;
† †      }
† †      | dexp '*' dexp
† †      {
† †                $$ = $1 * $3;
† †      }
† †      | dexp '/' dexp
† †      {
† †                $$ = $1 / $3;
† †      }
† †      | '-' dexp %prec UMINUS
† †      {
† †                $$ = -$2;
† †      }
† †      | '(' dexp')'
† †      {
† †                $$ = $2;
† †      }
† †      ;

vexp   : dexp
† †      {
† †                $$.hi = $$.lo = $1;
† †      }
† †      | '(' dexp ',' dexp ')'
† †      {
† †                $$.lo = $2;
† †                $$.hi = $4;
† †                if( $$.lo > $$.hi )
† †         {
† †                    (void) printf("interval out of order \n");
† †                    YYERROR;
† †          }
† †      }
† †      | VREG
† †      {
† †                $$ = vreg[$1];
† †      }
† †      | vexp '+' vexp
† †      {
† †                $$.hi = $1.hi + $3.hi;
† †                $$.lo = $1.lo + $3.lo;
† †      }
† †      | dexp '+' vexp
† †      {
† †                $$.hi = $1 + $3.hi;
† †                $$.lo = $1 + $3.lo;
† †      }
† †      | vexp '-' vexp
† †      {
† †                $$.hi = $1.hi - $3.lo;
† †                $$.lo = $1.lo - $3.hi;
† †           }
† †           | dvep '-' vdep
† †           {
† †                $$.hi = $1 - $3.lo;
† †                $$.lo = $1 - $3.hi;
† †           }
† †           | vexp '*' vexp
† †           {
† †                $$ = vmul( $1.lo,$.hi,$3 );
† †           }
† †           | dexp '*' vexp
† †           {
† †                $$ = vmul( $1, $1, $3 );
† †           }
† †           | vexp '/' vexp
† †           {
† †                if( dcheck( $3 ) ) YYERROR;
† †                $$ = vdiv( $1.lo, $1.hi, $3 );
† †           }
† †           | dexp '/' vexp
† †           {
† †                 f( dcheck( $3 ) ) YYERROR;
† †                $$ = vdiv( $1.lo, $1.hi, $3 );
† †           }
† †           | '-' vexp %prec UMINUS
† †           {
† †                $$.hi = -$2.lo;$$.lo = -$2.hi;
† †           }
† †           | '(' vexp ')'
† †           {
† †                $$ = $2;
† †           }
† †           ;

%%     /* beginning of subroutines section */

# define BSZ 50 /* buffer size for floating point number */

† †           /* lexical analysis */

int yylex(void)
{
† †   register int c;

† †      /* skip over blanks */
† †   while ((c = getchar()) == ' ')
† †        ;
† †   if (isupper(c))
† †   {
† †      yylval.ival = c - 'A';
† †      return (VREG);
† †   }
† †   if (islower(c))
† †   {
† †      yylval.ival = c - 'a';
† †      return( DREG );
† †   }

† †      /* gobble up digits. points, exponents */

† †   if (isdigit(c) || c == '.')
† †   {
† †      char buf[BSZ+1], *cp = buf;
† †      int dot = 0, exp = 0;

† †      for(; (cp - buf) < BSZ ; ++cp, c = getchar())
† †      {
† †         *cp = c;
† †         if (isdigit(c))
† †            continue;
† †         if (c == '.')
† †         {
† †            if (dot++ || exp)
† †               return ('.'); /* will cause syntax error */
† †            continue;
† †         }
† †         if( c == 'e')
† †         {
† †            if (exp++)
† †               return ('e'); /* will cause syntax error */
† †            continue;
† †         }
† †                  /* end of number */
† †         break;
† †      }
† †      *cp = '\0';
† †      if (cp - buf >= BSZ)
† †         (void) printf("constant too long - truncated\n");
† †      else
† †         ungetc(c, stdin); /* push back last char read */
† †      yylval.dval = atof(buf);
† †      return (CONST);
† †   }
† †   return (c);
}

INTERVAL
hilo(double a, double b, double c, double d)
{
† † /* returns the smallest interval containing a, b, c, and d */
† † /* used by *,/ routine */
† †  INTERVAL v;
† †  if (a > b)
† †  {
† †     v.hi = a;
† †     v.lo = b;
† †  }
† †  else
† †  {
† †     v.hi = b;
† †     v.lo = a;
† †  }
† †  if (c > d)
† †  {
† †     if (c > v.hi)
† †        v.hi = c;
† †     if (d < v.lo)
† †           v.lo = d;
† †  }
† †  else
† †  {
† †     if (d > v.hi)
† †        v.hi = d;
† †     if (c<v.lo)
† †        v.lo = c;
† †  }
† †  return (v);
}

INTERVAL
vmul(double a, double b, INTERVAL v)
{
† †  return (hilo(a * v.hi, a * v,lo, b * v.hi, b * v.lo));
}
dcheck(INTERVAL v)
{
† †  if (v.hi >= 0. && v.lo <= 0.)
† †  {
† †     (void) printf("divisor interval contains 0.\n");
† †     return (1);
† †  }
† †  return (0);
}

INTERVAL
vdiv(double a, double b, INTERVAL v)
{
† †  return (hilo(a / v.hi, a / v,lo, b / v.hi, b / v.lo));
}

ID="05.yacc56"LBL="6"ID="48026"Inter-Process CommunicationThe term "ID="06.ipc1"Inter-Process Communication" (IPC) describes any method of sending data from one running process to another. IPC is commonly used to allow processes to cooperatename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for instance, to let two subprograms use the same data areas in memory without interfering with each othername='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'or to make data acquired by one process available to others. There are a wide variety of IPC mechanisms in common use, each intended for a different purpose.LBL="" HELPID=""Types of Inter-Process Communication AvailableIRIX supports several types of IPC. Standard AT&T System V Release 4 IPC is available for use in making code portable. However, its implementation is fundamentally different from (and slower than) that of the IRIX-specific IPC also provided with IRIX. Finally, BSD-style socket-based IPC is supported both for compatibility and in order to allow IPC across a network, between processes running on different machines.ID="06.ipc2"Do not mix the various types of IPC in a given program. Use System V IPCname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'based on a mechanism called keysname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for code that must comply with the MIPS ABI, code that needs to be portable, or code that you're porting from another System V operating system. Use arena-based IRIX IPC for applications which require speed, ease of implementation, or multiprocessing ability. Socket-based IPC is only necessary for code being ported from or to a BSD system, and for network IPC.ID="06.ipc3"This chapter describes the available types of System V and IRIX IPC, and provides examples of each. Since there are many ways to accomplish any given task or requirement, keep in mind that the example programs were written for clarity and not for program efficiency.LBL="" HELPID=""System V IPCLBL="" HELPID=""System V IPC OverviewSystem V IPC comprises three inter-process communication mechanisms:ID="06.ipc4"Messages allow processes to send and receive buffers full of data.Semaphores allow processes to turn on and off a set of flags.Shared memory gives multiple processes access to the same data area in memory.LBL="" HELPID=""ID="34344"System V MessagesThe message mechanism allows processes to exchange data stored in buffers. This data is transmitted between processes in discrete units called messages. Processes using this type of IPC can perform two operations: sending messages and receiving messages.ID="06.ipc5"Before a process can send or receive messages, the process must request that the operating system generate a new ID="06.ipc6"message queue (the mechanism used to control and keep track of messages), and an associated data structure. A process makes this request by using the ID="06.ipc7"msgget() system call. The requesting process becomes the owner and creator of the resulting message queue, and specifies the initial operation permissions for all processes that might use that queue (including itself). Subsequently, the owning process can relinquish ownership or change the operation permissions using the ID="06.ipc8"msgctl() system call. However, the creator remains the creator as long as the queue exists. Other processes with permission can use msgctl() to perform various other control functions, as described in IDREF="85153" TYPE="TITLE""Controlling Message Queues: msgctl()."A process which is attempting to send a message can suspend execution temporarily in order to wait until the process which is to receive the message is ready; similarly, a receiving process can suspend execution until the sending process is ready. Message operations which suspend execution in this fashion are called "blocking message operations." A process which specifies that its execution is not to be suspendedname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'that is, a process which does not wait for communication if such is not immediately availablename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'is performing a "nonblocking message operation."ID="06.ipc9"ID="06.ipc10"A blocking message operation can be told to suspend a calling process until one of three conditions occurs:The operation is successful.The operation receives a signal.The message queue is removed.To request a message operation, the calling process passes arguments to a system call, and the system call attempts to perform its function. If the system call is successful, it returns its results. Otherwise, it returns a known error code (-1), and an external error variable, errno, is set accordingly.LBL="" HELPID=""Message QueuesBefore a message can be sent or received, a uniquely identified message queue and data structure must be created. The unique identifier created is called the message queue identifier (ID="06.ipc11"ID="06.ipc12"msqid); it is used to reference the associated message queue and data structure.The message queue is used to store header information about each message that is being sent or received. This information includes the following for each message:pointer to the next message on queuemessage typemessage text sizemessage text addressEach message queue has a data structure associated with it. This data structure contains the following information for its message queue:ID="06.ipc13"operation permissions datapointer to first message on the queuepointer to last message on the queuecurrent number of bytes on the queuenumber of messages on the queuemaximum number of bytes allowed on the queueprocess identification (PID) of last message senderPID of last message receiverlast message send timelast message receive timelast change timeand some padding space reserved for future expansion.The definition for the message queue structure is: struct msg
{
† †   struct msg   *msg_next; /* ptr to next message on queue */
† †   long         msg_type;  /* message type */
† †   short        msg_ts;    /* message text size */
† †   caddr_t      msg_spot;  /* message text map address */
};It is located in the /usr/include/sys/msg.h header file. The definition for the associated data structure, msqid_ds, is also located in that header file.The permissions structure that's part of the msqid_ds structure is based on another structure called ipc_perm, which is also used as a template for permissions for other forms of IPC. The ipc_perm data structure format can be found in the /usr/include/sys/ipc.h header file.ID="06.ipc14"LBL="" HELPID=""Message Operations OverviewThe ID="06.ipc15"msgget() system call receives an argument msgflg which can be set to indicate various flags. When only the IPC_CREAT flag is set in ID="06.ipc16"msgflg, msgget() performs one of two tasks:ID="06.ipc17"It gets a new msqid and creates an associated message queue and data structure for it; orIt returns an existing msqid that already has an associated message queue and data structure.The task performed is determined by the value of the ID="06.ipc18"key argument passed to the msgget() system call. For the first task, if the key is not already in use for an existing msqid, a new msqid is returned with an associated message queue and data structure created for the key, unless some system-tunable parameter (such as the maximum allowable number of message queues) would be exceeded.Instead of requesting a specific key number, you may indicate a key of value zero which is known as the private key (the constant IPC_PRIVATE is defined to be zero). When you specify IPC_PRIVATE for the key value, a new msqid is always returned with an associated message queue and data structure created for it unless a system-tunable parameter would be exceeded. When the ID="06.ipc19"ipcs command is performed, for security reasons the KEY field for the msqid is all zeros.For the second task, if a msqid exists for the key specified, the value of the existing msqid is returned. If you do not desire to have an existing ID="06.ipc20"msqid returned, a control command (IPC_EXCL) can be specified in the msgflg argument passed to the system call. The details of using this system call are discussed in the IDREF="98090" TYPE="TITLE""Getting Message Queues with msgget()"
 section of this chapter.When performing the first task, the process which calls msgget() becomes the owner/creator, and the associated data structure is initialized accordingly. Remember, ownership can be changed but the creating process always remains the creator; see IDREF="85153" TYPE="TITLE""Controlling Message Queues: msgctl()."
 The creator of the message queue also determines the initial operation permissions for it.Once a uniquely identified message queue and data structure are created, message operations and message control can be used.The available message operations are sending and receiving. System calls are provided for these operations: msgsnd() and msgrcv(), respectively. Refer to IDREF="97534" TYPE="TITLE""Operations for Messages: msgsnd() and msgrcv(),"
 for details of these system calls.Message control is done by using the ID="06.ipc21"msgctl() system call. It permits you to control the message facility in the following ways:to determine the associated data structure status for a message queue identifier (msqid)to change operation permissions for a message queueto change the size (msg_qbytes) of the message queue for a particular msqidto remove a particular msqid from the UNIX operating system along with its associated message queue and data structureRefer to IDREF="85153" TYPE="TITLE""Controlling Message Queues: msgctl()"
 for details of the msgctl() system call.LBL="" HELPID=""ID="98090"Getting Message Queues with msgget()This section gives a detailed description of using the ID="06.ipc22"msgget() system call along with an example program illustrating its use.The synopsis in the msgget(2) manual page looks like this:#include   <sys/types.h> 
#include   <sys/ipc.h>
#include   <sys/msg.h>

int msgget (key, msgflg)
key_t key;
int msgflg;All of the listed include-files are located in the /usr/include/sys directory of the UNIX operating system.The type of the key parameter, key_t, is defined by a typedef in the types.h header file to be equivalent to an integer.Upon successful completion, ID="06.ipc23"msgget() returns a message queue identifier. A new msqid with an associated message queue and data structure is provided if eitherkey is equal to IPC_PRIVATE, orkey is a unique hexadecimal integer, and IPC_CREAT is set in msgflg.The value passed to the msgflg argument must be an integer type octal value and it will specify access permissions, execution modes, and control fields (commands). Access permissions determine the read/write attributes, while execution modes determine the user/group/other attributes of the msgflg argument. The permissions and modes are collectively referred to as "operation permissions." ID="06.ipc24"IDREF="66255" TYPE="TABLE"Table 6-1
 shows the numeric values (expressed in octal notation) for the valid operation permissions codes.COLUMNS="2"LBL="6-1"Table 6-1 ID="66255"Operation Permissions CodesLEFT="0" WIDTH="171"Operation PermissionsLEFT="180" WIDTH="356"Octal ValueLEFT="0" WIDTH="171"Read by Owner (MSG_R)LEFT="180" WIDTH="356"00400LEFT="0" WIDTH="171"Write by Owner (MSG_W)LEFT="180" WIDTH="356"00200LEFT="0" WIDTH="171"Read by GroupLEFT="180" WIDTH="356"00040LEFT="0" WIDTH="171"Write by GroupLEFT="180" WIDTH="356"00020LEFT="0" WIDTH="171"Read by OthersLEFT="180" WIDTH="356"00004LEFT="0" WIDTH="171"Write by OthersLEFT="180" WIDTH="356"00002A specific octal value is derived by adding the octal values for the operation permissions desired. For instance, if you want a message queue to be readable by its owner and both readable and writable by others, use the code value 00406 (00400 plus 00004 plus 00002). The constants MSG_R and MSG_W, defined in the ID="06.ipc25"msg.h header file, can be used instead of 00400 and 00200, respectively.Control commands are constants defined in the ipc.h header file. IDREF="24795" TYPE="TABLE"See Table 6-2
 contains the names of the constants which apply to the msgget() system call along with their values.COLUMNS="2"LBL="6-2"Table 6-2 ID="24795"Control Commands (Flags)LEFT="0" WIDTH="171"Control CommandLEFT="180" WIDTH="356"ValueLEFT="0" WIDTH="171"IPC_CREATLEFT="180" WIDTH="356"0001000LEFT="0" WIDTH="171"IPC_EXCLLEFT="180" WIDTH="356"0002000The value for ID="06.ipc26"msgflg is therefore a combination of operation permissions and control commands. To accomplish this combination, bitwise OR (|) the flags with the operation permissions; the bit positions and values for the control commands in relation to those of the operation permissions make this possible.Two examples:msqid = msgget (key, (IPC_CREAT | MSG_R));
msqid = msgget (key, (IPC_CREAT | IPC_EXCL | 0400));The msgget() system call will attempt to return a new msqid if either of the following conditions is true:key is equal to IPC_PRIVATE, orkey does not already have a msqid associated with it, and IPC_CREAT is set in msgflg.To satisfy the first condition, simply pass IPC_PRIVATE as the key argument when calling msgget():msqid = msgget (IPC_PRIVATE, msgflg);The second condition is satisfied if the value for key is not already associated with a msqid and a bitwise AND of msgflg and IPC_CREAT gives "true" (1). This means that the given key is not currently being used to refer to any message queue on the computer the program is running on, and that the IPC_CREAT flag is set in msgflg.The system-tunable parameter MSGMNI determines the maximum number of unique message queues (ID="06.ipc27"msqids) in the UNIX operating system. Attempting to exceed MSGMNI always causes a failure.† †IPC_EXCL is another control flag used in conjunction with IPC_CREAT to exclusively have the system call fail if, and only if, a msqid exists for the specified key provided. This is necessary to prevent the process from thinking that it has received a new (unique) msqid when it has not. In other words, when both IPC_CREAT and IPC_EXCL are specified, a new msqid is returned if the system call is successful.Refer to the msgget(2) manual page for specific information about the associated data structures. The specific failure conditions, with error names, are listed there as well.LBL="" HELPID=""Example ProgramThe example program in this section (
ID="06.ipc28"IDREF="51581" TYPE="TEXT"Example 6-1
) is a menu-driven program which allows all possible combinations of using the msgget() system call to be exercised.From studying this program, you can observe the method of passing arguments and receiving return values. The user-written program requirements are pointed out.This program begins (lines 4-8) by including the required header files as specified by the msgget(2) manual page. Note that the ID="06.ipc29"errno.h header file is included instead of declaring errno as an external variable; either method will work.Variable names have been chosen to be as close as possible to those in the synopsis for the system call. Their declarations are self-explanatory. This choice of names make the program more readable, and it is perfectly legal since the variables are local to this program. The variables in this program and their purposes are as follows:key: used to pass the value for the desired keyopperm: used to store the desired operation permissionsflags: used to store the desired control commandsopperm_flags: used to store the combination from the logical ORing of the opperm and flags variables; it is then used in the system call to pass the msgflg argumentmsqid: used for returning the message queue identification number for a successful system call or the error code (-1) for an unsuccessful one.The program begins by prompting for a hexadecimal key, an octal operation permissions code, and finally for the control command combinations (flags) which are selected from a menu (lines 15-32). All possible combinations are allowed even though they might not be viable. This allows observing the errors for illegal combinations.Next, the menu selection for the flags is combined with the operation permissions, and the result is stored in the opperm_flags variable (lines 36-51).The system call is made next, and the result is stored in the msqid variable (line 53).Since the msqid variable now contains a valid message queue identifier or the error code (-1), it is tested to see if an error occurred (line 55). If msqid equals -1, a message indicates that an error resulted, and the external errno variable is displayed (lines 57, 58).If no error occurred, the returned message queue identifier is displayed (line 62).The example program for the msgget() system call follows in 
IDREF="51581" TYPE="TEXT"Example 6-1
.LBL="6-1"Example 6-1 ID="51581"msgget() System Call Example1  /*This is a program to illustrate the capabilities of
2   *the msgget() (message-get) system call.
3   */

4  #include <stdio.h>
5  #include <sys/types.h>
6  #include <sys/ipc.h>
7  #include <sys/msg.h>
8  #include <errno.h>

9  /*Start of main C program*/
10 main()
11 {
12     key_t key;
13     int opperm, flags; 
14     int msqid, opperm_flags; 
15     /*Enter the desired key*/ 
16     printf("Enter the desired key in hex = "); 
17     scanf("%x", &key);
18     /*Enter the desired octal operation
19       permissions.*/
20     printf("\nEnter the operation ");
21     printf("permissions in octal = "); 
22     scanf("%o", &opperm);
23     /*Set the desired flags.*/
24     printf("\nEnter corresponding number to\n"); 
25     printf("set the desired flags:\n");
26     printf("No flags = 0\n");
27     printf("IPC_CREAT = 1\n");
28     printf("IPC_EXCL = 2\n"); 
29     printf("IPC_CREAT and IPC_EXCL = 3\n");
30     printf(" Flags = ");

31     /*Get the flag(s) to be set.*/ 
32     scanf("%d", &flags);

33     /*Check the values.*/
34     printf ("\nkey =0x%x, opperm = 0%o, flags = 0%o\n",
35         key, opperm, flags);

36     /*Incorporate the control fields (flags) with
37       the operation permissions*/
38     switch (flags)
39     {
40     case 0: /*No flags are to be set.*/
41         opperm_flags = (opperm | 0);
42         break; 
43     case 1: /*Set the IPC_CREAT flag.*/ 
44         opperm_flags = (opperm | IPC_CREAT);
45         break;
46     case 2: /*Set the IPC_EXCL flag.*/
47         opperm_flags = (opperm | IPC_EXCL); 
48         break; 
49     case 3: /*Set the IPC_CREAT and IPC_EXCL flags.*/
50         opperm_flags = (opperm | IPC_CREAT | IPC_EXCL);
51     }
52     /*Call the msgget() system call.*/
53     msqid = msgget (key, opperm_flags);

54     /*Perform the following if the call failed.*/
55     if(msqid == -1)
56     {
57         printf ("\nThe msgget system call failed!\n");
58         printf ("The error number was %d.\n", errno);
59     }
60     /*Return the msqid upon successful completion.*/
61     else 
62         printf ("\nThe msqid is %d.\n", msqid);

63     exit(0);
64 }LBL="" HELPID=""ID="85153"ID="16573"Controlling Message Queues: msgctl()This section gives a detailed description of using the ID="06.ipc30"msgctl() system call along with an example program which allows all of its capabilities to be exercised.The synopsis given in the msgctl(2) manual page is as follows: #include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

int msgctl (msqid, cmd, buf)
int msqid, cmd;
struct msqid_ds *buf;The msgctl() system call requires three arguments to be passed to it, and it returns an integer value.Upon successful completion, it returns zero; when unsuccessful, it returns a -1.The msqid variable must be a valid, non-negative, integer value. In other words, it must have already been created by using the msgget() system call.The ID="06.ipc31"cmd argument can be replaced by one of the following control commands (flags):IPC_STATreturn the status information contained in the associated data structure for the specified msqid, and place it in the data structure pointed to by the *buf pointer in the user memory area.IPC_SETfor the specified msqid, set the effective user and group identification, operation permissions, and the number of bytes for the message queue.IPC_RMIDremove the specified msqid along with its associated message queue and data structure.A process must have an effective user identification of OWNER/CREATOR or super-user to perform an IPC_SET or IPC_RMID control command. Read permission is required to perform the IPC_STAT control command.The details of this system call are discussed in the example program for it. If you have trouble understanding the logic manipulations in this program, read the IDREF="98090" TYPE="TITLE""Getting Message Queues with msgget()"
 section of this chapter; it goes into more detail than would be practical to do for every system call.LBL="" HELPID=""Example ProgramThe example program in this section (
ID="06.ipc32"IDREF="23944" TYPE="TEXT"Example 6-2
) is a menu-driven program which allows all possible combinations of using the msgctl() system call to be exercised.From studying this program, you can observe the method of passing arguments and receiving return values. The user-written program requirements are pointed out.This program begins (lines 5-9) by including the required header files as specified by the msgctl(2) manual page. Note in this program that errno is declared as an external variable, and therefore, the errno.h header file does not have to be included.Variable and structure names have been chosen to be as close as possible to those in the synopsis for the system call. Their declarations are self-explanatory. These names make the program more readable, and it is perfectly legal since they are local to the program. The variables declared for this program and their purpose are as follows:uidused to store the IPC_SET value for the effective user identificationgidused to store the IPC_SET value for the effective group identificationmodeused to store the IPC_SET value for the operation permissionsbytesused to store the IPC_SET value for the number of bytes in the message queue (msg_qbytes)rtrnused to store the return integer value from the system callmsqidused to store and pass the message queue identifier to the system callcommandused to store the code for the desired control command so that subsequent processing can be performed on itchoiceused to determine which member is to be changed for the IPC_SET control commandmsqid_dsused to receive the specified message queue identifier's data structure when an IPC_STAT control command is performed*bufa pointer passed to the system call which locates the data structure in the user memory area where the IPC_STAT control command is to place its return values or where the IPC_SET command gets the values to setNote that the msqid_ds data structure in this program (line 16) uses the data structure located in the msg.h header file of the same name as a template for its declaration. This is a perfect example of the advantage of local variables.The next important thing to observe is that although the *buf pointer is declared to be a pointer to a data structure of the msqid_ds type, it must also be initialized to contain the address of the user memory area data structure (line 17). Now that all of the required declarations have been explained for this program, this is how it works.First, the program prompts for a valid message queue identifier which is stored in the msqid variable (lines 19, 20). This is required for every msgctl() system call.Then the code for the desired control command must be entered (lines 21-27), and it is stored in the command variable. The code is tested to determine the control command for subsequent processing.If the IPC_STAT control command is selected (code 1), the system call is performed (lines 37, 38) and the status information returned is printed out (lines 39-46); only the members that can be set are printed out in this program. Note that if the system call is unsuccessful (line 106), the status information of the last successful call is printed out. In addition, an error message is displayed and the errno variable is printed out (lines 108, 109). If the system call is successful, a message indicates this along with the message queue identifier used (lines 111-114).If the IPC_SET control command is selected (code 2), the first thing done is to get the current status information for the message queue identifier specified (lines 50-52). This is necessary because this example program provides for changing only one member at a time, and the system call changes all of them. Also, if an invalid value happened to be stored in the user memory area for one of these members, it would cause repetitive failures for this control command until corrected. The next thing the program does is to prompt for a code corresponding to the member to be changed (lines 53-59). This code is stored in the choice variable (line 60). Now, depending upon the member picked, the program prompts for the new value (lines 66-95). The value is placed in the appropriate member in the user memory area data structure, and the system call is made (lines 96-98). Depending upon success or failure, the program returns the same messages as for IPC_STAT above.If the IPC_RMID control command (code 3) is selected, the system call is performed (lines 100-103), and the msqid along with its associated message queue and data structure are removed from the UNIX operating system. Note that the *buf pointer is not required as an argument to perform this control command, and its value can be zero or NULL. Depending upon the success or failure, the program returns the same messages as for the other control commands.The example program for the msgctl() system call follows in 
IDREF="23944" TYPE="TEXT"Example 6-2
.LBL="6-2"Example 6-2 ID="23944"msgctl() System Call Example1 /*This is a program to illustrate 
2  *the message control, msgctl(), 
3  *system call capabilities. 
4  */

5  /*Include necessary header files.*/ 
6  #include <stdio.h> 
7  #include <sys/types.h>
8  #include <sys/ipc.h>
9  #include <sys/msg.h>

10  /*Start of main C language program*/
11  main()
12  {
13  extern int errno; 
14  int uid, gid, mode, bytes; 
15   int rtrn, msqid, command, choice; 
16   struct msqid_ds msqid_ds, *buf;
17  buf = &msqid_ds;
18  /*Get the msqid, and command.*/ 
19  printf("Enter the msqid = "); 
20  scanf("%d", &msqid); 
21  printf("\nEnter the number for\n"); 
22  printf("the desired command:\n");
23  printf("IPC_STAT = 1\n"); 24 printf("IPC_SET = 2\n");
25   printf("IPC_RMID = 3\n"); 
26   printf("Entry = ");
27   scanf("%d", &command);
28  /*Check the values.*/
29  printf (\nmsqid =%d, command = %\n", 30 msqid, command);
31  switch (command)
32  { 
33  case 1: /*Use msgctl() to duplicate
34      the data structure for
35      msqid in the msqid_ds area pointed 
36      to by buf and then print it out.*/ 
37    rtrn = msgctl(msqid, IPC_STAT,
38     buf);
39    printf ("\nThe USER ID = %d\n",
40     buf->msg_perm.uid);
41    printf ("The GROUP ID = %d\n", 
42     buf->msg_perm.gid); 
43    printf ("The operation permissions = 0%o\n", 
44     buf->msg_perm.mode); 
45    printf ("The msg_qbytes = %d\n", 
46     buf->msg_qbytes); 
47    break; 
48  case 2: /*Select and change the desired
49      member(s) of the data structure.*/ 
50    /*Get the original data for this msqid 
51      data structure first.*/
52    rtrn = msgctl(msqid, IPC_STAT, buf); 
53    printf("\nEnter the number for the\n"); 
54    printf("member to be changed:\n");
55   printf("msg_perm.uid = 1\n"); 
56    printf("msg_perm.gid = 2\n"); 
57    printf("msg_perm.mode = 3\n"); 
58    printf("msg_qbytes = 4\n"); 
59    printf("Entry = ");
60    scanf("%d", &choice);
61    /*Only one choice is allowed per
62    pass as an illegal entry will
63     cause repetitive failures until 
64    msqid_ds is updated with 
65     IPC_STAT.*/
66    switch(choice){
67    case 1: 
68    printf("\nEnter USER ID = "); 
69    scanf ("%d", &uid); 
70     buf->msg_perm.uid = uid; 
71     printf("\nUSER ID = %d\n", 
72      buf->msg_perm.uid); 
73     break; 
74    case 2: 
75     printf("\nEnter GROUP ID = ");
76     scanf("%d", &gid); 
77     buf->msg_perm.gid = gid;
78     printf("\nGROUP ID = %d\n",
79      buf->msg_perm.gid); 
80     break; 
81    case 3: 
82     printf("\nEnter MODE = "); 
83     scanf("%o", &mode); 
84     buf->msg_perm.mode = mode; 
85     printf("\nMODE = 0%o\n", 
86      buf->msg_perm.mode); 
87     break;
88    case 4: 
89     printf("\nEnter msq_bytes = "); 
90     scanf("%d", &bytes); 
91     buf->msg_qbytes = bytes; 
92     printf("\nmsg_qbytes = %d\n", 
93      buf->msg_qbytes); 
94     break;
95    }
96    /*Do the change.*/ 
97    rtrn = msgctl(msqid, IPC_SET, 
98     buf); 
99    break;
100   case 3: /*Remove the msqid along with its 
101       associated message queue 
102       and data structure.*/ 
103    rtrn = msgctl(msqid, IPC_RMID, NULL); 
104   } 
105   /*Perform the following if the call is unsuccessful.*/ 
106   if(rtrn == -1) 
107   { 
108    printf ("\nThe msgctl system call failed!\n"); 
109    printf ("The error number = %d\n", errno); 
110   } 
111   /*Return the msqid upon successful completion.*/ 
112   else 
113    printf ("\nMsgctl was successful for msqid = %d\n", 
114     msqid);
115   exit (0); 
116}LBL="" HELPID=""ID="97534"Operations for Messages: msgsnd() and msgrcv()This section gives a detailed description of using the ID="06.ipc33"msgsnd() and msgrcv() system calls, along with an example program which allows all of their capabilities to be exercised.ID="06.ipc34"The synopsis found in the ID="06.ipc35"msgop(2) manual page, which describes both msgsnd() and msgrcv(), is as follows: #include <sys/types.h>
#include <sys/ipc.h> 
#include <sys/msg.h>

int msgsnd(int msqid, const void *msgp,
† †size_t msgsz, int msgflg);

int msgrcv(int msqid, void *msgp,
† †size_t msgsz, long msgtyp, int msgflg);LBL="" HELPID=""Sending a MessageThe ID="06.ipc36"msgsnd() system call requires four arguments to be passed to it. It returns an integer value.Upon successful completion, a zero value is returned; when unsuccessful, msgsnd() returns a -1.The msqid argument must be a valid, non-negative, integer value. In other words, it must have already been created by using the msgget() system call.The msgp argument is a pointer to a structure in the user memory area that contains the type of the message and the message to be sent.The msgsz argument specifies the length of the character array in the data structure pointed to by the msgp argument. This is the length of the message. The maximum size of this array is determined by the MSGMAX system tunable parameter.The msg_qbytes data structure member can be lowered from MSGMNB by using the msgctl() IPC_SET control command, but only the super-user can raise it afterwards.The ID="06.ipc37"msgflg argument allows the "blocking message operation" to be performed if the IPC_NOWAIT flag is not set (msgflg & IPC_NOWAIT = 0); this would occur if the total number of bytes allowed on the specified message queue are in use (msg_qbytes or MSGMNB), or the total system-wide number of messages on all queues is equal to the system imposed limit (MSGTQL). If the IPC_NOWAIT flag is set, the system call will fail and return a -1.Further details of this system call are discussed in the example program for it. If you have problems understanding the logic manipulations in this program, read the IDREF="98090" TYPE="TITLE""Getting Message Queues with msgget()"
 section of this chapter; it goes into more detail than would be practical to do for every system call.LBL="" HELPID=""Receiving MessagesThe ID="06.ipc38"msgrcv() system call requires five arguments to be passed to it, and it returns an integer value.Upon successful completion, a value equal to the number of bytes received is returned and when unsuccessful it returns a -1.The msqid argument must be a valid, non-negative, integer value. In other words, it must have already been created by using the msgget() system call.The msgp argument is a pointer to a structure in the user memory area that will receive the message type and the message text.The msgsz argument specifies the length of the message to be received. If its value is less than the message in the array, an error can be returned if desired; see the msgflg argument.The msgtyp argument is used to pick the first message on the message queue of the particular type specified. If it is equal to zero, the first message on the queue is received; if it is greater than zero, the first message of the same type is received; if it is less than zero, the lowest type that is less than or equal to its absolute value is received.The ID="06.ipc39"msgflg argument allows the "blocking message operation" to be performed if the IPC_NOWAIT flag is not set (msgflg & IPC_NOWAIT = 0); this would occur if there is not a message on the message queue of the desired type (msgtyp) to be received. If the IPC_NOWAIT flag is set, the system call will fail immediately when there is not a message of the desired type on the queue. ID="06.ipc40"msgflg can also specify that the system call fail if the message is longer than the size to be received; this is done by not setting the MSG_NOERROR flag in the msgflg argument (msgflg & MSG_NOERROR = 0). If the MSG_NOERROR flag is set, the message is truncated to the length specified by the ID="06.ipc41"msgsz argument of msgrcv().Further details of this system call are discussed in the example program for it. If you have problems understanding the logic manipulations in this program, read the IDREF="98090" TYPE="TITLE""Getting Message Queues with msgget()"
 section of this chapter; it goes into more detail than would be practical to do for every system call.LBL="" HELPID=""Example ProgramThe example program in this section (
ID="06.ipc42"IDREF="84851" TYPE="TEXT"Example 6-3
) is a menu-driven program which allows all possible combinations of using the msgsnd() and msgrcv() system calls to be exercised.From studying this program, you can observe the method of passing arguments and receiving return values. The user-written program requirements are pointed out.This program begins (lines 5-9) by including the required header files as specified by the msgop(2) manual page. Note that in this program errno is declared as an external variable, and therefore, the errno.h header file does not have to be included.Variable and structure names have been chosen to be as close as possible to those in the synopsis. Their declarations are self-explanatory. These names make the program more readable, and this is perfectly legal since they are local to the program. The variables declared for this program and their purposes are as shown in IDREF="80810" TYPE="TABLE"Table 6-3
:COLUMNS="2"LBL="6-3"Table 6-3 ID="80810"Variables used in the msgop() example programLEFT="0" WIDTH="161"VariableLEFT="170" WIDTH="356"PurposeLEFT="0" WIDTH="161"sndbufLEFT="170" WIDTH="356"used as a buffer to contain a message to be 
sent (line 13); it uses the msgbuf1 data 
structure as a template (lines 10-13) 
The msgbuf1 structure (lines 10-13) is 
almost an exact duplicate of the msgbuf 
structure contained in the msg.h header 
file. The only difference is that the 
character array for msgbuf1 contains the 
maximum message size (MSGMAX) 
for the workstation where in msgbuf it is 
set to one to satisfy the compiler. For this 
reason msgbuf cannot be used directly 
as a template for the user-written 
program. It is there so you can determine 
its members.LEFT="0" WIDTH="161"rcvbufLEFT="170" WIDTH="356"used as a buffer to receive a message (line 
13); it uses the msgbuf1 data structure 
as a template (lines 10-13)LEFT="0" WIDTH="161"*msgpLEFT="170" WIDTH="356"used as a pointer (line 13) to both the 
sndbuf and rcvbuf buffersLEFT="0" WIDTH="161"iLEFT="170" WIDTH="356"used as a counter for inputting characters 
from the keyboard, storing them in the 
array, and keeping track of the message 
length for the msgsnd() system call; it is 
also used as a counter to output the 
received message for the msgrcv() 
system callLEFT="0" WIDTH="161"cLEFT="170" WIDTH="356"used to receive the input character from 
the getchar() function (line 50)LEFT="0" WIDTH="161"flagLEFT="170" WIDTH="356"used to store the code of IPC_NOWAIT 
for the msgsnd() system call (line 61)LEFT="0" WIDTH="161"flagsLEFT="170" WIDTH="356"used to store the code of the 
IPC_NOWAIT or MSG_NOERROR flags 
for the msgrcv() system call (line 117)LEFT="0" WIDTH="161"choiceLEFT="170" WIDTH="356"used to store the code for sending or 
receiving (line 30)LEFT="0" WIDTH="161"rtrnLEFT="170" WIDTH="356"used to store the return values from all 
system callsLEFT="0" WIDTH="161"msqidLEFT="170" WIDTH="356"used to store and pass the desired 
message queue identifier for both system 
callsLEFT="0" WIDTH="161"msgszLEFT="170" WIDTH="356"used to store and pass the size of the 
message to be sent or receivedLEFT="0" WIDTH="161"msgflgLEFT="170" WIDTH="356"used to pass the value of flag for sending 
or the value of flags for receivingLEFT="0" WIDTH="161"msgtypLEFT="170" WIDTH="356"used for specifying the message type for 
sending, or used to pick a message type 
for receivingNote that a msqid_ds data structure is set up in the program (line 21) with a pointer which is initialized to point to it (line 22); this will allow the data structure members that are affected by message operations to be observed. They are observed by using the msgctl() system call (with IPC_STAT) to get them so the program can print them out (lines 80-92 and lines 161-168).The first thing the program prompts for is whether to send or receive a message. A corresponding code must be entered for the desired operation, and it is stored in the choice variable (lines 23-30). Depending upon the code, the program proceeds as in the following msgsnd() or msgrcv() sections.LBL="" HELPID=""msgsndWhen the code is to send a message, the msgp pointer is initialized (line 33) to the address of the send data structure, sndbuf. Next, a message type must be entered for the message; it is stored in the variable msgtyp (line 42), and then (line 43) it is put into the mtype member of the data structure pointed to by msgp.The program now prompts for a message to be entered from the keyboard and enters a loop of getting and storing into the mtext array of the data structure (lines 48-51). This will continue until an end of file is reached (for the getchar() function this is a control-D immediately following a carriage return). When this happens, the size of the message is determined by adding one to the i counter (lines 52, 53) as it stored the message beginning in the zero array element of mtext. Keep in mind that the message also contains the terminating characters, and the message will therefore appear to be three characters short of msgsz.The message is immediately echoed from the mtext array of the sndbuf data structure to provide feedback (lines 54-56).The next and final thing that must be decided is whether to set the IPC_NOWAIT flag. The program does this by requesting that 1 be entered for yes or anything else for no (lines 57-65). The result is stored in the flag variable. If a 1 is entered, IPC_NOWAIT is logically ORed with msgflg; otherwise, msgflg is set to zero.The msgsnd() system call is then performed (line 69). If it is unsuccessful, a failure message is displayed along with the error number (lines 70-72). If it is successful, the returned value (which should be zero) is printed (lines 73-76).Every time a message is successfully sent, there are three members of the associated data structure which are updated. They are:msg_qnumrepresents the total number of messages on the message queue; it is incremented by one.msg_lspidcontains the Process Identification (PID) number of the last process sending a message; it is set accordingly.msg_stimecontains the time in seconds since January 1, 1970, Greenwich Mean Time (GMT) of the last message sent; it is set accordingly.These members are displayed after every successful message send operation (lines 79-92).LBL="" HELPID=""msgrcvIf the code specifies that a message is to be received, the program continues execution as in the following paragraphs.The msgp pointer is initialized to the rcvbuf data structure (line 99).Next, the message queue identifier of the message queue from which to receive the message is requested, and it is stored in msqid (lines 100-103).The message type is requested, and it is stored in msgtyp (lines 104-107).The code for the desired combination of control flags is requested next, and it is stored in flags (lines 108-117). Depending upon the selected combination, msgflg is set accordingly (lines 118-133).Finally, the number of bytes to be received is requested, and it is stored in msgsz (lines 134-137).The msgrcv() system call is performed (line 144). If it is unsuccessful, a message and error number is displayed (lines 145-148). If successful, a message indicates success, and the number of bytes returned is displayed followed by the received message (lines 153-159).When a message is successfully received, there are three members of the associated data structure which are updated; they are described as follows:msg_qnumcontains the number of messages on the message queue; it is decremented by one.msg_lrpidcontains the process identification (PID) of the last process receiving a message; it is set accordingly.msg_rtimecontains the time in seconds since January 1, 1970, Greenwich Mean Time (GMT) that the last process received a message; it is set accordingly.The example program for the msgop() system calls is shown in 
IDREF="84851" TYPE="TEXT"Example 6-3
.LBL="6-3"Example 6-3 ID="84851"msgsnd() and msgrcv() System Call ExampleID="06.ipc43"1  /*This is a program to illustrate
2   * the message operations, msgop(),
3   * system call capabilities: msgsnd() and msgrcv(). 
4   */
5  /*Include necessary header files.*/
6  #include <stdio.h>
7  #include <sys/types.h>
8  #include <sys/ipc.h>
9  #include <sys/msg.h>
10  struct msgbuf1 {
11   long mtype;
12   char mtext[8192];
13 } sndbuf, rcvbuf, *msgp;
14  /*Start of main C language program*/
15  main()
16  { 
17   extern int errno;
18   int i, c, flag, flags, choice;
19   int rtrn, msqid, msgsz, msgflg;
20   long mtype, msgtyp;
21   struct msqid_ds msqid_ds, *buf;
22   buf = &msqid_ds;

23   /*Select the desired operation.*/
24   printf("Enter the corresponding\n");
25   printf("code to send or\n");
26   printf("receive a message:\n");
27   printf("Send = 1\n");
28   printf("Receive = 2\n");
29   printf("Entry = ");
30   scanf("%d", &choice);

31   if(choice == 1) /*Send a message.*/
32   {
33    msgp = &sndbuf; /*Point to user send structure.*/

34    printf("\nEnter the msqid or\n");
35    printf("the message queue to\n");
36    printf("handle the message = "); 
37    scanf("%d", &msqid);

38    /*Set the message type.*/
39    printf("\nEnter a positive integer\n");
40    printf("message type (long) for the\n");
41    printf("message = ");
42    scanf("%d", &msgtyp);
43    msgp->mtype = msgtyp;

44    /*Enter the message to send.*/
45    printf("\nEnter a message: \n");

46    /*A control-d (^d) terminates as
47      EOF.*/

48    /*Get each character of the message
49      and put it in the mtext array.*/
50    for(i = 0; ((c = getchar()) != EOF); i++)
51     sndbuf.mtext[i] = c;

52    /*Determine the message size.*/
53    msgsz = i + 1;
54    /*Echo the message to send.*/
55    for(i = 0; i < msgsz; i++) 
56     putchar(sndbuf.mtext[i]);

57    /*Set the IPC_NOWAIT flag if
58      desired.*/
59    printf("\nEnter a 1 if you want the\n");
60    printf("the IPC_NOWAIT flag set: "); 
61    scanf("%d", &flag);
62    if(flag == 1)
63     msgflg |= IPC_NOWAIT;
64    else
65     msgflg = 0;

66    /*Check the msgflg.*/
67    printf("\nmsgflg = 0%o\n", msgflg);

68    /*Send the message.*/
69    rtrn = msgsnd(msqid, msgp, msgsz, msgflg);
70    if(rtrn == -1)
71    printf("\nMsgsnd failed. Error = %d\n", 
72       errno);
73    else {
74     /*Print the value of test which
75      should be zero for successful.*/
76     printf("\nValue returned = %d\n", rtrn);

77     /*Print the size of the message
78     sent.*/
79     printf("\nMsgsz = %d\n", msgsz);

80     /*Check the data structure update.*/
81     msgctl(msqid, IPC_STAT, buf);

82     /*Print out the affected members.*/

83     /*Print the incremented number of
84       messages on the queue.*/
85     printf("\nThe msg_qnum = %d\n",
86        buf->msg_qnum);
87     /*Print the process id of the last sender.*/
88     printf("The msg_lspid = %d\n",
89       buf->msg_lspid);
90     /*Print the last send time.*/
91     printf("The msg_stime = %d\n",
92       buf->msg_stime);
93    } 
94   }

95   if(choice == 2) /*Receive a message.*/
96   {
97    /*Initialize the message pointer
98    to the receive buffer.*/
99    msgp = &rcvbuf;

100    /*Specify the message queue which contains
101       the desired message.*/
102    printf("\nEnter the msqid = ");
103    scanf("%d", &msqid);

104    /*Specify the specific message on the queue
105     by using its type.*/
106    printf("\nEnter the msgtyp = ");
107    scanf("%d", &msgtyp);

108    /*Configure the control flags for the
109     desired actions.*/
110    printf("\nEnter the corresponding codeen");
111    printf("to select the desired flags: \n");
112    printf("No flags = 0\n");
113   printf("MSG_NOERROR = 1\n");
114    printf("IPC_NOWAIT = 2\n");
115    printf("MSG_NOERROR and IPC_NOWAIT = 3\n");
116    printf(" Flags = ");
117    scanf("%d", &flags);

118    switch(flags) {
119     /*Set msgflg by ORing it with the appropriate
120        flags (constants).*/
121    case 0:
122     msgflg = 0;
123     break;
124    case 1:
125     msgflg |= MSG_NOERROR;
126     break;
127    case 2:
128     msgflg |= IPC_NOWAIT;
129     break;
130    case 3:
131     msgflg |= MSG_NOERROR | IPC_NOWAIT;
132     break;
133    }

134    /*Specify the number of bytes to receive.*/
135    printf("\nEnter the number of bytes\n");
136    printf("to receive (msgsz) = ");
137    scanf("%d", &msgsz);

138    /*Check the values for the arguments.*/
139    printf("\nmsqid =%d\n", msqid);
140    printf("\nmsgtyp = %d\n", msgtyp);
141    printf("\nmsgsz = %d\n", msgsz);
142    printf("\nmsgflg = 0%o\n", msgflg);

143    /*Call msgrcv to receive the message.*/
144    rtrn = msgrcv(msqid, msgp, msgsz, msgtyp, msgflg);

145    if(rtrn == -1) {
146     printf("\nMsgrcv failed. ");
147     printf("Error = %d\n", errno);
148    }
149    else {
150     printf ("\nMsgctl was successful\n");
151     printf("for msqid = %d\n",
152      msqid);

153     /*Print the number of bytes received,
154       it is equal to the return
155       value.*/
156     printf("Bytes received = %d\n", rtrn);

157     /*Print the received message.*/
158     for(i = 0; i<=rtrn; i++)
159      putchar(rcvbuf.mtext[i]);
160    }
161    /*Check the associated data structure.*/
162    msgctl(msqid, IPC_STAT, buf);
163    /*Print the decremented number of messages.*/
164    printf("\nThe msg_qnum = %d\n", buf->msg_qnum);
165    /*Print the process id of the last receiver.*/
166    printf("The msg_lrpid = %d\n", buf->msg_lrpid);
167    /*Print the last message receive time*/
168    printf("The msg_rtime = %d\n", buf->msg_rtime);
169   }
170  }LBL="" HELPID=""System V SemaphoresSemaphore IPC allows processes to communicate through the exchange of data items called semaphores. A single semaphore is represented as a positive integer (0 through 32,767). Semaphores are usually used to manage resources; each semaphore indicates whether or not a specific data item is currently in use (and by how many different processes). Since many applications require the use of more than one semaphore, the UNIX operating system has the ability to create sets or arrays of semaphores at one time. A semaphore set can contain one or more semaphores, up to a limit set by the system administrator. (This limit, a tunable parameter called SEMMSL, has a default value of 25.) To create a set of semaphores, use the ID="06.ipc44"ID="06.ipc45"ID="06.ipc46"ID="06.ipc47"semget() system call.The process performing the ID="06.ipc48"semget() system call becomes the owner/creator of the semaphore set, determines how many semaphores are in the set, and sets the operation permissions for the set. This process can subsequently relinquish ownership of the set or change the operation permissions using the ID="06.ipc49"semctl() (semaphore control) system call. The creating process remains the creator as long as the semaphore set exists, but other processes with permission can use ID="06.ipc50"semctl() to perform other control functions.Provided a process has alter permission, it can manipulate the semaphore set. Each semaphore within a set can be either increased or decreased with the ID="06.ipc51"semop(2) system call (see the IRIX manual pages for more information).To increase a semaphore, pass a positive integer value of the desired magnitude to the ID="06.ipc52"semop() system call. To decrease a semaphore, pass a negative integer value of the desired magnitude.The UNIX operating system ensures that only one process can manipulate a semaphore set at any given time. Simultaneous requests are performed sequentially in an arbitrary manner.A process can test for a semaphore value to be greater than a certain value by attempting to decrement the semaphore by one more than that value. If the process is successful, then the semaphore value is greater than that certain value. Otherwise, the semaphore value is not. While doing this, the process can have its execution suspended (IPC_NOWAIT flag not set) until the semaphore value would permit the operation (other processes increment the semaphore), or the semaphore facility is removed.ID="06.ipc53"ID="06.ipc54"The ability to suspend execution is called a "blocking semaphore operation." This ability is also available for a process which is testing for a semaphore to become zero or equal to zero; only read permission is required for this test, and it is accomplished by passing a value of zero to the ID="06.ipc55"semop() system call.On the other hand, if the process is not successful and the process does not request to have its execution suspended, it is called a "nonblocking semaphore operation." In this case, the process is returned a known error code (-1), and the external ID="06.ipc56"errno variable is set accordingly.The blocking semaphore operation allows processes to communicate based on the values of semaphores at different points in time. Remember also that IPC facilities remain in the UNIX operating system until removed by a permitted process or until the system is reinitialized.ID="06.ipc57"Operating on a semaphore set is done by using the ID="06.ipc58"semop(), semaphore operation, system call.When a set of semaphores is created, the first semaphore in the set is semaphore number zero. The last semaphore in the set is numbered one less than the number of semaphores in the set.ID="06.ipc59"An array of these "blocking/nonblocking operations" can be performed on a set containing more than one semaphore. When performing an array of operations, the "blocking/nonblocking operations" can be applied to any or all of the semaphores in the set. Also, the operations can be applied in any order of semaphore number. However, no operations are done until they can all be done successfully. This requirement means that preceding changes made to semaphore values in the set must be undone when a "blocking semaphore operation" on a semaphore in the set cannot be completed successfully; no changes are made until they can all be made. For example, if a process has successfully completed three of six operations on a set of ten semaphores but is "blocked" from performing the fourth operation, no changes are made to the set until the fourth and remaining operations are successfully performed. Additionally, any operation preceding or succeeding the "blocked" operation, including the blocked operation, can specify that at such time that all operations can be performed successfully, that the operation be undone. Otherwise, the operations are performed and the semaphores are changed or one "nonblocking operation" is unsuccessful and none are changed. All of this is commonly referred to as being "atomically performed."ID="06.ipc60"The ability to undo operations requires the UNIX operating system to maintain an array of "undo structures" corresponding to the array of semaphore operations to be performed. Each semaphore operation which is to be undone has an associated adjust variable used for undoing the operation, if necessary.ID="06.ipc61"Remember, any unsuccessful "nonblocking operation" for a single semaphore or a set of semaphores causes immediate return with no operations performed at all. When this occurs, a known error code (-1) is returned to the process, and the external variable errno is set accordingly.System calls make these semaphore capabilities available to processes. The calling process passes arguments to a system call, and the system call attempts to perform its function. If the system call is successful, it performs its function and returns the appropriate information. Otherwise, a known error code (-1) is returned to the process, and the external variable errno is set accordingly.LBL="" HELPID=""Using SemaphoresBefore you can use semaphores, you must request a uniquely identified semaphore set and its associated data structure with a system call. The unique identifier is called the semaphore identifier (ID="06.ipc62"semid); it is used to reference a particular semaphore set and data structure.The semaphore set contains a predefined number of structures in an array, one structure for each semaphore in the set. The user may select the number of semaphores (ID="06.ipc63"nsems) in a set. The following members are in each instance of the structure within a semaphore set:semaphore text map addressprocess identification (PID) performing last operationnumber of processes waiting for the semaphore value to become greater than its current valuenumber of processes waiting for the semaphore value to equal zeroEach semaphore set has an associated data structure. This data structure contains information related to the semaphore set:operation permissions datapointer to first semaphore in the setnumber of semaphores in the setlast semaphore operation timelast semaphore change timeThe definition for the semaphore set is:struct sem
{
† †   ushort semval; /* semaphore text map address */
† †   short sempid; /* pid of last operation */
† †   ushort semncnt; /* # awaiting semval > cval */
† †   ushort semzcnt; /* # awaiting semval = 0 */
};This definition is located in the /usr/include/sys/sem.h header file. The structure definition for the associated semaphore data structure is also located in the same header file. Note that the sem_perm member of this structure uses ipc_perm as a template. The ipc_perm data structure is the same for all IPC facilities, and it is located in the /usr/include/sys/ipc.h header file.The ID="06.ipc64"semget() system call is used to perform two tasks when only the IPC_CREAT flag is set in the semflg argument that it receives:to get a new semid and create an associated data structure and semaphore set for itto return an existing semid that already has an associated data structure and semaphore setThe task performed is determined by the value of the key argument passed to the semget() system call. For the first task, if the key is not already in use for an existing semid, a new semid is returned with an associated data structure and semaphore set created for it, provided no system-tunable parameter would be exceeded.There is also a provision for specifying a ID="06.ipc65"key of value zero which is known as the private key (IPC_PRIVATE = 0); when specified, a new semid is always returned with an associated data structure and semaphore set created for it unless a system tunable parameter would be exceeded. When the ID="06.ipc66"ipcs command is performed, the KEY field for the semid is all zeros.When performing the first task, the process which calls semget() becomes the owner/creator, and the associated data structure is initialized accordingly. Remember, ownership can be changed, but the creating process always remains the creator; see IDREF="59545" TYPE="TITLE""Controlling Semaphores with semctl()"
 for more information. The creator of the semaphore set also determines the initial operation permissions for the facility.For the second task, if a semid exists for the key specified, the value of the existing semid is returned. If you do not desire to have an existing ID="06.ipc67"semid returned, a control command (IPC_EXCL) can be specified in the semflg argument passed to the system call. The system call will fail if it is passed a value for the number of semaphores (nsems) that is greater than the number actually in the set; if you do not know how many semaphores are in the set, use 0 for nsems. The details of using the semget() system call are discussed in IDREF="60684" TYPE="TITLE""Getting Semaphores with semget()."Once a uniquely-identified semaphore set and data structure have been created, semaphore operations (semop()) and semaphore control (semctl()) can be used.Semaphores can be increased, decreased, or tested for zero. A single system call, semop(), is used to perform these operations. Refer to IDREF="30161" TYPE="TITLE""Operations on Semaphores: semop()"
 for details on this system call.Semaphore control is done by using the ID="06.ipc68"semctl() system call. The control operations permit you to control the semaphore facility in the following ways:to return the value of a semaphoreto set the value of a semaphoreto return the process identification (PID) of the last process performing an operation on a semaphore setto return the number of processes waiting for a semaphore value to become greater than its current valueto return the number of processes waiting for a semaphore value to equal zeroto get all semaphore values in a set and place them in an array in user memoryto set all semaphore values in a semaphore set from an array of values in user memoryto place all data structure member values and status of a semaphore set into user memory areato change operation permissions for a semaphore setto remove a particular semid from the UNIX operating system along with its associated data structure and semaphore setRefer to IDREF="59545" TYPE="TITLE""Controlling Semaphores with semctl()"
 for details of the semctl() system call.LBL="" HELPID=""ID="60684"Getting Semaphores with semget()This section contains a detailed description of using the ID="06.ipc69"semget() system call along with an example program illustrating its use.The synopsis found in the semget(2) manual page is as follows: #include  <sys/types.h>
#include  <sys/ipc.h>
#include  <sys/sem.h>
int semget(key_t key, int nsems, int semflg);key_t is declared by a typedef in the types.h header file to be an integer.The integer returned from this system call upon successful completion is the semaphore set identifier (semid) that was discussed above.As declared, the process calling the semget() system call must supply three actual arguments to be passed to the formal key, nsems, and semflg arguments.A new semid with an associated semaphore set and data structure is provided if eitherkey is equal to IPC_PRIVATE, orkey is passed a unique hexadecimal integer, and semflg ANDed with IPC_CREAT is TRUE.The value passed to the semflg argument must be an integer type octal value and will specify the following:access permissionsexecution modescontrol fields (commands)Access permissions determine the read/alter attributes and execution modes determine the user/group/other attributes of the ID="06.ipc70"semflg argument. They are collectively referred to as "operation permissions." IDREF="76524" TYPE="TABLE"Table 6-4
 shows the numeric values (expressed in octal notation) for the valid operation permissions codes.COLUMNS="2"LBL="6-4"Table 6-4 ID="76524"Operation Permissions CodesLEFT="0" WIDTH="171"Operation PermissionsLEFT="180" WIDTH="356"Octal ValueLEFT="0" WIDTH="171"Read by UserLEFT="180" WIDTH="356"00400LEFT="0" WIDTH="171"Alter by UserLEFT="180" WIDTH="356"00200LEFT="0" WIDTH="171"Read by GroupLEFT="180" WIDTH="356"00040LEFT="0" WIDTH="171"Alter by GroupLEFT="180" WIDTH="356"00020LEFT="0" WIDTH="171"Read by OthersLEFT="180" WIDTH="356"00004LEFT="0" WIDTH="171"Alter by OthersLEFT="180" WIDTH="356"00002A specific octal value is derived by adding the octal values for the operation permissions desired. That is, if read by user and read/alter by others is desired, the code value would be 00406 (00400 plus 00006). There are constants #defined in the sem.h header file which can be used for the owner. They are: SEM_A 0200 /* alter permission by owner */
SEM_R 0400 /* read permission by owner */Control commands are predefined constants (represented by all uppercase letters). ID="06.ipc71"IDREF="34675" TYPE="TABLE"Table 6-5
 contains the names of the constants which apply to the semget() system call along with their values. They are also referred to as flags and are defined in the ipc.h header file.COLUMNS="2"LBL="6-5"Table 6-5 ID="34675"Control Commands (Flags)LEFT="0" WIDTH="171"Control CommandLEFT="180" WIDTH="356"ValueLEFT="0" WIDTH="171"IPC_CREATLEFT="180" WIDTH="356"0001000LEFT="0" WIDTH="171"IPC_EXCLLEFT="180" WIDTH="356"0002000The value for semflg is, therefore, a combination of operation permissions and control commands. After determining the value for the operation permissions as previously described, the desired flag(s) can be specified. This specification is accomplished by bitwise ORing (|) them with the operation permissions; the bit positions and values for the control commands in relation to those of the operation permissions make this possible.The semflg value can be easily set by using the names of the flags in conjunction with the octal operation permissions value: semid = semget (key, nsems, (IPC_CREAT | 0400));
semid = semget (key, nsems, (IPC_CREAT | IPC_EXCL | 0400));As specified by the semget(2) manual page, success or failure of this system call depends upon the actual argument values for key, nsems, semflg or system tunable parameters. The system call will attempt to return a new ID="06.ipc72"semid if one of the following conditions is true:key is equal to IPC_PRIVATE (0)key does not already have a semid associated with it, and (semflg & IPC_CREAT) is "true".The key argument can be set to IPC_PRIVATE in the following ways:semid = semget (IPC_PRIVATE, nsems, semflg);orsemid = semget (0, nsems, semflg);This alone will cause the system call to be attempted because it satisfies the first condition specified.Exceeding the SEMMNI, SEMMNS, or SEMMSL system-tunable parameters will always cause a failure. The SEMMNI system tunable parameter determines the maximum number of unique semaphore sets (ID="06.ipc73"semids) in the UNIX operating system. The SEMMNS system tunable parameter determines the maximum number of semaphores in all semaphore sets system wide. The SEMMSL system tunable parameter determines the maximum number of semaphores in each semaphore set.The second condition is satisfied if the value for key is not already associated with a semid, and the bitwise ANDing of semflg and IPC_CREAT is "true" (not zero). This means that the key is unique (not already in use) within the UNIX operating system for this facility type and that the IPC_CREAT flag has been set (using semflg | IPC_CREAT). SEMMNI, SEMMNS, and SEMMSL apply here also, just as for condition one.IPC_EXCL is another control command used in conjunction with IPC_CREAT to exclusively have the system call fail if, and only if, a ID="06.ipc74"semid exists for the specified key provided. This is necessary to prevent the process from thinking that it has received a new (unique) semid when it has not. In other words, when both IPC_CREAT and IPC_EXCL are specified, a new semid is returned if the system call is successful. Any value for semflg returns a new semid if the key equals zero (IPC_PRIVATE) and no system tunable parameters are exceeded.Refer to the semget(2) manual page for specific associated data structure initialization for successful completion.LBL="" HELPID=""Example ProgramThe example program in this section (
ID="06.ipc75"IDREF="22605" TYPE="TEXT"Example 6-4
) is a menu-driven program which allows all possible combinations of using the semget() system call to be exercised.From studying this program, you can observe the method of passing arguments and receiving return values. The user-written program requirements are pointed out.This program begins (lines 4-8) by including the required header files as specified by the semget(2) manual page. Note that the errno.h header file is included as opposed to declaring errno as an external variable; either method will work.Variable names have been chosen to be as close as possible to those in the synopsis. Their declarations are self-explanatory. These names make the program more readable, and this is perfectly legal since they are local to the program. The variables declared for this program and their purpose are as follows:key: used to pass the value for the desired keyopperm: used to store the desired operation permissionsflags: used to store the desired control commands (flags)opperm_flags: used to store the combination from the logical ORing of the opperm and flags variables; it is then used in the system call to pass the semflg argumentsemid: used for returning the semaphore set identification number for a successful system call or the error code (-1) for an unsuccessful one.The program begins by prompting for a hexadecimal key, an octal operation permissions code, and the control command combinations (flags) which are selected from a menu (lines 15-32). All possible combinations are allowed even though they might not be viable. This allows you to observe the errors for illegal combinations.Next, the menu selection for the flags is combined with the operation permissions, and the result is stored in the opperm_flags variable (lines 36-52).Then, the number of semaphores for the set is requested (lines 53-57), and its value is stored in nsems.The system call is made next, and the result is stored in the semid variable (lines 60, 61).Since the semid variable now contains a valid semaphore set identifier or the error code (-1), it is tested to see if an error occurred (line 63). If semid equals -1, a message indicates that an error resulted and the external errno variable is displayed (lines 65, 66). Remember that the external errno variable is only set when a system call fails; it should only be tested immediately following system calls.If no error occurred, the returned semaphore set identifier is displayed (line 70).The example program for the semget() system call is shown in 
IDREF="22605" TYPE="TEXT"Example 6-4
.LBL="6-4"Example 6-4 ID="22605"semget() System Call Example 1  /*This is a program to illustrate
2   *the semaphore get, semget(), 
3   *system call capabilities.*/

4  #include <stdio.h> 
5  #include <sys/types.h> 
6  #include <sys/ipc.h> 
7  #include <sys/sem.h> 
8  #include <errno.h>

9  /*Start of main C language program*/ 
10  main() 
11  {
12   key_t key; /*declare as long integer*/ 
13   int opperm, flags, nsems; 
14   int semid, opperm_flags;

15   /*Enter the desired key*/ 
16   printf("\nEnter the desired key in hex = "); 
17   scanf("%x", &key);

18   /*Enter the desired octal operation 
19   permissions.*/
20   printf("\nEnter the operation\n"); 
21   printf("permissions in octal = "); 
22   scanf("%o", &opperm);

23   /*Set the desired flags.*/
24  printf("\nEnter corresponding number to\n"); 
25  printf("set the desired flags:\n"); 
26  printf("No flags = 0\n"); 
27   printf("IPC_CREAT = 1\n"); 
28   printf("IPC_EXCL = 2\n"); 
29   printf("IPC_CREAT and IPC_EXCL = 3\n"); 
30   printf(" Flags = "); 
31   /*Get the flags to be set.*/ 
32   scanf("%d", &flags);

33   /*Error checking (debugging)*/ 
34   printf ("\nkey =0x%x, opperm = 0%o, flags = 0%o\n", 
35    key, opperm, flags); 
36   /*Incorporate the control fields (flags) with 
37      the operation permissions.*/ 
38   switch (flags) 
39   {
40   case 0: /*No flags are to be set.*/ 
41    opperm_flags = (opperm | 0); 
42    break; 
43   case 1: /*Set the IPC_CREAT flag.*/ 
44    opperm_flags = (opperm | IPC_CREAT); 
45    break; 
46   case 2: /*Set the IPC_EXCL flag.*/
47    opperm_flags = (opperm | IPC_EXCL); 
48    break; 
49   case 3: /*Set the IPC_CREAT and IPC_EXCL 
50     flags.*/
51    opperm_flags = (opperm | IPC_CREAT | IPC_EXCL); 
52   }
53   /*Get the number of semaphores for this set.*/ 
54   printf("\nEnter the number of\n");
55   printf("desired semaphores for\n"); 
56   printf("this set (25 max) = "); 
57  scanf("%d", &nsems);
58   /*Check the entry.*/
59   printf("enNsems = %d\n", nsems);
60   /*Call the semget system call.*/ 
61   semid = semget(key, nsems, opperm_flags);
62   /*Perform the following if the call is unsuccessful.*/
63   if(semid == -1) 
64   { 
65    printf("The semget system call failed!\n"); 
66    printf("The error number = %d\n", errno);
67   }
68   /*Return the semid upon successful completion.*/ 
69   else 
70    printf("\nThe semid = %d\n", semid);
71   exit(0); 
72  }LBL="" HELPID=""ID="59545"Controlling Semaphores with semctl()This section contains a detailed description of using the ID="06.ipc76"semctl() system call along with an example program which allows all of its capabilities to be exercised.The synopsis found in the semctl(2) manual page is as follows: #include <sys/types.h> 
#include <sys/ipc.h> 
#include <sys/sem.h>

int semctl (semid, semnum, cmd, arg) 
int semid, semnum, cmd;
union semun

{
† †     int val; 
† †     struct semid_ds *bu; 
† †     ushort array[];
} arg;The semctl() system call requires four arguments to be passed to it, and it returns an integer value.The semid argument must be a valid, non-negative, integer value that has already been created by using the semget() system call.The semnum argument is used to select a semaphore by its number. This relates to array (atomically performed) operations on the set. When a set of semaphores is created, the first semaphore is number 0, and the last semaphore has the number of one less than the total in the set.The cmd argument can be replaced by one of the following control commands (flags):GETVAL: return the value of a single semaphore within a semaphore setSETVAL: set the value of a single semaphore within a semaphore setGETPID: return the Process Identifier (PID) of the process that performed the last operation on the semaphore within a semaphore setGETNCNT: return the number of processes waiting for the value of a particular semaphore to become greater than its current valueGETZCNT: return the number of processes waiting for the value of a particular semaphore to be equal to zeroGETALL: return the values for all semaphores in a semaphore setSETALL: set all semaphore values in a semaphore setIPC_STAT: return the status information contained in the associated data structure for the specified semid, and place it in the data structure pointed to by the *buf pointer in the user memory area; arg.buf is the union member that contains the value of bufIPC_SET: for the specified semaphore set (semid), set the effective user/group identification and operation permissionsIPC_RMID-remove the specified (semid) semaphore set along with its associated data structure.A process must have an effective user identification of OWNER/CREATOR or super-user to perform an IPC_SET or IPC_RMID control command. Read/alter permission is required as applicable for the other control commands.The arg argument is used to pass the system call the appropriate union member for the control command to be performed:arg.valarg.bufarg.arrayThe details of this system call are discussed in the example program for it. If you have problems understanding the logic manipulations in this program, read IDREF="60684" TYPE="TITLE""Getting Semaphores with semget()"
; it goes into more detail than would be practical to do for every system call.LBL="" HELPID=""Example ProgramThe example program in this section (Figure 8-10) is a menu-driven program which allows all possible combinations of using the ID="06.ipc77"semctl() system call to be exercised.From studying this program, you can observe the method of passing arguments and receiving return values. The user-written program requirements are pointed out.This program begins (lines 5-9) by including the required header files as specified by the semctl(2) manual page. Note that in this program errno is declared as an external variable, and therefore the errno.h header file does not have to be included.Variable, structure, and union names have been chosen to be as close as possible to those in the synopsis. Their declarations are self-explanatory. These names make the program more readable, and this is perfectly legal since they are local to the program. Those declared for this program and their purpose are as follows:semid_ds: used to receive the specified semaphore set identifier's data structure when an IPC_STAT control command is performedc: used to receive the input values from the scanf() function, (line 117) when performing a SETALL control commandi: used as a counter to increment through the union arg.array when displaying the semaphore values for a GETALL (lines 97-99) control command, and when initializing the arg.array when performing a SETALL (lines 115-119) control commandlength: used as a variable to test for the number of semaphores in a set against the i counter variable (lines 97, 115)uid: used to store the IPC_SET value for the effective user identificationgid: used to store the IPC_SET value for the effective group identificationmode: used to store the IPC_SET value for the operation permissionsrtrn: used to store the return integer from the system call which depends upon the control command or a -1 when unsuccessfulsemid: used to store and pass the semaphore set identifier to the system callsemnum: used to store and pass the semaphore number to the system callcmd: used to store the code for the desired control command so that subsequent processing can be performed on itchoice: used to determine which member (uid, gid, mode) for the IPC_SET control command that is to be changedarg.val: used to pass the system call a value to set (SETVAL) or to store (GETVAL) a value returned from the system call for a single semaphore (union member)arg.buf: a pointer passed to the system call which locates the data structure in the user memory area where the IPC_STAT control command is to place its return values, or where the IPC_SET command gets the values to set (union member)arg.array: used to store the set of semaphore values when getting (GETALL) or initializing (SETALL) (union member).Note that the semid_ds data structure in this program (line 14) uses the data structure located in the sem.h header file of the same name as a template for its declaration. This is a perfect example of the advantage of local variables.The arg union (lines 18-22) serves three purposes in one. The compiler allocates enough storage to hold its largest member. The program can then use the union as any member by referencing union members as if they were regular structure members. Note that the array is declared to have 25 elements (0 through 24).This number corresponds to the maximum number of semaphores allowed per set (SEMMSL), a system-tunable parameter.The next important program aspect to observe is that although the† †*buf pointer member (arg.buf) of the union is declared to be a pointer to a data structure of the semid_ds type, it must also be initialized to contain the address of the user memory area data structure (line 24). Because of the way this program is written, the pointer does not need to be reinitialized later. If it was used to increment through the array, it would need to be reinitialized just before calling the system call.Now that all of the required declarations have been presented for this program, this is how it works.First, the program prompts for a valid semaphore set identifier, which is stored in the semid variable (lines 25-27). This is required for all semctl() system calls.Then, the code for the desired control command must be entered (lines 28-42), and the code is stored in the cmd variable. The code is tested to determine the control command for subsequent processing.If the GETVAL control command is selected (code 1), a message prompting for a semaphore number is displayed (lines 49, 50). When it is entered, it is stored in the semnum variable (line 51). Then, the system call is performed, and the semaphore value is displayed (lines 52-55). If the system call is successful, a message indicates this along with the semaphore set identifier used (lines 195, 196); if the system call is unsuccessful, an error message is displayed along with the value of the external errno variable (lines 191-193).If the SETVAL control command is selected (code 2), a message prompting for a semaphore number is displayed (lines 56, 57). When it is entered, it is stored in the semnum variable (line 58). Next, a message prompts for the value to which the semaphore is to be set, and it is stored as the arg.val member of the union (lines 59, 60). Then, the system call is performed (lines 61, 63). Depending upon success or failure, the program returns the same messages as for GETVAL above.If the GETPID control command is selected (code 3), the system call is made immediately since all required arguments are known (lines 64-67), and the PID of the process performing the last operation is displayed. Depending upon success or failure, the program returns the same messages as for GETVAL above.If the GETNCNT control command is selected (code 4), a message prompting for a semaphore number is displayed (lines 68-72). When entered, it is stored in the semnum variable (line 73). Then, the system call is performed, and the number of processes waiting for the semaphore to become greater than its current value is displayed (lines 74-77). Depending upon success or failure, the program returns the same messages as for GETVAL above.If the GETZCNT control command is selected (code 5), a message prompting for a semaphore number is displayed (lines 78-81). When it is entered, it is stored in the semnum variable (line 82). Then the system call is performed, and the number of processes waiting for the semaphore value to become equal to zero is displayed (lines 83, 86). Depending upon success or failure, the program returns the same messages as for GETVAL above.If the GETALL control command is selected (code 6), the program first performs an IPC_STAT control command to determine the number of semaphores in the set (lines 88-93). The length variable is set to the number of semaphores in the set (line 91). Next, the system call is made and, upon success, the arg.array union member contains the values of the semaphore set (line 96). Now, a loop is entered which displays each element of the arg.array† †from zero to one less than the value of length (lines 97-103). The semaphores in the set are displayed on a single line, separated by a space. Depending upon success or failure, the program returns the same messages as for GETVAL above.If the SETALL control command is selected (code 7), the program first performs an IPC_STAT control command to determine the number of semaphores in the set (lines 106-108). The length variable is set to the number of semaphores in the set (line 109). Next, the program prompts for the values to be set and enters a loop which takes values from the keyboard and initializes the arg.array union member to contain the desired values of the semaphore set (lines 113-119). The loop puts the first entry into the array position for semaphore number zero and ends when the semaphore number that is filled in the array equals one less than the value of length. The system call is then made (lines 120-122). Depending upon success or failure, the program returns the same messages as for GETVAL above.If the IPC_STAT control command is selected (code 8), the system call is performed (line 127), and the status information returned is printed out (lines 128-139); only the members that can be set are printed out in this program. Note that if the system call is unsuccessful, the status information of the last successful one is printed out. In addition, an error message is displayed, and the errno variable is printed out (lines 191, 192).If the IPC_SET control command is selected (code 9), the program gets the current status information for the semaphore set identifier specified (lines 143-146). This is necessary because this example program provides for changing only one member at a time, and the semctl() system call changes all of them. Also, if an invalid value happened to be stored in the user memory area for one of these members, it would cause repetitive failures for this control command until corrected. The next thing the program does is to prompt for a code corresponding to the member to be changed (lines 147-153). This code is stored in the choice variable (line 154). Now, depending upon the member picked, the program prompts for the new value (lines 155-178). The value is placed in the appropriate member in the user memory area data structure, and the system call is made (line 181). Depending upon success or failure, the program returns the same messages as for GETVAL above.If the IPC_RMID control command (code 10) is selected, the system call is performed (lines 183-185). The semid is removed from the UNIX operating system along with its associated data structure and semaphore set. Depending upon success or failure, the program returns the same messages as for the other control commands.The example program for the semctl() system call is shown in 
IDREF="37497" TYPE="TEXT"Example 6-5
.LBL="6-5"Example 6-5 ID="37497"semctl() System Call Example 1  /*This is a program to illustrate
2   *the semaphore control, semctl(), 
3   *system call capabilities. 
4   */
5  /*Include necessary header files.*/ 
6  #include <stdio.h>
7  #include <sys/types.h>
8  #include <sys/ipc.h> 
9  #include <sys/sem.h>
10  /*Start of main C language program*/ 
11  main() 
12  { 
13   extern int errno; 
14   struct semid_ds semid_ds;
15   int c, i, length; 
16   int uid, gid, mode; 
17   int retrn, semid, semnum, cmd, choice; 
18   union semun { 
19    int val;
20    struct semid_ds *buf; 
21    ushort array[25]; 
22   } arg;
23   /*Initialize the data structure pointer.*/
24   arg.buf = &semid_ds;
25   /*Enter the semaphore ID.*/ 
26   printf("Enter the semid = "); 
27   scanf("%d", &semid);
28   /*Choose the desired command.*/
29   printf("\nEnter the number for\n"); 
30   printf("the desired cmd:\n"); 
31   printf("GETVAL = 1\n"); 
32   printf("SETVAL = 2\n"); 
33   printf("GETPID = 3\n");
34   printf("GETNCNT = 4\n");
35   printf("GETZCNT = 5\n");
36   printf("GETALL = 6\n"); 
37   printf("SETALL = 7\n"); 
38   printf("IPC_STAT = 8\n"); 
39   printf("IPC_SET = 9\n"); 
40   printf("IPC_RMID = 10\n");
41   printf("Entry = "); 
42   scanf("%d", &cmd);
43   /*Check entries.*/
44   printf ("\nsemid =%d, cmd = %d\n\n", 
45    semid, cmd);
46   /*Set the command and do the call.*/ 
47   switch (cmd)
48   {
49   case 1: /*Get a specified value.*/ 
50    printf("\nEnter the semnum = "); 
51    scanf("%d", &semnum); 
52    /*Do the system call.*/ 
53    retrn = semctl(semid, semnum, GETVAL, 0); 
54    printf("\nThe semval = %d\n", retrn); 
55    break; 
56   case 2: /*Set a specified value.*/
57    printf("\nEnter the semnum = "); 
58    scanf("%d", &semnum); 
59    printf("\nEnter the value = "); 
60    scanf("%d", &arg.val);
61    /*Do the system call.*/ 
62    retrn = semctl(semid, semnum, SETVAL, arg.val);
63    break;
64   case 3: /*Get the process ID.*/ 
65    retrn = semctl(semid, 0, GETPID, 0); 
66    printf("\nThe sempid = %d\n", retrn); 
67    break; 
68   case 4: /*Get the number of processes 
69    waiting for the semaphore to 
70    become greater than its current 
71     value.*/
72    printf("\nEnter the semnum = "); 
73    scanf("%d", &semnum);
74    /*Do the system call.*/ 
75    retrn = semctl(semid, semnum, GETNCNT, 0); 
76    printf("\nThe semncnt = %d", retrn); 
77    break;
78   case 5: /*Get the number of processes 
79    waiting for the semaphore 
80     value to become zero.*/ 
81    printf("\nEnter the semnum = "); 
82    scanf("%d", &semnum); 
83    /*Do the system call.*/ 
84    retrn = semctl(semid, semnum, GETZCNT, 0); 
85    printf("\nThe semzcnt = %d", retrn); 
86    break;
87   case 6: /*Get all of the semaphores.*/ 
88    /*Get the number of semaphores in
89    the semaphore set.*/
90    retrn = semctl(semid, 0, IPC_STAT, arg.buf);
91    length = arg.buf->sem_nsems; 
92    if(retrn == -1) 
93     goto ERROR;
94    /*Get and print all semaphores in the 
95    specified set.*/ 
96    retrn = semctl(semid, 0, GETALL, arg.array);
97    for (i = 0; i < length; i++) 
98    { 
99     printf("%d", arg.array[i]); 
100     /*Seperate each 
101       semaphore.*/ 
102     printf("%c", ' '); 
103    } 
104    break;
105   case 7: /*Set all semaphores in the set.*/ 
106   /*Get the number of semaphores in
107    the set.*/ 
108    retrn = semctl(semid, 0, IPC_STAT, arg.buf); 
109    length = arg.buf->sem_nsems; 
110    printf("Length = %den", length);
111    if(retrn == -1) 
112     goto ERROR; 
113    /*Set the semaphore set values.*/ 
114    printf("\nEnter each value:\n"); 
115    for(i = 0; i < length ; i++) 
116    { 
117     scanf("%d", &c); 
118     arg.array[i] = c; 
119    } 
120    /*Do the system call.*/ 
121    retrn = semctl(semid, 0, SETALL, arg.array);
122    break;
123   case 8: /*Get the status for the semaphore set.*/ 
125    /*Get and print the current status values.*/ 
127    retrn = semctl(semid, 0, IPC_STAT, arg.buf); 
128    printf ("\nThe USER ID = %d\n", 
129     arg.buf->sem_perm.uid); 
130    printf ("The GROUP ID = %d\n", 
131     arg.buf->sem_perm.gid); 
132    printf ("The operation permissions = 0%o\n", 
133     arg.buf->sem_perm.mode); 
134    printf ("The number of semaphores in set = %d\n", 
135     arg.buf->sem_nsems); 
136    printf ("The last semop time = %d\n", 
137     arg.buf->sem_otime);
138    printf ("The last change time = %d\n", 
139     arg.buf->sem_ctime); 
140    break;
141   case 9: /*Select and change the desired 
142            member of the data structure.*/
143    /*Get the current status values.*/ 
144    retrn = semctl(semid, 0, IPC_STAT, arg.buf); 
145    if(retrn == -1) 
146     goto ERROR; 
147    /*Select the member to change.*/ 
148    printf("\nEnter the number for the\n"); 
149    printf("member to be changed:\n"); 
150    printf("sem_perm.uid = 1\n"); 
151    printf("sem_perm.gid = 2\n"); 
152    printf("sem_perm.mode = 3\n"); 
153    printf("Entry = "); 
154    scanf("%d", &choice); 
155    switch(choice){
156    case 1: /*Change the user ID.*/ 
157     printf("\nEnter USER ID = "); 
158     scanf ("%d", &uid); 
159     arg.buf->sem_perm.uid = uid; 
160     printf("enUSER ID = %d\n", 
161      arg.buf->sem_perm.uid); 
162     break;
163    case 2: /*Change the group ID.*/ 
164     printf("\nEnter GROUP ID = "); 
165     scanf("%d", &gid);
166     arg.buf->sem_perm.gid = gid; 
167     printf("\nGROUP ID = %d\n", 
168      arg.buf->sem_perm.gid); 
169     break;
170    case 3: /*Change the mode portion of
171     the operation
172       permissions.*/
173     printf("\nEnter MODE = "); 
174     scanf("%o", &mode); 
175     arg.buf->sem_perm.mode = mode; 
176     printf("\nMODE = 0%o\n",
177      arg.buf->sem_perm.mode); 
178     break; 
179    } 
180    /*Do the change.*/ 
181    retrn = semctl(semid, 0, IPC_SET, arg.buf); 
182    break; 
183   case 10: /*Remove the semid along with its 
184     data structure.*/ 
185    retrn = semctl(semid, 0, IPC_RMID, 0); 
186   } 
187   /*Perform the following if the call is unsuccessful.*/ 
188   if(retrn == -1) 
189   { 
190  ERROR: 
191    printf ("\n\nThe semctl system call failed!\n"); 
192    printf ("The error number = %d\n", errno); 
193    exit(0);
194   } 
195   printf ("\n\nThe semctl system call was successful\n"); 
196   printf ("for semid = %d\n", semid); 
197   exit (0); 
198  }LBL="" HELPID=""ID="30161"Operations on Semaphores: semop()This section contains a detailed description of using the ID="06.ipc78"semop() system call along with an example program which allows all of its capabilities to be exercised.The synopsis found in the semop(2) manual page is as follows:#include  <sys/types.h>
#include  <sys/ipc.h> 
#include  <sys/sem.h>

int semop (semid, sops, nsops) 
int semid;
struct sembuf *sops; 
size_t nsops;semop() returns zero on success, or -1 on failure.The semid argument must be a valid, non-negative, integer value. In other words, it must have already been created by using the semget() system call.The sops argument is a pointer to an array of structures in the user memory area that contains the following for each semaphore to be changed:the semaphore numberthe operation to be performedthe control command (flags)The *sops declaration means that a pointer can be initialized to the address of the array, or the array name can be used since it is the address of the first element of the array. Sembuf is the tag name of the data structure used as the template for the structure members in the array; it is located in the† †/usr/include/sys/sem.h header file.The nsops argument specifies the length of the array (the number of structures in the array). The maximum size of this array is determined by the SEMOPM system-tunable parameter. Therefore, a maximum of SEMOPM operations can be performed for each ID="06.ipc79"semop() system call.The semaphore number determines the particular semaphore within the set on which the operation is to be performed.The operation to be performed is determined by the following:a positive integer value means to increment the semaphore value by its valuea negative integer value means to decrement the semaphore value by its valuea value of zero means to test if the semaphore is equal to zeroThe following operation commands (flags) can be used:IPC_NOWAIT: this operation command can be set for any operations in the array. The system call will return unsuccessfully without changing any semaphore values at all if any operation for which IPC_NOWAIT is set cannot be performed successfully. The system call will be unsuccessful when trying to decrement a semaphore more than its current value, or when testing for a semaphore to be equal to zero when it is not.SEM_UNDO: this operation command allows any operations in the array to be undone when any operation in the array is unsuccessful and does not have the IPC_NOWAIT flag set. That is, the blocked operation waits until it can perform its operation; and when it and all succeeding operations are successful, all operations with the SEM_UNDO flag set are undone. Remember, no operations are performed on any semaphores in a set until all operations are successful. Undoing is accomplished by using an array of adjust values for the operations that are to be undone when the blocked operation and all subsequent operations are successful.LBL="" HELPID=""Example ProgramThe example program in this section (
ID="06.ipc80"IDREF="76840" TYPE="TEXT"Example 6-6
) is a menu driven program which allows all possible combinations of using the semop() system call to be exercised.From studying this program, you can observe the method of passing arguments and receiving return values. The user-written program requirements are pointed out.This program begins (lines 5-9) by including the required header files as specified by the semop(2) manual page. Note that in this program errno is declared as an external variable, and therefore, the errno.h header file does not have to be included.Variable and structure names have been chosen to be as close as possible to those in the synopsis. Their declarations are self-explanatory. These names make the program more readable, and this is perfectly legal since the declarations are local to the program. The variables declared for this program and their purpose are as follows:sembuf[10]: used as an array buffer (line 14) to contain a maximum of ten sembuf type structures; ten equals SEMOPM, the maximum number of operations on a semaphore set for each semop() system call*sops: used as a pointer (line 14) to sembuf[10] for the system call and for accessing the structure members within the arrayrtrn: used to store the return values from the system callflags: used to store the code of the IPC_NOWAIT or SEM_UNDO flags for the semop() system call (line 60)i: used as a counter (line 32) for initializing the structure members in the array, and used to print out each structure in the array (line 79)nsops: used to specify the number of semaphore operations for the system call-must be less than or equal to SEMOPMsemid: used to store the desired semaphore set identifier for the system callFirst, the program prompts for a semaphore set identifier that the system call is to perform operations on (lines 19-22). Semid is stored in the semid variable (line 23).A message is displayed requesting the number of operations to be performed on this set (lines 25-27). The number of operations is stored in the nsops variable (line 28).Next, a loop is entered to initialize the array of structures (lines 30-77). The semaphore number, operation, and operation command (flags) are entered for each structure in the array. The number of structures equals the number of semaphore operations (nsops) to be performed for the system call, so nsops is tested against the i counter for loop control. Note that sops is used as a pointer to each element (structure) in the array, and sops is incremented just like i. sops is then used to point to each member in the structure for setting them.After the array is initialized, all of its elements are printed out for feedback (lines 78-85).The sops pointer is set to the address of the array (lines 86, 87). Sembuf could be used directly, if desired, instead of sops in the system call.The system call is made (line 89), and depending upon success or failure, a corresponding message is displayed. The results of the operation(s) can be viewed by using semctl() with the GETALL control command.The example program for the semop() system call is shown in 
IDREF="76840" TYPE="TEXT"Example 6-6
.LBL="6-6"Example 6-6 ID="76840"semop() System Call ExampleID="06.ipc81"1  /*This is a program to illustrate
2   *the semaphore operations, semop(), 
3   *system call capabilities. 
4   */
5  /*Include necessary header files.*/ 
6  #include <stdio.h>
7  #include <sys/types.h>
8  #include <sys/ipc.h> 
9  #include <sys/sem.h> 
10  *Start of main C language program*/ 
11  main() 
12  { 
13   extern int errno; 
14   struct sembuf sembuf[10], *sops;
15   char string[]; 
16   int retrn, flags, sem_num, i, semid; 
17   unsigned nsops; 
18   sops = sembuf; /*Pointer to array sembuf.*/
19   /*Enter the semaphore ID.*/
20   printf("\nEnter the semid of\n");
21   printf("the semaphore set to\n"); 
22   printf("be operated on = "); 
23   scanf("%d", &semid); 
24   printf("ensemid = %d", semid);
25   /*Enter the number of operations.*/
26   printf("\nEnter the number of semaphore\n"); 
27   printf("operations for this set = "); 
28   scanf("%d", &nsops); 
29   printf("ennosops = %d", nsops);
30   /*Initialize the array for the 
31     number of operations to be performed.*/ 
32   for(i = 0; i < nsops; i++, sops++) 
33   {
34    /*This determines the semaphore in
35    the semaphore set.*/
36    printf("\nEnter the semaphore\n"); 
37    printf("number (sem_num) = "); 
38    scanf("%d", &sem_num); 
39    sops->sem_num = sem_num; 
40    printf("\nThe sem_num = %d", sops->sem_num);

41    /*Enter a (-)number to decrement,
42      an unsigned number (no +) to increment, 
43      or zero to test for zero. These values 
44      are entered into a string and converted
45      to integer values.*/ 
46    printf("\nEnter the operation for\n"); 
47    printf("the semaphore (sem_op) = "); 
48    scanf("%s", string); 
49    sops->sem_op = atoi(string);
50    printf("ensem_op = %d\n", sops->sem_op);
51    /*Specify the desired flags.*/ 
52    printf("\nEnter the corresponding\n"); 
53    printf("number for the desired\n"); 
54    printf("flags:\n"); 
55    printf("No flags = 0\n");
56    printf("IPC_NOWAIT = 1\n"); 
57    printf("SEM_UNDO = 2\n");
58    printf("IPC_NOWAIT and SEM_UNDO = 3\n"); 
59    printf(" Flags = "); 
60    scanf("%d", &flags);
61    switch(flags) 
62    { 
63    case 0: 
64     sops->sem_flg = 0;
65     break; 
66    case 1: 
67     sops->sem_flg = IPC_NOWAIT;
68     break; 
69    case 2:
70     sops->sem_flg = SEM_UNDO;
71     break;
72    case 3:
73     sops->sem_flg = IPC_NOWAIT | SEM_UNDO; 
74     break;
75    } 
76    printf("\nFlags = 0%o\n", sops->sem_flg); 
77   }
78   /*Print out each structure in the array.*/ 
79   for(i = 0; i < nsops; i++)
80   { 
81    printf("\nsem_num = %d\n", sembuf[i].sem_num); 
82    printf("sem_op = %d\n", sembuf[i].sem_op); 
83    printf("sem_flg = %o\n", sembuf[i].sem_flg);
84    printf("%c", ' '); 
85   }

86   sops = sembuf; /*Reset the pointer to
87         sembuf[0].*/
88   /*Do the semop system call.*/ 
89   retrn = semop(semid, sops, nsops); 
90   if(retrn == -1) {
91    printf("\nSemop failed. ");
92    printf("Error = %d\n", errno);
93   } 
94   else { 
95    printf ("\nSemop was successful\n"); 
96    printf("for semid = %d\n", semid);
97    printf("Value returned = %d\n", retrn); 
98   }
99  }LBL="" HELPID=""System V Shared MemoryShared memory IPC allows two or more executing processes to share memory and consequently the data contained there. This is done by allowing processes to set up access to a common virtual memory address space. This sharing occurs on a segment basis, which is memory management hardware dependent.ID="06.ipc82"This sharing of memory provides the fastest means of exchanging data between processes.A process initially creates a shared memory segment facility using the shmget() system call. Upon creation, this process sets the overall operation permissions for the shared memory segment facility, sets its size in bytes, and can specify that the shared memory segment is for reference only (read-only) upon attachment. If the memory segment is not specified to be for reference only, all other processes with appropriate operation permissions can read from or write to the memory segment.There are two operations that can be performed on a shared memory segment:ID="06.ipc83"shmat() - shared memory attachshmdt() - shared memory detachShared memory attach allows processes to associate themselves with the shared memory segment if they have permission. They can then read or write as allowed.Shared memory detach allows processes to disassociate themselves from a shared memory segment. Therefore, they lose the ability to read from or write to the shared memory segment.The original owner/creator of a shared memory segment can relinquish ownership to another process using the ID="06.ipc84"shmctl() system call. However, the creating process remains the creator until the facility is removed or the system is reinitialized. Other processes with permission can perform other functions on the shared memory segment using the shmctl() system call.System calls, which are documented in the IRIX manual pages, make these shared memory capabilities available to processes. The calling process passes arguments to a system call, and the system call attempts to perform its function. If the system call is successful, it performs its function and returns the appropriate information. Otherwise, a known error code (-1) is returned to the process, and the external variable errno is set accordingly.LBL="" HELPID=""Using Shared MemoryThe sharing of memory between processes occurs on a virtual segment basis. There is one and only one instance of an individual shared memory segment existing in the UNIX operating system at any point in time.ID="06.ipc85"Before sharing of memory can be realized, a uniquely identified shared memory segment and data structure must be created. The unique identifier created is called the shared memory identifier (shmid); it is used to identify or reference the associated data structure. The data structure includes the following for each shared memory segment:operation permissionssegment sizesegment descriptorprocess identification performing last operationprocess identification of creatorcurrent number of processes attachedin memory number of processes attachedlast attach timelast detach timelast change timeThe definition for the shared memory segment data structure is located in the /usr/include/sys/shm.h header file. It is as follows: /*
† †* There is a shared mem id data structure for 
† †* each segment in the system. 
† †*/

struct shmid_ds {
struct ipc_perm shm_perm; /* operation permission struct */
int shm_segsz; /* segment size */
struct region *shm_reg; /* ptr to region structure */
char pad[4]; /* for swap compatibility */
ushort shm_lpid; /* pid of last shmop */
ushort shm_cpid; /* pid of creator */
ushort shm_nattch; /* used only for shminfo */
ushort shm_cnattch; /* used only for shminfo */
time_t shm_atime; /* last shmat time */
time_t shm_dtime; /* last shmdt time */
time_t shm_ctime; /* last change time */ };Note that the shm_perm member of this structure uses ipc_perm as a template. The ipc_perm data structure is the same for all IPC facilities, and is located in the /usr/include/sys/ipc.h header file.The ID="06.ipc86"shmget() system call is used to perform two tasks when only the IPC_CREAT flag is set in the shmflg argument that it receives:to get a new shmid and create an associated shared memory segment data structure for itto return an existing shmid that already has an associated shared memory segment data structureThe task performed is determined by the value of the key argument passed to the shmget() system call. For the first task, if the key is not already in use for an existing shmid, a new shmid is returned with an associated shared memory segment data structure created for it provided no system tunable parameters would be exceeded.There is also a provision for specifying a key of value zero which is known as the private key (IPC_PRIVATE = 0); when specified, a new shmid is always returned with an associated shared memory segment data structure created for it unless a system tunable parameter would be exceeded. When the ID="06.ipc87"ipcs command is performed, the KEY field for the shmid is all zeros.For the second task, if a shmid exists for the key specified, the value of the existing shmid is returned. If you do not want to have an existing shmid returned, a control command (IPC_EXCL) can be set in the shmflg argument passed to the system call. The details of using this system call are discussed in IDREF="24446" TYPE="TITLE""Getting Shared Memory Segments with shmget()."When performing the first task, the process that calls shmget() becomes the owner/creator, and the associated data structure is initialized accordingly. Remember, ownership can be changed, but the creating process always remains the creator; see IDREF="11400" TYPE="TITLE""Controlling Shared Memory: shmctl()."
 The creator of the shared memory segment also determines the initial operation permissions for it.Once a uniquely-identified shared memory segment data structure is created, shared memory segment operations and control can be used.Shared memory segment operations consist of attaching and detaching shared memory segments. System calls are provided for each of these operations; they are shmat() and shmdt(). Refer to IDREF="36245" TYPE="TITLE""Operations for Shared Memory: shmat() and shmdt()"
 for details of these system calls.Shared memory segment control is done by using the ID="06.ipc88"shmctl() system call. It permits you to control the shared memory facility in the following ways:to determine the associated data structure status for a shared memory segment (shmid)to change operation permissions for a shared memory segmentto remove a particular shmid from the UNIX operating system along with its associated shared memory segment data structureto lock a shared memory segment in memoryto unlock a shared memory segmentRefer to IDREF="11400" TYPE="TITLE""Controlling Shared Memory: shmctl()"
 for details of the shmctl() system call.LBL="" HELPID=""ID="24446"Getting Shared Memory Segments with shmget()This section gives a detailed description of using the ID="06.ipc89"shmget() system call along with an example program illustrating its use.The synopsis found in the shmget(2) manual page is as follows:#include <sys/types.h> 
#include <sys/ipc.h> 
#include <sys/shm.h>

int shmget (key, size, shmflg)
key_t key;
int size, shmflg;All of these include files are located in the /usr/include/sys directory of the UNIX operating system.The integer returned from this function upon successful completion is the shared memory identifier (shmid) that was discussed earlier.As declared, the process calling the shmget() system call must supply three arguments to be passed to the formal key, size, and shmflg arguments.A new ID="06.ipc90"shmid with an associated shared memory data structure is provided if eitherkey is equal to IPC_PRIVATE,orkey is passed a unique hexadecimal integer, and shmflg ANDed with IPC_CREAT is TRUE.The value passed to the shmflg argument must be an integer type octal value and will specify the following:access permissionsexecution modescontrol fields (commands)Access permissions determine the read/write attributes and execution modes determine the user/group/other attributes of the ID="06.ipc91"shmflg argument. They are collectively referred to as "operation permissions." IDREF="44355" TYPE="TABLE"Table 6-6
 shows the numeric values (expressed in octal notation) for the valid operation permissions codes.COLUMNS="2"LBL="6-6"Table 6-6 ID="44355"Operation Permissions CodesLEFT="0" WIDTH="171"Operation PermissionsLEFT="180" WIDTH="356"Octal ValuesLEFT="0" WIDTH="171"Read by UserLEFT="180" WIDTH="356"00400LEFT="0" WIDTH="171"Write by UserLEFT="180" WIDTH="356"00200LEFT="0" WIDTH="171"Read by GroupLEFT="180" WIDTH="356"00040LEFT="0" WIDTH="171"Write by GroupLEFT="180" WIDTH="356"00020LEFT="0" WIDTH="171"Read by OthersLEFT="180" WIDTH="356"00004LEFT="0" WIDTH="171"Write by OthersLEFT="180" WIDTH="356"00002A specific octal value is derived by adding the octal values for the operation permissions desired. That is, if read by user and read/write by others is desired, the code value would be 00406 (00400 plus 00006). There are constants located in the shm.h header file which can be used for the owner. They are as follows: SHM_R 0400
SHM_W 0200Control commands are predefined constants (represented by all uppercase letters). ID="06.ipc92"IDREF="18335" TYPE="TABLE"Table 6-7
 contains the names of the constants that apply to the shmget() system call along with their values. They are also referred to as flags and are defined in the ipc.h header file.COLUMNS="2"LBL="6-7"Table 6-7 ID="18335"Control Commands (Flags)LEFT="0" WIDTH="171"ControlLEFT="180" WIDTH="356"ValueLEFT="0" WIDTH="171"IPC_CREATLEFT="180" WIDTH="356"0001000LEFT="0" WIDTH="171"IPC_EXCLLEFT="180" WIDTH="356"0002000The value for shmflg is, therefore, a combination of operation permissions and control commands. After determining the value for the operation permissions as previously described, the desired flag(s) can be specified. This is accomplished by bitwise ORing (|) them with the operation permissions; the bit positions and values for the control commands in relation to those of the operation permissions make this possible.The shmflg value can be easily set by using the names of the flags in conjunction with the octal operation permissions value:shmid = shmget (key, size, (IPC_CREAT | 0400));
shmid = shmget (key, size, (IPC_CREAT | IPC_EXCL | 0400));As specified by the shmget(2) manual page, success or failure of this system call depends upon the argument values for key, size, and shmflg or system tunable parameters. The system call will attempt to return a new shmid if one of the following conditions is true:key is equal to IPC_PRIVATE (0).key does not already have a shmid associated with it, and (shmflg & IPC_CREAT) is "true" (not zero).The key argument can be set to IPC_PRIVATE in the following ways:shmid = shmget (IPC_PRIVATE, size, shmflg);orshmid = shmget (0, size, shmflg);This alone will cause the system call to be attempted because it satisfies the first condition specified. Exceeding the SHMMNI system-tunable parameter always causes a failure. The SHMMNI system-tunable parameter determines the maximum number of unique shared memory segments (ID="06.ipc93"shmids) in the UNIX operating system.The second condition is satisfied if the value for key is not already associated with a shmid and the bitwise ANDing of shmflg and IPC_CREAT is "true" (not zero). This means that the key is unique (not in use) within the UNIX operating system for this facility type and that the IPC_CREAT flag has been set (by using shmflg | IPC_CREAT). SHMMNI applies here also, just as for condition one.IPC_EXCL is another control command used in conjunction with IPC_CREAT to exclusively have the system call fail if, and only if, a ID="06.ipc94"shmid exists for the specified key provided. This is necessary to prevent the process from thinking that it has received a new (unique) shmid when it has not. In other words, when both IPC_CREAT and IPC_EXCL are specified, a unique shmid is returned if the system call is successful. Any value for shmflg returns a new shmid if the key equals zero (IPC_PRIVATE).The system call will fail if the value for the size argument is less than SHMMIN or greater than SHMMAX. These tunable parameters specify the minimum and maximum shared memory segment sizes.ID="06.ipc95"Refer to the shmget(2) manual page for specific associated data structure initialization for successful completion. The specific failure conditions with error names are contained there also.LBL="" HELPID=""Example ProgramThe example program in this section (
ID="06.ipc96"IDREF="75612" TYPE="TEXT"Example 6-7
) is a menu-driven program which allows all possible combinations of using the shmget() system call to be exercised.From studying this program, you can observe the method of passing arguments and receiving return values. The program requirements are pointed out.This program begins (lines 4-7) by including the required header files as specified by the shmget(2) manual page. Note that the errno.h header file is included as opposed to declaring errno as an external variable; either method will work.Variable names have been chosen to be as close as possible to those in the synopsis for the system call. Their declarations are self-explanatory. These names make the program more readable, and this is perfectly legal since they are local to the program. The variables declared for this program and their purposes are as follows:key: used to pass the value for the desired keyopperm: used to store the desired operation permissionsflags: used to store the desired control commands (flags)opperm_flags: used to store the combination from the logical ORing of the opperm and flags variables; it is then used in the system call to pass the shmflg argumentshmid: used for returning the message queue identification number for a successful system call or the error code (-1) for an unsuccessful onesize: used to specify the shared memory segment size.The program begins by prompting for a hexadecimal key, an octal operation permissions code, and finally for the control command combinations (flags) which are selected from a menu (lines 14-31). All possible combinations are allowed even though they might not be viable. This allows observing the errors for illegal combinations.Next, the menu selection for the flags is combined with the operation permissions, and the result is stored in the opperm_flags variable (lines 35-50).A display then prompts for the size of the shared memory segment, which is stored in the size variable (lines 51-54).The system call is made next, and the result is stored in the shmid variable (line 56).Since the shmid variable now contains a valid message queue identifier or the error code (-1), it is tested to see if an error occurred (line 58). If shmid equals -1, a message indicates that an error resulted and the external errno variable is displayed (lines 60, 61).If no error occurred, the returned shared memory segment identifier is displayed (line 65).The example program for the shmget() system call is shown in 
IDREF="75612" TYPE="TEXT"Example 6-7
.LBL="6-7"Example 6-7 ID="75612"shmget() System Call Example 1  /*This is a program to illustrate 
2   *the shared memory get, shmget(), 
3   *system call capabilities.*/
4  #include <sys/types.h> 
5  #include <sys/ipc.h> 
6  #include <sys/shm.h>
7  #include <errno.h>
8  /*Start of main C language program*/ 
9  main() 
10  { 
11   key_t key; /*declare as long integer*/ 
12   int opperm, flags; 
13   int shmid, size, opperm_flags; 
14   /*Enter the desired key*/ 
15   printf("Enter the desired key in hex = "); 
16   scanf("%x", &key);
17   /*Enter the desired octal operation 
18     permissions.*/
19   printf("\nEnter the operation\n"); 
20   printf("permissions in octal = ");
21   scanf("%o", &opperm);
22   /*Set the desired flags.*/
23   printf("\nEnter corresponding number to\n"); 
24   printf("set the desired flags:\n"); 
25   printf("No flags = 0\n"); 
26   printf("IPC_CREAT = 1\n"); 
27   printf("IPC_EXCL = 2\n"); 
28   printf("IPC_CREAT and IPC_EXCL = 3\n"); 
29   printf(" Flags = "); 
30   /*Get the flag(s) to be set.*/ 
31   scanf("%d", &flags);
32   /*Check the values.*/
33   printf ("\nkey =0x%x, opperm = 0%o, flags = 0%o\n", 
34    key, opperm, flags);
35   /*Incorporate the control fields (flags) with 
36     the operation permissions*/
37   switch (flags) 
38   { 
39   case 0: /*No flags are to be set.*/
40    opperm_flags = (opperm | 0); 
41    break; 
42   case 1: /*Set the IPC_CREAT flag.*/ 
43    opperm_flags = (opperm | IPC_CREAT);
44    break;
45   case 2: /*Set the IPC_EXCL flag.*/
46    opperm_flags = (opperm | IPC_EXCL);
47    break; 
48   case 3: /*Set the IPC_CREAT and IPC_EXCL flags.*/
49    opperm_flags = (opperm | IPC_CREAT | IPC_EXCL); 
50   }
51   /*Get the size of the segment in bytes.*/
52   printf ("\nEnter the segment"); 
53   printf ("\nsize in bytes = ");
54   scanf ("%d", &size);
55   /*Call the shmget system call.*/
56   shmid = shmget (key, size, opperm_flags);
57   /*Perform the following if the call is unsuccessful.*/ 
58   if(shmid == -1)
59   {
60    printf ("\nThe shmget system call failed!\n");
61    printf ("The error number = %d\n", errno); 
62   } 
63   /*Return the shmid upon successful completion.*/ 
64   else 
65    printf ("\nThe shmid = %d\n", shmid); 
66   exit(0);
67  }LBL="" HELPID=""ID="11400"Controlling Shared Memory: shmctl()This section gives a detailed description of using the ID="06.ipc97"shmctl() system call along with an example program which allows all of its capabilities to be exercised.The synopsis found in the shmctl(2) manual page is as follows: #include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>

int shmctl (shmid, cmd, buf)
int shmid, cmd;
struct shmid_ds *buf;The shmctl() system call requires three arguments to be passed to it, and it returns an integer value.Upon successful completion, a zero value is returned; and when unsuccessful, shmctl() returns a -1.The shmid variable must be a valid, non-negative, integer value. In other words, it must have already been created by using the shmget() system call.The cmd argument can be replaced by one of following control commands (flags):IPC_STAT: return the status information contained in the associated data structure for the specified shmid and place it in the data structure pointed to by the *buf pointer in the user memory areaIPC_SET: for the specified shmid, set the effective user and group identification, and operation permissionsIPC_RMID: remove the specified shmid along with its associated shared memory segment data structureSHM_LOCK: lock the specified shared memory segment in memory, must be super-userSHM_UNLOCK: unlock the shared memory segment from memory, must be super-user.A process must have an effective user identification of OWNER/CREATOR or super-user to perform an IPC_SET or IPC_RMID control command. Only the super-user can perform a SHM_LOCK or SHM_UNLOCK control command. A process must have read permission to perform the IPC_STAT control command.The details of this system call are discussed in the example program for it. If you have problems understanding the logic manipulations in this program, read IDREF="24446" TYPE="TITLE""Getting Shared Memory Segments with shmget()"
; it goes into more detail than would be practical to do for every system call.LBL="" HELPID=""Example ProgramThe example program in this section (
ID="06.ipc98"IDREF="78805" TYPE="TEXT"Example 6-8
) is a menu-driven program which allows all possible combinations of using the shmctl() system call to be exercised.From studying this program, you can observe the method of passing arguments and receiving return values. The user-written program requirements are pointed out.This program begins (lines 5-9) by including the required header files as specified by the shmctl(2) manual page. Note in this program that errno is declared as an external variable, and therefore, the errno.h header file does not have to be included.Variable and structure names have been chosen to be as close as possible to those in the synopsis for the system call. Their declarations are self-explanatory. These names make the program more readable, and it is perfectly legal since they are local to the program. The variables declared for this program and their purposes are as follows:uid: used to store the IPC_SET value for the effective user identificationgid: used to store the IPC_SET value for the effective group identificationmode: used to store the IPC_SET value for the operation permissionsrtrn: used to store the return integer value from the system callshmid: used to store and pass the shared memory segment identifier to the system callcommand: used to store the code for the desired control command so that subsequent processing can be performed on itchoice: used to determine which member for the IPC_SET control command that is to be changedshmid_ds: used to receive the specified shared memory segment identifier's data structure when an IPC_STAT control command is performed*buf: a pointer passed to the system call which locates the data structure in the user memory area where the IPC_STAT control command is to place its return values or where the IPC_SET command gets the values to set.Note that the shmid_ds data structure in this program (line 16) uses the data structure located in the shm.h header file of the same name as a template for its declaration. This is a perfect example of the advantage of local variables.The next important thing to observe is that although the *buf pointer is declared to be a pointer to a data structure of the shmid_ds type, it must also be initialized to contain the address of the user memory area data structure (line 17).Now that all of the required declarations have been explained for this program, this is how it works.First, the program prompts for a valid shared memory segment identifier which is stored in the shmid variable (lines 18-20). This is required for every shmctl() system call.Then, the code for the desired control command must be entered (lines 21-29), and it is stored in the command variable. The code is tested to determine the control command for subsequent processing.If the IPC_STAT control command is selected (code 1), the system call is performed (lines 39, 40) and the status information returned is printed out (lines 41-71). Note that if the system call is unsuccessful (line 146), the status information of the last successful call is printed out. In addition, an error message is displayed and the errno variable is printed out (lines 148, 149). If the system call is successful, a message indicates this along with the shared memory segment identifier used (lines 151-154).If the IPC_SET control command is selected (code 2), the first thing done is to get the current status information for the message queue identifier specified (lines 90-92). This is necessary because this example program provides for changing only one member at a time, and the system call changes all of them. Also, if an invalid value happened to be stored in the user memory area for one of these members, it would cause repetitive failures for this control command until corrected. The next thing the program does is to prompt for a code corresponding to the member to be changed (lines 93-98). This code is stored in the choice variable (line 99). Now, depending upon the member picked, the program prompts for the new value (lines 105-127). The value is placed in the appropriate member in the user memory area data structure, and the system call is made (lines 128-130). Depending upon success or failure, the program returns the same messages as for IPC_STAT above.If the IPC_RMID control command (code 3) is selected, the system call is performed (lines 132-135), and the shmid along with its associated message queue and data structure are removed from the UNIX operating system. Note that the *buf pointer is not required as an argument to perform this control command and its value can be zero or NULL. Depending upon the success or failure, the program returns the same messages as for the other control commands.If the SHM_LOCK control command (code 4) is selected, the system call is performed (lines 137,138). Depending upon the success or failure, the program returns the same messages as for the other control commands.If the SHM_UNLOCK control command (code 5) is selected, the system call is performed (lines 140-142). Depending upon the success or failure, the program returns the same messages as for the other control commands.The example program for the shmctl() system call is shown in 
IDREF="78805" TYPE="TEXT"Example 6-8
.LBL="6-8"Example 6-8 ID="78805"shmctl() System Call Example 1  /*This is a program to illustrate 
2   *the shared memory control, shmctl(), 
3   *system call capabilities. 
4   */
5  /*Include necessary header files.*/ 
6  #include <stdio.h> 
7  #include <sys/types.h> 
8  #include <sys/ipc.h> 
9  #include <sys/shm.h>
10  /*Start of main C language program*/ 
11  main() 
12  {
13   extern int errno; 
14   int uid, gid, mode; 
15   int rtrn, shmid, command, choice;
16   struct shmid_ds shmid_ds, *buf; 
17   buf = &shmid_ds;
18   /*Get the shmid, and command.*/ 
19   printf("Enter the shmid = "); 
20   scanf("%d", &shmid); 
21   printf("\nEnter the number for\n"); 
22   printf("the desired command:\n");
23   printf("IPC_STAT = 1\n"); 
24   printf("IPC_SET = 2\n"); 
25   printf("IPC_RMID = 3\n"); 
26   printf("SHM_LOCK = 4\n"); 
27   printf("SHM_UNLOCK = 5\n"); 
28   printf("Entry = "); 
29   scanf("%d", &command);
30   /*Check the values.*/
31   printf ("\nshmid =%d, command = %d\n", 
32   shmid, command);
33   switch (command)
34   { 
35   case 1: /*Use shmctl() to duplicate 
36    the data structure for 
37     shmid in the shmid_ds area pointed 
38     to by buf and then print it out.*/
39    rtrn = shmctl(shmid, IPC_STAT, 
40     buf); 
41    printf ("\nThe USER ID = %d\n", 
42     buf->shm_perm.uid); 
43    printf ("The GROUP ID = %d\n", 
44     buf->shm_perm.gid); 
45    printf ("The creator's ID = %d\n",
46     buf->shm_perm.cuid); 
47    printf ("The creator's group ID = %d\n",
48     buf->shm_perm.cgid); 
49    printf ("The operation permissions = 0%o\n", 
50     buf->shm_perm.mode); 
51    printf ("The slot usage sequenceen");
52    printf ("number = 0%x\n", 
53     buf->shm_perm.seq); 
54    printf ("The key= 0%x\n", 
55     buf->shm_perm.key); 
56    printf ("The segment size = %d\n", 
57     buf->shm_segsz); 
58    printf ("The pid of last shmop = %d\n", 
59     buf->shm_lpid);
60    printf ("The pid of creator = %d\n", 
61     buf->shm_cpid); 
62    printf ("The current # attached = %d\n", 
63     buf->shm_nattch); 
64    printf("The in memory # attached = %d\n", 
65     buf->shm_cnattach); 
66    printf("The last shmat time = %d\n", 
67     buf->shm_atime); 
68    printf("The last shmdt time = %d\n",
69     buf->shm_dtime);
70    printf("The last change time = %d\n", 
71     buf->shm_ctime); 
72    break;
   /* Lines 73 - 87 deleted */
88   case 2: /*Select and change the desired
89       member(s) of the data structure.*/
90    /*Get the original data for this shmid 
91       data structure first.*/ 
92    rtrn = shmctl(shmid, IPC_STAT, buf);
93    printf("\nEnter the number for the\n"); 
94    printf("member to be changed:\n"); 
95    printf("shm_perm.uid = 1\n");
96    printf("shm_perm.gid = 2\n"); 
97    printf("shm_perm.mode = 3\n"); 
98    printf("Entry = ");
99    scanf("%d", &choice); 
100    /*Only one choice is allowed per 
101    pass as an illegal entry will
102      cause repetitive failures until
103     shmid_ds is updated with 
104      IPC_STAT.*/
105    switch(choice){
106    case 1: 
107     printf("\nEnter USER ID = "); 
108     scanf ("%d", &uid); 
109     buf->shm_perm.uid = uid; 
110     printf("\nUSER ID = %d\n", 
111     buf->shm_perm.uid); 
112     break;
113    case 2: 
114     printf("\nEnter GROUP ID = "); 
115     scanf("%d", &gid); 
116     buf->shm_perm.gid = gid; 
117     printf("\nGROUP ID = %d\n", 
118     buf->shm_perm.gid); 
119     break;

120    case 3: 
121     printf("\nEnter MODE = "); 
122     scanf("%o", &mode); 
123     buf->shm_perm.mode = mode; 
124     printf("\nMODE = 0%o\n", 
125      buf->shm_perm.mode); 
126     break; 
127    } 
128    /*Do the change.*/ 
129    rtrn = shmctl(shmid, IPC_SET, 
130     buf); 
131    break;
132    case 3: /*Remove the shmid along with its 
133        associated 
134        data structure.*/
135     rtrn = shmctl(shmid, IPC_RMID, NULL); 
136     break;
137    case 4: /*Lock the shared memory segment*/ 
138     rtrn = shmctl(shmid, SHM_LOCK, NULL);
139     break; 
140    case 5: /*Unlock the shared memory
141        segment.*/
142     rtrn = shmctl(shmid, SHM_UNLOCK, NULL); 
143     break; 
144    } 
145    /*Perform the following if the call fails.*/ 
146    if(rtrn == -1) 
147    { 
148     printf ("\nThe shmctl system call failed!\n"); 
149     printf ("The error number = %d\n", errno); 
150    } 
151    /*Return the shmid upon successful completion.*/ 
152    else 
153     printf ("\nShmctl was successful for shmid = %d\n", 
154      shmid);
155    exit (0);
156   }LBL="" HELPID=""ID="36245"Operations for Shared Memory: shmat() and shmdt()This section gives a detailed description of using the ID="06.ipc99"shmat() and shmdt() system calls, along with an example program which allows all of their capabilities to be exercised.The synopsis found in the shmop(2) manual page, which includes both shmat() and shmaddr(), is as follows: #include <sys/types.h> 
#include <sys/ipc.h> 
#include <sys/shm.h>

char *shmat (shmid, shmaddr, shmflg)
int shmid; 
char *shmaddr;
int shmflg;

int shmdt (shmaddr) 
char *shmaddr;LBL="" HELPID=""Attaching to a Shared Memory SegmentThe ID="06.ipc100"shmat() system call requires three arguments to be passed to it, and it returns a character pointer value.The system call can be cast to return an integer value. Upon successful completion, this value will be the address in core memory where the process is attached to the shared memory segment, and when unsuccessful it will be a -1.The shmid argument must be a valid, non-negative, integer value. In other words, it must have already been created by using the shmget() system call.The shmaddr argument can be zero or user-supplied when passed to the shmat() system call. If it is zero, the UNIX operating system picks the address of where the shared memory segment will be attached. If it is user supplied, the address must be a valid address that the UNIX operating system would pick. Here are some typical address ranges:0xc00c00000xc00e00000xc01000000xc0120000Note that these addresses are in chunks of 20,000 hexadecimal. It would be wise to let the operating system pick addresses so as to improve portability.The shmflg argument is used to pass the SHM_RND and SHM_RDONLY flags to the shmat() system call.Further details are discussed in the example program for shmop(). If you have problems understanding the logic manipulations in this program, read IDREF="24446" TYPE="TITLE""Getting Shared Memory Segments with shmget()"
; it goes into more detail than would be practical to do for every system call.LBL="" HELPID=""Detaching Shared Memory SegmentsThe ID="06.ipc101"shmdt() system call requires one argument to be passed to it, and it returns an integer value.shmdt() returns zero if it completes successfully and -1 otherwise.Further details of this system call are discussed in the example program. If you have problems understanding the logic manipulations in this program, read IDREF="24446" TYPE="TITLE""Getting Shared Memory Segments with shmget()"
; it goes into more detail than what would be practical to do for every system call.LBL="" HELPID=""Example ProgramThe example program in this section (Figure 8-17) is a menu-driven program which allows all possible combinations of using the ID="06.ipc102"shmat() and shmdt() system calls to be exercised.From studying this program, you can observe the method of passing arguments and receiving return values. The program requirements are pointed out.This program begins (lines 5-9) by including the required header files as specified by the shmop(2) manual page. Note that in this program that errno is declared as an external variable, and therefore, the errno.h header file does not have to be included.Variable and structure names have been chosen to be as close as possible to those in the synopsis. Their declarations are self-explanatory. These names make the program more readable, and this is perfectly legal since they are local to the program. The variables declared for this program and their purposes are as follows:flags: used to store the codes of SHM_RND or SHM_RDONLY for the shmat() system calladdr: used to store the address of the shared memory segment for the shmat() and shmdt() system callsi: used as a loop counter for attaching and detachingattach: used to store the desired number of attach operationsshmid: used to store and pass the desired shared memory segment identifiershmflg: used to pass the value of flags to the shmat() system callrtrn: used to store the return values from both system callsdetach: used to store the desired number of detach operationsThis example program combines both the shmat() and shmdt() system calls. The program prompts for the number of attachments and enters a loop until they are done for the specified shared memory identifiers. Then, the program prompts for the number of detachments to be performed and enters a loop until they are done for the specified shared memory segment addresses.LBL="" HELPID=""shmat()The program prompts for the number of attachments to be performed, and the value is stored in the attach variable (lines 17-21).A loop is entered using the attach variable and the i counter (lines 23-70) to perform the specified number of attachments.In this loop, the program prompts for a shared memory segment identifier (lines 24-27) and it is stored in the shmid variable (line 28). Next, the program prompts for the address where the segment is to be attached (lines 30-34), and it is stored in the addr variable (line 35). Then, the program prompts for the desired flags to be used for the attachment (lines 37-44), and the code representing the flags is stored in the flags variable (line 45). The flags variable is tested to determine the code to be stored for the shmflg variable used to pass them to the shmat() system call (lines 46-57). The system call is made (line 60). If successful, a message stating so is displayed along with the attach address (lines 66-68). If unsuccessful, a message stating so is displayed and the error code is displayed (lines 62, 63). The loop then continues until it finishes.LBL="" HELPID=""shmdtAfter the attach loop completes, the program prompts for the number of detach operations to be performed (lines 71-75), and the value is stored in the detach variable (line 76).A loop is entered using the detach variable and the i counter (lines 78-95) to perform the specified number of detachments.In this loop, the program prompts for the address of the shared memory segment to be detached (lines 79-83), and it is stored in the addr variable (line 84). Then, the shmdt() system call is performed (line 87). If successful, a message stating so is displayed along with the address that the segment was detached from (lines 92,93). If unsuccessful, the error number is displayed (line 89). The loop continues until it finishes.The example program for the shmop() system calls is shown in 
IDREF="34552" TYPE="TEXT"Example 6-9
.LBL="6-9"Example 6-9 ID="34552"shmop() System Call Example1  /*This is a program to illustrate
2   *the shared memory operations, shmop(),
3   *system call capabilities. 
4   */
5  /*Include necessary header files.*/
6  #include <stdio.h> 
7  #include <sys/types.h> 
8  #include <sys/ipc.h> 
9  #include <sys/shm.h> 
10  /*Start of main C language program*/ 
11  main() 
12  { 
13   extern int errno; 
14   int flags, addr, i, attach; 
15   int shmid, shmflg, retrn, detach;
16   /*Loop for attachments by this process.*/ 
17   printf("Enter the number ofen"); 
18   printf("attachments for this\n"); 
19   printf("process (1-4).\n"); 
20   printf(" Attachments = ");
21   scanf("%d", &attach); 
22   printf("Number of attaches = %d\n", attach);
23   for(i = 1; i <= attach; i++) {
24    /*Enter the shared memory ID.*/ 
25    printf("\nEnter the shmid ofen"); 
26    printf("the shared memory segment to\n");
27    printf("be operated on = "); 
28    scanf("%d", &shmid); 
29    printf("\nshmid = %d\n", shmid);
30    /*Enter the value for shmaddr.*/ 
31    printf("\nEnter the value for\n");
32    printf("the shared memory address\n"); 
33    printf("in hexadecimal:\n"); 
34    printf(" Shmaddr = "); 
35    scanf("%x", &addr); 
36    printf("The desired address = 0x%x\n", addr);
37    /*Specify the desired flags.*/ 
38    printf("\nEnter the corresponding\n");
39    printf("number for the desireden"); 
40    printf("flags:\n"); 
41    printf("SHM_RND = 1\n"); 
42    printf("SHM_RDONLY = 2\n"); 
43    printf("SHM_RND and SHM_RDONLY = 3\n");
44    printf(" Flags = "); 
45    scanf("%d", &flags);
46    switch(flags) 
47    { 
48    case 1: 
49     shmflg = SHM_RND; 
50     break; 
51    case 2: 
52     shmflg = SHM_RDONLY; 
53     break;
54    case 3: 
55     shmflg = SHM_RND | SHM_RDONLY; 
56     break;
57    }
58    printf("\nFlags = 0%o\n", shmflg);
59    /*Do the shmat system call.*/ 
60    retrn = (int)shmat(shmid, addr, shmflg); 
61    if(retrn == -1) { 
62     printf("\nShmat failed. "); 
63     printf("Error = %d\n", errno); 
64    } 
65    else { 
66     printf ("\nShmat was successful\n"); 
67     printf("for shmid = %d\n", shmid); 
68     printf("The address = 0x%x\n", retrn); 
69    } 
70   }
71   /*Loop for detachments by this process.*/
72   printf("Enter the number ofen");
73   printf("detachments for this\n"); 
74   printf("process (1-4).\n"); 
75   printf(" Detachments = ");
76   scanf("%d", &detach);
77   printf("Number of attaches = %d\n", detach);
78   for(i = 1; i <= detach; i++) {
79    /*Enter the value for shmaddr.*/
80    printf("\nEnter the value for\n");
81    printf("the shared memory address\n");
82    printf("in hexadecimal:\n");
83    printf(" Shmaddr = ");
84    scanf("%x", &addr);
85    printf("The desired address = 0x%x\n", addr);
86    /*Do the shmdt system call.*/
87    retrn = (int)shmdt(addr);
88    if(retrn == -1) {
89     printf("Error = %d\n", errno);
90    }
91    else {
92     printf ("\nShmdt was successful\n"); 
93     printf("for address = 0%x\n", addr);
94    }
95   }
96  }ID="06.ipc103"LBL="" HELPID=""ID="66587"IRIX IPCTo meet the demands of parallel programming, IRIX provides a set of fast, low-overhead inter-process communication mechanisms. These mechanisms are powerful and easy to use. However, you should remember that they are IRIX-specific, so code using them will not be portable to other systems.Unlike System V IPC mechanisms, which use their own namespace, IRIX IPC mechanisms are associated with the filesystem namespace. To begin using IRIX IPC, a process must specify the name of a file to be used as a shared arena. All processes using the same arena will have access to the same set of IPC mechanisms. This makes it relatively easy for unrelated processes to communicate using IRIX IPC. The shared arena file is mapped into the process's user space, which means that most of the shared arena IPC functions do not have to make system calls. This is one reason that the overhead on IRIX IPC is lower than the overhead on standard System V IPC.IRIX IPC comprises four main mechanisms, two of whichname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'semaphores and shared memoryname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'resemble their System V counterparts. The other mechanisms are spinlocks, simple busy-wait locks for low-level synchronization, and barriers, which provide rendezvous points for multiple processes.Modules using IRIX IPC routines should include <stdio.h> and <ulocks.h>, and should be linked with the libmpc.so shared object (-lmpc).† †For more information on any of the routines presented here, see the appropriate manual pages.LBL="" HELPID=""Initializing the Shared ArenaTo begin using IRIX IPC, call usinit().LBL="" HELPID=""Syntax#include <stdio.h>
#include <ulocks.h>
usptr_t *usinit (const char *filename);The filename variable specifies a file to use as the shared arena. If the file doesn't exist, usinit() will create it. If there is already a shared arena by that name, usinit() will join the shared arena. If the file exists but isn't a shared arena, usinit() will overwrite it. In any case, usinit() is subject to regular filesystem permissions: it will return an error if the process doesn't have read and write permission on the file (if it already exists) or permission to create the file (if it doesn't yet exist).LBL="" HELPID=""Using Shared-Arena SemaphoresTo allocate a new shared-arena semaphore, call usnewsema().LBL="" HELPID=""Syntax#include <ulocks.h>
usptr_t *usnewsema (usptr_t *handle, int initial_value);The initial_value argument simply specifies the initial value of the semaphore. An initial value of zero is commonly used for a synchronization semaphore: the first process that attempts a P operation on the semaphore will block until another process performs a V operation on the semaphore. An initial value of one may be used to provide a simple mutual exclusion semaphore: the first process attempting a P operation on the semaphore will succeed, and subsequent processes will block until the first process releases the semaphore by performing a V operation on it.LBL="" HELPID=""Changing the Values of Shared-Arena SemaphoresTo perform P and V operations on shared arena semaphores, use the uspsema() and usvsema() functions. The uscpsema() function provides a conditional P operation: it will perform a P operation on the semaphore only if it can do so without blocking. The ustestsema() function returns the current value of the semaphore (useful primarily for debugging), and the usinitsema() function reinitializes the semaphore to a specified value. Note that if you reinitialize a semaphore on which processes are waiting, the processes will not be woken.LBL="" HELPID=""Syntax#include <ulocks.h>
int uspsema (usema_t *sema);
int uscpsema (usema_t *sema);
int usvsema (usema_t *sema);
int ustestsema (usema_t *sema);
int usinitsema (usema_t *sema, int initial_value);The following code fragment demonstrates the use of uspsema(), usvsema(), and uscpsema():char *arenafile = "/usr/tmp/testarena";
usptr_t arena;
usema_t *sema;
/* open an arena, allocate a semaphore */
arena = usinit(arenafile);
if (arena == NULL) 
{
† † /* error */
}
sema = usnewsema(arena);
if (sema == NULL) 
{
† † /* error */
}
/* acquire the semaphore */
uspsema(sema);
/* release the semaphore */
usvsema(sema);
/* try to get the semaphore again, without blocking */
if (uscpsema(sema) == 1) 
{
† †/*we succeeded, so we have to release the semaphore again*/
† † usvsema(sema);
}
else
† † /* failed to get the semaphore */

LBL="" HELPID=""Using SpinlocksSpinlocks are somewhat like semaphores. Instead of having an integer value, a spinlock has a binary value: it is either locked or unlocked. The way that spinlocks are implemented depends upon the hardware architecture of the computer using them. On multiprocessor computers, spinlocks are busy-wait locks, so the processor continually tries to acquire the lock until it succeeds. This implementation only makes sense on multiprocessor systems, in which one processor can release the lock while another processor is "spinning" trying to acquire the lock. On single processor machines, spinlocks are implemented using the same algorithm as semaphoresname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'that is, processes waiting to acquire a lock may be put to sleep until the lock is released by another process.To allocate a new spinlock, use usnewlock():LBL="" HELPID=""Syntax#include <ulocks.h>
ulock_t usnewlock (usptr_t *arena);The usnewlock() function returns a lock, which may then be used by the process. Locking and unlocking can be performed with the functions ussetlock(), uscsetlock(), uswsetlock(), and usunsetlock().LBL="" HELPID=""Syntax#include <ulocks.h>
int ussetlock (ulock_t lock);
int uscsetlock (ulock_t lock, unsigned spins);
int uswsetlock (ulock_t lock, unsigned spins);
int usunsetlock (ulock_t lock);The ussetlock() function locks the specified lock. On multiprocessor systems it spins until  it succeeds; on single-processor systems, it may sleep until it can set the lock. It returns 1, unless it encounters an error. The uscsetlock() function tries to set the lock spins times; if it succeeds, it returns 1, if it fails, it returns 0. On a single-processor system, uscsetlock() ignores the spins argument and only sets the lock if it can do so without waiting. The uswsetlock() function resembles ussetlock() except that after every spins attempts to set the lock, it yields the processor by calling sginap(). On single-processor systems, uswsetlock() behaves exactly like ussetlock(). The usunsetlock() function unlocks the lock; it always returns 0, unless it encounters an error. All of these functions return -1 in the event of an error. You can find the reason for the error by calling oserror(). IRIX also provides a function to test whether a given lock is locked or unlocked, ustestlock(). ustestlock() returns 1 if the lock is set, and 0 if the lock is not set.LBL="" HELPID=""Syntax#include <ulocks.h>
int ustestlock (ulock_t lock);A process can call usunsetlock() on a lock that is either not locked or locked by another process. In either case, the lock will be unlocked. Double tripping, that is, calling a set lock function twice with the same lock is also permissible. The caller will block until another process unsets the lock.LBL="" HELPID=""Using BarriersBarriers provide a convenient way of synchronizing parallel processes on multiprocessor systems. To use a barrier, you must first allocate one by calling new_barrier(), which returns a pointer to an initialized barrier structure. You must then communicate this pointer to the other processes (for example, by placing it in a data structure in shared memory). In order to arrange a rendezvous, have each process call barrier(), passing it the pointer to the barrier structure and a numerical argument specifying the number of processes to wait for. Each process will block until the last process calls barrier(). Barriers are always busy-wait, so they aren't suitable for use on single-processor systems.LBL="" HELPID=""Syntax#include <ulocks.h>
barrier_t *new_barrier (usptr_t *handle);
void barrier (barrier_t *b, unsigned n);
void free_barrier (barrier_t *b);
void init_barrier (barrier_t *b);The free_barrier() function releases the resources associated with a barrier. The init_barrier() function restores a barrier to its original state, as if it had just been allocated by new_barrier().LBL="" HELPID=""Using IRIX Shared MemoryAllocating shared memory from a shared arena is much like the regular process of allocating memory using the malloc() and free() library routines. LBL="" HELPID=""Syntax#include <ulocks.h>
#include <malloc.h>
void *usmalloc (size_t size, usptr_t *handle);
void usfree (void *ptr, usptr_t *handle);
void *usrealloc (void *ptr, size_t size, usptr_t *handle);
void *uscalloc (size_t nelem, size_t elsize, usptr_t *handle);
int usmallopt (int cmd, int value, usptr_t *handle);
struct mallinfo usmallinfo (usptr_t *handle);Memory allocated using usmalloc(), and related functions can be accessed by all processes that have joined the shared arena specified by handle. Other than that, these functions operate in the same way as their single-threaded cousins.LBL="" HELPID=""Exchanging the First DatumOnce you've established a shared arena, it's frequently useful to communicate the location of some object in that arena to another process using the arena. For example,one process might create a data structure in shared memory, and pass the address of the data structure to other processes using the arena. The shared arena has a special one-word area for storing such data. This area is accessed using the calls usputinfo(),† †usgetinfo(), and uscasinfo(). The first two are fairly self-explanatory: usputinfo() puts a word of data into the storage area, and usgetinfo() returns the current value in the storage area. uscasinfo() is explained later.LBL="" HELPID=""Syntax#include <ulocks.h>
void usputinfo (usptr_t *handle, void *info);
void *usgetinfo (usptr_t *handle);The following program fragment initializes an arena, allocates space for a data structure, and places the address of the data structure in the storage area. The exact contents of the data structure are left as an exercise for the reader:#include <stdio.h>
#include <ulocks.h>
† † /* ... */
† † usptr_t *arena;
† † char *arenafile = "/usr/tmp/testarena";
† † struct controlStruct *control;
† † arena = usinit(arenafile);
† † if (arena == NULL) {
† †   /* error */
† † }
† † control = usmalloc(sizeof(struct controlStruct), arena);
† † if (control == NULL) {
† †   /* error */
† † }
† † usputinfo(arena, control);The next program fragment accesses the same shared arena created by the previous program fragment, and obtains the address of the previously allocated data structure:#include <stdio.h>
#include <ulocks.h>
† † /* ... */
† † usptr_t *arena;
† † char *arenafile = "/usr/tmp/testarena";
† † struct controlStruct *control;
† † arena = usinit(arenafile);
† † if (arena == NULL) {
† †   /* error */
† † }
† † control = usgetinfo(arena);
† † if (control == NULL) {
† †   /* error */
† † }The simple technique outlined above works fine if you know which process is going to create the arena (for example, if program #1 creates the arena before forking and execing program #2). However, if several processes are started independently and they all try to access the same arena, the situation becomes more complicated. You will probably want one of the processes to set up data structures for the others to use. For this kind of situation, IRIX provides an atomic compare-and-swap operator, uscasinfo(), which compares the current value in the storage area with a specified value, and if these two are equal, changes the value in the storage area to a second specified value.LBL="" HELPID=""Syntax#include <ulocks.h>
int uscasinfo (usptr_t *arena, void *oldinfo, void *newinfo);If the value in the storage area is equal to oldinfo, uscasinfo() will change the value to newinfo and return 1. Otherwise, uscasinfo() will leave the value untouched and return 0. Usually, uscasinfo() will be called with oldinfo equal to zero. The value in the storage area will be zero if no one has placed any data in it yet.The following example program uses uscasinfo() and barrier() to establish communication between multiple unrelated processes:#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <ulocks.h>
#include <string.h>

struct info {
† † barrier_t *wait_barrier;
† † pid_t master_pid;
};

main()
{
† † usptr_t *arena;
† † char *arenafile = "/usr/tmp/testarena";
† † char errstr[128];
† † struct info *data; 
† † pid_t pid;
† † int procs = 4;

† † pid = getpid();
† † arena = usinit(arenafile);
† † if (arena == NULL) 
† † {
† †   sprintf(errstr, "Proc %d couldn't open arena file", pid);
† †   perror(errstr);
† †   exit(1);
† † }
† † data = usgetinfo(arena);
† † if (data == NULL)
† † {
† †   data = usmalloc(sizeof(struct info), arena);
† †   if (data == NULL) 
† †   {
† †     sprintf(errstr, "Proc %d couldn't allocate data", pid);
† †     perror(errstr);
† †     exit(1);
† †   }
† †   data->wait_barrier = new_barrier(arena);
† †   if (uscasinfo(arena, 0, data) == 1)
† †   {
† †     printf("Proc %d is the master ...\n", pid);
† †     data->master_pid = pid;
† †     printf("Proc %d: master process at barrier.\n", pid);
† †     barrier(data->wait_barrier, procs);
† †     /* master process activities */
† †     exit(0);
† †   }
† †   else
† †   {
† †     /* we were beaten out by another process, and must  */
† †     /* free the data structures we allocated       */
† †     free_barrier(data->wait_barrier);
† †     usfree(data, arena);
† †   }
† † }
† † data = usgetinfo(arena);
† † if (data == NULL)
† † {
† †   fprintf(stderr, "Proc %d: no data waiting for slave process.\n", pid);
† †   exit(1);
† † }
† † printf("Proc %d: slave process at barrier.\n", pid);
† † barrier(data->wait_barrier, procs);
† † printf("Proc %d: got data--%d is master process.\n", pid, data->master_pid);
† † /* slave process activities */
† † exit(0);
}To run this example program, you would begin four instances of the program from the command line, like this:uscastest &
uscastest &
uscastest &
uscastest &
LBL="7"ID="82678"File and Record LockingLBL="" HELPID=""An Overview of File and Record LockingMandatory and advisory file and record locking are available on many current releases of the UNIX system. The intent of these capabilities is to provide a synchronization mechanism for programs accessing the same stores of data simultaneously. Such processing is characteristic of many multi-user applications, and the need for a standard method of dealing with the problem has been recognized by standards advocates like ID="07.locking1"ID="07.locking2"/usr/group, an organization of UNIX system users from businesses and campuses across the country.Advisory file and record locking can be used to coordinate self-synchronizing processes. In mandatory locking, on the other hand, the standard I/O subroutines and I/O system calls enforce the locking protocol. In this way, at the cost of a little efficiency, mandatory locking double-checks the programs to avoid accessing the data out of sequence.ID="07.locking3"This chapter describes how file and record locking capabilities can be used. Examples are given for the correct use of record locking. Misconceptions about the amount of protection that record locking affords are dispelled. Record locking should be viewed as a synchronization mechanism, not a security mechanism.The manual pages for the ID="07.locking4"fcntl(2) system call, the lockf(3) library function, and fcntl(5) data structures and commands are referred to throughout this section. You should read them before continuing.ID="07.locking5"LBL="" HELPID=""TerminologyBefore discussing how record locking should be used, let us first define a few terms.ID="07.locking6"RecordA contiguous set of bytes in a file. The UNIX operating system does not impose any record structure on files. Such structure may be imposed by the programs that use the files.ID="07.locking7"Cooperating Processes Processes that work together in some well-defined fashion to accomplish the tasks at hand. Processes that share files must request permission to access the files before using them. File access permissions must be carefully set to restrict non-cooperating processes from accessing those files. The term "process" will be used interchangeably with "cooperating process" to refer to a task obeying such protocols.Read (Share) LocksThese are used to gain limited access to sections of files. When a read lock is in place on a record, other processes may also read lock that record, in whole or in part. No other process, however, may have or obtain a write lock on an overlapping section of the file. If a process holds a read lock it may assume that no other process will be writing or updating that record at the same time. This access method also permits many processes to read the given record. This might be necessary when searching a file, without the contention involved if a write or exclusive lock were to be used.ID="07.locking8"Write (Exclusive) LockThese are used to gain complete control over sections of files. When a write lock is in place on a record, no other process may read- or write-lock that record, in whole or in part. If a process holds a write lock it may assume that no other process will be reading or writing that record at the same time. ID="07.locking9"Advisory LockingA form of record locking that does not interact with the I/O subsystem (which includes ID="07.locking10"creat(2), open(2), read(2), and write(2)). The control over records is accomplished by requiring an appropriate record lock request before I/O operations. If appropriate requests are always made by all processes accessing the file, then the accessibility of the file will be controlled by the interaction of these requests. Advisory locking depends on the individual processes to enforce the record locking protocol; it does not require an accessibility check at the time of each I/O request. † †Mandatory LockingA form of record locking that does interact with the I/O subsystem. Access to locked records is enforced by the ID="07.locking11"creat(2), open(2), read(2), and write(2) system calls. If a record is locked, then access to that record by any other process is restricted according to the type of lock on the record. The control over records should still be performed explicitly by requesting an appropriate record lock before I/O operations, but an additional check is made by the system before each I/O operation to ensure the record locking protocol is being honored. Mandatory locking offers an extra synchronization check, but at the cost of some additional system overhead.LBL="" HELPID=""File ProtectionThere are access permissions for each UNIX file to control who may read, write, or execute the file. These access permissions may only be set by the owner of the file or by the superuser. The permissions of the directory in which the file resides can also affect the access permissions for a file. Note that if the permissions for a directory allow anyone to write in the directory, then files within that directory may be removed even by a user who does not have read, write or execute permission for those files. Any information that is worth protecting, is worth protecting properly. If your application warrants the use of record locking, make sure that the permissions on your files and directories are set properly. A record lock, even a mandatory record lock, will only protect the portions of the files that are locked. Other parts of the files can be corrupted if proper precautions are not taken.ID="07.locking12"Only a known set of programs and/or administrators should be able to read or write a database. This can be done easily by setting the set-group-ID bit (see chmod(1)) of the database accessing programs. The files can then be accessed by a known set of programs that obey the record-locking protocol. An example of such file protection, although record locking is not used, is the mail(1) command. In that command only the owning user and the mail command can read and write the unread mail files.LBL="" HELPID=""Opening a File for Record LockingThe first requirement for locking a file or segment of a file is having a valid open file descriptor. If read locks are to be used, then the file must be opened with at least read access; likewise for write locks and write access. In this example we will open a file for both read and write access:ID="07.locking13"#include <stdio.h>
#include <errno.h>
#include <fcntl.h>
int fd;    /* file descriptor */
char *filename;

main(argc, argv)
int argc;
char *argv[];
{
† †   extern void exit(), perror();

† †   /* get database file name from command line and open the
† †    * file for read and write access. 
† †    */
† †   if (argc < 2) {
† †       (void) fprintf(stderr, "usage: %s filename\n", argv[0]);
† †       exit(2);
† †   }
† †   filename = argv[1];
† †   fd = open(filename, O_RDWR);
† †   if (fd < 0) {
† †       perror(filename);
† †       exit(2);
† †   }
}The file is now open for us to perform both locking and I/O functions. We then proceed with the task of setting a lock.LBL="" HELPID=""Setting a File LockThere are several ways for us to set a lock on a file. In part, these methods depend upon how the lock interacts with the rest of the program. There are also questions of performance as well as portability. Two methods will be given here, one using the ID="07.locking14"fcntl(2) system call, the other using the /usr/group standards-compatible lockf(3) library function call.Locking an entire file is just a special case of record locking. For both these methods the concept and the effect of the lock are the same. The file is locked starting at a byte offset of zero and going until the end of the maximum file size. This point is beyond any real end-of-file so that no other lock can be placed on the file. To set such a lock, set the size of the lock to zero. Here is a sample code fragment using the ID="07.locking15"fcntl() system call:#include <fcntl.h>
#define MAX_TRY 10
int try;
struct flock lck;

try = 0;

/* set up the record locking structure, the address of which
† †* is passed to the fcntl() system call.
† †*/
lck.l_type = F_WRLCK; /* setting a write lock */
lck.l_whence = 0; /* offset l_start from beginning of file */
lck.l_start = 0L;
lck.l_len = 0L; /* until the end of the file address space */

/* Attempt locking MAX_TRY times before giving up. */
while (fcntl(fd, F_SETLK, &lck) < 0) {
† †   if (errno == EAGAIN || errno == EACCES) {
† †       /* there might be other error cases in which
† †        * you might try again.
† †        */
† †       if (++try < MAX_TRY) {
† †           (void) sleep(2);
† †           continue;
† †       }
† †       (void) fprintf(stderr,"File busy try again later!\n");
† †       return;
† †   }
† †   perror("fcntl");
† †   exit(2);
}
.
.
.This piece of code tries to lock a file. The lock is attempted several times until one of the following things happens:the file is lockedan error occursthe program exceeds MAX_TRY and gives upTo perform the same task using the ID="07.locking16"lockf() function, use code like this:#include <unistd.h>
#define MAX_TRY 10
int try;
try = 0;

/* make sure the file pointer is at the beginning of the file.
† †*/
lseek(fd, 0L, 0);

/* Attempt locking MAX_TRY times before giving up. */
while (lockf(fd, F_TLOCK, 0L) < 0) {
† †   if (errno == EAGAIN || errno == EACCES) {
† †       /* there might be other error cases in which
† †        * you might try again.
† †        */
† †       if (++try < MAX_TRY) {
† †           sleep(2);
† †           continue;
† †       }
† †       (void) fprintf(stderr,"File busy try again later!\n");
† †       return;
† †   }
† †   perror("lockf");
† †   exit(2);


}
.
.
.It should be noted that the lockf() example appears to be simpler, but the fcntl() example exhibits additional flexibility. Using the fcntl() method, it is possible to set the type and start of the lock request simply by setting a few structure variables. ID="07.locking17"lockf() merely sets write (exclusive) locks; an additional system call (lseek()) is required to specify the start of the lock.LBL="" HELPID=""Setting and Removing Record LocksLocking a record is done the same way as locking a file except for the differing starting point and length of the lock. We will now try to solve an example problem: that of dealing with two records (which may be either in the same file or in different files) that must be updated simultaneously so that other processes get a consistent view of the information they contain. (This type of problem comes up, for example, when updating the inter-record pointers in a doubly linked list.) To do this you must answer the following questions:ID="07.locking18"What do you want to lock?For multiple locks, in what order do you want to lock and unlock the records?What do you do if you succeed in getting all the required locks?What do you do if you fail to get all the locks?In managing record locks, you must plan a failure strategy for the case in which you cannot obtain all the required locks. It is because of contention for these records that we have decided to use record locking in the first place. Different programs might:ID="07.locking19"wait a certain amount of time, and try againend the procedure and warn the userlet the process sleep until signaled that the lock has been freedsome combination of the aboveLet us now look at our example of inserting an entry into a doubly linked list. For the example, we will assume that the record after which the new record is to be inserted has a read lock on it already. The lock on this record must be changed or promoted to a write lock so that the record may be edited.Promoting a lock (generally from read lock to write lock) is permitted if no other process is holding a read lock in the same section of the file. If there are processes with pending write locks that are waiting for the same section of the file, the lock promotion succeeds and the other (sleeping) locks wait. Promoting (or demoting) a write lock to a read lock carries no restrictions. In either case, the lock is merely reset with the new lock type. Because the /usr/group† †ID="07.locking20"ID="07.locking21"lockf() function does not have read locks, lock promotion is not applicable to that call. Here is an example of record locking with lock promotion:struct record {
† †   .
† †   .             /* data portion of record */
† †   .
† †   long prev;    /* index to previous record in the list */
† †   long next;    /* index to next record in the list */
};

/* Lock promotion using fcntl(2)
† †* When this routine is entered it is assumed that there are
† †* read locks on "here" and "next".
† †* If write locks on "here" and "next" are obtained:
† †* Set a write lock on "this".
† †* Return index to "this" record.
† †* If any write lock is not obtained:
† †* Restore read locks on "here" and "next".
† †* Remove all other locks.
† †* Return a -1.
† †*/
long set3lock (this, here, next)
long this, here, next;
{
† †   struct flock lck;
† †   
† †   lck.l_type = F_WRLCK;    /* setting a write lock */
† †   lck.l_whence = 0;        /* offset l_start from beginning of file */
† †   lck.l_start = here;
† †   lck.l_len = sizeof(struct record);

† †   /* promote lock on "here" to write lock */
† †   if (fcntl(fd, F_SETLKW, &lck) < 0) {
† †       return (-1);
† †   }
† †   /* lock "this" with write lock */
† †   lck.l_start = this;
† †   if (fcntl(fd, F_SETLKW, &lck) < 0) {
† †       /* Lock on "this" failed;
† †        * demote lock on "here" to read lock.
† †        */
† †       lck.l_type = F_RDLCK;
† †       lck.l_start = here;
† †       (void) fcntl(fd, F_SETLKW, &lck);
† †       return (-1);
† †   }
† †   /* promote lock on "next" to write lock */
† †   lck.l_start = next;
† †   if (fcntl(fd, F_SETLKW, &lck) < 0) {
† †       /* Lock on "next" failed; demote lock on "here" to read lock,... */
† †       lck.l_type = F_RDLCK;
† †       lck.l_start = here;
† †       (void) fcntl(fd, F_SETLK, &lck);
† †       /* ...and remove lock on "this".  */
† †       lck.l_type = F_UNLCK;
† †       lck.l_start = this;
† †       (void) fcntl(fd, F_SETLK, &lck);
† †       return (-1) /* cannot set lock, try again or quit */
† †   }

† †   return (this);
}The locks on these three records were all set to wait (sleep) if another process was blocking them from being set. This was done with the F_SETLKW command. If the F_SETLK command was used instead, the ID="07.locking22"fcntl() system calls would fail if blocked. The program would then have to be changed to handle the blocked condition in each of the error return sections.Let us now look at a similar example using the lockf() function. Since there are no read locks, all (write) locks will be referenced generically as locks./* Lock promotion using lockf(3).
† †* When this routine is entered it is assumed that there are
† †* no locks on "here" and "next".
† †* If locks are obtained:
† †* Set a lock on "this".
† †* Return index to "this" record.
† †* If any lock is not obtained:
† †* Remove all other locks.
† †* Return a -1.
† †*/

#include <unistd.h>

long set3lock (this, here, next)
long this, here, next;
{

† †   /* lock "here" */
† †   (void) lseek(fd, here, 0);
† †   if (lockf(fd, F_LOCK, sizeof(struct record)) < 0) {
† †       return (-1);
† †   }
† †   /* lock "this" */
† †   (void) lseek(fd, this, 0);
† †   if (lockf(fd, F_LOCK, sizeof(struct record)) < 0) {
† †       /* Lock on "this" failed.  Clear lock on "here". */
† †       (void) lseek(fd, here, 0);
† †       (void) lockf(fd, F_ULOCK, sizeof(struct record));
† †       return (-1);
† †   }

† †   /* lock "next" */
† †   (void) lseek(fd, next, 0);
† †   if (lockf(fd, F_LOCK, sizeof(struct record)) < 0) {
† †       /* Lock on "next" failed.  Clear lock on "here", */
† †       (void) lseek(fd, here, 0);
† †       (void) lockf(fd, F_ULOCK, sizeof(struct record));
† †       /* and remove lock on "this". */
† †       (void) lseek(fd, this, 0);
† †       (void) lockf(fd, F_ULOCK, sizeof(struct record));
† †       return (-1); /* cannot set lock, try again or quit */
† †   }

† †   return (this);
}Locks are removed in the same manner as they are set; only the lock type is different (F_UNLCK or F_ULOCK). An unlock cannot be blocked by another process and will only affect locks that were placed by the unlocking process. The unlock only affects the section of the file defined in the previous example by ID="07.locking23"ID="07.locking24"lck. It is possible to unlock or change the type of lock on a subsection of a previously set lock; this may cause an additional lock (two locks for one system call) to be used by the operating system. This occurs if the subsection is from the middle of the previously set lock.LBL="" HELPID=""Getting Lock InformationOne can determine which processes, if any, are blocking a lock from being set. This can be used as a simple test or as a means to find locks on a file. To find this information, set up a lock as in the previous examples and use the F_GETLK command in the ID="07.locking25"ID="07.locking26"fcntl() call. If the lock passed to fcntl() would be blocked, the first blocking lock is returned to the process through the structure passed to fcntl(). That is, the lock data passed to fcntl() is overwritten by blocking lock information. This information includes two pieces of data that have not been discussed yet, l_pidf and l_sysid, that are only used by F_GETLK. (For systems that do not support a distributed architecture the value in l_sysid should be ignored.) These fields uniquely identify the process holding the lock.If a lock passed to fcntl() using the F_GETLK command would not be blocked by another process' lock, then the l_type field is changed to F_UNLCK and the remaining fields in the structure are unaffected. Let us use this capability to print all the segments locked by other processes. Note that if there are several read locks over the same segment only one of these will be found.ID="07.locking27"struct flock lck;

/* Find and print "write lock" blocked segments of file. */
(void) printf("sysid pid type start length\n");
lck.l_whence = 0;
lck.l_start = 0L;
lck.l_len = 0L;
do {
† †   lck.l_type = F_WRLCK;
† †   (void) fcntl(fd, F_GETLK, &lck);
† †   if (lck.l_type != F_UNLCK) {
† †       (void) printf("%5d %5d %c %8d %8d\n",
† †                     lck.l_sysid,
† †                     lck.l_pid,
† †                     (lck.l_type == F_WRLCK) ? `W' : `R',
† †                     lck.l_start,
† †                     lck.l_len);
† †       /* if this lock goes to the end of the address
† †        * space, no need to look further, so break out.
† †        */
† †       if (lck.l_len == 0)
† †           break;
† †       /* otherwise, look for new lock after the one
† †        * just found.
† †        */
† †       lck.l_start += lck.l_len;
† †   }
} while (lck.l_type != F_UNLCK);fcntl() with the F_GETLK command will always return correctly (that is, it will not sleep or fail) if the values passed to it as arguments are valid.The ID="07.locking28"lockf() function with the F_TEST command can also be used to test if there is a process blocking a lock. This function does not, however, return the information about where the lock actually is and which process owns the lock. Here is a routine using lockf() to test for a lock on a file:/* find a blocked record. */

/* seek to beginning of file */
(void) lseek(fd, 0, 0L);
/* set the size of the test region to zero
† †* to test until the end of the file address space.
† †*/
if (lockf(fd, F_TEST, 0L) < 0) {
† †   switch (errno) {
† †   case EACCES:
† †   case EAGAIN:
† †       (void) printf("file is locked by another process\n");
† †       break;
† †   case EBADF:
† †       /* bad argument passed to lockf */
† †       perror("lockf");
† †       break;

† †   default:
† †       (void) printf("lockf: unknown error <%d>\n", errno);
† †       break;
† †   }
}When a process forks, the child receives a copy of the file descriptors that the parent has opened. The parent and child also share a common file pointer for each file. If the parent were to seek to a point in the file, the child's file pointer would also be at that location. This feature has important implications when using record locking. The current value of the file pointer is used as the reference for the offset of the beginning of the lock, as described by l_start, when using an l_whence value of 1. If both the parent and child process set locks on the same file, there is a possibility that a lock will be set using a file pointer that was reset by the other process. This problem appears in the lockf() function call as well and is a result of the /usr/group requirements for record locking. If forking is used in a record locking program, the child process should close and reopen the file if either locking method is used. This will result in the creation of a new and separate file pointer that can be manipulated without this problem occurring. Another solution is to use the ID="07.locking29"fcntl() system call with an l_whence value of 0 or 2. This makes the locking function atomic, so that even processes sharing file pointers can lock without difficulty.LBL="" HELPID=""Deadlock HandlingThere is a certain level of deadlock detection/avoidance built into the record locking facility. This deadlock handling provides the same level of protection granted by the ID="07.locking30"/usr/group standard lockf() call. This deadlock detection is only valid for processes that are locking files or records on a single system. Deadlocks can only potentially occur when the system is about to put a record locking system call to sleep. A search is made for constraint loops of processes that would cause the system call to sleep indefinitely. If such a situation is found, the locking system call will fail and set errno to the deadlock error number. If a process wishes to avoid the use of the system's deadlock detection it should set its locks using F_GETLK instead of F_GETLKW.LBL="" HELPID=""Selecting Advisory or Mandatory LockingThe use of mandatory locking is not recommended, for reasons that will be made clear in IDREF="43386" TYPE="TITLE"Section , "Mandatory Locking."
 Whether or not locks are enforced by the I/O system calls is determined at the time the calls are made, by the state of the permissions on the file (see chmod(2)). For locks to be under mandatory enforcement, the file must be a regular file with the set-group-ID bit on and the group execute permission off. If either condition fails, all record locks are advisory. Mandatory enforcement can be assured by code like this:ID="07.locking31"#include <sys/types.h>
#include <sys/stat.h>

int mode;
struct stat buf;
.
.
.
if (stat(filename, &buf) < 0) {
† †   perror("program");
† †   exit (2);
}
/* get currently set mode */
mode = buf.st_mode;
/* remove group execute permission from mode */
mode &= ~(S_IEXEC>>3);
/* set `set group id bit' in mode */
mode |= S_ISGID;
if (chmod(filename, mode) < 0) {
† †   perror("program");
† †   exit(2);
}
.
.
.Files that are to be record locked should never have any type of execute permission set on them. This is because the operating system does not obey the record locking protocol when executing a file.The chmod command can be easily used to set a file to have mandatory locking. This can be done with the commandIRIS% chmod +l filenameThe ls command shows this setting when you ask for the long listing format:IRIS% ls -l filename
-rw---l--- 1 abc other 1048576 Dec 3 11:44 filenameLBL="" HELPID=""ID="43386"Mandatory LockingSome points to remember about mandatory locking:ID="07.locking32"Mandatory locking only protects those portions of a file that are locked. Other portions of the file that are not locked may be accessed according to normal UNIX system file permissions.If multiple reads or writes are necessary for an atomic transaction, the process should explicitly lock all necessary pieces before any I/O begins. Thus, advisory locking is sufficient for all programs that perform in this way.As stated earlier, arbitrary programs should not have unrestricted access permission to files that are important enough to record lock.Advisory locking is more efficient because a record lock check does not have to be performed for every I/O request.ID="07.locking33"ID="07.locking34"LBL="" HELPID=""Record Locking across Multiple SystemsIn a UNIX environment the system on which the locking process resides may be remote from the system on which the file and record locks reside. In this way multiple processes on different systems may put locks upon a single file that resides on one of them, or on yet another system. The record locks for a file reside on the system that maintains the file. It is also important to note that deadlock detection and avoidance is only determined by the record locks being held by and for a single system. Therefore, it is necessary that a process hold record locks on only a single system at any given time for the deadlock mechanism to be effective. If a process needs to maintain locks over several systems, it is suggested that the process avoid theID="07.locking35"† †sleep-when-blocked features of fcntl() or lockf() and that the process maintain its own deadlock detection. If the process uses the sleep-when-blocked feature, then a timeout mechanism should be provided by the process so that it does not hang waiting for a lock to be cleared.LBL="" HELPID=""ConclusionRecord locking has been added to UNIX System V to ease the development of small to mid-range database systems. The implementation is compatible with the published standards of /usr/group to this date. Minor differences in operation may exist; they were made for correctness, or to include things not covered by the published standards.ID="07.locking36"LBL="8"ID="24034"Using Real-Time Programming FeaturesThis chapter introduces a number of techniques for achieving real-time performance under IRIX. Note that only multiprocessor machines are really suitable for tasks requiring real-time response, so most of this chapter is geared toward multiprocessor systems, although some of these techniques are useful on single-processor systems as well.This chapter contains the following sections:IDREF="71291" TYPE="TITLE""Introduction to Real-Time Programming" introduces the concepts and techniques of real-time programming under IRIX.IDREF="70723" TYPE="TITLE""Real-Time Features" describes the various mechanisms available to help you achieve real-time performance.IDREF="11681" TYPE="TITLE""Optimal Real-Time Environment" describes how to use the real-time features together to create the best real-time environment.IDREF="54110" TYPE="TITLE""Real-Time with Ada" discusses some special considerations for real-time programming using the Ada language.IDREF="69142" TYPE="TITLE""Real-Time Latency" describes the sources of interrupt latency and how to eliminate them.LBL="" HELPID=""ID="71291"Introduction to Real-Time ProgrammingThe IRIX operating system supports a powerful set of real-time programming features. You can use these features in combination to accurately time events, use signals as true interrupt routines, control allocation of real memory to the process, and provide for priority scheduling.In addition, you can use the fully configurable kernel to install custom drivers when wanted. This provides for a range of response time and latency from very fast handling at device interrupt time to high priority dispatch of user processes to handle the event.Advanced programming features (such as shared process groups and mapped files) provide an environment in which you can construct tightly coupled multiprocess applications, assuring better response for real-time work.A real-time system provides immediate response to specific external events. Thus, a programmer can schedule particular processes to run within a specified time limit after the occurrence of an event.Optimal real-time response requires at least two processors: one to handle interrupts and other jobs, and one to service high-priority real-time jobs. A multiprocessor system can provide deterministic real-time response if the unpredictable loads (such as interrupts) are handled on processors other than the processor running the real-time application.The system scheduler has to do a fair amount of work to switch contexts from one process to another. The scheduling algorithm spends its time among three phases: saving the context of the current process, searching for the highest priority process it can run, and restoring the context of the selected process. Real-time response can be greatly improved if context switches are eliminated. This can be accomplished by creating a shared process group (using the sproc(2) system call), in which multiple processes share resources such as address space. One of these processes is dedicated to handle real-time events. You can designate a particular CPU to run only the real-time process; thus, the context of the process is always available in the real-time CPU maps and registers.LBL="" HELPID=""ID="70723"Real-Time FeaturesThis set of features refers to the programmer-visible features of the system. An example program (provided later in this chapter) shows how to incorporate these features into your program for optimal real-time response. The following sections describe features that may be valuable for real-time programming:IDREF="68710" TYPE="TITLE""Interval Timers"IDREF="89952" TYPE="TITLE""Event Timing"IDREF="46769" TYPE="TITLE""Reliable and Queued Signals"IDREF="83179" TYPE="TITLE""Virtual Memory Control"IDREF="94277" TYPE="TITLE""Implicit I/O"IDREF="15593" TYPE="TITLE""Asynchronous I/O"IDREF="15121" TYPE="TITLE""Scheduling Control"IDREF="55964" TYPE="TITLE""Shared Process Groups"IDREF="85860" TYPE="TITLE""User Synchronization Primitives"IDREF="68360" TYPE="TITLE""Process/Processor Locking"IDREF="89964" TYPE="TITLE""Processor Isolation"IDREF="41204" TYPE="TITLE""Process Blocking"IDREF="20517" TYPE="TITLE""Resource Limits"IDREF="13574" TYPE="TITLE""Real-Time Support in the Kernel"LBL="" HELPID=""ID="68710"Interval TimersIn BSD4.2, Berkeley introduced a facility called interval timers, often shortened to just itimers. This facility provides microsecond-resolution for both timers and the time-of-day clock. An interval timer allows the user to specify both an offset from the current time (the delay) and the recurrence time (the interval). The timer will not fire until the delay has passed, and then will continue to fire at the end of each interval.Three timers are provided, each of which delivers a separate signal to the process. The first is the real-time timer, which delivers the standard SIGALRM. The second is a process virtual time timer, which runs only when the process is running in user mode, delivering the signal SIGVTALRM. The third timer is the system virtual time timer, which runs when the process is in either user mode or the kernel is operating on behalf of the user. This timer delivers the signal SIGPROF.Using the combination of "itimers" and reliable signals (described later), it is possible to implement accurate handling of tasks at regular intervals. Although the resolution of the clock is in microseconds, the actual resolution provided by the kernel is equivalent to the kernel clock frequency, which is 100 Hz on the 4D series, giving 10 millisecond resolution. IRIX fully supports "itimers" as specified in the BSD4.2 programmer's manual.Using the ftimer(1) command, it is possible to enable fast itimers, which have a finer resolution. This will allow more accurate timing with a slight loss in performance for one of the CPUs in a system, due to the additional overhead of more frequent timer interrupts.The best resolution depends upon the underlying hardware and the setting of the FASTHZ variable in the kernel. See ftimer(1) and timers(5) man pages for resolution ranges. systune(1M) can be used to query and adjust the value of FASTHZ. In addition to interval timers, some applications need to pause for a specified amount of time. Typical UNIX systems include a "sleep" service, which provides this functionality with the granularity of sleep measured in seconds. IRIX includes the sginap call, which provides sleep resolutions down to 10 milliseconds.LBL="" HELPID=""ID="89952"Event TimingThe generic UNIX operating system offers two types of timing services. The time(2) system call returns the time in seconds since midnight January 1, 1970, in the local time zone. The second type of service is timing between events. Using the times(2) system call, a programmer may get the elapsed time since an arbitrary point in the past (that is, system startup) to the resolution of the kernel clock. By getting the time before and after an operation and then subtracting, the application can calculate elapsed time. ID="08.realtime1"IRIX extends these facilities through support of the BSD4.2† †gettimeofday(2) system call, which provides microsecond resolution. This system call returns a structure composed of two elements: the seconds since January 1, 1970 and the incremental microseconds since the last second was counted. The actual resolution of gettimeofday(2) depends on the underlying hardware (see timers(5)), but is never worse than 10 milliseconds.ID="08.realtime2"In addition to event timing via the kernel clock, some computers (Challenge systems and POWER Series systems with the IO3) have a free-running counter that can be mapped into the address space of a user process and used for very fine resolution timing with low overhead. The resolution is 62.5 nanoseconds on the IO3 and 21 nanoseconds on the Challenge. syssgi(2) can be used to query the existence of this counter, determine its resolution, and obtain an address to be used with the mmap(2) system call in mapping the counter into the user address space. ID="08.realtime3"LBL="" HELPID=""ID="46769"Reliable and Queued SignalsReliable signals are necessary because of the poor semantics of the original UNIX signal definition. In the original definition, signals are reset when caught, meaning that the kernel clears any signal handling information set up by the user just before entering the user's signal handler. In most cases, this sets the behavior to the default, which is usually to kill the process. The signal handler is usually responsible for resetting the signal handling information immediately upon entry; however, this leaves a small window in which a signal may be delivered again to a process, causing the (unwanted) default behavior. See the signal(2) manual page in the UNIX Programmer's Manual for a complete description of this behavior.ID="08.realtime4"Such unreliability when dealing with signals is unsuitable for real-time programming. Thus, AT&T added reliable signal handling capabilities to SVR3; these capabilities are described in the sigset(2) man page. Reliable signals are not reset when caught, meaning that user signal handling information is retained until changed by the user. In addition, a method is provided for blocking and unblocking signals in a manner similar to the way hardware interrupts may be blocked or unblocked. This makes it possible to create "critical sections" within a user program that are safe from interference by signal handlers. The signal handler itself is a "critical section"; the kernel automatically blocks that particular signal until the handler returns. IRIX fully supports this reliable signal implementation. IRIX also supports the full semantics of BSD4.3 signals (signal(3B)), including the signal stack system call sigstack(2) and POSIX signals (sigaction(2)). Both of these signal mechanisms are reliable, like the AT&T mechanism. The support for POSIX real-time signals is extended in IRIX to include operations to modify or query the status of signal sets (sigsetops(3)). Some SGI-specific additions are available that provide additional functionality and ease of use (also see sigsetops(3)).ID="08.realtime5"All signal mechanisms have support for signals 0-64, except the BSD signals, because a fixed 32-bit signal mask is part of their interface. POSIX 1003.4a Draft 12 reserves signals between SIGRTMIN and SIGRTMAX (49-64) as real-time signals. Within that range, lower signal numbers have higher priority and will be delivered first when more than one signal is pending. Signals 0-32 have equal priority for delivery, and are higher than any signals between SIGRTMIN and SIGRTMAX. Signals 33 through 49 are not guaranteed to be available to the user in future releases.IRIX supports the implementation of queued signals described in POSIX 1003.4a Draft 12. A process can queue a signal to itself, or another process, using† †sigqueue(3). Unlike other signals, that interrupt the process when they are delivered, queued signals are stored and made available when a process queries about their status. Also, up to† †SIGQUEUE_MAX signals can be queued to a process (the default is 64 but can be adjusted via systune(1M).) A process can wait for a queued signal in two ways: with sigwaitrt(3), if the signal is not immediately available, the process blocks; with sigtimedwait(3), the process will block for an amount of time specified in an argument to the function call.The timely delivery of signals is an interesting issue. Typical UNIX systems only look to deliver a signal to a process whenever the process enter or exits the system, or on a kernel timer interrupt (which is usually either 10 mS or 16 mS). There are two problems with this in a multiprocessor real-time environment. First, if the resolution of the interval timer is less than the system clock, and the process does no system calls, the process may not be given the signal until the next system clock tick. Thus, even though the interval timer is set to 1 mS, the process may only get awoken once every 10/16 mS. The second problem arises when a process can migrate between multiple processors. If the timer fires on a different processor than the one on which the process is running, the process may not see its pending signal until the next scheduling cycle. IRIX solves both these problemsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the delivery of SIGALARM signal checks where the target processor is running. If it is on the processor where the timer fired, a scheduling cycle is immediately performed. If the target process is running on another processor, an inter-processor interrupt is dispatched to that process.ID="08.realtime6"LBL="" HELPID=""ID="83179"Virtual Memory ControlIn a paging system, it is always possible that the next reference a program makes, whether it's to text or data, may cause a page fault. Fixing up a page fault can take a long time, destroying any semblance of real-time behavior. To address this problem, IRIX provides the programmer with the ability to lock ranges of pages into real memory, thus avoiding page-fault penalties.ID="08.realtime7"This capability is supplied in a crude way in SVR3; the user can specify that the text, data, or stack segments be locked into core. It may not always be necessary to lock the entire segment; in fact, it may not be possible on a system with limited memory. IRIX provides mpin(2) and munpin(2), which allow the programmer to lock a specified range of addresses into core. When a range of addresses is pinned by the programmer, the kernel allocates memory to all pages in the range and locks them into core before returning to the user program. Conversely, unpinning pages undoes any previous locking. This makes it possible for an application to manage its memory effectively, and ensure that critical text and data (such as signal handlers) are always available.ID="08.realtime8"If an application really needs to lock its entire virtual space, plock(2) can be used. IRIX has enhanced the locking capabilities by extending the System 5.3 plock(2) call to automatically lock shared library sections. In addition, when an entire data section is locked, any growth of that space (via† †sbrk(2)) will cause the pages to automatically be faulted in and locked down. Shared memory segments (see† †shmop(2)), shared arenas (see usinit(3P)), and mmap(2) files still need to be individually locked using mpin(2).ID="08.realtime9"LBL="" HELPID=""ID="94277"Implicit I/OAn old concept that is beginning to show up in various UNIX implementations is that of mapped files or implicit I/O. A user instructs the kernel to "map" a portion of a file into his virtual address space at some point. After mapping, the user can access the file simply by reading and writing the mapped memory in a manner identical to all other memory access. Multiple processes can map the same file, thus providing another way to share memory.ID="08.realtime10"Implicit I/O has advantages in terms of access speed and ease of programming. The programmer does not need to make system calls to read or write data, thus speeding up the program. The kernel uses its paging mechanism to manage the mapped data, and thus can deliver data to the user at a higher rate than system calls allow.IRIX supports mapped files according to the (unimplemented) specification originally intended for BSD4.2, called the mmap(2) interface. This interface allows read or read/write mapping, shared file data, or copy-on-write data (called private mapping). Calls are provided for synchronizing any in-core portions of the file with the actual disk image in both a synchronous and asynchronous manner.It is also possible to map files into memory that reside on remote systems and are available via NFS. The synchronization calls provided also ensure that changes to a remote file are flushed back to the NFS server.While real-time performance cannot be guaranteed for such files, large databases may be profitably shared or data collection algorithms supported. Finally, access to certain devices as mapped files is supported if that access is also supported by the driver. Thus, the driver writer supplies a "map" routine, which identifies a range of addresses in physical I/O space to be mapped, and performs any permission checking necessary. The kernel then maps that address range directly to the user's address space. If access to the VME address space is desired, it is not necessary for a driver to be involved. By mapping the device /dev/mmem into its address space, a user process may directly access VME devices. The range of addresses that may be specified by the user is controlled through the lboot facility, and thus may be adjusted for security or special access conditions.ID="08.realtime11"LBL="" HELPID=""ID="15593"Asynchronous I/OWith IRIX 5.0, support for asynchronous I/O was added in accordance with the specification in POSIX 1003.4a Draft 12. A user can queue read and write requests to a device (see aio_read(3) and aio_write(3)) and optionally receive a queued signal when the request completes. The read or write function call will return when the request is queued, instead of blocking until the operation is finished. The user can optionally use process priority to establish the order in which queued requests are completed. ID="08.realtime12"The user can query the state of an asynchronous I/O operation using aio_error(3) and aio_return(3), getting, respectively, error codes and return values similar to those obtained from read(2) and write(2) calls. With lio_listio(3), a program can simultaneously queue a number of requests.LBL="" HELPID=""ID="15121"Scheduling ControlUNIX implements priority aging for processes. Thus, a process that is CPU bound has its priority lowered gradually as it runs. This ensures that lower priority processes can eventually run and not be starved out of the CPU. This behavior is good in the original environments for which UNIX was designed: interactive users pounding on ASCII terminals. In real-time programming, the programmer often wishes to ensure that a process will run immediately when an event occurs (for example, delivery of a timer signal). Specifying a high priority with the nice(2) system call is only a partial solution; even "niced" jobs age, which can mean a significant delay before a process gets to run.ID="08.realtime13"To alleviate this problem, the notion of non-degrading or fixed priorities has been added to the IRIX kernel. With this facility, the programmer can specify via schedctl(2) a priority for a process that does not decrease over time, thus insuring that it maintains its priority order in the system. This makes it possible to guarantee that certain processes run in a timely manner, and that they can control the CPU as long as necessary to accomplish their tasks. Non-degrading priorities are available in three bands: above normal UNIX priorities, within the same priority range as normal UNIX processes, and below normal UNIX priority ranges. This gives the ability to support time-critical applications, server applications and batch processing, for example. In order for a program to raise its priority above those of normal UNIX processes, its effective user id must be that of the superuser.ID="08.realtime14"Non-degrading priorities above the normal UNIX band can be dangerous if misused. For instance, consider a process with the highest non-degrading priority in the system. If this process enters an infinite loop, then all other processes will be blocked from running, and it will be necessary to reset the machine to regain control. On a multiprocessor system, however, it is possible to dedicate a CPU to a particular task using non-degrading priorities without deadlocking the system.In addition to offering non-degrading priorities, IRIX has the capability of deadline scheduling, whereby a process is given a guaranteed opportunity to execute for a specific amount of time within a specific, recurring period. This capability is especially useful for frame-rate scheduling for simulation or continuous media (DAT, CD-ROM). Via schedctl(2), the user can set the length of the recurring period and the time allocated to the process. Even though it is not guaranteed exactly when within the period the process will execute, it is guaranteed that the process will receive its allotment at some time during the period. Non-degrading priorities in the high band (above normal UNIX processes) take precedence over deadline scheduling. ID="08.realtime15"In IRIX, the user can implement processor sets using the pset(1M) command. Each of these processor sets can be assigned to one of seven different queues, which implement various process scheduling semantics. One of the queues is the real-time queue of processes that have priorities in the high real-time band. Therefore, it is possible to have a set of four processors that are only responsible for handling user real-time processes. Other processors will not run real-time processes, nor will processors in the real-time set ever run other process types. ID="08.realtime16"LBL="" HELPID=""ID="55964"Shared Process GroupsAt the lowest level, IRIX shared process groups (see sproc(2)) allow multiple processes to share resources. This means that a set of processes may share the same virtual address space, and thus have free access to shared data without the overhead of copying or expensive protocols. These processes are referred to as a shared process group, or simply a share group. The processes in a share group are scheduled independently and may run at either user or kernel level in parallel. Because each process in a share group is an independently schedulable process with its own context, share group processes are not the same as "lightweight" processes or "threads" implemented in some operating systems. Share groups are supported in all configurations, whether they are single-processor or multiprocessor.ID="08.realtime17"IRIX also adds a novel innovation to this basic scheme: other resources may be selectively shared as well. For instance, file descriptors may be shared, meaning that if one process opens the descriptor, all other processes in the share group may access it as well. Other resources may be shared, such as the current directory or ulimit(2) values.Using this facility, it is possible to construct very tightly coupled multiprocessor applications with fast response times. For instance, if two processes share file descriptors, one could open a file and suffer the overhead of disk access and resource allocation while the other maintained real-time response for display update. Once the descriptor is opened, the kernel will automatically propagate it across all processes in the share group, which is much cheaper than multiple opens. The real-time process would then have immediate access to data through the previously opened descriptor. Mapped files could be used in this instance as an even lower-overhead method for passing data.LBL="" HELPID=""ID="85860"User Synchronization PrimitivesIRIX provides several extremely powerful shared memory models (usinit(3P), usmalloc(3P)) for programmers to use. To effectively use shared memory in real-time applications, the synchronization primitives used for access to that memory must be very fast. Invoking kernel primitives, such as System V messages or semaphores, is only acceptable in applications where latency isn't an issue.ID="08.realtime18"IRIX provides a set of user-level primitives that allow very low latency synchronization between processes. There are two levels of synchronization primitive offered, spinlocking (usnewlock(3P)) and semaphores (usnewsema(3P)). If the program is running on a POWER or Challenge Series system, then spinlocking automatically takes advantage of the built-in test-and-set hardware. On other 4D systems, a fast software spinlock mechanism is used instead. Semaphores, which can block or unblock processes, use spinlocks for the fundamental control mechanism and only interact with the kernel when putting a process to sleep or unblocking a waiting process. Semaphores may be used in conjunction with event-based applications by using a special pollable semaphore (via poll(2) and usnewpollsema(3P)). This permits applications to be more event driven, where an events could be hardware input, user input, or synchronization messages from other cooperating processes. These synchronization facilities also provide extensive tracing and metering support, making it much easier to debug and tune an application using them. For more information on IRIX IPC see IDREF="66587" TYPE="TITLE""IRIX IPC" in Chapter 6
.LBL="" HELPID=""ID="68360"Process/Processor LockingUsing the sysmp(2) system call or the runon(1) or mpadmin(1) command, the programmer or user may control the distribution of processes among the processors in a multiprocessor system. For instance, it is possible to lock a particular process onto a processor, such that it will always run there, even when performing work within the kernel on behalf of that process. Conversely, it is possible to restrict a processor to run only those processes that are explicitly assigned to it. This makes it possible to dedicate one or more processors to particular processes. However, if a process accesses a driver that is locked to a different processor, the process will execute on the other processor while in the driver; conversely, if a processor is restricted, but drivers or system code must run on that processor, the restricted processor will run those tasks as necessary. Consequently, IRIX allows full control over which processor in the system deals with any particular interrupt.ID="08.realtime19"As an example, consider a time critical environment in which a processor can be dedicated to real-time events. Using the† †mpadmin(1) command, all but minimal clock handling is moved to a different processor. All noncritical processes are locked off the real-time processor. The time-critical interrupt is vectored to the real-time processor, while all other interrupts go elsewhere. The programmer uses several threads, one of which is locked onto the real-time processor and the others are locked off. The other threads are responsible for nondeterministic system activity, such as reading or writing files or dealing with the network, while the real-time thread simply awaits time-critical events and handles them. In this example, the context switch latency is effectively reduced to nearly zero, since the processor is never executing kernel code or other user code. The normal UNIX environment is maintained for programming, simplifying the implementation. This normal UNIX environment includes periodic time slicing (though the time slice can be altered). This implies that even if there is only one process locked onto a processor, and the processor runs only that process, there will be periodic clock interrupts. These interrupts will update the accounting statistics for the running process, decrement its time slice, and perform some other time-sharing accounting. IRIX permits this clock interrupt to be turned off (again, using the mpadmin(1) command or the sysmp(2) system call), which eliminates these interrupts and the resulting latency anomalies. This implies that the process running on such a processor is responsible for all scheduling policy on that processor, and that certain UNIX accounting information will be lost. The clock interrupt can only be turned off on an isolated processor.LBL="" HELPID=""ID="89964"Processor IsolationNominally, when IRIX is running in a multiprocessor configuration, certain system services require synchronization of all processors in the complex. This is done for two main reasons: to synchronize the instruction caches and to synchronize virtual to physical translations (called the TLB). In IRIX 3.3 and earlier releases, this synchronization was accomplished by sending an interrupt to all processors to instruct them of what action was required. Although neither of these actions takes a long time, the fact that a process running on one processor can cause system services to be run on another processor adds to the worst-case dispatch latency on all processors. To solve this issue, IRIX 4.0 and later releases provide the ability to "isolate" a processor from the complex. This can be used in a couple of different ways. ID="08.realtime20"First, when a processor is isolated, the normal IRIX clock processing may be turned off. This implies that normal IRIX time slicing will no longer preempt the running process. It also means that a device driver may stay and poll its device for as long as it wishes, and there will be no effect on the other processors.Second, processes that run on an isolated processor have control over when, if ever, the synchronizing events take place. If the process never requests any system services, then there is never a need to synchronize. If a processor is isolated, no devices are configured onto that processor, the clock service is disabled, and the application process is entirely locked into main memory, then a user can accurately determine how long a particular compute-bound computation will take.LBL="" HELPID=""ID="41204"Process BlockingIRIX provides several new system calls for managing the run state of a process. A process may block another (after appropriate security checks) or itself, and may unblock any process. This blocking operation is implemented via a counter in the kernel, and thus is free of race conditions. The blocking operations have been tuned for high performance.ID="08.realtime21"Such primitives find their use in many areas, such as user-level semaphore support. Real-time modeling and simulation programs can use such calls to implement preemptive schedulers at the user level. For instance, an operating system environment can be simulated using a shared process group (sharing the virtual memory image) and blocking calls for process control. See blockproc(2) for more information.LBL="" HELPID=""ID="20517"Resource LimitsIRIX implements the BSD4.3 getrlimit(2) and setrlimit(2) system calls. This allows the programmer to control the resource usage of a process, such as CPU time, resident set size, and disk usage. The most useful of these is resident set size. By controlling the resident set size of various processes, the real-time application developer can ensure that background or low-priority processing does not impact memory usage for infrequently called but high-priority tasks.ID="08.realtime22"Default and hard resource limits are set in the kernel (see stune(1M)). A non-superuser process can successfully adjust its limits up to the hard limit.LBL="" HELPID=""ID="13574"Real-Time Support in the KernelThis set of features is not visible to the programmer but is critical in any real-time application. The system call and trap handling paths within the kernel have been optimized, reducing overhead to a minimum. Part of this reduction involves hand coding much of the initial state handling and exception processing in assembly language. Such coding is extremely efficient due to the RISC nature of the MIPS microprocessors, often allowing handling at the full rated clock speed of the processor. In the high-level parts of these handlers, exception conditions, which are normally tested for in a sequential manner in most UNIX implementations, are combined into a single bit-vector that can be tested in a single instruction. This is an advantage, as exception conditions (such as signals or process preemptions) occur rarely for most processes.The kernel also implements delayed binding for access to the floating-point coprocessor and graphics head. This allows active floating-point registers to stay in place during other processing, unless the floating-point unit is needed for another process (the kernel does not use floating point). In addition, the cost of saving and restoring the state of these units is eliminated for interrupt and trap handling.In standard UNIX implementations, the scheduler scans the entire run queue when searching for the next job to run. Processes are always added to this queue at the back, so there is no priority ordering to the queue. Normal UNIX scheduling is O(n), where n is the number of processes on the run queue. The IRIX kernel sorts processes on the run queue when adding them (typical UNIX round-robin scheduling is maintained). This insertion sort takes O(n/2) time and is only performed when placing processes on the queue. When dispatching processes from the queue, the first runnable process is taken from the queue, thus eliminating back-end searching.ID="08.realtime23"With IRIX 5.0, the scheduler was redesigned to have seven different queues that utilize different scheduling semantics: the kernel, user real-time, deadline, gang, time-share, gang batch, and batch queues. The kernel and user† †real-time queues utilize the scheduling described in the preceding paragraph. The deadline queue contains processes that have requested deadline scheduling (see schedctl(2)). The real-time and deadline queues would be the ones used most often by real-time processes. Share group processes that have requested gang scheduling (see schedctl(2)) will be scheduled on the gang queue if their priority is better than 128; otherwise, they go to the batch gang queue. Processes on the time share queue of a multiprocessor will be selected based upon their priority and their cache affinity, a measure of how long the process has spent filling the processor's cache with valid data. Processes with a high cache affinity will be preferentially selected ahead of higher priority processes. The hope here is that overall system throughput will increase due to more efficient overall use of the cache. The† †batch queue uses time-sharing queue semantics for processes with priorities worse than 127. (A list of the queues, their scheduling types, and priority ranges can be obtained via the pset(1M) command). ID="08.realtime24"By default, all processors can run all processes on all queues, but with the pset(1M) command, the superuser can assign groups of processors (processor sets) to service the various queues. pset(1M) can also be used to assign various disciplines to a processor set, whereby the set's access to various resources (especially graphics) can be controlled. Finally, pset(1) and schedctl(2) can be used to assign processes to various processor sets.Probably the largest enhancement to IRIX's real-time capabilities has been to make the kernel preemptable. This means that the time in which the kernel will ignore a high-priority runnable process because of critical sections is now bounded. IRIX also has the capability of directing interrupts from the VMEbus to selected processors, to prevent a high-priority real-time process from being interrupted by unwanted signals. This is customizable via the IPL directives in the kernel. By default, all VME interrupts are handled by processor 0, but the user can assign specified VME interrupt levels to specified processors, thereby dedicating a processor to handle one high-priority VME interrupt.ID="08.realtime25"In IRIX 3.3, the networking code was not preemptable, and therefore to construct a real-time system it was necessary to have one processor that handles the network in a non-time-critical fashion.This processor was assigned via the NETWORKPROC directive in the kernel. Later IRIX releases handle networking in either of two ways: interrupts from the ethernet hardware can be redirected via the IPL mechanism, or the rtnetd(1M) daemon can be run to provide preemptable networking behavior.All critical sections in which the kernel or Silicon Graphics supplied drivers hold off interrupts have been examined, and their length minimized.LBL="" HELPID=""ID="11681"Optimal Real-Time EnvironmentThis section explains how to use the IRIX real-time features to set up optimal real-time response.LBL="" HELPID=""Establishing Scheduling ControlUse the ID="08.realtime26"schedctl(2) command to assign a high, non-degrading priority to a process to prevent interference by other, less important processes. LBL="" HELPID=""Establishing Multiprocessor ControlMultiprocessing eliminates unwanted interrupts and lower-priority processes from competing with the real-time process for CPU cycles.ID="08.realtime27"IRIX supports the sysmp(2) commands MP_RESTRICT and MP_MUSTRUN (see sysmp(2) for details on these commands). These system calls let you dedicate a processor on which to run the real-time program. These calls also let you restrict a particular processor to run only certain designated processes. You must be the superuser to use these commands. The MP_MUSTRUN command assigns the calling process to run only on the processor specified, except as required for communications with hardware devices. The MP_RESTRICT command restricts the processor specified from running any process except those assigned to it via the MP_MUSTRUN command or the runon(1) command, or because of hardware necessity. Under IRIX, each processor in the system handles its own clock interrupt. The overhead of handling the clock interrupt is quite low for all the processors except for one special processor, the clock processor. It is selected by the MP_CLOCK (to specify a processor to handle the system clock) sysmp command. The real-time processor should not be the clock processor. Note that the program sample that follows uses various sysmp commands.For extremely low latency situations, sysmp(2) supplies the commands MP_ISOLATE and MP_NONPREEMPTIVE to isolate a processor by eliminating TLB and instruction cache synchronization, and turning off the scheduling clock. Processes isolated in this way cannot receive signals or be share group (sproc(2)) processes. In addition, they should only run user code (no system calls); otherwise, they will be subject to the latencies involved in any kernel access.LBL="" HELPID=""Locking InterruptsOn a single processor system, the time required for all interrupts to be serviced until no more interrupts are pending and process scheduling can proceed constitutes an unpredictable latency. Fortunately, on the multiprocessor systems, VME interrupt levels can be individually locked on to any processor in the system. For real-time application, move all the unwanted VME interrupt levels away from the real-time processor. To lock a particular VME interrupt level to a processor, edit the ID="08.realtime28"/usr/sysgen/system file and run lboot(1M) for the changes to take effect. The format is:IPL: level cpu# where level is the priority level (0 - 7, with 7 being the highest), and cpu# is the number of the CPU on which you want the VME interrupts of that level to occur. For example:IPL: 4 1designates VME interrupt priority level 4 on CPU number 1.After editing the system file, you must run lboot(1M) to reconfigure the system for the changes to take effect. See lboot(1M) and system(4) for details.LBL="" HELPID=""Reducing Other LatenciesUse the ID="08.realtime29"plock(2) and/or mpin(2) system calls to lock the important parts of your program in memory to prevent additional latencies due to page faults. LBL="" HELPID=""A Real-Time ExampleThe following example shows how to set up a user program for real-time application and acquire system resources for optimal real-time processing. This program includes examples of the use of fine-grained memory locking, process blocking, shared process group, and reliable signals.In this program, the user process is broken up into two threads executing on different processors. The real-time thread runs on a dedicated real-time processor, while the slave thread runs on a different processor.The real-time thread execution:sets up the itimer to simulate a real-time device that keeps interrupting the real-time thread by periodically sending it a SIGALARM.does some CPU-intensive calculation, trying not to sleep to avoid any context switching when it gets the itimer signal.on receipt of the itimer signal, wakes up the slave thread for additional I/O related processing.# include <sys/types.h># include <sys/time.h># include <sys/schedctl.h># include <sys/sysmp.h># include <sys/pda.h># include <signal.h># include <setjmp.h># include <stdio.h># include <sys/prctl.h>
int realtime_cpu = -1; int master_cpu = 0; /*default to CPU 0 to    * handle system clock*/
extern int errno;
struct timeval lasttime;

int  npri;
struct { /* structure we communicate through */ int ppid; /* parent process ID */ int cpid; /* child process ID */ unsigned count;   /* counter, bumped by parent */ unsigned nintr;   /* counter of itimer signals */} comarea;
main(argc, argv)   int  argc;   char  *argv[];{   extern int  optind;   extern char  *optarg;   int  c;   int  err;   int  i;   int  nprocs;   int  catcher();   register struct pda_stat *pstatus, *p;   struct itimerval itv;   int asyncslave();     /*
  * Parse arguments.  */
 while ((c = getopt(argc, argv, "r:f:")) != EOF) {   switch (c) {  case 'f':
     /*      * Set a non-degrading or fixed priority       * at the given value.      */        if ((npri = strtol(optarg, (char **) 0, 0)) <= 0) {      err++;      break;  }
  /*   * Figure out which band it is in.   * Smaller values mean higher priorities.   * These codes are here for illustration.   */        if (npri >= NDPHIMAX && npri <= NDPHIMIN) {   /*    * High priority (higher than all other    * processes).     */       }        else if (npri >= NDPNORMMAX && npri <= NDPNORMMIN) {    /*     * Non-degrading in the normal UNIX priority     * bands. This should give "constant response."     */       }
        else if (npri >= NDPLOMAX && npri <= NDPLOMIN) {     /*      * Lower than all other processes. Suitable      * for batch work, etc.      */       }         else      err++;    break;  case 'r':        if ((realtime_cpu = strtol(optarg,    (char **) 0, 0)) < 0)
     err++;  break;  case '?':     err++;  break;  }}if (err) { fprintf(stderr, "usage: %s [-rcpu] [-fpri]\\n",    argv[0]); exit(1);}
/* * Start the slave thread first. */comarea.ppid = getpid();comarea.cpid = sproc(asyncslave, PR_SALL, 0);
/* * Pin the signal handlers down to improve signal  * handling performance. We pass in a stack address * so we know which part of the stack to lock. */pinmem((char *) &itv);
/* * Set the priority if requested. If in the high * priority band, then you should always get control.  * If in the middle band, depends on who else is  * running. If in the lower band, you only * get cycles if nothing else is running. Note * that setting a non-degrading priority requires  * superuser privileges. */if (npri != 0) schedctl(NDPRI, 0, npri);
/* * To dedicate a processor to handle interrupts  * from a real-time device, use lboot to reconfig  * the kernel and reboot the system (see system(4), * lboot(1M)). To run your process only on the  * dedicated real-time processor, * then use the following system call.  */if (realtime_cpu >= 0) if (sysmp(MP_MUSTRUN, realtime_cpu) < 0) {   perror("Failed MP_MUSTRUN.           Resource not available!"); }
† †/*  * To obtain maximum real-time processing power   * out of the selected processor, use the following   * system call to kick all other processes   * from the real-time processor.   */ if (realtime_cpu >= 0 && sysmp(MP_RESTRICT,   realtime_cpu) < 0) { perror("Failed MP_RESTRICT.    Resource not available!");}
/* * Move the handling of the system clock * to another CPU, if it is currently  * handled by the real-time CPU. This will * increase the bandwidth of the real-time CPU. */nprocs = sysmp(MP_NPROCS);if (nprocs < 0) {  perror("Failed MP_NPROCS. Fatal system error!");  quit(-1);}pstatus = (struct pda_stat *)  calloc(nprocs, sizeof(struct pda_stat));if (sysmp(MP_STAT, pstatus) < 0) {  perror("Failed MP_STAT. Fatal system error!");  quit(-1);} /*  * Figure out which processor is currently   * handling the system clock. If that processor   * happens to be the real-time CPU,then move  * that functionality to another processor   * (the master processor in this example).  */for (i = 0, p = pstatus; i < nprocs; i++) {if ((p->p_flags & PDAF_CLOCK) &&    (i == realtime_cpu)) {         if (sysmp(MP_CLOCK, master_cpu) < 0) {  perror("Failed MP_CLOCK.    Fatal system error!");  quit(-1);   }   break;   }    p++;}
/* * Set up signal handling. Initialize the alarm  * signal to be "held", which means that  * timer pops will be ignored until we * "release" the signal. */sigset(SIGALRM, catcher);sighold(SIGALRM);
/* * Set up timer. The interval is the time between * each successive timer pop. The value is the  * initial value of the timer, which can be anything. * We will set the timer to start 10ms from now, and  * keep interrupting every 10ms thereafter. */itv.it_interval.tv_sec = 0;itv.it_interval.tv_usec = 10000;itv.it_value = itv.it_interval;setitimer(ITIMER_REAL, &itv, (struct itimerval *) 0);
/* * Get the starting time, and release  * the interrupt signal. */gettimeofday(&lasttime, 0);sigrelse(SIGALRM);
† †while (1) {    /* simulate CPU intensive processing */  comarea.count++;   }    /*NOTREACHED*/}
/* * Slave thread * block waiting for parent to wake child up upon * receipt of the itimer signal.  */asyncslave(){    static struct timeval last;    static int lastintr;    struct timeval newtime;    double  rt;    int cdone();
† †    /*      * Put us at the highest possible real-time       * priority so we respond to events very quickly.      */    schedctl(NDPRI, 0, npri);
† †   last = lasttime;
† †   /* initialize semaphore count */    setblockproccnt(comarea.cpid,0)
† †   /* catch INT signal to let parent know */    sigset(SIGINT, cdone);
† †   for (;;) { /*  * parent will wake us up  */ blockproc(comarea.cpid); /*  * Get the time that we finished.  */ gettimeofday(&newtime, 0);
 /*  * Turn the net time difference into a  * floating-point number so we can   * reasonably deal with it.  */ rt = newtime.tv_sec - last.tv_sec; rt += (double)(newtime.tv_usec - last.tv_usec) / 1000000;
 /*  * Tell the user what the result was.  */ printf("Current rate of interrupts/sec = %.2f\\n"   (comarea.nintr - lastintr)/rt); last = newtime; lastintr = comarea.nintr;    }    /*NOTREACHED*/}
/*** parent signal handler*/catcher(){    comarea.nintr++;    /* Wake up slave thread to output the results     * every 100 signals.     */    if ((comarea.nintr % 100) == 0) unblockproc(comarea.cpid);}
/*** code to lock critical memory in core; lock ** stack, signal handler, and the communication area*/pinmem(sbot)   char  *sbot;{
† †    /*      * Pin down various pieces of critical       * memory. Start with the stack.       * Allow about 2K for the stack (signal      * handlers run on the same stack).      */    /* stack grows downward */   mpin(sbot - (2*1024), 2*1024);
† †   /* pin data areas */   mpin(&comarea, sizeof(comarea));
† †   /* pin text areas */    mpin((char *) catcher, (int) pinmem - (int) catcher);}
quit(code){    kill(comarea.cpid, SIGINT);    exit(code);}
cdone(){    kill(comarea.ppid, SIGINT);    exit(0);}LBL="" HELPID=""ID="54110"Real-Time with AdaMany real-time programs require Ada as their language of development. Without MP Ada (MPXM-6.2), this is accomplished by making ID="08.realtime30"pragma interface calls to the C function calls (sysmp(2), schedctl(2), and so on). In this way, you can develop a program with a guaranteed response in Ada. One problem is the use of itimers with standard Ada. Because the Ada execution environment uses the SIGALRM signal to handle task scheduling, and itimers to execute delay statements, these uses conflict with itimers that also send a SIGALRM. Another problem is that all Ada tasks execute within the process space of a single process; therefore, adjusting the priority of one Ada task changes the priority of all the Ada tasks in the Ada program.The MP Ada product allows Ada tasks to run on separate share group processes created via sproc(2). The paradigm selected for this capability is the POSIX threads detailed in the POSIX 1003.4a Draft 6 document.This sproc(2) creation can be hidden from the user; she can determine the number of default "sprocs" to create via the VADS_SPROC_COUNT variable, and the Ada execution environment would assign tasks to any available sprocs for true symmetric multiprocessing.To allow greater control necessary for real-time programs, the user can individually create sprocs via the sproc_create() call (from package os_sproc), assigning the sproc a set of attributes. The attributes assignable include the CPU to execute on (sproc_attr_setcpu()), whether the sproc should be locked in memory (sproc_attr_setresident()), and the non-degrading priority (sproc_attr_setprio()). In addition, the† †sproc_create() routine can be passed the name of another routine, and an argument to that routine, that can be used to configure other real-time parameters (such as processor restriction, location of clock processor, and so on). Interfaces to the sysmp(2) command are now available as a part of MP Ada and do not need to be written by the user (see package os_prctl).Another important attribute of the sproc is a resource vector, which the Ada execution environment will use to assign specific tasks to the sproc. The pragma task_attributes will assign a particular resource vector to a specific task (done in the task specification), and then the Ada execution environment will provide the match of sprocs and tasks having the same resource vectors.By default, Ada execution environment time slicing is turned off; therefore, as long as the user avoids the use of delay statements, itimers will work with MP Ada. An interface to sginap(2) could be used in lieu of delays.Since share group processes do not work on isolated processors, the Ada programmer cannot use the sproc_create() routines when creating a process to run on an isolated processor. Instead, he should use fork()/exec() to create the process and interfaces to† †schedctl(2) and plock(2) to give it a high, non-degrading priority and lock it in memory. Since the interfaces for† †sysmp(2) are already written, he can use these for his other real-time needs.LBL="" HELPID=""ID="69142"Real-Time LatencyReal-time processes often sit dormant waiting for some real-life event to occur. The real-life event is typically signaled by the occurrence of an interrupt that is generated by a device connected to the computer. When this interrupt occurs, a device driver interrupt handler is dispatched to service the interrupt. The interrupt handler's task often is to wake up a dormant real-time process so that it can respond to the real-life event. The following sections describe all the components of latency that occur during this chain of events under IRIX.ID="08.realtime31"Total interrupt response time is the interval of time between the occurrence of an interrupt and the start of execution of the associated user process. Total interrupt response time is the sum of the interrupt latency, the interrupt service time, and the kernel dispatch latency. ID="08.realtime32"On a typical UNIX system, no maximum can be given for these latencies, since they depend on the amount of system activities generated by local processing and external events. Under IRIX, it is possible to take actions that place bounds on these latencies. The following sections describe the sources of latency and the actions required to minimize their effects. Worst-case results will be presented that were measured after the recommended approaches were taken.LBL="" HELPID=""Interrupt LatencyInterrupt latency is the elapsed time between the occurrence of an interrupt and the start of execution of the appropriate interrupt handler.LBL="" HELPID=""Sources of Interrupt Latency There are seven interrupt levels, each of which executes at a higher level than any user process and most kernel routines. A new interrupt will be serviced immediately unless:ID="08.realtime33"† †An equal or higher-priority interrupt handler is currently executing.Interrupts at that level are disabled during kernel execution. These two sources of latency are discussed in the following paragraphs.While an interrupt handler is executing, it prevents another interrupt at an equal or lower level from being serviced. Furthermore, all pending interrupts that are equal to or higher than the priority of a new interrupt must complete execution before the new interrupt is serviced.Certain critical sections of code in the kernel need exclusive access to shared resources. In order to guarantee exclusive access, the kernel acquires a spinlock (only on the POWER Series) and raises the processor's interrupt level. New interrupts that are below the processor's interrupt level will not be serviced until the critical section of code is complete and the processor's interrupt level is lowered. The seven interrupt levels and the recommended approach to minimizing their effects on the latency of a real-time interrupt (presumed to be VME) are summarized in IDREF="38562" TYPE="TABLE"Table 8-1
. A discussion of the approach to minimization follows.COLUMNS="4"LBL="8-1"Table 8-1 ID="38562"POWER Series Interrupt LevelsLEFT="0" WIDTH="61"Interrupt LevelLEFT="70" WIDTH="93"SourceLEFT="170" WIDTH="90"How To MinimizeLEFT="265" WIDTH="356"FacilityLEFT="0" WIDTH="61"1LEFT="70" WIDTH="93"Softwarename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'
kernel/ driver
 timeoutLEFT="170" WIDTH="90"Redirect non-RT 
processesLEFT="265" WIDTH="356"sysmp(2), 
runon(1)
mpadminLEFT="0" WIDTH="61"2LEFT="70" WIDTH="93"Softwarename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'
network activityLEFT="170" WIDTH="90"Redirect network
processesLEFT="265" WIDTH="356"sysmp(2), 
runon(1)
mpadminLEFT="0" WIDTH="61"3LEFT="70" WIDTH="93"VME interrupts &
SCSI interrupts &
Ethernet interruptsLEFT="170" WIDTH="90"Redirect non-RT
interruptsLEFT="265" WIDTH="356"lboot(1M), 
system(4)LEFT="0" WIDTH="61"4LEFT="70" WIDTH="93"RT processors' local
DUARTSLEFT="170" WIDTH="90"Disable getty on the 
real-time processorLEFT="265" WIDTH="356"/etc/inittabLEFT="0" WIDTH="61"4LEFT="70" WIDTH="93"Graphics interruptsLEFT="170" WIDTH="90"Redirect graphics 
interruptsLEFT="265" WIDTH="356"sysmp(2),
runon(1),
mpadmin(1)LEFT="0" WIDTH="61"4LEFT="70" WIDTH="93"Inter-processor
interruptsLEFT="170" WIDTH="90"Isolate RT processor 
and allocate memory 
earlyLEFT="265" WIDTH="356"sysmp(2), 
mpadmin(1)LEFT="0" WIDTH="61"5LEFT="70" WIDTH="93"Scheduler clockLEFT="170" WIDTH="90"Isolate RT processor
and disable 
scheduler
clockLEFT="265" WIDTH="356"sysmp(2), 
mpadmin(1)LEFT="0" WIDTH="61"6LEFT="70" WIDTH="93"Floating-point 
exception LEFT="170" WIDTH="90"Eliminate 
programming 
errorsLEFT="265" WIDTH="356"LEFT="0" WIDTH="61"6LEFT="70" WIDTH="93"Profiling clockLEFT="170" WIDTH="90"Disable profilingLEFT="265" WIDTH="356"prfstat(1)LEFT="0" WIDTH="61"7LEFT="70" WIDTH="93"Bus errorLEFT="170" WIDTH="90"(Indicates hardware
problem)LEFT="265" WIDTH="356"LBL="" HELPID=""Reducing Interrupt LatencyTo prevent the latency of a particular real-time interrupt from being affected by other interrupts in the system, those other interrupts should be prevented from occurring on the same processor as the interrupt of interest. The techniques for accomplishing this fall into four categories:ID="08.realtime34" Disabling unused interrupt sources.  Redirecting non-real-time interrupts.Isolating a real-time processor to exclude inter-processor interrupts caused by memory management activities on other processors.Avoiding activities on a real-time processor that subject it to memory-management-related interrupts at unpredictable times.To prevent the latency that results from executing kernel code (with interrupts disabled), the approach is to stay out of the kernel at times that are critical to the real-time application. This requires: Ensuring that non-real-time processes (whose entries into the kernel are assumed to be unpredictable) are prevented from running on real-time processors.Avoiding system calls in real-time processes during periods when minimum interrupt latency is required.All of these techniques are discussed in the upcoming sections.LBL="" HELPID=""Reducing Interrupt Latency Due to Other InterruptsLBL="" HELPID=""Disabling Unused Interrupt Sources Many devices in the system that can generate interrupts are not needed in most real-time applications. These devices can be disabled to ensure that they will not generate interrupts.The local DUARTS and the profiler clock certainly fall into this category. The DUARTS are used for RS-232 serial communication, and the profiler clock is used only for tuning the IRIX kernel.Another source of interrupt latency is the standard UNIX scheduling clock that interrupts at priority level 5. The clock interrupt is used for implementing time slicing and system accounting and to provide the kernel and device drivers with a timeout facility. In the case of a real-time process being run at very high priority to ensure that it does not get preempted, clock processing does not serve any useful purpose. On the multiprocessor POWER Series system, the clock interrupt can be turned off on any isolated processor using sysmp(2).   One important side effect of turning off the scheduling clock interrupt on a processor is that a process can then run until it completes or until a higher priority process becomes ready to run on that processor. Higher-priority processes will continue to preempt lower priority processes after the scheduling clock has been disabled, but processes of equal priority will not preempt one another.Another side effect of disabling the scheduling clock is that the kernel timeout facility is no longer available to drivers running on that processor.LBL="" HELPID=""Redirecting Non-Real-Time Interrupts On the multiprocessor POWER Series system, any VME interrupt level can be routed exclusively to any processor using lboot(1M) and system(4). The same is true for local SCSI and Ethernet interrupts. On a single processor system, disk interrupts can be avoided by making use of the traditional UNIX buffer cache. Non-synchronous UNIX disk writes usually don't immediately cause a physical write to the disk, but instead the data stays in the kernel's buffer cache until one of the following things occur: 1) the system needs to recycle a buffer that contains data to be written to the disk or 2) the system needs to push out some delayed write data for increased disk consistency. A user process can dictate when the flushing of the delayed write buffers occurs (using syssgi(2)), thus avoiding disk interrupts during a time-critical section. Also on a single processor, a real-time application that does not need network services during a time-critical section can momentarily turn off the network interface (using ifconfig(1)) to avoid any network related interrupts.LBL="" HELPID=""Isolating a ProcessorThe POWER Series' shared memory architecture enables processors to share physical memory. This requires consistency in the virtual-to-physical mapping of shared memory pages by all processors that participate in the sharing. Maintaining instruction cache and TLB consistency among all processors in the system requires the kernel to periodically broadcast inter-processor interrupts to request synchronization. The frequency of these interrupts is proportional to the system load. In describing the approach to minimizing the impact on latency, the instruction cache and TLB cases will be considered separately.LBL="" HELPID=""Instruction Cache FlushesUnder IRIX 4.0, whenever the kernel allocates physical memory to hold a user text page, it determines if the physical page is from the list of recycled (previously allocated) memory pages. If so, a system-wide instruction cache flush is required to ensure that as the user process migrates among processors, it will never access stale data from the local instruction cache. POWER Lock‘ Processor Isolation, a feature of IRIX 4.0, provides a process with a measure of protection from inter-processor interrupts. Processor isolation is established using either the sysmp(2) system call or the† †mpadmin(1).shell command.† †Isolating a processor will exclude that processor from the system-wide cache flushes, unless it is the processor that is initiating the memory allocation. Therefore, by allocating all text memory resources before entering the time-critical section of a real-time process, that process can be fully exempt from synchronization cache flushes during its time-critical section. This can be accomplished either by linking the real-time program as a preloaded program (versus a loaded-on-demand program, see ld(1)) or by using plock(2) to lock all text pages in core immediately. LBL="" HELPID=""TLB FlushesThe UNIX kernel allocates virtual pages to facilitate mapping in of user process physical pages during long DMA transfers, since typically the user process context will be switched out during these long waits. This virtual-physical mapping established by the kernel tends to be short-lived, since the mapping is only meaningful during the DMA transfer. Once the transfer is complete, the kernel immediately frees its allocated virtual pages into a recycled list of virtual pages. As this process continues, the list of free and untouched virtual pages will be depleted. The kernel will have to allocate virtual memory from the recycled list. Before the kernel can allocate pages from the recycled list, it requires a system-wide TLB flush to ensure that the TLBs in different processors do not hold conflicting translations of the same virtual page. To minimize TLB flushes, IRIX 4.0 takes the extra step of keeping track of each kernel page fault. When the time comes to allocate from the recycled list of virtual pages, only the processors that previously used pages that are on now the recycled list will be required to flush their TLB. There are two approaches to minimizing the latency introduced by TLB flushes. The first is to avoid freeing any pages on a real-time processor, either in user code or in a device driver. Instead, memory resources should be allocated once and recycled within the user program or device driver.The other approach is to allow exposure to TLB flushes only at noncritical times. Processor isolation prevents servicing of an inter-processor interrupt while the isolated processor is executing user code. Instead, servicing of an inter-processor interrupt is delayed until the processor enters the kernel. The kernel will be entered when the process running on that processor makes a system call or when any interrupt occurs on that processor.At present, no shared-resource processes (sproc(2)) are allowed to run on an isolated processor; all other IRIX services are still available.LBL="" HELPID=""Reducing Latency Due To Kernel Code ExecutionLBL="" HELPID=""Redirecting Non-Real-Time Processes POWER Series systems utilize a fully symmetric multiprocessor architecture and normally allow processes to migrate freely among processors (though there is affinity for the processor on which a process was most recently running). This results in optimal load-balancing and the most efficient use of processors. However, this is not optimal in a real-time environment because some processes will delay servicing of an interrupt directed to the processor on which they are running. There are three causes of this interrupt latency. First, there are software interrupts that are self-posted by various interrupt handler routines. In general, if some portions of an interrupt handler are lengthy and are not important enough to be executing at a high interrupt level, the interrupt handler will post a software interrupt to continue the processing at a lower interrupt level before returning the processor to the user program. The networking interrupt handler and the scheduling clock handler are the two handlers that will post software interrupts routinely.Second, processors that pass data to the graphics pipeline (graphics systems only) are subject to receiving a graphics FIFO overflow interrupt that is posted to the processor that was sending data to the graphics pipeline at the time it became full. Third, during a system call, certain critical sections of the kernel must be protected from being preempted by an interrupt handler to avoid contention for the same resource. This means that if a real-time event interrupts the processor when the processor is executing one of these critical sections, it will have to wait. If the activities they are associated with are not essential to the real-time process, these sources of latency can be completely avoided. By dedicating one or more processors to real-time processing and redirecting all non-real-time processes to execute on the other processor(s), the unpredictable latencies introduced by unrelated activity can be eliminated. IRIX provides facilities (sysmp(2), mpadmin(1), runon(1)) to control the distribution of processes among the processors in a multiprocessor system.LBL="" HELPID=""Controlling System Calls on Real-Time Processors The latency increase introduced by system calls made by real-time processes is similar to the third source of latency described in the previous section. The difference is that the real-time user has control over when system calls are made in her own process. This presents the possibility of making system calls at times when increased interrupt latency is not a problem.The maximum potential latency introduced under any circumstances by making a system call has been measured to be 650 uS.LBL="" HELPID=""Worst-Case Interrupt Latency On an isolated processor that is executing a process in user mode, the maximum time required to save the isolated processor's status and dispatch the interrupt handler has been measured to be 51 uS (from interrupt pending to the first line of C code in the driver interrupt handler, with no other interrupt sources). LBL="" HELPID=""Interrupt Service TimeThe real-time interrupt handler typically wakes up a sleeping process, clears the interrupt, and returns. The time required to perform these steps is called the interrupt service time. The interrupt service time is application dependent.LBL="" HELPID=""Kernel Dispatch LatencyOnce the interrupt handler wakes up a real-time process (makes it ready to run), the kernel must exit the interrupt handler, compare the priorities of the just-awakened process and the currently running process, then dispatch the winner. If the new process has the highest priority, a context switch is required. The interval from the time that the new process is ready to run until the execution of one of the user processes actually begins is called the kernel dispatch latency.LBL="" HELPID=""Sources of Kernel Dispatch Latency The factors that can affect kernel dispatch latency and the recommended approach to minimizing them are summarized in IDREF="90836" TYPE="TABLE"Table 8-2
:COLUMNS="3"LBL="8-2"Table 8-2 ID="90836"Kernel Dispatch Latency SourcesLEFT="0" WIDTH="110"SourceLEFT="115" WIDTH="110"How To MinimizeLEFT="230" WIDTH="356"FacilityLEFT="0" WIDTH="110"Process text and/or data
 not in memoryLEFT="115" WIDTH="110"Allocate memory early 
and lock into coreLEFT="230" WIDTH="356"mpin(2), plock(2)LEFT="0" WIDTH="110"Need to grow stack to
 handle a signalLEFT="115" WIDTH="110"Specify pre-allocated 
alternate stackLEFT="230" WIDTH="356"sigstack(2)LEFT="0" WIDTH="110"A higher priority process
 is executingLEFT="115" WIDTH="110"Assign RT process higher, 
non-degrading priorityLEFT="230" WIDTH="356"schedctl(2)LEFT="0" WIDTH="110"Lower priority process is
 executing a system callLEFT="115" WIDTH="110"Redirect process to 
another processorLEFT="230" WIDTH="356"sysmp(2), runon(1), 
mpadmin(1)LBL="" HELPID=""Worst-Case Kernel Dispatch LatencyThe time required to exit the interrupt handler is the same as the time required to enter it; that is, 51 uS. The additional time required to select the highest-priority process and dispatch it, including a context switch, has been measured to be less than 87 uS.LBL="" HELPID=""Worst-Case Total Interrupt ResponseAfter following the guidelines outlined in this report for minimizing latency, the worst-case total interrupt response was measured to be as follows, for POWER, Challenge, and Onyx Series computers:ID="08.realtime35"Interrupt latency: 51 uSInterrupt service: (application specific)Kernel dispatch: 138 uStotal: 189 uS + interrupt service timePOWER Series measurements were made on a 4D/320 (2 processor, 33 MHz) system. Challenge measurements were made on a four-processor Challenge. One processor was isolated with no other non-real-time interrupt sources pending. A user process was executing at user level with the real-time process sleeping at high priority. The scheduling clock was turned off on the isolated processor. On the remaining processor, various disk-, network-, and graphics-related processes were executing. The interrupt service routine awakened the real-time process.LBL="9"ID="16251"Working with FontsThis chapter contains instructions on how to work with fonts on Silicon Graphics computers. It begins with an introduction to fonts and digital typography. Then it explains which fonts are available, and how those fonts are used with the X Window System and the IRIS Font Manager. It contains instructions on how to install additional fonts. It also contains instructions on how to download outline fonts in the Type 1 format to a PostScript printer.This chapter contains the following sections:IDREF="91375" TYPE="TITLE""Font Basics"IDREF="69179" TYPE="TITLE""Using Fonts with the X Window System"IDREF="15367" TYPE="TITLE""Using Fonts with the IRIS Font Manager"IDREF="28671" TYPE="TITLE""Installing and Adding Font and Font Metric Files"IDREF="86842" TYPE="TITLE""Downloading a Type 1 Font to a PostScript Printer"LBL="" HELPID=""ID="91375"Font BasicsFonts are collections of characters. A font contains the information about the shape, size, and position of each character in a character set. That information is needed by those programs which process characters, such as editing, word-processing, desktop-publishing, multimedia, titling, and pre-press application programs. Almost all software components in a computer system use fonts to display messages, prompts, titles, etc.Computers from Silicon Graphics are called digital computers, because discrete voltage levels are used to represent the binary digits 0 and 1. Binary digits are used to represent all other information stored in a digital computer, including fonts. Digital typography deals with the style, arrangement, and appearance of typeset matter in digital systems. If you want to use font and font metric files to correctly typeset text on a digital computer, you will need to know some basic things about digital typography. This section contains a brief introduction to fonts and digital typography. You may want to read a book on typography for more in-depth information.LBL="" HELPID=""Introduction to Digital TypographyTypography is the art and technique of working with type. In traditional typography, the term type refers to a piece of wood or metal with a raised image of a character or characters on its upper face. Such pieces of wood or metal are assembled into lines and pages which are printed by a letterpress process. What typographers do with type is called typesetting or composition. Type can also refer to the images produced by using such pieces of wood or metal. Traditional typesetting is seldom used today. In modern typography, the term type usually refers to the images produced on typesetting or composition systems which do not use wooden or metal type, such as photo and digital composition systems. The typography on a digital system, such as a digital computer, is called digital typography.Digital typography is based on a hierarchy of objects called characters, fonts, and font families or typefaces. Numeric values or measurements related to those objects can be divided into character metrics, font metrics, and font family or typeface metrics. Sometimes all information about a font family or typeface is stored in a set of font files, but sometimes metric information for a set of font files is stored in a separate file called the font metric file. LBL="" HELPID=""What Is a Character?A character is a graphical or mathematical representation of a glyph. Letters, digits, punctuation marks, mathematical symbols, and cursors are examples of glyphs.In a bitmap font, the shape of a character is usually represented by a rectangular bitmap. In an outline font, the shape of a character is usually represented by a mathematical description of its outline.LBL="" HELPID=""What Is a Font?A font is a set of characters. There is a distinction between base fonts and composite fonts. A base font is a set of characters of the same size and style. A composite font is composed of base fonts with various attributes. Characters in a base font usually match each other in size, style, weight, and slant because their shape, size, position, and spacing have been carefully designed by a skilled font designer.LBL="" HELPID=""What Is a Font Family or Typeface?A professional font designer usually creates an entire font family or typeface, rather than a single font. A base font family or typeface is a set of base fonts with the same style or design. A composite font family or typeface is composed of base font families or typefaces. A base font family or typeface can consist of bitmap fonts in certain sizes, a scalable font that can be used to produce bitmap fonts in different sizes, or both.LBL="" HELPID=""How Resolution Affects Font SizeThe images on some output devices, such as laser printers and some types of video monitors, are created by drawing small dots or pixels (picture elements). The number of dots or pixels that can be drawn per unit of length in a horizontal direction is called the horizontal resolution, while the number of dots or pixels that can be drawn per unit of length in a vertical direction is called the vertical resolution. The most commonly used unit of measure for resolution is the number of dots per inch (dpi). The size of each dot or pixel decreases as the resolution of the output device increases and vice versa; therefore, dots and pixels are device-dependent units of measure.To display the resolution of your video monitor, enter this command:xdpyinfo | grep resolYou should get a response similar to this:resolution: 96x96 dots per inchIf you draw all of the characters in a font in the same place (without advancing), you will get a composite image of those characters. If you then draw smallest rectangle that encloses that image, you will get the bounding box for that font. The size of a font is usually measured in the vertical direction. That size is usually not smaller than the height of a font bounding box, but it can be greater than that height. It may include additional vertical spacing that is considered part of the font design.Typographers use small units of measure called points to specify font size. A point is approximately equal to 1/72 of an inch. The exact value is 1/72.27 (0.013837) of an inch or 0.351 mm. A point is a device-independent unit of measure. Its size does not depend on the resolution of an output device. A 12-point font should have approximately the same size on different output devices, regardless of the resolution of those devices.If the resolution of an output device is equal to 72 dots per inch (dpi), the size of a dot or pixel is approximately equal to the size of a point. If the resolution of an output device is greater than 72 dpi, the size of a dot or pixel is smaller than the size of a point, and vice versa. You can use the following formula to calculate a pixel size from a point size:pixel-size = point-size x device-resolution / 72.27A bitmap font is usually designed for a particular resolution. That font has the point size specified by its designer only when it is used on an output device whose resolution matches the resolution for which that font was designed. This is because a font designer specifies a fixed bitmap for each character. If a pixel is smaller than a point, characters will be smaller than intended, and vice versa.LBL="" HELPID=""Font NamesWhen a font is designed, it is assigned a name such as Courier Oblique. The Courier Oblique font belongs to a font family called Courier. The Courier font family includes the following fonts:† †Courier† †Courier Bold† †Courier Bold Oblique † †Courier ObliqueThe size of a font is usually not specified for scalable fonts, because they can be scaled to any specified size. Bitmap fonts are usually designed in specific sizes. They are referred to by names such as 12-point Courier or 10-pixel Courier Bold.When the PostScript page description software language was developed by Adobe Systems, the spaces embedded in font names were replaced with dashes. PostScript font names look like this:Courier
Courier-Bold
Courier-BoldObliqueThe X Consortium specified 14-part font names for the X Window System.IDREF="23159" TYPE="GRAPHIC"Figure 9-1 shows an example 14-part name for a bitmap font, with each part labeled. In this Point sizes in X font names are specified in decipoints (tenths of a point.)LBL="9-1" FILE="font.classification.bw" POSITION="INLINE" SCALE="FALSE"LBL="9-1"Figure 9-1 ID="23159"X Window System Font NameFor a detailed description of X font names, see the recommended X Window System documentation.LBL="" HELPID=""Writing Programs that Need to Use FontsYou can write different types of programs for Silicon Graphics computers, for example, X, Display PostScript (DPS), GL, and mixed-model programs. Some of your programs will need fonts. How a program accesses font files depends on the program type. X programs access fonts by calling X font functions, such as XListFonts() and XLoadFont(). DPS programs access fonts by calling X and DPS functions, or by using PostScript. GL and mixed-model programs usually access fonts by calling font management (fm) functions from the IRIS Font Manager library, such as fmenumerate() and fmfindfont().Most fonts are installed when you install the X Window System (X11 Execution Environment). Some fonts are installed with other software components, such as DPS, Impressario‘ and IRIS Showcase‘. Japanese fonts are installed when you install the Japanese Language System. However, most fonts are shared by the X Window System, DPS (which is an extension of the X Window System), IRIS Font Manager, and other software components.To maintain compatibility and portability, it is best not to access font files directly from an application program because font formats, font names, font contents, and the location of font directories may change. Your program should use the Application Programming Interfaces (APIs) specified for the X Window System, DPS, and IRIS Font Manager, or call even higher level functions for the 2D and 3D text available from toolkits such as Inventor‘ and Performer.LBL="" HELPID=""ID="69179"Using Fonts with the X Window SystemThis section describes how to use fonts with the X Window System.The X Window System has several font utilities. This section touches on a few of the most useful utilities. For a complete description of those utilities, refer to your X Window System documentation.LBL="" HELPID=""Getting a List of Font Names and Font AliasesTo find out which font names and font aliases are known to the X Window System, enter this command:xlsfonts > /tmp/fontlistThe resulting file, fontlist, contains entries such as:-adobe-courier-bold-o-normal--0-0-0-0-m-0-iso8859-1
-adobe-courier-bold-o-normal--14-100-100-100-m-90-iso8859-1
-sgi-screen-medium-r-normal--14-140-72-72-m-70-iso8859-1
screen14The first entry is an example of a 14-part X name for an outline (scalable) font. Numeric parts of font names are set to zero for outline fonts, because those fonts can be scaled to various sizes. The second and third entries are examples of 14-part X font names for bitmap fonts, while the last entry is an alias for the third entry. An X or DPS program can get a list of available fonts by calling XListFonts() or the function XListFontsWithInfo().LBL="" HELPID=""Viewing FontsTo see what a particular font looks like, use the command xfd, and specify a font name or font alias from the file fontlist by using the option -fn. For example, to display the 14-point Adobe Courier Bold font, enter:xfd -fn -adobe-courier-bold-r-normal--14-140-75-75-m-90-iso8859-1To request a Utopia Regular font scaled to the size of 28 points, enter: † †xfd -fn -adobe-utopia-medium-r-normal--0-280-0-0-p-0-iso8859-1 You can use wild-cards (*) to indicate that any value is acceptable for parts of an X font name. For example, enter: † †xfd -fn "-*-courier-bold-r-normal--14-140-75-75-m-90-iso8859-1"to indicate that xfd can use a Courier Bold font from any foundry. Enclose the X font name on a command line in single or double quotes when that name contains wild-cards or embedded space characters.The xfd command will display all characters in the specified font, as shown in IDREF="72338" TYPE="GRAPHIC"Figure 9-2
.LBL="9-2" FILE="xfd.bw" POSITION="INLINE" SCALE="FALSE"LBL="9-2"Figure 9-2 ID="72338"Sample Display from xfd† †To open a shell window that uses a certain font, enter:xwsh -fn font-nameLBL="" HELPID=""ID="15367"Using Fonts with the IRIS Font ManagerThis section describes how to use fonts with the IRIS Font Manager (FM).The main purpose of the IRIS Font Manager is to make it easier to write GL and mixed-model programs that need fonts. The IRIS FM is implemented as a library, which consists of:/usr/lib/libfm.so/usr/lib/libfm_s/usr/lib/libfm_s.alibfm.so is a dynamic shared object, a new type of shared library introduced in IRIX 5.0. It should be used when you develop new programs.libfm_s is the same type of static shared library that was shipped before IRIX 5.0. It is used to run programs that were linked with a shared version of the IRIS FM library prior to IRIX 5.0.libfm_s.a is a symbolic link to libfm.so. It is installed when you install the gl_dev subsystem. It is provided to avoid breaking old Makefiles that still have the option -lfm_s specified on their compile and link command lines. When you specify that option, the linker tries to link your program with /usr/lib/libfm_s.a. It will now link your program with /usr/lib/libfm.so. In IRIX release 5.0 and later, you should use the option -lfm to link your program with /usr/lib/libfm.so. The file libfm.a is no longer shipped because it is no longer needed.The IRIS FM library provides a number of font management (fm) functions that can be used to get a list of the names of available font families, select and scale a specified font, draw text in a specified font, and so on.Because font management functions were written in the C programming language, they can easily be used in C and C++ programs. Fortran programs can be linked with C modules that contain calls to font management functions.† †If you need font management functions, you should link your program with the library /usr/lib/libfm.so by specifying -lfm on the compile and link command line, such as the cc command line. You should also put the following statement at the beginning of each module that calls font management functions:#include <fmclient.h>LBL="" HELPID=""Font MetricsThe metrics (dimensions) of a character are given in the structID="09.fonts1"ID="09.fonts2"ID="09.fonts3"† †fmglyphinfoID="09.fonts4"ID="09.fonts5"ID="09.fonts6"ID="09.fonts7":typedef struct fmglyphinfo {
† †   long xsize, ysize;   /* dimensions of glyph in pixels */
† †   long xorig, yorig;   /* origin */
† †   float xmove, ymove;  /* move  */
† †   long gtype;          /* glyph type */
† †   long bitsdeep;       /* depth of pixels,in bits */
} fmglyphinfo;All but two character metrics are long integers. xmove and ymove are floats. The basic unit of the values in xmove and ymove is the device unit (pixel). By making xmove and ymove floats, the FM supports the subpixel positioning information needed by typesetting and graphics applications.IDREF="55664" TYPE="GRAPHIC"Figure 9-3 shows the character metrics for a pair of characters.LBL="9-3" FILE="09.metrics.ps" POSITION="INLINE" SCALE="FALSE"LBL="9-3"Figure 9-3 ID="55664"Character MetricsA bitmap font usually contains the specification of all pixels within the bounding box of each character, without the surrounding white space. The drawing of a character starts at a reference point on the baseline. That point represents the origin of a coordinate system. The values xorig and yorig are the coordinates of the left-lower corner of the character's bounding box. The character's bitmap is drawn at those coordinates. Then you return to the reference point on the baseline, and advance to the coordinates specified by the values of xmove and ymove. That becomes the reference point for the drawing of the next character.Note that in IDREF="55664" TYPE="GRAPHIC"Figure 9-3
, the values increase in the directions indicated by the arrows. Thus, xmove increases to the right; a negative value of xmove would indicate that the next character should be to the left. The value yorig is the distance from the bottom of the glyph to the baseline. The value xorig is the horizontal distance from the current character position to the left edge of the glyph; either can be a negative value. xsize and ysize are the character boundaries (for a bitmap glyph, this is the bitmap size).LBL="" HELPID=""Font Specification and SizingID="09.fonts8"ID="09.fonts9"ID="09.fonts10"ID="09.fonts11"The API for the IRIS FM is patterned after PostScript. After calling fminit() to initialize the IRIS FM, your program should call fmenumerate() to find out which font families are available. Then it should call fmfindfont() to find one of the available font families. That function returns a handle for a 1-point font in the specified font family. If it cannot find the specified font, it returns a value of zero (0).To get a font of certain point size, your program should call fmscalefont() with the handle it got from fmfindfont() and a point size. Your program can then call fmsetfont() to make the scaled font the current font, and call fmprstr() or fmfprstr to draw a specified string of characters. Other ways of rendering text will be discussed later.LBL="" HELPID=""Font TransformationID="09.fonts12"ID="09.fonts13"ID="09.fonts14"ID="09.fonts15"ID="09.fonts16"ID="09.fonts17"ID="09.fonts18"The Font Manager library maintains an abstract notion of font rendering, called the page. Think of the page as a transparent sheet that is superimposed on the current window. The page maintains a coordinate system for font rendering. Application programs can make calls to the Font Manager library to modify the page's transformation matrix. Changing the page's transformation matrix changes the appearance of the font in the window. You can make calls to the Font Manager library if you want to render scaled or rotated text. If you do not want to alter the page's transformation matrix, you can use ID="09.fonts19"ID="09.fonts20"ID="09.fonts21"fmscalefont() to scale only the characters without scaling the page. Conceptually, there is a distinction between scaling a font and scaling the characters of a font as they are rendered. The following code first draws a one-point high string and then draws a string of two-point high characters. The text appears larger because the size of the page is doubled. The font is actually still a one-point high font, but the characters are scaled as they are rendered.font1 = fmfindfont("Times-Roman");
fmsetfont(font1);
fmprstr("Hello");
fmscalepagematrix(2.0);
fmprstr("World");The second font drawn by the code is a true two-point high font, but the page scale is still at a 1:1 ratio. Calling fmprstr() draws a string of two-point-high characters.You can produce an identical effect using the code below: font1 = fmfindfont("Times-Roman");
fmsetfont(font1);
fmprstr("Hello");
font2 = fmscalefont(font1,2.0);
fmsetfont(font2);
fmprstr("World");The above code illustrates the fact that both the font and the page have a transformation matrix. Before rendering, the font's transformation matrix is concatenated with the page's transformation matrix, and the resultant font size is rendered onto the page. The font's transformation matrix is stored with the font. The page's transformation matrix is stored in the client's process space.To set or read the page's transformation matrix, use these routines:fmconcatpagematrix() 
fmgetpagematrix() 
fminitpagematrix() 
fmrotatepagematrix()  
fmscalepagematrix()  
fmsetpagematrix() You can use ID="09.fonts22"fmrotatepagematrix() to rotate the page. If you then render text onto that page, a font of zero-degree rotation appears along a rotated baseline. fmprstr() maintains the current character position, even with rotated text. LBL="" HELPID=""Font Search PathID="09.fonts23"ID="09.fonts24"ID="09.fonts25"The IRIS Font Manager library has a path that it searches when it looks for bitmap fonts. The default value for this font path is /usr/lib/X11/fonts/100dpi:/usr/lib/X11/fonts/75dpi:/usr/lib/X11/fonts/misc. To override the default search value, set the environment variable ID="09.fonts26"ID="09.fonts27"ID="09.fonts28"FONTPATH. Alternatively, you can use ID="09.fonts29"fmsetpath() to load a new font path. The argument to fmsetpath() is a colon-separated string of directory names. Because the Font Manager library searches a path, you can store font files in different directories. During a font look-up, the Font Manager library searches the directories in the order specified (left to right) by the string given to fmsetpath(). You can use this order to make the Font Manager library use a "local" experimental font but still preserve the official font for other users.For example, if you put the experimental font in your current directory and set FONTPATH to:.:/usr/lib/X11/fonts/100dpi:/usr/lib/X11/fonts/75dpi:/usr/lib/X11/fonts/miscthe Font Manager library uses the font in the current directory (dot), even if that font also exists in other specified font directories. If the Font Manager library fails to find the font in the current directory, the Font Manager library searches for the font in other specified font directories.The IRIS FM also uses outline font files in the Type 1 font format stored in the directory:/usr/lib/DPS/outline/baseThe path for outline fonts cannot be modified.LBL="" HELPID=""ID="21386"Font FormatsThis section provides references to information about font formats that are used on Silicon Graphics workstations.LBL="" HELPID=""ID="63183"About the Extended Bitmap Distribution Format Version 2.1The Bitmap Distribution Format (BDF) was originally specified by Adobe Systems. That format was later extended for the X Window System, as described in these documents:ID="09.fonts30"ID="09.fonts31"ID="09.fonts32"Bitmap Distribution Format 2.1, MIT X Consortium Standard, X Version 11, Release 5, Adobe Systems Incorporated, Mountain View, CA, 1988.† †X Logical Font Description Conventions, Version 1.4, MIT X Consortium Standard, X Version 11, Release 5, Flowers, Jim, Massachusetts Institute of Technology, Cambridge, MA, 1989.LBL="" HELPID=""ID="55433"About the Portable Compiled Format for Bitmap Font FilesThe bitmap fonts shipped by Silicon Graphics are in the PCF or compressed PCF format. Those files are produced from bitmap font files in the BDF 2.1 format. The Portable Compiled Format (PCF) format is described in Appendix D of:The X Window System Server, X Version 11, Release 5, Israel, Elias and Erik Fortune, Digital Press, 1992.LBL="" HELPID=""ID="64992"About the Adobe Type 1 Font FormatThe Adobe Type 1 format for outline (scalable) font files is described in:Adobe Type 1 Font Format, Version 1.1, Adobe Systems Incorporated, Addison-Wesley Publishing Company, Inc., Reading, MA, 1990.LBL="" HELPID=""Font Management RoutinesID="09.fonts33"ID="09.fonts34"IDREF="66942" TYPE="TABLE"Table 9-1 lists the FM font management routines. Routines are grouped in functional categories and are described in detail in the sections that follow.COLUMNS="2"LBL="9-1"Table 9-1 ID="66942"IRIS Font Manager Library RoutinesLEFT="0" WIDTH="93"TaskLEFT="100" WIDTH="356"RoutineLEFT="0" WIDTH="93"fmconcatpagematrix()LEFT="100" WIDTH="356"Concatenate page matrixLEFT="0" WIDTH="93"fmenumerate()LEFT="100" WIDTH="356"List font familyLEFT="0" WIDTH="93"fmfindfont()LEFT="100" WIDTH="356"Prepare font for manipulationLEFT="0" WIDTH="93"fmfontpath()LEFT="100" WIDTH="356"Get a path for finding fontsLEFT="0" WIDTH="93"fmfprstr()LEFT="100" WIDTH="356"Render a character string in the current font without using 
subpixel positioning. Usually faster than fmprstr().LEFT="0" WIDTH="93"fmfreefont()LEFT="100" WIDTH="356"Free memory storage for a fontLEFT="0" WIDTH="93"fmgetchrwidth()LEFT="100" WIDTH="356"Return width of a characterLEFT="0" WIDTH="93"fmgetcomment()LEFT="100" WIDTH="356"Return a comment associated with a fontLEFT="0" WIDTH="93"fmgetfontinfo()LEFT="100" WIDTH="356"Return overall information about fontLEFT="0" WIDTH="93"fmgetfontname()LEFT="100" WIDTH="356"Return a font's nameLEFT="0" WIDTH="93"fmgetpagematrix()LEFT="100" WIDTH="356"Get page matrixLEFT="0" WIDTH="93"fmgetstrwidth()LEFT="100" WIDTH="356"Return width of a string in pixelsLEFT="0" WIDTH="93"fmgetwholemetrics()LEFT="100" WIDTH="356"Get information on each character in font LEFT="0" WIDTH="93"fminit()LEFT="100" WIDTH="356"Initialize the Font Manager libraryLEFT="0" WIDTH="93"fminitpagematrix()LEFT="100" WIDTH="356"Initialize the page matrix to identityLEFT="0" WIDTH="93"fmmakefont()LEFT="100" WIDTH="356"Associate a matrix with a fontLEFT="0" WIDTH="93"fmoutchar()LEFT="100" WIDTH="356"Draw a single glyphLEFT="0" WIDTH="93"fmprintermatch()LEFT="100" WIDTH="356"Toggle printer matchingLEFT="0" WIDTH="93"fmprstr()LEFT="100" WIDTH="356"Draw a string in the current font with subpixel accuracyLEFT="0" WIDTH="93"fmrotatepagematrix()LEFT="100" WIDTH="356"Rotate the pageLEFT="0" WIDTH="93"fmscalefont()LEFT="100" WIDTH="356"Scale a fontLEFT="0" WIDTH="93"fmsetcachelimit()LEFT="100" WIDTH="356"Set the maximum cache size in quantaLEFT="0" WIDTH="93"fmsetfont()LEFT="100" WIDTH="356"Set the current fontLEFT="0" WIDTH="93"fmsetpagematrix()LEFT="100" WIDTH="356"Set the page matrixLEFT="0" WIDTH="93"fmsetpath()LEFT="100" WIDTH="356"Set a path for finding fontsLBL="" HELPID=""Initializing FontsID="09.fonts35"ID="09.fonts36"ID="09.fonts37"This section describes routines that perform various font initialization and specification functions.Call fminit() to initialize the Font Manager library. It sets the default page matrix for the scaling and transformation routines. You must call fminit() before you can make any other calls to the Font Manager library routines. Its function prototype is:void fminit()Use ID="09.fonts38"ID="09.fonts39"ID="09.fonts40"ID="09.fonts41"fmfindfont() to get a font handle for a typeface. Its function prototype is:fmfonthandle fmfindfont(char *face)The face argument is a pointer to a character string that specifies a font family.If fmfindfont() cannot find the font, it returns a value of zero. Otherwise, fmfindfont() returns a handle to a one-point high font of the specified type. ID="09.fonts42"fmenumerate() accepts the name of a callback routine as an argument. It calls the specified callback routine for each font family it finds in the directories specified by the font path. fmenumerate() uses a string pointer to pass the name of a font family to the callback routine. Its function prototype is:void fmenumerate(callback)
void (*callback)();For example, the following code uses fmenumerate() to send font names (via string pointers) to the user-defined routine, printname(). The printname() routine displays a list of available font families.void printname(str)
† †  char *str;
{
† †  printf("%s\n", str);
}

main( )
{
† †  fminit( );
† †  fmenumerate(printname);
}LBL="" HELPID=""Scaling FontsID="09.fonts43"ID="09.fonts44"ID="09.fonts45"ID="09.fonts46"ID="09.fonts47"ID="09.fonts48"This section describes routines that control the size of a font.fmscalefont()ID="09.fonts49" applies a scale factor to the matrix associated with the font handle passed to it, then returns a new font handle. Its function prototype is:fmfonthandle fmscalefont(fmfonthandle fh, double scale)Use fmscalefont() when you want to scale a font, but not rotate it.fmmakefont()ID="09.fonts50" concatenates a matrix that is passed to it with the matrix associated with the font handle that is also passed to it, then returns a new font handle. Its function prototype is:fmfonthandle fmmakefont(fh, matrix)
fmfonthandle *fh;
double matrix[3][2];The transformation matrix passed in by matrix is multiplied with the transformation matrix in the font handle passed in by fh. When the font is imaged, this matrix is inspected to determine the proper scaling, shearing, rotation, or combination of these, for the imaging. This operator is more general than fmscalefont(), which applies uniform scaling only. For example, this multiplication can scale the font and rotate the baseline.If you want to scale the font but do not want to rotate the baseline, it is easier to use fmscalefont() than fmmakefont(). Except for size and rotation information, the information in the new handle is copied from the handle passed in by fh. If the scaling of a font requests a font that does not exist, the Font Manager library substitutes the closest match available.When using matrix[3][2], think of it as a 2† †name='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]' 2 transformation matrix. The last row is reserved for future development and is currently ignored.† †LBL="" HELPID=""Setting the Current FontUse ID="09.fonts51"fmsetfont() to set the current font (font handle). Its function prototype is:void fmsetfont(fmfonthandle fh)All subsequent rendering operations use the font handle named by fh. To get a font handle, use a font routine that returns a font handle, for example, fmfindfont(), fmscalefont(), or fmmakefont().LBL="" HELPID=""Rendering FontsThis section describes routines that render fonts to the screen.ID="09.fonts52"ID="09.fonts53"ID="09.fonts54"fmoutchar()ID="09.fonts55" renders a single glyph, ch, from the current font. Its function prototype is:long fmoutchar(fmoutchar fh, unsigned char ch)If the glyph doesn't exist, the Font Manager library advances the current character position by the width of a space. If the font does not define a space character, the Font Manager library advances the current character position by the width of the font. The returned value of fmoutchar() is the width moved.fmprstr()ID="09.fonts56" renders the characters in str onto the screen at the current character position, using subpixel positioning. Its function prototype is:long fmprstr(char *str)The font used is the one most recently named by fmsetfont(). The Font Manager library starts rendering at the current character position and updates the current character position as it renders. Clients should use the GL ID="09.fonts57"cmov() and getcpos()ID="09.fonts58" routines to set or read the current character position. Before calling fmprstr(), you must call cmov() to set the current character position or the results of fmprstr() are undefined. If the string is null, or the font does not exist, fmprstr() returns -1; otherwise, fmprstr() returns zero.fmfprstr()ID="09.fonts59" renders the characters in str onto the screen at the current character position, without using subpixel positioning. This routine can usually render a given character string faster than fmfprstr(). Its function prototype is:long fmfprstr(char *str)The font used is the one most recently named by fmsetfont(). The Font Manager library starts rendering at the current character position and updates the current character position as it renders. Clients should use the GL ID="09.fonts60"cmov() and getcpos()ID="09.fonts61" routines to set or read the current character position. Before calling fmfprstr(), you must call cmov() to set the current character position or the results of fmfprstr() are undefined. If the string is null, or the font does not exist, fmfprstr() returns -1; otherwise, fmfprstr() returns the length of the rendered string.LBL="" HELPID=""Getting Font InformationThis section describes routines that return information about specified fonts.fmgetfontname()ID="09.fonts62" gets the name of the font associated with the font handle in fh. Its function prototype is:long fmgetfontname(fmfonthandle fh, long slen, char *str)fmgetfontname() writes information to the location pointed to by str. Use slen to tell fmgetfontname the size of the array pointed to by str. fmgetfontname() does not write more characters than are specified by slen. If there is an error in locating the font, or if no name exists for the font specified by fh, the returned value of fmgetfontname() is -1; otherwise, the returned value of fmgetfontname() is the length of the string actually written to str. The function fmgetcomment() is obsolete. It has been replaced by a stub that does not do anything.fmgetfontinfo() writes information to the members of the fmfontinfo type structure pointed to by the info parameter. Its function prototype is:long fmgetfontinfo(fmfonthandle fh, fmfontinfo *info)The information written to this structure pertains to the entire font that is associated with fh. The fmfontinfo data structure is defined in the /usr/include/fmclient.h header file. IDREF="26843" TYPE="TABLE"Table 9-2 lists members of the fmfontinfo structure that provide the most frequently used information. COLUMNS="2"LBL="9-2"Table 9-2 ID="26843"Members of the fmfontinfo StructureLEFT="0" WIDTH="109"Structure MemberLEFT="115" WIDTH="356"MeaningLEFT="0" WIDTH="109"printermatchedID="09.fonts63"LEFT="115" WIDTH="356"There is a printer widths file corresponding to this font.LEFT="0" WIDTH="109"matrix00, matrix01,
 matrix10, matrix11LEFT="115" WIDTH="356"Double-precision floats that provide transformation 
matrix information in points.LEFT="0" WIDTH="109"fixed_widthLEFT="115" WIDTH="356"All the characters in the font are the same width.LEFT="0" WIDTH="109"xorig, yorigLEFT="115" WIDTH="356"Coordinates of the lower-left corner of the font 
bounding box.LEFT="0" WIDTH="109"xsize and ysizeLEFT="115" WIDTH="356"Maximum sizes of the characters in the font, in pixels.LEFT="0" WIDTH="109"heightLEFT="115" WIDTH="356"Often the same as ysize, but some fonts use a larger 
ysize to get free leading (spacing between lines of text).LEFT="0" WIDTH="109"nglyphsLEFT="115" WIDTH="356"Index of the highest-numbered character. Indexing 
begins at 0.Some indices may not have glyphs assigned to them, but when you allocate space for fmgetwholemetrics(), you should use nglyphs + 1 as though it were the total number of characters. In other words, nglyphs is the highest index of a possibly sparse matrix.† †LBL="" HELPID=""Getting Font Glyph Informationfmgetwholemetrics()ID="09.fonts64" gets glyph information associated with the font handle fh and writes it to the ID="09.fonts65"fmglyphinfo structures pointed to by the elements of the array fi. Its function prototype is:long fmgetwholemetrics(fmfonthandle fh, fmglypinfo *fi)You should allocate enough space to contain nglyphs*sizeof(fmglyphinfo). Because fmgetwholemetrics() fills only those structures of the array that have corresponding glyphs in the font file, you should initialize all the fmglyphinfo structures before calling fmgetwholemetrics(). (For example, you could use calloc() to allocate the space. See malloc(3C) for more information.)The returned function value of fmgetwholemetrics() is 0 if successful. If fmgetwholemetrics() cannot find the font referenced by the font handle, the returned function value is -1.LBL="" HELPID=""Getting the Width of a Character Stringfmgetstrwidth()ID="09.fonts66"ID="09.fonts67"ID="09.fonts68" returns the number of pixels the string occupies in the x dimension. It uses the subpixel resolution provided in the glyph widths as it accumulates the width and rounds the sum to the nearest pixel. Rotated fonts are measured along an untransformed x axis. Its function prototype is:long fmgetstrwidth(fmfonthandle fh, char *str)LBL="" HELPID=""Getting the Width of a Characterfmgetchrwidth()ID="09.fonts69"ID="09.fonts70"ID="09.fonts71" returns the number of pixels the given character occupies in the x dimension when it is rendered. Its function prototype is:long fmgetchrwidth(fmfonthandle fh, unsigned char ch)The returned value is rounded to an integer. If that character glyph does not exist, the width of a space is returned. If a space does not exist, the width of the font is returned. Rotated fonts are measured along an untransformed x axis.LBL="" HELPID=""Getting and Setting the Font Environment VariablesID="09.fonts72"ID="09.fonts73"This section describes routines that affect the environment in which fonts are managed.LBL="" HELPID=""Getting the Font Search Pathfmfontpath()ID="09.fonts74" returns a pointer to a string that describes the current search path for finding font files. Its function prototype is:char *fmfontpath()The path is a colon-separated list of directories that originate at the root. The default path is /usr/lib/fmfonts. To reset the value of the font path, use fmsetpath(). LBL="" HELPID=""Setting the Font Search Pathfmsetpath()ID="09.fonts75"ID="09.fonts76"ID="09.fonts77" accepts a pointer to a string that describes the current search path for finding font files. Its function prototype is:void *fmsetpath(char *path)The path is a colon-separated list of directories that originate at the root. The default path is /usr/lib/fmfonts.LBL="" HELPID=""Managing Font MemoryMemory management for the Font Manager library is under user control.Previous releases of the FM used caching to restrict its use of memory for fonts. For compatibility, the font-caching routines are still in the library as stubs, but they are not functional.† †fmfreefont() ID="09.fonts78"frees the storage associated with a font in a given rotation and size, specified by the font handle fh. Its function prototype is:void fmfreefont(fmfonthandle fh)Freeing a font also frees the font handle. To ensure that fmfreefont() frees the correct font/rotation/size instance, be sure that the same page matrix is in force as when you first queried or rendered from that font. Because normal usage of the Font Manager library does not involve changing the page matrix, you seldom need to worry about it. But if you find that you cannot delete a font (or have deleted the wrong font) you may have rotated the page matrix. One way to avoid this problem is to call fmfreefont() only when the page matrix is not rotated. Rotated fonts are created and destroyed as necessary and do not need explicit deletion.LBL="" HELPID=""Adjusting Widths to Match Laser PrintersID="09.fonts79"ID="09.fonts80"Many applications render text on the screen to give the user the chance to proof the text before printing it on a laser printer. For a more realistic simulation, you should use laser printer character widths to represent the text.ID="09.fonts81"fmprintermatch() sets a state variable that controls printer font matching. Its function prototype is:void fmprintermatch(long set)fmprintermatch(1)enables printer matching fmprintermatch(0)disables printer matchingWhen the Font Manager library renders (images) a font, it inspects the state of this variable. If enabled, the Font Manager library searches for a printer widths file that corresponds to the font. If the file exists, and the font has not yet been sized, the Font Manager library creates a new font. The Font Manager library also updates the font handle of the current font so that it has character widths that correspond to the laser printer's width scheme.LBL="" HELPID=""Transforming the PageID="09.fonts82"ID="09.fonts83"ID="09.fonts84"The page transformation is stated in the page matrix. This section describes routines that let you inspect and change the state of the page matrix.When using matrix[3][2], think of it as a 2name='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]'2 transformation matrix. The last row is reserved for future development and is currently ignored.† †fminitpagematrix()ID="09.fonts85" initializes the page matrix to an orthographic projection. Its function prototype is:void fminitpagematrix()fmsetpagematrix()ID="09.fonts86" loads the page matrix verbatim with matrix mat. Its function prototype is:void fmsetpagematrix(mat)
double mat[3][2];fmgetpagematrix()ID="09.fonts87" returns the page matrix in mat. Its function prototype is:void fmgetpagematrix(mat)
double mat[3][2];fmscalepagematrix()ID="09.fonts88" uniformly scales the page matrix by scale. Its function prototype is:void fmscalepagematrix(double scale)fmrotatepagematrix()ID="09.fonts89" post-concatenates a rotation to the page matrix, where the rotation is measured in a counter-clockwise direction in degrees. Its function prototype is:fmrotatepagematrix(double angle)You can also use fmrotatepagematrix() to generate a screen font that is exactly (within one pixel) the specified size. You should try this in a test program first to see whether the possible degradation in quality is acceptable. This "roughness" comes from the need to scale a bitmap font if that font does not exist at the specified size. For example, the Font Manager library normally renders text using a bitmap font that is the closest match possible to the requested size. But, if you rotate the page matrix, even by one 1/1000 of a degree, the Font Manager library tries to create a font that is rotated that much. As a side effect, the Font Manager library also distorts (shrinks or stretches) the page to generate a font that is within a pixel of the specified size; however, stretching or shrinking a bitmap often results in "rough" looking characters. To try scaling a bitmap, call:fmrotatepagematrix(.01)then print a string with fmprstr().fmconcatpagematrix()ID="09.fonts90" post-concatenates the page matrix with mat. Its function prototype is:void fmconcatpagematrix(mat)
double mat[3][2];LBL="" HELPID=""Sample GL Program Using Font Manager Library RoutinesID="09.fonts91"ID="09.fonts92"The following sample program writes a string of green, 25-point characters to a window, beginning at window coordinate (30, 100). Compile the program using the following command line options:cc example.c -o example -lc_s -lfm_s -lgl_sThe sample code is below.#include <gl/gl.h>
#include <gl/device.h>
#include <fmclient.h>

main( )
{
† †   short val;
† †   fmfonthandle font1, font25;

† †   prefsize(240,210);
† †   winopen("Hello");
† †   color(BLACK);
† †   clear( );
† †   color(GREEN);
† †   fminit( );
† †   /* Exit if can't find the font family */
† †   if ((font1=fmfindfont("Times-Roman")) == 0) exit (1);  
† †   /* scale the 1-point-high font to 25 points */
† †   font25 = fmscalefont(font1, 25.0);
† †   fmsetfont(font25);
† †   cmov2i(30, 100); 
† †   fmprstr("Hello World!"); 
† †   while(TRUE) { /* redraw window if necessary */
† †         if (qread(&val) == REDRAW) {
† †             reshapeviewport( );
† †             color(BLACK);
† †             clear( );
† †             color(GREEN);
† †             cmov2i(30, 100); 
† †             fmprstr("Hello World!"); 
† †         }
† †   }
}LBL="" HELPID=""Remote Font ManagementRemote font usage, like the Network Transparent GL, follows the X remote font model. The old shared Font Manager (FM) library (/usr/lib/libfm_s) and the new shared FM library (/usr/lib/libfm.so) will work with either local or remote graphics service, or both within the same application. All Font Manager routines are rerouted at their calling point. This means that when the remote graphics routine is active, all calls are executed on the remote host. Because of this, a font directory containing the needed font data must reside on the remote hostname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'font data is not transmitted over a DGL socket connection. Only high-level calls to render and manipulate text are transmitted over the socket connection.For applications that open both local and remote windows, the user must note that the local and remote Font Manager services are disjoint. The user must note which server is currently active by following the rules for the network-transparent GL. To summarize how the current server is determined:After dglopen has been called, the current server is that specified by the dglopen call. This remains in effect until the next dglopen or winset call.In the absence of a dglopen call, the current server is determined by an environment variable such as DISPLAY and the defaulting mechanism.To use the Font Manager in a multi-server environment:fminit must be called once for each graphics server on which Font Manager facilities are desired. Only one fminit is needed, regardless of the number of windows you want to use on the specified server.A font handle returned by findfont is usable only in the windows controlled by the server from which the request originated; therefore, the user must remember which server originated the findfont request.Matrix operations pertain only to the currently active server.LBL="" HELPID=""ID="28671"Installing and Adding Font and Font Metric FilesThis section explains how to install and add font files and font metric files for system-wide use.LBL="" HELPID=""Installing Font and Font Metric FilesID="09.fonts93"ID="09.fonts94"ID="09.fonts95"By default, bitmap font files are installed in these directories: /usr/lib/X11/fonts/100dpi, /usr/lib/X11/fonts/75dpi, and /usr/lib/X11/fonts/misc. The 100dpi directory contains bitmap fonts designed for the screen resolution of 100 dpi. The 75dpi directory contains bitmap fonts designed for the screen resolution of 75 dpi. The misc directory contains miscellaneous other fonts. By default, outline font files in the Type 1 format are installed in the directory /usr/lib/DPS/outline/base.By default, font files in the directories listed above are used by the X Window System, DPS, IRIS Font Manager, and other software components.The X Window System accesses Type 1 font files with symbolic links in the directory /usr/lib/X11/fonts/Type1.By default, outline font files in the Speedo‘ format are installed in the directory /usr/lib/X11/fonts/Speedo. Font files in this directory are currently used only by the X Window System.LBL="" HELPID=""Getting the Current X Font PathTo display the current X font path, enter this command:xset qIn addition to other information, the xset utility displays font path information that may look like this:Font Path:
/usr/lib/X11/fonts/100dpi/,/usr/lib/X11/fonts/75dpi/,
/usr/lib/X11/fonts/misc/,/usr/lib/X11/fonts/Type1/, /usr/lib/X11/fonts/SpeedoThe X Window System checks the resolution of your video monitor. If that resolution is closer to 75 dpi than 100 dpi, it puts the directory 75dpi ahead of the directory 100dpi in the X font path.By default, Adobe Font Metric (AFM) files are installed in the directory /usr/lib/DPS/AFM.There is one font metric file per typeface. Font metric files are primarily used by text-processing and desktop-publishing programs to, for example, generate PostScript code for a specified document.LBL="" HELPID=""Changing the X Font PathYou can change the default X font path by using the option fp on an xset command line, followed by an equal sign (=), and a new font path (newpath):xset fp=newpathLBL="" HELPID=""Adding Font and Font Metric FilesWhen you purchase fonts or obtain a font that is in the public domain, you may need to add that font to your system or printer in order to use it. Adobe Systems donated bitmap, outline, and font metric files for the Utopia font family to the X Consortium. This section shows how the font and font metric files for Utopia Regular were added to the IRIX operating system. Other font and font metric files can be added in a similar way.You must log in as root to make any changes to X font directories. Before you make any changes to any IRIX directory, you should make a copy of its contents so that you can restore that directory if anything goes wrong. For example, your font files may not be in the right format, and they may interfere with the access of Silicon Graphics font files. You should keep a log of the changes you make, and mention those changes when you report a problem with font files to Silicon Graphics; otherwise, it may be very difficult or impossible for other people to reproduce any problems that you might report.LBL="" HELPID=""Adding a Bitmap FontAs an example, we will show you how Utopia Regular bitmap fonts were added to IRIX. Other fonts can be added in a similar way.To add the Utopia bitmap fonts to the X Window System and to Display PostScript:Log in as root.Look at the names of existing bitmap font files and try to match these names when you specify new font names. For example, Adobe provided two sets of Utopia Regular bitmap font files that were designed for the resolutions of 100 and 75 dpi. These files were in the extended Bitmap BDF 2.1 format. For more information about that format, see IDREF="63183" TYPE="TITLE""About the Extended Bitmap Distribution Format Version 2.1"
.The names of the bitmap files were:UTRG_10.bdf through UTRG_24.bdfWhen these fonts were added to IRIX, the names were changed to:utopiaR10.bdf through utopiaR24.bdfto match the names of other X bitmap font files.Convert the BDF font files to Portable Compiled Format (PCF) font files. BDF font files are text (ASCII) files. You can think of them as source font files. You could put BDF font files into an X font directory, but people usually use binary font formats such as the PCF (.pcf) or compressed PCF format (.pcf.Z), so you should covert new fonts to one of these formats. For more information about the PCF font format, see IDREF="55433" TYPE="TITLE""About the Portable Compiled Format for Bitmap Font Files"
.To convert a BDF font file to a PCF font file, enter a command such as:bdftopcf -o file-name.pcf file-name.bdfIf you have used the bdftopcf command before, you may not have specified the name of the output file, but the command now requires that you enter the name of the output file.† †You can compress a PCF file by entering a command such as:compress file-name.pcf That should give you a file called:file-name.pcf.ZMost bitmap font files shipped by Silicon Graphics are in the compressed PCF format to save on disk space.Put the bitmap font files for 100 dpi in the directory: /usr/lib/X11/fonts/100dpi.You can tell the resolution for which a font was designed by the name of the directory in which the font designer stored the font files, or by the information in the header of a bitmap font file. In a BDF 2.1 font file, the horizontal (x) and vertical (y) resolution are specified in the X font name. They are also specified after the point size as the second and third numeric values in a SIZE entry. For example, the entry:SIZE 8 100 100indicates an 8-point font that was designed for the horizontal and vertical resolution of 100 dpi.For example, when 100-dpi Utopia Regular bitmap font files were added to IRIX, they were moved to the directory /usr/lib/X11/fonts/100dpi. Similarly, put the bitmap font files for 75 dpi in the directory /usr/lib/X11/fonts/75dpi, and put other bitmap fonts into the directory /usr/lib/X11/fonts/misc.† †For example, when 75-dpi Utopia Regular bitmap font files were added to IRIX, they were placed in the directory /usr/lib/X11/fonts/75dpi.Whenever you make changes in an X font directory, enter the command:mkfontdirto create a new fonts.dir (fonts directory) file in that directory. For example, when Utopia Regular fonts were added to the directories 100dpi and 75dpi, the command mkfontdir was executed in both of those directories.Tell the X Window System that it should check again which fonts are available, by entering:xset fp rehashTo check whether the fonts you added are known to the X Window System, enter:xlsfonts > /tmp/fontlistThe names of the fonts you added should appear on the list of font names and aliases produced by xlsfonts. Bitmap fonts should now be added to the X Window System.Since DPS needs both outline and bitmap fonts for each supported typeface, it first checks which outline fonts are stored in the directory /usr/lib/DPS/outline/base. Then it looks for the corresponding bitmap fonts in other X font directories. It ignores all other bitmap fonts. Therefore, DPS will ignore the bitmap fonts you added, until you add the corresponding outline fonts.To add these bitmap fonts to the IRIS Font Manager, you must insert an entry for each new typeface in the file /usr/lib/X11/fonts/ps2xlfd_map. This file is used to map the PostScript and other short font names to X font names. A typical entry in that file looks like this:Utopia-Regular -adobe-utopia-medium-r-normal--0-0-0-0-p-0-iso8859-1You should not put any tabs in that file when you need to separate strings of characters, rather, use space characters. The pixel size, point size, horizontal resolution, vertical resolution, and average character advance width should all be set to 0, because this entry is like a template for all Utopia Regular bitmap font names.LBL="" HELPID=""Adding an Outline FontTo add the Utopia outline fonts to the X Window System and to Display PostScript:Log in as root.Look at the names of existing outline font files in the directory /usr/lib/DPS/outline/base. Display PostScript requires that the name of each outline font file match the PostScript font name specified in the /FontName entry in the header of that outline font file. Enter:grep /FontName Courier-BoldYou should get the response:/FontName /Utopia-Regular def You should put only Adobe text (ASCII) Type 1 font files or compatibles into that directory, not binary Type 1 font files or Type 3 font files. Display PostScript can handle Type 3 font files, but the X Window System and IRIS Font Manager cannot. You should put into that directory only those outline font files that look like the font files that are already in that directory. For more information about the Adobe Type 1 font format, see the IDREF="64992" TYPE="TITLE""About the Adobe Type 1 Font Format"
.If you have a binary Type 1 font file (a .pfb file), you need to convert it into a text (ASCII) Type 1 font file before you can use it on a Silicon Graphics system. You can get the program for converting .pfb files to .pfa files from Silicon Graphics.For example, Adobe provided the Utopia Regular outline font file UTRG____.pfa, which is an outline font file in the Type 1 format, a special PostScript program that specifies a scalable outline font.To find the PostScript font name for this font, enter:grep /FontName UTRG____.pfaYou should get the response:/FontName Utopia-Regular defwhich tells you that the PostScript font name for this font is Utopia-Regular.When this font was added to IRIX, the name of the file UTRG____.pfa was changed to Utopia-Regular.Add the font to the /usr/lib/DPS/outline/base directory.For example, when this font was added to IRIX the file Utopia-Regular was placed in the directory /usr/lib/DPS/outline/base.You should now be able to access the font file you added via Display PostScript or IRIS Font Manager. If you select Demos->PostScript Demos->Fontview from the Toolchest, you should see the new font in the list of available fonts. Display PostScript first checks for outline font files in the directory /usr/lib/DPS/outline/base, then it looks for the corresponding bitmap font files. It ignores other bitmap font files.Display PostScript (DPS) is an extension of the X Window System, so it knows how to access outline font files because the directory /usr/lib/DPS/outline/base is a DPS directory. If you want the rest of the X Window System to access new outline fonts, you need to enter the following command:type1xfontsThis re-creates symbolic links in the directory /usr/lib/X11/fonts/Type1 that point to outline font files in the directory /usr/lib/DPS/outline/base.LBL="" HELPID=""Adding a Font Metric FileAFM files are primarily used by application programsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for example, to generate PostScript code for a specified document. Follow these steps to add a font metric file:Log in as root.Put Adobe Font Metric files in the directory /usr/lib/DPS/AFM.For example, Adobe provided the Utopia Regular font metric file UTRG____.AFM.The name of an AFM file should also match the PostScript font name. When this font was added to IRIX, the name of the file UTRG____.AFM was changed to Utopia-Regular, and it was put in the directory /usr/lib/DPS/AFM. LBL="" HELPID=""ID="86842"Downloading a Type 1 Font to a PostScript PrinterSome outline fonts are usually built into a PostScript printer. You can find out which fonts are known to the PostScript interpreter in your printer by sending the following file to that printer:%!
% Produce a list of available fonts
/f 100 string def
/Times-Roman findfont 12 scalefont setfont
/y 700 def
72 y moveto
FontDirectory { 
pop f cvs show 72 /y y 13 sub def y moveto 
} forall
showpageUtopia fonts are not usually built into PS printers. If you try to print a document that requires a Utopia font on a PS printer that does not have that font, a warning message about the replacement of a missing font with a Courier font is sent to the file† †/usr/spool/lp/log on the machine to which that PS printer is attached.You can download a Type 1 font to a PS printer in either of the following two ways:You can insert a Type 1 font file at the beginning of the PostScript file that needs that font. You should have a statement that starts with:%!at the beginning of your PS file. If you have two such lines, delete the second one.When you download a font this way, the font is available only while your print job is being processed.You can make a copy of a Type 1 font file, and then insert the statement:serverdict begin 0 exitserver after the first group of comment statements (lines that start with %) if no password has been specified for your printer; otherwise, you should replace 0 in the above statement with the password for your printer. Then you should send the edited file to your printer.When you download a font this way, the warning message:%%[ exitserver: permanent state may be changed ]%%is sent to the file /usr/spool/lp/log on the machine to which the printer is attached. The permanent state of the printer is not really changed. Downloaded fonts disappear when you reset the printer by switching its power off and on. If there is not enough memory for additional fonts, you will get a message about a Virtual Memory (VM) error, and the font will not be downloaded.If you again send the program that produces a list of available fonts to your printer, you should see the PostScript names of the fonts you downloaded on that list.LBL="10"ID="10407"InternationalizationInternationalization is the process of generalizing an application so that it can easily be customizedname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'or localizedname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'to run in more than one language environment. Internationalized software can be made to produce output in a user's native language, to format data (such as dates and currency values) according to the user's local customs, and to otherwise make it easier to use the software for users from a culture other than that of the original software developer. As computers become more widely used in non-American cultures, it becomes increasingly more important that developers stop relying on the conventions of American programming and the English language in their programs; this chapter provides information on how to make your applications more widely accessible.LBL="" HELPID=""OverviewThis chapter discusses internationalization standards, local-custom databases ("locales"), and character-encoding methods other than traditional ASCII. It also describes culture-specific output formatting; X11, Release 5 (X11R5) support for internationalization; internationalizing user input; and internationalizing applications that use Graphical User Interfaces (GUIs). The chapter concludes with a discussion of a few common non-ASCII encodings.LBL="" HELPID=""TerminologyThis section defines some of the terms used in this chapter.LBL="" HELPID=""LocaleID="10.intl1"Locale refers to a set of local customs that determine many aspects of software input and output formatting, including natural language, culture, character sets and encodings, and formatting and sorting rules. The locale of a program is the set of such environmental parameters that are currently selected. For information on the method for selecting locales, see IDREF="52537" TYPE="TITLE""Locales,"
 below.LBL="" HELPID=""Internationalization (I18n)ID="10.intl2"Internationalization is the process of making a program capable of running in multiple locales without recompiling. To put it another way, an internationalized program is one that can be easily localized without changing the program itself. (See IDREF="66057" TYPE="TITLE""Localization (L10n),"
 below, for an explanation of the term "localization.")The word "internationalization" consists of an `i' followed by 18 letters followed by an `n.' It is thus commonly abbreviated "i18n." "I18n" is pronounced "internationalization," not† †"eye-eighteen-enn."† †A program written for a specific locale may be difficult to run in a different environment. Rewriting such a program to operate in each desired environment would be tedious and costly.Your goal as a developer should thus be to write locale-independent programs, programs that make no assumptions about languages, local customs, or coded character sets. Such internationalized applications can run in a user's native environment following native conventions with native messages, without recompiling or relinking. A single copy of an internationalized program can be used by a world of different users.LBL="" HELPID=""ID="66057"Localization (L10n)ID="10.intl3"Localization is the act of providing an internationalized application with the environment and data it needs to operate in a particular locale. For example, adding German system messages to IRIX is a part of localizing IRIX for the German locale. For more information on localization, see IDREF="78479" TYPE="TITLE"Chapter 11, "Localization and Creating New Locales."Localization is often abbreviated "l10n."† †LBL="" HELPID=""Nationalized SoftwareID="10.intl4"Nationalized programs run in only one language and are governed by one set of customs; in other words, in a nationalized program the locale is built into the application. Even if the application doesn't use ASCII or English, as long as it is a single-language program it is nationalized, not internationalized. Most older UNIX programs can be thought of as being nationalized for the United States.Consider two applications, hello and bonjour. hello always produces the outputHello, world.and bonjour always producesBon jour, tout le monde.Neither hello nor bonjour are internationalized; they are both nationalized.There are no special requirements for writing or porting nationalized applications, whether they are text or graphics programs. Terminal-based programs will work on suitable terminals, including internationalized terminal emulators. "Suitable" means that the terminal supports any necessary fonts and understands the encoding of the application output. Graphics programs simply do as they have always done. Applications using existing interfaces to operate in non-English or non-ASCII environments should continue to compile and run under an internationalized operating system.LBL="" HELPID=""Multilingual SoftwareA multilingual program is one that uses several different locales at the same time. Examples are described in IDREF="49439" TYPE="TITLE""Multilingual Support"
.LBL="" HELPID=""Areas of Concern in Internationalizing SoftwareFew developers will have to pay attention to more than a few items described in this chapter. Most will need to catalog their strings. Some will need to use library routines for character sorting or locale-dependent date, time, or number formatting. A few whose applications use the eighth bit of 8-bit characters inappropriately will need to stop doing so. The few applications that do arithmetic to manipulate characters will need to be cleaned up. Some GUI designers will have to spend just a little more time thinking. But for the large majority of developers, there isn't much to do.In this chapter, we will attempt to address every internationalization issue that a developer might wonder about, so there may be sections that are not germane to your applications.LBL="" HELPID=""StandardsIRIX internationalization includes these standards-compliant features, among others:ANSI C and POSIX (ISO 9945-1): LocaleX/OPEN Portability Guide, Issue 3 (XPG/3): XPG/3 message catalogs, interpretation of locale stringsAT&T UNIX‘ System V Release 4: Multi-National Language Support (MNLS) message catalogsX11R5: Input methods, text rendering, resource filesLBL="" HELPID=""ID="52537"LocalesAn internationalized system is capable of presenting and receiving data understandably in a number of different formats, cultures, languages and character sets. An application running in an internationalized system must indicate how it wants the system to behave. IRIX uses the concept of a locale to convey that information.ID="10.intl5"A process can have only one locale at a time. Most internationalization interfaces rely on the locale of the current process being set properly; the locale governs the behavior of certain library routines.LBL="" HELPID=""Setting the Current LocaleApplications begin in the ID="10.intl6"C locale. (C is the name used to indicate the system default locale; it usually corresponds to American English.) Applications should therefore call setlocale() as soon as possible to put the process into the desired locale. The syntax for setlocale() is:#include <locale.h>
char *setlocale(int category, const char *locale);The call almost always looks like this:if (setlocale(LC_ALL, "") == NULL)
† †   exit_with_error();Details of the two parameters are given in the next two sections.LBL="" HELPID=""CategoryApplications need not perform every aspect of their work in the same locale. Although this approach is not recommended, an application could (for example) perform most of its activities in the English locale but use French sorting rules. You can use locale categories to do this kind of locale-mixing. (Mixing locale categories is not the same as multilingual supportname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'see ID="10.intl7"IDREF="49439" TYPE="TITLE""Multilingual Support."
)The category argument is a symbolic constant that tells setlocale() which items in a locale to change. IDREF="89492" TYPE="TABLE"Table 10-1
 lists the available category choices:ID="24348"COLUMNS="2"LBL="10-1"Table 10-1 ID="89492"Locale CategoriesLEFT="0" WIDTH="166"CategoryLEFT="175" WIDTH="356"AffectsLEFT="0" WIDTH="166"LC_ALLLEFT="175" WIDTH="356"All categories belowLEFT="0" WIDTH="166"LC_COLLATELEFT="175" WIDTH="356"Regular expressions, strcoll(), and 
strxfrm()LEFT="0" WIDTH="166"LC_CTYPELEFT="175" WIDTH="356"Regular expressions and ctype routines 
(such as islower())IDREF="10.intlTF0a"aLEFT="0" WIDTH="166"LC_MESSAGESLEFT="175" WIDTH="356"gettxt(), pfmt(), and nl_langinfo()LEFT="0" WIDTH="166"LC_MONETARYLEFT="175" WIDTH="356"localeconv()LEFT="0" WIDTH="166"LC_NUMERICLEFT="175" WIDTH="356"Decimal-point character for formatted 
I/O and nonmonetary formatting 
information returned by localeconv()LEFT="0" WIDTH="166"LC_TIMELEFT="175" WIDTH="356"ascftime(), cftime(), getdate(), and strftime()LBL="a" ID="10.intlTF0a"LC_MESSAGES is supported by SVR4 but isn't required by XPG/3.Categories correspond to databases that contain relevant information for each defined locale. The locations of these databases are given in the IDREF="88353" TYPE="TITLE""Location of Locale-Specific Data"
 section, below.
LBL="" HELPID=""LocaleThe setlocale() function attempts to set the locale of the specified category to the specified locale. You should almost always pass the empty string as the locale parameter to conform to user preferences.On success, setlocale() returns the new value of the category. If setlocale() couldn't set the category to the value requested, it returns NULL and does not change locale.LBL="" HELPID=""The Empty StringAn empty string passed as the locale parameter is special. It specifies that the locale should be chosen based on environment variables. This is the way a user specifies a preferred locale, and that preference should almost always be honored. The variables are checked hierarchically, depending on category, as shown in IDREF="30326" TYPE="TABLE"Table 10-2
; for instance, if the category is LC_COLLATE, an empty-string locale parameter indicates that the locale should be chosen based on the value of the environment variable LC_COLLATEname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'or, if that value is undefined, the value of the environment variable LANG, which should contain the name of the locale that the user wishes to work in.COLUMNS="3"LBL="10-2"Table 10-2 ID="30326"Category Environment VariablesLEFT="0" WIDTH="110"CategoryLEFT="115" WIDTH="110"First Environment 
VariableLEFT="230" WIDTH="356"Second Environment 
VariableLEFT="0" WIDTH="110"LC_COLLATELEFT="115" WIDTH="110"LC_COLLATELEFT="230" WIDTH="356"LANGLEFT="0" WIDTH="110"LC_CTYPELEFT="115" WIDTH="110"LC_CTYPELEFT="230" WIDTH="356"LANGLEFT="0" WIDTH="110"LC_MESSAGESLEFT="115" WIDTH="110"LC_MESSAGESLEFT="230" WIDTH="356"LANGLEFT="0" WIDTH="110"LC_MONETARYLEFT="115" WIDTH="110"LC_MONETARYLEFT="230" WIDTH="356"LANGLEFT="0" WIDTH="110"LC_NUMERICLEFT="115" WIDTH="110"LC_NUMERICLEFT="230" WIDTH="356"LANGLEFT="0" WIDTH="110"LC_TIMELEFT="115" WIDTH="110"LC_TIMELEFT="230" WIDTH="356"LANGSpecifying the category LC_ALL attempts to set each category individually to the value of the appropriate environment variable.If no non-null environment variable is available, setlocale() returns the name of the current locale.LBL="" HELPID=""Nonempty Strings in Calls to setlocale()Here are the possibilities for specifying a nonempty string as the locale parameter:NULL stringSpecifying a locale value of NULLname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'not the same as the empty stringname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'causes setlocale() to return the name of the current locale."C"Specifying a locale value of the single-character string "C" requests whatever locale the system uses as a default. (Note that this is a string and not just a character.)Other nonempty stringsRequesting a particular locale to be used by specifying its name. Overrides any user preferences; this should only be done with good reason.LBL="" HELPID=""ID="88353"Location of Locale-Specific DataExcept for XPG/3 message catalogs, locale-specific data (that is, the "compiled" files containing the collation information, monetary information, and so on) are located in /usr/lib/locale/locale/category, where locale and category are the names of the locale and category, respectively. For example, the database for the LC_COLLATE category of the French locale fr would be in /usr/lib/locale/fr/LC_COLLATE.There will probably be multiple locales symbolically linked to each other, usually in cases where a specific locale name points to the more general case. For example, /usr/lib/locale/En_US.ascii might point to /usr/lib/locale/C.LBL="" HELPID=""Locale Naming ConventionsA locale string is of the form:ID="10.intl8"language[_territory[.encoding]][@modifier]...where:ID="10.intl9"language is the two-letter ISO 639 abbreviation for the language name.ID="10.intl10"erritory is the two-uppercase-letter ISO 3166 abbreviation for the territory name. (For a list of these abbreviations, see the table in IDREF="67532" TYPE="TITLE"Appendix B, "ISO 3166 Country Names and Abbreviations."
)ID="10.intl11"encoding is the name of the character encoding (mapping between numbers and characters). For western languages, this is typically the codeset, such as 8859-1 or ASCII. For Asian languages, where an encoding may encode multiple codesets, the encodings themselves have names, such as UJIS or EUC (these encodings are described later in this chapter). Codesets and encodings are discussed under IDREF="22554" TYPE="TITLE""Character Sets, Codesets, and Encodings,"
 below.ID="10.intl12"modifiers are not actually part of the locale name definition; they give more specific information about the desired localized behavior of an application. For example, under X11R5, a user can select an input method with modifiers. (To use the Xsi wnn Japanese input method, for instance, one adds @im=_XWNMO to the locale string.) There are no standards for this part of a locale string.Language data is implementation specific; databases for the language en (English) might contain British cultural data in England and American cultural data in the United States. If other than the default settings are required, the territory field may be used. For example, the above cases could be more strictly defined by setting LANG to en_EN or en_US. Full rigor might lead to en_EN.88591 for England (the locale encoding specification for ISO 8859-1 is "88591") and en_US.ascii for the USA.ANSI C has defined a special locale value of C. The C locale is guaranteed to work on all compliant systems and provides the user with the system's default locale. This default will typically be American English and ASCII, but need not be. POSIX has also defined a special locale value, POSIX, which is identical to the C locale.The length of the locale string may not exceed NL_LANGMAX characters (NL_LANGMAX is defined in /usr/include/limits.h). However, XPG/3 recommends that this string (not counting modifiers) not exceed 14 characters.LBL="" HELPID=""Limitations of the Locale SystemLBL="" HELPID=""ID="49439"Multilingual SupportThere can only be one locale at a time associated with any given process in an internationalized system. Therefore, although multilingual applicationsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'which give the appearance of using more than one locale at a timename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'can be created, internationalization does not provide inherent support for them. Here are two examples of multilingual programs:ID="10.intl13"An application creates and maintains windows on four different displays, operated by four different users. The program has a single controlling process, which is associated with only one locale at any given time. However, the application can switch back and forth between locales as it switches between users, so the four users may each use a different locale.In a sophisticated editing system with a complex user interface, a user may wish to operate the interface in one language while entering or editing text in another. For instance, a user whose first language is German may wish to compose a Japanese document, using Japanese input and text manipulation, but with the user interface operating in German. (There is no standard interface for such behavior.)In writing a multilingual application, the first task is identifying the locales for the program to run in and when they apply. (There is no standard method for performing this task.) Once the application has chosen the desired locales, it must either:fork, and then call setlocale() differently in each process, orcall setlocale() repeatedly as necessary to change from language to language.LBL="" HELPID=""Misuse of LocalesThe LANG environment variable and the locale variables provide the freedom to configure a locale, but they do not protect the user from creating a nonsensical combination of settings. For example, you are allowed to set LANG to fr (French) and LC_COLLATE to ja (Japanese). In such a case, string routines would assume text encoded in 8859-1name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'except for the sorting routines, which might assume French text and Japanese sorting rules. This would likely result in arbitrary-seeming behavior.LBL="" HELPID=""No Filesystem Information for Encoding TypesThe IRIX filesystem does not contain information about what encoding should be associated with any given data. Thus, applications must assume that data presented to an application in some locale is properly encoded for that locale. In other words, a file is interpreted differently depending on locale; there is no way to ask the file what it thinks its encoding is.ID="10.intl14"For example, you may have created a file while in a Japanese locale using SJIS. Later, you might try printing it while in a French locale. The results will likely resemble a random collection of Latin 1 characters.This problem applies to almost all stored strings. Most strings are uninterpreted sequences of nonzero bytes. This includes, for example, filenames. You can, if you want to, name your files using Chinese characters in a Chinese locale, but the names will look odd to anyone who runs /bin/ls on the same filesystem using a non-Chinese locale.LBL="" HELPID=""ID="22554"Character Sets, Codesets, and EncodingsOne major difference between nationalized and internationalized software is the availability in internationalized software of a wide variety of methods for encoding characters. Developers of internationalized software no longer have the convenience of always being able to assume ASCII.A ID="10.intl15"character set is an abstract collection of characters. A codeset is a character set with exactly one associated numerical encoding for each character. The English alphabet is a character set; ASCII is a codeset.An ID="10.intl16"encoding is also a set of characters and associated numbers, but the term is more general than "codeset." A single encoding may include multiple codesets; Extended Unix Code (EUC), for instance, is an encoding that provides for four codesets in one data stream. (For details, see the IDREF="31663" TYPE="TITLE""EUC"
 section later in this chapter.)LBL="" HELPID=""Eight-Bit CleanlinessA program is ID="10.intl17"8-bit clean if it does not use the high bit of any data byte to convey special information. ASCII characters are specified by the low seven bits of a byte, so some programs use the high bit of a data byte as a flag; such programs are not 8-bit clean. Internationalized programs must be 8-bit clean, because they cannot expect data to be in the form of ASCII bytes; non-ASCII character sets usually use all eight bits of each byte to specify the character. But a program must go out of its way to manipulate bytes based on the value of the high bit; and since changing data without cause is seldom desirable, most programs are already 8-bit clean.The old csh (before this problem was fixed in IRIX 5.0) was a good example of a program that was not 8-bit clean; it used the high bit in input strings to distinguish aliases from unaliased commands. An effect of this misuse was that csh stripped the 8th bit from all characters:echo I know an architect named MaÒosa
I know an architect named MaqosaAnother example is the specification of Internet messages, which calls for 7-bit data. Thus, if sendmail fails to strip the 8th bit from a character prior to sending it, it violates a protocol (this protocol problem is being addressed); if it does strip the bit, it could garble a non-ASCII message.One of the simplest things to do to remove the American bias from a program is to replace the ASCII assumption with the assumption that the Latin 1 codeset will be used. This approach is not true internationalization, but it can make the application usable in most of Western Europe. Latin 1 uses only one byte per character, unlike some other codesets, so 8-bit clean ASCII software should work without modification using the Latin 1 codeset.Ensuring that code is 8-bit clean is the single most important aspect of internationalizing software.Another caveat about 8-bit characters only applies to a particular set of circumstances: if you're not using a multibyte character type (see the next section), you should not declare characters as type ID="10.intl18"signed char. (The default in IRIX C is for char to imply unsigned char.) If you try to cast a signed char to an int (as you must do to use the ctype(3C) functions) and the character's high bit is set (as it may be in an 8-bit character set), the high bit will be interpreted as a sign bit and will extend into the full width of the int.† †ID="42850"Multiple-Byte Character TypesWestern languages usually require only one byte for each character. Asian languages, however, often require two or even four bytes per character; and some Asian encodings allow a variable number of bytes per character.ID="10.intl19"The two kinds of encodings that allow more than one byte per character are wide (ID="10.intl20"WC or wchar) characters (which are a fixed number of bytes long) and multibyte (MB) characters (which are of variable size). The application developer must decide where to use WC and MB characters and strings:Multibyte strings are almost the default: string I/O uses MB, MB code works for ASCII and ISO 8859, and MB characters use less space than do wide characters. However, manipulating individual characters within a multibyte string is difficult.Applications that do heavy string manipulation typically use WC strings for such activity, because manipulating individual WC characters in a string is much simpler than doing the same thing with MB characters. So wide characters are used as necessary to provide programming ease or runtime speed; however, they take up more space than MB characters.LBL="" HELPID=""Traditional ASCII (8859) StringsTraditional strings are merely a special case of multibyte strings, where every character happens to be one byte long and there is only one codeset. All MB code, including conversion to and from wchars, works for traditional ASCII, or ISO 8859, strings.ID="10.intl21"LBL="" HELPID=""Multibyte CharactersA multibyte character is a series of bytes. The character itself contains information on how many bytes long it is. Multibyte characters are referenced as strings (and are therefore of type ID="10.intl22"char *); before parsing, a string is indistinguishable from a multibyte character. The zero byte is still used as a string (and MB character) terminator.A string of MB characters can be considered a null-terminated array of bytes, exactly like a traditional string. A multibyte string may contain characters from multiple codesets; usually, this is done by incorporating special bytes that indicate that the next character (and only the next character) will be in a different codeset. Very little application code should ever need to be aware of that, though; you should use the available library routines to find out information about multibyte strings rather than look at the underlying byte structure, because that structure will vary from one encoding to another. For one example of an encoding that allows characters from multiple codesets, see IDREF="31663" TYPE="TITLE""EUC."LBL="" HELPID=""Use of Multibyte StringsMultibyte strings are very easy to pass around. They efficiently use space (both data and disk space), since "extra" bytes are used only for characters that require them. MB strings can be read and written without regard to their contents, as long as the strings remain intact. Displaying MB strings on a terminal is done with the usual routines: printf(), puts(), and so on. Many programs (such as cat) need never concern themselves with the multibyte nature of MB strings, since they operate on bytes rather than on characters; so MB strings are often used for string I/O.Manipulation of individual characters in an MB string can be difficult, since finding a particular character or position in a string is nontrivial (see IDREF="59943" TYPE="TITLE""Handling Multibyte Characters,"
 below). Therefore, it is common to convert to WC strings for that kind of work.LBL="" HELPID=""ID="59943"Handling Multibyte CharactersUsually, multibyte characters are handled just like char strings. Editing such strings, however, requires some care.You cannot tell how many bytes are in a particular character until you look at the character. You cannot look at the nth character in a string without looking at all the previous n - 1 characters, because you cannot tell where a character starts without knowing where the previous character ends. Given a byte, you don't know its position within a character. Thus, we say the string has state or is context-sensitive; that is, the interpretation we assign to any given byte depends on where we are in a character.This analysis of characters is locale-dependent, and therefore must be done by routines that understand locale.LBL="" HELPID=""Conversion to Constant-Size CharactersMultibyte characters and strings are convertible to wchars via ID="10.intl23"mbtowc(3) (individual characters) and mbstowcs(3) (strings).LBL="" HELPID=""How Many Bytes in a Character?To find out how many bytes make up a given single MB character, use ID="10.intl24"mblen(3):#include <stdlib.h>
. . .
size_t n;
int len;
char *pStr;
. . .
len = mblen(pStr, n); /* examine no more than n bytes */It is the application's responsibility to ensure that pStr points to the beginning of a character, not to the middle of a character.The maximum number of bytes in a multibyte character is MB_LEN_MAX, which is defined in limits.h. The maximum number of bytes in a character under the current locale is given by the macro MB_CUR_MAX, defined in stdlib.h.LBL="" HELPID=""How Many Bytes in an MB String?Since ID="10.intl25"strlen() simply counts bytes before the first NULL, it will tell you how many bytes are in an MB string.LBL="" HELPID=""How Many Characters in an MB String?When mbstowcs() coverts MB strings to WC strings, it returns the number of characters converted. This is the simplest way to count characters in an MB string.Many code segments that need to deal with individual characters within a string would be better suited by wide character strings. Since counting often involves conversion, such segments are often better served by working with a WC string, then converting back.† †Getting the length without performing the conversion is straightforward, but not as simple. mbtowc() converts one character and returns the number of bytes used, but will return the same information without conversion if a NULL is passed as the address of the WC destination. Thus:len = mblen(pStr, n);is equivalent tolen = mbtowc((wchar_t *) NULL, pStr, n);In fact, mblen() calls mbtowc() to perform its count. Therefore, counting characters in an MB string without converting would look like this:int cLen;
char *tStr = pStr;

numChars = 0;
cLen = mbtowc((wchar_t *) NULL, tStr, MB_CUR_MAX);
while (cLen > 0) {
† †   tStr += cLen;
† †   numChars++;
† †   cLen = mbtowc((wchar_t *) NULL, tStr, MB_CUR_MAX);
† †   if (cLen == -1)
† †       numChars = cLen; /* invalid MB character */
}LBL="" HELPID=""Wide CharactersA wide character (ID="10.intl26"WC or wchar) is a data object of type wchar_t, which is guaranteed to be able to hold the system's largest numerical code for a character. wchar_t is defined in stdlib.h. Under IRIX 4.0.x, sizeof(wchar_t) was 1. Under IRIX 5.1, it is 4. All wchars on a system are the same size, independent of locale, encoding, or any other factors.LBL="" HELPID=""Uses for wchar StringsThe single advantage of WC strings is that all characters are the same size. Thus, a string can be treated as an array, and a program can simply index into the array in order to modify its contents. Most applications' char manipulation routines will work with little modification other than a type change to wchar_t, with appropriate attention to byte count and sizeof().So, when applications have significant string editing to perform, they typically keep the strings in WC format while doing that editing. Those WC strings may or may not be converted to or from MB strings at other points in the application.Wide characters are often large and are not as space efficient as multibyte strings. Applications that do not need to perform string editing probably shouldn't use† †wchars. If an application intends to both maintain and edit large numbers of strings, then the developer needs to make size/complexity trade-off decisions.LBL="" HELPID=""Support Routines for Wide CharactersAnalogs to the routines defined in string.h and stdio.h are supplied in libw.a and defined in widec.h. This includes routines such as getwchar(), putwchar(), putws(), wscpy(), wslen(), and wsrchr().LBL="" HELPID=""Conversion to MB CharactersWide characters and strings are convertible to MB strings via ID="10.intl27"wctomb() and wcstombs(), respectively.LBL="" HELPID=""Reading Input DataInput can be divided into two categories: user events and other data. This section deals with non-user-originated data, which is assumed to come from file descriptors or streams. User events are discussed in ID="10.intl28"IDREF="35476" TYPE="TITLE""User Input"
.It is generally fair to assume that unless otherwise specified, data read by an application is encoded suitably for the current locale. Text strings will typically be in MB format.Streams can be read in WC format by using routines defined in widec.h.LBL="" HELPID=""Cultural ItemsThis section discusses several aspects of a locale that may differ between locales.LBL="" HELPID=""String CollationDifferent locales can have different rules governing collation of strings, even within identical encodings.ID="10.intl29"LBL="" HELPID=""The IssueIn English, sorting rules are extremely simple: each character sorts to exactly one unique place. Under ASCII, the characters are even in numeric order. However, neither of those statements is necessarily true for other languages and other codesets. Furthermore:Sorting order for a language may be completely unrelated to the (numerical) order of the characters in a given encoding.Even with a correctly sorted list of the characters in a character set, you may not be able to sort words properly.Locales using identically encoded character sets may use very different sorting rules.Programs using ASCII can do simple arithmetic on characters and directly calculate sorting relationships; such programs frequently rely on truisms such as the fact that:'a' < 'b'in ASCII. But internationalized programs cannot rely on ASCII and English sorting rules. Consider some non-English collation rule types:One-to-Two mappings collate certain characters as if they were two. For example, the German ﬂ collates as if it were "ss".Many-to-One mappings collate a string of characters as if they were one. For example, Spanish sorts "ch" as one character, following "c" and preceding "d". In Spanish, the following list is in correct alphabetical order: calle, creo, chocolate, decir.Don't-Care Character rules collate certain characters as if they were not present. For example, if "-" were a don't-care character, "co-op" and "coop" would sort identically.First-Vowel rules sort words based first on the first vowel of the word, then by consonants (which may precede or follow the vowel in question).Primary/Secondary sorts consider some characters as equals until there is a tie. For example, in French, a, ·, ‡, and ‚ all sort to the same primary location. If two strings (such as "tache" and "t‚che") collate to the same primary order, then the secondary sort distinguishes them.Special case sorts exist for some Asian languages. For example, Japanese Kanji has no strict sorting rules. Kanji strings can be sorted by the strokes that make up the characters, by the kana (phonetic) spellings of the characters, or by other agreed-upon rules.It should be clear that a programmer cannot hope to collate strings by simple arithmetic or by traditional methods.LBL="" HELPID=""The SolutionLocale-specific collation should be performed with ID="10.intl30"strcoll() and strxfm(). These are table-driven functions; the tables are supplied as part of locale support. The value of LC_COLLATE determines which ordering table to use. strcoll() has the same interface as strcmp(); it can be directly substituted into code that uses strcmp().LBL="" HELPID=""Specification of Numbers and MoneyFormat of simple numbers differs from locale to locale. Characters used for decimal radix and group separators vary. Grouping rules may also vary. Even though we assume that decimal numbers are universal, there are some eighteen varying aspects of numeric formatting defined by a locale. Many of these are details of monetary formatting.ID="10.intl31"For example, Germany uses a comma to denote a decimal radix and a period to denote a group separator. English reverses these. India groups digits by two except for the last three digits before the decimal radix. Many locales have particular formats used for money, some of which are shown in IDREF="26942" TYPE="TABLE"Table 10-3
:COLUMNS="3"LBL="10-3"Table 10-3 ID="26942"Some Monetary FormatsLEFT="0" WIDTH="110"CountryLEFT="115" WIDTH="110"Positive FormatLEFT="230" WIDTH="356"Negative FormatLEFT="0" WIDTH="110"IndiaLEFT="115" WIDTH="110"Rs1,02,34,567.89LEFT="230" WIDTH="356"Rs(1,02,34,567.89)LEFT="0" WIDTH="110"ItalyLEFT="115" WIDTH="110"L.10.234.567LEFT="230" WIDTH="356"-L.10.234.567LEFT="0" WIDTH="110"JapanLEFT="115" WIDTH="110"•10,234,567LEFT="230" WIDTH="356"-•10,234,567LEFT="0" WIDTH="110"NetherlandsLEFT="115" WIDTH="110"F10.234.567,89LEFT="230" WIDTH="356"F-10.234.567,89LEFT="0" WIDTH="110"NorwayLEFT="115" WIDTH="110"Kr10.234.567,89LEFT="230" WIDTH="356"Kr10.234.567,89-LEFT="0" WIDTH="110"SwitzerlandLEFT="115" WIDTH="110"SFr10,234,567.89LEFT="230" WIDTH="356"SFr10,234,567.89CLBL="" HELPID=""printf()ID="10.intl32"printf() will examine LC_NUMERIC and choose the appropriate decimal radix. If none is available, it will try to use ASCII period. No further locale-specific formatting is done directly by printf(), but see IDREF="15279" TYPE="TITLE""Variably Ordered Referencing of printf() Arguments,"
 later in this chapter, for a way to do your own locale-specific output formatting.LBL="" HELPID=""localeconv()The ID="10.intl33"localeconv() function can be called to find out about numeric formatting data, including the decimal radix (inappropriately called decimal_point), the grouping separator (inappropriately called thousands_sep), the grouping rules, and a great deal of monetary formatting information. Actual use of formatting information other than the decimal radix is left to the application; there aren't any special print routines that produce formatted numbers according to all of localeconv()'s data.LBL="" HELPID=""Dates and TimesAll of these can mean the same date to different people:ID="10.intl34"92.1.4
4/1/92
1/4/92All of these can mean the same time to different people:2:30 PM
14:30
14h30Dates and times can be easily formatted by using strftime(), which gives a host of options for displaying locale-specific dates and times. The ascftime() and cftime() functions give further options, but should be avoided because they do not conform to ANSI and XPG/3 specifications. The old asctime() and ctime() functions are now obsolete; use strftime() instead. For more information, see the strftime(3C) manual page.LBL="" HELPID=""Character Classification and ctypeThe ID="10.intl35"ctype.h header file is described in the ctype(3C) manual page and defines macros to determine various kinds of information about a given character: isalpha(), isupper(), islower(), isdigit(), isxdigit(), isalnum(), isspace(), ispunct(), isprint(), isgraph(), iscntrl(), and isascii().LBL="" HELPID=""The IssueWhen programmers knew that a character set was ASCII, some convenient assumptions could be made about characters and letters. It was common for programmers to do arithmetic with the ASCII code values in order to perform some simple operations. For example, raising a character to upper case could be done by subtracting the difference between the code for a and the code for A. Numeric characters could be identified by inspection: if they fell between 0 and 9, they were numeric; otherwise, they weren't. You could tell if a character was (for instance) printable, a letter, or a symbol by comparing to known encoding values. Macros for such activity have long been available in ctype.h, but lots of programs did character arithmetic anyway. Since character encoding and linguistic semantics are completely independent, such arithmetic in an internationalized program will certainly lead to unpleasant results.Furthermore, characters exist outside of ASCII that break some non-arithmetic assumptions. Consider the German character ﬂ which is a lowercase alphabetic character (letter), yet has no uppercase. Consider also French (as written in France), where the uppercase of È is E, not ….Clearly, the programmer of an internationalized application has no way of directly computing all the character associations that were available in English under ASCII.LBL="" HELPID=""The SolutionStrict avoidance of arithmetic on character values should remove any trouble in this area. The macros in ctype.h are table-driven and are therefore locale-sensitive. If you think of characters as abstract characters rather than as the numbers used to represent them, you can avoid a lot of pitfalls in this area.LBL="" HELPID=""Functions Instead of MacrosThere is a function corresponding to each of the above-mentioned macros in ctype.h. In order to get a function instead of a macro, simply undefine the name, for example:#undef toascii
char (*xlate)(char);
char a, b;
...
xlate = toascii;
a = (*xlate)(b);LBL="" HELPID=""Regular ExpressionsXPG/3 specifies some extensions to traditional regular expression syntax for internationalized software. Few application developers do their own regular expression parsing and matching, however, so we will not include full details here. Briefly, the extensions provide the ability to specify matches based on:ID="10.intl36"character class (such as alpha, digit, punct, or space)equivalence class (for instance: a, ·, ‡, ‚, A, ¡, ¿, and ¬ may be equivalent)collating symbols (allowing you to match the Spanish "ch" as one element because it is a single collating token)generalization of range specifications of the form [c1-c2] to include the aboveProgrammers who will process expressions themselves will need the full description of internationalized regular expression grammar in Volume 3, Chapter 6, of XPG/3.LBL="" HELPID=""Strings and Message CatalogsMessage catalogs are compiled databases of strings. While a major role of message catalogs is to provide communications text in locale-specific natural language, the strings can be used for any purpose. The idea is that an application will use only strings from a catalog, thus allowing localizers to supply catalogs suitable for a given locale.ID="10.intl37"There are two different and incompatible interfaces to message catalogs in IRIX: MNLS and XPG/3. Developers working on SVR4 or other AT&T code, or related base-system utilities, will probably be using MNLS. Developers working on independent projects will likely be using XPG/3. Neither is a solid standard, but XPG/3 is closer to being one than MNLS, and its prognosis looks brighter. Thus applications developers who have to choose between the two interfaces are encouraged to use XPG/3 in order to maximize their portability.XPG/3 seems to be more popular in Europe. Asia seems to lean toward MNLS.† †LBL="" HELPID=""XPG/3 Message CatalogsThe XPG/3 message catalog interface requires that a catalog be opened before it is read, and requires that catalog references specify a catalog descriptor.ID="10.intl38"Since catalog references include a default to be used in case of failure, applications will work normally without a catalog when in the default locale. This means catalog generation is exclusively the task of localizers. But in order to inform the localizer as to what strings to translate and how they should comprise a catalog, the application developer should provide a catalog for the developer's locale.LBL="" HELPID=""Opening and Closing XPG/3 Catalogscatopen() locates and opens a message catalog file:#include <nl_types.h>
nl_catd catopen(char *name, int unused);The argument name is used to locate the catalog. Usually, this is a simple, relative pathname that is combined with environment variables to indicate the path to the catalog (see IDREF="69643" TYPE="TITLE""XPG/3 Catalog Location"
 for details). However, names that begin with "/ " are assumed to be absolute pathnames to the catalog. Use of a hard-coded pathname like this is strongly discouraged; it doesn't allow the user to specify the catalog's locale through environment variables.When an application is finished using a message catalog, it should close the catalog and free the descriptor using catclose():int catclose(nl_catd);LBL="" HELPID=""Using an XPG/3 CatalogCatalogs contain sets of numbered messages. The application developer must know the contents of the catalog in order to specify the set and number of a message to be obtained.ID="10.intl39"catgets() is used to retrieve strings from a message catalog:#include <nl_types.h>
char *catgets (nl_catd catd, int set_num, int msg_num,
† †              char *defaultStr);catgets() retrieves message msg_num from set set_num from the catalog described by catd. If for any reason catgets() cannot do this, it returns defaultStr. 
IDREF="76198" TYPE="TEXT"Example 10-1
 shows a program which reads the first message from the first message set in the appropriate catalog, and displays the result.LBL="10-1"Example 10-1 ID="76198"Reading an XPG/3 Catalog#include <stdio.h>
#include <locale.h>
#include <nl_types.h>

#define SET1      1
#define WRLD_MSG  1

int main(){
† †   nl_catd msgd;
† †   char *message;
† †   setlocale(LC_ALL, "");

† †   msgd = catopen("hw",0);
† †   message = catgets(msgd, SET1, WRLD_MSG,"Hello, world\n");
† †   printf(message);
† †   catclose(msgd);
}The above example uses printf() instead of puts() in order to make a point: the format string of printf() came from a catalog. Note that:printf(catgets(msgd, set, num, defaultStr));is very different from:printf("%s", catgets(msgd, set, num, defaultStr));because strings in catalogs can contain formatting strings of the kind used by printf(). For further discussion of issues relating to this important distinction, see IDREF="15279" TYPE="TITLE""Variably Ordered Referencing of printf() Arguments."LBL="" HELPID=""ID="69643"XPG/3 Catalog LocationXPG/3 message catalogs are located using the environment variable NLSPATH. The default NLSPATH is /nlslib/%L/%N, where %L is filled in by the LANG environment variable and %N is filled in by the name argument to catopen(). NLSPATH can specify multiple pathnames in ordered precedence, much like the PATH variable. A sample NLSPATH assignment:NLSPATH=/usr/lib/locale/%L/%N:/usr/local/lib/locale/%L/%N:/usr/defaults/%NFull details are in the catopen(3) manual page.LBL="" HELPID=""Creating XPG/3 Message CatalogsMessage catalogs are of this general form:ID="10.intl40"$set n† †comment
a† †message-a\n
b† †message-b\n
c† †message-c\n
$quote "
d " message-d "
$this is a comment
$this is another commentEach message is identified by a message number and a set. Sets are often used to separate messages into more easily usable groups, such as error messages, help messages, directives, and so on. Alternatively, you could use a different set for each source file, containing all of that source file's messages."$set n" specifies the beginning of set n, where n is a set identifier in the range from 1 to NL_SETMAX. All messages following the "$set n" statement belong to set n until either a $delset or another $set is reached. You can skip set numbers (for example, you can have a set 3 without having a set 2), but the set numbers that you use must be listed in ascending numerical order (and every set must have a number). Any string following the set identifier on the same line is considered a comment."$delset n" deletes the set n from a message catalog."$quote c" specifies a quote character, c, which can be used to surround message text so that trailing spaces or null (empty) messages are visible in a message source line. By default, there is no quote character and messages are separated by newlines. To continue a message onto a second line, add a backslash to the end of the first line:$set 1
1 Hello, world.
2 here is a long \
string.\n
3 Hello again.
n† †message-text-nMessage #2 in set #1 is "here is a long string.\n".LBL="" HELPID=""Compiling XPG/3 Message CatalogsAfter creating the message catalog sources, you need to compile them into binary form using ID="10.intl41"gencat, which has the following syntax:gencat catfile† †msgfile [msgfile ...]where catfile is the target message catalog and msgfile is the message source file. If an old catfile exists, gencat will attempt to merge new entries in with the old. gencat "resolves" set and message number conflicts with new information replacing the old.The catfile then needs to be placed in a location where catopen() can find it; see the IDREF="69643" TYPE="TITLE""XPG/3 Catalog Location"
 section of this chapter, above.LBL="" HELPID=""SVR4 MNLS Message CatalogsThere are many ways to use strings from MNLS message catalogs. You can get strings directly and then use them, or you can use output routines that search catalogs.ID="10.intl42"LBL="" HELPID=""ID="71066"Specifying MNLS CatalogsMNLS message catalogs do not need to be specifically opened. The catalog of choice can be set explicitly once, or it can be specified every time a string is needed.To specify the default message catalog to be used by subsequent calls to MNLS routines that reference catalogs (such as gettxt(), tfmt(), or pfmt()), use setcat():#include <pfmt.h>
char *setcat(const char *catalog);where catalog is limited to 14 characters, with no character equal to zero or the ASCII codes for / (slash) or : (colon). setcat() doesn't check to see if the catalog name is valid; it just stores the string for future reference. For an example of use, see IDREF="46749" TYPE="TITLE""Getting Strings from MNLS Message Catalogs,"
 below. The catalog indicated by the string can be found in the directory /usr/lib/locale/localename/LC_MESSAGES.LBL="" HELPID=""ID="46749"Getting Strings from MNLS Message CatalogsMNLS message catalogs do not need to be specifically opened. The catalog of choice can be set explicitly once, or it can be specified in each reference call. Strings are read from a catalog via gettxt():#include <unistd.h>
char *gettxt(const char *msgid, const char *defaultStr);msgid is a string containing two fields separated by a colon:msgfilename:msgnumberThe msgfilename is a catalog name as described previously in the IDREF="71066" TYPE="TITLE""Specifying MNLS Catalogs"
 section of this chapter. For example, to get message 10 from the MQ catalog, you could use either:char *str = gettxt("MQ:10", "Hello, world.\n");orsetcat("MQ");
str = gettxt(":10", "Hello, world.\n");LBL="" HELPID=""pfmt()ID="10.intl43"pfmt() is one of the most important routines dealing with MNLS catalogs, because it is used to produce most system diagnostic messages. pfmt() formats like printf() and produces standard error message formats. It can usually be used in place of perror(). For example,pfmt(stderr, MM_ERROR, "MQ:64:Permission denied");would produce, by default (such as when the Mozambique locale is unavailable),ERROR: Permission denied.The syntax of pfmt() is:#include <pfmt.h>
int pfmt(FILE *stream, long flags, char *format, ... );The flags are used to indicate severity, type, or control details to pfmt(). The format string includes information specifying which message from which catalog to look for. Flag details are discussed next in the IDREF="80731" TYPE="TITLE""Labels, Severity, and Flags"
 section of this chapter, and the format is discussed in the IDREF="23095" TYPE="TITLE""Format Strings for pfmt()"
 section.LBL="" HELPID=""ID="80731"Labels, Severity, and Flagspfmt() flags are composed of several groups; no more than one from each group should be specified. Specify multiple flags by OR'ing them together. The groups are:output format control:MM_NOSTD, MM_STDcatalog access control:MM_NOGET, MM_GETseverity:MM_HALT, MM_ERROR, MM_WARNING, MM_INFOaction message specification:MM_ACTIONpfmt() prints messages in the form label:severity:text. Severity is specified in the flags. The text comes from a message catalog (or a default) as specified in the format, and the label is specified earlier by the application.In the example above, we get only:ERROR: Permission denied.if no label has been set. Typically, an application will set the label once early in its life; subsequent error messages will have the label prepended. For example:setlabel("UX:myprog");
...
pfmt(stderr, MM_ERROR, "MQ:64:Permission denied");would produce (by default):UX:myprog: ERROR: Permission denied.For details, consult the pfmt(3) and setlabel(3) manual pages.LBL="" HELPID=""ID="23095"Format Strings for pfmt()pfmt() format strings are of the form:[[catalog:]messagenum:]defaultstringThe catalog field is in the format described above in the IDREF="71066" TYPE="TITLE""Specifying MNLS Catalogs"
 section of this chapter. messagenum is the message number in the catalog to use as the format. defaultstring specifies the string to use if the catalog lookup fails for any reason.An important feature of pfmt() is its ability to refer to format arguments in format-specified order just as printf() does. See IDREF="15279" TYPE="TITLE""Variably Ordered Referencing of printf() Arguments"
 for details.LBL="" HELPID=""fmtmsg()ID="10.intl44"fmtmsg() is a comprehensive formatter using the MNLS catalogs and "standard" formats. You probably won't need to use it; most applications should get by with pfmt(), gettxt(), and printf(). Consult the fmtmsg(3) manual page for details.LBL="" HELPID=""Putting Strings into a CatalogAn MNLS catalog source file contains merely a list of strings, separated by newlines. For an empty string, an empty line is used. Strings are referenced by line number in the original source file.When you add new strings to an existing catalog source, always append them to the end of the filename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'otherwise, other applications will no longer know where in the catalog their strings are. But if you want to modify a string already in the catalog, don't append a modified copy to the end of the file; just change the old version directly.There are tools that will help you compile MNLS message catalogs. exstr, for instance, extracts strings directly from your source code and replaces them with calls to the message retrieval function. See IDREF="84797" TYPE="TITLE""Message Catalogs" in Chapter 11
 for more information about creating message catalogs.When a file of strings is ready to be compiled, simply run mkmsgs and put the results in the directory /usr/lib/locale/localename/LC_MESSAGES.LBL="" HELPID=""ID="15279"Variably Ordered Referencing of printf() ArgumentsID="10.intl45"printf() and its variants can now refer to arguments in any specified order. Consider the following scenario: an application has chosen "house" from a list of objects and "white" from a list of colors. The application wishes to display this choice. The code might look like:char *obj, *color;
... /* make choices */ ...
printf("%s %s\n", color, obj);And the printf() yields:white houseEven once we make sure that obj and color are localized strings, we are not quite finished. If our locale is Spanish, the printf() will yield:blanca casawhich is wrong; in Spanish, it should say:casa blancaThe solution to this problem is variably ordered referencing of printf() arguments. The syntax of printf() format strings has been expanded.If a format string used to contain %T (where T represents one of the printf() conversion characters), the string can now contain %D$T. The T is the same, but the D specifies which argument from the argument list should be used.This means you can write:printf("2nd parameter is %2$s; the 1st is %1$s", p1, p2)and the second parameter will get printed first, with the first parameter printed second. For example:char *store = "Macy's";
char *obj = "a cup";

printf("At %1$s, I bought %2$s.\n", store, obj);
printf("I bought %2$s at %1$s.\n", store, obj);yields:At Macy's, I bought a cup.
I bought a cup at Macy's.even though the parameters to printf() are in the same order.In English, we are able to come up with strings suitable for either word order; in some other language, we might not be so lucky. Nor can we predict which order such languages might prefer. So the developer has no way of knowing how to create traditional printf() format strings suitable for all languages.Developers should therefore use message catalogs for their printf() format strings that take linguistic parameters, and allow localizers to localize the format strings as well as text strings. This means that the localizer has much greater ability to create intelligible text. An internationalized version of the above might look like:/* internationalized (XPG/3) version */
char *form = catgets(msgd, set, formNum,
† †                  "At %1$s, I bought %2$s.\n");
char *store = catgets(msgd, set, storeNum, "Macy's");
char *obj = catgets(msgd, set, objNum, "a cup");

printf(form, store, obj);The unlocalized (default) version would produce:At Macy's, I bought a cup.and a localized version might produce:ComprÈ una tasa en Macy's.In practice, variably ordered format strings are only found in message catalogs and not in default strings. The default string usually simply uses the parameters in the order they're given, without the new variable-order format strings.LBL="" HELPID=""Changes to Support Internationalization in X11R5X11R5 internationalization support is provided on the X client side; that is, the application must take care of such support instead of relying on the X server. No server changes are necessary, and the protocol is unchanged. Full backward compatibility is preserved, so a new internationalized application can run on an old server.ID="10.intl46"X uses existing internationalization standards to do its internationalization support; thus, there are no X-specific interfaces to set and change locale. Internationalized X applications receive no help from X when attempting multilingual support. There are no locales or special process states peculiar to X.LBL="" HELPID=""Some Effects of X ConsiderationsSince X is locale-independent, there are some limitations on its ability to support internationalization. The X protocol and Xlib specification, together with ANSI C and POSIX restrictions, have led to the following choices being made in X11R5:LBL="" HELPID=""Vertical TextThere is no built-in support for vertical text. Applications may draw strings vertically only by laying out the text manually.ID="10.intl47"LBL="" HELPID=""Character SetsIn previous releases of X, there was no general support for character sets other than Latin 1. X11R5, however, does allow other character sets.ID="10.intl48"X11R5 includes the definition of the X Portable Character Set, which is required to exist in all locales supported by Xlib. There is no encoding defined for this set; it is only a character set. The set, similar to printable ASCII, consists of these characters:abcdefghijklmnoqrstuvwxyz
ABCDEFGHIJKLMNOPQRSTUVWXYZ
0123456789
!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
<space> <tab> <newline>The Host Portable Character Encoding is the encoding of the X Portable Character Set on the Xlib host. This encoding is part of X, and is thus independent of localename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the coding remains the same for all locales supported by the host.Strings used or returned by Xlib routines are either in the Host Portable Character Encoding or a locale-specific encoding. The Xlib manual pages specify which encodings are used where. Some string constructs (such as TextProperty) contain information regarding their own encoding.LBL="" HELPID=""Xlib Interface ChangeFull use of X11R5's internationalization features means calling some new routines supplied in the X11R5 Xlib. While all old Xlib applications will work with the new Xlib, developers will be asked to change their code in places. These are described below.LBL="" HELPID=""Resource NamesResource names are compiled into programs. Because of that, their encoding must be known independent of locale. Trying to add a level of indirection here results in a chicken-and-egg problem: you're always left with something compiled that therefore can't be localized. Resource names therefore use the X Portable Character Set. The names may be anything; at least they'll mean something to the application author. (If the names were (for example) numbers, they would be meaningless to everybody.)ID="10.intl49"LBL="" HELPID=""Getting X Internationalization StartedXlib's internationalization state, like that of libc, needs to be initialized.LBL="" HELPID=""ID="47944"Initialization for Xlib ProgrammingInitialize Xlib's internationalization state after calling setlocale(). Xlib is being initialized, not a server or server-specific object, so a server connection is not necessary:if ( setlocale(LC_ALL, "") == NULL )
† †   exit_with_error();
if ( ! XSupportsLocale() )
† †   exit_with_other_error();
if ( XSetLocaleModifiers("") == NULL)
† †   give_warning();Just as passing an empty string to setlocale() honors the user's environment, so does passing an empty string to XSetLocaleModifiers().LBL="" HELPID=""Initialization for Toolkit Programmingsetlocale() should be called as early as possible after execution begins. If the locale is set, standard toolkit initialization interfaces will perform required X initialization; no extra work is necessary.LBL="" HELPID=""FontsetsIn X11R5, unlike previous releases of X, a string may contain characters from more than one codeset. There are several methods for determining which codeset a given character is in; which method is appropriate depends on the locale and the encoding used.ID="10.intl50"Such multiple-codeset strings usually cannot be rendered using a single font. A fontset is a collection of fonts suitable for rendering all codesets represented in a locale's encoding. A fontset includes information to indicate which locale it was created in. Applications create fontsets for their own use; when a program creates a fontset, it will be told which of the requested fonts are unavailable.LBL="" HELPID=""Example: EUC in JapaneseTo render strings encoded in EUC in Japanese (see ID="10.intl51"IDREF="27791" TYPE="TITLE""Asian Languages"
), an application would need fonts encoded in 8859-1, JIS X 208, and JIS X 201. The application doesn't need to know which characters in a string go with which font, since it doesn't get into locale specifics. So it creates a fontset that is made from a list of user-specified fonts (under the assumption that the localizer has provided an appropriate list). Rendering is then done using that fontset. The locale-aware rendering system will choose the appropriate fonts for each character being rendered, from the supplied list.LBL="" HELPID=""Specifying a FontsetA fontset specification is just a string, enumerating XLFD names of fonts. (See ID="10.intl52"X Logical Font Description Conventions, an MIT X Consortium standard.) This string can include wild card characters. For example, a specification of 15-point "fixed" fonts might be:char *fontSetSpecString = "*fixed-medium-r-normal*150*";A particular server might expand this to:-jis-fixed-medium-r-normal--16-150-75-75-c-160-jisx0208.1983-0
-sony-fixed-medium-r-normal--16-150-75-75-c-80-iso8859-1
-sony-fixed-medium-r-normal--16-150-75-75-c-80-jisx0201.1976-0Specifying the fontset by simply enumerating the fonts is perfectly acceptable:char *fontSetSpecString =
"-jis-fixed-medium-r-normal*150-75-75*jisx0208.1983-0,\
-sony-fixed-medium-r-normal*150-75-75*iso8859-1,\
-sony-fixed-medium-r-normal*150-75-75*jisx0201.1976-0";A German locale would use this fontset with interest only in the ISO font; a Japanese locale might use all three; a Chinese locale would have trouble with this fontset.The developer should specify a default fontset suitable for the default locale. Furthermore, developers should ensure that the application will accept localized fontset specifications via resources (or message catalogs) or command line options. Localizers are responsible for providing default fontset specifications suitable for their locales.LBL="" HELPID=""Creating a FontsetCreating fontsets in X is simply a matter of providing a string that names the fonts, as described above.XFontSet fontset;
char *base_name;  /* should get from resource */
char **missingCharsetList;
int missingCharsetCount;
char *defaultStringForMissingCharsets;

base_name = "*fixed-medium-r*150*"; /* use resources! */

fontset = XCreateFontSet(display, base_name,
† †                      &missingCharsetList,
† †                      &missingCharsetCount,
† †                      &defaultStringForMissingCharsets);The locale in effect at create time is bound to the fontset. Fontsets are freed with XFreeFontSet().LBL="" HELPID=""Using a FontsetFontsets are used when rendering text with X11R5 Xmb or Xwc text rendering routines. These routines are described in IDREF="20370" TYPE="TITLE""Text Rendering Routines,"
 below.LBL="" HELPID=""ID="20370"Text Rendering RoutinesX11R5 includes text rendering routines that understand multibyte and wide character strings. These routines are analogs to the X11R4 text rendering routines ID="10.intl53"XDrawText(), XDrawString(), and XDrawImageString(). The old routines continue to operate, but do not take fontsets, and don't know how to handle characters longer than one byte.XmbDrawText() and XwcDrawText() take lists of TextItems, each of which contains (among other things) a string. The strings are rendered using fontsets. These routines allow complex spacing and fontset shifts between strings.XmbDrawString() and XwcDrawString() render a string using a fontset. These routines render in foreground only and use the raster operation from the current graphics context.XmbDrawImageString() and XwcDrawImageString also render a string using a fontset. These routines fill the background rectangle of the entire string with the background, then render the string in the foreground color, ignoring the currently active raster operation.Consult the appropriate manual pages for more details on these routines.LBL="" HELPID=""New Text Extents FunctionsX11R5 provides MB and WC versions of width and extents interrogation routines, supplying the maximum amount of space required to draw any character in a given fontset. These routines depend on fontsets to interpret strings and use locale-specific data.The XFontSetExtents structure contains the two kinds of extents a string can have:typedef struct {
† †   XRectangle max_ink_extent;
† †   XRectangle max_logical_extent;
} XFontSetExtents;max_ink_extent gives the maximum boundaries needed to render the drawable characters of a fontset. It considers only the parts of glyphs that would be drawn, and gives distances relative to a constant origin. max_logical_extent gives the maximum extent of the occupied space of drawable characters of a fontset. The occupied space of a character is a rectangle specifying minimum distance from other graphical features; other graphics generated by a client should not intersect this rectangle. max_logical_extent is used to compute interline spacing and the minimum amount of space needed for a given number of characters.Here are descriptions of a few of the new extents-related functions (consult the appropriate manual pages for details):XExtentsOfFontSet() returns an XFontSetExtents structure for a fontset.XmbTextEscapement() and XwcTextEscapement() take a string and return the distance in pixels (in the current drawing direction) to the origin of the next character after the string, if the string were drawn. Escapement is always positive, regardless of direction.XmbTextExtents() and XwcTextExtents() take a string and return information detailing the overall rectangle bounding the string's image and the space the string occupies (for spacing purposes).XmbTextPerCharExtents() and XwcTextPerCharExtents() take a string and return ink and logical extents for each character in the string. This can be used for redrawing portions of strings or for word justification. If the fontset might include context-dependent drawing, the client cannot assume that it can redraw individual characters and get the same rendering.XContextDependentDrawing() returns a Boolean telling whether a fontset might include context-dependent drawing.LBL="" HELPID=""ID="35476"User InputJust as internationalized programs cannot assume that data is in ASCII, they cannot assume that user input will use any specific keyboard. Keyboards change from country to country and language to language; internationalized software should never assume that a certain position on the keyboard is bound to a certain character, or that a given character will be available as a single keystroke on all keyboards.ID="10.intl54"No useful physical keyboardname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'not even one specifically designed for multilingual workname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'could possibly contain a key for every character we would ever wish to type. Certainly there are characters commonly used in other areas of the world that are not present on most USA keyboards. So methods have been invented that provide for input of almost any known character on even the most naÔve keyboards. These schemes are referred to as input methods (IMs).IMs should not be confused with IRIS IM, Silicon Graphics' port of OSF/Motif.† †Input methods vary significantly in design, use, and behavior, but there is a single API that developers use to access them. The object is for the application simply to ask for an IM and let the system check the locale and choose the appropriate IM.Some IMs are complex; others are very simple. The API is designed to be a low-level interface, like Xlib. Usually, only toolkit text object authors will have to deal with the IM interfaces. However, some applications developers are unable to use toolkit objects, so the concepts are described here.LBL="" HELPID=""Don't Use This Section If You Can Avoid ItThis section (IDREF="35476" TYPE="TITLE""User Input"
) has to do with the translation of physical user events into programmatic character strings or special keyboard data (such as "backspace"). This kind of work should be done by toolkits. If you can use a toolkit to manage event processing for you, do so, and blissfully ignore this section. If you are writing a toolkit text object, or are writing a truly extraordinary application, then this section is for you.LBL="" HELPID=""Reuse Sample CodeA sample program demonstrating some of the concepts in this chapter is given in chapter 11 of the Xlib Programming Manual, Volume One. Looking carefully at that code may be easier than starting from scratch.LBL="" HELPID=""GL InputThe old GL function ID="10.intl55"qdevice() has a hard-coded view of a keyboard (see /usr/include/gl/device.h for details). Some flexibility, particularly for Europe, is available if you queue KEYBD instead of individual keys, but the GL has no general solution to non-ASCII input. There is no supported way to input Chinese (for instance) to the old GL.The OpenGL does not contain input code but leaves that to the operating environment, which in IRIX means X.In short, support for internationalized input means a departure from qread(). Under IRIX, that means using mixed-model input, all the more reason to use a toolkit.LBL="" HELPID=""Keys, Keycodes, and KeysymsThis section provides some background that may help make the following sections easier to understand.LBL="" HELPID=""X Keyboard Support: a Brief TutorialWhen a client connects to the X server, the server announces its range of ID="10.intl56"keycodes and exports a table of keysyms. Each key event the client receives has a single byte keycode, which directly represents a physical key, and a single byte state, which represents currently engaged modifier keys, such as Shift or Alt.The mapping of state bits to modifiers is done by another table acquired from the server.† †Keysyms are well defined, and there has been an attempt to have a keysym for every engraving one might possibly find on any keyboard, anywhere. (An engraving is the image imprinted on a physical key.) These are contained in /usr/include/X11/keysymdef.h. Keysyms represent the engravings on the actual keys, but not their meanings. The server's idea of the keysym table can be changed by clients, and clients may receive KeyMap events when this remapping happens; but such events don't happen often.When a client receives a Key event, it asks Xlib to use the keycode to index into its keysym table to find a list of keysyms. (This list is usually very short. Most keys have only one or two engravings on them.) Using the state byte, Xlib chooses a keysym from the list to find out what was engraved on the key the user pressed.At this point, the client can choose to act on the keysym itself (if, for instance, it was a backspace) or it can ask for a character string represented by the keysym (or both). Generating such a string is tricky; it is discussed in IDREF="51546" TYPE="TITLE""Input Methods,"
 below.Details on X keyboard support can be found in X Window System, Third Edition, from Digital Press. Details on input methods are also available in that book, as well as in the Xlib Programming Manual, Volume One.LBL="" HELPID=""Composed CharactersThere are two ways to compose characters that do not exist on a keyboard: explicit and implicit.ID="10.intl57"It is common for an application to be modal and switch between the two. For example, Japanese input of kana is often done via implicit composition. Users switch between a mode where input is interpreted as Romaji (Latin characters) and a mode where strokes are all translated to kana.Furthermore, both styles may operate simultaneously. While an application is supporting implicit composition of certain characters, other characters may be composable via explicit composition.So remember that not every keystroke will produce a character, even if the associated keysym would normally imply character text. The event-to-string translation routines (see, for example, IDREF="24219" TYPE="TITLE""XLookupString(), XwcLookupString(), and XmbLookupString()"
 in this chapter) will figure out what result a given set of keystrokes should produce.LBL="" HELPID=""Explicit CompositionExplicit composition is requested when the user presses the Compose key and then types a key sequence that corresponds to the desired character. For example, to compose the character `Ò' under some keymaps, you might press the Compose key and then type "~n".The Compose key can be defined by using xmodmap(1) to map the XK_Multi_key keysym onto whatever key you want to use as Compose.† †LBL="" HELPID=""Implicit CompositionImplicit composition mimics many existing European typewriters that have "dead" keys: keys that type a character but do not advance the carriage. When a special "dead" key is struck, the system attempts to compose a character using the next character struck. For example, on a keyboard that had a diaeresis (®) and an O, but no ÷, one would simply strike `®' and then `O' to compose `÷'.Implicit composition support usually comes with some specified way to leave characters uncomposed.LBL="" HELPID=""KeyboardsIRIX currently supports 12 keyboard layouts: American, Belgian, Danish, English, French, German, Italian, Norwegian, Portuguese, Spanish, Swedish, and Swiss.ID="10.intl58"All are representable in Latin 1; the American keyboard needs only ASCII.LBL="" HELPID=""ID="51546"Input MethodsInput methods (IMs) are ways to translate keyboard-input events into text strings. You would use a different input method, for instance, to type on a USA keyboard in Chinese than to type on the same keyboard in English. Nobody would build a keyboard suitable for direct input of the roughly 80,000 distinct Chinese characters.ID="10.intl59"IMs come in two flavors, front-end and back-end. Both types can use identical application programming interfaces, so we lose no generality by using back-end methods for our examples here.To use an IM, follow these steps:Open the IM.Find out what the IM can do.Agree upon capabilities to use.Create input contexts with preferences and window(s) specified (see IDREF="64169" TYPE="TITLE""Input Contexts (ICs),"
 later in this chapter).Set the input context focus.Process events.Although all applications go through the same setup when establishing input methods, the results can vary widely. In a Japanese locale, one might end up with networked communications with an input method and a Kanji translation server, with circuitous paths for Key events. But in (say) a Swiss locale, it is likely that nothing would occur besides a flag or two being set in Xlib. Since operating in non-Asian locales ends up bypassing almost all of the things that might make input methods expensive, Western users are not noticeably penalized for using Asia-ready applications.LBL="" HELPID=""Opening an Input MethodID="10.intl60"XOpenIM() opens an input method appropriate for the locale and modifiers in effect when it is called. The locale is bound to that IM and cannot be changed. (But you could open another IM if you wanted to switch later.) Strings returned by XmbLookupString() and XwcLookupString() will be encoded in the locale that was current when the IM was opened, regardless of current input context.The syntax is:XIM XOpenIM(Display *dpy, XrmDataBase db, char *res_name,
† †           char *res_class);where res_name is the resource name of the application, res_class is the resource class, and db is the resource database that the input method should use for looking up resources private to itself. Any of these can be NULL.So opening an IM is easy:XIM im;
im = XOpenIM(dpy, NULL, NULL, NULL);
if (im == NULL)
† †   exit_with_error();XOpenIM() finds the IM appropriate for the current locale. If XSupportsLocale() has returned good status (see the IDREF="47944" TYPE="TITLE""Initialization for Xlib Programming"
 section of this chapter) and XOpenIM() fails, something is amiss with the administration of the system.The library routines are not prepared for the possibility of XSupportsLocale() succeeding and XOpenIM() failing, so it's up to application developers to deal with such an eventuality. (This circumstance could occur, for example, if the IM died after XSupportsLocale() was called.) This topic is under some debate in the MIT X consortium.† †Most of the complexity associated with IM use comes from configuring an input context to work with the IM. Input contexts are discussed in IDREF="64169" TYPE="TITLE""Input Contexts (ICs),"
 elsewhere in this chapter.To close an input method, call XCloseIM().LBL="" HELPID=""IM StylesIf the application requests it, an input method can often supply status information about itself. For example, a Japanese IM may be able to indicate whether it is in Japanese input mode or Romaji input mode. An input method can also supply pre-edit information, partial feedback about characters in the process of being composed. The way in which an IM deals with status and pre-edit information is referred to as an IM style. This section describes styles and their naming.LBL="" HELPID=""Root WindowThe ID="10.intl61"Root Window style has a pre-edit area and a status area in a window owned by the IM as a descendant of the root. The application does not manage the pre-edit data, the pre-edit area, the status data, or the status area. Everything is left to the input method to do in its own window, as illustrated in IDREF="81313" TYPE="GRAPHIC"Figure 10-1
:LBL="10-1" FILE="10.intl.cgm" POSITION="INLINE" SCALE="FALSE"LBL="10-1"Figure 10-1 ID="81313"Root Window InputLBL="" HELPID=""Off-the-SpotThe ID="10.intl62"Off-the-Spot style places a pre-edit area and a status area in the window being used, usually in reserved space away from the place where input appears. The application manages the pre-edit area and status area, but allows the IM to update the data there. (The application provides information regarding foreground and background colors, fonts, and so on.) A window using Off-the-Spot input style might look like that shown in IDREF="68750" TYPE="GRAPHIC"Figure 10-2
:LBL="10-2" FILE="10.intl.cgm2" POSITION="INLINE" SCALE="FALSE"LBL="10-2"Figure 10-2 ID="68750"Off-the-Spot InputLBL="" HELPID=""Over-the-SpotThe ID="10.intl63"Over-the-Spot style involves the IM creating a (small) pre-edit window over the point of insertion. The window is owned and managed by the IM as a descendant of the root, but it gives the user the impression that input is being entered in the right place; in fact, the pre-edit window often has no borders and is invisible to the user, giving the appearance of On-the-Spot input. The application manages the status area as in Off-the-Spot, but specifies the location of the editing so that the IM can place pre-edit data over that spot.LBL="" HELPID=""On-the-SpotID="10.intl64"On-the-Spot input is by far the most complex for the application developer. The IM delivers all pre-edit data via callbacks to the application, which must perform in-place editingname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'complete with insertion and deletion and so on. This approach usually involves a great deal of string and text rendering support at the input generation level, above and beyond the effort required for completed input. Since this may mean a lot of updating of surrounding data or other display management, everything is left to the application. There is little chance an IM could ever know enough about the application to be able to help it provide user feedback. The IM therefore provides status and edit information via callbacks.Done well, this style can be the most intuitive one for a user.LBL="" HELPID=""Setting IM StylesA style describes how an IM presents its pre-edit and status information to the user. An IM will supply information detailing its presentation capabilities. The information comes in the form of flags, OR'ed together. The flags to use with each style are:Root WindowXIMPreeditNothing | XIMStatusNothingOff-the-SpotXIMPreeditArea | XIMStatusAreaOver-the-SpotXIMPreeditPosition | XIMStatusAreaOn-the-SpotXIMPreeditCallbacks | XIMStatusCallbacksFor example, if you wanted a style variable to match an Over-the-Spot IM style, you could write:XIMStyle over = XIMPreeditPosition | XIMStatusArea;If an IM returns XIMStatusNone (not to be confused with XIMStatusNothing), it means the IM will not supply status information.LBL="" HELPID=""Using StylesAn input method supports one or more styles. It is up to the application to find a style that is supported by both the IM and the application. If there are several, the application must choose. If there are none, the application is in trouble.LBL="" HELPID=""ID="64169"Input Contexts (ICs)An input method may be serving multiple clients, or one client with multiple windows, or one client with multiple input styles on one window. The specification of style and client/IM communication is done via ID="10.intl65"input contexts. An input context is simply a collection of parameters that together describe how to go about receiving and examining input under a given set of circumstances.To set up and use an input context:Decide what styles your application can support.Query the IM to find out what styles it supports.Find a match.Determine information that the IC will need in order to work with your application.Create the IC.Employ the IC.LBL="" HELPID=""Find an IM StyleThe IM may be able to support multiple stylesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for example, both Off-the-Spot and Root Window. The application may be able to do, in order of preference, Over-the-Spot, Off-the-Spot, and Root Window. The application should determine that the best match in this case is Off-the-Spot.First, discover what the IM can do, then set up a variable describing what the application can do:XIMStyles *IMcando;
XIMStyle  clientCanDo; /* note type difference */
XIMStyle  styleWeWillUse = NULL;

XGetImValues(im, XNQueryInputStyle, &IMcando, NULL);

clientCanDo =
/*none*/ XIMPreeditNone | XIMStatusNone |
/*over*/ XIMPreeditPosition | XIMStatusArea |
/*off*/  XIMPreeditArea | XIMStatusArea |
/*root*/ XIMPreeditNothing | XIMStatusNothing;A client should always be able to handle the case of XIMPreeditNone | XIMStatusNone, which is likely in a Western locale. To the application, this is not very different from a RootWindow style, but it will come with less overhead.Once we know what the application can handle, we look through the IM styles for a match:for(i=0; i<IMcando->count_styles; i++) {
† †   XIMStyle tmpStyle;
† †   tmpStyle = IMcando->support_styles[i];

† †   if ( ((tmpStyle & clientCanDo) == tmpStyle) &&
† †       prefer(tmpStyle, styleWeWillUse) )
† †           styleWeWillUse = tmpStyle;
}

if (styleWeWillUse = NULL)
† †   exit_with_error();
XFree(IMcando);

/* styleWeWillUse is set, which is what we were after */The prefer() routine simply applies some heuristic to application preference.LBL="" HELPID=""ID="62196"IC ValuesThere are several pieces of information an input method may require, depending on the input context and style chosen by the application. The input method can acquire any such information it needs from the input context, ignoring any information that does not affect the style or IM.A full description of every item of information available to the IM is supplied in X Window System, Third Edition. We include only a brief list here:XNClientWindow specifies to the IM which client window it can display data in or create child windows in. It is set once and cannot be changed.XNFilterEvents is an additional event mask for event selection on the client window.XNFocusWindow specifies the focus window. This specifies which window will get the processed (composed) Key events.XNGeometryCallback specifies a geometry handler that will be called if the client allows an IM to change the geometry of the window.XNInputStyle specifies the style for this IC.XNResourceClass and XNResourceName specify the resource class and name to use when the IM looks up resources that vary by IC.XNStatusAttributes and XNPreeditAttributes specify to an IM the attributes to be used for any status and pre-edit areas. The attributes are nested, variable-length lists.LBL="" HELPID=""Pre-edit and Status AttributesWhen an IM is going to provide state, it needs some simple X information with which to do its work. For example, if an IM is going to draw status information in a client window in an Off-the-Spot style, it needs to know where the area is, what color and font to render text in, and so on. The application gives this data to the IC for use by the IM.As with the IDREF="62196" TYPE="TITLE""IC Values"
 section, full details are available in X Window System, Third Edition.XNArea specifies a rectangle to be used as a status or pre-edit area.XNAreaNeeded specifies the rectangle desired by the attribute writer. Either the application or the IM may provide this information, depending on circumstances.XNBackgroundPixmap specifies a pixmap to be used for the background of windows the IM creates.XNColormap specifies the colormap to use.XNCursor specifies the cursor to use.XNFontSet specifies the fontset to use for rendering text.XNForeground and XNBackground specify the colors to use for rendering.XNLineSpacing specifies the line spacing to be used in the pre-edit window if more than one line is used.XNSpotLocation specifies where the next insertion point is, for use by XIMPreeditPosition styles.XNStdColormap specifies that the IM should use XGetRGBColormaps() with the supplied property (passed as an Atom) in order to find out which colormap to use.LBL="" HELPID=""Creating an Input ContextCreating an input context is a simple matter of calling XCreateIC() with a variable-length list of parameters specifying IC values. A simple example:XVaNestedList arglist;
XIC ic;

arglist = XVaCreateNestedList(0, XNFontSet, fontset,
† †                          XNForeground,
† †                          WhitePixel(dpy, screen),
† †                          XNBackground,
† †                          BlackPixel(dpy, screen),
† †                          NULL);

ic = XCreateIC(im, XNInputStyle, styleWeWillUse,
† †             XNClientWindow, window, XNFocusWindow, window,
† †             XNStatusAttributes, arglist,
† †             XNPreeditAttributes, arglist, NULL);
XFree(arglist);

if (ic == NULL)
† †   exit_with_error();LBL="" HELPID=""Using the ICA multi-window application may choose to use several input contexts. But for simplicity, we will assume that the application just wants to get to the internationalized input using one method in one window.Using the IC is a matter of (a) making sure we check events the IC wants and (b) setting IC focus. If you are setting up a window for the first time, you will know the event mask you want, and you can use it directly. If you are attaching an IC to a previously configured window, you should query the window and add in the new event mask.unsigned long imEventMask;

XGetWindowAttributes(dpy, win, &winAtts);
XGetICValues(ic, XNFilterEvents, &imEventMask, NULL);

imEventMask |= winAtts.your_event_mask;
XSelectInput(dpy, window, imEventMask);
XSetICFocus(ic);At this point, the window is ready to be used.LBL="" HELPID=""Events under IM ControlProcessing events under input method control is almost the same in X11R5 as it was under R4 and before. There are two essential differences: ID="10.intl66"XFilterEvent() and the LookupString routines.LBL="" HELPID=""XFilterEvent()Every event received by your application should be fed to the IM via XFilterEvent(), which will return a value telling you whether or not to disregard the event. IMs will ask you to disregard the event if they have extracted the data and plan on giving it to you later, possibly in some other form. All events (not just KeyPress and KeyRelease events) go to XFilterEvent().If we compacted the event processing into a single routine, a typical event loop would look something like this:Xevent event;

while (TRUE) {
† †   XNextEvent(dpy, &event);

† †   if (XFilterEvent(&event, None))
† †       continue;

† †   DealWithEvent(&event);
}LBL="" HELPID=""ID="24219"XLookupString(), XwcLookupString(), and XmbLookupString()When using an input method, you should replace calls to XLookupString() with calls to XwcLookupString() or XmbLookupString(). The MB and WC versions have very similar interfaces. In the examples below, we arbitrarily use XmbLookupString(), but the examples apply to both versions.There are two new situations to deal with:The string returned may be long.There may be an interesting keysym returned, an interesting set of characters returned, both, or neither.Dealing with the former is merely a matter of maintaining an arena, as in the example below.To tell the application what to pay attention to for a given event, XmbLookupString() returns a status value in a passed parameter, equal to one of the following:XLookupKeysym, which indicates the keysym should be checkedXLookupChars, which indicates a string has been typed or composedXLookupBoth, which means both of the aboveXLookupNone, which means neither is ready for processingXBufferOverflow, which means the supplied buffer is too smallname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'XmbLookupString() should be called again with a bigger bufferXmbLookupString() also returns the length of the string in question. Note that XmbLookupString() returns the length of the string in bytes, while XwcLookupString() returns the length of the string in characters.The example below should help show how these functions work. Most event processors perform a switch() on the event type; assume we have done that, and we have received a KeyPress event:case KeyPress:
{
† †   Keysym keysym;
† †   Status status;
† †   int buflength;
† †   static int bufsize = 16;
† †   static char *buf = NULL;

† †   if (buf == NULL) {
† †       buf = malloc(bufsize);
† †       if (buf < 0) StopSequence();
† †   }

† †   buflength = XmbLookupString(ic, &event, buf, bufsize,
† †                            &keysym, &status);

† †   /* first, check to see if that worked */
† †   if (status == XBufferOverflow) {
† †       buf = realloc(buf, (bufsize = buflength));
† †       buflength = XmbLookupString(ic, &event, buf, bufsize,
† †                                &keysym, &status);
† †   }

† †   /* We have a valid status. Check that */
† †   switch(status) {
† †   case XLookupKeysym:
† †   case XLookupBoth:
† †       DealWithKeysym(keysym);
† †       if (status == XLookupKeysym)
† †           break; /* wasn't XLookupBoth */
† †   case XLookupChars:
† †       DealWithString(buf, buflength);
† †   case XLookupNone:
† †       break;
† †   } /* end switch(status) */

} /* end case KeyPress segment */
break; /* we are in a switch(event.type) statement */LBL="" HELPID=""GUI ConcernsIt shouldn't be significantly more difficult to internationalize an application with a graphical user interface than an application without such an interface, but there are a few further issues that must be addressed.ID="10.intl67"LBL="" HELPID=""X Resources for StringsResource lookup mechanisms in Xlib as well as in toolkits monitor locale environment variables when locating resource files. For string constants that will be used within toolkit objects, resources provide a simpler solution than do message catalogs.ID="10.intl68"Some common objects that should definitely get their labels from resources:LabelsButtonsMenu itemsDialog notices and questionsAny object that employs some sort of text label should be labeled via resources. Since the localizer will want to provide strings for the local version of the application, the app-defaults file for the application should specify every reasonable string resource. Manual pages should identify all localizable string resources.Localizers of an application will provide a separate resource file for each locale that the application runs in.LBL="" HELPID=""LayoutLayout management is especially of interest when you cannot predict how large a button (or other) label might be. The nature of the problem of layout composition and management does not change, but one must construct the layout management without full knowledge of the final appearance.ID="10.intl69"It's worth noting that localization efforts can be assumed to be "reasonable" in some sense. For example, X resources have always allowed a user to specify an extremely large font for buttons, but applications correctly choose to let such users live with the results. But it's not always that clear what is reasonable and what isn't; we don't always know what will be difficult to translate succinctly in some locale. So while developers need not provide for all combinations of resource specifications, they must take the responsibility to make the application localizable.There are three main approaches to the layout problem.LBL="" HELPID=""Dynamic LayoutMost toolkits provide form, pane, rowcolumn, rubberboard, or other layout objects that will calculate layout depending on the "natural" (localized) size of the objects involved. Most use some hints provided by the developer that can regulate this layout. For example, some IRIS IM widgets providing these services are XmForm, XmPanedWindow, and XmRowColumn.Dynamic layout is probably the simplest way to prevent localization difficulties.IRIS IM is Silicon Graphics' port of OSF/Motif, and should not be confused with IM, the abbreviation for Input Methods.† †LBL="" HELPID=""Constant LayoutUnder certain circumstances, an application may insist on having a predefined layout. When this is so, the application must provide objects that are so constructed as to allow localization. A "Quit" button that just barely allows room for the Latin 1 string "Quit" is not likely to suffice when localizers attempt to fit their translations into that small space.In order to enforce constant layout, the developer incurs the heavy responsibility of making sure the objects are localizable. This means a lot of investigation; the "there, that ought to be enough" approach is chancy at best.LBL="" HELPID=""Localized LayoutSome toolkits provide for layout control by run-time reading of strings or other data files. Applications that use such toolkits can easily finesse the layout issue by providing capability for localization of the layout as well as the contents of the layout. This provides each localizer maximum freedom in presenting the application to the local users. The application developer is responsible for providing localizers with instructions and mechanisms necessary to produce layout data.LBL="" HELPID=""IRIS IM Localization with editresIRIX provides an interactive method of laying out widgets for IRIS IM and Xaw (the Athena Widget Set): a utility called editres. With editres, you can construct and edit resources and see how your widgets will look on the screen; the program even generates a usable app-defaults file for you. But note that if you hard-code any resources into your IRIS IM code, you won't be able to edit them using this method.LBL="" HELPID=""IconsIcons attempt to be fairly generic representations of their antecedents. Unfortunately, it is very difficult for a designer to know what is generic or recognizable in other cultures. Therefore, it is important that any pictographic representations used by an application be localizable.ID="10.intl70"Graphic representations can be stored as strings representing X bitmaps, as names of data files containing pictographs, or in whatever manner the developer thinks best, so long as the developer provides a way for the localizer to produce and deliver localized pictographs.LBL="" HELPID=""Some Popular EncodingsLBL="" HELPID=""The ISO 8859 FamilyAmerican English is easily representable in 7-bit ASCII. Most other languages are not. For example, the character È is not in ASCII.ID="10.intl71"Most Western European languages are representable in 8-bit ISO 8859-1, which is commonly known as Latin 1. Latin 1 is a superset of ASCII including characters used by several Western European languages (such as ˆ, £, Ò, Á, ø).ID="15634"ISO 8859 comes in nine parts, many overlapping, all supersets of ASCII, as shown in IDREF="62878" TYPE="TABLE"Table 10-4
:COLUMNS="3"LBL="10-4"Table 10-4 ID="62878"ISO 8859 Character SetsLEFT="0" WIDTH="110"Character setLEFT="115" WIDTH="110"Common nameLEFT="230" WIDTH="356"Languages supportedLEFT="0" WIDTH="110"8859-1LEFT="115" WIDTH="110"Latin 1LEFT="230" WIDTH="356"Danish, Dutch, English, 
Faeroese, Finnish, French, 
German, Icelandic, Irish, 
Italian, Norwegian, 
Portuguese, Spanish, 
SwedishLEFT="0" WIDTH="110"8859-2LEFT="115" WIDTH="110"Latin 2LEFT="230" WIDTH="356"Albanian, Czech, English, 
German, Hungarian, 
Polish, Rumanian, 
Serbo-Croatian, Slovak, 
SloveneLEFT="0" WIDTH="110"8859-3LEFT="115" WIDTH="110"Latin 3LEFT="230" WIDTH="356"Afrikaans, Catalan, Dutch, 
English, Esperanto, 
German, Italian, Maltese, 
Spanish, TurkishLEFT="0" WIDTH="110"8859-4LEFT="115" WIDTH="110"Latin 4LEFT="230" WIDTH="356"Danish, English, Estonian, 
Finnish, German, 
Greenlandic, Lapp, 
Latvian, Lithuanian, 
Norwegian, SwedishLEFT="0" WIDTH="110"8859-5LEFT="115" WIDTH="110"Latin/CyrillicLEFT="230" WIDTH="356"Bulgarian, Byelorussian, 
English, Macedonian, 
Russian, Serbo-Croatian, 
UkrainianLEFT="0" WIDTH="110"8859-6LEFT="115" WIDTH="110"Latin/ArabicLEFT="230" WIDTH="356"Arabic, English (see ISO 
8859-6 specification)LEFT="0" WIDTH="110"8859-7LEFT="115" WIDTH="110"Latin/GreekLEFT="230" WIDTH="356"English, Greek (see ISO 
8859-7 specification)LEFT="0" WIDTH="110"8859-8LEFT="115" WIDTH="110"Latin/HebrewLEFT="230" WIDTH="356"English, Hebrew (see ISO 
8859-8 specification)LEFT="0" WIDTH="110"8859-9LEFT="115" WIDTH="110"Latin 5LEFT="230" WIDTH="356"Danish, Dutch, English, 
Finnish, French, German, 
Irish, Italian, Norwegian, 
Portuguese, Spanish, 
Swedish, TurkishIRIX contains over 500 Latin 1 fonts, as well as a few fonts for each of the other 8859-encoded character sets except 8859-6. Currently, IRIX contains no fonts for use with the 8859-6 character set.LBL="" HELPID=""ID="27791"Asian LanguagesAsian languages are commonly pictographic and employ many thousands of characters for their representation. For example, Japanese and Korean can be practically encoded in 16 bits. Daily-use Chinese can also be, but archives and scholars frequently need more; Chinese is often encoded with up to four bytes per character.ID="10.intl72"LBL="" HELPID=""Some StandardsVarious Asian character sets have been developed, some of which are considered standard. Encodings for these sets are less standardized. Asian character sets usually require larger-than-byte character types like those described in IDREF="42850" TYPE="TITLE""Multiple-Byte Character Types."
† †IDREF="70619" TYPE="TABLE"Table 10-5
 lists some of these standard character sets. Note that some of these character sets have multiple associated codesets, usually designated by appending the year the codeset was adopted to the character set name. (For example, JIS X 208-1983 is different from JIS X 208-1990.)COLUMNS="3"LBL="10-5"Table 10-5 ID="70619"Character Sets for Asian LanguagesLEFT="0" WIDTH="110"LanguageLEFT="115" WIDTH="110"Character Set StandardsLEFT="230" WIDTH="356"SupportLEFT="0" WIDTH="110"JapaneseLEFT="115" WIDTH="110"JIS X 0201JIS X 0208JIS X 0212LEFT="230" WIDTH="356"KatakanaKanji, kana, Latin, Greek, 
Cyrillic, symbols, othersSupplemental Kanji, 
othersLEFT="0" WIDTH="110"ChineseLEFT="115" WIDTH="110"no specific standard yetLEFT="230" WIDTH="356"LEFT="0" WIDTH="110"KoreanLEFT="115" WIDTH="110"KSC5601.1987-0LEFT="230" WIDTH="356"HangulLBL="" HELPID=""ID="31663"EUCEUC is ID="10.intl73"Extended Unix Code, an encoding methodology that supports concurrent use of four codesets in one encoding. It employs two special "shift state" bytes:ss1 = 0x8e
ss2 = 0x8fwhich are used to identify codesets within a string. The EUC encoding scheme uses the following patterns to indicate which codeset is in use at any given time:Codeset #1: 0xxxxxxx
Codeset #2: 1xxxxxxx [ 1xxxxxxx ...]
Codeset #3: ss1 1xxxxxxx [ 1xxxxxxx ...]
Codeset #4: ss2 1xxxxxxx [ 1xxxxxxx ...]So if ss1 appears in a string, it means that the next charactername='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'however many bytes long it isname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'should be interpreted as a character from codeset #3. (So if there are multiple characters in a row from codeset #3, each one will be preceded by ss1.) Similarly, ss2 indicates that the following character belongs to codeset #4. If any other byte whose high bit is 1 appears in the string (without being preceded by ss1 or ss2), it is interpreted as part of a character from codeset #2.In EUC, codeset #1 is always ASCII. The other codesets are implementation- or user-defined.EUC implementations exist (but are not standardized) for all ideographic Asian languages.LBL="" HELPID=""JapaneseThe codesets for the JIS character sets all use 7-bit codes. This allows Japanese to be sent in Internet messages without modification of the messages or the transport. Plain JIS requires imbedded escape sequences in order to switch between one- and two-byte character modes and character sets.Shift-JIS (SJIS) and UJIS (a Japanese EUC encoding) use a string's numeric values to switch between codesets. Both encodings use the eighth bit of bytes.Most Unix workstations that support Japanese use UJIS for internal code. UJIS codeset #2 is JIS X 208-1990, a 2-byte codeset. Codeset #3 is JIS X 201-1989, a one-byte codeset; since the ss1 byte is needed for each character to indicate codeset #3, each character becomes 2 bytes. Codeset #4 is not used. Thus the largest characters in UJIS are 2 bytes long.In Japan, most PCs use SJIS, which turns on the high bit of 7-bit JIS characters to shift them above ASCII, becoming compatible with ASCII at the expense of using the eighth bit of bytes.The Japanese encodings are interconvertible. Since JIS uses a 7-bit code, SJIS and UJIS are commonly converted to JIS for network transmission.LBL="" HELPID=""ISO 10646 and UnicodeISO and the Unicode Consortium have jointly developed a character set designed to cover almost every character normally used by any language in the world. ISO calls this ID="10.intl74"ISO IS 10646. The Unicode Consortium embraces a subset of 10646, called the Basic Multilingual Plane (BMP) of 10646, and calls it Unicode. The only characters defined in either standard are the characters in the BMP. The characters have 2- and 4-byte representations.It appears that ISO 10646 will grow significantly in acceptance, but widespread use is still some years away.LBL="11"ID="78479"Localization and Creating New LocalesLBL="" HELPID=""IntroductionLocalizing an application is the process of supplying, for use with that application, a database of information specific to a local language and customs. Such databases are called locales; internationalized software uses these locales (at run time) in order to behave suitably with users who use those languages and customs. Much localization data comes from system locale databases, but applications may have particular data of their own to be localized. A properly internationalized program will use locale databases as necessary, but it is usually not the task of the application developer to perform localization by creating such databases. Applications should be written to allow the use of any localename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for more information on how to do this, see IDREF="10407" TYPE="TITLE"Chapter 10, "Internationalization."The purpose of this chapter is to introduce methods to develop new locale databases. The first section of this chapter describes IRIX system locales; the second section describes application localization.LBL="" HELPID=""IRIX System LocalizationLocalization covers many aspects of computers and applications, and its usefulness depends on the degree of internationalization achieved by the applications that make use of it. This section presents the components of an IRIX system locale and describes how to create a new IRIX locale.LBL="" HELPID=""IRIX Locale ComponentsThe first component of an IRIX locale is a keyboard layout definition file, which contains a list correlating keyboard keys with character codes. Even two places that use the same language may have different standard keyboard layouts; this file allows the use of a different keyboard for each locale.The second component of an IRIX locale is the compose sequence description file. It describes which sequences of characters draw those characters that do not appear on the keycaps but that are nevertheless part of a character set. For example, a French keyboard has a non-spacing circumflex key that you press prior to a vowel to produce circumflex-accented vowels. The compose character mechanism is built-in to Xlib.ID="11.local1"The third component of an IRIX locale is the message catalog system. All IRIX system messages should be translated into the language of the locale and put into message catalogs. There should be a different message catalog set for each locale.ID="11.local2"The fourth component of an IRIX locale is the set of POSIX locale configuration files. (Please note that conceptually a POSIX locale is a subset of this document's definition of a locale.) These files define the collating sequence of characters within a character set, the printing format of time and date, and numerical and monetary formats. Most of these configuration files are kept as binary files created from plain text files.ID="11.local3"The fifth component of an IRIX locale is the set of X client resource files, for X client applications shipped with IRIX, that have been customized to a locale.ID="11.local4"The last component of an IRIX locale is the font encoding attributes. For example, a Latin 1 (ISO 8859-1) font can be used for English, French, Italian, German, Spanish, and so on, but not for Greek or Russian. While it is up to an internationalized application to ensure that the correct font is available for the currently set locale, a locale must define which font encoding it requires.ID="11.local5"LBL="" HELPID=""Creating a New IRIX LocaleCreating a new IRIX locale requires that all components be customized to a local environment. However, it does not imply that all components be created from scratch, as it is often possible to reuse components from an already-existing IRIX locale.ID="11.local6"LBL="" HELPID=""Keyboard LayoutThe keyboard layout configuration file is the IRIX locale component that is most likely to differ from locale to locale. Many countries have a national standards organization from which you can get the official keyboard layout. (Though there are some countries in which everyone uses some unofficial, de facto standard instead.)ID="11.local7"To create a new keyboard layout, you need to build a keymap file. Note that some keyboard layouts define more than two characters per key. Please ensure that the keymap entry of a keymap file has a second dimension qualifier that matches the maximum number of characters that a key can hold.Here is an example of a keymap entry:#define NoSymbol 0
keymap [2 .. 110] [4] = {
† †   offset = 8
† †   ...
† †   { XK_a, XK_A, NoSymbol, XK_adiaeresis }
† †   ...
}Naming of keymap files is not important in itself. A keymap file can be named foo.map and still be a perfectly valid keyboard layout configuration file. It is strongly suggested, however, that keymap files be named using the format "language_REGION", where both language and REGION are ISO two-letter names. For example, a Belgian French keymap file should be named fr_BE.map. (When the REGION and language names are the same, it is common to name only the languagename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'for example, a French French keymap file should be named fr.map, not fr_FR.map.)Once your keymap file is complete you must use the keymap compiler xkeymap to produce a binary keymap file, named in the form (for instance) fr_BE.xkm. This resulting file should be installed in the /usr/lib/X11/input directory. The keyboard layout is now ready to be used either through the keyboard's X application or directly using setxkeymap.LBL="" HELPID=""Compose TablesA compose table contains information on how to generate complex characters from a keyboard where the desired character does not appear on any key. For example, circumflex-accented characters do not appear on the keys of French keyboards, but they can be generated by first pressing the non-spacing circumflex and then pressing a vowel key. Compose tables, like keymap files, vary greatly from one region to another, so they can rarely be reused in a new locale. But, as for keymap files, frequently there are national standards describing the composition of characters.ID="11.local8"Composition of characters falls into three categories: implicit introducers, explicit introducers, and explicit introducers/terminators. An implicit introducer example is the non-spacing circumflex character (because it is non-spacing, it is often called a "dead key"); a circumflex-accented character is generated only after both the circumflex and a vowel have been typed. Explicit introducers are special keys that must be pressed to initiate a character composition. Explicit introducers/terminators are special keys that must be pressed to initiate and terminate character composition.Naming of compose table files is also important and, again, it is strongly suggested to use the "language_REGION" naming standard. So a French Belgian compose table should be named fr_BE.cmp.Once a compose table is complete, the ckmcomp utility is used to generate a binary file (with a name like fr_BE.ckm), which can be installed into the /usr/lib/X11/input/compose directory.The heuristic to load a compose table is load default.ckm, load $LANG.ckm, load $HOME/.SGIcompose, and load $_SGI_COMPOSE_TABLES.LBL="" HELPID=""ID="84797"Message CatalogsMessage catalogs allow IRIX and its applications to communicate with users in the languages of their choice. It is likely that these files can be reused from one locale to another if the language remains the same. For example, a French locale for Quebec will use the same message catalogs as a French locale for France.ID="11.local9"Message catalogs are found under /usr/lib/locale/locale/LC_MESSAGES, where locale is of the format "language_REGION".If a message catalog from another locale can be reused, then it can either be copied or, even better, linked into the new locale.If a message catalog must be built from scratch it is good practice to copy into the new locale directory the message catalog from another language's locale and translate the messages. Original uncompiled English message catalogs can be found under /usr/lib/locale/C/MSGFILES. Any message file can be printed from its binary format using srchtxt ≠m catalog. So to use a French uxawk message catalog as the base for another language, do this:setenv LANG fr
srchtxt -m uxawk | sed -e 's/<.*>//' > awk.stringsThe exstr utility facilitates creation of MNLS message catalogs from the original source code. See the exstr(1) manual page for more information.To compile a message catalog, use the mkmsgs utility. The selection of message catalogs is driven by the contents of the $LANG environment variable, again using the "language_REGION" format. (If $LANG is not set the default is the C locale.)LBL="" HELPID=""POSIX LocaleA POSIX locale is a collection of configuration files that describe printing formats for numerical, monetary, date and time data it also defines return values for character inquiry functions, and it describes the character collating sequence. As for message catalogs, this information is likely to be reused from one locale to another except that a POSIX locale contains more culture-sensitive information (for example, monetary, numeric information).ID="11.local10"A POSIX locale resides under /usr/lib/locale/localename, where localename is in the format "language_REGION".Here is the list of files that make up a POSIX locale and how to create them:(As before, to create a configuration file work from a copy of another locale.)LC_COLLATE: character collating sequencebuilt from colltbl_ccompiled with colltbl utilityLC_MONEY: monetary printing formatbuilt from montbl_ccompiled with montbl utilityLC_NUMERIC: numerical printing formatLC_CTYPE: character type inquirybuilt from chrtbl_ccompiled with chrtbl utilityLC_TIME: date and time printing formatA POSIX locale is selected by setting the environment variable $LANG (default is C locale).LBL="" HELPID=""X Resource FilesX resource files sometimes contain information that does not apply well from one culture to another. Localization of X resource files involves finding such information. Of all the resource files under ID="11.local11"/usr/lib/X11/app-defaults, only a few need to be customized from one locale to another. Furthermore, once a resource file has been localized for one language, all other geographical regions using the same language can use the same file (in which case the resource file simply needs to be copied or linked).X resource files reside under /usr/lib/X11/locale/app-defaults, where locale is, once more, in the format "language_REGION". There are also two subdirectories that contain more resource files under app-defaults: these are sgi-color1280 and sgi-color1600.To create a new set of X resource files for a locale, it is suggested you start from an already existing locale, but not the C locale, and modify the files. For example, /usr/lib/X11/fr/app-defaults contains all X resource files that contain culture-sensitive information.Modifications are required whenever character strings are printed either as button labels, titles, and so on. It may also be desirable to create new icons or bitmaps if their pictorial information is not readily understandable by a culture. Finally, localization may also include repositioning of elements (widgets) within a window; this is sometimes due to string translation yielding longer strings.LBL="" HELPID=""MiscellaneousSome system files that are not in any of the previously discussed categories must be localized. They are:xcalendar help file: in /usr/lib/X11/xcalendar/xcalendar_locale.hlpnls.alias files: under /usr/lib/X11/nls (nls=national language support); add an alias for new localelocale man page: it is good practice to have a manual page describing the new locale being added under /usr/catman/localLBL="" HELPID=""Non-Latin 1 LocalesSo far, this chapter has described a methodology to create locales that use Latin 1 (ISO 8859-1) languages. Creating locales for Arabic, Hebrew, or Asian languages is beyond the scope of this book. However, it is fairly simple to extend the methodology presented thus far to other non-Latin 1 character sets, such as Latin-2 and Latin/Cyrillic. For such character sets, the input method for the standard Xlib can be supplemented by the Xmu library. Creating a locale using a non-Latin 1 character set involves modifying the ID="11.local12"nls.alias and nls.dir files under /usr/lib/X11/nls and proceeding as discussed previously.LBL="" HELPID=""Creating an Application LocaleIn this section, we will cover localization of generic X client applications.LBL="" HELPID=""Application Locale ComponentsBefore you can create a new application locale, you must make sure that a matching IRIX locale already exists. For example, to create a French locale for application XYZ, one must rely on a French keyboard layout, a French character compose sequence, French IRIX message catalogs, a French POSIX locale, and French fonts (ISO 8859-1).ID="11.local13"Even after this preliminary condition has been fulfilled, an application still must be internationalized before locales can be made for it (see IDREF="10407" TYPE="TITLE"Chapter 10
).Application-dependent information that is subject to localization falls into four categories, namely: prompts and greetings, status and error messages, help information, and pictograms. Textual information, as for IRIX locales, must be translated according to the language of a locale. Such information can be kept in message catalogs, plain IRIX files, or even X resource files. Pictograms, however, are trickier to translate. For example, the English expression "filing a bug" might be represented by a pictogram showing an insect inside a filing cabinet. What might a Korean user make out of that picture?LBL="" HELPID=""Creating Application LocalesIf we put aside the pictogram issue, then creating an application locale becomes mostly an issue of translating textual information. For non-X client applications, messages, for prompts and error reporting, should be kept in message catalogs (preferably XPG/3 catalogs), while help messages might be kept in IRIX plain files, especially if they are lengthy. X client applications, however, should make maximum use of X resource files to maintain locale-dependent information (although nothing prevents them from using message catalogs). Additional care must be taken while creating a new locale for X-based applications, as frequently button and label arrangement will suffer from string-length variations from one language to another. In this case, it is best to use relative positioning of widgets maintained as resources.Even a properly internationalized application will not necessarily be able to do everything necessary for a given locale. In particular, a user using a dumb terminal (without X capabilities) will be restricted to a fixed keyboard layout, and will not be able to use compose-key sequences. Further, use of message catalogs will only be possible if the terminal supports 8-bit data transmission and a font matching the data (such as Latin 1).† †LBL="A"ID="27381"Position-Independent Coding in Assembly LanguageSeveral new assembler directives have been added to support generation of PIC. You should also make yourself familiar with the MIPS ABI Supplement and the PIC coding model it describes.ID="A.assembly1"The assembler generates PIC if either the directive .option pic2 appears in the assembler file or the assembler, as, is invoked with the -KPIC argument in the absence of an explicit .option pic0 directive in the assembler file. Unless PIC is being generated, the other options in this section are ignored by the assembler, with the exception of ID="A.assembly2"ID="A.assembly3".gpword, which becomes .word. Thus, you may easily use the same assembler file for generating PIC and non-PIC (i.e., non-shared) objects by not placing .option pic0 or .option pic2 in the assembler file and invoking the assembler without -KPIC (for non-shared) or with -KPIC (for PIC)..option pic2This directive forces the assembler to mark the output object file "PIC" and activates the following directives. It overrides the command line argument. Normally, you don't need to specify this directive. Instead, you should use the ID="A.assembly4"≠KPIC or ≠non_shared options to toggle between generating PIC or non-PIC.Note that even though ≠KPIC will be made the default for the high-level language drivers (such as cc, f77, and pc) in future releases, it will not be the default for assembly sources. You will always have to explicitly specify ≠KPIC for compiling .s files..cpload regThis directive expands into three instructions that sets the gp register to the context pointer value for the current function. The three instructions are:† †    lui     gp,_gp_disp
† †    addui   gp,gp,_gp_disp
† †    addu    gp,gp,reg_gp_disp is a reserved symbol that the linker sets to the distance between the lui instruction and the context pointer. This directive is required at the beginning of each subroutine that uses the gp register.You must add this directive at the beginning of every procedure, with the exception of leaf-procedures that do not access any global variables, and procedures that are static (i.e., not marked .globl or .extern)..cprestore offsetThis directive causes the assembler to issue† †    sw     gp,offset(sp)at the point where it appears. Additionally, it causes the assembler to emitID="A.assembly5"† †    lw     gp,offset(sp)after every jump-and-link (jal) operation (but not after a branch-and-link (bal) operation), thereby restoring the gp register after function calls. The programmer is responsible for allocating the stack space for the gp. This space should be in the saved register area of the stack frame to remain consistent with MIPS' calling and debugger conventions..gpword local-symThis directive is similar to .word except that the relocation entry for local-sym has the R_MIPS_GPREL32 type. After linkage, this results in a 32-bit value that is the distance between local-sym and the context pointer (that is, the gp). local-sym must be local. It is currently used for PIC switch tables.ID="A.assembly6"ID="A.assembly7".cpadd regThis adds the value of the context pointer (gp) to reg.LBL="" HELPID=""ExamplesThis following is a simplified version of the "hello world" program:† †       .option pic2
† †       .data
† †       .align      2
$$5:
† †       .ascii      "hello world\X0A\X00"
† †       .text
† †       .align      2
main:
† †       .set        noreorder
† †       .cpload    $25
† †       .set       reorder
† †       subu       $sp, 40
† †       sw         $31, 36($sp)
† †       .cprestore 32
† †       la         $4, $$5
† †       jal        printf
† †       move       $2, $0
† †       lw         $31, 36($sp)
† †       addu       $sp, 40
† †       j          $31The actual instructions generated by the assembler will be:† †       lui     gp,0            #
† †       addiu   gp,gp,0         # generated by .cpload
† †       addu    gp,gp,t9        #
† †       lw      a0,0(gp)        # gp-relative addressing used
† †       lw      t9,0(gp)        # t9 is used for func. call
† †       addiu   sp,sp,-40
† †       sw      ra,36(sp)
† †       sw      gp,32(sp)       # from .cprestore
† †       jalr    ra,t9           # jal is changed to jalr
† †       addiu   a0,a0,0
† †       lw      ra,36(sp)
† †       lw      gp,32(sp)       # activated by .cprestore
† †       move    v0,zero
† †       jr      ra
† †       addiu   sp,sp,40
† †       nopThe MIPS ABI requires that register t9 ($25) be used for indirect function call, so .cpload should always use $25. No reorder mode should also be used. Also, programmers should make sure that t9 is dead before any function call.If your program uses an indirect jump (jalr), you must also use t9 as the jump register.If you have an unconditional jump to an external label:j    _cerroryou have to rewrite it into indirect jump via t9:la   t9,_cerror
j    t9If you use branch-and-link (bal) instruction, and if the target procedure begins with a .cpload, you have to specify an alternate entry point:foo: .set     noreorder # callee
† †    .cpload  $25
† †    .set     reorder
$$1:          ...       # alternate entry point
† †    ...
† †    j        $31       # foo returns
bar:          ...       # caller
† †    ...
bal  $$1                # by-pass the .cpload
† †    ...† †This is very important because .cpload assumes register $25 contains the address of foo, but in this case $25 is not set up. Note that since both foo and bar reside in the same file, they must have the same value for $gp. So the .cpload instructions can be and must be bypassed. However, since foo can still be called from outside, the .cpload is still required.Alternatively, if you don't want to have an alternate entry point, you can set up register $25 before the bal:† †    la      t9,foo
† †    bal     foobut this will be less efficient. .gpword and† †.cpadd are used together to implement position-independent jump table (or any table of text addresses). Entries of the address table created by .gpword are converted into displacement from the context pointer. To get the correct text address, .cpadd should be used to add the value of gp  back to them. Since the gp is updated by the run-time linker, the correct text address can be reconstructed regardless of the location of the DSO.ID="A.assembly8"LBL="B"ID="67532"ISO 3166 Country Names and AbbreviationsIDREF="32360" TYPE="TABLE"Table B-1 lists the ISO 3166 country codes, alphabetized by country name (the table reads from left to right, and top to bottom): COLUMNS="6"LBL="B-1"Table B-1 ID="32360" ISO 3166 Country CodesLEFT="0" WIDTH="76"Country NameLEFT="85" WIDTH="34"CodeLEFT="125" WIDTH="76"Country NameLEFT="210" WIDTH="34"CodeLEFT="250" WIDTH="76"Country NameLEFT="335" WIDTH="356"CodeLEFT="0" WIDTH="76"AfghanistanLEFT="85" WIDTH="34"AFLEFT="125" WIDTH="76"AlbaniaLEFT="210" WIDTH="34"ALLEFT="250" WIDTH="76"AlgeriaLEFT="335" WIDTH="356"DZLEFT="0" WIDTH="76"American SamoaLEFT="85" WIDTH="34"ASLEFT="125" WIDTH="76"AndorraLEFT="210" WIDTH="34"ADLEFT="250" WIDTH="76"AngolaLEFT="335" WIDTH="356"AOLEFT="0" WIDTH="76"AnguillaLEFT="85" WIDTH="34"AILEFT="125" WIDTH="76"AntarcticaLEFT="210" WIDTH="34"AQLEFT="250" WIDTH="76"Antigua and 
BarbudaLEFT="335" WIDTH="356"AGLEFT="0" WIDTH="76"ArgentinaLEFT="85" WIDTH="34"ARLEFT="125" WIDTH="76"ArubaLEFT="210" WIDTH="34"AWLEFT="250" WIDTH="76"AustraliaLEFT="335" WIDTH="356"AULEFT="0" WIDTH="76"AustriaLEFT="85" WIDTH="34"ATLEFT="125" WIDTH="76"BahamasLEFT="210" WIDTH="34"BSLEFT="250" WIDTH="76"BahrainLEFT="335" WIDTH="356"BHLEFT="0" WIDTH="76"BangladeshLEFT="85" WIDTH="34"BDLEFT="125" WIDTH="76"BarbadosLEFT="210" WIDTH="34"BBLEFT="250" WIDTH="76"BelgiumLEFT="335" WIDTH="356"BELEFT="0" WIDTH="76"BelizeLEFT="85" WIDTH="34"BZLEFT="125" WIDTH="76"BeninLEFT="210" WIDTH="34"BJLEFT="250" WIDTH="76"BermudaLEFT="335" WIDTH="356"BMLEFT="0" WIDTH="76"BhutanLEFT="85" WIDTH="34"BTLEFT="125" WIDTH="76"BoliviaLEFT="210" WIDTH="34"BOLEFT="250" WIDTH="76"BotswanaLEFT="335" WIDTH="356"BWLEFT="0" WIDTH="76"Bouvet IslandLEFT="85" WIDTH="34"BVLEFT="125" WIDTH="76"BrazilLEFT="210" WIDTH="34"BRLEFT="250" WIDTH="76"British Indian 
Ocean TerritoryLEFT="335" WIDTH="356"IOLEFT="0" WIDTH="76"Brunei 
DarussalamLEFT="85" WIDTH="34"BNLEFT="125" WIDTH="76"BulgariaLEFT="210" WIDTH="34"BGLEFT="250" WIDTH="76"Burkina FasoLEFT="335" WIDTH="356"BFLEFT="0" WIDTH="76"BurmaLEFT="85" WIDTH="34"BULEFT="125" WIDTH="76"BurundiLEFT="210" WIDTH="34"BILEFT="250" WIDTH="76"ByelorussiaLEFT="335" WIDTH="356"BYLEFT="0" WIDTH="76"CameroonLEFT="85" WIDTH="34"CMLEFT="125" WIDTH="76"CanadaLEFT="210" WIDTH="34"CALEFT="250" WIDTH="76"Cape VerdeLEFT="335" WIDTH="356"CVLEFT="0" WIDTH="76"Cayman IslandsLEFT="85" WIDTH="34"KYLEFT="125" WIDTH="76"Central African 
RepublicLEFT="210" WIDTH="34"CFLEFT="250" WIDTH="76"ChadLEFT="335" WIDTH="356"TDLEFT="0" WIDTH="76"ChileLEFT="85" WIDTH="34"CLLEFT="125" WIDTH="76"ChinaLEFT="210" WIDTH="34"CNLEFT="250" WIDTH="76"Christmas IslandLEFT="335" WIDTH="356"CXLEFT="0" WIDTH="76"Cocos IslandsLEFT="85" WIDTH="34"CCLEFT="125" WIDTH="76"ColombiaLEFT="210" WIDTH="34"COLEFT="250" WIDTH="76"ComorosLEFT="335" WIDTH="356"KMLEFT="0" WIDTH="76"CongoLEFT="85" WIDTH="34"CGLEFT="125" WIDTH="76"Cook IslandsLEFT="210" WIDTH="34"CKLEFT="250" WIDTH="76"Costa RicaLEFT="335" WIDTH="356"CRLEFT="0" WIDTH="76"Cote D'IvoireLEFT="85" WIDTH="34"CILEFT="125" WIDTH="76"CubaLEFT="210" WIDTH="34"CULEFT="250" WIDTH="76"CyprusLEFT="335" WIDTH="356"CYLEFT="0" WIDTH="76"Czech RepublicLEFT="85" WIDTH="34"CSLEFT="125" WIDTH="76"DenmarkLEFT="210" WIDTH="34"DKLEFT="250" WIDTH="76"DjiboutiLEFT="335" WIDTH="356"DJLEFT="0" WIDTH="76"DominicaLEFT="85" WIDTH="34"DMLEFT="125" WIDTH="76"Dominican 
RepublicLEFT="210" WIDTH="34"DOLEFT="250" WIDTH="76"East TimorLEFT="335" WIDTH="356"TPLEFT="0" WIDTH="76"EcuadorLEFT="85" WIDTH="34"ECLEFT="125" WIDTH="76"EgyptLEFT="210" WIDTH="34"EGLEFT="250" WIDTH="76"El SalvadorLEFT="335" WIDTH="356"SVLEFT="0" WIDTH="76"Equatorial 
GuineaLEFT="85" WIDTH="34"GQLEFT="125" WIDTH="76"EthiopiaLEFT="210" WIDTH="34"ETLEFT="250" WIDTH="76"Falkland IslandsLEFT="335" WIDTH="356"FKLEFT="0" WIDTH="76"Faroe IslandsLEFT="85" WIDTH="34"FOLEFT="125" WIDTH="76"FijiLEFT="210" WIDTH="34"FJLEFT="250" WIDTH="76"FinlandLEFT="335" WIDTH="356"FILEFT="0" WIDTH="76"FranceLEFT="85" WIDTH="34"FRLEFT="125" WIDTH="76"French GuianaLEFT="210" WIDTH="34"GFLEFT="250" WIDTH="76"French PolynesiaLEFT="335" WIDTH="356"PFLEFT="0" WIDTH="76"French Southern 
TerritoriesLEFT="85" WIDTH="34"TFLEFT="125" WIDTH="76"GabonLEFT="210" WIDTH="34"GALEFT="250" WIDTH="76"GambiaLEFT="335" WIDTH="356"GMLEFT="0" WIDTH="76"GermanyLEFT="85" WIDTH="34"DELEFT="125" WIDTH="76"GhanaLEFT="210" WIDTH="34"GHLEFT="250" WIDTH="76"GibraltarLEFT="335" WIDTH="356"GILEFT="0" WIDTH="76"GreeceLEFT="85" WIDTH="34"GRLEFT="125" WIDTH="76"GreenlandLEFT="210" WIDTH="34"GLLEFT="250" WIDTH="76"GrenadaLEFT="335" WIDTH="356"GDLEFT="0" WIDTH="76"GuadelupeLEFT="85" WIDTH="34"GPLEFT="125" WIDTH="76"GuamLEFT="210" WIDTH="34"GULEFT="250" WIDTH="76"GuatemalaLEFT="335" WIDTH="356"GTLEFT="0" WIDTH="76"Guinea-BissauLEFT="85" WIDTH="34"GWLEFT="125" WIDTH="76"GuineaLEFT="210" WIDTH="34"GNLEFT="250" WIDTH="76"GuyanaLEFT="335" WIDTH="356"GYLEFT="0" WIDTH="76"HaitiLEFT="85" WIDTH="34"HTLEFT="125" WIDTH="76"Heard and 
McDonald 
IslandsLEFT="210" WIDTH="34"HMLEFT="250" WIDTH="76"HondurasLEFT="335" WIDTH="356"HNLEFT="0" WIDTH="76"Hong KongLEFT="85" WIDTH="34"HKLEFT="125" WIDTH="76"HungaryLEFT="210" WIDTH="34"HULEFT="250" WIDTH="76"IcelandLEFT="335" WIDTH="356"ISLEFT="0" WIDTH="76"IndiaLEFT="85" WIDTH="34"INLEFT="125" WIDTH="76"IndonesiaLEFT="210" WIDTH="34"IDLEFT="250" WIDTH="76"IranLEFT="335" WIDTH="356"IRLEFT="0" WIDTH="76"IraqLEFT="85" WIDTH="34"IQLEFT="125" WIDTH="76"IrelandLEFT="210" WIDTH="34"IELEFT="250" WIDTH="76"IsraelLEFT="335" WIDTH="356"ILLEFT="0" WIDTH="76"ItalyLEFT="85" WIDTH="34"ITLEFT="125" WIDTH="76"JamaicaLEFT="210" WIDTH="34"JMLEFT="250" WIDTH="76"JapanLEFT="335" WIDTH="356"JPLEFT="0" WIDTH="76"JordanLEFT="85" WIDTH="34"JOLEFT="125" WIDTH="76"KampucheaLEFT="210" WIDTH="34"KHLEFT="250" WIDTH="76"KenyaLEFT="335" WIDTH="356"KELEFT="0" WIDTH="76"KiribatiLEFT="85" WIDTH="34"KILEFT="125" WIDTH="76"KoreaLEFT="210" WIDTH="34"KP or 
KRLEFT="250" WIDTH="76"KuwaitLEFT="335" WIDTH="356"KWLEFT="0" WIDTH="76"LaosLEFT="85" WIDTH="34"LALEFT="125" WIDTH="76"LebanonLEFT="210" WIDTH="34"LBLEFT="250" WIDTH="76"LesothoLEFT="335" WIDTH="356"LSLEFT="0" WIDTH="76"Liberia LEFT="85" WIDTH="34"LRLEFT="125" WIDTH="76"LibyaLEFT="210" WIDTH="34"LYLEFT="250" WIDTH="76"LiechtensteinLEFT="335" WIDTH="356"LILEFT="0" WIDTH="76"LuxembourgLEFT="85" WIDTH="34"LULEFT="125" WIDTH="76"MacauLEFT="210" WIDTH="34"MOLEFT="250" WIDTH="76"MadagascarLEFT="335" WIDTH="356"MGLEFT="0" WIDTH="76"MalawiLEFT="85" WIDTH="34"MWLEFT="125" WIDTH="76"MalaysiaLEFT="210" WIDTH="34"MYLEFT="250" WIDTH="76"MaldivesLEFT="335" WIDTH="356"MVLEFT="0" WIDTH="76"MaliLEFT="85" WIDTH="34"MLLEFT="125" WIDTH="76"MaltaLEFT="210" WIDTH="34"MTLEFT="250" WIDTH="76"Marshall IslandsLEFT="335" WIDTH="356"MHLEFT="0" WIDTH="76"MartiniqueLEFT="85" WIDTH="34"MQLEFT="125" WIDTH="76"MauritaniaLEFT="210" WIDTH="34"MRLEFT="250" WIDTH="76"MauritiusLEFT="335" WIDTH="356"MULEFT="0" WIDTH="76"MexicoLEFT="85" WIDTH="34"MXLEFT="125" WIDTH="76"MicronesiaLEFT="210" WIDTH="34"FMLEFT="250" WIDTH="76"MonacoLEFT="335" WIDTH="356"MCLEFT="0" WIDTH="76"MongoliaLEFT="85" WIDTH="34"MNLEFT="125" WIDTH="76"MontserratLEFT="210" WIDTH="34"MSLEFT="250" WIDTH="76"MoroccoLEFT="335" WIDTH="356"MALEFT="0" WIDTH="76"MozambiqueLEFT="85" WIDTH="34"MZLEFT="125" WIDTH="76"NamibiaLEFT="210" WIDTH="34"NALEFT="250" WIDTH="76"NauruLEFT="335" WIDTH="356"NRLEFT="0" WIDTH="76"NepalLEFT="85" WIDTH="34"NPLEFT="125" WIDTH="76"Netherlands 
AntillesLEFT="210" WIDTH="34"ANLEFT="250" WIDTH="76"NetherlandsLEFT="335" WIDTH="356"NLLEFT="0" WIDTH="76"Neutral ZoneLEFT="85" WIDTH="34"NTLEFT="125" WIDTH="76"New CaledoniaLEFT="210" WIDTH="34"NCLEFT="250" WIDTH="76"New ZealandLEFT="335" WIDTH="356"NZLEFT="0" WIDTH="76"NicaraguaLEFT="85" WIDTH="34"NILEFT="125" WIDTH="76"NigeriaLEFT="210" WIDTH="34"NGLEFT="250" WIDTH="76"NigerLEFT="335" WIDTH="356"NELEFT="0" WIDTH="76"NiueLEFT="85" WIDTH="34"NULEFT="125" WIDTH="76"Norfolk IslandLEFT="210" WIDTH="34"NFLEFT="250" WIDTH="76"Northern 
Mariana IslandsLEFT="335" WIDTH="356"MPLEFT="0" WIDTH="76"NorwayLEFT="85" WIDTH="34"NOLEFT="125" WIDTH="76"OmanLEFT="210" WIDTH="34"OMLEFT="250" WIDTH="76"PakistanLEFT="335" WIDTH="356"PKLEFT="0" WIDTH="76"PalauLEFT="85" WIDTH="34"PWLEFT="125" WIDTH="76"PanamaLEFT="210" WIDTH="34"PALEFT="250" WIDTH="76"PangaeaLEFT="335" WIDTH="356"GELEFT="0" WIDTH="76"Papua New 
GuineaLEFT="85" WIDTH="34"PGLEFT="125" WIDTH="76"ParaguayLEFT="210" WIDTH="34"PYLEFT="250" WIDTH="76"PeruLEFT="335" WIDTH="356"PELEFT="0" WIDTH="76"PhilippinesLEFT="85" WIDTH="34"PHLEFT="125" WIDTH="76"PitcairnLEFT="210" WIDTH="34"PNLEFT="250" WIDTH="76"PolandLEFT="335" WIDTH="356"PLLEFT="0" WIDTH="76"PortugalLEFT="85" WIDTH="34"PTLEFT="125" WIDTH="76"Puerto RicoLEFT="210" WIDTH="34"PRLEFT="250" WIDTH="76"QatarLEFT="335" WIDTH="356"QALEFT="0" WIDTH="76"QuebecLEFT="85" WIDTH="34"QCLEFT="125" WIDTH="76"ReunionLEFT="210" WIDTH="34"RELEFT="250" WIDTH="76"RomaniaLEFT="335" WIDTH="356"ROLEFT="0" WIDTH="76"RwandaLEFT="85" WIDTH="34"RWLEFT="125" WIDTH="76"Saint Kitts and 
NevisLEFT="210" WIDTH="34"KNLEFT="250" WIDTH="76"Saint LuciaLEFT="335" WIDTH="356"LCLEFT="0" WIDTH="76"Saint Vincent and 
the GranadinesLEFT="85" WIDTH="34"VCLEFT="125" WIDTH="76"SamoaLEFT="210" WIDTH="34"WSLEFT="250" WIDTH="76"San MarinoLEFT="335" WIDTH="356"SMLEFT="0" WIDTH="76"Sao Tome and 
PrincipeLEFT="85" WIDTH="34"STLEFT="125" WIDTH="76"Saudi ArabiaLEFT="210" WIDTH="34"SALEFT="250" WIDTH="76"SenegalLEFT="335" WIDTH="356"SNLEFT="0" WIDTH="76"SeychellesLEFT="85" WIDTH="34"SCLEFT="125" WIDTH="76"Sierra LeoneLEFT="210" WIDTH="34"SLLEFT="250" WIDTH="76"SingaporeLEFT="335" WIDTH="356"SGLEFT="0" WIDTH="76"Solomon IslandsLEFT="85" WIDTH="34"SBLEFT="125" WIDTH="76"SomaliaLEFT="210" WIDTH="34"SOLEFT="250" WIDTH="76"South AfricaLEFT="335" WIDTH="356"ZALEFT="0" WIDTH="76"SpainLEFT="85" WIDTH="34"ESLEFT="125" WIDTH="76"Sri LankaLEFT="210" WIDTH="34"LKLEFT="250" WIDTH="76"St. HelenaLEFT="335" WIDTH="356"SHLEFT="0" WIDTH="76"St. Pierre and 
MiquelonLEFT="85" WIDTH="34"PMLEFT="125" WIDTH="76"SudanLEFT="210" WIDTH="34"SDLEFT="250" WIDTH="76"SurinameLEFT="335" WIDTH="356"SRLEFT="0" WIDTH="76"Svalbard and Jan 
Mayen IslandsLEFT="85" WIDTH="34"SJLEFT="125" WIDTH="76"SwazilandLEFT="210" WIDTH="34"SZLEFT="250" WIDTH="76"SwedenLEFT="335" WIDTH="356"SELEFT="0" WIDTH="76"SwitzerlandLEFT="85" WIDTH="34"CHLEFT="125" WIDTH="76"Syrian Arab 
RepublicLEFT="210" WIDTH="34"SYLEFT="250" WIDTH="76"TaiwanLEFT="335" WIDTH="356"TWLEFT="0" WIDTH="76"TanzaniaLEFT="85" WIDTH="34"TZLEFT="125" WIDTH="76"ThailandLEFT="210" WIDTH="34"THLEFT="250" WIDTH="76"TogoLEFT="335" WIDTH="356"TGLEFT="0" WIDTH="76"TokelauLEFT="85" WIDTH="34"TKLEFT="125" WIDTH="76"TongaLEFT="210" WIDTH="34"TOLEFT="250" WIDTH="76"Trinidad and 
TobagoLEFT="335" WIDTH="356"TTLEFT="0" WIDTH="76"TunisiaLEFT="85" WIDTH="34"TNLEFT="125" WIDTH="76"TurkeyLEFT="210" WIDTH="34"TRLEFT="250" WIDTH="76"Turks and Caicos 
IslandsLEFT="335" WIDTH="356"TCLEFT="0" WIDTH="76"TuvaluLEFT="85" WIDTH="34"TVLEFT="125" WIDTH="76"UgandaLEFT="210" WIDTH="34"UGLEFT="250" WIDTH="76"UkraineLEFT="335" WIDTH="356"UALEFT="0" WIDTH="76"United Arab 
EmiratesLEFT="85" WIDTH="34"AELEFT="125" WIDTH="76"United KingdomLEFT="210" WIDTH="34"GBLEFT="250" WIDTH="76"United States 
Minor Outlying 
IslandsLEFT="335" WIDTH="356"† †UMLEFT="0" WIDTH="76"UruguayLEFT="85" WIDTH="34"UYLEFT="125" WIDTH="76"VanuatuLEFT="210" WIDTH="34"VULEFT="250" WIDTH="76"Vatican City StateLEFT="335" WIDTH="356"VALEFT="0" WIDTH="76"VenezuelaLEFT="85" WIDTH="34"VELEFT="125" WIDTH="76"Viet NamLEFT="210" WIDTH="34"VNLEFT="250" WIDTH="76"Virgin Islands 
(British)LEFT="335" WIDTH="356"VGLEFT="0" WIDTH="76"Virgin Islands 
(USA)LEFT="85" WIDTH="34"VILEFT="125" WIDTH="76"Wallis and 
Futuna IslandsLEFT="210" WIDTH="34"WFLEFT="250" WIDTH="76"Western SaharaLEFT="335" WIDTH="356"EHLEFT="0" WIDTH="76"YemenLEFT="85" WIDTH="34"YE or 
YDLEFT="125" WIDTH="76"Yugoslavia 
(Former)LEFT="210" WIDTH="34"YULEFT="250" WIDTH="76"ZaireLEFT="335" WIDTH="356"ZRLEFT="0" WIDTH="76"ZambiaLEFT="85" WIDTH="34"ZMLEFT="125" WIDTH="76"ZimbabweLEFT="210" WIDTH="34"ZWLEFT="250" WIDTH="76"LEFT="335" WIDTH="356"LBL="C"ID="72283"Changing Default Xsgi SettingsThe X window system server (Xsgi) can be configured to default to a keyboard layout and a default font. This is useful if all users of a workstation will always want to use a specific keyboard layout or a specific default font. Here is the default Xsgi option line (file /usr/lib/X11/xdm/Xservers)::0 secure /usr/bin/X11/X -bs -c -pseudomap 4sightIn order to default to a French keyboard layout the previous file must be modified as follows::0 secure /usr/bin/X11/X -bs -c -keymap fr -pseudomap 4sightA more complex case involves non Latin-1 locales where the default font (Latin-1) is no longer acceptable. In this case the Xsgi option line must also include a default font name (xlfd). For example a Bulgarian setup might be::0 secure /usr/bin/X11/X -bs -c -fn -sgi-fixed-bold-r-normal--16-120-100-100-c-80-iso8859-5 -keymap BG -pseudomap 4sightNote that changing default font does not necessarily means that all X client applications will automatically start using this font. Some applications, such as xterm, define their own default font. In this case resource files must be updated. For xterm either the file /usr/lib/X11/app-defaults/XTerm (or /usr/lib/X11/locale/app-default/XTerm) or the file $HOME/.Xdefaults must declare the following resource entry: XTerm.*.Font: fontname.Of course an individual user can always override Xsgi defaults by calling setxkeymap with the appropriate argument to set the preferred keyboard layout in either the $HOME/.login file or the $HOME/.xsession. A default font can be defined in the $HOME/.Xdefaults file.LBL="D"ID="46986"Internationalized CommandsThis appendix lists First-Pass Internationalized Commands. IDREF="73542" TYPE="TABLE"Table D-1
 lists UNIX andIDREF="33463" TYPE="TABLE"Table D-2
 lists X-Client commands.COLUMNS="2"LBL="D-1"Table D-1 ID="73542"UNIX CommandsLEFT="0" WIDTH="153"CommandLEFT="160" WIDTH="356"DescriptionLEFT="0" WIDTH="153"acceptLEFT="160" WIDTH="356"allow LP requestsLEFT="0" WIDTH="153"awkLEFT="160" WIDTH="356"pattern scanning and processing 
languageLEFT="0" WIDTH="153"basenameLEFT="160" WIDTH="356"deliver portions of path namesLEFT="0" WIDTH="153"bdiffLEFT="160" WIDTH="356"big diffLEFT="0" WIDTH="153"calLEFT="160" WIDTH="356"print calendarLEFT="0" WIDTH="153"cancelLEFT="160" WIDTH="356"cancel requests to an LP line printerLEFT="0" WIDTH="153"catLEFT="160" WIDTH="356"concatenate and print filesLEFT="0" WIDTH="153"chmodLEFT="160" WIDTH="356"change the permissions mode of a file 
or directoryLEFT="0" WIDTH="153"chownLEFT="160" WIDTH="356"change ownerLEFT="0" WIDTH="153"chrootLEFT="160" WIDTH="356"change root directory for a commandLEFT="0" WIDTH="153"clearLEFT="160" WIDTH="356"clear terminal screenLEFT="0" WIDTH="153"cmpLEFT="160" WIDTH="356"compare two filesLEFT="0" WIDTH="153"colLEFT="160" WIDTH="356"filter reverse line-feedsLEFT="0" WIDTH="153"commLEFT="160" WIDTH="356"select or reject lines common to two 
sorted filesLEFT="0" WIDTH="153"compressLEFT="160" WIDTH="356"compress dataLEFT="0" WIDTH="153"cpLEFT="160" WIDTH="356"copy filesLEFT="0" WIDTH="153"cpioLEFT="160" WIDTH="356"copy file archives in and outLEFT="0" WIDTH="153"cryptLEFT="160" WIDTH="356"encode/decodeLEFT="0" WIDTH="153"cshLEFT="160" WIDTH="356"shell command interpreter with a 
C-like syntaxLEFT="0" WIDTH="153"csplitLEFT="160" WIDTH="356"context splitLEFT="0" WIDTH="153"cutLEFT="160" WIDTH="356"cut out selected fields of each line of a 
fileLEFT="0" WIDTH="153"dateLEFT="160" WIDTH="356"print and set the dateLEFT="0" WIDTH="153"ddLEFT="160" WIDTH="356"convert and copy a fileLEFT="0" WIDTH="153"dfLEFT="160" WIDTH="356"report number of free disk blocksLEFT="0" WIDTH="153"diffLEFT="160" WIDTH="356"differential file and directory 
comparatorLEFT="0" WIDTH="153"dircmpLEFT="160" WIDTH="356"directory comparisonLEFT="0" WIDTH="153"dirnameLEFT="160" WIDTH="356"deliver portions of path namesLEFT="0" WIDTH="153"disableLEFT="160" WIDTH="356"disable LP printersLEFT="0" WIDTH="153"duLEFT="160" WIDTH="356"summarize disk usageLEFT="0" WIDTH="153"echoLEFT="160" WIDTH="356"echo argumentsLEFT="0" WIDTH="153"edLEFT="160" WIDTH="356"text editorLEFT="0" WIDTH="153"egrepLEFT="160" WIDTH="356"search a file for a pattern using full 
regular expressionsLEFT="0" WIDTH="153"enableLEFT="160" WIDTH="356"enable LP printersLEFT="0" WIDTH="153"exLEFT="160" WIDTH="356"text editorLEFT="0" WIDTH="153"falseLEFT="160" WIDTH="356"provide false valuesLEFT="0" WIDTH="153"fgrepLEFT="160" WIDTH="356"search a file for a character stringLEFT="0" WIDTH="153"fileLEFT="160" WIDTH="356"determine file typeLEFT="0" WIDTH="153"findLEFT="160" WIDTH="356"find filesLEFT="0" WIDTH="153"foldLEFT="160" WIDTH="356"fold long lines for finite width output 
deviceLEFT="0" WIDTH="153"gencatLEFT="160" WIDTH="356"generate a formatted message 
catalogueLEFT="0" WIDTH="153"getoptLEFT="160" WIDTH="356"parse command optionsLEFT="0" WIDTH="153"gettxtLEFT="160" WIDTH="356"retrieve a text string from a message 
databaseLEFT="0" WIDTH="153"grepLEFT="160" WIDTH="356"search a file for a patternLEFT="0" WIDTH="153"headLEFT="160" WIDTH="356"give first few linesLEFT="0" WIDTH="153"joinLEFT="160" WIDTH="356"relational database operatorLEFT="0" WIDTH="153"kbdloadLEFT="160" WIDTH="356"load or link kbd tablesLEFT="0" WIDTH="153"kbdpipeLEFT="160" WIDTH="356"use the kbd module in a pipelineLEFT="0" WIDTH="153"kbdsetLEFT="160" WIDTH="356"attach to kbd mapping tables, set 
modesLEFT="0" WIDTH="153"killLEFT="160" WIDTH="356"terminate a process by defaultLEFT="0" WIDTH="153"killallLEFT="160" WIDTH="356"kill named processesLEFT="0" WIDTH="153"lineLEFT="160" WIDTH="356"read one lineLEFT="0" WIDTH="153"lnLEFT="160" WIDTH="356"link filesLEFT="0" WIDTH="153"loginLEFT="160" WIDTH="356"loginLEFT="0" WIDTH="153"lognameLEFT="160" WIDTH="356"get login nameLEFT="0" WIDTH="153"lpLEFT="160" WIDTH="356"send requests to an LP line printerLEFT="0" WIDTH="153"lpadminLEFT="160" WIDTH="356"configure the LP spooling systemLEFT="0" WIDTH="153"lpmoveLEFT="160" WIDTH="356"move LP requestsLEFT="0" WIDTH="153"lpshutLEFT="160" WIDTH="356"stop the LP schedulerLEFT="0" WIDTH="153"lpstatLEFT="160" WIDTH="356"print LP status informationLEFT="0" WIDTH="153"lsLEFT="160" WIDTH="356"list contents of directoryLEFT="0" WIDTH="153"mailLEFT="160" WIDTH="356"send mail to users or read mailLEFT="0" WIDTH="153"MailLEFT="160" WIDTH="356"send mail to users or read mailLEFT="0" WIDTH="153"makeLEFT="160" WIDTH="356"maintain, update, and regenerate 
groups of programsLEFT="0" WIDTH="153"makekeyLEFT="160" WIDTH="356"generate encryption keyLEFT="0" WIDTH="153"mesgLEFT="160" WIDTH="356"permit or deny messagesLEFT="0" WIDTH="153"mkdirLEFT="160" WIDTH="356"make directoriesLEFT="0" WIDTH="153"mkmsgsLEFT="160" WIDTH="356"create message files for use by gettxtLEFT="0" WIDTH="153"mknodLEFT="160" WIDTH="356"build special file or named pipeLEFT="0" WIDTH="153"moreLEFT="160" WIDTH="356"browse through a text fileLEFT="0" WIDTH="153"mvLEFT="160" WIDTH="356"move filesLEFT="0" WIDTH="153"mvdirLEFT="160" WIDTH="356"move a directoryLEFT="0" WIDTH="153"nawkLEFT="160" WIDTH="356"pattern scanning and processing 
languageLEFT="0" WIDTH="153"nlLEFT="160" WIDTH="356"line numbering filterLEFT="0" WIDTH="153"nohupLEFT="160" WIDTH="356"run a command immune to hangups 
and quitsLEFT="0" WIDTH="153"odLEFT="160" WIDTH="356"octal dumpLEFT="0" WIDTH="153"packLEFT="160" WIDTH="356"compress filesLEFT="0" WIDTH="153"passwdLEFT="160" WIDTH="356"change login password and 
password attributesLEFT="0" WIDTH="153"pasteLEFT="160" WIDTH="356"merge same lines of several files or 
subsequent lines of one fileLEFT="0" WIDTH="153"pcatLEFT="160" WIDTH="356"expand filesLEFT="0" WIDTH="153"pfmtLEFT="160" WIDTH="356"display error message in standard 
formatLEFT="0" WIDTH="153"pgLEFT="160" WIDTH="356"file perusal filter for CRTsLEFT="0" WIDTH="153"prLEFT="160" WIDTH="356"print filesLEFT="0" WIDTH="153"printfLEFT="160" WIDTH="356"print formatted outputLEFT="0" WIDTH="153"psLEFT="160" WIDTH="356"report process statusLEFT="0" WIDTH="153"pwconvLEFT="160" WIDTH="356"install and update /etc/shadow with 
information from /etc/passwdLEFT="0" WIDTH="153"pwdLEFT="160" WIDTH="356"print working directory nameLEFT="0" WIDTH="153"rcsLEFT="160" WIDTH="356"change RCS file attributesLEFT="0" WIDTH="153"rejectLEFT="160" WIDTH="356"prevent LP requestsLEFT="0" WIDTH="153"rmLEFT="160" WIDTH="356"remove filesLEFT="0" WIDTH="153"rmdirLEFT="160" WIDTH="356"remove directoriesLEFT="0" WIDTH="153"sedLEFT="160" WIDTH="356"stream editorLEFT="0" WIDTH="153"shLEFT="160" WIDTH="356"shell, the standard/restricted 
commanprogramming languageLEFT="0" WIDTH="153"sleepLEFT="160" WIDTH="356"suspend execution for an intervalLEFT="0" WIDTH="153"sortLEFT="160" WIDTH="356"sort and/or merge filesLEFT="0" WIDTH="153"splitLEFT="160" WIDTH="356"split a file into piecesLEFT="0" WIDTH="153"srchtxtLEFT="160" WIDTH="356"display contents of, or search for a 
text string in,message databasesLEFT="0" WIDTH="153"stringsLEFT="160" WIDTH="356"find printable strings in an object file 
or binaryLEFT="0" WIDTH="153"sttyLEFT="160" WIDTH="356"set the options for a terminalLEFT="0" WIDTH="153"suLEFT="160" WIDTH="356"become super-user or another userLEFT="0" WIDTH="153"sumLEFT="160" WIDTH="356"print checksum and block count of a 
fileLEFT="0" WIDTH="153"syncLEFT="160" WIDTH="356"update the super blockLEFT="0" WIDTH="153"sysinfoLEFT="160" WIDTH="356"print system identificationLEFT="0" WIDTH="153"tailLEFT="160" WIDTH="356"deliver the last part of a fileLEFT="0" WIDTH="153"tarLEFT="160" WIDTH="356"tape archiverLEFT="0" WIDTH="153"teeLEFT="160" WIDTH="356"pipe fittingLEFT="0" WIDTH="153"testLEFT="160" WIDTH="356"condition evaluation commandLEFT="0" WIDTH="153"timeLEFT="160" WIDTH="356"time a commandLEFT="0" WIDTH="153"touchLEFT="160" WIDTH="356"update access and modification times 
of a fileLEFT="0" WIDTH="153"trLEFT="160" WIDTH="356"translate charactersLEFT="0" WIDTH="153"trueLEFT="160" WIDTH="356"provide truth valuesLEFT="0" WIDTH="153"ttyLEFT="160" WIDTH="356"get the name of the terminaLEFT="0" WIDTH="153"unameLEFT="160" WIDTH="356"identify the current IRIX systemLEFT="0" WIDTH="153"uncompressLEFT="160" WIDTH="356"expand dataLEFT="0" WIDTH="153"uniqLEFT="160" WIDTH="356"report repeated lines in a fileLEFT="0" WIDTH="153"unpackLEFT="160" WIDTH="356"expand filesLEFT="0" WIDTH="153"viLEFT="160" WIDTH="356"screen-oriented (visual) display 
editor based on exLEFT="0" WIDTH="153"wallLEFT="160" WIDTH="356"write to all usersLEFT="0" WIDTH="153"wcLEFT="160" WIDTH="356"word countLEFT="0" WIDTH="153"wchrtblLEFT="160" WIDTH="356"generate character classification and 
conversion tables for ASCII and 
supplementary code setsLEFT="0" WIDTH="153"whereisLEFT="160" WIDTH="356"locate source, binary, and or manual 
for programLEFT="0" WIDTH="153"whoLEFT="160" WIDTH="356"who is on the systemLEFT="0" WIDTH="153"whoamiLEFT="160" WIDTH="356"display the effective current 
usernameLEFT="0" WIDTH="153"writeLEFT="160" WIDTH="356"write to another userCOLUMNS="2"LBL="D-2"Table D-2 ID="33463"X-Client CommandsLEFT="0" WIDTH="153"ClientLEFT="160" WIDTH="356"CommentLEFT="0" WIDTH="153"4DwmLEFT="160" WIDTH="356"IRIS extended Motif window 
managerLEFT="0" WIDTH="153"bitmapLEFT="160" WIDTH="356"bitmap editorLEFT="0" WIDTH="153"editresLEFT="160" WIDTH="356"dynamic resource editor for X Toolkit 
applications (Internationalized 
version)LEFT="0" WIDTH="153"extermLEFT="160" WIDTH="356"terminal emulatorLEFT="0" WIDTH="153"toolchestLEFT="160" WIDTH="356"utility menu programLEFT="0" WIDTH="153"twmLEFT="160" WIDTH="356"Tab window managerLEFT="0" WIDTH="153"viewresLEFT="160" WIDTH="356"graphical class browser for XtLEFT="0" WIDTH="153"wintermLEFT="160" WIDTH="356"terminal emulatorLEFT="0" WIDTH="153"xcalendarLEFT="160" WIDTH="356"calendar with a notebook for X11LEFT="0" WIDTH="153"xclipboardLEFT="160" WIDTH="356"clipboard clientLEFT="0" WIDTH="153"xeditLEFT="160" WIDTH="356"text editorLEFT="0" WIDTH="153"xlbiffLEFT="160" WIDTH="356"mailbox message previewer for XLEFT="0" WIDTH="153"xmessageLEFT="160" WIDTH="356"display a message or query in a 
window (X-based /bin/echo)LEFT="0" WIDTH="153"xmhLEFT="160" WIDTH="356"send and read mail with an X 
interface to MH (Internationalized 
version)LEFT="0" WIDTH="153"xpostitLEFT="160" WIDTH="356"X window system Post-itr notes^IDREF="04.lex15"Some Special FeaturesacceptIDREF="05.yacc32"Parser OperationAddrs fileIDREF="03.optimize3"SyntaxIDREF="03.optimize15"Obtaining Basic Block CountsAdobe Bitmap Distribution Format (BDF)IDREF="09.fonts31"About the Extended Bitmap Distribution Format Version 2.1ar commandcommand syntaxIDREF="01.compiler49"SyntaxoptionsIDREF="01.compiler50"Archiver Optionsar command IDREF="01.compiler51"ExamplesIDREF="01.compiler48"Using the Archiver to Create Librariesarchiver, see ar commandIDREF="01.compiler48"Using the Archiver to Create Librariesas1IDREF="01.compiler10"OverviewassemblerIDREF="01.compiler10"Overviewassembly language programs, link editingIDREF="01.compiler23"Linking Assembly Language Programsbal operationIDREF="A.assembly5"Position-Independent Coding in Assembly Languagebasic blocks, counting, see profiling IDREF="03.optimize13"Basic Block Countingcc, see driversIDREF="01.compiler3"OverviewcfeIDREF="01.compiler6"OverviewIDREF="01.compiler4"OverviewbypassingIDREF="01.compiler12"Overviewcharacter sets, see internationalization, character setsIDREF="10.intl15"Character Sets, Codesets, and Encodingscharacters, scalingIDREF="09.fonts20"Font Transformationcmov()IDREF="09.fonts57"Rendering FontsIDREF="09.fonts60"Rendering Fontscode generatorIDREF="01.compiler9"Overviewcodesets, see internationalization, codesetsIDREF="10.intl15"Character Sets, Codesets, and Encodingscompiler drivers, see driversIDREF="01.compiler2"Overviewcompiler front endIDREF="01.compiler6"Overviewcompiler options, see driversIDREF="01.compiler18"General Options for Compiler Driverscompose tablesaboutIDREF="11.local1"IRIX Locale ComponentsCounts fileIDREF="03.optimize16"Obtaining Basic Block CountsIDREF="03.optimize4"Syntaxdbxand include filesIDREF="01.compiler15"Header Filesdeadline schedulingIDREF="08.realtime15"Scheduling Controldebuggingand include filesIDREF="01.compiler15"Header Filesand optimizationIDREF="03.optimize31"Loop OptimizationdlcloseIDREF="02.dso18"Dynamic Loading under Program ControldlerrorIDREF="02.dso17"Dynamic Loading under Program ControldlopenIDREF="02.dso15"Dynamic Loading under Program ControldlsymIDREF="02.dso16"Dynamic Loading under Program ControldriversccIDREF="01.compiler2"Overviewf77IDREF="01.compiler2"OverviewoptionsIDREF="01.compiler18"General Options for Compiler Driversoptions:-KPICIDREF="A.assembly2"Position-Independent Coding in Assembly LanguageIDREF="A.assembly4"Position-Independent Coding in Assembly Languageoptions:-llIDREF="04.lex33"Running lex Under IRIXoptions:-lyIDREF="04.lex34"Running lex Under IRIXoptions:-nocppIDREF="01.compiler12"Overviewoptions:-non_sharedIDREF="A.assembly4"Position-Independent Coding in Assembly Languageoptions:-O3IDREF="03.optimize35"Full Optimizationoptions:-vIDREF="01.compiler13"Overviewoptions:passing options to ldIDREF="01.compiler20"Invoking the Link Editor ManuallypcIDREF="01.compiler2"OverviewDSOsbuilding new DSOsIDREF="02.dso5"Building DSOsdynamic loading diagnosticsIDREF="02.dso17"Dynamic Loading under Program Controllinking withIDREF="01.compiler28"Linking to Dynamic Shared Objectsloading dynamicallyIDREF="02.dso15"Dynamic Loading under Program Controlnaming conventionsIDREF="02.dso7"Building DSOsunloading dynamicallyIDREF="02.dso18"Dynamic Loading under Program ControlDSOs IDREF="02.dso19"Dynamic Loading under Program ControlIDREF="02.dso1"Dynamic Shared Objectsdynamic linkingIDREF="02.dso14"Dynamic Loading under Program ControlDynamic Shared Objects, see DSOsIDREF="01.compiler28"Linking to Dynamic Shared Objectselfdump commandIDREF="01.compiler31"Getting Information about Object FilesIDREF="01.compiler36"Listing Selected Parts of Object Files and Libraries with elfdumpcommand syntaxIDREF="01.compiler37"Syntaxencodings, see internationalization, encodingsIDREF="10.intl16"Character Sets, Codesets, and Encodingserrno variableIDREF="06.ipc29"Example ProgramerrorIDREF="05.yacc32"Parser Operationf77, see driversIDREF="01.compiler3"Overviewfcntl()IDREF="07.locking4"File and Record LockingIDREF="07.locking15"Setting a File LockfcomIDREF="01.compiler6"Overviewfile and record lockingIDREF="07.locking2"File and Record LockingIDREF="07.locking36"ConclusionadvisoryIDREF="07.locking34"Mandatory LockingIDREF="07.locking3"File and Record LockingIDREF="07.locking10"Terminologychanging lock typesIDREF="07.locking21"Setting and Removing Record Locksefficiency, comparativeIDREF="07.locking33"Mandatory Lockingexclusive locksIDREF="07.locking9"TerminologyF_GETLKIDREF="07.locking26"Getting Lock InformationF_SETLKIDREF="07.locking22"Setting and Removing Record LocksF_TESTIDREF="07.locking28"Getting Lock InformationF_ULOCKIDREF="07.locking24"Setting and Removing Record LocksF_UNLCKIDREF="07.locking24"Setting and Removing Record LocksfailureIDREF="07.locking19"Setting and Removing Record Locksfcntl()IDREF="07.locking15"Setting a File LockforkingIDREF="07.locking29"Getting Lock Informationlockf()IDREF="07.locking16"Setting a File Locklseek()IDREF="07.locking17"Setting a File LockmandatoryIDREF="07.locking11"TerminologyIDREF="07.locking3"File and Record Lockingmandatory:assuringIDREF="07.locking31"Selecting Advisory or Mandatory Lockingmultiple read locksIDREF="07.locking27"Getting Lock Informationorder of lock removalIDREF="07.locking23"Setting and Removing Record LocksoverviewIDREF="07.locking5"File and Record LockingIDREF="07.locking2"File and Record Lockingpromoting a lockIDREF="07.locking20"Setting and Removing Record Locksread locksIDREF="07.locking8"Terminologyshare locksIDREF="07.locking8"Terminologywrite locksIDREF="07.locking9"Terminologyfile commandIDREF="01.compiler32"Getting Information about Object FilesIDREF="01.compiler38"Determining File Type with filecommand syntaxIDREF="01.compiler39"Syntaxfile type, determiningIDREF="01.compiler38"Determining File Type with filefile, listing properties ofIDREF="01.compiler32"Getting Information about Object Filesfinite-state machineIDREF="05.yacc27"Parser Operationfmconcatpagematrix()IDREF="09.fonts90"Transforming the Pagefmenumerate()IDREF="09.fonts42"Initializing Fontsfmfreefont()IDREF="09.fonts78"Managing Font Memoryfmgetfontname()IDREF="09.fonts62"Getting Font Informationfmgetpagematrix()IDREF="09.fonts87"Transforming the Pagefmglyphinfo structureIDREF="09.fonts4"Font MetricsIDREF="09.fonts65"Getting Font Glyph Informationfminitpagematrix()IDREF="09.fonts85"Transforming the Pagefmmakefont()IDREF="09.fonts50"Scaling Fontsfmoutchar()IDREF="09.fonts55"Rendering Fontsfmprstr()IDREF="09.fonts56"Rendering FontsIDREF="09.fonts59"Rendering Fontsfmrotatepagematrix()IDREF="09.fonts22"Font TransformationIDREF="09.fonts89"Transforming the Pagefmscalefont()IDREF="09.fonts21"Font TransformationIDREF="09.fonts49"Scaling Fontsfmscalepagematrix()IDREF="09.fonts88"Transforming the Pagefmsetpagematrix()IDREF="09.fonts86"Transforming the Pagefmsetpath()IDREF="09.fonts29"Font Search Pathfont handlesIDREF="09.fonts41"Initializing FontsFont Manageradjusting fonts for laser printersIDREF="09.fonts79"Adjusting Widths to Match Laser Printerschanging font search pathIDREF="09.fonts72"Getting and Setting the Font Environment Variablesfont renderingIDREF="09.fonts15"Font Transformationfont search pathIDREF="09.fonts24"Font Search Pathgetting character lengthIDREF="09.fonts70"Getting the Width of a Charactergetting font handlesIDREF="09.fonts38"Initializing Fontsgetting the string lengthIDREF="09.fonts67"Getting the Width of a Character Stringinititializing fontsIDREF="09.fonts35"Initializing Fontslist of routinesIDREF="09.fonts34"Font Management RoutinespageIDREF="09.fonts14"Font Transformationpage transformationIDREF="09.fonts83"Transforming the Pagerendering fontsIDREF="09.fonts53"Rendering Fontsrotating fontsIDREF="09.fonts43"Scaling Fontssample programIDREF="09.fonts92"Sample GL Program Using Font Manager Library Routinessetting search pathIDREF="09.fonts76"Setting the Font Search Pathsizing fontsIDREF="09.fonts47"Scaling Fontssubpixel positioning fontsIDREF="09.fonts5"Font MetricstransformationIDREF="09.fonts12"Font Transformationfont metricsIDREF="09.fonts2"Font MetricsFONTPATH IDREF="09.fonts28"Font Search PathfontsAdobe Bitmap Distribution Format (BDF)IDREF="09.fonts32"About the Extended Bitmap Distribution Format Version 2.1changing search pathIDREF="09.fonts73"Getting and Setting the Font Environment Variablesexample programIDREF="09.fonts91"Sample GL Program Using Font Manager Library Routinesfont management routinesIDREF="09.fonts33"Font Management Routinesfont metricsIDREF="09.fonts3"Font Metricsfont renderingIDREF="09.fonts18"Font Transformationfont search pathIDREF="09.fonts25"Font Search PathFONTPATHIDREF="09.fonts27"Font Search Pathgeting string lengthIDREF="09.fonts68"Getting the Width of a Character Stringgetting a font handleIDREF="09.fonts40"Initializing Fontsgetting character lengthIDREF="09.fonts71"Getting the Width of a CharacterinitializingIDREF="09.fonts37"Initializing FontspageIDREF="09.fonts17"Font Transformationpage transformationIDREF="09.fonts84"Transforming the PagerenderingIDREF="09.fonts54"Rendering FontsrotatingIDREF="09.fonts44"Scaling Fontssetting search pathIDREF="09.fonts77"Setting the Font Search PathsizingIDREF="09.fonts9"Font Specification and SizingIDREF="09.fonts48"Scaling FontsspecificationIDREF="09.fonts8"Font Specification and Sizingsubpixel positioningIDREF="09.fonts6"Font MetricstransformationIDREF="09.fonts13"Font Transformationwidths for laser printersIDREF="09.fonts80"Adjusting Widths to Match Laser PrintersX Window SystemIDREF="09.fonts93"Installing Font and Font Metric FilesforkingIDREF="07.locking29"Getting Lock Informationgetcpos()IDREF="09.fonts58"Rendering FontsIDREF="09.fonts61"Rendering Fontsgettimeofday() system callIDREF="08.realtime2"Event Timingglobal optimizerIDREF="03.optimize28"Global OptimizergotoIDREF="05.yacc30"Parser Operation.gpwordIDREF="A.assembly3"Position-Independent Coding in Assembly LanguageIDREF="A.assembly6"Position-Independent Coding in Assembly Languageheader filesIDREF="01.compiler14"Header Filesfor multiple languagesIDREF="01.compiler16"Creating a Header File for Multiple Languagesinclude filesIDREF="01.compiler14"Header Filesfor multiple languagesIDREF="01.compiler17"Creating a Header File for Multiple Languagesindirect calls, use ofIDREF="03.optimize40"C and Fortran Programsinitializing fontsIDREF="09.fonts36"Initializing Fontsinput()IDREF="04.lex16"Some Special Featuresinstalling X font filesIDREF="09.fonts95"Installing Font and Font Metric Filesinternationalizationcharacter sets:definedIDREF="10.intl15"Character Sets, Codesets, and Encodingscodesets:definedIDREF="10.intl15"Character Sets, Codesets, and Encodingsencodings:aboutIDREF="10.intl11"Locale Naming Conventionsencodings:definedIDREF="10.intl16"Character Sets, Codesets, and Encodingsencodings:multi byteIDREF="10.intl20"Eight-Bit Cleanlinessencodings:wcharIDREF="10.intl20"Eight-Bit Cleanlinesslanguages:in locale stringsIDREF="10.intl9"Locale Naming Conventionsmultibyte characters:aboutIDREF="10.intl19"Eight-Bit Cleanlinesssigned charsIDREF="10.intl18"Eight-Bit CleanlinessterritoriesIDREF="10.intl10"Locale Naming Conventionswide characters:aboutIDREF="10.intl20"Eight-Bit Cleanlinessinterruptsinterrupt response timeIDREF="08.realtime32"Real-Time LatencyredirectingIDREF="08.realtime25"Real-Time Support in the KernelIPCarenasIDREF="06.ipc3"Types of Inter-Process Communication AvailableIPC_CREATIDREF="06.ipc16"Message Operations OverviewIDREF="06.ipc86"Using Shared MemoryIPC_EXCLIDREF="06.ipc94"Getting Shared Memory Segments with shmget()IDREF="06.ipc74"Getting Semaphores with semget()IDREF="06.ipc67"Using SemaphoresIDREF="06.ipc20"Message Operations OverviewIPC_NOWAITIDREF="06.ipc54"System V SemaphoresIDREF="06.ipc39"Receiving MessagesIPC_PRIVATEIDREF="06.ipc65"Using SemaphoresIDREF="06.ipc23"Getting Message Queues with msgget()IPC_RMIDIDREF="06.ipc31"Controlling Message Queues: msgctl()IPC_SETIDREF="06.ipc31"Controlling Message Queues: msgctl()IPC_STATIDREF="06.ipc31"Controlling Message Queues: msgctl()ipcsIDREF="06.ipc87"Using Shared MemoryIDREF="06.ipc66"Using SemaphoreskeysIDREF="06.ipc3"Types of Inter-Process Communication AvailableIDREF="06.ipc18"Message Operations Overviewmessage operation permissionsIDREF="06.ipc24"Getting Message Queues with msgget()message operationsIDREF="06.ipc9"System V Messagesmessage queuesIDREF="06.ipc14"Message QueuesIDREF="06.ipc6"System V Messagesmessage queues:controllingIDREF="06.ipc21"Message Operations Overviewmessage queues:creatingIDREF="06.ipc17"Message Operations Overviewmessage queues:data structureIDREF="06.ipc13"Message Queuesmessage queues:maximum numberIDREF="06.ipc27"Getting Message Queues with msgget()messagesIDREF="06.ipc43"msgrcvmessages:automatic truncatingIDREF="06.ipc41"Receiving Messagesmessages:limit on total numberIDREF="06.ipc37"Sending a Messagemessages:msgctl()IDREF="06.ipc21"Message Operations OverviewIDREF="06.ipc8"System V Messagesmessages:msgctl():exampleIDREF="06.ipc32"Example Programmessages:msgget()IDREF="06.ipc7"System V Messagesmessages:msgget():exampleIDREF="06.ipc28"Example Programmessages:msgrcv()IDREF="06.ipc34"Operations for Messages: msgsnd() and msgrcv()messages:msgrcv():exampleIDREF="06.ipc42"Example Programmessages:msgsnd():exampleIDREF="06.ipc42"Example Programmessages:receivingIDREF="06.ipc35"Operations for Messages: msgsnd() and msgrcv()MSG_NOERRORIDREF="06.ipc40"Receiving MessagesMSG_RIDREF="06.ipc25"Getting Message Queues with msgget()MSG_WIDREF="06.ipc25"Getting Message Queues with msgget()msgctl()IDREF="06.ipc8"System V MessagesIDREF="06.ipc21"Message Operations OverviewmsgflgIDREF="06.ipc26"Getting Message Queues with msgget()IDREF="06.ipc16"Message Operations Overviewmsgget()IDREF="06.ipc7"System V MessagesMSGMNIIDREF="06.ipc27"Getting Message Queues with msgget()msgrcv()IDREF="06.ipc34"Operations for Messages: msgsnd() and msgrcv()MSGTQLIDREF="06.ipc37"Sending a MessagemsqidIDREF="06.ipc12"Message QueuesportabilityIDREF="06.ipc3"Types of Inter-Process Communication Availableremoving facilitiesIDREF="06.ipc57"System V SemaphoressemaphoresIDREF="06.ipc81"Example Programsemaphores:arrays of operationsIDREF="06.ipc60"System V Semaphoressemaphores:blocking operationsIDREF="06.ipc55"System V Semaphoressemaphores:control commandsIDREF="06.ipc71"Getting Semaphores with semget()semaphores:controllingIDREF="06.ipc68"Using Semaphoressemaphores:creatingIDREF="06.ipc48"System V SemaphoresIDREF="06.ipc72"Getting Semaphores with semget()IDREF="06.ipc64"Using Semaphoressemaphores:decrementingIDREF="06.ipc52"System V Semaphoressemaphores:gettingIDREF="06.ipc64"Using Semaphoressemaphores:incrementingIDREF="06.ipc52"System V Semaphoressemaphores:maximum number allowedIDREF="06.ipc45"System V Semaphoressemaphores:nonblocking operationsIDREF="06.ipc56"System V Semaphoressemaphores:number of, limitsIDREF="06.ipc73"Getting Semaphores with semget()semaphores:numberingIDREF="06.ipc59"System V Semaphoressemaphores:operation permissionsIDREF="06.ipc70"Getting Semaphores with semget()semaphores:operations, limitsIDREF="06.ipc79"Operations on Semaphores: semop()semaphores:ownershipIDREF="06.ipc49"System V Semaphoressemaphores:semctl()IDREF="06.ipc50"System V SemaphoresIDREF="06.ipc68"Using Semaphoressemaphores:semget():exampleIDREF="06.ipc75"Example Programsemaphores:semop()IDREF="06.ipc51"System V SemaphoresIDREF="06.ipc58"System V Semaphoressemaphores:semop():exampleIDREF="06.ipc80"Example Programsemaphores:set structureIDREF="06.ipc63"Using Semaphoressemaphores:testing valuesIDREF="06.ipc53"System V Semaphoressemaphores:undo structuresIDREF="06.ipc61"System V Semaphoressemctl()IDREF="06.ipc68"Using SemaphoresIDREF="06.ipc50"System V Semaphoressemget()IDREF="06.ipc47"System V SemaphoresIDREF="06.ipc64"Using SemaphoresSEMMNIIDREF="06.ipc73"Getting Semaphores with semget()SEMMNSIDREF="06.ipc73"Getting Semaphores with semget()SEMMSLIDREF="06.ipc46"System V SemaphoresIDREF="06.ipc73"Getting Semaphores with semget()semop()IDREF="06.ipc51"System V SemaphoresIDREF="06.ipc58"System V SemaphoresSEMOPMIDREF="06.ipc79"Operations on Semaphores: semop()sempahores:semget()IDREF="06.ipc47"System V Semaphoressetting message permissionsIDREF="06.ipc26"Getting Message Queues with msgget()shared memoryIDREF="06.ipc103"shmdtshared memory:attachingIDREF="06.ipc83"System V Shared Memoryshared memory:control commandsIDREF="06.ipc92"Getting Shared Memory Segments with shmget()shared memory:controllingIDREF="06.ipc84"System V Shared MemoryIDREF="06.ipc88"Using Shared Memoryshared memory:creatingIDREF="06.ipc90"Getting Shared Memory Segments with shmget()IDREF="06.ipc86"Using Shared Memoryshared memory:detachingIDREF="06.ipc83"System V Shared Memoryshared memory:gettingIDREF="06.ipc86"Using Shared Memoryshared memory:number of segments, limitIDREF="06.ipc93"Getting Shared Memory Segments with shmget()shared memory:operation permissionsIDREF="06.ipc91"Getting Shared Memory Segments with shmget()shared memory:shmat()IDREF="06.ipc83"System V Shared Memoryshared memory:shmctl()IDREF="06.ipc84"System V Shared MemoryIDREF="06.ipc88"Using Shared Memoryshared memory:shmctl():exampleIDREF="06.ipc98"Example Programshared memory:shmdt()IDREF="06.ipc83"System V Shared Memoryshared memory:shmget()IDREF="06.ipc86"Using Shared Memoryshared memory:shmget():exampleIDREF="06.ipc96"Example Programshared memory:size, limitsIDREF="06.ipc95"Getting Shared Memory Segments with shmget()shmat()IDREF="06.ipc83"System V Shared Memoryshmctl()IDREF="06.ipc88"Using Shared MemoryIDREF="06.ipc84"System V Shared Memoryshmdt()IDREF="06.ipc83"System V Shared Memoryshmget()IDREF="06.ipc86"Using Shared MemorySHMMAXIDREF="06.ipc95"Getting Shared Memory Segments with shmget()SHMMINIDREF="06.ipc95"Getting Shared Memory Segments with shmget()SHMMNIIDREF="06.ipc93"Getting Shared Memory Segments with shmget()socketsIDREF="06.ipc3"Types of Inter-Process Communication Availablesuspending executionIDREF="06.ipc54"System V SemaphorestypesIDREF="06.ipc3"Types of Inter-Process Communication Availableipcs commandIDREF="06.ipc19"Message Operations Overviewjal operationIDREF="A.assembly5"Position-Independent Coding in Assembly LanguageKPIC, see driversIDREF="A.assembly2"Position-Independent Coding in Assembly LanguageldIDREF="01.compiler11"Overviewcommand syntaxIDREF="01.compiler21"Syntaxlibraries, default search pathIDREF="01.compiler26"Specifying Librariesoptions:-B symbolicIDREF="02.dso10"Options for Building Shared Objectsoptions:-sharedIDREF="02.dso6"Building DSOsuse with assembly language programsIDREF="01.compiler23"Linking Assembly Language ProgramslexIDREF="05.yacc25"Lexical AnalysisabbreviationsIDREF="04.lex22"DefinitionsactionsIDREF="04.lex9"Actionsadvanced usesIDREF="04.lex11"Advanced lex Usagecaret operatorIDREF="04.lex15"Some Special Featurescompiling a lex specificationIDREF="04.lex32"Running lex Under IRIXdefinitionsIDREF="04.lex20"DefinitionsdisadvantagesIDREF="04.lex4"lexfinite automataIDREF="04.lex37"Running lex Under IRIXfundamental rulesIDREF="04.lex6"The Fundamental lex Rulesmultiple matchingsIDREF="04.lex13"Some Special Featuresoptions:-tIDREF="04.lex35"Running lex Under IRIXoptions:-vIDREF="04.lex36"Running lex Under IRIXregular expressions:operatorsIDREF="04.lex8"Specificationsspecial featuresIDREF="04.lex12"Some Special FeaturessubroutinesIDREF="04.lex23"SubroutinestokvalIDREF="04.lex28"Using lex with yacctrailing contextIDREF="04.lex14"Some Special Featuresusing with IRIXIDREF="04.lex30"Running lex Under IRIXusing with yaccIDREF="04.lex24"Using lex with yaccwriting specificationsIDREF="04.lex5"Writing lex ProgramsyytextIDREF="04.lex10"Actionslex IDREF="04.lex38"Running lex Under IRIXIDREF="04.lex1"lexlex.yy.cIDREF="04.lex31"Running lex Under IRIXlexical analyzerIDREF="04.lex3"lexlibdlIDREF="02.dso14"Dynamic Loading under Program Controllibrariesand multilanguage programsIDREF="01.compiler27"Specifying Librariesnon-shared, converting to DSOsIDREF="02.dso13"Runtime Symbol Resolutionshared, staticIDREF="02.dso3"Dynamic Shared ObjectsIDREF="01.compiler29"Linking to Dynamic Shared ObjectsspecifyingIDREF="01.compiler24"Specifying Librarieslink editor, see ld IDREF="01.compiler11"Overviewloaderruntime, see rldIDREF="02.dso4"Dynamic Shared Objectsloader, see ldIDREF="01.compiler11"Overviewlocalescompose tables, see compose tablesIDREF="11.local1"IRIX Locale ComponentsencodingIDREF="10.intl11"Locale Naming Conventionsfont encoding attributes:aboutIDREF="11.local5"IRIX Locale ComponentslanguageIDREF="10.intl9"Locale Naming Conventionsmessage catalogs, see message catalogsIDREF="11.local2"IRIX Locale ComponentsmodifiersIDREF="10.intl12"Locale Naming ConventionsPOSIX locales:aboutIDREF="11.local3"IRIX Locale ComponentsterritoryIDREF="10.intl10"Locale Naming ConventionsX resource files:aboutIDREF="11.local4"IRIX Locale Componentslockf()IDREF="07.locking16"Setting a File LockIDREF="07.locking4"File and Record Lockinglook-ahead tokenIDREF="05.yacc27"Parser Operationloop unrollingIDREF="03.optimize32"Loop Unrollinglseek()IDREF="07.locking17"Setting a File Lockmacro preprocessorIDREF="01.compiler4"Overviewmemory mapped devicesIDREF="08.realtime11"Implicit I/Omessage catalogsaboutIDREF="11.local2"IRIX Locale Componentsmessage operationsblockingIDREF="06.ipc9"System V MessagesnonblockingIDREF="06.ipc10"System V Messagesmessage queue identifierIDREF="06.ipc12"Message Queuesmpin() system callIDREF="08.realtime8"Virtual Memory Controlmsgctl()IDREF="06.ipc8"System V MessagesIDREF="06.ipc21"Message Operations Overviewmsgget()IDREF="06.ipc7"System V Messagesmsgrcv()IDREF="06.ipc34"Operations for Messages: msgsnd() and msgrcv()msqidIDREF="06.ipc12"Message QueuesMultibyte characters, see internationalization, multibyte charactersIDREF="10.intl19"Eight-Bit Cleanlinessmultilanguage programsand header filesIDREF="01.compiler16"Creating a Header File for Multiple Languagesand librariesIDREF="01.compiler27"Specifying Librariesmultiprocessed executables, profilingIDREF="03.optimize26"Profiling Multiprocessed Executablesmunpin system callIDREF="08.realtime8"Virtual Memory Controlnm commandIDREF="01.compiler33"Getting Information about Object Filescommand syntaxIDREF="01.compiler41"Syntaxnm command IDREF="01.compiler42"ExampleIDREF="01.compiler40"Listing Symbol Table Information: nmnocpp, see driversIDREF="01.compiler12"Overviewnon-degrading prioritiesIDREF="08.realtime14"Scheduling Controlnon_shared optionIDREF="A.assembly4"Position-Independent Coding in Assembly LanguageO3 compiler optionIDREF="03.optimize35"Full Optimizationobject file informationlisting section sizesIDREF="01.compiler46"Determining Section Sizes with sizeIDREF="01.compiler35"Getting Information about Object Filessymbol table informationIDREF="01.compiler40"Listing Symbol Table Information: nmIDREF="01.compiler33"Getting Information about Object Filesusing elfdumpIDREF="01.compiler31"Getting Information about Object FilesIDREF="01.compiler36"Listing Selected Parts of Object Files and Libraries with elfdumpusing odumpIDREF="01.compiler34"Getting Information about Object FilesIDREF="01.compiler43"Listing Selected Parts of COFF Files with odumpobject file toolsIDREF="01.compiler30"Getting Information about Object Filesodump commandIDREF="01.compiler34"Getting Information about Object Filescommand syntaxIDREF="01.compiler44"Syntaxodump command IDREF="01.compiler43"Listing Selected Parts of COFF Files with odumpIDREF="01.compiler45"SyntaxoptimizationaddressesIDREF="03.optimize49"Generated Assembly Codeand debuggingIDREF="03.optimize31"Loop Optimizationand loop unrollingIDREF="03.optimize32"Loop Unrollingand register allocationIDREF="03.optimize33"Register AllocationCIDREF="03.optimize59"C Programs Onlydo whileIDREF="03.optimize42"C Programs Onlyfunction return valuesIDREF="03.optimize41"C Programs Onlyif-then-else statementsIDREF="03.optimize55"C and Fortran Programslibc.so functionsIDREF="03.optimize56"C Programs OnlyloopIDREF="03.optimize31"Loop Optimizationmachine-dependentIDREF="03.optimize29"Global Optimizermachine-independentIDREF="03.optimize29"Global Optimizerof separate compilation unitsIDREF="03.optimize34"Optimizing Separate Compilation Unitspointers and aliasingIDREF="03.optimize46"C Programs Onlypragma inlineIDREF="03.optimize53"AdaÆ Programsregister declarationsIDREF="03.optimize48"Generated Assembly Codesigned data typesIDREF="03.optimize58"C Programs OnlySTDARGIDREF="03.optimize50"Generated Assembly CodesubscriptsIDREF="03.optimize47"Generated Assembly CodetablesIDREF="03.optimize55"C and Fortran Programstips for improvingIDREF="03.optimize38"Improving Global OptimizationunionsIDREF="03.optimize43"C Programs Onlyunsigned data typeIDREF="03.optimize57"C Programs Onlyvalue parametersIDREF="03.optimize45"C Programs OnlyVARARGIDREF="03.optimize50"Generated Assembly Codevariables, global versus localIDREF="03.optimize44"C Programs Onlyoptimization, globalIDREF="03.optimize28"Global OptimizeroptimizerIDREF="01.compiler8"Overviewoptimizing programsbenefitsIDREF="03.optimize30"Optimization and Debuggingoutput()IDREF="04.lex16"Some Special Featurespage transformationIDREF="09.fonts82"Transforming the Pagepage, fontsIDREF="09.fonts16"Font Transformationparallel analyzerIDREF="01.compiler5"Overviewpc sampling, see profiling IDREF="03.optimize6"Pc Samplingpc, see driversIDREF="01.compiler3"OverviewpcaIDREF="01.compiler5"OverviewpfaIDREF="01.compiler5"OverviewpixieIDREF="03.optimize14"Using pixieand Addrs fileIDREF="03.optimize15"Obtaining Basic Block Countsand Counts fileIDREF="03.optimize16"Obtaining Basic Block Countsrestricting outputIDREF="03.optimize17"Obtaining Basic Block Countspixstats commandIDREF="03.optimize23"Using pixstatsexampleIDREF="03.optimize25"Exampleplock() system callIDREF="08.realtime9"Virtual Memory Controlpoint size, fontsIDREF="09.fonts10"Font Specification and SizingPosition-Independent Codeand assembly languageIDREF="A.assembly8"Examplesswitch tablesIDREF="A.assembly7"Position-Independent Coding in Assembly LanguageprintermatchedIDREF="09.fonts63"Getting Font Informationprocess priorities, non-degradingIDREF="08.realtime14"Scheduling ControlprocessesschedulingIDREF="08.realtime23"Real-Time Support in the Kernelprof, see profiling IDREF="03.optimize2"Syntaxprofilingaveraging resultsIDREF="03.optimize21"Averaging Basic Block Count Resultsbasic block counting IDREF="03.optimize22"Averaging Basic Block Count ResultsIDREF="03.optimize13"Basic Block Countingclock optionIDREF="03.optimize20"Examplescommand syntaxIDREF="03.optimize24"SyntaxIDREF="03.optimize2"Syntaxexclude optionIDREF="03.optimize8"Pc SamplingIDREF="03.optimize18"Obtaining Basic Block Countsg optionIDREF="03.optimize18"Obtaining Basic Block Countsmerge optionIDREF="03.optimize5"Syntaxonly optionIDREF="03.optimize18"Obtaining Basic Block CountsIDREF="03.optimize8"Pc Samplingpc sampling IDREF="03.optimize6"Pc SamplingIDREF="03.optimize12"Creating Multiple Profile Data Filesquit optionIDREF="03.optimize17"Obtaining Basic Block Countswith multiple data filesIDREF="03.optimize10"Creating Multiple Profile Data Filesprofiling IDREF="03.optimize1"Profiling with profIDREF="03.optimize27"Profiling Multiprocessed Executablespset commandIDREF="08.realtime16"Scheduling Controlrecord, definitionIDREF="07.locking7"TerminologyreduceIDREF="05.yacc29"Parser Operationregister allocationIDREF="03.optimize33"Register AllocationREJECTIDREF="04.lex17"Some Special FeaturesIDREF="04.lex19"Some Special FeaturesrldIDREF="02.dso4"Dynamic Shared ObjectsIDREF="02.dso11"Runtime Linkingrotating fontsIDREF="09.fonts45"Scaling Fontsruntime linker, see rld IDREF="02.dso4"Dynamic Shared Objectsruntime linkingIDREF="02.dso11"Runtime Linkingscheduling controlIDREF="08.realtime15"Scheduling Controlsearch path, fontsIDREF="09.fonts23"Font Search Pathsemctl()IDREF="06.ipc50"System V SemaphoresIDREF="06.ipc68"Using Semaphoressemget()IDREF="06.ipc47"System V SemaphoresIDREF="06.ipc64"Using Semaphoressemop()IDREF="06.ipc51"System V SemaphoresIDREF="06.ipc58"System V Semaphoresshared libraries, staticIDREF="01.compiler29"Linking to Dynamic Shared ObjectsIDREF="02.dso3"Dynamic Shared Objectsshared process groupsschedulingIDREF="08.realtime24"Real-Time Support in the KernelshiftIDREF="05.yacc28"Parser Operationshmat()IDREF="06.ipc83"System V Shared Memoryshmctl()IDREF="06.ipc88"Using Shared MemoryIDREF="06.ipc84"System V Shared Memoryshmdt()IDREF="06.ipc83"System V Shared Memoryshmget()IDREF="06.ipc86"Using Shared MemorysignalsBSDIDREF="08.realtime5"Reliable and Queued SignalsPOSIXIDREF="08.realtime5"Reliable and Queued Signalssize commandIDREF="01.compiler46"Determining Section Sizes with sizeIDREF="01.compiler35"Getting Information about Object Filescommand syntaxIDREF="01.compiler47"Syntaxsizing fontsIDREF="09.fonts11"Font Specification and SizingIDREF="09.fonts46"Scaling FontssocketsIDREF="06.ipc3"Types of Inter-Process Communication AvailableSTDARG, see optimization IDREF="03.optimize51"Generated Assembly Codesubpixel positioning, fontsIDREF="09.fonts7"Font Metricsswitch tablesIDREF="A.assembly7"Position-Independent Coding in Assembly Languagesymbol table information, listingIDREF="01.compiler33"Getting Information about Object Filestables, switchIDREF="A.assembly7"Position-Independent Coding in Assembly Languagetiminghardware countersIDREF="08.realtime3"Event Timingreliable signalsIDREF="08.realtime6"Reliable and Queued Signalstokval variableIDREF="04.lex28"Using lex with yacctrailing contextIDREF="04.lex14"Some Special Featurestype, determining for filesIDREF="01.compiler38"Determining File Type with filetypeface, see fontsIDREF="09.fonts39"Initializing Fontsucode object library, buildingIDREF="03.optimize36"Building a Ucode Object Libraryucode object library, usingIDREF="03.optimize37"Using Ucode Object Librariesucode toolsIDREF="01.compiler7"OverviewugenIDREF="01.compiler9"OverviewujoinIDREF="01.compiler7"OverviewuldIDREF="01.compiler7"OverviewumergeIDREF="01.compiler7"Overviewunary minusIDREF="05.yacc39"Precedenceunput()IDREF="04.lex16"Some Special FeaturesuoptIDREF="01.compiler8"OverviewupasIDREF="01.compiler6"Overview VARARG, see optimization IDREF="03.optimize51"Generated Assembly CodeX Window System, installing font filesIDREF="09.fonts94"Installing Font and Font Metric Filesy.output fileIDREF="05.yacc33"Parser Operationy.tab.c parser fileIDREF="04.lex26"Using lex with yaccy.tab.hIDREF="05.yacc23"Lexical Analysisy.tab.h include fileIDREF="04.lex27"Using lex with yaccyaccIDREF="05.yacc56"An Advanced Example#defineIDREF="05.yacc22"Lexical Analysis%% delimiterIDREF="05.yacc8"Basic Specifications%left keywordIDREF="05.yacc38"Precedence%nonassoc keywordIDREF="05.yacc38"Precedence%prec keywordIDREF="05.yacc40"Precedence%right keywordIDREF="05.yacc38"Precedence%type keywordIDREF="05.yacc54"Support for Arbitrary Value TypesacceptIDREF="05.yacc32"Parser OperationactionsIDREF="05.yacc19"ActionsIDREF="05.yacc2"yacccommentsIDREF="05.yacc9"Basic Specificationsdisambiguating rulesIDREF="05.yacc36"Ambiguity and Conflictsend-markerIDREF="05.yacc16"Basic SpecificationsIDREF="05.yacc24"Lexical AnalysiserrorIDREF="05.yacc32"Parser Operationerror tokenIDREF="05.yacc43"Error Handlingfailure to produce parserIDREF="05.yacc5"yaccgotoIDREF="05.yacc30"Parser OperationliteralsIDREF="05.yacc11"Basic SpecificationsIDREF="05.yacc4"yaccnamesIDREF="05.yacc10"Basic Specificationsnonterminal symbolsIDREF="05.yacc3"yaccNULL characterIDREF="05.yacc12"Basic Specifications$ operatorIDREF="05.yacc18"ActionsoverviewIDREF="05.yacc6"yaccparser operationIDREF="05.yacc34"Parser Operationprecedence:and associativity rulesIDREF="05.yacc41"PrecedencereduceIDREF="05.yacc29"Parser OperationshiftIDREF="05.yacc28"Parser Operationstart symbolIDREF="05.yacc15"Basic Specificationsterminal symbolsIDREF="05.yacc3"yacctoken declarationIDREF="05.yacc14"Basic SpecificationstokensIDREF="05.yacc3"yaccuse with lexIDREF="05.yacc25"Lexical Analysisusing with lexIDREF="04.lex24"Using lex with yaccy.tab.hIDREF="05.yacc23"Lexical Analysisyyclearin statementIDREF="05.yacc45"Error Handlingyyerrok statementIDREF="05.yacc44"Error HandlingyylvalIDREF="04.lex29"Using lex with yaccIDREF="05.yacc21"Lexical Analysis| operatorIDREF="05.yacc13"Basic Specificationsyychar variableIDREF="05.yacc48"The yacc EnvironmentyyclearinIDREF="05.yacc45"Error Handlingyydebug variableIDREF="05.yacc49"The yacc Environmentyyless()IDREF="04.lex17"Some Special FeaturesIDREF="04.lex18"Some Special Featuresyylex()IDREF="04.lex25"Using lex with yaccyylvalIDREF="05.yacc31"Parser OperationIDREF="04.lex29"Using lex with yaccIDREF="05.yacc21"Lexical Analysisyymore()IDREF="04.lex17"Some Special Featuresyyparse() functionIDREF="05.yacc47"The yacc EnvironmentyytextIDREF="04.lex10"Actions