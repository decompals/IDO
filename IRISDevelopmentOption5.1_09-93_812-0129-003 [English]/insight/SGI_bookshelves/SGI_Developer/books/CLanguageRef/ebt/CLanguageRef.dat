#EDIR DATA#
C Language Reference ManualDocument Number 007-0701-060ContributorsWritten by C J SilverioEdited by Gail Larrick and Loraine McCormickProduction by Laura CooperEngineering contributions by Greg Boyd, Dave Anderson, and Dave Ciemiewicz© Copyright 1993, Silicon Graphics, Inc.name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' All Rights ReservedThis document contains proprietary and confidential information of Silicon Graphics, Inc. The contents of this document may not be disclosed to third parties, copied, or duplicated in any form, in whole or in part, without the prior written permission of Silicon Graphics, Inc.Restricted Rights LegendUse, duplication, or disclosure of the technical data contained in this document by the Government is subject to restrictions as set forth in subdivision (c) (1) (ii) of the Rights in Technical Data and Computer Software clause at DFARS 52.227-7013 and/or in similar or successor clauses in the FAR, or in the DOD or NASA FAR Supplement. Unpublished rights reserved under the Copyright Laws of the United States. Contractor/manufacturer is Silicon Graphics, Inc., 2011 N. Shoreline Blvd., Mountain View, CA 94039-7311.C Language Reference ManualDocument Number 007-0701-060Silicon Graphics, Inc.Mountain View, CaliforniaSilicon Graphics and IRIS are registered trademarks and IRIX and IRIS-4D are trademarks of Silicon Graphics, Inc. UNIX is a registered trademark of UNIX System Laboratories.LBL="1"IntroductionThis document contains a summary of the syntax and semantics of the C programming language as implemented on the IRIS-4DÔ Series workstations.  It documents previous releases of Silicon Graphics'® C compilers as well as the ANSI C compiler.This document uses the term "traditional C" to refer to previous versions of Silicon Graphics' C and to the dialect of C described in the first edition of The C Programming Language, by Kernighan and Ritchie.This manual also includes information formerly included in the ANSI C Transition Guide.  That material is now in the following chapters:IDREF="47127" TYPE="TITLE"Chapter 2, "An Overview of ANSI C," discusses some effective strategies in porting your traditional C code to ANSI C.IDREF="90984" TYPE="TITLE"Chapter 3, "C Language Changes," gives an overview of changes that the ANSI standard introduced to the language.Chapters 4 through 10 of this manual give the syntax and semantics rules of C, with ANSI C differences called out.  IDREF="48935" TYPE="TITLE"Chapter 4, "Lexical Conventions," lists and defines the six classes of C tokens.IDREF="20204" TYPE="TITLE"Chapter 5, "Meaning of Identifiers," discusses objects, lvalues, identifiers, and disambiguation.IDREF="61724" TYPE="TITLE"Chapter 6, "Operator Conversions," discusses object type conversions and result types.IDREF="74335" TYPE="TITLE"Chapter 7, "Expressions and Operators," defines the various types of expressions and operators and gives their order of precedence. IDREF="87922" TYPE="TITLE"Chapter 8, "Declarations," discusses type specifiers, structures, unions, declarators of various kinds, and initialization.IDREF="70950" TYPE="TITLE"Chapter 9, "Statements," describes expression, compound, selection, iteration, and jump statements.IDREF="42146" TYPE="TITLE"Chapter 10, "External Definitions," gives the syntax for external definitions.IDREF="41509" TYPE="TITLE"Appendix A, "Implementation-defined Behavior," describes various implementation-specific aspects of Silicon Graphics' C compiler, keyed to paragraphs from the ANSI standard.LBL="1.1" HELPID=""Notational ConventionsThis manual uses a few typographical and notational conventions, which are explained below.The expression [fF] stands for "f or F".  Filenames are italicized, as in the example:  <stddef.h> is the file /usr/include/stddef.h.  Syntactic categories are indicated by italic type and literal words and characters by bold type.  Alternative categories are listed on separate lines.  An optional entry is indicated by the subscript "opt" so that { expressionopt   }indicates an optional expression enclosed in braces. This notation is the standard BNF notation.LBL="1.2" HELPID=""Corequisite PublicationsThe ANSI C language specification  is available from the American National Standards Institute (ANSI) at 1430 Broadway, NY, NY 10018, (212) 642-4900.  Specify ANSI X3.159-1989.  The cost at this writing is $50 plus $6 handling.  This manual is not intended as a substitute for a copy of the specification.  LBL="2"ID="47127"An Overview of ANSI CThis chapter contains the following sections:IDREF="58298" TYPE="TITLE""What Is ANSI C?" briefly discusses the scope of the new standard.IDREF="68958" TYPE="TITLE""Helpful Programming Hints" lists some programming practices to avoid and some to take to heart.IDREF="37032" TYPE="TITLE""Areas of Major Change" lists the major changes to C made by the ANSI standard.LBL="2.1" HELPID=""ID="58298"What Is ANSI C?The ANSI standard on the programming language C is designed to promote the portability of C programs among a variety of data-processing systems.  To accomplish this, the standard covers three major areas:  the environment in which the program compiles and executes, the semantics and syntax of the language, and the content and semantics of a set of library routines and header files.  Strictly conforming programs are programs that: ID="chap.021"use only those features of the language defined in the standarddo not produce output dependent on any ill-defined behaviordo not exceed any minimum limit.Ill-defined behavior includes   implementation-defined, undefined, and unspecified behavior.  The term refers to areas that the standard does not specify. This ANSI C environment is designed to be, in the words of the standard, a conforming hosted implementation, which is guaranteed to accept any strictly conforming program.  Extensions are allowed, so long as the behavior of strictly conforming programs is not altered.Besides knowing which features of the language and library you may rely on when writing portable programs, you must be able to avoid naming conflicts with support routines used for the implementation of the library.  To avoid such naming conflicts, ANSI divides the space of available names into a set reserved for the user and a set reserved for the implementation.  Any name that does not begin with an underscore and is neither a keyword in the language nor reserved for the ANSI library, is in the user's namespace.  (This rule is given for simplicity.  The space of names reserved for the user is actually somewhat larger than this.)  ID="chap.022"ID="chap.023"Strictly conforming programs may not define any names unless they are in the user's namespace.  New keywords as well as those names reserved for the ANSI library are discussed in IDREF="22110" TYPE="TITLE"Section 3.6, "Standard Headers."
   LBL="2.1.1" HELPID=""ID="95059"Compiling ANSI ProgramsTo provide the portable clean environment dictated by ANSI while retaining the many extensions available to Silicon Graphics users, two modes of compilation are provided for ANSI programs.  Each of these modes invokes the ANSI compiler and is selected by a switch to cc(1): ID="chap.024"ID="chap.025"­ansienforces a pure ANSI environment, eliminating Silicon Graphics extensions.  The ANSI symbol indicating a pure environment (__STDC__) is defined to be 1 for the preprocessor.  Use this mode when compiling strictly conforming programs, as it guarantees purity of the ANSI namespace.    ID="chap.026"ID="chap.027"­xansiadds Silicon Graphics extensions to the environment.  This mode is the default.  The ANSI preprocessor symbol (__STDC__) is defined to be 1. The symbol to include extensions from standard headers (__EXTENSIONS__) is also defined, as is the symbol to inline certain library routines that are directly supported by the hardware  (__INLINE_INTRINSICS.)ID="chap.028"ID="chap.029"ID="chap.0210"Here are some key facts to keep in mind when you use ANSI C: Use only   lc and/or ­lm to specify the C and/or math libraries.  These switches ensure the incorporation of the ANSI version of these libraries.     ID="chap.0211"ID="chap.0212"ID="chap.0213"The default compilation mode is shared and the libraries are shared.     ID="chap.0214"ID="chap.0215"ID="chap.0216"Use the switch ­fullwarn to receive additional diagnostic warnings that are suppressed by default. Use the switch ­wlint to get lint-like warnings about the compiled source. This option provides lint-like warnings for ANSI and   ­cckr   modes and can be used together with the other ID="chap.0217"cc(1) options and switches. ID="chap.0218"If you want to compile code using traditional C (that is, non-ANSI), use the switch ­cckr.  The dialect of C invoked by ­cckr is referred to interchangeably as ­cckr, "the previous version of Silicon Graphics C," and "traditional C" in the remainder of this document.ID="chap.0219"ID="chap.0220"ID="chap.0221"ID="chap.0222"You can find complete information concerning ANSI and non-ANSI compilation modes in the on-line manual page for cc(1).  LBL="2.2" HELPID=""ID="68958"Helpful Programming HintsAlthough the ANSI Standard has added only a few new features to the C language, it has tightened the semantics of many areas.  In some cases, constructs were removed that had fallen into disuse, were ambiguous, or were obvious hacks.  The next two sections give two lists of programming practices.  The first section recommends practices that you can use to ease your transition into this new environment.  The second lists common C coding practices that will cause problems when you use ANSI C.     ID="chap.0223"ID="chap.0224"LBL="2.2.1" HELPID=""Recommended PracticesFollow these recommendations as you code:Always use the appropriate header when declaring standard external functions.  Avoid embedding the declaration in your code.      ID="chap.0225"ID="chap.0226"ID="chap.0227"Always use function prototypes, and write your function prologues in function prototype form. Use the offsetof() macro to derive structure member offsets.  (The offsetof() macro is in <stddef.h>.)  ID="chap.0228"Always use casts when converting.  Be strict with your use of qualified objects such as with volatile   and   const.    Assign the addresses of these objects only to pointers that are so qualified.  Return a value from all return points of all non-void   functions.  Use only structure designators of the appropriate type as the structure designator in .   and   -> expressions (that is, ensure that the right hand side is a member of the structure on the left hand side).  Always specify the types of integer bitfields as signed   or   unsigned.  LBL="2.2.2" HELPID=""Practices to AvoidAvoid these dangerous practices:Never rely on the order in which arguments are evaluated.  For example, what is the result of the code fragment foo(a++,a,name='hellip' font=symbol charset=fontspecific code=188)?ID="chap.0229"ID="chap.0230"ID="chap.0231"Avoid using expressions with side effects as arguments to a function.    ID="chap.0232"Avoid declaring functions in a local context, especially if they have prototypes.  Never access parameters that are not specified in the argument list unless using the stdarg facilities.  Use the stdarg facilities only on a function with an unbounded argument list (that is, an argument list terminated with name='hellip' font=symbol charset=fontspecific code=188).  ID="chap.0233"Don't play hack tricks with preprocessor tokens (for example, FOO/**/BAR).  ID="chap.0234"Never modify a string literal.  ID="chap.0235"Don't rely on search rules to locate include files specified with quotes.  LBL="2.3" HELPID=""ID="37032"Areas of Major ChangeThe following are areas of major change:Some preprocessor   changes are noteworthy.  The changes are in practices that, although questionable, are not uncommon.  

   
Rules for disambiguating   names have been more clearly defined.  Most of these changes allow greater freedom to use the same name in different contexts.     ID="chap.0236"ID="chap.0237"Types have undergone some significant changes in the areas of promotions and more strictly enforced compatibility rules.  In addition, the compiler is stricter about mixing qualified and unqualified types and their pointers.            ID="chap.0238"ID="chap.0239"ID="chap.0240"ID="chap.0241"ID="chap.0242"Function prototypes are more completely observed.  Many warnings concerning prototypes in traditional C are now errors under ANSI.   ID="chap.0243"ID="chap.0244"A few external names have been changed for conformance.  LBL="3"ID="90984"C Language ChangesThis chapter contains the following sections:IDREF="16672" TYPE="TITLE""Preprocessor Changes" discusses two changes in the way the preprocessor handles string literals and tokens.IDREF="36460" TYPE="TITLE""Changes in Disambiguating Identifiers" discusses the four characteristics ANSI C uses to distinguish identifiers.IDREF="30681" TYPE="TITLE""Types and Type Compatibility" describes ANSI C changes to type promotions and type compatibility.IDREF="93558" TYPE="TITLE""Function Prototypes" describes how ANSI C handles function prototyping.IDREF="26015" TYPE="TITLE""External Name Changes" discusses the changes in function, linker-defined, and data area names.IDREF="22110" TYPE="TITLE""Standard Headers" lists standard header files.LBL="3.1" HELPID=""ID="16672"Preprocessor ChangesWhen compiling in an ANSI C mode (which is the default unless you specify ­cckr), ANSI-standard C preprocessing is used. The preprocessor is built into the C front end (cfe) and is functionally unchanged from the version appearing on IRIXÔ Release 3.10. The 3.10 version of the compiler had no built-in preprocessor and used two standalone preprocessors for ID="chap.031"ID="chap.032"ID="chap.033"­cckr (cpp(1)) and ANSI C (acpp(5)) preprocessing respectively. You can activate acpp instead of the built-in preprocessorby using the ­oldcpp option in ANSI C mode or the ­acpp option in any mode.You can activate cpp instead of the built-in preprocessor by using the ­oldcpp option in ­cckr mode. acpp is a public domain preprocessor and its source is included in /usr/src/gnu/acpp. We recommend that you always use the built-in preprocessor, rather than cpp and acpp, since these standalone preprocessors may not be supported in future releases of the compilers.Traditionally, the C preprocessor has performed two functions that are now illegal under ANSI C.  These functions are the substitution of macro arguments within string literals and the concatenation of tokens after removing a null comment sequence.LBL="3.1.1" HELPID=""Replacement of Macro Arguments in StringsSuppose you define two macros IN and PLANT as #define IN(x) `x'
#define PLANT(y) "placing y in a string"
ID="chap.034"ID="chap.035"ID="chap.036"and later invoke them as IN(hi)
PLANT(foo) Compiling with ­cckr makes these substitutions:   ID="chap.037"ID="chap.038"`hi'
"placing foo in a string"However, since ANSI C considers a string literal to be an atomic unit, the expected substitution will not occur.  Recognizing that this facility is desirable, ANSI C adopted an explicit preprocessor sequence to accomplish it.In ANSI C, adjacent string literals are concatenated.  Thus      ID="chap.039"ID="chap.0310"ID="chap.0311""abc" "def"becomes "abcdef"A mechanism for quoting a macro argument was adopted that relies on this.  When a macro definition contains one of its formal arguments preceded by a single #, the substituted argument value is quoted in the output.  The simplest example of this is #define STRING_LITERAL(a)   # a that, when invoked asSTRING_LITERAL(foo) yields "foo"In conjunction with the rule of concatenation of adjacent string literals, the following macros can be defined: #define ARE(a,c) # a " are " # c Then ARE(trucks,big) yields "trucks" " are " "big" or "trucks are big" when concatenated.  Blanks prepended and appended to the argument value are removed.  If the value has more than one word, each pair of words in the result will be separated by a single blank.  Thus, the macro ARE above could be invoked as ARE( fat   cows,big ) ARE(fat cows, big) each of which yields (after concatenation) "fat cows are big"Be sure to avoid enclosing your macro arguments in quotes, since these quotes will be placed in the output string.  For example,ARE ("fat cows", "big")becomes"\"fat cows\" are \"big\""No obvious facility exists to enclose macro arguments with single quotes.LBL="3.1.2" HELPID=""Token Concatenation   When compiling ­cckr, the value of macro arguments can be concatenated by ID="chap.0312"#define glue(a,b)  a/**/b glue(FOO,BAR) which yields FOOBAR.    ID="chap.0313"ID="chap.0314"This concatenation does not occur under ANSI C, since null comments are replaced by a blank.  However, similar behavior can be obtained by using the ## operator in ­ansi and ­xansi mode.    ## instructs the precompiler to concatenate the value of a macro argument with the adjacent token.  Thus    ID="chap.0315"ID="chap.0316"#define glue_left(a) GLUED ## a 
#define glue_right(a) a ## GLUED 
#define glue(a,b) a ## b 
glue_left(LEFT) 
glue_right(RIGHT) 
glue(LEFT,RIGHT) yields GLUEDLEFT
RIGHTGLUED
LEFTRIGHT Furthermore, the resulting token is a candidate for further replacement.  Note what happens in this example:#define HELLO "hello"
#define glue(a,b) a ## b 
glue(HEL,LO) which yields "hello"LBL="3.2" HELPID=""ID="36460"Changes in Disambiguating Identifiers    Under ANSI C, an identifier has four disambiguating characteristics: its ID="chap.0317"ID="chap.0318"scope, linkage, name   space, and   storage   duration.    Each of these characteristics was used in traditional C, either implicitly or explicitly.  Except in the case of storage duration, which is either static or automatic, the definitions of these characteristics chosen by the standard differ in certain ways from those you might be accustomed to, as detailed below.  For a discussion of the same material with a different focus, see IDREF="39439" TYPE="TITLE"Section 5.1, "Disambiguating Names."LBL="3.2.1" HELPID=""ID="45081"Scoping DifferencesANSI C recognizes four scopes of identifiers: the familiar file and block scopes and the new function and function prototype scopes.   ID="chap.0319"ID="chap.0320"Function scope includes only labels.  As in traditional C, labels are valid until the end of the current function. Block scope rules differ from traditional C in one significant instance: the outermost block of a function and the block that contains the function arguments are the same under ANSI C.  Thus in the exampleint f(x)
int x;
{
     int x;
     x = 1; 
} ANSI C complains of a redeclaration of x, whereas traditional C would quietly hide the argument   x with the   local variable x, as they were in distinct scopes. Function prototype scope is a new scope in ANSI C.  If an identifier appears within the list of parameter declarations in a function prototype that is not part of a function definition, it has function prototype scope, which terminates at the end of the prototype.  This allows any dummy parameter names appearing in a function prototype to disappear at the end of the prototype.  In the exampleID="chap.0321"ID="chap.0322"char * getenv (const char * name);int name;the int variable name does not conflict with the parameter name since the parameter went out-of-scope at the end of the prototype.  (Note that the prototype is still in scope.)Identifiers appearing outside of any block, function, or function prototype have file scope. One last discrepancy in scoping rules between ANSI and traditional C concerns the scope of the function foo() in the example below: ID="chap.0323"float f;
func0() {
     extern float foo() ;
     f = foo() ;
}
func1() {
     f = foo() ;
} In traditional C, the function foo() would be of type float when it is invoked in the function   func1(), since the declaration for   foo() had file scope, even though it occurred within a function.  ANSI C dictates that the declaration for foo() has block scope.  Thus, there is no declaration for   foo() in scope in   func1(), and it is implicitly typed int.  This difference in typing between the explicitly and implicitly declared versions of foo() will result in a redeclaration error at compile time, since they both are linked to the same external definition for foo() and the difference in typing could otherwise produce unexpected behavior.ID="chap.0324"LBL="3.2.2" HELPID=""Name Space ChangesANSI C recognizes four distinct name spaces: one for ID="chap.0325"tags, one for labels, one for members of a particular struct or union, and one for everything else.  This division creates two discrepancies with traditional C:In ANSI C, each struct or union has its own name space for its members.  This is a pointed departure from traditional C, in which these members were nothing more than offsets, allowing you to use a member with a structure to which it does not belong.  This usage is illegal in ANSI C.    ID="chap.0326"ID="chap.0327"Enumeration constants were special identifiers in versions of Silicon Graphics C prior to IRIX Release 3.3.  In ANSI C, these constants are simply integer constants that can be used anywhere they are appropriate.  Similarly, in ANSI C, other integer variables can be assigned to a variable of an enumeration type with no error.    ID="chap.0328"ID="chap.0329"LBL="3.2.3" HELPID=""ID="40124"Changes in the Linkage of IdentifiersAn identifier's linkage determines which of the references to that identifier refer to the same object.  This terminology formalizes the familiar concept of variables declared extern and variables declared static and is a necessary augmentation to the concept of scope. ID="chap.0330"extern int mytime;
static int yourtime; In the example above, both mytime and yourtime have   file scope.  However, mytime has external linkage, while yourtime has   internal linkage.  An object can also have no linkage, as is the case of automatic variables. The above example illustrates another implicit difference between the declarations of mytime and yourtime.  The declaration of   yourtime allocates storage for the object, whereas the declaration of mytime merely references it.  If mytime had been initialized, as in: int mytime=0; it would also have allocated storage.  In ANSI C terminology, a declaration that allocates storage is referred to as a definition.  Here is where the change occurs.In traditional C, neither of the declarationsextern int bert;
int bert; was a definition.  In effect, the second declaration included an implicit extern specification.  This is not true in ANSI C.  Objects with external linkage that are not specified as extern at the end of the compilation unit are considered definitions, and, in effect, initialized to zero.  (If multiple declarations of the object are in the compilation unit, only one need have the extern specification.) ID="chap.0331"The effect of this change is to produce "multiple definition" messages from the linker when two modules contain definitions of the same identifier, even though neither is explicitly initialized. This is often referred to as the strict ref/def model. A more relaxed model can be achieved by using the compiler flag ­common.The ANSI C linker issues a warning when it finds redundant definitions, indicating the modules that produced the conflict.  However, the linker cannot determine whether the definition of the object is explicit.  The result might be incorrectly initialized objects, if a definition was given with an explicit initialization, and this definition is not the linker's random choice.Thus, in the following example: module1.c:     int ernie;
module2.c:
     int ernie=5; ANSI C implicitly initializes ernie in module1.c to zero.  To the linker, ernie is initialized in two different modules.  The linker will warn you of this situation, and choose the first such module it encountered as the true definition of ernie.  This module might or might not contain the explicitly initialized copy.LBL="3.3" HELPID=""ID="30681"Types and Type CompatibilityHistorically, C has allowed free intermixing of arithmetic types in expressions and as arguments to functions.  (Arithmetic types include integral and floating point types.  Pointer types are not included.)  C's type promotion rules reduced the number of actual types used in arithmetic expressions and as arguments to three: int, unsigned, and double.  This scheme allowed free intermixing of types, but in some cases forced unnecessary conversions and complexity in the generated code.           ID="chap.0332"ID="chap.0333"ID="chap.0334"ID="chap.0335"One ubiquitous example of unnecessary conversions can be observed when float variables were used as arguments to a function.  C's type promotion rules often caused two unwanted expensive conversions across a function boundary.ANSI C has altered these rules somewhat to avoid the unnecessary overhead in many C implementations.  This alteration, however, might produce differences in arithmetic and pointer expressions and in argument passing.  For a complete discussion of operator conversions and type promotions, see IDREF="61724" TYPE="TITLE"Chapter 6, "Operator Conversions."LBL="3.3.1" HELPID=""Type Promotion in Arithmetic ExpressionsTwo differences are noteworthy between ANSI and traditional C.  First, ANSI C relaxes the restriction that all floating point calculations must be performed in double precision.  In the example   ID="chap.0336"ID="chap.0337"extern float f,f0,f1; 
addf() {
     f = f0 + f1;
} pre-ANSI C compilers are required to convert each operand to double, perform the operation in double precision, and truncate the result to float.  These steps are not required in ANSI C.  In ANSI C, the operation can be done entirely in single-precision.  (In traditional C, these operations were performed in single-precision if the ­float compiler option was selected.)    ID="chap.0338"ID="chap.0339"ID="chap.0340"The second change in arithmetic expression evaluation involves integral promotions.  ANSI C dictates that any integral promotions be value-preserving.  Traditional C used unsignedness-preserving promotions.  In the example    ID="chap.0341"ID="chap.0342"unsigned short us=1,them=2;
int i;
test() {
     i = us - them;
} ANSI C's value-preserving rules cause each of us and them to be promoted to int, which is the expression type.  In traditional C, the unsignedness-preserving rules cause each of us and them to be promoted to unsigned, which is the expression type.  The latter case yields a large unsigned number, whereas ANSI C yields -1.  The discrepancy in this case is inconsequential, as the same bit pattern is stored in the integer   i in both cases, and it is later interpreted as -1.  However, if the case is altered slightly as inunsigned short us=1,them=2;
float f;
test() {
     f = us - them;
} the result assigned to f is quite different under the two schemes.  If you use the ­wlint option, you'll be warned about the implicit conversions from int or unsigned to float.For more information on arithmetic conversions, see IDREF="26274" TYPE="TITLE"Section 6.6, "Arithmetic Conversions."LBL="3.3.2" HELPID=""ID="55446"Type Promotion and Floating Point ConstantsThe differences in behavior of ANSI C floating point constants and traditional C floating point constants can cause numerical and performance differences in code ported from the traditional C to the ANSI C compiler.ID="chap.0343"For example, consider the result type of the computation below:#define PI 3.1415926
float a,b;

b = a * PI;The result type of b depends on which compilation options you use. IDREF="54517" TYPE="TABLE"Table 3-1
 lists the effects of various options.COLUMNS="3"LEFT="0" WIDTH="113"Compilation OptionLEFT="120" WIDTH="113"PI Constant TypeLEFT="240" WIDTH="356"Promotion BehaviorLEFT="0" WIDTH="113"-cckrLEFT="120" WIDTH="113"doubleLEFT="240" WIDTH="356"(float)((double)a * PI)LEFT="0" WIDTH="113"-cckr -floatLEFT="120" WIDTH="113"floatLEFT="240" WIDTH="356"a * PILEFT="0" WIDTH="113"-xansiLEFT="120" WIDTH="113"doubleLEFT="240" WIDTH="356"(float)((double)a * PI)LEFT="0" WIDTH="113"-ansiLEFT="120" WIDTH="113"doubleLEFT="240" WIDTH="356"(float)((double)a * PI)LBL="3-1"Table 3-1 ID="54517"The Effect of Compilation Options on Floating Point ConversionsEach conversion incurs computational overhead.The ­float flag will have no effect if you also specify ­ansi or ­xansi. To prevent the promotion of floating constants to doublename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'and thus promoting the computation to double precision multipliesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'you must specify the constant as a single precision floating point constant.  To continue the example, you would use:#define PI 3.1415926f    /* single precision float */Traditional C (compiled with the -cckr option) won't recognize the f float qualifier, however. You might want to write the constant definition like this:#ifdef __STDC__
#define PI 3.1415926f
#else
#define PI 3.1415926
#endifIf you compile with the ­ansi or ­xansi options, __STDC__ is automatically defined as though ­D__STDC__ = 1 were used on your compilation line.If you compile with the ansi, ­ansiposix or ­xansi options, __STDC__ is automatically defined, as though -D__STDC__=1 were used on your compilation line. Thus, with the last form of constant definition noted above, the calculation in the example is promoted as described inIDREF="36444" TYPE="TABLE"Table 3-2COLUMNS="3"LEFT="0" WIDTH="113"Compilation OptionLEFT="120" WIDTH="113"PI Constant TypeLEFT="240" WIDTH="356"Promotion BehaviorLEFT="0" WIDTH="113"-cckrLEFT="120" WIDTH="113"doubleLEFT="240" WIDTH="356"(float)((double)a * PI)LEFT="0" WIDTH="113"-cckr -floatLEFT="120" WIDTH="113"floatLEFT="240" WIDTH="356"a * PILEFT="0" WIDTH="113"-xansiLEFT="120" WIDTH="113"floatLEFT="240" WIDTH="356"a * PILEFT="0" WIDTH="113"-ansiLEFT="120" WIDTH="113"floatLEFT="240" WIDTH="356"a * PILBL="3-2"Table 3-2 ID="36444"Using __STDC__ to Affect Floating Point ConversionsLBL="3.3.3" HELPID=""Compatible TypesTo determine whether an implicit conversion is permissible, ANSI C has introduced the concept of compatible types.  After promotion, using the appropriate set of promotion rules, two non-pointer types are compatible if they have the same size, signedness, integer/float characteristic, or, in the case of aggregates, are of the same structure or union type. Except as discussed in the previous section, no surprises should result from these changes.  You should not encounter unexpected problems unless you are using pointers.   ID="chap.0344"ID="chap.0345"Pointers are compatible if they point to compatible types.  No default promotion rules apply to pointers.  Under traditional C, the following code fragment compiled silently: int *iptr; 
unsigned int *uiptr; 
foo() {
     iptr = uiptr; 
} Under ANSI C, the pointers iptr and uiptr do not point to compatible types (as they differ in unsignedness), which means that the assignment is illegal.  Insert the appropriate cast to alleviate the problem.  When the underlying pointer type is irrelevant or variable, use the wildcard type void *.  LBL="3.3.4" HELPID=""Argument Type PromotionsANSI C rules for the promotion of arithmetic types when passing arguments to a function depend on whether or not a prototype is in scope for the function at the point of the call.  If a prototype is not in scope, the arguments are converted using the default argument promotion rules:  short and char types (whether signed or unsigned) are passed as ints, other integral quantities are not changed, and floating point quantities are passed as doubles.  These rules are also used for arguments in the variable-argument portion of a function whose prototype ends in ellipses (name='hellip' font=symbol charset=fontspecific code=188).           ID="chap.0346"ID="chap.0347"ID="chap.0348"ID="chap.0349"If a prototype is in scope, an attempt is made to convert each argument to the type indicated in the prototype prior to the call.  The types of conversions that will succeed are similar to those that will succeed in expressions.  Thus, an int   will be promoted to a float if the prototype so indicates, but a pointer to unsigned will not be converted to a pointer to int.  ANSI C also allows the implementation greater freedom when passing integral arguments if a prototype is in scope.  If it makes sense for an implementation to pass short arguments as 16-bit quantities, it can do so.Use of prototypes when calling functions allows greater ease in coding.  However, due to the differences in argument promotion rules, serious discrepancies could occur if a function is called both with and without a prototype in scope.  You should ensure that you use prototypes consistently and that any prototype is declared to be in scope for all uses of the function identifier. LBL="3.3.5" HELPID=""Mixed Use of FunctionsTo reduce the chances of problems occurring when calling functions, it is wise to limit the types of arithmetic arguments used in the argument declarations.  In particular, avoid using short or char types for arguments; their use rarely improves performance and might raise portability issues if you move your code to a machine with a smaller word size, since function calls made with and without a prototype in scope might promote the arguments differently.  In addition, be circumspect when typing a function argument float, as you will encounter difficulties if the function is called without a prototype in scope.  Keeping these issues in mind will allow you to solve quickly the few problems that can arise.    ID="chap.0350"LBL="3.4" HELPID=""ID="93558"Function PrototypesFunction prototypes are not new to Silicon Graphics C.  In traditional C, however, the implementation of prototypes was incomplete.  In one case, as seen below, there is still a significant difference between the ANSI C and the traditional C implementations of prototypes.     ID="chap.0351"ID="chap.0352"You can prototype functions in two ways.  The most common method is to simply create a copy of the function declaration with the arguments typed, with or without identifiers for each, such as: int func(int, float, unsigned [2]);
 or 
int func(int i, float f, unsigned u[2]); A function can also be prototyped by writing the function definition in prototype form, as:   int func(int i, float f, unsigned u[2])
{
     < code for func >
} In each case, a prototype is created for func() that remains in scope for the rest of the compilation unit.One area of confusion about function prototypes is that you must write functions that have prototypes in prototype form.  Unless you do this, when you use ANSI C, the default argument promotion rules apply.  Traditional C will silently honor the prototype when the function definition is encountered even if it is not written in prototype form.  This is not allowed in ANSI C.As an example, the function func() below is not written in prototype form.int func (float);
int func (f)
float f;
{ name='hellip' font=symbol charset=fontspecific code=188 }When you use ANSI C, the parameter f in func() will be assumed to be type double, because the default argument promotions apply, thus eliciting error diagnostics about the two incompatible declarations for func().  When you use traditional C, the prototype for func() (which appears just prior to the function) is honored, giving f type float.  The following three situations will produce diagnostics from the ANSI C compiler when you use function prototypes:A prototyped function is called with one or more arguments of incompatible type.  (Incompatible types are discussed in Section 3.3.)       ID="chap.0353"ID="chap.0354"ID="chap.0355"Two inconsistent prototypes for the same function are encountered.  This version of the compiler scrutinizes duplicate prototypes carefully and catches inconsistencies.    ID="chap.0356"ID="chap.0357"A function that has a prototype is not written in prototype form.  If a function is prototyped, its definition must be written in prototype form.  The compiler will indicate an error if it is not. When you use ­cckr you do not get warnings about prototyped functions unless you specify ­prototypes.LBL="3.5" HELPID=""ID="26015"External Name ChangesMany well-known UNIX® external names that are not covered by the ANSI C standard are in the user's name space.  These names fall into three categories: ID="chap.0358"ID="chap.0359"names of functions in the C librarynames defined by the linkernames of data areas with external linkage LBL="3.5.1" HELPID=""Changes in Function NamesNames of functions that are in the user's name space and that are referenced by ANSI C functions in the C library have simply been aliased to counterpart functions whose names are reserved.  In all cases, the new name is formed simply by prefixing an underbar to the old name.  Thus, although it was necessary to change the name of the familiar UNIX C library function write to _write, the function write remains in the library as an alias.Notice that this might change the behavior of your program if you have written your own versions of C library functions.  If, for example, you have your own version of write, the C library will continue to use its version of _write. LBL="3.5.2" HELPID=""Changes in Linker-defined NamesThe linker is responsible for defining the standard UNIX symbols end, etext, and edata, if these symbols are unresolved in the final phases of linking.  (See end(3c) for more information.)  The ANSI C linker has been modified to satisfy references for _etext, _edata, and _end as well.  The ANSI C library reference to end has been altered to _end.    ID="chap.0360"ID="chap.0361"This mechanism preserves the ANSI C name space, while providing for the definition of the non-ANSI C forms of these names if they are referenced from existing code.  LBL="3.5.3" HELPID=""Data Area Name ChangesThe names of several well-known data objects used in the ANSI C portion of the C library were in the user's name space.  These objects are listed in Table 3.1.  These names were moved into the reserved name space by prefixing their old names with an underscore.  Whether these names will be defined in your environment depends on the compilation mode you are using.  Recall that ­xansi is the default.    ID="chap.0362"ID="chap.0363"IDREF="87505" TYPE="TABLE"Table 3-3 indicates whether these well-known external names are visible when you compile your code in the various modes.  The left column contains three sets of names.  Determine which version of these names are visible by examining the corresponding column under your compilation mode.  In IDREF="87505" TYPE="TABLE"Table 3-3"aliased" means the two names access the same object.  "unchanged" means the well-known version of the name is unaltered.  "identical copies" means that two copies of the object existname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'one with the well-known name and one with the ANSI C name (prefixed with an underbar).  Applications should not alter these objects.  "#define" means that a macro is provided in the indicated header to translate the well-known name to the ANSI C counterpart.  Only the ANSI C name exists.  You should include the indicated header if your code refers to the well-known name.  For example, the name tzname is unchanged when compiling -cckr, is converted to the reserved ANSI C name (_tzname) by a macro if you include   <time.h> when compiling -xansi, and is available only as the ANSI C version (_tzname) if compiling -ansi.  (Recall that -xansi is the default.)            ID="chap.0364"ID="chap.0365"ID="chap.0366"ID="chap.0367"ID="chap.0368"ID="chap.0369"COLUMNS="4"LEFT="0" WIDTH="85"nameLEFT="90" WIDTH="85"LEFT="180" WIDTH="85"compilation modeLEFT="270" WIDTH="356"LEFT="0" WIDTH="85"LEFT="90" WIDTH="85"-cckrLEFT="180" WIDTH="85"-xansiLEFT="270" WIDTH="356"-ansiLEFT="0" WIDTH="85"environLEFT="90" WIDTH="85"environ and 
_environ aliasedLEFT="180" WIDTH="85"environ and 
_environ aliasedLEFT="270" WIDTH="356"only _environ 
visibleLEFT="0" WIDTH="85"timezone, tzname, 
altzone, daylightLEFT="90" WIDTH="85"unchangedLEFT="180" WIDTH="85"#define to ANSI C 
name if using 
<LEFT="270" WIDTH="356"_timezone, 
_tzname, _altzone, 
_daylightLEFT="0" WIDTH="85"sys_nerr, sys_errlistLEFT="90" WIDTH="85"unchangedLEFT="180" WIDTH="85"identical copies 
with names 
_sys_nerr, 
_sys_errlistLEFT="270" WIDTH="356"identical copies 
with names 
_sys_nerr, 
_sys_errlistLBL="3-3"Table 3-3 ID="87505"The Effect of Compilation Mode on NamesLBL="3.6" HELPID=""ID="22110"Standard HeadersID="chap.0370"ID="chap.0371"Functions in the ANSI C library are declared in a set of standard headers and are a subset of the C and math library included in the beta release.  This subset is self-consistent and is free of name space pollution, when compiling in the pure ANSI mode.  Names that are normally elements of the user's name space but are specifically reserved by ANSI are described in the corresponding standard header.  The reader is referred to these headers for information on both reserved names and ANSI library function prototypes.  The set of standard headers is enumerated in IDREF="25328" TYPE="TABLE"Table 3-4
.    ID="chap.0372"ID="chap.0373"ID="chap.0374"COLUMNS="5"LEFT="0" WIDTH="68"Header FilesLEFT="75" WIDTH="68"LEFT="150" WIDTH="68"LEFT="225" WIDTH="68"LEFT="300" WIDTH="356"LEFT="0" WIDTH="68"<assert.h>LEFT="75" WIDTH="68"<ctype.h>LEFT="150" WIDTH="68"<errno.h>LEFT="225" WIDTH="68"<sys/errno.h>LEFT="300" WIDTH="356"<float.h>LEFT="0" WIDTH="68"<limits.h>LEFT="75" WIDTH="68"<locale.h>LEFT="150" WIDTH="68"<math.h>LEFT="225" WIDTH="68"<setjmp.h>LEFT="300" WIDTH="356"<signal.h>LEFT="0" WIDTH="68"<sys/signal.h>LEFT="75" WIDTH="68"<stdarg.h>LEFT="150" WIDTH="68"<stddef.h>LEFT="225" WIDTH="68"<stdio.h>LEFT="300" WIDTH="356"LEFT="0" WIDTH="68"<stdlib.h>LEFT="75" WIDTH="68"<string.h>LEFT="150" WIDTH="68"<time.h> LEFT="225" WIDTH="68"LEFT="300" WIDTH="356"LBL="3-4"Table 3-4 ID="25328"ANSI C Standard Header FilesLBL="4"ID="48935"Lexical ConventionsThe six classes of tokens are: identifiers ID="chap.041"keywords ID="chap.042"constants ID="chap.043"string literals ID="chap.044"operators ID="chap.045"punctuators  ID="chap.046"Blanks, tabs, new-lines, and comments (described in the next section) are collectively known as "white space." White space is ignored except as it serves to separate tokens.  Some white space is required to separate otherwise adjacent identifiers, keywords, and constants.    ID="chap.047"ID="chap.048"If the input stream has been parsed into tokens up to a given character, the next token is taken to include the longest string of characters that could possibly constitute a token.LBL="4.1" HELPID=""CommentsThe charactersID="chap.049"   /* introduce a comment that terminates with the characters */.  They do not indicate a comment when occurring within a string literal.  Comments do not nest.  Once the /*   introducing a comment is seen, all other characters are ignored until the matching   */   is encountered.  LBL="4.2" HELPID=""IdentifiersAn identifier, or name, is a sequence of letters, digits, and underscores ( _ ).  The first character cannot be a digit.  Uppercase and lowercase letters are distinct.  Name length is unlimited.  The terms identifier and name are used interchangeably.      ID="chap.0410"ID="chap.0411"ID="chap.0412"LBL="4.3" HELPID=""KeywordsThe identifiers listed in ID="chap.0413"ID="chap.0414"IDREF="93967" TYPE="TABLE"Table 4-1
 are reserved for use as keywords and cannot be used otherwise. COLUMNS="6"LEFT="0" WIDTH="56"KeywordsLEFT="65" WIDTH="56"LEFT="130" WIDTH="56"LEFT="195" WIDTH="56"LEFT="260" WIDTH="56"LEFT="325" WIDTH="356"LEFT="0" WIDTH="56"autoLEFT="65" WIDTH="56"continueLEFT="130" WIDTH="56"externLEFT="195" WIDTH="56"longLEFT="260" WIDTH="56"staticLEFT="325" WIDTH="356"voidLEFT="0" WIDTH="56"breakLEFT="65" WIDTH="56"defaultLEFT="130" WIDTH="56"floatLEFT="195" WIDTH="56"registerLEFT="260" WIDTH="56"structLEFT="325" WIDTH="356"volatileLEFT="0" WIDTH="56"caseLEFT="65" WIDTH="56"doLEFT="130" WIDTH="56"forLEFT="195" WIDTH="56"returnLEFT="260" WIDTH="56"switchLEFT="325" WIDTH="356"whileLEFT="0" WIDTH="56"charLEFT="65" WIDTH="56"doubleLEFT="130" WIDTH="56"gotoLEFT="195" WIDTH="56"shortLEFT="260" WIDTH="56"typedefLEFT="325" WIDTH="356"LEFT="0" WIDTH="56"constLEFT="65" WIDTH="56"elseLEFT="130" WIDTH="56"ifLEFT="195" WIDTH="56"signedLEFT="260" WIDTH="56"unionLEFT="325" WIDTH="356"LEFT="0" WIDTH="56"LEFT="65" WIDTH="56"enumLEFT="130" WIDTH="56"intLEFT="195" WIDTH="56"sizeofLEFT="260" WIDTH="56"unsignedLEFT="325" WIDTH="356"LBL="4-1"Table 4-1 ID="93967"Reserved KeywordsTraditional C reserves and ignores the keyword fortran.LBL="4.4" HELPID=""ID="81807"ConstantsThe four types of  constants are integer, character, floating, and enumeration.  Each constant has a type, determined by its form and value.ID="chap.0415"In the following discussion of the various types of constants, a unary operator preceding the constant is not considered part of it.  Rather, such a construct is a constant-expression (see IDREF="72985" TYPE="TITLE"Section 7.18, "Constant Expressions"
).  Thus, the integer constant   0xff becomes an integral constant expression by prefixing a minus sign, as -0xff.  The effect of the operator ­ is not considered in the discussion of integer constants.ID="chap.0416"As an example, the integer constant 0xffffffff has type int   in traditional C, with value -1.  It has type unsigned in ANSI C, with value 232­1.  This discrepancy is inconsequential if the constant is assigned to a variable of integral type (for example, int or unsigned), as a conversion occurs.  If it is assigned to a double, however, the value would differ as indicated between traditional and ANSI C. LBL="4.4.1" HELPID=""Integer ConstantsAn integer constant consisting of a sequence of digits is considered octal if it begins with   0 (digit zero).  An octal constant consists of the digits 0 through 7 only.  A sequence of digits preceded by 0x or 0X (digit zero) is considered a hexadecimal integer.  The hexadecimal digits include   [aA] through [fF] with values 10 through 15. ID="chap.0417"ID="chap.0418"The suffixes [lL] have traditionally indicated integer constants of type long.  These suffixes are allowed, but are superfluous, since int and   long are the same size. The suffices ll, LL, lL, and Ll indicate a long long constant (a 64 bits integral type).Note that long long is not a strict ANSI C type and a warning will be given for long long constants in ­ansi and ­ansiposix modes.In ANSI C, an integer constant can be suffixed with   [uU],   in which case its type is unsigned.    (One or both of   [uU]   and   [lL] can appear.)  An integer constant will also have type unsigned if its value cannot be represented as an int.    Otherwise, the type of an integer constant is   int.LBL="4.4.2" HELPID=""ID="20008"Character ConstantsA character constant is a character enclosed in single quotes, as in `x'.  The value of a character constant is the numerical value of the character in the machine's character set. An explicit new-line character is illegal in a character constant.  The type of a character constant is int.   ID="chap.0419"ID="chap.0420"In ANSI C, a character constant can be prefixed by L, in which case it is a wide character constant.  For example, a wide character constant for   `z' would be written   L'z'.  The type of a wide character constant is wchar_t, which is defined in <stddef.h>.     ID="chap.0421"ID="chap.0422"LBL="" HELPID=""Special CharactersSome special and nongraphic characters are represented by the escape sequences shown in IDREF="24177" TYPE="TABLE"Table 4-2
.         ID="chap.0423"ID="chap.0424"ID="chap.0425"ID="chap.0426"ID="chap.0427"COLUMNS="2"LEFT="0" WIDTH="171"Character NameLEFT="180" WIDTH="356"Escape SequenceLEFT="0" WIDTH="171"new-lineLEFT="180" WIDTH="356"\nLEFT="0" WIDTH="171"horizontal tabLEFT="180" WIDTH="356"\tLEFT="0" WIDTH="171"vertical tabLEFT="180" WIDTH="356"\vLEFT="0" WIDTH="171"backspaceLEFT="180" WIDTH="356"\bLEFT="0" WIDTH="171"carriage returnLEFT="180" WIDTH="356"\rLEFT="0" WIDTH="171"form feedLEFT="180" WIDTH="356"\fLEFT="0" WIDTH="171"backslashLEFT="180" WIDTH="356"\\LEFT="0" WIDTH="171"single quoteLEFT="180" WIDTH="356"\'LEFT="0" WIDTH="171"double quoteLEFT="180" WIDTH="356"\"LEFT="0" WIDTH="171"question markLEFT="180" WIDTH="356"\?LEFT="0" WIDTH="171"bell (ANSI C only)LEFT="180" WIDTH="356"\aLBL="4-2"Table 4-2 ID="24177"Escape Sequences for Nongraphic CharactersThe escape \ddd consists of the backslash followed by 1, 2, or 3 octal digits that are taken to specify the value of the desired character.  A special case of this construction is \0 (not followed by a digit), which indicates the ASCII character NUL.     ID="chap.0428"ID="chap.0429"In ANSI C, \x indicates the beginning of a hexadecimal escape sequence.  The sequence is assumed to continue until a character is encountered that is not a member of the hexadecimal character set   0,1, name='hellip' font=symbol charset=fontspecific code=188 9, [aA], [bB], name='hellip' font=symbol charset=fontspecific code=188 [fF].  The resulting unsigned number cannot be larger than a character will accommodate (decimal 255).    ID="chap.0430"ID="chap.0431"If the character following a backslash is not one of those specified in this discussion, the behavior is undefined.  LBL="" HELPID=""Trigraph Sequences (ANSI C Only)The character sets of some older machines lack certain members that have come into common usage.  In order to provide a capability for such machines to specify these characters, ANSI C has defined an alternate method for their specification, using sequences of  characters that are commonly available.  These sequences are termed trigraph sequences.    Nine such sequences have been defined, each of which consists of three characters beginning with two question marks.  Each instance of one of these sequences is translated to the corresponding single character.  Other sequences of characters, perhaps including multiple question marks, are unchanged.  Each trigraph sequence with the single character it represents is listed in IDREF="33803" TYPE="TABLE"Table 4-3
.ID="chap.0432"COLUMNS="2"LEFT="0" WIDTH="171"Trigraph SequenceLEFT="180" WIDTH="356"Single CharacterLEFT="0" WIDTH="171"??=LEFT="180" WIDTH="356"#LEFT="0" WIDTH="171"??(LEFT="180" WIDTH="356"[LEFT="0" WIDTH="171"??/LEFT="180" WIDTH="356"\LEFT="0" WIDTH="171"??)LEFT="180" WIDTH="356"]LEFT="0" WIDTH="171"??'LEFT="180" WIDTH="356"^LEFT="0" WIDTH="171"??<LEFT="180" WIDTH="356"{LEFT="0" WIDTH="171"??!LEFT="180" WIDTH="356"|LEFT="0" WIDTH="171"??>LEFT="180" WIDTH="356"}LEFT="0" WIDTH="171"??-LEFT="180" WIDTH="356"~LBL="4-3"Table 4-3 ID="33803"Trigraph SequencesLBL="4.4.3" HELPID=""Floating ConstantsA floating constant consists of an integer part, a decimal point, a fraction part, an [eE], and an optionally signed integer exponent.  The integer and fraction parts both consist of a sequence of digits.  Either the integer part or the fraction part (but not both) can be missing.  Either the decimal point or the   [eE] and the exponent (not both) can be missing.   ID="chap.0433"ID="chap.0434"In traditional C, every floating constant has type double.In ANSI C, floating constants can be suffixed by either [fF] or   [lL].  Floating constants suffixed with   [fF] have type float.  Those suffixed with   [lL] have type long double, which is the same size and precision as double in this implementation.LBL="4.4.4" HELPID=""Enumeration ConstantsNames declared as enumerators have type int.  For a discussion of enumerators, see IDREF="30981" TYPE="TITLE"Section 8.5, "Enumeration Declarations."
  For information on the use of enumerators in expressions, see IDREF="11806" TYPE="TITLE"Section 5.2.2, "Integer and Floating Point Types."
      ID="chap.0435"ID="chap.0436"LBL="4.5" HELPID=""ID="33247"String LiteralsA string literal is a sequence of characters surrounded by double quotes, as in "...".  A string literal has type array of char and is initialized with the given characters.  The compiler places a null byte (\0) at the end of each string literal so that programs that scan the string literal can find its end.  A double-quote character (") in a string literal must be preceded by a backslash (\).  In addition, the same escapes as described for character constants can be used.  (See IDREF="20008" TYPE="TITLE"Section 4.4.2
 for a list of escapes.)  A backslash (\) and the immediately following new line are ignored.  Adjacent string literals are concatenated.    ID="chap.0437"ID="chap.0438"In traditional C, all string literals, even when written identically, are distinct.In ANSI C, identical string literals are not necessarily distinct.  Prefixing a string literal with   L   specifies a wide string literal.  Adjacent wide string literals are concatenated.    ID="chap.0439"ID="chap.0440"As an example, consider the sentence He said, "Hi there."   This sentence could be written with three adjacent string literals as "He said, " "\"Hi " "there.\"" LBL="4.6" HELPID=""OperatorsAn   operator specifies an operation to be performed.  The operators   [ ], ( ), and ? : must occur in pairs, possibly separated by expressions.  The operators # and ##   can occur only in preprocessing directives. ID="chap.0441"operator: one of[  ]  (  )  .  ­>++  ­ ­  &  *  +  ­  ~  !  sizeof/  %  <<  >>  <  >  <=  =>  ==  !=  ^  |  &&  ||?  :=  *=  /=  %=  +=  ­=  <<=  >>= &=  ^=  |=, # ##Particular operations are discussed in IDREF="74335" TYPE="TITLE"Chapter 7, "Expressions and Operators."LBL="4.7" HELPID=""PunctuatorsA punctuator   is a symbol that has semantic significance but does not specify an operation to be performed.  The punctuators [ ], ( ), and { }   must occur in pairs, possibly separated by expressions, declarations or statements.  The punctuator #   can only occur in preprocessing directives.   ID="chap.0442"ID="chap.0443"punctuator: one of [  ]  (  )  {  }  *  ,  :  =  ;  name='hellip' font=symbol charset=fontspecific code=188  #Some operators, determined by context, are also punctuators.  For example, the array index indicator [ ] is a punctuator in a declaration (see IDREF="87922" TYPE="TITLE"Chapter 8
), but an operator in an expression (see IDREF="74335" TYPE="TITLE"Chapter 7
).LBL="5"ID="20204"Meaning of IdentifiersTraditional C formally based the interpretation of an identifier on two of its attributes: storage class and type.  The storage class determined the location and lifetime of the storage associated with an identifier; the type determined the meaning of the values found in the identifier's storage.  Informally, name space, scope, and linkage were also considered.ANSI C formalizes the practices of traditional C.  An ANSI C identifier is disambiguated by four characteristics: its   scope, name space, linkage,   and   storage duration.  The ANSI C definitions of these terms differ somewhat from their interpretations in traditional C.A discussion of the storage-class specifiers and their meanings is found in IDREF="87922" TYPE="TITLE"Chapter 8, "Declarations."
  Storage-class specifiers are discussed in this chapter only in terms of their effect on an object's storage duration and linkage.This chapter contains the following sections:IDREF="39439" TYPE="TITLE""Disambiguating Names" discusses scope, name spaces, linkage, and storage duration as means of distinguishing identifiers.IDREF="64032" TYPE="TITLE""Type" describes the three fundamental object types.IDREF="23437" TYPE="TITLE""Objects and lvalues" briefly defines those two terms.You can find a discussion of some of this material, focused on changes to the language, in IDREF="36460" TYPE="TITLE"Section 3.2, "Changes in Disambiguating Identifiers,"
 and IDREF="30681" TYPE="TITLE"Section 3.3, "Types and Type Compatibility."LBL="5.1" HELPID=""ID="39439"Disambiguating NamesThis section discusses the four ways C disambiguates names: scope, name space, linkage, and storage class.LBL="5.1.1" HELPID=""ID="92800"ScopeThe region of a program in which a given instance of an identifier is visible is called its scope.  The scope of an identifier usually begins when its declaration is seen, or, in the case of labels and functions, when it is implied by use.  Although it is impossible to have two declarations of the same identifier active in the same scope, there is no conflict if the instances are in different scopes.  Of the four kinds of scope, twoname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'file and blockname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'are familiar from traditional C.  The two `newer' kinds of scopename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'function and function prototypename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'are implied in traditional C and formalized in ANSI C.ID="chap.051"LBL="" HELPID=""Block ScopeBlock ID="chap.052"ID="chap.053"scope is the scope of automatic variablesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'that is, variables declared within a function.  Each block has its own scope.  No conflict occurs if the same identifier is declared in two blocks. If one block encloses the other, the declaration in the enclosed block hides that in the enclosing block until the end of the enclosed block is reached.  The definition of a block is the same in ANSI C and traditional C, with one exception, illustrated by the example below:int f(x) 
int x; 
{
      int x;
      x = 1;
}In ANSI C, the function arguments are in the function body block.  Thus, ANSI C complains of a "redeclaration of x."In traditional C, the function arguments are in a separate block that encloses the function body block.  Thus, traditional C would quietly hide the argument   x with the   local variable   x, as they are in distinct blocks.ANSI C and traditional C differ in the assignment of block   and   file   scope in a few instances.  See the following discussion of file scope. LBL="" HELPID=""Function ScopeOnly labels have function scope.  Function scope continues until the end of the current function.   ID="chap.054"ID="chap.055"LBL="" HELPID=""Function Prototype ScopeIf an identifier appears within the list of parameter declarations in a function prototype that is not part of a function definition (see IDREF="95935" TYPE="TITLE"Section 8.7.4, "Function Declarators and Prototypes"
), it has function prototype scope, which terminates at the end of the prototype.  This termination allows any dummy parameter names appearing in a function prototype to disappear at the end of the prototype.     ID="chap.056"ID="chap.057"LBL="" HELPID=""File ScopeIdentifiers appearing outside of any block, function, or function prototype, have ID="chap.058"ID="chap.059"file scope.  This scope continues to the end of the compilation unit.  Unlike other scopes, multiple declarations of the same identifier with file scope can exist in a compilation unit, so long as the declarations are compatible.Whereas ANSI C assigns block scope to all declarations occurring inside a function, traditional C assigns file scope to such declarations if they have the storage class extern. This storage class is implied in all function declarations, whether the declaration is explicit (as in   int foo();) or implicit (if there is no active declaration for   foo() when an invocation is encountered, as in   f = foo();).  For a further discussion of this discrepancy, with examples, see IDREF="45081" TYPE="TITLE"Section 3.2.1, "Scoping Differences."
   LBL="5.1.2" HELPID=""ID="16739"Name SpacesIn certain cases, the purpose for which an identifier is used may disambiguate it from other uses of the same identifier appearing in the same scope.  This is true, for example, for tags, and is used in traditional C to avoid conflicts between identifiers used as tags and those used in object or function declarations.  ANSI C formalizes this mechanism by defining certain ID="chap.0510"name spaces.    These name spaces are completely independent.  A member of one name space cannot conflict with a member of another.  ANSI C recognizes four distinct name spaces:TagsThere is a single name space for struct, union and enum tags.    ID="chap.0511"ID="chap.0512"LabelsLabels are in their own name space.    ID="chap.0513"ID="chap.0514"Members Each struct or union has its own name space for its members.   ID="chap.0515"ID="chap.0516"ID="chap.0517"ID="chap.0518"Ordinary identifiersOrdinary identifiers, including function and object names as well as user-defined type names, are placed in the last name space.  ID="chap.0519"ID="chap.0520"LBL="" HELPID=""Name Space Discrepancies between Traditional and ANSI CThe definition of name spaces causes discrepancies between traditional and ANSI C in a few situations: ID="chap.0521"Structure members in traditional C were nothing more than offsets, allowing the use of a member with a structure to which it does not belong.  This is illegal under ANSI C. Enumeration constants were special identifiers in traditional C prior to IRIX Release 3.3.  In later releases of traditional C, as in ANSI C, these constants are simply integer constants that can be used anywhere they are appropriate. Labels reside in the same name space as ordinary identifiers in traditional C.  Thus the examplefunc() { 
int lab;
     if (lab) goto lab;
     func1() ; 
lab:
     return; 
}is legal in ANSI C but not in traditional C. LBL="5.1.3" HELPID=""Linkage of IdentifiersTwo instances of the same identifier appearing in different scopes may, in fact, refer to the same entity.  For example, the references to a variable counter declared with file scope as ID="chap.0522"ID="chap.0523"extern int counter;in two separate files refer to the same int object.  The association between the references to an identifier occurring in distinct scopes and the underlying objects are determined by the identifier's linkage.The three kinds of linkage are:Internal linkage Within a file, all declarations of the same identifier with internal linkage denote the same object.    ID="chap.0524"ID="chap.0525"External linkageWithin an entire program, all declarations of an identifier with external linkage denote the same object.    ID="chap.0526"ID="chap.0527"No linkageA unique entity, accessible only in its own scope, has no linkage. ID="chap.0528"An identifier's linkage is determined by whether it appears inside or outside a function, whether it appears in a declaration of a function (as opposed to an object), its storage-class specifier, and the linkage of any previous declarations of the same identifier that have file scope.  It is determined as follows:If an identifier is declared with file scope and the storage-class specifier static, it has internal linkage. If the identifier is declared with the storage-class specifier extern, or is an explicit or implicit function declaration with block scope, the identifier has the same linkage as any previous declaration of the same identifier with file scope.  If no previous declaration exists, the identifier has external linkage. If an identifier for an object is declared with file scope and no storage-class specifier, it has external linkage. (See IDREF="40124" TYPE="TITLE"Section 3.2.3, "Changes in the Linkage of Identifiers."
)All other identifiers have no linkage.  This includes all identifiers that do not denote an object or function, all objects with block scope declared without the storage-class specifier   extern, and all identifiers that are not members of the ordinary variables name space.Two declarations of the same identifier in a single file that have the same linkage, either internal or external, refer to the same object.  The same identifier cannot appear in a file with both internal and external linkage.This code gives an example where the linkage of each declaration is the same in both traditional and ANSI C:static int pete; 
extern int bert; 
int mom; 
int func0() {
      extern int mom;
      extern int pete;
      static int dad;
      int bert;
      ...  
} 
int func1() {
      static int mom;
      extern int dad;
      extern int bert;
      ...  
}The declaration of pete with file scope has internal linkage by rule 1 above.  This means that the declaration of pete in   func0() also has internal linkage by rule 2 and refers to the same object.By rule 2, the declaration of bert with file scope has external linkage, since there is no previous declaration of bert with file scope.  Thus, the declaration of bert in   func1() also has external linkage (again by rule 2) and refers to the same (external) object.  By rule 4, however, the declaration of bert in   func0() has no linkage, and refers to a unique object.The declaration of mom with file scope has external linkage by rule 3, and, by rule 2, so does the declaration of mom in func0().  (Again, two declarations of the same identifier in a single file that both have either internal or external linkage refer to the same object.)  The declaration of mom in func1(), however, has no linkage by rule 4 and thus refers to a unique object.Last, the declarations of dad in func0() and func1() refer to different objects, as the former has no linkage and the latter, by rule 2, has external linkage.  LBL="5.1.4" HELPID=""Linkage Discrepancies between Traditional and ANSI CTraditional and ANSI C differ on the concept of linkage in the following important ways:In traditional C, a function can be declared with block scope and the storage-class specifier static.  The declaration is given internal linkage.  Only the storage class extern can be specified in function declarations with block scope in ANSI C. In traditional C, if an object is declared with block scope and the storage-class specifier static, and a declaration for the object with file scope and internal linkage exists, the block scope declaration has internal linkage.  In ANSI C, an object declared with block scope and the storage-class specifier static has no linkage.Traditional and ANSI C handle the concepts of reference   and   definition   differently.  Here is an example:extern int mytime; 
static int yourtime;In the example above, both mytime and yourtime have file scope.  As discussed previously, mytime has external linkage, while yourtime has internal linkage.  However, there is an implicit differencename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'which exists in both ANSI and traditional Cname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'between the declarations of mytime and yourtime in the above example.  The declaration of yourtime allocates storage for the object, whereas the declaration of mytime merely references it.  If mytime had been initialized, as inint mytime=0;it would also have allocated storage.  A declaration that allocates storage is referred to as a definition.  In traditional C, neither of the two declarationsextern int bert; 
int bert;is a definition.  In effect, the second declaration includes an implicit extern specification.  ANSI C does not include such an implicit specification.  In ANSI C, objects with external linkage that are not specified as extern at the end of the compilation unit are considered definitions, and, in effect, initialized to zero.  (If multiple declarations of the object occur in the compilation unit, only one need have the extern specification.) If two modules contain definitions of the same identifier, the linker will complain of "multiple definitions," even though neither is explicitly initialized.The ANSI C linker will issue a warning when it finds redundant definitions, indicating the modules that produced the conflict.  However, the linker cannot determine if the initialization of the object is explicit.  The result might be incorrectly initialized objects, if another module fails to tag the object with extern.Thus, in the examplemodule1.c:       int ernie;
module2.c: 
      int ernie=5;ANSI C implicitly initializes ernie in module1.c to zero.  To the linker, ernie is initialized in two different modules.  The linker warns you of this situation, and chooses the first such module it encountered as the true definition of ernie.  This module might or might not be the one containing the explicitly initialized copy.  LBL="5.1.5" HELPID=""Storage DurationStorage duration denotes the lifetime of an object.  Storage duration is of two types: static   and   automatic.       ID="chap.0529"ID="chap.0530"ID="chap.0531"Objects declared with external or internal linkage, or with the storage-class specifier static, have static storage duration.  If these objects are initialized, the initialization occurs once, prior to any reference.Other objects have   automatic storage duration.    Storage is newly allocated for these objects each time the block that contains their declaration is entered.  If an object with automatic storage duration is initialized, the initialization occurs each time the block is entered at the top.  It is not guaranteed to occur if the block is entered by a jump to a labeled statement.LBL="5.2" HELPID=""ID="64032"TypeThe C language supports three fundamental types of objects: character, integer, and   floating point types.         ID="chap.0532"ID="chap.0533"LBL="5.2.1" HELPID=""Character TypesObjects declared as characters (char) are large enough to store any member of the implementation's character set.  If a genuine character from that character set is stored in a char variable, its value is equivalent to the integer code for that character.  Other quantities may be stored into character variables, but the implementation is machine dependent.  In this implementation, char is unsigned by default.       ID="chap.0534"ID="chap.0535"ID="chap.0536"The ANSI C standard has added multibyte and wide character types.  In Silicon Graphics' initial release of ANSI C, wide characters are of type unsigned char, and multibyte characters are of length one.  (See the header files <stddef.h> and <limits.h> for more information.) Because of their initial limited implementation in this release, this document includes little discussion of wide and multibyte character types.             ID="chap.0537"ID="chap.0538"ID="chap.0539"ID="chap.0540"ID="chap.0541"LBL="5.2.2" HELPID=""ID="11806"Integer and Floating Point TypesUp to four sizes of integer, declared short int, int, long int, and long long int are available.  Plain integers have the natural size suggested by the host machine architecture.  The other sizes are provided to meet special needs.  The sizes are shown in IDREF="59876" TYPE="TABLE"Table 5-1
.  (The values in the table apply to both ANSI and traditional C, with the exceptions noted below.)COLUMNS="2"LEFT="0" WIDTH="171"TypeID="chap.0542"ID="chap.0543"ID="chap.0544"ID="chap.0545"LEFT="180" WIDTH="356"SizeLEFT="0" WIDTH="171"charLEFT="180" WIDTH="356"8 bitsLEFT="0" WIDTH="171"intLEFT="180" WIDTH="356"32LEFT="0" WIDTH="171"shortLEFT="180" WIDTH="356"16LEFT="0" WIDTH="171"longLEFT="180" WIDTH="356"32LEFT="0" WIDTH="171"long longLEFT="180" WIDTH="356"64LEFT="0" WIDTH="171"unsignedLEFT="180" WIDTH="356"32LEFT="0" WIDTH="171"unsigned long longLEFT="180" WIDTH="356"64LEFT="0" WIDTH="171"floatLEFT="180" WIDTH="356"32LEFT="0" WIDTH="171"doubleLEFT="180" WIDTH="356"64LEFT="0" WIDTH="171"float rangeLEFT="180" WIDTH="356"± 10 38LEFT="0" WIDTH="171"double rangeLEFT="180" WIDTH="356"± 10 308LEFT="0" WIDTH="171"long double rangeLEFT="180" WIDTH="356"± 10 308LBL="5-1"Table 5-1 ID="59876"Storage Class SizesANSI C adds long   double, which is the same as double in this implementation.  Types long and int are synonymous in traditional C. In this implementation of ANSI C, they are the same size.  This document uses both terms interchangeably. long long is introduced in this version of the compiler as a 64 bits integral type. Note that long long is not a valid ANSI C type, hence a warning will be elicited for every occurrence of "long long" in the source program text in ­ansi and ­ansiposix modes.                        ID="chap.0546"ID="chap.0547"ID="chap.0548"ID="chap.0549"ID="chap.0550"ID="chap.0551"ID="chap.0552"ID="chap.0553"In ANSI C, characteristics of integer and floating point types are defined in the standard header files <limits.h> and <float.h>.Enumeration constants were special identifiers under various versions of  traditional C, prior to IRIX Release 3.3.  In ANSI C, these constants are simply integer constants that may be used anywhere.  Similarly, ANSI C allows the assignment of other integer variables to variables of enumeration type, with no error.  Unsigned integers, declared unsigned,   obey the laws of arithmetic modulo 2n, where   n   is the number of bits in the representation. ID="chap.0554"LBL="5.2.3" HELPID=""ID="54350"Derived TypesBecause objects of the types mentioned in IDREF="11806" TYPE="TITLE"Section 5.2.2
 can be interpreted usefully as numbers, this manual refers to them as arithmetic types.  The types char, enum, and int of all sizes (whether unsigned or not) will be collectively called integral types.  The float and double types will collectively be called floating types. Arithmetic types and pointers will be collectively referred to as scalar types.                               ID="chap.0555"ID="chap.0556"ID="chap.0557"ID="chap.0558"ID="chap.0559"ID="chap.0560"ID="chap.0561"ID="chap.0562"ID="chap.0563"ID="chap.0564"ID="chap.0565"The fundamental arithmetic types can be used to construct a conceptually infinite class of derived types, such as:arrays of objects of most typesfunctions that return objects of a given typepointers to objects of a given typestructures that contain a sequence of objects of various typesunions capable of containing any one of several objects of various typesIn general, these constructed objects can be used as building blocks for other constructed objects.LBL="5.2.4" HELPID=""The void TypeThe void type specifies an empty set of values.  It is used as the type returned by functions that generate no value.  The void type never refers to an object, and is therefore not included in any reference to object types.    ID="chap.0566"ID="chap.0567"LBL="5.3" HELPID=""ID="23437"Objects and lvaluesAn ID="chap.0568"ID="chap.0569"object is a manipulatable region of storage.  An lvalue is an expression referring to an object.  An obvious example of an lvalue expression is an identifier.  Some operators yield lvalues. For example, if E is an expression of pointer type, then *E is an lvalue expression referring to the object to which E points.  The name lvalue comes from the term "left value."  In the assignment expression E1= E2, the left operand E1 must be an lvalue expression.  Most lvalues are modifiable, meaning that the lvalue may be used to modify the object to which it refers.  Examples of lvalues that are not modifiable include array names, lvalues with incomplete type, and lvalues that refer to an object, part or all of which is qualified with const (see IDREF="22645" TYPE="TITLE"Section 8.6, "Type Qualifiers"
).  Whether an lvalue appearing in an expression must be modifiable is usually obvious.  For example, in the assignment expression E1 = E2, E1 must be modifiable.  This document makes the distinction between modifiable and unmodifiable lvalues only when it is not obvious.LBL="6"ID="61724"Operator ConversionsA number of operators can, depending on the types of their operands, cause an implicit conversion of some operands from one type to another.  The following discussion explains the results you can expect from these conversions.  The conversions demanded by most operators are summarized in IDREF="26274" TYPE="TITLE"Section 6.6, "Arithmetic Conversions."
  As necessary, a discussion of the individual operators supplements the summary.    ID="chap.061"ID="chap.062"LBL="6.1" HELPID=""Conversions of Characters and IntegersYou can use a character or a short integer wherever you can use an integer.  Characters are unsigned by default.  In all cases the value is converted to an integer.  Conversion of a shorter integer to a longer preserves sign.A longer integer is truncated on the left when converted to a shorter integer or to a char.  Excess bits are simply discarded.       ID="chap.063"ID="chap.064"ID="chap.065"LBL="6.2" HELPID=""Conversions of Float and DoubleHistorically in C, expressions containing floating point operands (either ID="chap.066"float or double) were calculated using double precision.  This is also true of calculations in traditional C unless you've specified the compiler option ­float.  With the ­float   option, calculations involving floating point operands and no double operands take place in single precision.  The ­float option has no effect on argument promotion rules at function calls or on function prototypes.       ID="chap.067"ID="chap.068"ID="chap.069"ANSI C performs calculations involving floating point in the same precision as if ­float had been specified in traditional C, except when floating point constants are involved. In traditional C, specifying the   -float option would coerce floating point constants into type float if the rest of the expression was type float. This is not the case in ANSI C. ANSIC considers all floating point constants to be implicitly double precision, and arithmetics involving such constants will therefore take place in double precision. To force single precision arithmetic in ANSI C, you should use the f qualifier on floating point constants. For example, 3.14 is double precision in ANSI C, and 3.14f is single precision.For a complete discussion with examples, see IDREF="55446" TYPE="TITLE"Section 3.3.2, "Type Promotion and Floating Point Constants."LBL="6.3" HELPID=""Conversion of Floating and Integral TypesConversions between floating and integral values are machine dependent.  Silicon Graphics uses IEEE floating point, in which the default rounding mode is to nearest, or in case of a tie, to even.  Floating point rounding modes can be controlled using the facilities of fpc(3c).  Floating point exception conditions are discussed in the introductory paragraph of IDREF="74335" TYPE="TITLE"Chapter 7
.When a floating value is converted to an integral value, the rounded value is preserved as long as it does not overflow.  When an integral value is converted to a floating value, the value is preserved unless a value of more than six significant digits is being converted to single precision or fifteen significant digits is being converted to double precision.LBL="6.4" HELPID=""Conversion of Pointers and IntegersAn expression of integral type can be added to or subtracted from an object pointer.  In such a case, the integer expression is converted as specified in the discussion of the addition operator in IDREF="48455" TYPE="TITLE"Section 7.6, "Additive Operators."
 Two pointers to objects of the same type can be subtracted.  In this case, the result is converted to an integer as specified in the discussion of the subtraction operator, also in IDREF="48455" TYPE="TITLE"Section 7.6
.       ID="chap.0610"ID="chap.0611"ID="chap.0612"LBL="6.5" HELPID=""Conversion of Unsigned IntegersWhen an unsigned integer is converted to a longer unsigned   or signed integer, the value of the result is preserved.  Thus, the conversion amounts to padding with zeros on the left.         ID="chap.0613"ID="chap.0614"ID="chap.0615"When an unsigned integer is converted to a shorter signed   or   unsigned   integer, the value is truncated on the left.  This truncation might produce a negative value, if the result is signed.LBL="6.6" HELPID=""ID="26274"Arithmetic ConversionsMany types of operations in C require two operands to be converted to a common type.  Two sets of conversion rules are applied to accomplish this conversion.  The first, referred to as the   integral promotions, defines how integral types are promoted to one of several integral types that are at least as large as int.  The second, called the usual arithmetic conversions, derives a common type in which the operation is performed. ID="chap.0616"ID="chap.0617"ANSI C and traditional C follow different sets of these rules.LBL="6.6.1" HELPID=""Integral PromotionsThe difference between the ANSI C and traditional versions of the conversion rules is that the traditional C rules emphasize preservation of the signedness of a quantity, while ANSI C rules emphasize preservation of its value. In the rules that follow, int refers to types   int, long, and   long   int.  unsigned   int   refers to types unsigned int, unsigned, unsigned long, and   unsigned   long   int.       ID="chap.0618"ID="chap.0619"ID="chap.0620"In traditional C, operands of types   char, unsigned char, and unsigned short are converted to unsigned int.  Operands of types signed char and short are converted to int.ANSI C converts all char and short operands, whether signed or unsigned,  to int.  Only operands of type   unsigned int and unsigned long long may remain unsigned.LBL="6.6.2" HELPID=""Usual Arithmetic ConversionsBesides differing in emphasis on signedness and value preservation, the usual arithmetic conversion rules of ANSI C and traditional C also differ in the precision of the chosen floating point type.    ID="chap.0621"ID="chap.0622"Below are two sets of conversion rules, one for traditional C, and the other for ANSI C.  Each set is ordered in decreasing precedence.  In any particular case, the rule that applies is the first whose conditions are met.Each rule specifies a type, referred to as the   result type.  Once a rule has been chosen, each operand is converted to the result type, the operation is performed in that type, and the result is of that type. ID="chap.0623"LBL="" HELPID=""Traditional C Conversion RulesThe traditional C conversion rules are:If any operand is of type double, the result type is double.ID="chap.0624"If an operand is of type float, the result type is float if you have specified the   ­float switch.  Otherwise, the result type is double.The integral promotions are performed on each operand. If one of the operands is of type   unsigned long long, the result is of type unsigned long long; otherwise, if one of the operands is of type long long, the result is of type   long long; otherwise, if one of the operands is of type unsigned int, the result type is unsigned int.  Otherwise it is int.LBL="" HELPID=""ANSI C Conversion RulesThe ANSI C rules that follow are simplified considerably by disregarding the ANSI C distinctions between double and long double types.  Although these types are distinct, the distinctions vanish in this context in Silicon Graphics' implementation. ID="chap.0625"If any operand is of type double, the result type is double.If an operand is of type float, the result type is float.The integral promotions are performed on each operand. If one of the operands is of type   unsigned long long, the result is of type unsigned long long; otherwise, if one of the operands is of type long long, the result is of type   long long; otherwise, if one of the operands is of type unsigned int, the result type is unsigned int. Otherwise it is int.LBL="6.7" HELPID=""Conversion of Other OperandsThe following three sections discuss conversion of lvalues, function designators, void objects, and pointers.LBL="6.7.1" HELPID=""ID="71167"Conversion of lvalues and Function DesignatorsExcept as noted, if an lvalue that has type array of <type> appears as an operand, it is converted to an expression of the type   pointer to <type>.  The resultant pointer will point to the initial element of the array.  In this case, the resultant pointer ceases to be an lvalue.  (For a discussion of lvalues, see IDREF="23437" TYPE="TITLE"Section 5.3
.)          ID="chap.0626"ID="chap.0627"ID="chap.0628"ID="chap.0629"A   function designator   is an expression that has function type.  Except as noted, a function designator appearing as an operand is converted to an expression of type   pointer to function.LBL="6.7.2" HELPID=""Conversion of Void ObjectsThe (nonexistent) value of a void object cannot be used in any way, and neither explicit nor implicit conversion can be applied.  Because a void expression denotes a nonexistent value, such an expression can be used only as an expression statement (see IDREF="10732" TYPE="TITLE"Section 9.1
) or as the left operand of a comma expression (see IDREF="11638" TYPE="TITLE"Section 7.17
).     ID="chap.0630"ID="chap.0631"An expression can be converted to type void by use of a cast.  For example, this makes explicit the discarding of the value of a function call used as an expression statement.LBL="6.7.3" HELPID=""Conversion of PointersA pointer to void can be converted to a pointer to any object type and back without change in the underlying value.          ID="chap.0632"ID="chap.0633"ID="chap.0634"ID="chap.0635"The NULL pointer constant can be specified either as the integral value zero, or the value zero cast to a pointer to   void.  If a NULL pointer constant is assigned or compared to a pointer to any type, it is appropriately converted.LBL="7"ID="74335"Expressions and OperatorsThe precedence of expression operators is indicated by their syntax in this chapter; it usually follows the order of the major subsections, with earlier subsections having higher precedence. For example, since the multiplication operator * can have a unary-expression (which is a cast-expression as well) as an operand, the order of evaluation of the expression ~ i * z gives ~ higher precedence than * and can be written( ~ i ) * zThe text indicates this precedence by placing unary-expressions in IDREF="22392" TYPE="TITLE"Section 7.3
, and multiplicative-expressions in IDREF="31930" TYPE="TITLE"Section 7.5
.  This syntax­subsection correlation is violated in a few cases. For example, cast-expressions (IDREF="35206" TYPE="TITLE"Section 7.4
) can be operands in unary-expressions (IDREF="22392" TYPE="TITLE"Section 7.3
), in which case the cast-expression has higher precedence.    ID="chap.071"ID="chap.072"Within each subsection, the operators have the same precedence.  All operators group left-to-right unless otherwise indicated in their discussion.The order of evaluation of expressions, as well as the order in which side-effects take place, is unspecified, except as indicated by the syntax, or specified explicitly in this chapter.  The compiler can arbitrarily rearrange expressions involving a commutative and associative operator (*, +, &, |, ^).      ID="chap.073"ID="chap.074"ID="chap.075"Integer divide-by-zero results in a trap.  Other integer exception conditions are ignored.  Silicon Graphics floating point conforms to the IEEE standard. Floating point exceptions are ignored by default, yielding the default IEEE results of infinity for divide-by-zero and overflow, not-a-number for invalid operations, and zero for underflow.  You can gain control over these exceptions and their results most easily by using the Silicon Graphics IEEE floating point exception handler package (see handle_sigfpes(3c)).  You can also control these exceptions by implementing your own handler and appropriately initializing the floating point unit (see fpc(3c)).          ID="chap.076"ID="chap.077"ID="chap.078"LBL="7.1" HELPID=""ID="19257"Primary ExpressionsID="chap.079"ID="chap.0710"ID="chap.0711"ID="chap.0712"ID="chap.0713"An identifier is a primary-expression provided it has been declared as referring to an object, in which case it is an lvalue, or a function, in which case it is a function designator.  Lvalues and function designators are discussed in IDREF="71167" TYPE="TITLE"Section 6.7.1
.    ID="chap.0714"ID="chap.0715"primary-expression:identifierconstantstring literal( expression ) A constant is a primary-expression.  Its type is determined by its form and value, as described in IDREF="81807" TYPE="TITLE"Section 4.4
. ID="chap.0716"A string literal is a primary-expression.  Its type is array of char, subject to modification, as described in IDREF="71167" TYPE="TITLE"Section 6.7.1
. ID="chap.0717"A parenthesized expression is a primary-expression whose type and value are identical to those of the unparenthesized expression.  The presence of parentheses does not affect whether the expression is an lvalue, rvalue, or function designator.  For information on expressions, see IDREF="11638" TYPE="TITLE"Section 7.17
.    ID="chap.0718"ID="chap.0719"LBL="7.2" HELPID=""Postfix ExpressionsPostfix expressions involving ., ­>, subscripting, and function calls group left to right.    ID="chap.0720"ID="chap.0721"postfix-expression:primary-expressionpostfix-expression [ expression ]postfix-expression ( argument-expression-list opt )postfix-expression . identifierpostfix-expression ­> identifierpostfix-expression ++postfix-expression ­ ­argument-expression-list:argument-expressionargument-expression-list , argument-expression LBL="7.2.1" HELPID=""SubscriptsA postfix-expression followed by an expression in square brackets is a subscript.  Usually, the postfix-expression has type pointer to <type>, the expression within the square brackets has type int, and the type of the result is <type>.  However, it is equally valid if the types of the postfix-expression and the expression in brackets are reversed.  This is because the expression postfix E1[E2]is identical (by definition) to*((E1)+(E2))Since   + is commutative, E1   and   E2 can be interchanged.You can find further information on this notation in the discussions on identifiers, and in the discussion of the operators * (in IDREF="22392" TYPE="TITLE"Section 7.3, "Unary Operators"
) and +, (in IDREF="48455" TYPE="TITLE"Section 7.6, "Additive Operators"
) in this chapter. LBL="7.2.2" HELPID=""ID="71562"Function CallsThe syntax of postfix-expressions that are function calls is:postfix-expression ( argument-expression-list   opt )argument-expression-list:argument-expressionargument-expression-list , argument-expression A   postfix­expression followed by parentheses containing a possibly empty, comma-separated list of expressions (which constitute the actual arguments to the function) denotes a function call.  The postfix­expression must be of type function returning <type>, and the result of the function call is of type <type>, and is not an lvalue.  If the postfix­expression denoting the called function consists solely of a previously unseen identifier foo, the call produces an implicit declaration as if, in the innermost block containing the call, the declaration        ID="chap.0722"ID="chap.0723"ID="chap.0724"extern int foo(); had appeared.If a corresponding function prototype that specifies a type for the argument being evaluated is in force, an attempt is made to convert the argument to that type.  If the number of arguments does not agree with the number of parameters specified in the prototype, the behavior is undefined.  If the type returned by the function as specified in the prototype does not agree with the type derived from the postfix-expression denoting the called function, the behavior is undefined. Such a scenario may occur for an external function declared with conflicting prototypes in different files. If no corresponding prototype is in scope or the argument is in the variable argument section of a prototype that ends in ellipses (name='hellip' font=symbol charset=fontspecific code=188), the argument is converted according to the following default argument promotions:        ID="chap.0725"ID="chap.0726"ID="chap.0727"Type float is converted to double. Array and function names are converted to corresponding pointers. When using traditional C: types unsigned short and unsigned char are converted to unsigned int. types signed short and signed char are converted to signed int. When using ANSI C: short and char, whether signed or unsigned, are converted to int.In preparing for the call to a function, a copy is made of each actual argument.  Thus, all argument passing in C is strictly by value.  A function can change the values of its parameters, but these changes cannot affect the values of the actual arguments.  It is possible to pass a pointer on the understanding that the function can change the value of the object to which the pointer points.  (Arguments that are array names can be changed as well, since these arguments are converted to pointer expressions.)  Since the order of evaluation of arguments is unspecified, side effects might be delayed until the next sequence point, which occurs at the point of the actual callname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'after all arguments have been evaluated.  (For example, the incrementation of foo, which is a side-effect of the evaluation of an argument   foo++, might be delayed.)  Recursive calls to any function are permitted.     ID="chap.0728"ID="chap.0729"LBL="7.2.3" HELPID=""Structure and Union ReferencesA postfix-expression followed by a dot followed by an identifier denotes a structure or union reference.  postfix-expression . identifierThe postfix-expression must be a structure or a union, and the identifier must name a member of the structure or union.  The value is the named member of the structure or union, and it is an lvalue if the first expression is an lvalue.  The result has the type of the indicated member and the qualifiers of the structure or union.                 ID="chap.0730"ID="chap.0731"ID="chap.0732"ID="chap.0733"ID="chap.0734"ID="chap.0735"LBL="7.2.4" HELPID=""Indirect Structure and Union ReferencesA postfix-expression   followed by an arrow (built from ­ and > ) followed by an identifier is an indirect structure or union reference.  postfix-expression ­> identifierThe postfix-expression must be a pointer to a structure or a union, and the identifier must name a member of that structure or union.  The result is an lvalue referring to the named member of the structure or union to which the postfix-expression points.  The result has the type of the selected member and the qualifiers of the structure or union to which the postfix-expression points.  Thus the expression          ID="chap.0736"ID="chap.0737"ID="chap.0738"ID="chap.0739"E1­>MOS is the same as (*E1).MOS  Structures and unions are discussed in IDREF="82788" TYPE="TITLE"Section 8.3
.  LBL="7.2.5" HELPID=""Postfix ++ and   ­ ­The syntax of   postfix ++ and postfix -- is:postfix-expression ++postfix-expression   ­ ­When postfix   ++ is applied to a modifiable lvalue, the result is the value of the object referred to by the lvalue.  After the result is noted, the object is incremented as if the constant 1 (one) were added to it.  See the discussions in IDREF="48455" TYPE="TITLE"Section 7.6, "Additive Operators,"
 and IDREF="65675" TYPE="TITLE"Section 7.16, "Assignment Operators,"
 for information on conversions.  The type of the result is the same as the type of the lvalue expression.  The result is not an lvalue.                ID="chap.0740"ID="chap.0741"ID="chap.0742"ID="chap.0743"ID="chap.0744"ID="chap.0745"When postfix ­ ­   is applied to a modifiable lvalue, the result is the value of the object referred to by the lvalue.  After the result is noted, the object is decremented as if the constant 1 (one) were subtracted from it. See the discussions in IDREF="48455" TYPE="TITLE"Section 7.6
 and IDREF="65675" TYPE="TITLE"Section 7.16
 for information on conversions.  The type of the result is the same as the type of the lvalue expression.  The result is not an lvalue.For both postfix   ++   and   ­ ­ operators, updating the stored value of the operand might be delayed until the next sequence point.  LBL="7.3" HELPID=""ID="22392"Unary OperatorsExpressions with unary operators group from right to left.     ID="chap.0746"ID="chap.0747"   unary-expression:postfix-expression++   unary-expression­ ­ unary-expressionunary-operator cast-expressionsizeof   unary-expressionsizeof   ( type-name )unary-operator: one of* & ­ ! ~ +Except as noted, the operand of a unary-operator must have arithmetic type.LBL="7.3.1" HELPID=""Address-of and Indirection OperatorsThe unary * operator means "indirection"; the cast-expression must be a pointer, and the result is either an lvalue referring to the object to which the expression points or a function designator.  If the type of the expression is pointer to <type>, the type of the result is <type>.               ID="chap.0748"ID="chap.0749"ID="chap.0750"ID="chap.0751"ID="chap.0752"The operand of the unary & operator can be either a function designator or an lvalue that designates an object.  If it is an lvalue, the object it designates cannot be a bitfield, and it cannot be declared with the storage-class register.  The result of the unary & operator is a pointer to the object or function referred to by the lvalue or function designator.  If the type of the lvalue is <type>, the type of the result is pointer to <type>.LBL="7.3.2" HELPID=""Unary + and   ­ OperatorsThe result of the unary ­ operator is the negative of its operand.  The integral promotions are performed on the operand, and the result has the promoted type and the value of the negative of the operand.  Negation of unsigned quantities is analogous to subtracting the value from 2n, where n is the number of bits in the promoted type.             ID="chap.0753"ID="chap.0754"ID="chap.0755"ID="chap.0756"ID="chap.0757"The unary + operator exists only in ANSI C.  The integral promotions are used to convert the operand.  The result has the promoted type and the value of the operand.LBL="7.3.3" HELPID=""Unary !   and   ~   OperatorsThe result of the logical negation operator ! is one if the value of its operand is zero, zero if the value of its operand is nonzero.  The type of the result is int.  The logical negation operator is applicable to any arithmetic type and to pointers.         ID="chap.0758"ID="chap.0759"ID="chap.0760"ID="chap.0761"The ~   operator yields the one's complement of its operand.  The usual arithmetic conversions are performed.  The type of the operand must be integral.LBL="7.3.4" HELPID=""Prefix ++ and ­ ­ OperatorsThe prefix operators ++ and ­ ­ increment and decrement their operands.++ unary-expression­ ­ unary-expressionThe object referred to by the modifiable lvalue operand of prefix ++ is incremented.  The value is the new value of the operand but is not an lvalue.  The expression ++x is equivalent to   x += 1.  See the discussions in IDREF="48455" TYPE="TITLE"Section 7.6, "Additive Operators,"
 and IDREF="65675" TYPE="TITLE"Section 7.16, "Assignment Operators,"
 for information on conversions.                ID="chap.0762"ID="chap.0763"ID="chap.0764"ID="chap.0765"ID="chap.0766"ID="chap.0767"The prefix ­ ­ decrements its lvalue operand in the same manner prefix ++ increments.LBL="7.3.5" HELPID=""The sizeof Unary OperatorThe sizeof operator yields the size in bytes of its operand.  The size of a char is 1 (one).  Its major use is in communication with routines like storage allocators and I/O systems.   ID="chap.0768"ID="chap.0769"sizeof unary-expressionsizeof ( type-name )The operand of sizeof can not have function or incomplete type, or be an lvalue that denotes a bitfield.  It can be an object or a parenthesized type name.  In traditional C, the type of the result is unsigned.  In ANSI C, the type of the result is size_t, which is defined in <stddef.h> as unsigned.  The result is a constant and can be used anywhere a constant is required.    ID="chap.0770"ID="chap.0771"When applied to an array, sizeof returns the total number of bytes in the array.  The size is determined from the declaration of the object in the unary-expression.  The sizeof operator can also be applied to a parenthesized type-name.  In that case it yields the size in bytes of an object of the indicated type.When sizeof is applied to an aggregate, the result includes space used for padding, if any.LBL="7.4" HELPID=""ID="35206"Cast OperatorsA cast-expression preceded by a parenthesized type-name causes conversion of the value of the expression to the indicated type.  This construction is called a cast.  type-names are discussed in IDREF="13939" TYPE="TITLE"Section 8.8
.    ID="chap.0772"ID="chap.0773"cast-expression:unary-expression( type-name ) cast-expressionThe type-name specifies scalar type or void, and the operand has scalar type.  Since a cast does not yield an lvalue, the effect of qualifiers attached to the type-name is inconsequential.When an arithmetic value is cast to a pointer, its underlying bit pattern does not change.  The resulting pointer might not be aligned as required by its data type.LBL="7.5" HELPID=""ID="31930"Multiplicative OperatorsThe multiplicative operators   *, /,  and % group from left to right.  The usual arithmetic conversions are performed.                     ID="chap.0774"ID="chap.0775"ID="chap.0776"ID="chap.0777"ID="chap.0778"ID="chap.0779"ID="chap.0780"ID="chap.0781"multiplicative expression:cast-expressionmultiplicative-expression * cast-expressionmultiplicative-expression   / cast-expressionmultiplicative-expression % cast-expressionOperands of   * and   / must have arithmetic type.  Operands of % must have integral type.The binary * operator indicates multiplication, and its result is the product of the operands.  The binary   / operator indicates division of the first operator (dividend) by the second (divisor).  If the operands are integral and the value of the divisor is zero, SIGTRAP is signalled.  Integral division results in the integer quotient whose magnitude is less than or equal to that of the true quotient, and with the same sign.The binary % operator yields the remainder from the division of the first expression (dividend) by the second (divisor).   The operands must be integral.  The remainder has the same sign as the dividend, so that the equality(dividend / divisor) * divisor + dividend % divisor == dividendis true when the divisor is nonzero.  If the value of the divisor is zero, SIGTRAP is signalled.LBL="7.6" HELPID=""ID="48455"Additive OperatorsThe additive operators   + and ­ group from left to right.  The usual arithmetic conversions are performed.             ID="chap.0782"ID="chap.0783"ID="chap.0784"ID="chap.0785"ID="chap.0786"additive-expression:multiplicative-expressionadditive-expression   + multiplicative-expressionadditive-expression   ­ multiplicative-expressionIn addition to arithmetic types, the following type combinations are acceptable for additive-expressions:For addition, one operand is a pointer to an object type and the other operand is an integral type.For subtraction:Both operands are pointers to qualified or unqualified versions of compatible object types.The left operand is a pointer to an object type, and the right operand has integral type.The result of the + operator is the sum of the operands.  The result of the ­ operator is the difference of the operands.  When an operand of integral type is added to or subtracted from a pointer to an object type, the integral operand is first converted to an address offset by multiplying it by the length of the object to which the pointer points.  The result is a pointer of the same type as the original pointer.Suppose a has type array of <object>, and p has type pointer to <object> and points to the initial element of a.  Then the result of  pname='plusmn' font=symbol charset=fontspecific code=177 
	TeX='\pm ' descr='[plusmn]'n,   where   n is an integral operand, is the same as &a [name='plusmn' font=symbol charset=fontspecific code=177 
	TeX='\pm ' descr='[plusmn]'n].If two pointers to objects of the same type are subtracted, the result is converted (by division by the length of the object) to an integral quantity representing the number of objects separating them.  Unless the pointers point to objects in the same array, the result is undefined.  The actual type of the result is int in traditional C, and ptrdiff_t (defined in <stddef.h> as int) in ANSI C.    ID="chap.0787"ID="chap.0788"LBL="7.7" HELPID=""Shift OperatorsThe shift operators << and   >> group from left to right.  Each operand must be of an integral type.  The integral promotions are performed on each operand.  The type of the result is that of the promoted left operand.  The result is undefined if the right operand is negative or greater than or equal to the length in bits of the promoted left operand.                ID="chap.0789"ID="chap.0790"ID="chap.0791"ID="chap.0792"ID="chap.0793"ID="chap.0794"shift-expression:additive-expressionshift-expression << additive-expressionshift-expression >> additive-expression The value of E1<<E2 is E1 (interpreted as a bit pattern) left-shifted E2 bits.  Vacated bits are filled with zeros.  The value of   E1>>E2 is E1 right-shifted E2 bit positions.  Vacated bits are filled with zeros if E1 is unsigned, or if it's signed and its value is nonnegative.  If E1 is signed and its value is negative, vacated bits are filled with ones. LBL="7.8" HELPID=""ID="83059"Relational OperatorsThe relational operators group from left to right.             ID="chap.0795"ID="chap.0796"ID="chap.0797"ID="chap.0798"ID="chap.0799"ID="chap.07100"relational-expression:shift-expressionrelational-expression < shift-expressionrelational-expression > shift-expressionrelational-expression   <= shift-expressionrelational-expression >= shift-expression The operators < (less than), > (greater than), <= (less than or equal to), and   >= (greater than or equal to) all yield a result of type int with the value 0 if the specified relation is false and one if it is true.The operands must beboth arithmetic, in which case the usual arithmetic conversions are performed on them.both pointers to qualified or unqualified versions of compatible object types, orboth pointers to qualified or unqualified versions of compatible incomplete types.When two pointers are compared, the result depends on the relative locations in the address space of the pointed-to objects.  Pointer comparison is portable only when the pointers point to objects in the same aggregate.  In particular, no correlation is guaranteed between the order in which objects are declared and their resulting addresses.  LBL="7.9" HELPID=""Equality OperatorsThe   == (equal to) and the   != (not equal to) operators are exactly analogous to the relational operators except for their lower precedence.  (Thus a<b == c<d is 1 whenever a<b and c<d have the same truth value.) equality-expression:relational-expressionequality-expression == relational-expressionequality-expression != relational-expression           ID="chap.07101"ID="chap.07102"ID="chap.07103"ID="chap.07104"The operands must beboth arithmetic, in which case the usual arithmetic conversions are performed on them;both pointers to qualified or unqualified versions of compatible types;a pointer to an object or incomplete type, and a pointer to qualified or unqualified void type; ora pointer and a null pointer constant.The semantics detailed in IDREF="83059" TYPE="TITLE"Section 7.8, "Relational Operators,"
 apply if the operands have types suitable for those operators.  Combinations of other operands have the behavior detailed below:Two null pointers to object or incomplete types are equal.  If two pointers to such types are equal, they either are null, point to the same object, or point to one object beyond the end of an array of such objects.Two pointers to the same function are equal, as are two null function pointers.  Two function pointers that are equal either are both null or point to the same function.LBL="7.10" HELPID=""Bitwise AND OperatorEach operand must have integral type.  The usual arithmetic conversions are performed.  The result is the bitwise AND function of the operands, that is, each bit in the result is zero unless the corresponding bit in each of the two operands is one.              ID="chap.07105"ID="chap.07106"ID="chap.07107"ID="chap.07108"ID="chap.07109"ID="chap.07110"AND-expression:equality-expressionAND-expression & equality-expression LBL="7.11" HELPID=""Bitwise Exclusive OR OperatorEach operand must have integral type.  The usual arithmetic conversions are performed.  The result has type int or long long, and the value is the bitwise exclusive OR function of the operands.  That is, each bit in the result is zero unless the corresponding bit in one of the operands is one, and the corresponding bit in the other operand is zero. exclusive-OR-expression:AND-expressionexclusive-OR-expression ^ AND-expression               ID="chap.07111"ID="chap.07112"ID="chap.07113"ID="chap.07114"ID="chap.07115"ID="chap.07116"LBL="7.12" HELPID=""Bitwise Inclusive OR OperatorEach operand must have integral type.  The usual arithmetic conversions are performed.  inclusive-OR-expression:exclusive-OR-expressioninclusive-OR-expression | exclusive-OR-expression The result has type int or long long, and the value is the bitwise inclusive OR function of the operands.  That is, each bit in the result is zero unless the corresponding bit in at least one of the operands is one.             ID="chap.07117"ID="chap.07118"ID="chap.07119"ID="chap.07120"ID="chap.07121"ID="chap.07122"LBL="7.13" HELPID=""Logical AND OperatorThe && operator groups left to right.  logical-AND-expression:inclusive-OR-expressionlogical-AND-expression && inclusive-OR-expression Each of the operands must have scalar type.  The result has type int and value one if neither of its operands evaluates to zero.  Otherwise it has value zero.Unlike &, && guarantees left to right evaluation; moreover, the second operand is not evaluated if the first operand evaluates to zero.  There is a sequence point after the evaluation of the first operand.       ID="chap.07123"ID="chap.07124"ID="chap.07125"ID="chap.07126"LBL="7.14" HELPID=""Logical OR OperatorThe || operator groups left to right.           ID="chap.07127"ID="chap.07128"ID="chap.07129"ID="chap.07130"logical-OR-expression:logical-AND-expressionlogical-OR-expression || logical-AND-expression Each of the operands must have scalar type.  The result has type int and value one if either of its operands evaluates to one.  Otherwise it has value zero.Unlike |, || guarantees left to right evaluation; moreover, the second operand is not evaluated unless the first operand evaluates to zero.  There is a sequence point after the evaluation of the first operand.LBL="7.15" HELPID=""Conditional OperatorConditional expressions group from right to left.      ID="chap.07131"ID="chap.07132"ID="chap.07133"conditional-expression:logical-OR-expressionlogical-OR-expression ? expression   : conditional-expression The type of the first operand must be scalar.  Only certain combinations of types are allowed for the second and third operands.  These combinations are listed below, along with the type of result the combination yields.Both can be arithmetic types.  In this case, the usual arithmetic conversions are performed on them to derive a common type, which is the type of the result.Both are compatible structure or union objects.  The result has that type.Both are void.  The type of the result is void.One is a pointer, and the other a null pointer constant.  The type of the result is the type of the nonconstant pointer.One is a pointer to void, and the other is a pointer to an object or incomplete type.  The second operand is converted to a pointer to void, and this is the type of the result.Both are pointers to qualified or unqualified versions of compatible types.  The result has a type compatible with each, qualified with all the qualifiers of the types pointed to by both operands.Evaluation of the conditional operator proceeds as follows:The first expression is evaluated, after which a sequence point occurs.   If the value of the first expression is nonzero, the result is the value of the second operand; otherwise it is that of third operand.  Only one of the second and third operands is evaluated. LBL="7.16" HELPID=""ID="65675"Assignment OperatorsAll assignment operators group from right to left.ID="chap.07134"ID="chap.07135"assignment-expression:conditional-expressionunary-expression assignment-operator assignment-expressionassignment operator: one of=  *=  /=  %=  +=  -=   <<=  >>=  &=  ^=  |= Assignment operators require a modifiable lvalue as their left operand.  The type of an assignment expression is that of its unqualified left operand.  The result is not an lvalue.  Its value is the value stored in the left operand after the assignment, but the actual update of the stored value might be delayed until the next sequence point.The order of evaluation of the operands is unspecified.LBL="7.16.1" HELPID=""Assignment using = (Simple Assignment)The operands permissible in simple assignment must obey one of the following:   ID="chap.07136"ID="chap.07137"ID="chap.07138"ID="chap.07139"Both have arithmetic type or are compatible structure or union types.Both are pointers, and the type pointed to by the left has all of the qualifiers of the type pointed to by the right.One is a pointer to an object or incomplete type, and the other is a pointer to void.  Again, the type pointed to by the left must have all of the qualifiers of the type pointed to by the right.The left operand is a pointer and the right a null pointer constant.In simple assignment, the value of the right operand is converted to the type of the assignment expression and replaces the value of the object referred to by the left operand.  If the value being stored is accessed by another object that overlaps it, the behavior is undefined unless the overlap is exact and the types of the two objects are compatible.LBL="7.16.2" HELPID=""Compound AssignmentFor the operators += and -=, either both have arithmetic types or the left operand is a pointer and the right operand integral.    In the latter case, the right operand is converted as explained in IDREF="48455" TYPE="TITLE"Section 7.6, "Additive Operators."
  For all other operators, each operand must have arithmetic type consistent with those allowed for the corresponding binary operator.The expression   E1 op = E2   is equivalent to the expression   E1 = E1 op E2, except that in the former, E1 is evaluated only once.ID="chap.07140"ID="chap.07141"ID="chap.07142"ID="chap.07143"ID="chap.07144"ID="chap.07145"ID="chap.07146"LBL="7.17" HELPID=""ID="11638"Comma OperatorA pair of expressions separated by a comma is evaluated left to right, and the value of the left expression is discarded.  expression:assignment-expressionexpression , assignment-expression The type and value of the result are the type and value of the right operand.  This operator groups left to right.  In contexts where "comma" is given a special meaning, the comma operator as described in this section can appear only in parentheses.  Two such contexts are lists of actual arguments to functions (described in IDREF="19257" TYPE="TITLE"Section 7.1, "Primary Expressions"
) and lists of initializers (see IDREF="65471" TYPE="TITLE"Section 8.11, "Initialization"
).  For example,f(a, (t=3, t+2), c) has three arguments, the second of which has the value 5.      ID="chap.07147"ID="chap.07148"ID="chap.07149"LBL="7.18" HELPID=""ID="72985"Constant ExpressionsA constant expression can be used any place a constant can be used.        ID="chap.07150"constant-expression:conditional-expressionIt cannot contain assignment, increment, decrement, function-call, or comma operators.  It must evaluate to a constant that is in the range of representable values for its type.  Otherwise, the semantic rules for the evaluation of nonconstant expressions apply.Constant expressions are separated into three classes:An integral constant expression has integral type and is restricted to operands that are integral constants, sizeof expressions, and floating constants that are the immediate operands of integral casts.    ID="chap.07151"ID="chap.07152"An arithmetic constant expression has arithmetic type and is restricted to operands that are arithmetic constants, and sizeof expressions.  Cast expressions in arithmetic constant expressions can convert only between arithmetic types. ID="chap.07153"ID="chap.07154"An   address constant is a pointer to an lvalue designating an object of static storage duration, or a pointer to a function designator.  It can be created explicitly or implicitly, as long as no attempt is made to access an object value. ID="chap.07155"ID="chap.07156"Either address or arithmetic constant expressions can be used in initializers.  In addition, initializers can contain null pointer constants and address constants (for object types), and plus or minus integral constant expressions.LBL="8"ID="87922"DeclarationsA declaration specifies the interpretation given to a set of identifiers. Declarations have the form declaration:declaration-specifiers init-declarator-listopt ; The   init-declarator-list is a comma-separated sequence of declarators, each of which can have an initializer. In ANSI C, theID="chap.081"   init-declarator-list can also contain additional type information:init-declarator-list:init-declaratorinit-declarator-list , init-declaratorinit-declarator:declaratordeclarator   = initializer The declarators in the init-declarator-list contain the identifiers being declared.  The declaration-specifiers consist of a sequence of specifiers that determine the linkage, storage duration, and part of the type of the identifiers indicated by the declarator.    declaration-specifiers:storage-class-specifier declaration-specifiersopttype-specifier declaration-specifiersopttype-qualifier declaration-specifiersoptIf an identifier that is not a tag has no linkage (see IDREF="39439" TYPE="TITLE"Section 5.1, "Disambiguating Names"
), at most one declaration of the identifier can appear in the same scope and name space.  The type of an object that has no linkage must be complete by the end of its declarator or initializer.  Multiple declarations of tags and ordinary identifiers with external or internal linkage can appear in the same scope so long as they specify compatible types. ID="chap.082"In traditional C, at most one declaration of an identifier with internal linkage can appear in the same scope and name space, unless it is a tag.In ANSI C, a declaration must declare at least one of these: a declaratora tagthe members of an enumerationA declaration might reserve storage for the entities specified in the declarators.  Such a declaration is called a definition.   (Function definitions have a different syntax and are discussed in 
IDREF="95935" TYPE="TEXT"IDREF="95935" TYPE="TITLE"Section 8.7.4, "Function Declarators and Prototypes,"
 and IDREF="42146" TYPE="TITLE"Chapter 10, "External Definitions."
)     ID="chap.083"ID="chap.084"LBL="8.1" HELPID=""Storage-class SpecifiersThe   storage-class-specifier indicates linkage and storage duration.  These attributes are discussed in IDREF="39439" TYPE="TITLE"Section 5.1
.     ID="chap.085"ID="chap.086"ID="chap.087"storage-class-specifier:autostaticexternregistertypedef The typedef specifier does not reserve storage and is called a storage class specifier only for syntactic convenience.  See IDREF="18668" TYPE="TITLE"Section 8.10
 on typedef for more information. ID="chap.088"At most one storage-class specifier can appear in a declaration.  If the storage-class-specifier is missing from a declaration, it is assumed to be extern unless the declaration is of an object and occurs inside a function, in which case it is assumed to be auto. (See IDREF="40124" TYPE="TITLE"Section 3.2.3, "Changes in the Linkage of Identifiers,"
 for further details.)       ID="chap.089"ID="chap.0810"Identifiers  declared within a function with the storage class   extern must have an external definition (see IDREF="42146" TYPE="TITLE"Chapter 10, "External Definitions"
) somewhere outside the function in which they are declared.  Identifiers declared with the storage class static have static storage duration and either internal linkage (if declared outside a function) or no linkage (if declared inside a function).  If the identifiers are initialized, the initialization is performed once prior to the beginning of execution.  If no explicit initialization is performed, static objects are implicitly initialized to zero.       ID="chap.0811"ID="chap.0812"ID="chap.0813"ID="chap.0814"A register declaration is an auto declaration, with a hint to the compiler that the objects declared will be heavily used.  Whether the object will actually be placed in fast storage is implementation-defined.  You cannot take the address of any part of an object declared with the register specifier.      ID="chap.0815"ID="chap.0816"ID="chap.0817"ID="chap.0818"LBL="8.2" HELPID=""Type SpecifiersType specifiers are:type-specifier:ID="chap.0819"struct-or-union-specifiertypedef-nameenum-specifierID="chap.0820"charID="chap.0821"shortID="chap.0822"intID="chap.0823"longID="chap.0824"signedID="chap.0825"unsignedID="chap.0826"floatID="chap.0827"doubleID="chap.0828"voidThe following list enumerates all valid combinations of type specifiers. These combinations are organized into a number of sets, each set comprising one line.  The arrangement of the type specifiers appearing in any combination below can be altered without effect.  The type specifiers in each set are equivalent in all implementations.ID="chap.0829"void   char   signed char unsigned char short, signed short, short int, or signed short int unsigned short, or   unsigned short int int, signed, signed int, or no type specifiers unsigned, or unsigned int long, signed long, long int, or signed long int long long, signed long long, long long int, or signed long long intunsigned long long, or unsigned long long intfloat   double   long double In traditional C, the type long float is allowed and equivalent to double.  Its use should be discouraged and elicits a warning if you're not in ­cckr mode.  Use of the type long double is not recommended.long long is not a valid ANSI C type, so a warning appears for every occurrence of "long long" in the source program text in ­ansi and ­ansiposix modes.   Specifiers for structures, unions, and enumerations are discussed in IDREF="82788" TYPE="TITLE"Section 8.3
 and IDREF="30981" TYPE="TITLE"Section 8.5
.  Declarations with typedefID="chap.0830" names are discussed in IDREF="18668" TYPE="TITLE"Section 8.10
.  LBL="8.3" HELPID=""ID="82788"Structure and Union DeclarationsA structure is an object consisting of a sequence of named members.  Each member can have any type.  A union is an object that can, at a given time, contain any one of several members.  Structure and union specifiers have the same form.                 ID="chap.0831"ID="chap.0832"ID="chap.0833"ID="chap.0834"ID="chap.0835"ID="chap.0836"struct-or-union-specifier:struct-or-union { struct-decl-list }struct-or-union identifier { struct-decl-list }struct-or-union identifierstruct-or-union:structunion The   struct-decl-list is a sequence of declarations for the members of the structure or union:struct-decl-list:struct-declarationstruct-decl-list struct-declaration struct-declaration:specifier-qualifier-list struct-declarator-list ; struct-declarator-list:struct-declaratorstruct-declarator-list , struct-declarator In the usual case, a struct-declarator is just a declarator for a member of a structure or union.  A structure member can also consist of a specified number of bits.  Such a member is also called a bitfield.  Its length, a non-negative constant expression, is separated from the field name by a colon.  Bitfields are discussed at the end of this section.  struct-declarator:declaratordeclarator : constant-expression: constant-expression A struct or union cannot contain a member with incomplete or function type, or that is an instance of itself.  It can, however, contain a member that is a pointer to an instance of itself.    ID="chap.0837"ID="chap.0838"Within a structure, the objects declared have addresses that increase as the declarations are read left to right.  Each non-field member of a structure begins on an addressing boundary appropriate to its type; therefore, there might be unnamed holes in a structure.A union can be thought of as a structure whose members all begin at offset 0 and whose size is sufficient to contain any of its members.  At most, one of the members can be stored in a union at any time.A structure or union specifier of the second form, that is, one ofstruct identifier { struct-decl-list }union identifier { struct-decl-list } declares the identifier to be the structure tag (or union tag) of the structure specified by the list.  A subsequent declaration can then use the third form of specifier, one ofstruct identifierunion identifierStructure tags allow definition of self-referential structures.  Structure tags also permit the long part of the declaration to be given once and used several times.The third form of a structure or union specifier can be used prior to a declaration that gives the complete specification of the structure or union in situations in which the size of the structure or union is unnecessary.  The size is unnecessary in two situations: when a pointer to a structure or union is being declared and when a typedef name is declared to be a synonym for a structure or union.  This, for example, allows the declaration of a pair of structures that contain pointers to each other. ID="chap.0839"The names of members of each struct or union have their own name space, and do not conflict with each other or with ordinary variables.  A particular member name cannot be used twice in the same structure, but it can be used in several different structures in the same scope.  Names that are used for tags reside in a single name space.  They do not conflict with other names or with names used for tags in an enclosing scope.  This tag name space, however, consists of tag names used for all struct, union or enum declarations.  Thus the tag name of an enum might conflict with the tag name of a struct in the same scope.  (See IDREF="39439" TYPE="TITLE"Section 5.1, "Disambiguating Names."
) ID="chap.0840"A simple but important example of a structure declaration is the following binary tree structure: struct tnode {
 char tword[20];
 int count;
 struct tnode *left;
 struct tnode *right; 
}; This structure contains an array of 20 characters, an integer, and two pointers to instances of itself.  Once this declaration has been given, the declarationstruct tnode s, *sp; declares s to be a structure of the given sort and sp to be a pointer to a structure of the given sort.  With these declarations, the expression sp->count refers to the count field of the structure to which sp points; s.left refers to the left subtree pointer of the structure s; and s.right->tword[0] refers to the first character of the tword member of the right subtree of s. LBL="8.4" HELPID=""BitfieldsBitfields should be of type int, signed int, or unsigned int in strict ANSI C mode.  We allow bitfields of any integral type, but warn for non-int types in ­ansi and ­ansiposix modes.The default type of field members is int, but whether it is signed or unsigned int is defined by the implementation.  It is thus wise to specify the signedness of bitfields when they are declared.  In this implementation, the default type of a bitfield is signed. ID="chap.0841"The   constant-expression that denotes the width of the bitfield must have a value no greater than the width, in bits, of the type of the bitfield.  An implementation can allocate any addressable storage unit (referred to in this discussion as simply a "unit") large enough to hold a bitfield.  If an adjacent bitfield will not fit in the remainder of the unit, whether a unit is allocated for it or bitfields are allowed to span units is implementation-defined.  The ordering of the bits within a unit is also implementation-defined.A bitfield with no declarator, just a colon and a width, indicates an unnamed field useful for padding.  As a special case, a field with a width of zero, which cannot have a declarator, specifies alignment of the next field at the next unit boundary.These implementation-defined characteristics make the use of bitfields inherently unportable, particularly if they are used in situationsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in a union, for examplename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' where the underlying object might be accessed by another data type.In this implementation, the size of a unit for bitfields is equal to the size of the type of the bitfield that started the unit. The first bitfield encountered in a struct is not necessarily allocated on a unit boundary and is packed into the current unit if possible.  A bitfield cannot span a unit boundary. Bits for bitfields are allocated from left (most significant) to right.  A new unit is allocated when the alignment of the type of the next bitfield differs from the alignment of the current unit, even if the number of bits in the next bitfield would fit into the current unit (for example, if the current unit has char alignment and the next bitfield has type int, then a new int-sized unit will be allocated).As an example, in this implementation the structurestruct {
     char c;
     int k:9,
          :12;
     signed int j:5;
} s;is two units in size.  The first unit consists of the char   c in its eight bits.  The alignment of an int differs from that of a char, hence the next 24 bits are padding, followed by an int unit.  The (signed)   int bitfield k will be in the most significant 9 bits of the int unit, followed by 12 pad bits and the 5 bits of the signed int   j.  The size of this struct is eight bytes.There are no arrays of bitfields.  Since the address-of operator, &, cannot be applied to fields, there are no pointers to fields.ID="chap.0842"ID="chap.0843"LBL="8.5" HELPID=""ID="30981"Enumeration DeclarationsEnumeration variables and constants have integral type.   ID="chap.0844"ID="chap.0845"ID="chap.0846"enum-specifier:enum { enum-list }enum identifier { enum-list }enum identifierenum-list:enumeratorenum-list , enumeratorenumerator:identifieridentifier = constant-expression The identifiers in an enum-list are declared as int constants and can appear wherever such constants are allowed.  If no enumerators with   = appear, then the values of the corresponding constants begin at 0 and increase by 1 as the declaration is read from left to right.  An enumerator with = gives the associated identifier the value indicated; subsequent identifiers continue the progression from the assigned value.  Note that the use of = might result in multiple enumeration constants having the same integral value, even though they are declared in the same enumeration declaration.Enumerators are in the ordinary identifiers name space (see IDREF="16739" TYPE="TITLE"Section 5.1.2
).  Thus, an identifier used as an enumerator might conflict with identifiers used for objects, functions, and user-defined types in the same scope.The role of the identifier in the enum-specifier is entirely analogous to that of the structure tag in a struct-specifier; it names a particular enumeration.  For example, enum color { chartreuse, burgundy, claret=20, winedark }; 
name='hellip' font=symbol charset=fontspecific code=188  
enum color *cp, col; 
name='hellip' font=symbol charset=fontspecific code=188  
col = claret; 
cp = &col; 
name='hellip' font=symbol charset=fontspecific code=188  
if (*cp == burgundy) name='hellip' font=symbol charset=fontspecific code=188  makes color the enumeration-tag of a type describing various colors, and then declares cp as a pointer to an object of that type and col as an object of that type.  The possible values are drawn from the set {0,1,20,21}.  The tags of enumeration declarations are members of the single tag name space, and thus must be distinct from tags of struct and union declarations.LBL="8.6" HELPID=""ID="22645"Type QualifiersType qualifiers are:type-qualifier:ID="chap.0847"constID="chap.0848"volatile The same type qualifier cannot appear more than once in the same specifier list either directly or indirectly (through typedefs).   The value of an object declared with the ID="chap.0849"ID="chap.0850"ID="chap.0851"const type qualifier is constant.  It cannot be modified, although it can be initialized following the same rules as the initialization of any other object.  (See the discussion in IDREF="65471" TYPE="TITLE"Section 8.11, "Initialization."
)  Implementations are free to allocate const objects, which are not also declared volatile, in read-only storage.       ID="chap.0852"ID="chap.0853"ID="chap.0854"ID="chap.0855"An object declared with the volatile type qualifier might be accessed in unknown ways or have unknown side effects.  For example, a volatile object might be a special hardware register.  Expressions referring to objects qualified as volatile must be evaluated strictly according to the semantics.  When volatile objects are involved, an implementation is not free to perform optimizations that would otherwise be valid.  At each sequence point, the value of all volatile objects must agree with that specified by the semantics.If an array is specified with type qualifiers, the qualifiers are applied to the elements of the array.  If a struct or union is qualified, the qualification applies to each member.Two qualified types are compatible if they are identically qualified versions of compatible types.  The order of qualifiers in a list has no effect on their semantics.The syntax of pointers allows the specification of qualifiers that affect either the pointer itself or the underlying object.  Qualified pointers are covered in IDREF="47299" TYPE="TITLE"Section 8.7.2, "Pointer Declarators."LBL="8.7" HELPID=""ID="17758"DeclaratorsDeclarators have the syntax: declarator:pointeropt direct-declaratordirect-declarator:identifier( declarator )direct-declarator (parameter-type-listopt)direct-declarator (identifier-listopt)direct-declarator [ constant-expressionopt   ] Portions of the list above are reproduced in the sections following, along with expansions of their constituent parts.  The grouping is the same as in expressions.  ID="chap.0856"LBL="8.7.1" HELPID=""Meaning of DeclaratorsEach declarator is an assertion that when a construction of the same form as the declarator appears in an expression, it designates a function or object with the scope, storage duration, and type indicated by the declaration.ID="chap.0857"Each declarator contains exactly one identifier; it is this identifier that is declared.  If, in the declarationT D1 D1 is simply an identifier, then the type of the identifier is T.  If D1 has the form (D) then the underlying identifier has the type specified by the declaration T   D.  Thus, a declarator in parentheses is identical to the unparenthesized declarator.  The binding of complex declarators can, however, be altered by parentheses.  LBL="8.7.2" HELPID=""ID="47299"Pointer DeclaratorsPointer declarators have the form    ID="chap.0858"ID="chap.0859"pointer:* type-qualifier-listopt* type-qualifier-listopt pointerSuppose that in the declaration T D1 the identifier has type ".. T ", where the ".." is empty if D1 is just a plain identifier (so that the type of x in "int x" is just int).  Then if D1 has the form *type-qualifier-listopt   D, the type of the contained identifier is .. (possibly-qualified) pointer to T. LBL="" HELPID=""Qualifiers and PointersIt is important to be aware of the distinction between a qualified pointer to <type> and a pointer to <qualified type>.  In the declarations    ID="chap.0860"ID="chap.0861"const long *ptr_to_const; 
long * const const_ptr; 
volatile int * const const_ptr_to_volatile; ptr_to_const is a pointer to const long.  Thus, the long pointed to cannot be modified by the pointer.  The pointer itself, however, can be altered.  const_ptr can be used to modify the long that it points to, but the pointer itself cannot be modified.  In the last example, const_ptr_to_volatile is a constant pointer to a volatile int and can be used to modify it.  The pointer itself, however, cannot be modified.  LBL="8.7.3" HELPID=""Array DeclaratorsIf D1 has the form ID="chap.0862"ID="chap.0863"D[constant-expressionopt] then the contained identifier has type ".. array of T."  The expression enclosed in square brackets, if it exists, must be an integral constant expression whose value is greater than zero.  (See IDREF="72985" TYPE="TITLE"Section 7.18, "Constant Expressions."
) When several "array of" specifications are adjacent, a multi-dimensional array is created; the constant expressions that specify the bounds of the arrays can be missing only for the first member of the sequence.The absence of the first array dimension is allowed if the array is external and the actual definition, which allocates storage, is given elsewhere, or if the declarator is followed by initialization.  In the latter case the size is calculated from the number of elements supplied.In order for two array types to be compatible, their element types must be compatible.  In addition, if both of their size specifications are present, they must have the same value.An array can be constructed from one of the basic types, from a pointer, from a structure or union, or from another array (to generate a multi-dimensional array).As an example, float fa[17], *afp[17]; declares an array of float numbers and an array of pointers to float numbers.  Finally, static int x3d[3][5][7]; declares a static three-dimensional array of integers, with rank 3x5x7.  In complete detail, x3d is an array of three items; each item is an array of five items; each of the latter items is an array of seven integers.  Any of the expressions x3d, x3d[i], x3d[i][j], x3d[i][j][k] can reasonably appear in an expression.  The first three have type "array" and the last has type int.   LBL="8.7.4" HELPID=""ID="95935"Function Declarators and PrototypesThe syntax for function declarators is       ID="chap.0864"ID="chap.0865"ID="chap.0866"direct-declarator ( parameter-type-listopt )direct-declarator ( identifier-listopt )parameter-type-list:parameter-listparameter-list , name='hellip' font=symbol charset=fontspecific code=188parameter-list:parameter-declarationparameter-list , parameter-declarationparameter-declaration:declaration-specifiers declaratordeclaration-specifiers abstract-declaratoroptidentifier-list:identifieridentifier-list , identifier Function declarators cannot specify a function or array type as the return type.  In addition, the only storage-class specifier that can be used in a parameter declaration is register.  If, in the declaration T D1, D1 has the form ID="chap.0867"D(parameter-type-listopt) or D(identifier-listopt) then the contained identifier has the type   .. function returning T, and is possibly a prototype, as discussed below.A parameter-type-list declares the types of, and can declare identifiers for, the formal parameters of a function.  The absence of a parameter-type-list indicates that no typing information is given for the function.  A parameter-type-list consisting only of the keyword voidID="chap.0868" indicates that the function takes zero parameters.  If the parameter-type-list ends in ellipses (name='hellip' font=symbol charset=fontspecific code=188), the function can have one or more additional arguments of variable or unknown type.  (See <stdarg.h>.) ID="chap.0869"The semantics of a function declarator is determined by its form and context.  The possible combinations of these are as follows: The declarator is not part of the function definition.  The function is defined elsewhere.  In this case, the declarator cannot have an identifier-list.    If the   parameter-type-list is absent, the declarator is an old-style function declaration.  Only the return type is significant.  If the parameter-type-list is present, the declarator is a   function prototype.  The declarator is part of the function definition:  If the declarator has an   identifier-list, the declarator is an old-style function definition.  Only the return type is significant.  If the declarator has a parameter-type-list, the definition is in prototype form. If no previous declaration for this function has been encountered, a function prototype is created for it that has file scope.  If two declarations (one of which can be a definition) of the same function in the same scope are encountered, they must match, both in type of return value and in parameter-type-list.  If one and only one of the declarations has a parameter-type-list, the behavior varies between ANSI C and Traditional C, as described below.In traditional C, the function declaration that has the parameter-type-list is used as the "true" declaration.  This function prototype remains in-scope.In ANSI C, if the type of any parameter declared in the parameter-type-list is other than that which would be derived using the default argument promotions, an error is posted.  Otherwise, a warning is posted and the function prototype remains in scope.In all cases, the type of the return value of duplicate declarations of the same function must match, as must the use of ellipses.When a function is invoked for which a function prototype is in scope, an attempt is made to convert each actual parameter to the type of the corresponding formal parameter specified in the function prototype, superseding the   default argument promotions.  In particular, floats specified in the type list are not converted to double before the call.  If the list terminates with an ellipsis (...), only the parameters specified in the prototype have their types checked; additional parameters are converted according to the default argument promotions (discussed in IDREF="22645" TYPE="TITLE"Section 8.6
).  Otherwise, the number of parameters appearing in the parameter list at the point of call must agree in number with those in the function prototype.The following are two examples of function prototypes: double foo(int *first, float second, ... ); 
int *fip(int a, long l, int (*ff)(float)); The first prototype declares a function foo(), returning a double, that has (at least) two parameters: a pointer to an int and a float.  Further parameters can appear in a call of the function and are unspecified.  The default argument promotions will be applied to any unspecified arguments.  The second prototype declares a function fip(), that returns a pointer to an int.  The function fip() has three parameters:  an int, a long, and a pointer to a function returning an int that has a single (float) argument.    LBL="" HELPID=""Prototyped Functions SummarizedWhen a function call occurs, each argument is converted using the default argument promotions unless that argument has a type specified in a corresponding in-scope prototype for the function being called.  It is easy to envision situations that might prove disastrous if some calls to a function were made with a prototype in-scope and some were not.  Unexpected results could also occur if a function was called with different prototypes in-scope.  Thus, if a function is prototyped, it is extremely important to ensure that all invocations of the function use the prototype.    ID="chap.0870"ID="chap.0871"In addition to adding a new syntax for external declarations of functions, prototypes have added a new syntax for external definitions of functions.  This syntax is termed function prototype form.  It is highly important to define prototyped functions using a parameter-type-list rather than a simple identifier-list if the parameters are to be received as intended.In ANSI C, unless the function definition has a parameter-type-list, it will be assumed that arguments have been promoted according to the default argument promotions.  Specifically, an in-scope prototype for the function at the point of its definition has no effect on the type of the arguments that the function will expect.  In traditional C, if a function definition includes an identifier-list (that is, is not in function-prototype form) and a prototype for the function is in scope at the point of its definition, the arguments are assumed to be the types indicated in the function prototype.  The default argument promotions are not used.LBL="8.7.5" HELPID=""Restrictions on DeclaratorsNot all the possibilities allowed by the syntax of declarators are actually permitted.  The restrictions are as follows: functions cannot return arrays or functions although they can return pointers; there are no arrays of functions although there can be arrays of pointers to functions.  Likewise, a structure or union cannot contain a function, but it can contain a pointer to a function.ID="chap.0872"As an example, the declaration int i, *ip, f(), *fip(), (*pfi)(); declares an integer   i, a pointer ip to an integer, a function f returning an integer, a function fip returning a pointer to an integer, and a pointer pfi to a function, which returns an integer.  It is especially useful to compare the last two.  The binding of *fip() is *(fip()). The declaration suggests, and the same construction in an expression requires, the calling of a function fip, and then using indirection through the (pointer) result to yield an integer.  In the declarator (*pfi)(), the extra parentheses are necessary, as they are also in an expression, to indicate that indirection through a pointer to a function yields a function, which is then called; it returns an integer.LBL="8.8" HELPID=""ID="13939"Type NamesIn several contexts (for example, to specify type conversions explicitly by means of a cast, in a function prototype, and as an argument of sizeofID="chap.0873"), it is desired to supply the name of a data type.  This naming is accomplished using a "type name", whose syntax is a declaration for an object of that type without the identifier.  ID="chap.0874"type-name:specifier-qualifier-list abstract-declaratoropt   abstract-declarator:pointerpointeropt direct-abstract-declaratordirect-abstract-declarator:( abstract-declarator )direct-abstract-declaratoropt   [ constant-expressionopt   ]direct-abstract-declaratoropt   ( parameter-type-listopt   )The type-name created can be used as a synonym for the type that the omitted identifier would have.  (The syntax indicates that a set of empty parentheses in a type name will be interpreted as   function with no parameter information rather than as redundant parentheses surrounding the (omitted) identifier.)  For example, int 
int * 
int *[3] 
int (*)[3] 
int *(void) 
int (*)(float, ...)  
int (*[3])() name respectively the types "integer", "pointer to integer", "array of three pointers to integers", "pointer to an array of three integers", "function with zero arguments returning pointer to integer", "pointer to function returning an integer, that has a variable number of arguments the first of which is a float", and "array of three pointers to functions returning an integer for which no parameter type information is given".  LBL="8.9" HELPID=""Implicit DeclarationsIt is not always necessary to specify both the storage class and the type of identifiers in a declaration.  The storage class is supplied by the context in external definitions and in declarations of formal parameters and structure members.  Missing storage class specifiers appearing in declarations outside of functions are assumed to be ID="chap.0875"ID="chap.0876"extern (see IDREF="40124" TYPE="TITLE"Section 3.2.3
 for details); missing type specifiers in this context are assumed to be int.  In a declaration inside a function, if a type but no storage class is indicated, the identifier is assumed to be auto. An exception to the latter rule is made for functions because auto functions do not exist.  If the type of an identifier is function returning <type>, it is implicitly declared to be extern. In an expression, an identifier followed by a left parenthesis (indicating a function call) that is not already declared, is implicitly declared to be of type function returning int.  LBL="8.10" HELPID=""ID="18668"typedefDeclarations with the storage class specifier  typedef do not define storage.  typedef-name:ID="chap.0877"identifier Rather than becoming an object with the given type, an identifier appearing in a typedef declaration becomes a synonym for the type.  If, in the example int intarray[10]; the int type specifier were preceded with typedef, the identifier declared as an object would instead be declared as a synonym for the array type.  This can appear as typedef int intarray[10]; that could be used as if it were a basic type, for example intarray ia;After typedef int MILES, *KLICKSP; 
typedef struct { 
double re, im; 
} 
complex; the constructions MILES distance; 
extern KLICKSP metricp; 
complex z, *zp; are all legal declarations; the type of distance is int, that of metricp is pointer to int, and that of z is the specified structure.  The zp is a pointer to such a structure.The typedef does not introduce brand-new types, only synonyms for types that could be specified in another way.  Thus in the example above distance is considered to have exactly the same type as any other int object.  LBL="8.11" HELPID=""ID="65471"InitializationA declaration of an object or of an array of unknown size can specify an initial value for the identifier being declared.  The initializer is preceded by =  and consists of an expression or a list of values enclosed in nested braces.initializer:assignment-expression{ initializer-list }{ initializer-list , }initializer-list:initializerinitializer-list , initializer There cannot be more initializers than there are objects to be initialized.  All the expressions in an initializer for an object of static storage duration must be constant expressions (see IDREF="72985" TYPE="TITLE"Section 7.18
).  Objects with automatic storage duration can be initialized by arbitrary expressions involving constants and previously declared variables and functions, except for aggregate initialization, which can only include constant expressions.Identifiers declared with block scope and either external or internal linkage (that is, objects declared in a function with the storage-class specifier extern) cannot be initialized.  Variables of static storage duration that are not explicitly initialized are implicitly initialized to zero.  The value of automatic and register variables that are not explicitly initialized is undefined. When an initializer applies to a scalar (a pointer or an object of arithmetic type; see IDREF="54350" TYPE="TITLE"Section 5.2.3, "Derived Types"
), it consists of a single expression, perhaps in braces.  The initial value of the object is taken from the expression. With the exception of type qualifiers associated with the scalar, which are ignored during the initialization, the same conversions as for assignment are performed.LBL="8.11.1" HELPID=""Initialization of AggregatesIn traditional C it is illegal to initialize a union.  It is also illegal to initialize a struct of automatic storage duration.      ID="chap.0878"ID="chap.0879"ID="chap.0880"ID="chap.0881"ID="chap.0882"In ANSI C, objects that are struct or union types can be initialized, even if they have automatic storage duration.  unions  are initialized using the type of the first named element in their declaration.  The initializers used for a struct or union of automatic storage duration must be constant expressions.When the declared variable is a struct or array, the initializer consists of a brace-enclosed, comma-separated list of initializers for the members of the aggregate written in increasing subscript or member order.  If the aggregate contains subaggregates, this rule applies recursively to the members of the aggregate.  If the initializer of a subaggregate or union begins with a left brace, its initializers consist of all the initializers found between the left brace and the matching right brace.  If, however, the initializer does not begin with a left brace, then only enough elements from the list are taken to account for the members of the subaggregate; any remaining members are left to initialize the next member of the aggregate of which the current subaggregate is a part.  Within any brace-enclosed list, it is erroneous for there to be more initializers than members.  If there are fewer initializers in the list than there are members of the aggregate, then the aggregate is padded with zeros.Unnamed struct or union members are ignored during initialization.In ANSI C, if the variable is a union, the initializer consists of a brace-enclosed initializer for the first member of the union.  Initialization of struct or union objects with automatic storage duration can be abbreviated as a simple assignment of a compatible struct or union object.A final abbreviation allows a char array to be initialized by a string literal.  In this case successive characters of the string literal initialize the members of the array.In ANSI C, an array of wide characters (that is, whose element type is compatible with wchar_t) can be initialized with a wide string literal (see IDREF="33247" TYPE="TITLE"Section 4.5, "String Literals"
).  ID="chap.0883"ID="chap.0884"LBL="8.11.2" HELPID=""Examples of InitializationFor example, ID="chap.0885"int x[] = { 1, 3, 5 }; declares and initializes x as a one-dimensional array that has three members, since no size was specified and there are three initializers.  float y[4][3] = 
{
 { 1, 3, 5 },
 { 2, 4, 6 },
 { 3, 5, 7 }, 
}; is a completely bracketed initialization: 1, 3, and 5 initialize the first row of the array y[0], namely y[0][0], y[0][1], and y[0][2]. Likewise, the next two lines initialize y[1] and y[2]. The initializer ends early, and therefore   y[3] is initialized with 0.  The next example achieves precisely the same effect.float y[4][3] = 
{
 1, 3, 5, 2, 4, 6, 3, 5, 7 
}; The initializer for y begins with a left brace but that for y[0] does not; therefore, three elements from the list are used.  Likewise, the next three are taken successively for y[1] and y[2]. Also, float y[4][3] = { { 1 }, { 2 }, { 3 }, { 4 } 
}; initializes the first column of y (regarded as a two-dimensional array) and leaves the rest 0.The following example demonstrates the ANSI C rules.  A union   object   union dc_u {
 double d;
 char *cptr; 
}; is initialized by using the first element only, as in union dc_u dc0 = { 4.0 };Finally,char msg[] = "Syntax error on line %s\n"; shows a character array whose members are initialized with a string literal.  The length of the string (or size of the array) includes the terminating NULL character, \0.LBL="9"ID="70950"StatementsExcept as indicated, statements are executed in sequence.  statement:expression-statementcompound-statementselection-statementiteration-statementjump-statementlabeled-statement LBL="9.1" HELPID=""ID="10732"Expression StatementMost statements are expression statements, which have the form   ID="chap.091"ID="chap.092"expression-statement:expressionopt; Usually expression statements are expressions evaluated for their side effects, such as assignments or function calls.  A special case is the null statement, which consists only of a semicolon.     ID="chap.093"ID="chap.094"LBL="9.2" HELPID=""Compound Statement or BlockA compound statement (or block) groups a set of statements into a syntactic unit.  The set can have its own declarations and initializers.    ID="chap.095"ID="chap.096"ID="chap.097"compound-statement:         { declaration-list opt  statement-list opt } declaration-list:          declaration          declaration-list declaration statement-list:          statement          statement-list statement Declarations within compound statements have block scope.  If any of the identifiers in the declaration-list were previously declared, the outer declaration is hidden for the duration of the block, after which it resumes its force. In traditional C, however, function declarations always have ID="chap.098"ID="chap.099"file scope whenever they appear.Initialization of identifiers declared within the block is restricted to those that have no linkage.  Thus, the initialization of an identifier declared within the block using the extern specifier is not allowed.  These initializations are performed only once, prior to the first entry into the block, for identifiers with static storage duration.  For identifiers with automatic storage duration, it is performed each time the block is entered at the top.  It is currently possible (but a bad practice) to transfer into a block; in that case, no initializations are performed.  LBL="9.3" HELPID=""Selection StatementsSelection statements include if   and   switch   statements.      ID="chap.0910"ID="chap.0911"ID="chap.0912"ID="chap.0913"selection-statement:if   ( expression ) statement if   ( expression ) statement else statementswitch ( expression ) statement   Selection statements choose one of a set of statements to execute, based on the evaluation of the expression.  The expression is referred to as the controlling expression. ID="chap.0914"LBL="9.3.1" HELPID=""The if   StatementThe controlling expression of an if   statement must have scalar type. ID="chap.0915"For both forms of the if statement, the first statement is executed if the controlling expression evaluates to nonzero.  For the second form, the second statement is executed if the controlling expression evaluates to zero.  An else clause that follows multiple sequential else-less if statements is associated with the most recent if statement in the same block (that is, not in an enclosed block).  ID="chap.0916"LBL="9.3.2" HELPID=""The switch   Statement   The controlling expression of a switch statement must have integral type.  The statement is typically a compound statement, some of whose constituent statements are labeled case statements (see IDREF="60638" TYPE="TITLE"Section 9.6, "Labeled Statements"
).  In addition, at most one labeled default statement can occur in a   switch.  The expression on each case label must be an integral constant expression.  No two expressions on case labels in the same switch can evaluate to the same constant.         ID="chap.0917"ID="chap.0918"ID="chap.0919"ID="chap.0920"ID="chap.0921"A compound statement attached to a switch can include declarations.  Due to the flow of control in a switch, however, initialization of identifiers so declared will not be performed if these initializers have automatic storage duration.The integral promotions are performed on the controlling expression, and the constant expression of each case statement is converted to the promoted type.  Control is transferred to the labeled case statement whose expression value matches the value of the controlling expression.  If no such match occurs, control is transferred either past the end of the switch or to the labeled default   statement, if one exists in the switch.  Execution continues sequentially once control has been transferred.  In particular, the flow of control is not altered upon encountering another case label.  The switch statement is exited, however, upon encountering a break   or   continue statement (see IDREF="58788" TYPE="TITLE"Section 9.5.3
 and IDREF="61959" TYPE="TITLE"Section 9.5.2
, respectively).   ID="chap.0922"ID="chap.0923"A simple example of a complete switch statement is: switch (c) {
 case 'o':
  oflag = TRUE;
  break;
 case 'p':
  pflag = TRUE;
  break;
 case 'r':
  rflag = TRUE;
  break;
 default :
  (void) fprintf(stderr, 
          "Unknown option\n");
  exit(2);
} LBL="9.4" HELPID=""Iteration StatementsThe iteration statements execute the attached statement (called the body) repeatedly until the controlling expression evaluates to zero.  (In the for statement, the second expression is the controlling expression.)ID="chap.0924"iteration-statement:while ( expression ) statementdo   statement   while ( expression ) ;for ( expressionopt  ; expressionopt  ; expressionopt )  statement The controlling expression must have scalar type.ID="chap.0925"The flow of control in an iteration statement can be altered by a jump-statement (see IDREF="39384" TYPE="TITLE"Section 9.5
).ID="chap.0926"LBL="9.4.1" HELPID=""The while   StatementThe controlling expression of a while statement is evaluated before each execution of the body. ID="chap.0927"LBL="9.4.2" HELPID=""The do   StatementThe controlling expression of a do   statement is evaluated after each execution of the body. ID="chap.0928"LBL="9.4.3" HELPID=""The for   Statementfor (expressionopt ; expressionopt ; expressionopt )statementThe first expression specifies initialization for the loop. The second expression is the controlling expression, which is evaluated before each iteration.  The third expression often specifies incrementation. It is evaluated after each iteration.This statement is equivalent to expression-1 ; while ( expression-2 ){          statement          expression-3 ; } with one exception:  if a continue statement (see IDREF="61959" TYPE="TITLE"Section 9.5.2
) is encountered, expression-3 of the for statement is executed prior to the next iteration.ID="chap.0929"Any or all of the expressions can be omitted.  A missing expression-2 makes the implied while clause equivalent to while ( 1 ).  Other missing expressions are simply dropped from the expansion above.  LBL="9.5" HELPID=""ID="39384"Jump StatementsJump statements cause unconditional transfer of control.  ID="chap.0930"jump-statement:goto   identifier ;continue ;break ;return   expression opt  ; LBL="9.5.1" HELPID=""The goto StatementControl can be transferred unconditionally by means of the statement goto identifier ; ID="chap.0931"The identifier must name a label located in the enclosing function.  If the label has not yet appeared, it is implicitly declared.  (See IDREF="60638" TYPE="TITLE"Section 9.6
 for more information on labelled statements.) LBL="9.5.2" HELPID=""ID="61959"The continue   StatementThe continue statement can appear only in the body of an iteration statement. It causes control to pass to the loop-continuation portion of the smallest enclosing while, do, or for statementname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'that is, to the end of the loop.  More precisely, in each of the statementsID="chap.0932"while (...){
 ...
contin: ;
}

do {   ...
     contin: ;
} while (...) ;

for (...) {
     ...
     contin: ;
}a continue is equivalent to   goto contin.  (Following the contin: is a null statement.) LBL="9.5.3" HELPID=""ID="58788"The break   StatementThe break statement can appear only in the body of an iteration statement or code attached to a switch statement.  It transfers control to the statement immediately following the smallest enclosing iteration or switch statement, terminating its execution.   ID="chap.0933"LBL="9.5.4" HELPID=""The return   StatementA function returns to its caller by means of the return statement.  The value of the expression is returned to the caller after conversion, as if by assignment, to the declared type of the function, as the value of the function call expression.  The return statement cannot have an expression if the type of the current function is void.   ID="chap.0934"ID="chap.0935"If the end of a function is reached prior to the execution of an explicit return, an implicit return (with no expression) is executed.  If the value of the function call expression is used when none is returned, the behavior is undefined. LBL="9.6" HELPID=""ID="60638"Labeled Statementslabeled-statement:identifier : statementcase constant-expression : statementdefault : statement A case or   default label can appear only on statements that are part of a switch.Any statement can have a label attached as a simple identifier.  The scope of such a label is the current function.  Thus, labels must be unique within a function.  In traditional C, identifiers used as labels and in object declarations share a name space.  Thus, use of an identifier as a label will hide any declaration of that identifier in an enclosing scope.  In ANSI C, identifiers used as labels are placed in a different name space from all other identifiers, and do not conflict.  Thus the code fragment{
     int foo;
     foo = 1;
     name='hellip' font=symbol charset=fontspecific code=188
     goto foo;
     name='hellip' font=symbol charset=fontspecific code=188
     foo: ;
} is legal in ANSI C, but not in traditional C.LBL="10"ID="42146"External DefinitionsA C program consists of a sequence of external definitions.  An external declaration becomes an external definition when it reserves storage for the object or function indicated.  Within the entire program, all external declarations of the same identifier with external linkage refer to the same object or function.  Within a particular translation unit, all external declarations of the same identifier with internal linkage refer to the same object or function. ID="chap.101"ID="chap.102"external declaration:function-definitiondeclarationThe syntax for external definitions that are not functions is the same as the syntax for the corresponding external declarations.  The syntax for the corresponding external function definition differs somewhat from that of the declaration, since the definition includes the code for the function itself.LBL="10.1" HELPID=""External Function DefinitionsFunction definitions have the form     ID="chap.103"ID="chap.104"ID="chap.105"function-definition:declaration-specifiersopt declarator declaration-listopt   compound statementwhere the form of a declarator used for a function definition can bepointeropt direct-declarator ( parameter-type-listopt )pointeropt direct-declarator ( identifier-listopt   )in which the simplest instance of a direct-declarator is an identifier.  (For the exact syntax, see IDREF="17758" TYPE="TITLE"Section 8.7, "Declarators."
)The only storage-class specifiers allowed in a function definition are extern and static.   ID="chap.106"ID="chap.107"ID="chap.108"If the function declarator has a parameter-type-list (see IDREF="17758" TYPE="TITLE"Section 8.7
), it is in function prototype form (as discussed in IDREF="95935" TYPE="TITLE"Section 8.7.4
), and the function definition cannot have a declaration-list.  Otherwise, the function declarator has a possibly empty   identifier-list, and the   declaration-list declares the types of the formal parameters.  register is the only storage-class specifier permitted in declarations that are in the declaration-list.  Any identifiers in the identifier-list of the function declarator that do not have their types specified in the declaration-list are assumed to have type int.ID="chap.109"Each parameter has block scope and automatic storage duration (see IDREF="39439" TYPE="TITLE"Section 5.1
).  (ANSI C and traditional C place parameters in different blocks.  See IDREF="92800" TYPE="TITLE"Section 5.1.1
 for details.)  Each parameter is also an lvalue, but since function calls in C are by value, the modification of a parameter of arithmetic type cannot affect the corresponding argument.  Pointer parameters, while unmodifiable for this reason, can be used to modify the objects to which they point.  Argument promotion rules are discussed in IDREF="71562" TYPE="TITLE"Section 7.2.2
.The type of a function must be either void   or an object type that is not an array. ID="chap.1010"LBL="10.2" HELPID=""External Object DefinitionsA declaration of an object with file scope that has either an initializer or static linkage is an external object definition.   ID="chap.1011"ID="chap.1012"ID="chap.1013"In ANSI C, a file-scope object declaration with external linkage that is declared without the storage-class specifier extern, and also without an initializer, will result in a definition of the object at the end of the translation unit.  See the discussion in Section 3.1 for more details.LBL="A"ID="41509"Implementation-defined BehaviorThe following sections describe implementation-defined behavior. Each section is keyed to the ANSI C Standard, Appendix F, and each point is keyed to the section number of the ANSI C Standard. The italicized lines, usually marked with bullets, are items from Appendix F of the ANSI C Standard. Text following the italic lines describes the Silicon Graphics implementation. LBL="A.1" HELPID=""Translation (F.3.1)Whether each nonempty sequence of white-space characters other than newline is retained or replaced by one space character (2.1.1.2)A nonempty sequence of white-space characters (other than newline) is replaced by a single space character.          ID="appendix.A1"ID="appendix.A2"ID="appendix.A3"ID="appendix.A4"How a diagnostic is identified ( 2.1.1.3) ID="appendix.A5"Successful compilations are silent. Diagnostics are, in general, emitted to standard error. Diagnostic messages have the general pattern of program: message.   Typical messages from the ANSI C compiler front end (the tail of messages has been elided for brevity) are:cfe: Error: t4.c, line 4: Function x has ... 
cfe: Warning 765: t4.c, line 4: Useless keyword ...Messages can also be issued by other internal compiler passes. Classes of diagnostic messages, their return codes and control over themID="appendix.A6"There are basically two classes of messages: warning and error. Warning messages include the notation 'warning' (which can be capitalized), and allow the compilation to continue (return code 0). Error messages cause the compilation to fail (return code 1).    ID="appendix.A7"ID="appendix.A8"ID="appendix.A9"ID="appendix.A10"Warning messages from the compiler front-end have a unique number. These warning messages can be suppressed individually using this message number by use of the -woff   numberlist switch to cc(1).  numberlist is a comma-separated list of warning numbers and ranges of warning numbers.  For example, -woff 642-644,759will suppress warning messages numbered 642,643, 644, and 759.LBL="A.2" HELPID=""Environment (F.3.2)ID="appendix.A11"Support of freestanding environments.No support is provided for a freestanding environment.ID="appendix.A12"The semantics of the arguments to main (2.1.2.2.1).main ID="appendix.A13"is defined to have the two required parameters ID="appendix.A14"argc and ID="appendix.A15"argv. A third parameter, ID="appendix.A16"envp, is provided as an extension. (that is, main would have the equivalent of the prototype int main(int argc, char *argv[], char *envp[]). The parameters have the following semantics:argc is the number of arguments on the command line.argv[0..argc-1] are pointers to the command-line arguments (strings).argv[0] is the program name, as it appeared on the command-line.argv[argc] is a null pointer. envp is an array of pointers to strings of the form NAME=value, where NAME is the name of an environment variable and value is its value. The array is terminated by a null pointer.What constitutes an interactive device (2.1.2.3).Asynchronous terminals, including windows, are interactive devices and are, by default, line-buffered. In addition, the standard error device, ID="appendix.A17"stderr, is, by default, unbuffered.ID="appendix.A18"ID="appendix.A19"LBL="A.3" HELPID=""Identifiers (F.3.3)ID="appendix.A20"The number of significant initial characters (beyond 31) in an identifier without external linkage (3.1.2).All characters are significant. The number of significant initial characters (beyond 6) in an identifier with external linkage (3.1.2).All characters are significant. Whether case distinctions are significant in an identifier with external linkage (3.1.2).Case distinctions are always significant.   ID="appendix.A21"ID="appendix.A22"LBL="A.4" HELPID=""Characters (F.3.4)ID="appendix.A23"ID="appendix.A24"The members of the source and execution character sets, except as explicitly specified in the standard (2.2.1)Only the mandated characters are present. The source character set includes all printable ASCII characters, hexadecimal 0x20 through 0x7e and 0x7 through 0xc (the standard escape sequences).. The values to which the standard escape sequences are translated (2.2.2)The escape sequences are translated as specified for standard ASCII: \a = 0x7, \b = 0x8, \f = 0x c, \n = 0xa, \r = 0xd, \t = 0x9, \v=0xbID="appendix.A25"The shift states used for the encoding of multibyte characters (2.2.1.2)The multibyte character set is identical to the source and execution character sets. There are no shift states.   ID="appendix.A26"ID="appendix.A27"ID="appendix.A28"ID="appendix.A29"The number of bits in a character in the execution character set (2.2.4.2.1)There are eight (8) bits per character.   ID="appendix.A30"ID="appendix.A31"The mapping of members of the source character set (in character constants and string literals) to members of the execution character set (3.1.3.4).The mapping is the identity mapping. ID="appendix.A32"The value of an integer character constant that contains a character or escape sequence not represented in the basic execution character set or the extended character set for a wide character constant (3.1.3.4).With the exception of newline (0xa), backslash ('\'), and 0xff (end-of-file), eight-bit values appearing in an integer character constant are placed in the resultant integer in the same fashion as are characters which are members of the execution character set (see below). A backslash, newline, or 0xff can be placed in a character constant by preceeding it with a backslash (that is, ``escaping'' it).ID="appendix.A33"ID="appendix.A34"The value of an integer character constant that contains more than one character or wide character constant that contains more than one multibyte character (3.1.3.4)You can assign up to four characters to an int using a character constant. The encoding of multiple characters in an integer consists of the assignment of the corresponding character values of the   n characters in the constant to the least-significant n bytes of the integer, filling any unused bytes with zeros. The most significant byte assigned contains the value of the lexically first character in the constant. For example:int t = 'a'; /* integer value 0x61 */ 
int t2 = 'ab'; /* integer value 0x6162 */ 
int t4 = 'abcd'; /* integer value 0x61626364 */ 
int t4 = 'abcde'; /* error: too many characters 
     for character constant */   Since the multibyte character set is identical to the source and execution character sets, the above discussion applies to the assignment of more than one multibyte character to a wide character constant.The current locale used to convert multibyte characters into corresponding wide character (codes) for a wide character constant (3.1.3.4).The mapping is the identity mapping to the standard ASCII character set. The ``C'' locale is used. ID="appendix.A35"ID="appendix.A36"ID="appendix.A37"ID="appendix.A38"Whether a "plain" char has the same range of values as signed char or unsigned char.ID="appendix.A39"ID="appendix.A40"ID="appendix.A41"Plain char is the same as unsigned char by default. Use the   ­signed option to cc to switch the range to be that of signed char.   LBL="A.5" HELPID="" Integers (F.3.5)The representations and sets of values of the various types of integers (3.1.2.5).Integers are two's complement binary. IDREF="74002" TYPE="TABLE"Table A-1
 gives the sizes and ranges of the various types of integer.  The use of long long will result in a warning in ­ansi and ­ansiposix modes.  To take full advantage of the support for 64 bits integral values in ­ansi and ­ansiposix modes, the user should define the macro _LONGLONG on the cc(1) command line when using the types __uint64_t or __int64_t or library routines that are protyped in terms of these types.ID="appendix.A42"COLUMNS="4"LEFT="0" WIDTH="85"typeLEFT="90" WIDTH="91"range: lowLEFT="190" WIDTH="95"highLEFT="290" WIDTH="356"size (bits)LEFT="0" WIDTH="85"signed charLEFT="90" WIDTH="91"­128LEFT="190" WIDTH="95"127LEFT="290" WIDTH="356"8LEFT="0" WIDTH="85"char, unsigned charLEFT="90" WIDTH="91"0LEFT="190" WIDTH="95"255 LEFT="290" WIDTH="356"8LEFT="0" WIDTH="85"short, signed shortLEFT="90" WIDTH="91"­32768LEFT="190" WIDTH="95"32767 LEFT="290" WIDTH="356"16LEFT="0" WIDTH="85"unsigned short intLEFT="90" WIDTH="91"0LEFT="190" WIDTH="95"65535 LEFT="290" WIDTH="356"16LEFT="0" WIDTH="85"int, signed intLEFT="90" WIDTH="91"­2147483648LEFT="190" WIDTH="95"2147483647 LEFT="290" WIDTH="356"32LEFT="0" WIDTH="85"unsigned intLEFT="90" WIDTH="91"0LEFT="190" WIDTH="95"4294967295 LEFT="290" WIDTH="356"32LEFT="0" WIDTH="85"long, signed long 
intLEFT="90" WIDTH="91"­2147483648LEFT="190" WIDTH="95"2147483647 LEFT="290" WIDTH="356"32LEFT="0" WIDTH="85"unsigned long intLEFT="90" WIDTH="91"0LEFT="190" WIDTH="95"4294967295 LEFT="290" WIDTH="356"32LEFT="0" WIDTH="85"long long,signed 
long long intLEFT="90" WIDTH="91"9223372036854775808LEFT="190" WIDTH="95"9223372036854775807LEFT="290" WIDTH="356"64LEFT="0" WIDTH="85"unsigned long long 
intLEFT="90" WIDTH="91"0LEFT="190" WIDTH="95"18446744073709551615LEFT="290" WIDTH="356"64LBL="A-1"Table A-1 ID="74002" Integer Types and RangesThe result of converting an integer to a shorter signed integer, or the result of converting an unsigned integer to a signed integer of equal length, if the value cannot be represented (3.2.1.2).The least significant n bits (n being the length of the result integer) of the source are copied to the result. ID="appendix.A43"The results of bitwise operations on signed integers (3.3).With the exception of right-shift of a negative signed integer (defined below) operations on signed and unsigned integers produce the same bitwise results. ID="appendix.A44"ID="appendix.A45"The sign of the remainder on integer division (3.3.5)The sign of the remainder is that of the numerator. ID="appendix.A46"ID="appendix.A47"ID="appendix.A48"The result of a right shift of a negative-valued signed integral type (3.3.7).The sign bit is propagated, so the result value is still negative. ID="appendix.A49"ID="appendix.A50"LBL="A.6" HELPID=""Floating Point (F.3.6)The representations and sets of values of the various types of floating-point numbers (3.1.2.5)ID="appendix.A51"ID="appendix.A52"The representation is IEEE single (for float values) and double ( for double values). See ANSI/IEEE Std 754-1985, IEEE Standard for Binary Floating-Point Arithmetic. COLUMNS="4"LEFT="0" WIDTH="85"typeLEFT="90" WIDTH="85"range: minLEFT="180" WIDTH="85"maxLEFT="270" WIDTH="356"size (bits)LEFT="0" WIDTH="85"floatLEFT="90" WIDTH="85"1.1755e-38LEFT="180" WIDTH="85"3.4028e+38LEFT="270" WIDTH="356"32LEFT="0" WIDTH="85"doubleLEFT="90" WIDTH="85"2.225e-308LEFT="180" WIDTH="85"1.7977e+308LEFT="270" WIDTH="356"64LBL="A-2"Table A-2    Ranges of Floating-point TypesThe type of rounding or truncation used when representing a floatingname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'point constant which is within its rangePer IEEE, the rounding is round-to-nearest (IEEE Std 754 sec 4.1 and 5.5). If the two values are equally near, then the one with the least significant bit zero is chosen. ID="appendix.A53"ID="appendix.A54"ID="appendix.A55"The direction of truncation when an integral number is converted to a floating-point number that cannot exactly represent the original value (3.2.1.3)   Conversion of an integral type to a float type will, if the integral value is too large to be exactly represented, give the next higher value. The direction of truncation or rounding when a floating-point number is converted to a narrower floating-point number.Per IEEE, the rounding is round-to-nearest (IEEE Std 754 sec 4.1 and 5.5). If the two values are equally near, then the one with the least significant bit zero is chosen. ID="appendix.A56"LBL="A.7" HELPID=""Arrays and Pointers (F.3.7)The type of integer required to hold the maximum size of an array name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' that is, the type of the sizeof   operator, size_t (3.3.3.4,4.1.1).An unsigned int will hold the maximum array size. ID="appendix.A57"ID="appendix.A58"ID="appendix.A59"ID="appendix.A60"The size of integer required for a pointer to be converted to an integer type (3.3.4)ints are large enough to hold pointers. Both are 32 bits wide.ID="appendix.A61"ID="appendix.A62"The result of casting a pointer to an integer or vice versa (3.3.4).The result is bitwise exact.. Integers are large enough to hold pointers. Pointers and integers are both 32 bits wide. The type of integer required to hold the difference between two pointers to elements of the same array, ID="appendix.A63"ptrdiff_t(3.3.6, 4.1.1).An integer is large enough to hold the difference between two pointers to elements of the same array. ID="appendix.A64"LBL="A.8" HELPID=""Registers (F.3.8)The extent to which objects can actually be placed in registers by use of the register   storage-class specifier (3.5.1).If not optimizing, then up to 8 of the register storage-class specifiers can be used by the compilation system.registerID="appendix.A65" storage-class specifiers in function-prototype style function definitions and declarations are ignored.If optimizing, then the compilation system ignores the register keyword and makes its own decision about what should be in registers. LBL="A.9" HELPID=""Structures, Unions, Enumerations, and Bitfields (F.3.9)What is the result if a member of a union object is accessed using a member of a different type (3.3.2.3).The bits of the accessed member are interpreted according to the type used to access the member. For integral types the N bits of the type are simply accessed. For floating types, the access might cause a trap if the bits are not a legal floating point value. For pointer types, the 32 bits of the pointer are picked up. The usability of the pointer depends on whether it points to a valid object or function, and whether it is used ``appropriately.'' For example, a pointer whose least-significant bit is set can point to a character, but not to an integer. ID="appendix.A66"The padding and alignment of members of structures (3.5.2.1). This should present no problem unless binary data written by one implementation are read by another.Members of structures are on the same boundaries as the base data type alignments anywhere else. A word is 32 bits and is aligned on an address which is a multiple of 4. Type alignments are given in ID="appendix.A67"ID="appendix.A68"IDREF="50992" TYPE="TABLE"Table A-3
.   COLUMNS="2"LEFT="0" WIDTH="171"typeLEFT="180" WIDTH="356"alignmentLEFT="0" WIDTH="171"doubleLEFT="180" WIDTH="356"double-word boundary LEFT="0" WIDTH="171"floatLEFT="180" WIDTH="356"word boundary LEFT="0" WIDTH="171"long longLEFT="180" WIDTH="356"double-word boundaryLEFT="0" WIDTH="171"intLEFT="180" WIDTH="356"word boundary LEFT="0" WIDTH="171"pointerLEFT="180" WIDTH="356"word boundary LEFT="0" WIDTH="171"shortLEFT="180" WIDTH="356"half-word boundary LEFT="0" WIDTH="171"charLEFT="180" WIDTH="356"byte boundary LBL="A-3"Table A-3 ID="50992"Alignment of Structure MembersUnsigned and signed versions of a basic type use identical alignment.Whether a "plain" int   bit-field is treated as a signed int   bit-field or as an unsigned int   bit-field (3.5.2.1).A "plain" int bit-field is treated as a signed int bit-field. ID="appendix.A69"The order of allocation of bitfields within a unit (3.5.2.1).Bits in a bitfield are allocated most-significant-bit-first within a unit. ID="appendix.A70"Whether a bitfield can straddle a storage-unit boundary (3.5.2.1).Bitfields cannot straddle int boundaries (relative to the beginning of the struct or   union) for int fields nor long long boundaries for long long fields.   ID="appendix.A71"The integer type chosen to represent the values of an enumeration type (3.5.2.2).The int type is always used. Note that ID="appendix.A72"long long enumerations are not supported. LBL="A.10" HELPID=""   Qualifiers (F.3.10)What constitutes an access to an object that has volatile-qualified type (3.5.3).Objects of ID="appendix.A73"ID="appendix.A74"volatile-qualified type are accessed only as specified by the abstract semantics, and as would be expected on a RISC architecture. There are no complex instructions (for example, read-modify-write). volatile objects appearing on the left-hand-side of an assignment expression are accessed once for the write. If the assignment is not simple, an additional read access is performed. volatile objects appearing in other contexts are accessed once per instance. Incrementation and decrementation require both a read and a write access.volatile objects which are memory-mapped are accessed only as specified: if such an object is of size char, for example, adjacent bytes are not accessed. If the object is a bitfield, a read might access the entire int object containing the field. A write of an unaligned field necessitates a read and write of the int object which contains it.LBL="A.11" HELPID=""Declarators (F.3.11)The maximum number of declarators that can modify an arithmetic, structure, or union type (3.5.4).There is no limit.ID="appendix.A75"LBL="A.12" HELPID=""Statements (F.3.12)The maximum number of case   values in a switch   statement (3.6.4.2).There is no limit.ID="appendix.A76"ID="appendix.A77"LBL="A.13" HELPID=""Preprocessing Directives (F.3.13)Whether the value of a single character character constant in a constant expression that controls conditional inclusion matches the value of the same character constant in the execution character set. Whether such a character constant can have a negative value.(3.8.1)The preprocessing and execution phases use exactly the same meanings for character constants.A single-character character constant is always positive. The method for locating includable source files (3.8.2).For file names surrounded by <>, the includable source files are searched for in /usr/local/include, then in /usr/include.ID="appendix.A78"The default search list includes   /usr/local/include and   /usr/include. You can change this list with various compiler options. See cc(1), the   ­I and ­nostdinc options. ID="appendix.A79"The support of quoted names for includable source files (3.8.2)Quoted names are supported for includable source files. For file names surrounded by ``'', the includable source files are searched for in the directory of the current include file, then in ID="appendix.A80"ID="appendix.A81"/usr/local/include, then in /usr/include.The default search list includes   /usr/local/include and   /usr/include. You can change this list with various compiler options. See cc(1), the   ­I and ­nostdinc options. The mapping of source file character sequences (3.8.2)The mapping is the identity mapping. The behavior on each recognized #pragma directive.#pragma weak ID="appendix.A82"weak_name = strong_name causes a weak symbol for weak_name to be associated with the definition for strong_name. At the time of the program link, if a reference to weak_name is found, and no non-weak defintion of weak_name exists, the definition of strong_name is used. The definition of strong_name must occur in the same compilation unit as the #pragma weak and appear after it. If strong_name is a data object, it must be initialized. No declaration for weak_name is allowed in the compilation unit.Other #pragmas are used for C multiprocessing. They are described in the Power C User's Guide.The definitions forID="appendix.A83"   __DATE__ and   ID="appendix.A84"__TIME__ when respectively, the date and time of translation are not available.The date and time of translation are always available in this implementation. ID="appendix.A85"ID="appendix.A86"What is the maximum nesting depth of include files? (3.8.2)The maximum nesting of include files is 200. ID="appendix.A87"LBL="A.14" HELPID=""Library Functions (F.3.14)The null pointer constant to which the macro NULL   expands (4.1.5)The NULL pointer constant expands to an ID="appendix.A88"int with value zero. That is,#define NULL 0The diagnostic printed by and the termination behavior of the ID="appendix.A89"assert function (4.2).If an assertion given by assert(EX) fails, the messageID="appendix.A90"Assertion failed: EX, file <filename>, line <linenumber> is printed on stderr using a   _write to its underlying fileno. This is followed by a call to abort(3c) (which exits with a SIGABRT).The sets of characters tested for by the ID="appendix.A91"isalnum, ID="appendix.A92"isalpha, iscntrl, islower, isprint, ID="appendix.A93"ID="appendix.A94"ID="appendix.A95"and   ID="appendix.A96"isupper functions (4.3.1).The following is true when operating in the C locale. The C locale is in effect at program startup for programs compiled for pure ANSI C (that is, -ansi), or by invoking ID="appendix.A97"setlocale(LC_ALL,"C"). The C locale can be overridden at startup for any program that does not explicitly invoke setlocale by setting the value of the environment variable ID="appendix.A98"CHRCLASS. (See the man page ctype(3C).)isalnum is nonzero for the 26 letters a­z and the 26 letters A­Z and the digits 0­9.isalpha is nonzero for the 26 letters a­z and the 26 letters A­Z.islower is nonzero for the 26 letters a­z.isupper is nonzero for the 26 letters A­Z.isprint is nonzero for the ASCII characters space through tilde (~) (0x20 through 0x7e).iscntrl is nonzero for the ASCII characters NUL through US (0x0 through 0x1f). The values returned by the mathematics functions on domain errors (4.5.1).The value returned by the math functions on domain errors is the default IEEE Quiet NaN in all cases except the following:ID="appendix.A99"ID="appendix.A100"The functions   powID="appendix.A101" and ID="appendix.A102"powf return -HUGE_VAL when the first argument is zero and the second argument is negative. When both arguments are zero,   pow and powf return 1.0.The functions   atan2ID="appendix.A103" and ID="appendix.A104"atan2f return zero when both arguments are zero.   Whether mathematics functions set the integer expression ID="appendix.A105"errno to the value of the macro ID="appendix.A106"ID="appendix.A107"ID="appendix.A108"ERANGE on underflow range errors (4.5.1).Yes, except intrinsic functions that have been inlined. Note that fabs,fabst,sqrt, and sqrtf are intrinsic by default in ­xansi and ­cckr modes and can be made intrinsic in ­ansi mode by using the compiler option D__INLINE_INTRINSICS. Whether a domain error occurs or zero is returned when the ID="appendix.A109"fmod function has a second argument of zero (4.5.6.4).   fmod(x,0) gives a domain error and returns the default IEEE Quiet NaN.LBL="A.14.1" HELPID=""SignalsThe set of signals for the ID="appendix.A110"signal function (4.7.1.1).The signal set is listed in IDREF="35301" TYPE="TABLE"Table A-4, which is from the signal(2) man page. The set of signals is conformant with SVR4 ABI. Note that some of the signals are not defined in ­ansiposix mode. References in square brackets beside the signal numbers are described under ``Signal Notes'' in the discussion of signal semantics.COLUMNS="3"LEFT="0" WIDTH="113"SignalLEFT="120" WIDTH="113"Number[Note]LEFT="240" WIDTH="356"MeaningLEFT="0" WIDTH="113"SIGHUPLEFT="120" WIDTH="113"01LEFT="240" WIDTH="356"hangup LEFT="0" WIDTH="113"SIGINTLEFT="120" WIDTH="113"02LEFT="240" WIDTH="356"interrupt LEFT="0" WIDTH="113"SIGQUITLEFT="120" WIDTH="113"03[1]LEFT="240" WIDTH="356"quit LEFT="0" WIDTH="113"SIGILLLEFT="120" WIDTH="113"04[1]LEFT="240" WIDTH="356"illegal instruction (not reset 
when caught) LEFT="0" WIDTH="113"SIGTRAPLEFT="120" WIDTH="113"05[1][5] LEFT="240" WIDTH="356"race trap (not reset when 
caught) LEFT="0" WIDTH="113"SIGIOTLEFT="120" WIDTH="113"06LEFT="240" WIDTH="356"IOT instructionLEFT="0" WIDTH="113"SIGABRTLEFT="120" WIDTH="113"06[1]LEFT="240" WIDTH="356"abort LEFT="0" WIDTH="113"SIGEMTLEFT="120" WIDTH="113"07[1][4] LEFT="240" WIDTH="356"MT instruction LEFT="0" WIDTH="113"SIGFPELEFT="120" WIDTH="113"08[1]LEFT="240" WIDTH="356"floating point exception LEFT="0" WIDTH="113"SIGKILLLEFT="120" WIDTH="113"09LEFT="240" WIDTH="356"kill (cannot be caught or 
ignored) LEFT="0" WIDTH="113"SIGBUSLEFT="120" WIDTH="113"10[1]LEFT="240" WIDTH="356"bus error LEFT="0" WIDTH="113"SIGSEGVLEFT="120" WIDTH="113"11[1]LEFT="240" WIDTH="356"segmentation violation LEFT="0" WIDTH="113"SIGSYSLEFT="120" WIDTH="113"12[1]LEFT="240" WIDTH="356"bad argument to system 
call LEFT="0" WIDTH="113"SIGPIPELEFT="120" WIDTH="113"13LEFT="240" WIDTH="356"write on a pipe with no one 
to read it LEFT="0" WIDTH="113"SIGALRMLEFT="120" WIDTH="113"14LEFT="240" WIDTH="356"alarm clock LEFT="0" WIDTH="113"SIGTERMLEFT="120" WIDTH="113"15LEFT="240" WIDTH="356"software termination 
signal LEFT="0" WIDTH="113"SIGUSR1LEFT="120" WIDTH="113"16LEFT="240" WIDTH="356"user-defined signal 1 LEFT="0" WIDTH="113"SIGUSR2LEFT="120" WIDTH="113"17LEFT="240" WIDTH="356"user-defined signal 2 LEFT="0" WIDTH="113"SIGCLDLEFT="120" WIDTH="113"18[2]LEFT="240" WIDTH="356"death of a child LEFT="0" WIDTH="113"SIGGHLDLEFT="120" WIDTH="113"18LEFT="240" WIDTH="356"4.3 BSD/POSIX nameLEFT="0" WIDTH="113"SIGPWRLEFT="120" WIDTH="113"19[2]LEFT="240" WIDTH="356"power fail (not reset when 
caught) LEFT="0" WIDTH="113"SIGWINCHLEFT="120" WIDTH="113"20[2]LEFT="240" WIDTH="356"window size changes LEFT="0" WIDTH="113"SIGURGLEFT="120" WIDTH="113"21[2]LEFT="240" WIDTH="356"urgent condition on I/O 
channel LEFT="0" WIDTH="113"SIGIOLEFT="120" WIDTH="113"22[2]LEFT="240" WIDTH="356"input/output possible LEFT="0" WIDTH="113"SIGPOLLLEFT="120" WIDTH="113"22[3]LEFT="240" WIDTH="356"selectable event pendingLEFT="0" WIDTH="113"SIGSTOPLEFT="120" WIDTH="113"23[6]LEFT="240" WIDTH="356"stop (cannot be caught or 
ignored) LEFT="0" WIDTH="113"SIGTSTPLEFT="120" WIDTH="113"24[6]LEFT="240" WIDTH="356"stop signal generated from 
keyboard LEFT="0" WIDTH="113"SIGCONTLEFT="120" WIDTH="113"25[6]LEFT="240" WIDTH="356"continue after stop (cannot 
be ignored) LEFT="0" WIDTH="113"SIGTTINLEFT="120" WIDTH="113"26[6]LEFT="240" WIDTH="356"background read from 
control terminal LEFT="0" WIDTH="113"SIGTTOULEFT="120" WIDTH="113"27[6]LEFT="240" WIDTH="356"background write to 
control terminal LEFT="0" WIDTH="113"SIGVTALRMLEFT="120" WIDTH="113"28LEFT="240" WIDTH="356"virtual time alarm LEFT="0" WIDTH="113"SIGPROFLEFT="120" WIDTH="113"29LEFT="240" WIDTH="356"profiling alarm LEFT="0" WIDTH="113"SIGXCPULEFT="120" WIDTH="113"30LEFT="240" WIDTH="356"cpu time limit exceeded 
[see setrlimit(2)] LEFT="0" WIDTH="113"SIGXFSZLEFT="120" WIDTH="113"31LEFT="240" WIDTH="356"file size limit exceeded [see 
setrlimit(2)] LEFT="0" WIDTH="113"SIG32LEFT="120" WIDTH="113"32LEFT="240" WIDTH="356"reserved for kernel usageLBL="A-4"Table A-4 ID="35301" SignalsThe semantics for each signal recognized by the signal   function (4.7.1.1). In the ID="appendix.A111"signal invocation signal(sig, func), func can be the address of a signal handler, handler, or one of the two constant values (defined in <sys/signal.h>) SIG_DFL or SIG_IGN. The semantics of these values are as follows:SIG_DFLterminate process upon receipt of signal sig(This is the default if no call to signal for signal sig occurs.) Upon receipt of the signal sig, the receiving process is to be terminated with all of the consequences outlined in exit(2). See note 1. under   Signal Notes below.SIG_IGNignore signal The signal sig is to be ignored. handler catch signal. func is the address of function handler.The signals SIGKILL, SIGSTOP and SIGCONT cannot be ignored.If func is the address of handler, upon receipt of the signal sig, the receiving process is to invoke handler as follows:handler (int sig, int code, struct sigcontext *sc);The remaining arguments are supplied as extensions and are optional. The value of the second argument   code is meaningful only in the cases shown in IDREF="45343" TYPE="TABLE"Table A-5
.COLUMNS="3"LEFT="0" WIDTH="113"ConditionLEFT="120" WIDTH="113"SignalLEFT="240" WIDTH="356"CodeLEFT="0" WIDTH="113"User breakpoint LEFT="120" WIDTH="113"SIGTRAPLEFT="240" WIDTH="356"BRK_USERBPLEFT="0" WIDTH="113"User breakpointLEFT="120" WIDTH="113"SIGTRAPLEFT="240" WIDTH="356"BRK_SSTEPBPLEFT="0" WIDTH="113"Integer overflow LEFT="120" WIDTH="113"SIGTRAPLEFT="240" WIDTH="356"BRK_OVERFLOWLEFT="0" WIDTH="113"Divide by zeroLEFT="120" WIDTH="113"SIGTRAPLEFT="240" WIDTH="356"BRK_DIVZEROLEFT="0" WIDTH="113"Multiply overflowLEFT="120" WIDTH="113"SIGTRAPLEFT="240" WIDTH="356"BRK_MULOVFLEFT="0" WIDTH="113"Invalid virtual address LEFT="120" WIDTH="113"SIGSEGVLEFT="240" WIDTH="356"EFAULTLEFT="0" WIDTH="113"Read-only addressLEFT="120" WIDTH="113"SIGSEGVLEFT="240" WIDTH="356"EACCESSLEFT="0" WIDTH="113"Read beyond mapped 
objectLEFT="120" WIDTH="113"SIGSEGVLEFT="240" WIDTH="356"ENXIOLBL="A-5"Table A-5 ID="45343"Valid Codes in a Signal-catching FunctionThe third argument, sc, is a pointer to a struct sigcontext (defined in <sys/signal.h>) that contains the processor context at the time of the signal. Upon return from handler, the receiving process will resume execution at the point it was interrupted. Before entering the signal-catching function, the value of func for the caught signal will be set to SIG_DFL, unless the signal is SIGILL, SIGTRAP, or SIGPWR. This means that before exiting the handler, a call to signal is necessary to catch future signals. When a signal that is to be caught occurs during a read(2), a write(2), an open(2), or an ioctl(2) system call on a slow device (like a terminal; but not a file), during a pause(2) system call, or during a wait(2) system call that does not return immediately due to the existence of a previously stopped or zombie process, the signal catching function will be executed and then the interrupted system call can return a ­1 to the calling process with errno set to EINTR.   ID="appendix.A112"The signals SIGKILL and SIGSTOP cannot be caught.LBL="" HELPID=""Signal NotesIf SIG_DFL is assigned for SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGEMT, SIGFPE, SIGBUS, SIGSEGV, or SIGSYS, in addition to the process being terminated, a "core image" will be constructed in the current working directory of the process, if the following conditions are met:The effective user ID and the real user ID of the receiving process are equal. An ordinary file named core exists and is writable or can be created. If the file must be created, it will have the following properties:a mode of 0666 modified by the file creation mask [see umask(2)]a file owner ID that is the same as the effective user ID of the receiving process.a file group ID that is the same as the effective group ID of the receiving processThe core file can be truncated if the resultant file size would exceed either ulimit [see ulimit(2)] or the process's maximum core file size [see setrlimit(2)].For the signals SIGCLD, SIGWINCH, SIGPWR, SIGURG, and SIGIO, the actions associated with each of the three possible values for func are:SIG_DFLignore signalThe signal is to be ignored.SIG_IGNignore signal The signal is to be ignored. Also, if sig is SIGCLD, the calling process's child processes will not create zombie processes when they terminate [see exit(2)].handlercatch signal If the signal is SIGPWR, SIGURG, SIGIO, or SIGWINCH, the action to be taken is the same as that described above when func is the address of a function. The same is true if the signal is SIGCLD with one exception: while the process is executing the signal-catching function, all terminating child processes will be queued. The wait system call removes the first entry of the queue. If the signal system call is used to catch SIGCLD, the signal handler must be reattached when exiting the handler, and at that timename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'if the queue is not emptyname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'SIGCLD is re- raised before signal returns. See wait(2).In addition, SIGCLD affects the wait and exit system calls as follows:waitIf the handler parameter of SIGCLD is set to SIG_IGN and a wait is executed, the wait will block until all of the calling process's child processes terminate; it will then return a value of -1 with errno set to ECHILD.exitIf in the exiting process's parent process the handler parameter of SIGCLD is set to SIG_IGN, the exiting process will not create a zombie process.When processing a pipeline, the shell makes the last process in the pipeline the parent of the preceding processes. A process that can be piped into in this manner (and thus become the parent of other processes) should take care not to set SIGCLD to be caught.SIGPOLL is issued when a file descriptor corresponding to a STREAMS [see intro(2)] file has a ``selectable'' event pending. A process must specifically request that this signal be sent using the I_SETSIG ioctl call. Otherwise, the process will never receive SIGPOLL.SIGEMT is never generated on an IRIS-4D system.SIGTRAP is generated for breakpoint instructions, overflows, divide by zeros, range errors, and multiply overflows. The second argument code gives specific details of the cause of the signal. Possible values are described in <sys/signal.h>.The signals SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU and SIGCONT are used by command interpreters like the C shell [see csh(1)] to provide job control. The first four signals listed will stop the receiving process  unless the signal is caught or ignored. SIGCONT resumes a stopped process. SIGTSTP is sent from the terminal driver in response to the SWTCH character being entered from the keyboard [see termio(7)]. SIGTTIN is sent from the terminal driver when a background process attempts to read from its controlling terminal. If SIGTTIN is ignored by the process, then the read will return EIO. SIGTTOU is sent from the terminal driver when a background process attempts to write to its controlling terminal when the terminal is in TOSTOP mode. If SIGTTOU is ignored by the process, then the write will succeed regardless of the state of the controlling terminal.Signal will not catch an invalid function argument, func, and results are undefined when an attempt is made to execute the function at the bad address.SIGKILL will immediately terminate a process, regardless of its state.Processes stopped via job control (typically <Ctrl>-Z) will not act upon any delivered signals other than SIGKILL until the job is restarted. Processes blocked via a blockproc(2) system call will unblock if they receive a signal which is fatal (that is, a non-job-control signal which they are not catching). These processes will remained stopped, however, if the job they are a part of is stopped. Only upon restart will they die. Any non-fatal signals received by a blocked process will not cause the process to be unblocked. An unblockproc(2) or unblockprocall(2) system call is necessary.If an instance of signal sig is pending when signal(sig,func) is executed, the pending signal is cancelled unless it is SIGKILL.signal() will fail if sig is an illegal signal number, including SIGKILL and SIGSTOP, or if an illegal operation is requested (such as ignoring SIGCONT, which is ignored by default). In these cases,   signal() returns SIG_ERR and sets errno to EINVAL.After a fork(2) the child inherits all handlers and signal masks. If any signals are pending for the parent, they are not inherited by the child.The exec(2) routines reset all caught signals to the default action; ignored signals remain ignored; the blocked signal mask is unchanged and pending signals remain pending.These man pages contain other relevant information: intro(2), blockproc(2), kill(2), pause(2), ptrace(2), sigaction(2), sigset(2), wait(2), setjmp(3C), sigvec(3B), and   kill(1). LBL="" HELPID=""DiagnosticsUpon successful completion, signal returns the previous value of func for the specified signal sig. Otherwise, a value of SIG_ERR is returned and errno is set to indicate the error. SIG_ERR is defined in the header file <sys/signal.h>.Signals raised by the instruction streamname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'SIGILL, SIGEMT, SIGBUS, SIGSEGVname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'will cause infinite loops if their handler returns, or the action is set to SIG_IGN. The POSIX signal routines (sigaction(2), sigpending(2), sigprocmask(2), sigsuspend(2), sigsetjmp(3)), and the 4.3BSD signal routines (sigvec(3B), signal(3B), sigblock(3B), sigpause(3B), sigsetmask(3B)) must never be used with signal(2) or   sigset(2).Before entering the signal-catching function, the value of func for the caught signal will be set to SIG_DFL, unless the signal is SIGILL, SIGTRAP, or SIGPWR. This means that before exiting the handler, a signal call is necessary to again set the disposition to catch the signal.Note that handlers installed by signal execute with no signals blocked, not even the one that invoked the handler.The default handling and the handling at program startup for each signal recognized by the signal   function (4.7.1.1). Each signal is set to SIG_DFL at program startup. ID="appendix.A113"If the equivalent of signal(sig, SIG_DFL);   is not executed prior to the call of a signal handler, the blocking of the signal that is performed(4.7.1.1).The equivalent of signal(sig, SIG_DFL); is executed prior to the call of a signal handler unless the signal is SIGILL, SIGTRAP, or SIGPWR. See  the signal(3B) man page for information on the support for the BSD4.3 signal facilities. Whether the default handling is reset if the SIGILL signal is received by a handler specified to the signal function (4.7.1.1). No.LBL="A.14.2" HELPID=""Streams and Files Whether the last line of a text stream requires a terminating newline character (4.9.2). There is no requirement that the last line of a text stream have a terminating newline: the output will be flushed when the program terminates if not earlier (as a result of ID="appendix.A114"ID="appendix.A115"ID="appendix.A116"fflush() call). However subsequent processes/programs reading the text stream or file might expect the newline to be present; it customarily is in IRIX text files. Whether space characters that are written out to a text stream immediately before a newline character appear when read in (4.9.2).   All text characters (including spaces before a newline character) written out to a text stream appear exactly as written when read back in. The number of null characters that can be appended to data written to a binary stream (4.9.2). The library never appends nulls to data written to a binary stream. Only the characters written by the application are written to the output stream, whether binary or text. Text and binary streams are identical: there is no distinction. ID="appendix.A117"ID="appendix.A118"Whether the file position indicator of an append mode stream is initially positioned at the beginning or end of the file. (4.9.2)The file position indicator of an append stream is initially positioned at the end of the file. ID="appendix.A119"ID="appendix.A120"Whether a write on a text stream causes the associated file to be truncated beyond that point (4.9.3). A write on a text stream does not cause the associated file to be truncated. ID="appendix.A121"The characteristics of file buffering (4.9.3) Files are fully buffered, as described in paragraph 3 of section 4.9.3 of ANSI X3.159-1989.ID="appendix.A122"Whether a zero-length file actually exists (4.9.3). Zero-length files exist, but have no data, so a read on such a file gets an immediate EOF. ID="appendix.A123"ID="appendix.A124"The rules for composing valid file names (4.9.3).  Filenames consist of 1 to FILENAME_MAX characters. These characters can be selected from the set of all character values excluding \0 (null) and the ASCII code for / (slash).ID="appendix.A125"ID="appendix.A126"ID="appendix.A127"   Note that it is generally unwise to use *, ?, [, or ] as part of file names because of the special meaning attached to these characters by the shell [see sh(1)]. Although permitted, the use of unprintable characters should be avoided.Whether the same file can be opened multiple times (4.9.3). A file can be open any number of times. ID="appendix.A128"The effect of the remove   function on an open file (4.9.4.1). For local disk files, a remove removes a directory entry pointing to the file but has no effect on the file or the program with the file open. For files remotely mounted via NFS the effect is unpredictable (the file might be removed making further I/O impossible through open streams, or it might behave like a local disk file) and might depend on the version(s) of NFS involved. ID="appendix.A129"ID="appendix.A130"The effect if a file with the new name exists prior to a call to the rename function (4.9.4.2). If the new name exists, the file with that new name is removed (See rm(1)) before the rename is done. ID="appendix.A131"ID="appendix.A132"ID="appendix.A133"The output for %p conversion in the ID="appendix.A134"fprintf function (4.9.6.1). %p is treated the same as %x. The input for %p conversion in the ID="appendix.A135"fscanf function (4.9.6.2). %p is treated the same as %x. The interpretation of a ­   character that is neither the first nor the last character in the scanlist for %[   conversion in the fscanf   function (4.9.6.2).A ­ character that does not fit the pattern mentioned above is used as a shorthand for ranges of characters. For example, [xabcdefgh] and   [xa-h] mean that characters a through   h and the character   x are in the range (called a scanset in 4.9.6.2). ID="appendix.A136"LBL="A.14.3" HELPID=""Temporary FilesWhether a temporary file is removed if a program terminates abnormally (4.9.4.3). Temporary files are removed if a program terminates abnormally. ID="appendix.A137"LBL="A.14.4" HELPID=""ID="71777"errno and perrorThe value to which the macro errno is set by the   fgetpos or   ftell function on failure (4.9.9.1, 4.9.9.4). errno is set to EBADF (9) by the ID="appendix.A138"ID="appendix.A139"ID="appendix.A140"fgetpos or ftell function on failure. The messages generated by theID="appendix.A141"   perror function (4.9.10.4). The message generated is simply a string. The content of the message given for each legal value of errno is given in the list below which is of the format errno_value:message.   1: No permission match   2: No such file or directory   3: No such process   4: Interrupted system call   5: I/O error   6: No such device or address   7: Arg list too long   8: Exec format error   9: Bad file number   10: No child processes   11: Resource temporarily unavailable   12: Not enough space   13: Permission denied   14: Bad address   15: Block device required   16: Device or resource busy   17: File exists   18: Cross-device link   19: No such device   20: Not a directory   21: Is a directory   22: Invalid argument   23: Too many open files in system   24: Too many open files in a process   25: Inappropriate IOCTL operation   26: Text file busy   27: File too large   28: No space left on device   29: Illegal seek   30: Read-only file system   31: Too many links   32: Broken pipe   33: Argument out of domain   34: Result too large   35: No message of desired type   36: Identifier removed   37: Channel number out of range   38: Level 2 not synchronized   39: Level 3 halted   40: Level 3 reset   41: Link number out of range   42: Protocol driver not attached   43: No CSI structure available   44: Level 2 halted   45: Deadlock situation detected/avoided   46: No record locks available   47: Error 47   48: Error 48   49: Error 49   50: Bad exchange descriptor   51: Bad request descriptor   52: Message tables full   53: Anode table overflow   54: Bad request code   55: Invalid slot   56: File locking deadlock   57: Bad font file format   58: Error 58   59: Error 59   60: Not a stream device   61: No data available   62: Timer expired   63: Out of stream resources   64: Machine is not on the network   65: Package not installed   66: Object is remote   67: Link has been severed   68: Advertise error   69: Srmount error   70: Communication error on send   71: Protocol error   72: Error 72   73: Error 73   74: Multihop attempted   75: Error 75   76: Error 76   77: Not a data message   78: Error 78   79: Error 79   80: Name not unique on network   81: File descriptor in bad state   82: Remote address changed   83: Cannot access a needed shared library   84: Accessing a corrupted shared library   85: .lib section in a.out corrupted   86: Attempting to link in more shared libraries than system limit   87: Cannot exec a shared library directly   88: Invalid System Call   89: Error 89   90: Error 90   91: Error 91   92: Error 92   93: Error 93   94: Error 94   95: Error 95   96: Error 96   97: Error 97   98: Error 98   99: Error 99 100: Error 100 101: Operation would block 102: Operation now in progress 103: Operation already in progress 104: Socket operation on non-socket 105: Destination address required 106: Message too long 107: Protocol wrong type for socket 108: Option not supported by protocol 109: Protocol not supported 110: Socket type not supported 111: Operation not supported on socket 112: Protocol family not supported 113: Address family not supported by protocol family 114: Address already in use 115: Can't assign requested address 116: Network is down 117: Network is unreachable 118: Network dropped connection on reset 119: Software caused connection abort 120: Connection reset by peer 121: No buffer space available 122: Socket is already connected 123: Socket is not connected 124: Can't send after socket shutdown 125: Too many references: can't splice 126: Connection timed out 127: Connection refused 128: Host is down 129: Host is unreachable 130: Too many levels of symbolic links 131: File name too long 132: Directory not empty 133: Disc quota exceeded 134: Stale NFS file handleSee the perror(3C) man page for further information. LBL="A.14.5" HELPID=""Memory allocation The behavior of the ID="appendix.A142"calloc, ID="appendix.A143"malloc, or ID="appendix.A144"realloc function if the size requested is zero (4.10.3). The malloc etc. in libc.a returns a pointer to a zero-length space if a size of zero is requested. Successive calls to malloc return different zero-length pointers. If the library   ID="appendix.A145"libmalloc.a is used, malloc etc. return 0 (the NULL pointer). LBL="A.14.6" HELPID=""The abort functionThe behavior of the abort function with regard to open and temporary files (4.10.4.1). Open files are not flushed, but are closed. Temporary files are removed. ID="appendix.A146"ID="appendix.A147"ID="appendix.A148"LBL="A.14.7" HELPID=""The exit functionThe status returned by the ID="appendix.A149"exit function if the value of the argument is other than zero, EXIT_SUCCESS or EXIT_FAILURE (4.10.4.3). The status returned to the environment is the least significant eight (8) bits of the value passed to exit. LBL="A.14.8" HELPID=""The getenv functionThe set of environment names and the method for altering the environment list used by the getenv   function (4.10.4.4). Any string can be used as the name of an environment variable, and any string can be used for its value. The function ID="appendix.A150"ID="appendix.A151"ID="appendix.A152"ID="appendix.A153"ID="appendix.A154"putenv alters the environment list of the application. For example,putenv("MYNAME=foo")sets the value of the environment variable MYNAME to ``foo''. If the environment variable MYNAME already existed, its value is changed. If it did not exist, it is added. The string passed to putenv will actually become part of the environment, and changing it later will alter the environment. Further, the string should not be space which was automatically allocated (for example, an auto array); rather, it should be space which is either global or malloced. For more information, see the putenv(3C) man page. It is not wise to alter the value of well-known environment variables. For the current list, see the man page for environ(3c).LBL="A.14.9" HELPID=""The system functionThe contents and mode of execution of the string passed to the ID="appendix.A155"system function (4.10.4.5). The contents of the string should be a command string, as if typed to a normal IRIX shell, such as sh(1). A shell (sh(1)) is forked, and the string is passed to it. The current process waits until the shell has completed and returns the exit status of the shell as the return value. LBL="A.14.10" HELPID=""The strerror functionThe contents of the error message strings returned by the strerror function (4.11.6.2). The string is exactly the same as the string output by perror, which is documented in IDREF="71777" TYPE="TITLE"Section A.14.4, "errno and perror."LBL="A.14.11" HELPID=""Timezones and the clock function. The local time zone and Daylight Saving Time (4.12.1). Local time and Daylight Saving Time are determined by the value of the ID="appendix.A156"ID="appendix.A157"ID="appendix.A158"ID="appendix.A159"TZ environment variable. TZ is set by init(1) to the default value indicated in the file /etc/TIMEZONE, and this value is inherited in the environment of all processes. If TZ is unset, the local time zone defaults to GMT (Greenwich Mean Time, or Coordinated Universal Time), and Daylight Savings Time is not in effect. See the man pages ctime(3C), time(2), timezone(4), environ(5), getenv(3), and other related man pages for the format of TZ. The era for the clock function (4.12.2.1). clockID="appendix.A160" counts seconds from 00:00:00: GMT, January 1, 1970. What was once known as Greenwich Mean Time (GMT) is now known as Coordinated Universal Time (UTC), though the man pages do not reflect this change yet. See the   ctime(3C) man page for further information. LBL="A.15" HELPID=""Locale-Specific Behavior (F.4)For information on locale-specific behavior, refer to the X/Open Portability Guide, Volume 3, "XSI   Supplementary Definitions," published by Prentice Hall, Englewood Cliffs, New Jersey 07632, ISBN 0-13-685-850-3.LBL="A.16" HELPID=""Common Extensions (F.5)The following extensions are widely used in many systems, but are not portable to all implementations. The inclusion of any extension that can cause a strictly conforming program to become invalid renders an implementation nonconforming. Examples of such extensions are new keywords, or library functions declared in standard headers or predefined macros with names that do not begin with an underscore. The Standard's description of each extension is followed by a definition of Silicon Graphics' support/nonsupport of each common extension. LBL="A.16.1" HELPID=""Environment Arguments (F.5.1)In a hosted environment, the main function receives a third argument, char *envp[], that points to a null-terminated array of pointers to char, each of which points to a string that provides information about the environment for this execution of the process (2.1.2.1.1). This extension is supported. LBL="A.16.2" HELPID=""Specialized IdentifiersCharacters other than the underscore _, letters, and digits, that are not defined in the required source character set (such as dollar sign $, or characters in national character sets) can appear in an identifier. If the ­dollar option is given to cc then dollar sign $ is allowed in identifiers.   LBL="A.16.3" HELPID=""Lengths and Cases of IdentifiersAll characters in identifiers (with or without external linkage) are significant and case distinctions are observed (3.1.2). Identifiers (whether external linkage, internal linkage, or no linkage) of up to 8191 characters are allowed and are significant. Case distinctions are observed. LBL="A.16.4" HELPID=""Scopes of Identifiers (F.5.4)A function identifier, or the identifier of an object the declaration of which contains the keyword extern   has file scope.This is true of the compiler when invoked with cc ­cckr (that is, when requesting traditional C). When compiling in ANSI mode (by default or with one of the ANSI options) function identifiers (and all other identifiers) have block scope when declared at block level. LBL="A.16.5" HELPID=""Writable String Literals (F.5.5)String literals are modifiable. Identical string literals shall be distinct (3.1.4). All string literals are distinct and writable. LBL="A.16.6" HELPID=""Other Arithmetic Types (F.5.6)Other arithmetic types, such as long long int and their appropriate conversions are defined (3.2.2.1). Yes. LBL="A.16.7" HELPID=""Function Pointer Casts (F.5.7)A pointer to an object or to void can be cast to a pointer to a function, allowing data to be invoked as a function (3.3.4). A pointer to a function can be cast to a pointer to an object or to void   allowing a function to be inspected or modified (for example, by a debugger) (3.3.4).Function pointers can be cast to a pointer to an object or void and vice versa.Data can be invoked as a function.Casting a pointer to a function to a pointer to an object or void does allow a function to be inspected. Normally, functions cannot be written to, since text space is read-only. Dynamically loaded functions will be loaded (by a user program) into data space and can be written to. LBL="A.16.8" HELPID=""Non-int Bit-Field Types (F.5.8)Types other than int, unsigned int, and signed int   can be declared as bitfields, with appropriate maximum widths (3.5.2.1).   No such extension is supported in ­ansi mode. A bitfield can be any integral type in ­xansi and ­cckr modes.. LBL="A.16.9" HELPID=""The fortran Keyword (F.5.9)The   fortran   declaration specifier can be used in a function declaration to indicate that calls suitable for Fortran should be generated, or that different representations for external names are to be generated (3.5.4.3).The fortran keyword is not supported in this ANSI C. With   cc ­cckr that keyword is accepted but ignored. LBL="A.16.10" HELPID=""The asm Keyword (F.5.10)The asm   keyword can be used to insert assembly language code directly into the translator output. The most common implementation is via statement of the form   asm (character-string-literal)   (3.6).The asm keyword is not supported. LBL="A.16.11" HELPID=""Multiple External Definitions (F.5.11)There can be more than one external definition for the identifier of an object, with or without the explicit use of the keyword extern. If the definitions disagree, or more than one is initialized, the behavior is undefined (3.7.2).With ANSI C, only one external definition of the object is permitted. If more than one is present, the linker (ld(1) will give a warning message. The Strict Ref/Def model is followed (ANSI C Rationale, 3.1.2.2, page 23).With cc ­cckr the Relaxed Ref/Def model is followed (ANSI C Rationale, 3.1.2.2, page 23): multiple definitions of the same identifier of an object in different files are accepted and all but one of the definitions are treated (silently) as if they had the extern keyword.If the definitions in different source units disagree the mismatch is not currently detected by the linker (ld) and the resulting program will probably not work correctly. LBL="A.16.12" HELPID=""Empty Macro Arguments (F.5.12)A macro argument can consist of no preprocessing tokens (3.8.3). This extension is supported. For example, one could define a macro such as #define notokargs() macrovalueLBL="A.16.13" HELPID=""Predefined Macro Names (F.5.13)Macro names that do not begin with an underscore, describing the translation and execution environments, may be defined by the implementation before translation begins (3.8.8).This is not true for cc -ansi, which defines ANSI C. Only macro names beginning with two underscores or a single underscore followed by a capital letter are predefined by the implementation before translation begins. The name space is not polluted.With cc ­cckr   (traditional C) a C preprocessor is used with a full set of the predefined symbols. For example, sgi is predefined.With cc ­xansi   (which is the default for cc) an ANSI C preprocessor and compiler are used and a full set of predefined symbols is defined (including sgi for example). If the compiler predefines __STDC__, it sets the value to 1 and there are no predefined macro names in the user's name space. See the cc man page for more details. LBL="A.16.14" HELPID=""Extra Arguments for Signal Handlers (F.5.14)Handlers for specific signals can be called with extra arguments in addition to the signal number.Silicon Graphics supports System V, POSIX, and BSD signal handlers. There are extra arguments to the handler available for your use. See the signal man page.LBL="A.16.15" HELPID=""Additional Stream Types and File-Opening Modes (F.5.15)Additional mappings from files to streams may be supported (4.9.2), and additional file-opening modes may be specified by characters appended to the mode   argument of the fopen   function (4.9.5.3).There are no additional modes supported. There are no additional mappings. The UNIX approach is used, as mentioned in the ANSI C Rationale, Section 4.9.2, page 90. LBL="A.16.16" HELPID=""Defined File Position Indicator (F.5.16)The file position indicator is decremented by each successful call to the ungetc function for a text stream, except if its value was zero before a call (4.9.7.11).   Only the one character of pushback guaranteed by the standard is supported.postfixIDREF="chap.0763"Prefix ++ and ­ ­ Operators! operatorIDREF="chap.0760"Unary !   and   ~   Operators!= operatorIDREF="chap.07104"Equality Operators#pragma weakIDREF="appendix.A82"Preprocessing Directives (F.3.13)% operatorIDREF="chap.0778"Multiplicative Operators %p conversionin fscanf functionIDREF="appendix.A133"Streams and Files %p conversionin fprintf functionIDREF="appendix.A133"Streams and Files & operatorIDREF="chap.0752"Address-of and Indirection OperatorsIDREF="chap.07107"Bitwise AND Operatorfields andIDREF="chap.0843"Bitfields&& operatorIDREF="chap.07125"Logical AND Operator&minusIDREF="chap.0763"Prefix ++ and ­ ­ OperatorsIDREF="chap.0765"Prefix ++ and ­ ­ OperatorsIDREF="chap.0765"Prefix ++ and ­ ­ Operators< operatorIDREF="chap.0797"Relational Operators<< operatorIDREF="chap.0792"Shift Operators<= operatorIDREF="chap.0799"Relational Operators­ ­IDREF="chap.0744"Postfix ++ and   ­ ­* operatorIDREF="chap.0776"Multiplicative Operators+ operatorIDREF="chap.0786"Additive OperatorsIDREF="chap.0756"Unary + and   ­ Operators++IDREF="chap.0745"Postfix ++ and   ­ ­++ operatorIDREF="chap.0764"Prefix ++ and ­ ­ Operators+= operatorIDREF="chap.07143"Compound Assignment, operatorIDREF="chap.07149"Comma Operator- characterin fscanf functionIDREF="appendix.A136"Streams and Files - operatorIDREF="chap.0785"Additive OperatorsIDREF="chap.0755"Unary + and   ­ Operators-= operatorIDREF="chap.07144"Compound Assignment-I compiler optionIDREF="appendix.A80"Preprocessing Directives (F.3.13)-nostdinc compiler optionIDREF="appendix.A79"Preprocessing Directives (F.3.13)= operatorIDREF="chap.07138"Assignment using = (Simple Assignment)== operatorIDREF="chap.07103"Equality Operators> operatorIDREF="chap.0798"Relational Operators>= operatorIDREF="chap.07100"Relational Operators>> operatorIDREF="chap.0791"Shift Operators? operatorIDREF="chap.07133"Conditional Operator^ operatorIDREF="chap.07113"Bitwise Exclusive OR Operator__DATE__IDREF="appendix.A83"Preprocessing Directives (F.3.13)__TIME__IDREF="appendix.A84"Preprocessing Directives (F.3.13)abort functioneffect on temporary filesIDREF="appendix.A148"The abort functionacppchangesIDREF="chap.032"Preprocessor Changesadditive operatorspointers andIDREF="chap.0787"Additive Operatorsaddress constantIDREF="chap.07155"Constant Expressionsaddress-of operatorIDREF="chap.0751"Address-of and Indirection Operatorsfields andIDREF="chap.0842"BitfieldsAND operatorlogicalIDREF="chap.07126"Logical AND OperatorANSI C standard header filesIDREF="chap.0374"Standard Headersansi compiler optioneffect on string literalsIDREF="chap.0310"Replacement of Macro Arguments in Stringsexternal names andIDREF="chap.0366"Data Area Name ChangesmacrosIDREF="chap.0311"Replacement of Macro Arguments in StringstokensIDREF="chap.0316"Token Concatenationansi switch to ccIDREF="chap.027"Compiling ANSI Programsappend mode streaminitial file positionIDREF="appendix.A119"Streams and Files argcIDREF="appendix.A14"Environment (F.3.2)argument promotionsIDREF="chap.0725"Function Callsargument type promotionschangesIDREF="chap.0348"Argument Type PromotionsargumentspassingIDREF="chap.0728"Function CallsargvIDREF="appendix.A15"Environment (F.3.2)arithmetic constant expressionsIDREF="chap.07153"Constant Expressionsarithmetic conversionsIDREF="chap.0622"Usual Arithmetic Conversionsarithmetic typesIDREF="chap.0565"Derived Typesarraytype required to hold maximum sizeIDREF="appendix.A57"Arrays and Pointers (F.3.7)assertIDREF="appendix.A89"Library Functions (F.3.14)diagnosticIDREF="appendix.A90"Library Functions (F.3.14)assignment operators+=IDREF="chap.07141"Compound Assignment-=IDREF="chap.07142"Compound Assignment=IDREF="chap.07137"Assignment using = (Simple Assignment)atan2IDREF="appendix.A103"Library Functions (F.3.14)atan2fIDREF="appendix.A104"Library Functions (F.3.14)autoIDREF="chap.089"Storage-class Specifiersauto keywordIDREF="chap.0816"Storage-class Specifiersauto storage classIDREF="chap.0815"Storage-class SpecifiersautomaticIDREF="chap.0531"Storage Durationbinary streamsnull characters inIDREF="appendix.A117"Streams and Files bitfieldsIDREF="chap.0841"Bitfieldsorder of allocationIDREF="appendix.A70"Structures, Unions, Enumerations, and Bitfields (F.3.9)signedness ofIDREF="appendix.A69"Structures, Unions, Enumerations, and Bitfields (F.3.9)straddling int boundariesIDREF="appendix.A71"Structures, Unions, Enumerations, and Bitfields (F.3.9)bits per characterIDREF="appendix.A30"Characters (F.3.4)bitwise AND operatorIDREF="chap.07106"Bitwise AND Operatorbitwise operationssigned integersIDREF="appendix.A44" Integers (F.3.5)bitwise OR operatorexclusiveIDREF="chap.07112"Bitwise Exclusive OR OperatorinclusiveIDREF="chap.07118"Bitwise Inclusive OR Operatorblock statementsIDREF="chap.096"Compound Statement or Blockbreak statementsIDREF="chap.0922"The switch   Statement   C libraryANSIIDREF="chap.0213"Compiling ANSI ProgramssharedIDREF="chap.0215"Compiling ANSI Programscase distinctionsin identifiersIDREF="appendix.A22"Identifiers (F.3.3)case labelIDREF="chap.0921"The switch   Statement   case valuesmaximum number ofIDREF="appendix.A76"Statements (F.3.12)cast operatorsIDREF="chap.0772"Cast Operatorsccansi modeIDREF="chap.026"Compiling ANSI Programscckr optionIDREF="chap.0221"Compiling ANSI Programsfullwarn optionIDREF="chap.0218"Compiling ANSI Programstraditional C optionIDREF="chap.0222"Compiling ANSI Programsxansi modeIDREF="chap.028"Compiling ANSI Programscc switchesIDREF="chap.025"Compiling ANSI Programscckr compiler optionIDREF="chap.0220"Compiling ANSI Programsexternal names andIDREF="chap.0367"Data Area Name ChangesmacrosIDREF="chap.038"Replacement of Macro Arguments in StringstokensIDREF="chap.0314"Token ConcatenationcharIDREF="chap.0820"Type Specifiersdefault signIDREF="appendix.A39"Characters (F.3.4)unsigned vs "plain"IDREF="appendix.A41"Characters (F.3.4)characterspaceIDREF="appendix.A1"Translation (F.3.1)white spaceIDREF="appendix.A3"Translation (F.3.1)character constantswideIDREF="chap.0421"Character Constantscharacter setIDREF="appendix.A23"Characters (F.3.4)charactersIDREF="appendix.A24"Characters (F.3.4)conversions to integerIDREF="chap.063"Conversions of Characters and Integersinteger constantsIDREF="appendix.A33"Characters (F.3.4)multi-byteIDREF="chap.0539"Character TypesmultibyteIDREF="appendix.A35"Characters (F.3.4)IDREF="appendix.A28"Characters (F.3.4)non-graphicalIDREF="chap.0426"Special Charactersnumber of bitsIDREF="appendix.A31"Characters (F.3.4)shift statesIDREF="appendix.A27"Characters (F.3.4)source set vs. execution setIDREF="appendix.A32"Characters (F.3.4)specialIDREF="chap.0425"Special CharacterstypeIDREF="chap.0535"Character TypeswideIDREF="appendix.A36"Characters (F.3.4)wide:initializationIDREF="chap.0883"Initialization of AggregatesCHRCLASS environment variableIDREF="appendix.A98"Library Functions (F.3.14)clock functionIDREF="appendix.A160"Timezones and the clock function. coding hintsIDREF="chap.0224"Helpful Programming Hintscoding practicesdiscouragedIDREF="chap.0230"Practices to AvoidrecommendedIDREF="chap.0226"Recommended Practicescomma operatorIDREF="chap.07148"Comma Operatorcompatibility ruleschangesIDREF="chap.0242"Areas of Major Changecompatible typeschangesIDREF="chap.0345"Compatible Typescompilation modeeffect on namesIDREF="chap.0368"Data Area Name Changescompound assignmentIDREF="chap.07140"Compound Assignmentcompound statementsscope of declarationsIDREF="chap.099"Compound Statement or Blockconditional operatorIDREF="chap.07132"Conditional OperatorconstIDREF="chap.0847"Type Qualifiersconst type qualifierIDREF="chap.0852"Type Qualifiersconstant expressionarithmeticIDREF="chap.07154"Constant Expressionsconstant expressionsIDREF="chap.0416"Constantsaddress constantIDREF="chap.07156"Constant ExpressionsintegralIDREF="chap.07151"Constant ExpressionsconstantsIDREF="chap.043"Lexical ConventionsIDREF="chap.0716"Primary ExpressionscharacterIDREF="chap.0420"Character ConstantsenumerationIDREF="chap.0435"Enumeration ConstantsintegerIDREF="chap.0418"Integer Constantswide characterIDREF="chap.0422"Character Constantscontinue statementsIDREF="chap.0929"The for   StatementIDREF="chap.0923"The switch   Statement   controlling expressiondefinitionIDREF="chap.0914"Selection StatementsconversionsIDREF="chap.062"Operator ConversionsarithmeticIDREF="chap.0617"Arithmetic ConversionscharacterIDREF="chap.065"Conversions of Characters and Integersfloat compiler option andIDREF="chap.068"Conversions of Float and Doublefloating-pointIDREF="chap.069"Conversions of Float and Doublefunction designatorsIDREF="chap.0629"Conversion of lvalues and Function DesignatorsintegerIDREF="chap.0615"Conversion of Unsigned Integersinteger:promotionsIDREF="chap.0620"Integral PromotionslvaluesIDREF="chap.0628"Conversion of lvalues and Function DesignatorspointerIDREF="chap.0612"Conversion of Pointers and IntegerspointersIDREF="chap.0633"Conversion of Pointersrules:traditional CIDREF="chap.0624"Traditional C Conversion RulesvoidIDREF="chap.0631"Conversion of Void ObjectscppchangesIDREF="chap.031"Preprocessor ChangesdateavailabilityIDREF="appendix.A86"Preprocessing Directives (F.3.13)Daylight Saving TimeIDREF="appendix.A158"Timezones and the clock function. declarationsas definitionsIDREF="chap.084"DeclarationsenumerationsIDREF="chap.0846"Enumeration DeclarationsmultipleIDREF="chap.082"DeclarationsstructureIDREF="chap.0833"Structure and Union DeclarationsunionIDREF="chap.0834"Structure and Union Declarationsdeclarations, implicitIDREF="chap.0876"Implicit DeclarationsdeclaratorsarrayIDREF="chap.0863"Array Declaratorsmaximum number ofIDREF="appendix.A75"Declarators (F.3.11)pointerIDREF="chap.0859"Pointer DeclaratorssyntaxIDREF="chap.0856"Declaratorsdecrement operatorIDREF="chap.0767"Prefix ++ and ­ ­ Operatorsdefault argument promotionsIDREF="chap.0726"Function Callsdefault labelIDREF="chap.0920"The switch   Statement   definitiondeclarationIDREF="chap.083"Declarationsderived typesIDREF="chap.0559"Derived TypesdeviceinteractiveIDREF="appendix.A18"Environment (F.3.2)diagnosticsclassesIDREF="appendix.A9"Translation (F.3.1)IDREF="appendix.A10"Translation (F.3.1)controlIDREF="appendix.A7"Translation (F.3.1)identificationIDREF="appendix.A5"Translation (F.3.1)return codesIDREF="appendix.A6"Translation (F.3.1)IDREF="appendix.A8"Translation (F.3.1)disambiguating nameschangesIDREF="chap.0237"Areas of Major Changediscouraged coding practicesIDREF="chap.0229"Practices to Avoiddivisionsign of remainderIDREF="appendix.A48" Integers (F.3.5)division by zeroIDREF="chap.076"Expressions and Operatorsdomain errorsreturn valuesIDREF="appendix.A100"Library Functions (F.3.14)doubleIDREF="chap.0827"Type Specifierselse statementsIDREF="chap.0916"The if   StatementenumIDREF="chap.0840"Structure and Union DeclarationschangesIDREF="chap.0328"Name Space Changesenumeration constantsIDREF="chap.0554"Integer and Floating Point TypesIDREF="chap.0436"Enumeration ConstantschangesIDREF="chap.0329"Name Space Changesenumeration typestype of int usedIDREF="appendix.A72"Structures, Unions, Enumerations, and Bitfields (F.3.9)enumeration variablesIDREF="chap.0845"Enumeration DeclarationsenvironmentalteringIDREF="appendix.A151"The getenv functionnamesIDREF="appendix.A150"The getenv functionvariablesIDREF="appendix.A150"The getenv functionenvironment namesIDREF="appendix.A152"The getenv functionenvironmentsIDREF="appendix.A11"Environment (F.3.2)freestandingIDREF="appendix.A12"Environment (F.3.2)envpIDREF="appendix.A16"Environment (F.3.2)equality operatorsIDREF="chap.07101"Equality OperatorsERANGE macroIDREF="appendix.A108"Library Functions (F.3.14)errnoIDREF="appendix.A105"Library Functions (F.3.14)errno macroIDREF="appendix.A140"errno and perrorescape sequencesIDREF="chap.0427"Special CharactersIDREF="appendix.A25"Characters (F.3.4)hexadecimalIDREF="chap.0430"Special Charactersexception handlingIDREF="chap.077"Expressions and OperatorsIDREF="chap.0711"Primary Expressionsexclusive OR operatorIDREF="chap.07114"Bitwise Exclusive OR Operatorexpression statementsIDREF="chap.092"Expression Statementexpressions­ ­IDREF="chap.0743"Postfix ++ and   ­ ­++IDREF="chap.0742"Postfix ++ and   ­ ­parenthesizedIDREF="chap.0718"Primary Expressionspostfix:function callsIDREF="chap.0723"Function Callspostfix:structure referencesIDREF="chap.0735"Structure and Union Referencespostfix:union referencesIDREF="chap.0734"Structure and Union ReferencesprimaryIDREF="chap.0715"Primary ExpressionsextensionsIDREF="chap.0210"Compiling ANSI ProgramsexternIDREF="chap.0810"Storage-class SpecifiersdefinitionsIDREF="chap.0331"Changes in the Linkage of Identifiersfunction definitionsIDREF="chap.107"External Function Definitionsexternal definitionsIDREF="chap.102"External Definitionsexternal function definitionsIDREF="chap.104"External Function Definitionsexternal linkageIDREF="chap.0527"Linkage of Identifiersexternal nameschangesIDREF="chap.0359"External Name Changescompiler options andIDREF="chap.0365"Data Area Name Changesfgetpos functionerrno on failureIDREF="appendix.A139"errno and perrorfile bufferingIDREF="appendix.A122"Streams and Files file namesIDREF="appendix.A126"Streams and Files file position indicatorinitial positionIDREF="appendix.A120"Streams and Files file scopeIDREF="chap.059"File Scopefilesopening multiple timesIDREF="appendix.A128"Streams and Files remove on an open fileIDREF="appendix.A130"Streams and Files renamingIDREF="appendix.A131"Streams and Files temporaryIDREF="appendix.A147"The abort functionvalid namesIDREF="appendix.A127"Streams and Files zero-lengthIDREF="appendix.A123"Streams and Files floatIDREF="chap.0826"Type Specifiersrepresentation ofIDREF="appendix.A52"Floating Point (F.3.6)float compiler optioneffect on conversionsIDREF="chap.067"Conversions of Float and Doubletype promotionsIDREF="chap.0338"Type Promotion in Arithmetic Expressionsfloating constantsIDREF="chap.0434"Floating Constantsfloating typesIDREF="chap.0560"Derived Typesfloating-pointIDREF="chap.0548"Integer and Floating Point Typesexception handlingIDREF="chap.078"Expressions and OperatorssizesIDREF="chap.0552"Integer and Floating Point TypesfmodIDREF="appendix.A109"Library Functions (F.3.14)fpcIDREF="chap.079"Primary ExpressionsfprintfIDREF="appendix.A134"Streams and Files fscanfIDREF="appendix.A135"Streams and Files ftell functionerrno on failureIDREF="appendix.A138"errno and perrorfucntionstypeIDREF="chap.1010"External Function Definitionsfullwarn compiler optionIDREF="chap.0217"Compiling ANSI ProgramsscopeIDREF="chap.0324"Scoping Differencesfunction prototype scopeIDREF="chap.056"Function Prototype ScopeIDREF="chap.0321"Scoping Differencesfunction prototypeschangesIDREF="chap.0243"Areas of Major Changeincompatible typesIDREF="chap.0354"Function PrototypesinconsistentIDREF="chap.0357"Function PrototypesfunctionscallsIDREF="chap.0722"Function CallsdeclaratorsIDREF="chap.0865"Function Declarators and Prototypesdesignators:conversionsIDREF="chap.0627"Conversion of lvalues and Function Designatorsexternal:definitionIDREF="chap.105"External Function DefinitionsprototypesIDREF="chap.0866"Function Declarators and Prototypesstorage-class specifiersIDREF="chap.108"External Function Definitionsgetenv functionIDREF="appendix.A154"The getenv functiongoto statementsIDREF="chap.0931"The goto Statementhandle_sigfpesIDREF="chap.0710"Primary Expressionsheader fileschangesIDREF="chap.0373"Standard Headersheaders, standardIDREF="chap.0370"Standard Headershexadecimal escape sequencesIDREF="chap.0431"Special CharactersidentifiersIDREF="appendix.A20"Identifiers (F.3.3)IDREF="chap.041"Lexical Conventionscase distinctionsIDREF="appendix.A21"Identifiers (F.3.3)disambiguating:changesIDREF="chap.0318"Changes in Disambiguating Identifiers lengthIDREF="chap.0412"Identifiersname spaceIDREF="chap.0520"Name Spacesscope:changesIDREF="chap.0320"Scoping Differencesif statementsIDREF="chap.0912"Selection Statementsinclude filesIDREF="appendix.A78"Preprocessing Directives (F.3.13)maximum nesting depthIDREF="appendix.A87"Preprocessing Directives (F.3.13)quoted namesIDREF="appendix.A81"Preprocessing Directives (F.3.13)inclusive OR operatorIDREF="chap.07120"Bitwise Inclusive OR Operatorincompatible typesfunction prototypes andIDREF="chap.0353"Function Prototypesincrement operatorIDREF="chap.0766"Prefix ++ and ­ ­ Operatorsindirect referencesIDREF="chap.0736"Indirect Structure and Union Referencesindirection operatorIDREF="chap.0750"Address-of and Indirection Operatorsinit-declarator-listdefinitionIDREF="chap.081"DeclarationsinitializationaggregratesIDREF="chap.0880"Initialization of Aggregatesand storage durationIDREF="chap.0814"Storage-class SpecifiersstructsIDREF="chap.0881"Initialization of AggregatesunionsIDREF="chap.0882"Initialization of AggregatesintIDREF="chap.0822"Type SpecifiersIDREF="chap.0544"Integer and Floating Point TypesintegerIDREF="chap.0549"Integer and Floating Point Typesconversions to characterIDREF="chap.064"Conversions of Characters and IntegerssizesIDREF="chap.0553"Integer and Floating Point Typesinteger character constantsIDREF="appendix.A34"Characters (F.3.4)integer divisionsign of remainderIDREF="appendix.A47" Integers (F.3.5)integersbitwise operationsIDREF="appendix.A45" Integers (F.3.5)conversionsIDREF="appendix.A43" Integers (F.3.5)pointersIDREF="chap.0611"Conversion of Pointers and IntegersrepresentationIDREF="appendix.A42" Integers (F.3.5)integral constant expressionsIDREF="chap.07152"Constant Expressionsintegral typesIDREF="chap.0562"Derived Typesinteractive deviceIDREF="appendix.A19"Environment (F.3.2)internal linkageIDREF="chap.0525"Linkage of IdentifiersisalnumIDREF="appendix.A91"Library Functions (F.3.14)isalphaIDREF="appendix.A92"Library Functions (F.3.14)iscntrlIDREF="appendix.A93"Library Functions (F.3.14)islowerIDREF="appendix.A94"Library Functions (F.3.14)isprintIDREF="appendix.A95"Library Functions (F.3.14)isupperIDREF="appendix.A96"Library Functions (F.3.14)iteration statementscontrolling expressionIDREF="chap.0925"Iteration Statementsflow of controlIDREF="chap.0926"Iteration StatementskeywordsIDREF="chap.042"Lexical Conventionslist ofIDREF="chap.0414"KeywordslabelscaseIDREF="chap.0917"The switch   Statement   defaultIDREF="chap.0918"The switch   Statement   name spaceIDREF="chap.0513"Name Spaceslibmalloc.aIDREF="appendix.A145"Memory allocation librariesshared CIDREF="chap.0216"Compiling ANSI ProgramsspecifyingIDREF="chap.0211"Compiling ANSI Programslibrary functions, prototypesIDREF="chap.0371"Standard HeaderslinkageIDREF="chap.086"Storage-class SpecifiersexternalIDREF="chap.0526"Linkage of IdentifiersidentifiersIDREF="chap.0523"Linkage of IdentifiersinternalIDREF="chap.0524"Linkage of IdentifiersnoneIDREF="chap.0528"Linkage of Identifierslinker-defined nameschangesIDREF="chap.0361"Changes in Linker-defined NamesliteralsIDREF="chap.0438"String Literalslocal timeIDREF="appendix.A158"Timezones and the clock function. logical operatorsANDIDREF="chap.07124"Logical AND OperatorORIDREF="chap.07130"Logical OR OperatorlongIDREF="chap.0823"Type Specifierslong intIDREF="chap.0545"Integer and Floating Point TypeslvaluesconversionsIDREF="chap.0626"Conversion of lvalues and Function Designatorsmacro argumentsIDREF="chap.034"Replacement of Macro Arguments in Stringsmacrosin ansi modeIDREF="chap.039"Replacement of Macro Arguments in Stringsin cckr modeIDREF="chap.037"Replacement of Macro Arguments in Stringsmainarguments toIDREF="appendix.A13"Environment (F.3.2)mallocIDREF="appendix.A143"Memory allocation math libraryANSIIDREF="chap.0212"Compiling ANSI Programsmathematics functionsdomain errorsIDREF="appendix.A99"Library Functions (F.3.14)underflow range errorsIDREF="appendix.A106"Library Functions (F.3.14)maximum array sizetype required to holdIDREF="appendix.A58"Arrays and Pointers (F.3.7)membersname spaceIDREF="chap.0515"Name Spacesmulti-byte charactersIDREF="chap.0541"Character Typesmultibyte charactersIDREF="appendix.A29"Characters (F.3.4)IDREF="appendix.A37"Characters (F.3.4)multiplicative operatorsIDREF="chap.0775"Multiplicative OperatorsnamedefinitionIDREF="chap.0411"Identifiersname spacesidentifiersIDREF="chap.0519"Name SpaceslabelsIDREF="chap.0514"Name SpacesmembersIDREF="chap.0516"Name SpacestagsIDREF="chap.0512"Name Spacesnamescompilation mode effect onIDREF="chap.0369"Data Area Name Changesdata area:changesIDREF="chap.0363"Data Area Name Changesdisambiguating:changesIDREF="chap.0236"Areas of Major ChangenamespacesIDREF="chap.022"What Is ANSI C?negationIDREF="chap.0757"Unary + and   ­ Operatorsnegative integersright shift onIDREF="appendix.A49" Integers (F.3.5)new-linein text streamsIDREF="appendix.A114"Streams and Files non-graphical charactersIDREF="chap.0423"Special CharactersNUL characterIDREF="chap.0428"Special CharactersnullIDREF="chap.0429"Special Charactersnull charactersin binary streamsIDREF="appendix.A118"Streams and Files NULL pointerIDREF="appendix.A88"Library Functions (F.3.14)null statementIDREF="chap.093"Expression StatementobjectdefinitionIDREF="chap.0569"Objects and lvaluesobjectsdefinitions:externalIDREF="chap.1012"External Object DefinitionsexternalIDREF="chap.1013"External Object Definitionsoffsetof() macroIDREF="chap.0228"Recommended Practicesone's complementIDREF="chap.0761"Unary !   and   ~   Operators/ operatorIDREF="chap.0777"Multiplicative Operators operatorIDREF="chap.0765"Prefix ++ and ­ ­ OperatorsoperatorsIDREF="chap.045"Lexical Conventions/IDREF="chap.0780"Multiplicative Operators%IDREF="chap.0781"Multiplicative Operators&IDREF="chap.07110"Bitwise AND Operator&minusIDREF="chap.0763"Prefix ++ and ­ ­ Operators<<IDREF="chap.0794"Shift Operators*IDREF="chap.0779"Multiplicative Operators+IDREF="chap.0783"Additive Operators++:prefixIDREF="chap.0762"Prefix ++ and ­ ­ Operators-IDREF="chap.0784"Additive Operators-:unaryIDREF="chap.0754"Unary + and   ­ Operators>>IDREF="chap.0793"Shift OperatorsANDIDREF="chap.07109"Bitwise AND OperatorassignmentIDREF="chap.07135"Assignment Operatorsassignment:+=IDREF="chap.07145"Compound Assignmentassignment:-=IDREF="chap.07146"Compound Assignmentassignment:=IDREF="chap.07139"Assignment using = (Simple Assignment)bitwise:ANDIDREF="chap.07108"Bitwise AND OperatorcastIDREF="chap.0773"Cast OperatorscommaIDREF="chap.07147"Comma OperatorconversionsIDREF="chap.061"Operator ConversionsequalityIDREF="chap.07102"Equality OperatorsevaluationIDREF="chap.073"Expressions and Operatorsexclusive ORIDREF="chap.07115"Bitwise Exclusive OR Operatorinclusive ORIDREF="chap.07121"Bitwise Inclusive OR OperatorindirectionIDREF="chap.0749"Address-of and Indirection Operatorslogical:ANDIDREF="chap.07123"Logical AND OperatorOR:exclusiveIDREF="chap.07116"Bitwise Exclusive OR OperatorOR:inclusiveIDREF="chap.07122"Bitwise Inclusive OR Operatororder of evaluationIDREF="chap.074"Expressions and OperatorsprecedenceIDREF="chap.071"Expressions and OperatorsrelationalIDREF="chap.0796"Relational OperatorsshiftIDREF="chap.0790"Shift OperatorsunaryIDREF="chap.0747"Unary Operators~IDREF="chap.0759"Unary !   and   ~   OperatorsOR operatorexclusiveIDREF="chap.07111"Bitwise Exclusive OR OperatorinclusiveIDREF="chap.07117"Bitwise Inclusive OR OperatorlogicalIDREF="chap.07129"Logical OR Operatororder of evaluationoperatorsIDREF="chap.075"Expressions and Operatorsoverflow handlingIDREF="chap.0712"Primary Expressionsparenthesized expressionsIDREF="chap.0719"Primary Expressionspassing argumentsIDREF="chap.0729"Function Callsperror functionIDREF="appendix.A141"errno and perrorpointersadditive operators onIDREF="chap.0788"Additive Operatorscasting to intIDREF="appendix.A62"Arrays and Pointers (F.3.7)conversion to intIDREF="appendix.A61"Arrays and Pointers (F.3.7)difference ofIDREF="appendix.A64"Arrays and Pointers (F.3.7)integer additions andIDREF="chap.0610"Conversion of Pointers and Integersto qualified typesIDREF="chap.0861"Qualifiers and Pointersto voidIDREF="chap.0635"Conversion of Pointerspostfix expressionsIDREF="chap.0721"Postfix Expressions­ ­IDREF="chap.0741"Postfix ++ and   ­ ­++IDREF="chap.0740"Postfix ++ and   ­ ­function callsIDREF="chap.0724"Function Callsindirect referencesIDREF="chap.0737"Indirect Structure and Union Referencesstructure referencesIDREF="chap.0732"Structure and Union Referencesunion referencesIDREF="chap.0733"Structure and Union ReferencespowIDREF="appendix.A101"Library Functions (F.3.14)powfIDREF="appendix.A102"Library Functions (F.3.14)precedence of operatorsIDREF="chap.072"Expressions and OperatorspreprocessorchangesIDREF="chap.033"Preprocessor Changesprimary expressionsIDREF="chap.0714"Primary Expressionsprogramming practicesdiscouragedIDREF="chap.0231"Practices to AvoidrecommendedIDREF="chap.0225"Recommended PracticespromotionsargumentsIDREF="chap.0727"Function Callsarguments:changesIDREF="chap.0349"Argument Type Promotionsarithmetic expressionsIDREF="chap.0337"Type Promotion in Arithmetic ExpressionschangesIDREF="chap.0334"Types and Type CompatibilityIDREF="chap.0240"Areas of Major Changefloating-pointIDREF="chap.0339"Type Promotion in Arithmetic ExpressionsintegralIDREF="chap.0619"Integral PromotionsIDREF="chap.0341"Type Promotion in Arithmetic Expressionsprototyped functionsIDREF="chap.0871"Prototyped Functions SummarizedprototypeschangesIDREF="chap.0244"Areas of Major ChangeIDREF="chap.0352"Function Prototypesincompatible typesIDREF="chap.0355"Function PrototypesinconsistentIDREF="chap.0356"Function Prototypesptrdiff_tIDREF="appendix.A63"Arrays and Pointers (F.3.7)punctuatorsIDREF="chap.046"Lexical Conventionslist ofIDREF="chap.0443"Punctuatorsputenv functionIDREF="appendix.A153"The getenv functionqualified typeschangesIDREF="chap.0238"Areas of Major ChangequalifiersIDREF="chap.0851"Type Qualifiersaccess to volatileIDREF="appendix.A74"   Qualifiers (F.3.10)constIDREF="chap.0853"Type QualifiersvolatileIDREF="chap.0855"Type QualifiersreallocIDREF="appendix.A144"Memory allocation recommended coding practicesIDREF="chap.0227"Recommended PracticesregisterIDREF="appendix.A65"Registers (F.3.8)IDREF="chap.0867"Function Declarators and Prototypesfunction declaration lists andIDREF="chap.109"External Function Definitionsregister keywordIDREF="chap.0817"Storage-class Specifiersremaindersign ofIDREF="appendix.A46" Integers (F.3.5)remove functionon an open fileIDREF="appendix.A129"Streams and Files rename functionIDREF="appendix.A132"Streams and Files result typedefinitionIDREF="chap.0623"Usual Arithmetic Conversionsright shifton negative integersIDREF="appendix.A50" Integers (F.3.5)roundingtype usedIDREF="appendix.A54"Floating Point (F.3.6)scalar typesIDREF="chap.0561"Derived TypesscopeblockIDREF="chap.053"Block ScopefunctionIDREF="chap.055"Function Scopefunction prototypeIDREF="chap.057"Function Prototype Scopescope, function prototypeIDREF="chap.0322"Scoping Differencesscopingchanges:function scopeIDREF="chap.0323"Scoping DifferencessetlocaleIDREF="appendix.A97"Library Functions (F.3.14)shared C libraryIDREF="chap.0214"Compiling ANSI Programsshift statesIDREF="appendix.A26"Characters (F.3.4)shortIDREF="chap.0821"Type Specifiersshort intIDREF="chap.0543"Integer and Floating Point Typesside effectsIDREF="chap.0232"Practices to Avoidsignal-catching functionsvalid codesIDREF="appendix.A112"Signalssignalsdefault handlingIDREF="appendix.A113"DiagnosticssemanticsIDREF="appendix.A111"SignalssignedIDREF="chap.0824"Type Specifierssize_tIDREF="appendix.A60"Arrays and Pointers (F.3.7)IDREF="chap.0770"The sizeof Unary OperatorsizeofIDREF="appendix.A59"Arrays and Pointers (F.3.7)IDREF="chap.0769"The sizeof Unary Operatortype of resultIDREF="chap.0771"The sizeof Unary Operatorspace characterIDREF="appendix.A2"Translation (F.3.1)special charactersIDREF="chap.0424"Special Charactersstandard header fileschangesIDREF="chap.0372"Standard HeadersstatementsblockIDREF="chap.097"Compound Statement or Blockcompound:scope of declarationsIDREF="chap.098"Compound Statement or BlocknullIDREF="chap.094"Expression StatementselectionIDREF="chap.0911"Selection StatementsstaticIDREF="chap.0530"Storage Durationfunction definitionsIDREF="chap.106"External Function Definitionsstatic keywordIDREF="chap.0811"Storage-class Specifiersstatic storage durationIDREF="chap.0813"Storage-class SpecifiersstdargIDREF="chap.0869"Function Declarators and PrototypesIDREF="chap.0234"Practices to Avoidrecommended practiceIDREF="chap.0233"Practices to AvoidstderrIDREF="appendix.A17"Environment (F.3.2)storage class sizesIDREF="chap.0542"Integer and Floating Point TypesIDREF="chap.0550"Integer and Floating Point Typesstorage class specifiersIDREF="chap.085"Storage-class Specifiersstorage durationIDREF="chap.087"Storage-class SpecifiersautoIDREF="chap.0818"Storage-class SpecifiersstaticIDREF="chap.0812"Storage-class Specifiersstring literalsIDREF="chap.0717"Primary ExpressionsIDREF="chap.044"Lexical ConventionsIDREF="chap.036"Replacement of Macro Arguments in StringsIDREF="chap.0437"String Literalsrecommended practiceIDREF="chap.0235"Practices to AvoidwideIDREF="chap.0439"String Literalswide:wide characters andIDREF="chap.0884"Initialization of Aggregatesstrings, macro arguments inIDREF="chap.035"Replacement of Macro Arguments in StringsstructIDREF="chap.0835"Structure and Union Declarationsname space of membersIDREF="chap.0517"Name Spacesnamespace:changesIDREF="chap.0326"Name Space Changesstructureindirect referencesIDREF="chap.0739"Indirect Structure and Union Referencesmembers:restrictionsIDREF="chap.0837"Structure and Union DeclarationsreferencesIDREF="chap.0731"Structure and Union ReferencesstructuresalignmentIDREF="appendix.A67"Structures, Unions, Enumerations, and Bitfields (F.3.9)initializationIDREF="chap.0879"Initialization of AggregatespaddingIDREF="appendix.A68"Structures, Unions, Enumerations, and Bitfields (F.3.9)switch statementsIDREF="chap.0919"The switch   Statement   IDREF="chap.0913"Selection Statementsmaximum number of case valuesIDREF="appendix.A77"Statements (F.3.12)tagsname spaceIDREF="chap.0511"Name Spacestemporary filesIDREF="appendix.A137"Temporary FilesIDREF="appendix.A146"The abort functiontext streamlast lineIDREF="appendix.A116"Streams and Files new-lineIDREF="appendix.A115"Streams and Files text streamswrites onIDREF="appendix.A121"Streams and Files timeavailabilityIDREF="appendix.A85"Preprocessing Directives (F.3.13)daylight savingsIDREF="appendix.A159"Timezones and the clock function. localIDREF="appendix.A159"Timezones and the clock function. timezoneIDREF="appendix.A157"Timezones and the clock function. tokensclasses ofIDREF="chap.047"Lexical Conventionsin ansi modeIDREF="chap.0315"Token Concatenationin cckr modeIDREF="chap.0313"Token Concatenationtraditional Ccompiler optionIDREF="chap.0219"Compiling ANSI Programstrigraph sequencesIDREF="chap.0432"Trigraph Sequences (ANSI C Only)truncationdirection ofIDREF="appendix.A55"Floating Point (F.3.6)IDREF="appendix.A56"Floating Point (F.3.6)type usedIDREF="appendix.A53"Floating Point (F.3.6)type namesIDREF="chap.0874"Type Namestype qualifiersIDREF="chap.0850"Type Qualifierstype specifiersIDREF="chap.0819"Type Specifierslist ofIDREF="chap.0829"Type SpecifierstypedefIDREF="chap.0839"Structure and Union DeclarationsIDREF="chap.088"Storage-class SpecifiersIDREF="chap.0877"typedefIDREF="chap.0849"Type Qualifierstypedef IDREF="chap.0830"Type SpecifierstypesIDREF="chap.0533"TypearithmeticIDREF="chap.0564"Derived TypeschangesIDREF="chap.0241"Areas of Major ChangecharacterIDREF="chap.0536"Character Typescompatibility:changesIDREF="chap.0335"Types and Type CompatibilityderivedIDREF="chap.0558"Derived TypesdoubleIDREF="chap.0557"Derived TypesfloatIDREF="chap.0556"Derived Typesfloating-pointIDREF="chap.0547"Integer and Floating Point TypesintegerIDREF="chap.0546"Integer and Floating Point TypesintegralIDREF="chap.0563"Derived Typesmulti-byte charactersIDREF="chap.0538"Character Typespromotions:changesIDREF="chap.0347"Argument Type PromotionsIDREF="chap.0333"Types and Type Compatibilitypromotions:floating-pointIDREF="chap.0340"Type Promotion in Arithmetic Expressionspromotions:integralIDREF="chap.0342"Type Promotion in Arithmetic ExpressionsscalarIDREF="chap.0555"Derived TypessizesIDREF="chap.0551"Integer and Floating Point Typesunsigned charIDREF="chap.0537"Character TypesvoidIDREF="chap.0567"The void TypeTZ environment variableIDREF="appendix.A156"Timezones and the clock function. underflow handlingIDREF="chap.0713"Primary Expressionsunderflow range errorsmath functionsIDREF="appendix.A107"Library Functions (F.3.14)unionIDREF="chap.0836"Structure and Union Declarationsaccessing membersIDREF="appendix.A66"Structures, Unions, Enumerations, and Bitfields (F.3.9)declarationIDREF="chap.0832"Structure and Union Declarationsindirect referencesIDREF="chap.0738"Indirect Structure and Union Referencesmember:s:restrictionsIDREF="chap.0838"Structure and Union Declarationsname space of membersIDREF="chap.0518"Name Spacesnamespace:changesIDREF="chap.0327"Name Space ChangesreferencesIDREF="chap.0730"Structure and Union Referencesunqualified typeschangesIDREF="chap.0239"Areas of Major ChangeunsignedIDREF="chap.0825"Type Specifiersunsigned charIDREF="chap.0540"Character TypesdefaultIDREF="appendix.A40"Characters (F.3.4)unsigned integersconversionsIDREF="chap.0614"Conversion of Unsigned Integersuser namespaceIDREF="chap.023"What Is ANSI C?valid file namesIDREF="appendix.A125"Streams and Files voidIDREF="chap.0828"Type SpecifiersconversionsIDREF="chap.0630"Conversion of Void Objectspointers toIDREF="chap.0634"Conversion of Pointersreturn statementsIDREF="chap.0935"The return   Statementvoid IDREF="chap.0868"Function Declarators and PrototypesvolatileIDREF="chap.0854"Type Qualifiersvolatile IDREF="chap.0848"Type Qualifiersvolatile-qualified typesaccess toIDREF="appendix.A73"   Qualifiers (F.3.10)white spaceIDREF="chap.048"Lexical ConventionsIDREF="appendix.A4"Translation (F.3.1)wide charactersIDREF="appendix.A38"Characters (F.3.4)wide string literalsIDREF="chap.0440"String Literalsxansi compiler optionexternal names andIDREF="chap.0364"Data Area Name Changesxansi switch to ccIDREF="chap.029"Compiling ANSI Programszero-length filesIDREF="appendix.A124"Streams and Files | operatorIDREF="chap.07119"Bitwise Inclusive OR Operator|| operatorIDREF="chap.07128"Logical OR Operator