#EDIR DATA#
The OpenGL Porting GuideDocument Number 007-1797-010CONTRIBUTORSWritten by C J Silverio and Beth FryerEdited by Nancy SchweigerCover design and illustration by Rob Aguilar, Rikk Carey,Dean Hodgkinson, Erik Lindholm, and Kay MaitzProduction by Lorrie WilliamsEngineering contributions by Kurt Akeley, Gavin Bell, Derrick Burns, Dave Ciemiewicz, Tom Davis, Phil Karlton, Reuel Nash, Mark Segal, Dave Shreiner, Mason Woo© Copyright 1993, Silicon Graphics, Inc.name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' All Rights ReservedThis document contains proprietary and confidential information of Silicon Graphics, Inc. The contents of this document may not be disclosed to third parties, copied, or duplicated in any form, in whole or in part, without the prior written permission of Silicon Graphics, Inc.RESTRICTED RIGHTS LEGENDUse, duplication, or disclosure of the technical data contained in this document by the Government is subject to restrictions as set forth in subdivision (c) (1) (ii) of the Rights in Technical Data and Computer Software clause at DFARS 52.227-7013 and/or in similar or successor clauses in the FAR, or in the DOD or NASA FAR Supplement. Unpublished rights reserved under the Copyright Laws of the United States. Contractor/manufacturer is Silicon Graphics, Inc., 2011 N. Shoreline Blvd., Mountain View, CA 94039-7311.Silicon Graphics and IRIS are registered trademarks, and Graphics Library, IRIS IM, IRIS Indigo, IRIS Inventor, IRIX, and OpenGL, and Personal IRIS are trademarks, of Silicon Graphics, Inc. X Window System is a trademark of Massachusetts Institute of Technology. OSF/Motif is a trademark of the Open Software Foundation, Inc.ID="37200"About This BookThis book describes how to port your existing IRISÆ GL code to OpenGL. It describes how to use the automatic translation script (called toogl) lists OpenGL equivalents for IRIS GL calls, describes how to reimplement IRIS GL windowing code with X and IRIS IM‘ (IRIS IM is Silicon Graphics' port of the industry-standard OSF/Motif‘ software), and gives you the very basics of what you need to know about X.This book is intended for developers who have been using IRIS GL. It is not an introduction to graphics programming and it is not comprehensive OpenGL documentation. For more complete OpenGL documentation, refer to the OpenGL Programming Guide, available from Addison-Wesley.This book is written for programmers who are working in C. The Fortran and Ada wrappers for OpenGL have not yet been determined, but will be available sometime in the future.† †LBL="" HELPID=""How to Use This GuideAs you use this guide, you'll probably need to refer often to the OpenGL man pages, as well as the IRIS GL man pages and programming guide. You can read all the man pages online using the man command, or you can buy the printed OpenGL man pages. These are published in the OpenGL Reference Manual, available in bookstores or from Silicon Graphics. LBL="" HELPID=""What This Guide ContainsThis guide includes the following chapters:IDREF="80988" TYPE="TITLE"Chapter 1, "Introduction to Porting from IRIS GL to OpenGL," describes some of the major differences between IRIS GL and OpenGL, lists the tools Silicon GraphicsÆ provides to help you with the translation, and provides some general porting instructions.IDREF="16996" TYPE="TITLE"Chapter 2, "Using toogl," describes how to use the automatic translation tool, which can do much of the porting work for you.IDREF="17509" TYPE="TITLE"Chapter 3, "After toogl: How to Finish Porting to OpenGL," discusses IRIS GL commands that might need some extra porting attention, giving command equivalents and providing porting tips for each.IDREF="45274" TYPE="TITLE"Chapter 4, "Using the Auxiliary Library to Replace Windowing and Event Handling Calls," explains how to use the auxiliary library to replace simple windowing and event handling commands (rather than using Xt or Xlib).IDREF="37274" TYPE="TITLE"Chapter 5, "OpenGL/X Mixed-Model Programming," describes two methods for using the X Window System‘ to manage windows and events with OpenGL: using Xt and the Silicon Graphics mixed-model programming widget or using Xlib. IRIS IM is also discussed in this chapter.IDREF="39727" TYPE="TITLE"Appendix A, "OpenGL Commands and Their IRIS GL Equivalents," is a complete alphabetical list of IRIS GL calls and their OpenGL equivalents (if an equivalent exists) along with cross-references to documentation, where available.IDREF="71689" TYPE="TITLE"Appendix B, "OpenGL/IRIS GL Differences," provides a more complete list of the differences between OpenGL and IRIS GL than is offered in IDREF="80988" TYPE="TITLE"Chapter 1
.IDREF="18405" TYPE="TITLE"Appendix C, "Some Important OpenGL Basics," explains the OpenGL naming conventions, lists OpenGL defined types, and describes error handling in OpenGL.IDREF="13844" TYPE="TITLE"Appendix D, "Example OpenGL Program with the Auxiliary Library," provides an example OpenGL program that uses the auxiliary library for windowing and event handling.IDREF="77823" TYPE="TITLE"Appendix E, "Example Mixed-Model Program with WorkProc," provides an example OpenGL mixed-model program using Xt, IRIS IM, and the Silicon Graphics widget. The program demonstrates the use of WorkProc for animation.LBL="" HELPID=""† †Where To Get More InformationID="intro1"For more information on programming in OpenGL, refer to these manuals:OpenGL Reference Manual, from the OpenGL Architecture Review Board, published by Addison-Wesley Publishing Company, Reading, Massachusetts, 1992. ISBN 0-201-63276-4. OpenGL Programming Guide, written by Jackie Neider, Tom Davis, and Mason Woo, published by Addison-Wesley Publishing Company, Reading, Massachusetts. ISBN 0-201-63274-8For more information on programming with IRIS GL, refer to these Silicon Graphics manuals:Graphics Library Programming Guide† †Graphics Library Programming Tools and Techniques† †For comprehensive information on the X Window System, Xlib, Xt, and X protocol, see the Digital Press X Series:X Window System: The Complete Reference to Xlib, X Protocol, ICCCM, XLFD, Third Edition, X Version 11, Release 5, Scheifler, Robert W., and James Gettys, et al., Digital Press - Digital Equipment Corporation, Burlington Massachusetts, 1992. ISBN 1-55558-088-2.X Window System Toolkit: The Complete Programmer's Guide and Specification, Asente, Paul J., and Ralph R. Swick, Digital Press - Digital Equipment Corporation, Burlington MA, 1992. ISBN 1-55558-051-3.Or refer to the O'Reilly X Window System Series, Volumes 1, 4, and 5:Volume One: Xlib Programming Manual, by Adrian Nye, published by O'Reilly & Associates, Inc., Sebastopol, California.Volume Four: X Toolkit Intrinsics Programming Manual, by Adrian Nye and Tim O'Reilly, published by O'Reilly & Associates, Inc., Sebastopol, California.Volume Five: X Toolkit Intrinsics Reference Manual, published by O'Reilly & Associates, Inc., Sebastopol, California.For information on OSF/Motif, see the Prentice-Hall OSF/Motif series:OSF/Motif Programmer's Guide, Open Software Foundation, PTR Prentice-Hall, Inc., Englewood Cliffs, NJ.OSF/Motif Programmer's Reference, Open Software Foundation, PTR Prentice-Hall, Inc., Englewood Cliffs, NJ. OSF/Motif Style Guide, Open Software Foundation, PTR Prentice-Hall, Inc., Englewood Cliffs, NJ.LBL="" HELPID=""Style ConventionsThese style conventions are used in this guide:Boldname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Command and routine names.Italicsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Variables, arguments, parameter names, and spatial dimensions.Code examples are set off from the text in a fixed-space font.LBL="1"Introduction to ID="80988"Porting from IRIS GL to OpenGLThis chapter provides an overview to porting from IRIS GL to OpenGL. It lists the most important differences between OpenGL and IRIS GL, describes some tools and libraries provided by Silicon Graphics that might help you port your code, and lists the basic steps for porting code from IRIS GL to OpenGL. It also provides some advice for programmers who do not plan to port to OpenGL immediately.LBL="" HELPID=""ID="64796"What's Different?ID="chap.011"Due in part to OpenGL's focus on portability, OpenGL and IRIS GL differ in several major areas. This section lists a few very important ways in which OpenGL is different from IRIS GL. A more complete list of the differences between the two is provided in IDREF="71689" TYPE="TITLE"Appendix B, "OpenGL/IRIS GL Differences."Here are some key differences between OpenGL and IRIS GL:Since OpenGL is window-system independent, it contains no windowing, pop-up menus, event handling, color-map loading, buffer allocation/management, font file formats, or cursor handling. These functions are delegated to the window or operating system. Silicon Graphics provides a small, auxiliary library that you can use to replace simple windowing, event handling, and color-map loading calls. See IDREF="45274" TYPE="TITLE"Chapter 4, "Using the Auxiliary Library to Replace Windowing and Event Handling Calls,"
 for more information. If you need more sophisticated windowing and event handling calls, you'll probably need to turn your program into a mixed-model program (a program that mixes X and GL calls). Silicon Graphics provides some special OpenGL/X calls and a OpenGL/X widget to help you replace your IRIS GL windowing, event, and color-map handling calls. See IDREF="37274" TYPE="TITLE"Chapter 5, "OpenGL/X Mixed-Model Programming,"
 for details.OpenGL establishes and adheres to a standard "name space." OpenGL commands begin with the gl prefix (glEnable(), glTranslatef(), and so on). This prevents conflict with commands from other libraries. IDREF="63238" TYPE="TITLE""OpenGL Command Names"
 explains the OpenGL naming conventions, and IDREF="68221" TYPE="TITLE""OpenGL Defined Types"
 lists the OpenGL defined types with their C data type equivalents.Like IRIS GL, OpenGL maintains many state variables (for color, fog, texture, lighting, viewport, and so on). But OpenGL manages state variables more directly and consistently than does IRIS GL. With OpenGL there are no tablesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'you just load values directly. Since OpenGL doesn't keep tables of lights and materials that you've predefined, it has no equivalent for "binds," although you can use display lists to get a similar effect. IDREF="21145" TYPE="TITLE""Porting defs, binds, and sets: Replacing `Tables' of Stored Definitions"
 explains how to do this. You might also refer to IDREF="20887" TYPE="TITLE""Porting Lighting and Materials Calls"
 and IDREF="43929" TYPE="TITLE""Porting Texture Calls"
 for more discussion and some examples.OpenGL display lists are not editable. In OpenGL, the sole purpose of display lists is to efficiently cache OpenGL commands. This means that IRIS GL calls for editing display lists have no OpenGL equivalentsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'if your IRIS GL code edits display lists, you'll need to reimplement to some extent. IDREF="58056" TYPE="TITLE""Porting Display Lists"
 lists the relevant IRIS GL calls, and IDREF="91726" TYPE="TITLE""Edited Display Lists"
 provides some suggestions for porting code that edits display lists. IRIS GL provides calls to handle fonts and text strings. Although OpenGL can render text, it doesn't provide a file format for fonts. For fonts and text strings, you can use the GLX call glXUseXFont() in conjunction with the OpenGL calls glCallLists() and glListBase(). IDREF="89603" TYPE="TITLE""Fonts and Strings"
 provides suggestions for porting fonts and strings.OpenGL provides a utility library, called the GL Utility Library (GLU), that contains additional routines (such as NURBS and quadric surfaces rendering routines). This library is discussed in the OpenGL Programming Guide. Man pages for all the routines comprising the GLU are included in the OpenGL Reference Manual. These routines all begin with the glu prefix (gluDisk(), gluErrorString(), and so on).LBL="" HELPID=""ID="83315"Tools and Libraries to Help Port Your CodeSilicon Graphics provides some tools and libraries to help you port your code:ID="chap.012"The toogl tool translates your program's IRIS GL calls to OpenGL calls. toogl can't translate everything (in particular, it can't translate windowing and event calls), so you have to edit the outputname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'but it does do a lot of the translation work for you. IDREF="16996" TYPE="TITLE"Chapter 2, "Using toogl,"
 explains how to use this tool.The OpenGL extension to X (GLX) provides a variety of routines to help you replace your old IRIS GL windowing, event, and font calls. IDREF="37274" TYPE="TITLE"Chapter 5
 explains how to do this. Man pages for the GLX routines are included in the OpenGL Reference Manual. You might want to look at the glXIntro man page first.The GLwDrawingArea and GLwMDrawingArea widgets help you port your code to mixed-model mode. (In the context of this book, a mixed-model program is a mixture of X and OpenGL, in which OpenGL is used for rendering and X is used for windowing, event handling, fonts, and so on.) These widgets provide a window with the appropriate visual and color maps needed for OpenGL, based on supplied parameters. They also provide callbacks for redraw, resize, input, and initialization. For information on how to use these widgets, see IDREF="37274" TYPE="TITLE"Chapter 5
. The auxiliary library was designed to support the code examples in the OpenGL Programming Guide. It is intentionally very simple, but it does provide some simple routines that you can use to open windows, detect input, load the color map, render 3-D objects, and so on. For information on how to use the auxiliary library, see the OpenGL Programming Guide and IDREF="45274" TYPE="TITLE"Chapter 4
 of this book.LBL="" HELPID=""ID="93927"How to Port Your Code to OpenGLID="chap.013"This section lists three casesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'select the one that best matches your situation and complete the porting tasks listed (you don't need to do them in any particular order).Case 1:Your IRIS GL code is already in mixed-model mode. (A mixed-model program uses GL for rendering and X for all window system calls, including windowing and event handling.)This means it'll be much easier to port to OpenGL. Here's what you'll need to do:Run your program through a C beautifier (such as cb), then run the toogl filter script on your code. Spend some time editing its output. See IDREF="16996" TYPE="TITLE"Chapter 2
 for a list of known trouble spots where hand-porting is required. You'll probably need to hand-port some of the trickier commandsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'see IDREF="17509" TYPE="TITLE"Chapter 3, "After toogl: How to Finish Porting to OpenGL,"
 for specific suggestions.Convert your IRIS GL/X calls to OpenGL/X calls. If you used one of the mixed-model widgets, GlxDraw or GlxMDraw, switch to the OpenGL version: GLwDrawingArea or GLwMDrawingArea. The OpenGL Reference Manual contains an overview of the OpenGL Extension to the X Window System. It also includes a glXIntro man page and man pages for all the OpenGL/X routines. IDREF="37274" TYPE="TITLE"Chapter 5
 discusses mixed-model programming in OpenGL and provides information about the OpenGL version of the Silicon Graphics mixed-model widget.Case 2:Your IRIS GL code is not in mixed-model mode, but your windowing, color map, and event handling code is reasonably simple, conforms to Silicon Graphics recommendations, and does not use unsupported calls. You can use the OpenGL Programming Guide auxiliary library to replace your IRIS GL windowing, color map, and event handling calls. Here's what you'll need to do:Replace windowing and event handling calls with auxiliary library calls. See IDREF="45274" TYPE="TITLE"Chapter 4
 for porting instructions and refer to the OpenGL Programming Guide for more information on the auxiliary library.Run your program through a C beautifier (such as cb), then run the toogl filter script on your code. Spend some time editing its output. See IDREF="16996" TYPE="TITLE"Chapter 2
 for a list of known trouble spots where hand-porting is required. You'll probably need to hand-port some of the trickier commandsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'see IDREF="17509" TYPE="TITLE"Chapter 3
 for specific suggestions.Case 3:Your IRIS GL code is not in mixed-model mode and your windowing and event handling code uses unsupported calls, does not conform to Silicon Graphics recommendations, or is especially complicated or unusual in scope. In this case, you're probably better off porting to mixed-model mode. Here's what you'll need to do:Run your program through a C beautifier (such as cb), then run the toogl filter script on your code. Spend some time editing its output. See IDREF="16996" TYPE="TITLE"Chapter 2
 for a list of known trouble spots where hand-porting is required. You'll probably need to hand-port some of the trickier commandsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'see IDREF="17509" TYPE="TITLE"Chapter 3
 for specific suggestions.Port your program to the mixed-model mode (mixing OpenGL and X). You can do this either by using Xlib and directly replacing calls like winopen() and qread() with their GLX equivalents, or by using Xt along with a widget set and the OpenGL widget GLwDrawingArea. See IDREF="37274" TYPE="TITLE"Chapter 5
 for more information.In all cases, after you've finished the porting tasks listed, you'll probably need to iteratively compile, run, and debug your program. If necessary, run the toogl script again to catch any IRIS GL commands that you missed. You might find it useful to refer to IDREF="99378" TYPE="TITLE""Error Handling"
 which gives some basic information on error handling in OpenGL.LBL="" HELPID=""ID="56142"If You're Not Porting Your Code to OpenGL YetID="chap.014"If you're not porting to OpenGL now, but know that you will be porting in the future, it's a very good idea to switch to mixed-model mode now. Replace all GL windowing calls with GLX and X calls. Replace GL event handling with X event handling. Refer the Graphics Library Programming Tools and Techniques manual for detailed instructions. Another thing you can do now is to learn what IRIS GL features have no OpenGL equivalents. Avoid using them in new code, and reimplement code that does use them. (IDREF="39727" TYPE="TITLE"Appendix A, "OpenGL Commands and Their IRIS GL Equivalents,"
 lists IRIS GL commands and indicates which commands are not supported in OpenGL.)Finally, replace any obsolete or unsupported calls with newer IRIS GL equivalents as soon as possible.You might also consider switching now from IRIS GL to IRIS Inventor‘, a powerful toolkit based on OpenGL. You can order IRIS Inventor from your Silicon Graphics sales representative or through Silicon Graphics Software Express.† †LBL="2"ID="16996"Using tooglThis chapter documents how to use and get the most from toogl. It explains where to find a copy of toogl and how to use toogl most effectively. It also mentions some areas of your IRIS GL code that might give you problems.LBL="" HELPID=""ID="10561"How to Get and Call tooglID="chap.021"toogl (which stands for To† †OpenGL and is pronounced TOO-guhl) is a script that takes IRIS GL code as input and produces commented, nearly equivalent OpenGL code as output. You can use toogl to do much of the work of translating your IRIS GL code to OpenGL code. While toogl can't do everything, it can do all the tedious work of changing command names, and it can call your attention to code you will need to port by hand. You can get a copy of toogl from /usr/people/4Dgifts/bin. If you want to look at the source (it's in C++), you can get a copy from the OpenGL directory in /usr/people/4Dgifts. (If you have any problems finding something in 4Dgifts, refer to the /usr/people/4Dgifts/README file, which explains the structure and contents of 4Dgifts.)toogl syntax:toogl [-cwq] < infile > outfileYou can use any of these options with ID="chap.022"toogl:-cdon't clutter up the output with comments-wdon't remove window manager calls, like winopen(), mapcolor()-qdon't remove event queue calls, like qread(), setvaluator()toogl doesn't attempt to translate event queue and windowing callsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' it simply removes them, replacing them with warning comments. The -w and -q flags merely suppress the comments.Keep your original source! Accidents happen.To process a directory full of source files automatically, you could use a shell script like this one:ID="chap.023"#!/bin/sh
mkdir OpenGL
for i in *.c
† †  do
    echo "Converting " $i " ..."
    toogl < $i > OpenGL/$i
† †doneLBL="" HELPID=""ID="34013"Using gdiff to Compare FilesID="chap.024"You'll probably find the gdiff command very helpful when editing toogl output. gdiff allows you to easily see differences between the toogl output and your original programname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'or any other version of the program. To use gdiff, type:gdiff -b file1† †file2where file1 and file2 are the names of the files you want to compare. The -b option tells gdiff to ignore trailing blanks on lines when comparing files. You might also want to use the -w option, which tells gdiff to ignore white space.See the gdiff man page for more information.LBL="" HELPID=""ID="22881"What toogl Will and Won't Do for YouID="chap.025"toogl is a filter that scans each line of an input file, looking for IRIS GL calls. When it finds an IRIS GL function, it replaces the function with the corresponding OpenGL function(s). Since toogl can't translate everything, you need to edit its output. Any time toogl translates code that you might need to look at, check, or change, it marks the potential problem with a comment starting with "OGLXXX". (You can use the -c option to suppress the comments.) LBL="" HELPID=""ID="88166"Hints for Using toogl EffectivelyID="chap.026"ID="chap.027"ID="chap.028"Here are a few suggestions for getting the most out of toogl:For best results, use a C beautifier (such as cb) on your code before running toogl on it.Use gdiff to browse through your source and the translation simultaneously.toogl expects to find the matching parentheses or quotes on the same line as the IRIS GL function.toogl expects to find only spaces and tabs between a function name and the opening parenthesis. For example, this code:v3f
(foo);will be left unchanged, as will:v3f /* comment */ (foo);(Running a C beautifier on your program before using toogl can prevent this sort of problem.)C comments inside the argument list of a function shouldn't contain parentheses or quote characters. Faced with the following code, ID="chap.029"ID="chap.0210"toogl will generate a warning and do no translation:v3f ( foo /* I really mean bar "-) */ );LBL="" HELPID=""ID="13398"Editing† †toogl Output: Areas that Need Special AttentionID="chap.0211"After you've run toogl on your code, you need to edit the output. Some areas are more problematic than othersname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' for example,† †v() calls usually translate quite neatly into glVertex() calls, but texture calls often don't translate well at all. This section lists some of the general areas that are likely to need special attention. IDREF="17509" TYPE="TITLE"Chapter 3, "After toogl: How to Finish Porting to OpenGL,"
 provides more detailed information on problem areas.LBL="" HELPID=""ID="34561"Windowing, Device, and Event CallsID="chap.0212"toogl can't translate sections of code where you make window manager, window configuration, device, or event calls, or where you load a color map. You'll need to rewrite these yourself. You can use the -w and -q options to make toogl leave this code alone, so you can still read it to translate it manually. If your windowing and event handling calls are very simple and straightforward, you can replace them with calls from the auxiliary library. IDREF="45274" TYPE="TITLE"Chapter 4, "Using the Auxiliary Library to Replace Windowing and Event Handling Calls,"
 explains how to do this. If your windowing and event handling calls are fairly sophisticated, you'll need to switch to mixed-model programmingname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'this is explained in IDREF="37274" TYPE="TITLE"Chapter 5, "OpenGL/X Mixed-Model Programming."LBL="" HELPID=""Parentheses and QuotesID="chap.0213"toogl understands a little about matching parentheses and quotes. It translates:v3f( v[strlen(strcat(foo, "foo("))] );into:glVertex3fv( v[strlen(strcat(foo, "foo("))] );LBL="" HELPID=""Defined Color ConstantsID="chap.0214"IRIS GL provides defined color constants: BLACK, BLUE, RED, GREEN, MAGENTA, CYAN, YELLOW, and WHITE. OpenGL does not provide these constants and toogl does not translate them, so you'll need to port them by hand.LBL="" HELPID=""clear() CallsID="chap.0215"Check to make sure clear() calls are correctly translated. For example, you might have code that clears the window this way:color(BLACK);
clear();toogl translates those two lines into:glIndex(BLACK);
glClear(GL_COLOR_BUFFER_BIT);This code is incorrect, unfortunately, because OpenGL maintains a clear color, distinct from its drawing colorname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'also, OpenGL does not provide the color constant, BLACK. A better translation would be:glIndex(0);
glClearIndex(0);
glClear(GL_COLOR_BUFFER_BIT);LBL="" HELPID=""Get CallsID="chap.0216"toogl doesn't always translate IRIS GL "get" calls (such as getdepth(), getcolor(), and so on) correctly. toogl translates:i = getcolor();
getdepth(&near, &far);into:/* OGLXXX replace value with your variable */
i = glGetIntegerv(GL_CURRENT_INDEX, &value);

/* OGLXXX You can probably do better than this. */
{
† † int get_depth_tmp[2];
† † glGetIntegerv(GL_DEPTH_RANGE, get_depth_tmp);
† † *(&near)=get_depth_tmp[0];
† † *( &far)=get_depth_tmp[1];
};This guide lists the get calls related to a particular topic in the section on that topic. For general information on replacing get calls, see IDREF="66224" TYPE="TITLE""Porting IRIS GL `Get' Commands"
.LBL="" HELPID=""rotate()The OpenGL rotation call, glRotate(), is somewhat different from rotate(). You'll probably need to massage the code a bit after translating with toogl. See IDREF="91369" TYPE="TITLE""Porting Matrix and Transformation Calls"
 for details.LBL="" HELPID=""Texturingtoogl correctly translates texture coordinate calls, but that's about it. You'll need to do some additional work by hand. IDREF="43929" TYPE="TITLE""Porting Texture Calls"
 explains how. LBL="" HELPID=""defs/bindsOpenGL doesn't keep tables of lights and materials that you've predefined, so it has no equivalent for "binds." You can mimic this behavior by using display lists. See IDREF="21145" TYPE="TITLE""Porting defs, binds, and sets: Replacing `Tables' of Stored Definitions"
 for more information. You might also look at IDREF="20887" TYPE="TITLE""Porting Lighting and Materials Calls"
 and IDREF="43929" TYPE="TITLE""Porting Texture Calls"
 for more discussion and some examples.LBL="" HELPID=""Calls without Direct Equivalentstoogl can't directly translate some IRIS GL calls into OpenGL calls.† †arcf() is one example of such a call. You'll need to port such calls by hand. IDREF="84596" TYPE="TITLE""Editing toogl Output: An Example"
 gives an example of how you might hand-port a call like† †arcf(). LBL="" HELPID=""Finding OpenGL Replacements for IRIS GL CallsIDREF="39727" TYPE="TITLE"Appendix A, "OpenGL Commands and Their IRIS GL Equivalents," contains a table listing IRIS GL commands and the corresponding OpenGL commands, and tells you where to go for more information. This table also indicates which IRIS GL calls are unsupported in OpenGLLBL="" HELPID=""ID="84596"Editing toogl Output: An ExampleID="chap.0217"Here's an example of how you might handle a call like arcf(). toogl translates this call:arcf(1.0, 1.0, 0.9, 1200, 2200);as:/* OGLXXX see gluPartialDisk man page */
gluPartialDisk( *gobj, innerRad, outerRad, slices, loops, startAng, endAng);The IRIS GL call† †arcf() can't be directly translated into an OpenGL call. The GL Utility Library call† †gluPartialDisk() is the nearest equivalent, but you need to fill in its arguments by hand. Compare the man pages for the two commands, or refer to the section in this guide that discusses porting that command (in this case, IDREF="44954" TYPE="TITLE""Arcs and Circles"
). Perusal of that material will tell you that you have to account for the following changes:Arcs are now quadrics and are drawn using quadric objects.Angles are now measured in degrees instead of tenths of degrees.Instead of specifying a center for your arc in the call, you now do a translation first.Angles are now measured on different coordinate axes, and the second angle is a sweep angle instead of an end angle.Your completed† †arcf() translation might look like this:gluQuadricObj *arcObj;
arcObj = gluNewQuadric(void);
glTranslatef( 1.0, 1.0, 0.0 );
gluPartialDisk( *arcObj, 0.0, 0.9, 100, 2, -30, -100);LBL="3"ID="17509"After toogl: How to Finish Porting to OpenGLAfter you run your IRIS GL program through toogl, you can use this chapter to find out how to replace IRIS GL calls that toogl didn't manage to translate fully. To get the most out of this discussion, refer to the man pages as necessary. (If you want a printed version of the man pages, buy the OpenGL Reference Manual, described in the introductory section, IDREF="37200" TYPE="TITLE""About This Book"
 at the beginning of this guide.) LBL="" HELPID=""ID="21136"Header FilesID="chap.031"toogl doesn't replace header files for you, so you'll need to replace them yourself. This section lists the files your IRIS GL program probably used and which OpenGL files to replace them with.Your IRIS GL program probably uses these include lines:#include <gl/gl.h>
#include <gl/device.h>
#include <gl/get.h>In your OpenGL program, you'll need to replace these with:#include <GL/gl.h>
#include <GL/glu.h>

#include <Xm/Xm.h>        /* (these are X header files-- */
#include <Xm/Frame.h>     /* you don't need them if you're */
#include <Xm/Form.h>      /* using the auxiliary library */
#include <X11/StringDefs.h> /* instead of mixed-model */
#include <X11/keysym.h>If you use the auxiliary library, you'll also need to include:#include "aux.h"If your IRIS GL program uses the mixed-model widget, it uses one of these include lines:For the IRIS IM version of the widget:#include <X11/Xirisw/GlxMDraw.h>For the generic version of the widget:#include <X11/Xirisw/GLxDraw.h>For the OpenGL version, substitute these include lines:For the IRIS IM version of the widget:#include <GLw/GLwMDrawingArea.h>For the generic version of the widget:#include <GLw/GLwDrawingArea.h>If you're using Xlib and OpenGL/X calls, add:#include <GL/glx.h>LBL="" HELPID=""ID="62214"Porting greset()ID="chap.032"OpenGL replaces the functionality of greset() with the commands glPushAttrib() and† †glPopAttrib(). Use these commands to save and restore groups of state variables. The command:void glPushAttrib( GLbitfield mask );takes a bitwise OR of symbolic constants, indicating which groups of state variables to push onto an attribute stack. Each constant refers to a group of state variables. IDREF="52610" TYPE="TABLE"Table 3-1
 shows the attribute groups with their corresponding symbolic constant names. For a complete list of the OpenGL state variables associated with each constant, see the man page for glPushAttrib().COLUMNS="2"LBL="3-1"Table 3-1 ID="52610"State Attribute GroupsLEFT="0" WIDTH="189"AttributeLEFT="195" WIDTH="356"ConstantLEFT="0" WIDTH="189"accumulation buffer clear valueLEFT="195" WIDTH="356"GL_ACCUM_BUFFER_BITLEFT="0" WIDTH="189"color bufferLEFT="195" WIDTH="356"GL_COLOR_BUFFER_BITLEFT="0" WIDTH="189"currentLEFT="195" WIDTH="356"GL_CURRENT_BITLEFT="0" WIDTH="189"depth bufferLEFT="195" WIDTH="356"GL_DEPTH_BUFFER_BITLEFT="0" WIDTH="189"enableLEFT="195" WIDTH="356"GL_ENABLE_BITLEFT="0" WIDTH="189"evaluatorsLEFT="195" WIDTH="356"EGL_VAL_BITLEFT="0" WIDTH="189"fogLEFT="195" WIDTH="356"GL_FOG_BITLEFT="0" WIDTH="189"GL_LIST_BASE settingLEFT="195" WIDTH="356"GL_LIST_BITLEFT="0" WIDTH="189"hint variablesLEFT="195" WIDTH="356"GL_HINT_BITLEFT="0" WIDTH="189"lighting variablesLEFT="195" WIDTH="356"GL_LIGHTING_BITLEFT="0" WIDTH="189"line drawing modeLEFT="195" WIDTH="356"GL_LINE_BITLEFT="0" WIDTH="189"pixel mode variablesLEFT="195" WIDTH="356"GL_PIXEL_MODE_BITLEFT="0" WIDTH="189"point variablesLEFT="195" WIDTH="356"GL_POINT_BITLEFT="0" WIDTH="189"polygonLEFT="195" WIDTH="356"GL_POLYGON_BITLEFT="0" WIDTH="189"polygon stippleLEFT="195" WIDTH="356"GL_POLYGON_STIPPLE_BITLEFT="0" WIDTH="189"scissorLEFT="195" WIDTH="356"GL_SCISSOR_BITLEFT="0" WIDTH="189"stencil bufferLEFT="195" WIDTH="356"GL_STENCIL_BUFFER_BITLEFT="0" WIDTH="189"textureLEFT="195" WIDTH="356"GL_TEXTURE_BITLEFT="0" WIDTH="189"transformLEFT="195" WIDTH="356"GL_TRANSFORM_BITLEFT="0" WIDTH="189"viewportLEFT="195" WIDTH="356"GL_VIEWPORT_BITLEFT="0" WIDTH="189"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="195" WIDTH="356"GL_ALL_ATTRIB_BITSID="chap.033"To restore the values of the state variables to those saved with the last glPushAttrib(), simply call glPopAttrib(). The variables you didn't save will remain unchanged. The attribute stack has a finite depth of at least16.LBL="" HELPID=""ID="66224"Porting IRIS GL `Get' CommandsID="chap.034""Get" calls in IRIS GL were of the form:int getthing();
int getthings( int *a, int *b);Your IRIS GL code probably includes get calls that look something like:thing = getthing();
if(getthing() == THING) { /* stuff */ }
getthings (&a, &b);Gets in OpenGL use glGet() commands and look something like this:void glGetIntegerfv(NAME_OF_THING, &thing);IDREF="56942" TYPE="TABLE"Table A-1 lists the IRIS GL get commands with their OpenGL equivalents. In general, this guide lists various parameters for glGet() in the sections that discuss topics related to those parameters. To see the parameter values related to matrices, for example, see IDREF="91369" TYPE="TITLE""Porting Matrix and Transformation Calls"
.There are other commands to query the OpenGL state, such as glGetClipPlane() and† †glGetLight(). These commands are also discussed in the sections on related callsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'you can also refer to the man pages for these commands.LBL="" HELPID=""About glGet()There are four types of glGet() commands:glGetBooleanv()glGetIntegerv()glGetFloatv()glGetDoublev()The commands have the syntax:glGet<Datatype>v( value, *data )where value is of type GLenum and data of type GLdatatype. If you issue a glGet() command that returns types different from the type expected, the type is converted appropriately. For a complete list of glGet() parameters, see the man page. LBL="" HELPID=""glGet() Conventions Used in This BookThis guide, for the sake of brevity, usually shortens the reference to the form glGet(GL_GET_TYPE). For example, glGetIntegerv(GL_VIEWPORT, *params);will be abbreviated as:glGet(GL_VIEWPORT);in tables and text (though not in code examples).LBL="" HELPID=""ID="67471"Porting Commands that Required Current Graphics PositionID="chap.035"ID="chap.036"OpenGL does not maintain a current graphics position. IRIS GL commands that depend on the current graphics position, such as move(), draw(), and rmv(), have no equivalents in OpenGL. ID="chap.037"Older versions of IRIS GL included drawing commands that relied upon the current graphics position, though their use has been discouraged. You will need to reimplement if you relied on the current graphics position in any way, or used any of the following routines:draw() and move()pmv(),† †pdr(), and pclos()† †rdr(), rmv(),† †rpdr(), and† †rpmv()† †getgpos()OpenGL has a concept of raster position that corresponds to IRIS GL's current character position. See IDREF="92008" TYPE="TITLE""Porting Pixel Operations"
 for more information.LBL="" HELPID=""ID="28727"Porting Screen and Buffer Clearing CommandsOpenGL replaces a variety of IRIS GL clear() calls (such as zclear(),† †aclear(), sclear(), and so on) with one: glClear(). Specify exactly what you want to clear by passing masks to glClear().Porting notes:OpenGL maintains clear colors separately from drawing colors, with calls like glClearColor() and glClearIndex(). Be sure to set the clear color for each buffer before doing a clear.Since toogl has no concept of context, it will not correctly translate color calls immediately preceding clears into† †glClearColor() calls. You will have to do this by hand. For example, you might have cleared your viewport with code like this:color(BLACK);
clear();toogl will translate those two lines into:glIndex(BLACK);
glClear(GL_COLOR_BUFFER_BIT);That fragment might correctly read: glClearIndex(0);
glClear(GL_COLOR_BUFFER_BIT);(Remember that IRIS GL color constants, such as BLACK, are not defined in OpenGL.)Instead of using one of several differently named clear calls, you now clear several buffers with one call, glClear(), by OR-ing together buffer masks. For example czclear() is replaced by: glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT )IRIS GL respects the polygon stipple and the color write mask. OpenGL ignores the polygon stipple but respects the write mask. (czclear() ignored both the polygon stipple and the write mask.)IDREF="92580" TYPE="TABLE"Table 3-2 lists the various clear calls with their IRIS GL equivalents.† †ID="chap.038"COLUMNS="3"LBL="3-2"Table 3-2 ID="92580"Calls for Clearing the ScreenLEFT="0" WIDTH="82"IRIS GL CallLEFT="90" WIDTH="159"OpenGL CallLEFT="255" WIDTH="356"MeaningLEFT="0" WIDTH="82"acbuf(AC_CLEAR)LEFT="90" WIDTH="159"glClear(GL_ACCUM_BUFFER_BIT)LEFT="255" WIDTH="356"clear the 
accumulation bufferLEFT="0" WIDTH="82"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="159"glClearColor()LEFT="255" WIDTH="356"set the RGBA clear 
colorLEFT="0" WIDTH="82"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="159"glClearIndex()LEFT="255" WIDTH="356"set the clear color 
indexLEFT="0" WIDTH="82"clear()LEFT="90" WIDTH="159"glClear(GL_COLOR_BUFFER_BIT)LEFT="255" WIDTH="356"clear the color bufferLEFT="0" WIDTH="82"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="159"glClearDepth()LEFT="255" WIDTH="356"specify the clear 
value for the depth 
bufferLEFT="0" WIDTH="82"zclear()LEFT="90" WIDTH="159"glClear(GL_DEPTH_BUFFER_BIT)LEFT="255" WIDTH="356"clear the depth bufferLEFT="0" WIDTH="82"czclear()LEFT="90" WIDTH="159"glClear(GL_COLOR_BUFFER_BIT |† †GL_DEPTH_BUFFER_BIT)LEFT="255" WIDTH="356"clear the color buffer 
and the depth bufferLEFT="0" WIDTH="82"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="159"glClearAccum()LEFT="255" WIDTH="356"specify clear values 
for the accumulation 
bufferLEFT="0" WIDTH="82"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="159"glClearStencil()LEFT="255" WIDTH="356"specify the clear 
value for the stencil 
bufferLEFT="0" WIDTH="82"sclear()LEFT="90" WIDTH="159"glClear(GL_STENCIL_BUFFER_BIT )LEFT="255" WIDTH="356"clear the stencil 
bufferIf your IRIS GL code used both gclear() and sclear(), you can combine them into a single† †glClear() callname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'this might improve your program's performance.LBL="" HELPID=""Porting ID="91369"Matrix and Transformation CallsID="chap.039"ID="chap.0310"Porting notes:There is no single-matrix mode. You are always in double-matrix mode in OpenGL.Angles are now measured in degrees, instead of tenths of degrees.Projection matrix calls, like glFrustum() and glOrtho(), now multiply onto the current matrix, instead of being loaded onto the current matrix.The OpenGL call glRotate() is very different from† †rotate(). You can now rotate around any arbitrary axis, instead of being confined to the x, y, and z axes. But you will probably have to port rotate() calls by hand, since toogl often has trouble translating them. For example, toogl might translate:rotate(200*(i+1), 'z');into:glRotate(.1*(200*(i+1)), ( 'z')=='x', ( 'z')=='y', 
† †                        ( 'z')=='z');toogl correctly switched to degrees from tenths of degrees, but didn't correctly handle the replacement of `z' with a vector for the z-axis. A better translation would be:glRotate(.1*(200*(i+1), 0.0, 0.0, 1.0);OpenGL documentation presents matrices in a manner more consistent with standard usage in linear algebra than did IRIS GL documentation. Specifically, in IRIS GL documentation, vectors are treated as rows, and a matrix is applied to a vector on the right of the vector.ID="chap.0311"† †multmatrix() replaces the current matrix C with C' = MC. In OpenGL documentation, vectors are treated as columns, and a matrix applies to a vector on the left of the vector. glMultMatrix() computes C' = CM. A generic IRIS GL translation is shown in the equation in IDREF="29746" TYPE="GRAPHIC"Figure 3-1
.LBL="3-1" FILE="equation_1.bw" POSITION="INLINE" SCALE="FALSE"LBL="3-1"Figure 3-1 ID="29746"A Generic IRIS GL TranslationA generic OpenGL translation is shown in the equation in IDREF="36379" TYPE="GRAPHIC"Figure 3-2
.LBL="3-2" FILE="equation_2.bw" POSITION="INLINE" SCALE="FALSE"LBL="3-2"Figure 3-2 ID="36379"A Generic OpenGL TranslationThe important thing is that this is a change in documentation onlyname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'OpenGL matrices are completely compatible to the ones in IRIS GL except that they are stored in column-major order. So, if you want the matrix shown in the equation in IDREF="33798" TYPE="GRAPHIC"Figure 3-3
 in your OpenGL application, you would declare it like this:float mat[16] = {a, e, i, m, b, f, j, n, c, g, 
† †                k, o, d, h, l, p}LBL="3-3" FILE="equation_3.bw" POSITION="INLINE" SCALE="FALSE"LBL="3-3"Figure 3-3 ID="33798"An OpenGL Matrix ExampleOpenGL has no equivalent to the polarview()ID="chap.0312" call. You can replace it easily with a translation and three rotations, For example,polarview(distance, azimuth, incidence, twist);translates to:glTranslatef( 0.0, 0.0, -distance);
glRotatef( -twist * 10.0, 0.0, 0.0, 1.0);
glRotatef( -incidence * 10.0, 1.0, 0.0, 0.0);
glRotatef( -azimuth * 10.0, 0.0, 0.0, 1.0);The replacement for the† †lookat()ID="chap.0313" call,† †gluLookAt()ID="chap.0314", takes an up vector instead of a twist angle. toogl does not translate this call correctly, so you will have to port by hand. See the man page for gluLookAt() for more information.IDREF="62790" TYPE="TABLE"Table 3-3 lists the OpenGL matrix calls and their IRIS GL equivalents.COLUMNS="3"LBL="3-3"Table 3-3 ID="62790"Matrix OperationsLEFT="0" WIDTH="83"IRIS GL CallLEFT="90" WIDTH="113"OpenGL CallLEFT="210" WIDTH="356"MeaningLEFT="0" WIDTH="83"mmode()ID="chap.0315"LEFT="90" WIDTH="113"glMatrixMode()ID="chap.0316"LEFT="210" WIDTH="356"set current matrix modeID="chap.0317"ID="chap.0318"LEFT="0" WIDTH="83"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="113"glLoadIdentity()ID="chap.0319"LEFT="210" WIDTH="356"replace current matrix with the 
identity matrixLEFT="0" WIDTH="83"loadmatrix()ID="chap.0320"LEFT="90" WIDTH="113"glLoadMatrixf(),ID="chap.0321"glLoadMatrixd()ID="chap.0322"LEFT="210" WIDTH="356"replace current matrix with the 
specified matrixLEFT="0" WIDTH="83"multmatrix()ID="chap.0323"LEFT="90" WIDTH="113"glMultMatrixf(),ID="chap.0324"glMultMatrixd()ID="chap.0325"LEFT="210" WIDTH="356"post-multiply current matrix 
with the specified matrix (note 
that multmatrix() 
pre-multiplied)LEFT="0" WIDTH="83"mapw(), mapw2()ID="chap.0326"ID="chap.0327"LEFT="90" WIDTH="113"gluUnProject()ID="chap.0328"LEFT="210" WIDTH="356"project world space coordinates 
to object space (see also 
gluProject())ID="chap.0329"LEFT="0" WIDTH="83"ortho()ID="chap.0330"LEFT="90" WIDTH="113"glOrtho()ID="chap.0331"LEFT="210" WIDTH="356"multiply current matrix by an 
orthographic projection matrixLEFT="0" WIDTH="83"ortho2()ID="chap.0332"LEFT="90" WIDTH="113"gluOrtho2D()ID="chap.0333"LEFT="210" WIDTH="356"define a 2-dimensional 
orthographic projection matrixLEFT="0" WIDTH="83"perspective()ID="chap.0334"LEFT="90" WIDTH="113"gluPerspective()ID="chap.0335"LEFT="210" WIDTH="356"define a perspective projection 
matrixLEFT="0" WIDTH="83"picksize()ID="chap.0336"LEFT="90" WIDTH="113"gluPickMatrix()ID="chap.0337"LEFT="210" WIDTH="356"define a picking regionLEFT="0" WIDTH="83"popmatrix()ID="chap.0338"LEFT="90" WIDTH="113"glPopMatrix()ID="chap.0339"LEFT="210" WIDTH="356"pop current matrix stack, 
replacing the current matrix 
with the one below itLEFT="0" WIDTH="83"pushmatrix()ID="chap.0340"LEFT="90" WIDTH="113"glPushMatrix()ID="chap.0341"LEFT="210" WIDTH="356"push current matrix stack down 
by one, duplicating the current 
matrixLEFT="0" WIDTH="83"rotate(),rot()ID="chap.0342"ID="chap.0343"LEFT="90" WIDTH="113"glRotated(),ID="chap.0344"glRotatef()ID="chap.0345"LEFT="210" WIDTH="356"rotate current coordinate system 
by the given angle about the 
vector from the origin through 
the given point. Note that 
rotate() rotated only about the x, 
y, and z axesLEFT="0" WIDTH="83"scale()ID="chap.0346"LEFT="90" WIDTH="113"glScaled(),ID="chap.0347"glScalef()ID="chap.0348"LEFT="210" WIDTH="356"multiply current matrix by a 
scaling matrixLEFT="0" WIDTH="83"translate()ID="chap.0349"LEFT="90" WIDTH="113"glTranslatef(),ID="chap.0350"† †glTranslated()ID="chap.0351"LEFT="210" WIDTH="356"move coordinate system origin 
to the point specified, by 
multiplying the current matrix 
by a translation matrixLEFT="0" WIDTH="83"window()ID="chap.0352"LEFT="90" WIDTH="113"glFrustum()ID="chap.0353"LEFT="210" WIDTH="356"given coordinates for clipping 
planes, multiply the current 
matrix by a perspective matrixOpenGL has three matrix modes, which are set with ID="chap.0354"ID="chap.0355"glMatrixMode(). IDREF="22064" TYPE="TABLE"Table 3-4
 lists the mode types available as arguments to glMatrixMode(). The corresponding arguments to mmode() calls are listed in the second column.COLUMNS="4"LBL="3-4"Table 3-4 ID="22064"Matrix ModesLEFT="0" WIDTH="85"IRIS GL Matrix ModeLEFT="90" WIDTH="79"OpenGL ModeLEFT="175" WIDTH="95"MeaningLEFT="275" WIDTH="356"Min Stack DepthLEFT="0" WIDTH="85"MTEXTUREID="chap.0356"LEFT="90" WIDTH="79"GL_TEXTUREID="chap.0357"LEFT="175" WIDTH="95"operate on the texture 
matrix stackLEFT="275" WIDTH="356"2LEFT="0" WIDTH="85"MVIEWINGID="chap.0358"LEFT="90" WIDTH="79"GL_MODELVIEWID="chap.0359"LEFT="175" WIDTH="95"operate on the 
modelview matrix 
stackLEFT="275" WIDTH="356"32LEFT="0" WIDTH="85"MPROJECTIONID="chap.0360"LEFT="90" WIDTH="79"GL_PROJECTIONID="chap.0361"LEFT="175" WIDTH="95"operate on the 
projection matrix stackLEFT="275" WIDTH="356"2LBL="" HELPID=""Porting MSINGLE Mode CodeNote that OpenGL has no equivalent for MSINGLE, single-matrix mode. Though use of this mode has been discouraged, it was the default for IRIS GL and your code might have used it. If it did, you will need to reimplement. OpenGL is always in double-matrix mode, and is initially in GL_MODELVIEW mode. Most IRIS GL code in MSINGLE mode looks like this:...
projectionmatrix();
...where† †projectionmatrix() is one of: ortho(),† †ortho2(), perspective(), window(). To port to OpenGL, replace the MSINGLE mode projectionmatrix() call by:...
glMatrixMode( GL_PROJECTION );
glLoadMatrix( identity matrix );
[one of these calls: glFrustrum(), glOrtho(), glOrtho2(), gluPerspective()};
glMatrixMode( GL_MODELVIEW );
glLoadMatrix( identity matrix );LBL="" HELPID=""Porting "Get" Calls For Matrices and TransformationsIDREF="91195" TYPE="TABLE"Table 3-5 lists related gets. COLUMNS="3"LBL="3-5"Table 3-5 ID="91195"Arguments for Transformation Matrix QueriesLEFT="0" WIDTH="81"IRIS GL Matrix 
QueryLEFT="90" WIDTH="180"OpenGL glGet() Matrix QueryLEFT="275" WIDTH="356"MeaningLEFT="0" WIDTH="81"getmmode()ID="chap.0362"LEFT="90" WIDTH="180"GL_MATRIX_MODEID="chap.0363"LEFT="275" WIDTH="356"return the 
current matrix 
modeLEFT="0" WIDTH="81"getmatrix() in 
MVIEWING modeID="chap.0364"LEFT="90" WIDTH="180"GL_MODELVIEW_MATRIXID="chap.0365"LEFT="275" WIDTH="356"return a copy of 
the current 
modelview 
matrixLEFT="0" WIDTH="81"getmatrix() in 
MPROJECTION 
modeLEFT="90" WIDTH="180"GL_PROJECTION_MATRIXID="chap.0366"LEFT="275" WIDTH="356"return a copy of 
the current 
projection 
matrixLEFT="0" WIDTH="81"getmatrix() in 
MTEXTURE modeLEFT="90" WIDTH="180"GL_TEXTURE_MATRIXID="chap.0367"LEFT="275" WIDTH="356"return a copy of 
the current 
texture matrixLEFT="0" WIDTH="81"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="180"GL_MAX_MODELVIEW_STACK_DEPTHLEFT="275" WIDTH="356"return 
maximum 
supported 
depth of the 
modelview 
matrix stackLEFT="0" WIDTH="81"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="180"GL_MAX_PROJECTION_STACK_DEPTHLEFT="275" WIDTH="356"return 
maximum 
supported 
depth of the 
projection 
matrix stackLEFT="0" WIDTH="81"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="180"GL_MAX_TEXTURE_STACK_DEPTHLEFT="275" WIDTH="356"return 
maximum 
supported 
depth of the 
texture matrix 
stackLEFT="0" WIDTH="81"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="180"GL_MODELVIEW_STACK_DEPTHLEFT="275" WIDTH="356"returns number 
of matrices on 
the modelview 
stackLEFT="0" WIDTH="81"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="180"GL_PROJECTION_STACK_DEPTHLEFT="275" WIDTH="356"returns number 
of matrices on 
the projection 
stackLEFT="0" WIDTH="81"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="180"GL_TEXTURE_STACK_DEPTHLEFT="275" WIDTH="356"returns number 
of matrices on 
the texture stackLBL="" HELPID=""ID="73299"Viewports, Screenmasks, and ScrboxesThe following IRIS GL calls have no OpenGL equivalent:ID="chap.0368"reshapeviewport() (see IDREF="91085" TYPE="TITLE""Handling Redraw Events"
 for information on how to replace this with auxiliary library calls)ID="chap.0369"scrbox(), getscrbox()ID="chap.0370"† †Porting notes:With viewport(), you specified the x coordinates (in pixels) for the left and right of the viewport rectangle and the y coordinates for the top and bottom. With glViewport()ID="chap.0371", however, you specify the x and y coordinates (in pixels) of the lower left corner of the viewport rectangle along with its width and height.IDREF="36584" TYPE="TABLE"Table 3-6 lists the OpenGL equivalents for viewport commands. COLUMNS="3"LBL="3-6"Table 3-6 ID="36584"Viewport CallsLEFT="0" WIDTH="99"IRIS GL CallLEFT="105" WIDTH="146"OpenGL CallLEFT="260" WIDTH="356"MeaningLEFT="0" WIDTH="99"viewport(left, right,
                  bottom, top)ID="chap.0372"LEFT="105" WIDTH="146"glViewport(x, y, width, height)LEFT="260" WIDTH="356"set the viewportLEFT="0" WIDTH="99"popviewport()pushviewport()ID="chap.0373"ID="chap.0374"LEFT="105" WIDTH="146"glPopAttrib()glPushAttrib(GL_VIEWPORT_BIT)LEFT="260" WIDTH="356"push and pop the 
stackLEFT="0" WIDTH="99"getviewport()ID="chap.0375"LEFT="105" WIDTH="146"glGet(GL_VIEWPORT)LEFT="260" WIDTH="356"returns viewport 
dimensionsLBL="" HELPID=""ID="26684"Clipping PlanesOpenGL implements clipping planes the way IRIS GL did, though you can now also query clipping planes. IDREF="25826" TYPE="TABLE"Table 3-7
 lists the OpenGL equivalents to IRIS GL calls. COLUMNS="3"LBL="3-7"Table 3-7 ID="25826"Clipping Plane CallsLEFT="0" WIDTH="135"IRIS GL CallLEFT="140" WIDTH="126"OpenGL CallLEFT="275" WIDTH="356"MeaningLEFT="0" WIDTH="135"clipplane(ID="chap.0376"i, CP_ON, params)LEFT="140" WIDTH="126"glEnable(GL_CLIP_PLANEi)LEFT="275" WIDTH="356"enable clipping 
on plane iLEFT="0" WIDTH="135"clipplane(i, CP_DEFINE, plane)LEFT="140" WIDTH="126"glClipPlane( 
GL_CLIP_PLANEID="chap.0377"i, plane)LEFT="275" WIDTH="356"define clipping 
planeLEFT="0" WIDTH="135"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="140" WIDTH="126"glGetClipPlane()ID="chap.0378"LEFT="275" WIDTH="356"returns clipping 
plane equationLEFT="0" WIDTH="135"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="140" WIDTH="126"glIsEnabled( 
GL_CLIP_PLANEi)LEFT="275" WIDTH="356"returns true if 
clip plane i is 
enabledLEFT="0" WIDTH="135"scrmask()ID="chap.0379"LEFT="140" WIDTH="126"glScissor()ID="chap.0380"LEFT="275" WIDTH="356"defines the 
scissor boxLEFT="0" WIDTH="135"getscrmask()ID="chap.0381"LEFT="140" WIDTH="126"glGet(GL_SCISSOR_BOX)LEFT="275" WIDTH="356"return the 
current scissor 
boxTo turn on the scissor test, call glEnable() with GL_SCISSOR_BOX as the parameter.LBL="" HELPID=""Porting ID="98356"Drawing CommandsID="chap.0382"The following sections discuss how to port IRIS GL drawing primitives.LBL="" HELPID=""TheID="11089" IRIS GL Sphere LibraryID="chap.0383"The sphere library that worked with IRIS GL isn't yet available for OpenGL. Look for it in a later release of OpenGL. In the meantime, you can replace your sphere library calls with quadrics routines from the GLU library. Refer to the OpenGL Programming Guide and the GLU man pages in the OpenGL Reference Manual for details on using the GLU library. IDREF="74711" TYPE="TABLE"Table 3-8
 summarizes OpenGL quadrics calls.COLUMNS="2"LBL="3-8"Table 3-8 ID="74711"Calls for Drawing QuadricsLEFT="0" WIDTH="108"OpenGL CallLEFT="115" WIDTH="356"MeaningLEFT="0" WIDTH="108"gluNewQuadric()ID="chap.0384"LEFT="115" WIDTH="356"create a new quadric objectLEFT="0" WIDTH="108"gluDeleteQuadric()ID="chap.0385"LEFT="115" WIDTH="356"delete a quadric objectLEFT="0" WIDTH="108"gluQuadricCallback()ID="chap.0386"LEFT="115" WIDTH="356"associate a callback with a quadric object, for error 
handlingLEFT="0" WIDTH="108"gluQuadricNormals()ID="chap.0387"LEFT="115" WIDTH="356"specify normals: no normals, one per face, or one per 
vertexLEFT="0" WIDTH="108"gluQuadricOrientation()ID="chap.0388"LEFT="115" WIDTH="356"specify direction of normals: outward or inwardLEFT="0" WIDTH="108"gluQuadricTexture()ID="chap.0389"LEFT="115" WIDTH="356"turn texture coordinate generation on or offLEFT="0" WIDTH="108"gluQuadricDrawstyle()ID="chap.0390"LEFT="115" WIDTH="356"specify drawing style: polygons, lines, points, and so onLEFT="0" WIDTH="108"gluSphere()ID="chap.0391"LEFT="115" WIDTH="356"draw a sphereLEFT="0" WIDTH="108"gluCylinder()ID="chap.0392"LEFT="115" WIDTH="356"draw a cylinder or coneLEFT="0" WIDTH="108"gluPartialDisk()ID="chap.0393"LEFT="115" WIDTH="356"draw an arcLEFT="0" WIDTH="108"gluDisk()ID="chap.0394"LEFT="115" WIDTH="356"draw a circle or diskID="chap.0395"ID="chap.0396"You can use one quadric object for all quadrics you'd like to render in similar ways. The following code fragment uses two quadrics objects to draw four quadrics, two of them textured.GLUquadricObj    *texturedQuad, *plainQuad;

texturedQuad = gluNewQuadric(void);
gluQuadricTexture(texturedQuad, GL_TRUE);
gluQuadricOrientation(texturedQuad, GLU_OUTSIDE);
gluQuadricDrawStyle(texturedQuad, GLU_FILL);

plainQuad = gluNewQuadric(void);
gluQuadricDrawStyle(plainQuad, GLU_LINE);

glColor3f (1.0, 1.0, 1.0);

gluSphere(texturedQuad, 5.0, 20, 20);
glTranslatef(10.0, 10.0, 0.0);
gluCylinder(texturedQuad, 2.5, 5, 5, 10, 10);
glTranslatef(10.0, 10.0, 0.0);
gluDisk(plainQuad, 2.0, 5.0, 10, 10);
glTranslatef(10.0, 10.0, 0.0);
gluSphere(plainQuad, 5.0, 20, 20);LBL="" HELPID=""ID="37304"The v() CommandsID="chap.0397"In IRIS GL, you use variations on the v() call to specify vertices. This call has a direct successor in OpenGL,† †glVertex():glVertex2[d|f|i|s][v]( x, y );glVertex3[d|f|i|s][v]( x, y, z);
glVertex4[d|f|i|s][v]( x, y, z, w);glVertex() takes suffixes the same way other OpenGL calls do. The vector versions of the call take arrays of the proper size as arguments. In the 2D version, z=0 and w=1. In the 3D version, w=1.LBL="" HELPID=""ID="49018"bgn/end CommandsID="chap.0398"IRIS GL uses the begin/end paradigm but has a different call for each graphics primitive. For example, you probably used bgnpolygon()† †and endpolygon() to draw polygons, and† †bgnline() and† †endline() to draw lines. With the OpenGL, you use the ID="chap.0399"glBegin()/ID="chap.03100"glEnd() structure for both. (The OpenGL draws most geometric objects by enclosing a series of calls that specify vertices, normals, textures, and colors between pairs of glBegin() and glEnd() calls.) void glBegin( GLenum mode) ;
† †  /* vertex list, colors, normals, textures, materials */
void glEnd( void );glBegin() takes a single argument that specifies the drawing mode, and thus the primitive. Here's an OpenGL code fragment that draws a polygon and then a line:glBegin( GL_POLYGON) ;
† †  glVertex2f(20.0, 10.0);
† †  glVertex2f(10.0, 30.0);
† †  glVertex2f(20.0, 50.0);
† †  glVertex2f(40.0, 50.0);
† †  glVertex2f(50.0, 30.0);
† †  glVertex2f(40.0, 10.0);
glEnd();
glBegin( GL_LINES ) ;
† †  glVertex2i(100,100);
† †  glVertex2i(500,500);
glEnd();In OpenGL, you draw different geometric objects by specifying different arguments to glBegin(). These arguments are listed in IDREF="16389" TYPE="TABLE"Table 3-9
 below, along with the IRIS GL calls they replace (if any).   COLUMNS="3"LBL="3-9"Table 3-9 ID="16389"Calls for Drawing PrimitivesLEFT="0" WIDTH="108"IRIS GL CallLEFT="115" WIDTH="108"Value of glBegin() ModeLEFT="230" WIDTH="356"MeaningLEFT="0" WIDTH="108"bgnpoint()LEFT="115" WIDTH="108"GL_POINTSLEFT="230" WIDTH="356"individual pointsLEFT="0" WIDTH="108"bgnline()LEFT="115" WIDTH="108"GL_LINE_STRIPLEFT="230" WIDTH="356"series of connected line 
segmentsLEFT="0" WIDTH="108"bgnclosedline()LEFT="115" WIDTH="108"GL_LINE_LOOPLEFT="230" WIDTH="356"series of connected line 
segments, with a segment 
added between first and last 
verticesLEFT="0" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="115" WIDTH="108"GL_LINESLEFT="230" WIDTH="356"pairs of vertices interpreted 
as individual line segmentsLEFT="0" WIDTH="108"bgnpolygon()LEFT="115" WIDTH="108"GL_POLYGONLEFT="230" WIDTH="356"boundary of a simple 
convex polygonLEFT="0" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="115" WIDTH="108"GL_TRIANGLESLEFT="230" WIDTH="356"triples of vertices 
interpreted as trianglesLEFT="0" WIDTH="108"bgntmesh()LEFT="115" WIDTH="108"GL_TRIANGLE_STRIPLEFT="230" WIDTH="356"linked strips of trianglesLEFT="0" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="115" WIDTH="108"GL_TRIANGLE_FANLEFT="230" WIDTH="356"linked fans of trianglesLEFT="0" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="115" WIDTH="108"GL_QUADSLEFT="230" WIDTH="356"quadruples of vertices 
interpreted as 
quadrilateralsLEFT="0" WIDTH="108"bgnqstrip()LEFT="115" WIDTH="108"GL_QUAD_STRIPLEFT="230" WIDTH="356"linked strips of 
quadrilateralsFor a detailed discussion of the differences between triangle meshes, strips, and fans, see IDREF="65584" TYPE="TITLE""Triangles"
.There is no limit to the number of vertices you can specify between a glBegin()/glEnd() pair.In addition to specifying vertices inside a glBegin()/glEnd() pair, you can also specify a current normal, current texture coordinates, and a current color. IDREF="87386" TYPE="TABLE"Table 3-10
 lists the commands valid inside a glBegin()/glEnd() pair.COLUMNS="3"LBL="3-10"Table 3-10 ID="87386"Valid Commands inside a Begin/End StructureLEFT="0" WIDTH="108"IRIS GL CallID="chap.03101"LEFT="115" WIDTH="108"OpenGL EquivalentLEFT="230" WIDTH="356"MeaningLEFT="0" WIDTH="108"v2(), v3(), v4()LEFT="115" WIDTH="108"glVertex()LEFT="230" WIDTH="356"set vertex coordinatesLEFT="0" WIDTH="108"RGBcolor(), cpack()LEFT="115" WIDTH="108"glColor()LEFT="230" WIDTH="356"set current colorLEFT="0" WIDTH="108"color()LEFT="115" WIDTH="108"glIndex()LEFT="230" WIDTH="356"set current color indexLEFT="0" WIDTH="108"n3f()LEFT="115" WIDTH="108"glNormal()LEFT="230" WIDTH="356"set normal vector 
coordinatesLEFT="0" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="115" WIDTH="108"glEvalCoord()LEFT="230" WIDTH="356"evaluate enabled one- and 
two-dimensional mapsLEFT="0" WIDTH="108"callobj()LEFT="115" WIDTH="108"glCallList(), glCallLists()LEFT="230" WIDTH="356"execute display list(s)LEFT="0" WIDTH="108"t2()LEFT="115" WIDTH="108"glTexCoord()LEFT="230" WIDTH="356"set texture coordinatesLEFT="0" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="115" WIDTH="108"glEdgeFlag()LEFT="230" WIDTH="356"control drawing edgesLEFT="0" WIDTH="108"lmbind()LEFT="115" WIDTH="108"glMaterial()LEFT="230" WIDTH="356"set material propertiesIf you use any other OpenGL command inside a glBegin()/glEnd() pair, you'll get unpredictable results, or possibly an error.LBL="" HELPID=""ID="89248"PointsID="chap.03102"OpenGL has no command to draw a single point. Otherwise, porting point calls is straightforward. IDREF="16149" TYPE="TABLE"Table 3-11
 lists commands for drawing points.COLUMNS="3"LBL="3-11"Table 3-11 ID="16149"Calls for Drawing PointsLEFT="0" WIDTH="72"IRIS GL CallLEFT="80" WIDTH="144"OpenGL EquivalentLEFT="230" WIDTH="356"MeaningLEFT="0" WIDTH="72"pnt()ID="chap.03103"LEFT="80" WIDTH="144"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="230" WIDTH="356"draw a single pointLEFT="0" WIDTH="72"bgnpoint(),endpoint()ID="chap.03104"ID="chap.03105"LEFT="80" WIDTH="144"glBegin(GL_POINTS), ID="chap.03106"glEnd()ID="chap.03107"LEFT="230" WIDTH="356"interpret vertices as pointsLEFT="0" WIDTH="72"pntsize()ID="chap.03108"LEFT="80" WIDTH="144"glPointSize()ID="chap.03109"LEFT="230" WIDTH="356"set point size in pixelsID="chap.03110"LEFT="0" WIDTH="72"pntsmooth()ID="chap.03111"LEFT="80" WIDTH="144"glEnable(GL_POINT_SMOOTH)ID="chap.03112"LEFT="230" WIDTH="356"turn on point antialiasing 
(see "Porting Antialiasing 
Calls" on page 60)See the† †glPointSize() man page for information about related get commands.LBL="" HELPID=""ID="68126"LinesID="chap.03113"Porting code that draws lines is fairly straightforward, though you should note the differences in the way OpenGL does stipples.COLUMNS="3"LBL="3-12"Table 3-12 Calls for Drawing LinesLEFT="0" WIDTH="72"IRIS GL CallLEFT="80" WIDTH="162"OpenGL CallLEFT="250" WIDTH="356"MeaningLEFT="0" WIDTH="72"bgnclosedline(),endclosedline()ID="chap.03114"ID="chap.03115"LEFT="80" WIDTH="162"glBegin(GL_LINE_LOOP)ID="chap.03116"glEnd()ID="chap.03117"LEFT="250" WIDTH="356"† †draw a closed lineLEFT="0" WIDTH="72"bgnline()ID="chap.03118"LEFT="80" WIDTH="162"glBegin(GL_LINE_STRIP)LEFT="250" WIDTH="356"draw line segmentsLEFT="0" WIDTH="72"linewidth()ID="chap.03119"LEFT="80" WIDTH="162"glLineWidth()ID="chap.03120"LEFT="250" WIDTH="356"set line widthLEFT="0" WIDTH="72"getlwidth()ID="chap.03121"LEFT="80" WIDTH="162"glGet(GL_LINE_WIDTH)ID="chap.03122"LEFT="250" WIDTH="356"return current line 
widthLEFT="0" WIDTH="72"deflinestyle()setlinestyle()ID="chap.03123"ID="chap.03124"LEFT="80" WIDTH="162"glLineStipple(ID="chap.03125"factor, pattern)LEFT="250" WIDTH="356"specify a line stipple 
patternLEFT="0" WIDTH="72"lsrepeat()ID="chap.03126"LEFT="80" WIDTH="162"factor argument of glLineStipple()LEFT="250" WIDTH="356"set a repeat factor for 
the line styleLEFT="0" WIDTH="72"getlstyle()ID="chap.03127"LEFT="80" WIDTH="162"glGet(GL_LINE_STIPPLE_PATTERN)LEFT="250" WIDTH="356"return line stipple 
patternLEFT="0" WIDTH="72"getlsrepeat()ID="chap.03128"LEFT="80" WIDTH="162"glGet(GL_LINE_STIPPLE_REPEAT)LEFT="250" WIDTH="356"return repeat factorLEFT="0" WIDTH="72"linesmooth(), smoothline()ID="chap.03129"ID="chap.03130"LEFT="80" WIDTH="162"glEnable(GL_LINE_SMOOTH)LEFT="250" WIDTH="356"turn on line 
antialiasing (see 
"Porting Antialiasing 
Calls" on page 60)Note that there are no tables for line stipples. OpenGL maintains only one line stipple pattern. You can use glPushAttrib() and glPopAttrib() to switch between different stipple patterns. Old-style line style routines are not supported by OpenGL. You might have used these calls: draw(), ID="chap.03131"lsbackup(), ID="chap.03132"getlsbackup(), resetls()ID="chap.03133", ID="chap.03134"getresetls(). If so, you will have to reimplement.For information on drawing antialiased lines, see IDREF="91804" TYPE="TITLE""Porting Antialiasing Calls"
.LBL="" HELPID=""ID="83655"Polygons and QuadrilateralsID="chap.03135"Porting notes:There is no direct equivalent for concave(TRUE). You might want to use the tessellation routines in the GLU, described in ID="chap.03136"IDREF="26633" TYPE="TITLE""Tessellated Polygons"
.Polygon modes are now set differently.ID="chap.03137"These older polygon drawing calls have no direct equivalents in OpenGL:the poly()ID="chap.03138" family of routinesthe ID="chap.03139"polf() family of routinespmv()ID="chap.03140",† †pdr()ID="chap.03141", and† †pclos()ID="chap.03142"rpmv()ID="chap.03143" and† †rpdr()ID="chap.03144"ID="chap.03145"splf()ID="chap.03146"spclos()If you used them, you'll have to reimplement using glBegin(GL_POLYGON). IDREF="16389" TYPE="TABLE"Table 3-9
 lists the OpenGL equivalents to IRIS GL polygon drawing calls.COLUMNS="3"LBL="3-13"Table 3-13 ID="16389"Calls for Drawing PolygonsLEFT="0" WIDTH="81"IRIS GL CallLEFT="90" WIDTH="135"OpenGL EquivalentLEFT="230" WIDTH="356"MeaningLEFT="0" WIDTH="81"bgnpolygon(), 
endpolygon()ID="chap.03147"ID="chap.03148"LEFT="90" WIDTH="135"glBegin(GL_POLYGON),ID="chap.03149"glEnd()ID="chap.03150"LEFT="230" WIDTH="356"vertices define boundary of 
a simple convex polygonLEFT="0" WIDTH="81"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="135"glBegin(GL_QUADS),glEnd()LEFT="230" WIDTH="356"interpret quadruples of 
vertices as quadrilateralsLEFT="0" WIDTH="81"bgnqstrip(), 
endqstrip()ID="chap.03151"ID="chap.03152"LEFT="90" WIDTH="135"glBegin(GL_QUAD_STRIP),glEnd()LEFT="230" WIDTH="356"interpret vertices as linked 
strips of quadrilateralsLEFT="0" WIDTH="81"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="90" WIDTH="135"glEdgeFlag()ID="chap.03153"LEFT="230" WIDTH="356"LEFT="0" WIDTH="81"polymode()ID="chap.03154"LEFT="90" WIDTH="135"glPolygonMode()ID="chap.03155"LEFT="230" WIDTH="356"set polygon drawing modeLEFT="0" WIDTH="81"rect(), rectf(),ID="chap.03156"ID="chap.03157"LEFT="90" WIDTH="135"glRect()ID="chap.03158"ID="chap.03159"LEFT="230" WIDTH="356"draw a rectangleLEFT="0" WIDTH="81"sbox(), sboxf()ID="chap.03160"ID="chap.03161"LEFT="90" WIDTH="135"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="230" WIDTH="356"draw a screen-aligned 
rectangleLBL="" HELPID=""Polygon ModesID="chap.03162"The call for setting the polygon mode has changed slightly. The OpenGL call ID="chap.03163"glPolygonMode() allows you to specify which side of a polygon (the back or the front) that the mode applies to. Its syntax is:void glPolygonMode( GLenum face, GLenum mode )where face is one of:GL_FRONTmode applies to front-facing polygonsGL_BACKmode applies to back-facing polygonsGL_FRONT_AND_BACKmode applies to both front- and back-facing polygonsThe equivalents to IRIS GL ID="chap.03164"polymode() calls would use GL_FRONT_AND_BACK. IDREF="29723" TYPE="TABLE"Table 3-14
 lists IRIS GL polygon modes and the corresponding OpenGL modes.COLUMNS="3"LBL="3-14"Table 3-14 ID="29723"Polygon ModesLEFT="0" WIDTH="108"IRIS GL ModeLEFT="115" WIDTH="108"OpenGL ModeLEFT="230" WIDTH="356"MeaningLEFT="0" WIDTH="108"PYM_POINTLEFT="115" WIDTH="108"GL_POINTLEFT="230" WIDTH="356"draw vertices as pointsLEFT="0" WIDTH="108"PYM_LINELEFT="115" WIDTH="108"GL_LINELEFT="230" WIDTH="356"draw boundary edges as 
line segmentsLEFT="0" WIDTH="108"PYM_FILLLEFT="115" WIDTH="108"GL_FILLLEFT="230" WIDTH="356"draw polygon interior filledLEFT="0" WIDTH="108"PYM_HOLLOWLEFT="115" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="230" WIDTH="356"fill only interior pixels at the 
boundariesLBL="" HELPID=""Polygon StipplesID="chap.03165"Porting notes:There are no tables for polygon stipples. OpenGL keeps only one stipple pattern. You can use display lists to store different stipple patterns.The polygon stipple bitmap size is always a 32x32 bit pattern.Stipple encoding is affected by† †glPixelStore()ID="chap.03166". See IDREF="92008" TYPE="TITLE""Porting Pixel Operations"
 for more information.IDREF="26272" TYPE="TABLE"Table 3-15 lists polygon stipple calls.COLUMNS="3"LBL="3-15"Table 3-15 ID="26272"Polygon Stipple CallsLEFT="0" WIDTH="108"IRIS GL CallLEFT="115" WIDTH="108"OpenGL CallLEFT="230" WIDTH="356"MeaningLEFT="0" WIDTH="108"defpattern()ID="chap.03167"LEFT="115" WIDTH="108"glPolygonStipple()ID="chap.03168"LEFT="230" WIDTH="356"set the stipple patternLEFT="0" WIDTH="108"setpattern()ID="chap.03169"LEFT="115" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="230" WIDTH="356"OpenGL keeps only one 
polygon stipple patternLEFT="0" WIDTH="108"getpattern()ID="chap.03170"LEFT="115" WIDTH="108"glGetPolygonStipple()ID="chap.03171"LEFT="230" WIDTH="356"return the stipple bitmap 
(used to return an index)Enable and disable polygon stippling by passing GL_POLYGON_STIPPLE as an argument to ID="chap.03172"glEnable() and ID="chap.03173"glDisable().Here's an example OpenGL code fragment that demonstrates polygon stippling:/*  polys.c  */
#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"
void display(void)
{
† †   GLubyte fly[] = {
† †     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
† †     0x03, 0x80, 0x01, 0xC0, 0x06, 0xC0, 0x03, 0x60,
† †     0x04, 0x60, 0x06, 0x20, 0x04, 0x30, 0x0C, 0x20,
† †     0x04, 0x18, 0x18, 0x20, 0x04, 0x0C, 0x30, 0x20,
† †     0x04, 0x06, 0x60, 0x20, 0x44, 0x03, 0xC0, 0x22,
† †     0x44, 0x01, 0x80, 0x22, 0x44, 0x01, 0x80, 0x22,
† †     0x44, 0x01, 0x80, 0x22, 0x44, 0x01, 0x80, 0x22,
† †     0x44, 0x01, 0x80, 0x22, 0x44, 0x01, 0x80, 0x22,
† †     0x66, 0x01, 0x80, 0x66, 0x33, 0x01, 0x80, 0xCC,
† †     0x19, 0x81, 0x81, 0x98, 0x0C, 0xC1, 0x83, 0x30,
† †     0x07, 0xe1, 0x87, 0xe0, 0x03, 0x3f, 0xfc, 0xc0,
† †     0x03, 0x31, 0x8c, 0xc0, 0x03, 0x33, 0xcc, 0xc0,
† †     0x06, 0x64, 0x26, 0x60, 0x0c, 0xcc, 0x33, 0x30,
† †     0x18, 0xcc, 0x33, 0x18, 0x10, 0xc4, 0x23, 0x08,
† †     0x10, 0x63, 0xC6, 0x08, 0x10, 0x30, 0x0c, 0x08,
† †     0x10, 0x18, 0x18, 0x08, 0x10, 0x00, 0x00, 0x08
† †   };
† †   GLubyte halftone[] = {
† †     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
† †     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
† †     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
† †     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
† †     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
† †     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
† †     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
† †     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
† †     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
† †     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
† †     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
† †     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
† †     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
† †     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
† †     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
† †     0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55
† †   };

† †   glClear (GL_COLOR_BUFFER_BIT);

/*  draw all polygons in white*/
† †   glColor3f (1.0, 1.0, 1.0);
/*  draw one solid, unstippled rectangle,*/
/*  then two stippled rectangles*/
† †   glRectf (25.0, 25.0, 125.0, 125.0);
† †   glEnable (GL_POLYGON_STIPPLE);
† †   glPolygonStipple (fly);
† †   glRectf (125.0, 25.0, 225.0, 125.0);
† †   glPolygonStipple (halftone);
† †   glRectf (225.0, 25.0, 325.0, 125.0);
† †   glDisable (GL_POLYGON_STIPPLE);

† †   glFlush ();
}LBL="" HELPID=""ID="26633"Tessellated PolygonsID="chap.03174"The GLU has routines you can use to draw concave polygons. You no longer just use concave(TRUE) and then† †bgnpolygon().To draw a concave polygon with OpenGL, follow these steps:Create a tesselation object.Define callbacks that will be used to process the triangles generated by the tessellator.ID="chap.03175"Specify the concave polygon to be tessellated.IDREF="71609" TYPE="TABLE"Table 3-16 lists the calls for drawing tessellated polygons.COLUMNS="2"LBL="3-16"Table 3-16 ID="71609"Tessellated Polygon CallsLEFT="0" WIDTH="99"GLU CallLEFT="105" WIDTH="356"MeaningLEFT="0" WIDTH="99"gluNewTess()ID="chap.03176"LEFT="105" WIDTH="356"create a new tessellation objectLEFT="0" WIDTH="99"gluDeleteTess()ID="chap.03177"LEFT="105" WIDTH="356"delete a tessellation objectLEFT="0" WIDTH="99"gluTessCallback()ID="chap.03178"LEFT="105" WIDTH="356"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="99"gluBeginPolygon()ID="chap.03179"LEFT="105" WIDTH="356"begin the polygon specificationLEFT="0" WIDTH="99"gluTessVertex()ID="chap.03180"LEFT="105" WIDTH="356"specify a polygon vertex in a contoursLEFT="0" WIDTH="99"gluNextContour()ID="chap.03181"LEFT="105" WIDTH="356"indicate that the next series of vertices describe a new 
contourLEFT="0" WIDTH="99"gluEndPolygon()ID="chap.03182"LEFT="105" WIDTH="356"end the polygon specificationFor complete details, see the man pages for the commands listed in IDREF="71609" TYPE="TABLE"Table 3-16
.LBL="" HELPID=""ID="65584"TrianglesID="chap.03183"OpenGL provides three ways to draw triangles: separate triangles, triangle strips, and triangle fans. Porting notes:You don't have any equivalent for swaptmesh()ID="chap.03184". Instead, use a combination of triangles, triangle strips, and triangle fans.IDREF="61828" TYPE="TABLE"Table 3-17 lists the commands for drawing triangles.COLUMNS="3"LBL="3-17"Table 3-17 ID="61828"Calls for Drawing TrianglesLEFT="0" WIDTH="72"IRIS GL CallLEFT="80" WIDTH="144"Equivalent glBegin() ArgumentLEFT="230" WIDTH="356"MeaningLEFT="0" WIDTH="72"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="80" WIDTH="144"GL_TRIANGLESLEFT="230" WIDTH="356"triples of vertices 
interpreted as trianglesLEFT="0" WIDTH="72"bgntmesh(), 
endtmesh()ID="chap.03185"ID="chap.03186"LEFT="80" WIDTH="144"GL_TRIANGLE_STRIPLEFT="230" WIDTH="356"linked strips of trianglesLEFT="0" WIDTH="72"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="80" WIDTH="144"GL_TRIANGLE_FANLEFT="230" WIDTH="356"linked fans of trianglesLBL="" HELPID=""ID="44954"Arcs and CirclesID="chap.03187"In OpenGL, filled arcs and circles are drawn with the same calls as unfilled arcs and circles. See the man pages for specifics. IDREF="50683" TYPE="TABLE"Table 3-18
 lists the IRIS GL arc and circle commands with the corresponding OpenGL (GLU) commands.COLUMNS="3"LBL="3-18"Table 3-18 ID="50683"Calls for Drawing Arcs and Circles LEFT="0" WIDTH="54"IRIS GL CallLEFT="60" WIDTH="69"OpenGL CallLEFT="135" WIDTH="356"MeaningLEFT="0" WIDTH="54"arc(),arcf()ID="chap.03188"ID="chap.03189"LEFT="60" WIDTH="69"gluPartialDisk()ID="chap.03190"LEFT="135" WIDTH="356"draw an arcLEFT="0" WIDTH="54"circ(),circf()ID="chap.03191"ID="chap.03192"LEFT="60" WIDTH="69"gluDisk()ID="chap.03193"LEFT="135" WIDTH="356"draw a circle or diskThe gluPartialDisk() call is very different from the arc() call. Refer to the gluPartialDisk() man page for complete information.You can do some things with OpenGL arcs and circles that you can't do with IRIS GL. Refer to the OpenGL Programming Guide and the man pages in the OpenGL Reference Manual for detailed information on OpenGL arcs and circles (which are called disks and partial disks in OpenGL).Porting notes:ID="chap.03194"Angles are no longer measured in tenths of degrees, but simply in degrees.The start angle is measured from the positive y-axis, and not from the x.The sweep angle is now clockwise instead of counterclockwise, as shown in IDREF="71639" TYPE="GRAPHIC"Figure 3-4
..LBL="3-4" FILE="chap.03.cgm4" POSITION="INLINE" SCALE="FALSE"LBL="3-4"Figure 3-4 ID="71639"Drawing Angles: IRIS GL vs. OpenGLLBL="" HELPID=""SpheresID="chap.03195"Porting notes:You can no longer control the type of primitives used to draw the sphere. You have control of drawing precision in another way: you can use the slices and stacks parameters. Slices are longitudinal; stacks are latitudinal.Spheres are now drawn centered at the origin. Instead of specifying the location, as you used to in ID="chap.03196"sphdraw() calls, precede a† †gluSphere()ID="chap.03197" call with a translation.The sphere library isn't yet available for OpenGLname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'see IDREF="11089" TYPE="TITLE""The IRIS GL Sphere Library"
 for more information about replacing sphere library calls.IDREF="69155" TYPE="TABLE"Table 3-19 lists the IRIS GL calls for drawing spheres along with the corresponding GLU calls where available. COLUMNS="3"LBL="3-19"Table 3-19 ID="69155"Calls for Drawing SpheresLEFT="0" WIDTH="81"IRIS GL CallLEFT="90" WIDTH="90"GLU CallLEFT="185" WIDTH="356"NotesLEFT="0" WIDTH="81"sphobj()ID="chap.03198"LEFT="90" WIDTH="90"gluNewQuadric()ID="chap.03199"LEFT="185" WIDTH="356"create a new sphere objectLEFT="0" WIDTH="81"sphfree()ID="chap.03200"LEFT="90" WIDTH="90"gluDeleteQuadric()ID="chap.03201"LEFT="185" WIDTH="356"delete sphere object and free memory 
usedLEFT="0" WIDTH="81"sphdraw()ID="chap.03202"LEFT="90" WIDTH="90"gluSphere()ID="chap.03203"LEFT="185" WIDTH="356"draw a sphereLEFT="0" WIDTH="81"sphmode()ID="chap.03204"LEFT="90" WIDTH="90"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="185" WIDTH="356"set sphere attributesLEFT="0" WIDTH="81"sphrotmatrix()ID="chap.03205"LEFT="90" WIDTH="90"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="185" WIDTH="356"control sphere orientationLEFT="0" WIDTH="81"sphgnpolys()ID="chap.03206"LEFT="90" WIDTH="90"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="185" WIDTH="356"return number of polygons in current 
sphereLBL="" HELPID=""ID="31702"Porting Color, Shading, and Writemask CommandsID="chap.03207"The major change you'll have to watch out for is the change in how color maps are implemented. Porting notes:Though you can set color map indices with the OpenGL glIndex()ID="chap.03208" call, OpenGL does not provide a routine for loading color map indices. If you're using the auxiliary library, see IDREF="54935" TYPE="TITLE""Using Color-Index Mode"
 for instructions on loading color maps. If you're using X, see IDREF="23967" TYPE="TITLE""X Color Maps"
 for an example code fragment that sets up a color map.Color values are normalized to their data type. See the ID="chap.03209"glColor() man page for details.There is no simple equivalent for ID="chap.03210"cpack(). You can use† †glColor() instead, but you'll need to port by hand.Some calls to c() or ID="chap.03211"color() might need to be translated to glClearColor() or glClearIndex() and not glColor() or glIndex(). See IDREF="28727" TYPE="TITLE""Porting Screen and Buffer Clearing Commands"
 for details.The RGBA writemask is not for each bit, just each component.IRIS GL provided defined color constants: BLACK, BLUE, RED, GREEN, MAGENTA, CYAN, YELLOW, and WHITE. OpenGL does not provide these constants and ID="chap.03212"toogl does not translate them, so you'll need to port them by hand.LBL="" HELPID=""Color CallsIDREF="12951" TYPE="TABLE"Table 3-20 lists equivalent color calls.   COLUMNS="3"LBL="3-20"Table 3-20 ID="12951"Color CallsLEFT="0" WIDTH="81"IRIS GL CallLEFT="90" WIDTH="153"OpenGL CallLEFT="250" WIDTH="356"MeaningLEFT="0" WIDTH="81"c()ID="chap.03213"LEFT="90" WIDTH="153"glColor()LEFT="250" WIDTH="356"sets RGB colorLEFT="0" WIDTH="81"color()LEFT="90" WIDTH="153"glIndex()LEFT="250" WIDTH="356"sets the color indexLEFT="0" WIDTH="81"getcolor()ID="chap.03214"LEFT="90" WIDTH="153"glGet(GL_CURRENT_INDEX)ID="chap.03215"LEFT="250" WIDTH="356"returns the current 
color indexLEFT="0" WIDTH="81"getmcolor()ID="chap.03216"LEFT="90" WIDTH="153"XQueryColor()LEFT="250" WIDTH="356"gets a copy of the RGB 
values for a color map 
entryLEFT="0" WIDTH="81"gRGBcolor()ID="chap.03217"LEFT="90" WIDTH="153"glGet(GL_CURRENT_COLOR)ID="chap.03218"LEFT="250" WIDTH="356"gets the current RGB 
color valuesLEFT="0" WIDTH="81"mapcolor()ID="chap.03219"LEFT="90" WIDTH="153"auxSetOneColor() or XStoreColor()ID="chap.03220"ID="chap.03221"LEFT="250" WIDTH="356"see "Using Color-Index 
Mode" on page 106 or 
"X Color Maps" on 
page 125LEFT="0" WIDTH="81"RGBcolor()ID="chap.03222"LEFT="90" WIDTH="153"glColor()LEFT="250" WIDTH="356"sets RGB colorLEFT="0" WIDTH="81"writemask()ID="chap.03223"LEFT="90" WIDTH="153"glIndexMask()ID="chap.03224"LEFT="250" WIDTH="356"sets the color index 
mode color maskLEFT="0" WIDTH="81"wmpack()RGBwritemask()ID="chap.03225"ID="chap.03226"LEFT="90" WIDTH="153"glColorMask()ID="chap.03227"LEFT="250" WIDTH="356"sets the RGB color 
mode maskLEFT="0" WIDTH="81"getwritemask()ID="chap.03228"LEFT="90" WIDTH="153"glGet(GL_COLOR_WRITEMASK)ID="chap.03229"glGet(GL_INDEX_WRITEMASK)LEFT="250" WIDTH="356"gets the color maskLEFT="0" WIDTH="81"gRGBmask()ID="chap.03230"LEFT="90" WIDTH="153"glGet(GL_COLOR_WRITEMASK)LEFT="250" WIDTH="356"gets the color maskLEFT="0" WIDTH="81"zwritemask()ID="chap.03231"LEFT="90" WIDTH="153"glDepthMask()ID="chap.03232"LEFT="250" WIDTH="356"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Be careful when replacing zwritemask() with glDepthMask(): glDepthMask() takes a boolean argument, whereas zwritemask() takes a bitfield. † †If you want to use multiple color maps, you'll need to implement them using X's colormap facilities. Therefore, ID="chap.03233"multimap(), ID="chap.03234"onemap(), ID="chap.03235"getcmmode(), ID="chap.03236"setmap(), and† †getmap(ID="chap.03237") have no OpenGL equivalents.LBL="" HELPID=""Shading ModelsAs with IRIS GL, you can switch between smooth (Gouraud) shading and flat shading. IDREF="86023" TYPE="TABLE"Table 3-21
 lists the calls.COLUMNS="3"LBL="3-21"Table 3-21 ID="86023"Shading and DitheringLEFT="0" WIDTH="117"IRIS GL CallLEFT="125" WIDTH="131"OpenGL CallLEFT="265" WIDTH="356"MeaningLEFT="0" WIDTH="117"shademodel(FLAT)ID="chap.03238"LEFT="125" WIDTH="131"glShadeModel(GL_FLAT) ID="chap.03239"LEFT="265" WIDTH="356"do flat shadingLEFT="0" WIDTH="117"shademodel(GOURAUD)LEFT="125" WIDTH="131"glShadeModel(GL_SMOOTH)LEFT="265" WIDTH="356"do smooth shadingLEFT="0" WIDTH="117"getsm()ID="chap.03240"LEFT="125" WIDTH="131"glGet(GL_SHADE_MODEL)ID="chap.03241"LEFT="265" WIDTH="356"return current 
shade modelLEFT="0" WIDTH="117"dither(DT_ON)dither(DT_OFF)ID="chap.03242"LEFT="125" WIDTH="131"glEnable(GL_DITHER)ID="chap.03243"glDisable(GL_DITHER)ID="chap.03244"ID="chap.03245"LEFT="265" WIDTH="356"turn on dithering 
on/offID="chap.03246"Smooth shading and dithering are on by default, as in IRIS GL.LBL="" HELPID=""Porting ID="92008"Pixel OperationsID="chap.03247"Porting notes:Logical pixel operations are not applied to RGBA color buffers. See the glLogicOp() man page for more information.In general, for pixels IRIS GL used the format ABGR, whereas OpenGL uses RGBA. You can change this with glPixelStore().When porting† †lrectwrite() calls, be careful to note where† †lrectwrite() is writing (for instance, it could be writing to the depth buffer).OpenGL gives you some additional flexibility in pixel operations. IDREF="53998" TYPE="TABLE"Table 3-22
 lists calls for pixel operations.COLUMNS="3"LBL="3-22"Table 3-22 ID="53998"Pixel OperationsLEFT="0" WIDTH="99"IRIS GL CallLEFT="105" WIDTH="117"OpenGL CallLEFT="230" WIDTH="356"MeaningLEFT="0" WIDTH="99"lrectread(), rectread(),readRGB()ID="chap.03248"ID="chap.03249"ID="chap.03250"LEFT="105" WIDTH="117"glReadPixels()ID="chap.03251"LEFT="230" WIDTH="356"read a block of pixels from 
the frame bufferLEFT="0" WIDTH="99"lrectwrite(), rectwrite()ID="chap.03252"ID="chap.03253"LEFT="105" WIDTH="117"glDrawPixels()ID="chap.03254"LEFT="230" WIDTH="356"write a block of pixels to the 
frame bufferLEFT="0" WIDTH="99"rectcopy()ID="chap.03255"LEFT="105" WIDTH="117"glCopyPixels()ID="chap.03256"LEFT="230" WIDTH="356"copy pixels in the frame 
bufferLEFT="0" WIDTH="99"rectzoom()ID="chap.03257"LEFT="105" WIDTH="117"glPixelZoom()ID="chap.03258"LEFT="230" WIDTH="356"specify pixel zoom factors 
for glDrawPixels() and 
glCopyPixels()LEFT="0" WIDTH="99"cmov()ID="chap.03259"LEFT="105" WIDTH="117"glRasterPos()ID="chap.03260"LEFT="230" WIDTH="356"specify raster position for 
pixel operationsLEFT="0" WIDTH="99"readsource()ID="chap.03261"LEFT="105" WIDTH="117"glReadBuffer()ID="chap.03262"LEFT="230" WIDTH="356"select a color buffer source 
for pixelsLEFT="0" WIDTH="99"pixmode()ID="chap.03263"LEFT="105" WIDTH="117"glPixelStore()ID="chap.03264"LEFT="230" WIDTH="356"set pixel storage modesLEFT="0" WIDTH="99"pixmode()ID="chap.03265"LEFT="105" WIDTH="117"glPixelTransfer()ID="chap.03266"LEFT="230" WIDTH="356"set pixel transfer modesLEFT="0" WIDTH="99"logicop()ID="chap.03267"LEFT="105" WIDTH="117"glLogicOp()ID="chap.03268"LEFT="230" WIDTH="356"specify a logical operation 
for pixel writesLEFT="0" WIDTH="99"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="105" WIDTH="117"glEnable(GL_LOGIC_OP)ID="chap.03269"LEFT="230" WIDTH="356"turn on pixel logic 
operationsSee the man page for glLogicOp() for a list of possible logical operations.Here's a code fragment that shows a typical pixel write:unsigned long *packedRaster;
...
packedRaster[k] = 0x00000000;
...
lrectwrite(0, 0, xSize, ySize, packedRaster);Here is how toogl translates the call to† †lrectwrite():/* OGLXXX lrectwrite: see man page for glDrawPixels */
glRasterPos2i(0,  0);
glDrawPixels(( xSize)-(0)+1, ( ySize)-( 0)+1, GL_RGBA,             GL_UNSIGNED_BYTE, packedRaster);After some tweaking, the finished code might look like this:glRasterPos2i( 0, 0);
glDrawPixels( xSize + 1, ySize + 1, GL_RGBA, GL_UNSIGNED_BYTE,              packedRaster);LBL="" HELPID=""Porting ID="77276"Depth Cueing and Fog CommandsID="chap.03270"Porting notes:The fog calls have been restructured, so you might have to rewrite them by hand. The IRIS GL call fogvertex() set a mode and parameters affecting that mode. In OpenGL, you call glFog() once to set the mode, then again twice or more to set various parameters.Depth cueing is no longer a separate feature. Use linear fog instead of depth cueing. (This section provides an example of how to do this.) The following calls therefore have no direct OpenGL equivalent:ID="chap.03271"depthcue()ID="chap.03272"lRGBrange()ID="chap.03273"lshaderange()ID="chap.03274"getdcm()To adjust fog quality, use glHint(GL_FOG_HINT).IDREF="44184" TYPE="TABLE"Table 3-23 lists the IRIS GL calls for managing fog along with the corresponding OpenGL calls.COLUMNS="3"LBL="3-23"Table 3-23 ID="44184"Calls for Managing FogLEFT="0" WIDTH="108"IRIS GL CallLEFT="115" WIDTH="108"OpenGL CallLEFT="230" WIDTH="356"MeaningLEFT="0" WIDTH="108"fogvertex()ID="chap.03275"LEFT="115" WIDTH="108"glFog()ID="chap.03276"LEFT="230" WIDTH="356"set various fog parametersLEFT="0" WIDTH="108"fogvertex(FG_ON)LEFT="115" WIDTH="108"glEnable(GL_FOG)ID="chap.03277"LEFT="230" WIDTH="356"turn fog onLEFT="0" WIDTH="108"fogvertex(FG_OFF)LEFT="115" WIDTH="108"glDisable(GL_FOG)ID="chap.03278"LEFT="230" WIDTH="356"turn fog offLEFT="0" WIDTH="108"depthcue()LEFT="115" WIDTH="108"glFog(GL_FOG_MODE, 
GL_LINEAR)LEFT="230" WIDTH="356"use linear fog for depth 
cueingIDREF="29081" TYPE="TABLE"Table 3-24 lists the arguments you can pass to ID="chap.03279"glFog().COLUMNS="3"LBL="3-24"Table 3-24 ID="29081"Fog ParametersLEFT="0" WIDTH="99"Fog ParameterLEFT="105" WIDTH="117"MeaningLEFT="230" WIDTH="356"DefaultLEFT="0" WIDTH="99"GL_FOG_DENSITYLEFT="105" WIDTH="117"fog densityLEFT="230" WIDTH="356"1.0LEFT="0" WIDTH="99"GL_FOG_STARTLEFT="105" WIDTH="117"near distance for linear fogLEFT="230" WIDTH="356"0.0LEFT="0" WIDTH="99"GL_FOG_ENDLEFT="105" WIDTH="117"far distance for linear fogLEFT="230" WIDTH="356"1.0LEFT="0" WIDTH="99"GL_FOG_INDEXLEFT="105" WIDTH="117"fog color indexLEFT="230" WIDTH="356"0.0LEFT="0" WIDTH="99"GL_FOG_COLORLEFT="105" WIDTH="117"fog RGBA colorLEFT="230" WIDTH="356"(0, 0, 0, 0)LEFT="0" WIDTH="99"GL_FOG_MODELEFT="105" WIDTH="117"fog modeLEFT="230" WIDTH="356"see Table 3-25The fog density argument of OpenGL is different than the fog density argument of IrisGL.  They are related as follows:if  fogMode = EXP2 openGLfogDensity = (irisGLfogDensity)  (sqrt( - log( 1 / 255 ) ))if fogMode =  EXPopenGLfogDensity = (irisGLfogDensity)  (- log( 1 / 255 ) )where sqrt is the square root operation,  log is the natural logarithm, irisGLfogDensity is the IrisGL fog density, and openGLfogDensity is the OpenGL fog density.To switch between calculating fog in per-pixel mode and per-vertex mode, use glHint(GL_FOG_HINT, hintMode). Two hint modes are available:GL_NICESTID="chap.03280"per-pixel fog calculationGL_FASTESTID="chap.03281"per-vertex fog calculationIDREF="91254" TYPE="TABLE"Table 3-25 lists the OpenGL equivalents for IRIS GL fog modes.ID="chap.03282"ID="chap.03283"COLUMNS="4"LBL="3-25"Table 3-25 ID="91254"Fog ModesLEFT="0" WIDTH="81"IRIS GL Fog ModeLEFT="90" WIDTH="81"OpenGL Fog ModeLEFT="180" WIDTH="81"Hint ModeLEFT="270" WIDTH="356"MeaningLEFT="0" WIDTH="81"FG_VTX_EXP, FG_PIX_EXPLEFT="90" WIDTH="81"GL_EXPLEFT="180" WIDTH="81"GL_FASTEST,GL_NICESTLEFT="270" WIDTH="356"heavy fog mode 
(default)LEFT="0" WIDTH="81"FG_VTX_EXP2, FG_PIX_EXP2LEFT="90" WIDTH="81"GL_EXP2LEFT="180" WIDTH="81"GL_FASTEST,GL_NICESTLEFT="270" WIDTH="356"haze modeLEFT="0" WIDTH="81"FG_VTX_LIN, FG_PIX_LINLEFT="90" WIDTH="81"GL_LINEARLEFT="180" WIDTH="81"GL_FASTEST,GL_NICESTLEFT="270" WIDTH="356"linear fog mode (use 
for depthcueing)Here's an example program that demonstrates depth cueing in OpenGL:/*
† †*  depthcue.c
† †*  This program draws a wireframe model, which uses
† †*  intensity (brightness) to give clues to distance.
† †*  Fog is used to achieve this effect.
† †*/
#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"

/*  Initialize linear fog for depth cueing.
† †*/
void myinit(void)
{
† †   GLfloat fogColor[4] = {0.0, 0.0, 0.0, 1.0};

† †   glEnable(GL_FOG);
† †   glFogi (GL_FOG_MODE, GL_LINEAR);
† †   glHint (GL_FOG_HINT, GL_NICEST);  /*  per pixel   */
† †   glFogf (GL_FOG_START, 3.0);
† †   glFogf (GL_FOG_END, 5.0);
† †   glFogfv (GL_FOG_COLOR, fogColor);
† †   glClearColor(0.0, 0.0, 0.0, 1.0);
† †   glDepthFunc(GL_LEQUAL);
† †   glEnable(GL_DEPTH_TEST);
† †   glShadeModel(GL_FLAT);
}

/*  display() draws an icosahedron.
† †*/
void display(void)
{
† †   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
† †   glColor3f (1.0, 1.0, 1.0);
† †   auxWireIcosahedron(1.0);
† †   glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
† †   glViewport(0, 0, w, h);
† †   glMatrixMode(GL_PROJECTION);
† †   glLoadIdentity();
† †   gluPerspective (45.0, (GLfloat) w/(GLfloat) h, 3.0, 5.0);
† †   glMatrixMode(GL_MODELVIEW);
† †   glLoadIdentity ();
† †   glTranslatef (0.0, 0.0, -4.0); /*move object into view*/
}
/*  Main Loop
† †*/
int main(int argc, char** argv)
{
† †   auxInitDisplayMode (AUX_SINGLE | AUX_RGBA | AUX_DEPTH);
† †   auxInitPosition (0, 0, 400, 400);
† †   auxInitWindow (argv[0]);
† †   myinit();
† †   auxReshapeFunc (myReshape);
† †   auxMainLoop(display);
}LBL="" HELPID=""Porting ID="41945"Curve and Surface CommandsID="chap.03284"OpenGL does not support equivalents to the old-style curves and surface patches. You'll need to reimplement if your code uses any of these calls:ID="chap.03285"defbasis()ID="chap.03286"curvebasis(), ID="chap.03287"curveprecision(), crv(), crvn(), rcrv(), rcrvn(), and curveit()ID="chap.03288"ID="chap.03289"ID="chap.03290"ID="chap.03291"ID="chap.03292"ID="chap.03293"patchbasis(), ID="chap.03294"patchcurves(), patchprecision(), patch()ID="chap.03295"ID="chap.03296", and ID="chap.03297"rpatch()(Silicon Graphics recommends that you reimplement these calls using evaluators, rather than trying to replace them with NURBS. Refer to the OpenGL Reference Manual and the OpenGL Programming Guide for more information on using evaluators.)LBL="" HELPID=""NURBS ObjectsID="chap.03298"OpenGL treats NURBS as objects, similar to the way it treats quadrics: you create a NURBS object and then specify how it should be rendered. IDREF="54158" TYPE="TABLE"Table 3-26
 lists the NURBS object commands. COLUMNS="2"LBL="3-26"Table 3-26 ID="54158"Calls for Managing NURBS ObjectsLEFT="0" WIDTH="117"OpenGL CallLEFT="125" WIDTH="356"MeaningLEFT="0" WIDTH="117"gluNewNurbsRenderer()ID="chap.03299"LEFT="125" WIDTH="356"create a new NURBS objectLEFT="0" WIDTH="117"gluDeleteNurbsRenderer()ID="chap.03300"LEFT="125" WIDTH="356"delete a NURBS objectLEFT="0" WIDTH="117"gluNurbsCallback()ID="chap.03301"LEFT="125" WIDTH="356"associate a callback with a NURBS object, for error 
handlingPorting notes:ID="chap.03302"ID="chap.03303"NURBS control points are now floats, not doubles.The stride parameter is now counted in floats, not bytes.If you're using lighting and you're not specifying normals, call ID="chap.03304"glEnable() with GL_AUTO_NORMAL as the parameter to generate normals automatically.LBL="" HELPID=""ID="41356"NURBS CurvesThe OpenGL calls for drawing NURBS are very similar to the IRIS GL calls. You specify knot sequences and control points using a gluNurbsCurve() call, which must be contained within a glBeginCurve()/glEndCurve() pair.† †IDREF="80167" TYPE="TABLE"Table 3-27
 summarizes the calls for drawing NURBS curves.COLUMNS="3"LBL="3-27"Table 3-27 ID="80167"Calls for Drawing NURBS CurvesLEFT="0" WIDTH="108"IRIS GL CallLEFT="115" WIDTH="108"OpenGL CallLEFT="230" WIDTH="356"MeaningLEFT="0" WIDTH="108"bgncurve()ID="chap.03305"LEFT="115" WIDTH="108"gluBeginCurve()ID="chap.03306"LEFT="230" WIDTH="356"begin a curve definitionLEFT="0" WIDTH="108"nurbscurve()ID="chap.03307"LEFT="115" WIDTH="108"gluNurbsCurve()ID="chap.03308"LEFT="230" WIDTH="356"specify curve attributesLEFT="0" WIDTH="108"endcurve()ID="chap.03309"LEFT="115" WIDTH="108"gluEndCurve()ID="chap.03310"LEFT="230" WIDTH="356"end a curve definitionPosition, texture, and color coordinates are associated by presenting each as a separate† †gluNurbsCurve() inside the begin/end pair. You can make no more than one call to gluNurbsCurve() for each piece of color, position, and texture data within a single gluBeginCurve()/gluEndCurve() pair. You must make exactly one call to describe the position of the curve (a GL_MAP1_VERTEX_3 or GL_MAP1_VERTEX_4 description). When you call gluEndCurve(), the curve will be tessellated into line segments and then rendered.IDREF="65325" TYPE="TABLE"Table 3-28 lists NURBS curve types.COLUMNS="3"LBL="3-28"Table 3-28 ID="65325"NURBS Curve TypesLEFT="0" WIDTH="72"IRIS GL TypeLEFT="80" WIDTH="144"OpenGL TypeLEFT="230" WIDTH="356"MeaningLEFT="0" WIDTH="72"N_V3DLEFT="80" WIDTH="144"GL_MAP1_VERTEX_3LEFT="230" WIDTH="356"polynomial curveID="chap.03311"LEFT="0" WIDTH="72"N_V3DRLEFT="80" WIDTH="144"GL_MAP1_VERTEX_4LEFT="230" WIDTH="356"rational curveID="chap.03312"LEFT="0" WIDTH="72"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="80" WIDTH="144"GL_MAP1_TEXTURE_COORD_*LEFT="230" WIDTH="356"control points are texture 
coordinatesLEFT="0" WIDTH="72"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="80" WIDTH="144"GL_MAP1_NORMALLEFT="230" WIDTH="356"control points are normalsID="chap.03313"ID="chap.03314"For more information on available evaluator types, see the man page for ID="chap.03315"glMap1().LBL="" HELPID=""ID="88446"Trimming CurvesID="chap.03316"OpenGL trimming curves are very similar to IRIS GL trimming curves. IDREF="86587" TYPE="TABLE"Table 3-29
 lists the calls for defining trimming curves.ID="chap.03317"COLUMNS="3"LBL="3-29"Table 3-29 ID="86587"Calls for Drawing NURBS Trimming CurvesLEFT="0" WIDTH="81"IRIS GL CallLEFT="90" WIDTH="81"OpenGL CallLEFT="180" WIDTH="356"MeaningLEFT="0" WIDTH="81"bgntrim()ID="chap.03318"LEFT="90" WIDTH="81"gluBeginTrim()ID="chap.03319"LEFT="180" WIDTH="356"begin trimming curve definitionLEFT="0" WIDTH="81"pwlcurve()ID="chap.03320"LEFT="90" WIDTH="81"gluPwlCurve()ID="chap.03321"LEFT="180" WIDTH="356"define a piecewise linear curveLEFT="0" WIDTH="81"nurbscurve()ID="chap.03322"LEFT="90" WIDTH="81"gluNurbsCurve()ID="chap.03323"LEFT="180" WIDTH="356"specify trimming curve attributesLEFT="0" WIDTH="81"endtrim()ID="chap.03324"LEFT="90" WIDTH="81"gluEndTrim()ID="chap.03325"LEFT="180" WIDTH="356"end trimming curve definitionLBL="" HELPID=""ID="12666"NURBS SurfacesID="chap.03326"IDREF="78966" TYPE="TABLE"Table 3-30 summarizes the calls for drawing NURBS surfaces.COLUMNS="3"LBL="3-30"Table 3-30 ID="78966"Calls for Drawing NURBS SurfacesLEFT="0" WIDTH="99"IRIS GL CallLEFT="105" WIDTH="108"OpenGL CallLEFT="220" WIDTH="356"MeaningLEFT="0" WIDTH="99"bgnsurface()ID="chap.03327"LEFT="105" WIDTH="108"gluBeginSurface()ID="chap.03328"LEFT="220" WIDTH="356"begin a surface definitionLEFT="0" WIDTH="99"nurbssurface()ID="chap.03329"LEFT="105" WIDTH="108"gluNurbsSurface()ID="chap.03330"LEFT="220" WIDTH="356"specify surface attributesLEFT="0" WIDTH="99"endsurface()ID="chap.03331"LEFT="105" WIDTH="108"gluEndSurface()ID="chap.03332"LEFT="220" WIDTH="356"end a surface definitionIDREF="67597" TYPE="TABLE"Table 3-31 lists parameters for surface types.COLUMNS="3"LBL="3-31"Table 3-31 ID="67597"NURBS Surface TypesLEFT="0" WIDTH="63"IRIS GL TypeLEFT="70" WIDTH="144"OpenGL TypeLEFT="220" WIDTH="356"MeaningLEFT="0" WIDTH="63"N_V3DLEFT="70" WIDTH="144"GL_MAP2_VERTEX_3LEFT="220" WIDTH="356"polynomial curveID="chap.03333"LEFT="0" WIDTH="63"N_V3DRLEFT="70" WIDTH="144"GL_MAP2_VERTEX_4LEFT="220" WIDTH="356"rational curveID="chap.03334"LEFT="0" WIDTH="63"N_C4DLEFT="70" WIDTH="144"GL_MAP2_COLOR_4LEFT="220" WIDTH="356"control points define color 
surface in (R,G,B,A) formLEFT="0" WIDTH="63"N_C4DRLEFT="70" WIDTH="144"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="220" WIDTH="356"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="63"N_T2DLEFT="70" WIDTH="144"GL_MAP2_TEXTURE_COORD_2LEFT="220" WIDTH="356"control points are texture 
coordinatesLEFT="0" WIDTH="63"N_T2DRLEFT="70" WIDTH="144"GL_MAP2_TEXTURE_COORD_3LEFT="220" WIDTH="356"control points are texture 
coordinatesLEFT="0" WIDTH="63"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="70" WIDTH="144"GL_MAP2_NORMALLEFT="220" WIDTH="356"control points are normalsID="chap.03335"For more information on available evaluator types, see the man page for ID="chap.03336"glMap2().Here's an example program that draws a trimmed NURBS surface:/*
† †*  trim.c
† †*  This program draws a NURBS surface in the shape of a
† †*  symmetrical hill, using both a NURBS curve and pwl
† †*  (piecewise linear) curve to trim part of the surface.
† †*/
#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"

GLfloat ctlpoints[4][4][3];

GLUnurbsObj *theNurb;

/*
† †*  Initializes the control points of the surface to 
† †*  a small hill. The control points range from -3 to 
† †*  +3 in x, y, and z
† †*/
void init_surface(void)
{
† †   int u, v;
† †   for (u = 0; u < 4; u++) {
† †       for (v = 0; v < 4; v++) {
† †           ctlpoints[u][v][0] = 2.0*((GLfloat)u - 1.5);
† †           ctlpoints[u][v][1] = 2.0*((GLfloat)v - 1.5);

† †           if ( (u == 1 || u == 2) && (v == 1 || v == 2))
† †               ctlpoints[u][v][2] = 3.0;
† †           else
† †               ctlpoints[u][v][2] = -3.0;
† †       }
† †   }
}

/*  Initialize material property and depth buffer.
† †*/
void myinit(void)
{
† †   GLfloat mat_diffuse[] = { 0.6, 0.6, 0.6, 1.0 };
† †   GLfloat mat_specular[] = { 0.9, 0.9, 0.9, 1.0 };
† †   GLfloat mat_shininess[] = { 128.0 };

† †   glClearColor (0.0, 0.0, 0.0, 1.0);
† †   glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
† †   glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
† †   glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);

† †   glEnable(GL_LIGHTING);
† †   glEnable(GL_LIGHT0);
† †   glDepthFunc(GL_LEQUAL);
† †   glEnable(GL_DEPTH_TEST);
† †   glEnable(GL_AUTO_NORMAL);
† †   glEnable(GL_NORMALIZE);

† †   init_surface();

† †   theNurb = gluNewNurbsRenderer();
† †   gluNurbsProperty(theNurb, GLU_SAMPLING_TOLERANCE, 50.0);
† †   gluNurbsProperty(theNurb, GLU_DISPLAY_MODE, GLU_FILL);
}

void display(void)
{
† †   GLfloat knots[8] = {0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0};
† †   GLfloat edgePt[5][2] = /* counter clockwise */
† †   {{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}, {0.0, 1.0},
† †    {0.0, 0.0}};
† †   GLfloat curvePt[4][2] = /* clockwise */
† †   {{0.25, 0.5}, {0.25, 0.75}, {0.75, 0.75}, {0.75, 0.5}};
† †   GLfloat curveKnots[8] =
† †       {0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0};
† †   GLfloat pwlPt[4][2] = /* clockwise */
† †       {{0.75, 0.5}, {0.5, 0.25}, {0.25, 0.5}};

† †   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
† †   glPushMatrix();
† †   glRotatef(330.0, 1.,0.,0.);
† †   glScalef (0.5, 0.5, 0.5);
† †   gluBeginSurface(theNurb);
† †   gluNurbsSurface(theNurb,
† †           8, knots,
† †           8, knots,
† †           4 * 3,
† †           3,
† †           &ctlpoints[0][0][0],
† †           4, 4,
† †           GL_MAP2_VERTEX_3);
† †   gluBeginTrim (theNurb);
† †       gluPwlCurve (theNurb, 5, &edgePt[0][0], 2,
† †                    GLU_MAP1_TRIM_2);
† †   gluEndTrim (theNurb);
† †   gluBeginTrim (theNurb);
† †       gluNurbsCurve (theNurb, 8, curveKnots, 2,
† †               &curvePt[0][0], 4, GLU_MAP1_TRIM_2);
† †       gluPwlCurve (theNurb, 3, &pwlPt[0][0], 2,
† †                    GLU_MAP1_TRIM_2);
† †   gluEndTrim (theNurb);
† †   gluEndSurface(theNurb);

† †   glPopMatrix();
† †   glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
† †   glViewport(0, 0, w, h);
† †   glMatrixMode(GL_PROJECTION);
† †   glLoadIdentity();
† †   gluPerspective (45.0, (GLdouble)w/(GLdouble)h, 3.0, 8.0);

† †   glMatrixMode(GL_MODELVIEW);
† †   glLoadIdentity();
† †   glTranslatef (0.0, 0.0, -5.0);
}
/*  Main Loop
† †*/
int main(int argc, char** argv)
{
† †   auxInitDisplayMode (AUX_SINGLE | AUX_RGBA | AUX_DEPTH);
† †   auxInitPosition (0, 0, 500, 500);
† †   auxInitWindow (argv[0]);
† †   myinit();
† †   auxReshapeFunc (myReshape);
† †   auxMainLoop(display);
}LBL="" HELPID=""Porting ID="91804"Antialiasing CallsID="chap.03337"Subpixel mode is always on, so the IRIS GL call subpixel (TRUE) is not necessary and has no OpenGL equivalent.LBL="" HELPID=""ID="87998"BlendingID="chap.03338"ID="chap.03339"Blending is off by default. If you use _DA or _MDA blend functions, you'll need to allocate destination alpha bits when you choose a visualname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'you need to use X for this, so refer to ID="chap.03340"ID="chap.03341"IDREF="37274" TYPE="TITLE"Chapter 5
.Porting Tips:In IRIS GL, when drawing to both front and back buffers, blending is done by reading one of the buffers, blending with that color, and then writing the result to both buffers. In OpenGL, however, each buffer is read in turn, blended, and then written.IDREF="73474" TYPE="TABLE"Table 3-32 lists IRIS GL and OpenGL blending calls.COLUMNS="3"LBL="3-32"Table 3-32 ID="73474"Blending CallsLEFT="0" WIDTH="108"IRIS GLLEFT="115" WIDTH="108"OpenGLLEFT="230" WIDTH="356"MeaningLEFT="0" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="115" WIDTH="108"glEnable(GL_BLEND)ID="chap.03342"LEFT="230" WIDTH="356"turn on blendingLEFT="0" WIDTH="108"blendfunction()ID="chap.03343"LEFT="115" WIDTH="108"glBlendFunc()ID="chap.03344"LEFT="230" WIDTH="356"specify a blend functionThe calls glBlendFunc() and blendfunction() are almost identical. IDREF="19817" TYPE="TABLE"Table 3-33
 lists the OpenGL equivalents to the IRIS GL blend factors.ID="chap.03345"COLUMNS="3"LBL="3-33"Table 3-33 ID="19817"Blending FactorsLEFT="0" WIDTH="90"IRIS GL LEFT="95" WIDTH="144"OpenGLLEFT="245" WIDTH="356"NotesLEFT="0" WIDTH="90"BF_ZEROLEFT="95" WIDTH="144"GL_ZEROLEFT="245" WIDTH="356"LEFT="0" WIDTH="90"BF_ONELEFT="95" WIDTH="144"GL_ONELEFT="245" WIDTH="356"LEFT="0" WIDTH="90"BF_SALEFT="95" WIDTH="144"GL_SRC_ALPHALEFT="245" WIDTH="356"LEFT="0" WIDTH="90"BF_MSALEFT="95" WIDTH="144"GL_ONE_MINUS_SRC_ALPHALEFT="245" WIDTH="356"LEFT="0" WIDTH="90"BF_DALEFT="95" WIDTH="144"GL_DST_ALPHALEFT="245" WIDTH="356"LEFT="0" WIDTH="90"BF_MDALEFT="95" WIDTH="144"GL_ONE_MINUS_DST_ALPHALEFT="245" WIDTH="356"LEFT="0" WIDTH="90"BF_SCLEFT="95" WIDTH="144"GL_SRC_COLORLEFT="245" WIDTH="356"LEFT="0" WIDTH="90"BF_MSCLEFT="95" WIDTH="144"GL_ONE_MINUS_SRC_COLORLEFT="245" WIDTH="356"destination onlyLEFT="0" WIDTH="90"BF_DCLEFT="95" WIDTH="144"GL_DST_COLORLEFT="245" WIDTH="356"source onlyLEFT="0" WIDTH="90"BF_MDCLEFT="95" WIDTH="144"GL_ONE_MINUS_DST_COLORLEFT="245" WIDTH="356"source onlyLEFT="0" WIDTH="90"BF_MIN_SA_MDALEFT="95" WIDTH="144"GL_SRC_ALPHA_SATURATELEFT="245" WIDTH="356"LBL="" HELPID=""ID="93903"afunction() test functionsID="chap.03346"IDREF="11057" TYPE="TABLE"Table 3-34 lists the available alpha test functions.COLUMNS="2"LBL="3-34"Table 3-34 ID="11057"Alpha Test FunctionsLEFT="0" WIDTH="113"afunction()LEFT="120" WIDTH="356"glAlphaFunc()LEFT="0" WIDTH="113"AF_NOTEQUALID="chap.03347"LEFT="120" WIDTH="356"GL_NOTEQUALID="chap.03348"LEFT="0" WIDTH="113"AF_ALWAYSID="chap.03349"LEFT="120" WIDTH="356"GL_ALWAYSID="chap.03350"LEFT="0" WIDTH="113"AF_NEVERID="chap.03351"LEFT="120" WIDTH="356"GL_NEVERID="chap.03352"LEFT="0" WIDTH="113"AF_LESSID="chap.03353"LEFT="120" WIDTH="356"GL_LESSID="chap.03354"LEFT="0" WIDTH="113"AF_EQUALID="chap.03355"LEFT="120" WIDTH="356"GL_EQUALID="chap.03356"LEFT="0" WIDTH="113"AF_LEQUALID="chap.03357"LEFT="120" WIDTH="356"GL_LEQUALID="chap.03358"LEFT="0" WIDTH="113"AF_GREATERID="chap.03359"LEFT="120" WIDTH="356"GL_GREATERID="chap.03360"LEFT="0" WIDTH="113"AF_GEQUALID="chap.03361"LEFT="120" WIDTH="356"GL_GEQUALID="chap.03362"LBL="" HELPID=""ID="65073"Antialiasing CallsID="chap.03363"OpenGL has direct equivalents to IRIS GL's antialiasing calls. IDREF="51190" TYPE="TABLE"Table 3-35
 lists them.COLUMNS="3"LBL="3-35"Table 3-35 ID="51190"Calls to Draw Antialiased PrimitivesLEFT="0" WIDTH="63"IRIS GL CallLEFT="70" WIDTH="153"OpenGL CallLEFT="230" WIDTH="356"MeaningLEFT="0" WIDTH="63"pntsmooth()ID="chap.03364"LEFT="70" WIDTH="153"glEnable(GL_POINT_SMOOTH)ID="chap.03365"LEFT="230" WIDTH="356"enable antialiasing of pointsLEFT="0" WIDTH="63"linesmooth()ID="chap.03366"LEFT="70" WIDTH="153"glEnable(GL_LINE_SMOOTH)LEFT="230" WIDTH="356"enable antialiasing of linesLEFT="0" WIDTH="63"polysmooth()ID="chap.03367"LEFT="70" WIDTH="153"glEnable(GL_POLYGON_SMOOTH)LEFT="230" WIDTH="356"enable antialiasing of 
polygonsUse the corresponding glDisable()ID="chap.03368" calls to turn off antialiasing.With IRIS GL, you can control the quality of the antialiasing, by calling:linesmooth(SML_ON + SML_SMOOTHER);OpenGL provides similar controlname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'use ID="chap.03369"glHint():glHint(GL_POINT_SMOOTH_HINT, hintMode);
glHint(GL_LINE_SMOOTH_HINT, hintMode);
glHint(GL_POLYGON_SMOOTH_HINT, hintMode);where hintMode is one of the following:GL_NICESTID="chap.03370"Use the highest quality smoothing.GL_FASTESTID="chap.03371"Use the most efficient smoothing.GL_DONT_CAREID="chap.03372"You don't care which smoothing method is used.IRIS GL also allowed end correction by calling:ID="chap.03373"linesmooth(SML_ON +  SML_END_CORRECT);OpenGL doesn't have an equivalent for this call.LBL="" HELPID=""ID="19353"Accumulation Buffer CallsID="chap.03374"You must allocate your accumulation buffer by requesting the appropriate visual with auxInitDisplayMode() or† †glXChooseVisual(). (To learn how to use auxInitDisplayMode(), see IDREF="64084" TYPE="TITLE""Porting Display Mode Initialization Calls with auxInitDisplayMode()"
. For information on glXChooseVisual(), see the glXIntro and† †glXChooseVisual() man pages and refer to IDREF="37274" TYPE="TITLE"Chapter 5
.) Otherwise, porting should be straightforward. IDREF="42317" TYPE="TABLE"Table 3-36
 lists calls that affect the accumulation buffer.COLUMNS="3"LBL="3-36"Table 3-36 ID="42317"Accumulation Buffer CallsLEFT="0" WIDTH="108"IRIS GL CallLEFT="115" WIDTH="108"OpenGL CallLEFT="230" WIDTH="356"MeaningLEFT="0" WIDTH="108"acsize()ID="chap.03375"LEFT="115" WIDTH="108"auxInitDisplayMode() orID="chap.03376"glXChooseVisual() ID="chap.03377"LEFT="230" WIDTH="356"specify number of bitplanes 
per color component in the 
accumulation bufferLEFT="0" WIDTH="108"acbuf()ID="chap.03378"LEFT="115" WIDTH="108"glAccum()ID="chap.03379"LEFT="230" WIDTH="356"operate on the 
accumulation bufferLEFT="0" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="115" WIDTH="108"glClearAccum()ID="chap.03380"LEFT="230" WIDTH="356"set clear values for 
accumulation bufferLEFT="0" WIDTH="108"acbuf(AC_CLEAR)LEFT="115" WIDTH="108"glClear(GL_ACCUM_ID="chap.03381"ID="chap.03382"BUFFER_BIT)LEFT="230" WIDTH="356"clear the accumulation 
bufferIDREF="79183" TYPE="TABLE"Table 3-37 lists IRIS GL's acbuf() arguments along with the corresponding arguments to OpenGL's glAccum().COLUMNS="2"LBL="3-37"Table 3-37 ID="79183"Accumulation Buffer OperationsLEFT="0" WIDTH="162"IRIS GL ArgumentLEFT="170" WIDTH="356"OpenGL ArgumentLEFT="0" WIDTH="162"AC_ACCUMULATEID="chap.03383"LEFT="170" WIDTH="356"GL_ACCUMID="chap.03384"LEFT="0" WIDTH="162"AC_CLEAR_ACCUMULATEID="chap.03385"LEFT="170" WIDTH="356"GL_LOADID="chap.03386"LEFT="0" WIDTH="162"AC_RETURNID="chap.03387"LEFT="170" WIDTH="356"GL_RETURNID="chap.03388"LEFT="0" WIDTH="162"AC_MULTID="chap.03389"LEFT="170" WIDTH="356"GL_MULTID="chap.03390"LEFT="0" WIDTH="162"AC_ADDID="chap.03391"LEFT="170" WIDTH="356"GL_ADDID="chap.03392"LBL="" HELPID=""ID="80759"Stencil Plane CallsID="chap.03393"In OpenGL, you allocate stencil planes by requesting the appropriate visual with† †ID="chap.03394"auxInitDisplayMode() or glXChooseVisual(). (To learn how to use auxInitDisplayMode(), see IDREF="64084" TYPE="TITLE""Porting Display Mode Initialization Calls with auxInitDisplayMode()"
. For information on glXChooseVisual(), see the glXIntro and† †glXChooseVisual() man pages and refer to IDREF="37274" TYPE="TITLE"Chapter 5
.) Otherwise, porting should be straightforward. IDREF="74240" TYPE="TABLE"Table 3-38
 lists calls that affect the stencil planes.COLUMNS="3"LBL="3-38"Table 3-38 ID="74240"Stencil OperationsLEFT="0" WIDTH="75"IRIS GL CallLEFT="80" WIDTH="140"OpenGL CallLEFT="225" WIDTH="356"MeaningLEFT="0" WIDTH="75"stensize()ID="chap.03395"LEFT="80" WIDTH="140"glXChooseVisual()LEFT="225" WIDTH="356"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="75"stencil(TRUE, ...)ID="chap.03396"LEFT="80" WIDTH="140"glEnable(GL_STENCIL_TEST)ID="chap.03397"LEFT="225" WIDTH="356"enable stencil testsLEFT="0" WIDTH="75"stencil()LEFT="80" WIDTH="140"glStencilOp()ID="chap.03398"LEFT="225" WIDTH="356"set stencil test actionsLEFT="0" WIDTH="75"stencil(... func, ...)LEFT="80" WIDTH="140"glStencilFunc()ID="chap.03399"LEFT="225" WIDTH="356"set function and reference 
value for stencil testingLEFT="0" WIDTH="75"swritemask()ID="chap.03400"LEFT="80" WIDTH="140"glStencilMask()ID="chap.03401"LEFT="225" WIDTH="356"specify which stencil bits 
can be writtenLEFT="0" WIDTH="75"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="80" WIDTH="140"glClearStencil()ID="chap.03402"LEFT="225" WIDTH="356"specify the clear value for 
the stencil bufferLEFT="0" WIDTH="75"sclear()ID="chap.03403"LEFT="80" WIDTH="140"glClear(GL_STENCIL_BUFFER_
BIT)ID="chap.03404"ID="chap.03405"ID="chap.03406"ID="chap.03407"LEFT="225" WIDTH="356"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Stencil comparison functions and stencil pass/fail operations are nearly equivalent in OpenGL and IRIS GL. The IRIS GL stencil function flags are prefaced with SF, the OpenGL flags with GL. IRIS GL pass/fail operation flags are prefaced with ST, the OpenGL flags with GL. Compare the man pages for further details.LBL="" HELPID=""Porting ID="58056"Display ListsID="chap.03408"The OpenGL implementation of display lists is similar to the IRIS GL implementation, with two exceptions: you can't edit display lists once you've created them and you can't call functions from within display lists. Since you can't edit or call functions from within display lists, these IRIS GL commands have no equivalents in OpenGL:ID="chap.03409"editobj()ID="chap.03410"objdelete(),† †objinsert()ID="chap.03411", and ID="chap.03412"objreplace()ID="chap.03413"maketag(), ID="chap.03414"gentag(), ID="chap.03415"istag(), and ID="chap.03416"deltag()ID="chap.03417"callfunc()With IRIS GL, you used the commands ID="chap.03418"makeobj() and ID="chap.03419"closeobj() to create display lists. With OpenGL, you use glNewList()ID="chap.03420" and ID="chap.03421"glEndList(). For details on using glNewList() (including a description of the two list modes and a list of commands that are not compiled into the display list but are executed immediately), see the glNewList() man page and the OpenGL Programming Guide.IDREF="14056" TYPE="TABLE"Table 3-39 lists the IRIS GL display list commands with the corresponding OpenGL commands.COLUMNS="3"LBL="3-39"Table 3-39 ID="14056"Display List CommandsLEFT="0" WIDTH="108"IRIS GL CallLEFT="115" WIDTH="108"OpenGL CallLEFT="230" WIDTH="356"MeaningLEFT="0" WIDTH="108"makeobj()LEFT="115" WIDTH="108"glNewList()LEFT="230" WIDTH="356"create a new display listLEFT="0" WIDTH="108"closeobj()LEFT="115" WIDTH="108"glEndList()LEFT="230" WIDTH="356"signal end of display listLEFT="0" WIDTH="108"callobj()ID="chap.03422"LEFT="115" WIDTH="108"glCallList(), glCallLists()ID="chap.03423"ID="chap.03424"LEFT="230" WIDTH="356"execute display list(s)LEFT="0" WIDTH="108"isobj()ID="chap.03425"LEFT="115" WIDTH="108"glIsList()ID="chap.03426"LEFT="230" WIDTH="356"test for display list existenceLEFT="0" WIDTH="108"delobj()ID="chap.03427"LEFT="115" WIDTH="108"glDeleteLists()ID="chap.03428"LEFT="230" WIDTH="356"delete contiguous group of 
display listsLEFT="0" WIDTH="108"genobj()ID="chap.03429"LEFT="115" WIDTH="108"glGenLists()ID="chap.03430"LEFT="230" WIDTH="356"generate the given number 
of contiguous empty 
display listsLBL="" HELPID=""ID="14029"Porting bbox2() CallsThe command† †bbox2() has no OpenGL equivalent. To port† †bbox2() calls, first create a new (OpenGL) display list that has everything that was in the corresponding IRIS GL display list except the bbox2() call. Then, in feedback mode, draw a rectangle the same size as the IRIS GL bbox: if nothing comes back, the box was completely clipped and you shouldn't draw the display list.LBL="" HELPID=""ID="91726"Edited Display ListsID="chap.03431"ID="chap.03432"Although you can't actually edit OpenGL display lists, you can get a similar result by nesting display lists, then destroying and creating new versions of the sublists.This OpenGL code fragment shows how:glNewList (1, GL_COMPILE);
† †   glIndexi (MY_RED);
glEndList ();
† †   glNewList (2, GL_COMPILE);
† †   glScalef (1.2, 1.2, 1.0);
glEndList ();

glNewList (3, GL_COMPILE);
† †   glCallList (1);
† †   glCallList (2);
glEndList ();
† †    .
† †    .
glDeleteLists (1, 2);
glNewList (1, GL_COMPILE);
† †   glIndexi (MY_CYAN);
glEndList ();
glNewList (2, GL_COMPILE);
† †   glScalef (0.5, 0.5, 1.0);
glEndList ();LBL="" HELPID=""A Sample Implementation of a Display ListID="chap.03433"An IRIS GL display list might look like this:makeobj (10);   /* 10 object   */
† †  cpack (0x0000FF);
† †  recti (164, 33, 364, 600);  /* hollow rectangle */
closeobj ();

makeobj (20);     /* 20 object -- various things   */
† †  cpack (0xFFFF00);
† †  circi(0,0,25); /* draw an unfilled circle   */
† †  rectfi (100, 100, 200, 200); /* draw filled rect */
closeobj ();
† †  
makeobj (30);      /* 30 -- THE MAIN OBJECT */
† †  callobj (10);
† †  cpack (0xFFFFFF);      
† †  rectfi (400, 100, 500, 300); /* draw filled rect */
† †  callobj (20);
closeobj ();
/* now draw by calling the lists */
callobj(30);The example above defines three display lists, one of which refers to the others in its definition. Translated to OpenGL, that code might look like this:glNewList( 10, GL_COMPILE );
† †  glColor3f( 1, 0, 0 );
† †  glRecti( 164, 33, 364, 600 );
glEndList();

glNewList( 20, GL_COMPILE );
† †  glColor3f( 1, 1, 0 ); /* set color to YELLOW  */
† †  glPolygonMode(GL_BOTH, GL_LINE); /* unfilled mode */
† †  glBegin(GL_POLYGON); /* use polygon to approximate circle */
† †     for(i=0;i<100;i++) {
† †        cosine = 25 * cos(i*2*PI/100.0);
† †        sine =   25 * sin(i*2*PI/100.0);
† †       glVertex2f(cosine,sine);
† †     }
† †  glEnd();
† †  glBegin(GL_QUADS);
† †     glColorf( 0, 1, 1 ); /* set color to CYAN  */
† †     glVertex2i(100,100);
† †     glVertex2i(100,200);
† †     glVertex2i(200,200);
† †     glVertex2i(100,200);
† †  glEnd();
glEndList();

glNewList(30, GL_COMPILE); /* List #30 */
† †  glCallList( 10 );
† †     glColorf( 1, 1, 1 ); /* set color to WHITE */   
† †     glRecti(400, 100, 500, 300);
† †  glCallList( 20 );
glEndList();

/* execute the display lists */
glCallList( 30 );LBL="" HELPID=""ID="21145"Porting defs, binds, and sets: Replacing `Tables' of Stored DefinitionsID="chap.03434"OpenGL does not have tables of stored definitionsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'you can't define lighting models, materials, textures, line styles, or patterns as separate objects as you could in IRIS GL. Thus, there are no direct equivalents to these IRIS GL calls:lmdef()ID="chap.03435" and† †lmbind()ID="chap.03436"ID="chap.03437"tevdef() and ID="chap.03438"tevbind()ID="chap.03439"texdef() and ID="chap.03440"texbind()ID="chap.03441"deflinestyle() and ID="chap.03442"setlinestyle()ID="chap.03443"defpattern() and setpattern()ID="chap.03444"However, you can use display lists to mimic the def/bind behavior. (It's often best to optimize by writing display lists that contain just a single material definition.)For example, here is a material definition in IRIS GL:float mat[] = {
† †   AMBIENT, .1, .1, .1,
† †   DIFFUSE, 0, .369, .165,
† †   SPECULAR, .5, .5, .5,
† †   SHININESS, 10,
† †   LMNULL
};
lmdef(DEFMATERIAL, 1, 0, mat);
lmbind(MATERIAL, 1);In the following code fragment, the same material is defined in a display list, referred to by the list number in MYMATERIAL.#define MYMATERIAL 10
/* you would probably use glGenLists() to get list numbers */
GLfloat   mat_amb[] = {.1, .1, .1, 1.0}; 
GLfloat   mat_dif[] = {0, .369, .165, 1.0};
GLfloat   mat_spec[] = { .5, .5, .5, 1.0};

glNewList( MYMATERIAL, GL_COMPILE );
† †   glMaterialfv( GL_FRONT, GL_AMBIENT, mat_amb);
† †   glMaterialfv( GL_FRONT, GL_DIFFUSE, mat_dif);
† †   glMaterialfv( GL_FRONT, GL_SPECULAR, mat_spec);
† †   glMateriali(  GL_FRONT, GL_SHININESS, 10);
glEndList();

glCallList( MYMATERIAL );LBL="" HELPID=""ID="20887"Porting Lighting and Materials CallsID="chap.03445"ID="chap.03446"ID="chap.03447"ID="chap.03448"You'll probably need to port lighting and materials code by hand, since the OpenGL calls differ substantially from the IRIS GL calls. The OpenGL API is much cleaner, however; it has separate calls for setting lights, light models, and materials.Porting notes:OpenGL has no table of stored definitions. It has no separate lmdef()ID="chap.03449" and ID="chap.03450"lmbind() calls. You can use display lists to mimic the def/bind behavior. See IDREF="21145" TYPE="TITLE""Porting defs, binds, and sets: Replacing `Tables' of Stored Definitions"
 for an example. This might have the added benefit of improving your program's performance.Attenuation is now associated with each light source, rather than with the overall lighting model.Diffuse and specular components are separated out in OpenGL light sources.OpenGL light sources have an alpha component. When porting your code, it's best to set this alpha component to 1.0, indicating 100% fully opaque. That way, alpha values will be determined solely by the alpha component of your materials and the objects in your scene will look the same as they did in IRIS GL. IDREF="24918" TYPE="TABLE"Table 3-40 lists IRIS GL lighting and materials commands and the corresponding OpenGL commands. COLUMNS="3"LBL="3-40"Table 3-40 ID="24918"Lighting and Materials CommandsLEFT="0" WIDTH="113"IRIS GL CallLEFT="120" WIDTH="113"OpenGL CallLEFT="240" WIDTH="356"MeaningLEFT="0" WIDTH="113"lmdef(DEFLIGHT,...)LEFT="120" WIDTH="113"glLight()ID="chap.03451"LEFT="240" WIDTH="356"define a light sourceLEFT="0" WIDTH="113"lmdef(DEFLMODEL, ...)LEFT="120" WIDTH="113"glLightModel()ID="chap.03452"LEFT="240" WIDTH="356"define a lighting modelLEFT="0" WIDTH="113"lmbind()LEFT="120" WIDTH="113"glEnable(GL_LIGHTID="chap.03453"i)LEFT="240" WIDTH="356"enable light iLEFT="0" WIDTH="113"lmbind()LEFT="120" WIDTH="113"glEnable(GL_LIGHTING)LEFT="240" WIDTH="356"enable lightingLEFT="0" WIDTH="113"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="120" WIDTH="113"glGetLight()ID="chap.03454"LEFT="240" WIDTH="356"get light source 
parametersLEFT="0" WIDTH="113"lmdef(DEFMATERIAL, ...)LEFT="120" WIDTH="113"glMaterial()ID="chap.03455"LEFT="240" WIDTH="356"define a materialLEFT="0" WIDTH="113"lmcolor()ID="chap.03456"LEFT="120" WIDTH="113"glColorMaterial()ID="chap.03457"LEFT="240" WIDTH="356"change effect of color 
commands while 
lighting is activeLEFT="0" WIDTH="113"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="120" WIDTH="113"glGetMaterial()ID="chap.03458"LEFT="240" WIDTH="356"get material parametersWhen the first argument for† †lmbind() is DEFMATERIAL, the equivalent command is glMaterial()ID="chap.03459"ID="chap.03460". IDREF="12769" TYPE="TABLE"Table 3-41
 lists the various materials parameters you can set.COLUMNS="4"LBL="3-41"Table 3-41 ID="12769"Material Definition ParametersLEFT="0" WIDTH="77"lmdef() indexLEFT="85" WIDTH="99"glMaterial() parameterLEFT="190" WIDTH="72"DefaultLEFT="270" WIDTH="356"MeaningLEFT="0" WIDTH="77"ALPHALEFT="85" WIDTH="99"IDREF="chap.03TF40a"aGL_DIFFUSELEFT="190" WIDTH="72"LEFT="270" WIDTH="356"LEFT="0" WIDTH="77"AMBIENTID="chap.03461"LEFT="85" WIDTH="99"GL_AMBIENTID="chap.03462"LEFT="190" WIDTH="72"(0.2, 0.2, 0.2, 1.0)LEFT="270" WIDTH="356"ambient colorLEFT="0" WIDTH="77"DIFFUSEID="chap.03463"LEFT="85" WIDTH="99"GL_DIFFUSEID="chap.03464"LEFT="190" WIDTH="72"(0.8, 0.8, 0.8, 1.0)LEFT="270" WIDTH="356"diffuse colorLEFT="0" WIDTH="77"SPECULARID="chap.03465"LEFT="85" WIDTH="99"IDREF="chap.03TF40b"bGL_SPECULARID="chap.03466"LEFT="190" WIDTH="72"(0.0, 0.0, 0.0, 1.0)LEFT="270" WIDTH="356"specular colorLEFT="0" WIDTH="77"EMISSIONID="chap.03467"LEFT="85" WIDTH="99"GL_EMISSIONID="chap.03468"LEFT="190" WIDTH="72"(0.0, 0.0, 0.0, 1.0)LEFT="270" WIDTH="356"emissive colorLEFT="0" WIDTH="77"SHININESSID="chap.03469"LEFT="85" WIDTH="99"GL_SHININESSID="chap.03470"LEFT="190" WIDTH="72"0.0LEFT="270" WIDTH="356"specular exponentLEFT="0" WIDTH="77"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="85" WIDTH="99"GL_AMBIENT_AND_
DIFFUSEID="chap.03471"LEFT="190" WIDTH="72"(see above)LEFT="270" WIDTH="356"equivalent to 
calling glMaterial() 
twice with same 
valuesLEFT="0" WIDTH="77"COLORINDEXESID="chap.03472"LEFT="85" WIDTH="99"GL_COLOR_INDEXESID="chap.03473"LEFT="190" WIDTH="72"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="270" WIDTH="356"color indices for 
ambient, diffuse, 
and specular 
lightingLBL="a" ID="chap.03TF40a"(The fourth value in  the GL_DIFFUSE parameter specifies the alpha value.)LBL="b" ID="chap.03TF40b"In IRIS GL, if the specular exponent (i.e. SHININESS) is zero, then the specular component 
of the light is not added in. In OpenGL, the specular component is added in anyway.When the first argument of lmdef() is DEFLMODEL, the equivalent OpenGL call is glLightModel(). The exception is the case when the first argument of† †lmdef() is DEFLMODEL, ATTENUATIONname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in this case, you'll need to replace† †lmdef() with several glLight() calls. IDREF="65825" TYPE="TABLE"Table 3-42
 lists equivalent lighting model parameters.COLUMNS="4"LBL="3-42"Table 3-42 ID="65825"Lighting Model ParametersLEFT="0" WIDTH="72"lmdef() indexLEFT="80" WIDTH="107"glLightModel() ParameterLEFT="195" WIDTH="70"DefaultLEFT="270" WIDTH="356"MeaningLEFT="0" WIDTH="72"AMBIENTLEFT="80" WIDTH="107"GL_LIGHT_MODEL_A
MBIENTID="chap.03474"LEFT="195" WIDTH="70"(0.2, 0.2, 0.2, 1.0)LEFT="270" WIDTH="356"ambient color of 
sceneLEFT="0" WIDTH="72"ATTENUATIONLEFT="80" WIDTH="107"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="195" WIDTH="70"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="270" WIDTH="356"see glLight()LEFT="0" WIDTH="72"LOCALVIEWERLEFT="80" WIDTH="107"GL_LIGHT_MODEL_LO
CAL_VIEWERID="chap.03475"LEFT="195" WIDTH="70"GL_FALSELEFT="270" WIDTH="356"viewer local 
(TRUE) or infinite 
(FALSE)LEFT="0" WIDTH="72"TWOSIDELEFT="80" WIDTH="107"GL_LIGHT_MODEL_T
WO_SIDEID="chap.03476"LEFT="195" WIDTH="70"GL_FALSELEFT="270" WIDTH="356"use two-sided 
lighting when 
TRUEWhen the first argument of† †lmdef() is DEFLIGHT, the equivalent OpenGL call is† †glLight(). IDREF="13070" TYPE="TABLE"Table 3-43
 lists equivalent lighting parameters.COLUMNS="4"LBL="3-43"Table 3-43 ID="13070"Light ParametersLEFT="0" WIDTH="80"lmdef() indexLEFT="85" WIDTH="101"glLight() ParameterLEFT="195" WIDTH="72"DefaultLEFT="275" WIDTH="356"MeaningLEFT="0" WIDTH="80"AMBIENTLEFT="85" WIDTH="101"GL_AMBIENTLEFT="195" WIDTH="72"(0.0, 0.0, 0.0, 1.0)LEFT="275" WIDTH="356"ambient intensityLEFT="0" WIDTH="80"LEFT="85" WIDTH="101"GL_DIFFUSELEFT="195" WIDTH="72"(1.0, 1.0, 1.0, 1.0)LEFT="275" WIDTH="356"diffuse intensityLEFT="0" WIDTH="80"LEFT="85" WIDTH="101"GL_SPECULARLEFT="195" WIDTH="72"(1.0, 1.0, 1.0, 1.0)LEFT="275" WIDTH="356"specular intensityLEFT="0" WIDTH="80"LCOLORID="chap.03477"LEFT="85" WIDTH="101"LEFT="195" WIDTH="72"LEFT="275" WIDTH="356"LEFT="0" WIDTH="80"POSITIONID="chap.03478"LEFT="85" WIDTH="101"GL_POSITIONID="chap.03479"LEFT="195" WIDTH="72"(0.0, 0.0, 1.0, 0.0)LEFT="275" WIDTH="356"position of lightLEFT="0" WIDTH="80"SPOTDIRECTIONID="chap.03480"LEFT="85" WIDTH="101"GL_SPOT_DIRECTIONID="chap.03481"LEFT="195" WIDTH="72"(0, 0, -1)LEFT="275" WIDTH="356"spot directionLEFT="0" WIDTH="80"SPOTLIGHTID="chap.03482"LEFT="85" WIDTH="101"LEFT="195" WIDTH="72"LEFT="275" WIDTH="356"LEFT="0" WIDTH="80"LEFT="85" WIDTH="101"GL_SPOT_EXPONENTID="chap.03483"LEFT="195" WIDTH="72"0LEFT="275" WIDTH="356"intensity 
distributionLEFT="0" WIDTH="80"LEFT="85" WIDTH="101"GL_SPOT_CUTOFFID="chap.03484"LEFT="195" WIDTH="72"180LEFT="275" WIDTH="356"maximum spread 
angle of light 
sourceLEFT="0" WIDTH="80"DEFLMODEL, 
ATTENUATION, 
...LEFT="85" WIDTH="101"GL_CONSTANT_ID="chap.03485"ID="chap.03486"ATTENUATIONGL_LINEAR_ID="chap.03487"ATTENUATIONGL_QUADRATIC_ID="chap.03488"ATTENUATIONLEFT="195" WIDTH="72"(1,0,0)LEFT="275" WIDTH="356"attenuation factorsHere's an OpenGL code fragment that demonstrates some OpenGL lighting and material calls, including two-sided lighting:ID="chap.03489"ID="chap.03490"/* Initialize lighting */
void myinit(void)
{
† †   GLfloat light_ambient[] = { 0.0, 0.0, 0.0, 1.0 };
† †   GLfloat light_diffuse[] = { 1.0, 1.0, 1.0, 1.0 };
† †   GLfloat light_specular[] = { 1.0, 1.0, 1.0, 1.0 };
/*      light_position is NOT default value     */
† †   GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };

† †   glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
† †   glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
† †   glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
† †   glLightfv(GL_LIGHT0, GL_POSITION, light_position);

† †   glFrontFace (GL_CW);
† †   glEnable(GL_LIGHTING);
† †   glEnable(GL_LIGHT0);
† †   glEnable(GL_AUTO_NORMAL);
† †   glEnable(GL_NORMALIZE);
† †   glDepthFunc(GL_LEQUAL);
† †   glEnable(GL_DEPTH_TEST);
}
† †void display(void)
{
† †   GLdouble eqn[4] = {1.0, 0.0, -1.0, 1.0};
† †   GLfloat mat_diffuse[] = { 0.8, 0.8, 0.8, 1.0 };
† †   GLfloat back_diffuse[] = { 0.8, 0.2, 0.8, 1.0 };

† †   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

† †   glPushMatrix ();
† †   glClipPlane (GL_CLIP_PLANE0, eqn);  /*  slice objects   */
† †   glEnable (GL_CLIP_PLANE0);

† †   glPushMatrix ();
† †   glTranslatef (0.0, 2.0, 0.0);
† †   auxSolidTeapot(1.0);        /*  one-sided lighting  */
† †   glPopMatrix ();

† †       /*  two-sided lighting, but same material       */
† †   glLightModelf (GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
† †   glMaterialfv (GL_FRONT_AND_BACK, GL_DIFFUSE,
† †                 mat_diffuse);
† †   glPushMatrix ();
† †   glTranslatef (0.0, 0.0, 0.0);
† †   auxSolidTeapot(1.0);
† †   glPopMatrix ();

† †       /*  two-sided lighting, two different materials */
† †   glMaterialfv (GL_FRONT, GL_DIFFUSE, mat_diffuse);
† †   glMaterialfv (GL_BACK, GL_DIFFUSE, back_diffuse);
† †   glPushMatrix ();
† †   glTranslatef (0.0, -2.0, 0.0);
† †   auxSolidTeapot(1.0);
† †   glPopMatrix ();

† †   glLightModelf (GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE);
† †   glDisable (GL_CLIP_PLANE0);
† †   glPopMatrix ();
† †   glFlush();
}LBL="" HELPID=""Porting ID="43929"Texture CallsID="chap.03491"A single IRIS GL call might be replaced with two or more OpenGL calls, so you'll definitely need to edit the ID="chap.03492"toogl output for these calls. You might need to restructure your code, or use more variables than you did before. Porting notes:OpenGL keeps no tables of textures, just a single 1D texture and a single 2D texture. If you want to reuse your textures, put them in a display list, as described in IDREF="21145" TYPE="TITLE""Porting defs, binds, and sets: Replacing `Tables' of Stored Definitions"
.OpenGL doesn't automatically generate mipmaps for youname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'if you're using mipmaps, you'll need to call ID="chap.03493"gluBuild2DMipmaps() first.You need to use† †glEnable()ID="chap.03494" and ID="chap.03495"glDisable() to turn texturing capabilities on and off. See the man page for details.Texture size in OpenGL is more strictly regulated than in IRIS GL. An OpenGL texture must be2n + 2bwhere n is an integer and b is:0, if there's no border1, if there's a border pixel (textures in OpenGL can have 1 pixel borders)IDREF="76828" TYPE="TABLE"Table 3-44 lists the general OpenGL equivalents to IRIS GL texture calls.COLUMNS="3"LBL="3-44"Table 3-44 ID="76828"Texture CommandsLEFT="0" WIDTH="99"IRIS GL CallLEFT="105" WIDTH="113"OpenGL CallLEFT="225" WIDTH="356"MeaningLEFT="0" WIDTH="99"texdef2d() ID="chap.03496"LEFT="105" WIDTH="113"glTexImage2D()ID="chap.03497"glTexParameter()ID="chap.03498"gluBuild2DMipmaps()ID="chap.03499"LEFT="225" WIDTH="356"specify a 2D texture imageLEFT="0" WIDTH="99"texbind()ID="chap.03500"LEFT="105" WIDTH="113"glTexParameter()ID="chap.03501"glTexImage2D()ID="chap.03502"gluBuild2DMipmaps()ID="chap.03503"LEFT="225" WIDTH="356"select a texture functionLEFT="0" WIDTH="99"tevdef()ID="chap.03504"LEFT="105" WIDTH="113"glTexEnv()ID="chap.03505"LEFT="225" WIDTH="356"define a texture mapping 
environmentLEFT="0" WIDTH="99"tevbind()ID="chap.03506"LEFT="105" WIDTH="113"glTexEnv()ID="chap.03507"LEFT="225" WIDTH="356"select a texture environmentLEFT="0" WIDTH="99"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="105" WIDTH="113"glTexImage1D()ID="chap.03508"LEFT="225" WIDTH="356"LEFT="0" WIDTH="99"t2()ID="chap.03509"LEFT="105" WIDTH="113"glTexCoord()ID="chap.03510"LEFT="225" WIDTH="356"set the current texture 
coordinatesID="chap.03511"LEFT="0" WIDTH="99"texgen()ID="chap.03512"LEFT="105" WIDTH="113"glTexGen()ID="chap.03513"LEFT="225" WIDTH="356"control generation of texture 
coordinatesLEFT="0" WIDTH="99"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="105" WIDTH="113"glGetTexParameter()ID="chap.03514"LEFT="225" WIDTH="356"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="99"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="105" WIDTH="113"gluBuild1DMipmaps()ID="chap.03515"LEFT="225" WIDTH="356"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="99"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="105" WIDTH="113"gluBuild2DMipmaps()ID="chap.03516"LEFT="225" WIDTH="356"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="99"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="105" WIDTH="113"gluScaleImage()ID="chap.03517"ID="chap.03518"LEFT="225" WIDTH="356"scale an image to an 
arbitrary sizeYou'll probably want to look at the OpenGL Programming Guide to get details on how textures work in OpenGL, but here are a few brief, general tips:remember to call gluBuild2DMipmaps() or† †gluBuild1DMipmaps() before trying to use mipmapsuse glTexParameter() to specify wrapping and filtersuse glTexEnv() to set up texturing environmentuse† †glTexImage2D() or glTexImage1D() to load each imageuse glEnable() and glDisable() to turn texturing capabilities on and offSee the man pages for detailed information.LBL="" HELPID=""ID="91980"Translating tevdef()ID="chap.03519"Here's an example of an IRIS GL texture environment definition that specifies the TV_DECAL texture environment option:float tevprops[] = {TV_DECAL, TV_NULL};tevdef(1, 0, tevprops);Here's how you could translate that code to OpenGL:glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);IDREF="21691" TYPE="TABLE"Table 3-45 lists the IRIS GL texture environment options and their OpenGL equivalents.COLUMNS="2"LBL="3-45"Table 3-45 ID="21691"Texture Environment OptionsLEFT="0" WIDTH="171"IRIS GL OptionLEFT="180" WIDTH="356"OpenGL OptionLEFT="0" WIDTH="171"TV_MODULATEID="chap.03520"LEFT="180" WIDTH="356"GL_MODULATEID="chap.03521"LEFT="0" WIDTH="171"TV_DECALID="chap.03522"LEFT="180" WIDTH="356"GL_DECALID="chap.03523"LEFT="0" WIDTH="171"TV_BLENDID="chap.03524"LEFT="180" WIDTH="356"GL_BLENDID="chap.03525"LEFT="0" WIDTH="171"TV_COLORID="chap.03526"LEFT="180" WIDTH="356"GL_TEXTURE_ENV_COLORID="chap.03527"LEFT="0" WIDTH="171"TV_ALPHAID="chap.03528"LEFT="180" WIDTH="356"no direct OpenGL equivalentLEFT="0" WIDTH="171"TV_COMPONENT_SELECTID="chap.03529"LEFT="180" WIDTH="356"no direct OpenGL equivalentFor more detailed information on how to use these options, see the glTexEnv() man page. LBL="" HELPID=""ID="43009"Translating texdef()ID="chap.03530"Here's an example of an IRIS GL texture definition:float texprops[] = { TX_MINFILTER, TX_POINT,
† †                    TX_MAGFILTER, TX_POINT,
† †                    TX_WRAP_S, TX_REPEAT,
† †                    TX_WRAP_T, TX_REPEAT,
† †                    TX_NULL };
texdef2d(1, 1, 6, 6, granite_texture, 7, texprops)In the above code example, texdef() specifies the TX_POINT filter as both the magnification and the minification filter, and TX_REPEAT as the wrapping behavior. It also specifies the texture image, in this case an image called granite_texture.In OpenGL, the image specification is handled by glTexImage() and property-setting is handled by glTexParameter(). So to translate to OpenGL, you'd replace a texdef() call with a call to glTexImage() and one or more calls to glTexParameter().Here's an example of one way you could translate the IRIS GL code fragment above:GLfloat nearest [] = {GL_NEAREST};
GLfloat repeat [] = {GL_REPEAT};
glTexParameterfv( GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER,
† †                 nearest);
glTexParameterfv( GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER,
† †                 nearest);
glTexParameterfv( GL_TEXTURE_1D, GL_TEXTURE_WRAP_S,
† †                 repeat);
glTexParameterfv( GL_TEXTURE_1D, GL_TEXTURE_WRAP_T,
† †                 nearest);
glTexImage1D(GL_TEXTURE_1D, 0, 1, 6, 0, GL_RGB,
† †                 GL_UNSIGNED_SHORT,granite_tex); IDREF="31508" TYPE="TABLE"Table 3-46 lists the IRIS GL texture parameters with their OpenGL equivalents. For more detailed information on OpenGL texture parameters, refer to the glTexParameter() man page.COLUMNS="2"LBL="3-46"Table 3-46 ID="31508"IRIS GL and OpenGL Texture ParametersLEFT="0" WIDTH="162"texdef(... np, ...) OptionLEFT="170" WIDTH="356"glTexParameter() paramNameLEFT="0" WIDTH="162"TX_MINFILTERID="chap.03531"LEFT="170" WIDTH="356"GL_TEXTURE_MIN_FILTERID="chap.03532"LEFT="0" WIDTH="162"TX_MAGFILTERID="chap.03533"LEFT="170" WIDTH="356"GL_TEXTURE_MAG_FILTERID="chap.03534"LEFT="0" WIDTH="162"TX_WRAP, TX_WRAP_SID="chap.03535"ID="chap.03536"LEFT="170" WIDTH="356"GL_TEXTURE_WRAP_SID="chap.03537"LEFT="0" WIDTH="162"TX_WRAP, TX_WRAP_TID="chap.03538"ID="chap.03539"LEFT="170" WIDTH="356"GL_TEXTURE_WRAP_TID="chap.03540"LEFT="0" WIDTH="162"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="170" WIDTH="356"GL_TEXTURE_BORDER_COLORID="chap.03541"IDREF="71837" TYPE="TABLE"Table 3-47 lists the possible values of the IRIS GL texture parameters along with their OpenGL equivalents. If you used special values available only on the Reality Engine, you might need to wait for Reality Engine extensions to the OpenGL before you can translate these values exactly. For more information on possible values of OpenGL texture parameters, see the glTexParameter() man page.COLUMNS="2"LBL="3-47"Table 3-47 ID="71837"Values for IRIS GL and OpenGL Texture ParametersLEFT="0" WIDTH="162"IRIS GLLEFT="170" WIDTH="356"OpenGLLEFT="0" WIDTH="162"TX_POINTID="chap.03542"LEFT="170" WIDTH="356"GL_NEARESTID="chap.03543"LEFT="0" WIDTH="162"TX_BILINEARID="chap.03544"LEFT="170" WIDTH="356"GL_LINEARID="chap.03545"LEFT="0" WIDTH="162"TX_MIPMAP_POINTID="chap.03546"LEFT="170" WIDTH="356"GL_NEAREST_MIPMAP_NEARESTID="chap.03547"LEFT="0" WIDTH="162"TX_MIPMAP_BILINEARID="chap.03548"LEFT="170" WIDTH="356"GL_LINEAR_MIPMAP_NEARESTID="chap.03549"LEFT="0" WIDTH="162"TX_MIPMAP_LINEARID="chap.03550"LEFT="170" WIDTH="356"GL_NEAREST_MIPMAP_LINEARID="chap.03551"LEFT="0" WIDTH="162"TX_TRILINEARID="chap.03552"LEFT="170" WIDTH="356"GL_LINEAR_MIPMAP_LINEARID="chap.03553"LBL="" HELPID=""ID="31165"Translating texgen()ID="chap.03554"The functionality of† †texgen() is replaced by ID="chap.03555"glTexGen() almost entirely, though you need to call glEnable() and glDisable() to turn coordinate generation on and off. IDREF="14951" TYPE="TABLE"Table 3-48
 lists the equivalents for texture coordinate names.COLUMNS="3"LBL="3-48"Table 3-48 ID="14951"Texture Coordinate NamesLEFT="0" WIDTH="110"IRIS GL Texture CoordinateLEFT="115" WIDTH="112"OpenGL Texture CoordinateLEFT="235" WIDTH="356"glEnable() ArgumentLEFT="0" WIDTH="110"TX_SID="chap.03556"LEFT="115" WIDTH="112"GL_SID="chap.03557"LEFT="235" WIDTH="356"GL_TEXTURE_GEN_SLEFT="0" WIDTH="110"TX_TID="chap.03558"LEFT="115" WIDTH="112"GL_TID="chap.03559"LEFT="235" WIDTH="356"GL_TEXTURE_GEN_TLEFT="0" WIDTH="110"TX_RID="chap.03560"LEFT="115" WIDTH="112"GL_RID="chap.03561"LEFT="235" WIDTH="356"GL_TEXTURE_GEN_RLEFT="0" WIDTH="110"TX_QID="chap.03562"LEFT="115" WIDTH="112"GL_QID="chap.03563"LEFT="235" WIDTH="356"GL_TEXTURE_GEN_QIDREF="80835" TYPE="TABLE"Table 3-49 lists texture generation mode and plane names.COLUMNS="3"LBL="3-49"Table 3-49 ID="80835"Texture Generation Modes and PlanesLEFT="0" WIDTH="99"IRIS GL Texture ModeLEFT="105" WIDTH="108"OpenGL Texture ModeLEFT="220" WIDTH="356"Corresponding Plane NameLEFT="0" WIDTH="99"TG_LINEARID="chap.03564"LEFT="105" WIDTH="108"GL_OBJECT_LINEARID="chap.03565"LEFT="220" WIDTH="356"GL_OBJECT_PLANEID="chap.03566"LEFT="0" WIDTH="99"TG_CONTOURID="chap.03567"LEFT="105" WIDTH="108"GL_EYE_LINEARID="chap.03568"LEFT="220" WIDTH="356"GL_EYE_PLANEID="chap.03569"LEFT="0" WIDTH="99"TG_SPHEREMAPID="chap.03570"LEFT="105" WIDTH="108"GL_SPHERE_MAPID="chap.03571"LEFT="220" WIDTH="356"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'With IRIS GL, you call texgen() twice: once to simultaneously set the mode and a plane equation, and once more to enable texture coordinate generation. In OpenGL, you make three calls: two to glTexGen() (once to set the mode, and again to set the plane equation), and one to† †glEnable(). For example, if you called† †texgen() like this:texgen(TX_S, TG_LINEAR, planeParams);
texgen(TX_S, TG_ON, NULL);the equivalent OpenGL code is:glTexGen(GL_S, GL_TEXTURE_GEN_MODE, modeName);
glTexGen(GL_S, GL_OBJECT_PLANE, planeParams);
glEnable(GL_TEXTURE_GEN_S);LBL="" HELPID=""Texturing in OpenGL: An ExampleHere's an example of a complete OpenGL program demonstrating texture mapping:/*  checker2.c
† †*  This program texture maps a checkerboard image onto
† †*  two rectangles.  This program repeats the texture, if
† †*  the texture coordinates fall outside 0.0 and 1.0.
† †*/
#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"
/*      Create checkerboard texture     */
#define checkImageWidth 64
#define checkImageHeight 64
GLubyte checkImage[checkImageWidth][checkImageHeight][3];

void makeCheckImage(void)
{
† †   int i, j, r, c;

† †   for (i = 0; i < checkImageWidth; i++) {
† †       for (j = 0; j < checkImageHeight; j++) {
† †           c = ((((i&0x8)==0)^((j&0x8))==0))*255;
† †           checkImage[i][j][0] = (GLubyte) c;
† †           checkImage[i][j][1] = (GLubyte) c;
† †           checkImage[i][j][2] = (GLubyte) c;
† †       }
† †   }
}

void myinit(void)
{
† †   glClearColor (0.0, 0.0, 0.0, 0.0);
† †   glEnable(GL_DEPTH_TEST);
† †   glDepthFunc(GL_LEQUAL);

† †   makeCheckImage();
† †   glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
† †   glTexImage2D(GL_TEXTURE_2D, 0, 3, checkImageWidth,
† †       checkImageHeight, 0, GL_RGB, GL_UNSIGNED_BYTE,
† †       &checkImage[0][0][0]);
† †   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
† †                   GL_REPEAT);
† †   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,
† †                   GL_REPEAT);
† †   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
† †                   GL_NEAREST);
† †   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
† †                   GL_NEAREST);
† †   glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
† †   glEnable(GL_TEXTURE_2D);
† †   glShadeModel(GL_FLAT);
}
void display(void)
{
† †   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
† †   glBegin(GL_QUADS);
† †   glTexCoord2f(0.0, 0.0); glVertex3f(-2.0, -1.0, 0.0);
† †   glTexCoord2f(0.0, 3.0); glVertex3f(-2.0, 1.0, 0.0);
† †   glTexCoord2f(3.0, 3.0); glVertex3f(0.0, 1.0, 0.0);
† †   glTexCoord2f(3.0, 0.0); glVertex3f(0.0, -1.0, 0.0);

† †   glTexCoord2f(0.0, 0.0); glVertex3f(1.0, -1.0, 0.0);
† †   glTexCoord2f(0.0, 3.0); glVertex3f(1.0, 1.0, 0.0);
† †   glTexCoord2f(3.0, 3.0); glVertex3f(2.41421, 1.0,
† †                                      -1.41421);
† †   glTexCoord2f(3.0, 0.0); glVertex3f(2.41421, -1.0,
† †                                      -1.41421);
† †   glEnd();
† †   glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
† †   glViewport(0, 0, w, h);
† †   glMatrixMode(GL_PROJECTION);
† †   glLoadIdentity();
† †   gluPerspective(60.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0,
† †                  30.0);
† †   glMatrixMode(GL_MODELVIEW);
† †   glLoadIdentity();
† †   glTranslatef(0.0, 0.0, -3.6);
}

int main(int argc, char** argv)
{
† †   auxInitDisplayMode (AUX_SINGLE | AUX_RGBA | AUX_DEPTH);
† †   auxInitPosition (0, 0, 500, 500);
† †   auxInitWindow (argv[0]);
† †   myinit();
† †   auxReshapeFunc (myReshape);
† †   auxMainLoop(display);
}LBL="" HELPID=""Porting ID="20349"Picking CallsID="chap.03572"All the IRIS GL picking calls have OpenGL equivalents, with the exception of clearhitcode(). IDREF="44504" TYPE="TABLE"Table 3-50
 lists the IRIS GL picking calls and their OpenGL counterparts.COLUMNS="3"LBL="3-50"Table 3-50 ID="44504"Calls for PickingLEFT="0" WIDTH="108"IRIS GL CallLEFT="115" WIDTH="125"OpenGL CallLEFT="245" WIDTH="356"NotesLEFT="0" WIDTH="108"clearhitcode()LEFT="115" WIDTH="125"not supportedLEFT="245" WIDTH="356"clears global variable, 
hitcodeLEFT="0" WIDTH="108"pick(),† †select()ID="chap.03573"ID="chap.03574"LEFT="115" WIDTH="125"glRenderMode(GL_SELECT)ID="chap.03575"LEFT="245" WIDTH="356"switch to 
selection/picking modeLEFT="0" WIDTH="108"endpick(),endselect()ID="chap.03576"ID="chap.03577"LEFT="115" WIDTH="125"glRenderMode(GL_RENDER)ID="chap.03578"LEFT="245" WIDTH="356"switch back to 
rendering modeLEFT="0" WIDTH="108"picksize()ID="chap.03579"LEFT="115" WIDTH="125"gluPickMatrix()ID="chap.03580"LEFT="245" WIDTH="356"LEFT="0" WIDTH="108"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="115" WIDTH="125"glSelectBuffer()ID="chap.03581"LEFT="245" WIDTH="356"set the return arrayLEFT="0" WIDTH="108"initnames()ID="chap.03582"LEFT="115" WIDTH="125"glInitNames()ID="chap.03583"LEFT="245" WIDTH="356"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="108"pushname(),popname()ID="chap.03584"ID="chap.03585"LEFT="115" WIDTH="125"glPushName(), glPopName()ID="chap.03586"ID="chap.03587"LEFT="245" WIDTH="356"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="108"loadname()ID="chap.03588"LEFT="115" WIDTH="125"glLoadName()ID="chap.03589"LEFT="245" WIDTH="356"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'For more information on picking, refer to the† †gluPickMatrix() man page and the OpenGL Programming Guide.Here's an example of an OpenGL program that demonstrates picking:#include <stdio.h>
#include <gl/gl.h>
#include <gl/device.h>

#define SELECT 1
#define RENDER 2
void drawLine(int mode)
{
† †   float vec1[3] = {30.0, 30.0, 0.0};
† †   float vec2[3] = {50.0, 60.0, 0.0};
† †   float vec3[3] = {70.0, 40.0, 0.0};

† †   if (mode == SELECT)
† †     loadname(1);
† †   else
† †     cpack (0xFFFFFF);
† †   bgnline ();
† †     v3f (vec1);
† †     v3f (vec2);
† †   endline ();    

† †   if (mode == SELECT)
† †     loadname(2);
† †   else
† †     cpack (0xFFFFFF);
† †   bgnline ();
† †     v3f (vec2);
† †     v3f (vec3);
† †   endline ();    
}

#define BUFSIZE 50

void printhits(short buffer[], long hits)
{
† †   int indx, items, h, i;
† †   char str[20];

† †   printf("%ld hit", hits);

† †   if (hits != 1)
† †     printf("s");
† †   if (hits > 0)
† †     printf(": ");
† †   indx = 0;
† †   for (h = 0; h < hits; h++) {
† †     items = buffer[indx++];
† †     printf("(");
† †     for (i = 0; i < items; i++) {
† †         if (i != 0)
† †           printf(" ");
† †         printf("%d", buffer[indx++]);
† †      }
† †     printf(") ");
† †   }
† †   printf("\n");
}

main()
{
† †   Device dev;
† †   short val;
† †   long hits;
† †   long xsize, ysize;
† †   short buffer[BUFSIZE];
† †   Boolean run;

† †   prefsize (100, 100);
† †   winopen ("pickline");
† †   RGBmode ();
† †   gconfig ();
† †   getsize(&xsize, &ysize);
† †   mmode(MVIEWING);
† †   ortho2(0.0, 100.0, 0.0, 100.0);

† †   cpack(0);
† †   clear();
† †   qdevice(LEFTMOUSE);
† †   qdevice(ESCKEY);
† †       
† †   drawLine(RENDER);
† †   run = TRUE;

† †   picksize (5,5);
† †   while (run) {
† †     dev = qread(&val);
† †     if (val == 0) {                /* on upstroke */
† †       switch (dev) {
† †       case LEFTMOUSE:
† †         pushmatrix ();
† †           pick(buffer, BUFSIZE);
† †           ortho2(0.0, 100.0, 0.0, 100.0);
† †           drawLine(SELECT);/* no actual drawing happens */
† †           hits = endpick(buffer);
† †         popmatrix ();
† †         printhits(buffer, hits);
† †         break;
† †       
† †       case ESCKEY:
† †         run = FALSE;
† †         break;
† †       }
† †   }
† †   }
† †   gexit();
† †   return 0;
}Here's how you could handle picking in OpenGL. This example uses auxiliary library calls for windowing and event handling.
/*
† †*  pickline.c
† †*  Picking is demonstrated here.  Press the left mouse button
† †*  to enter picking mode.  You get two hits if you press the
† †*  mouse, while the cursor is where the lines intersect.
† †*/
#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"

void drawLine(GLenum mode)
{
† †   if (mode == GL_SELECT)
† †     glLoadName (1);
† †   glBegin (GL_LINES);
† †     glColor3f (1.0, 1.0, 1.0);
† †     glVertex3f (30.0, 30.0, 0.0);
† †     glVertex3f (50.0, 60.0, 0.0);
† †   glEnd (); 

† †   if (mode == GL_SELECT)
† †     glLoadName (2);
† †   glBegin (GL_LINES);
† †     glColor3f (1.0, 1.0, 1.0);
† †     glVertex3f (50.0, 60.0, 0.0);
† †     glVertex3f (70.0, 40.0, 0.0);
† †   glEnd (); 
}

void printHits (GLint hits, GLuint buffer[])
{
† †   unsigned int i, j, names, ii, jj;
† †   unsigned int *ptr;

† †   printf ("hits = %d\n", hits);
† †   ptr = (unsigned int *) buffer;
† †   for (i = 0; i < hits; i++) {    /*  for each hit  */
† †     names = *ptr;
† †     printf (" number of names for this hit = %d\n", names);
† †     ptr++;
† †     printf ("  z1 is %u;", *ptr); ptr++;
† †     printf (" z2 is %u\n", *ptr); ptr++;
† †     printf ("   names are ");
† †     for (j = 0; j < names; j++) {    /*  for each name */
† †       printf ("%d ", *ptr);
† †       ptr++;
† †     }
† †     printf ("\n");
† †   }
}

#define BUFSIZE 512

void pickLine(AUX_EVENTREC *event)
{
† †   GLuint selectBuf[BUFSIZE];
† †   GLint hits;
† †   GLint viewport[4];
† †   int x, y;

† †   x = event->data[AUX_MOUSEX];
† †   y = event->data[AUX_MOUSEY];
† †   glGetIntegerv (GL_VIEWPORT, viewport);

† †   glSelectBuffer (BUFSIZE, selectBuf);
† †   (void) glRenderMode (GL_SELECT);

† †   glInitNames();
† †   glPushName(-1);

† †   glPushMatrix ();
† †   glMatrixMode (GL_PROJECTION);
† †   glLoadIdentity ();
† †   gluPickMatrix (x, 100-y, 5, 5, viewport);
† †   gluOrtho2D (0.0, 100.0, 0.0, 100.0);
† †   drawLine (GL_SELECT);
† †   glPopMatrix ();
† †   glFlush ();

† †   hits = glRenderMode (GL_RENDER);
† †   printHits (hits, selectBuf);
} 

void display(void)
{
† †   glMatrixMode (GL_PROJECTION);
† †   glLoadIdentity ();
† †   gluOrtho2D (0.0, 100.0, 0.0, 100.0);

† †   glClearColor (0.0, 0.0, 0.0, 0.0);
† †   glClear(GL_COLOR_BUFFER_BIT);
† †   drawLine (GL_RENDER);
† †   glEnd ();
† †   glFlush();
}

void main(int argc, char** argv)
{
† †   auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);
† †   auxInitPosition (0, 0, 100, 100);
† †   auxInitWindow (argv[0]);
† †   auxMouseFunc (AUX_LEFTBUTTON, AUX_MOUSEDOWN, pickLine);
† †   auxMainLoop(display);
}LBL="" HELPID=""Porting ID="43211"Feedback CallsFeedback under IRIS GL differed from machine to machine. OpenGL standardizes feedback, so you can now rely on consistent feedback from machine to machine, implementation to implementation.COLUMNS="3"LBL="3-51"Table 3-51 ID="91748"Feedback CallsLEFT="0" WIDTH="63"IRIS GL CallLEFT="70" WIDTH="144"OpenGL CallLEFT="220" WIDTH="356"NotesLEFT="0" WIDTH="63"feedback()ID="chap.03590"LEFT="70" WIDTH="144"glRenderMode(GL_FEEDBACK)ID="chap.03591"LEFT="220" WIDTH="356"switch to feedback modeLEFT="0" WIDTH="63"endfeedback()ID="chap.03592"LEFT="70" WIDTH="144"glRenderMode(GL_RENDER)LEFT="220" WIDTH="356"switch back to rendering 
modeLEFT="0" WIDTH="63"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="70" WIDTH="144"glFeedbackBuffer()ID="chap.03593"LEFT="220" WIDTH="356"name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'LEFT="0" WIDTH="63"passthrough()ID="chap.03594"LEFT="70" WIDTH="144"glPassThrough()ID="chap.03595"LEFT="220" WIDTH="356"place a token marker in the 
feedback bufferIDREF="91748" TYPE="TABLE"Table 3-51OpenGL Programming GuideHere's an example demonstrating OpenGL feedback:/*
† †* feedback.c
† †* This program demonstrates use of OpenGL feedback. First,
† †* a lighting environment is set up and a few lines are
† †* drawn. Then feedback mode is entered, and the same lines
† †* are drawn. The results in the feedback buffer are printed.
† †*/
#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"

/*    Initialize lighting.
† †*/
void myinit(void)
{
† †glEnable(GL_LIGHTING);
† †glEnable(GL_LIGHT0);
}

/*    Draw a few lines and two points, one of which will 
† †*    be clipped. If in feedback mode, a passthrough token 
† †*    is issued between the primitives.
† †*/
void drawGeometry (long mode)
{
† †glBegin (GL_LINE_STRIP);
† †glNormal3f (0.0, 0.0, 1.0);
† †glVertex3f (30.0, 30.0, 0.0);
† †glVertex3f (50.0, 60.0, 0.0);
† †glVertex3f (70.0, 40.0, 0.0);
† †glEnd ();
† †if (mode == GL_FEEDBACK)
† †   glPassThrough (1.0);
† †glBegin (GL_POINTS);
† †glVertex3f (-100.0, -100.0, -100.0);   /* will be clipped */
† †glEnd ();
† †if (mode == GL_FEEDBACK)
† †   glPassThrough (2.0);
† †glBegin (GL_POINTS);
† †glNormal3f (0.0, 0.0, 1.0);
† †glVertex3f (50.0, 50.0, 0.0);
† †glEnd ();
}

void print3DcolorVertex(GLint size, GLint *count, GLfloat *buffer)
{
† †int i;

† †printf (" ");
† †for (i = 0; i < 7; i++) {
† †   printf ("%4.2f ", buffer[size-(*count)]);
† †   *count = *count - 1;
† †}
† †printf ("\n");
}

void printBuffer(GLint size, GLfloat *buffer)
{
† †GLint count;
† †GLfloat token;
† †count = size;
† †while (count) {
† †   token = buffer[size-count]; count--;
† †   if (token == GL_PASS_THROUGH_TOKEN) {
† †    printf ("GL_PASS_THROUGH_TOKEN\n");
† †    printf (" %4.2f\n", buffer[size-count]);
† †    count--;
† †   }
† †   else if (token == GL_POINT_TOKEN) {
† †    printf ("GL_POINT_TOKEN\n");
† †    print3DcolorVertex (size, &count, buffer);
† †   }
† †   else if (token == GL_LINE_TOKEN) {
† †    printf ("GL_LINE_TOKEN\n");
† †    print3DcolorVertex (size, &count, buffer);
† †    print3DcolorVertex (size, &count, buffer);
† †   }
† †   else if (token == GL_LINE_RESET_TOKEN) {
† †    printf ("GL_LINE_RESET_TOKEN\n");
† †    print3DcolorVertex (size, &count, buffer);
† †    print3DcolorVertex (size, &count, buffer);
† †   }
† †}
}

void display(void)
{
† †GLfloat feedBuffer[1024];
† †GLint size;

† †glMatrixMode (GL_PROJECTION);
† †glLoadIdentity ();
† †glOrtho (0.0, 100.0, 0.0, 100.0, 0.0, 1.0);

† †glClearColor (0.0, 0.0, 0.0, 0.0);
† †glClear(GL_COLOR_BUFFER_BIT);
† †drawGeometry (GL_RENDER);

† †glFeedbackBuffer (1024, GL_3D_COLOR, feedBuffer);
† †(void) glRenderMode (GL_FEEDBACK);
† †drawGeometry (GL_FEEDBACK);

† †size = glRenderMode (GL_RENDER);
† †printBuffer (size, feedBuffer);
}

void main(int argc, char** argv)
{
† †auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);
† †auxInitPosition (0, 0, 100, 100);
† †auxInitWindow (argv[0]);
† †myinit ();
† †auxMainLoop(display);
}LBL="4"ID="45274"Using the Auxiliary Library to Replace Windowing and Event Handling CallsID="chap.041"The auxiliary library provides several simple routines for windowing, event handling, loading the color map, and drawing several three-dimensional objects.If your program uses only simple window and event handling calls, you can probably replace them with auxiliary library calls, rather than converting immediately to a mixed model program using Xlib or X. Remember that the auxiliary library is limited in functionalityname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'more complicated applications will almost certainly require you to switch to mixed model instead of the auxiliary library. For more information on the auxiliary library or on the auxiliary library calls, refer to the OpenGL Programming Guide. (At the time of this writing, man pages are not available for auxiliary library routines.)When using the auxiliary library, remember to include the auxiliary library header file:ID="chap.042"#include "aux.h"LBL="" HELPID=""Running a Program That Uses the Auxiliary LibraryID="chap.043"To run a program using the auxiliary library, you need to call ID="chap.044"auxMainLoop() from within your main() routine, passing it the name of the routine that redraws the objects in your scene. The example programs in IDREF="26599" TYPE="TITLE""Windowing with the Auxiliary Library: Example Program"
 and IDREF="19802" TYPE="TITLE""Input Handling with the Auxiliary Library: Example Program"
 demonstrate how to do this.auxMainLoop() never exits, so calls that are placed after auxMainLoop() in your program are never executed.† †LBL="" HELPID=""ID="88614"WindowingID="chap.045"The auxiliary library provides three windowing routines:† †auxInitWindow(), auxInitDisplayMode(), and auxInitPosition(). With these routines, you can open and initialize a window. LBL="" HELPID=""ID="45155"Replacing prefposition() with auxInitPosition()You can replace ID="chap.046"prefposition() with auxInitPosition()ID="chap.047". The arguments don't correspond exactly, however. With prefposition() you specified the coordinates of opposite corners of the window. With auxInitPosition() you specify the screen coordinates (in pixels) of the upper left corner of the window, as well as the width and height of the window. The C specification for† †auxInitPosition() is:void auxInitPosition( GLint x, GLint y, GLsizei width,
† †                     GLsizei height );The default size for auxInitPosition() is a 100 x 100 pixel square. The default window position is at the upper left corner of the screen.LBL="" HELPID=""ID="64084"Porting Display Mode Initialization Calls with auxInitDisplayMode()ID="chap.048"ID="chap.049"ID="chap.0410"You can set the display mode of a window by selecting arguments to auxInitDisplayMode(). The C specification for auxInitDisplayMode() is:void auxInitDisplayMode(GLbitfield mask)The mask argument is a bitwise OR-ed combination of:AUX_RGBA or AUX_INDEXID="chap.0411"ID="chap.0412"AUX_SINGLE or AUX_DOUBLEID="chap.0413"ID="chap.0414"and any of these buffer enabling flags:AUX_DEPTH, AUX_STENCIL, and AUX_ACCUMID="chap.0415"ID="chap.0416"ID="chap.0417"So, for example, for a double-buffered, RGBA-mode window with a depth buffer, you would use:auxInitDisplayMode( AUX_DOUBLE | AUX_RGBA | AUX_DEPTH );The default setting for† †auxInitDisplayMode() is a single-buffered, color index window.IDREF="23684" TYPE="TABLE"Table 4-1 IRIS GL lists display mode calls that can be either fully or partially replaced by auxInitDisplayMode(). COLUMNS="3"LBL="4-1"Table 4-1 ID="23684"auxInitDisplayMode() Arguments and IRIS GL Command EquivalentsLEFT="0" WIDTH="108"IRIS GL CallLEFT="115" WIDTH="108"Corresponding 
auxInitDisplayMode() 
ArgumentLEFT="230" WIDTH="356"Specifies:LEFT="0" WIDTH="108"acsize()ID="chap.0418"LEFT="115" WIDTH="108"AUX_ACCUMLEFT="230" WIDTH="356"accumulation-buffer modeLEFT="0" WIDTH="108"cmode()ID="chap.0419"LEFT="115" WIDTH="108"AUX_INDEXLEFT="230" WIDTH="356"color-map modeLEFT="0" WIDTH="108"doublebuffer()ID="chap.0420"LEFT="115" WIDTH="108"AUX_DOUBLELEFT="230" WIDTH="356"double-buffer modeLEFT="0" WIDTH="108"RGBmode()ID="chap.0421"LEFT="115" WIDTH="108"AUX_RGBALEFT="230" WIDTH="356"RGBA modeLEFT="0" WIDTH="108"singlebuffer()ID="chap.0422"LEFT="115" WIDTH="108"AUX_SINGLELEFT="230" WIDTH="356"single-buffer modeLEFT="0" WIDTH="108"stensize()ID="chap.0423"LEFT="115" WIDTH="108"IDREF="chap.04TF0a"aAUX_STENCILLEFT="230" WIDTH="356"stencil-buffer modeLEFT="0" WIDTH="108"zbuffer(TRUE)ID="chap.0424"LEFT="115" WIDTH="108"AUX_DEPTHLEFT="230" WIDTH="356"z-buffer modeLBL="a" ID="chap.04TF0a"note that stencil() does more than specify stencil-buffer mode,name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'use glStencilFunc() to re
place the rest of the stencil() functionalityThe auxiliary library doesn't providename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'and you won't needname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'an equivalent for gconfig(ID="chap.0425").† †auxInitDisplayMode() must be called before auxInitWindow().LBL="" HELPID=""ID="49158"Replacing winopen() with auxInitWindow()ID="chap.0426"Use† †auxInitWindow()ID="chap.0427" to replace ID="chap.0428"winopen(). The C specification for auxInitWindow() is:void auxInitWindow (GLbyte *titleString);The specified string appears in the title bar of the window, and the escape key is bound to an exiting function that kills the window and exits the program. The default color for the background window is set to black for an RGBA window and to color index 0 for a color-index window.ID="chap.0429"ID="chap.0430"Remember that auxInitDisplayMode() must be called before auxInitWindow().† †LBL="" HELPID=""ID="26599"Windowing with the Auxiliary Library: Example ProgramHere's a simple program that uses the auxiliary library to initialize and open a window:/*
† †*  simple.c
† †*  This program draws a white rectangle on a black background.
† †*/
#include <GL/gl.h>
#include "aux.h"

int main(int argc, char** argv)
{
† †       auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);
† †       auxInitPosition (0, 0, 500, 500);
† †       auxInitWindow (argv[0]);

† †       glClearColor (0.0, 0.0, 0.0, 0.0);
† †       glClear(GL_COLOR_BUFFER_BIT);
† †       glColor3f(1.0, 1.0, 1.0);
† †       glMatrixMode (GL_PROJECTION);
† †       glLoadIdentity ();
† †       glOrtho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0);
† †       glBegin(GL_POLYGON);
† †               glVertex2f(-0.5, -0.5);
† †               glVertex2f(-0.5, 0.5);
† †               glVertex2f(0.5, 0.5);
† †               glVertex2f(0.5, -0.5);
† †       glEnd();
† †       glFlush();
† †       sleep (10);
}LBL="" HELPID=""ID="43633"Event Handling: Replacing qdevice(), qtest(), and qread()† †ID="chap.0431"If you used the queuing method of event handling, you can use the auxiliary library to replace simple IRIS GL event handling calls. If you used polling calls, such as ID="chap.0432"getvaluator() and ID="chap.0433"getbutton(), you can't exactly replace that functionality with the auxiliary library. And, in general, for anything particularly complicated, you should probably invest the extra effort and translate your program to mixed model.The auxiliary library's method of event handling is somewhat different from what you're used to in IRIS GL. With the auxiliary library, you structure your application's event handling to use callback functions. In general, you first open a window and register callback routines for specific events. Then you create a main loop without an exit. In the main loop, if an event occurs, its registered callback functions are executed. Upon completion of the callback functions, flow of control is returned to the main loop.After a window is created, but before you enter the main loop, register callback functions using these three auxiliary library event handling routines: ID="chap.0434"auxReshapeFunc(),auxKeyFunc(), and auxMouseFunc().Each of these three routines takes over some part of what you used to do with qdevice(), qtest(), and qread(), so read each section for details.LBL="" HELPID=""ID="91085"Handling Redraw EventsThis section explains how to use† †auxReshapeFunc()ID="chap.0435"ID="chap.0436" to specify a function to be called whenever the window is resized, moved, or exposed. In IRIS GL, you might have done something like this:gid = winopen("MyProgram"); /*initialization*/
qenter(REDRAW,gid); 
dev = qread (&value);
if ( dev == REDRAW ) {
† †      reshapeviewport();
† †      MySceneRedraw();
}Using the auxiliary library, you specify a function that will be called automatically whenever you get a redraw event. Here's an example of a redraw function:void myReshape(GLsizei w, GLsizei h)
{
† †   glViewport(0, 0, w, h);
† †   glMatrixMode(GL_PROJECTION);
† †   glLoadIdentity();
† †   gluPerspective (45.0, (GLfloat) w/(GLfloat) h, 3.0, 5.0);

† †   glMatrixMode(GL_MODELVIEW);
† †   glLoadIdentity ();
† †   glTranslatef (0.0, 0.0, -4.0);/*move object into view*/}Once you've written your redraw function, like the myReshape() in the example above, you have auxReshapeFunc() call it from the main loop. In this example, the main loop might look something like this:int main(int argc, char** argv)
{
† †   auxInitDisplayMode (AUX_SINGLE | AUX_RGBA | AUX_DEPTH);
† †   auxInitPosition (0, 0, 400, 400);
† †   auxInitWindow (argv[0]);
† †   myinit();
† †   auxReshapeFunc (myReshape);
† †   auxMainLoop(display);
}Here's the C specification for auxReshapeFunc():void auxReshapeFunc( void (*function) (GLsizei, GLsizei));The argument function is a pointer to a function that expects two arguments: the new width and height of the window. Typically, the function calls glViewport()ID="chap.0437" so that the display is clipped to the new size, and it redefines the projection matrix so that the aspect ratio of the projected image matches the viewport, avoiding aspect ratio distortion. If you don't call ID="chap.0438"auxReshapeFunc(), a default reshape function is called, which assumes a two-dimensional orthographic projection. With the auxiliary library, the window is automatically redrawn after every reshaping event.LBL="" HELPID=""Handling Keyboard InputID="chap.0439"With IRIS GL, you might do something like this:qdevice (AKEY); /*initialization*/ 
dev = qread (&value);
if ((device == AKEY) && (val == 1))
† †   /* toggle autopilot mode */
† †   autopilot = ! autopilot;In the auxiliary library, you use auxKeyFunc()ID="chap.0440" to specify a function that will be called automatically whenever the A key is pressed. So, for this example, before entering the main loop of your program, you could define a function called MyAutopilot() to toggle the autopilot mode for you, then in the main loop of your program, you could call:auxKeyFunc(AUX_a, MyAutopilot);Then the auxiliary library will call MyAutopilot whenever the A key is pressed. The C specification for auxKeyFunc() is:void auxKeyFunc(GLint key, void (*function) (void) );Specifies the function that is called when the key indicated by key is pressed. Use one of the auxiliary library constants for key:AUX_A through AUX_Z for the upper case alphabetID="chap.0441"ID="chap.0442"AUX_a through AUX_z for the lower case alphabetID="chap.0443"ID="chap.0444"AUX_0 through AUX_9 for the digitsID="chap.0445"ID="chap.0446"AUX_LEFT, AUX_RIGHT, AUX_UP, and AUX_DOWN for the arrow keysID="chap.0447"ID="chap.0448"ID="chap.0449"ID="chap.0450"AUX_ESCAPE, AUX_SPACE, and AUX_RETURN for the escape key, the spacebar, and the return key, respectivelyID="chap.0451"ID="chap.0452"ID="chap.0453"With the auxiliary library, the window is automatically redrawn after every processed key event, although in a more sophisticated application, you might want to wait for several events to be completed before drawing. LBL="" HELPID=""Handling Mouse EventsID="chap.0454"The C specification for auxMouseFunc()ID="chap.0455" is:void auxMouseFunc(GLint button, GLint mode,† †                 void(*function)(AUX_EVENTREC *) );auxMouseFunc() specifies the function that is called when the mouse button indicated by button enters the mode defined by mode. Here are the possible button arguments:AUX_LEFTBUTTONID="chap.0456"AUX_RIGHTBUTTONID="chap.0457"AUX_MIDDLEBUTTONID="chap.0458"Here are the possible mode arguments:AUX_MOUSEDOWNID="chap.0459"AUX_MOUSEUPID="chap.0460"AUX_MOUSELOCID="chap.0461"The function argument must take one argument that is a pointer to a structure of type AUX_EVENTREC. The ID="chap.0462"ID="chap.0463"auxMouseFunc() routine allocates memory for the structure. IDREF="19802" TYPE="TITLE""Input Handling with the Auxiliary Library: Example Program"
 contains a complete program using auxMouseFunc(). With IRIS GL, you might do something like this:qdevice (LEFTMOUSE); /*initialization*/
tie(LEFTMOUSE, MOUSEX, MOUSEY);
...
dev = qread (&value);

if (dev == LEFTMOUSE)
† †   {
† †       if (value)
† †       {
† †           qread(&x);
† †           qread(&y);
† †           qdevice(MOUSEX);
† †           qdevice(MOUSEY);
† †       }
† †       elseIn the auxiliary library, you use† †auxMouseFunc() to specify functions that will be called automatically whenever the left mouse button is pressed or released. To replace the IRIS GL code above, you might define a function like this:void MyFunction (AUX_EVENTREC *event ) {
† †   GLint x, y;
† †   x = event -> data[AUX_MOUSEX];
† †   y = event -> data[AUX_MOUSEY];
† †   ...
}Then in your main loop you would call† †auxMouseFunc() like this:auxMouseFunc(AUX_LEFTMOUSE, AUX_MOUSEDOWN, MyFunction);For more information on auxMouseFunc(), see the OpenGL Programming Guide. You might also want to look at the aux.h include file for more information on defined constants, structure types, and so on. LBL="" HELPID=""ID="19802"Input Handling with the Auxiliary Library: Example ProgramID="chap.0464"This program uses the auxiliary library for simple windowing and event handling. For another program example using the auxiliary library, see IDREF="13844" TYPE="TITLE"Appendix D, "Example OpenGL Program with the Auxiliary Library."/*  movelight.c
† †*  This program demonstrates when to issue lighting and
† †*  transformation commands to render a model with a light
† †*  that is moved by a modeling transformation (rotate or
† †*  translate).  The light position is reset after the modeling
† †*  transformation is called.  The eye position does not
† †*  change.
† †
† †*  A sphere is drawn using a gray material characteristic.
† †*  A single light source illuminates the object.
† †*
† †*  Interaction:  pressing the left or middle mouse button
† †*  alters the modeling transformation (x rotation) by 30
† †*  degrees.
† †*  The scene is then redrawn with the light in a new position.
† †*/

#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"

static int spin = 0;

void movelight (AUX_EVENTREC *event)
{
† †   spin = (spin + 30) % 360;
}

void myinit (void)
{
† †   glEnable(GL_LIGHTING);
† †   glEnable(GL_LIGHT0);
† †   glDepthFunc(GL_LEQUAL);
† †   glEnable(GL_DEPTH_TEST);
}

/*  Here is where the light position is reset
† †*  after the modeling transformation (glRotated) 
† †*  is called. This places the light at a new position
† †*  in world coordinates. The cube represents the 
† †*  position of the light.
† †*/
void display(void)
{
† †   GLfloat position[] = { 0.0, 0.0, 1.5, 1.0 };

† †   glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
† †   glPushMatrix ();
† †   glTranslatef (0.0, 0.0, -5.0);

† †   glPushMatrix ();
† †   glRotated ((GLdouble) spin, 1.0, 0.0, 0.0);
† †   glLightfv (GL_LIGHT0, GL_POSITION, position);

† †   glTranslated (0.0, 0.0, 1.5);
† †   glDisable (GL_LIGHTING);
† †   glColor3f (0.0, 1.0, 1.0);
† †   auxWireCube (0.1);
† †   glEnable (GL_LIGHTING);
† †   glPopMatrix ();

† †   auxSolidTorus (0.275, 0.85);
† †   glPopMatrix ();
† †   glFlush ();
}

void myReshape(GLsizei w, GLsizei h)
{
† †   glViewport(0, 0, w, h);
† †   glMatrixMode(GL_PROJECTION);
† †   glLoadIdentity();
† †   gluPerspective(40.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
† †   glMatrixMode(GL_MODELVIEW);
}
/*  Main Loop
† †*  Open window with initial window size, title bar,
† †*  RGBA display mode, and handle input events.
† †*/
int main(int argc, char** argv)
{
† †   auxInitDisplayMode (AUX_SINGLE | AUX_RGBA | AUX_DEPTH);
† †   auxInitPosition (0, 0, 500, 500);
† †   auxInitWindow (argv[0]);
† †   myinit();
† †   auxMouseFunc (AUX_LEFTBUTTON, AUX_MOUSEDOWN, movelight);
† †   auxReshapeFunc (myReshape);
† †   auxMainLoop(display);
}LBL="" HELPID=""Managing Background EventsID="chap.0465"You can specify a function to be executed if no other events are pending with auxIdleFunc()ID="chap.0466". Here's the C specification:void auxIdleFunc(void (*func(void));This routine takes a pointer to a function as its only argument. Pass in zero to disable the execution of the function.LBL="" HELPID=""ID="54935"Using Color-Index ModeID="chap.0467"ID="chap.0468"Loading a color map depends completely on the windowing system, so OpenGL doesn't provide any routines for this task. You can use the auxiliary library routine,† †auxSetOneColor()ID="chap.0469", instead of ID="chap.0470"mapcolor(). Like mapcolor(), auxSetOneColor() takes four arguments: an index into the color map, and red, green, and blue values for intensity values of each of those colors. The main thing to remember when you're switching from mapcolor() to auxSetOneColor() is that the red, green, and blue values are now normalized to lie in the range [0.0, 1.0]. So, for color values, mapcolor() took (short) integers between 0 and 255 and auxSetOneColor() takes floats between 0.0 and 1.0. Here's an example of how you could use auxSetOneColor() to load values into the colormap:† †   for (i = 0; i < 32; i++) {
† †       auxSetOneColor (16 + i, 1.0 * (i/32.0), 
† †                       0.0, 1.0 *(i/32.0));
† †       auxSetOneColor (48 + i, 1.0, 1.0 * (i/32.0), 1.0);
† †   }For a more complete example, see the program in IDREF="19802" TYPE="TITLE""Input Handling with the Auxiliary Library: Example Program"
† †Here's the C specification for auxSetOneColor():auxSetOneColor (GLint index, GLfloat red, GLfloat green,
† †               GLfloat blue );As explained in IDREF="64084" TYPE="TITLE""Porting Display Mode Initialization Calls with auxInitDisplayMode()"
 you replace the initialization calls to ID="chap.0471"cmode() and ID="chap.0472"gconfig() by calling auxInitDisplayMode() with the argument AUX_INDEX.† †LBL="" HELPID=""Other Auxiliary Library RoutinesID="chap.0473"ID="chap.0474"The auxiliary library provides routines for drawing 3-D objects, such as cylinders, spheres, cubes, teapots, and more. The OpenGL Programming Guide discusses these routines in detail.LBL="5"ID="37274"ID="61628"OpenGL/X Mixed-Model ProgrammingID="chap.051"ID="chap.052"ID="chap.053"This chapter provides some preliminary information about OpenGL programming in the X environment. This chapter focuses specifically on information relevant to translating IRIS GL programs into mixed-model OpenGL/X programsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'it does not provide a tutorial on Xt and IRIS IM. For more information on the relevant features of Xt and IRIS IM, consult the OSF/Motif series, and Digital's X Window System Toolkit: The Complete Programmer's Guide and Specification, or O'Reilly's Vols. 4 & 5 on X Toolkit Intrinsics.LBL="" HELPID=""What Is a Mixed-Model Program?ID="chap.054"ID="chap.055"ID="chap.056"ID="chap.057"A mixed-model program, in the context of this manual, is an X program that creates one or more subwindows that use OpenGL for rendering. A mixed-model program allows full access to the capabilities of X by completely removing OpenGL from any feature governed by the X server, giving the programmer direct control of all the areas governed by the X server. In a mixed-model program, the X part of the code manages all of the event handling, window control, and menus. You also use X to handle color maps and fonts.ID="chap.058"ID="chap.059"You can't create mixed-model programs that go only halfway. Your mixed-model program must use X for all window-system-related services. † †You can find examples of many mixed-model programsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'both OpenGL and IRIS GLname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in the 4Dgifts directories. If you have trouble finding the relevant directories, refer to the README file in /usr/people/4Dgifts. This file explains the contents and organization of the 4Dgifts directories. With IRIS GL, instead of creating a mixed-model program, you could use IRIS GL event and window management routines, such as† †winopen()ID="chap.0510" or ID="chap.0511"qread()name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'these routines would access the X Window System for you. Silicon Graphics does provide a very limited Auxiliary Library, which provides some windowing and event handling routines, but if these are not sufficient for your purposes, you'll need to translate your IRIS GL code to a mixed-model program.LBL="" HELPID=""Two Choices For Mixed-Model ProgrammingID="chap.0512"When writing a mixed-model program, you have two choices: you can use the Xt toolkit and a widget set, such as IRIS IM, or you can write your program in Xlib and GL using special GLX commands. The first method, using Xt and a widget set, is much easier and is more commonly used by mixed-model developers. This is the method recommended by Silicon Graphicsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'particularly for programmers with little or no previous experience with X.Whichever method you choose, you'll find more information on programming with Xlib and Xt in the X Window System series from O'Reilly & Associates. The material in this chapter is intended as a supplement to the O'Reilly guides, detailing X development features available on Silicon Graphics workstations. LBL="" HELPID=""Using Xt and a Widget SetID="chap.0513"Silicon Graphics provides a widget library that simplifies mixed-model programming with Xt. IDREF="47893" TYPE="TITLE""Porting to Mixed-Model Using Xt and a Widget Set"
 explains how to convert your IRIS GL program to an OpenGL/X mixed-model program using Xt, the IRIS Widget Library, and the GL widget, GLwDrawingArea (Silicon Graphics also provides an IRIS IM version of GLwDrawingArea, called GLwMDrawingArea). Sample programs demonstrate these concepts.ID="chap.0514"ID="chap.0515"LBL="" HELPID=""Using XlibIf you prefer to create a mixed-model program in Xlib, without using Xt, refer to the recommended references on X programming, and use the GLX routines described in the ID="chap.0516"ID="chap.0517"OpenGL Reference Manual (start with the glXIntro man page). IDREF="34451" TYPE="TITLE""Mixed-Model Programming Using Xlib and OpenGL GLX Commands"
 provides more information on this mixed-model programming method and contains some code examples. Several complete programs using this method are included in IDREF="77823" TYPE="TITLE"Appendix F, "Example Mixed-Model Programs With Xlib,"
 along with IRIS GL versions of the same programs.LBL="" HELPID=""Some General Hints on Mixed-Model Programming This section contains a few brief hints for OpenGL/X mixed-model programmers. This list is not comprehensivename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'it just describes a few important things to watch out for.LBL="" HELPID=""You Can't Change Window Depth and Display ModeID="chap.0518"In mixed-model programs, window depth and display mode are window attributes that are defined when the window is created, and they cannot be changed. To change these attributes, you must create a new window. If you need multiple display modes in your application, you can create multiple windows, then map and unmap them, or raise one above the others.LBL="" HELPID=""ID="22249"Installing Color MapsID="chap.0519"ID="chap.0520"ID="chap.0521"ID="chap.0522"It's a good idea to call ID="chap.0523"XSetWMColormapWindows() in your mixed-model programname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'this ensures that its color maps are installed. If you don't call XSetWMColormapWindows(), the default X color map is used. Even if your program uses RGB mode, you should still call XSetWMColormapWindows() because some hardware (such as IRIS Indigo) simulates RGB with a color map.ID="chap.0524"LBL="" HELPID=""ID="89603"Fonts and StringsID="chap.0525"ID="chap.0526"The OpenGL contains no equivalents for the IRIS GL text-handling calls and Font Manager calls. To obtain full text- and font-handling facilities, use the OpenGL/X call ID="chap.0527"glXUseXFont() with display lists to get some text-display capabilities. This section gives you an example.To use display lists to do X bitmap fonts, your code should do the following:ID="chap.0528"ID="chap.0529"Use X calls to load information about the font you want to use.Using glXUseXFont(), generate a series of display lists, one for each character in the font.Put the bitmap for one character into each display list, in the order the characters appear in the font.To print out a string, use† †glListBase()ID="chap.0530" to set the display list base to the base for your character series. Then pass the string as an argument to ID="chap.0531"glCallLists().The following code fragment gives you an example, using Helvetica Medium to print out the string "The quick brown fox jumps over a lazy dog." It also prints out the entire character set, from ASCII 32 to 127.#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glx.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include "aux.h"

GLuint base;

void makeRasterFont(void)
{
† †   XFontStruct *fontInfo;
† †   Font id;
† †   unsigned int first, last;
† †   Display *xdisplay;

† †   xdisplay = auxIdentifyXDisplay ();
† †   fontInfo = XLoadQueryFont(xdisplay, 
† †            "-adobe-helvetica-medium-r-normal--17-120-100-100-p-88-iso8859-1");
† †   if (fontInfo == NULL) {
† †       printf ("no font found\n");
† †       exit (0);
† †   }

† †   id = fontInfo->fid;
† †   first = fontInfo->min_char_or_byte2;
† †   last = fontInfo->max_char_or_byte2;

† †   base = glGenLists(last+1);
† †   if (base == 0) {
† †       printf ("out of display lists\n");
† †   exit (0);
† †   }
† †   glXUseXFont(id, first, last-first+1, base+first);
}

void printString(char *s)
{
† †   glPushAttrib (GL_LIST_BIT);
† †   glListBase(base);
† †   glCallLists(strlen(s), GL_UNSIGNED_BYTE, 
† †               (unsigned char *)s);
† †   glPopAttrib ();
}

void display(void)
{
† †   GLfloat white[3] = { 1.0, 1.0, 1.0 };
† †   long i, j;
† †   char teststring[33];

† †   glClear(GL_COLOR_BUFFER_BIT);
† †   glColor3fv(white);
† †   for (i = 32; i < 127; i += 32) {
† †       glRasterPos2i(20, 200 - 18*i/32);
† †       for (j = 0; j < 32; j++)
† †           teststring[j] = i+j;
† †       teststring[32] = 0;
† †       printString(teststring);
† †   }
† †   glRasterPos2i(20, 100);
† †   printString("The quick brown fox jumps");
† †   glRasterPos2i(20, 82);
† †   printString("over a lazy dog.");
† †   glFlush ();
}LBL="" HELPID=""ID="47893"Porting to Mixed-Model Using Xt and a Widget SetID="chap.0532"The addition of direct control over X features makes mixed-model programs more complex than pure GL programs. In general, you can bypass many of the complexities of X and of mixed-model programming by using the Xt toolkit and a widget set such as IRIS IM. When mixing the GL with Xt, IRIS IM, or Athena widgets, you can use the Silicon Graphics mixed-model GLwDrawingArea widget, which simplifies mixed-model programming with IRIS IM or any other widget set. The GLwDrawingArea widget is also compatible with User Interface Language (UIL). This section explains how to use the GLwMDrawingArea widget for embedding GL in an Xt or IRIS IM program. ID="chap.0533"ID="chap.0534"ID="chap.0535"LBL="" HELPID=""What You Need to Know About Xt and IRIS IMID="chap.0536"ID="chap.0537"ID="chap.0538"ID="chap.0539"The examples shown in this chapter use Xt and IRIS IM. Although knowledge of Xt and IRIS IM is not required to read this chapter, understanding the details of the examples does require some Xt and IRIS IM knowledge. This chapter points out areas of the Xt and IRIS IM toolkits that are of special interest to mixed-model programmersname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'it does not provide a tutorial on Xt and IRIS IM. For more information on the relevant features of Xt and IRIS IM, consult the OSF/Motif series, and Digital's X Window System Toolkit: The Complete Programmer's Guide and Specification, or O'Reilly's Vols. 4 & 5 on the X Toolkit Intrinsics.LBL="" HELPID=""What is Xt?Xt, also known as the X Toolkit Intrinsics, is a C library that provides routines for creating and using user interface componentsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'widgets. It's much easier to convert your IRIS GL program to mixed-model using Xt than it is to use the low-level programming library Xlib.ID="chap.0540"Since Xt doesn't dictate the "look and feel" of the GUI, you must use it in conjunction with a widget set (a library of pre-built widgets), such as the Athena widget set or IRIS IM.ID="chap.0541"LBL="" HELPID=""What Is IRIS IM?ID="chap.0542"IRIS IM is Silicon Graphics' port of OSF/Motif. Motif is an extensible widget set of user interface objects, such as buttons, scroll bars, menu systems, and dialog boxes. These widgets are accessible via a library of C routines. These widgets are supported by the Xt. Ultimately, the X Window System is the foundation for both the Motif and Athena widget sets.Motif is also a style guide, which describes the "look and feel" of a Motif-compliant user interface. LBL="" HELPID=""You Don't Have to Use IRIS IMID="chap.0543"ID="chap.0544"ID="chap.0545"This section refers frequently to IRIS IM because it is commonly used in mixed-model programs; however, unless otherwise specified, you can use the features discussed here with other widget sets, such as the Athena widget set, because the features discussed in this chapter exist either within the widget itself or are based on the X toolkit. If you do use IRIS IM, you should use GLwMDrawingArea, the IRIS IM version of the GLwDrawingArea widget.LBL="" HELPID=""About the GLwDrawingArea WidgetCombining OpenGL and Motif is made easier by a specially supplied OpenGL drawing area widget, GLwDrawingArea. Use the GLwDrawingArea widget when creating a mixed-model program using Xt. The GLwDrawingArea widget is similar to a normal widget, but it sets up a configuration for GL drawing, as well as providing resources and callbacks that are useful to the GL programmer. The GLwDrawingArea widget also provides support for overlays. ID="chap.0546"There are actually two GLwDrawingArea widgets. The widget known as GLwDrawingArea is a generic widget, suitable with any widget set that is based on the Xt intrinsics. There is also a version known as GLwMDrawingArea (note the M) for use with IRIS IM programs.ID="chap.0547"ID="chap.0548"The two widgets are very similar, but they do have these differences:ID="chap.0549"ID="chap.0550"GLwMDrawingArea is a subclass of the IRIS IM XmPrimitive widget, rather than being a subclass of the Xt Core widget and, therefore, has various defaults such as background color.GLwMDrawingArea understands IRIS IM traversal, although traversal is turned off by default.† †ID="chap.0551"ID="chap.0552"ID="chap.0553"GLwMDrawingArea has an IRIS IM style creation function, ID="chap.0554"GlxCreateMDrawingArea(), in addition to allowing creation of the widget directly through Xt.ID="chap.0555"In all other respects, the two widgets are identical. The remainder of this chapter refers to the GlxMDraw widget, but unless otherwise specified, everything stated refers to both.LBL="" HELPID=""What You Need to Replace with XYou need to replace any GL code that handled anything controlled by the X Window Systemname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'this will mainly include your windowing and event handling code. One way to do this is to run toogl and then search through the output for the toogl warnings, which it marks "OGLXXX." It should be reasonably straightforward to determine which warnings relate to X. LBL="" HELPID=""Using the OpenGL WidgetID="chap.0556"ID="chap.0557"This section shows a simple example of a program that uses the IRIS IM version of the OpenGL widget and explains how the code worksname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the generic version of the widget can be used in the same way. When the OpenGL widget is initially opened, its visual must be set. In other words, you must first declare the display mode of the visual: single or double buffer, color index or RGBA mode. You may also specify how many bits will be used by the components of the frame buffer: for example, depth, stencil, and accumulation bits. In the program below, the function† †init_window(), which is registered with the GlxNginitCallback callback, calls glXCreateContext()ID="chap.0558" to set the visual of the OpenGL widget. In this case, the resources for the widget are set to support RGBA and double buffer mode. (See the fallback_resources[] array in the main() procedure.)/*
† †* mixed.c
† †*/

#include <Xm/Xm.h>
#include <Xm/Form.h>
#include <X11/keysym.h>
#include <X11/StringDefs.h>
#include "GlxMDrawA.h"

#include <GL/gl.h>
#include <GL/glu.h>
#include <stdio.h>
#include <stdlib.h>

static void input(Widget, XtPointer, XtPointer);
static void draw_scene_callback (Widget, XtPointer, XtPointer);
static void do_resize(Widget, XtPointer, XtPointer);
static void init_window(Widget, XtPointer, XtPointer);

static GLXContext glx_context;

void main(int argc, char** argv)
{
† †Arg args[20];
† †int n;
† †Widget glw, toplevel, form;
† †static XtAppContext app_context;
† †static String fallback_resources[] = {
† †"*glwidget*width: 300",
† †"*glwidget*height: 300",
† †"*glwidget*rgba: TRUE",
† †"*glwidget*doublebuffer: TRUE",
† †"*glwidget*allocateBackground: TRUE",
† †NULL
† †};

† †toplevel = XtAppInitialize(&app_context, "Mixed",
† †NULL , 0, &argc, argv, fallback_resources, NULL, 0);
† †n = 0;
† †form = XmCreateForm(toplevel, "form", args, n);
† †XtManageChild(form);

† †n = 0;
† †XtSetArg(args[n], XmNbottomAttachment, XmATTACH_FORM); n++;
† †XtSetArg(args[n], XmNtopAttachment, XmATTACH_FORM); n++;
† †XtSetArg(args[n], XmNleftAttachment, XmATTACH_FORM); n++;
† †XtSetArg(args[n], XmNrightAttachment, XmATTACH_FORM); n++;
† †glw = GlxCreateMDrawingArea(form, "glwidget", args, n);
† †XtManageChild (glw);
† †XtAddCallback(glw, GlxNexposeCallback,
† †draw_scene_callback, (XtPointer) NULL);
† †XtAddCallback(glw, GlxNresizeCallback, do_resize,
† †(XtPointer) NULL);
† †XtAddCallback(glw, GlxNginitCallback, init_window,
† †(XtPointer) NULL);
† †XtAddCallback(glw, GlxNinputCallback, input,
† †(XtPointer) NULL);

† †XtRealizeWidget(toplevel);
† †XtAppMainLoop(app_context);
}

static int rotation = 0;

void spin (void)
{
† †rotation = (rotation + 5) % 360;
}

static void draw_scene (Widget w)
{
† †GLUquadricObj *quadObj;

† †glClear(GL_COLOR_BUFFER_BIT);
† †glColor3f (1.0, 1.0, 1.0);
† †glPushMatrix();
† †glTranslatef (0.0, 0.0, -5.0);
† †glRotatef ((GLfloat) rotation, 1.0, 0.0, 0.0);
† †glPushMatrix ();
† †glRotatef (90.0, 1.0, 0.0, 0.0);
† †glTranslatef (0.0, 0.0, -1.0);
† †quadObj = gluNewQuadric ();
† †gluQuadricDrawStyle (quadObj, GLU_LINE);
† †gluCylinder (quadObj, 1.0, 1.0, 2.0, 12, 2);
† †glPopMatrix ();

† †glPopMatrix();
† †glFlush();
† †glXSwapBuffers (XtDisplay(w), XtWindow(w));
}
/* Process all Input callbacks*/
static void input(Widget w, XtPointer client_data,
† †XtPointer call)
{
† †char buffer[1];
† †KeySym keysym;
† †GlxDrawingAreaCallbackStruct *call_data;

† †call_data = (GlxDrawingAreaCallbackStruct *) call;

† †switch(call_data->event->type)
† †{
† †case KeyRelease:
† †  /* It is necessary to convert the keycode
† †   * to a keysym before it is possible to check
† †   * if it is an escape.
† †   */
† †  if (XLookupString( (XKeyEvent *)
† †                     call_data->event, buffer, 1, &keysym,
† †                     (XComposeStatus *)NULL) == 1 && 
† †                     keysym == (KeySym)XK_Escape)
† †    exit(0);
† †break;

† †case ButtonPress:
† †  switch (call_data->event->xbutton.button) {
† †    case Button1:
† †      spin();
† †      draw_scene(w);
† †    break;
† †  }
† †break;

† †default:
† †break;
† †}
}


static void draw_scene_callback
† †(Widget w, XtPointer client_data, XtPointer call)
{
† †static char firstTime = 0x1;
† †GlxDrawingAreaCallbackStruct *call_data;

† †call_data = (GlxDrawingAreaCallbackStruct *) call;
† †GlxDrawingAreaMakeCurrent(w, glx_context);

† †if (firstTime) {
† †  glViewport(0, 0, call_data->width, call_data->height);
† †  glMatrixMode(GL_PROJECTION);
† †  glLoadIdentity();
† †  gluPerspective(65.0,
† †         (float) call_data->width/(float) call_data->height,
† †         1.0, 20.0);
† †  glMatrixMode(GL_MODELVIEW);
† †  glLoadIdentity();
† †  firstTime = 0;
† †}
draw_scene (w);
}

static void do_resize(Widget w, XtPointer client_data,
† †XtPointer call)
{
† †GlxDrawingAreaCallbackStruct *call_data;

† †call_data = (GlxDrawingAreaCallbackStruct *) call;

† †GlxDrawingAreaMakeCurrent(w, glx_context);
† †glViewport(0, 0, call_data->width, call_data->height);
† †glMatrixMode(GL_PROJECTION);
† †glLoadIdentity();
† †gluPerspective(65.0,
† †(GLfloat) call_data->width/(GLfloat) call_data->height, 1.0, 20.0);
† †glMatrixMode(GL_MODELVIEW);
† †glLoadIdentity();
}

static void init_window(Widget w, XtPointer client_data, XtPointer call_data)
{
† †Arg args[1];
† †XVisualInfo *vi;
† †GLUquadricObj *quadObj;

† †XtSetArg(args[0], GlxNvisualInfo, &vi);
† †XtGetValues(w, args, 1);

† †glx_context = glXCreateContext(XtDisplay(w), vi, 0, GL_FALSE);
}It is a good idea to always call ID="chap.0559"GlxDrawingAreaMakeCurrent() to set the current widget. In the previous program, ID="chap.0560"GlxDrawingAreaMakeCurrent() is called from the callback functions.In the program example shown above, a wire frame cylinder is drawn using OpenGL. The GlxNinputCallback calls ID="chap.0561"input(), which handles mouse and keyboard input. Pressing the escape key causes the program to exit. Pressing Button1 (usually the left mouse button) calls spin(), which changes the rotation of the cylinder. Then the scene is completely redrawn. The mixed.c program has absolutely basic placement of widgets. The OpenGL drawing area widget is attached to all sides of its parent, an IRIS IM XmForm widget. This is a minimal arrangementname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'you can add additional IRIS IM widgets for a more sophisticated interface.ID="chap.0562"You might also want to add a WorkProc (or idle) function, which executes when no other events are occurring. A WorkProc is useful for rendering continuous motion, which does not require steady input events. ID="chap.0563"IDREF="77823" TYPE="TITLE"Appendix E, "Example Mixed-Model Program with WorkProc,"
 contains an example mixed-model program using Xt and WorkProc.LBL="" HELPID=""Other Information Sources for Mixed-Model ProgrammingFor more information on mixed-model programming in general, you can refer to the ID="chap.0564"OpenGL Reference Manual, which contains man pages for the OpenGL GLX command, as well as an introductory man page, glXIntro.For more detailed information on programming with Xt, refer to Volume IV of the X Window System Series, "X Toolkit Intrinsics Programming Manual," by Adrian Nye and Tim O'Reilly, published by O'Reilly & Associates, Inc. (If you're also using IRIS IM, you'll probably want the Motif version of Volume IV.)For more information on IRIS IM, refer to documentation on Motif, such as the OSF/Motif Series published by Prentice Hall.ID="chap.0565"LBL="" HELPID=""ID="34451"Mixed-Model Programming Using Xlib and OpenGL GLX CommandsID="chap.0566"This method of mixed-model programming is more difficult than using Xt and a widget set, and Silicon Graphics doesn't recommend it unless you're already familiar with Xlib programming. This section provides an overview of the necessary steps for mixed-model programming using Xlib and GLX. It also provides some simple code examples.You'll almost certainly need to refer to more substantial Xlib documentation (such as the O'Reilly volumes), as well as the OpenGL Reference Manual. The glXIntro man page is a good starting point.In brief, to port your OpenGL code to a mixed-model program using Xlib and GLX calls, follow these steps: Add the necessary include files to your program. (See IDREF="21136" TYPE="TITLE""Header Files"
 for information on what files to include.)Open a connection to a display: XOpenDisplay()ID="chap.0567".Choose an X visual: ID="chap.0568"glXChooseVisual().Create a GLX context: ID="chap.0569"glXCreateContext().Create an X window or pixmap: ID="chap.0570"XCreateWindow().Connect the GLX context to the X window: ID="chap.0571"glXMakeCurrent().LBL="" HELPID=""Code Example: Opening a Window with OpenGL GLXThe following example is a simple way of following those steps.You can find a version of this code in the ID="chap.0572"glXIntro man page. This sample is more heavily commented and contains some additional examples:#include <X11/Xlib.h>
#include <GL/glx.h>
#include <GL/gl.h>
#include <stdio.h>

static int attributeList[] = { GLX_RGBA, None };

static Bool WaitForNotify(Display *d, XEvent *e, char *arg)
† †   { return(e->type == MapNotify) && (e->xmap.window == (Window)arg); }

int main(int argc, char**argv) 
{
† †   Display *dpy;
† †   XVisualInfo *vi;
† †   Colormap cmap;
† †   XSetWindowAttributes swa;
† †   Window win;
† †   GLXContext cx;
† †   XEvent event;

/* get a connection   */
† †   dpy   = XOpenDisplay(0);
† †   if (!dpy) {
† †       fprintf(stderr, "Cannot open display.\n");
† †       exit(-1);
† †   }

/* get an appropriate visual */
† †   vi = glXChooseVisual(dpy, DefaultScreen(dpy),
† †        attributeList);
† †   if (!vi) {
† †       fprintf(stderr, "Cannot find visual with desired attributes.\n");
† †       exit(-1);
† †   }
/* create a GLX context */
† †   cx = glXCreateContext(dpy, vi, 0, GL_FALSE);
† †   if (!cx) {
† †       fprintf(stderr, "Cannot create context.\n");
† †       exit(-1);
† †   }

/* create a colormap -- AllocAll for color index mode */
† †   cmap = XCreateColormap(dpy, RootWindow(dpy, vi->screen),
† †          vi->visual, AllocNone);
† †   if (!cmap) {
† †       fprintf(stderr, "Cannot allocate colormap.\n");
† †       exit(-1);
† †   }

† †   /* create a   window */
† †   swa.colormap = cmap;
† †   swa.border_pixel = 0;
/* connect the context to the window */
† †   glXMakeCurrent(dpy, win, cx);

/* clear the buffer */
† †   glClearColor(1,1,0,1);
† †   glClear(GL_COLOR_BUFFER_BIT);
† †   glFlush();

/wait for a while */
† †   sleep(10);
/* exit cleanly */
† †   XCloseDisplay(dpy);
† †   exit(0);
}LBL="" HELPID=""ID="23967"X Color MapsID="chap.0573"Here's a brief example of OpenGL GLX code that demonstrates the use of color maps:XColor xc;

display = XOpenDisplay(0);

visual = glXChooseVisual(display,     

† †   DefaultScreen(display), attributeList);

context = glXCreateContext (display,visual,0,GL_FALSE);

colorMap = XCreateColormap (display,RootWindow(display, 

† †   visual->screen), visual->visual, AllocAll);

/* Note: if you don't say AllocAll, you can't load */
/* the color maps! */
† †   ...

if (index < visual->colormap_size) {

† †   xc.pixel = index;

† †   xc.red = (unsigned short)(red * 65535.0 + 0.5);

† †   xc.green = (unsigned short)(green * 65535.0 + 0.5);

† †   xc.blue = (unsigned short)(blue * 65535.0 + 0.5);

† †   xc.flags = DoRed | DoGreen | DoBlue;

† †   XStoreColor (display, colorMap, &xc);

}
LBL="" HELPID=""A Sample X Event LoopID="chap.0574"Here's a simple example of a mixed-model program that uses Xlib and OpenGL GLX calls for event handling:swa.event_mask = ExposureMask | StructureNotifyMask 
† †                | KeyPressMask | KeyReleaseMask;
do {
† †  XNextEvent(dpy, &event);
† †  switch (event.type) {
† †     case Expose:
† †        doRedraw = GL_TRUE;
† †        break;
† †     case ConfigureNotify:
† †        width = event.xconfigure.width;
† †        height = event.xconfigure.height;
† †        doRedraw = GL_TRUE;
† †        break;
† †     case KeyPress:
† †     {
† †        char buf[100];
† †        int rv;
† †        KeySym ks;

† †        rv = XLookupString(&event.xkey, buf, sizeof(buf), &ks, 0);
† †        switch (ks) {
† †           case XK_s:
† †           case XK_S:
† †              doSave = GL_TRUE;
† †              break;
† †           case XK_Escape:
† †              return 0;
† †              break;
† †        }
† †     }LBL="A"ID="39727"OpenGL Commands and Their IRIS GL EquivalentsIDREF="56942" TYPE="TABLE"Table A-1 contains a list of equivalent calls that you might find useful while porting. The first column is an alphabetical list of IRIS GL calls, the second column contains the corresponding calls to use with OpenGL, and the third column contains pointers to any relevant discussion in the text. In many cases the OpenGL commands listed will function somewhat differently from the IRIS GL commands, and the parameters may be different as well. Be sure to refer to the OpenGL man pages in the OpenGL Reference Manual for detailed descriptions of the functions of the these commands and the parameters they take. You might also need to refer to X or IRIS IM documentation; some appropriate X and IRIS IM manuals are listed in the Introduction to this book.COLUMNS="3"LBL="A-1"Table A-1 ID="56942"IRIS GL Commands and Their OpenGL EquivalentsLEFT="0" WIDTH="90"IRIS GL CallLEFT="95" WIDTH="135"OpenGL/glu/glX/aux EquivalentLEFT="235" WIDTH="356"Where DiscussedLEFT="0" WIDTH="90"acbuf()LEFT="95" WIDTH="135"glAccum()LEFT="235" WIDTH="356""Accumulation Buffer 
Calls" on page 63LEFT="0" WIDTH="90"acsize()LEFT="95" WIDTH="135"glXChooseVisual()LEFT="235" WIDTH="356""Accumulation Buffer 
Calls" on page 63LEFT="0" WIDTH="90"addtopup()LEFT="95" WIDTH="135"use X or IRIS IM for menusLEFT="235" WIDTH="356"Chapter 5, glXIntro man 
page, X documentation, 
IRIS IM documentationLEFT="0" WIDTH="90"afunction()LEFT="95" WIDTH="135"glAlphaFunc()LEFT="235" WIDTH="356""afunction() test 
functions" on page 61LEFT="0" WIDTH="90"arc()LEFT="95" WIDTH="135"IDREF="appen.ATF0a"agluPartialDisk()LEFT="235" WIDTH="356""Editing toogl Output: 
An Example" on page 13 
and "Arcs and Circles" on 
page 42LEFT="0" WIDTH="90"backbuffer()LEFT="95" WIDTH="135"glDrawBuffer(GL_BACK)LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"backface()LEFT="95" WIDTH="135"glCullFace(GL_BACK)LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"bbox2()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting bbox2() Calls" 
on page 66LEFT="0" WIDTH="90"bgnclosedline()LEFT="95" WIDTH="135"glBegin(GL_LINE_LOOP)LEFT="235" WIDTH="356""bgn/end Commands" 
on page 31 and "Lines" 
on page 35LEFT="0" WIDTH="90"bgncurve()LEFT="95" WIDTH="135"gluBeginCurve()LEFT="235" WIDTH="356""NURBS Curves" on 
page 54LEFT="0" WIDTH="90"bgnline()LEFT="95" WIDTH="135"glBegin(GL_LINE_STRIP)LEFT="235" WIDTH="356""bgn/end Commands" 
on page 31 and "Lines" 
on page 35LEFT="0" WIDTH="90"bgnpoint()LEFT="95" WIDTH="135"glBegin(GL_POINTS)LEFT="235" WIDTH="356""bgn/end Commands" 
on page 31 and "Points" 
on page 34LEFT="0" WIDTH="90"bgnpolygon()LEFT="95" WIDTH="135"glBegin(GL_POLYGON)LEFT="235" WIDTH="356""bgn/end Commands" 
on page 31, "Polygons 
and Quadrilaterals" on 
page 36 and "Tessellated 
Polygons" on page 40LEFT="0" WIDTH="90"bgnqstrip()LEFT="95" WIDTH="135"glBegin(GL_QUAD_STRIP)LEFT="235" WIDTH="356""bgn/end Commands" 
on page 31 and "Polygons 
and Quadrilaterals" on 
page 36LEFT="0" WIDTH="90"bgnsurface()LEFT="95" WIDTH="135"gluBeginSurface()LEFT="235" WIDTH="356""NURBS Surfaces" on 
page 55LEFT="0" WIDTH="90"bgntmesh()LEFT="95" WIDTH="135"glBegin( 
GL_TRIANGLE_STRIP)LEFT="235" WIDTH="356""bgn/end Commands" 
on page 31 and 
"Triangles" on page 41LEFT="0" WIDTH="90"bgntrim()LEFT="95" WIDTH="135"gluBeginTrim()LEFT="235" WIDTH="356""Trimming Curves" on 
page 55LEFT="0" WIDTH="90"blankscreen()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"blanktime()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"blendfunction()LEFT="95" WIDTH="135"glBlendFunc()LEFT="235" WIDTH="356""Blending" on page 60LEFT="0" WIDTH="90"blink()LEFT="95" WIDTH="135"use auxiliary library or X for 
color mapsLEFT="235" WIDTH="356""Using Color-Index 
Mode" on page 106 or 
Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"blkqread()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="356""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" on 
page 99 or Chapter 5 and 
glXIntro man pageLEFT="0" WIDTH="90"c() LEFT="95" WIDTH="135"glColor()LEFT="235" WIDTH="356""Porting Color, Shading, 
and Writemask 
Commands" on page 44LEFT="0" WIDTH="90"callfunc()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Display Lists" 
on page 65LEFT="0" WIDTH="90"callobj() LEFT="95" WIDTH="135"glCallList()LEFT="235" WIDTH="356""bgn/end Commands" 
on page 31 and "Porting 
Display Lists" on page 65LEFT="0" WIDTH="90"charstr()LEFT="95" WIDTH="135"glCallLists()aLEFT="235" WIDTH="356""Fonts and Strings" on 
page 111LEFT="0" WIDTH="90"chunksize()LEFT="95" WIDTH="135"not neededLEFT="235" WIDTH="356""Porting Display Lists" 
on page 65LEFT="0" WIDTH="90"circ()LEFT="95" WIDTH="135"gluDisk()LEFT="235" WIDTH="356""Arcs and Circles" on 
page 42LEFT="0" WIDTH="90"clear()LEFT="95" WIDTH="135"glClear( 
GL_COLOR_BUFFER_BIT)LEFT="235" WIDTH="356""Windowing, Device, and 
Event Calls" on page 10 
and "Porting Screen and 
Buffer Clearing 
Commands" on page 20LEFT="0" WIDTH="90"clearhitcode()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Picking Calls" 
on page 84LEFT="0" WIDTH="90"clipplane() LEFT="95" WIDTH="135"glClipPlane()LEFT="235" WIDTH="356""Clipping Planes" on 
page 29LEFT="0" WIDTH="90"clkon()LEFT="95" WIDTH="135"XChangeKeyboardControl()LEFT="235" WIDTH="356"see X documentationLEFT="0" WIDTH="90"clkoff()LEFT="95" WIDTH="135"XChangeKeyboardControl()LEFT="235" WIDTH="356"see X documentationLEFT="0" WIDTH="90"closeobj()LEFT="95" WIDTH="135"glEndList()LEFT="235" WIDTH="356""Porting Display Lists" 
on page 65LEFT="0" WIDTH="90"cmode()LEFT="95" WIDTH="135"auxInitDisplayMode() or 
glXChooseVisual()LEFT="235" WIDTH="356""Using Color-Index 
Mode" on page 106 or 
Chapter 5 and glXIntro 
and glXChooseVisual() 
man pagesLEFT="0" WIDTH="90"cmov(),cmov2()LEFT="95" WIDTH="135"glRasterPos3()a,glRasterPos2()aLEFT="235" WIDTH="356""Porting Pixel 
Operations" on page 47LEFT="0" WIDTH="90"color()LEFT="95" WIDTH="135"glIndex()LEFT="235" WIDTH="356""bgn/end Commands" 
on page 31 and "Porting 
Color, Shading, and 
Writemask Commands" 
on page 44LEFT="0" WIDTH="90"compactify()LEFT="95" WIDTH="135"not neededLEFT="235" WIDTH="356""Porting Color, Shading, 
and Writemask 
Commands" on page 44LEFT="0" WIDTH="90"concave()LEFT="95" WIDTH="135"gluBeginPolygon()aLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"cpack()LEFT="95" WIDTH="135"glColor()aLEFT="235" WIDTH="356""bgn/end Commands" 
on page 31 and "Porting 
Color, Shading, and 
Writemask Commands" 
on page 44LEFT="0" WIDTH="90"crv()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Curve and 
Surface Commands" on 
page 53LEFT="0" WIDTH="90"crvn()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Curve and 
Surface Commands" on 
page 53LEFT="0" WIDTH="90"curorigin()LEFT="95" WIDTH="135"use X for cursorsLEFT="235" WIDTH="356"Chapter 5, glXIntro man 
page, X documentationLEFT="0" WIDTH="90"cursoff()LEFT="95" WIDTH="135"use X for cursorsLEFT="235" WIDTH="356"Chapter 5, glXIntro man 
page, X documentationLEFT="0" WIDTH="90"curson()LEFT="95" WIDTH="135"use X for cursorsLEFT="235" WIDTH="356"Chapter 5, glXIntro man 
page, X documentationLEFT="0" WIDTH="90"curstype()LEFT="95" WIDTH="135"use X for cursorsLEFT="235" WIDTH="356"Chapter 5, glXIntro man 
page, X documentationLEFT="0" WIDTH="90"curvebasis()LEFT="95" WIDTH="135"glMap1()LEFT="235" WIDTH="356""Porting Curve and 
Surface Commands" on 
page 53LEFT="0" WIDTH="90"curveit()LEFT="95" WIDTH="135"glEvalMesh1()LEFT="235" WIDTH="356""Porting Curve and 
Surface Commands" on 
page 53LEFT="0" WIDTH="90"curveprecision() LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Curve and 
Surface Commands" on 
page 53LEFT="0" WIDTH="90"cyclemap()LEFT="95" WIDTH="135"use auxiliary library or X for 
color mapsLEFT="235" WIDTH="356""Using Color-Index 
Mode" on page 106 or 
Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"czclear()LEFT="95" WIDTH="135"glClear( 
GL_COLOR_BUFFER_BIT | 
GL_DEPTH_BUFFER_BIT)LEFT="235" WIDTH="356""Porting Screen and 
Buffer Clearing 
Commands" on page 20LEFT="0" WIDTH="90"dbtext()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"Dial and Button Box 
documentationLEFT="0" WIDTH="90"defbasis()LEFT="95" WIDTH="135"glMap1()LEFT="235" WIDTH="356""Porting Curve and 
Surface Commands" on 
page 53LEFT="0" WIDTH="90"defcursor()LEFT="95" WIDTH="135"use X for cursorsLEFT="235" WIDTH="356"Chapter 5, glXIntro man 
page, X documentationLEFT="0" WIDTH="90"deflinestyle()LEFT="95" WIDTH="135"glLineStipple()LEFT="235" WIDTH="356""Lines" on page 35 and 
"Porting defs, binds, and 
sets: Replacing `Tables' of 
Stored Definitions" on 
page 69LEFT="0" WIDTH="90"defpattern() LEFT="95" WIDTH="135"glPolygonStipple()LEFT="235" WIDTH="356""Polygons and 
Quadrilaterals" on page 
36 and "Porting defs, 
binds, and sets: Replacing 
`Tables' of Stored 
Definitions" on page 69LEFT="0" WIDTH="90"defpup()LEFT="95" WIDTH="135"use X for menusLEFT="235" WIDTH="356"Chapter 5, glXIntro man 
page, X documentationLEFT="0" WIDTH="90"defrasterfont() LEFT="95" WIDTH="135"glXUseXFont()aLEFT="235" WIDTH="356""Fonts and Strings" on 
page 111LEFT="0" WIDTH="90"delobj() LEFT="95" WIDTH="135"glDeleteLists()LEFT="235" WIDTH="356""Porting Display Lists" 
on page 65LEFT="0" WIDTH="90"deltag()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Display Lists" 
on page 65LEFT="0" WIDTH="90"depthcue()LEFT="95" WIDTH="135"glFog()aLEFT="235" WIDTH="356""Porting Depth Cueing 
and Fog Commands" on 
page 49LEFT="0" WIDTH="90"dglclose()LEFT="95" WIDTH="135"not neededname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'OpenGL is 
network transparentLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"dglopen()LEFT="95" WIDTH="135"not neededname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'OpenGL is 
network transparentLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"dither()LEFT="95" WIDTH="135"glEnable(GL_DITHER)LEFT="235" WIDTH="356""Porting Color, Shading, 
and Writemask 
Commands" on page 44LEFT="0" WIDTH="90"dopup()LEFT="95" WIDTH="135"use X for menusLEFT="235" WIDTH="356"Chapter 5, glXIntro man 
page, X documentationLEFT="0" WIDTH="90"doublebuffer()LEFT="95" WIDTH="135"auxInitDisplayMode() or 
glXChooseVisual()LEFT="235" WIDTH="356""Porting Display Mode 
Initialization Calls with 
auxInitDisplayMode()" 
on page 96 or Chapter 5 
and glXIntro man pageLEFT="0" WIDTH="90"draw()LEFT="95" WIDTH="135"glBegin(GL_LINES)aLEFT="235" WIDTH="356""Porting Commands that 
Required Current 
Graphics Position" on 
page 19 and "Lines" on 
page 35LEFT="0" WIDTH="90"drawmode()LEFT="95" WIDTH="135"glXMakeCurrent()aLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"editobj()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Display Lists" 
on page 65LEFT="0" WIDTH="90"endclosedline()LEFT="95" WIDTH="135"glEnd()LEFT="235" WIDTH="356""bgn/end Commands" 
on page 31 and "Lines" 
on page 35LEFT="0" WIDTH="90"endcurve()LEFT="95" WIDTH="135"gluEndCurve()LEFT="235" WIDTH="356""Porting Curve and 
Surface Commands" on 
page 53LEFT="0" WIDTH="90"endfeedback()LEFT="95" WIDTH="135"glRenderMode(GL_RENDER)LEFT="235" WIDTH="356""Porting Feedback Calls" 
on page 90LEFT="0" WIDTH="90"endfullscreen()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"endline()LEFT="95" WIDTH="135"glEnd()LEFT="235" WIDTH="356""bgn/end Commands" 
on page 31LEFT="0" WIDTH="90"endpick()LEFT="95" WIDTH="135"glRenderMode(GL_RENDER)LEFT="235" WIDTH="356""Porting Picking Calls" 
on page 84LEFT="0" WIDTH="90"endpoint()LEFT="95" WIDTH="135"glEnd()LEFT="235" WIDTH="356""bgn/end Commands" 
on page 31 and "Points" 
on page 34LEFT="0" WIDTH="90"endpolygon()LEFT="95" WIDTH="135"glEnd()LEFT="235" WIDTH="356""bgn/end Commands" 
on page 31 and "Polygons 
and Quadrilaterals" on 
page 36LEFT="0" WIDTH="90"endpupmode()LEFT="95" WIDTH="135"use X for menusLEFT="235" WIDTH="356"Chapter 5, glXIntro man 
page, X documentationLEFT="0" WIDTH="90"endqstrip()LEFT="95" WIDTH="135"glEnd()LEFT="235" WIDTH="356""bgn/end Commands" 
on page 31 and "Polygons 
and Quadrilaterals" on 
page 36LEFT="0" WIDTH="90"endselect()LEFT="95" WIDTH="135"glRenderMode(GL_RENDER)LEFT="235" WIDTH="356""Porting Picking Calls" 
on page 84LEFT="0" WIDTH="90"endsurface()LEFT="95" WIDTH="135"gluEndSurface()LEFT="235" WIDTH="356""NURBS Surfaces" on 
page 55LEFT="0" WIDTH="90"endtmesh()LEFT="95" WIDTH="135"glEnd()LEFT="235" WIDTH="356""bgn/end Commands" 
on page 31 and 
"Triangles" on page 41LEFT="0" WIDTH="90"endtrim()LEFT="95" WIDTH="135"gluEndTrim()LEFT="235" WIDTH="356""Trimming Curves" on 
page 55LEFT="0" WIDTH="90"feedback()LEFT="95" WIDTH="135"glFeedbackBuffer()LEFT="235" WIDTH="356""Porting Feedback Calls" 
on page 90LEFT="0" WIDTH="90"finish()LEFT="95" WIDTH="135"glFinish()LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"fogvertex() LEFT="95" WIDTH="135"glFog()LEFT="235" WIDTH="356""Porting Depth Cueing 
and Fog Commands" on 
page 49LEFT="0" WIDTH="90"font()LEFT="95" WIDTH="135"see glListBase()LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"foreground()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"freepup()LEFT="95" WIDTH="135"use X for menusLEFT="235" WIDTH="356"Chapter 5, glXIntro man 
page, X documentationLEFT="0" WIDTH="90"frontbuffer()LEFT="95" WIDTH="135"glDrawBuffer(GL_FRONT)LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"frontface()LEFT="95" WIDTH="135"see glCullFace()LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"fudge()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"fullscrn()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"gammaramp()LEFT="95" WIDTH="135"use auxiliary library or X for 
color mapsLEFT="235" WIDTH="356""Using Color-Index 
Mode" on page 106 or 
Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"gbegin()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"gconfig()LEFT="95" WIDTH="135"no equivalent (not needed)LEFT="235" WIDTH="356""Porting Display Mode 
Initialization Calls with 
auxInitDisplayMode()" 
on page 96 or Chapter 5 
and glXIntro man pageLEFT="0" WIDTH="90"genobj()LEFT="95" WIDTH="135"glGenLists()LEFT="235" WIDTH="356""Porting Display Lists" 
on page 65LEFT="0" WIDTH="90"gentag()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Stencil Plane Calls" on 
page 64LEFT="0" WIDTH="90"getbackface()LEFT="95" WIDTH="135"glGet()LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"getbuffer()LEFT="95" WIDTH="135"glGet()LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"getbutton()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18, 
"Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" on 
page 99 or Chapter 5, and 
glXIntro man pageLEFT="0" WIDTH="90"getcmmode()LEFT="95" WIDTH="135"glXGetCurrentContext()LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18, 
Chapter 5 and "Porting 
Color, Shading, and 
Writemask Commands" 
on page 44LEFT="0" WIDTH="90"getcolor()LEFT="95" WIDTH="135"glGet()LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"getcpos()LEFT="95" WIDTH="135"glGet()LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"getcursor()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"getdcm()LEFT="95" WIDTH="135"glIsEnabled()LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18 
and "Porting Depth 
Cueing and Fog 
Commands" on page 49LEFT="0" WIDTH="90"getdepth()LEFT="95" WIDTH="135"glGet()LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"getdescender()LEFT="95" WIDTH="135"use X for fontsLEFT="235" WIDTH="356""Fonts and Strings" on 
page 111 and "Porting 
IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"getdev()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"getdisplaymode()LEFT="95" WIDTH="135"glGet()LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"LEFT="95" WIDTH="135"glXGetCurrentContext()LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"getdrawmode()LEFT="95" WIDTH="135"glXGetCurrentContext()LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"getfont()LEFT="95" WIDTH="135"use X for fontsLEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18 
and "Fonts and Strings" 
on page 111LEFT="0" WIDTH="90"getgdesc()LEFT="95" WIDTH="135"glGet(),glXGetConfig(),glXGetCurrentContext(),glXGetCurrentDrawable()LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"getgpos() LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Commands that 
Required Current 
Graphics Position" on 
page 19 and "Porting IRIS 
GL `Get' Commands" on 
page 18LEFT="0" WIDTH="90"getheight()LEFT="95" WIDTH="135"use X for fontsLEFT="235" WIDTH="356""Fonts and Strings" on 
page 111 and "Porting 
IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"gethitcode()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Picking Calls" 
on page 84 and "Porting 
IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"getlsbackup()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Lines" on page 35 and 
"Porting IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"getlsrepeat()LEFT="95" WIDTH="135"glGet()LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18 
and "Lines" on page 35LEFT="0" WIDTH="90"getlstyle()LEFT="95" WIDTH="135"glGet()LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18 
and "Lines" on page 35LEFT="0" WIDTH="90"getlwidth()LEFT="95" WIDTH="135"glGet()LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18 
and "Lines" on page 35LEFT="0" WIDTH="90"getmap(void)LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18, 
Chapter 5 and "Porting 
Color, Shading, and 
Writemask Commands" 
on page 44LEFT="0" WIDTH="90"getmatrix()LEFT="95" WIDTH="135"glGet(GL_MODELVIEW_† †          MATRIX),glGet(GL_PROJECTION_† †          MATRIX)LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18 
and "Porting Matrix and 
Transformation Calls" on 
page 22LEFT="0" WIDTH="90"getmcolor()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18, 
"Porting Color, Shading, 
and Writemask 
Commands" on page 44, 
"Using Color-Index 
Mode" on page 106, or 
Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"getmmode()LEFT="95" WIDTH="135"glGet(GL_MATRIX_MODE)LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18 
and "Porting Matrix and 
Transformation Calls" on 
page 22LEFT="0" WIDTH="90"getmonitor()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"getnurbsproperty() LEFT="95" WIDTH="135"gluGetNurbsProperty()LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"getopenobj()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Display Lists" 
on page 65 and "Porting 
IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"getorigin()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18 
and "Windowing" on 
page 96, or Chapter 5 and 
glXIntro man pageLEFT="0" WIDTH="90"getpattern()LEFT="95" WIDTH="135"glGetPolygonStipple()LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18 
and "Polygons and 
Quadrilaterals" on page 
36LEFT="0" WIDTH="90"getplanes()LEFT="95" WIDTH="135"glGet(GL_RED_BITS),glGet(GL_GREEN_BITS),glGet(GL_BLUE_BITS)LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"getport()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18, 
"Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"getresetls()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Lines" on page 35 and 
"Porting IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"getscrbox()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18 
and "Viewports, 
Screenmasks, and 
Scrboxes" on page 28LEFT="0" WIDTH="90"getscrmask() LEFT="95" WIDTH="135"glGet(GL_SCISSOR_BOX)LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18 
and "Viewports, 
Screenmasks, and 
Scrboxes" on page 28LEFT="0" WIDTH="90"getshade()LEFT="95" WIDTH="135"† †glGet( GL_CURRENT_INDEX)LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"getsize()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18, 
"Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"getsm()LEFT="95" WIDTH="135"glGet(GL_SHADE_MODEL)LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18 
and "Porting Color, 
Shading, and Writemask 
Commands" on page 44LEFT="0" WIDTH="90"getvaluator()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="356"† †"Porting IRIS GL `Get' 
Commands" on page 18, 
"Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" on 
page 99 or Chapter 5 and 
glXIntro man pageLEFT="0" WIDTH="90"getvideo()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"getviewport()LEFT="95" WIDTH="135"glGet(GL_VIEWPORT)LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18 
and "Viewports, 
Screenmasks, and 
Scrboxes" on page 28LEFT="0" WIDTH="90"getwritemask()LEFT="95" WIDTH="135"glGet( 
GL_INDEX_WRITEMASK)LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18 
and "Porting Color, 
Shading, and Writemask 
Commands" on page 44LEFT="0" WIDTH="90"getwscrn()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18 
and "Windowing" on 
page 96 or Chapter 5 and 
glXIntro man pageLEFT="0" WIDTH="90"getzbuffer()LEFT="95" WIDTH="135"glIsEnabled( GL_DEPTH_TEST)LEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"gexit()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"gflush()LEFT="95" WIDTH="135"glFlush()LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"ginit()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"glcompat()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"greset()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting greset()" on 
page 16LEFT="0" WIDTH="90"gRGBcolor()LEFT="95" WIDTH="135"glGet(GL_CURRENT_† †          RASTER_COLOR)LEFT="235" WIDTH="356""Porting Color, Shading, 
and Writemask 
Commands" on page 44LEFT="0" WIDTH="90"gRGBcursor()LEFT="95" WIDTH="135"use X for cursorsLEFT="235" WIDTH="356"Chapter 5, glXIntro man 
page, X documentationLEFT="0" WIDTH="90"gRGBmask()LEFT="95" WIDTH="135"glGet( 
GL_COLOR_WRITEMASK)LEFT="235" WIDTH="356""Porting Color, Shading, 
and Writemask 
Commands" on page 44LEFT="0" WIDTH="90"gselect() LEFT="95" WIDTH="135"glSelectBuffer()LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"gsync()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"gversion()LEFT="95" WIDTH="135"glGetString( GL_RENDERER)aLEFT="235" WIDTH="356"Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"iconsize()LEFT="95" WIDTH="135"use X LEFT="235" WIDTH="356"see X documentation for 
XIconSize()LEFT="0" WIDTH="90"icontitle()LEFT="95" WIDTH="135"use XLEFT="235" WIDTH="356"see X documentation for 
XSetIconName()LEFT="0" WIDTH="90"imakebackground()LEFT="95" WIDTH="135"use the auxiliary library or X for 
event handlingLEFT="235" WIDTH="356""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" on 
page 99 or Chapter 5 and 
glXIntro man pageLEFT="0" WIDTH="90"initnames()LEFT="95" WIDTH="135"glInitNames()LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"ismex()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting IRIS GL `Get' 
Commands" on page 18LEFT="0" WIDTH="90"isobj()LEFT="95" WIDTH="135"glIsList()LEFT="235" WIDTH="356""Porting Display Lists" 
on page 65LEFT="0" WIDTH="90"isqueued()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="356""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" on 
page 99 or Chapter 5 and 
glXIntro man pageLEFT="0" WIDTH="90"istag()LEFT="95" WIDTH="135"not supported LEFT="235" WIDTH="356""Stencil Plane Calls" on 
page 64LEFT="0" WIDTH="90"keepaspect()LEFT="95" WIDTH="135"use the auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"lampoff()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"see X documentation for 
XChangeKeyboardContr
ol()LEFT="0" WIDTH="90"lampon()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"see X documentation for 
XChangeKeyboardContr
ol()LEFT="0" WIDTH="90"linesmooth()LEFT="95" WIDTH="135"glEnable( GL_LINE_SMOOTH)LEFT="235" WIDTH="356""Lines" on page 35 and 
"Antialiasing Calls" on 
page 62LEFT="0" WIDTH="90"linewidth()LEFT="95" WIDTH="135"glLineWidth()LEFT="235" WIDTH="356""Lines" on page 35LEFT="0" WIDTH="90"linewidthf()LEFT="95" WIDTH="135"glLineWidth()LEFT="235" WIDTH="356""Lines" on page 35LEFT="0" WIDTH="90"lmbind()LEFT="95" WIDTH="135"glEnable(GL_LIGHTING)glEnable(GL_LIGHTi)LEFT="235" WIDTH="356""bgn/end Commands" 
on page 31, "Porting defs, 
binds, and sets: Replacing 
`Tables' of Stored 
Definitions" on page 69, 
and "Porting Lighting 
and Materials Calls" on 
page 70LEFT="0" WIDTH="90"lmcolor()LEFT="95" WIDTH="135"glColorMaterial()LEFT="235" WIDTH="356""Porting Lighting and 
Materials Calls" on page 
70LEFT="0" WIDTH="90"lmdef()LEFT="95" WIDTH="135"glMaterial()glLight()glLightModel()LEFT="235" WIDTH="356""Porting defs, binds, and 
sets: Replacing `Tables' of 
Stored Definitions" on 
page 69 and "Porting 
Lighting and Materials 
Calls" on page 70LEFT="0" WIDTH="90"loadmatrix()LEFT="95" WIDTH="135"glLoadMatrix()LEFT="235" WIDTH="356""Porting Matrix and 
Transformation Calls" on 
page 22LEFT="0" WIDTH="90"loadname()LEFT="95" WIDTH="135"glLoadName()LEFT="235" WIDTH="356""Porting Picking Calls" 
on page 84LEFT="0" WIDTH="90"logicop()LEFT="95" WIDTH="135"glLogicOp()LEFT="235" WIDTH="356""Porting Pixel 
Operations" on page 47LEFT="0" WIDTH="90"lookat() LEFT="95" WIDTH="135"gluLookAt()aLEFT="235" WIDTH="356""Porting Matrix and 
Transformation Calls" on 
page 22LEFT="0" WIDTH="90"lrectread() LEFT="95" WIDTH="135"glReadPixels()LEFT="235" WIDTH="356""Porting Pixel 
Operations" on page 47LEFT="0" WIDTH="90"lrectwrite(])LEFT="95" WIDTH="135"glDrawPixels()LEFT="235" WIDTH="356""Porting Pixel 
Operations" on page 47LEFT="0" WIDTH="90"lRGBrange()LEFT="95" WIDTH="135"not supported, see glFog()LEFT="235" WIDTH="356""Porting Depth Cueing 
and Fog Commands" on 
page 49LEFT="0" WIDTH="90"lsbackup()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Lines" on page 35LEFT="0" WIDTH="90"lsetdepth()LEFT="95" WIDTH="135"glDepthRange()LEFT="235" WIDTH="356""Porting Depth Cueing 
and Fog Commands" on 
page 49LEFT="0" WIDTH="90"lshaderange()LEFT="95" WIDTH="135"not supported, see glFog()LEFT="235" WIDTH="356""Porting Depth Cueing 
and Fog Commands" on 
page 49LEFT="0" WIDTH="90"lsrepeat()LEFT="95" WIDTH="135"glLineStipple()LEFT="235" WIDTH="356""Lines" on page 35LEFT="0" WIDTH="90"makeobj()LEFT="95" WIDTH="135"glNewList()LEFT="235" WIDTH="356""Porting Display Lists" 
on page 65LEFT="0" WIDTH="90"maketag()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Stencil Plane Calls" on 
page 64LEFT="0" WIDTH="90"mapcolor()LEFT="95" WIDTH="135"auxSetOneColor() or 
XStoreColor()LEFT="235" WIDTH="356""Using Color-Index 
Mode" on page 106 and 
Chapter 5LEFT="0" WIDTH="90"mapw()LEFT="95" WIDTH="135"gluProject()LEFT="235" WIDTH="356""Porting Matrix and 
Transformation Calls" on 
page 22LEFT="0" WIDTH="90"maxsize()LEFT="95" WIDTH="135"use the auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"minsize()LEFT="95" WIDTH="135"use the auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"mmode()LEFT="95" WIDTH="135"glMatrixMode()LEFT="235" WIDTH="356""Porting Matrix and 
Transformation Calls" on 
page 22LEFT="0" WIDTH="90"move()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Commands that 
Required Current 
Graphics Position" on 
page 19LEFT="0" WIDTH="90"mswapbuffers()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"multimap()LEFT="95" WIDTH="135"use the auxiliary library or X for 
color mapsLEFT="235" WIDTH="356""Porting Color, Shading, 
and Writemask 
Commands" on page 44, 
also "Using Color-Index 
Mode" on page 106 or 
Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"multmatrix()LEFT="95" WIDTH="135"glMultMatrix()LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"n3f()LEFT="95" WIDTH="135"glNormal3fv()LEFT="235" WIDTH="356""bgn/end Commands" 
on page 31LEFT="0" WIDTH="90"newpup()LEFT="95" WIDTH="135"use X for menusLEFT="235" WIDTH="356"Chapter 5, glXIntro man 
page, X documentationLEFT="0" WIDTH="90"newtag()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Display Lists" 
on page 65LEFT="0" WIDTH="90"nmode()LEFT="95" WIDTH="135"glEnable(GL_NORMALIZE)LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"noborder()LEFT="95" WIDTH="135"use the auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"noise()LEFT="95" WIDTH="135"use the auxiliary library or X for 
event handlingLEFT="235" WIDTH="356""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" on 
page 99 or Chapter 5 and 
glXIntro man pageLEFT="0" WIDTH="90"noport()LEFT="95" WIDTH="135"use X for windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"normal()LEFT="95" WIDTH="135"glNormal3fv()LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"nurbscurve()LEFT="95" WIDTH="135"gluNurbsCurve()aLEFT="235" WIDTH="356""NURBS Curves" on 
page 54 and "Trimming 
Curves" on page 55LEFT="0" WIDTH="90"nurbssurface()LEFT="95" WIDTH="135"gluNurbsSurface()aLEFT="235" WIDTH="356""NURBS Surfaces" on 
page 55LEFT="0" WIDTH="90"objdelete()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Stencil Plane Calls" on 
page 64LEFT="0" WIDTH="90"objinsert()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Stencil Plane Calls" on 
page 64LEFT="0" WIDTH="90"objreplace()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Display Lists" 
on page 65LEFT="0" WIDTH="90"onemap()LEFT="95" WIDTH="135"use the auxiliary library or X for 
color mapsLEFT="235" WIDTH="356""Porting Color, Shading, 
and Writemask 
Commands" on page 44 
and "Using Color-Index 
Mode" on page 106 or 
Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"ortho()LEFT="95" WIDTH="135"glOrtho()LEFT="235" WIDTH="356""Porting Matrix and 
Transformation Calls" on 
page 22LEFT="0" WIDTH="90"ortho2()LEFT="95" WIDTH="135"gluOrtho2D()LEFT="235" WIDTH="356""Porting Matrix and 
Transformation Calls" on 
page 22LEFT="0" WIDTH="90"overlay()LEFT="95" WIDTH="135"use XLEFT="235" WIDTH="356"Chapter 5 and glXIntro 
man page, also 
glXChooseVisual()LEFT="0" WIDTH="90"pagecolor()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"passthrough()LEFT="95" WIDTH="135"glPassThrough() LEFT="235" WIDTH="356""Porting Feedback Calls" 
on page 90LEFT="0" WIDTH="90"patch()LEFT="95" WIDTH="135"glEvalMesh2()aLEFT="235" WIDTH="356""Porting Curve and 
Surface Commands" on 
page 53LEFT="0" WIDTH="90"patchbasis()LEFT="95" WIDTH="135"glMap2()aLEFT="235" WIDTH="356""Porting Curve and 
Surface Commands" on 
page 53LEFT="0" WIDTH="90"patchcurves()LEFT="95" WIDTH="135"glMap2()aLEFT="235" WIDTH="356""Porting Curve and 
Surface Commands" on 
page 53LEFT="0" WIDTH="90"patchprecision()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Curve and 
Surface Commands" on 
page 53LEFT="0" WIDTH="90"pclos()LEFT="95" WIDTH="135"not supported, see glEnd()LEFT="235" WIDTH="356""Porting Commands that 
Required Current 
Graphics Position" on 
page 19 and "Polygons 
and Quadrilaterals" on 
page 36LEFT="0" WIDTH="90"pdr()LEFT="95" WIDTH="135"not supported, see glVertex()LEFT="235" WIDTH="356""Porting Commands that 
Required Current 
Graphics Position" on 
page 19 and "Polygons 
and Quadrilaterals" on 
page 36LEFT="0" WIDTH="90"perspective()LEFT="95" WIDTH="135"gluPerspective()LEFT="235" WIDTH="356""Porting Matrix and 
Transformation Calls" on 
page 22LEFT="0" WIDTH="90"pick()LEFT="95" WIDTH="135"gluPickMatrix()a andglRenderMode(GL_SELECT)LEFT="235" WIDTH="356""Porting Picking Calls" 
on page 84LEFT="0" WIDTH="90"picksize() LEFT="95" WIDTH="135"gluPickMatrix()LEFT="235" WIDTH="356""Porting Matrix and 
Transformation Calls" on 
page 22 and "Porting 
Picking Calls" on page 84LEFT="0" WIDTH="90"pixmode()LEFT="95" WIDTH="135"glPixelTransfer() and 
glPixelStore()LEFT="235" WIDTH="356""Porting Pixel 
Operations" on page 47LEFT="0" WIDTH="90"pmv()LEFT="95" WIDTH="135"not supported, see glBegin() and 
glVertex()LEFT="235" WIDTH="356""Porting Commands that 
Required Current 
Graphics Position" on 
page 19 and "Polygons 
and Quadrilaterals" on 
page 36LEFT="0" WIDTH="90"pnt()LEFT="95" WIDTH="135"glBegin(GL_POINTS)aLEFT="235" WIDTH="356""Points" on page 34LEFT="0" WIDTH="90"pntsize()LEFT="95" WIDTH="135"glPointSize()LEFT="235" WIDTH="356""Points" on page 34LEFT="0" WIDTH="90"pntsizef()LEFT="95" WIDTH="135"glPointSize()LEFT="235" WIDTH="356""Points" on page 34LEFT="0" WIDTH="90"pntsmooth()LEFT="95" WIDTH="135"glEnable( 
GL_POINT_SMOOTH)LEFT="235" WIDTH="356""Points" on page 34 and 
"Antialiasing Calls" on 
page 62LEFT="0" WIDTH="90"polarview()LEFT="95" WIDTH="135"not supported, see glRotate() 
and glTranslate()LEFT="235" WIDTH="356""Porting Matrix and 
Transformation Calls" on 
page 22LEFT="0" WIDTH="90"polf()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Polygons and 
Quadrilaterals" on page 
36LEFT="0" WIDTH="90"poly()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Polygons and 
Quadrilaterals" on page 
36LEFT="0" WIDTH="90"polymode()LEFT="95" WIDTH="135"glPolygonMode()LEFT="235" WIDTH="356""Polygons and 
Quadrilaterals" on page 
36LEFT="0" WIDTH="90"polysmooth()LEFT="95" WIDTH="135"glEnable( 
GL_POLYGON_SMOOTH)LEFT="235" WIDTH="356""Antialiasing Calls" on 
page 62LEFT="0" WIDTH="90"popattributes()LEFT="95" WIDTH="135"glPopAttrib()LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"popmatrix()LEFT="95" WIDTH="135"glPopMatrix()LEFT="235" WIDTH="356""Porting Matrix and 
Transformation Calls" on 
page 22LEFT="0" WIDTH="90"popname()LEFT="95" WIDTH="135"glPopName()LEFT="235" WIDTH="356""Porting Picking Calls" 
on page 84LEFT="0" WIDTH="90"popviewport()LEFT="95" WIDTH="135"glPopAttrib()LEFT="235" WIDTH="356""Viewports, 
Screenmasks, and 
Scrboxes" on page 28LEFT="0" WIDTH="90"prefposition()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Replacing 
prefposition() with 
auxInitPosition()" on 
page 96 or Chapter 5 and 
glXIntro man pageLEFT="0" WIDTH="90"prefsize()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"pupmode()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"pushattributes()LEFT="95" WIDTH="135"glPushAttrib() LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"pushmatrix()LEFT="95" WIDTH="135"glPushMatrix()LEFT="235" WIDTH="356""Porting Matrix and 
Transformation Calls" on 
page 22LEFT="0" WIDTH="90"pushname()LEFT="95" WIDTH="135"glPushName()LEFT="235" WIDTH="356""Porting Picking Calls" 
on page 84LEFT="0" WIDTH="90"pushviewport()LEFT="95" WIDTH="135"glPushAttrib(GL_VIEWPORT)LEFT="235" WIDTH="356""Viewports, 
Screenmasks, and 
Scrboxes" on page 28LEFT="0" WIDTH="90"pwlcurve()LEFT="95" WIDTH="135"gluPWLCurve()LEFT="235" WIDTH="356""Trimming Curves" on 
page 55LEFT="0" WIDTH="90"qcontrol()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="356""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" on 
page 99 or Chapter 5 and 
glXIntro man pageLEFT="0" WIDTH="90"qdevice()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="356""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" on 
page 99 or Chapter 5 and 
glXIntro man pageLEFT="0" WIDTH="90"qenter()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="356""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" on 
page 99 or Chapter 5 and 
glXIntro man pageLEFT="0" WIDTH="90"qgetfd()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="356""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" on 
page 99 or Chapter 5 and 
glXIntro man pageLEFT="0" WIDTH="90"qread()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="356""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" on 
page 99 or Chapter 5 and 
glXIntro man pageLEFT="0" WIDTH="90"qreset()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="356""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" on 
page 99 or Chapter 5 and 
glXIntro man pageLEFT="0" WIDTH="90"qtest()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="356""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" on 
page 99 or Chapter 5 and 
glXIntro man pageLEFT="0" WIDTH="90"rcrv()LEFT="95" WIDTH="135"not supported LEFT="235" WIDTH="356""Porting Curve and 
Surface Commands" on 
page 53LEFT="0" WIDTH="90"rcrvn()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Curve and 
Surface Commands" on 
page 53LEFT="0" WIDTH="90"rdr()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Commands that 
Required Current 
Graphics Position" on 
page 19LEFT="0" WIDTH="90"readdisplay()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"readRGB()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Pixel 
Operations" on page 47LEFT="0" WIDTH="90"readsource()LEFT="95" WIDTH="135"glReadBuffer()LEFT="235" WIDTH="356""Porting Pixel 
Operations" on page 47LEFT="0" WIDTH="90"rect()LEFT="95" WIDTH="135"see glRect() and 
glPolygonMode()LEFT="235" WIDTH="356""Polygons and 
Quadrilaterals" on page 
36LEFT="0" WIDTH="90"rectf()LEFT="95" WIDTH="135"glRect()LEFT="235" WIDTH="356""Polygons and 
Quadrilaterals" on page 
36LEFT="0" WIDTH="90"rectcopy() LEFT="95" WIDTH="135"glCopyPixels()LEFT="235" WIDTH="356""Porting Pixel 
Operations" on page 47LEFT="0" WIDTH="90"rectread()LEFT="95" WIDTH="135"glReadPixels()LEFT="235" WIDTH="356""Porting Pixel 
Operations" on page 47LEFT="0" WIDTH="90"rectwrite()LEFT="95" WIDTH="135"glDrawPixels()LEFT="235" WIDTH="356""Porting Pixel 
Operations" on page 47LEFT="0" WIDTH="90"rectzoom()LEFT="95" WIDTH="135"glPixelZoom()LEFT="235" WIDTH="356""Porting Pixel 
Operations" on page 47LEFT="0" WIDTH="90"resetls()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Lines" on page 35LEFT="0" WIDTH="90"reshapeviewport()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Handling Redraw 
Events" on page 99 or 
Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"RGBcolor()LEFT="95" WIDTH="135"glColor()LEFT="235" WIDTH="356""bgn/end Commands" 
on page 31 and "Porting 
Color, Shading, and 
Writemask Commands" 
on page 44LEFT="0" WIDTH="90"RGBcursor()LEFT="95" WIDTH="135"use X for cursorsLEFT="235" WIDTH="356"† †Chapter 5, glXIntro man 
page, X documentationLEFT="0" WIDTH="90"RGBmode()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Porting Display Mode 
Initialization Calls with 
auxInitDisplayMode()" 
on page 96 or Chapter 5 
and glXIntro man pageLEFT="0" WIDTH="90"RGBrange()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"RGBwritemask()LEFT="95" WIDTH="135"glColorMask()LEFT="235" WIDTH="356""Porting Color, Shading, 
and Writemask 
Commands" on page 44LEFT="0" WIDTH="90"ringbell()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"see X documentation for 
XBell()LEFT="0" WIDTH="90"rmv()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Commands that 
Required Current 
Graphics Position" on 
page 19LEFT="0" WIDTH="90"rot()LEFT="95" WIDTH="135"glRotate()LEFT="235" WIDTH="356""Porting Matrix and 
Transformation Calls" on 
page 22LEFT="0" WIDTH="90"rotate()LEFT="95" WIDTH="135"glRotate()LEFT="235" WIDTH="356""Porting Matrix and 
Transformation Calls" on 
page 22LEFT="0" WIDTH="90"rpatch()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Curve and 
Surface Commands" on 
page 53LEFT="0" WIDTH="90"rpdr()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Commands that 
Required Current 
Graphics Position" on 
page 19 and "Polygons 
and Quadrilaterals" on 
page 36LEFT="0" WIDTH="90"rpmv()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Commands that 
Required Current 
Graphics Position" on 
page 19 and "Polygons 
and Quadrilaterals" on 
page 36LEFT="0" WIDTH="90"sbox()LEFT="95" WIDTH="135"glRect()aLEFT="235" WIDTH="356""Polygons and 
Quadrilaterals" on page 
36LEFT="0" WIDTH="90"scale()LEFT="95" WIDTH="135"glScale()LEFT="235" WIDTH="356""Porting Matrix and 
Transformation Calls" on 
page 22LEFT="0" WIDTH="90"sclear()LEFT="95" WIDTH="135"glClear( 
GL_STENCIL_BUFFER_BIT)LEFT="235" WIDTH="356""Porting Screen and 
Buffer Clearing 
Commands" on page 20 
and "Stencil Plane Calls" 
on page 64LEFT="0" WIDTH="90"scrbox()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Viewports, 
Screenmasks, and 
Scrboxes" on page 28LEFT="0" WIDTH="90"screenspace()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Matrix and 
Transformation Calls" on 
page 22LEFT="0" WIDTH="90"scrmask() LEFT="95" WIDTH="135"glScissor()LEFT="235" WIDTH="356""Viewports, 
Screenmasks, and 
Scrboxes" on page 28LEFT="0" WIDTH="90"scrnattach()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"scrnselect()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"scrsubdivide()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"select()LEFT="95" WIDTH="135"glRenderMode()LEFT="235" WIDTH="356""Porting Picking Calls" 
on page 84LEFT="0" WIDTH="90"setbell()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"see X documentation for 
XChangeKeyboardContr
ol()LEFT="0" WIDTH="90"setcursor() LEFT="95" WIDTH="135"use X for cursorsLEFT="235" WIDTH="356"Chapter 5, glXIntro man 
page and X 
documentationLEFT="0" WIDTH="90"setdblights()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"dial and button box 
documentationLEFT="0" WIDTH="90"setdepth()LEFT="95" WIDTH="135"glDepthRange()aLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"setlinestyle()LEFT="95" WIDTH="135"glLineStipple()LEFT="235" WIDTH="356""Lines" on page 35 and 
"Porting defs, binds, and 
sets: Replacing `Tables' of 
Stored Definitions" on 
page 69LEFT="0" WIDTH="90"setmap()LEFT="95" WIDTH="135"use auxiliary library or X for 
color mapsLEFT="235" WIDTH="356""Porting Color, Shading, 
and Writemask 
Commands" on page 44 
and "Using Color-Index 
Mode" on page 106 or 
Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"setmonitor()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"setnurbsproperty()LEFT="95" WIDTH="135"gluNurbsProperty()LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"setpattern()LEFT="95" WIDTH="135"glPolygonStipple() LEFT="235" WIDTH="356""Polygons and 
Quadrilaterals" on page 
36 and "Porting defs, 
binds, and sets: Replacing 
`Tables' of Stored 
Definitions" on page 69LEFT="0" WIDTH="90"setpup()LEFT="95" WIDTH="135"use X for menusLEFT="235" WIDTH="356"Chapter 5, glXIntro man 
page, X documentationLEFT="0" WIDTH="90"setvaluator()LEFT="95" WIDTH="135"use X for devicesLEFT="235" WIDTH="356"Chapter 5, glXIntro man 
page, X documentationLEFT="0" WIDTH="90"setvideo()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"shademodel()LEFT="95" WIDTH="135"glShadeModel()LEFT="235" WIDTH="356""Porting Color, Shading, 
and Writemask 
Commands" on page 44LEFT="0" WIDTH="90"shaderange()LEFT="95" WIDTH="135"glFog()LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"singlebuffer()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Porting Display Mode 
Initialization Calls with 
auxInitDisplayMode()" 
on page 96 or Chapter 5 
and glXIntro man pageLEFT="0" WIDTH="90"smoothline()LEFT="95" WIDTH="135"glEnable( GL_LINE_SMOOTH)LEFT="235" WIDTH="356""Lines" on page 35LEFT="0" WIDTH="90"spclos()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Polygons and 
Quadrilaterals" on page 
36LEFT="0" WIDTH="90"splf()LEFT="95" WIDTH="135"not supportedsee glBegin()LEFT="235" WIDTH="356""Polygons and 
Quadrilaterals" on page 
36LEFT="0" WIDTH="90"stencil()LEFT="95" WIDTH="135"glStencilFunc(),glStencilOp()LEFT="235" WIDTH="356""Stencil Plane Calls" on 
page 64LEFT="0" WIDTH="90"stensize()LEFT="95" WIDTH="135"glStencilMask()LEFT="235" WIDTH="356""Stencil Plane Calls" on 
page 64LEFT="0" WIDTH="90"stepunit()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"strwidth()LEFT="95" WIDTH="135"use X for fonts and stringsLEFT="235" WIDTH="356""Fonts and Strings" on 
page 111LEFT="0" WIDTH="90"subpixel()LEFT="95" WIDTH="135"not neededLEFT="235" WIDTH="356""Porting Antialiasing 
Calls" on page 60LEFT="0" WIDTH="90"swapbuffers()LEFT="95" WIDTH="135"glXSwapBuffers()LEFT="235" WIDTH="356"glXIntro and 
glXSwapBuffers() man 
pagesLEFT="0" WIDTH="90"swapinterval()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5LEFT="0" WIDTH="90"swaptmesh()LEFT="95" WIDTH="135"not supported, see glBegin(GL_TRIANGLE_FAN)LEFT="235" WIDTH="356""Triangles" on page 41LEFT="0" WIDTH="90"swinopen()LEFT="95" WIDTH="135"use the auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"swritemask()LEFT="95" WIDTH="135"glStencilMask()LEFT="235" WIDTH="356""Stencil Plane Calls" on 
page 64LEFT="0" WIDTH="90"t2()LEFT="95" WIDTH="135"glTexCoord2()LEFT="235" WIDTH="356""Porting Lighting and 
Materials Calls" on page 
70LEFT="0" WIDTH="90"tevbind() LEFT="95" WIDTH="135"glTexEnv()LEFT="235" WIDTH="356""Porting defs, binds, and 
sets: Replacing `Tables' of 
Stored Definitions" on 
page 69 and "Porting 
Lighting and Materials 
Calls" on page 70LEFT="0" WIDTH="90"tevdef() LEFT="95" WIDTH="135"glTexEnv()LEFT="235" WIDTH="356""Porting defs, binds, and 
sets: Replacing `Tables' of 
Stored Definitions" on 
page 69, "Porting 
Lighting and Materials 
Calls" on page 70, and 
"Translating tevdef()" on 
page 78LEFT="0" WIDTH="90"texbind()LEFT="95" WIDTH="135"glTexImage2D(),glTexParameter(),gluBuild2DMipmaps(),LEFT="235" WIDTH="356""Porting defs, binds, and 
sets: Replacing `Tables' of 
Stored Definitions" on 
page 69 and "Porting 
Texture Calls" on page 76LEFT="0" WIDTH="90"texdef2d()LEFT="95" WIDTH="135"glTexImage2D(),glTexParameter(),gluBuild2DMipmaps()LEFT="235" WIDTH="356""Porting defs, binds, and 
sets: Replacing `Tables' of 
Stored Definitions" on 
page 69, "Porting 
Lighting and Materials 
Calls" on page 70, and 
"Translating texdef()" on 
page 78LEFT="0" WIDTH="90"texgen()LEFT="95" WIDTH="135"glTexGen()LEFT="235" WIDTH="356""Porting Lighting and 
Materials Calls" on page 
70 and "Translating 
texgen()" on page 80LEFT="0" WIDTH="90"textcolor()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"textinit()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"textport()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"tie()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="356""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" on 
page 99 or Chapter 5 and 
glXIntro man pageLEFT="0" WIDTH="90"tpoff()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"tpon()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"translate()LEFT="95" WIDTH="135"glTranslate()LEFT="235" WIDTH="356""Porting Matrix and 
Transformation Calls" on 
page 22LEFT="0" WIDTH="90"underlay()LEFT="95" WIDTH="135"glXChooseVisual()LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"unqdevice()LEFT="95" WIDTH="135"use auxiliary library or X for 
event handlingLEFT="235" WIDTH="356""Event Handling: 
Replacing qdevice(), 
qtest(), and qread()" on 
page 99 or Chapter 5 and 
glXIntro man pageLEFT="0" WIDTH="90"v()LEFT="95" WIDTH="135"glVertex()LEFT="235" WIDTH="356""The v() Commands" on 
page 31LEFT="0" WIDTH="90"videocmd()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"viewport()LEFT="95" WIDTH="135"glViewport()LEFT="235" WIDTH="356""Viewports, 
Screenmasks, and 
Scrboxes" on page 28LEFT="0" WIDTH="90"winattach()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowing LEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"winclose()LEFT="95" WIDTH="135"glXDestroyContext(), 
XCloseDisplay()LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"winconstraints()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"windepth()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"window() LEFT="95" WIDTH="135"glFrustum()LEFT="235" WIDTH="356""Porting Matrix and 
Transformation Calls" on 
page 22LEFT="0" WIDTH="90"winget()LEFT="95" WIDTH="135"glXGetCurrentContext()LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"winmove()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"winopen()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Replacing winopen() 
with auxInitWindow()" 
on page 98 or Chapter 5 
and glXIntro man pageLEFT="0" WIDTH="90"winpop()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"winposition() LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"winpush()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"winset()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
and glXMakeCurrent() 
man pagesLEFT="0" WIDTH="90"wintitle()LEFT="95" WIDTH="135"use auxiliary library or X for 
windowingLEFT="235" WIDTH="356""Windowing" on page 96 
or Chapter 5 and glXIntro 
man pageLEFT="0" WIDTH="90"wmpack()LEFT="95" WIDTH="135"glColorMask()LEFT="235" WIDTH="356""Porting Color, Shading, 
and Writemask 
Commands" on page 44LEFT="0" WIDTH="90"writemask()LEFT="95" WIDTH="135"glIndexMask()LEFT="235" WIDTH="356""Porting Color, Shading, 
and Writemask 
Commands" on page 44LEFT="0" WIDTH="90"writepixels()LEFT="95" WIDTH="135"glDrawPixels()LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"writeRGB()LEFT="95" WIDTH="135"glDrawPixels()LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"xfpt()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356""Porting Picking Calls" 
on page 84 and "Porting 
Feedback Calls" on page 
90LEFT="0" WIDTH="90"zbuffer()LEFT="95" WIDTH="135"glEnable(GL_DEPTH_TEST)LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"zclear()LEFT="95" WIDTH="135"glClear( 
GL_DEPTH_BUFFER_BIT)LEFT="235" WIDTH="356""Porting Screen and 
Buffer Clearing 
Commands" on page 20LEFT="0" WIDTH="90"zdraw()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"zfunction()LEFT="95" WIDTH="135"glDepthFunc()LEFT="235" WIDTH="356"LEFT="0" WIDTH="90"zsource()LEFT="95" WIDTH="135"not supportedLEFT="235" WIDTH="356"LEFT="0" WIDTH="90"zwritemask()LEFT="95" WIDTH="135"glDepthMask()LEFT="235" WIDTH="356""Porting Color, Shading, 
and Writemask 
Commands" on page 44LBL="a" ID="appen.ATF0a"note that this is not a direct equivalent of IRIS GL functionalityname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'be careful when portingLBL="B"ID="71689"OpenGL/IRIS GL DifferencesThis appendix contains a list of OpenGL and IRIS GL differences. Each difference is given a simple name, followed by a description.accumulation wrappingOpenGL accumulation buffer operation is not defined when component values exceed 1.0 or go below -1.0.antialiased lines OpenGL stipples antialiased lines. IRIS GL does not.arc OpenGL supports arcs in its utility library. attribute lists The attributes pushed by IRIS GL pushattributes() differ from any of the attribute sets that are pushed by OpenGL glPushAttrib(). Because all OpenGL states can be read back, however, it is possible to implement any desired push/pop semantics using the OpenGL API.automatic texture scalingThe OpenGL texture interface does not support automatic scaling of images to power-of-two dimensions. However, the GLU supports image scaling.bbox OpenGL does not support conditional execution of display lists. callfunc OpenGL does not support callback from display lists. Note that IRIS GL also did not support this functionality when client and server were on different platforms.circle OpenGL supports circles in the GLU. In OpenGL both circles and arcs (disks and partial disks) can have holes. Also, subdivision of the primitives can be changed in OpenGL and the primitives' surface normals are available for lighting.clear optionsOpenGL really clears buffers. It does not apply currently-specified pixel operations, such as blending and logicop, regardless of their modes. To clear using such features, you must render a window-size polygon.closed lines OpenGL renders all single-width aliased lines such that abutting lines share no pixels. This means that the "last" pixel of an independent line is not drawn.color/normal flag OpenGL lighting is explicitly enabled or disabled. When enabled, it is effective regardless of the order in which colors and normals are specified.Lighting cannot be enabled or disabled between OpenGL glBegin() and glEnd() commands. If you need to disable lighting between glBegin() and glEnd(), you must do it by specifying zero ambient, diffuse, and specular material reflectance. Then set the material emission to the desired color.concave polygons The core OpenGL API does not handle concave polygons, but the GLU does provide support for decomposing concave, non-self-intersecting contours into triangles. These triangles can either be draw immediately or returned.current computed color OpenGL has no notion of a current computed color. If you're using OpenGL as a lighting engine, you can use feedback to obtain colors generated by lighting calculations. current graphics position OpenGL does not maintain a current graphics position. IRIS GL commands that depended on current graphics position, such as relative lines and polygons, are not included in OpenGL. curves OpenGL does not support IRIS GL curves. Use of NURBS curves is recommended.defs/binds OpenGL does not have the concept of a material, light, or texture objects, only of material, light, and texture properties. OpenGL programmers can use display lists to create their own objects, however. depthcue OpenGL provides no direct support for depth cueing. However, its fog support is a more general capability that you can easily use to emulate IRIS GL depthcue().display list editingOpenGL display lists cannot be edited, only created and destroyed. Because display list names are specified by the programmer, however, it is possible to redefine individual display lists in a hierarchy.OpenGL display lists are designed for data caching, not for data base management. They are guaranteed to be stored on the server in client/server environments, so they are not limited by network bandwidth during execution.OpenGL display lists can be called between† †glBegin() and glEnd() commands, so the display list hierarchy can be made fine enough that it can, in effect, be edited.error checkingOpenGL checks for errors more carefully than IRIS GL. For example, all OpenGL commands that are not accepted between glBegin() and glEnd() are detected as errors, and have no other effect. error return valuesWhen an OpenGL command that returns a value detects an error, it always returns zero. OpenGL commands that return data through passed pointers make no change to the array contents if an error is detected.error side effectsWhen an OpenGL command results in an error, its only side effect is to update the error flag to the appropriate value. No other state changes are made. (Exception is the OUT_OF_MEMORY error, which is fatal.)feedback In OpenGL, feedback is standardized so that it doesn't change from machine to machine. explains how to port your IRIS GL feedback calls.fonts and stringsOpenGL expects character glyphs to be manipulated as individual display lists. It provides a display list calling function that accepts a list of display list names, each name represented as 1, 2, or 4 bytes.† †glCallLists() adds a separately specified offset to each display list name before the call, allowing lists of display list names to be treated as strings. This mechanism provides all the functionality of IRIS GL fonts, and considerably more. For example, characters comprised of triangles can be easily manipulated. frontbufferIRIS GL had complex rules for defeating rendering to the front buffer in singlebuffer mode. OpenGL does as it is asked in this regard.hollow polygonsOpenGL does not support hollow polygons. However, you can use the OpenGL stencil capability to render hollow polygons.index clampingWhere possible, OpenGL treats color and stencil indexes as bitfields rather than numbers. Thus indexes are masked, rather than clamped, to the supported range of the framebuffer.integer colorsSigned integer color components (red, green, blue, or alpha) are linearly mapped to floating point such that the most negative integer maps to -1.0 and the most positive integer maps to 1.0. This mapping occurs when the color is specified, before it replaces the current color.Unsigned integer color components are linearly mapped to floating point such that 0 maps to 0.0 and the largest representable integer maps to 1.0. This mapping occurs when the color is specified, before it replaces the current color.integer normalsInteger normal components are mapped just like signed color components, such that the most negative integer maps to -1.0, and the most positive integer maps to 1.0. pixel fragmentsPixels drawn by glDrawPixels() or glCopyPixels() are always rasterized and converted to fragments. The resulting fragments are textured, fogged, depth buffered, blended, etc. just as if they had be generated from geometric points. Fragment data that are not provided by the source pixels are augmented from the current raster position. For example, RGBA pixels take the raster position Z and texture coordinates. Depth pixels take the raster position color and texture coordinates.invarianceOpenGL guarantees certain invariances that IRIS GL does not. For example, OpenGL guarantees that identical code sequences sent to the same system, differing only in the blending function specified, will generate the same pixel fragments. (The fragments may be different if blending is enabled and disabled, however.)lighting equation The OpenGL lighting equation differs slightly from the IRIS GL equation. OpenGL supports separate attenuation for each light source, rather than a single attenuation for all the light sources as in IRIS GL, and OpenGL regularizes the equation so that ambient, diffuse, and specular lighting contributions are all attenuated. Also, OpenGL allows separate colors to be specified for the ambient, diffuse, and specular intensities of light sources, as well as for the ambient, diffuse, and specular reflectance of materials. All OpenGL light and material colors include alpha.Setting the specular exponent to zero does NOT defeat specular lighting in OpenGL.mapw OpenGL utilities support mapping between object and window coordinates.matrix modeAll OpenGL matrix operations operate on the current matrix, rather than on a particular matrix, as do the IRIS GL ortho(), ortho2(),† †perspective(), and window() commands. All OpenGL matrix operations except glLoadIdentity() and glLoadMatrix() multiply the current matrix rather than replacing it (as do ortho(),† †ortho2(),† †perspective(), and window() in the IRIS GL).mipmaps, automatic generationThe OpenGL texture interface does not support automatic generation of mipmap images. However, automatic generation of mipmap images is supported by GLU for both 1D and 2D textures.move/draw/pmove/pdraw/pclos OpenGL supports only Begin/End style graphics, because it does not maintain a current graphics position. The scalar parameter specification of the old move/draw commands is accepted by OpenGL for all vertex related commands, however.mprojection modeIRIS GL did not transform geometry by the ModelView matrix while in Projection matrix mode. OpenGL always transforms by both the ModelView and the Projection matrix, regardless of matrix mode. multi-buffer drawingOpenGL renders to each color buffer individually, rather than computing a single new color value based on the contents of one color buffer and writing it to all the enabled color buffers, as IRIS GL did.NURBS OpenGL supports NURBS with a combination of core capability (evaluators) and GLU support. All IRIS GL NURBS capabilities are supported.old polygon modeAliased OpenGL polygons are always point sampled. The old polygon compatibility mode of the IRIS GL, where pixels outside the polygon perimeter were included in its rasterization, is not supported. If your code uses old polygon mode, it's probably for rectangles. Old polygon mode rectangles appear one pixel wider and higher. packed color formats OpenGL accepts colors as 8-bit components, but these components are treated as an array of bytes rather than as bytes packed into larger words. By encouraging array indexing rather than shifting, OpenGL promotes endian-invariant programming.Just as IRIS GL accepted packed colors both for geometric and pixel rendering, OpenGL accepts arrays of color components for geometric and pixel rendering.patches OpenGL does not support IRIS GL patches. Use of evaluators is recommended.per-bit color writemask OpenGL writemasks for color components enable or disable changes to the entire component (red, green, blue, or alpha), not to individual bits of components. Note that per-bit writemasks are supported for both color indexes and stencil indexes, however.per-bit depth writemask OpenGL writemasks for depth components enable or disable changes to the entire component, not to individual bits of the depth component.pick The OpenGL utility library includes support for generating a pick matrix.pixel coordinates OpenGL and IRIS GL agree that the origin of a window's coordinate system is at its lower left corner. OpenGL places the origin at the lower left corner of this pixel, however, while IRIS GL placed it at the center of the lower left pixel.pixel zoomOpenGL negative zoom factors reflect about the current graphics position. IRIS GL doesn't define the operation of negative zoom factors, and instead provides RIGHT_TO_LEFT and TOP_TO_BOTTOM reflection pixmodes. These reflection modes reflect in place, rather than about the current raster position. OpenGL doesn't define reflection modes. pixmodeOpenGL pixel transfers operate on individual color components, rather than on packed groups of 4 8-bit components as does IRIS GL. While OpenGL provides substantially more pixel capability than IRIS GL, it does not support packed color constructs, and it does not allow color components to be reassigned (red to green, red to blue, etc.) during pixel copy operations.polf/poly OpenGL provides no direct support for vertex lists other than display lists. Functions like polf() and poly() can easily be implemented using the OpenGL API, however.polygon provoking vertex Flat shaded IRIS GL polygons took the color of the last vertex specified, while OpenGL polygons take the color of the first vertex specified.polygon stipple In IRIS GL the polygon stipple pattern was screen-relative. In OpenGL it is window-relative.polygon vertex count There is no limit to the number of vertexes between glBegin() and† †glEnd() in OpenGL, even for glBegin(POLYGON). In IRIS GL polygons are limited to no more than 255 vertexes.readdisplay Reading pixels outside window boundaries is properly a window system capability, rather than a renderer capability. We will propose an extension to X to replace the IRIS GL readdisplay command.relative move/draw/pmove/pdraw/pclos OpenGL does not maintain a current graphics position, and therefore is unable to support relative vertex operations. reset linestyle IRIS GL resetls() has not been supported for some time, and is not supported by OpenGL.RGBA logicop() OpenGL does not support logical operations on RGBA buffers. sbox() sbox() is an IRIS GL rectangle primitive that is well defined only if transformed without rotation, and is designed to be faster than standard rectangles. While OpenGL does not support such a primitive, it can be tuned to render rectangles very quickly when the matrixes and other modes are in states that simplify calculations. scalar argumentsAll OpenGL commands that are accepted between glBegin() and glEnd() have entry points that accept scalar arguments. For example, glColor4f(red,green,blue,alpha).scissorOpenGL glScissor() does not track the viewport. The IRIS GL viewport() command automatically updates the scrmask.scrbox() OpenGL does not support bounding box computation.scrsubdivide() Screen subdivision is not supported by OpenGL.single matrix mode OpenGL always maintains two matrixes: ModelView and Projection. While an OpenGL implementation may consolidate these into a single matrix for performance reasons, it must always present the 2-matrix model to the programmer.subpixel modeAll OpenGL rendering is subpixel positionedname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'subpixel mode is always on.swaptmesh() OpenGL does not support the† †swaptmesh() capability. It does offer two types of triangle meshes, however: one that corresponds to the default "strip" behavior of the IRIS GL, and another that corresponds to calling swaptmesh() prior to the third and all subsequent vertexes when using IRIS GL.vector argumentsAll OpenGL commands that are accepted between glBegin() and glEnd() have entry points that accept vector arguments. For example, glColor4fv(v).window management OpenGL includes no window system commands. It is always supported as an extension to a window or operating system that includes capability for device and window control. Each extension provides a system-specific mechanism for creating, destroying, and manipulating OpenGL rendering contexts. For example, the OpenGL extension to the X window system (GLX) includes roughly 10 commands for this purpose.IRIS GL commands such as gconfig() and drawmode() are not implemented by OpenGL.window offsetIRIS GL returned viewport and character position in screen, rather than window, coordinates. OpenGL always deals with window coordinates.z renderingOpenGL does not support rendering colors to the depth buffer. It does allow for additional color buffers, which can be implemented using the same memory that is used for depth buffers in other window configurationsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'but these additional color buffers cannot share memory with the depth buffer in any single configuration.LBL="C"ID="18405"Some Important OpenGL BasicsThis appendix provides a bit of background information on OpenGL command names, OpenGL defined types, and OpenGL error handling. It is intended mainly as a brief, quick reference. For more detailed information, refer to the OpenGL Programming Guide.LBL="" HELPID=""ID="63238"OpenGL Command NamesThis section describes the naming convention for OpenGL calls. For a complete list of OpenGL equivalents to IRIS GL routines, see IDREF="39727" TYPE="TITLE"Appendix A, "OpenGL Commands and Their IRIS GL Equivalents."OpenGL commands begin with the gl prefix (glEnable(), glTranslatef(), and so on). OpenGL Utility Library (GLU) commands all begin with the glu prefix (gluDisk(), gluErrorString(), and so on). The commands that comprise the OpenGL extension to X (GLX) all begin with the glX prefix (glXChooseVisual(), glXCopyContext(), and so on). The commands that comprise the OpenGL auxiliary library begin with the aux prefix (auxWireCone(), auxSolidTeapot(), and so on).OpenGL commands are formed by a root name followed by up to four characters. The first character indicates the number of arguments. The second character, or pair or characters, specifies the type of the arguments. IDREF="30548" TYPE="TABLE"Table C-1
 lists the character suffixes and the corresponding argument types (some of these values might be different on a 64-bit architecture).COLUMNS="3"LBL="C-1"Table C-1 ID="30548"Command Suffixes and Corresponding Argument TypesLEFT="0" WIDTH="45"LetterLEFT="50" WIDTH="135"TypeLEFT="190" WIDTH="356"C TypebLEFT="0" WIDTH="135"8-bit integerLEFT="140" WIDTH="113"charsLEFT="0" WIDTH="135"16-bit integerLEFT="140" WIDTH="113"shortLEFT="0" WIDTH="45"iLEFT="50" WIDTH="135"32-bit integerLEFT="190" WIDTH="356"longLEFT="0" WIDTH="45"fLEFT="50" WIDTH="135"32-bit floating pointLEFT="190" WIDTH="356"floatLEFT="0" WIDTH="45"dLEFT="50" WIDTH="135"64-bit floating pointLEFT="190" WIDTH="356"doubleLEFT="0" WIDTH="45"ubLEFT="50" WIDTH="135"8-bit unsigned integerLEFT="190" WIDTH="356"unsigned charLEFT="0" WIDTH="45"usLEFT="50" WIDTH="135"16-bit unsigned integerLEFT="190" WIDTH="356"unsigned shortLEFT="0" WIDTH="45"uiLEFT="50" WIDTH="135"32-bit unsigned integerLEFT="190" WIDTH="356"unsigned longThe final character, if present, is v. The v indicates that the command takes a pointer to an array of valuesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'a vectorname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'rather than a series of individual arguments. The IRIS GL used a similar mechanism for some commands. The predecessor to glVertex(), for example, was v(), which also used a suffix to specify the number and type of its arguments.Here are some examples of OpenGL command naming:void glVertex2i( GLint x, GLint y) ;void glVertex3f( GLfloat x, GLfloat y, GLfloat z);
void glVertex3dv( const GLdouble *v) ;The first version of the vertex call, glVertex2i(), takes two integer arguments. The second, glVertex3f(), is a three-dimensional version, which expects three floats. The third version, glVertex3dv() expects an argument in the form of a vector, which is a pointer to an array. In this case, the array should have three elements.LBL="" HELPID=""ID="68221"OpenGL Defined TypesCOLUMNS="2"LBL="C-2"Table C-2 ID="70682"OpenGL Equivalents to C Data TypesLEFT="0" WIDTH="171"C TypeLEFT="180" WIDTH="356"Equivalent OpenGL TypeLEFT="0" WIDTH="171"bitmask valueLEFT="180" WIDTH="356"GLbitfieldLEFT="0" WIDTH="171"boolean valueLEFT="180" WIDTH="356"GLbooleanLEFT="0" WIDTH="171"doubleLEFT="180" WIDTH="356"GLdoubleLEFT="0" WIDTH="171"double value clamped to [ 0.0, 1.0 ]LEFT="180" WIDTH="356"GLclampdLEFT="0" WIDTH="171"enumerated typeLEFT="180" WIDTH="356"GLenumLEFT="0" WIDTH="171"floatLEFT="180" WIDTH="356"GLfloatLEFT="0" WIDTH="171"float value clamped to [ 0.0, 1.0 ]LEFT="180" WIDTH="356"GLclampfLEFT="0" WIDTH="171"longLEFT="180" WIDTH="356"GLintLEFT="0" WIDTH="171"shortLEFT="180" WIDTH="356"GLshortLEFT="0" WIDTH="171"signed charLEFT="180" WIDTH="356"GLbyteLEFT="0" WIDTH="171"unsigned charLEFT="180" WIDTH="356"GLubyteLEFT="0" WIDTH="171"unsigned intLEFT="180" WIDTH="356"GLuintLEFT="0" WIDTH="171"unsigned shortLEFT="180" WIDTH="356"GLushortLEFT="0" WIDTH="171"voidLEFT="180" WIDTH="356"GLvoidIDREF="70682" TYPE="TABLE"Table C-2LBL="" HELPID=""ID="99378"Error HandlingWhen an error occurs, OpenGL sets an error flag to the appropriate error value. You can test error conditions using the glGetError() call, which returns the error number. IDREF="21378" TYPE="TABLE"Table C-3
 lists possible error values. For details, see the man page for glGetError().COLUMNS="3"LBL="C-3"Table C-3 ID="21378"glGetError() Return ValuesLEFT="0" WIDTH="113"ErrorLEFT="120" WIDTH="113"DescriptionLEFT="240" WIDTH="356"Command Ignored?LEFT="0" WIDTH="113"NO_ERRORLEFT="120" WIDTH="113"No errorLEFT="240" WIDTH="356"NoLEFT="0" WIDTH="113"INVALID_ENUMLEFT="120" WIDTH="113"enumerated argument out 
of rangeLEFT="240" WIDTH="356"YesLEFT="0" WIDTH="113"INVALID_VALUELEFT="120" WIDTH="113"Numeric argument out of 
rangeLEFT="240" WIDTH="356"YesLEFT="0" WIDTH="113"INVALID_OPERATIONLEFT="120" WIDTH="113"Operation illegal in current 
stateLEFT="240" WIDTH="356"YesLEFT="0" WIDTH="113"STACK_OVERFLOWLEFT="120" WIDTH="113"Command would cause a 
stack overflowLEFT="240" WIDTH="356"YesLEFT="0" WIDTH="113"STACK_UNDERFLOWLEFT="120" WIDTH="113"Command would cause a 
stack underflowLEFT="240" WIDTH="356"YesLEFT="0" WIDTH="113"OUT_OF_MEMORYLEFT="120" WIDTH="113"Not enough memory left to 
execute commandLEFT="240" WIDTH="356"UnknownLBL="D"ID="13844"Example OpenGL Program with the Auxiliary LibraryThis program uses OpenGL and the auxiliary library to display a planet rotating around the sun. It demonstrates how to composite modeling transformations to draw translated and rotated models. Pressing the left, right, up, and down arrow keys alters the rotation of the planet around the sun./*
† †*  planet.c
† †*/

#include <GL/gl.h>
#include <GL/glu.h>
#include "aux.h"

static int year = 0, day = 0;

void dayAdd (void)
{
† †   day = (day + 10) % 360;
}

void daySubtract (void)
{
† †   day = (day - 10) % 360;
}

void yearAdd (void)
{
† †   year = (year + 5) % 360;
}
void yearSubtract (void)
{
† †   year = (year - 5) % 360;
}

void display(void)
{
† †   glClear(GL_COLOR_BUFFER_BIT);

† †   glColor3f (1.0, 1.0, 1.0);
† †   glPushMatrix();
/*      draw sun        */
† †   auxWireSphere(1.0);
/*      draw smaller planet     */
† †   glRotatef ((GLfloat) year, 0.0, 1.0, 0.0);
† †   glTranslatef (2.0, 0.0, 0.0);
† †   glRotatef ((GLfloat) day, 0.0, 1.0, 0.0);
† †   auxWireSphere(0.2);
† †   glPopMatrix();
† †   glFlush();
}

void myinit (void) {
† †   glShadeModel (GL_FLAT);
}

void myReshape(GLsizei w, GLsizei h)
{
† †   glViewport(0, 0, w, h);
† †   glMatrixMode(GL_PROJECTION);
† †   glLoadIdentity();
† †   gluPerspective(60.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
† †   glMatrixMode(GL_MODELVIEW);
† †   glLoadIdentity();
† †   glTranslatef (0.0, 0.0, -5.0);
}
/*  Main Loop
† †*  Open window with initial window size, title bar,
† †*  RGBA display mode, and handle input events.
† †*/
int main(int argc, char** argv)
{
† †   auxInitDisplayMode (AUX_SINGLE | AUX_RGBA);
† †   auxInitPosition (0, 0, 500, 500);
† †   auxInitWindow (argv[0]);
† †   myinit ();
† †   auxKeyFunc (AUX_LEFT, yearSubtract);
† †   auxKeyFunc (AUX_RIGHT, yearAdd);
† †   auxKeyFunc (AUX_UP, dayAdd);
† †   auxKeyFunc (AUX_DOWN, daySubtract);
† †   auxReshapeFunc (myReshape);
† †   auxMainLoop(display);
}
LBL="E"ID="77823"Example Mixed-Model Program with WorkProcThis appendix contains an example mixed model program that uses Xt, IRIS IM, and the IRIS IM version of the Silicon Graphics widget. The program displays a planet with a moon, orbiting a sun, and uses WorkProc for the animation./* opensolar.c
† †* opensolar displays a planet with a moon, orbiting a sun.
† †* Add ESCape key for exit.
† †* Add WorkProc and motion.
† †*/

#include <Xm/Xm.h>
#include <Xm/Frame.h>
#include <Xm/Form.h>
#include <X11/keysym.h>
#include <X11/StringDefs.h>
#include "GlxMDrawA.h"

#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glx.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "malloc.h"

typedef struct _spin {
† †short year;
} SPINDATA, *SPINPTR;
/* function prototypes
† †*/

void main(int argc, char **argv);

void initCB (Widget w, XtPointer client_data, XtPointer call_data);
void exposeCB (Widget w, XtPointer spin, XtPointer call_data);
void resizeCB (Widget w, XtPointer spin, XtPointer call_data);
void inputCB (Widget w, XtPointer client_data, XtPointer call_data);

Boolean drawWP (XtPointer spin);

void drawscene(SPINPTR spin);
void setbeachball(int stripes);
void beachball(unsigned long color1, unsigned long color2);

XtAppContext app_context;
XtWorkProcId workprocid = NULL;

GLXContext glx_context;
Display * global_display;
Window global_window;

/* main
† †* This program shows a solar system, with a sun, planet, and
† †* moon (in OpenGL).
† †* The user can exit with the ESCape key or through the
† †* window manager menu.
† †*/

void main(int argc, char **argv)
{
† †Arg wargs[15];
† †int n;
† †Widget glw, toplevel, frame, form;
† †SPINPTR spin;
† †static String fallback_resources[] = {
† †"*frame*shadowType: SHADOW_IN",
† †"*glwidget*width: 750",
† †"*glwidget*height: 600",
† †"*glwidget*rgba: TRUE",
† †"*glwidget*doublebuffer: TRUE",
† †"*glwidget*allocateBackground: TRUE",
† †NULL
† †};

† †/* create main data structure, spin pointer */
† †spin = (SPINPTR) malloc (sizeof (SPINDATA));
† †spin->year = 0;
† †toplevel = XtAppInitialize(
† †&app_context, /* Application context */
† †"Opensolar", /* Application class */
† †NULL, 0, /* command line option list */
† †&argc, argv, /* command line args */
† †fallback_resources,
† †NULL, /* argument list */
† †0); /* number of arguments */

† †n = 0;
† †form = XmCreateForm(toplevel, "form", wargs, n);
† †XtManageChild(form);

† †n = 0;
† †XtSetArg(wargs[n], XtNx, 30); 
† †n++;
† †XtSetArg(wargs[n], XtNy, 30); 
† †n++;
† †XtSetArg(wargs[n], XmNbottomAttachment, XmATTACH_FORM); 
† †n++;
† †XtSetArg(wargs[n], XmNleftAttachment, XmATTACH_FORM); 
† †n++;
† †XtSetArg(wargs[n], XmNrightAttachment, XmATTACH_FORM); 
† †n++;
† †XtSetArg(wargs[n], XmNtopAttachment, XmATTACH_FORM); 
† †n++;
† †XtSetArg(wargs[n], XmNleftOffset, 30); 
† †n++;
† †XtSetArg(wargs[n], XmNbottomOffset, 30); 
† †n++;
† †XtSetArg(wargs[n], XmNrightOffset, 30); 
† †n++;
† †XtSetArg(wargs[n], XmNtopOffset, 30); 
† †n++;
† †frame = XmCreateFrame (form, "frame", wargs, n);
† †XtManageChild (frame);

† †n = 0;
† †glw = GlxCreateMDrawingArea(frame, "glwidget", wargs, n);
† †XtManageChild (glw);
† †XtAddCallback(glw, GlxNginitCallback, initCB,
† †              (XtPointer) NULL);
† †XtAddCallback(glw, GlxNexposeCallback, exposeCB,
† †              (XtPointer) spin);
† †XtAddCallback(glw, GlxNresizeCallback, resizeCB,
† †              (XtPointer) spin);
† †XtAddCallback(glw, GlxNinputCallback, inputCB,
† †              (XtPointer) NULL);

† †XtRealizeWidget(toplevel); /* instantiate it now */
† †XtAppMainLoop(app_context); /* loop for events */
} /* end main() */

/* initCB 
† †* The initCB subroutine initializes graphics modes and
† †* transformation matrices.
† †*/

void initCB (Widget w, XtPointer client_data, XtPointer call_data)
{
† †Arg args[1];
† †XVisualInfo *vi;

† †XtSetArg(args[0], GlxNvisualInfo, &vi);
† †XtGetValues(w, args, 1);

† †global_display = XtDisplay(w);
† †global_window = XtWindow(w);
† †glx_context = glXCreateContext(global_display, vi, 0,
† †                               GL_FALSE);
} /* end initCB() */
/* exposeCB() and resizeCB() are called when the window
† †* is uncovered, moved, or resized.
† †*/

void exposeCB (Widget w, XtPointer ptr, XtPointer call_data)
{
† †SPINPTR spin;
† †static char firstTime = 0x1;
† †GlxDrawingAreaCallbackStruct *call_ptr;

† †call_ptr = (GlxDrawingAreaCallbackStruct *) call_data;
† †GlxDrawingAreaMakeCurrent(w, glx_context);
† †if (firstTime) {
† †  glClearColor(0.0, 0.0, 0.0, 0.0);
† †  glShadeModel (GL_FLAT);
† †  glEnable(GL_DEPTH_TEST);
† †  glMatrixMode(GL_PROJECTION);
† †  glLoadIdentity ();
† †  gluPerspective(45.0, (GLfloat)(call_ptr->width)
† †                 /(GLfloat)(call_ptr->height), 1.0, 25.0);
† †  glMatrixMode(GL_MODELVIEW);
† †  glLoadIdentity ();
† †  glTranslatef(0.0, 0.0, -12.0);
† †  workprocid = XtAppAddWorkProc 
† †               (app_context, drawWP, ptr); /* ptr is spin */
† †  firstTime = 0;
† †}
† †spin = (SPINPTR) ptr;
† †drawscene(spin);
}

void resizeCB (Widget w, XtPointer ptr, XtPointer call_data)
{
† †GlxDrawingAreaCallbackStruct *call_ptr;
† †SPINPTR spin;

† †spin = (SPINPTR) ptr;
† †call_ptr = (GlxDrawingAreaCallbackStruct *) call_data;
† †GlxDrawingAreaMakeCurrent(w, glx_context);
† †glViewport (0, 0, (GLsizei) (call_ptr->width-1),
† †            (GLsizei) (call_ptr->height-1));
† †glMatrixMode(GL_PROJECTION);
† †glLoadIdentity ();
† †gluPerspective(45.0, (GLfloat)(call_ptr->width)
† †               /(GLfloat)(call_ptr->height), 1.0, 25.0);
† †glMatrixMode(GL_MODELVIEW);
† †glLoadIdentity ();
† †glTranslatef(0.0, 0.0, -12.0);
† †drawscene(spin);
}

/* inputCB() handles all types of input from the GL widget.
† †* The KeyRelease handles the ESCape key, so that it exits
† †* the program. 
† †*/
void inputCB (Widget w, XtPointer client_data, XtPointer call_data)
{
† †char buffer[1];
† †KeySym keysym;
† †GlxDrawingAreaCallbackStruct *call_ptr;
† †XKeyEvent *kevent;

† †call_ptr = (GlxDrawingAreaCallbackStruct *) call_data;
† †kevent = (XKeyEvent *) (call_ptr->event);
† †switch(call_ptr->event->type) {
† †case KeyRelease:
† †/* It is necessary to convert the keycode to a keysym before
† †* it is possible to check if it is an escape
† †*/
† †if (XLookupString(kevent,buffer,1,&keysym,NULL) == 1 
† †                  && keysym == (KeySym)XK_Escape)
† †    exit(0);
† †  break;
† †default:
† †  break;
† †}
}
/* drawWP() is called by the WorkProc. When the scene
† †* is in automatic motion, the WorkProc calls this routine,
† †* which adds 1 degree (10 tenths) to the cumulative amount
† †* of rotation. drawscene() is called, so the image is
† †* redrawn. It returns(FALSE) so the WorkProc does not
† †* discontinue operation.
† †*/

Boolean drawWP (XtPointer ptr)
{
† †SPINPTR spin;

† †spin = (SPINPTR) ptr;
† †spin->year = (spin->year + 10) % 3600;
† †drawscene (spin);
† †return (FALSE);
}

/* drawscene
† †* drawscene calculates angles relative to the spin->year
† †* and then draws sun, planet, and moon.
† †*/
void drawscene(SPINPTR spin)
{
† †short sunangle;
† †float earthdist = 4.5; /* actual 1.5e8 kM * 3.0e-9 fudgefactor */
† †short dayangle;
† †float earthscale = 0.5;
† †short monthangle;
† †float moondist = 0.9;
† †float moonscale = 0.2;

† †glClear(GL_DEPTH_BUFFER_BIT|GL_COLOR_BUFFER_BIT);

† †glPushMatrix();
† †glRotatef(10.0, 1.0, 0.0, 0.0); /* tilt entire scene slightly */
† †glPushMatrix();
† †sunangle = (spin->year*365/25) % 3600;
† †/* sun rotates on axis every 25 days */
† †glRotatef(.1*(sunangle), 0.0, 1.0, 0.0);
† †/* cpack format color1, color2 */
† †/* swapped by hand: was beachball(0x20C0FF, 0x200FFFF); */
† †beachball(0xFFC02000, 0xFFFF0020);
† †glPopMatrix();
† †glPushMatrix();
† †glRotatef(.1*(spin->year), 0.0, 1.0, 0.0);
† †glTranslatef(earthdist, 0.0, 0.0);
† †glPushMatrix();
† †dayangle = (spin->year*50) % 3600;
† †/* dayangle fudged so earth rotation can be seen */
† †glRotatef(.1*(dayangle), 0.0, 1.0, 0.0);
† †glScalef(earthscale, earthscale, earthscale);
† †glColor3f(0.0, 0.0, 1.0);
† †/* swap by hand; was beachball(0xFF0000, 0xC02000);*/
† †beachball(0x0000FF00, 0x0020C000); /* earth */
† †glPopMatrix();
† †monthangle = (spin->year*365/28) % 3600;
† †glRotatef(.1*(monthangle), 0.0, 1.0, 0.0);
† †glTranslatef(moondist, 0.0, 0.0);
† †glScalef(moonscale, moonscale, moonscale);
† †glColor3f(1.0, 1.0, 1.0);
† †/* swap by hand; was beachball(0xFFFFFF, 0xC0C0C0); */
† †beachball(0xFFFFFF00, 0xC0C0C000); /* moon */
† †glPopMatrix();
† †glPopMatrix();
† †glXSwapBuffers(global_display, global_window);
} /* end drawscene() */


/*
† †* BEACHBALL
† †*/
/* three dimensional vector */
typedef float vector[3];

vector front =  { 0.0, 0.0, 1.0 };
vector back =   { 0.0, 0.0, -1.0 };
vector top =    { 0.0, 1.0, 0.0 };
vector bottom = { 0.0, -1.0, 0.0 };
vector right =  { 1.0, 0.0, 0.0 };
vector left =   { -1.0, 0.0, 0.0 };
vector center = { 0.0, 0.0, 0.0 };

/* Number of colored stripes. Should be even to look right */
#define BEACHBALL_STRIPES 12
/* Default number of polygons making up a stripe. Should be even */
#define BEACHBALL_POLYS 16

/* array of vertices making up a stripe */
vector stripe_point[BEACHBALL_POLYS + 3];

/* has the beachball been initialized */
Boolean beachball_initialized = FALSE;

/* Number of polygons making up a stripe */
int beachball_stripes;

/* Number of vertices making up a stripe */
int stripe_vertices;

/*
† †* Initializes beachball_point array to a stripe of unit radius.
† †*/
void setbeachball(int stripes)
{
† †int i,j;
† †float x,y,z; /* vertex points */
† †float theta,delta_theta; /* angle from top pole to bottom pole */
† †float offset; /* offset from center of stripe to vertex */
† †float cross_radius; /* radius of cross section at current latitude */
† †float cross_theta; /* angle occupied by a stripe */

† †beachball_stripes = stripes;

† †/* polys distributed by even angles from top to bottom */
† †delta_theta = M_PI/((float)BEACHBALL_POLYS/2.0);
† †theta = delta_theta;
† †cross_theta = 2.0*M_PI/(float)beachball_stripes;

† †j = 0;
† †stripe_point[j][0] = top[0];
† †stripe_point[j][1] = top[1];
† †stripe_point[j][2] = top[2];
† †j++;
† †for (i = 0; i < BEACHBALL_POLYS; i += 2) {
† †  cross_radius = fsin(theta);
† †  offset = cross_radius * ftan(cross_theta/2.0);

† †  stripe_point[j][0] = - offset;
† †  stripe_point[j][1] = fcos(theta);
† †  stripe_point[j][2] = cross_radius;
† †  j++;

† †  stripe_point[j][0] = offset;
† †  stripe_point[j][1] = stripe_point[j-1][1];
† †  stripe_point[j][2] = stripe_point[j-1][2];
† †  j++;

† †  theta += delta_theta;
† †} /* end for */

† †stripe_point[j][0] = bottom[0];
† †stripe_point[j][1] = bottom[1];
† †stripe_point[j][2] = bottom[2];

† †stripe_vertices = j + 1;

† †beachball_initialized = TRUE;
}

/*
† †* Draws a canonical beachball. The colors are cpack values 
† †* when in RGBmode.
† †*/
void beachball(unsigned long c1, unsigned long c2)
{
† †float angle, delta_angle;
† †int i, j;

† †if (! beachball_initialized)
† †  setbeachball(BEACHBALL_STRIPES);

† †angle = 0.0;
† †delta_angle = 360.0/(float)beachball_stripes;
† †for (i = 0; i < beachball_stripes; i++) {
† †  if ( i%2 == 0)
† †    glColor4ubv((GLubyte *)(&c1));
† †  else
† †    glColor4ubv((GLubyte *)(&c2));
† †  glPushMatrix();
† †  glRotatef(angle, 0.0, 1.0, 0.0);
† †  angle += delta_angle;

† †  glBegin(GL_TRIANGLE_STRIP);
† †  for (j = 0; j < stripe_vertices; j++)
† †    glVertex3fv(stripe_point[j]);
† †  glEnd();
† †  glPopMatrix();
† †}
}LBL="F"ID="77823"Example Mixed-Model Programs With XlibThis appendix contains two example mixed model programs that use Xlib. Each example program is shown first in IRIS GL, then in OpenGL. LBL="" HELPID=""Example One: iobounce.ciobounce.c is a simple interactive program that bounces a ball around a 2D surface. Users can use the mouse buttons to change the velocity of the ball. The IRIS GL version of the program is presented first, then the OpenGL version.LBL="" HELPID=""IRIS GL VersionHere's the IRIS GL version of iobounce.c. This is a "pure" IRIS GL program, meaning that it does not contain X calls./*                    iobounce.c:
† †*
† †*   "pool" ball that "bounces" around a 2-d "surface". 
† †*                RIGHTMOUSE stops ball
† †*                MIDDLEMOUSE increases y velocity
† †*                LEFTMOUSE increases x velocity
† †*/

#include <stdio.h>
#include <gl/gl.h>
#include <gl/device.h>

long xmaxscrn, ymaxscrn;  /* maximum size of screen  */
† †                         /* in x and y              */
#define XMIN 100
#define YMIN 100
#define XMAX 900
#define YMAX 700

long xvelocity = 0, yvelocity = 0;

main()
{
† †   Device dev;
† †   short val;
† †   long sizex, sizey;

† †   initialize();

† †   while (TRUE) {
† †      while (qtest()) {
† †         dev = qread(&val);
† †         switch (dev) {
† †               case REDRAW:        /* redraw window re: */
† †                                   /* move/resize/push/pop */
† †                   reshapeviewport();
† †                   ortho2(XMIN - 0.5, XMAX + 0.5, YMIN - 0.5,
† †                          YMAX + 0.5);
† †                   drawball();
† †                   break;
† †               case LEFTMOUSE:     /* increase xvelocity */
† †                   if (xvelocity >= 0)
† †                       xvelocity++;
† †                   else
† †                       xvelocity--;
† †                   break;
† †               case MIDDLEMOUSE:   /* increase yvelocity */
† †                   if (yvelocity >= 0)
† †                       yvelocity++;
† †                   else
† †                       yvelocity--;
† †                   break;
† †               case RIGHTMOUSE:     /* stop ball */
† †                   xvelocity = yvelocity = 0;
† †                   break;
† †               case ESCKEY:
† †                   gexit();
† †                   exit(0);
† †           }
† †       }
† †       drawball();
† †   }
}

initialize() {

† †   xmaxscrn = getgdesc(GD_XPMAX)-1;
† †   ymaxscrn = getgdesc(GD_YPMAX)-1;
† †   prefposition(xmaxscrn/4,xmaxscrn*3/4,ymaxscrn/4,ymaxscrn*3/4);
† †   winopen("iobounce");
† †   winconstraints();

† †   doublebuffer();
† †   gconfig();
† †   shademodel(FLAT);

† †   ortho2(XMIN - 0.5, XMAX + 0.5, YMIN - 0.5, YMAX + 0.5);

† †   qdevice(ESCKEY);
† †   qdevice(LEFTMOUSE);
† †   qdevice(MIDDLEMOUSE);
† †   qdevice(RIGHTMOUSE);
}

drawball() {
† †   static xpos = 500,ypos = 500;
† †   long radius = 10;

† †   color(BLACK);
† †   clear();
† †   xpos += xvelocity;
† †   ypos += yvelocity;
† †   if (xpos > XMAX - radius ||
† †       xpos < XMIN + radius) {
† †       xpos -= xvelocity;
† †       xvelocity = -xvelocity;
† †   }
† †   if (ypos > YMAX - radius ||
† †       ypos < YMIN + radius) {
† †       ypos -= yvelocity;
† †       yvelocity = -yvelocity;
† †   }
† †   color(YELLOW);
† †   circfi(xpos, ypos, radius);
† †   swapbuffers();
}LBL="" HELPID=""OpenGL Version of iobounce.cHere's the OpenGL version of iobounce.c. Windowing and event handling are now controlled with Xlib, rather than IRIS GL calls./*                   iobounce.c:
† †*
† †*   "pool ball" that "bounces" around a 2-d "surface". 
† †*            RIGHTMOUSE stops ball
† †*            MIDDLEMOUSE increases y velocity
† †*            LEFTMOUSE increases x velocity
† †*
† †*           (ported from ~4Dgifts/example/grafix/iobounce.c)
† †*/

#include <GL/glx.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <stdio.h>
#include <stdlib.h>
#include <X11/keysym.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>

#define XMIN 100
#define YMIN 100
#define XMAX 900
#define YMAX 700

#define BLACK           0
#define YELLOW          3
#define LEFTMOUSE       3
#define MIDDLEMOUSE     2
#define RIGHTMOUSE      1

#define TRUE            1
#define FALSE           0

long xmaxscrn, ymaxscrn; /* maximum size of screen /*
† †                        /* in x and y */

Display *dpy;            /* The X server connection */
Atom del_atom;           /* WM_DELETE_WINDOW atom   */
Window glwin;            /* handle to the GL window */
XEvent event;

static void openwindow(char *);
static void drawball(void);
static void clean_exit(void);

long xvelocity = 0, yvelocity = 0;

main(int argc, char *argv[])
{
† †   int myExpose, myConfigure,
† †       myButtRelease, myKeyPress,
† †       myButtonNumber;   /* store which events occur */
† †   long xsize, ysize;



† †   myExpose = myConfigure = myButtRelease = myKeyPress =
† †              myButtonNumber = FALSE;

† †   openwindow(argv[0]);

† †   while (TRUE) {

† †       KeySym keysym;
† †       char buf[4];
† †   /* this "do while" loop does the `get events'   */
† †   /* half of the "get events,process events"      */
† †   /* action of the infinite while. this is to     */
† †   /* ensure the event queue is always drained     */
† †   /* before the events that have come in are      */
† †   /*processed.                                    */
† †   while (XEventsQueued(dpy,QueuedAfterReading)) { /* end "do
† †                      * { } while"
† †                      * XEventsQueued(dpy,QueuedAfterReading)
† †                      * is like qtest()--it only tells you if 
† †                      * there're any events presently in the 
† †                      * queue.it does not disturb the event
† †                      * queue's contents in any way.       */

† †           XNextEvent(dpy, &event);
† †           switch (event.type) {

† †           /* "Expose" events are sort of like "REDRAW" in
† †            * gl-speak in terms of when a window becomes
† †            * visible, or a previously invisible part becomes
† †            */
† †               case Expose:   /* Exposures */
† †                   myExpose = TRUE;
† †                   break;

† †           /* "ConfigNotify" events are like "REDRAW" in
† †            * terms of changes to a window's size or
† †            * position.*/
† †               case ConfigureNotify:  /* Resize GL manually */
† †                   xsize = event.xconfigure.width;
† †                   ysize = event.xconfigure.height;
† †                   myConfigure = TRUE;
† †                   break;

† †           /* Wait for "ButtonRelease" events so the queue
† †            * doesn't fill up the way it would if the user
† †            * sits on ButtonPresss. */
† †               case ButtonRelease:
† †                   if (event.xbutton.button == Button1) {  
† †                       myButtonNumber = LEFTMOUSE;        
† †                       myButtRelease = TRUE;             
† †                   } else if (event.xbutton.button ==
† †                              Button2) {
† †                       myButtonNumber = MIDDLEMOUSE;
† †                       myButtRelease = TRUE;      
† †                   } else if (event.xbutton.button ==
† †                              Button3) {
† †                       myButtonNumber = RIGHTMOUSE;
† †                       myButtRelease = TRUE; 
† †                   }  /* twirl the green sphere */
† †                   break;

† †           /* "ClientMessage" is generated if the WM itself
† †            * is being
† †            *  gunned down and sends an exit signal to any
† †            * running prog.
† †            */
† †               case ClientMessage:
† †                   if (event.xclient.data.l[0] == del_atom)
† †                       clean_exit();
† †                   break;

† †           /* "KeyPress" events are those that would be
† †            * generated before whenever queueing up any
† †            * KEYBD key via qdevice.
† †            */
† †               case KeyPress:
† †                  /* save out which unmodified key (i.e. the
† †                   * key was not modified w/something like
† †                   * "Shift", "Ctrl", or "Alt") got pressed
† †                   * for use below.
† †                   */
† †                   XLookupString((XKeyEvent *)&event, buf, 4,
† †                                  &keysym, 0);
† †                   myKeyPress = TRUE;
† †                   break;

† †           }  /* end switch (event.type) */
† †       }

† †   /* On an "Expose" event, redraw the affected pop'd or
† †    * de-iconized window
† †    */
† †       if (myExpose) {
† †           drawball();       /* draw the GL stuff */
† †           myExpose = FALSE; /* reset flag--queue now empty */
† †       }
† †   /* On a "ConfigureNotify" event, the GL window has either
† †    * been moved or resized.  Respond accordingly and then
† †    * redraw its contents.
† †    */

† †       if (myConfigure) {
† †           glViewport(0, 0, xsize, ysize);
† †           glLoadIdentity();
† †           gluOrtho2D(XMIN-0.5, XMAX+0.5, YMIN-0.5, YMAX+0.5);
† †           drawball();           /* draw the GL stuff */
† †           myConfigure = FALSE;  /* reset flag--queue now
† †                                  * empty */
† †       }

† †   /* On a "ButtonRelease" event, myButtonNumber stores which
† †    * mouse button was pressed/released and then we update
† †    * x/yvelocity accordingly
† †    * /
† †       if (myButtRelease) {
† †           if (myButtonNumber == LEFTMOUSE) {  /* increase
† †                                                  xvelocity */
† †               if (xvelocity >= 0)
† †                   xvelocity += 3;
† †               else
† †                   xvelocity -= 3;
† †           } else if (myButtonNumber == MIDDLEMOUSE) {
† †                                                /* increase
† †                                                   yvelocity*/
† †               if (yvelocity >= 0)
† †                   yvelocity += 3;
† †               else
† †                   yvelocity -= 3;
† †           } else if (myButtonNumber == RIGHTMOUSE) {
† †                                              /* stop ball */
† †               xvelocity = yvelocity = 0;
† †           } else {
† †               fprintf(stderr,"ERROR: %s thinks 
† †                       mouse button # ");
† †               fprintf(stderr,"%d was
† †                       pressed(?)\n",argv[0],myButtonNumber);
† †           }
† †           drawball();
† †           myButtRelease = FALSE;
† †       }

† †       /* On a keypress of Esc key, exit program. */
† †       if (myKeyPress) {
† †           if (keysym == XK_Escape)
† †               clean_exit();
† †       }

† †       drawball();

† †   }
}

static int attributeList[] = { GLX_DOUBLEBUFFER, 
† †                              None };
GLUquadricObj *qobj; 

static Bool WaitForNotify(Display *d, XEvent *e, char *arg) {
† †   return (e->type == MapNotify) && (e->xmap.window ==
† †                                     (Window)arg);
}

static void openwindow(char *progname) {

† †   int scrnnum;       /* X screen number  */    
† †   int xorig, yorig;  /* window (upper-left) origin */
† †   XVisualInfo *vi;
† †   GLXContext cx;
† †   Colormap cmap;
† †   XSizeHints Winhints;/* used to fix window size */
† †   XSetWindowAttributes swa;
† †   XColor colorstruct;

† †   /* Connect to the X server and get screen info */
† †   if ((dpy = XOpenDisplay(NULL)) == NULL) {
† †       fprintf(stderr, "%s: cannot connect to X server %s\n",
† †                                progname, XDisplayName(NULL));
† †       exit(1);
† †   }
† †   scrnnum = DefaultScreen(dpy);
† †   ymaxscrn = DisplayHeight(dpy, scrnnum);
† †   xmaxscrn = DisplayWidth(dpy, scrnnum);
† †   /* get an appropriate visual */
† †   vi = glXChooseVisual(dpy, DefaultScreen(dpy),
† †                        attributeList);
† †   if (vi == NULL) {
† †       printf("Couldn't get visual.\n");
† †       exit(0);
† †   }

† †   /* create a GLX context */
† †   cx = glXCreateContext(dpy, vi, None, GL_TRUE);

† †   if (cx == NULL) {
† †       printf("Couldn't get context.\n");
† †       exit(0);
† †   }

† †   /* create a colormap */
† †   cmap = XCreateColormap(dpy, RootWindow(dpy, vi->screen),
† †                          vi->visual, AllocAll);

† †   XSync(dpy, 0);
† †   /* create a window */
† †   swa.colormap = cmap;
† †   swa.border_pixel = 0;

† †   /* express interest in certain events */
† †   swa.event_mask = StructureNotifyMask | KeyPressMask |
† †                    ButtonPressMask |
† †                    ButtonReleaseMask | ExposureMask;
† †   glwin = XCreateWindow(dpy, RootWindow(dpy, vi->screen), 
† †                         10, 10, 300, 300,
† †                         0, vi->depth, InputOutput,
† †                         vi->visual,
† †                         CWBorderPixel|CWColormap|CWEventMask, &swa);

† †   XMapWindow(dpy, glwin);
† †   XIfEvent(dpy, &event, WaitForNotify, (char*)glwin);

† †   /* connect the context to the window */
† †   glXMakeCurrent(dpy, glwin, cx);

† †  /* express interest in WM killing this app */
† †   if ((del_atom = XInternAtom(dpy, "WM_DELETE_WINDOW",
† †                               True)) != None)
† †       XSetWMProtocols(dpy, glwin, &del_atom, 1);

† †   colorstruct.pixel = BLACK;    
† †   colorstruct.red   = 0;
† †   colorstruct.green = 0;
† †   colorstruct.blue  = 0;
† †   colorstruct.flags = DoRed | DoGreen | DoBlue;
† †   XStoreColor(dpy, cmap, &colorstruct);
† †   colorstruct.pixel = YELLOW;
† †   colorstruct.red   = 65535;
† †   colorstruct.green = 65535;
† †   colorstruct.blue  = 0;
† †   colorstruct.flags = DoRed | DoGreen | DoBlue;
† †   XStoreColor(dpy, cmap, &colorstruct);

† †   glLoadIdentity();
† †   gluOrtho2D(XMIN - 0.5,  XMAX + 0.5,  YMIN - 0.5,  YMAX +
† †              0.5);

† †   /* clear the buffer */
† †   glClearIndex((GLfloat)BLACK);
† †   qobj = gluNewQuadric(); 
† †   gluQuadricDrawStyle(qobj,GLU_FILL);
† †   glFlush();
}

static void drawball(void) {
† †   static int xpos = 500, ypos = 500;
† †   GLdouble radius = 14.0;

† †   glClear(GL_COLOR_BUFFER_BIT);
† †   xpos += xvelocity;
† †   ypos += yvelocity;
† †   if (xpos > XMAX - radius || xpos < XMIN + radius) {
† †       xpos -= xvelocity;
† †       xvelocity = -xvelocity;
† †   }
† †   if (ypos > YMAX - radius || ypos < YMIN + radius) {
† †       ypos -= yvelocity;
† †       yvelocity = -yvelocity;
† †   }
† †   glIndexi(YELLOW);
† †   glPushMatrix(); 
† †   glTranslatef(xpos,  ypos, 0.); 
† †   gluDisk( qobj, 0., radius, 10, 1); 
† †   glPopMatrix(); 
† †   glXSwapBuffers(dpy, glwin);
}

/*  clean_exit  --  Clean up before exiting */
static void clean_exit(void)
{
† †   gluDeleteQuadric(qobj); 
† †   XCloseDisplay(dpy);
† †   exit(0);
}LBL="" HELPID=""Example Two: zrgb.cHere's another example program, zrgb.c. This program includes zbuffering. This program won't work on 8-bit IRIS workstations. Again, the IRIS GL version is presented first. LBL="" HELPID=""IRIS GL Version of zrgb.cHere's the IRIS GL version of zrgb.c. Like iobounce.c, this is a pure IRIS GL program./*                  zrgb.c
† †*
† †*  This program demostrates zbuffering 3 intersecting RGB
† †*  polygons while in doublebuffer mode where,movement of the
† †*  mouse with the LEFTMOUSE button depressed will, rotate the 3
† †*  polygons. This is done via compound rotations allowing
† †*  continuous screen-oriented rotations. (See orient(),
† †*  and draw_scene() below).  Notice the effective way there
† †*  is no wasted CPU usage when the user moves the mouse out
† †*  of the window without holding down LEFTMOUSE--there is no
† †*  qtest being performed and so the program simply blocks on
† †*  the qread statement. Press the "Esc"[ape] key to exit.
† †*  Please note that this program will not work on any 8-bit
† †*  IRIS machine.
† †*                                          ratman - 1989
† †*/

#include <stdio.h>
#include <gl/gl.h>
#include <gl/device.h>

Matrix objmat = {
† †   {1.0, 0.0, 0.0, 0.0},
† †   {0.0, 1.0, 0.0, 0.0},
† †   {0.0, 0.0, 1.0, 0.0},
† †   {0.0, 0.0, 0.0, 1.0},
};

Matrix idmat = {
† †   {1.0, 0.0, 0.0, 0.0},
† †   {0.0, 1.0, 0.0, 0.0},
† †   {0.0, 0.0, 1.0, 0.0},
† †   {0.0, 0.0, 0.0, 1.0},
};

/* Modes the program can be in */
#define NOTHING 0
#define ORIENT 1

int mode = 0;
int omx, mx, omy, my;  /* old and new mouse position */
float scrnaspect;      /* aspect ratio value         */
long zfar;             /* holds specific machine's   */
† †                      /* maximum Z depth value      */

main(argc, argv)
int argc;
char *argv[];
{
† †   long dev;
† †   short val;
† †   int redrawneeded=TRUE;  /* Is true when the scene */
† †                           /* needs redrawing */

† †   initialize(argv[0]);
† †   while (TRUE) {

† †       if (redrawneeded) {
† †           draw_scene();
† †           redrawneeded=FALSE;
† †       }

† †       while (qtest() || (!redrawneeded)) {

† †           switch(dev=qread(&val)) {

† †           case ESCKEY:   /* exit when key is going up, */
† †                          /* not down                   */
† †               if (val)   /* this avoids the scenario   */
† †                          /* where a window             */
† †                   break; /* underneath this program's  */
† †                          /* window--say                */
† †               exit(0);   /* another copy of this       */
† †                          /* program--getting the       */
† †                          /* ESC UP event and exiting   */
† †                          /* also.                      */
† †           case REDRAW:
† †               reshapeviewport();
† †               redrawneeded=TRUE;
† †               break;

† †           case LEFTMOUSE:
† †               if (val) {
† †                   mode = ORIENT;
† †                   omx = mx;
† †                   omy = my;
† †               } else 
† †                   mode = NOTHING;
† †               break;

† †           case MOUSEX:
† †               omx = mx; 
† †               mx = val;
† †               if (mode == ORIENT) {
† †                   update_scene();
† †                   redrawneeded=TRUE;
† †               }
† †               break;
† †           case MOUSEY:
† †               omy = my;
† †               my = val;
† †               if (mode == ORIENT) {
† †                   update_scene();
† †                   redrawneeded=TRUE;
† †               }
† †               break;
† †           }
† †       }
† †   }
}


initialize(progname)
char *progname;
{

† †   long xscrnsize;   /* size of screen in x used
† †                      * to set globals  */    
† †   long testifZinst;

† †   /*
† †    * This program requires the following to run:
† †    *  -- z buffer
† †    *  -- ability to do double-buffered RGB mode
† †    */
† †            /* Test for Z buffer */
† †   testifZinst = getgdesc(GD_BITS_NORM_ZBUFFER);
† †   if (testifZinst == FALSE) {
† †        fprintf(stderr,"BUMmer!--%s won't work on ",
† †                        progname);
† †        fprintf(stderr,"this machine--zbuffer option not
† †                        installed.\n");
† †        exit(0);
† †   }
† †   /* Test for double-buffered RGB */
† †   if (getgdesc(GD_BITS_NORM_DBL_RED) == 0) {
† †        fprintf(stderr,"BUMmer!--%s won't work on ",
† †                        progname);
† †        fprintf(stderr,"this machine--not enough
† †                        bitplanes.\n");
† †        exit(0);
† †       
† †   }

† †   /* Code to keep same aspec ratio as the screen */
† †   keepaspect(getgdesc(GD_XMMAX), getgdesc(GD_YMMAX));
† †   scrnaspect =
† †          (float)getgdesc(GD_XMMAX)/(float)getgdesc(GD_YMMAX);

† †   winopen(progname);
† †   wintitle("Zbuffered RGB #1");

† †   doublebuffer();
† †   RGBmode();
† †   gconfig();
† †   zbuffer(TRUE);
† †   glcompat(GLC_ZRANGEMAP, 0);
† †   zfar = getgdesc(GD_ZMAX);

† †   qdevice(ESCKEY);
† †   qdevice(LEFTMOUSE);
† †   qdevice(MOUSEX);
† †   qdevice(MOUSEY);
}

update_scene() {

† †   switch (mode) {

† †       case ORIENT:
† †           orient();
† †           break;
† †   }
}

orient () {

† †   pushmatrix();

† †   loadmatrix(idmat);

† †   rotate(mx-omx, 'y');
† †   rotate(omy-my, 'x');

† †   multmatrix(objmat);
† †   getmatrix(objmat);
† †   popmatrix();
}

draw_scene() {

† †   czclear(0x00C86428, zfar);

† †   perspective(400, scrnaspect, 30.0, 60.0);
† †   translate(0.0, 0.0, -40.0);
† †   multmatrix(objmat);
† †   rotate(-580, 'y');   /* skews original view 
† †                         * to show all polygons */
† †   draw_polys();

† †   swapbuffers();
}
float polygon1[3][3] = { {-10.0, -10.0,   0.0,},
† †                        { 10.0, -10.0,   0.0,},
† †                        {-10.0,  10.0,   0.0,} };

float polygon2[3][3] = { {  0.0, -10.0, -10.0,},
† †                        {  0.0, -10.0,  10.0,},
† †                        {  0.0,   5.0, -10.0,} };

float polygon3[4][3] = { {-10.0,   6.0,   4.0,},
† †                        {-10.0,   3.0,   4.0,},
† †                        {  4.0,  -9.0, -10.0,},
† †                        {  4.0,  -6.0, -10.0,} };

draw_polys() {

† †   bgnpolygon();
† †   cpack(0x00000000);
† †   v3f(&polygon1[0][0]);
† †   cpack(0x007F7F7F);
† †   v3f(&polygon1[1][0]);
† †   cpack(0x00FFFFFF);
† †   v3f(&polygon1[2][0]);
† †   endpolygon();
† †   bgnpolygon();
† †   cpack(0x0000FFFF);
† †   v3f(&polygon2[0][0]);
† †   cpack(0x007FFF00);
† †   v3f(&polygon2[1][0]);
† †   cpack(0x00FF0000);
† †   v3f(&polygon2[2][0]);
† †   endpolygon();

† †   bgnpolygon();
† †   cpack(0x0000FFFF);
† †   v3f(&polygon3[0][0]);
† †   cpack(0x00FF00FF);
† †   v3f(&polygon3[1][0]);
† †   cpack(0x00FF0000);
† †   v3f(&polygon3[2][0]);
† †   cpack(0x00FF00FF);
† †   v3f(&polygon3[3][0]);
† †   endpolygon();
}LBL="" HELPID=""OpenGL version of zrgb.cHere's the OpenGL version of zrgb.c./*
† †*                     zrgb.c
† †*/
#include <GL/glx.h>
/*
#include <GL/gl.h>
#include <GL/glu.h>
*/
#include <stdio.h>
#include <stdlib.h>
#include <X11/keysym.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>

#define TRUE            1
#define FALSE           0

Display *dpy;         /* The X server connection */
Atom del_atom;        /* WM_DELETE_WINDOW atom   */
Window glwin;         /* handle to the GL window */
XEvent event;

/* function declarations */

static void openwindow(char *);
static void resize_buffer(void);
static void clean_exit(void);
void initGL(void);
void orient(void);
void drawScene(void);
void drawPolys(void);

static float objmat[16] = {
† †        1.0, 0.0, 0.0, 0.0,
† †        0.0, 1.0, 0.0, 0.0,
† †        0.0, 0.0, 1.0, 0.0,
† †        0.0, 0.0, 0.0, 1.0,
};

short ax, ay, az;     /* angles for the "twirling" green
† †                      * sphere to ride on */
long xsize, ysize;    /* current size-of-window keepers */
long zfar;            /* used in czclear for the machine's
† †                      * zbuffer max */
long buffermode;      /* flag tracks current window
† †                      * single or double) */
double scrnaspect;    /* aspect ratio value */
int xpos, ypos, oxpos, oypos; /* old and new mouse position */


main(argc,argv)
int argc;
char **argv;
{
† †   int myExpose, myConfigure, myButtPress, myKeyPress; 
† †   int needToDraw = 0;  /* don't set this to true until
† †                         * we get our first Expose event */

† †   myExpose = myConfigure = myButtPress = myKeyPress = FALSE;

† †   openwindow(argv[0]);
† †  
† † 
† †  /* start out making the singlebuffer window be 
† †   * our current GL window */
† †   initGL();     /* do GL init stuff */

† †   /*
† †    * The event loop.
† †    */
† †   while (1) {      /* standard logic:  get event(s), 
† †                     * process event(s) */

† †       XEvent event;
† †       KeySym keysym;
† †       char buf[4];

† †   /* this "do while" loop does the `get events' 
† †    * half of the "get events, process events" action 
† †    * of the infinite while. this is to ensure
† †    * the event queue is always drained before the events
† †    * that have come in are processed.
† †    */

† †       do {

† †           XNextEvent(dpy, &event);
† †               switch (event.type) {

† †           /* "Expose" events are sort of like "REDRAW" in
† †            * gl-speak in terms of when a window becomes
† †            * visible, or a previously
† †            * invisible part becomes visible.
† †            */
† †               case Expose:   /* Exposures */
† †                   needToDraw = myExpose = TRUE;
† †                   break;

† †           /* "ConfigNotify" events are like "REDRAW" in
† †            * terms of changes to a window's size or position.
† †            */
† †               case ConfigureNotify: /* Resize GL manually */
† †                   xsize = event.xconfigure.width;
† †                   ysize = event.xconfigure.height;
† †                   needToDraw = myConfigure = TRUE;
† †                   break;

† †           /* Wait for "MotionNotify" events so the 
† †            * queue doesn't fill up
† †            */
† †               case MotionNotify:                        
† †                   myButtPress = TRUE;
† †                   xpos = event.xmotion.x;
† †                   ypos = event.xmotion.y;
† †                   break;

† †           /* "ClientMessage" is generated if the WM itself
† †            * is being gunned down and sends an exit signal
† †            * to any running prog.
† †            */
† †               case ClientMessage:
† †                   if (event.xclient.data.l[0] == del_atom)
† †                       clean_exit();
† †                   break;

† †           /* "KeyPress" events are those that would be
† †            *  generated before whenever queueing up any
† †               KEYBD key via qdevice.
† †            */

† †               case KeyPress:
† †                  /* save out which unmodified key (i.e. the
† †                   * key was not modified w/something like
† †                   * "Shift", "Ctrl", or "Alt") got pressed
† †                   * for use below.
† †                   */
† †                   XLookupString((XKeyEvent *)&event, buf, 4,
† †                                  &keysym, 0);
† †                   myKeyPress = TRUE;
† †                   break;

† †             }  /* end switch (event.type) */

† †       } while (XPending(dpy));   /* end "do { } while".
† †                                   * XPending() is like
† †                                   * qtest()--it only
† †                                   * tells you if there're
† †                                   * any events presently in
† †                                   * the queue. it does not
† †                                   * disturb queue's contents
† †                                   * in any way.
† †                                   */

† †   /* On an "Expose" event, redraw the affected pop'd or
† †    * de-iconized window
† †    */
† †       if (myExpose) {
† †           resize_buffer();   
† †           myExpose = FALSE; /* reset flag--queue now empty */
† †       }

† †   /* On a "ConfigureNotify" event, the GL window has either
† †    * been moved or resized. Respond accordingly and then
† †    * redraw its contents.
† †    */
† †       if (myConfigure) {
† †           oxpos = xpos;
† †           oypos = ypos;
† †           resize_buffer();   
† †           myConfigure = FALSE;  /* reset flag--queue now
† †                                  * empty */
† †       }

† †       if (needToDraw) {
† †           drawScene();
† †           needToDraw = FALSE;
† †       }

† †       /* On a keypress of Esc key, exit program.
† †        */
† †       if (myKeyPress) {
† †           if (keysym == XK_Escape)
† †               clean_exit();
† †       }

† †       if (myButtPress) {
† †           orient();
† †           drawScene();
† †           myButtPress = FALSE;
† †       }
† †   }      /* end while(1) */

}      /* end main */
static int attributeList[] = { GLX_RGBA, 
† †                              GLX_DOUBLEBUFFER, 
† †                              GLX_RED_SIZE, 1, 
† †                              GLX_GREEN_SIZE, 1, 
† †                              GLX_BLUE_SIZE, 1,
† †                              GLX_DEPTH_SIZE, 1,
† †                              None };
static int attributeList2[] = { GLX_RGBA,
† †                              GLX_RED_SIZE, 1,
† †                              GLX_GREEN_SIZE, 1,
† †                              GLX_BLUE_SIZE, 1,
† †                              GLX_DEPTH_SIZE, 1,
† †                              None };


static Bool WaitForNotify(Display *d, XEvent *e, char *arg) {
† †   return (e->type == MapNotify) && (e->xmap.window ==
† †                                     (Window)arg);
}

XSizeHints Winhints;          /* used to fix window size */

/*  openwindow - establish connection to X server, get screen
† †* info, specify the attributes we want the WM to try to
† †* provide, and create the GL window */
static void openwindow(char *progname) {

† †   XVisualInfo *vi;
† †   GLXContext cx;
† †   Colormap cmap;
† †   XSizeHints Winhints;       /* used to fix window size*/ 
† †   XSetWindowAttributes swa;
† †   int scrnnum;               /* X screen number */
† †   int xorig, yorig;          /* window (upper-left) origin */
† †   long scrnheight;

† †  /* define window initial size */
† †   xorig = 50;  yorig = 40;
† †   xsize = 300; ysize = 240;
† †   scrnaspect = xsize / (double) ysize;
† †  /* Connect to the X server and get screen info */
† †   if ((dpy = XOpenDisplay(NULL)) == NULL) {
† †       fprintf(stderr, "%s: cannot connect to X server %s\n",
† †                                progname, XDisplayName(NULL));
† †       exit(1);
† †   }

† †   scrnnum = DefaultScreen(dpy);
† †   scrnheight = DisplayHeight(dpy, scrnnum);

† †       /* get an appropriate visual */
† †   vi = glXChooseVisual(dpy, DefaultScreen(dpy),
† †                        attributeList);
† †   if (vi == NULL) {
† †       fprintf(stderr, "Unable to obtain visual
† †                        Doublebuffered visual\n");
† †       vi = glXChooseVisual(dpy, DefaultScreen(dpy),
† †                            attributeList2);
† †   }
† †   if (vi == NULL) {
† †       printf("Unable to obtain Singlebuffered
† †              VISUAL(????)\n");
† †       exit(0);
† †   }

† †   /* create a GLX context */
† †   cx = glXCreateContext(dpy, vi, None, GL_TRUE);

† †   /* create a colormap */
† †   cmap = XCreateColormap(dpy, RootWindow(dpy, vi->screen),
† †                          vi->visual, AllocNone);

† †   /* create a window */
† †   swa.colormap = cmap;
† †   swa.border_pixel = 0;
† †   swa.event_mask = StructureNotifyMask  | ButtonPressMask |
† †                    ExposureMask |
† †                    Button1MotionMask | 
† †                    KeyPressMask;    /* express interest in
† †                                      * events */;
† †   glwin = XCreateWindow(dpy, RootWindow(dpy, vi->screen),
† †                         xorig, yorig, xsize, ysize, 
† †                         0, vi->depth, InputOutput,
† †                         vi->visual,
† †                         CWBorderPixel|CWColormap|CWEventMask, &swa);

† †   XMapWindow(dpy, glwin);
† †   XIfEvent(dpy, &event, WaitForNotify, (char*)glwin);

† †   /* connect the context to the window */
† †   glXMakeCurrent(dpy, glwin, cx);

† †   if (!(glwin)) {
† †       fprintf(stderr,"%s: couldn't create `parent' X
† †                       window\n",progname);
† †       exit(1);
† †   }

† †  /* define string that will show up in the window title bar
† †   * (and icon) */
† †   XStoreName(dpy, glwin, "z-buffered rgb program");

† †  /* specify the values for the Window Size Hints we want to
† †   * enforce: this window's aspect ratio needs to stay at
† †   * 1:1, constrain min and max window size, and specify the
† †   * initial size of the window.
† †   */
† †   Winhints.width  = xsize;   /* specify desired x/y size of
† †                               * window */
† †   Winhints.height = ysize;
† †   Winhints.min_width = xorig;  /* define min and max */
† †   Winhints.max_width = scrnheight-1;  /* width and height */
† †   Winhints.min_height = yorig;
† †   Winhints.max_height = scrnheight-1;
† †   Winhints.min_aspect.x = xsize;    /* keep aspect to a
† †                                      * xsize:ysize ratio */
† †   Winhints.max_aspect.x = xsize;
† †   Winhints.min_aspect.y = ysize;
† †   Winhints.max_aspect.y = ysize;
† †   /* set the */
† †    /* corresponding flags */                                              
† †   Winhints.flags = USSize|PMaxSize|PMinSize|PAspect;
† †   XSetNormalHints(dpy, glwin, &Winhints);      
† †  /* express interest in WM killing this app */
† †   if ((del_atom = XInternAtom(dpy, "WM_DELETE_WINDOW",
† †                               True)) != None)
† †       XSetWMProtocols(dpy, glwin, &del_atom, 1);

† †   return ;
}

/*  window has been moved or resized so update viewport & CTM
† †* stuff.
† †*/
static void resize_buffer() {

† †   XSync(dpy, False);  /* STILL NEED THIS????? */
† †                       /* Need before GL reshape */
† †   scrnaspect = xsize / (double) ysize;
† †   glViewport(0, 0, (short) (xsize-1), (short) (ysize-1));
}

/*  clean up before exiting */
static void clean_exit(void)
{
† †   XCloseDisplay(dpy);
† †   exit(0);
}

/* setup all necessary GL initialzation parameters. */
void initGL()
{
† †   glEnable(GL_DEPTH_TEST);
† †   glClearColor(0.16, 0.39, 0.78, 0.0);
† †   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
† †   glLoadIdentity();
† †   gluPerspective(400.0, scrnaspect, 30.0, 1000.0);
}
void orient() 
{
† †   float dx, dy;
† †   glPushMatrix();
† †   dx = xpos-oxpos;
† †   dy = oypos-ypos;
† †   glLoadIdentity();
† †   glRotatef((float) (0.03*(xpos-oxpos)), 1.0, 0.0, 0.0);
† †   glRotatef((float) (0.03*(oypos-ypos)), 0.0, 1.0, 0.0);
† †   glMultMatrixf(objmat);
† †   glGetFloatv(GL_MODELVIEW_MATRIX, objmat);

† †   glPopMatrix();
}

void drawScene() 
{
† †   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

† †   glPushMatrix();
† †   glTranslatef(0.0, 0.0, -40.0);
† †   glMultMatrixf(objmat);
† †   glRotatef(-220.0, 0.0, 1.0, 0.0);  /* skews orig view to
† †                                       * show all polys */
† †   drawPolys();
† †   glPopMatrix();
† †   glFlush ();
† †   glXSwapBuffers(dpy, glwin);
}

float polygon1[3][3] = { {-10.0, -10.0,   0.0,},
† †                        { 10.0, -10.0,   0.0,},
† †                        {-10.0,  10.0,   0.0,} };

float polygon2[3][3] = { {  0.0, -10.0, -10.0,},
† †                        {  0.0, -10.0,  10.0,},
† †                        {  0.0,   5.0, -10.0,} };

float polygon3[4][3] = { {-10.0,   6.0,   4.0,},
† †                        {-10.0,   3.0,   4.0,},
† †                        {  4.0,  -9.0, -10.0,},
† †                        {  4.0,  -6.0, -10.0,} };
void drawPolys() 
{
† †   glBegin(GL_POLYGON);
† †   glColor4f(0.0, 0.0, 0.0, 0.0);
† †   glVertex3fv(&polygon1[0][0]);
† †   glColor4f(0.5, 0.5, 0.5, 0.0);
† †   glVertex3fv(&polygon1[1][0]);
† †   glColor4f(1.0, 1.0, 1.0, 0.0);
† †   glVertex3fv(&polygon1[2][0]);
† †   glEnd();

† †   glBegin(GL_POLYGON);
† †   glColor4f(1.0, 1.0, 0.0, 0.0);
† †   glVertex3fv(&polygon2[0][0]);
† †   glColor4f(0.0, 1.0, 0.5, 0.0);
† †   glVertex3fv(&polygon2[1][0]);
† †   glColor4f(0.0, 0.0, 1.0, 0.0);
† †   glVertex3fv(&polygon2[2][0]);
† †   glEnd();

† †   glBegin(GL_POLYGON);
† †   glColor4f(1.0, 1.0, 0.0, 0.0);
† †   glVertex3fv(&polygon3[0][0]);
† †   glColor4f(1.0, 0.0, 1.0, 0.0);
† †   glVertex3fv(&polygon3[1][0]);
† †   glColor4f(0.0, 0.0, 1.0, 0.0);
† †   glVertex3fv(&polygon3[2][0]);
† †   glColor4f(1.0, 0.0, 1.0, 0.0);
† †   glVertex3fv(&polygon3[3][0]);
† †   glEnd();

}
AC_ACCUMULATEIDREF="chap.03383"Accumulation Buffer CallsAC_ADDIDREF="chap.03391"Accumulation Buffer CallsAC_CLEAR_ACCUMULATEIDREF="chap.03385"Accumulation Buffer CallsAC_MULTIDREF="chap.03389"Accumulation Buffer CallsAC_RETURNIDREF="chap.03387"Accumulation Buffer Callsacbuf()IDREF="chap.03378"Accumulation Buffer Callsacbuf() argumentsIDREF="chap.03381"Accumulation Buffer Callsaccumulation bufferIDREF="chap.03374"Accumulation Buffer Callsaccumulation buffer operationsIDREF="chap.03381"Accumulation Buffer Callsaccumulation-buffer modeauxliary libraryIDREF="chap.049"Porting Display Mode Initialization Calls with auxInitDisplayMode()acsize()IDREF="chap.03375"Accumulation Buffer CallsIDREF="chap.0418"Porting Display Mode Initialization Calls with auxInitDisplayMode()AF_ALWAYSIDREF="chap.03349"afunction() test functionsAF_EQUALIDREF="chap.03355"afunction() test functionsAF_GEQUALIDREF="chap.03361"afunction() test functionsAF_GREATERIDREF="chap.03359"afunction() test functionsAF_LEQUALIDREF="chap.03357"afunction() test functionsAF_LESSIDREF="chap.03353"afunction() test functionsAF_NEVERIDREF="chap.03351"afunction() test functionsAF_NOTEQUALIDREF="chap.03347"afunction() test functionsafunction()IDREF="chap.03346"afunction() test functionsalpha component, lightingIDREF="chap.03446"Porting Lighting and Materials Callsalpha test functionsIDREF="chap.03346"afunction() test functionsAMBIENTIDREF="chap.03461"Porting Lighting and Materials CallsanglesIDREF="chap.03194"Arcs and CirclesantialiasingIDREF="chap.03337"Porting Antialiasing CallsIDREF="chap.03363"Antialiasing CallsblendingIDREF="chap.03339"Blendingend correctionIDREF="chap.03373"Antialiasing CallslinesIDREF="chap.03113"LinespointsIDREF="chap.03110"Pointsarc()IDREF="chap.03188"Arcs and Circlesarcf()IDREF="chap.03189"Arcs and CirclesIDREF="chap.0217"Editing toogl Output: An ExamplearcsIDREF="chap.03187"Arcs and Circlesusing quadricsIDREF="chap.0396"The IRIS GL Sphere LibraryAthena widget setIDREF="chap.0544"You Don't Have to Use IRIS IMIDREF="chap.0541"What is Xt?attenuationIDREF="chap.03447"Porting Lighting and Materials Callsattribute groupsIDREF="chap.033"Porting greset()AUX_0IDREF="chap.0445"Handling Keyboard InputAUX_9IDREF="chap.0446"Handling Keyboard InputAUX_aIDREF="chap.0443"Handling Keyboard InputIDREF="chap.0441"Handling Keyboard InputAUX_ACCUMIDREF="chap.0417"Porting Display Mode Initialization Calls with auxInitDisplayMode()AUX_DEPTHIDREF="chap.0415"Porting Display Mode Initialization Calls with auxInitDisplayMode()AUX_DOUBLEIDREF="chap.0414"Porting Display Mode Initialization Calls with auxInitDisplayMode()AUX_DOWNIDREF="chap.0450"Handling Keyboard InputAUX_ESCAPEIDREF="chap.0451"Handling Keyboard InputAUX_EVENTRECIDREF="chap.0462"Handling Mouse EventsAUX_INDEXIDREF="chap.0412"Porting Display Mode Initialization Calls with auxInitDisplayMode()AUX_LEFTIDREF="chap.0447"Handling Keyboard InputAUX_LEFTBUTTONIDREF="chap.0456"Handling Mouse EventsAUX_MIDDLEBUTTONIDREF="chap.0458"Handling Mouse EventsAUX_MOUSEDOWNIDREF="chap.0459"Handling Mouse EventsAUX_MOUSELOCIDREF="chap.0461"Handling Mouse EventsAUX_MOUSEUPIDREF="chap.0460"Handling Mouse EventsAUX_RETURNIDREF="chap.0453"Handling Keyboard InputAUX_RGBAIDREF="chap.0411"Porting Display Mode Initialization Calls with auxInitDisplayMode()AUX_RIGHTIDREF="chap.0448"Handling Keyboard InputAUX_RIGHTBUTTONIDREF="chap.0457"Handling Mouse EventsAUX_SINGLEIDREF="chap.0413"Porting Display Mode Initialization Calls with auxInitDisplayMode()AUX_SPACEIDREF="chap.0452"Handling Keyboard InputAUX_STENCILIDREF="chap.0416"Porting Display Mode Initialization Calls with auxInitDisplayMode()AUX_UPIDREF="chap.0449"Handling Keyboard InputAUX_zIDREF="chap.0444"Handling Keyboard InputIDREF="chap.0442"Handling Keyboard Inputauxiliary libraryIDREF="chap.041"Using the Auxiliary Library to Replace Windowing and Event Handling CallsauxInitDisplayMode()IDREF="chap.03376"Accumulation Buffer CallsIDREF="chap.048"Porting Display Mode Initialization Calls with auxInitDisplayMode()auxInitPosition()IDREF="chap.047"Replacing prefposition() with auxInitPosition()auxKeyFunc()IDREF="chap.0440"Handling Keyboard InputauxMouseFunc()IDREF="chap.0463"Handling Mouse EventsauxReshapeFunc()IDREF="chap.0436"Handling Redraw EventsauxReshapeViewport()IDREF="chap.0438"Handling Redraw EventsauxSetOneColor()IDREF="chap.03220"Color Callsback, polygonsIDREF="chap.03162"Polygon Modesbackground eventsIDREF="chap.0465"Managing Background Eventsbackground windowdefault colorIDREF="chap.0430"Replacing winopen() with auxInitWindow()beautifier, cbIDREF="chap.027"Hints for Using toogl Effectivelybegin and end commandsIDREF="chap.0398"bgn/end Commandsbgn/end commandsIDREF="chap.0398"bgn/end Commandsbgnclosedline()IDREF="chap.03114"Linesbgncurve()IDREF="chap.03305"NURBS Curvesbgnline()IDREF="chap.03118"Linesbgnpoint()IDREF="chap.03104"Pointsbgnpolygon()IDREF="chap.03147"Polygons and Quadrilateralsbgnqstrip()IDREF="chap.03151"Polygons and Quadrilateralsbgnsurface()IDREF="chap.03327"NURBS Surfacesbgntmesh()IDREF="chap.03185"Trianglesbgntrim()IDREF="chap.03318"Trimming CurvesbindsIDREF="chap.03434"Porting defs, binds, and sets: Replacing `Tables' of Stored Definitionsblend factorsIDREF="chap.03345"Blendingblend functionsIDREF="chap.03338"Blendingblendfunction()IDREF="chap.03343"BlendingblendingIDREF="chap.03339"BlendingbuffersclearingIDREF="chap.035"Porting Commands that Required Current Graphics PositionC comments, and tooglIDREF="chap.029"Hints for Using toogl Effectivelyc()IDREF="chap.03213"Color Callscallbacksconcave polygonsIDREF="chap.03175"Tessellated Polygonswith quadric objectsIDREF="chap.0396"The IRIS GL Sphere Librarycallfunc()IDREF="chap.03417"Porting Display Listscallobj()IDREF="chap.03422"Porting Display ListscbIDREF="chap.027"Hints for Using toogl Effectivelycharacter stringsIDREF="chap.0526"Fonts and Stringscirc()IDREF="chap.03191"Arcs and Circlescircf()IDREF="chap.03192"Arcs and CirclescirclesIDREF="chap.03187"Arcs and Circlesusing quadricsIDREF="chap.0395"The IRIS GL Sphere Libraryclear()IDREF="chap.035"Porting Commands that Required Current Graphics PositionIDREF="chap.0215"clear() Callsclearing screen, buffersIDREF="chap.035"Porting Commands that Required Current Graphics Positionclipplane()IDREF="chap.0376"Clipping Planescloseobj()IDREF="chap.03419"Porting Display Listscmode()IDREF="chap.0471"Using Color-Index ModeIDREF="chap.0419"Porting Display Mode Initialization Calls with auxInitDisplayMode()cmov()IDREF="chap.03259"Porting Pixel OperationscolorIDREF="chap.03207"Porting Color, Shading, and Writemask Commandsdefault backgroundIDREF="chap.0430"Replacing winopen() with auxInitWindow()color constantsIDREF="chap.03212"Porting Color, Shading, and Writemask CommandsIDREF="chap.0214"Defined Color Constantscolor mapsIDREF="chap.0522"Installing Color MapsIDREF="chap.03207"Porting Color, Shading, and Writemask CommandsauxiliaryIDREF="chap.0467"Using Color-Index Modemixed modelIDREF="chap.059"What Is a Mixed-Model Program?XlibIDREF="chap.0573"X Color Mapscolor()IDREF="chap.03211"Porting Color, Shading, and Writemask Commandscolor-index modeIDREF="chap.0468"Using Color-Index Modeauxiliary libraryIDREF="chap.0410"Porting Display Mode Initialization Calls with auxInitDisplayMode()COLORINDEXESIDREF="chap.03472"Porting Lighting and Materials Callscolormapsimulating RGB withIDREF="chap.0524"Installing Color Mapscomments,tooglIDREF="chap.025"What toogl Will and Won't Do for Youcomparing filesIDREF="chap.024"Using gdiff to Compare Filescomparison functionsstencilIDREF="chap.03405"Stencil Plane Callsconcave polygonsIDREF="chap.03174"Tessellated PolygonsIDREF="chap.03136"Polygons and Quadrilateralsconesusing quadricsIDREF="chap.0396"The IRIS GL Sphere Librarycontrol points, NURBSIDREF="chap.03303"NURBS Objectsconversion tool, see tooglIDREF="chap.021"How to Get and Call tooglcoordinates, textureIDREF="chap.03511"Porting Texture Callscpack()IDREF="chap.03210"Porting Color, Shading, and Writemask Commandscrv()IDREF="chap.03288"Porting Curve and Surface Commandscrvn()IDREF="chap.03289"Porting Curve and Surface Commandscurrent graphics positionIDREF="chap.036"Porting Commands that Required Current Graphics Positioncurrent matrix modeIDREF="chap.0317"Porting Matrix and Transformation Callscurve types, NURBSIDREF="chap.03313"NURBS Curvescurvebasis()IDREF="chap.03286"Porting Curve and Surface Commandscurveit()IDREF="chap.03292"Porting Curve and Surface Commandscurveprecision()IDREF="chap.03287"Porting Curve and Surface CommandscurvesIDREF="chap.03284"Porting Curve and Surface Commandscurves, trimmingIDREF="chap.03317"Trimming Curvescylindersusing quadricsIDREF="chap.0396"The IRIS GL Sphere LibraryczclearIDREF="chap.035"Porting Commands that Required Current Graphics Positionczclear()IDREF="chap.038"Porting Screen and Buffer Clearing Commandsdefault colorbackground windowIDREF="chap.0430"Replacing winopen() with auxInitWindow()defbasis()IDREF="chap.03285"Porting Curve and Surface Commandsdefined color constantsIDREF="chap.03212"Porting Color, Shading, and Writemask CommandsIDREF="chap.0214"Defined Color Constantsdeflinestyle()IDREF="chap.03441"Porting defs, binds, and sets: Replacing `Tables' of Stored DefinitionsIDREF="chap.03123"Linesdefpattern()IDREF="chap.03443"Porting defs, binds, and sets: Replacing `Tables' of Stored DefinitionsIDREF="chap.03167"Polygon StipplesdefsIDREF="chap.03434"Porting defs, binds, and sets: Replacing `Tables' of Stored Definitionsdelobj()IDREF="chap.03427"Porting Display Listsdeltag()IDREF="chap.03416"Porting Display Listsdepth cueingIDREF="chap.03270"Porting Depth Cueing and Fog Commandsdepth-buffer modeauxiliary libraryIDREF="chap.049"Porting Display Mode Initialization Calls with auxInitDisplayMode()IDREF="chap.0410"Porting Display Mode Initialization Calls with auxInitDisplayMode()depthcue()IDREF="chap.03271"Porting Depth Cueing and Fog Commandsdestination alpha bitsIDREF="chap.03341"Blendingdevice callstooglIDREF="chap.0212"Windowing, Device, and Event Callsdifferences, OpenGL and IRIS GLIDREF="chap.011"What's Different?DIFFUSEIDREF="chap.03463"Porting Lighting and Materials Callsdiffuse lighting componentsIDREF="chap.03446"Porting Lighting and Materials Callsdisksusing quadricsIDREF="chap.0395"The IRIS GL Sphere Librarydisplay listsIDREF="chap.03408"Porting Display ListseditingIDREF="chap.03432"Edited Display ListsexampleIDREF="chap.03433"A Sample Implementation of a Display Listfor X bitmap fontsIDREF="chap.0528"Fonts and Stringsdisplay modeIDREF="chap.0518"You Can't Change Window Depth and Display Modedisplay modesauxiliary libraryIDREF="chap.0410"Porting Display Mode Initialization Calls with auxInitDisplayMode()dither()IDREF="chap.03242"Shading ModelsditheringIDREF="chap.03246"Shading ModelsdocumentationIRIS IMIDREF="chap.0565"Other Information Sources for Mixed-Model ProgrammingIDREF="intro1"† †Where To Get More InformationMotifIDREF="chap.0565"Other Information Sources for Mixed-Model ProgrammingIDREF="intro1"† †Where To Get More InformationXIDREF="chap.0565"Other Information Sources for Mixed-Model ProgrammingIDREF="intro1"† †Where To Get More Informationdouble-buffer modeauxiliary libraryIDREF="chap.0410"Porting Display Mode Initialization Calls with auxInitDisplayMode()double-matrix modeIDREF="chap.0310"Porting Matrix and Transformation Callsdoublebuffer()IDREF="chap.0420"Porting Display Mode Initialization Calls with auxInitDisplayMode()draw()IDREF="chap.036"Porting Commands that Required Current Graphics Positiondrawing commandsIDREF="chap.0382"Porting Drawing Commandsdrawing objectsauxliary libraryIDREF="chap.0474"Other Auxiliary Library RoutinesIDREF="chap.0473"Other Auxiliary Library Routinesdrawing single pointsIDREF="chap.03102"Pointsediting display listsIDREF="chap.03431"Edited Display Listsediting toogl outputIDREF="chap.0211"Editing† †toogl Output: Areas that Need Special Attentioneditobj()IDREF="chap.03409"Porting Display ListsEMISSIONIDREF="chap.03467"Porting Lighting and Materials Callsend commandsIDREF="chap.0398"bgn/end Commandsend correctionIDREF="chap.03373"Antialiasing Callsendclosedline()IDREF="chap.03115"Linesendcurve()IDREF="chap.03309"NURBS Curvesendfeedback()IDREF="chap.03592"Porting Feedback Callsendpick()IDREF="chap.03576"Porting Picking Callsendpoint()IDREF="chap.03105"Pointsendpolygon()IDREF="chap.03148"Polygons and Quadrilateralsendqstrip()IDREF="chap.03152"Polygons and Quadrilateralsendselect()IDREF="chap.03577"Porting Picking Callsendsurface()IDREF="chap.03331"NURBS Surfacesendtmesh()IDREF="chap.03186"Trianglesendtrim()IDREF="chap.03324"Trimming Curvesescape keyexiting programIDREF="chap.0429"Replacing winopen() with auxInitWindow()event callstooglIDREF="chap.0212"Windowing, Device, and Event Callsevent handlingauxiliary libraryIDREF="chap.0431"Event Handling: Replacing qdevice(), qtest(), and qread()† †mixed modelIDREF="chap.056"What Is a Mixed-Model Program?XlibIDREF="chap.0574"A Sample X Event Loopexiting with escape keyIDREF="chap.0429"Replacing winopen() with auxInitWindow()feedback()IDREF="chap.03590"Porting Feedback Callsflat shadingIDREF="chap.03244"Shading ModelsfogIDREF="chap.03270"Porting Depth Cueing and Fog Commandsfog modesIDREF="chap.03283"Porting Depth Cueing and Fog Commandsfogvertex()IDREF="chap.03275"Porting Depth Cueing and Fog CommandsfontsIDREF="chap.0526"Fonts and Stringsfront, polygonsIDREF="chap.03162"Polygon Modesfunction flagsstencilIDREF="chap.03404"Stencil Plane Callsfunctionsalpha testingIDREF="chap.03346"afunction() test functionsfunctions, blendingIDREF="chap.03338"Blendinggconfig()IDREF="chap.0425"Porting Display Mode Initialization Calls with auxInitDisplayMode()IDREF="chap.0472"Using Color-Index ModegdiffIDREF="chap.024"Using gdiff to Compare Filesgenobj()IDREF="chap.03429"Porting Display Listsgentag()IDREF="chap.03414"Porting Display Listsget commandsIDREF="chap.034"Porting IRIS GL `Get' CommandsIDREF="chap.0216"Get Callsgetbutton()IDREF="chap.0433"Event Handling: Replacing qdevice(), qtest(), and qread()† †getcmmode()IDREF="chap.03235"Color Callsgetcolor()IDREF="chap.03214"Color Callsgetdcm()IDREF="chap.03274"Porting Depth Cueing and Fog Commandsgetgpos()IDREF="chap.036"Porting Commands that Required Current Graphics Positiongetlsbackup()IDREF="chap.03132"Linesgetlsrepeat()IDREF="chap.03128"Linesgetlstyle()IDREF="chap.03127"Linesgetlwidth()IDREF="chap.03121"Linesgetmap()IDREF="chap.03237"Color Callsgetmatrix()IDREF="chap.0364"Porting "Get" Calls For Matrices and Transformationsgetmcolor()IDREF="chap.03216"Color Callsgetmmode()IDREF="chap.0362"Porting "Get" Calls For Matrices and Transformationsgetpattern()IDREF="chap.03170"Polygon Stipplesgetresetls()IDREF="chap.03134"Linesgetscrbox()IDREF="chap.0370"Viewports, Screenmasks, and Scrboxesgetscrmask()IDREF="chap.0381"Clipping Planesgetsm()IDREF="chap.03240"Shading Modelsgetviewport()IDREF="chap.0375"Viewports, Screenmasks, and Scrboxesgetwritemask()IDREF="chap.03228"Color CallsGL and X mixed programs, see mixed-model programmingIDREF="chap.052"OpenGL/X Mixed-Model ProgrammingGL_ACCUMIDREF="chap.03384"Accumulation Buffer CallsGL_ADDIDREF="chap.03392"Accumulation Buffer CallsGL_ALWAYSIDREF="chap.03350"afunction() test functionsGL_AMBIENTIDREF="chap.03462"Porting Lighting and Materials CallsGL_AMBIENT_AND_ DIFFUSEIDREF="chap.03471"Porting Lighting and Materials CallsGL_BLENDIDREF="chap.03525"Translating tevdef()GL_COLOR_INDEXESIDREF="chap.03473"Porting Lighting and Materials CallsGL_CONSTANT_IDREF="chap.03485"Porting Lighting and Materials CallsGL_CONSTANT_ATTENUATIONIDREF="chap.03486"Porting Lighting and Materials CallsGL_DECALIDREF="chap.03523"Translating tevdef()GL_DIFFUSEIDREF="chap.03464"Porting Lighting and Materials CallsGL_DONT_CAREIDREF="chap.03372"Antialiasing CallsGL_EMISSIONIDREF="chap.03468"Porting Lighting and Materials CallsGL_EQUALIDREF="chap.03356"afunction() test functionsGL_EYE_LINEARIDREF="chap.03568"Translating texgen()GL_EYE_PLANEIDREF="chap.03569"Translating texgen()GL_FASTESTIDREF="chap.03281"Porting Depth Cueing and Fog CommandsIDREF="chap.03371"Antialiasing CallsGL_GEQUALIDREF="chap.03362"afunction() test functionsGL_GREATERIDREF="chap.03360"afunction() test functionsGL_LEQUALIDREF="chap.03358"afunction() test functionsGL_LESSIDREF="chap.03354"afunction() test functionsGL_LIGHT_MODEL_ AMBIENTIDREF="chap.03474"Porting Lighting and Materials CallsGL_LIGHT_MODEL_ LOCAL_VIEWERIDREF="chap.03475"Porting Lighting and Materials CallsGL_LIGHT_MODEL_ TWO_SIDEIDREF="chap.03476"Porting Lighting and Materials CallsGL_LINEARIDREF="chap.03545"Translating texdef()GL_LINEAR_ATTENUATIONIDREF="chap.03487"Porting Lighting and Materials CallsGL_LINEAR_MIPMAP_LINEARIDREF="chap.03553"Translating texdef()GL_LINEAR_MIPMAP_NEARESTIDREF="chap.03549"Translating texdef()GL_LOADIDREF="chap.03386"Accumulation Buffer CallsGL_MATRIX_MODEIDREF="chap.0363"Porting "Get" Calls For Matrices and TransformationsGL_MODELVIEWIDREF="chap.0359"Porting Matrix and Transformation CallsGL_MODELVIEW_MATRIXIDREF="chap.0365"Porting "Get" Calls For Matrices and TransformationsGL_MODULATEIDREF="chap.03521"Translating tevdef()GL_MULTIDREF="chap.03390"Accumulation Buffer CallsGL_NEARESTIDREF="chap.03543"Translating texdef()GL_NEAREST_MIPMAP_LINEARIDREF="chap.03551"Translating texdef()GL_NEAREST_MIPMAP_NEARESTIDREF="chap.03547"Translating texdef()GL_NEVERIDREF="chap.03352"afunction() test functionsGL_NICESTIDREF="chap.03280"Porting Depth Cueing and Fog CommandsIDREF="chap.03370"Antialiasing CallsGL_NOTEQUALIDREF="chap.03348"afunction() test functionsGL_OBJECT_LINEARIDREF="chap.03565"Translating texgen()GL_OBJECT_PLANEIDREF="chap.03566"Translating texgen()GL_POSITIONIDREF="chap.03479"Porting Lighting and Materials CallsGL_PROJECTIONIDREF="chap.0361"Porting Matrix and Transformation CallsGL_PROJECTION_MATRIXIDREF="chap.0366"Porting "Get" Calls For Matrices and TransformationsGL_QIDREF="chap.03563"Translating texgen()GL_QUADRATIC_ATTENUATIONIDREF="chap.03488"Porting Lighting and Materials CallsGL_RIDREF="chap.03561"Translating texgen()GL_RETURNIDREF="chap.03388"Accumulation Buffer CallsGL_SIDREF="chap.03557"Translating texgen()GL_SHININESSIDREF="chap.03470"Porting Lighting and Materials CallsGL_SPECULARIDREF="chap.03466"Porting Lighting and Materials CallsGL_SPHERE_MAPIDREF="chap.03571"Translating texgen()GL_SPOT_CUTOFFIDREF="chap.03484"Porting Lighting and Materials CallsGL_SPOT_DIRECTIONIDREF="chap.03481"Porting Lighting and Materials CallsGL_SPOT_EXPONENTIDREF="chap.03483"Porting Lighting and Materials CallsGL_TIDREF="chap.03559"Translating texgen()GL_TEXTUREIDREF="chap.0357"Porting Matrix and Transformation CallsGL_TEXTURE_BORDER_COLORIDREF="chap.03541"Translating texdef()GL_TEXTURE_ENV_COLORIDREF="chap.03527"Translating tevdef()GL_TEXTURE_MAG_FILTERIDREF="chap.03534"Translating texdef()GL_TEXTURE_MATRIXIDREF="chap.0367"Porting "Get" Calls For Matrices and TransformationsGL_TEXTURE_MIN_FILTERIDREF="chap.03532"Translating texdef()GL_TEXTURE_WRAP_SIDREF="chap.03537"Translating texdef()GL_TEXTURE_WRAP_TIDREF="chap.03540"Translating texdef()glAccum()IDREF="chap.03379"Accumulation Buffer CallsglBegin()IDREF="chap.03106"PointsIDREF="chap.0398"bgn/end CommandslinesIDREF="chap.03116"LinespolygonsIDREF="chap.03149"Polygons and QuadrilateralsglBegin/glEndvalid commandsIDREF="chap.03101"bgn/end CommandsglBlendFunc()IDREF="chap.03344"BlendingglCallList()IDREF="chap.03423"Porting Display ListsglCallLists()IDREF="chap.03424"Porting Display ListsfontsIDREF="chap.0531"Fonts and Stringsglcear()IDREF="chap.038"Porting Screen and Buffer Clearing CommandsglClear()IDREF="chap.035"Porting Commands that Required Current Graphics Positionaccumulation bufferIDREF="chap.03382"Accumulation Buffer Callsstencil planesIDREF="chap.03407"Stencil Plane CallsglClearAccum()IDREF="chap.03380"Accumulation Buffer CallsIDREF="chap.038"Porting Screen and Buffer Clearing CommandsglClearColor()IDREF="chap.035"Porting Commands that Required Current Graphics PositionglClearDepth()IDREF="chap.038"Porting Screen and Buffer Clearing CommandsglClearIndex()IDREF="chap.035"Porting Commands that Required Current Graphics PositionglClearStencil()IDREF="chap.038"Porting Screen and Buffer Clearing CommandsIDREF="chap.03402"Stencil Plane CallsglClipPlane()IDREF="chap.0377"Clipping PlanesglColor()IDREF="chap.03209"Porting Color, Shading, and Writemask CommandsglColorMask()IDREF="chap.03227"Color CallsglColorMaterial()IDREF="chap.03457"Porting Lighting and Materials CallsglCopyPixels()IDREF="chap.03256"Porting Pixel OperationsglDeleteLists()IDREF="chap.03428"Porting Display ListsglDepthMask()IDREF="chap.03232"Color CallsglDisable()antialiasingIDREF="chap.03368"Antialiasing CallsditheringIDREF="chap.03245"Shading ModelsfogIDREF="chap.03278"Porting Depth Cueing and Fog Commandspolygon stipplingIDREF="chap.03173"Polygon StipplestexturesIDREF="chap.03495"Porting Texture CallsglDrawPixels()IDREF="chap.03254"Porting Pixel OperationsglEdgeFlag()IDREF="chap.03153"Polygons and QuadrilateralsglEnable()IDREF="chap.03112"PointsantialiasingIDREF="chap.03365"Antialiasing CallsblendingIDREF="chap.03342"BlendingditheringIDREF="chap.03243"Shading ModelsfogIDREF="chap.03277"Porting Depth Cueing and Fog CommandslightingIDREF="chap.03453"Porting Lighting and Materials CallslogicopIDREF="chap.03269"Porting Pixel OperationsNURBSIDREF="chap.03304"NURBS Objectspolygon stipplingIDREF="chap.03172"Polygon Stipplesstencil planesIDREF="chap.03397"Stencil Plane CallstexturesIDREF="chap.03494"Porting Texture CallsglEnd()IDREF="chap.03107"PointsIDREF="chap.03100"bgn/end CommandsIDREF="chap.0398"bgn/end CommandslinesIDREF="chap.03117"LinespolygonsIDREF="chap.03150"Polygons and QuadrilateralsglEndList()IDREF="chap.03421"Porting Display ListsglFeedbackBuffer()IDREF="chap.03593"Porting Feedback CallsglFog()IDREF="chap.03276"Porting Depth Cueing and Fog Commandsarguments IDREF="chap.03279"Porting Depth Cueing and Fog CommandsglFrustum()IDREF="chap.0353"Porting Matrix and Transformation CallsglGenLists()IDREF="chap.03430"Porting Display ListsglGet()IDREF="chap.034"Porting IRIS GL `Get' Commandscolor indexIDREF="chap.03215"Color Callscolor maskIDREF="chap.03229"Color Callsline widthIDREF="chap.03122"LinesRGB color valuesIDREF="chap.03218"Color Callsshade modelIDREF="chap.03241"Shading ModelsglGetClipPlane()IDREF="chap.0378"Clipping PlanesglGetLight()IDREF="chap.03454"Porting Lighting and Materials CallsglGetMaterial()IDREF="chap.03458"Porting Lighting and Materials CallsglGetPolygonStipple()IDREF="chap.03171"Polygon StipplesglGetTexParameter()IDREF="chap.03514"Porting Texture CallsglHint()antialiasingIDREF="chap.03369"Antialiasing CallsglIndex()IDREF="chap.03208"Porting Color, Shading, and Writemask CommandsglIndexMask()IDREF="chap.03224"Color CallsglInitNames()IDREF="chap.03583"Porting Picking CallsglIsList()IDREF="chap.03426"Porting Display ListsglLight()IDREF="chap.03451"Porting Lighting and Materials CallsglLightModel()IDREF="chap.03452"Porting Lighting and Materials CallsglLineStipple()IDREF="chap.03125"LinesglLineWidth()IDREF="chap.03120"LinesglListBase()fontsIDREF="chap.0530"Fonts and StringsglLoadIdentity()IDREF="chap.0319"Porting Matrix and Transformation CallsglLoadMatrixd()IDREF="chap.0322"Porting Matrix and Transformation CallsglLoadMatrixf()IDREF="chap.0321"Porting Matrix and Transformation CallsglLoadName()IDREF="chap.03589"Porting Picking CallsglLogicOp()IDREF="chap.03268"Porting Pixel OperationsglMap1()IDREF="chap.03315"NURBS CurvesglMap2()IDREF="chap.03336"NURBS SurfacesglMaterial()IDREF="chap.03455"Porting Lighting and Materials CallsglMaterial() parametersIDREF="chap.03460"Porting Lighting and Materials CallsglMatrixMode()IDREF="chap.0316"Porting Matrix and Transformation CallsglMultMatrix()IDREF="chap.039"Porting Matrix and Transformation CallsglMultMatrixd()IDREF="chap.0325"Porting Matrix and Transformation CallsglMultMatrixf()IDREF="chap.0324"Porting Matrix and Transformation CallsglNewList()IDREF="chap.03420"Porting Display ListsglOrtho()IDREF="chap.0331"Porting Matrix and Transformation CallsglPassThrough()IDREF="chap.03595"Porting Feedback CallsglPixelStore()IDREF="chap.03166"Polygon StipplesIDREF="chap.03264"Porting Pixel OperationsglPixelTransfer()IDREF="chap.03266"Porting Pixel OperationsglPixelZoom()IDREF="chap.03258"Porting Pixel OperationsglPointSize()IDREF="chap.03109"PointsglPolygonMode()IDREF="chap.03155"Polygons and QuadrilateralsglPolygonStipple()IDREF="chap.03168"Polygon StipplesglPopAttrib()IDREF="chap.032"Porting greset()glPopMatrix()IDREF="chap.0339"Porting Matrix and Transformation CallsglPopName()IDREF="chap.03587"Porting Picking CallsglPushAttrib()IDREF="chap.032"Porting greset()glPushMatrix()IDREF="chap.0341"Porting Matrix and Transformation CallsglPushName()IDREF="chap.03586"Porting Picking CallsglRasterPos()IDREF="chap.03260"Porting Pixel OperationsglReadBuffer()IDREF="chap.03262"Porting Pixel OperationsglReadPixels()IDREF="chap.03251"Porting Pixel OperationsglRect()IDREF="chap.03158"Polygons and QuadrilateralsglRenderMode()feedbackIDREF="chap.03591"Porting Feedback CallspickingIDREF="chap.03575"Porting Picking CallsselectIDREF="chap.03578"Porting Picking CallsglRotate()IDREF="chap.0310"Porting Matrix and Transformation CallsglRotated()IDREF="chap.0344"Porting Matrix and Transformation CallsglRotatef()IDREF="chap.0345"Porting Matrix and Transformation CallsglScaled()IDREF="chap.0347"Porting Matrix and Transformation CallsglScalef()IDREF="chap.0348"Porting Matrix and Transformation CallsglScissor()IDREF="chap.0380"Clipping PlanesglSelectBuffer()IDREF="chap.03581"Porting Picking CallsglShadeModel()IDREF="chap.03239"Shading ModelsglStencilFunc()IDREF="chap.03399"Stencil Plane CallsglStencilMask()IDREF="chap.03401"Stencil Plane CallsglStencilOp()IDREF="chap.03398"Stencil Plane CallsglTexCoord()IDREF="chap.03510"Porting Texture CallsglTexEnv()IDREF="chap.03505"Porting Texture CallsIDREF="chap.03507"Porting Texture CallsglTexGen()IDREF="chap.03513"Porting Texture CallsglTexImage1D()IDREF="chap.03508"Porting Texture CallsglTexImage2D()IDREF="chap.03502"Porting Texture CallsIDREF="chap.03497"Porting Texture CallsglTexParameter()IDREF="chap.03501"Porting Texture CallsIDREF="chap.03498"Porting Texture CallsglTranslated()IDREF="chap.0351"Porting Matrix and Transformation CallsglTranslatef()IDREF="chap.0350"Porting Matrix and Transformation CallsGLU quadrics routinesIDREF="chap.0383"The IRIS GL Sphere LibrarygluBeginCurve()IDREF="chap.03306"NURBS CurvesgluBeginPolygon()IDREF="chap.03179"Tessellated PolygonsgluBeginSurface()IDREF="chap.03328"NURBS SurfacesgluBeginTrim()IDREF="chap.03319"Trimming CurvesgluBuild1DMipmaps()IDREF="chap.03515"Porting Texture CallsgluBuild2DMipmaps()IDREF="chap.03499"Porting Texture CallsIDREF="chap.03516"Porting Texture CallsIDREF="chap.03493"Porting Texture CallsIDREF="chap.03503"Porting Texture CallsgluCylinder()IDREF="chap.0392"The IRIS GL Sphere LibrarygluDeleteNurbsRenderer()IDREF="chap.03300"NURBS ObjectsgluDeleteQuadric()IDREF="chap.0385"The IRIS GL Sphere LibraryIDREF="chap.03201"SpheresgluDeleteTess()IDREF="chap.03177"Tessellated PolygonsgluDisk()IDREF="chap.0394"The IRIS GL Sphere LibraryIDREF="chap.03193"Arcs and CirclesgluEndCurve()IDREF="chap.03310"NURBS CurvesgluEndPolygon()IDREF="chap.03182"Tessellated PolygonsgluEndSurface()IDREF="chap.03332"NURBS SurfacesgluEndTrim()IDREF="chap.03325"Trimming CurvesgluLookAt()IDREF="chap.0314"Porting Matrix and Transformation CallsgluNewNurbsRenderer()IDREF="chap.03299"NURBS ObjectsgluNewQuadric()IDREF="chap.0384"The IRIS GL Sphere LibraryIDREF="chap.03199"SpheresgluNewTess()IDREF="chap.03176"Tessellated PolygonsgluNextContour()IDREF="chap.03181"Tessellated PolygonsgluNurbsCallback()IDREF="chap.03301"NURBS ObjectsgluNurbsCurve()IDREF="chap.03323"Trimming CurvesIDREF="chap.03308"NURBS CurvesgluNurbsSurface()IDREF="chap.03330"NURBS SurfacesgluOrtho2D()IDREF="chap.0333"Porting Matrix and Transformation CallsgluPartialDisk()IDREF="chap.0393"The IRIS GL Sphere LibraryIDREF="chap.03190"Arcs and CirclesgluPerspective()IDREF="chap.0335"Porting Matrix and Transformation CallsgluPickMatrix()IDREF="chap.03580"Porting Picking CallsIDREF="chap.0337"Porting Matrix and Transformation CallsgluProject()IDREF="chap.0329"Porting Matrix and Transformation CallsgluPwlCurve()IDREF="chap.03321"Trimming CurvesgluQuadricCallback()IDREF="chap.0386"The IRIS GL Sphere LibrarygluQuadricDrawstyle()IDREF="chap.0390"The IRIS GL Sphere LibrarygluQuadricNormals()IDREF="chap.0387"The IRIS GL Sphere LibrarygluQuadricOrientation()IDREF="chap.0388"The IRIS GL Sphere LibrarygluQuadricTexture()IDREF="chap.0389"The IRIS GL Sphere LibrarygluScaleImage()IDREF="chap.03517"Porting Texture CallsgluSphere()IDREF="chap.0391"The IRIS GL Sphere LibraryIDREF="chap.03203"SpheresIDREF="chap.03197"SpheresgluTessCallback()IDREF="chap.03178"Tessellated PolygonsgluTessVertex()IDREF="chap.03180"Tessellated PolygonsgluUnProject()IDREF="chap.0328"Porting Matrix and Transformation CallsglVertex()IDREF="chap.0397"The v() CommandsglViewport()IDREF="chap.0371"Viewports, Screenmasks, and ScrboxesIDREF="chap.0437"Handling Redraw EventsGLwDrawIDREF="chap.0533"Porting to Mixed-Model Using Xt and a Widget SetIDREF="chap.0514"Using Xt and a Widget SetGLwMDrawIDREF="chap.0535"Porting to Mixed-Model Using Xt and a Widget SetIDREF="chap.0515"Using Xt and a Widget SetGLX commandsIDREF="chap.0566"Mixed-Model Programming Using Xlib and OpenGL GLX CommandsGLX routinesIDREF="chap.0517"Using XlibglXChooseVisual()IDREF="chap.0568"Mixed-Model Programming Using Xlib and OpenGL GLX Commandsaccumulation bufferIDREF="chap.03377"Accumulation Buffer CallsglXCreateContext()IDREF="chap.0558"Using the OpenGL WidgetIDREF="chap.0569"Mixed-Model Programming Using Xlib and OpenGL GLX CommandsGlxCreateMDrawIDREF="chap.0554"About the GLwDrawingArea WidgetGlxDrawIRIS IM versionIDREF="chap.0555"About the GLwDrawingArea WidgetGlxDrawingAreaMakeCurrent()IDREF="chap.0559"Using the OpenGL WidgetIDREF="chap.0560"Using the OpenGL WidgetglXMakeCurrent()IDREF="chap.0571"Mixed-Model Programming Using Xlib and OpenGL GLX CommandsGlxMDrawIDREF="chap.0548"About the GLwDrawingArea WidgetGlxNinputCallbackIDREF="chap.0561"Using the OpenGL Widgetgouraud shadingIDREF="chap.03244"Shading Modelsgraphics position, currentIDREF="chap.036"Porting Commands that Required Current Graphics Positiongreset()IDREF="chap.032"Porting greset()gRGBcolor()IDREF="chap.03217"Color CallsgRGBmask()IDREF="chap.03230"Color Callsgroups, state attributeIDREF="chap.033"Porting greset()header filesIDREF="chap.031"Header Filesauxiliary libraryIDREF="chap.042"Using the Auxiliary Library to Replace Windowing and Event Handling Callshint modes, fogIDREF="chap.03282"Porting Depth Cueing and Fog Commandshow to portIDREF="chap.013"How to Port Your Code to OpenGLimage scalingIDREF="chap.03518"Porting Texture Callsinclude filesIDREF="chap.031"Header Filesauxiliary libraryIDREF="chap.042"Using the Auxiliary Library to Replace Windowing and Event Handling Callsinitnames()IDREF="chap.03582"Porting Picking Callsinput handlingIDREF="chap.0464"Input Handling with the Auxiliary Library: Example Programinstalling color mapsIDREF="chap.0522"Installing Color MapsIRIS IMIDREF="chap.0537"What You Need to Know About Xt and IRIS IMIDREF="chap.0512"Two Choices For Mixed-Model ProgrammingIDREF="chap.0532"Porting to Mixed-Model Using Xt and a Widget SetIDREF="chap.0542"What Is IRIS IM?traversalIDREF="chap.0553"About the GLwDrawingArea WidgetIRIS IM documentationIDREF="chap.0565"Other Information Sources for Mixed-Model ProgrammingIDREF="intro1"† †Where To Get More InformationIRIS InventorIDREF="chap.014"If You're Not Porting Your Code to OpenGL Yetisobj()IDREF="chap.03425"Porting Display Listsistag()IDREF="chap.03415"Porting Display Listskeyboard inputIDREF="chap.0439"Handling Keyboard InputLCOLORIDREF="chap.03477"Porting Lighting and Materials Callslight modelsIDREF="chap.03448"Porting Lighting and Materials CallslightingIDREF="chap.03448"Porting Lighting and Materials Callsdisplay listsIDREF="chap.03445"Porting Lighting and Materials Callstwo-sidedIDREF="chap.03490"Porting Lighting and Materials Callslinear fogIDREF="chap.03270"Porting Depth Cueing and Fog CommandslinesdrawingIDREF="chap.03113"Linesquadric routinesIDREF="chap.0396"The IRIS GL Sphere LibrarystipplesIDREF="chap.03113"Lineslinesmooth()IDREF="chap.03129"LinesIDREF="chap.03366"Antialiasing Callslinewidth()IDREF="chap.03119"Lineslmbind()IDREF="chap.03450"Porting Lighting and Materials CallsIDREF="chap.03436"Porting defs, binds, and sets: Replacing `Tables' of Stored Definitionslmcolor()IDREF="chap.03456"Porting Lighting and Materials Callslmdef()IDREF="chap.03449"Porting Lighting and Materials CallsIDREF="chap.03435"Porting defs, binds, and sets: Replacing `Tables' of Stored Definitionsloadmatrix()IDREF="chap.0320"Porting Matrix and Transformation Callsloadname()IDREF="chap.03588"Porting Picking Callslogical pixel operationsIDREF="chap.03247"Porting Pixel Operationslogicop()IDREF="chap.03267"Porting Pixel Operationslookat()IDREF="chap.0313"Porting Matrix and Transformation Callslrectread()IDREF="chap.03248"Porting Pixel Operationslrectwrite()IDREF="chap.03252"Porting Pixel OperationslRGBrange()IDREF="chap.03272"Porting Depth Cueing and Fog Commandslsbackup()IDREF="chap.03131"Lineslshaderange()IDREF="chap.03273"Porting Depth Cueing and Fog Commandslsrepeat()IDREF="chap.03126"Linesmakeobj()IDREF="chap.03418"Porting Display Listsmaketag()IDREF="chap.03413"Porting Display Listsmapcolor()IDREF="chap.0470"Using Color-Index ModeIDREF="chap.03219"Color Callsmapw()IDREF="chap.0326"Porting Matrix and Transformation Callsmapw2()IDREF="chap.0327"Porting Matrix and Transformation Callsmaterial parametersIDREF="chap.03459"Porting Lighting and Materials CallsmaterialsIDREF="chap.03448"Porting Lighting and Materials Callsdisplay listsIDREF="chap.03445"Porting Lighting and Materials CallsmatricesIDREF="chap.0310"Porting Matrix and Transformation Callsmatrix modesIDREF="chap.0355"Porting Matrix and Transformation Callsmixed model programIDREF="chap.055"What Is a Mixed-Model Program?mixed model programmingIDREF="chap.0557"Using the OpenGL Widgetmixed-modelXlibIDREF="chap.0566"Mixed-Model Programming Using Xlib and OpenGL GLX Commandsmixed-model programmingIDREF="chap.051"OpenGL/X Mixed-Model ProgrammingAthena widget setIDREF="chap.0545"You Don't Have to Use IRIS IMGlxDraw:IRIS IM versionIDREF="chap.0547"About the GLwDrawingArea WidgetGlxMdrawIDREF="chap.0550"About the GLwDrawingArea Widgetinstalling colormapsIDREF="chap.0520"Installing Color MapsIRIS IMIDREF="chap.0549"About the GLwDrawingArea WidgetIDREF="chap.0539"What You Need to Know About Xt and IRIS IMIRIS IM:traversalIDREF="chap.0551"About the GLwDrawingArea Widgetwithout IRIS IMIDREF="chap.0543"You Don't Have to Use IRIS IMXtIDREF="chap.0538"What You Need to Know About Xt and IRIS IMmmode()IDREF="chap.0315"Porting Matrix and Transformation Callsmodelview matrixIDREF="chap.0354"Porting Matrix and Transformation Callsmodes, fogIDREF="chap.03283"Porting Depth Cueing and Fog CommandsMotif documentationIDREF="intro1"† †Where To Get More InformationIDREF="chap.0565"Other Information Sources for Mixed-Model Programmingmouse eventsIDREF="chap.0454"Handling Mouse Eventsmove()IDREF="chap.036"Porting Commands that Required Current Graphics PositionMPROJECTIONIDREF="chap.0360"Porting Matrix and Transformation CallsMTEXTUREIDREF="chap.0356"Porting Matrix and Transformation Callsmultimap()IDREF="chap.03233"Color Callsmultiplying matricesIDREF="chap.0311"Porting Matrix and Transformation Callsmultmatrix()IDREF="chap.039"Porting Matrix and Transformation CallsIDREF="chap.0323"Porting Matrix and Transformation CallsMVIEWINGIDREF="chap.0358"Porting Matrix and Transformation Callsnormalsand GLU quadricsIDREF="chap.0396"The IRIS GL Sphere LibraryNURBScontrol pointsIDREF="chap.03302"NURBS Objectscurve typesIDREF="chap.03314"NURBS CurvesobjectsIDREF="chap.03298"NURBS Objectsstride parameterIDREF="chap.03302"NURBS Objectssurface typesIDREF="chap.03335"NURBS SurfacessurfacesIDREF="chap.03326"NURBS SurfacestrimmingIDREF="chap.03316"Trimming Curvesnurbscurve()IDREF="chap.03307"NURBS CurvesIDREF="chap.03322"Trimming Curvesnurbssurface()IDREF="chap.03329"NURBS Surfacesobjdelete()IDREF="chap.03410"Porting Display Listsobjinsert()IDREF="chap.03411"Porting Display Listsobjreplace()IDREF="chap.03412"Porting Display Listsonemap()IDREF="chap.03234"Color CallsOpenGL widgetIDREF="chap.0557"Using the OpenGL Widgetopening windowsauxiliary libraryIDREF="chap.0426"Replacing winopen() with auxInitWindow()ortho()IDREF="chap.0330"Porting Matrix and Transformation Callsortho2()IDREF="chap.0332"Porting Matrix and Transformation Callsparentheses, and tooglIDREF="chap.0213"Parentheses and Quotespass/fail operationsstencil planesIDREF="chap.03406"Stencil Plane Callspassthrough()IDREF="chap.03594"Porting Feedback Callspatch()IDREF="chap.03296"Porting Curve and Surface Commandspatchbasis()IDREF="chap.03293"Porting Curve and Surface Commandspatchcurves()IDREF="chap.03294"Porting Curve and Surface Commandspatchprecision()IDREF="chap.03295"Porting Curve and Surface Commandspclos()IDREF="chap.036"Porting Commands that Required Current Graphics PositionIDREF="chap.03142"Polygons and Quadrilateralspdr()IDREF="chap.036"Porting Commands that Required Current Graphics PositionIDREF="chap.03141"Polygons and QuadrilateralsIDREF="chap.036"Porting Commands that Required Current Graphics Positionperspective()IDREF="chap.0334"Porting Matrix and Transformation Callspick()IDREF="chap.03573"Porting Picking CallspickingIDREF="chap.03572"Porting Picking Callspicksize()IDREF="chap.03579"Porting Picking CallsIDREF="chap.0336"Porting Matrix and Transformation Callspixel operationsIDREF="chap.03247"Porting Pixel Operationspixmode()IDREF="chap.03265"Porting Pixel OperationsIDREF="chap.03263"Porting Pixel Operationspmv()IDREF="chap.03140"Polygons and QuadrilateralsIDREF="chap.036"Porting Commands that Required Current Graphics Positionpnt()IDREF="chap.03103"Pointspntsize()IDREF="chap.03108"Pointspntsmooth()IDREF="chap.03364"Antialiasing CallsIDREF="chap.03111"PointspointsIDREF="chap.03102"PointsantialiasingIDREF="chap.03110"Pointsquadric routinesIDREF="chap.0396"The IRIS GL Sphere Libraryset point sizeIDREF="chap.03110"Pointsvertices as pointsIDREF="chap.03110"Pointspol()IDREF="chap.03139"Polygons and Quadrilateralspolarview()IDREF="chap.0312"Porting Matrix and Transformation Callspolling callsIDREF="chap.0431"Event Handling: Replacing qdevice(), qtest(), and qread()† †poly()IDREF="chap.03138"Polygons and QuadrilateralspolygonsIDREF="chap.03135"Polygons and Quadrilateralsarcs, circlesIDREF="chap.03187"Arcs and Circlesback/frontIDREF="chap.03162"Polygon ModesconcaveIDREF="chap.03174"Tessellated PolygonsmodesIDREF="chap.03137"Polygons and QuadrilateralsIDREF="chap.03162"Polygon Modesquadric routinesIDREF="chap.0396"The IRIS GL Sphere LibrarystipplesIDREF="chap.03165"Polygon StipplestessellatedIDREF="chap.03174"Tessellated PolygonstrianglesIDREF="chap.03183"Trianglespolymode()IDREF="chap.03154"Polygons and QuadrilateralsIDREF="chap.03164"Polygon Modespolynomial curveIDREF="chap.03333"NURBS SurfacesIDREF="chap.03311"NURBS Curvespolysmooth()IDREF="chap.03367"Antialiasing Callspopmatrix()IDREF="chap.0338"Porting Matrix and Transformation Callspopname()IDREF="chap.03585"Porting Picking Callspopviewport()IDREF="chap.0373"Viewports, Screenmasks, and Scrboxesporting, how toIDREF="chap.013"How to Port Your Code to OpenGLPOSITIONIDREF="chap.03478"Porting Lighting and Materials Callsprojection matrixIDREF="chap.0354"Porting Matrix and Transformation Callspushmatrix()IDREF="chap.0340"Porting Matrix and Transformation Callspushname()IDREF="chap.03584"Porting Picking Callspushviewport()IDREF="chap.0374"Viewports, Screenmasks, and Scrboxespwlcurve()IDREF="chap.03320"Trimming Curvesqread()IDREF="chap.0511"What Is a Mixed-Model Program?quadrics routinesIDREF="chap.0383"The IRIS GL Sphere LibraryquadrilateralsIDREF="chap.03135"Polygons and Quadrilateralsqueuing callsIDREF="chap.0431"Event Handling: Replacing qdevice(), qtest(), and qread()† †quotes, and tooglIDREF="chap.0213"Parentheses and Quotesrational curvesIDREF="chap.03312"NURBS CurvesIDREF="chap.03334"NURBS Surfacesrcrv()IDREF="chap.03290"Porting Curve and Surface Commandsrcrvn()IDREF="chap.03291"Porting Curve and Surface Commandsrdr()IDREF="chap.036"Porting Commands that Required Current Graphics PositionreadRGB()IDREF="chap.03250"Porting Pixel Operationsreadsource()IDREF="chap.03261"Porting Pixel Operationsrect()IDREF="chap.03156"Polygons and Quadrilateralsrectangles, drawingIDREF="chap.03159"Polygons and Quadrilateralsrectcopy()IDREF="chap.03255"Porting Pixel Operationsrectf()IDREF="chap.03157"Polygons and Quadrilateralsrectread()IDREF="chap.03249"Porting Pixel Operationsrectwrite()IDREF="chap.03253"Porting Pixel Operationsrectzoom()IDREF="chap.03257"Porting Pixel Operationsredraw eventsIDREF="chap.0434"Event Handling: Replacing qdevice(), qtest(), and qread()† †repeat factorlinesIDREF="chap.03113"Linesresetls()IDREF="chap.03133"Linesreshapeviewport()IDREF="chap.0368"Viewports, Screenmasks, and ScrboxesRGBsimulating with color mapIDREF="chap.0524"Installing Color MapsRGBA-modeauxiliary libraryIDREF="chap.0410"Porting Display Mode Initialization Calls with auxInitDisplayMode()RGBcolor()IDREF="chap.03222"Color CallsRGBmode()IDREF="chap.0421"Porting Display Mode Initialization Calls with auxInitDisplayMode()RGBwritemask()IDREF="chap.03226"Color Callsrot()IDREF="chap.0343"Porting Matrix and Transformation Callsrotate()IDREF="chap.0310"Porting Matrix and Transformation CallsIDREF="chap.0342"Porting Matrix and Transformation CallsrotationsIDREF="chap.0310"Porting Matrix and Transformation Callsrpatch()IDREF="chap.03297"Porting Curve and Surface Commandsrpdr()IDREF="chap.03144"Polygons and Quadrilateralsrpmv()IDREF="chap.03143"Polygons and QuadrilateralsIDREF="chap.036"Porting Commands that Required Current Graphics Positionrunning auxiliary library programIDREF="chap.043"Running a Program That Uses the Auxiliary Librarysbox()IDREF="chap.03160"Polygons and Quadrilateralssboxf()IDREF="chap.03161"Polygons and Quadrilateralsscale()IDREF="chap.0346"Porting Matrix and Transformation Callsscaling imagesIDREF="chap.03518"Porting Texture Callssclear()IDREF="chap.03403"Stencil Plane CallsIDREF="chap.038"Porting Screen and Buffer Clearing Commandsscrbox()IDREF="chap.0369"Viewports, Screenmasks, and ScrboxesscreenclearingIDREF="chap.035"Porting Commands that Required Current Graphics Positionscrmask()IDREF="chap.0379"Clipping Planesselect()IDREF="chap.03574"Porting Picking Callssetlinestyle()IDREF="chap.03442"Porting defs, binds, and sets: Replacing `Tables' of Stored DefinitionsIDREF="chap.03124"Linessetmap()IDREF="chap.03236"Color Callssetpattern()IDREF="chap.03444"Porting defs, binds, and sets: Replacing `Tables' of Stored DefinitionsIDREF="chap.03169"Polygon StipplessetsIDREF="chap.03434"Porting defs, binds, and sets: Replacing `Tables' of Stored Definitionssetting matrix modeIDREF="chap.0318"Porting Matrix and Transformation Callsshademodel()IDREF="chap.03238"Shading ModelsshadingIDREF="chap.03207"Porting Color, Shading, and Writemask CommandsIDREF="chap.03244"Shading ModelsSHININESSIDREF="chap.03469"Porting Lighting and Materials Callssingle pointsIDREF="chap.03102"Pointssingle-buffer modeauxiliary libraryIDREF="chap.0410"Porting Display Mode Initialization Calls with auxInitDisplayMode()single-matrix modeIDREF="chap.0310"Porting Matrix and Transformation Callssinglebuffer()IDREF="chap.0422"Porting Display Mode Initialization Calls with auxInitDisplayMode()slices, spheresIDREF="chap.03195"Spheressmooth shadingIDREF="chap.03244"Shading Modelssmoothline()IDREF="chap.03130"Linesspclos()IDREF="chap.03146"Polygons and QuadrilateralsSPECULARIDREF="chap.03465"Porting Lighting and Materials Callsspecular lighting componentsIDREF="chap.03446"Porting Lighting and Materials Callssphdraw()IDREF="chap.03202"SpheresIDREF="chap.03196"Spheressphereusing quadricsIDREF="chap.0396"The IRIS GL Sphere Librarysphere libraryIDREF="chap.0383"The IRIS GL Sphere LibraryspheresIDREF="chap.03195"Spheresslices, stacksIDREF="chap.03195"Spheressphfree()IDREF="chap.03200"Spheressphgnpolys()IDREF="chap.03206"Spheressphmode()IDREF="chap.03204"Spheressphobj()IDREF="chap.03198"Spheressphrotmatrix()IDREF="chap.03205"Spheressplf()IDREF="chap.03145"Polygons and QuadrilateralsSPOTDIRECTIONIDREF="chap.03480"Porting Lighting and Materials CallsSPOTLIGHTIDREF="chap.03482"Porting Lighting and Materials Callsstacks, spheresIDREF="chap.03195"Spheresstate attribute groupsIDREF="chap.033"Porting greset()state variables, saving/restoringIDREF="chap.032"Porting greset()stencil function flagsIDREF="chap.03404"Stencil Plane Callsstencil planesIDREF="chap.03393"Stencil Plane Callsstencil()IDREF="chap.03396"Stencil Plane CallsIDREF="chap.0423"Porting Display Mode Initialization Calls with auxInitDisplayMode()stencil-buffer modeauxiliary libraryIDREF="chap.0410"Porting Display Mode Initialization Calls with auxInitDisplayMode()stensize()IDREF="chap.03395"Stencil Plane Callssteps to portingIDREF="chap.013"How to Port Your Code to OpenGLstippled polygonsIDREF="chap.03165"Polygon Stipplesstored definitionsIDREF="chap.03434"Porting defs, binds, and sets: Replacing `Tables' of Stored Definitionsstride parameter, NURBSIDREF="chap.03302"NURBS ObjectsstringsIDREF="chap.0526"Fonts and Stringssubpixel modeIDREF="chap.03337"Porting Antialiasing Callssurface types, NURBSIDREF="chap.03335"NURBS SurfacessurfacesIDREF="chap.03284"Porting Curve and Surface Commandssurfaces, NURBSIDREF="chap.03326"NURBS Surfacesswaptmesh()IDREF="chap.03184"Trianglesswritemask()IDREF="chap.03400"Stencil Plane Callst2()IDREF="chap.03509"Porting Texture CallstablesIDREF="chap.03434"Porting defs, binds, and sets: Replacing `Tables' of Stored Definitionstessellated polygonsIDREF="chap.03174"Tessellated PolygonsIDREF="chap.03136"Polygons and Quadrilateralstest functions, alphaIDREF="chap.03346"afunction() test functionstevbind()IDREF="chap.03506"Porting Texture CallsIDREF="chap.03438"Porting defs, binds, and sets: Replacing `Tables' of Stored Definitionstevdef()IDREF="chap.03504"Porting Texture CallsIDREF="chap.03437"Porting defs, binds, and sets: Replacing `Tables' of Stored DefinitionsIDREF="chap.03519"Translating tevdef()texbind()IDREF="chap.03500"Porting Texture CallsIDREF="chap.03440"Porting defs, binds, and sets: Replacing `Tables' of Stored Definitionstexdef()IDREF="chap.03530"Translating texdef()IDREF="chap.03439"Porting defs, binds, and sets: Replacing `Tables' of Stored Definitionstexdef2d()IDREF="chap.03496"Porting Texture Callstexgen()IDREF="chap.03554"Translating texgen()IDREF="chap.03512"Porting Texture Callstext handlingIDREF="chap.0525"Fonts and Stringstexturewith quadricsIDREF="chap.0396"The IRIS GL Sphere LibrarytexturesIDREF="chap.03491"Porting Texture CallsTG_CONTOURIDREF="chap.03567"Translating texgen()TG_LINEARIDREF="chap.03564"Translating texgen()TG_SPHEREMAPIDREF="chap.03570"Translating texgen()toogland spaces, tabsIDREF="chap.026"Hints for Using toogl EffectivelyC comments andIDREF="chap.0210"Hints for Using toogl Effectively callingIDREF="chap.021"How to Get and Call tooglcommentsIDREF="chap.025"What toogl Will and Won't Do for Youdevice callsIDREF="chap.0212"Windowing, Device, and Event Callsediting outputIDREF="chap.0211"Editing† †toogl Output: Areas that Need Special Attentionevent callsIDREF="chap.0212"Windowing, Device, and Event CallsoptionsIDREF="chap.022"How to Get and Call tooglparentheses and quotesIDREF="chap.0213"Parentheses and Quotesprocessing entire directoryIDREF="chap.023"How to Get and Call toogltipsIDREF="chap.028"Hints for Using toogl Effectivelywindowing callsIDREF="chap.0212"Windowing, Device, and Event CallstransformationsIDREF="chap.0310"Porting Matrix and Transformation Callstranslate()IDREF="chap.0349"Porting Matrix and Transformation CallstraversalIDREF="chap.0552"About the GLwDrawingArea Widgettriangle fansIDREF="chap.03183"Trianglestriangle stripsIDREF="chap.03183"TrianglestrianglesIDREF="chap.03183"Trianglestrimming curvesIDREF="chap.03316"Trimming CurvesTV_ALPHAIDREF="chap.03528"Translating tevdef()TV_BLENDIDREF="chap.03524"Translating tevdef()TV_COLORIDREF="chap.03526"Translating tevdef()TV_COMPONENT_SELECTIDREF="chap.03529"Translating tevdef()TV_DECALIDREF="chap.03522"Translating tevdef()TV_MODULATEIDREF="chap.03520"Translating tevdef()two-sided lightingIDREF="chap.03489"Porting Lighting and Materials CallsTX_BILINEARIDREF="chap.03544"Translating texdef()TX_MAGFILTERIDREF="chap.03533"Translating texdef()TX_MINFILTERIDREF="chap.03531"Translating texdef()TX_MIPMAP_BILINEARIDREF="chap.03548"Translating texdef()TX_MIPMAP_LINEARIDREF="chap.03550"Translating texdef()TX_MIPMAP_POINTIDREF="chap.03546"Translating texdef()TX_POINTIDREF="chap.03542"Translating texdef()TX_QIDREF="chap.03562"Translating texgen()TX_RIDREF="chap.03560"Translating texgen()TX_SIDREF="chap.03556"Translating texgen()TX_TIDREF="chap.03558"Translating texgen()TX_TRILINEARIDREF="chap.03552"Translating texdef()TX_WRAPIDREF="chap.03538"Translating texdef()IDREF="chap.03535"Translating texdef()TX_WRAP_SIDREF="chap.03536"Translating texdef()TX_WRAP_TIDREF="chap.03539"Translating texdef()User Interface LanguageIDREF="chap.0534"Porting to Mixed-Model Using Xt and a Widget Setv()IDREF="chap.0397"The v() CommandsverticesIDREF="chap.0397"The v() Commandsviewport()IDREF="chap.0372"Viewports, Screenmasks, and Scrboxesvisualfor stencil planesIDREF="chap.03393"Stencil Plane Callswidget setIDREF="chap.0513"Using Xt and a Widget Setwidget setsIDREF="chap.0532"Porting to Mixed-Model Using Xt and a Widget Setwindow depthIDREF="chap.0518"You Can't Change Window Depth and Display Modewindow()IDREF="chap.0352"Porting Matrix and Transformation Callswindowingevent handlingIDREF="chap.045"Windowingwindowing callstooglIDREF="chap.0212"Windowing, Device, and Event Callswindowsmixed modelIDREF="chap.057"What Is a Mixed-Model Program?winopen()IDREF="chap.0510"What Is a Mixed-Model Program?IDREF="chap.0428"Replacing winopen() with auxInitWindow()wmpack()IDREF="chap.03225"Color CallsWorkProcIDREF="chap.0563"Using the OpenGL Widgetwritemask()IDREF="chap.03223"Color CallswritemasksIDREF="chap.03207"Porting Color, Shading, and Writemask CommandsXmixed modelIDREF="chap.054"What Is a Mixed-Model Program?X and GL mixed programs, see mixed-model programmingIDREF="chap.053"OpenGL/X Mixed-Model ProgrammingX bitmap fontsIDREF="chap.0529"Fonts and StringsX documentationIDREF="intro1"† †Where To Get More InformationX functionsXSetWMColormapWindows()IDREF="chap.0521"Installing Color MapsIDREF="chap.0519"Installing Color MapsXCreateWindow()IDREF="chap.0570"Mixed-Model Programming Using Xlib and OpenGL GLX CommandsXlibIDREF="chap.0512"Two Choices For Mixed-Model ProgrammingIDREF="chap.0566"Mixed-Model Programming Using Xlib and OpenGL GLX Commandscolor mapsIDREF="chap.0573"X Color Mapsevent handlingIDREF="chap.0574"A Sample X Event LoopXmForm widgetIDREF="chap.0562"Using the OpenGL WidgetXOpenDisplay()IDREF="chap.0567"Mixed-Model Programming Using Xlib and OpenGL GLX CommandsXStoreColor()IDREF="chap.03221"Color CallsXtIDREF="chap.0512"Two Choices For Mixed-Model ProgrammingIDREF="chap.0532"Porting to Mixed-Model Using Xt and a Widget SetIDREF="chap.0536"What You Need to Know About Xt and IRIS IMmixed model programmingIDREF="chap.0556"Using the OpenGL Widgetzbuffer()IDREF="chap.0424"Porting Display Mode Initialization Calls with auxInitDisplayMode()zclear()IDREF="chap.038"Porting Screen and Buffer Clearing Commandszwritemask()IDREF="chap.03231"Color Calls