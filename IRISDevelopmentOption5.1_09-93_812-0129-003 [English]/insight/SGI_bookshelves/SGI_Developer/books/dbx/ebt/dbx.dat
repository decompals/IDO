#EDIR DATA#
dbx User's GuideDocument Number 007-0906-070ContributorsWritten by Ken JonesEdited by Loraine McCormickProduction by Gloria AckleyEngineering contributions by David Anderson and Wei-min Pan© Copyright 1992-1993, Silicon Graphics, Inc.name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' All Rights ReservedThis document contains proprietary and confidential information of Silicon Graphics, Inc. The contents of this document may not be disclosed to third parties, copied, or duplicated in any form, in whole or in part, without the prior written permission of Silicon Graphics, Inc.Restricted Rights LegendUse, duplication, or disclosure of the technical data contained in this document by the Government is subject to restrictions as set forth in subdivision (c) (1) (ii) of the Rights in Technical Data and Computer Software clause at DFARS 52.227-7013 and/or in similar or successor clauses in the FAR, or in the DOD or NASA FAR Supplement. Unpublished rights reserved under the Copyright Laws of the United States. Contractor/manufacturer is Silicon Graphics, Inc., 2011 N. Shoreline Blvd., Mountain View, CA 94039-7311.dbx User's GuideDocument Number 007-0906-070Silicon Graphics, Inc.Mountain View, CaliforniaSilicon Graphics and IRIS are registered trademarks and IRIX is a trademark of Silicon Graphics, Inc.IntroductionThis manual explains how to use the source level debugger, dbx. You can use dbx to debug programs in C, Fortran 77, Pascal, assembly language, and machine code.LBL="" HELPID=""AudienceThis manual is for programmers. It assumes that you are familiar with general debugging techniques.LBL="" HELPID=""Contents OverviewThis manual describes the features of dbx and provides simple examples of how to use dbx to debug programs. Brief descriptions of the chapters in this manual follow:IDREF="99146" TYPE="TITLE"Chapter 1, "Getting Started with dbx," introduces some basic dbx commands and discusses some tips about how to approach a debugging session.IDREF="16930" TYPE="TITLE"Chapter 2, "Running dbx," explains how to run dbx and perform basic dbx control functions.IDREF="58524" TYPE="TITLE"Chapter 3, "Running Your Program under dbx," explains how to run a program under dbx control.IDREF="41478" TYPE="TITLE"Chapter 4, "Examining Source Files," explains how to examine source files under dbx.IDREF="97856" TYPE="TITLE"Chapter 5, "Controlling dbx," describes features of dbx that affect its operation while debugging a program.IDREF="74286" TYPE="TITLE"Chapter 6, "Examining and Changing Data," describes how to examine and change data in your program while running it under dbx.IDREF="85798" TYPE="TITLE"Chapter 7, "Controlling Program Execution," describes how to use the dbx commands that control execution of your program.IDREF="28107" TYPE="TITLE"Chapter 8, "Debugging Machine Language Code," explains how to debug machine language code.IDREF="61722" TYPE="TITLE"Chapter 9, "Multiple Process Debugging," explains multiprocess debugging procedures.IDREF="37598" TYPE="TITLE"Appendix A, "dbx Commands," lists and describes all dbx commands.IDREF="14532" TYPE="TITLE"Appendix B, "Predefined Aliases," lists and describes all predefined dbx aliases.IDREF="54810" TYPE="TITLE"Appendix C, "Predefined dbx Variables," lists and describes all predefined dbx variables.LBL="" HELPID=""ConventionsThe conventions used in this manual help make information easy to access and understand. The following list describes the conventions and how they are used:Command names, including dbx commands, appear in italics. For example:The edit command lets you edit files from within dbx.Examples, shell prompts, and information displayed on the screen appear in a typewriter font. For example:Process 946: [6] trace count in mainExamples of what you enter are in boldface typewriter font. This example illustrates entering edit soar.c in response to a (dbx) prompt:(dbx) edit soar.cCommand arguments you replace with actual values appear in italics. In this example, you replace name with the name of an alias:alias   nameOptional arguments are enclosed in square brackets ([ ... ]). In the following example, you can provide one or more directory names as arguments to the command:use [ dir ... ]Mutually exclusive arguments to a command are enclosed in braces ({ ... }) and separated by a pipe character (|). In the first example below, you can provide either an activation level or a procedure name as an argument to the command. In the second example, because the argument choices are enclosed in square brackets, you can use either the call or return argument, or omit an argument to the command:func { activation_level | procedure }
syscall   catch [{ call | return }]File and directory names appear in italics. For example:You can put any dbx command in the .dbxinit file.New terms appear in italics. For example:Each procedure on the stack defines an activation level.LBL="" HELPID=""Quick Reference Command SamplesBelow are samples of dbx commands, listed by the chapter in which each command is described. This list provides you with some examples of dbx commands, and you can use it as a quick index of the commands covered in each chapter.IDREF="16930" TYPE="TITLE"Chapter 2, "Running dbx"help
help all
help playback
quit
sh cat small.c++IDREF="58524" TYPE="TITLE"Chapter 3, "Running Your Program under dbx"corefile tmp_core
givenfile my_program
rerun
run
run -f <indata >outdataIDREF="41478" TYPE="TITLE"Chapter 4, "Examining Source Files"/errno
?[iI]mg
dir
dir /usr/local/src
edit special.c
file procedure.c
list
list 1,30
list 75:15
use /usr/srcIDREF="97856" TYPE="TITLE"Chapter 5, "Controlling dbx"!!
!pr
alias
alias bp
alias pa "print \"a = \", a"
hed
hed 1,9
hed all
history
playback input
playback output my_journal
record
record input script
record output
set
set $k = 200
unalias pa
unrecord 4
unrecord all
unset $kIDREF="74286" TYPE="TITLE"Chapter 6, "Examining and Changing Data"assign c = 27
ccall func(y,3)
down
dump .
dump main
func somefunc
print prime(7)
print $pc
printf "8.1f %d\n", fv2, ival
up 4
whatis x
where
whereis yIDREF="85798" TYPE="TITLE"Chapter 7, "Controlling Program Execution"catch USR1
catch all
cont
cont to 49
cont sigfpe
delete 3
delete all
disable 3
enable 3
ignore INT
goto 57
next
return
status
step 10
stop at 37
stop in my_function
stop my_variable at 37 if (x = 2)
syscall catch call exit
trace my_function
trace my_variable in my_function
when my_variable {$my_var_changed = $my_var_changed + 1}
when at 44 {print i, k}IDREF="28107" TYPE="TITLE"Chapter 8, "Debugging Machine Language Code"&z/8x
$pc-40/10i
$sp/20X
conti
conti sigfpe
nexti
printregs
stepi 10
stopi at 0x400abc
tracei my_variable at 0x400abc
wheni at 0x400abc {print i, k}IDREF="61722" TYPE="TITLE"Chapter 9, "Multiple Process Debugging"active 9876
addpgrp 3456
addproc 1234
delete 10 pgrp
delpgrp 3456
delproc 1234
kill 1234
resume sigfpe
resume pid 3456
showpgrp
showproc
status pgrp
stop at 40 pgrp
suspend pid 9876
wait pid 3456
waitallLBL="1"ID="99146"Getting Started with dbxdbx is a source-level debugger. Source-level debuggers let you trace problems in your program at the source code level, rather than at the machine code level. ID="dbx_ch11"ID="dbx_ch12"dbx enables you to control a program's execution, symbolically monitoring program control flow, variables, and memory locations. You can also use dbx to trace the logic and flow of control to acquaint yourself with a program written by someone else.This chapter introduces some basic dbx commands and discusses some tips about how to approach a debugging session. In particular, this chapter describes how to:examine core dumps to determine the cause of a program failure (IDREF="89331" TYPE="TITLE"Section 1.1
)control program execution under dbx to debug a program that produces incorrect results (IDREF="84992" TYPE="TITLE"Section 1.2
)use dbx to study the execution of a program (IDREF="30965" TYPE="TITLE"Section 1.3
) avoid common dbx problems (IDREF="85965" TYPE="TITLE"Section 1.4
)LBL="1.1" HELPID=""ID="89331"Examining Core Dumps to Determine Cause of FailureEven if your program compiles successfully, it still might crash when you try to run it. When a program crashes, it generates a terminating signal that instructs the system to write out to a ID="dbx_ch13"ID="dbx_ch14"core file. The core file is the memory image of the running program.With dbx, you can examine the core file to determine at what point your program crashed. To determine the point of failure, follow these steps:Copy the core file to the directory containing the executable code for the program that failed.If the source code for the program is not contained in the directory and you do not provide dbx with another directory to search for source code (as described in IDREF="35657" TYPE="TITLE"Section 4.1, "Specifying Source Directories"
), then dbx cannot display the source code. However, as long as the program is compiled with the ID="dbx_ch15"-g flag, dbx can still display line numbers and recognize function and variable names.Invoke ID="dbx_ch16"dbx for the failed program as described in IDREF="67611" TYPE="TITLE"Section 2.3, "Invoking dbx."
   dbx automatically reads in the local core file.Perform a stack trace using the ID="dbx_ch17"whereID="dbx_ch18" command (described in IDREF="50445" TYPE="TITLE"Section 6.7, "Examining the Stack"
) to locate the failure point.For example, suppose you examine the core file for a program called test. If the stack trace appears as follows:(dbx) where
>  0 foo2(i = 5) ["/usr/demo/test.c":28, 0x4002cc]
     1 foo(i = 4) ["/usr/demo/test.c":16, 0x40028c]
     2 main(argc = 1, argv = 0x7fffc77c) ["/usr/demo/test.c":54, 0x40035c]then test terminated at line 28 of the source file test.c. The program terminated while executing the function foo2. foo2 was called from line 16 in the function foo, which was in turn called from line 54 in the function main. You can then use the other features of dbx to examine values of program variables and otherwise investigate why test crashed.If you use dbx to debug code that was not compiled using the ID="dbx_ch19"-g flag, local variables are invisible to dbx, and source lines may appear to jump around oddly as a result of various optimizations. If the code is stripped of its symbol table, there is very little information that ID="dbx_ch110"dbx can display.LBL="1.2" HELPID=""ID="84992"Debugging Your ProgramsDebugging a program consists primarily of causing your program to stop under certain conditions and then examining the state of the program stack and the values stored in program variables.ID="dbx_ch111"You stop execution of your program by setting ID="dbx_ch112"breakpoints in your program. Breakpoints can be ID="dbx_ch113"unconditional, in which case they always stop your program, or  ID="dbx_ch114"conditional, in which case they stop your program only if a test condition that you specify is true. Breakpoints are discussed in IDREF="23865" TYPE="TITLE"Section 7.1, "Breakpoints."To use breakpoints to debug your program, examine your program carefully to determine where there are likely to be problems, and set breakpoints in these problem areas. If your program crashes, first determine which line causes it to crash, then set a breakpoint just before that line.There are many dbx commands you can use to trace a variable's value. This is the simplest method for tracing a program variable:Use stopID="dbx_ch115" (described in IDREF="23865" TYPE="TITLE"Section 7.1
) to set breakpoints in the program at locations where you want to examine the state of the program stack or the values stored in program variables.ID="dbx_ch116"Use runID="dbx_ch117" or rerunID="dbx_ch118" (described in IDREF="23899" TYPE="TITLE"Section 3.2, "Running Your Program"
) to run your program under dbx. The program stops at any breakpoint you set.Examine program variables as described in ID="dbx_ch119"IDREF="85784" TYPE="TITLE"Section 6.4.3, "Displaying the Value of a Variable."
   Examine the program stack as described in ID="dbx_ch120"IDREF="50445" TYPE="TITLE"Section 6.7, "Examining the Stack."Use contID="dbx_ch121" (described in IDREF="31983" TYPE="TITLE"Section 7.1.3, "Continuing Execution after a Breakpoint"
) to continue execution past a breakpoint. However, you cannot continue execution past a line that crashes the program.ID="dbx_ch122"LBL="1.3" HELPID=""ID="30965"Studying a New ProgramID="dbx_ch123"dbx is a useful tool for examining the flow of control in a program. When studying the flow of control within a program, use the dbx commands stopID="dbx_ch124", runID="dbx_ch125"/rerunID="dbx_ch126", printID="dbx_ch127", nextID="dbx_ch128", stepID="dbx_ch129", and contID="dbx_ch130". This is the procedure:Use stopID="dbx_ch131" to set breakpoints in the program. When you execute the program under ID="dbx_ch132"dbx, it stops execution at the set breakpoints.If you want to review every line in the program, set a breakpoint on the first executable line. If you don't want to look at each line, set breakpoints just before the sections you intend to review.Use runID="dbx_ch133" and rerunID="dbx_ch134" to run the program under ID="dbx_ch135"dbx. The program stops at each breakpoint.Use printID="dbx_ch136" to print the value of a program variable at a breakpoint.ID="dbx_ch137"Use step, next, or cont to continue past a breakpoint and execute the rest of the program.stepID="dbx_ch138" executes the next line of the program. If the next line is a procedure, ID="dbx_ch139"step steps down into the procedure. step is described in IDREF="33387" TYPE="TITLE"Section 7.7.2, "Stepping Using the step Command."nextID="dbx_ch140" executes the next line; if it is a procedure, ID="dbx_ch141"next executes it but does not step down into it. next is described in IDREF="24643" TYPE="TITLE"Section 7.7.3, "Stepping Using the next Command."contID="dbx_ch142"   resumes execution of the program past a breakpoint and does not stop until it reaches the next breakpoint or the end of the program.ID="dbx_ch143"Another tool that you can use to follow the execution of you program is the traceID="dbx_ch144" command. With it you can examine:values of variables at specific points in your program or whenever variables change valueID="dbx_ch145"parameters passed to and values returned from functionsID="dbx_ch146"line numbers as they are executedID="dbx_ch147"The trace command is described in IDREF="19256" TYPE="TITLE"Section 7.2, "Tracing Program Execution."LBL="1.4" HELPID=""ID="85965"Avoiding Common PitfallsYou may encounter some common problems when you debug a program. These problems and their solutions are listed below:ID="dbx_ch148"If ID="dbx_ch149"ID="dbx_ch150"dbx does not display variables, recompile the program with the ID="dbx_ch151"-g compiler flag.If the debugger's listing seems confused, try separating the lines of source code into logical units. The debugger might get confused if there's more than one source statement on the same line.ID="dbx_ch152"ID="dbx_ch153"If the debugger's executable version of the code doesn't match the source, recompile the source code. The code displayed in the debugger is identical to the executable version of the code.ID="dbx_ch154"ID="dbx_ch155"If code appears to be missing, it may be contained in an include file or a macro. The debugger treats include files and macros as single lines. To debug code from an include file, remove the source from the include file and compile the source as part of your source program. To debug a macro, expand the macro in the source code.ID="dbx_ch156"ID="dbx_ch157"ID="dbx_ch158"ID="dbx_ch159"ID="dbx_ch160"ID="dbx_ch161"LBL="2"ID="16930"Running dbxThis chapter explains how to run dbxname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'specifically, how to:compile your program for debugging under dbx (IDREF="97214" TYPE="TITLE"Section 2.1
)compile and link programs with dynamic shared objects (IDREF="68536" TYPE="TITLE"Section 2.2
)invoke dbx from a shell prompt (IDREF="67611" TYPE="TITLE"Section 2.3
)automatically execute commands on startup (IDREF="87665" TYPE="TITLE"Section 2.4
)get on-line help (IDREF="92439" TYPE="TITLE"Section 2.5
)include multiple commands on a single line (IDREF="79140" TYPE="TITLE"Section 2.6
)split a command across multiple lines (IDREF="94741" TYPE="TITLE"Section 2.7
)invoke a shell from dbx (IDREF="38587" TYPE="TITLE"Section 2.8
)end your debugging session (IDREF="10584" TYPE="TITLE"Section 2.9
)LBL="2.1" HELPID=""ID="97214"Compiling a Program for Debugging under dbxBefore you use ID="dbx_ch21"dbx to debug a program, use the -gID="dbx_ch22" flag to compile the program. The -g compile flag includes additional symbol table information in your program object so that ID="dbx_ch23"dbx can list local variables and find source lines.If you use dbx to debug code that was not compiled using the -g flag, local variables are invisible to dbx, and source lines may appear to jump around oddly as a result of various optimizations. Because it is more difficult to debug code without reliable references to lines of source code, use the -g flag to recompile the program that you want to debug.LBL="2.2" HELPID=""ID="68536"Compiling and Linking Programs with Dynamic Shared Objects (DSOs)This section summarizes a few things you need to know if you compile and link your program with Dynamic Shared Objects (DSOs). A DSO is a relocatable shared library. By linking with a DSO, you keep your program size small and use memory efficiently. See also the ID="dbx_ch24"dbx help section on hint_dso for more information on dbx and DSOs.You cannot link with both a DSO and a non-shared library at the same time. If you compile and link with DSOs, dbx automatically notices their use in the program and picks up the relevant symbol table information. The dbx command ID="dbx_ch25"listobj shows any DSOs in a process. The dbx command ID="dbx_ch26"whichobj lists all DSOs in which the named variable is present. To include the DSO name whenever a variable reference is printed, set the ID="dbx_ch27"$printobjname variable to 1. (Variables are described in IDREF="74286" TYPE="TITLE"Chapter 6
 and in IDREF="54810" TYPE="TITLE"Appendix C
.)See IDREF="58524" TYPE="TITLE"Chapter 3, "Running Your Program under dbx,"
 for more description of the differences between programs compiled and linked with DSOs and programs compiled and linked with non-shared libraries.LBL="2.3" HELPID=""ID="67611"Invoking dbx
To invoke dbx from the shell command line, enter dbx. The syntax is as follows:dbx [ options ] [ object_file [ corefile ]]The object_file is the name of the executable 

object file that you want to debug.The corefile is the name of a 

core dump that dbx should use as "the contents of memory" for the program that you specified. If you specify corefile, dbx lists the point of program failure. For 

core files, you can perform stack traces and examine the code; however, you cannot force the program to execute past the line that caused it to crash.If you don't specify a corefile, dbx examines the current directory for a file named core. If it finds core, and if core seems (based on data in the core file) to be a core dump of the program you specified, dbx acts as if you had specified core as the core file.The other options that you can give to dbx are described in IDREF="38456" TYPE="TABLE"Table 2-1
. These options are described in greater detail in appropriate sections of this manual.COLUMNS="2"LEFT="0" WIDTH="81"OptionLEFT="90" WIDTH="356"DescriptionLEFT="0" WIDTH="81"ID="dbx_ch28"-I   dirLEFT="90" WIDTH="356"Tell dbx to look in the specified directory (in addition to the 
current directory and the object file's directory) for source 
files. To specify multiple directories, use a separate ID="dbx_ch29"-I for 
each. If no directory is specified when you invoke dbx, it 
looks for source files in the current directory and in the 
object file's directory. From dbx, change the directories 
searched for source files with the ID="dbx_ch210"use and ID="dbx_ch211"dir commands.LEFT="0" WIDTH="81"ID="dbx_ch212"-c   fileLEFT="90" WIDTH="356"Select a command file other than ID="dbx_ch213".dbxinit to execute upon 
starting dbx.LEFT="0" WIDTH="81"ID="dbx_ch214"-iLEFT="90" WIDTH="356"Use interactive mode. This option does not treat "#" 
characters as comments in a file. It also prompts for source 
even when it reads from a file and has extra formatting, as if 
for a terminal. ID="dbx_ch215"LEFT="0" WIDTH="81"ID="dbx_ch216"-r   program [ arg ]LEFT="90" WIDTH="356"Run the named program upon entering ID="dbx_ch217"dbx, using the 
specified arguments. The .dbxinit file (if any) is read and 
executed after executing the object_file. You cannot specify a 
core file with -r.LEFT="0" WIDTH="81"ID="dbx_ch218"-p   pidLEFT="90" WIDTH="356"Debug the process specified by the pid number.LEFT="0" WIDTH="81"ID="dbx_ch219"-P   nameLEFT="90" WIDTH="356"Debug the running process with the specified ID="dbx_ch220"name (name as 
described in IRIXÔps(1) man page).LEFT="0" WIDTH="81"ID="dbx_ch221"-xLEFT="90" WIDTH="356"Debug a program that has been processed through the IRIX 
pixieID="dbx_ch222"(1) command. This option has no effect if the program 
has not been processed by pixie. See the help file 
/usr/lib/dbx.help for more information on debugging a pixied 
program.LEFT="0" WIDTH="81"ID="dbx_ch223"-e   numLEFT="90" WIDTH="356"Choose a larger size for the evaluation stack (as large as you 
want). The default stack size is 20,000 bytes. ID="dbx_ch224"num = number 
of bytes.LEFT="0" WIDTH="81"ID="dbx_ch225"-kLEFT="90" WIDTH="356"Turn on kernel debugging. When debugging a running 
system, specify ID="dbx_ch226"/dev/kmem as the core file.LEFT="0" WIDTH="81"ID="dbx_ch227"-CLEFT="90" WIDTH="356"Suppress the automatic translation of C++ variable names. 
This option makes the full long names output by ID="dbx_ch228"cfront to cc 
visible. This is useful when you think dbx has translated a 
name improperly, but it makes C++ code more difficult to 
work with.LBL="2-1"Table 2-1 ID="38456" dbx Command Line OptionsOnce dbx has started, it displays the prompt:ID="dbx_ch229"(dbx) To change this prompt, change the value of the dbx   ID="dbx_ch230"$prompt variable. IDREF="78540" TYPE="TITLE"Section 5.1.1, "Setting dbx Variables,"
 describes how to set dbx variables.LBL="2.4" HELPID=""ID="87665"Automatically Executing Commands on StartupYou can use an editor to create a ID="dbx_ch231".dbxinit command file. This file contains various dbx commands that are automatically executed when you invoke dbx. You can put any dbx command in the .dbxinit file. If any of these commands require input, the system prompts you for it when you invoke dbx.When you invoke dbx, it looks for a .dbxinit file in the current directory. If the current directory does not contain a .dbxinit file, dbx looks for one in your home directory. (This assumes that you have set the IRIX system ID="dbx_ch232"HOME environment variable.)LBL="2.5" HELPID=""ID="92439"On-line HelpThe ID="dbx_ch233"dbx command ID="dbx_ch234"help provides several options:help allshows the entire dbx help filehelp   keywordshows information pertaining to the given keyword, such as most_used, quit, alias, playback, record, and so onWhen you type help all, dbx displays the file using the command name given by the dbx   ID="dbx_ch235"$pager variable. The dbx help file is large and can be difficult to use if you use a simple paging program like more(1). A useful technique is to set the $pager variable to a text editor like vi(1). You can do this automatically upon starting dbx if you put the following command in your .dbxinit file:set $pager = "vi"When the above entry is in your .dbxinit file, dbx displays the help file in your editor. You can then use the editor's search commands to look through the help file quickly. Quit the editor to return to dbx.If you prefer, you can replace vi in the above example with the name of your favorite editor. For more information on this process, type:(dbx) help helpLBL="2.6" HELPID=""ID="79140"Entering Multiple Commands on a Single LineYou can use the semicolon (ID="dbx_ch236";) as a separator to include multiple commands on the same command line. This is particularly useful with commands such as when (described in IDREF="89878" TYPE="TITLE"Section 7.3, "Writing Conditional Commands"
) as it allows you to include multiple commands in the command block:(dbx)   when at "myfile.c":37 {print a ; where ; print b}LBL="2.7" HELPID=""ID="94741"Spanning a Command across Multiple LinesYou can use the backslash (ID="dbx_ch237"\) at the end of a line of input to dbx to indicate that the command is continued on the next line. This can be convenient when entering complex commands such as an alias definition (aliases are discussed in IDREF="37216" TYPE="TITLE"Section 5.3, "dbx Aliases"
):(dbx) alias foll "print *(struct list *)$p ; \
set $p = (int)((struct list *)($p))->next"LBL="2.8" HELPID=""ID="38587"Invoking a ShellTo invoke a subshell, enter ID="dbx_ch238"sh at the dbx prompt, or enter sh and a shell command at the dbx prompt. After invoking a subshell, enter exit or type <Ctrl-d> to return to dbx.The syntax for the sh command is:shID="dbx_ch239"Invoke a subshell.sh   comExecute the specified shell command. ID="dbx_ch240"dbx interprets the remainder of the line as a command to pass to the spawned shell process, unless you enclose the command in double-quotes or you terminate your shell command with a semicolon (;).For example, to spawn a subshell, enter:(dbx) sh
% To display the end of the file datafile, enter:(dbx) sh tail datafileLBL="2.9" HELPID=""ID="10584"Quitting dbxTo end a ID="dbx_ch241"dbx debugging session, enter the ID="dbx_ch242"quit command at the dbx prompt:(dbx) quitLBL="3"ID="58524"Running Your Program under dbxThis chapter explains how to run a program under dbx control. It describes how to:specify object and core files to use (IDREF="89350" TYPE="TITLE"Section 3.1
)run and rerun programs (IDREF="23899" TYPE="TITLE"Section 3.2
)provide arguments to your program (IDREF="45434" TYPE="TITLE"Section 3.1.1
)redirect your program's input and output (IDREF="23899" TYPE="TITLE"Section 3.2
)LBL="3.1" HELPID=""ID="89350"Specifying Object and Core FilesAn object file is an executable file. It provides both the code that dbx executes and the symbol table that provides variable and procedure names and maps executable code to its corresponding source code in source files.A 
core file is produced when a program exits abnormally. dbx allows you to provide the name of a core file that it uses as "the contents of memory" for the program that you specify. If you provide a core file, dbx lists the point of program failure. You can then perform stack traces and examine variable values to determine why a program crashed.You can 

specify object and 

core files either as arguments when you invoke dbx or as commands that you enter at the dbx prompt.LBL="3.1.1" HELPID=""ID="45434"Specifying Files with ArgumentsUsually you provide the object and core file names as arguments when you 

invoke dbx:dbx [ options ] [ object_file [ corefile ]]The object_file is the name of the object file that you want to debug.The corefile is the core file. If you don't specify a corefile, dbx examines the current directory for a file named core. If it finds core, and if core seems (based on data in the core file) to be a core dump of the program you specified, dbx acts as if you had specified core as the core file.LBL="3.1.2" HELPID=""Specifying Files with dbx CommandsThe ID="dbx_ch31"givenfile and ID="dbx_ch32"corefile   dbx commands allow you to set the object file and the core file respectively while dbx is running:givenfileID="dbx_ch33" [ file ]If you provide a file name, dbx kills the currently running processes and loads the executable code and symbol table found in file.If you do not provide a file name, dbx displays the name of the program that it is currently debugging.corefileID="dbx_ch34" [ file ]If you provide a file name, dbx uses the program data stored in the core dump file.If you do not provide a file name, dbx displays the name of the current core file.LBL="3.2" HELPID=""ID="23899"Running Your ProgramYou can start your program under ID="dbx_ch35"dbx using either the ID="dbx_ch36"run or the ID="dbx_ch37"rerun command:runID="dbx_ch38" [ arg1   arg2 ... ] [   <   input_file ] [ >   output_file ] [   >&   error_file ]The run command starts your program and passes to it any arguments that you provide. You can also redirect the program's standard input, standard output, and/or standard error as you would if you were executing your program from the shell.ID="dbx_ch39"ID="dbx_ch310"ID="dbx_ch311"rerunID="dbx_ch312" [ arg1   arg2 ... ] [   <   input_file ] [   >   output_file ] [   >&   error_file ]The ID="dbx_ch313"rerun command starts your program and passes to it any arguments that you provide. You can also redirect the program's standard input, standard output, and/or standard error. If you do not provide any arguments or specify any redirection, ID="dbx_ch314"ID="dbx_ch315"ID="dbx_ch316"rerun uses the same arguments and file redirection that you provided for your last run command.For example, consider a program called sort that takes an input file and produces a sorted output file and that allows you to specify input and output files either through command line arguments or file redirection. In this case, two examples of invoking this program from the command line might be:% sort -i input -o output
% sort < input2 > output2If you are debugging the sort program with dbx, the equivalent commands would be:(dbx) run -i input -o output
(dbx) run < input2 > output2If you execute these run commands in the order presented, you can repeat the latter by entering the rerun command:(dbx) rerunLBL="3.2.1" HELPID=""Programs Linked with DSOsWhen a program using DSOs is started under ID="dbx_ch317"dbx, by default dbx runs the program up to main (in Fortran, to MAIN_). This allows the runtime linker, ID="dbx_ch318"rld, to set up the program and all of its DSOs. When a running program that uses DSOs calls exec(), dbx automatically runs the new program to its main (or in Fortran, to MAIN_). Again, this allows the runtime linker to set up the new application and its DSOs.If you do not want the program to run to main, set the ID="dbx_ch319"$onexecruntomain variable to 0. The program then stops at the exit of the exec() system call.A DSO cannot be named "main."LBL="3.2.2" HELPID=""Programs Linked with Non-shared LibrariesWhen a program linked with a non-shared library is started under ID="dbx_ch320"dbx, dbx stops before it begins program execution.When a program linked with a non-shared library calls ID="dbx_ch321"exec(), the program stops at the exit of the exec() system call.LBL="4"ID="41478"Examining Source FilesThis chapter explains how to examine source files under dbx. It describes how to:specify source directories (IDREF="35657" TYPE="TITLE"Section 4.1
)change source files (IDREF="41684" TYPE="TITLE"Section 4.2
)list source code (IDREF="59599" TYPE="TITLE"Section 4.3
)search for strings in source code (IDREF="91727" TYPE="TITLE"Section 4.4
)call an editor from dbx (IDREF="33324" TYPE="TITLE"Section 4.5
)LBL="4.1" HELPID=""ID="35657"Specifying Source DirectoriesBased on the information contained in an object file's symbol table, dbx determines from which source files the program was compiled and prints portions of these files as appropriate.ID="dbx_ch41"Object files compiled with ID="dbx_ch42"ID="dbx_ch43"-g, -g2, or -g3 record both the source file names and the absolute path names to the source files. Each time dbx needs a source file, it first searches the absolute path for the source file. If the source file is not present (or if the object file was not compiled with -g, -g2, or -g3), dbx checks its own list of directories for source files.By default, the dbx directory list contains only the current directory (from which you invoked ID="dbx_ch44"dbx) and the object file's directory (if it is different from the current directory). Each time dbx searches this list, it searches all directories in the list in the order in which they appear until it finds the file with the specified name.LBL="4.1.1" HELPID=""Specifying Source Directories with ArgumentsYou can specify additional source directories when you invoke ID="dbx_ch45"dbx with the IID="dbx_ch46" option. To specify multiple directories, use a separate -I for each.For example, consider debugging a program called look in /usr/local/bin, the source for which resides in /usr/local/src/look.c. To debug this program, you can invoke dbx from the /usr/local/bin directory by entering:% dbx -I /usr/local/src lookLBL="4.1.2" HELPID=""Specifying Source Directories with dbx CommandsThe ID="dbx_ch47"dir and ID="dbx_ch48"use   dbx commands allow you to modify the source directory list while dbx is running:dirID="dbx_ch49" [ dir ... ]If you provide one or more directories, ID="dbx_ch410"dbx adds those directories to the end of the source directory list.If you do not provide any directories, dbx displays the current source directory list.useID="dbx_ch411" [ dir ... ]If you provide one or more directories, ID="dbx_ch412"dbx replaces the source directory list with the directories that you provide.If you do not provide any directories, dbx displays the current source directory list.Both the dir and use commands recognize absolute and relative pathnames (for example, ../src); however, they do not recognize C shell tilde (~) syntax (for example, ~john/src) or environment variables (for example, $HOME/src).Consider debugging the look program in /usr/local/bin, the source for which resides in /usr/local/src/look.c. If you invoked dbx from the /usr/local/bin directory without specifying /usr/local/src as a source directory, it will not initially appear in the directory list:(dbx) dir
.You can add /usr/local/src with the dir command by entering:(dbx) dir /usr/local/src
(dbx) dir
. /usr/local/srcIf you use the use command instead, the current directory is no longer contained in the source directory list:(dbx) use /usr/local/src
(dbx) use
/usr/local/srcLBL="4.2" HELPID=""ID="41684"Changing Source FilesThe ID="dbx_ch413"file   command changes the current source file to a file that you specify. The new file becomes the current source file, on which you can search, list, and perform other operations. For example to set the current source file to ID="dbx_ch414"ID="dbx_ch415"procedure.c, enter:(dbx) file procedure.cIf your program is large, you probably store the source code in multiple files. dbx automatically selects the proper source file for the section of code that you are examining. Thus, many dbx commands reset the current source file as a side effect. For example, when you move up and down activation levels in the stack using the up and down commands, dbx changes the current source file to whatever file contains the source for the procedure (see IDREF="50445" TYPE="TITLE"Section 6.7, "Examining the Stack,"
 for more information on activation levels).If you enter the file command without any arguments, dbx prints the current source file:(dbx) file
procedure.cLBL="4.3" HELPID=""ID="59599"Listing Source CodeThe list command displays lines of source code. The dbx variable ID="dbx_ch416"$listwindow defines the number of lines dbx lists by default. The list command uses the current file and line unless otherwise specified. After displaying the specified lines, it sets the current line to immediately follow the last line displayed.ID="dbx_ch417"The syntax for the list command is:listID="dbx_ch418"List ID="dbx_ch419"$listwindow lines beginning at the current line.list   expList ID="dbx_ch420"$listwindow lines starting with the line number given by the expression exp. The expression may be any valid expression that evaluates to an integer value as described in IDREF="25993" TYPE="TITLE"Section 6.1, "Expressions."list   exp1:exp2List exp2 lines, beginning at line exp1.list   exp1,exp2List all source between line exp1 and line exp2 inclusive.For example, to list lines 20­35 of a file, enter:(dbx) list 20,35In response to this command, dbx displays lines 20 through 35 and sets the current line to 36.To list 15 lines starting with line 75, enter:(dbx) list 75:15In response to this command, dbx displays lines 75 through 89 and sets the current line to 90.LBL="4.4" HELPID=""ID="91727"Searching Through Source CodeThe forward slash (ID="dbx_ch421"/ID="dbx_ch422") and question mark (?ID="dbx_ch423") commands search through the current file for regular expressions in source code. For a description of regular expressions, consult the IRIX ed(1) man page.The search commands have the following syntax:ID="dbx_ch424"/[   reg_exp ]Search forward through the current file from the current line for the regular expression ID="dbx_ch425"regexp. If dbx reaches the end of the file without finding the regular expression, it wraps around to the beginning of the file. dbx prints the first source line containing a match of the search expression.If you do not supply a regular expression, dbx searches forward based on the last regular expression you searched for.ID="dbx_ch426"?[   reg_exp ]Search backward through the current file from the current line for the regular expression ID="dbx_ch427"regexp. If dbx reaches the beginning of the file without finding the regular expression, it wraps around to the end of the file. dbx prints the first source line containing a match of the search expression.If you do not supply a regular expression, dbx searches backward based on the last regular expression you searched for.For example, to search for the next occurrence of the string "errno," enter:(dbx) /errnoTo search for the previous occurrence of either "img" or "Img," enter:(dbx) ?[iI]mgLBL="4.5" HELPID=""ID="33324"Calling an EditorThe ID="dbx_ch428"edit command lets you edit files from within ID="dbx_ch429"dbx:editID="dbx_ch430" [ file | procedure ]Edit a file. If you have set the dbx variable ID="dbx_ch431"$editor to the name of an editor, the edit command invokes that editor on the source file. If you have not set the dbx variable $editor, dbx checks whether you have set the environment variable ID="dbx_ch432"EDITOR and, if so, invokes that editor. If you have not set either the dbx variable or the environment variable, dbx invokes the vi editor. When you exit the editor, you return to the dbx prompt.If you supply a file name, edit invokes the editor on the given file. If you supply the name of a procedure, edit invokes the editor on the file that contains the source for that procedure. If you do not supply either a file name or a procedure name, edit invokes the editor on the current source file.For example, to edit a file named   soar.c from within dbx, type:(dbx) edit soar.cThe edit command is also useful for editing dbx script files. See IDREF="60766" TYPE="TITLE"Section 5.5, "Executing dbx Scripts,"
 for more information on script files.LBL="5"ID="97856"Controlling dbxThis chapter describes features of dbx that affect its operation while debugging a program. Specifically, it describes:creating and removing dbx variables (IDREF="88718" TYPE="TITLE"Section 5.1
)using the history feature and the history editor (IDREF="82250" TYPE="TITLE"Section 5.2
)creating and removing command aliases (IDREF="37216" TYPE="TITLE"Section 5.3
)recording and playing back input and output (IDREF="43528" TYPE="TITLE"Section 5.4
)executing dbx scripts (IDREF="60766" TYPE="TITLE"Section 5.5
)LBL="5.1" HELPID=""ID="88718"dbx Variablesdbx allows you to define variables that you can use within ID="dbx_ch51"dbx to store values. These variables exist entirely within dbx; they are not part of your program. You can use dbx variables for a variety of purposes while debugging. For example, you can use dbx variables as temporary storage, counters, or pointers that you use to step through arrays.dbx also provides many predefined variables that control how various ID="dbx_ch52"dbx commands function. IDREF="54810" TYPE="TITLE"Appendix C, "Predefined dbx Variables,"
 provides a complete list of predefined dbx variables and their purposes.dbx variables do not have fixed types. You can assign a dbx variable any type of value, even if it already has a value of a different type.You can use practically any name for dbx variables. A good practice to follow is to use a dollar sign ($) as the first character of all dbx variables to prevent conflicts with most program variable names. All of dbx's predefined variables begin with a dollar sign.The commands described in this section apply only to the manipulations of dbx variables, not program variables. IDREF="50911" TYPE="TITLE"Section 6.4, "Program Variables,"
 describes how to manipulate program variables.LBL="5.1.1" HELPID=""ID="78540"Setting dbx VariablesThe ID="dbx_ch53"ID="dbx_ch54"set command sets a dbx variable to a given value, defining the variable if it does not exist:setID="dbx_ch55"   var   =   expDefine (or redefine) the specified ID="dbx_ch56"dbx variable, setting its value of that of the expression you provide.You display the value of a variable with the ID="dbx_ch57"print command, for example:(dbx) set $k = 1
(dbx) print $k
1
(dbx) set $k = $k +23
(dbx) print $k
24
(dbx) print $k // 11
2In the last example, dbx performs an integer division because both the variable $k and the constant 11 are integers. If you assign a floating point value to $k and evaluate the expression again, dbx performs a floating point division:(dbx) set $k = 24.0
(dbx) print $k
24.0
(dbx) print $k // 11
2.1818181818181817LBL="5.1.2" HELPID=""Listing dbx VariablesIf you enter the ID="dbx_ch58"ID="dbx_ch59"set command without providing any arguments, dbx displays a list of all currently defined dbx variables, including predefined variables. For example:(dbx) set
$addrfmt        "0x%x"
$assumenormalframe      0
$casesense      2
    ...
$tagfile        "tags"
$visiblemangled 0
$visiblestackwalk       0LBL="5.1.3" HELPID=""Removing VariablesThe ID="dbx_ch510"ID="dbx_ch511"unset command removes a dbx variable. For example, to delete the variable $k, enter:(dbx) unset $kLBL="5.2" HELPID=""ID="82250"The History FeatureThe dbx   history feature is similar to the C shell's history feature in that it allows you to repeat commands that you have entered previously. However, unlike the C shell's history feature, ID="dbx_ch512"ID="dbx_ch513"dbx does not allow you to execute a history command anywhere except the beginning of a line. Also, dbx does not support history substitution of command arguments such as the C shell !$ argument.LBL="5.2.1" HELPID=""Examining the History Listdbx stores all commands that you enter in the history list. The value of the ID="dbx_ch514"dbx variable $lines determines how many commands are stored in the history list. The default value is 100.You display the history list with the ID="dbx_ch515"ID="dbx_ch516"history command. For example, after setting a breakpoint, running a program, and examining some variables, your history list might look something like this:(dbx) history
    1     stop in foo
    2     run
    3     whatis i
    4     whatis k
    5     which i
    6     historyLBL="5.2.2" HELPID=""Repeating CommandsYou can execute any of the commands contained in the history list. There are four history execution commands; each begins with an exclamation point (ID="dbx_ch517"ID="dbx_ch518"!):ID="dbx_ch519"!!Repeat the previous command. If the value of the dbx variable ID="dbx_ch520"$repeatmode is set to 1, then entering a carriage return at an empty line is equivalent to executing !!. By default, $repeatmode is set to 0.ID="dbx_ch521"!stringRepeat the most recent command that starts with the specified string.ID="dbx_ch522"!integerRepeat the command associated with the specified integer in the history list.ID="dbx_ch523"!-integerRepeat the command that occurred integer times before the most recent command. Entering !-1 executes the previous command, !-2 the command before that, and so forth.For example, you can use the !!ID="dbx_ch524" command to facilitate single-stepping through your program. (Single-stepping is described in IDREF="31135" TYPE="TITLE"Section 7.7, "Stepping Through Your Program."
) The following illustrates using the next command to execute 5 lines of source code and then using the !! command to repeat the next command:(dbx) next 5
Process 28116 (test2) stopped at [main:46 ,0x400290]
     46 count = 0;
(dbx) !!
(!! = next 5)
Process 28116 (test2) stopped at [main:53 ,0x4002d4]
    53 j = foo( i );Another convenient way to repeat a commonly used command is with ID="dbx_ch525"!string. For example, suppose that you occasionally print the values of certain variables using the printf command while running your program under dbx. (The printf command is described in IDREF="17137" TYPE="TITLE"Section 6.2, "Printing Expressions."
) In this case, as long as you do not enter any command beginning with "pr" after you enter the printf command, you can repeat the printf command by entering !pr:(dbx) printf "i = %d, j = %d, total = %d\n", i, j, total
i = 4, j = 25, total = 1
    ...
(dbx) !pr
(!pr = printf "i = %d, j = %d, total = %d\n", i, j, total)
i = 7, j = 19, total = 392Using ID="dbx_ch526"!integer, you can repeat any command in the history list. If you want to repeat the printf command, but you have entered a subsequent print command, examine the history list and then explicitly repeat the printf command using its reference number:(dbx) history
    1     stop in foo
    2     run
    ...
    45    printf "i = %d, j = %d, total = %d\n", i, j, total
    46    next
    ...
    49    print j
    ...
    53    history
(dbx) !45
(!45 = printf "i = %d, j = %d, total = %d\n", i, j, total)
i = 9, j = 43, total = 1084LBL="5.2.3" HELPID=""The History EditorThe history editor, ID="dbx_ch527"ID="dbx_ch528"hed, lets you use your favorite editor on any or all of the commands in the current dbx   history list. When you enter the ID="dbx_ch529"hed command, dbx copies all or part of the history list into a temporary file that you can edit. When you quit the editor, any commands left in this temporary file are automatically executed by dbx.If you have set the dbx variable ID="dbx_ch530"$editor to the name of an editor, the hed command invokes that editor. If you have not set the dbx variable $editor, dbx checks whether you have set the environment variable ID="dbx_ch531"EDITOR and, if so, invokes that editor. If you have not set either the dbx variable or the environment variable, dbx invokes the vi editor.The syntax for the hed commands is:hedID="dbx_ch532"Edit only the last line of the history list (the last command executed).hedID="dbx_ch533"   num1,num2Edit the lines in the history list from num1 through num2.hed allID="dbx_ch534"Edit the entire history list.By default, dbx does not display the commands that it executes as a result of the hed command. If the value of the dbx variable ID="dbx_ch535"$pimode is set to 1, then dbx does display the commands as it executes them. By default, $pimode is set to 0.LBL="5.3" HELPID=""ID="37216"dbx Aliasesdbx lets you create aliases for debugger commands. You can then use these aliases as you would any other ID="dbx_ch536"dbx command. When dbx encounters an alias, it expands it using the definition you provided.dbx has a group of predefined aliases that you can modify or delete. These aliases are listed and described in ID="dbx_ch537"IDREF="14532" TYPE="TITLE"Appendix B, "Predefined Aliases."If you find that you often create the same aliases in your debugging sessions, you can include their definitions in your .dbxinit file so that they are automatically defined for you. See 
IDREF="87665" TYPE="TEXT"
Section 2.4, "Automatically Executing Commands on Startup,"
 for more information on the .dbxinit file.LBL="5.3.1" HELPID=""Listing AliasesYou can display the definition of aliases using the ID="dbx_ch538"ID="dbx_ch539"alias command:aliasID="dbx_ch540"List all existing aliases.aliasID="dbx_ch541"   nameList the alias definition for name.For example, to display the definitions of the predefined aliases "l" and "bp," enter:(dbx) alias l
"list"
(dbx) alias bp
"stop in"LBL="5.3.2" HELPID=""Creating Command AliasesYou also use the ID="dbx_ch542"ID="dbx_ch543"alias command to define new aliases:aliasID="dbx_ch544"   name   commandDefine ID="dbx_ch545"name as an alias for command.aliasID="dbx_ch546"   name   "string"Define ID="dbx_ch547"name as an alias for string. With this form of the alias command, you can provide command arguments in the alias definition.aliasID="dbx_ch548"   name(arg1 [, ... argN])   "string"Define ID="dbx_ch549"name as an alias for string. arg1 through argN are arguments to the alias, appearing in the string definition. When you use the alias, you must provide values for the arguments, which dbx then substitutes in string.The simplest form of an alias is to redefine a dbx command with a short alias. Many of the predefined dbx aliases fall into this category: "a" is an alias for the assign command, "s" is an alias for the step command. When you use one of these aliases, dbx simply replaces it with the command for which it is an alias. Any arguments that you include on the command line are passed to the command.For example, if you to create "gf" as an alias for the givenfile command, enter:(dbx) alias gf givenfile
(dbx) alias gf
"givenfile"
(dbx) gf
Current givenfile is test and its processid is 29957
(dbx) gf test2
Process 29957 (test) terminated
Reading symbolic information of `test2' . . .
cannot open corefile core
(dbx) gf
Current givenfile is test2 and its processid is 0More complex alias definitions require more than the name of a command. In these cases, you must enclose the entire alias definition string in double quotation marks ("). For example, you can define a brief alias to print the value of a variable that you commonly examine. Note that in this example you must use the escape character (\) to include the double quotation marks (") as part of the alias definition:(dbx) alias pa "print \"a =\", a"
(dbx) alias pa
"print \"a =\", a"
(dbx) pa
a = 3You can also define an alias so that you can pass arguments to it, much in the same way that you can provide arguments in a C language macro definition. When you use the alias, you must include the arguments. dbx then substitutes the values that you provide in the alias definition.To illustrate this, consider the following alias definition:(dbx) alias p (arg1, arg2, arg3, arg4) "print '|arg1|arg2|arg3|arg4|'"
(dbx) alias p
(arg1, arg2, arg3, arg4)"print '|arg1|arg2|arg3|arg4|'"The "p" alias takes four arguments and prints them surrounded by vertical bars (|). For example:(dbx) p(1,2,3,4)
|1|2|3|4|
(dbx) p( first, second, 3rd,4)
| first| second| 3rd|4|In the above example, dbx retains any spaces that you enter when calling an alias.You can also omit arguments when calling an alias as long as you include the commas as argument separators in the alias call:(dbx) p(a,,b,c)
|a||b|c|
(dbx) p(,first missing, preceding space,)
||first missing| preceding space||LBL="5.3.3" HELPID=""Removing Command AliasesThe ID="dbx_ch550"ID="dbx_ch551"unalias command removes the alias you provide as an argument. For example, to remove the "pa" alias defined in the previous section, enter:(dbx) unalias paYou can remove any of the predefined dbx aliases; however, these aliases are restored the next time you start dbx.LBL="5.3.4" HELPID=""Alias ExampleAn easy way to follow linked lists is to use aliases and casts. This example shows how to construct an alias that follows a simple linked list with members defined by the following structure:ID="dbx_ch552"ID="dbx_ch553"struct list { struct list *next; int value; };In this example, a dbx variable called $p is used as a pointer to a member of the linked list. You can define a alias called "foll" to print the contents of the list member to which $p currently points and then advance to the next list member. Because the command is too long to fit onto one line, this example uses the backslash character (\) to continue the command on a second line:(dbx) alias foll "print *(struct list *)$p ; \
set $p = (long)((struct list *)($p))->next"Casting $p to an integer type when following the link (the second assignment in the alias) is essential. If left off, dbx leaves the $p reference symbolic and dbx gets into an infinite loop. (Type <Ctrl-c> to interrupt dbx if it gets into the infinite loop.)Before using this alias, you must set $p to point at the first list member. In this example, assume that the program variable top points to the first list member. Then you can use the "foll" alias to follow the linked list, printing the contents of each member as you proceed:(dbx) set $p = top
(dbx) foll
struct list {
      next = 0x7fffc71c
      value = 57
} 
(dbx) foll
struct list {
      next = 0x7fffc724
      value = 3
} 
(dbx) foll
struct list {
      next = 0x7fffc72c
      value = 12
}LBL="5.4" HELPID=""ID="43528"Recording and Playing Back dbx Input and Outputdbx allows you to record and play back both your input and ID="dbx_ch554"ID="dbx_ch555"dbx's output. ID="dbx_ch556"ID="dbx_ch557"dbx saves the information that you capture in files, which allows you to create command scripts that you can use in subsequent dbx sessions.LBL="5.4.1" HELPID=""Recording InputUse the ID="dbx_ch558"ID="dbx_ch559"record input command to start an input recording session. Once you start an input recording session, all commands to dbx are copied to the specified file. If the specified file already exists, dbx appends to the existing file. You can start and run as many simultaneous dbx input recording sessions as you need.Each recording session is assigned a number when you begin it. You use this number to reference the recording session with the unrecord command described in IDREF="30241" TYPE="TITLE"Section 5.4.2, "Ending a Recording Session."After you end the input recording session, use the command file with the ID="dbx_ch560"playback   input or ID="dbx_ch561"source commands to execute again all the commands saved to the file. See IDREF="38563" TYPE="TITLE"Section 5.4.3, "Playing Back Input."For example, to save the recorded input in a file called script, enter:(dbx) record input script
[4] record input script (0 lines)If you do not specify a file to record input, dbx creates a temporary dbx file in the /tmp directory. The name of the temporary file is stored in the dbx variable ID="dbx_ch562"$defaultin. You can display the temporary file name using the print command as follows:(dbx) print $defaultinBecause the dbx temporary files are deleted at the end of the dbx session, use the temporary file to repeat previously executed dbx commands in the current debugging session only. If you need a command file for use in subsequent dbx sessions, you must specify the file name when you invoke record input. If the specified file already exists, the new input is appended to the file.LBL="5.4.2" HELPID=""ID="30241"Ending a Recording SessionTo end input or output recording sessions, use the ID="dbx_ch563"ID="dbx_ch564"unrecord command:unrecordID="dbx_ch565"   session1 [,   session2 ... ]Turn off the specified recording session(s) and close the file(s) involved.ID="dbx_ch566"unrecord allID="dbx_ch567"Turn off all recording sessions and close all files involved.ID="dbx_ch568"For example, to stop recording session 4, enter the dbx command:(dbx) unrecord 4To stop all recording sessions, enter:(dbx) unrecord allThe dbx   ID="dbx_ch569"status command does not report on recording sessions. To see whether there are any active recording sessions, use the record command described in 
IDREF="22428" TYPE="TEXT"IDREF="22428" TYPE="TITLE"Section 5.4.6, "Examining the Record State."LBL="5.4.3" HELPID=""ID="38563"Playing Back InputUse ID="dbx_ch570"ID="dbx_ch571"playback input or ID="dbx_ch572"source to execute commands that you recorded with the ID="dbx_ch573"record input command. (source is simply an alias for playback input.) If you don't specify a file name, dbx uses the current temporary file that it created for the record input command. If you set the dbx variable ID="dbx_ch574"$pimode to nonzero, the commands are printed out as they are played back. By default, $pimode is set to zero.A pound sign (#) introduces a comment in a dbx command file. When dbx sees a pound sign in a script file, it interprets all characters between the pound sign and the end of the current line as a comment.To include the # operator (described in IDREF="90268" TYPE="TITLE"Section 6.1.1, "Operators"
) in a dbx command file, use two pound signs (for example, ##27).LBL="5.4.4" HELPID=""Recording OutputUse the ID="dbx_ch575"ID="dbx_ch576"record output command to start output recording sessions within dbx. During an output recording session, dbx copies its screen output to a file. If the specified file already exists, dbx appends to the existing file. You can start and run as many simultaneous dbx input recording sessions as you need.By default, the commands you enter are not copied to the output file; however, if you set the dbx variable ID="dbx_ch577"$rimode to a nonzero value, dbx also copies the commands you enter.Each recording session is assigned a number when you begin it. You use this number to reference the recording session with the unrecord command described in IDREF="30241" TYPE="TITLE"Section 5.4.2, "Ending a Recording Session."The record output command is very useful when the screen output is too large for a single screen (for example, printing a large structure). Within dbx, you can use the ID="dbx_ch578"playback output command (described in IDREF="95547" TYPE="TITLE"Section 5.4.5, "Playing Back Output"
) to look at the recorded information. After quitting dbx, you can review the output file using any IRIX system text viewing command (such as vi(1)).For example, to record the dbx output in a file called gaffa, enter:(dbx) record output gaffaTo record both the commands and the output, enter:(dbx) set $rimode=1
(dbx) record output gaffaIf you omit the file name, dbx saves the recorded output in a temporary file in /tmp. The temporary file is deleted at the end of the dbx session. To save output for use after the dbx session, you must specify the file name when giving the record output command. The name of the temporary file is stored in the dbx variable ID="dbx_ch579"$defaultout. To display the temporary file name, type:(dbx) print $defaultinLBL="5.4.5" HELPID=""ID="95547"Playing Back OutputThe ID="dbx_ch580"ID="dbx_ch581"playback output command displays output saved with the record output command. This command works the same as the IRIX system cat(1) command. If you don't specify a file name, dbx uses the current temporary file created for the record output command.For example, to display the output stored in the file script, enter:(dbx) playback output scriptLBL="5.4.6" HELPID=""ID="22428"Examining the Record StateThe ID="dbx_ch582"record command displays all ID="dbx_ch583"ID="dbx_ch584"record input and ID="dbx_ch585"record output sessions currently active. For example:(dbx) record
[4] record input /usr/demo/script (12 lines)
[5] record output /tmp/dbxoXa17992 (5 lines)LBL="5.5" HELPID=""ID="60766"Executing dbx ScriptsYou can create ID="dbx_ch586"dbx command scripts using an external editor and then execute these scripts using the ID="dbx_ch587"source or ID="dbx_ch588"playback input command. This is a convenient method for creating and executing automated test scripts.You can include comments in your command scripts by using the pound sign (ID="dbx_ch589"#) to introduce a comment. When ID="dbx_ch590"dbx sees a pound sign in a script file, it interprets all characters between the pound sign and the end of the current line as a comment.To include the ID="dbx_ch591"# operator (described in IDREF="90268" TYPE="TITLE"Section 6.1.1
) in a dbx script, use two pound signs (for example, ##27).LBL="6"ID="74286"Examining and Changing DataThis chapter describes how to examine and change data in your program while running it under dbx. Topics covered in this chapter include:proper syntax for expressions (IDREF="25993" TYPE="TITLE"Section 6.1
)printing expressions (IDREF="17137" TYPE="TITLE"Section 6.2
)using type casts to convert data types (IDREF="18732" TYPE="TITLE"Section 6.3
)displaying and changing program variables (IDREF="50911" TYPE="TITLE"Section 6.4
)determining variable scope (IDREF="18664" TYPE="TITLE"Section 6.5
)displaying type declarations (IDREF="84723" TYPE="TITLE"Section 6.6
)examining the program stack (IDREF="50445" TYPE="TITLE"Section 6.7
)calling functions interactively (IDREF="81639" TYPE="TITLE"Section 6.8
)special considerations for debugging programs written in C++ (IDREF="65271" TYPE="TITLE"Section 6.9
)LBL="6.1" HELPID=""ID="25993"ExpressionsMany dbx commands accept one or more expressions as arguments. Expressions can consist of constants, ID="dbx_ch61"dbx variables, program variables, and operators. This section discusses operators and constants. ID="dbx_ch62"ID="dbx_ch63"IDREF="88718" TYPE="TITLE"Section 5.1, "dbx Variables,"
 describes dbx variables, and IDREF="50911" TYPE="TITLE"Section 6.4, "Program Variables,"
 describes program variables.LBL="6.1.1" HELPID=""ID="90268"OperatorsIn general, dbx recognizes most expression operators from C, Fortran 77, and Pascal. dbx also provides some of its own operators. Operators follow the C language precedence. You may also use parentheses to explicitly determine the order of evaluation.ID="dbx_ch64"IDREF="53353" TYPE="TABLE"Table 6-1 lists the operators provided by dbx.COLUMNS="2"LEFT="0" WIDTH="54"OperatorLEFT="60" WIDTH="356"DescriptionLEFT="0" WIDTH="54"notLEFT="60" WIDTH="356"Unary operator returning false if the operand is trueLEFT="0" WIDTH="54"orLEFT="60" WIDTH="356"Binary logical operator returning true if either operand is 
nonzeroLEFT="0" WIDTH="54"xorLEFT="60" WIDTH="356"Binary operator returning the exclusive-OR of its operandsLEFT="0" WIDTH="54"//LEFT="60" WIDTH="356"Binary division operator (do not use "/" for division)LEFT="0" WIDTH="54"divLEFT="60" WIDTH="356"Binary operator that coerces its operands to integers before 
dividingLEFT="0" WIDTH="54"modLEFT="60" WIDTH="356"Binary operator returning op1 modulo op2. This is equivalent 
to the C "%" operator.LEFT="0" WIDTH="54"#exp   LEFT="60" WIDTH="356"Unary operator returning the address of source line specified 
by exp.LEFT="0" WIDTH="54""file"   #exp   LEFT="60" WIDTH="356"Unary operator returning the address of source line specified 
by exp in the file specified by file.LEFT="0" WIDTH="54"proc #exp   LEFT="60" WIDTH="356"Unary operator returning the address of source line specified 
by exp in the file containing the procedure proc.LBL="6-1"Table 6-1 ID="53353" dbx OperatorsThe ID="dbx_ch65"# operator takes the line number specified by the expression that follows it and returns the address of that source line. If you precede the # operator with a file name enclosed in quotation marks, the # operator returns the address of the line number in the file that you specify. If you precede the # operator with the name of a procedure, dbx identifies the source file that contains the procedure and returns the address of the line number in that file.For example, to print the address of line 27 in the current source file, enter:(dbx) print #27To print the address of line 27 in the source file foo.c (assuming that foo.c contains source that was used to compile the current object file), enter:(dbx) print "foo.c"   #27To print the address of line 27 in the source file containing the procedure bar (assuming that bar is a function in the current object file), enter:(dbx) print bar #27A pound sign (ID="dbx_ch66"#) introduces a comment in a ID="dbx_ch67"dbx script file. When dbx sees a pound sign in a script file, it interprets all characters between the pound sign and the end of the current line as a comment. See IDREF="60766" TYPE="TITLE"Section 5.5, "Executing dbx Scripts,"
 for more information on dbx script files.To include the ID="dbx_ch68"# operator in a dbx script, use two pound signs (for example, ##27).IDREF="76162" TYPE="TABLE"Table 6-2 lists the C language operators recognized by dbx.COLUMNS="2"LEFT="0" WIDTH="171"TypeLEFT="180" WIDTH="356"OperatorsLEFT="0" WIDTH="171"UnaryLEFT="180" WIDTH="356"! & + - * sizeof()LEFT="0" WIDTH="171"BinaryLEFT="180" WIDTH="356"% << >> == <= >= != < > & && | || + - * 
// [] -> .ID="dbx_ch69"LBL="6-2"Table 6-2 ID="76162"C Language Operators Recognized by dbx   C does not allow you to use the sizeof operator on bit fields. However, dbx allows you to enter expressions using the sizeof operator on bit fields; in these cases, dbx returns the number of bytes in the data type of bit fields (such as int or unsigned).You must use "//" as the division operator instead of the normal C "/" operator.The "^" exclusive-OR operator is not supported. Use the dbx "xor" operator instead.IDREF="89237" TYPE="TABLE"Table 6-3 lists the Pascal operators   ID="dbx_ch610"recognized by dbx.COLUMNS="2"LEFT="0" WIDTH="171"TypeLEFT="180" WIDTH="356"OperatorsLEFT="0" WIDTH="171"UnaryLEFT="180" WIDTH="356"not ^ + -LEFT="0" WIDTH="171"BinaryLEFT="180" WIDTH="356"mod = <= >= <> < > and or + - *// div []LBL="6-3"Table 6-3 ID="89237"Pascal Operators Recognized by dbx   You must use "//" as the division operator instead of the normal Pascal "/" operator.IDREF="97740" TYPE="TABLE"Table 6-4 lists the Fortran 77 language operators recognized by ID="dbx_ch611"dbx.COLUMNS="2"LEFT="0" WIDTH="171"TypeLEFT="180" WIDTH="356"OperatorsLEFT="0" WIDTH="171"UnaryLEFT="180" WIDTH="356"+ -LEFT="0" WIDTH="171"BinaryLEFT="180" WIDTH="356"+ - *//LBL="6-4"Table 6-4 ID="97740"Fortran 77 Operators Recognized by dbx   Fortran array subscripting must use "[]" not "()".You must use "//" as the division operator instead of the normal Fortran "/" operator.LBL="6.1.2" HELPID=""ConstantsYou can use both numeric and string constants under ID="dbx_ch612"ID="dbx_ch613"dbx.Expressions cannot contain constants defined by ID="dbx_ch614"#define declarations to the C preprocessor.ID="dbx_ch615"LBL="" HELPID=""Numeric ConstantsIn numeric expressions, you can use any valid integer or floating point constants. By default, dbx assumes that numeric constants are in decimal. You can set the default input base to octal by setting the ID="dbx_ch616"ID="dbx_ch617"ID="dbx_ch618"ID="dbx_ch619"dbx variable ID="dbx_ch620"$octin to a nonzero value. You can set the default input base to hexadecimal by setting the ID="dbx_ch621"dbx variable ID="dbx_ch622"$hexin to a nonzero value. If you set both $octin and $hexin to nonzero values, $hexin takes precedence.You can override the default input type by prefixing "0x" to indicate a hexadecimal constant or "0t" to indicate a decimal constant. For example, "0t23" is decimal 23 (which equals hexadecimal 17), and "0x2A" is hexadecimal 2A (which equals decimal 42).By default, ID="dbx_ch623"dbx prints the value of numeric expressions in decimal. You can set the default output base to octal by setting the ID="dbx_ch624"ID="dbx_ch625"dbx variable ID="dbx_ch626"$octints to a nonzero value. You can set the default output base to hexadecimal by setting the ID="dbx_ch627"dbx variable ID="dbx_ch628"$hexints to a nonzero value. If you set both $octints and $hexints to nonzero values, $hexints takes precedence.LBL="" HELPID=""String ConstantsMost dbx expressions cannot include string constants. The ID="dbx_ch629"print and printf commands are two of the dbx commands that accept string constants as arguments. You can also use the ID="dbx_ch630"set command to assign a string value to a dbx variable.Otherwise, string constants are useful only as arguments to functions that you call interactively. See IDREF="81639" TYPE="TITLE"Section 6.8, "Interactive Function Calls,"
 for information on interactive function calls.ID="dbx_ch631"You can use either the double-quote character (") or the single-quote character (') to quote strings in dbx.In general, dbx recognizes the following escape sequences in quoted strings (following the standard C language usage):ID="dbx_ch632"\\ \n \r \f \b \t \' \"LBL="6.2" HELPID=""ID="17137"Printing Expressionsdbx provides the following commands for printing values of expressions:ID="dbx_ch633"printID="dbx_ch634" [ exp1 [,   exp2, ... ] ] Print the value(s) of the specified expression(s).printdID="dbx_ch635"  [ exp1 [,   exp2, ... ] ]Print the value(s) of the specified expression(s) in decimal. (ID="dbx_ch636"pd is an alias for printd. See IDREF="37216" TYPE="TITLE"Section 5.3, "dbx Aliases,"
 for more information about dbx aliases.)printfID="dbx_ch637"   string [,   exp1 [,   exp2, ... ] ] Print the value(s) of the specified expression(s) in the format specified by the string, ID="dbx_ch638"string. The printf command supports all formats of the IRIX printf command except "%s". For a list of formats, see the printf(3S) man page in the IRIX Programming Man Pages.printoID="dbx_ch639"  [ exp1 [,   exp2, ... ] ]Print the value(s) of the specified expression(s) in octal.  (ID="dbx_ch640"po is an alias for printo.) printxID="dbx_ch641"  [ exp1 [,   exp2, ... ] ]Print the value(s) of the specified expression(s) in hexadecimal. (ID="dbx_ch642"px is an alias for printx.) LBL="6.3" HELPID=""ID="18732"Data Types and Type Coercion (Casts)You can use data types for type conversion (casting) by including the name of the data type in parentheses before the expression you want to cast. For example, to convert a character into an integer, use ID="dbx_ch643"ID="dbx_ch644"(int) to cast the value:(dbx) print (int) 'b'
98To convert an integer into a character, use (char) to cast the value:(dbx) print (char) 67
'C'This is standard C language type casting.LBL="6.4" HELPID=""ID="50911"Program VariablesYou can use the value of program variables in ID="dbx_ch645"dbx expressions. You can also change the value of program variables while running your program under dbx control.LBL="6.4.1" HELPID=""ID="90553"Qualifying Variable NamesYou can use the same name for a variable multiple times in the same program. For example, you might use a temporary counter named "i" in many different functions.ID="dbx_ch646"During program execution, this potential ambiguity presents no problem. The scope of each variable is local: space is allocated for it when the function is called and freed when the function returns.ID="dbx_ch647"Under dbx, however, you need to be able to distinguish between different variables that may have the same name. To do so, you can qualify a reference to a variable to specify its scope.dbx qualifies variables with the file, the procedure, a block, or a structure. You can manually specify the full scope of a variable by separating scopes with periods. For example, in the expression mrx.main.i, i is the variable name, main is a procedure in which it appears, and mrx is the source file (omitting the file extension) in which the procedure is defined.To illustrate, consider a C program called test that contains a function compare. In this example, the variable i is declared in both the main procedure and the compare function:int  compare ( int );

main( argc, argv )

int argc;
char **argv;

{
 int  i;
...
}

compare ( arg1, arg2 )
{
 int  i;
...
}To trace the value of the i that appears in the function compare, enter:(dbx) trace test.compare.iTo print the value of the i that appears in the procedure main, enter:(dbx) print test.main.iA leading dot (a period at the beginning of the identifier) tells dbx that the first qualifier is a module (file).The leading dot is useful when a file and a procedure have the same name. For instance, suppose mrx.c contains a function called mrx. Further, suppose that mrx.c contains a global variable called mi and a local variable, also called mi. To refer to the global variable, use the qualified form .mrx.mi, and to refer to the local variable, use the qualified form .mrx.mrx.mi.LBL="6.4.2" HELPID=""Variable ScopeYou can access the value of a variable only while it is in scope. The variable is in scope only if the block or procedure with which it is associated is active.ID="dbx_ch648"After you start your program, whenever your program executes a block or procedure that contains variables, your program allocates space for those variables and they "come into scope." You may access the values of those variables as long as the block or procedure is active. Once the block or procedure ends, the space for those variables is deallocated and you may no longer access their values.LBL="6.4.3" HELPID=""ID="85784"Displaying the Value of a VariableYou can display the value of a program variable using the ID="dbx_ch649"ID="dbx_ch650"print, ID="dbx_ch651"printd, ID="dbx_ch652"printf, ID="dbx_ch653"printo, and ID="dbx_ch654"printx commands and the ID="dbx_ch655"pd, ID="dbx_ch656"po, and ID="dbx_ch657"px aliases described in IDREF="17137" TYPE="TITLE"Section 6.2, "Printing Expressions."
 For example, to print the value of the program variable total, enter:(dbx) print total
235The print command can also display arrays, structures, and other complex data structures. For example, if message is a character array (a string), dbx prints the string:(dbx) print message
"Press <Return> to continue."As a more complex example, consider a simple linked list stored as an array of elements, each element consisting of an integer value and a pointer to the next element. If the array is named list, you can print the entire array by entering:(dbx) print arraydbx prints the value of each element in the array:{
      [0] struct linked_list {
          next = 0x7fffc714
          value = 5
      }
      [1] struct linked_list {
          next = 0x7fffc71c
          value = 17
      }
      [2] struct linked_list {
          next = 0x7fffc724
          value = 3
      }
...
}To print an individual element, enter a command such as:(dbx) print array[5]
{
struct linked_list {
      next = 0x7fffc714
      value = 17
}There is no simple method for examining a portion of an array with the ID="dbx_ch658"print command. However, if your array consists of simple elements such as integers or floating point values, you can directly examine the contents of memory using the /ID="dbx_ch659" (examine forward) command described in IDREF="51451" TYPE="TITLE"Section 8.2, "Examining Memory and Disassembling Code."For example, if you have a single-precision floating point array named float_vals, you can examine the six consecutive elements beginning with the fifth element by entering:(dbx) &float_vals[4] / 6f
7fffc748:  0.2500000 0.2000000 0.1666667 0.1428571
7fffc758:  0.1250000 0.1111111LBL="6.4.4" HELPID=""Changing the Value of a VariableThe ID="dbx_ch660"ID="dbx_ch661"assign command changes the value of existing program variables. You can also use the assign command to change the value of machine registers, as described in IDREF="34959" TYPE="TITLE"Section 8.1.2, "Changing Register Values."The syntax of the assign command is:assignID="dbx_ch662"   variable   =   expression Assign the value of expression to the program variable, variable.For example:(dbx) assign x = 27
27
(dbx) assign y = 37.5
37.5If you receive an incompatible types error when you try to assign a value to a pointer, use casts to make the assignment work. For example if next is a pointer to a structure of type "element," you can assign next a null pointer by entering:(dbx) assign *(int *) (&next) = 0
(nil)LBL="6.4.5" HELPID=""Conflicts Between Variable Names and KeywordsWhen naming variables in your program, try to avoid using any ID="dbx_ch663"dbx keywords. If you have a variable with the same name as a dbx keyword and you attempt to use that variable in a dbx command, dbx reports a syntax error.If you do have a program variable with the same name as a dbx command, you can force dbx to treat it as a variable by enclosing the variable in parentheses. For example, if you try to print the value of a variable named input, by entering:(dbx) print inputdbx displays:print input
        ^ syntax error
Suggestion: input is a dbx keyword; a revised command is in history.
Type !16 or !! to execute: print (input)The proper way to display the value of input is to enter:(dbx) print (input)
34Here is a list of dbx keywords:all    not
and    or
at     output
div    pgrp
if     pid
in     sizeof
input  to
mod    xorBy default, dbx treats as keywords the following C type keywords:signed     struct
unsigned   union
short      enum
long       double
int        float
charHowever, if your program is not written in C or C++, you may wish to disable these keywords. The ID="dbx_ch664"dbx variable ID="dbx_ch665"$ctypenames determines whether or not C type keywords are treated as dbx keywords. If $ctypenames is set to 1 (the default), then C type keywords are treated as dbx keywords; if $ctypenames is set to 0, they are not.LBL="6.4.6" HELPID=""Case Sensitivity in Variable NamesWhether or not ID="dbx_ch666"dbx is case sensitive when it comes to evaluating program variable names depends on the value of the dbx variable ID="dbx_ch667"$casesense.If $casesense is 2 (the default), then the language in which the variable was defined is taken into account (for example, C and C++ are case sensitive while Pascal and Fortran are not). If $casesense is 1, case is always checked. If $casesense is 0, case is always ignored.LBL="6.5" HELPID=""ID="18664"Determining the Scope of VariablesThe ID="dbx_ch668"ID="dbx_ch669"which and ID="dbx_ch670"whereis commands allow you to determine the scope of variables. These commands are useful for programs that have multiple variables with the same name occurring in different scopes.The which command prints the fully qualified name of the active version of a specified variable. For example, to determine the scope of the variable i, enter:(dbx) which i
.foo.foo2.iIn the example above, the variable i that is currently active is local to the procedure foo2 that appears in the module foo (corresponding to the file foo.c in a C language program).The whereis command prints the fully qualified names of all versions of a specified variable. For example, to determine all occurrences of the variable i in your program, enter:(dbx) whereis i
.test.main.i .foo.foo2.i .foo.foo.iIn this example, dbx reports that a variable named i occurs in three places in your program: the procedure main in the module test, the procedure foo in the module foo, and the procedure foo2 in the module foo.LBL="6.6" HELPID=""ID="84723"Displaying Type DeclarationsThe ID="dbx_ch671"ID="dbx_ch672"whatis command displays the type declaration for a specified variable or procedure in your program. For example, to display the type declaration for the variable i, enter:(dbx) whatis i
int i;The following example illustrates the output of whatis for an array of structures:(dbx) whatis score_list
struct score_entry {
      (float) score;
      unsigned char name[20];
} score_list[20];When you provide a procedure name to whatis, dbx reports the type of the value returned by the procedure and the types of all arguments to the procedure:(dbx) whatis foo
int foo(i)
int i;
(dbx) whatis main
int main(argc, argv)
int argc;
unsigned char **argv;LBL="6.7" HELPID=""ID="50445"Examining the StackEach time your program executes a procedure, the information about where in the program the call was made from is saved on a stack. The stack also contains arguments to the procedure and all of the procedure's local variables. Each procedure on the stack defines an ID="dbx_ch673"ID="dbx_ch674"activation level. Activation levels can also consist of blocks that define local variables within procedures.Each activation level determines the scope of many ID="dbx_ch675"dbx commands and expressions. For example, unless you qualify a variable, as described in ID="dbx_ch676"IDREF="90553" TYPE="TITLE"Section 6.4.1, "Qualifying Variable Names,"
   dbx assumes that variables you reference are local to the current activation level.The most recently called procedure or block is numbered 0. The next active procedure (the one that called the current procedure) is numbered 1. The last activation level is always the main program block.LBL="6.7.1" HELPID=""Printing Stack TracesThe ID="dbx_ch677"ID="dbx_ch678"where command prints stack traces. Stack traces show the current activation levels (procedures) of a program.For example, consider the following stack trace for a program called test:(dbx) where
>  0 foo2(i = 5) ["/usr/demo/foo.c":21, 0x4002c0]
     1 .foo.foo(i = 4) ["/usr/demo/foo.c":13, 0x40028c]
     2 main(argc = 1, argv = 0x7fffc77c) ["/usr/demo/test.c":29, 0x400348]This program has three activation levels. The most recent, a call of the procedure foo2, is numbered 0. The stack trace also reports that foo2 was passed one argument: the value "5" was assigned to the local variable i. Finally, the trace indicates that the program was stopped at line 21 of the file foo.c, which translates to machine address 0x4002c0.The stack trace reports similar information for the two other activation levels in this example. From this you can determine that the function foo called foo2 from line 13 in foo.c. In turn, foo was called by main at line 29 of the file test.c.The currently selected activation level is 0, indicated by the ">" character.If you compile with ID="dbx_ch679"-g0, -g1, or with no g option, limited symbols are reported. In cases such as this, where detailed symbolic information is not available, the five hexadecimal values returned represent dbx's guess that the function has five integer arguments. The following example illustrates such a case:Process 6947: [3] stop in printf
(dbx) run
Process 6947 (a.out) terminated
Process 6948 (a.out) started
[3] Process 6948 (a.out) stopped at [printf:27 ,0x5feab16c]
    Source (of printf.c) not available for Process 6948
(dbx) where
> 0 printf(0x10000000, 0x7fffaf4c, 0x7fffaf54, 0x0, 0x0) ["printf.c":27, 0x5feab16c]
    1 main(0x10000000, 0x7fffaf4c, 0x7fffaf54, 0x0, 0x10008000) ["t.c":3, 0x400794]
(dbx) quit
Process 6948 (a.out) terminated
davea-28: cat t.c
int main()
{
   printf("Hello\n");
}LBL="6.7.2" HELPID=""Moving Within the StackThe ID="dbx_ch680"up and ID="dbx_ch681"down commands move up and down the activation levels in the stack. These commands are useful when examining a call from one level to another. You can also move up and down the activation stack with the ID="dbx_ch682"ID="dbx_ch683"func command described in IDREF="82062" TYPE="TITLE"Section 6.7.3, "Moving to a Specified Procedure."The up and down commands have the following syntax:up [ num ] Move up the specified number of activation levels in the stack. The default is one level.down [ num ] Move down the specified number of activation levels in the stack. The default is one level.When you change your activation level, your scope changes. For example, unless you qualify a variable as described in ID="dbx_ch684"IDREF="90553" TYPE="TITLE"Section 6.4.1
, dbx assumes that variables you reference are local to the current activation level. Also, dbx changes the current source file to the one containing the procedure's source.ID="dbx_ch685"Consider examining the stack trace for a program called test and moving up one level in the activation stack:(dbx) where
>  0 foo2(i = 5) ["/usr/demo/foo.c":21, 0x4002c0]
     1 .foo.foo(i = 4) ["/usr/demo/foo.c":13, 0x40028c]
     2 main(argc = 1, argv = 0x7fffc77c) ["/usr/demo/test.c":29, 0x400348]
(dbx) up
.foo.foo(i = 4) ["/usr/demo/foo.c":13, 0x40028c]The current activation level is now the procedure foo. As indicated in the output, the variable i receives the argument passed to foo and is therefore local to foo. The variable i at this activation level is different from the variable i in the foo2 activation level. You can reference the currently active i as "i", whereas you must now qualify the reference to the i in foo2:(dbx) print i
4
(dbx) print foo2.i
5Moving up one more activation level brings you to the main procedure:(dbx) up
main(argc = 1, argv = 0x7fffc77c) ["/usr/demo/test.c":29, 0x400348]In this example, the source for main is in test.c, whereas the source for foo and foo2 is in foo.c; therefore, dbx changes the current source file when you move up to the main activation level:(dbx) file
/usr/demo/test.cdbx resets the source file when you return to the foo2 activation level:(dbx) down 2
foo2(i = 5) ["/usr/demo/foo.c":21, 0x4002c0]
(dbx) file
/usr/demo/foo.cLBL="6.7.3" HELPID=""ID="82062"Moving to a Specified ProcedureThe ID="dbx_ch686"func command lets you move up or down the activation stack. You can specify the new activation level by providing either a procedure name or an activation level number.ID="dbx_ch687"The syntax for the func command is:funcID="dbx_ch688" { activation_level | procedure } Change the current activation level. If you specify an activation level by number, dbx changes to that activation level. If you specify a procedure, dbx changes to the activation level of that procedure. If you specify a procedure name and that procedure has called itself recursively, dbx changes to the most recently called instance of that procedure.funcID="dbx_ch689" Display the name of the procedure corresponding to the current activation level.When you change your activation level, your scope changes. For example, unless you qualify a variable as described in ID="dbx_ch690"IDREF="90553" TYPE="TITLE"Section 6.4.1
, dbx assumes that variables you reference are local to the current activation level. Also, dbx changes the current source file to the one containing the procedure's source and the current line to the first line of the procedure.ID="dbx_ch691"You can also give the func command the name of a procedure that is not on the activation stack, even when your program is not executing. In this case, dbx has no corresponding activation level to make current; however, dbx still changes the current source file to the one containing the procedure's source and the current line to the first line of the procedure.For example, consider the following activation stack:(dbx) where
>  0 foo2(i = 5) ["/usr/demo/foo.c":21, 0x4002c0]
     1 .foo.foo(i = 4) ["/usr/demo/foo.c":13, 0x40028c]
     2 main(argc = 1, argv = 0x7fffc77c) ["/usr/demo/test.c":29, 0x400348]In this case, you can go to the main activation stack by entering:(dbx) func main
main:29   29  j = foo ( i );This command changes the current activation level to "2" and changes the current source file to test.c.If you use the func command to go to a function that is not on the activation stack, dbx changes only the current source file to the one containing the procedure's source and the current line to the first line of the procedure:(dbx) func bar
bar:73   73  temp = 0;
(dbx) file
/usr/demo/bar.cLBL="6.7.4" HELPID=""Printing Activation Level InformationThe ID="dbx_ch692"dump command prints information about the variables in an activation level:ID="dbx_ch693"dumpID="dbx_ch694" Print information about the variables in the current procedure.dumpID="dbx_ch695"   procedure Print information about the variables in the specified procedure. The procedure must be active.dump .ID="dbx_ch696" Print information about the variables in all procedures currently active.For example, executing dump while in a function called strcopy might appear as follows:(dbx) dump
strcopy(str1 = (nil), str2 = 0x100002a4 = "Source") ["/usr/demo/str.c":120, 0x4003c8]
len = 7
i = 0To examine the information for the procedure main, enter:(dbx) dump main
main(argc = 1, argv = 0x7fffc77c) ["/usr/demo/test.c":120, 0x4003c8]
total = 0
count = 0
j = 5
i = 4To perform a complete dump of the program's active variables, enter:(dbx) dump .
>  0 strcopy(str1 = "Source", str2 = 0x100002a4 = (nil) ) ["/usr/demo/str.c":120, 0x4003c8]
len = 7
i = 0

     1 .foo.foo(i = 4) ["/usr/demo/foo.c":13, 0x40028c]
string1 = 0x7fffc048 = "Source"
string2 = (nil)
k = 5

     2 main(argc = 1, argv = 0x7fffc77c) ["/usr/demo/test.c":29, 0x400348]
total = 0
count = 0
j = 5
i = 4LBL="6.8" HELPID=""ID="81639"Interactive Function CallsThere are two ways to interactively call a function in your program from ID="dbx_ch697"dbx.If the function returns a value, you can use that function in a normal dbx expression. For example, consider a function prime defined in your program that accepts an integer value as an argument and returns 1 if the value is prime and 0 if it is not. You can call this function interactively and print the results by entering a command such as:(dbx) print prime(7)
1If your function does not return a value, or if you want to execute a function primarily for its side effects, you can execute the function interactively with the dbx command ccall:ccallID="dbx_ch698"   func(   arg1, arg2, ... , argn   ) Call a function with the given arguments.ID="dbx_ch699"Regardless of the language the function was written in, the call is interpreted as if it were written in C, and normal C calling conventions are used.Structure and union arguments to, and structure and union returns from, a function are not supported.Functions called interactively honor breakpoints. This lets you debug a function by setting breakpoints and then calling it interactively. However, if there is a breakpoint in a function called interactively, the value returned by the function is lost, and any computation (for example, in an expression) following the function call is ignored.If you perform a stack trace using the where command while stopped in a routine executed interactively, dbx displays only those activation levels created by your interactive function call. The activation levels for your active program are effectively invisible. The following is an example of what a stack trace can look like during an interactive function call:(dbx) where
>  0 foo2(i = 6) ["/usr/demo/foo.c":21, 0x4002c0]
     1 .foo.foo(i = 5) ["/usr/demo/foo.c":13, 0x40028c]
     2 _mcount [0x403ff8]

Stopped in interactive callIf you stop execution of an interactively called function, you are responsible for eventually "unstacking" the call and returning from the function call. To unstack a call, you can complete the call using ID="dbx_ch6100"ID="dbx_ch6101"dbx commands such as ID="dbx_ch6102"cont, ID="dbx_ch6103"resume, ID="dbx_ch6104"next, or ID="dbx_ch6105"step as many times as necessary. If you run or rerun your program, dbx automatically unstacks all interactive function calls.Another way to unstack an interactive function call is to execute the ID="dbx_ch6106"ID="dbx_ch6107"clearcalls command, which clears all stopped interactive calls.You can also "nest" interactive function calls. In other words, if you have one or more breakpoints in a function, and you call that function repeatedly, each interactive call is "stacked" on top of the previous call. Breakpoints in a function affect all nesting levels; that is, you cannot have different breakpoints at different nesting levels.ID="dbx_ch6108"ID="dbx_ch6109"The where command reports the depth of nesting, if applicable. For example:(dbx) where
>  0 foo2(i = 8) ["/usr/demo/foo.c":21, 0x4002c0]
     1 .foo.foo(i = 7) ["/usr/demo/foo.c":13, 0x40028c]
     2 _mcount [0x403ff8]

Stopped in interactive call. Nesting level 2.Only one level of activation stack is visible at a time; in an interactive call the stack trace of the hidden levels is invisible to you and to dbx. This can provoke error messages if you try to access variables that are not in the scope of the interactive function call.For example, suppose you set a conditional breakpoint like:(dbx) stop in foo if j == 7
Process 1360: [5] stop if j = 7 in .foo.fooIf j is not within the scope of foo, then you will receive an error message if you attempt to call foo interactively. To prevent this, disable or delete any such breakpoints, conditional commands, or traces before executing the interactive function call.LBL="6.9" HELPID=""ID="65271"C++ ConsiderationsDebugging a program written in C++ is somewhat different from debugging programs written in other languages. This section describes these differences.ID="dbx_ch6110"LBL="6.9.1" HELPID=""Accessing C++ Member VariablesIn general, you use standard C++ syntax to access member variables of objects. For example, if the string ID="dbx_ch6111"_name is a member variable of the object myWindow, you can print its value by entering:(dbx) print myWindow._name
0x1001dc1c = "MenuWindow" To display a static member variable for a C++ class, you must specify the variable with the class qualifier. For example, to print the value of the static member variable ID="dbx_ch6112"costPerShare of the class CoOp, enter:(dbx) print CoOp::costPerShare
25.0Unlike normal C++ usage, to access a member variable within a member function, you must use the keyword this to reference the value. For example, if you were stopped in a member function of the object myWindow, you must use the following syntax to print the value of the member variable _name:(dbx) print this->_name
0x1001dc1c = "MenuWindow" LBL="6.9.2" HELPID=""Referring to C++ FunctionsFor the purpose of dbx debugging, functions in C++ programs fall into three general categories:Member functionsID="dbx_ch6113"Refer to member functions using the syntax classname::functionname. For example, refer to the member function foo in the class Window as Window::foo.Global C++ functionsID="dbx_ch6114"Refer to global functions using the syntax ::functionname. For example, refer to the global function foo as ::foo.Non-C++ functionsID="dbx_ch6115"Refer to non-C++ functions using the syntax functionname. For example, refer to the function printf as printf.There are two restrictions to keep in mind when using dbx with C++:You cannot set a breakpoint in an inline function.ID="dbx_ch6116"You cannot distinguish among overloaded functions. For example, given two functions:ID="dbx_ch6117"print(int);
print(float);the following command sets a breakpoint in both functions:(dbx) stop in ::printThe following example illustrates various possibilities:#include <stdio.h> 
class foo {
 int n; 
public:
 foo() {n = 0;}
 foo(int x);
 int bar();
 int bar(int); 
};

int foo:: bar() 
{
 return n; 
}

int foo:: bar(int x) 
{
 return n + x; 
}

foo::foo(int x) 
{
 n = x; 
}

int square(int x) 
{
 return x * x; 
}

main() 
{ 
 foo a; 
 foo b = 11; 
 int x = a.bar(); 
 int y = b.bar(x) + square(x);  
 printf("y = %d\n", y); 
} If you enter:(dbx) stop in foo::foodbx stops execution in the constructor for the variable b but not in the constructor for the variable a, because you cannot set a breakpoint by name in an inline function.If you enter:(dbx) stop in foo::bardbx stops execution both when a.bar is called and when b.bar is called, because dbx is unable to distinguish between the overloaded functions.To stop in square, enter:(dbx) stop in ::squareTo stop in printf (a C function), enter:(dbx) stop in printfLBL="7"ID="85798"Controlling Program ExecutionYour program normally runs until it exits or encounters an unrecoverable error. dbx, however, allows you to stop your program under various conditions, step through your program line by line, stop execution on receiving a signal, and execute conditional commands based on your program's status.This chapter describes how to:set breakpoints to stop execution, both conditionally and unconditionally, at specified lines of code (IDREF="23865" TYPE="TITLE"Section 7.1
)continue after breakpoints (IDREF="31983" TYPE="TITLE"Section 7.1.3
)trace code to observe program execution, changes to variables, and procedure calls (IDREF="19256" TYPE="TITLE"Section 7.2
)execute commands when specified conditions in your program occur (IDREF="89878" TYPE="TITLE"Section 7.3
)manage breakpoints, traces, and conditional commands (IDREF="14485" TYPE="TITLE"Section 7.4
)stop execution when your program receives a signal (IDREF="25866" TYPE="TITLE"Section 7.5
)stop execution when your program executes a system call (IDREF="93296" TYPE="TITLE"Section 7.6
)step through your program one line at a time (IDREF="31135" TYPE="TITLE"Section 7.7
)begin execution at a given line (IDREF="28904" TYPE="TITLE"Section 7.8
)LBL="7.1" HELPID=""ID="23865"BreakpointsBreakpointsID="dbx_ch71" allow you to stop execution of your program. Breakpoints can be unconditionalID="dbx_ch72", in which case they always stop your program, or ID="dbx_ch73"conditional, in which case they stop your program only if a test condition that you specify is true.All breakpoints halt program execution before executing the line on which they are set. Therefore, if you want to examine the effects of a line of code, you should set the breakpoint on the line of code following the one whose effects you want to study.Each breakpoint is assigned a number when you create it. You use this number to reference the breakpoint in the various commands provided for manipulating breakpoints (for example, ID="dbx_ch74"disable, ID="dbx_ch75"enable, and ID="dbx_ch76"delete, all described in IDREF="14485" TYPE="TITLE"Section 7.4, "Managing Breakpoints, Traces, and Conditional Commands"
).LBL="7.1.1" HELPID=""Setting Unconditional BreakpointsTo set an unconditional breakpoint, you simply specify the point at which you want to stop program execution using one of the following forms of the ID="dbx_ch77"stop command:stop atID="dbx_ch78"Set a breakpoint at the current source line.stop atID="dbx_ch79"   lineSet a breakpoint at the specified source line.stop inID="dbx_ch710"   procedure Set a breakpoint to stop execution upon entering the specified procedure.If your program has multiple source files, be sure to set the breakpoint in the proper file. To do so, you can explicitly set the source file using dbx's file command (see IDREF="41684" TYPE="TITLE"Section 4.2, "Changing Source Files"
), or you can use the func command to go to a source file containing a specified function (see IDREF="82062" TYPE="TITLE"Section 6.7.3, "Moving to a Specified Procedure"
).LBL="7.1.2" HELPID=""Setting Conditional BreakpointsAn unconditional breakpoint is the simplest type of breakpoint; your program stops every time it reaches a specified place. On the other hand, a ID="dbx_ch711"conditional breakpoint stops your program only if a condition that you specify is true. The two conditions that you can test are:Has the value of a variable or other memory location changed?Is a test expression true?LBL="" HELPID=""Stopping if a Variable or Memory Location has ChangedBy including a ID="dbx_ch712"variable clause in your stop command, you can cause dbx to stop if the value of a variable or the contents of a memory location has changed.If you provide only a variable name in your variable clause, the breakpoint stops your program if the value of the variable has changed since the last time dbx checked it. If instead of a variable name you provide an expression, dbx evaluates the expression and uses the result as an address in memory; the breakpoint stops your program if the contents of the memory location (32 bits) has changed since the last time dbx checked it.The points at which dbx checks the value of a variable or memory location depend on the command that you use to set the breakpoint:stopID="dbx_ch713"   variableInspect the value before executing each instruction. Note that execution is very slow if you choose this type of conditional breakpoint.ID="dbx_ch714"stopID="dbx_ch715"   variable   at   lineInspect the value at the given line.ID="dbx_ch716"stopID="dbx_ch717"   variable   in   procedureInspect the value at every instruction within a given procedure.ID="dbx_ch718"LBL="" HELPID=""ID="71997"Stopping If a Test Expression is TrueBy including a test clause in your ID="dbx_ch719"stop command, you can cause dbx to stop if the value of an expression is true. You can use as a test any valid numerical expression. If the result of the expression is nonzero, the expression is true and the test is successful.The point at which dbx evaluates the test expression depends on the command that you use to set the breakpoint:stopID="dbx_ch720"   if   expressionEvaluate the expression before executing each instruction. Note that execution is very slow if you choose this type of conditional breakpoint.ID="dbx_ch721"stopID="dbx_ch722"   at   line   if   expressionEvaluate the expression at the given line.ID="dbx_ch723"stopID="dbx_ch724"   in   procedure   if   expressionEvaluate the expression at every instruction within a given procedure.ID="dbx_ch725"LBL="" HELPID=""Conditional Breakpoints Combining Variable and Test ClausesYou can create conditional breakpoints that combine both variable and test clauses. In these cases, the overall test evaluates to true only if both clauses are true.ID="dbx_ch726"ID="dbx_ch727"The following forms of the stop command combine both the variable and test clauses:stopID="dbx_ch728"   variable   if   expressionTest both conditions before executing each instruction. Note that execution is very slow if you choose this type of conditional breakpoint.ID="dbx_ch729"stopID="dbx_ch730"   variable   at   line   if   expressionTest both conditions at the given line.ID="dbx_ch731"stopID="dbx_ch732"   variable   in   procedure   if   expressionTest both conditions at every instruction within a given procedure.ID="dbx_ch733"LBL="7.1.3" HELPID=""ID="31983"Continuing Execution after a BreakpointThe ID="dbx_ch734"cont command allows you to continue execution after any type of breakpoint. In its simplest form, program execution continues until the end of the program or until another breakpoint is reached. You can also tell ID="dbx_ch735"dbx to continue your program until it reaches a given line or procedure; this is similar to setting a temporary, "one-shot" breakpoint and then continuing.The syntax of the cont command is:contID="dbx_ch736"Continue execution with the current line.ID="dbx_ch737"contID="dbx_ch738" { at | to } lineSet a temporary breakpoint at the specified source line, then resume execution with the current line. When your program reaches the breakpoint at ID="dbx_ch739"line, dbx stops your program and deletes the temporary breakpoint. The keywords at and to are equivalent.cont   in   procedureSet a temporary breakpoint to stop execution upon entering the specified procedure, then resume execution with the current line. When your program reaches the breakpoint in ID="dbx_ch740"procedure, dbx stops your program and deletes the temporary breakpoint.If your program stopped because dbx caught a signal intended for your program, then dbx will send that signal to your program when you continue execution. You can also explicitly send a signal to your program when you continue execution. Sending signals to your program upon continuation is discussed in ID="dbx_ch741"IDREF="62814" TYPE="TITLE"Section 7.5.2, "Continuing after Catching a Signal."When you debug multiprocess programs, the ID="dbx_ch742"ID="dbx_ch743"resume command can be more helpful than the cont command. Refer to IDREF="87200" TYPE="TITLE"Section 9.7, "Resuming a Suspended Process,"
 for more information about the resume command.LBL="7.2" HELPID=""ID="19256"Tracing Program ExecutionThe ID="dbx_ch744"trace command allows you to observe the progress of your program as it executes. With it you can print:values of variables at specific points in your program or whenever variables change valueparameters passed to and values returned from functionsline numbers as they are executedEach trace is assigned a number when you create it. You use this number to reference the trace in the various commands provided for manipulating traces (for example, ID="dbx_ch745"disable, ID="dbx_ch746"enable, and ID="dbx_ch747"delete, all described IDREF="14485" TYPE="TITLE"Section 7.4
).The syntax of the trace command is:traceID="dbx_ch748"   variableWhenever the specified variable changes, ID="dbx_ch749"dbx prints the old and new values of that variable. Note that execution is very slow if you choose this type of trace.traceID="dbx_ch750"   proceduredbx prints the values of the parameters passed to the specified procedure whenever your program calls it. Upon return, ID="dbx_ch751"dbx prints the return value.traceID="dbx_ch752"   variable   at   linedbx prints the value of the variable whenever your program reaches the specified line.ID="dbx_ch753"traceID="dbx_ch754"   variable   in   procedureWhenever the variable changes within the procedure that you specify, ID="dbx_ch755"dbx prints the old and new values of that variable.traceID="dbx_ch756"   variable   at   line   if   expressiondbx prints the value of the variable whenever your program reaches the specified line and the given expression is true.ID="dbx_ch757"traceID="dbx_ch758"   variable   in   procedure   if   expressionWhenever the variable changes within the procedure that you specify, ID="dbx_ch759"dbx prints the old and new values of that variable if the given expression is true.To examine the parameters passed to and values returned from a function, you can trace that function. For example, if the function name is foo, you set the trace by entering:(dbx) trace fooWhen you execute your program, dbx prints the values of the parameters passed to foo whenever your program calls it. Upon return from foo, dbx prints the return value:(dbx) run
[3] calling foo(text = 0x10000484 = "Processing...\n", i = 4) from function main
[4] foo returning -1 from fooIn the example shown above, foo receives two parameters: a character string variable named text containing the value "Processing...\n" and an integer variable named i containing the value 4. The trace also indicates that foo returns a value of -1.You can also examine a variable as it changes values. For example, you might want to monitor the value of a string variable named curarg as you use it to process an argument list. To set the trace, enter:(dbx) trace curarg
Process 2395: [6] trace .test.main.curarg in mainWhen you set a trace on a variable, examine the confirmation that dbx prints. If you use the same variable name in multiple functions in your program, dbx may not set the trace on the variable that you want. If dbx sets the trace on an incorrect variable, delete the trace and set a new trace using a qualified variable format as described in ID="dbx_ch760"IDREF="90553" TYPE="TITLE"Section 6.4.1, "Qualifying Variable Names."
 For more information on deleting traces, see IDREF="99674" TYPE="TITLE"Section 7.4.4, "Deleting Breakpoints, Traces, and Conditional Commands."So, in this example, if you used the variable curarg in both main and a function called arg_process, and you want to trace the curarg in arg_process, you would have to delete this trace and set a new trace:(dbx) delete 6
(dbx) trace arg_process.curarg
Process 2395: [7] trace .test.arg_process.curarg in arg_processWhen you execute your program, whenever curarg changes, dbx prints its old and new values:(dbx) run
[7] curarg changed before [arg_process: line 53]:
                  new value = (nil);
[7] curarg changed before [arg_process: line 86]:
                  old value = 0;
                  new value = 0x7fffc7e5 = "-i";
[7] curarg changed before [arg_process: line 86]:
                  old value = 2147469285;
                  new value = 0x7fffc7eb = "names.out";
[7] curarg changed before [arg_process: line 86]:
                  old value = 2147469291;
                  new value = 0x7fffc7f5 = "names.in";LBL="7.3" HELPID=""ID="89878"Writing Conditional CommandsA conditional command created with the ID="dbx_ch761"when command is similar to a breakpoint set with the stop command, except that rather than stopping when certain conditions are met, dbx executes a list of commands. The command list can consist of any dbx commands, separated by semicolons if you include more than one command in the command list. Additionally, you can use the keyword ID="dbx_ch762"stop in the command list to stop execution, just like a breakpoint.Each conditional command is assigned a number when you create it. You use this number to reference the conditional command in the various commands provided for manipulating conditional commands (for example, ID="dbx_ch763"disable, ID="dbx_ch764"enable, and ID="dbx_ch765"delete, all described in IDREF="14485" TYPE="TITLE"Section 7.4
).The syntax of the when command is:whenID="dbx_ch766"   variable   {   command-list   }Inspect the value before executing each instruction. If it has changed, execute the command list. Note that execution is very slow if you choose this type of conditional command execution.ID="dbx_ch767"whenID="dbx_ch768"   variable   at   line   {   command-list   }Inspect the value at the given line. If it has changed, execute the command list.ID="dbx_ch769"whenID="dbx_ch770"   variable   in   procedure   {   command-list   }Inspect the value at every instruction within a given procedure. If it has changed, execute the command list.ID="dbx_ch771"whenID="dbx_ch772"   if   expression   {   command-list   }Evaluate the expression before executing each instruction. If it is true, execute the command list. Note that execution is very slow if you choose this type of conditional command execution.ID="dbx_ch773"whenID="dbx_ch774"   at   line   if   expression   {   command-list   }Evaluate the expression at the given line. If it is true, execute the command list.ID="dbx_ch775"whenID="dbx_ch776"   in   procedure   if   expression   {   command-list   }Evaluate the expression at every instruction within a given procedure. If it is true, execute the command list.ID="dbx_ch777"whenID="dbx_ch778"   variable   if   expression   {   command-list   }Test both conditions before executing each instruction. If they are true, execute the command list. Note that execution is very slow if you choose this type of conditional command execution.ID="dbx_ch779"ID="dbx_ch780"whenID="dbx_ch781"   variable   at   line   if   expression   {   command-list   }Test both conditions at the given line. If they are true, execute the command list.ID="dbx_ch782"ID="dbx_ch783"whenID="dbx_ch784"   variable   in   procedure   if   expression   {   command-list   }Test both conditions at every instruction within a given procedure. If they are true, execute the command list.ID="dbx_ch785"ID="dbx_ch786"LBL="7.4" HELPID=""ID="14485"Managing Breakpoints, Traces, and Conditional Commandsdbx provides commands that allow you to disable, enable, delete, and examine the status of the breakpoints, traces, and conditional commands that you set in your programs.Each breakpoint, trace, and conditional command is assigned a number when you create it. You use these numbers as identifiers in the various commands provided for manipulating these debugging controls.LBL="7.4.1" HELPID=""ID="58446"Listing Breakpoints, Traces, and Conditional CommandsThe ID="dbx_ch787"status command lists all of the breakpoints, traces, and conditional commands that you have set and indicates whether they are enabled or disabled.ID="dbx_ch788"ID="dbx_ch789"ID="dbx_ch790"For example, consider executing the following commands while debugging a program called test:(dbx) stop in foo
Process 946: [5] stop in foo
(dbx) trace count
Process 946: [6] trace count in main
(dbx) when at 44 {print i, k}
Process 946: [7] print i, k at "/usr/demo/test.c":44You then see the following if you enter status:(dbx) status
Process 946: [5] stop in foo
Process 946: [6] trace count in main
Process 946: [7] print i, k at "/usr/demo/test.c":44LBL="7.4.2" HELPID=""ID="84268"Disabling Breakpoints, Traces, and Conditional CommandsThe ID="dbx_ch791"disable command allows you to temporarily disable a breakpoint, trace, or conditional command so that it is inoperative and has no effect on program execution. dbx remembers all information about a disabled breakpoint, trace, or conditional command, and you may enable it using the ID="dbx_ch792"enable command described in IDREF="14318" TYPE="TITLE"Section 7.4.3, "Enabling Breakpoints, Traces, and Conditional Commands."The syntax of the disable command is:disableID="dbx_ch793"   item [, item ... ]Disable the specified breakpoint(s), trace(s), or conditional command(s). This command has no effect if the item you specify is already disabled.ID="dbx_ch794"ID="dbx_ch795"ID="dbx_ch796"For example, to disable the conditional command set in IDREF="58446" TYPE="TITLE"Section 7.4.1, "Listing Breakpoints, Traces, and Conditional Commands,"
 enter:(dbx) disable 7Then you see the following if you enter status:(dbx) status
Process 946: [5] stop in foo
Process 946: [6] trace count in main
Process 946: [7] (disabled) print i, k at "/usr/demo/test.c":44LBL="7.4.3" HELPID=""ID="14318"Enabling Breakpoints, Traces, and Conditional CommandsThe ID="dbx_ch797"enable command reverses the effects of a ID="dbx_ch798"disable command: the breakpoint, trace, or conditional command that you specify is enabled and once again affects the execution of your program. The syntax of the enable command is:enableID="dbx_ch799"   item [, item ... ]Enable the specified breakpoint(s), trace(s), or conditional command(s).ID="dbx_ch7100"ID="dbx_ch7101"ID="dbx_ch7102"For example, to enable the conditional command disabled in IDREF="84268" TYPE="TITLE"Section 7.4.2, "Disabling Breakpoints, Traces, and Conditional Commands,"
 enter:(dbx) enable 7Executing the status command shows that the condition command is now enabled:(dbx) status
Process 946: [5] stop in foo
Process 946: [6] trace count in main
Process 946: [7] print i, k at "/usr/demo/test.c":44LBL="7.4.4" HELPID=""ID="99674"Deleting Breakpoints, Traces, and Conditional CommandsThe ID="dbx_ch7103"delete command allows you to delete breakpoints, traces, and conditional commands:deleteID="dbx_ch7104" { item [, item ... ] | all }Delete the item or items specified. If you use the keyword "all" instead of listing individual items, dbx deletes all breakpoints, traces, and conditional commands.ID="dbx_ch7105"ID="dbx_ch7106"ID="dbx_ch7107"For example, to delete the breakpoint and trace set in IDREF="58446" TYPE="TITLE"Section 7.4.1, "Listing Breakpoints, Traces, and Conditional Commands,"
 enter:(dbx) delete 5, 6Then you see the following if you enter status:(dbx) status
Process 946: [7] (disabled) print i, k at "/usr/demo/test.c":44To delete all breakpoints, traces, and conditional commands, enter:(dbx) delete allLBL="7.5" HELPID=""ID="25866"Signal Processingdbx can detect any signals sent to your program while it is running and, at your option, stop your program.LBL="7.5.1" HELPID=""Catching and Ignoring SignalsWith the catch command, you can instruct dbx to stop your program when it receives any specified signal. The ID="dbx_ch7108"ignore command undoes the effects of a catch command. The catch and ignore commands have the following syntax:catch { signal | all }Instruct ID="dbx_ch7109"dbx to stop your program whenever it receives the specified signal. If you use the keyword "all" rather than giving a specific signal, dbx catches all signals.ignoreID="dbx_ch7110" { signal | all }Instruct ID="dbx_ch7111"dbx to ignore the specified signal. All ignored signals are passed to your program normally. If you use the keyword "all" rather than giving a specific signal, dbx ignores all signals.catchPrint a list of all signals caught.ID="dbx_ch7112"ignoreID="dbx_ch7113"Print a list of all signals ignored.ID="dbx_ch7114"You can use the signal names and numbers as listed in the IRIX signal(2) man page. You can also abbreviate the signal names by omitting the "SIG" portion of the name. You can use uppercase or lowercase for the signal names.Because "int" (in lowercase) is a dbx keyword, you cannot use it as an abbreviation for the SIGINT signal. You must use uppercase ("INT"), the full signal name ("SIGINT" or "sigint"), or the signal number ("2"). SIGINT is the only signal name with such a restriction.If you instruct dbx to catch a signal, whenever that signal is directed to your program, dbx intercepts it and stops your program. Your program does not see this signal until you continue your program with the cont command. If your program did not declare a signal handler for a signal, your program does not see the signal when dbx continues it.If you issue a SIGINT signal at the keyboard (usually by pressing <Ctrl-C>) while you are running an application under dbx, what happens depends on the circumstances:If the process is in the same IRIX process group as dbx, the interrupt signal is sent to both dbx and the process. Both dbx and the process stop running. You are left at the dbx command line.If the process was added with addproc, dbx -P, or dbx -p, it is not in the same IRIX process group as dbx. In this case, the signal interrupt is sent to dbx but not to the process. dbx stops running, but the process continues to run. Use the showproc command to see whether the process is still running. Then use the suspend command to stop the process. LBL="7.5.2" HELPID=""ID="62814"Continuing after Catching a SignalThe ID="dbx_ch7115"cont command allows you to continue execution after catching a signal. If your program stopped because dbx caught a signal intended for your program, then dbx will send that signal to your program when you continue execution. You can also use the cont command to specify a different signal to send to your program than the one that dbx caught. Using the same syntax, you can also send a signal to your program when you continue even if your program did not stop because of a caught signal.Use the following forms of the cont command when handling signals. In each case, if you do not provide a signal, but your program stopped because dbx caught a signal intended for your program, then dbx sends that signal to your program when you continue execution:contID="dbx_ch7116" [ signal ]Continue execution with the current line and send the specified signal to your program.ID="dbx_ch7117"contID="dbx_ch7118" [ signal ] { at | to } lineSet a temporary breakpoint at the specified source line, then resume execution with the current line and send the specified signal to your program.ID="dbx_ch7119"contID="dbx_ch7120" [ signal ] in   procedureSet a temporary breakpoint to stop execution upon entering the specified procedure, then resume execution with the current line and send the specified signal to your program.ID="dbx_ch7121"For example, if your program stopped because dbx caught a SIGINT signal, dbx will automatically send that signal to your program if you enter:(dbx) contSuppose you have a procedure called alarm_handler to handle an alarm signal sent to your program. If you want to test this procedure by single-stepping through it, you can execute the command:(dbx) cont SIGALRM in alarm_handlerThis would set a temporary breakpoint to stop your program upon entering alarm_handler, continue execution of your program, and send a SIGALRM signal to your program. Your program would then enter the alarm_handler procedure and stop. You can then single-step through the procedure and observe execution.Debugging a program that attempts to catch signals can be awkward if you also catch the signal in dbx. For example, if your program wants to catch SIGFPEs and you issue the command:(dbx) catch sigfpethen, after dbx catches the signal, you must execute the command:(dbx) ignore sigfpeto prevent dbx from catching the signal again when you resume execution of your program.If you want to catch further instances of that signal in your program, you must regain dbx control (the best way is to set a breakpoint before executing the cont) to re-execute the catch sigfpe command.LBL="7.6" HELPID=""ID="93296"Stopping at System CallsBecause system calls are part of the operating system and their source is generally not available for debugging purposes, you cannot set breakpoints in system calls using the same method that you use for your program's procedures. Instead, dbx provides the ID="dbx_ch7122"syscall command to allow you to stop your program when it executes system calls. With the syscall command you can catch (breakpoint) system calls either at the entry to the system call or at the return from the system call.The syntax of the syscall command is:syscall catchID="dbx_ch7123" { call | return } { system_call | all }Set a breakpoint to stop execution upon entering (ID="dbx_ch7124"call) or returning from (return) the specified system call. Note that you can set dbx to catch both the call and the return of a system call.If you use the keyword all rather than giving a specific system call, dbx catches all system calls.syscall ignoreID="dbx_ch7125" { call | return } { system_call | all }Clear the breakpoint to stop execution upon entering (ID="dbx_ch7126"call) or returning from (return) the specified system call.If you use the keyword all rather than giving a specific system call, dbx clears the breakpoints to stop execution upon entering (call) or returning from (return) all system calls.syscall catchID="dbx_ch7127" [ { call | return } ]Print a list of all system calls caught upon entry (ID="dbx_ch7128"call) or return (return). If you provide neither the call nor return keyword, dbx lists all system calls that are caught.syscall ignoreID="dbx_ch7129" [ { call | return } ]Print a list of all system calls not caught upon entry (ID="dbx_ch7130"call) or return (return). If you provide neither the call nor return keyword, dbx lists all system calls that are ignored.syscallID="dbx_ch7131"Print a summary of the catch and ignore status of all system calls. The summary is divided into four sections: 1) caught at call, 2) caught at return, 3) ignored at call, and 4) ignored at return.The ID="dbx_ch7132"execv, ID="dbx_ch7133"execve, ID="dbx_ch7134"fork, and ID="dbx_ch7135"sproc system calls are treated specially as they invoke new processes. In particular, the returns from these system calls are controlled by the dbx variables ID="dbx_ch7136"$promptonfork and ID="dbx_ch7137"$mp_program, not by ID="dbx_ch7138"syscall. This is discussed in depth in IDREF="61470" TYPE="TITLE"Section 9.11, "Handling fork System Calls"
 and IDREF="59516" TYPE="TITLE"Section 9.13, "Process Group Debugging."
 These system calls are always marked as catch return.The system calls are all listed in /usr/include/sys.s. dbx ignores the case of the system call names in all syscall commands; therefore, you can use uppercase or lowercase in these commands.A particularly useful setting is:(dbx) syscall catch call exitThis stops your program upon entry to ID="dbx_ch7139"exit. With your program stopped, you can do a stack trace before the termination to see why exit was called.LBL="7.7" HELPID=""ID="31135"Stepping Through Your ProgramSteppingID="dbx_ch7140" is a process of executing your program for a fixed number of lines and then automatically returning control to dbx. dbx provides two commands for stepping through lines of code, ID="dbx_ch7141"step and ID="dbx_ch7142"next.For both step and next, dbx counts only those source lines that actually contain code; dbx ignores blank lines and lines consisting solely of comments for the purposes of stepping.The next and step commands differ in their treatment of procedure calls. When step encounters a procedure call, it usually "steps into" the procedure and continues stepping through the procedure. On the other hand, when next encounters a procedure call, it "steps over" the procedurename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'executing it without stoppingname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'and continues stepping through the current procedure.The following code fragment illustrates the difference between step and next:   55  foo( arg1, arg2 )
   56  int arg1, arg2;
   57  {
   58        if ( arg1 < arg2 ) {
   ...       ...
   78        return( 0 );
   79  }
   ...
211  x = foo( i, j );
212  y = 2 * x;In this example, if at line 211 you execute a step command to advance one line, dbx proceeds to line 58 (the first code line of the foo procedure); however, if you execute a next command, dbx executes line 211name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'calling fooname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'and advances to line 212.LBL="7.7.1" HELPID=""Using the return CommandIf you have stepped into a procedure and then decide you don't want to step through the rest of it, use ID="dbx_ch7143"return to finish executing the procedure and return to the calling procedure.The format of the return command is:returnID="dbx_ch7144"Continue execution until control returns to the next procedure on the stack.return [ proc ]Continue execution until control returns to the named procedure. The procedure must be in the current activation stack.LBL="7.7.2" HELPID=""ID="33387"Stepping Using the step CommandThe format of the step command is:stepID="dbx_ch7145" [ integer ]Execute the specified number of lines of source code, stepping into procedures. If you do not provide an argument, step executes one line. If step encounters any breakpoints, it immediately stops execution.By default, step steps into only those procedures that are compiled with the debugging options ID="dbx_ch7146"-g, -g2, or -g3 for which there are line numbers in the symbol table. Note that this does not include standard library routines because they are not compiled using debugging options.ID="dbx_ch7147"You can modify this behavior, even force dbx to step into procedures not compiled with a symbol table, by changing the value of the dbx variable $stepintoall. IDREF="66599" TYPE="TABLE"Table 7-1
 summarizes how the value of ID="dbx_ch7148"$stepintoall affects dbx's treatment of the step command.COLUMNS="2"LEFT="0" WIDTH="63"$stepintoall 
valueLEFT="70" WIDTH="356"Effect on step CommandLEFT="0" WIDTH="63"0 (default)LEFT="70" WIDTH="356"step steps into only those procedures that are compiled with the 
debugging options -g, -g2, or -g3 for which there are line 
numbers in the symbol table. step steps over all other procedures.LEFT="0" WIDTH="63"1LEFT="70" WIDTH="356"step steps into the above procedures plus all procedures for 
which dbx can find a source file. Note that when you debug a 
source file compiled without symbols or compiled with 
optimization, the line numbers may sometimes jump erratically.LEFT="0" WIDTH="63"2LEFT="70" WIDTH="356"step steps into all procedures.  Note that when you debug a 
source file compiled without symbols or compiled with 
optimization, the line numbers may sometimes jump erratically.Also note that if dbx cannot locate a source file, then it cannot 
display source lines as you step through a procedure.LBL="7-1"Table 7-1 ID="66599"Effect of $stepintoall Variable on the step CommandLBL="7.7.3" HELPID=""ID="24643"Stepping Using the next CommandThe format of the next command is:nextID="dbx_ch7149" [ integer ]Execute the specified number of lines of source code, stepping over procedures. If you do not provide an argument, next executes one line. If next encounters any breakpoints, even in procedures that it steps over, it immediately stops execution.IDREF="19336" TYPE="TABLE"Table 7-2 summarizes how the value of ID="dbx_ch7150"$nextbreak affects dbx's treatment of the next command.COLUMNS="2"LEFT="0" WIDTH="63"$nextbreak 
ValueLEFT="70" WIDTH="356"Effect on next CommandLEFT="0" WIDTH="63"2 (default)LEFT="70" WIDTH="356"next executes procedure calls at full speed. If next is executed 
from within a function that recurses, it may stop at a deeper level 
of recursion rather than at the next source. To avoid this, set 
$nextbreak to 1.LEFT="0" WIDTH="63"1LEFT="70" WIDTH="356"next single-steps through procedure calls, including library 
functions and gets back to exactly the next statement. (In the 
current implementation, stop if, trace, or when commands testing 
variables may fail with the message not active, stopping the 
execution.) The single-step rate is not determined by $naptime. 
This is slow but guarantees return to the right place even if part 
of your code is compiled without symbols and is recursive.LEFT="0" WIDTH="63"0LEFT="70" WIDTH="356"ID="dbx_ch7151"$stepintoall determines how "visible" procedures are to next. If 
$stepintoall = 0, then next single-steps only through those 
procedures compiled with the -g, -g2, or -g3 flags for which it can 
find the source file; it executes all others at full speed. If 
$stepintoall = 1, then next single-steps those procedures listed 
above, plus all other procedures for which dbx can find source 
code; all others it executes at full speed. If $stepintoall = 2, then 
next single-steps through all procedures.LBL="7-2"Table 7-2 ID="19336"Effect of $nextbreak Variable on the next CommandLBL="7.8" HELPID=""ID="28904"Starting at a Specified LineOrdinarily, when you continue your program, you do so at the place where it stopped using the ID="dbx_ch7152"cont command. However, you can also force your program to continue at a different address by using the goto command:gotoID="dbx_ch7153"   lineBegin execution at the specified line. You may not use the goto command to resume execution with a line outside of the current procedure.You might, for example, want to use the goto command when you step across a function call with the next command and find that the return value is incorrect.To determine where in the function the error occurred, you can rerun the program and execute up to this function call, then step into the function to debug the function; however, this can be time consuming.If the function does not have significant side effects, you can get the same information by resuming execution just before the function call and stepping through it. To do this, first set a breakpoint in the function. Then use the goto command to continue execution on the line with the function call.LBL="8"ID="28107"Debugging Machine Language CodeThis chapter explains how to debug machine language code by:examining and changing register values (IDREF="88998" TYPE="TITLE"Section 8.1
)printing the contents of memory addresses (IDREF="51451" TYPE="TITLE"Section 8.2
)disassembling source code (IDREF="51451" TYPE="TITLE"Section 8.2
)setting breakpoints (IDREF="64338" TYPE="TITLE"Section 8.3
)continuing after breakpoints (IDREF="37993" TYPE="TITLE"Section 8.4
)tracing variables (IDREF="81564" TYPE="TITLE"Section 8.5
)executing single lines of code (IDREF="53669" TYPE="TITLE"Section 8.7
)LBL="8.1" HELPID=""ID="88998"RegistersUsing dbx you can examine and change the hardware registers during execution of your program. ID="dbx_ch81"IDREF="39923" TYPE="TABLE"Table 8-1
 lists the machine form of the register names along with the alternate software names as defined in the include file ID="dbx_ch82"regdef.h.COLUMNS="3"LEFT="0" WIDTH="72"RegisterLEFT="80" WIDTH="72"Alternate FormLEFT="160" WIDTH="356"DescriptionLEFT="0" WIDTH="72"$r0LEFT="80" WIDTH="72"$zeroLEFT="160" WIDTH="356"Always 0LEFT="0" WIDTH="72"$r1LEFT="80" WIDTH="72"$atLEFT="160" WIDTH="356"Reserved for assemblerLEFT="0" WIDTH="72"$r2 ... $r3LEFT="80" WIDTH="72"$v0 ... v1LEFT="160" WIDTH="356"Expression evaluations, function return 
values, static linksLEFT="0" WIDTH="72"$r4 ... $r7LEFT="80" WIDTH="72"$a0 ... $a3LEFT="160" WIDTH="356"ArgumentsLEFT="0" WIDTH="72"$r8 ... $r15LEFT="80" WIDTH="72"$t0 ... t7LEFT="160" WIDTH="356"TemporariesLEFT="0" WIDTH="72"$r16 ... $r23LEFT="80" WIDTH="72"$s0 ... $s7LEFT="160" WIDTH="356"Saved across procedure callsLEFT="0" WIDTH="72"$r24 ... $r25LEFT="80" WIDTH="72"$t8 ... $t9LEFT="160" WIDTH="356"TemporariesLEFT="0" WIDTH="72"$r26 ... $r27LEFT="80" WIDTH="72"$k0 ... $k1LEFT="160" WIDTH="356"Reserved for kernelLEFT="0" WIDTH="72"$r28LEFT="80" WIDTH="72"$gpLEFT="160" WIDTH="356"Global pointerLEFT="0" WIDTH="72"$r29LEFT="80" WIDTH="72"$spLEFT="160" WIDTH="356"Stack pointerLEFT="0" WIDTH="72"$r30LEFT="80" WIDTH="72"$s8LEFT="160" WIDTH="356"Saved across procedure callsLEFT="0" WIDTH="72"$r31LEFT="80" WIDTH="72"$raLEFT="160" WIDTH="356"Return addressLEFT="0" WIDTH="72"$mmhiLEFT="80" WIDTH="72"LEFT="160" WIDTH="356"Most significant multiply/divide result 
registerLEFT="0" WIDTH="72"$mmloLEFT="80" WIDTH="72"LEFT="160" WIDTH="356"Least significant multiply/divide result 
registerLEFT="0" WIDTH="72"$fcsrLEFT="80" WIDTH="72"LEFT="160" WIDTH="356"Floating point control and status registerLEFT="0" WIDTH="72"$feirLEFT="80" WIDTH="72"LEFT="160" WIDTH="356"Floating point exception instruction registerLEFT="0" WIDTH="72"$causeLEFT="80" WIDTH="72"LEFT="160" WIDTH="356"Exception cause registerLEFT="0" WIDTH="72"$d0 ... $d30LEFT="80" WIDTH="72"LEFT="160" WIDTH="356"Double precision floating point registersLEFT="0" WIDTH="72"$f0 ... $f30LEFT="80" WIDTH="72"LEFT="160" WIDTH="356"Single precision floating point registersLBL="8-1"Table 8-1 ID="39923"Hardware Registers and AliasesFor registers with alternate names, the dbx variable ID="dbx_ch83"$regstyle controls which name is displayed when you disassemble code (as described in ID="dbx_ch84"IDREF="51451" TYPE="TITLE"Section 8.2, "Examining Memory and Disassembling Code"
). If  $regstyle is set to 0, then dbx uses the alternate form of the register name (for example, "zero" instead of "r0" and "t1" instead of "r9"); if $regstyle is anything other than 0, the machine names are used ("r0" through "r31").LBL="8.1.1" HELPID=""Printing Register ValuesUse the ID="dbx_ch85"printregs command to print the values stored in all registers.ID="dbx_ch86"The base in which the register values are displayed depends on the values of the dbx variables ID="dbx_ch87"$octints and ID="dbx_ch88"$hexints. By default, dbx prints the register values in decimal. You can set the output base to octal by setting the ID="dbx_ch89"dbx variable $octints to a nonzero value. You can set the output base to hexadecimal by setting the ID="dbx_ch810"dbx variable $hexints to a nonzero value. If you set both $octints and $hexints to nonzero values, $hexints takes precedence.To examine the register values in hexadecimal, enter the following:(dbx) set $hexints = 1
(dbx) printregs

r0/zero=0x0         r1/at=0x1           r2/v0=0x19          r3/v1=0x0
r4/a0=0x4           r5/a1=0x7fffc77c    r6/a2=0x7fffc784    r7/a3=0x0
r8/t0=0x4           r9/t1=0x35          r10/t2=0x39         r11/t3=0x0
r12/t4=0x38353900   r13/t5=0x100010c3   r14/t6=0x5          r15/t7=0x5
r16/s0=0x0          r17/s1=0x0          r18/s2=0x0          r19/s3=0x0
r20/s4=0x0          r21/s5=0x0          r22/s6=0x0          r23/s7=0x0
r24/t8=0x0          r25/t9=0x1          r26/k0=0x0          r27/k1=0xffffc100
r28/gp=0x10008f90   r29/sp=0x7fffc738   r30/s8=0x0          r31/ra=0x40028c
$f0=  0.0           $f2=  0.0           $f4=  0.0           $f6=  0.0
$f8=  0.0           $f10= 0.0           $f12= 0.0           $f14= 0.0
$f16= 0.0           $f18= 0.0           $f20= 0.0           $f22= 0.0
$f24= 0.0           $f26= 0.0           $f28= 0.0           $f30= 0.0
$d0=  0.0           $d2=  0.0           $d4=  0.0           $d6=  0.0
$d8=  0.0           $d10= 0.0           $d12= 0.0           $d14= 0.0
$d16= 0.0           $d18= 0.0           $d20= 0.0           $d22= 0.0
$d24= 0.0           $d26= 0.0           $d28= 0.0           $d30= 0.0
$pc=  0x400290      $mmhi=0x0           $mmlo=0x19          $cause=0x24
$badvaddr=0x403a4c  $fcsr=0x0           $feir=0x0You can also use the value of a single register in an expression by typing the name of the register preceded by a dollar sign ($). For example, to print the current value of the program counter (the ID="dbx_ch811"$pc register), enter:(dbx) print $pc
0x400290LBL="8.1.2" HELPID=""ID="34959"Changing Register ValuesIn the same way you change the values of program variables, you can use the ID="dbx_ch812"assign command to change the value of registers:assignID="dbx_ch813"   register   =   expressionAssign the value of ID="dbx_ch814"expression to register. You must precede the name of the register with a dollar sign ($).For example:(dbx) assign $f0 = 3.14159
3.1415901184082031
(dbx) assign $t8 = 0x5a
0x5aLBL="8.2" HELPID=""ID="51451"Examining Memory and Disassembling CodeThe forward slash (/) and question mark (?) commands allow you to examine the contents of memory. Depending on the format you specify, you can display the values as numbers, characters, or disassembled machine code.The commands for examining memory have the following syntax:address ID="dbx_ch815"/ count   formatPrint the contents of the specified address or disassemble the code for the instruction at the specified address. Repeat for a total of ID="dbx_ch816"ID="dbx_ch817"count addresses in increasing addressname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in other words, an "examine forward" command. The format codes are listed in IDREF="54646" TYPE="TABLE"Table 8-2
.address   ID="dbx_ch818"? count   formatPrint the contents of the specified address or disassemble the code for the instruction at the specified address. Repeat for a total of ID="dbx_ch819"ID="dbx_ch820"count addresses in decreasing addressname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in other words, an "examine backward" command. The format codes are listed in IDREF="54646" TYPE="TABLE"Table 8-2
.address   ID="dbx_ch821"/   count L   value   maskExamine ID="dbx_ch822"count 32-bit words in increasing address and print those 32-bit words which, when ORed with mask, equals value. This command searches memory for specific patterns..ID="dbx_ch823"/Repeat the previous examine command with increasing address. .ID="dbx_ch824"?Repeat the previous examine command with decreasing address.COLUMNS="2"LEFT="0" WIDTH="72"Format CodeLEFT="80" WIDTH="356"Displays Memory in the FormatLEFT="0" WIDTH="72"iLEFT="80" WIDTH="356"print machine instructions (disassemble)LEFT="0" WIDTH="72"dLEFT="80" WIDTH="356"print a 16-bit word in signed decimalID="dbx_ch825"LEFT="0" WIDTH="72"DLEFT="80" WIDTH="356"print a 32-bit word in signed decimalID="dbx_ch826"LEFT="0" WIDTH="72"ddLEFT="80" WIDTH="356"print a 64-bit word in signed decimalID="dbx_ch827"LEFT="0" WIDTH="72"oLEFT="80" WIDTH="356"print a 16-bit word in octalLEFT="0" WIDTH="72"OLEFT="80" WIDTH="356"print a 32-bit word in octalID="dbx_ch828"LEFT="0" WIDTH="72"ooLEFT="80" WIDTH="356"print a 64-bit word in octalID="dbx_ch829"LEFT="0" WIDTH="72"xLEFT="80" WIDTH="356"print a 16-bit word in hexadecimalLEFT="0" WIDTH="72"XLEFT="80" WIDTH="356"print a 32-bit word in hexadecimalID="dbx_ch830"LEFT="0" WIDTH="72"xxLEFT="80" WIDTH="356"print a 64-bit word in hexadecimalID="dbx_ch831"LEFT="0" WIDTH="72"vLEFT="80" WIDTH="356"print a 16-bit word in unsigned decimalID="dbx_ch832"LEFT="0" WIDTH="72"VLEFT="80" WIDTH="356"print a 32-bit word in unsigned decimalID="dbx_ch833"LEFT="0" WIDTH="72"vvLEFT="80" WIDTH="356"print a 64-bit word in unsigned decimalID="dbx_ch834"LEFT="0" WIDTH="72"LLEFT="80" WIDTH="356"like X but use with val mask LEFT="0" WIDTH="72"bLEFT="80" WIDTH="356"print a byte in octalID="dbx_ch835"LEFT="0" WIDTH="72"cLEFT="80" WIDTH="356"print a byte as character LEFT="0" WIDTH="72"sLEFT="80" WIDTH="356"print a string of characters that ends in a null byte LEFT="0" WIDTH="72"fLEFT="80" WIDTH="356"print a single-precision real number LEFT="0" WIDTH="72"gLEFT="80" WIDTH="356"print a double-precision real numberLBL="8-2"Table 8-2 ID="54646"Memory Display Format CodesFor example, to display 10 disassembled machine instructions starting at the current address of the program counter, enter:(dbx) $pc/10i
*[main:26, 0x400290]    sw      zero,28(sp)
   [main:27, 0x400294]    sw      zero,24(sp)
   [main:29, 0x400298]    lw      t1,28(sp)
   [main:29, 0x40029c]    lw      t2,32(sp)
   [main:29, 0x4002a0]    nop
   [main:29, 0x4002a4]    slt     at,t1,t2
   [main:29, 0x4002a8]    beq     at,zero,0x4002ec
   [main:29, 0x4002ac]    nop
   [main:31, 0x4002b0]    lw      t3,28(sp)
   [main:31, 0x4002b4]    nopTo disassemble another 10 lines, enter:(dbx) ./
   [main:31, 0x4002b8]    addiu   t4,t3,1
   [main:31, 0x4002bc]    sw      t4,28(sp)
   [main:32, 0x4002c0]    lw      t5,24(sp)
   [main:32, 0x4002c4]    lw      t6,28(sp)
   [main:32, 0x4002c8]    nop
   [main:32, 0x4002cc]    addu    t7,t5,t6
   [main:32, 0x4002d0]    sw      t7,24(sp)
   [main:33, 0x4002d4]    lw      t8,28(sp)
   [main:33, 0x4002d8]    lw      t9,32(sp)
   [main:33, 0x4002dc]    nopTo examine ten 32-bit words starting at address 0x7fffc754 and print those whose least significant byte is hexadecimal 0x19, enter:(dbx) 0x7fffc754 / 10 L 0x19 0xff
7fffc758:  00000019If you have a single-precision floating point array named array, you can examine the six consecutive elements beginning with the fifth element by entering:(dbx) &array[4] / 6f
7fffc748:  0.2500000 0.2000000 0.1666667 0.1428571
7fffc758:  0.1250000 0.1111111LBL="8.3" HELPID=""ID="64338"Setting Machine-level Breakpointsdbx allows you to set breakpoints while debugging machine code just as you can while debugging source code. You set breakpoints at the machine code level using the ID="dbx_ch836"ID="dbx_ch837"stopi command.The conditional and unconditional versions of the stopi commands work in the same way as the stop command described in IDREF="23865" TYPE="TITLE"Section 7.1, "Breakpoints,"
 with two exceptions:The stopi command checks its breakpoint conditions on a machine-instruction level instead of a source-code level.The stopi at commands require an address rather than a line number.Each breakpoint is assigned a number when you create it. You use this number to reference the breakpoint in the various commands provided for manipulating breakpoints (for example, ID="dbx_ch838"disable, ID="dbx_ch839"enable, and ID="dbx_ch840"delete, all described IDREF="14485" TYPE="TITLE"Section 7.4, "Managing Breakpoints, Traces, and Conditional Commands"
).LBL="8.3.1" HELPID=""Syntax of the stopi CommandThe syntax of the stopi command is:stopi atID="dbx_ch841"Set an unconditional breakpoint at the current instruction.ID="dbx_ch842"stopi atID="dbx_ch843"   addressSet an unconditional breakpoint at the specified address.ID="dbx_ch844"stopi inID="dbx_ch845"   procedureSet an unconditional breakpoint to stop execution upon entering the specified procedure.ID="dbx_ch846"stopiID="dbx_ch847"   variableInspect the value before executing each instruction and stop if the value has changed. Note that execution is very slow if you choose this type of conditional breakpoint.ID="dbx_ch848"stopiID="dbx_ch849"   variable   at   addressInspect the value at the given address and stop if the value has changed.ID="dbx_ch850"stopiID="dbx_ch851"   variable   in   procedureInspect the value at every instruction within a given procedure and stop if the value has changed.ID="dbx_ch852"stopiID="dbx_ch853"   if   expressionEvaluate the expression before executing each instruction and stop if the expression is true. Note that execution is very slow if you choose this type of conditional breakpoint.ID="dbx_ch854"stopiID="dbx_ch855"   at   address   if   expressionEvaluate the expression at the given address and stop if the expression is true.ID="dbx_ch856"stopiID="dbx_ch857"   in   procedure   if   expressionEvaluate the expression at every instruction within a given procedure and stop if the expression is true.ID="dbx_ch858"stopiID="dbx_ch859"   variable   if   expressionTest both conditions before executing each instruction. Note that execution is very slow if you choose this type of conditional breakpoint.ID="dbx_ch860"stopiID="dbx_ch861"   variable   at   address   if   expressionTest both conditions at the given address.ID="dbx_ch862"stopiID="dbx_ch863"   variable   in   procedure   if   expressionTest both conditions at every instruction within a given procedure.ID="dbx_ch864"When you stop execution because of a machine-level breakpoint set by one of the stopi in commands, a ID="dbx_ch865"where command at the point of stop may yield an incorrect stack trace. This is because the stack for the function is not completely set up until several machine instructions have been executed. dbx attempts to account for this but is sometimes unsuccessful.LBL="8.3.2" HELPID=""ID="54393"Linking with DSOsIf you have linked with a DSO, you need to be a bit more careful when you use the stopi at command. For example, suppose you give the commanddbx()   stopi at functionxThe breakpoint at functionx will be hit only if the gp_prolog instruction has actually been executed. (gp_prolog is a short sequence of instructions at the beginning of the routine that implements DSOs.) To avoid this problem, use the stopi in command:dbx()   stopi in functionxIf you really want to use stopi at, a safe alternative is to disassemble functionx and put the breakpoint after the gp_prolog.The tracei at, wheni at, and conti at commands described in the following sections also follow this pattern. Use their "in" versions to ensure that the function breakpoint is hit.LBL="8.4" HELPID=""ID="37993"Continuing Execution after a Machine-level BreakpointThe ID="dbx_ch866"conti command continues executing assembly code after a breakpoint. As with the ID="dbx_ch867"ID="dbx_ch868"cont command, if your program stopped because dbx caught a signal intended for your program, then dbx   sends that signal to your program when you continue execution. You can also explicitly send a signal to your program when you continue execution. Signal processing and sending signals to your program is discussed in ID="dbx_ch869"IDREF="25866" TYPE="TITLE"Section 7.5, "Signal Processing."The syntax of the conti command is:contiID="dbx_ch870" [ signal ]Continue execution with the current instruction.contiID="dbx_ch871" [ signal ] { at | to } addressSet a temporary breakpoint at the specified address, then resume execution with the current instruction. When your program reaches the breakpoint at address, dbx stops your program and deletes the temporary breakpoint.contiID="dbx_ch872" [ signal ] in   procedureSet a temporary breakpoint to stop execution upon entering the specified procedure, then resume execution with the current instruction. When your program reaches the breakpoint in procedure, dbx stops your program and deletes the temporary breakpoint.See also IDREF="54393" TYPE="TITLE"Section 8.3.2, "Linking with DSOs,"
 for a description on using the conti in and conti at commands with DSOs.LBL="8.5" HELPID=""ID="81564"Tracing Execution at the Machine LevelThe ID="dbx_ch873"tracei command allows you to observe the progress of your program while debugging machine code just as you can with the trace command while debugging source code. The tracei command traces in units of machine instructions instead of in lines of code.Each trace is assigned a number when you create it. You use this number to reference the breakpoint in the various commands provided for manipulating breakpoints (for example, ID="dbx_ch874"disable, ID="dbx_ch875"enable, and ID="dbx_ch876"delete, all described IDREF="14485" TYPE="TITLE"Section 7.4
).The syntax of the tracei command is:traceiID="dbx_ch877"ID="dbx_ch878"   variableWhenever the specified variable changes, dbx prints the old and new values of that variable. Note that execution is very slow if you choose this type of trace.traceiID="dbx_ch879"   procedureThis command is equivalent to entering trace   procedure. dbx prints the values of the parameters passed to the specified procedure whenever your program calls it. Upon return, dbx prints the return value.traceiID="dbx_ch880"   variable   at   addressdbx prints the value of the variable whenever your program reaches the specified address.traceiID="dbx_ch881"   variable   in   procedureWhenever the variable changes within the procedure that you specify, dbx prints the old and new values of that variable.traceiID="dbx_ch882"   variable   at   address   if   expressiondbx prints the value of the variable whenever your program reaches the specified address and the given expression is true.traceiID="dbx_ch883"   variable   in   procedure   if   expressionWhenever the variable changes within the procedure that you specify, dbx prints the old and new values of that variable if the given expression is true.See also IDREF="54393" TYPE="TITLE"Section 8.3.2, "Linking with DSOs,"
 for a description on using the tracei in and tracei at commands with DSOs.LBL="8.6" HELPID=""Writing Conditional Commands at the Machine LevelUse the ID="dbx_ch884"wheni command to write conditional commands for use in debugging machine code. The wheni command works in the same way as the when command described in IDREF="89878" TYPE="TITLE"Section 7.3, "Writing Conditional Commands."
 The command list is a list of   dbx commands, separated by semicolons. When the specified conditions are met, the command list is executed. If one of the commands in the list is stop (with no operands), then the process stops when the command list is executed.wheni ifID="dbx_ch885"   expression   {   command-list   }Evaluate the expression before executing each machine instruction. If the expression is true, execute the command list.wheni at   address [ if   expression ] {   command-list   }Evalute the expression at the given address. If the expression is true, execute the command list. wheni in   procedure [ if   expression ] {   command-list   }Evaluate the expression in the given procedure. If the expression is true, execute the command list. wheni   variable [ at   address ] [ if   expression ] {   command-list   }Test both conditions at the given address. If the conditions are true, execute the command list. wheni   variable [ in   procedure ] [ if   expression ] {   command-list   }Test both conditions at every machine instruction within a given procedure. If they are true, execute the command list.See also IDREF="54393" TYPE="TITLE"Section 8.3.2, "Linking with DSOs,"
 for a description on using the wheni in and wheni at commands with DSOs.LBL="8.7" HELPID=""ID="53669"Stepping Through Machine CodeThe ID="dbx_ch886"ID="dbx_ch887"stepi   and ID="dbx_ch888"nexti   commands allow you to step through machine code in much the same way as you can with the step and next commands while debugging source code. The step and next commands step in units of machine instructions instead of in lines of code.The formats of the nexti and stepi commands are:nextiID="dbx_ch889" [ integer ]Execute the specified number of machine instructions, stepping over procedures. If you do not provide an argument, nexti executes one line. If nexti encounters any breakpoints, even in procedures that it steps over, it immediately stops execution.stepiID="dbx_ch890"Single step one machine instruction, stepping into procedures (as called by jal and   jalr). If stepi encounters any breakpoints, it immediately stops execution.stepiID="dbx_ch891" [ n ]Execute the specified number of machine instructions, stepping into procedures (as called by jal and jalr). stepbID="dbx_ch892"Execute the program until the next jump, jal, or conditional branch machine instruction.stepbID="dbx_ch893" [   n ]Execute the program until the nth jump, jal, or conditional branch machine instruction.stepjID="dbx_ch894"Execute the program until the next jump or jal machine instruction.stepjID="dbx_ch895" [ n ]Execute the program until the nth jump or jal machine instruction.The values of the dbx variables ID="dbx_ch896"$stepintoall and ID="dbx_ch897"$nextbreak affect the stepi and nexti commands just as they do the step and next commands. See IDREF="31135" TYPE="TITLE"Section 7.7, "Stepping Through Your Program,"
 for a discussion of these variables.For the stepj command, dbx determines the next jump by reading through the instructions until it finds a jump or jal machine instruction. Because it ignores conditional branches, it does not necessarily follow the sequence of the program's execution to find the "next" jump. LBL="9"ID="61722"Multiple Process DebuggingThis chapter explains multiprocess debugging procedures, including:ID="dbx_ch91"listing available processes (IDREF="12529" TYPE="TITLE"Section 9.2
)adding processes to dbx control (IDREF="45986" TYPE="TITLE"Section 9.3
)deleting processes from the dbx pool (IDREF="89656" TYPE="TITLE"Section 9.4
)selecting processes (IDREF="16095" TYPE="TITLE"Section 9.5
)suspending processes (IDREF="38426" TYPE="TITLE"Section 9.6
)resuming suspended processes (IDREF="87200" TYPE="TITLE"Section 9.7
)waiting for a specific process to stop (IDREF="12702" TYPE="TITLE"Section 9.8
)waiting for any process to stop (IDREF="82112" TYPE="TITLE"Section 9.9
)killing active processes (IDREF="68796" TYPE="TITLE"Section 9.10
)handling calls to fork (IDREF="61470" TYPE="TITLE"Section 9.11
)handling calls to exec (IDREF="10836" TYPE="TITLE"Section 9.12
)debugging process groups (IDREF="59516" TYPE="TITLE"Section 9.13
)LBL="9.1" HELPID=""Processesdbx supports debugging multiprocess applications, including processes spawned with either the ID="dbx_ch92"fork(2) or ID="dbx_ch93"sproc(2) system calls. You can attach child processes automatically to dbx. You also can perform process control operations on a single process or on all processes in a group.dbx provides commands specifically for seizing, stopping, and debugging currently running processes. When dbx seizes a process, it adds it to a pool of processes available for debugging. Once you select a process from the pool of available processes, you can use all the ID="dbx_ch94"dbx commands normally available.Once you are finished with the process, you can terminate it, return it to the pool, or return it to the operating system.Many ID="dbx_ch95"dbx commands allow you to append the clause ID="dbx_ch96"pid   pid (where pid is a numeric process ID or a debugger variable holding a process ID) to make them apply to process pid. Using the pid   pid clause means you can apply a command to any process in the process pool even though it is not the active process.For example, to set a breakpoint at line 97 of the process whose ID is 12745, enter:(dbx) stop at 97 pid 12745
Process 12745: [3] stop at "/usr/demo/test.c":97Commands that accept the pid   pid clause include:active        edit        resume         wait
addproc       file        return         whatis
assign        func        showpoc        when[i]
catch         goto        status         where
cont[i]       ignore      step[i}        whereis
delete        kill        stop[i]        which
delproc       next        suspend
directory     print       trace[i]
down          printf      up
dump          printregs   useAdditionally, dbx provides two variables that can be useful when you write scripts to debug multiprocess programs:ID="dbx_ch97"$lastchild Always set to the process ID of the last child process created by a fork or sproc.ID="dbx_ch98"$pid0 Always set to the process ID of the current process.See the dbx on-line help file section on hint_mp_debug for sample multiprocessing debugging scripts.LBL="9.2" HELPID=""ID="12529"Listing Available ProcessesUse the showproc command to list the available processes:showprocID="dbx_ch99" [ pid | all ]Show processes already in the ID="dbx_ch910"dbx process pool or processes that dbx can control. If you provide no arguments, dbx lists the processes it already controls. If you provide a process ID, pid, dbx displays the status of the specified process. If you use argument "all," dbx lists all the processes it controls as well as all those processes it could control but that are not yet added to the process pool.For example to display all processes in the process pool, enter:(dbx) showproc
Process 12711 (test) Trace/BPT trap [main:14 ,0x40028c]
Process 12712 (test) Trace/BPT trap [main:18 ,0x4002b4]To display only process 12712, enter:(dbx) showproc 12712
Process 12712 (test) Trace/BPT trap [main:18 ,0x4002b4]To display all processes that dbx can control, enter:(dbx) showproc all
Process 12711 (test) Trace/BPT trap [main:14 ,0x40028c]
Process 12055 (tcsh)
Process 12006 (clock)
Process 12054 (tcsh)
Process 12673 (zipxgizmo)
Process 12672 (zip)
Process 11974 (4Dwm)
Process 12712 (test) Trace/BPT trap [main:18 ,0x4002b4]
Process 12708 (dbx)
Process 12034 (xlock)LBL="9.3" HELPID=""ID="45986"Adding a Process to the Process PoolThe ID="dbx_ch911"ID="dbx_ch912"addproc command adds one or more specified processes to the dbx process pool. This allows you to debug a program that is already running. The syntax of the addproc command is:addproc   pid [ ... ]For example:(dbx) addproc 12924
Reading symbolic information of Process 12924 . . .
Process 12924 (loop_test) added to pool
Process 12924 (loop_test) runningLBL="9.4" HELPID=""ID="89656"Deleting a Process from the Process PoolThe ID="dbx_ch913"ID="dbx_ch914"delproc command removes a process from the process pool, freeing it from dbx control. When you delete a process from the process pool, dbx automatically returns the process to normal operation. The syntax of the delproc command is:delproc   pid [ ... ]For example:(dbx) delproc 12924
Process 12924 (loop_test) deleted from poolLBL="9.5" HELPID=""ID="16095"Selecting a ProcessWhile dbx has the ability to control multiple processes, by default, dbx commands apply to only one process at a time, the active process. To select a process from the process pool to be the active process, use the active command:activeID="dbx_ch915" [ pid ]Select a process, ID="dbx_ch916"pid, from dbx process pool as the active process. If you do not provide a process ID, dbx prints the currently active process ID.ID="dbx_ch917"For example, to determine which process is currently active, enter:(dbx) active
Process 12976 (test1) is activeTo then select process 12977 as the active process, enter:(dbx) active 12977
Process 12977 (test1) after fork [.fork.fork:15 +0x8,0x4005e8]LBL="9.6" HELPID=""ID="38426"Suspending a ProcessAdding a process to the dbx pool of controlled processes does not automatically stop the process; however, you must stop the process before you can debug the process with dbx. The suspend command allows you to stop a process in the dbx process pool:suspendID="dbx_ch918" Suspend the active process if it is running. If it is not running, this command does nothing.ID="dbx_ch919"suspend pid ID="dbx_ch920"pid Suspend the process ID="dbx_ch921"pid if it is in the dbx process pool. If it is not running, this command does nothing.For example, to stop the active process, enter:(dbx) suspend
Process 12987 (loop_test) requested stop [main:10 +0x8,0x400244]
    10  i = i % 10;Then to stop process 12988, enter:(dbx) suspend pid 12988
Process 12988 (test3) requested stop [main:29 +0x4,0x400424]
    10  j = k / 10.0;LBL="9.7" HELPID=""ID="87200"Resuming a Suspended ProcessTo resume execution of a suspended dbx controlled process, you can use either the ID="dbx_ch922"cont command or the resume command. If you use cont, you do not return to the dbx command interpreter until the program encounters an event (for example, a breakpoint). On the other hand, the resume command returns immediately to the dbx command interpreter.The syntax of the resume command is:resumeID="dbx_ch923" [ signal ]Resume execution of the active process and return immediately to the ID="dbx_ch924"dbx command interpreter. If you specify a signal, dbx   sends that signal to the process when it resumes.ID="dbx_ch925"resumeID="dbx_ch926" [ signal ] pid pid Resume execution of the process ID="dbx_ch927"pid and return immediately to the dbx command interpreter. If you specify a signal, dbx   sends that signal to the process when it resumes.ID="dbx_ch928"Because the resume command returns you to the dbx command interpreter after restarting the process, it is more useful than the cont command when debugging multiple processes. With resume, you are free to select and debug a process while another process is running.For example, if you are debugging multiple processes and want to resume the active process, enter:(dbx) resumedbx restarts the active process and returns the dbx prompt. You can then continue debugging, for example by switching to another process.LBL="9.8" HELPID=""ID="12702"Waiting for a Resumed ProcessTo wait for a process to stop for an event (such as a breakpoint), use the wait command. This is useful after a resume command. Also refer to the description of the ID="dbx_ch929"waitall command, described in IDREF="82112" TYPE="TITLE"Section 9.9, "Waiting for Any Running Process."The syntax of the wait command is:waitID="dbx_ch930" Wait for the active process to stop for an event.ID="dbx_ch931"wait pid ID="dbx_ch932"pid Wait for the process ID="dbx_ch933"pid to stop for an event.For example, assume that you want to wait until process 14280 stops, perhaps at a breakpoint you have set. To do so, enter:(dbx) wait pid 14280After you enter this command, dbx waits until process 14280 stops, at which point it displays the dbx prompt.LBL="9.9" HELPID=""ID="82112"Waiting for Any Running ProcessTo wait for any process currently running to breakpoint or stop for any reason, use the ID="dbx_ch934"ID="dbx_ch935"waitall command. It causes dbx to wait until a running process in the process list stops, at which point it returns you to the dbx command interpreter.When you return to the dbx command interpreter after a waitall command, dbx does not make the process that stopped the active process. You must use the active command to change the active process.For example, to wait until one of your processes under dbx control stops, enter:(dbx) waitallAfter you enter this command, dbx waits until a process stops, at which point it indicates which process stopped and displays the dbx prompt. For example:Process 14281 (loop_test) Terminated [main:10 +0x8,0x400244]
    10  i = i % 10;
(dbx)LBL="9.10" HELPID=""ID="68796"Killing a ProcessTo kill a process in the process pool while running dbx, use the kill command:killID="dbx_ch936" Kill the active process. ID="dbx_ch937"killID="dbx_ch938"   pid [ ... ]Kill the specified process(es).ID="dbx_ch939"For example, to kill process 14257, enter:(dbx) kill 14257
Process 14257 (fork_test) terminated
Process 14257 (fork_test) deleted from poolLBL="9.11" HELPID=""ID="61470"Handling fork System CallsWhen a program executes a ID="dbx_ch940"fork system call and starts another process, dbx allows you to add that process to the process pool. (See also IDREF="93296" TYPE="TITLE"Section 7.6, "Stopping at System Calls."
)The dbx variable ID="dbx_ch941"$promptonfork determines how dbx treats forks. IDREF="43416" TYPE="TABLE"Table 9-1
 summarizes its effects.COLUMNS="2"LEFT="0" WIDTH="72"ID="dbx_ch942"$promptonfork 
ValueLEFT="80" WIDTH="356"Effect on dbx's Treatment of ForksLEFT="0" WIDTH="72"0 (default)LEFT="80" WIDTH="356"dbx does not add the child process to the process pool. Both the 
child process and the parent process continue to run.LEFT="0" WIDTH="72"1LEFT="80" WIDTH="356"dbx stops the parent process and asks if you want to add the child 
process to the process pool. If you answer yes, then dbx adds the 
child process to the pool and stops the child process; if you 
answer no, dbx allows the child process to run and does not place 
it in the process pool.LEFT="0" WIDTH="72"2LEFT="80" WIDTH="356"dbx automatically stops both the parent and child processes and 
adds the child process to the process pool.LBL="9-1"Table 9-1 ID="43416"How the $promptonfork Variable Affects dbx's Treatment of ForksIDREF="59516" TYPE="TITLE"Section 9.13, "Process Group Debugging," provides additional information on debugging multiprocessing programs with emphasis on the ID="dbx_ch943"sproc system call, though some of the material in that section can apply as well to programs that use the fork system call.Consider a program named fork that contains these lines:main(argc, argv)
int argc;
char *argv;
{
     int pid;
     if ((pid = fork()) == -1)
        perror("fork");
     else if (pid == 0)
        printf("child\n");
     else { printf("parent\n");
}If you set $promptonfork to 1 and run the program, dbx prompts you whether it should add the child process to the process pool:(dbx) set $promptonfork = 1
(dbx) run
Process 14371 (fork_test) started
Process 14371 (fork_test) has executed the "fork" system call

Add child to process pool (n if no)?y
Reading symbolic information of Process 14372 . . .
Process 14372 (fork_test) added to pool
Process 14372 (fork_test) after fork [.fork.fork:15 +0x8,0x4005e8]
Process 14371 (fork_test) after fork [.fork.fork:15 +0x8,0x4005e8]
           Source (of sys/fork.s) not available for Process 14371LBL="9.12" HELPID=""ID="10836"Handling exec System CallsThe ID="dbx_ch944"exec system call executes another program. During an exec, the first program gives up its process number to the program it executes. When a program using DSOs executes an exec() call, dbx runs the new program to main. When a program linked with a non-shared library executes an exec() call, dbx reads the symbolic information for the new program and then stops program execution. In either case, you can continue by entering a ID="dbx_ch945"cont or ID="dbx_ch946"resume command.For example, consider the programs exec1.c and exec2.c:/* exec1.c */
main()
{
     printf("in exec1\n");
     /* Invoke the "exec2" program */

     execl("exec2", "exec2", 0);

     /* We'll only get here if execl() fails */

     perror("execl");
}
/* exec2.c */
main()
{
     printf("in exec2\n");
}The following shows what happens if you run exec1 under dbx and you have compiled and linked your program with DSOs (the default):ID="dbx_ch947"(dbx) run
Process 6979 (exec1) started
in exec1
Process 6979 (exec1) has exec()ed to become (exec2)
Re-reading symbolic information of Process 6979 . . .
Process 6979 (exec2) Trace/BPT trap (Signal 5) [main, :0x40077c]
*[main, 0x40077c] addiu sp,sp,-32
(dbx) where
> 0 main() [0x400778]The following code shows what happens if you run exec1 under dbx and you have compiled and linked your program with a non-shared library:(dbx) run
Process 14409 (exec1) started
in exec1
Process 14409 (exec1) has exec()ed to become (exec2)
Re-reading symbolic information of Process 14409 . . .
Process 14409 (exec2) after execve [__start, :0x4001c0]
*[__start, 0x4001c0] lw a0,0(sp)In either case, you can enter cont to continue executing exec2. For example:(dbx) cont
in exec2
Process 14409 (exec2) finishedLBL="9.13" HELPID=""ID="59516"Process Group DebuggingThe process group facility allows a group of processes to be operated on simultaneously by a single ID="dbx_ch948"dbx command. This is far more convenient to use when dealing with processes created with the ID="dbx_ch949"sproc system call than issuing individual resume, suspend, or breakpoint setting commands. This facility was created to deal more conveniently with parallel programs created, for example, by the Power Fortran Accelerator (PFA).ID="dbx_ch950"ID="dbx_ch951"The dbx variable ID="dbx_ch952"$mp_program determines how dbx treats ID="dbx_ch953"sproc system calls. IDREF="92131" TYPE="TABLE"Table 9-2
 summarizes its effects.COLUMNS="2"LEFT="0" WIDTH="72"$mp_program 
ValueLEFT="80" WIDTH="356"Effect on dbx's Treatment of sprocLEFT="0" WIDTH="72"0 (default)LEFT="80" WIDTH="356"dbx treats calls to sproc in the same way as it treats calls to ID="dbx_ch954"fork.LEFT="0" WIDTH="72"1LEFT="80" WIDTH="356"Child processes created by calls to sproc are allowed to run; they 
block on multiprocessor synchronization code emitted by mp 
Fortran or C code. When you set $mp_program to 1, mp Fortran or 
C code is easier to debug.LBL="9-2"Table 9-2 ID="92131"How the $mp_program Variable Affects dbx's Treatment of ForksWhenever a process executes a sproc, if dbx adds the child to the process pool, dbx also adds the parent and child to the ID="dbx_ch955"group list. The group list is simply a list of processes. If you set the dbx variable ID="dbx_ch956"$groupforktoo to 1, then forked processes are added to the group list automatically just as sproced processes are. (By default, $groupforktoo is set to 0.)You can explicitly add one or more processes to the group list with the ID="dbx_ch957"ID="dbx_ch958"addpgrp command (only processes in the process pool can be added to the group list):addpgrp   pid [ ... ]You can remove processes from the group list with the ID="dbx_ch959"ID="dbx_ch960"delpgrp command:delpgrp   pid [ ... ]The ID="dbx_ch961"ID="dbx_ch962"showpgrp command displays information about the group list. The following is an example of the output of the showpgrp command with two processes in the group list:(dbx) showpgrp
2 processes in group:
   14559 14558Once you have added processes to the group list, by adding the keyword pgrpID="dbx_ch963" to the end of certain dbx commands, you can apply that command to all processes in the group. The commands to which you can append pgrp are: delete, next[i], resume, stop[i], status, suspend, trace[i], and when[i].The breakpoints and traces set by the ID="dbx_ch964"ID="dbx_ch965"stop[i], trace[i], and when commands when used with the pgrp keyword are also added to the ID="dbx_ch966"group history. This group history is displayed as a numbered list when you execute showpgrp.The command:delete int   pgrpdeletes the history entry int for the process group. Thus you can delete breakpoints from multiple processes with a single command.Breakpoints set on the process group are recorded both in the group and in each process. Deleting breakpoints individually (even if set by a group command) is allowed.For example, the following command sets a breakpoint at line 10 in all processes in the group list:(dbx) stop at 10 pgrp
Process 14558: [6] stop at "/usr/demo/pgrp_test.c":10
Process 14559: [7] stop at "/usr/demo/pgrp_test.c":10If you now enter a status command, only those breakpoints associated with the active process are displayed:(dbx) status
Process 14559: [7] {pgrp 269011340} stop at "/usr/demo/pgrp_test.c":10By appending the keyword pgrp you can display the breakpoints for all processes in the group list:(dbx) status pgrp
Process 14558: [6] {pgrp 269011276} stop at "/usr/demo/pgrp_test.c":10
Process 14559: [7] {pgrp 269011340} stop at "/usr/demo/pgrp_test.c":10Use the showpgrp command to display the group history:(dbx) showpgrp
2 processes in group:
   14559 14558
Group history number: 10
          Process 14558 Process 14558: [6] stop at "/usr/demo/pgrp_test.c":10
          Process 14559 Process 14559: [7] stop at "/usr/demo/pgrp_test.c":10You can delete the breakpoints in both processes by deleting the associated group history entry. To do so in this example, enter:(dbx) delete 10 pgrp
(dbx) showpgrp
2 processes in group:
   14559 14558LBL="A"ID="37598"dbx CommandsAll dbx commands are listed below along with a brief description. For more information about a command, refer to the description of the command in the main text of this manual.address   ID="dbx_chA1"/ count   format Print the contents of the specified address or disassemble the code for the instruction at the specified address. Repeat for a total of ID="dbx_chA2"ID="dbx_chA3"count addresses in increasing addressname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in other words, an "examine forward" command. The format codes are listed in IDREF="54646" TYPE="TABLE"Table 8-2
.address   ID="dbx_chA4"? count   format Print the contents of the specified address or disassemble the code for the instruction at the specified address. Repeat for a total of ID="dbx_chA5"ID="dbx_chA6"count addresses in decreasing addressname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in other words, an "examine backward" command. The format codes are listed in IDREF="54646" TYPE="TABLE"Table 8-2
.address ID="dbx_chA7"/   count L   value   mask Examine ID="dbx_chA8"count 32-bit words in increasing address and print those 32-bit words which, when ORed with mask, equal value. This command searches memory for specific patterns../ID="dbx_chA9" Repeat the previous examine command with increasing address..?ID="dbx_chA10" Repeat the previous examine command with decreasing address.!!ID="dbx_chA11" Repeat the previous command. If the value of the ID="dbx_chA12"dbx variable ID="dbx_chA13"$repeatmode is set to 1, then entering a carriage return at an empty line is equivalent to executing !!. By default, $repeatmode is set to 0.ID="dbx_chA14"!string Repeat the most recent command that starts with the specified ID="dbx_chA15"string.ID="dbx_chA16"!integer Repeat the command associated with the specified ID="dbx_chA17"integer in the history list.ID="dbx_chA18"!-integer Repeat the command that occurred ID="dbx_chA19"integer times before the most recent command. Entering !-1 executes the previous command, !-2 the command before that, and so forth.;ID="dbx_chA20" You can use the semicolon (;) as a separator to include multiple commands on the same command line.\ID="dbx_chA21" You can use the backslash (\) at the end of a line of input to dbx to indicate that the command is continued on the next line.ID="dbx_chA22"/[   reg_exp ] Search forward through the current source file from the current line for the regular expression ID="dbx_chA23"ID="dbx_chA24"regexp. If dbx reaches the end of the file without finding the regular expression, it wraps around to the beginning of the file. dbx prints the first source line containing a match of the search expression.If you do not supply a regular expression, dbx searches forward based on the last regular expression you searched for.ID="dbx_chA25"?[   reg_exp ] Search backward through the current source file from the current line for the regular expression ID="dbx_chA26"ID="dbx_chA27"regexp. If dbx reaches the beginning of the file without finding the regular expression, it wraps around to the end of the file. dbx prints the first source line containing a match of the search expression.If you do not supply a regular expression, dbx searches backward based on the last regular expression you searched for.activeID="dbx_chA28" [pid] Select a process, ID="dbx_chA29"pid, from dbx process pool as the active process. If you do not provide a process ID, dbx prints the currently active process ID.ID="dbx_chA30"addobjID="dbx_chA31"   name1   name2 ...Add the symbol tables for the named dynamic shared objects into dbx. This command is not normally needed, since dbx automatically notices objects added and deleted.addpgrpID="dbx_chA32"   pid [ ... ]Add the process IDs specified to the group list. Only processes in the process pool can be added to the group list.ID="dbx_chA33"addprocID="dbx_chA34"   pid [ ... ]Add the specified process(es) to the pool of ID="dbx_chA35"dbx controlled processes.aliasID="dbx_chA36" List all existing aliases.ID="dbx_chA37"aliasID="dbx_chA38"   name List the alias definition for ID="dbx_chA39"name.aliasID="dbx_chA40"   name   command Define ID="dbx_chA41"name as an alias for command.aliasID="dbx_chA42"   name   "string" Define ID="dbx_chA43"name as an alias for string. With this form of the alias command, you can provide command arguments in the alias definition.aliasID="dbx_chA44"   name(arg1 [, ... argN])   "string" Define ID="dbx_chA45"name as an alias for string. arg1 through argN are arguments to the alias, appearing in the string definition. When you use the alias, you must provide values for the arguments, which dbx then substitutes in string.assignID="dbx_chA46"   register   =   expression Assign the value of ID="dbx_chA47"expression to register. You must precede the name of the register with a dollar sign ($).assignID="dbx_chA48"   variable   =   expression Assign the value of ID="dbx_chA49"expression to the program variable, variable.catchID="dbx_chA50" Print a list of all signals caught.ID="dbx_chA51"catchID="dbx_chA52" { signal | all } Instruct ID="dbx_chA53"dbx to stop your program whenever it receives the specified signal. If you use the keyword "all" rather than giving a specific signal, dbx catches all signals.ccallID="dbx_chA54"   func(   arg1, arg2, ... , argn   ) Call a function with the given arguments.ID="dbx_chA55"clearcallsID="dbx_chA56" Clear all stopped interactive calls.ID="dbx_chA57"contID="dbx_chA58" Continue execution with the current line.ID="dbx_chA59"contID="dbx_chA60" { at | to } line Set a temporary breakpoint at the specified source line, then resume execution with the current line. When your program reaches the breakpoint at ID="dbx_chA61"line, dbx stops your program and deletes the temporary breakpoint. The keywords at and to are equivalent.contID="dbx_chA62"   in   procedure Set a temporary breakpoint to stop execution upon entering the specified procedure, then resume execution with the current line. When your program reaches the breakpoint in ID="dbx_chA63"procedure, dbx stops your program and deletes the temporary breakpoint.contID="dbx_chA64" [ signal ] Continue execution with the current line and send the specified signal to your program. If you do not provide a signal, but your program stopped because dbx caught a signal intended for your program, then dbx sends that signal to your program when you continue execution.contID="dbx_chA65" [ signal ] { at | to } line Set a temporary breakpoint at the specified source line, then resume execution with the current line and send the specified signal to your program. If you do not provide a signal, but your program stopped because dbx caught a signal intended for your program, then dbx sends that signal to your program when you continue execution.contID="dbx_chA66" [ signal ] in   procedure Set a temporary breakpoint to stop execution upon entering the specified procedure, then resume execution with the current line and send the specified signal to your program. If you do not provide a signal, but your program stopped because dbx caught a signal intended for your program, then dbx sends that signal to your program when you continue execution.contiID="dbx_chA67" [ signal ] Continue execution with the current instruction. If you specify a signal, then dbx sends the signal to your program. If you do not provide a signal, but your program stopped because dbx caught a signal intended for your program, then dbx sends that signal to your program when you continue execution.contiID="dbx_chA68" [ signal ] { at | to } address Set a temporary breakpoint at the specified address, then resume execution with the current instruction. When your program reaches the breakpoint at address, dbx stops your program and deletes the temporary breakpoint.If you specify a signal, then dbx sends the signal to your program. If you do not provide a signal, but your program stopped because dbx caught a signal intended for your program, then dbx sends that signal to your program when you continue execution.contiID="dbx_chA69" [ signal ] in   procedure Set a temporary breakpoint to stop execution upon entering the specified procedure, then resume execution with the current instruction. When your program reaches the breakpoint in procedure, dbx stops your program and deletes the temporary breakpoint.If you specify a signal, then dbx sends the signal to your program. If you do not provide a signal, but your program stopped because dbx caught a signal intended for your program, then dbx sends that signal to your program when you continue execution.corefileID="dbx_chA70" [ file ]
If you provide a file name, dbx uses the program data stored in the core dump file.If you do not provide a file name, dbx displays the name of the current core file.deleteID="dbx_chA71" { item [, item ... ] | all } Delete the item or items specified. If you use the keyword "all" instead of listing individual items, dbx deletes all breakpoints, traces, and conditional commands.ID="dbx_chA72"ID="dbx_chA73"ID="dbx_chA74"delpgrpID="dbx_chA75"   pid [ ... ]Deletes the process IDs specified from the group list.ID="dbx_chA76"delprocID="dbx_chA77"   pid [ ... ]Delete the specified process(es) from the pool of ID="dbx_chA78"dbx controlled processes.dirID="dbx_chA79" [ dir ... ] If you provide one or more directories, ID="dbx_chA80"dbx adds those directories to the end of the source directory list.If you do not provide any directories, dbx displays the current source directory list.disableID="dbx_chA81"   item [, item ... ] Disable the item or items listed. The specified breakpoint(s), trace(s), or conditional command(s) no longer affect program execution. This command has no effect if the item you specify is already disabled.ID="dbx_chA82"ID="dbx_chA83"ID="dbx_chA84"downID="dbx_chA85" [ num ] Move down the specified number of activation levels in the stack. The default is one level.ID="dbx_chA86"dumpID="dbx_chA87" Print information about the variables in the current procedure. dumpID="dbx_chA88"   procedure Print information about the variables in the specified procedure. The procedure must be active.ID="dbx_chA89"dump.ID="dbx_chA90" Print information about the variables in all procedures currently active.ID="dbx_chA91"editID="dbx_chA92" [ file | procedure ] Edit a file. If you have set the ID="dbx_chA93"dbx variable ID="dbx_chA94"$editor to the name of an editor, the edit command invokes that editor on the source file. If you have not set the dbx variable $editor, dbx checks whether you have set the environment variable ID="dbx_chA95"EDITOR and, if so, invokes that editor. If you have not set either the dbx variable or the environment variable, dbx invokes the vi editor. When you exit the editor, you return to the dbx prompt.If you supply a file name, edit invokes the editor on the given file. If you supply the name of a procedure, edit invokes the editor on the file that contains the source for that procedure. If you do not supply either a file name or a procedure name, edit invokes the editor on the current source file.enableID="dbx_chA96"   item [, item ... ] Enable the item or items specified. This command activates the specified breakpoint(s), trace(s), or conditional command(s), reversing the effects of a ID="dbx_chA97"ID="dbx_chA98"ID="dbx_chA99"ID="dbx_chA100"disable command, so that they affect program execution.fileID="dbx_chA101" [ file ] Change the current source file to ID="dbx_chA102"ID="dbx_chA103"file. The new file becomes the current source file, on which you can search, list, and perform other operations.funcID="dbx_chA104" Display the name of the procedure corresponding to the current activation level.funcID="dbx_chA105" { activation_level | procedure } Change the current activation level. If you specify an activation level by number, ID="dbx_chA106"dbx changes to that activation level. If you specify a procedure, dbx changes to the activation level of that procedure. If you specify a procedure name and that procedure has called itself recursively, dbx changes to the most recently called instance of that procedure.givenfileID="dbx_chA107" [ file ] 
If you provide a file name, dbx kills the currently running processes and loads the executable code and symbol table found in file.If you do not provide a file name, dbx displays the name of the program that it is currently debugging.gotoID="dbx_chA108"   line Begin execution at the specified line. You may not use the goto command to resume execution with a line outside of the current procedure.hedID="dbx_chA109" Edit only the last line of the history list (the last command executed).ID="dbx_chA110"hedID="dbx_chA111"   num1,num2 Edit the lines in the history list from ID="dbx_chA112"num1 to num2.hed allID="dbx_chA113" Edit the entire history list.ID="dbx_chA114"helpID="dbx_chA115" Show the list of available help sections.ID="dbx_chA116"help allDisplay the entire dbx help file. dbx displays the file using the command name given by the dbx   ID="dbx_chA117"$pager variable. The dbx help file is large and can be difficult to use if you use a simple paging program like more(1). A useful technique is to set the $pager variable to a text editor like vi(1).help helpExplain how to display the help file in your favorite editor.help sectionShow this help section. dbx displays the file using the command name given by the dbx   ID="dbx_chA118"$pager variable. (By default, it uses more.) A useful technique is to set the $pager variable to a text editor like vi(1).historyID="dbx_chA119" Print the commands in the history list.ignoreID="dbx_chA120" Print a list of all signals ignored.ID="dbx_chA121"ignoreID="dbx_chA122" { signal | all } Instruct ID="dbx_chA123"dbx to ignore the specified signal. All ignored signals are passed to your program normally. If you use the keyword "all" rather than giving a specific signal, dbx ignores all signals.ID="dbx_chA124"kill Kill the active process. ID="dbx_chA125"ID="dbx_chA126"kill   pid ... Kill the active process(es) whose PIDs are specified.ID="dbx_chA127"ID="dbx_chA128"list List ID="dbx_chA129"$listwindow lines beginning at the current line.ID="dbx_chA130"list   exp List ID="dbx_chA131"$listwindow lines starting with the line number given by the expression exp. The expression may be any valid expression that evaluates to an integer value.listID="dbx_chA132"   exp1:exp2 List exp2 lines, beginning at line exp1.listID="dbx_chA133"   exp1,exp2 List all source between line exp1 and line exp2 inclusive.listobjID="dbx_chA134"List dynamic shared objects being used. The base application is first in the list.nextID="dbx_chA135" [ n ] Execute the specified number of lines of source code, stepping over procedures. If you do not provide an argument, ID="dbx_chA136"next executes one line. If next encounters any breakpoints, even in procedures that it steps over, it immediately stops execution.nextiID="dbx_chA137" [ n ] Execute the specified number of machine instructions, stepping over procedures. If you do not provide an argument, nexti executes one line. If nexti encounters any breakpoints, even in procedures which it steps over, it immediately stops execution.playback inputID="dbx_chA138" [ file ] Execute the commands from ID="dbx_chA139"file. The default file is the current temporary file created for the record input command. If the dbx variable ID="dbx_chA140"$pimode is nonzero, the commands are printed out as they are played back.playback outputID="dbx_chA141" [ file ] Print the commands from ID="dbx_chA142"file. The default file is the current temporary file created for the record output command.printID="dbx_chA143" [ exp1 [,   exp2, ... ] ] Print the value(s) of the specified expression(s).ID="dbx_chA144"printdID="dbx_chA145"  [ exp1 [,   exp2, ... ] ]Print the value(s) of the specified expression(s) in decimal.printfID="dbx_chA146"   string [,   exp1 [,   exp2, ... ] ] Print the value(s) of the specified expression(s) in the format specified by the string, ID="dbx_chA147"string. The printf command supports all formats of the IRIX printf command except "%s". For a list of formats, see the printf(3S) man page in the IRIX Programming Man Pages.printoID="dbx_chA148"  [ exp1 [,   exp2, ... ] ]Print the value(s) of the specified expression(s) in octal.printregsID="dbx_chA149" Print all register values.ID="dbx_chA150"printxID="dbx_chA151"  [ exp1 [,   exp2, ... ] ]Print the value(s) of the specified expression(s) in hexadecimal. quitID="dbx_chA152" Quit ID="dbx_chA153"dbx.recordID="dbx_chA154" Display the current input and output recording sessions.ID="dbx_chA155"record inputID="dbx_chA156" [ file ] Record everything you type to ID="dbx_chA157"dbx in file. The default file is a temporary dbx file in the /tmp directory. The name of the temporary file is stored in the dbx variable ID="dbx_chA158"$defaultin.record outputID="dbx_chA159" [ file ]  Record all ID="dbx_chA160"dbx output in file. The default file is a temporary dbx file in the /tmp directory. The name of the temporary file is stored in the dbx variable ID="dbx_chA161"$defaultout. If the dbx variable ID="dbx_chA162"$rimode is nonzero, dbx also records the commands you enter.rerunID="dbx_chA163" [ arg1   arg2 ... ] [   <   input_file ] [   >   output_file ] [   >&   error_file ] The ID="dbx_chA164"rerun command starts your program and passes to it any arguments that you provide. You can also redirect the program's standard input, standard output, and/or standard error. If you do not provide any arguments or specify any redirection, ID="dbx_chA165"ID="dbx_chA166"ID="dbx_chA167"rerun uses the same arguments and file redirection that you provided for your last ID="dbx_chA168"run command.resumeID="dbx_chA169" Resume execution of the program, and return immediately to the ID="dbx_chA170"dbx command interpreter.resume pidID="dbx_chA171"   pid Resume execution of the process ID="dbx_chA172"pid, and return immediately to the dbx command interpreter.resumeID="dbx_chA173"   signal Resume execution of the process, sending it the specified signal, and return immediately to the ID="dbx_chA174"ID="dbx_chA175"dbx command interpreter.resumeID="dbx_chA176"   signal   pid pid Resume execution of the process ID="dbx_chA177"pid, sending it the specified signal, and return immediately to the ID="dbx_chA178"dbx command interpreter.returnID="dbx_chA179"Continue execution until control returns to the next procedure on the stack.returnID="dbx_chA180" [ proc ]Continue execution until control returns to the named procedure.runID="dbx_chA181" [ arg1   arg2 ... ] [   <   input_file ] [ >   output_file ] [   >&   error_file ] The ID="dbx_chA182"run command starts your program and passes to it any arguments that you provide. You can also redirect the program's standard input, standard output, and/or standard error as you would if you were executing your program from the shell.ID="dbx_chA183"ID="dbx_chA184"ID="dbx_chA185"setID="dbx_chA186" Display a list of predefined and user defined variables.ID="dbx_chA187"setID="dbx_chA188"   var   =   exp Define (or redefine) the specified ID="dbx_chA189"dbx variable, setting its value of that of the expression you provide.shID="dbx_chA190" Invoke a subshell. To return to ID="dbx_chA191"dbx from the subshell, enter exit at the command line or otherwise terminate the subshell.shID="dbx_chA192"   com Execute the specified shell command. ID="dbx_chA193"dbx interprets the remainder of the line as a command to pass to the spawned shell process, unless you enclose the command in double-quotes or you terminate your shell command with a semicolon (;).showpgrpID="dbx_chA194" Show the group process list and the group history.ID="dbx_chA195"showprocID="dbx_chA196" [ pid | all ] Show processes already in the ID="dbx_chA197"dbx process pool or processes that dbx can control. If you provide no arguments, dbx lists the processes it already controls. If you provide a pid, dbx displays the status of the specified process. If you use argument "all," dbx lists all the processes it controls as well as all those processes it could control but that are not yet added to the process pool.ID="dbx_chA198"source [ file ] Execute dbx commands from file.statusID="dbx_chA199" Display all breakpoints, traces, and conditional commands.ID="dbx_chA200"ID="dbx_chA201"ID="dbx_chA202"stepID="dbx_chA203" [ n ] Execute the specified number of lines of source code, stepping into procedures. If you do not provide an argument, ID="dbx_chA204"step executes one line. If step encounters any breakpoints, it immediately stops execution.stepbID="dbx_chA205"Execute the program until the next jump, jal, or conditional branch machine instruction.stepbID="dbx_chA206" [   n ]Execute the program until the nth jump, jal, or conditional branch machine instruction.stepiID="dbx_chA207"Single step one machine instruction, stepping into procedures (as called by jal and   jalr). If stepi encounters any breakpoints, it immediately stops execution.stepiID="dbx_chA208" [ n ]Execute the specified number of machine instructions, stepping into procedures (as called by jal and jalr). stepjID="dbx_chA209"Execute the program until the next jump or jal machine instruction.stepjID="dbx_chA210" [ n ]Execute the program until the nth jump or jal machine instruction.stop atID="dbx_chA211" Set a breakpoint at the current source line.ID="dbx_chA212"stop atID="dbx_chA213"   line Set a breakpoint at the specified source line.ID="dbx_chA214"stopID="dbx_chA215"   in   procedure Set a breakpoint to stop execution upon entering the specified procedure.ID="dbx_chA216"stopID="dbx_chA217"   variable Inspect the value before executing each source line. Note that execution is very slow if you choose this type of conditional breakpoint.ID="dbx_chA218"stopID="dbx_chA219"   variable   at   line Inspect the value at the given source line. Stop if the value has changed.ID="dbx_chA220"stopID="dbx_chA221"   variable   in   procedure Inspect the value at every source line within a given procedure. Stop if the value has changed.ID="dbx_chA222"stopID="dbx_chA223"   if   expression Evaluate the expression before executing each source line. Stop if the expression is true. Note that execution is very slow if you choose this type of conditional breakpoint.stopID="dbx_chA224"   at   line   if   expression Evaluate the expression at the given source line. Stop if the expression is true.stopID="dbx_chA225"   in   procedure   if   expression Evaluate the expression at every source line within a given procedure. Stop if the expression is true.stopID="dbx_chA226"   variable   if   expression Test both conditions before executing each source line. Stop if both conditions are true. Note that execution is very slow if you choose this type of conditional breakpoint.ID="dbx_chA227"stopID="dbx_chA228"   variable   at   line   if   expression Test both conditions at the given source line. Stop if both conditions are true.ID="dbx_chA229"stopID="dbx_chA230"   variable   in   procedure   if   expression Test both conditions at every source line within a given procedure. Stop if both conditions are true.ID="dbx_chA231"stopi atID="dbx_chA232" Set an unconditional breakpoint at the current machine instruction.ID="dbx_chA233"stopi atID="dbx_chA234"   address Set an unconditional breakpoint at the specified address (for machine-level debugging).ID="dbx_chA235"stopiID="dbx_chA236"   in   procedure Set an unconditional breakpoint to stop execution upon entering the specified procedure (for machine-level debugging).ID="dbx_chA237"stopiID="dbx_chA238"   variable Inspect the value before executing each machine instruction and stop if the value has changed. Note that execution is very slow if you choose this type of conditional breakpoint.ID="dbx_chA239"ID="dbx_chA240"stopiID="dbx_chA241"   variable   at   address Inspect the value at the given address and stop if the value has changed (for machine-level debugging).ID="dbx_chA242"ID="dbx_chA243"stopiID="dbx_chA244"   variable   in   procedure Inspect the value at every machine instruction within a given procedure and stop if the value has changed.ID="dbx_chA245"ID="dbx_chA246"stopiID="dbx_chA247"   if   expression Evaluate the expression before executing each machine instruction and stop if the expression is true. Note that execution is very slow if you choose this type of conditional breakpoint.ID="dbx_chA248"stopiID="dbx_chA249"   at   address   if   expression Evaluate the expression at the given address and stop if the expression is true (for machine-level debugging).ID="dbx_chA250"stopiID="dbx_chA251"   in   procedure   if   expression Evaluate the expression at every machine instruction within a given procedure and stop if the expression is true.ID="dbx_chA252"stopiID="dbx_chA253"   variable   if   expression Test both conditions before executing each machine instruction. Stop if both conditions are true. Note that execution is very slow if you choose this type of conditional breakpoint.ID="dbx_chA254"ID="dbx_chA255"stopiID="dbx_chA256"   variable   at   address   if   expression Test both conditions at the given address (for machine-level debugging). Stop if both conditions are true.ID="dbx_chA257"ID="dbx_chA258"stopiID="dbx_chA259"   variable   in   procedure   if   expression Test both conditions at every machine instruction within a given procedure. Stop if both conditions are true.ID="dbx_chA260"ID="dbx_chA261"suspendID="dbx_chA262" Suspend the active process if it is running. If it is not running, this command does nothing.suspend pid ID="dbx_chA263"pid Suspend the process ID="dbx_chA264"pid if it is in the dbx process pool. If it is not running, this command does nothing.syscallID="dbx_chA265" Print a summary of the catch and ignore status of all system calls. The summary is divided into four sections: 1) caught at call, 2) caught at return, 3) ignored at call, and 4) ignored at return.syscall catchID="dbx_chA266" [ { call | return } ] Print a list of all system calls caught upon entry (ID="dbx_chA267"call) or return (return). If you provide neither the call nor return keyword, dbx lists all system calls that are caught.syscall ignoreID="dbx_chA268" [ { call | return } ]Print a list of all system calls not caught upon entry (ID="dbx_chA269"call) or return (return). If you provide neither the call nor return keyword, dbx lists all system calls that are ignored.syscall catchID="dbx_chA270" { call | return } { system_call | all }Set a breakpoint to stop execution upon entering (ID="dbx_chA271"call) or returning from (return) the specified system call. Note that you can set dbx to catch both the call and the return of a system call.If you use the keyword all rather than giving a specific system call, dbx catches all system calls.syscall ignoreID="dbx_chA272" { call | return } { system_call | all } Clear the breakpoint to stop execution upon entering (ID="dbx_chA273"call) or returning from (return) the specified system call.If you use the keyword all rather than giving a specific system call, dbx clears the breakpoints to stop execution upon entering (call) or returning from (return) all system calls.traceID="dbx_chA274"   variable Whenever the specified variable changes, ID="dbx_chA275"dbx prints the old and new values of that variable. Note that execution is very slow if you choose this type of trace.traceID="dbx_chA276"   proceduredbx prints the values of the parameters passed to the specified procedure whenever your program calls it. Upon return, ID="dbx_chA277"dbx prints the return value.traceID="dbx_chA278"   variable   at   linedbx prints the value of the variable whenever your program reaches the specified line.ID="dbx_chA279"traceID="dbx_chA280"   variable   in   procedure Whenever the variable changes within the procedure that you specify, ID="dbx_chA281"dbx prints the old and new values of that variable.traceID="dbx_chA282"   variable   at   line   if   expression dbx prints the value of the variable whenever your program reaches the specified line and the given expression is true.ID="dbx_chA283"traceID="dbx_chA284"   variable   in   procedure   if   expression Whenever the variable changes within the procedure that you specify, ID="dbx_chA285"dbx prints the old and new values of that variable if the given expression is true.traceiID="dbx_chA286"   variable Whenever the specified variable changes, ID="dbx_chA287"dbx prints the old and new values of that variable. Note that execution is very slow if you choose this type of trace. (For machine-level debugging.)traceiID="dbx_chA288"   procedure This command is equivalent to entering ID="dbx_chA289"trace   procedure. (For machine-level debugging.)traceiID="dbx_chA290"   variable   at   address dbx prints the value of the variable whenever your program reaches the specified address.  (For machine-level debugging.)ID="dbx_chA291"traceiID="dbx_chA292"   variable   in   procedure Whenever the variable changes within the procedure that you specify, ID="dbx_chA293"dbx prints the old and new values of that variable.  (For machine-level debugging.)traceiID="dbx_chA294"   variable   at   address   if   expression dbx prints the value of the variable whenever your program reaches the specified address and the given expression is true.  (For machine-level debugging.)ID="dbx_chA295"traceiID="dbx_chA296"   variable   in   procedure   if   expression Whenever the variable changes within the procedure that you specify, ID="dbx_chA297"dbx prints the old and new values of that variable if the given expression is true.  (For machine-level debugging.)unaliasID="dbx_chA298"   alias Remove the specified alias.ID="dbx_chA299"unrecordID="dbx_chA300"   session1 [,   session2 ... ] Turn off the specified recording session(s) and close the file(s) involved.ID="dbx_chA301"unrecord allID="dbx_chA302" Turn off all recording sessions and close all files involved.ID="dbx_chA303"unsetID="dbx_chA304"   var Remove the specified ID="dbx_chA305"dbx variable.upID="dbx_chA306" [ num ] Move up the specified number of activation levels in the stack. The default is one level.ID="dbx_chA307"useID="dbx_chA308" [ dir ... ]If you provide one or more directories, ID="dbx_chA309"dbx replaces the source directory list with the directories that you provide.If you do not provide any directories, dbx displays the current source directory list.waitID="dbx_chA310" Wait for the active process to stop for an event.ID="dbx_chA311"wait pid ID="dbx_chA312"pid Wait for the process ID="dbx_chA313"pid to stop for an event.waitallID="dbx_chA314" Wait for any process currently running to breakpoint or stop for any reason.ID="dbx_chA315"whatisID="dbx_chA316"   variable Print the type declaration for the specified variable or procedure.ID="dbx_chA317"whenID="dbx_chA318"   variable   {   command-list   } Inspect the value before executing each source line. If it has changed, execute the command list. Note that execution is very slow if you choose this type of conditional command execution.ID="dbx_chA319"whenID="dbx_chA320"   variable   at   line   {   command-list   } Inspect the value at the given source line. If it has changed, execute the command list.ID="dbx_chA321"whenID="dbx_chA322"   variable   in   procedure   {   command-list   } Inspect the value at every source line within a given procedure. If it has changed, execute the command list.ID="dbx_chA323"whenID="dbx_chA324"   if   expression   {   command-list   } Evaluate the expression before executing each source line. If it is true, execute the command list. Note that execution is very slow if you choose this type of conditional command execution.ID="dbx_chA325"whenID="dbx_chA326"   at   line   if   expression   {   command-list   } Evaluate the expression at the given source line. If it is true, execute the command list.ID="dbx_chA327"whenID="dbx_chA328"   in   procedure   if   expression   {   command-list   } Evaluate the expression at every source line within a given procedure. If it is true, execute the command list.ID="dbx_chA329"whenID="dbx_chA330"   variable   if   expression   {   command-list   } Test both conditions before executing each source line. If they are true, execute the command list. Note that execution is very slow if you choose this type of conditional command execution.ID="dbx_chA331"ID="dbx_chA332"whenID="dbx_chA333"   variable   at   line   if   expression   {   command-list   } Test both conditions at the given source line. If they are true, execute the command list.ID="dbx_chA334"ID="dbx_chA335"whenID="dbx_chA336"   variable   in   procedure   if   expression   {   command-list   } Test both conditions at every source line within a given procedure. If they are true, execute the command list.ID="dbx_chA337"ID="dbx_chA338"wheni ifID="dbx_chA339"   expression   {   command-list   }Evaluate the expression before executing each machine instruction. If the expression is true, execute the command list.wheni atID="dbx_chA340"   address [ if   expression ] {   command-list   }Evalute the expression at the given address. If the expression is true, execute the command list.  (For machine-level debugging.)wheni inID="dbx_chA341"   procedure [ if   expression ] {   command-list   }Evaluate the expression in the given procedure. If the expression is true, execute the command list.  (For machine-level debugging.)wheniID="dbx_chA342"   variable [ at   address ] [ if   expression ] {   command-list   }Test both conditions at the given address. If the conditions are true, execute the command list.  (For machine-level debugging.)wheniID="dbx_chA343"   variable [ in   procedure ] [ if   expression ] {   command-list   }Test both conditions at every machine instruction within a given procedure. If they are true, execute the command list.whereID="dbx_chA344" Print a stack trace.ID="dbx_chA345"whereisID="dbx_chA346"   variable Print the fully qualified names of all versions of the specified variable.ID="dbx_chA347"whichID="dbx_chA348"   variable Print the fully qualified name of the active version of the specified variable.ID="dbx_chA349"whichobjID="dbx_chA350"   variableList the dynamic shared objects that contain the named variable.LBL="B"ID="14532"Predefined AliasesIDREF="75693" TYPE="TABLE"Table B-1 lists all predefined ID="dbx_chB1"dbx aliases. You can override any predefined alias by redefining it with the   ID="dbx_chB2"alias command or by removing it with the ID="dbx_chB3"unalias command.COLUMNS="3"LEFT="0" WIDTH="54"AliasLEFT="60" WIDTH="99"DefinitionLEFT="165" WIDTH="356"DescriptionLEFT="0" WIDTH="54"aID="dbx_chB4"LEFT="60" WIDTH="99"assignLEFT="165" WIDTH="356"Assign the specified expression to the 
specified program variable or register.LEFT="0" WIDTH="54"bID="dbx_chB5"LEFT="60" WIDTH="99"stop atLEFT="165" WIDTH="356"Set a breakpoint at the specified line.LEFT="0" WIDTH="54"bpID="dbx_chB6"LEFT="60" WIDTH="99"stop inLEFT="165" WIDTH="356"Set a breakpoint in the specified procedure.LEFT="0" WIDTH="54"cID="dbx_chB7"LEFT="60" WIDTH="99"contLEFT="165" WIDTH="356"Continue program execution after a 
breakpoint.LEFT="0" WIDTH="54"dID="dbx_chB8"LEFT="60" WIDTH="99"deleteLEFT="165" WIDTH="356"Delete the specified item from the status list.LEFT="0" WIDTH="54"dirID="dbx_chB9"LEFT="60" WIDTH="99"directoryLEFT="165" WIDTH="356"Display the current source directory list. If you 
specify one or more directories, those 
directories are added to the end of the source 
directory list.LEFT="0" WIDTH="54"eID="dbx_chB10"LEFT="60" WIDTH="99"fileLEFT="165" WIDTH="356"Display the name of the currently selected 
source file. If you specify a file, this command 
makes the specified file the currently selected 
source file.LEFT="0" WIDTH="54"fID="dbx_chB11"LEFT="60" WIDTH="99"funcLEFT="165" WIDTH="356"Move to the specified procedure (activation 
level) on the stack. If you specify no procedure 
or expression, dbx prints the current activation 
level.LEFT="0" WIDTH="54"gID="dbx_chB12"LEFT="60" WIDTH="99"gotoLEFT="165" WIDTH="356"Go to the specified source line.LEFT="0" WIDTH="54"hID="dbx_chB13"LEFT="60" WIDTH="99"historyLEFT="165" WIDTH="356"List all the items currently in the history list.LEFT="0" WIDTH="54"jID="dbx_chB14"LEFT="60" WIDTH="99"statusLEFT="165" WIDTH="356"List all the currently set stop,   trace, and when 
commands.LEFT="0" WIDTH="54"lID="dbx_chB15"LEFT="60" WIDTH="99"listLEFT="165" WIDTH="356"List the next $listwindow lines of source code 
beginning at the current line.LEFT="0" WIDTH="54"liID="dbx_chB16"LEFT="60" WIDTH="99"$curpc/10i; \
set $curpc=$curpc+40LEFT="165" WIDTH="356"List the next 40 bytes of machine instructions 
(approximately 10 instructions).LEFT="0" WIDTH="54"nID="dbx_chB17"LEFT="60" WIDTH="99"nextLEFT="165" WIDTH="356"Execute the specified number of lines of source 
code, stepping over procedures. If you do not 
provide an argument, dbx executes only one 
line.LEFT="0" WIDTH="54"niID="dbx_chB18"LEFT="60" WIDTH="99"nextiLEFT="165" WIDTH="356"Execute the specified number of lines of 
machine code, stepping over procedures. If 
you do not provide an argument, dbx executes 
only one instruction.LEFT="0" WIDTH="54"pID="dbx_chB19"LEFT="60" WIDTH="99"printLEFT="165" WIDTH="356"Print the value of the specified variable or 
expression.LEFT="0" WIDTH="54"pdID="dbx_chB20"LEFT="60" WIDTH="99"printdLEFT="165" WIDTH="356"Print the value of the specified variable in 
decimal.LEFT="0" WIDTH="54"piID="dbx_chB21"LEFT="60" WIDTH="99"playback inputLEFT="165" WIDTH="356"Replay dbx commands saved in the specified 
file. If you do not specify a file, dbx uses the 
temporary file specified by $defaultin.LEFT="0" WIDTH="54"poID="dbx_chB22"LEFT="60" WIDTH="99"printoLEFT="165" WIDTH="356"Print the value of the specified variable or 
expression in octal.LEFT="0" WIDTH="54"prID="dbx_chB23"LEFT="60" WIDTH="99"printregsLEFT="165" WIDTH="356"Print values contained in all registers.LEFT="0" WIDTH="54"pxID="dbx_chB24"LEFT="60" WIDTH="99"printxLEFT="165" WIDTH="356"Print the value of the specified variable or 
expression in hexadecimal.LEFT="0" WIDTH="54"qID="dbx_chB25"LEFT="60" WIDTH="99"quitLEFT="165" WIDTH="356"Quit dbx.LEFT="0" WIDTH="54"rID="dbx_chB26"LEFT="60" WIDTH="99"rerunLEFT="165" WIDTH="356"Run the program again using the arguments 
specified for the last run command executed.LEFT="0" WIDTH="54"riID="dbx_chB27"LEFT="60" WIDTH="99"record inputLEFT="165" WIDTH="356"Record to the specified file all the input you 
give to dbx. If you do not specify a file, dbx 
creates a temporary file. The name of the file is 
specified by $defaultin.LEFT="0" WIDTH="54"roID="dbx_chB28"LEFT="60" WIDTH="99"record outputLEFT="165" WIDTH="356"Record all dbx output to the specified file. If no 
file is specified, output is recorded to a 
temporary file. The name of the file is specified 
by $defaultout.LEFT="0" WIDTH="54"sID="dbx_chB29"LEFT="60" WIDTH="99"stepLEFT="165" WIDTH="356"Execute the specified number of lines of source 
code, stepping into procedures. If you do not 
provide an argument, dbx executes only one 
line.LEFT="0" WIDTH="54"SID="dbx_chB30"LEFT="60" WIDTH="99"nextLEFT="165" WIDTH="356"Execute the specified number of lines of source 
code, stepping over procedures. If you do not 
provide an argument, dbx executes only one 
line.LEFT="0" WIDTH="54"siID="dbx_chB31"LEFT="60" WIDTH="99"stepiLEFT="165" WIDTH="356"Execute the specified number of lines of 
machine code, stepping into procedures. If 
you do not provide an argument, dbx executes 
only one instruction.LEFT="0" WIDTH="54"SiID="dbx_chB32"LEFT="60" WIDTH="99"nextiLEFT="165" WIDTH="356"Execute the specified number of lines of 
machine code, stepping over procedures. If 
you do not provide an argument, dbx executes 
only one instruction.LEFT="0" WIDTH="54"sourceID="dbx_chB33"LEFT="60" WIDTH="99"playback inputLEFT="165" WIDTH="356"Replay dbx commands saved in the specified 
file. If no file is specified, dbx uses the 
temporary file specified by $defaultin.LEFT="0" WIDTH="54"tID="dbx_chB34"LEFT="60" WIDTH="99"whereLEFT="165" WIDTH="356"Do a stack trace to show the current activation 
levels.LEFT="0" WIDTH="54"uID="dbx_chB35"LEFT="60" WIDTH="99"list $curline-9:10LEFT="165" WIDTH="356"List a window of source code showing the 
nines lines before the current code line and the 
current code line. This command does not 
change the current code line.LEFT="0" WIDTH="54"wID="dbx_chB36"LEFT="60" WIDTH="99"list $curline-5:10LEFT="165" WIDTH="356"List a window of source code around the 
current line. This command shows the four 
lines before the current code line, the current 
code line, and five lines after the current code 
line. This command does not change the 
current code line.LEFT="0" WIDTH="54"WID="dbx_chB37"LEFT="60" WIDTH="99"list $curline-10:20LEFT="165" WIDTH="356"List a window of source code around the 
current line. This command shows the nine 
lines before the current code line, the current 
code line, and 10 lines after the current code 
line. This command does not change the 
current code line.LEFT="0" WIDTH="54"wiID="dbx_chB38"LEFT="60" WIDTH="99"$curpc-20/10iLEFT="165" WIDTH="356"List a window of assembly code around the 
program counter.LBL="B-1"Table B-1 ID="75693"Predefined AliasesLBL="C"ID="54810"Predefined dbx VariablesID="dbx_chC1"         ID="dbx_chC2"ID="dbx_chC3"ID="dbx_chC4"ID="dbx_chC5"ID="dbx_chC6"ID="dbx_chC7"ID="dbx_chC8"ID="dbx_chC9"ID="dbx_chC10"ID="dbx_chC11"Predefined dbx variables are listed in ID="dbx_chC12"IDREF="59186" TYPE="TABLE"Table C-1
. The predefined variable names begin with "$" so that they do not conflict with variable, command, or alias names.COLUMNS="3"LEFT="0" WIDTH="108"VariableLEFT="115" WIDTH="54"DefaultLEFT="175" WIDTH="356"DescriptionLEFT="0" WIDTH="108"ID="dbx_chC13"$addrfmtLEFT="115" WIDTH="54""0x%x"LEFT="175" WIDTH="356"Specifies the format for addresses. This can 
be set to any format valid for the C language 
printf(3S) function.LEFT="0" WIDTH="108"$assumenormalframeID="dbx_chC14"LEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If the value is 0, dbx disassembles function 
prologs to determine if the stack frame is 
complete.If the value is 1, dbx assumes the stack frame 
is complete, which is a little faster but can 
lead to incomplete and incorrect stack 
traceback output if you actually stopped 
with the stack incomplete (as in debugging 
machine code).dbx changes the value to 1 automatically if a 
stack trace detects a program counter 
address that cannot be found in the program 
text. (Often this happens because core files 
do not have shared library code in them.) If 
ID="dbx_chC15"$visiblestackwalk is 1, dbx notifies you of the 
change with a warning message.LEFT="0" WIDTH="108"ID="dbx_chC16"$casesenseLEFT="115" WIDTH="54"2LEFT="175" WIDTH="356"If 0, symbol names are case sensitive. If 1, 
symbol names are not case sensitive. If 2, the 
case sensitivity of symbol names depends 
on the case sensitivity of the language in 
which the symbol was defined.ID="dbx_chC17"LEFT="0" WIDTH="108"ID="dbx_chC18"$charisunsignedLEFT="115" WIDTH="54"1LEFT="175" WIDTH="356"If 1, a (char) type cast is taken as unsigned; if 
0, a (char) cast is taken as signed.LEFT="0" WIDTH="108"ID="dbx_chC19"$ctypenamesLEFT="115" WIDTH="54"1LEFT="175" WIDTH="356"If 1, the words "unsigned," "short," "long," 
"int," "char," "struct," "union," and "enum" 
are keywords usable only in type casts. If 0, 
"struct," "union," and "enum" are ordinary 
words with no predefined meaning (in C 
modules, the others are still known as C 
types).ID="dbx_chC20"LEFT="0" WIDTH="108"ID="dbx_chC21"$cureventLEFT="115" WIDTH="54"LEFT="175" WIDTH="356"The last event number as seen by the status 
command.LEFT="0" WIDTH="108"ID="dbx_chC22"$curlineLEFT="115" WIDTH="54"LEFT="175" WIDTH="356"The current line in the source code being 
executed.LEFT="0" WIDTH="108"ID="dbx_chC23"$curpcLEFT="115" WIDTH="54"LEFT="175" WIDTH="356"The current program counter.LEFT="0" WIDTH="108"ID="dbx_chC24"$cursrclineLEFT="115" WIDTH="54"LEFT="175" WIDTH="356"The current source listing line plus one.LEFT="0" WIDTH="108"ID="dbx_chC25"$datacacheLEFT="115" WIDTH="54"1LEFT="175" WIDTH="356"If nonzero, dbx caches information from the 
data space so that it has to check the data 
space only once. You can change the value to 
0 with no visible loss in performance. When 
debugging a running operating system, set 
this variable to 0.LEFT="0" WIDTH="108"ID="dbx_chC26"$defaultinLEFT="115" WIDTH="54"LEFT="175" WIDTH="356"The name of the file that dbx uses when the 
ID="dbx_chC27"record input or the playback input command is 
executed with no argument.LEFT="0" WIDTH="108"ID="dbx_chC28"$defaultoutLEFT="115" WIDTH="54"LEFT="175" WIDTH="356"The name of the file that dbx uses when the 
ID="dbx_chC29"record output or the playback output command 
is executed with no argument.LEFT="0" WIDTH="108"ID="dbx_chC30"$dynamic_scopeLEFT="115" WIDTH="54"1LEFT="175" WIDTH="356"If 0, dbx does not walk the stack to look for 
contexts in which a variable might be 
visible. Insert this variable as a workaround 
if commands do not return. This variable 
has a similar use to that of $notypenames. Try 
setting $dynamic_scope to 0 first; if this 
approach doesn't work, then try setting 
$notypenames to 1.LEFT="0" WIDTH="108"ID="dbx_chC31"$editorLEFT="115" WIDTH="54""vi"LEFT="175" WIDTH="356"The name of the editor to invoke (with the 
ID="dbx_chC32"edit command). Default value is set to the 
value of the EDITOR environment variable. 
If EDITOR missing, it defaults to "vi."LEFT="0" WIDTH="108"ID="dbx_chC33"$frameviadisassemblyLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If 0, dbx uses frame information from the 
symbol table whenever possible. If nonzero, 
dbx does not use stack frame information 
about procedures during stack trace 
walking. This variable is primarily used for 
debugging dbx.LEFT="0" WIDTH="108"ID="dbx_chC34"$funcentrybylinesLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"Applies only to Pascal, C, and C++. If 0, dbx 
uses disassembly of the code to estimate the 
location of the first line of each function. If 1, 
dbx uses the line numbers in the line table; 
this does not work well if the first line of 
code is on the same line as the function 
opening brace "{" as it often is in short C++ 
functions. LEFT="0" WIDTH="108"$functionsymbolsID="dbx_chC35"LEFT="115" WIDTH="54"LEFT="175" WIDTH="356"The number of functions in the process for 
which dbx last read the symbol table.LEFT="0" WIDTH="108"$globalcountID="dbx_chC36"LEFT="115" WIDTH="54"LEFT="175" WIDTH="356"The number of global symbols read in from 
the symbol table dbx last read in. LEFT="0" WIDTH="108"ID="dbx_chC37"$groupforktooLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If 0, only processes created with the sproc(2) 
system call are added to the process group 
list automatically. If 1, then processes 
created with either the fork(2) or sproc 
system calls are added to process group list.LEFT="0" WIDTH="108"ID="dbx_chC38"$hexcharsLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If nonzero, output characters in 
hexadecimal, using C format "%x". This 
affects char type variables, including those 
in structures. It does not affection arrays of 
characters, which are printed using the 
"%.*s" format.LEFT="0" WIDTH="108"ID="dbx_chC39"$hexinLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If nonzero, input constants are assumed to 
be in hexadecimal. This overrides $octin.LEFT="0" WIDTH="108"ID="dbx_chC40"$hexintsLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If nonzero, output integers in hexadecimal 
format. This overrides $octints.LEFT="0" WIDTH="108"ID="dbx_chC41"$hexstringsLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If nonzero, output strings and arrays in 
hexadecimal. For character arrays, if 
nonzero, the null byte is not taken as a 
terminator. Instead, the whole array (or 
$maxlen values, whichever is less) is printed. 
If 0, then a null byte in an array is taken as 
the end of the array (the length of the array 
and $maxstrlen can terminate the array print 
before a null byte is found). LEFT="0" WIDTH="108"$historyeventID="dbx_chC42"LEFT="115" WIDTH="54"LEFT="175" WIDTH="356"The current history line number.LEFT="0" WIDTH="108"ID="dbx_chC43"$lastchildLEFT="115" WIDTH="54"LEFT="175" WIDTH="356"The process ID of the last child process 
created by a fork or sproc system call.LEFT="0" WIDTH="108"ID="dbx_chC44"$linesLEFT="115" WIDTH="54"100LEFT="175" WIDTH="356"The number of lines in the history list.LEFT="0" WIDTH="108"ID="dbx_chC45"$listwindowLEFT="115" WIDTH="54"10LEFT="175" WIDTH="356"Specifies how many lines the list command 
lists.LEFT="0" WIDTH="108"ID="dbx_chC46"$mainLEFT="115" WIDTH="54""main"LEFT="175" WIDTH="356"At startup, dbx sets source file and line to the 
function named in this string variable. It can 
be any procedure.LEFT="0" WIDTH="108"ID="dbx_chC47"$maxstrlenLEFT="115" WIDTH="54"128LEFT="175" WIDTH="356"Maximum length printed for 
zero-terminated char strings and arrays. 
Char arrays are printed for array-length, 
$maxstrlen bytes, or up to a null byte, 
whichever comes first (see $hexstrings).LEFT="0" WIDTH="108"ID="dbx_chC48"$mp_programLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If 0, dbx treats calls to sproc in the same way 
as it treats calls to fork. If 1, child processes 
created by calls to sproc are allowed to run; 
they block on multiprocessor 
synchronization code emitted by mp 
Fortran code. When you set $mp_program to 
1, mp Fortran code is easier to debug.LEFT="0" WIDTH="108"ID="dbx_chC49"$naptimeLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"ID="dbx_chC50"   trace, step n, and next n delay $naptime 
100ths of a second after every instruction. 
See sginap(2).LEFT="0" WIDTH="108"ID="dbx_chC51"$neweventLEFT="115" WIDTH="54"LEFT="175" WIDTH="356"After every command creating an event, this 
variable is set to the event's number. The 
$newevent variable is useful in writing 
scripts that do not use hard-coded event 
numbers.LEFT="0" WIDTH="108"ID="dbx_chC52"$nextbreakLEFT="115" WIDTH="54"2LEFT="175" WIDTH="356"If 0, ID="dbx_chC53"$stepintoall determines how "visible" 
procedures are to next. If $stepintoall = 0, 
then next single-steps only through those 
procedures compiled with the -g, -g2, or -g3 
flags for which it can find the source file; it 
executes all others at full speed. If 
$stepintoall = 1, then next single-steps those 
procedures listed above, plus all other 
procedures for which dbx can find source 
code; all others it executes at full speed. If 
$stepintoall = 2, then next single-steps 
through all procedures.If 1, next single-steps through procedure 
calls, including library functions and gets 
back to exactly the next statement. (In the 
current implementation, stop if, trace, or 
when commands testing variables may fail 
with the message not active, stopping 
the execution.) The single-step rate is not 
determined by ID="dbx_chC54"$naptime. This is slow but 
guarantees return to the right place even if 
part of your code is compiled without 
symbols and is recursive.If 2, next executes procedure calls at full 
speed. If next is executed from within a 
function that recurses, it may stop at a 
deeper level of recursion rather than at the 
next source. To avoid this, set $nextbreak to 1.LEFT="0" WIDTH="108"ID="dbx_chC55"$notypenamesLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If a stack trace cannot be printed, and dbx 
cannot disassemble code near the problem, 
set $notypenames equal to 1 and retry the 
examine command. This variable has a 
similar effect to that of $dynamic_scope. Try 
setting $dynamic_scope to 0 first; if this 
approach doesn't work, then try setting 
$notypenames to 1. This variable is usually 
used as a last resort.LEFT="0" WIDTH="108"ID="dbx_chC56"$octinLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If nonzero, input constants are assumed to 
be in   octal (ID="dbx_chC57"ID="dbx_chC58"$hexin overrides $octin). LEFT="0" WIDTH="108"ID="dbx_chC59"$octintsLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If nonzero, output integers in octal format 
(ID="dbx_chC60"ID="dbx_chC61"$hexints takes precedence).LEFT="0" WIDTH="108"ID="dbx_chC62"$onexecruntomainLEFT="115" WIDTH="54"1LEFT="175" WIDTH="356"If nonzero, programs using DSOs do not 
stop at the exit of the exec(2) system call; they 
run to main (MAIN_ in Fortran). If 0, 
applications calling exec(2) stop at the exit of 
exec(2).LEFT="0" WIDTH="108"ID="dbx_chC63"$pageLEFT="115" WIDTH="54"1LEFT="175" WIDTH="356"Specifies whether to page when dbx output 
would scroll information off the current 
screen. A nonzero value turns on paging; a 0 
turns it off.LEFT="0" WIDTH="108"ID="dbx_chC64"$pagerLEFT="115" WIDTH="54""more"LEFT="175" WIDTH="356"The name of the program used to display 
help information.ID="dbx_chC65"LEFT="0" WIDTH="108"ID="dbx_chC66"$pagewindowLEFT="115" WIDTH="54"23LEFT="175" WIDTH="356"Specifies how many lines print when 
information runs longer than one screen. 
This can be changed to match the number of 
lines on any terminal. If set to 0, 1 is used.LEFT="0" WIDTH="108"ID="dbx_chC67"$pagewidthLEFT="115" WIDTH="54"80LEFT="175" WIDTH="356"The width of the window in characters 
(assumes a fixed-width font). Used by dbx to 
calculate how many screen lines are output. 
dbx never inserts newlines; the window 
software wraps the lines.LEFT="0" WIDTH="108"ID="dbx_chC68"$pidLEFT="115" WIDTH="54"LEFT="175" WIDTH="356"The current process for kernel debugging 
(-k).LEFT="0" WIDTH="108"ID="dbx_chC69"$pid0LEFT="115" WIDTH="54"LEFT="175" WIDTH="356"Set by dbx to the process ID of the given 
process (also called the object file)LEFT="0" WIDTH="108"$piaddtohistID="dbx_chC70"LEFT="115" WIDTH="54"1LEFT="175" WIDTH="356"If 1, commands read from files using the 
ID="dbx_chC71"playback input command are added to the 
command history. If 0, the commands are 
not added to the history.LEFT="0" WIDTH="108"ID="dbx_chC72"$pimodeLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If 1, dbx prints the commands read from files 
using theID="dbx_chC73"   playback input command. If 0, dbx 
does not print the commands. In either case, 
dbx prints the output resulting from such 
commands.LEFT="0" WIDTH="108"ID="dbx_chC74"$printdataLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"Used when disassembling. If 1, print 
register contents alongside disassembled 
instructions. If 0, just print disassembled 
instructions.LEFT="0" WIDTH="108"ID="dbx_chC75"$print_exception_frameLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"Available to dbx only if you invoke it with 
the -k flag (that is, it is not available unless 
you are doing kernel debugging). If 
nonzero, when doing where, up, or down, 
exception frames and struct sigcontext 
blocks are output in hexadecimal when the 
stack frame encounters one of these on the 
stack. If 0, dbx displays no special output.LEFT="0" WIDTH="108"$printobjnameID="dbx_chC76"LEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If nonzero, whenever a variable reference is 
printed, the object name is printed following 
the variable (for example, [ in libc.so.1 ]. The 
application program is considered an object 
in this case. See the on-line help section on 
hint_dso for more information on DSOs.LEFT="0" WIDTH="108"$printwhilestepID="dbx_chC77"LEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If 0, dbx prints only the next line to be 
executed. If nonzero, dbx prints each line 
that is executed while it single steps.LEFT="0" WIDTH="108"ID="dbx_chC78"$printwideLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If 0, arrays are printed one element per line. 
If nonzero, arrays are printed compactly 
(wide).LEFT="0" WIDTH="108"ID="dbx_chC79"LEFT="115" WIDTH="54"LEFT="175" WIDTH="356"This variable applies only if you invoke dbx 
with the -k flag (that is, it is not available 
unless you are doing kernel debugging). 
Whenever ID="dbx_chC80"$pid is set, dbx sets $procaddr to 
the address of the process table entry for 
that process.LEFT="0" WIDTH="108"$proginstsreadID="dbx_chC81"LEFT="115" WIDTH="54"LEFT="175" WIDTH="356"The count of machine instructions which 
have been read so far in disassembling 
function prologs to get a correct stack 
traceback. If ID="dbx_chC82"$assumenormalframe is 1, 
$proginstsread does not change because no 
disassembly of prologs occurs.LEFT="0" WIDTH="108"$prologanalysisID="dbx_chC83"LEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If 1, when a function prolog is disassembled, 
various notes are printed showing certain 
characteristics about the function prolog. 
Mainly of interest if dbx is 
misunderstanding a function prolog. If 0, 
dbx is silent about what it finds in function 
prologs.LEFT="0" WIDTH="108"ID="dbx_chC84"$promptLEFT="115" WIDTH="54""(dbx) "LEFT="175" WIDTH="356"The prompt for ID="dbx_chC85"dbx.LEFT="0" WIDTH="108"ID="dbx_chC86"$promptonforkLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If 0, dbx does not add the child process to the 
process pool. Both the child process and the 
parent process continue to run.If 1, dbx stops the parent process and asks if 
you want to add the child process to the 
process pool. If you answer yes, then dbx 
adds the child process to the pool and stops 
the child process; if you answer no, dbx 
allows the child process to run and does not 
place it in the process pool.If 2, dbx automatically stops both the parent 
and child processes and adds the child 
process to the process pool.LEFT="0" WIDTH="108"ID="dbx_chC87"$regstyleLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If 0, dbx uses the alternate form of the 
register name (for example, "zero" instead 
of "r0" and "t1" instead of "r9"). If nonzero, 
ID="dbx_chC88"dbx uses the machine name ("r0" through 
"r31").LEFT="0" WIDTH="108"ID="dbx_chC89"$repeatmodeLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If nonzero, entering a null line (entering a 
newline on an empty line) repeats the last 
command. If 0, ID="dbx_chC90"dbx performs no action.LEFT="0" WIDTH="108"ID="dbx_chC91"$rimodeLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If 1, dbx records commands you enter in 
addition to output when using the recordoutput command. If 0, dbx does not copy the 
commands.LEFT="0" WIDTH="108"ID="dbx_chC92"$showbreakaddrsLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If nonzero, show the address of each 
breakpoint placed in the code each time it is 
placed. Removal of the breakpoints is not 
shown. If multiple breakpoints are placed at 
one location, only one of the placements is 
shown. Since breakpoints are frequently 
placed and removed by dbx, the volume of 
output can be annoying when tracing.LEFT="0" WIDTH="108"ID="dbx_chC93"$stepintoallLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If 0, ID="dbx_chC94"step steps into only those procedures 
that are compiled with the debugging 
options -gID="dbx_chC95", -g2, or -g3 for which there are 
line numbers in the symbol table. step steps 
over all other procedures.If 1, step steps into the above procedures 
plus all procedures for which dbx can find a 
source file. Note that when you debug a 
source file compiled without symbols or 
compiled with optimization, the line 
numbers may sometimes jump erratically.If 2, step steps into all procedures.  Note that 
when you debug a source file compiled 
without symbols or compiled with 
optimization, the line numbers may 
sometimes jump erratically.Also note that if dbx cannot locate a source 
file, then it cannot display source lines as 
you step through a procedure.LEFT="0" WIDTH="108"ID="dbx_chC96"$tagfileLEFT="115" WIDTH="54""tags"LEFT="175" WIDTH="356"The name of a file of tags, as created by 
ctags(1). Used by the tag command.LEFT="0" WIDTH="108"ID="dbx_chC97"$visiblemangledLEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"Applicable to C++ only. If nonzero, mangled 
names of functions print along with the 
demangled forms.LEFT="0" WIDTH="108"ID="dbx_chC98"LEFT="115" WIDTH="54"0LEFT="175" WIDTH="356"If 0, stack tracebacks (where output) are 
shown normally. If 1, extra information is 
printed about each stack frame as the 
traceback is shown.LBL="C-1"Table C-1 ID="59186"Predefined dbx VariablesID="59741"!! commandIDREF="dbx_chA11"dbx CommandsIDREF="dbx_ch524"Repeating CommandsIDREF="dbx_ch519"Repeating Commands!-integer commandIDREF="dbx_ch523"Repeating CommandsIDREF="dbx_chA18"dbx Commands!integer commandIDREF="dbx_ch526"Repeating CommandsIDREF="dbx_chA16"dbx CommandsIDREF="dbx_ch522"Repeating Commands!string commandIDREF="dbx_ch521"Repeating CommandsIDREF="dbx_ch525"Repeating CommandsIDREF="dbx_chA14"dbx Commands# charactersIDREF="dbx_ch215"Invoking dbxIDREF="dbx_ch66"OperatorsIDREF="dbx_ch589"Executing dbx Scripts#define declarationsIDREF="dbx_ch614"Constants (command separator)IDREF="dbx_chA20"dbx Commands// (division) operatorIDREF="dbx_ch610"OperatorsIDREF="dbx_ch69"OperatorsIDREF="dbx_ch611"Operators)IDREF="dbx_chA20"dbx Commands-C flagIDREF="dbx_ch227"Invoking dbxIDREF="dbx_ch212"Invoking dbx-e flagIDREF="dbx_ch223"Invoking dbx-g flagIDREF="dbx_ch19"Examining Core Dumps to Determine Cause of FailureIDREF="dbx_ch15"Examining Core Dumps to Determine Cause of FailureIDREF="dbx_ch7146"Stepping Using the step CommandIDREF="dbx_ch7147"Stepping Using the step CommandIDREF="dbx_ch22"Compiling a Program for Debugging under dbxIDREF="dbx_ch43"Specifying Source DirectoriesIDREF="dbx_ch679"Printing Stack TracesIDREF="dbx_chC95"Predefined dbx Variables         IDREF="dbx_ch151"Avoiding Common Pitfalls-i flagIDREF="dbx_ch214"Invoking dbxIDREF="dbx_ch46"Specifying Source Directories with ArgumentsIDREF="dbx_ch28"Invoking dbx-k flagIDREF="dbx_ch225"Invoking dbx-p flagIDREF="dbx_ch218"Invoking dbxIDREF="dbx_ch219"Invoking dbx-r flagIDREF="dbx_ch216"Invoking dbx-x flagIDREF="dbx_ch221"Invoking dbx16-bit wordIDREF="dbx_ch825"Examining Memory and Disassembling Code? commandIDREF="dbx_ch818"Examining Memory and Disassembling CodeIDREF="dbx_chA25"dbx CommandsIDREF="dbx_chA4"dbx CommandsIDREF="dbx_chA10"dbx CommandsIDREF="dbx_ch423"Searching Through Source CodeIDREF="dbx_ch824"Examining Memory and Disassembling CodeIDREF="dbx_ch426"Searching Through Source Code\IDREF="dbx_chA20"dbx Commands\\ (command continuation)IDREF="dbx_chA21"dbx CommandsaIDREF="dbx_chB4"Predefined Aliasesactivation levelsIDREF="dbx_ch674"Examining the StackchangingIDREF="dbx_ch687"Moving to a Specified ProcedureIDREF="dbx_chA106"dbx Commandsmoving downIDREF="dbx_ch683"Moving Within the StackIDREF="dbx_chA86"dbx Commandsmoving upIDREF="dbx_ch682"Moving Within the StackIDREF="dbx_chA307"dbx Commandsprinting informationIDREF="dbx_chA89"dbx CommandsIDREF="dbx_chA91"dbx CommandsIDREF="dbx_ch693"Printing Activation Level Informationactive commandIDREF="dbx_ch915"Selecting a ProcessIDREF="dbx_chA28"dbx Commandsactive processwait forIDREF="dbx_chA311"dbx CommandsIDREF="dbx_ch931"Waiting for a Resumed Processadd processes to process poolIDREF="dbx_chA35"dbx Commandsadding processes to the process group listIDREF="dbx_chA33"dbx CommandsIDREF="dbx_ch955"Process Group DebuggingIDREF="dbx_ch957"Process Group Debuggingaddobj commandIDREF="dbx_chA31"dbx Commandsaddpgrp commandIDREF="dbx_ch958"Process Group DebuggingIDREF="dbx_chA32"dbx Commandsaddproc commandIDREF="dbx_chA34"dbx CommandsIDREF="dbx_ch912"Adding a Process to the Process Pooladdress of line numbersIDREF="dbx_ch68"OperatorsIDREF="dbx_ch591"Executing dbx ScriptsIDREF="dbx_ch65"Operators$addrfmtIDREF="dbx_chC13"Predefined dbx Variables         alias commandIDREF="dbx_chB2"Predefined AliasesIDREF="dbx_chA40"dbx CommandsIDREF="dbx_ch548"Creating Command AliasesIDREF="dbx_chA36"dbx CommandsIDREF="dbx_ch540"Listing AliasesIDREF="dbx_chA42"dbx CommandsIDREF="dbx_ch543"Creating Command AliasesIDREF="dbx_ch546"Creating Command AliasesIDREF="dbx_chA38"dbx CommandsIDREF="dbx_chA44"dbx CommandsIDREF="dbx_ch539"Listing AliasesIDREF="dbx_ch544"Creating Command AliasesIDREF="dbx_ch541"Listing AliasesaliasescreatingIDREF="dbx_ch545"Creating Command AliasesIDREF="dbx_chA41"dbx CommandsIDREF="dbx_chA45"dbx CommandsIDREF="dbx_ch547"Creating Command AliasesIDREF="dbx_ch549"Creating Command AliasesIDREF="dbx_chA43"dbx CommandsdeletingIDREF="dbx_chA299"dbx CommandsdisplayingIDREF="dbx_chA39"dbx CommandsIDREF="dbx_chA37"dbx Commandspredefined, see predefined dbx aliasesIDREF="dbx_chB1"Predefined AliasesIDREF="dbx_ch537"dbx Aliasesarray, examiningIDREF="dbx_ch658"Displaying the Value of a Variableassign commandIDREF="dbx_ch661"Changing the Value of a VariableIDREF="dbx_chA46"dbx CommandsIDREF="dbx_ch813"Changing Register ValuesIDREF="dbx_ch662"Changing the Value of a VariableIDREF="dbx_chA48"dbx Commands$assumenormalframeIDREF="dbx_chC14"Predefined dbx Variables         IDREF="dbx_chC82"Predefined dbx Variables         bIDREF="dbx_chB5"Predefined AliasesbpIDREF="dbx_chB6"Predefined AliasesbreakpointsIDREF="dbx_ch112"Debugging Your ProgramsIDREF="dbx_ch132"Studying a New ProgramconditionalIDREF="dbx_ch73"Breakpointscontinuing afterIDREF="dbx_ch122"Debugging Your ProgramsIDREF="dbx_chA63"dbx CommandsIDREF="dbx_ch735"Continuing Execution after a BreakpointIDREF="dbx_chA59"dbx CommandsIDREF="dbx_ch739"Continuing Execution after a BreakpointIDREF="dbx_ch737"Continuing Execution after a BreakpointIDREF="dbx_ch740"Continuing Execution after a BreakpointIDREF="dbx_chA61"dbx CommandsIDREF="dbx_ch867"Continuing Execution after a Machine-level BreakpointIDREF="dbx_ch143"Studying a New ProgramdisablingIDREF="dbx_ch794"Disabling Breakpoints, Traces, and Conditional CommandsIDREF="dbx_chA82"dbx CommandsenablingIDREF="dbx_ch7100"Enabling Breakpoints, Traces, and Conditional CommandsIDREF="dbx_chA97"dbx Commandsmachine-levelIDREF="dbx_chA254"dbx CommandsIDREF="dbx_chA235"dbx CommandsIDREF="dbx_ch856"Syntax of the stopi CommandIDREF="dbx_ch846"Syntax of the stopi CommandIDREF="dbx_chA245"dbx CommandsIDREF="dbx_ch862"Syntax of the stopi CommandIDREF="dbx_chA257"dbx CommandsIDREF="dbx_chA237"dbx CommandsIDREF="dbx_ch850"Syntax of the stopi CommandIDREF="dbx_ch848"Syntax of the stopi CommandIDREF="dbx_ch858"Syntax of the stopi CommandIDREF="dbx_chA248"dbx CommandsIDREF="dbx_chA260"dbx CommandsIDREF="dbx_chA239"dbx CommandsIDREF="dbx_ch864"Syntax of the stopi CommandIDREF="dbx_ch854"Syntax of the stopi CommandIDREF="dbx_chA250"dbx CommandsIDREF="dbx_ch844"Syntax of the stopi CommandIDREF="dbx_chA233"dbx CommandsIDREF="dbx_ch842"Syntax of the stopi CommandIDREF="dbx_chA252"dbx CommandsIDREF="dbx_chA242"dbx CommandsIDREF="dbx_ch860"Syntax of the stopi CommandIDREF="dbx_ch852"Syntax of the stopi Commandprocess groupsIDREF="dbx_ch964"Process Group DebuggingsettingIDREF="dbx_chA212"dbx CommandsIDREF="dbx_chA214"dbx CommandsIDREF="dbx_ch116"Debugging Your ProgramsIDREF="dbx_chA216"dbx CommandsstatusIDREF="dbx_ch788"Listing Breakpoints, Traces, and Conditional CommandsIDREF="dbx_chA200"dbx Commandstest clauseIDREF="dbx_ch729"Conditional Breakpoints Combining Variable and Test ClausesIDREF="dbx_ch727"Conditional Breakpoints Combining Variable and Test ClausesIDREF="dbx_ch733"Conditional Breakpoints Combining Variable and Test ClausesIDREF="dbx_ch721"Stopping If a Test Expression is TrueIDREF="dbx_ch725"Stopping If a Test Expression is TrueIDREF="dbx_ch731"Conditional Breakpoints Combining Variable and Test ClausesIDREF="dbx_ch723"Stopping If a Test Expression is TrueunconditionalIDREF="dbx_ch72"BreakpointsIDREF="dbx_ch113"Debugging Your ProgramsIDREF="dbx_ch114"Debugging Your Programsvariable clauseIDREF="dbx_ch718"Stopping if a Variable or Memory Location has ChangedIDREF="dbx_chA220"dbx CommandsIDREF="dbx_chA258"dbx CommandsIDREF="dbx_chA218"dbx CommandsIDREF="dbx_chA243"dbx CommandsIDREF="dbx_chA231"dbx CommandsIDREF="dbx_chA227"dbx CommandsIDREF="dbx_chA261"dbx CommandsIDREF="dbx_ch716"Stopping if a Variable or Memory Location has ChangedIDREF="dbx_ch714"Stopping if a Variable or Memory Location has ChangedIDREF="dbx_chA246"dbx CommandsIDREF="dbx_chA222"dbx CommandsIDREF="dbx_chA255"dbx CommandsIDREF="dbx_chA240"dbx CommandsIDREF="dbx_chA229"dbx Commandsbreakpoints and interactive function callsIDREF="dbx_ch6109"Interactive Function CallscIDREF="dbx_chB7"Predefined AliasesC keyword conflictsIDREF="dbx_ch664"Conflicts Between Variable Names and KeywordsIDREF="dbx_chC20"Predefined dbx Variables         C preprocessorIDREF="dbx_ch615"ConstantsC++global functionsIDREF="dbx_ch6114"Referring to C++ Functionsinline functionsIDREF="dbx_ch6116"Referring to C++ Functionsmember functionsIDREF="dbx_ch6113"Referring to C++ Functionsnon-C++ functionsIDREF="dbx_ch6115"Referring to C++ Functionsoverloaded functionsIDREF="dbx_ch6117"Referring to C++ Functionsstatic member variablesIDREF="dbx_ch6112"Accessing C++ Member Variablesvariable namesIDREF="dbx_ch228"Invoking dbxcase sensitivity of program variable namesIDREF="dbx_chC17"Predefined dbx Variables         $casesenseIDREF="dbx_ch667"Case Sensitivity in Variable NamesIDREF="dbx_chC16"Predefined dbx Variables         catch commandIDREF="dbx_chA50"dbx CommandsIDREF="dbx_chA52"dbx Commandscatching signalsIDREF="dbx_ch7109"Catching and Ignoring SignalsIDREF="dbx_chA53"dbx Commandscatching system callsIDREF="dbx_ch7124"Stopping at System CallsIDREF="dbx_chA271"dbx Commandsccall commandIDREF="dbx_chA54"dbx CommandsIDREF="dbx_ch698"Interactive Function Callschanging program variable valuesIDREF="dbx_chA49"dbx Commands$charisunsignedIDREF="dbx_chC18"Predefined dbx Variables         clearcalls commandIDREF="dbx_ch6107"Interactive Function CallsIDREF="dbx_chA56"dbx Commandscode and source don't matchIDREF="dbx_ch155"Avoiding Common Pitfallscode missingIDREF="dbx_ch160"Avoiding Common PitfallsIDREF="dbx_ch157"Avoiding Common Pitfalls/ commandIDREF="dbx_ch659"Displaying the Value of a VariableIDREF="dbx_chA7"dbx CommandsIDREF="dbx_chA22"dbx CommandsIDREF="dbx_ch823"Examining Memory and Disassembling CodeIDREF="dbx_ch815"Examining Memory and Disassembling CodeIDREF="dbx_ch821"Examining Memory and Disassembling CodeIDREF="dbx_chA9"dbx CommandsIDREF="dbx_ch424"Searching Through Source CodeIDREF="dbx_ch422"Searching Through Source CodeIDREF="dbx_chA1"dbx Commands commands/IDREF="dbx_ch422"Searching Through Source CodeIDREF="dbx_ch424"Searching Through Source CodeIDREF="dbx_ch821"Examining Memory and Disassembling CodeIDREF="dbx_chA22"dbx CommandsIDREF="dbx_chA1"dbx CommandsIDREF="dbx_chA7"dbx CommandsIDREF="dbx_ch815"Examining Memory and Disassembling CodeIDREF="dbx_ch659"Displaying the Value of a VariableIDREF="dbx_chA9"dbx CommandsIDREF="dbx_ch823"Examining Memory and Disassembling Code!!IDREF="dbx_ch519"Repeating CommandsIDREF="dbx_ch524"Repeating CommandsIDREF="dbx_chA11"dbx Commands!-integerIDREF="dbx_ch523"Repeating CommandsIDREF="dbx_chA18"dbx Commands!integerIDREF="dbx_ch522"Repeating CommandsIDREF="dbx_chA16"dbx CommandsIDREF="dbx_ch526"Repeating Commands!stringIDREF="dbx_chA14"dbx CommandsIDREF="dbx_ch525"Repeating CommandsIDREF="dbx_ch521"Repeating Commands?IDREF="dbx_ch824"Examining Memory and Disassembling CodeIDREF="dbx_chA25"dbx CommandsIDREF="dbx_ch818"Examining Memory and Disassembling CodeIDREF="dbx_ch423"Searching Through Source CodeIDREF="dbx_ch426"Searching Through Source CodeIDREF="dbx_chA4"dbx CommandsIDREF="dbx_chA10"dbx CommandscontIDREF="dbx_ch142"Studying a New ProgramIDREF="dbx_ch121"Debugging Your ProgramsIDREF="dbx_ch130"Studying a New ProgramnextIDREF="dbx_ch128"Studying a New ProgramIDREF="dbx_ch140"Studying a New ProgramprintIDREF="dbx_ch127"Studying a New ProgramIDREF="dbx_ch136"Studying a New ProgramrerunIDREF="dbx_ch126"Studying a New ProgramIDREF="dbx_ch134"Studying a New ProgramIDREF="dbx_ch118"Debugging Your ProgramsrunIDREF="dbx_ch133"Studying a New ProgramIDREF="dbx_ch125"Studying a New ProgramIDREF="dbx_ch117"Debugging Your ProgramsstepIDREF="dbx_ch129"Studying a New ProgramIDREF="dbx_ch138"Studying a New ProgramstopIDREF="dbx_ch115"Debugging Your ProgramsIDREF="dbx_ch131"Studying a New ProgramIDREF="dbx_ch124"Studying a New ProgramtraceIDREF="dbx_ch144"Studying a New ProgramwhereIDREF="dbx_ch18"Examining Core Dumps to Determine Cause of Failurecommand continuationIDREF="dbx_chA21"dbx Commandscommand scriptscommentsIDREF="dbx_ch590"Executing dbx ScriptsIDREF="dbx_ch67"Operatorscommand separator (\IDREF="dbx_chA20"dbx CommandscommandsactiveIDREF="dbx_ch915"Selecting a ProcessIDREF="dbx_chA28"dbx CommandsaddobjIDREF="dbx_chA31"dbx CommandsaddpgrpIDREF="dbx_chA32"dbx CommandsIDREF="dbx_ch958"Process Group DebuggingaddprocIDREF="dbx_chA34"dbx CommandsIDREF="dbx_ch912"Adding a Process to the Process PoolaliasIDREF="dbx_chA38"dbx CommandsIDREF="dbx_ch539"Listing AliasesIDREF="dbx_chA40"dbx CommandsIDREF="dbx_ch546"Creating Command AliasesIDREF="dbx_chA42"dbx CommandsIDREF="dbx_ch540"Listing AliasesIDREF="dbx_chA44"dbx CommandsIDREF="dbx_ch548"Creating Command AliasesIDREF="dbx_ch541"Listing AliasesIDREF="dbx_ch543"Creating Command AliasesIDREF="dbx_chA36"dbx CommandsIDREF="dbx_ch544"Creating Command AliasesIDREF="dbx_chB2"Predefined AliasesassignIDREF="dbx_ch662"Changing the Value of a VariableIDREF="dbx_chA48"dbx CommandsIDREF="dbx_ch813"Changing Register ValuesIDREF="dbx_ch661"Changing the Value of a VariableIDREF="dbx_chA46"dbx CommandscatchIDREF="dbx_chA52"dbx CommandsIDREF="dbx_chA50"dbx CommandsccallIDREF="dbx_chA54"dbx CommandsIDREF="dbx_ch698"Interactive Function CallsclearcallsIDREF="dbx_ch6107"Interactive Function CallsIDREF="dbx_chA56"dbx CommandscontIDREF="dbx_chA65"dbx CommandsIDREF="dbx_ch6102"Interactive Function CallsIDREF="dbx_chA66"dbx CommandsIDREF="dbx_chA58"dbx CommandsIDREF="dbx_ch7120"Continuing after Catching a SignalIDREF="dbx_ch945"Handling exec System CallsIDREF="dbx_chA60"dbx CommandsIDREF="dbx_ch736"Continuing Execution after a BreakpointIDREF="dbx_ch7118"Continuing after Catching a SignalIDREF="dbx_chA62"dbx CommandsIDREF="dbx_ch868"Continuing Execution after a Machine-level BreakpointIDREF="dbx_ch7116"Continuing after Catching a SignalIDREF="dbx_chA64"dbx CommandsIDREF="dbx_ch738"Continuing Execution after a BreakpointcontiIDREF="dbx_chA69"dbx CommandsIDREF="dbx_ch872"Continuing Execution after a Machine-level BreakpointIDREF="dbx_chA67"dbx CommandsIDREF="dbx_ch871"Continuing Execution after a Machine-level BreakpointIDREF="dbx_chA68"dbx CommandsIDREF="dbx_ch870"Continuing Execution after a Machine-level BreakpointcorefileIDREF="dbx_ch32"Specifying Files with dbx CommandsIDREF="dbx_ch34"Specifying Files with dbx CommandsIDREF="dbx_chA70"dbx CommandsdeleteIDREF="dbx_ch840"Setting Machine-level BreakpointsIDREF="dbx_ch876"Tracing Execution at the Machine LevelIDREF="dbx_ch747"Tracing Program ExecutionIDREF="dbx_chA71"dbx CommandsIDREF="dbx_ch765"Writing Conditional CommandsIDREF="dbx_ch7104"Deleting Breakpoints, Traces, and Conditional CommandsIDREF="dbx_ch76"BreakpointsdelpgrpIDREF="dbx_chA75"dbx CommandsIDREF="dbx_ch960"Process Group DebuggingdelprocIDREF="dbx_chA77"dbx CommandsIDREF="dbx_ch914"Deleting a Process from the Process PooldirIDREF="dbx_chA79"dbx CommandsIDREF="dbx_ch211"Invoking dbxIDREF="dbx_ch49"Specifying Source Directories with dbx CommandsdisableIDREF="dbx_ch838"Setting Machine-level BreakpointsIDREF="dbx_chA100"dbx CommandsIDREF="dbx_ch793"Disabling Breakpoints, Traces, and Conditional CommandsIDREF="dbx_ch874"Tracing Execution at the Machine LevelIDREF="dbx_chA81"dbx CommandsIDREF="dbx_ch763"Writing Conditional CommandsIDREF="dbx_ch745"Tracing Program ExecutionIDREF="dbx_ch798"Enabling Breakpoints, Traces, and Conditional CommandsIDREF="dbx_ch74"BreakpointsdownIDREF="dbx_chA85"dbx CommandsIDREF="dbx_ch681"Moving Within the StackdumpIDREF="dbx_chA87"dbx CommandsIDREF="dbx_ch695"Printing Activation Level InformationIDREF="dbx_chA88"dbx CommandsIDREF="dbx_ch694"Printing Activation Level InformationIDREF="dbx_chA90"dbx CommandsIDREF="dbx_ch696"Printing Activation Level InformationeditIDREF="dbx_ch430"Calling an EditorIDREF="dbx_chC32"Predefined dbx Variables         IDREF="dbx_chA92"dbx CommandsenableIDREF="dbx_ch75"BreakpointsIDREF="dbx_ch792"Disabling Breakpoints, Traces, and Conditional CommandsIDREF="dbx_ch799"Enabling Breakpoints, Traces, and Conditional CommandsIDREF="dbx_ch839"Setting Machine-level BreakpointsIDREF="dbx_ch875"Tracing Execution at the Machine LevelIDREF="dbx_ch746"Tracing Program ExecutionIDREF="dbx_chA96"dbx CommandsIDREF="dbx_ch764"Writing Conditional CommandsfileIDREF="dbx_chA101"dbx CommandsfuncIDREF="dbx_ch688"Moving to a Specified ProcedureIDREF="dbx_chA104"dbx CommandsIDREF="dbx_ch689"Moving to a Specified ProcedureIDREF="dbx_chA105"dbx CommandsgivenfileIDREF="dbx_ch33"Specifying Files with dbx CommandsIDREF="dbx_chA107"dbx CommandsgotoIDREF="dbx_ch7153"Starting at a Specified LineIDREF="dbx_chA108"dbx CommandshedIDREF="dbx_chA111"dbx CommandsIDREF="dbx_ch534"The History EditorIDREF="dbx_chA109"dbx CommandsIDREF="dbx_ch528"The History EditorIDREF="dbx_chA113"dbx CommandsIDREF="dbx_ch533"The History EditorIDREF="dbx_ch532"The History EditorhelpIDREF="dbx_chA115"dbx CommandsIDREF="dbx_ch234"On-line HelphistoryIDREF="dbx_chA119"dbx CommandsIDREF="dbx_ch516"Examining the History ListignoreIDREF="dbx_chA122"dbx CommandsIDREF="dbx_ch7110"Catching and Ignoring SignalsIDREF="dbx_ch7113"Catching and Ignoring SignalsIDREF="dbx_chA120"dbx CommandskillIDREF="dbx_chA126"dbx CommandsIDREF="dbx_ch938"Killing a ProcessIDREF="dbx_ch936"Killing a ProcessIDREF="dbx_chA124"dbx CommandslistIDREF="dbx_chA132"dbx CommandsIDREF="dbx_chA128"dbx CommandsIDREF="dbx_chA133"dbx CommandsIDREF="dbx_ch418"Listing Source CodeIDREF="dbx_chA130"dbx CommandslistobjIDREF="dbx_ch25"Compiling and Linking Programs with Dynamic Shared Objects (DSOs)IDREF="dbx_chA134"dbx CommandsnextIDREF="dbx_ch7149"Stepping Using the next CommandIDREF="dbx_ch7142"Stepping Through Your ProgramIDREF="dbx_ch6104"Interactive Function CallsIDREF="dbx_chA135"dbx CommandsnextiIDREF="dbx_ch889"Stepping Through Machine CodeIDREF="dbx_chA137"dbx CommandsIDREF="dbx_ch888"Stepping Through Machine Codeplayback inputIDREF="dbx_chC7"Predefined dbx Variables         IDREF="dbx_chA138"dbx CommandsIDREF="dbx_ch560"Recording InputIDREF="dbx_chC73"Predefined dbx Variables         IDREF="dbx_ch588"Executing dbx ScriptsIDREF="dbx_ch571"Playing Back InputIDREF="dbx_chC71"Predefined dbx Variables         playback outputIDREF="dbx_chA141"dbx CommandsIDREF="dbx_ch581"Playing Back OutputIDREF="dbx_ch578"Recording OutputIDREF="dbx_chC6"Predefined dbx Variables         printIDREF="dbx_chA143"dbx CommandsIDREF="dbx_ch650"Displaying the Value of a VariableIDREF="dbx_ch634"Printing ExpressionsIDREF="dbx_ch57"Setting dbx VariablesprintdIDREF="dbx_chA145"dbx CommandsIDREF="dbx_ch635"Printing ExpressionsIDREF="dbx_ch651"Displaying the Value of a VariableprintfIDREF="dbx_ch652"Displaying the Value of a VariableIDREF="dbx_ch637"Printing ExpressionsIDREF="dbx_chA146"dbx CommandsprintoIDREF="dbx_chA148"dbx CommandsIDREF="dbx_ch639"Printing ExpressionsIDREF="dbx_ch653"Displaying the Value of a VariableprintregsIDREF="dbx_chA149"dbx CommandsprintxIDREF="dbx_ch641"Printing ExpressionsIDREF="dbx_chA151"dbx CommandsIDREF="dbx_ch654"Displaying the Value of a VariablequitIDREF="dbx_chA152"dbx CommandsIDREF="dbx_ch242"Quitting dbxrecordIDREF="dbx_chA154"dbx Commandsrecord inputIDREF="dbx_ch584"Examining the Record StateIDREF="dbx_chC27"Predefined dbx Variables         IDREF="dbx_chA156"dbx CommandsIDREF="dbx_ch573"Playing Back InputIDREF="dbx_ch559"Recording Inputrecord outputIDREF="dbx_chC29"Predefined dbx Variables         IDREF="dbx_ch576"Recording OutputIDREF="dbx_ch585"Examining the Record StateIDREF="dbx_chA159"dbx CommandsIDREF="dbx_chC1"Predefined dbx Variables         rerunIDREF="dbx_chA163"dbx CommandsIDREF="dbx_ch37"Running Your ProgramIDREF="dbx_ch312"Running Your ProgramresumeIDREF="dbx_ch926"Resuming a Suspended ProcessIDREF="dbx_chA176"dbx CommandsIDREF="dbx_ch946"Handling exec System CallsIDREF="dbx_chA169"dbx CommandsIDREF="dbx_chA173"dbx CommandsIDREF="dbx_ch923"Resuming a Suspended ProcessIDREF="dbx_ch743"Continuing Execution after a BreakpointIDREF="dbx_ch6103"Interactive Function CallsIDREF="dbx_chA171"dbx CommandsreturnIDREF="dbx_chA180"dbx CommandsIDREF="dbx_chA179"dbx CommandsIDREF="dbx_ch7144"Using the return CommandrunIDREF="dbx_ch38"Running Your ProgramIDREF="dbx_chA181"dbx CommandsIDREF="dbx_ch36"Running Your ProgramIDREF="dbx_chA168"dbx Commandssearch backward (?)IDREF="dbx_ch426"Searching Through Source CodeIDREF="dbx_chA25"dbx CommandsIDREF="dbx_ch423"Searching Through Source Codesearch forward (/)IDREF="dbx_chA22"dbx CommandsIDREF="dbx_ch424"Searching Through Source CodeIDREF="dbx_ch422"Searching Through Source CodesetIDREF="dbx_ch54"Setting dbx VariablesIDREF="dbx_chA186"dbx CommandsIDREF="dbx_ch55"Setting dbx VariablesIDREF="dbx_ch59"Listing dbx VariablesIDREF="dbx_ch630"String ConstantsIDREF="dbx_chA188"dbx CommandsshIDREF="dbx_ch239"Invoking a ShellIDREF="dbx_chA192"dbx CommandsIDREF="dbx_chA190"dbx CommandsshowpgrpIDREF="dbx_chA194"dbx CommandsIDREF="dbx_ch962"Process Group DebuggingshowprocIDREF="dbx_chA196"dbx CommandsIDREF="dbx_ch99"Listing Available ProcessesstatusIDREF="dbx_chA199"dbx CommandsIDREF="dbx_ch569"Ending a Recording SessionstepIDREF="dbx_ch7141"Stepping Through Your ProgramIDREF="dbx_chA203"dbx CommandsIDREF="dbx_ch6105"Interactive Function CallsIDREF="dbx_chC94"Predefined dbx Variables         IDREF="dbx_ch7145"Stepping Using the step CommandstepbIDREF="dbx_ch893"Stepping Through Machine CodeIDREF="dbx_chA206"dbx CommandsIDREF="dbx_ch892"Stepping Through Machine CodeIDREF="dbx_chA205"dbx CommandsstepiIDREF="dbx_ch891"Stepping Through Machine CodeIDREF="dbx_chA208"dbx CommandsIDREF="dbx_ch890"Stepping Through Machine CodeIDREF="dbx_ch887"Stepping Through Machine CodeIDREF="dbx_chA207"dbx CommandsstepjIDREF="dbx_chA210"dbx CommandsIDREF="dbx_ch894"Stepping Through Machine CodeIDREF="dbx_chA209"dbx CommandsIDREF="dbx_ch895"Stepping Through Machine CodestopIDREF="dbx_ch717"Stopping if a Variable or Memory Location has ChangedIDREF="dbx_chA224"dbx CommandsIDREF="dbx_chA213"dbx CommandsIDREF="dbx_chA225"dbx CommandsIDREF="dbx_ch724"Stopping If a Test Expression is TrueIDREF="dbx_chA226"dbx CommandsIDREF="dbx_ch78"Setting Unconditional BreakpointsIDREF="dbx_ch710"Setting Unconditional BreakpointsIDREF="dbx_chA228"dbx CommandsIDREF="dbx_chA215"dbx CommandsIDREF="dbx_ch720"Stopping If a Test Expression is TrueIDREF="dbx_chA230"dbx CommandsIDREF="dbx_ch728"Conditional Breakpoints Combining Variable and Test ClausesIDREF="dbx_ch715"Stopping if a Variable or Memory Location has ChangedIDREF="dbx_chA217"dbx CommandsIDREF="dbx_ch79"Setting Unconditional BreakpointsIDREF="dbx_ch730"Conditional Breakpoints Combining Variable and Test ClausesIDREF="dbx_chA219"dbx CommandsIDREF="dbx_ch722"Stopping If a Test Expression is TrueIDREF="dbx_chA211"dbx CommandsIDREF="dbx_chA221"dbx CommandsIDREF="dbx_ch713"Stopping if a Variable or Memory Location has ChangedIDREF="dbx_ch732"Conditional Breakpoints Combining Variable and Test ClausesIDREF="dbx_chA223"dbx CommandsstopiIDREF="dbx_ch847"Syntax of the stopi CommandIDREF="dbx_chA247"dbx CommandsIDREF="dbx_ch859"Syntax of the stopi CommandIDREF="dbx_chA234"dbx CommandsIDREF="dbx_chA249"dbx CommandsIDREF="dbx_ch841"Syntax of the stopi CommandIDREF="dbx_ch853"Syntax of the stopi CommandIDREF="dbx_chA251"dbx CommandsIDREF="dbx_chA236"dbx CommandsIDREF="dbx_ch861"Syntax of the stopi CommandIDREF="dbx_chA253"dbx CommandsIDREF="dbx_ch845"Syntax of the stopi CommandIDREF="dbx_chA238"dbx CommandsIDREF="dbx_ch849"Syntax of the stopi CommandIDREF="dbx_chA256"dbx CommandsIDREF="dbx_ch863"Syntax of the stopi CommandIDREF="dbx_ch855"Syntax of the stopi CommandIDREF="dbx_chA241"dbx CommandsIDREF="dbx_chA259"dbx CommandsIDREF="dbx_ch843"Syntax of the stopi CommandIDREF="dbx_ch837"Setting Machine-level BreakpointsIDREF="dbx_ch857"Syntax of the stopi CommandIDREF="dbx_chA244"dbx CommandsIDREF="dbx_ch851"Syntax of the stopi CommandIDREF="dbx_chA232"dbx CommandssuspendIDREF="dbx_ch918"Suspending a ProcessIDREF="dbx_chA263"dbx CommandsIDREF="dbx_ch920"Suspending a ProcessIDREF="dbx_chA262"dbx CommandssyscallIDREF="dbx_ch7127"Stopping at System CallsIDREF="dbx_chA268"dbx CommandsIDREF="dbx_ch7131"Stopping at System CallsIDREF="dbx_ch7129"Stopping at System CallsIDREF="dbx_chA265"dbx CommandsIDREF="dbx_chA270"dbx CommandsIDREF="dbx_ch7125"Stopping at System CallsIDREF="dbx_chA266"dbx CommandsIDREF="dbx_chA272"dbx CommandsIDREF="dbx_ch7123"Stopping at System CallsIDREF="dbx_ch7138"Stopping at System CallstraceIDREF="dbx_ch748"Tracing Program ExecutionIDREF="dbx_chA278"dbx CommandsIDREF="dbx_ch756"Tracing Program ExecutionIDREF="dbx_ch750"Tracing Program ExecutionIDREF="dbx_chA280"dbx CommandsIDREF="dbx_chA274"dbx CommandsIDREF="dbx_ch754"Tracing Program ExecutionIDREF="dbx_chA282"dbx CommandsIDREF="dbx_ch758"Tracing Program ExecutionIDREF="dbx_chA276"dbx CommandsIDREF="dbx_chA284"dbx CommandsIDREF="dbx_chC50"Predefined dbx Variables         IDREF="dbx_ch752"Tracing Program ExecutiontraceiIDREF="dbx_chA288"dbx CommandsIDREF="dbx_ch883"Tracing Execution at the Machine LevelIDREF="dbx_ch880"Tracing Execution at the Machine LevelIDREF="dbx_chA290"dbx CommandsIDREF="dbx_ch877"Tracing Execution at the Machine LevelIDREF="dbx_ch881"Tracing Execution at the Machine LevelIDREF="dbx_chA292"dbx CommandsIDREF="dbx_ch879"Tracing Execution at the Machine LevelIDREF="dbx_chA286"dbx CommandsIDREF="dbx_chA294"dbx CommandsIDREF="dbx_ch882"Tracing Execution at the Machine LevelIDREF="dbx_ch878"Tracing Execution at the Machine LevelIDREF="dbx_chA296"dbx CommandsunaliasIDREF="dbx_ch551"Removing Command AliasesIDREF="dbx_chB3"Predefined AliasesIDREF="dbx_chA298"dbx CommandsunrecordIDREF="dbx_ch564"Ending a Recording SessionIDREF="dbx_chA302"dbx CommandsIDREF="dbx_chA300"dbx CommandsIDREF="dbx_ch567"Ending a Recording SessionIDREF="dbx_ch565"Ending a Recording SessionunsetIDREF="dbx_chA304"dbx CommandsIDREF="dbx_ch511"Removing VariablesupIDREF="dbx_chA306"dbx CommandsuseIDREF="dbx_ch48"Specifying Source Directories with dbx CommandsIDREF="dbx_chA308"dbx CommandsIDREF="dbx_ch411"Specifying Source Directories with dbx CommandsIDREF="dbx_ch210"Invoking dbxwaitIDREF="dbx_chA310"dbx CommandsIDREF="dbx_chA312"dbx CommandsIDREF="dbx_ch932"Waiting for a Resumed ProcessIDREF="dbx_ch930"Waiting for a Resumed ProcesswaitallIDREF="dbx_ch935"Waiting for Any Running ProcessIDREF="dbx_chA314"dbx CommandswhatisIDREF="dbx_chA316"dbx CommandsIDREF="dbx_ch672"Displaying Type DeclarationswhenIDREF="dbx_chA330"dbx CommandsIDREF="dbx_chA320"dbx CommandsIDREF="dbx_ch781"Writing Conditional CommandsIDREF="dbx_ch776"Writing Conditional CommandsIDREF="dbx_chA333"dbx CommandsIDREF="dbx_chA322"dbx CommandsIDREF="dbx_ch770"Writing Conditional CommandsIDREF="dbx_ch766"Writing Conditional CommandsIDREF="dbx_chA336"dbx CommandsIDREF="dbx_chA324"dbx CommandsIDREF="dbx_ch784"Writing Conditional CommandsIDREF="dbx_ch778"Writing Conditional CommandsIDREF="dbx_chA326"dbx CommandsIDREF="dbx_ch774"Writing Conditional CommandsIDREF="dbx_chA318"dbx CommandsIDREF="dbx_chA328"dbx CommandsIDREF="dbx_ch768"Writing Conditional CommandsIDREF="dbx_ch772"Writing Conditional CommandswheniIDREF="dbx_chA342"dbx CommandsIDREF="dbx_chA340"dbx CommandsIDREF="dbx_chA343"dbx CommandsIDREF="dbx_chA339"dbx CommandsIDREF="dbx_chA341"dbx CommandsIDREF="dbx_ch885"Writing Conditional Commands at the Machine LevelwhereIDREF="dbx_ch678"Printing Stack TracesIDREF="dbx_chA344"dbx CommandsIDREF="dbx_ch865"Syntax of the stopi CommandwhereisIDREF="dbx_chA346"dbx CommandsIDREF="dbx_ch670"Determining the Scope of VariableswhichIDREF="dbx_chA348"dbx CommandsIDREF="dbx_ch669"Determining the Scope of VariableswhichobjIDREF="dbx_chA350"dbx CommandsIDREF="dbx_ch26"Compiling and Linking Programs with Dynamic Shared Objects (DSOs)comments, command scriptsIDREF="dbx_ch67"OperatorsIDREF="dbx_ch590"Executing dbx Scriptsconditional breakpointsIDREF="dbx_ch73"Breakpointstest clauseIDREF="dbx_ch731"Conditional Breakpoints Combining Variable and Test ClausesIDREF="dbx_ch725"Stopping If a Test Expression is TrueIDREF="dbx_ch733"Conditional Breakpoints Combining Variable and Test ClausesIDREF="dbx_ch727"Conditional Breakpoints Combining Variable and Test ClausesIDREF="dbx_ch723"Stopping If a Test Expression is TrueIDREF="dbx_ch729"Conditional Breakpoints Combining Variable and Test ClausesIDREF="dbx_ch721"Stopping If a Test Expression is Truevariable clauseIDREF="dbx_ch718"Stopping if a Variable or Memory Location has ChangedIDREF="dbx_chA255"dbx CommandsIDREF="dbx_chA243"dbx CommandsIDREF="dbx_chA218"dbx CommandsIDREF="dbx_chA258"dbx CommandsIDREF="dbx_ch716"Stopping if a Variable or Memory Location has ChangedIDREF="dbx_chA246"dbx CommandsIDREF="dbx_chA261"dbx CommandsIDREF="dbx_chA220"dbx CommandsIDREF="dbx_chA227"dbx CommandsIDREF="dbx_ch714"Stopping if a Variable or Memory Location has ChangedIDREF="dbx_chA229"dbx CommandsIDREF="dbx_chA222"dbx CommandsIDREF="dbx_chA240"dbx CommandsIDREF="dbx_chA231"dbx Commandsconditional commandsdeletingIDREF="dbx_ch7105"Deleting Breakpoints, Traces, and Conditional CommandsIDREF="dbx_ch7107"Deleting Breakpoints, Traces, and Conditional CommandsIDREF="dbx_chA72"dbx CommandsIDREF="dbx_chA74"dbx CommandsdisablingIDREF="dbx_chA84"dbx CommandsIDREF="dbx_ch796"Disabling Breakpoints, Traces, and Conditional CommandsenablingIDREF="dbx_ch7102"Enabling Breakpoints, Traces, and Conditional CommandsIDREF="dbx_chA99"dbx CommandsstatusIDREF="dbx_chA202"dbx CommandsIDREF="dbx_ch790"Listing Breakpoints, Traces, and Conditional Commandsstop keywordIDREF="dbx_ch762"Writing Conditional Commandstest clauseIDREF="dbx_ch780"Writing Conditional CommandsIDREF="dbx_chA329"dbx CommandsIDREF="dbx_ch786"Writing Conditional CommandsIDREF="dbx_ch777"Writing Conditional CommandsIDREF="dbx_chA332"dbx CommandsIDREF="dbx_ch775"Writing Conditional CommandsIDREF="dbx_ch783"Writing Conditional CommandsIDREF="dbx_chA335"dbx CommandsIDREF="dbx_chA325"dbx CommandsIDREF="dbx_ch773"Writing Conditional CommandsIDREF="dbx_chA338"dbx CommandsIDREF="dbx_chA327"dbx Commandsvariable clauseIDREF="dbx_ch771"Writing Conditional CommandsIDREF="dbx_chA323"dbx CommandsIDREF="dbx_ch785"Writing Conditional CommandsIDREF="dbx_ch769"Writing Conditional CommandsIDREF="dbx_ch779"Writing Conditional CommandsIDREF="dbx_ch767"Writing Conditional CommandsIDREF="dbx_chA331"dbx CommandsIDREF="dbx_chA319"dbx CommandsIDREF="dbx_chA334"dbx CommandsIDREF="dbx_ch782"Writing Conditional CommandsIDREF="dbx_chA337"dbx CommandsIDREF="dbx_chA321"dbx Commandsconflicts between program variable names and C keywordsIDREF="dbx_ch664"Conflicts Between Variable Names and KeywordsIDREF="dbx_chC20"Predefined dbx Variables         confused listingIDREF="dbx_ch152"Avoiding Common PitfallsconstantsstringIDREF="dbx_ch613"Constantscont commandIDREF="dbx_ch7120"Continuing after Catching a SignalIDREF="dbx_ch130"Studying a New ProgramIDREF="dbx_ch121"Debugging Your ProgramsIDREF="dbx_ch7116"Continuing after Catching a SignalIDREF="dbx_chA58"dbx CommandsIDREF="dbx_ch142"Studying a New ProgramIDREF="dbx_chA60"dbx CommandsIDREF="dbx_ch736"Continuing Execution after a BreakpointIDREF="dbx_chA62"dbx CommandsIDREF="dbx_ch868"Continuing Execution after a Machine-level BreakpointIDREF="dbx_chA64"dbx CommandsIDREF="dbx_chA65"dbx CommandsIDREF="dbx_chA66"dbx CommandsIDREF="dbx_ch7118"Continuing after Catching a SignalIDREF="dbx_ch945"Handling exec System CallsIDREF="dbx_ch6102"Interactive Function CallsIDREF="dbx_ch738"Continuing Execution after a Breakpointconti commandIDREF="dbx_chA67"dbx CommandsIDREF="dbx_chA68"dbx CommandsIDREF="dbx_chA69"dbx CommandsIDREF="dbx_ch871"Continuing Execution after a Machine-level BreakpointIDREF="dbx_ch872"Continuing Execution after a Machine-level BreakpointIDREF="dbx_ch870"Continuing Execution after a Machine-level Breakpointcontinuing after a breakpointIDREF="dbx_ch739"Continuing Execution after a BreakpointIDREF="dbx_ch867"Continuing Execution after a Machine-level BreakpointIDREF="dbx_chA59"dbx CommandsIDREF="dbx_chA61"dbx CommandsIDREF="dbx_chA63"dbx CommandsIDREF="dbx_ch740"Continuing Execution after a BreakpointIDREF="dbx_ch735"Continuing Execution after a BreakpointIDREF="dbx_ch737"Continuing Execution after a Breakpointcontinuing after breakpointsIDREF="dbx_ch122"Debugging Your ProgramsIDREF="dbx_ch143"Studying a New Programcontinuing after catching signalsIDREF="dbx_ch7117"Continuing after Catching a SignalIDREF="dbx_ch7121"Continuing after Catching a SignalIDREF="dbx_ch7119"Continuing after Catching a Signalcore filesIDREF="dbx_ch14"Examining Core Dumps to Determine Cause of Failurecorefile commandIDREF="dbx_ch34"Specifying Files with dbx CommandsIDREF="dbx_chA70"dbx CommandsIDREF="dbx_ch32"Specifying Files with dbx Commandscreating aliasesIDREF="dbx_chA43"dbx CommandsIDREF="dbx_chA45"dbx CommandsIDREF="dbx_ch547"Creating Command AliasesIDREF="dbx_ch549"Creating Command AliasesIDREF="dbx_ch545"Creating Command AliasesIDREF="dbx_chA41"dbx Commands$ctypenamesIDREF="dbx_chC19"Predefined dbx Variables         IDREF="dbx_ch665"Conflicts Between Variable Names and Keywords$cureventIDREF="dbx_chC21"Predefined dbx Variables         $curlineIDREF="dbx_chC22"Predefined dbx Variables         $curpcIDREF="dbx_chC23"Predefined dbx Variables         current directoryIDREF="dbx_ch44"Specifying Source Directoriescurrent source fileIDREF="dbx_ch415"Changing Source FilesIDREF="dbx_ch427"Searching Through Source CodeIDREF="dbx_chA103"dbx CommandsIDREF="dbx_chA27"dbx CommandsIDREF="dbx_ch417"Listing Source CodeIDREF="dbx_ch425"Searching Through Source CodeIDREF="dbx_ch691"Moving to a Specified ProcedureIDREF="dbx_chA24"dbx CommandsIDREF="dbx_ch685"Moving Within the Stack$cursrclineIDREF="dbx_chC24"Predefined dbx Variables         dIDREF="dbx_chB8"Predefined Aliases$datacacheIDREF="dbx_chC25"Predefined dbx Variables         dbx -C flagIDREF="dbx_ch227"Invoking dbxIDREF="dbx_ch212"Invoking dbx -e flagIDREF="dbx_ch223"Invoking dbx -I flagIDREF="dbx_ch28"Invoking dbxIDREF="dbx_ch214"Invoking dbxIDREF="dbx_ch46"Specifying Source Directories with Arguments -k flagIDREF="dbx_ch225"Invoking dbx -p flagIDREF="dbx_ch218"Invoking dbxIDREF="dbx_ch219"Invoking dbx -r flagIDREF="dbx_ch216"Invoking dbx -x flagIDREF="dbx_ch221"Invoking dbxdbx invokingIDREF="dbx_ch16"Examining Core Dumps to Determine Cause of Failuredbx quittingIDREF="dbx_chA153"dbx Commandsdbx variableslistingIDREF="dbx_chA187"dbx Commandspredefined, see predefined dbx variablesIDREF="dbx_ch52"dbx VariablesremovingIDREF="dbx_chA305"dbx CommandssettingIDREF="dbx_ch56"Setting dbx VariablesIDREF="dbx_chA189"dbx Commands.dbxinit fileIDREF="dbx_ch213"Invoking dbxdebugging Fortran multiprocess programsIDREF="dbx_ch951"Process Group Debuggingdebugging running processesIDREF="dbx_ch220"Invoking dbxdecimal inputIDREF="dbx_ch617"Numeric Constantsdecimal outputIDREF="dbx_ch624"Numeric Constantsdefault input baseIDREF="dbx_ch618"Numeric Constantsdefault output baseIDREF="dbx_ch623"Numeric Constants$defaultinIDREF="dbx_chA158"dbx CommandsIDREF="dbx_chC26"Predefined dbx Variables         IDREF="dbx_ch562"Recording Input$defaultoutIDREF="dbx_ch579"Recording OutputIDREF="dbx_chC28"Predefined dbx Variables         IDREF="dbx_chA161"dbx Commandsdelete commandIDREF="dbx_ch765"Writing Conditional CommandsIDREF="dbx_ch76"BreakpointsIDREF="dbx_ch876"Tracing Execution at the Machine LevelIDREF="dbx_ch840"Setting Machine-level BreakpointsIDREF="dbx_chA71"dbx CommandsIDREF="dbx_ch7104"Deleting Breakpoints, Traces, and Conditional CommandsIDREF="dbx_ch747"Tracing Program Executiondelete processes from process poolIDREF="dbx_chA78"dbx Commandsdeletingconditional commandsIDREF="dbx_chA72"dbx CommandsIDREF="dbx_ch7107"Deleting Breakpoints, Traces, and Conditional CommandsIDREF="dbx_ch7105"Deleting Breakpoints, Traces, and Conditional CommandsIDREF="dbx_chA74"dbx CommandstracingIDREF="dbx_ch7106"Deleting Breakpoints, Traces, and Conditional CommandsIDREF="dbx_chA73"dbx Commandsdeleting aliasesIDREF="dbx_chA299"dbx Commandsdeleting processes from the process group listIDREF="dbx_chA76"dbx CommandsIDREF="dbx_ch959"Process Group Debuggingdelpgrp commandIDREF="dbx_ch960"Process Group DebuggingIDREF="dbx_chA75"dbx Commandsdelproc commandIDREF="dbx_ch914"Deleting a Process from the Process PoolIDREF="dbx_chA77"dbx Commandsdetermining scope of program variablesIDREF="dbx_chA347"dbx CommandsIDREF="dbx_chA349"dbx CommandsdirIDREF="dbx_chB9"Predefined Aliasesdir commandIDREF="dbx_ch49"Specifying Source Directories with dbx CommandsIDREF="dbx_ch211"Invoking dbxIDREF="dbx_chA79"dbx Commandsdisable commandIDREF="dbx_ch874"Tracing Execution at the Machine LevelIDREF="dbx_ch745"Tracing Program ExecutionIDREF="dbx_ch838"Setting Machine-level BreakpointsIDREF="dbx_chA81"dbx CommandsIDREF="dbx_ch74"BreakpointsIDREF="dbx_ch763"Writing Conditional CommandsIDREF="dbx_ch793"Disabling Breakpoints, Traces, and Conditional CommandsIDREF="dbx_ch798"Enabling Breakpoints, Traces, and Conditional CommandsIDREF="dbx_chA100"dbx CommandsdisablingbreakpointsIDREF="dbx_chA82"dbx CommandsIDREF="dbx_ch794"Disabling Breakpoints, Traces, and Conditional Commandsconditional commandsIDREF="dbx_ch796"Disabling Breakpoints, Traces, and Conditional CommandsIDREF="dbx_chA84"dbx CommandstracingIDREF="dbx_ch795"Disabling Breakpoints, Traces, and Conditional CommandsIDREF="dbx_chA83"dbx Commandsdisassemble codeIDREF="dbx_ch820"Examining Memory and Disassembling CodeIDREF="dbx_ch817"Examining Memory and Disassembling CodeIDREF="dbx_chA6"dbx CommandsIDREF="dbx_chA3"dbx Commandsdisassembling codeIDREF="dbx_ch84"Registersdisplayactive process in process poolIDREF="dbx_ch917"Selecting a ProcessIDREF="dbx_chA30"dbx Commandsprocesses in process poolIDREF="dbx_chA197"dbx CommandsIDREF="dbx_ch910"Listing Available Processesdisplaying aliasesIDREF="dbx_chA39"dbx CommandsIDREF="dbx_chA37"dbx Commandsdisplaying caught signalsIDREF="dbx_ch7112"Catching and Ignoring SignalsIDREF="dbx_chA51"dbx Commandsdisplaying caught system callsIDREF="dbx_ch7128"Stopping at System CallsIDREF="dbx_chA267"dbx Commandsdisplaying ignored signalsIDREF="dbx_ch7114"Catching and Ignoring SignalsIDREF="dbx_chA121"dbx Commandsdisplaying ignored system callsIDREF="dbx_chA269"dbx CommandsIDREF="dbx_ch7130"Stopping at System Callsdisplaying recording sessionsIDREF="dbx_ch583"Examining the Record StateIDREF="dbx_chA155"dbx Commandsdown commandIDREF="dbx_chA85"dbx CommandsIDREF="dbx_ch681"Moving Within the StackDSOsIDREF="dbx_ch947"Handling exec System Callsdump commandIDREF="dbx_ch694"Printing Activation Level InformationIDREF="dbx_ch695"Printing Activation Level InformationIDREF="dbx_chA87"dbx CommandsIDREF="dbx_chA88"dbx CommandsIDREF="dbx_chA90"dbx CommandsIDREF="dbx_ch696"Printing Activation Level Information dynamic shared objectsIDREF="dbx_ch947"Handling exec System Calls$dynamic_scopeIDREF="dbx_chC30"Predefined dbx Variables         eIDREF="dbx_chB10"Predefined Aliasesedit commandIDREF="dbx_ch430"Calling an EditorIDREF="dbx_chC32"Predefined dbx Variables         IDREF="dbx_chA92"dbx Commandsedit history listIDREF="dbx_ch529"The History EditorIDREF="dbx_chA110"dbx CommandsIDREF="dbx_chA114"dbx CommandsIDREF="dbx_chA112"dbx Commandsediting filesIDREF="dbx_chA93"dbx CommandsIDREF="dbx_ch429"Calling an Editor$editorIDREF="dbx_ch530"The History EditorIDREF="dbx_ch431"Calling an EditorIDREF="dbx_chA94"dbx CommandsIDREF="dbx_chC31"Predefined dbx Variables         EDITOR environment variableIDREF="dbx_chA95"dbx CommandsIDREF="dbx_chC3"Predefined dbx Variables         IDREF="dbx_ch432"Calling an EditorIDREF="dbx_ch531"The History Editorenable commandIDREF="dbx_ch75"BreakpointsIDREF="dbx_ch792"Disabling Breakpoints, Traces, and Conditional CommandsIDREF="dbx_chA96"dbx CommandsIDREF="dbx_ch839"Setting Machine-level BreakpointsIDREF="dbx_ch746"Tracing Program ExecutionIDREF="dbx_ch799"Enabling Breakpoints, Traces, and Conditional CommandsIDREF="dbx_ch764"Writing Conditional CommandsIDREF="dbx_ch875"Tracing Execution at the Machine LevelenablingbreakpointsIDREF="dbx_ch7100"Enabling Breakpoints, Traces, and Conditional CommandsIDREF="dbx_chA97"dbx Commandsconditional commandsIDREF="dbx_chA99"dbx CommandsIDREF="dbx_ch7102"Enabling Breakpoints, Traces, and Conditional CommandstracingIDREF="dbx_chA98"dbx CommandsIDREF="dbx_ch7101"Enabling Breakpoints, Traces, and Conditional Commandsending recordingIDREF="dbx_ch566"Ending a Recording SessionIDREF="dbx_ch568"Ending a Recording SessionIDREF="dbx_chA303"dbx CommandsIDREF="dbx_chA301"dbx Commandsenvironment variablesEDITORIDREF="dbx_chC3"Predefined dbx Variables         IDREF="dbx_chA95"dbx CommandsIDREF="dbx_ch531"The History EditorIDREF="dbx_ch432"Calling an EditorHOMEIDREF="dbx_ch232"Automatically Executing Commands on Startupevaluation stack, increasingIDREF="dbx_ch224"Invoking dbxexamining arraysIDREF="dbx_ch658"Displaying the Value of a Variableexamining program variablesIDREF="dbx_ch137"Studying a New ProgramIDREF="dbx_ch119"Debugging Your Programsexamining stackIDREF="dbx_ch120"Debugging Your ProgramsexecIDREF="dbx_ch7132"Stopping at System CallsIDREF="dbx_ch321"Programs Linked with Non-shared Librariesexecuting a shell commandIDREF="dbx_ch240"Invoking a ShellIDREF="dbx_chA193"dbx CommandsexecveIDREF="dbx_ch7133"Stopping at System CallsexitIDREF="dbx_ch7139"Stopping at System CallsexpressionsprintingIDREF="dbx_chA144"dbx Commandsprinting formattedIDREF="dbx_chA147"dbx CommandsIDREF="dbx_ch638"Printing ExpressionsfIDREF="dbx_chB11"Predefined Aliasesfile commandIDREF="dbx_chA101"dbx CommandsforkIDREF="dbx_chC8"Predefined dbx Variables         IDREF="dbx_chC10"Predefined dbx Variables         IDREF="dbx_ch7134"Stopping at System CallsIDREF="dbx_ch954"Process Group DebuggingFortran multiprocess debuggingIDREF="dbx_ch951"Process Group Debugging$frameviadisassemblyIDREF="dbx_chC33"Predefined dbx Variables         func commandIDREF="dbx_ch689"Moving to a Specified ProcedureIDREF="dbx_ch688"Moving to a Specified ProcedureIDREF="dbx_chA104"dbx CommandsIDREF="dbx_chA105"dbx Commands$funcentrybylinesIDREF="dbx_chC34"Predefined dbx Variables         function calls, interactiveIDREF="dbx_ch6100"Interactive Function CallsIDREF="dbx_chA57"dbx CommandsIDREF="dbx_ch6106"Interactive Function CallsIDREF="dbx_ch699"Interactive Function CallsIDREF="dbx_chA55"dbx Commands$functionsymbolsIDREF="dbx_chC35"Predefined dbx Variables         gIDREF="dbx_chB12"Predefined Aliasesgivenfile commandIDREF="dbx_ch33"Specifying Files with dbx CommandsIDREF="dbx_chA107"dbx Commands$globalcountIDREF="dbx_chC36"Predefined dbx Variables         goto commandIDREF="dbx_chA108"dbx CommandsIDREF="dbx_ch7153"Starting at a Specified Linegroup historyIDREF="dbx_ch966"Process Group Debugging$groupforktooIDREF="dbx_chC37"Predefined dbx Variables         IDREF="dbx_ch956"Process Group DebugginghIDREF="dbx_chB13"Predefined Aliaseshed commandIDREF="dbx_chA111"dbx CommandsIDREF="dbx_ch534"The History EditorIDREF="dbx_chA113"dbx CommandsIDREF="dbx_ch528"The History EditorIDREF="dbx_ch532"The History EditorIDREF="dbx_chA109"dbx CommandsIDREF="dbx_ch533"The History EditorhelpIDREF="dbx_chC65"Predefined dbx Variables         IDREF="dbx_chA116"dbx Commandshelp commandIDREF="dbx_chA115"dbx CommandsIDREF="dbx_ch234"On-line Helphexadecimal inputIDREF="dbx_chC2"Predefined dbx Variables         IDREF="dbx_ch621"Numeric Constantshexadecimal outputIDREF="dbx_ch810"Printing Register ValuesIDREF="dbx_ch627"Numeric ConstantsIDREF="dbx_chC5"Predefined dbx Variables         $hexcharsIDREF="dbx_chC38"Predefined dbx Variables         $hexinIDREF="dbx_chC39"Predefined dbx Variables         IDREF="dbx_chC58"Predefined dbx Variables         IDREF="dbx_ch622"Numeric Constants$hexintsIDREF="dbx_ch628"Numeric ConstantsIDREF="dbx_ch88"Printing Register ValuesIDREF="dbx_chC40"Predefined dbx Variables         IDREF="dbx_chC61"Predefined dbx Variables         $hexstringsIDREF="dbx_chC41"Predefined dbx Variables         history commandIDREF="dbx_chA119"dbx CommandsIDREF="dbx_ch516"Examining the History Listhistory listIDREF="dbx_ch518"Repeating CommandseditingIDREF="dbx_chA114"dbx CommandsIDREF="dbx_ch529"The History EditorIDREF="dbx_chA110"dbx CommandsIDREF="dbx_chA112"dbx CommandsprintIDREF="dbx_ch515"Examining the History List$historyeventIDREF="dbx_chC42"Predefined dbx Variables         HOME environment variableIDREF="dbx_ch232"Automatically Executing Commands on Startupignore commandIDREF="dbx_chA120"dbx CommandsIDREF="dbx_ch7113"Catching and Ignoring SignalsIDREF="dbx_chA122"dbx CommandsIDREF="dbx_ch7110"Catching and Ignoring Signalsignoring signalsIDREF="dbx_ch7111"Catching and Ignoring SignalsIDREF="dbx_chA123"dbx Commandsignoring system callsIDREF="dbx_ch7126"Stopping at System CallsIDREF="dbx_chA273"dbx Commandsinclude filesIDREF="dbx_ch156"Avoiding Common Pitfallsinline C++ functionsIDREF="dbx_ch6116"Referring to C++ Functionsinputplaying backIDREF="dbx_chA139"dbx CommandsrecordingIDREF="dbx_chA157"dbx CommandsIDREF="dbx_ch555"Recording and Playing Back dbx Input and Outputinput basedecimalIDREF="dbx_ch617"Numeric ConstantshexadecimalIDREF="dbx_ch621"Numeric ConstantsIDREF="dbx_chC2"Predefined dbx Variables         octalIDREF="dbx_chC57"Predefined dbx Variables         IDREF="dbx_ch619"Numeric Constantsinteractive function callsIDREF="dbx_ch631"String ConstantsbreakpointsIDREF="dbx_ch6109"Interactive Function CallscallingIDREF="dbx_ch699"Interactive Function CallsIDREF="dbx_chA55"dbx CommandsclearingIDREF="dbx_ch6100"Interactive Function CallsIDREF="dbx_chA57"dbx CommandsIDREF="dbx_ch6106"Interactive Function CallsnestingIDREF="dbx_ch6108"Interactive Function CallsunstackingIDREF="dbx_ch6101"Interactive Function Callsinvoking a shellIDREF="dbx_chA191"dbx Commandsinvoking dbxIDREF="dbx_ch16"Examining Core Dumps to Determine Cause of FailurejIDREF="dbx_chB14"Predefined Aliaseskernel debuggingIDREF="dbx_ch226"Invoking dbxkill active processIDREF="dbx_ch937"Killing a ProcessIDREF="dbx_chA125"dbx Commandskill commandIDREF="dbx_chA124"dbx CommandsIDREF="dbx_ch938"Killing a ProcessIDREF="dbx_chA126"dbx CommandsIDREF="dbx_ch936"Killing a Processkill process in process poolIDREF="dbx_chA127"dbx CommandsIDREF="dbx_ch939"Killing a ProcesslIDREF="dbx_chB15"Predefined Aliases$lastchildIDREF="dbx_chC43"Predefined dbx Variables         IDREF="dbx_ch97"ProcessesliIDREF="dbx_chB16"Predefined Aliases$linesIDREF="dbx_chC44"Predefined dbx Variables         line numbers, addressIDREF="dbx_ch591"Executing dbx ScriptsIDREF="dbx_ch68"OperatorsIDREF="dbx_ch65"Operatorslinked listIDREF="dbx_ch553"Alias ExamplelinkerIDREF="dbx_ch318"Programs Linked with DSOslist commandIDREF="dbx_chA128"dbx CommandsIDREF="dbx_chA132"dbx CommandsIDREF="dbx_chA133"dbx CommandsIDREF="dbx_chA130"dbx CommandsIDREF="dbx_ch418"Listing Source Codelisting dbx variablesIDREF="dbx_chA187"dbx Commandslisting is confusedIDREF="dbx_ch153"Avoiding Common Pitfallslistobj commandIDREF="dbx_ch25"Compiling and Linking Programs with Dynamic Shared Objects (DSOs)IDREF="dbx_chA134"dbx Commands$listwindowIDREF="dbx_chA129"dbx CommandsIDREF="dbx_ch420"Listing Source CodeIDREF="dbx_chA131"dbx CommandsIDREF="dbx_chC45"Predefined dbx Variables         IDREF="dbx_ch419"Listing Source Codemachine-level breakpointsIDREF="dbx_chA239"dbx CommandsIDREF="dbx_ch842"Syntax of the stopi CommandIDREF="dbx_chA242"dbx CommandsIDREF="dbx_ch858"Syntax of the stopi CommandIDREF="dbx_chA245"dbx CommandsIDREF="dbx_ch850"Syntax of the stopi CommandIDREF="dbx_chA248"dbx CommandsIDREF="dbx_ch860"Syntax of the stopi CommandIDREF="dbx_chA250"dbx CommandsIDREF="dbx_ch846"Syntax of the stopi CommandIDREF="dbx_chA252"dbx CommandsIDREF="dbx_ch862"Syntax of the stopi CommandIDREF="dbx_chA254"dbx CommandsIDREF="dbx_ch852"Syntax of the stopi CommandIDREF="dbx_chA257"dbx CommandsIDREF="dbx_ch864"Syntax of the stopi CommandIDREF="dbx_chA260"dbx CommandsIDREF="dbx_ch844"Syntax of the stopi CommandIDREF="dbx_chA233"dbx CommandsIDREF="dbx_ch854"Syntax of the stopi CommandIDREF="dbx_chA235"dbx CommandsIDREF="dbx_ch848"Syntax of the stopi CommandIDREF="dbx_chA237"dbx CommandsIDREF="dbx_ch856"Syntax of the stopi Commandmachine-level debuggingIDREF="dbx_ch12"Getting Started with dbxmacrosIDREF="dbx_ch159"Avoiding Common Pitfalls$mainIDREF="dbx_chC46"Predefined dbx Variables         $maxstrlenIDREF="dbx_chC47"Predefined dbx Variables         memory, print contentsIDREF="dbx_ch819"Examining Memory and Disassembling CodeIDREF="dbx_chA8"dbx CommandsIDREF="dbx_ch816"Examining Memory and Disassembling CodeIDREF="dbx_chA2"dbx CommandsIDREF="dbx_ch822"Examining Memory and Disassembling CodeIDREF="dbx_chA5"dbx Commandsmissing codeIDREF="dbx_ch158"Avoiding Common PitfallsIDREF="dbx_ch161"Avoiding Common Pitfallsmp FortranIDREF="dbx_ch950"Process Group DebuggingIDREF="dbx_chC4"Predefined dbx Variables         $mp_programIDREF="dbx_ch952"Process Group DebuggingIDREF="dbx_chC48"Predefined dbx Variables         IDREF="dbx_ch7137"Stopping at System Callsmultiprocess programsIDREF="dbx_ch742"Continuing Execution after a BreakpointnIDREF="dbx_chB17"Predefined Aliases$naptimeIDREF="dbx_chC49"Predefined dbx Variables         IDREF="dbx_chC54"Predefined dbx Variables         nesting interactive function callsIDREF="dbx_ch6108"Interactive Function Calls$neweventIDREF="dbx_chC51"Predefined dbx Variables         next commandIDREF="dbx_ch7142"Stepping Through Your ProgramIDREF="dbx_chA135"dbx CommandsIDREF="dbx_ch7149"Stepping Using the next CommandIDREF="dbx_ch128"Studying a New ProgramIDREF="dbx_ch140"Studying a New ProgramIDREF="dbx_ch6104"Interactive Function Calls$nextbreakIDREF="dbx_chC52"Predefined dbx Variables         IDREF="dbx_ch7150"Stepping Using the next CommandIDREF="dbx_ch897"Stepping Through Machine Codenexti commandIDREF="dbx_ch889"Stepping Through Machine CodeIDREF="dbx_chA137"dbx CommandsIDREF="dbx_ch888"Stepping Through Machine CodeniIDREF="dbx_chB18"Predefined Aliasesno display of variablesIDREF="dbx_ch150"Avoiding Common Pitfalls$notypenamesIDREF="dbx_chC55"Predefined dbx Variables         object filesIDREF="dbx_ch42"Specifying Source Directoriesoctal inputIDREF="dbx_chC57"Predefined dbx Variables         IDREF="dbx_ch619"Numeric Constantsoctal outputIDREF="dbx_chC60"Predefined dbx Variables         IDREF="dbx_ch625"Numeric ConstantsIDREF="dbx_ch89"Printing Register Values$octinIDREF="dbx_chC56"Predefined dbx Variables         IDREF="dbx_ch620"Numeric Constants$octintsIDREF="dbx_ch626"Numeric ConstantsIDREF="dbx_chC59"Predefined dbx Variables         IDREF="dbx_ch87"Printing Register Valueson-line helpIDREF="dbx_chA116"dbx CommandsIDREF="dbx_chC65"Predefined dbx Variables         $onexecruntomainIDREF="dbx_ch319"Programs Linked with DSOsIDREF="dbx_chC62"Predefined dbx Variables         operatorsIDREF="dbx_ch63"Expressions# operatorIDREF="dbx_ch591"Executing dbx ScriptsIDREF="dbx_ch65"OperatorsIDREF="dbx_ch68"Operators// (division)IDREF="dbx_ch69"OperatorsIDREF="dbx_ch610"OperatorsIDREF="dbx_ch611"Operatorsoutputplaying backIDREF="dbx_chA142"dbx CommandsIDREF="dbx_ch557"Recording and Playing Back dbx Input and OutputrecordingIDREF="dbx_ch556"Recording and Playing Back dbx Input and OutputIDREF="dbx_chA160"dbx Commandsoutput basedecimalIDREF="dbx_ch624"Numeric ConstantshexadecimalIDREF="dbx_ch627"Numeric ConstantsIDREF="dbx_chC5"Predefined dbx Variables         IDREF="dbx_ch810"Printing Register ValuesoctalIDREF="dbx_chC60"Predefined dbx Variables         IDREF="dbx_ch625"Numeric ConstantsIDREF="dbx_ch89"Printing Register Valuesoverloaded C++ functionsIDREF="dbx_ch6117"Referring to C++ FunctionspIDREF="dbx_chB19"Predefined Aliases$pageIDREF="dbx_chC63"Predefined dbx Variables         $pagerIDREF="dbx_ch235"On-line HelpIDREF="dbx_chA118"dbx CommandsIDREF="dbx_chC64"Predefined dbx Variables         IDREF="dbx_chA117"dbx Commands$pagewidthIDREF="dbx_chC67"Predefined dbx Variables         $pagewindowIDREF="dbx_chC66"Predefined dbx Variables         pdIDREF="dbx_ch636"Printing ExpressionsIDREF="dbx_ch655"Displaying the Value of a VariableIDREF="dbx_chB20"Predefined Aliasespgrp clauseIDREF="dbx_ch963"Process Group Debugging$pidIDREF="dbx_chC80"Predefined dbx Variables         IDREF="dbx_chC68"Predefined dbx Variables         IDREF="dbx_chB21"Predefined Aliases$piaddtohistIDREF="dbx_chC70"Predefined dbx Variables         $pid0IDREF="dbx_chC69"Predefined dbx Variables         IDREF="dbx_ch98"Processespid clauseIDREF="dbx_ch96"Processes$pimodeIDREF="dbx_ch574"Playing Back InputIDREF="dbx_ch535"The History EditorIDREF="dbx_chA140"dbx CommandsIDREF="dbx_chC72"Predefined dbx Variables         pixieIDREF="dbx_ch222"Invoking dbxplayback input commandIDREF="dbx_chC71"Predefined dbx Variables         IDREF="dbx_ch560"Recording InputIDREF="dbx_chC73"Predefined dbx Variables         IDREF="dbx_ch588"Executing dbx ScriptsIDREF="dbx_chC7"Predefined dbx Variables         IDREF="dbx_ch571"Playing Back InputIDREF="dbx_chA138"dbx Commandsplayback output commandIDREF="dbx_ch578"Recording OutputIDREF="dbx_chC6"Predefined dbx Variables         IDREF="dbx_chA141"dbx CommandsIDREF="dbx_ch581"Playing Back Outputplaying back inputIDREF="dbx_chA139"dbx Commandsplaying back outputIDREF="dbx_ch557"Recording and Playing Back dbx Input and OutputIDREF="dbx_chA142"dbx CommandspoIDREF="dbx_chB22"Predefined AliasesIDREF="dbx_ch640"Printing ExpressionsIDREF="dbx_ch656"Displaying the Value of a VariableprIDREF="dbx_chB23"Predefined Aliasespredefined dbx aliasesIDREF="dbx_chB1"Predefined AliasesIDREF="dbx_ch537"dbx AliasesaIDREF="dbx_chB4"Predefined AliasesbIDREF="dbx_chB5"Predefined AliasesbpIDREF="dbx_chB6"Predefined AliasescIDREF="dbx_chB7"Predefined AliasesdIDREF="dbx_chB8"Predefined AliasesdirIDREF="dbx_chB9"Predefined AliaseseIDREF="dbx_chB10"Predefined AliasesfIDREF="dbx_chB11"Predefined AliasesgIDREF="dbx_chB12"Predefined AliaseshIDREF="dbx_chB13"Predefined AliasesjIDREF="dbx_chB14"Predefined AliaseslIDREF="dbx_chB15"Predefined AliasesliIDREF="dbx_chB16"Predefined AliasesnIDREF="dbx_chB17"Predefined AliasesniIDREF="dbx_chB18"Predefined AliasespIDREF="dbx_chB19"Predefined AliasespdIDREF="dbx_ch636"Printing ExpressionsIDREF="dbx_chB20"Predefined AliasesIDREF="dbx_ch655"Displaying the Value of a VariablepiIDREF="dbx_chB21"Predefined AliasespoIDREF="dbx_ch640"Printing ExpressionsIDREF="dbx_ch656"Displaying the Value of a VariableIDREF="dbx_chB22"Predefined AliasesprIDREF="dbx_chB23"Predefined AliasespxIDREF="dbx_chB24"Predefined AliasesIDREF="dbx_ch657"Displaying the Value of a VariableIDREF="dbx_ch642"Printing ExpressionsqIDREF="dbx_chB25"Predefined AliasesrIDREF="dbx_chB26"Predefined AliasesriIDREF="dbx_chB27"Predefined AliasesroIDREF="dbx_chB28"Predefined AliasessIDREF="dbx_chB29"Predefined AliasesIDREF="dbx_chB30"Predefined AliasessiIDREF="dbx_chB31"Predefined AliasesIDREF="dbx_chB32"Predefined AliasessourceIDREF="dbx_ch587"Executing dbx ScriptsIDREF="dbx_chA198"dbx CommandsIDREF="dbx_ch561"Recording InputIDREF="dbx_chB33"Predefined AliasesIDREF="dbx_ch572"Playing Back InputtIDREF="dbx_chB34"Predefined AliasesuIDREF="dbx_chB35"Predefined AliasesWIDREF="dbx_chB37"Predefined AliasesIDREF="dbx_chB36"Predefined AliaseswiIDREF="dbx_chB38"Predefined Aliasespredefined dbx variablesIDREF="dbx_ch52"dbx Variables$addrfmtIDREF="dbx_chC13"Predefined dbx Variables         $assumenormalframeIDREF="dbx_chC82"Predefined dbx Variables         IDREF="dbx_chC14"Predefined dbx Variables         $casesenseIDREF="dbx_ch667"Case Sensitivity in Variable NamesIDREF="dbx_chC16"Predefined dbx Variables         $charisunsignedIDREF="dbx_chC18"Predefined dbx Variables         $ctypenamesIDREF="dbx_ch665"Conflicts Between Variable Names and KeywordsIDREF="dbx_chC19"Predefined dbx Variables         $cureventIDREF="dbx_chC21"Predefined dbx Variables         $curlineIDREF="dbx_chC22"Predefined dbx Variables         $curpcIDREF="dbx_chC23"Predefined dbx Variables         $cursrclineIDREF="dbx_chC24"Predefined dbx Variables         $datacacheIDREF="dbx_chC25"Predefined dbx Variables         $defaultinIDREF="dbx_ch562"Recording InputIDREF="dbx_chA158"dbx CommandsIDREF="dbx_chC26"Predefined dbx Variables         $defaultoutIDREF="dbx_chA161"dbx CommandsIDREF="dbx_chC28"Predefined dbx Variables         IDREF="dbx_ch579"Recording Output$dynamic_scopeIDREF="dbx_chC30"Predefined dbx Variables         $editorIDREF="dbx_ch530"The History EditorIDREF="dbx_chC31"Predefined dbx Variables         IDREF="dbx_chA94"dbx CommandsIDREF="dbx_ch431"Calling an Editor$frameviadisassemblyIDREF="dbx_chC33"Predefined dbx Variables         $funcentrybylinesIDREF="dbx_chC34"Predefined dbx Variables         $functionsymbolsIDREF="dbx_chC35"Predefined dbx Variables         $globalcountIDREF="dbx_chC36"Predefined dbx Variables         $groupforktooIDREF="dbx_chC37"Predefined dbx Variables         IDREF="dbx_ch956"Process Group Debugging$hexcharsIDREF="dbx_chC38"Predefined dbx Variables         $hexinIDREF="dbx_chC58"Predefined dbx Variables         IDREF="dbx_ch622"Numeric ConstantsIDREF="dbx_chC39"Predefined dbx Variables         $hexintsIDREF="dbx_ch88"Printing Register ValuesIDREF="dbx_ch628"Numeric ConstantsIDREF="dbx_chC40"Predefined dbx Variables         IDREF="dbx_chC61"Predefined dbx Variables         $hexstringsIDREF="dbx_chC41"Predefined dbx Variables         $historyeventIDREF="dbx_chC42"Predefined dbx Variables         $lastchildIDREF="dbx_chC43"Predefined dbx Variables         IDREF="dbx_ch97"Processes$linesIDREF="dbx_chC44"Predefined dbx Variables         $listwindowIDREF="dbx_chA131"dbx CommandsIDREF="dbx_ch419"Listing Source CodeIDREF="dbx_ch420"Listing Source CodeIDREF="dbx_chC45"Predefined dbx Variables         IDREF="dbx_chA129"dbx Commands$mainIDREF="dbx_chC46"Predefined dbx Variables         $maxstrlenIDREF="dbx_chC47"Predefined dbx Variables         $mp_programIDREF="dbx_chC48"Predefined dbx Variables         IDREF="dbx_ch7137"Stopping at System CallsIDREF="dbx_ch952"Process Group Debugging$naptimeIDREF="dbx_chC49"Predefined dbx Variables         IDREF="dbx_chC54"Predefined dbx Variables         $neweventIDREF="dbx_chC51"Predefined dbx Variables         $nextbreakIDREF="dbx_ch897"Stepping Through Machine CodeIDREF="dbx_ch7150"Stepping Using the next CommandIDREF="dbx_chC52"Predefined dbx Variables         $notypenamesIDREF="dbx_chC55"Predefined dbx Variables         $octinIDREF="dbx_chC56"Predefined dbx Variables         IDREF="dbx_ch620"Numeric Constants$octintsIDREF="dbx_ch626"Numeric ConstantsIDREF="dbx_chC59"Predefined dbx Variables         IDREF="dbx_ch87"Printing Register Values$onexecruntomainIDREF="dbx_ch319"Programs Linked with DSOsIDREF="dbx_chC62"Predefined dbx Variables         $pageIDREF="dbx_chC63"Predefined dbx Variables         $pagerIDREF="dbx_chC64"Predefined dbx Variables         IDREF="dbx_chA118"dbx CommandsIDREF="dbx_ch235"On-line HelpIDREF="dbx_chA117"dbx Commands$pagewidthIDREF="dbx_chC67"Predefined dbx Variables         $pagewindowIDREF="dbx_chC66"Predefined dbx Variables         $pidIDREF="dbx_chC68"Predefined dbx Variables         IDREF="dbx_chC80"Predefined dbx Variables         $piaddtohistIDREF="dbx_chC70"Predefined dbx Variables         $pid0IDREF="dbx_ch98"ProcessesIDREF="dbx_chC69"Predefined dbx Variables         $pimodeIDREF="dbx_chC72"Predefined dbx Variables         IDREF="dbx_chA140"dbx CommandsIDREF="dbx_ch574"Playing Back InputIDREF="dbx_ch535"The History Editor$print_exception_frameIDREF="dbx_chC75"Predefined dbx Variables         $printdataIDREF="dbx_chC74"Predefined dbx Variables         $printobjnameIDREF="dbx_ch27"Compiling and Linking Programs with Dynamic Shared Objects (DSOs)IDREF="dbx_chC76"Predefined dbx Variables         $printwhilestepIDREF="dbx_chC77"Predefined dbx Variables         $printwideIDREF="dbx_chC78"Predefined dbx Variables         $procaddrIDREF="dbx_chC79"Predefined dbx Variables         $proginstsreadIDREF="dbx_chC81"Predefined dbx Variables         $prologanalysisIDREF="dbx_chC83"Predefined dbx Variables         $promptIDREF="dbx_chC84"Predefined dbx Variables         IDREF="dbx_ch230"Invoking dbx$promptonforkIDREF="dbx_ch942"Handling fork System CallsIDREF="dbx_chC86"Predefined dbx Variables         IDREF="dbx_ch941"Handling fork System CallsIDREF="dbx_ch7136"Stopping at System Calls$regstyleIDREF="dbx_ch83"RegistersIDREF="dbx_chC87"Predefined dbx Variables         $repeatmodeIDREF="dbx_ch520"Repeating CommandsIDREF="dbx_chC89"Predefined dbx Variables         IDREF="dbx_chA13"dbx Commands$rimodeIDREF="dbx_chA162"dbx CommandsIDREF="dbx_chC91"Predefined dbx Variables         IDREF="dbx_ch577"Recording Output$showbreakaddrsIDREF="dbx_chC92"Predefined dbx Variables         $stepintoallIDREF="dbx_ch7148"Stepping Using the step CommandIDREF="dbx_chC53"Predefined dbx Variables         IDREF="dbx_ch7151"Stepping Using the next CommandIDREF="dbx_ch896"Stepping Through Machine CodeIDREF="dbx_chC93"Predefined dbx Variables         $tagfileIDREF="dbx_chC96"Predefined dbx Variables         $visiblemangledIDREF="dbx_chC97"Predefined dbx Variables         $visiblestackwalkIDREF="dbx_chC98"Predefined dbx Variables         IDREF="dbx_chC15"Predefined dbx Variables         printbyte in octalIDREF="dbx_ch835"Examining Memory and Disassembling Codeword in decimalIDREF="dbx_ch833"Examining Memory and Disassembling CodeIDREF="dbx_ch834"Examining Memory and Disassembling CodeIDREF="dbx_ch826"Examining Memory and Disassembling CodeIDREF="dbx_ch829"Examining Memory and Disassembling CodeIDREF="dbx_ch827"Examining Memory and Disassembling CodeIDREF="dbx_ch831"Examining Memory and Disassembling CodeIDREF="dbx_ch832"Examining Memory and Disassembling Codeword in hexadecimalIDREF="dbx_ch830"Examining Memory and Disassembling Codeword in octalIDREF="dbx_ch828"Examining Memory and Disassembling Codeprint commandIDREF="dbx_chA143"dbx CommandsIDREF="dbx_ch57"Setting dbx VariablesIDREF="dbx_ch127"Studying a New ProgramIDREF="dbx_ch136"Studying a New ProgramIDREF="dbx_ch634"Printing ExpressionsIDREF="dbx_ch650"Displaying the Value of a Variableprint history listIDREF="dbx_ch515"Examining the History Listprint memory contentsIDREF="dbx_chA5"dbx CommandsIDREF="dbx_chA8"dbx CommandsIDREF="dbx_ch822"Examining Memory and Disassembling CodeIDREF="dbx_ch816"Examining Memory and Disassembling CodeIDREF="dbx_ch819"Examining Memory and Disassembling CodeIDREF="dbx_chA2"dbx Commands$print_exception_frameIDREF="dbx_chC75"Predefined dbx Variables         printd commandIDREF="dbx_ch635"Printing ExpressionsIDREF="dbx_chA145"dbx CommandsIDREF="dbx_ch651"Displaying the Value of a Variable$printdataIDREF="dbx_chC74"Predefined dbx Variables         printf commandIDREF="dbx_ch637"Printing ExpressionsIDREF="dbx_ch652"Displaying the Value of a VariableIDREF="dbx_chA146"dbx Commandsprinting expressionsIDREF="dbx_chA144"dbx Commandsprinting formatted expressionsIDREF="dbx_chA147"dbx CommandsIDREF="dbx_ch638"Printing Expressionsprinto commandIDREF="dbx_ch653"Displaying the Value of a VariableIDREF="dbx_chA148"dbx CommandsIDREF="dbx_ch639"Printing Expressions$printobjnameIDREF="dbx_ch27"Compiling and Linking Programs with Dynamic Shared Objects (DSOs)IDREF="dbx_chC76"Predefined dbx Variables         printregs commandIDREF="dbx_chA149"dbx Commands$printwhilestepIDREF="dbx_chC77"Predefined dbx Variables         $printwideIDREF="dbx_chC78"Predefined dbx Variables         printx commandIDREF="dbx_ch641"Printing ExpressionsIDREF="dbx_ch654"Displaying the Value of a VariableIDREF="dbx_chA151"dbx Commandsproblemsconfused listingIDREF="dbx_ch152"Avoiding Common Pitfallsinclude filesIDREF="dbx_ch156"Avoiding Common PitfallsmacrosIDREF="dbx_ch159"Avoiding Common Pitfallssource and code do not matchIDREF="dbx_ch154"Avoiding Common Pitfallsvariables do not displayIDREF="dbx_ch149"Avoiding Common Pitfalls$procaddrIDREF="dbx_chC79"Predefined dbx Variables         procedures, tracingIDREF="dbx_ch146"Studying a New Programprocess group listadding processesIDREF="dbx_chA33"dbx CommandsIDREF="dbx_ch955"Process Group DebuggingIDREF="dbx_ch957"Process Group Debuggingdeleting processesIDREF="dbx_chA76"dbx CommandsIDREF="dbx_ch959"Process Group Debuggingshowing processesIDREF="dbx_chA195"dbx CommandsIDREF="dbx_ch961"Process Group Debuggingprocess groupsbreakpointsIDREF="dbx_ch964"Process Group Debugginggroup historyIDREF="dbx_ch966"Process Group DebuggingtracingIDREF="dbx_ch965"Process Group Debuggingprocess identification number (PID)IDREF="dbx_ch95"Processesprocess poolIDREF="dbx_ch94"Processesadd processesIDREF="dbx_chA35"dbx Commandsdelete processesIDREF="dbx_chA78"dbx Commandsdisplay active processIDREF="dbx_chA30"dbx CommandsIDREF="dbx_ch917"Selecting a Processdisplay processesIDREF="dbx_chA197"dbx CommandsIDREF="dbx_ch910"Listing Available Processeskill active processIDREF="dbx_ch937"Killing a ProcessIDREF="dbx_chA125"dbx Commandskill processesIDREF="dbx_chA127"dbx CommandsIDREF="dbx_ch939"Killing a Processresume active processIDREF="dbx_chA170"dbx CommandsIDREF="dbx_ch924"Resuming a Suspended ProcessIDREF="dbx_chA174"dbx Commandsresume processesIDREF="dbx_chA172"dbx CommandsIDREF="dbx_chA177"dbx CommandsIDREF="dbx_ch927"Resuming a Suspended Processselect active processIDREF="dbx_chA29"dbx CommandsIDREF="dbx_ch916"Selecting a Processsuspend active processIDREF="dbx_ch919"Suspending a Processsuspend processesIDREF="dbx_ch921"Suspending a ProcessIDREF="dbx_chA264"dbx Commandsprocesseswait forIDREF="dbx_ch933"Waiting for a Resumed ProcessIDREF="dbx_chA315"dbx CommandsIDREF="dbx_ch931"Waiting for a Resumed ProcessIDREF="dbx_chA313"dbx CommandsIDREF="dbx_chA311"dbx Commands$proginstsreadIDREF="dbx_chC81"Predefined dbx Variables          program variables, see variables, programIDREF="dbx_ch62"Expressionsprogram variables, see variables, programIDREF="dbx_ch119"Debugging Your Programs$prologanalysisIDREF="dbx_chC83"Predefined dbx Variables         $promptIDREF="dbx_chC84"Predefined dbx Variables         IDREF="dbx_ch230"Invoking dbxpromptIDREF="dbx_ch229"Invoking dbxIDREF="dbx_chC85"Predefined dbx Variables         $promptonforkIDREF="dbx_ch941"Handling fork System CallsIDREF="dbx_ch942"Handling fork System CallsIDREF="dbx_chC86"Predefined dbx Variables         IDREF="dbx_ch7136"Stopping at System CallspxIDREF="dbx_chB24"Predefined AliasesIDREF="dbx_ch642"Printing ExpressionsIDREF="dbx_ch657"Displaying the Value of a VariableqIDREF="dbx_chB25"Predefined Aliasesqualifying program variable namesIDREF="dbx_ch760"Tracing Program ExecutionIDREF="dbx_ch676"Examining the Stackquit commandIDREF="dbx_chA152"dbx CommandsIDREF="dbx_ch242"Quitting dbxquitting dbxIDREF="dbx_chA153"dbx CommandsrIDREF="dbx_chB26"Predefined Aliasesrecord commandIDREF="dbx_chA154"dbx Commandsrecord input commandIDREF="dbx_ch584"Examining the Record StateIDREF="dbx_chC27"Predefined dbx Variables         IDREF="dbx_ch573"Playing Back InputIDREF="dbx_ch559"Recording InputIDREF="dbx_chA156"dbx Commandsrecord output commandIDREF="dbx_chC1"Predefined dbx Variables         IDREF="dbx_ch576"Recording OutputIDREF="dbx_chC29"Predefined dbx Variables         IDREF="dbx_chA159"dbx CommandsIDREF="dbx_ch585"Examining the Record Staterecording inputIDREF="dbx_ch555"Recording and Playing Back dbx Input and OutputIDREF="dbx_chA157"dbx Commandsrecording outputIDREF="dbx_chA160"dbx CommandsIDREF="dbx_ch556"Recording and Playing Back dbx Input and Outputrecording, displaying sessionsIDREF="dbx_chA155"dbx CommandsIDREF="dbx_ch583"Examining the Record Staterecording, endingIDREF="dbx_chA301"dbx CommandsIDREF="dbx_ch568"Ending a Recording SessionIDREF="dbx_chA303"dbx CommandsIDREF="dbx_ch566"Ending a Recording Sessionregister namesIDREF="dbx_ch82"RegistersIDREF="dbx_chC88"Predefined dbx Variables         registerschanging valuesIDREF="dbx_ch814"Changing Register ValuesIDREF="dbx_chA47"dbx Commandsprinting valuesIDREF="dbx_ch86"Printing Register ValuesIDREF="dbx_chA150"dbx Commandsusing values in expressionsIDREF="dbx_ch811"Printing Register Values$regstyleIDREF="dbx_chC87"Predefined dbx Variables         IDREF="dbx_ch83"Registersremoving dbx variablesIDREF="dbx_chA305"dbx Commandsrepeating commandsIDREF="dbx_chA19"dbx CommandsIDREF="dbx_chA12"dbx CommandsIDREF="dbx_ch513"The History FeatureIDREF="dbx_chC90"Predefined dbx Variables         IDREF="dbx_chA15"dbx CommandsIDREF="dbx_chA17"dbx Commands$repeatmodeIDREF="dbx_chC89"Predefined dbx Variables         IDREF="dbx_ch520"Repeating CommandsIDREF="dbx_chA13"dbx Commandsrerun commandIDREF="dbx_chA163"dbx CommandsIDREF="dbx_ch312"Running Your ProgramIDREF="dbx_ch118"Debugging Your ProgramsIDREF="dbx_ch134"Studying a New ProgramIDREF="dbx_ch126"Studying a New ProgramIDREF="dbx_ch37"Running Your Programresume active processIDREF="dbx_chA170"dbx CommandsIDREF="dbx_ch924"Resuming a Suspended ProcessIDREF="dbx_chA174"dbx Commandsresume commandIDREF="dbx_chA171"dbx CommandsIDREF="dbx_ch946"Handling exec System CallsIDREF="dbx_chA173"dbx CommandsIDREF="dbx_ch743"Continuing Execution after a BreakpointIDREF="dbx_ch926"Resuming a Suspended ProcessIDREF="dbx_chA176"dbx CommandsIDREF="dbx_ch923"Resuming a Suspended ProcessIDREF="dbx_ch6103"Interactive Function CallsIDREF="dbx_chA169"dbx Commandsresume process in process poolIDREF="dbx_chA177"dbx CommandsIDREF="dbx_ch927"Resuming a Suspended ProcessIDREF="dbx_chA172"dbx Commandsreturn commandIDREF="dbx_chA179"dbx CommandsIDREF="dbx_chA180"dbx CommandsIDREF="dbx_ch7144"Using the return CommandriIDREF="dbx_chB27"Predefined Aliases$rimodeIDREF="dbx_chC91"Predefined dbx Variables         IDREF="dbx_chA162"dbx CommandsIDREF="dbx_ch577"Recording Output rld IDREF="dbx_ch318"Programs Linked with DSOsroIDREF="dbx_chB28"Predefined Aliasesrun commandIDREF="dbx_chA168"dbx CommandsIDREF="dbx_ch117"Debugging Your ProgramsIDREF="dbx_ch125"Studying a New ProgramIDREF="dbx_ch133"Studying a New ProgramIDREF="dbx_ch36"Running Your ProgramIDREF="dbx_chA181"dbx CommandsIDREF="dbx_ch38"Running Your Programrunning a programIDREF="dbx_ch135"Studying a New Programrunning process, wait forIDREF="dbx_chA315"dbx Commandsrunning programsIDREF="dbx_chA182"dbx CommandsIDREF="dbx_ch217"Invoking dbxIDREF="dbx_chA164"dbx CommandsIDREF="dbx_ch313"Running Your ProgramsIDREF="dbx_chB29"Predefined AliasesIDREF="dbx_chB30"Predefined Aliasesscope of program variablesIDREF="dbx_ch690"Moving to a Specified ProcedureIDREF="dbx_ch684"Moving Within the StackIDREF="dbx_ch675"Examining the Stacksearch backward (?) commandIDREF="dbx_ch426"Searching Through Source CodeIDREF="dbx_chA25"dbx CommandsIDREF="dbx_ch423"Searching Through Source Codesearch forward (/) commandIDREF="dbx_ch424"Searching Through Source CodeIDREF="dbx_ch422"Searching Through Source CodeIDREF="dbx_chA22"dbx Commandssearching source codeIDREF="dbx_chA23"dbx CommandsIDREF="dbx_chA26"dbx Commandsselect active process from process poolIDREF="dbx_ch916"Selecting a ProcessIDREF="dbx_chA29"dbx Commandssending signalsIDREF="dbx_ch869"Continuing Execution after a Machine-level BreakpointIDREF="dbx_ch925"Resuming a Suspended ProcessIDREF="dbx_chA175"dbx CommandsIDREF="dbx_ch741"Continuing Execution after a BreakpointIDREF="dbx_chA178"dbx CommandsIDREF="dbx_ch928"Resuming a Suspended Processset commandIDREF="dbx_ch55"Setting dbx VariablesIDREF="dbx_ch54"Setting dbx VariablesIDREF="dbx_ch630"String ConstantsIDREF="dbx_chA186"dbx CommandsIDREF="dbx_chA188"dbx CommandsIDREF="dbx_ch59"Listing dbx Variablessetting breakpointsIDREF="dbx_ch116"Debugging Your Programssetting dbx variablesIDREF="dbx_chA189"dbx CommandsIDREF="dbx_ch56"Setting dbx Variablessetting unconditional breakpointsIDREF="dbx_chA212"dbx CommandsIDREF="dbx_chA214"dbx CommandsIDREF="dbx_chA216"dbx Commandssh commandIDREF="dbx_chA190"dbx CommandsIDREF="dbx_ch239"Invoking a ShellIDREF="dbx_chA192"dbx Commandsshell command, executingIDREF="dbx_ch240"Invoking a ShellIDREF="dbx_chA193"dbx Commandsshell, invoking from dbxIDREF="dbx_chA191"dbx Commands$showbreakaddrsIDREF="dbx_chC92"Predefined dbx Variables         showing processes in the process group listIDREF="dbx_chA195"dbx CommandsIDREF="dbx_ch961"Process Group Debuggingshowpgrp commandIDREF="dbx_chA194"dbx CommandsIDREF="dbx_ch962"Process Group Debuggingshowproc commandIDREF="dbx_ch99"Listing Available ProcessesIDREF="dbx_chA196"dbx CommandsSiIDREF="dbx_chB32"Predefined AliasesIDREF="dbx_chB31"Predefined AliasessignalscatchingIDREF="dbx_ch7109"Catching and Ignoring SignalsIDREF="dbx_chA53"dbx Commandscontinuing after catchingIDREF="dbx_ch7121"Continuing after Catching a SignalIDREF="dbx_ch7117"Continuing after Catching a SignalIDREF="dbx_ch7119"Continuing after Catching a Signaldisplaying caughtIDREF="dbx_chA51"dbx CommandsIDREF="dbx_ch7112"Catching and Ignoring Signalsdisplaying ignoredIDREF="dbx_chA121"dbx CommandsIDREF="dbx_ch7114"Catching and Ignoring SignalsignoringIDREF="dbx_ch7111"Catching and Ignoring SignalsIDREF="dbx_chA123"dbx CommandssendingIDREF="dbx_chA175"dbx CommandsIDREF="dbx_chA178"dbx CommandsIDREF="dbx_ch928"Resuming a Suspended ProcessIDREF="dbx_ch741"Continuing Execution after a BreakpointIDREF="dbx_ch869"Continuing Execution after a Machine-level BreakpointIDREF="dbx_ch925"Resuming a Suspended Processsingle-steppingIDREF="dbx_ch139"Studying a New ProgramIDREF="dbx_chA204"dbx CommandsIDREF="dbx_ch141"Studying a New ProgramIDREF="dbx_chA136"dbx CommandssourceIDREF="dbx_ch561"Recording InputIDREF="dbx_ch572"Playing Back InputIDREF="dbx_ch587"Executing dbx ScriptsIDREF="dbx_chB33"Predefined AliasesIDREF="dbx_chA198"dbx Commandssource and code do not matchIDREF="dbx_ch154"Avoiding Common Pitfallssource codesearchingIDREF="dbx_chA23"dbx CommandsIDREF="dbx_chA26"dbx Commandssource directoriesspecifyingIDREF="dbx_chA80"dbx CommandsIDREF="dbx_ch410"Specifying Source Directories with dbx CommandsIDREF="dbx_ch412"Specifying Source Directories with dbx CommandsIDREF="dbx_chA309"dbx Commandssource fileseditingIDREF="dbx_chA93"dbx CommandsIDREF="dbx_ch429"Calling an EditorspecifyingIDREF="dbx_chA102"dbx CommandsIDREF="dbx_chA309"dbx CommandsIDREF="dbx_ch414"Changing Source FilesIDREF="dbx_ch410"Specifying Source Directories with dbx CommandsIDREF="dbx_chA80"dbx CommandsIDREF="dbx_ch29"Invoking dbxIDREF="dbx_ch412"Specifying Source Directories with dbx Commandssource lines, tracingIDREF="dbx_ch147"Studying a New ProgramsprocIDREF="dbx_ch943"Handling fork System CallsIDREF="dbx_ch7135"Stopping at System CallsIDREF="dbx_ch949"Process Group DebuggingIDREF="dbx_chC9"Predefined dbx Variables         IDREF="dbx_ch93"ProcessesIDREF="dbx_ch953"Process Group DebuggingIDREF="dbx_chC11"Predefined dbx Variables         stackexaminingIDREF="dbx_ch120"Debugging Your ProgramstraceIDREF="dbx_chA345"dbx Commandsstack traceIDREF="dbx_ch17"Examining Core Dumps to Determine Cause of Failurestandard errorIDREF="dbx_chA185"dbx CommandsIDREF="dbx_chA167"dbx CommandsIDREF="dbx_ch316"Running Your ProgramIDREF="dbx_ch311"Running Your Programstandard inputIDREF="dbx_ch314"Running Your ProgramIDREF="dbx_chA165"dbx CommandsIDREF="dbx_ch39"Running Your ProgramIDREF="dbx_chA183"dbx Commandsstandard outputIDREF="dbx_chA184"dbx CommandsIDREF="dbx_ch315"Running Your ProgramIDREF="dbx_ch310"Running Your ProgramIDREF="dbx_chA166"dbx Commandsstatus commandIDREF="dbx_ch569"Ending a Recording SessionIDREF="dbx_chA199"dbx Commandsstep commandIDREF="dbx_ch7145"Stepping Using the step CommandIDREF="dbx_ch129"Studying a New ProgramIDREF="dbx_ch138"Studying a New ProgramIDREF="dbx_chA203"dbx CommandsIDREF="dbx_chC94"Predefined dbx Variables         IDREF="dbx_ch6105"Interactive Function CallsIDREF="dbx_ch7141"Stepping Through Your Programstepb commandIDREF="dbx_chA205"dbx CommandsIDREF="dbx_chA206"dbx CommandsIDREF="dbx_ch893"Stepping Through Machine CodeIDREF="dbx_ch892"Stepping Through Machine Codestepi commandIDREF="dbx_ch887"Stepping Through Machine CodeIDREF="dbx_ch890"Stepping Through Machine CodeIDREF="dbx_chA207"dbx CommandsIDREF="dbx_chA208"dbx CommandsIDREF="dbx_ch891"Stepping Through Machine Code$stepintoallIDREF="dbx_ch896"Stepping Through Machine CodeIDREF="dbx_ch7148"Stepping Using the step CommandIDREF="dbx_ch7151"Stepping Using the next CommandIDREF="dbx_chC53"Predefined dbx Variables         IDREF="dbx_chC93"Predefined dbx Variables         stepj commandIDREF="dbx_chA209"dbx CommandsIDREF="dbx_chA210"dbx CommandsIDREF="dbx_ch894"Stepping Through Machine CodeIDREF="dbx_ch895"Stepping Through Machine Codestop commandIDREF="dbx_ch730"Conditional Breakpoints Combining Variable and Test ClausesIDREF="dbx_ch732"Conditional Breakpoints Combining Variable and Test ClausesIDREF="dbx_ch115"Debugging Your ProgramsIDREF="dbx_ch124"Studying a New ProgramIDREF="dbx_ch131"Studying a New ProgramIDREF="dbx_ch78"Setting Unconditional BreakpointsIDREF="dbx_ch79"Setting Unconditional BreakpointsIDREF="dbx_ch710"Setting Unconditional BreakpointsIDREF="dbx_ch713"Stopping if a Variable or Memory Location has ChangedIDREF="dbx_ch715"Stopping if a Variable or Memory Location has ChangedIDREF="dbx_chA211"dbx CommandsIDREF="dbx_ch717"Stopping if a Variable or Memory Location has ChangedIDREF="dbx_chA213"dbx CommandsIDREF="dbx_ch720"Stopping If a Test Expression is TrueIDREF="dbx_chA215"dbx CommandsIDREF="dbx_ch722"Stopping If a Test Expression is TrueIDREF="dbx_chA217"dbx CommandsIDREF="dbx_chA219"dbx CommandsIDREF="dbx_chA221"dbx CommandsIDREF="dbx_chA223"dbx CommandsIDREF="dbx_chA224"dbx CommandsIDREF="dbx_chA225"dbx CommandsIDREF="dbx_chA226"dbx CommandsIDREF="dbx_chA228"dbx CommandsIDREF="dbx_chA230"dbx CommandsIDREF="dbx_ch724"Stopping If a Test Expression is TrueIDREF="dbx_ch728"Conditional Breakpoints Combining Variable and Test Clausesstopi commandIDREF="dbx_ch853"Syntax of the stopi CommandIDREF="dbx_ch855"Syntax of the stopi CommandIDREF="dbx_ch857"Syntax of the stopi CommandIDREF="dbx_ch859"Syntax of the stopi CommandIDREF="dbx_ch861"Syntax of the stopi CommandIDREF="dbx_ch863"Syntax of the stopi CommandIDREF="dbx_ch837"Setting Machine-level BreakpointsIDREF="dbx_ch841"Syntax of the stopi CommandIDREF="dbx_ch843"Syntax of the stopi CommandIDREF="dbx_ch845"Syntax of the stopi CommandIDREF="dbx_ch847"Syntax of the stopi CommandIDREF="dbx_ch849"Syntax of the stopi CommandIDREF="dbx_chA232"dbx CommandsIDREF="dbx_chA234"dbx CommandsIDREF="dbx_chA236"dbx CommandsIDREF="dbx_chA238"dbx CommandsIDREF="dbx_chA241"dbx CommandsIDREF="dbx_chA244"dbx CommandsIDREF="dbx_chA247"dbx CommandsIDREF="dbx_chA249"dbx CommandsIDREF="dbx_chA251"dbx CommandsIDREF="dbx_chA253"dbx CommandsIDREF="dbx_chA256"dbx CommandsIDREF="dbx_chA259"dbx CommandsIDREF="dbx_ch851"Syntax of the stopi Commandstring constantsIDREF="dbx_ch613"Constantsescape sequencesIDREF="dbx_ch632"String Constantsstripped symbol tableIDREF="dbx_ch110"Examining Core Dumps to Determine Cause of Failuresuspend active processIDREF="dbx_ch919"Suspending a Processsuspend commandIDREF="dbx_ch918"Suspending a ProcessIDREF="dbx_chA262"dbx CommandsIDREF="dbx_chA263"dbx CommandsIDREF="dbx_ch920"Suspending a Processsuspend process in process poolIDREF="dbx_ch921"Suspending a ProcessIDREF="dbx_chA264"dbx Commandssymbol tableinformationIDREF="dbx_ch23"Compiling a Program for Debugging under dbxstrippedIDREF="dbx_ch110"Examining Core Dumps to Determine Cause of Failuresyscall commandIDREF="dbx_chA266"dbx CommandsIDREF="dbx_ch7138"Stopping at System CallsIDREF="dbx_chA268"dbx CommandsIDREF="dbx_ch7131"Stopping at System CallsIDREF="dbx_chA270"dbx CommandsIDREF="dbx_ch7127"Stopping at System CallsIDREF="dbx_chA272"dbx CommandsIDREF="dbx_ch7125"Stopping at System CallsIDREF="dbx_ch7129"Stopping at System CallsIDREF="dbx_ch7123"Stopping at System CallsIDREF="dbx_chA265"dbx Commandssystem callscatchingIDREF="dbx_chA271"dbx CommandsIDREF="dbx_ch7124"Stopping at System Callsdisplaying caughtIDREF="dbx_ch7128"Stopping at System CallsIDREF="dbx_chA267"dbx Commandsdisplaying ignoredIDREF="dbx_chA269"dbx CommandsIDREF="dbx_ch7130"Stopping at System CallsexecIDREF="dbx_ch7132"Stopping at System CallsIDREF="dbx_ch321"Programs Linked with Non-shared LibrariesexecveIDREF="dbx_ch7133"Stopping at System CallsexitIDREF="dbx_ch7139"Stopping at System CallsforkIDREF="dbx_ch7134"Stopping at System CallsIDREF="dbx_chC8"Predefined dbx Variables         IDREF="dbx_ch954"Process Group DebuggingIDREF="dbx_chC10"Predefined dbx Variables         ignoringIDREF="dbx_ch7126"Stopping at System CallsIDREF="dbx_chA273"dbx CommandssprocIDREF="dbx_ch943"Handling fork System CallsIDREF="dbx_ch949"Process Group DebuggingIDREF="dbx_chC9"Predefined dbx Variables         IDREF="dbx_chC11"Predefined dbx Variables         IDREF="dbx_ch953"Process Group DebuggingIDREF="dbx_ch93"ProcessesIDREF="dbx_ch7135"Stopping at System CallstIDREF="dbx_chB34"Predefined Aliases$tagfileIDREF="dbx_chC96"Predefined dbx Variables         trace commandIDREF="dbx_ch752"Tracing Program ExecutionIDREF="dbx_chA284"dbx CommandsIDREF="dbx_ch144"Studying a New ProgramIDREF="dbx_ch754"Tracing Program ExecutionIDREF="dbx_chA274"dbx CommandsIDREF="dbx_ch750"Tracing Program ExecutionIDREF="dbx_chC50"Predefined dbx Variables         IDREF="dbx_chA276"dbx CommandsIDREF="dbx_ch756"Tracing Program ExecutionIDREF="dbx_chA278"dbx CommandsIDREF="dbx_ch748"Tracing Program ExecutionIDREF="dbx_chA280"dbx CommandsIDREF="dbx_ch758"Tracing Program ExecutionIDREF="dbx_chA282"dbx Commandstracei commandIDREF="dbx_chA296"dbx CommandsIDREF="dbx_ch882"Tracing Execution at the Machine LevelIDREF="dbx_ch883"Tracing Execution at the Machine LevelIDREF="dbx_chA286"dbx CommandsIDREF="dbx_ch877"Tracing Execution at the Machine LevelIDREF="dbx_chA288"dbx CommandsIDREF="dbx_ch878"Tracing Execution at the Machine LevelIDREF="dbx_chA290"dbx CommandsIDREF="dbx_ch879"Tracing Execution at the Machine LevelIDREF="dbx_chA292"dbx CommandsIDREF="dbx_ch880"Tracing Execution at the Machine LevelIDREF="dbx_chA294"dbx CommandsIDREF="dbx_ch881"Tracing Execution at the Machine LeveltracingdeletingIDREF="dbx_chA73"dbx CommandsIDREF="dbx_ch7106"Deleting Breakpoints, Traces, and Conditional CommandsdisablingIDREF="dbx_ch795"Disabling Breakpoints, Traces, and Conditional CommandsIDREF="dbx_chA83"dbx CommandsenablingIDREF="dbx_chA98"dbx CommandsIDREF="dbx_ch7101"Enabling Breakpoints, Traces, and Conditional CommandsproceduresIDREF="dbx_ch751"Tracing Program ExecutionIDREF="dbx_ch146"Studying a New ProgramIDREF="dbx_chA289"dbx CommandsIDREF="dbx_chA277"dbx Commandsprocess groupsIDREF="dbx_ch965"Process Group Debuggingsource linesIDREF="dbx_ch147"Studying a New ProgramstatusIDREF="dbx_ch789"Listing Breakpoints, Traces, and Conditional CommandsIDREF="dbx_chA201"dbx CommandsvariablesIDREF="dbx_chA283"dbx CommandsIDREF="dbx_chA285"dbx CommandsIDREF="dbx_chA287"dbx CommandsIDREF="dbx_chA291"dbx CommandsIDREF="dbx_chA293"dbx CommandsIDREF="dbx_chA295"dbx CommandsIDREF="dbx_chA297"dbx CommandsIDREF="dbx_ch755"Tracing Program ExecutionIDREF="dbx_ch757"Tracing Program ExecutionIDREF="dbx_ch759"Tracing Program ExecutionIDREF="dbx_ch145"Studying a New ProgramIDREF="dbx_ch749"Tracing Program ExecutionIDREF="dbx_ch753"Tracing Program ExecutionIDREF="dbx_chA275"dbx CommandsIDREF="dbx_chA279"dbx CommandsIDREF="dbx_chA281"dbx Commandstype castingIDREF="dbx_ch644"Data Types and Type Coercion (Casts)type declarations of program variable namesIDREF="dbx_chA317"dbx CommandsuIDREF="dbx_chB35"Predefined Aliasesunalias commandIDREF="dbx_ch551"Removing Command AliasesIDREF="dbx_chB3"Predefined AliasesIDREF="dbx_chA298"dbx Commandsunconditional breakpointsIDREF="dbx_ch114"Debugging Your ProgramsIDREF="dbx_ch72"BreakpointsIDREF="dbx_ch113"Debugging Your ProgramssettingIDREF="dbx_chA214"dbx CommandsIDREF="dbx_chA216"dbx CommandsIDREF="dbx_chA212"dbx Commandsunrecord commandIDREF="dbx_chA302"dbx CommandsIDREF="dbx_ch565"Ending a Recording SessionIDREF="dbx_ch567"Ending a Recording SessionIDREF="dbx_ch564"Ending a Recording SessionIDREF="dbx_chA300"dbx Commandsunset commandIDREF="dbx_chA304"dbx CommandsIDREF="dbx_ch511"Removing Variablesunstacking interactive function callsIDREF="dbx_ch6101"Interactive Function Callsup commandIDREF="dbx_chA306"dbx Commandsuse commandIDREF="dbx_ch48"Specifying Source Directories with dbx CommandsIDREF="dbx_ch411"Specifying Source Directories with dbx CommandsIDREF="dbx_chA308"dbx CommandsIDREF="dbx_ch210"Invoking dbxvariable namesC++IDREF="dbx_ch228"Invoking dbxvariables do not displayIDREF="dbx_ch149"Avoiding Common Pitfallsvariables, programIDREF="dbx_ch62"Expressionscase sensitivityIDREF="dbx_chC17"Predefined dbx Variables         changing valuesIDREF="dbx_chA49"dbx Commandsdetermining scopeIDREF="dbx_chA347"dbx CommandsIDREF="dbx_chA349"dbx CommandsexaminingIDREF="dbx_ch137"Studying a New ProgramIDREF="dbx_ch119"Debugging Your Programsexamining arraysIDREF="dbx_ch658"Displaying the Value of a Variablenames and C keyword conflictsIDREF="dbx_chC20"Predefined dbx Variables         IDREF="dbx_ch664"Conflicts Between Variable Names and Keywordsqualifying variable namesIDREF="dbx_ch760"Tracing Program ExecutionIDREF="dbx_ch676"Examining the StackscopeIDREF="dbx_ch690"Moving to a Specified ProcedureIDREF="dbx_ch675"Examining the StackIDREF="dbx_ch647"Qualifying Variable NamesIDREF="dbx_ch684"Moving Within the StacktracingIDREF="dbx_ch145"Studying a New Programtype declarationsIDREF="dbx_chA317"dbx Commands$visiblemangledIDREF="dbx_chC97"Predefined dbx Variables         $visiblestackwalkIDREF="dbx_chC15"Predefined dbx Variables         IDREF="dbx_chC98"Predefined dbx Variables         WIDREF="dbx_chB37"Predefined AliasesIDREF="dbx_chB36"Predefined Aliaseswait commandIDREF="dbx_chA310"dbx CommandsIDREF="dbx_ch930"Waiting for a Resumed ProcessIDREF="dbx_chA312"dbx CommandsIDREF="dbx_ch932"Waiting for a Resumed Processwait for active processIDREF="dbx_chA311"dbx CommandsIDREF="dbx_ch931"Waiting for a Resumed Processwait for processIDREF="dbx_ch933"Waiting for a Resumed ProcessIDREF="dbx_chA313"dbx Commandswait for running processIDREF="dbx_chA315"dbx Commandswaitall commandIDREF="dbx_chA314"dbx CommandsIDREF="dbx_ch935"Waiting for Any Running Processwhatis commandIDREF="dbx_ch672"Displaying Type DeclarationsIDREF="dbx_chA316"dbx Commandswhen commandIDREF="dbx_chA330"dbx CommandsIDREF="dbx_chA333"dbx CommandsIDREF="dbx_chA336"dbx CommandsIDREF="dbx_ch770"Writing Conditional CommandsIDREF="dbx_ch772"Writing Conditional CommandsIDREF="dbx_ch774"Writing Conditional CommandsIDREF="dbx_ch776"Writing Conditional CommandsIDREF="dbx_ch778"Writing Conditional CommandsIDREF="dbx_ch781"Writing Conditional CommandsIDREF="dbx_ch784"Writing Conditional CommandsIDREF="dbx_ch766"Writing Conditional CommandsIDREF="dbx_ch768"Writing Conditional CommandsIDREF="dbx_chA318"dbx CommandsIDREF="dbx_chA320"dbx CommandsIDREF="dbx_chA322"dbx CommandsIDREF="dbx_chA324"dbx CommandsIDREF="dbx_chA326"dbx CommandsIDREF="dbx_chA328"dbx Commandswheni commandIDREF="dbx_chA342"dbx CommandsIDREF="dbx_chA343"dbx CommandsIDREF="dbx_ch885"Writing Conditional Commands at the Machine LevelIDREF="dbx_chA339"dbx CommandsIDREF="dbx_chA340"dbx CommandsIDREF="dbx_chA341"dbx Commandswhere commandIDREF="dbx_chA344"dbx CommandsIDREF="dbx_ch18"Examining Core Dumps to Determine Cause of FailureIDREF="dbx_ch678"Printing Stack TracesIDREF="dbx_ch865"Syntax of the stopi Commandwhereis commandIDREF="dbx_ch670"Determining the Scope of VariablesIDREF="dbx_chA346"dbx Commandswhich commandIDREF="dbx_chA348"dbx CommandsIDREF="dbx_ch669"Determining the Scope of Variableswhichobj commandIDREF="dbx_ch26"Compiling and Linking Programs with Dynamic Shared Objects (DSOs)IDREF="dbx_chA350"dbx CommandswiIDREF="dbx_chB38"Predefined Aliases