#EDIR DATA#
LANG=COpenGL Reference ManualThe Official Reference Document for OpenGL, Release 1OpenGL Architecture Review BoardAddison-Wesley Publishing CompanyReading, Massachusetts Menlo Park, California New York Don Mills, Ontario Wokingham, England Amsterdam Bonn Sydney Singapore Tokyo Madrid San Juan Paris Seoul Milan Mexico City TaipeiSilicon Graphics is a registered trademark and OpenGL and Graphics Library are trademarks of Silicon Graphics, Inc. X Window System is a trademark of Massachusetts Institute of Technology. The authors and publishers have taken care in preparation of this book, but make no expressed or implied warranty of any kind and assume no responsibility for errors or omissions. No liability is assumed for incidental or consequential damages in connection with or arising out of the use of the information or programs contained herein.Copyright © 1994 by Silicon Graphics, Inc. All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form or by any means, electronic, mechanical, photocopying, recording or otherwise, without the prior written permission of the publisher. Printed in the United States of America. Published simultaneously in Canada.Sponsoring Editor: David RogelbergProject Editor: Joanne Clapp FullagarCover Image: Thad BeierCover Design: Jean SealText Design: Electric Ink, Ltd., and Kay MaitzSet in 10-point Stone SerifISBN 0-201-63276-4First Printing, November 1992123456789-AL-9695949392PrefaceOpenGL‘ (GL for Graphics Library‘) is a software interface to graphics hardware. This interface consists of several hundred functions that allow you, a graphics programmer, to specify the objects and operations needed to produce high-quality color images of three-dimensional objects. Many of these functions are actually simple variations of each other, so in reality there are only 120 substantially different functions. As complements to the core set of OpenGL functions, the OpenGL Utility Library (GLU) and the OpenGL Extension to the X Window System‘ (GLX) provide useful supporting features. This manual explains what all these functions do; it has the following chapters:IDREF="60402" TYPE="TITLE"Chapter 1, "Introduction to OpenGL," provides a brief statement of the major underlying concepts embodied in OpenGL. It uses a high-level block diagram to discuss in conceptual terms all the major stages of processing performed by OpenGL. IDREF="51876" TYPE="TITLE"Chapter 2, "Overview of Commands and Routines," describes in more detail how input data (in the form of vertices specifying a geometric object or pixels defining an image) is processed and how you can control this processing using the functions that comprise OpenGL. Functions belonging to GLU and GLX are also discussed. IDREF="67537" TYPE="TITLE"Chapter 3, "Summary of Commands and Routines," lists the OpenGL commands in groups according to what sort of tasks they perform. Full prototypes are given so that you can use this section as a quick reference once you understand what the commands accomplish. IDREF="68318" TYPE="TITLE"Chapter 4, "Defined Constants and Associated Commands," lists the constants defined in OpenGL and the commands that use them.IDREF="14044" TYPE="TITLE"Chapter 5, "OpenGL Reference Pages," which forms the bulk of this manual, contains descriptions of each set of related OpenGL commands. (Commands with parameters that differ only in data type are described together, for example.) Each reference page fully describes the relevant parameters, the effect of the commands, and what errors might be generated by using the commands. IDREF="10211" TYPE="TITLE"Chapter 6, "GLU Reference Pages," contains the reference pages for all the GLU routines.IDREF="45928" TYPE="TITLE"Chapter 7, "GLX Reference Pages,"contains the reference pages for the GLX routines.LBL="" HELPID=""What You Should Know Before Reading This ManualThis manual is designed to be used as the companion reference volume to the OpenGL Programming Guide by Jackie Neider, Tom Davis, and Mason Woo (Reading, MA: Addison-Wesley Publishing Company). The focus of this Reference Manual is how OpenGL works, while the Programming Guide's focus is how to use OpenGL. For a complete understanding of OpenGL, you need both types of information. Another difference between these two books is that most of the content of this Reference Manual is organized alphabetically, based on the assumption that you know what you don't know and therefore need only to look up a description of a particular command; the Programming Guide is organized like a tutorialname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'it explains the simpler OpenGL concepts first and builds up to the more complex ones. Although the command descriptions in this manual don't necessarily require you to have read the Programming Guide, your understanding of the intended usage of the commands will be much more complete if you have read it. Both books also assume that you know how to program in C. If you don't have much of a computer graphics background, you should certainly start with the Programming Guide rather than this Reference Manual. Basic graphics concepts are not explained in this manual. You might also want to look at Computer Graphics: Principles and Practice by James D. Foley, Andries van Dam, Steven K. Feiner, and John F. Hughes (Reading, MA: Addison-Wesley Publishing Company). That book is an encyclopedic treatment of the field of computer graphics. Another, gentler introduction to the subject can be found in 3D Computer Graphics: A User's Guide for Artists and Designers by Andrew S. Glassner (New York: Design Press).LBL="" HELPID=""AcknowledgmentsThis manual owes its existence to many people. Kurt Akeley of Silicon GraphicsÆ, Sally Browning of SABL Productions, and Kevin P. Smith also of Silicon Graphics wrote most of the material, with contributions from Jackie Neider and Mark Segal (both from Silicon Graphics). The OpenGL Graphics System: A Specification (coauthored by Mark and Kurt), The OpenGL Graphics System Utility Library (written by Kevin), and OpenGL Graphics with the X Window System (written by Phil Karlton) served as source documents for the authors. Phil Karlton and Kipp Hickman assisted by helping to define and create OpenGL at Silicon Graphics, with help from Raymond Drewry of Gain Technology, Inc., Fred Fisher of Digital Equipment Corp., and Randi Rost of Kubota Pacific Computer, Inc. The members of the OpenGL Architecture Review Boardname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Murray Cantor and Linas Vepstas from International Business Machines, Paula Womack and Jeff Lane of Digital Equipment Corporation, Murali Sundaresan of Intel, and Chuck Whitmer of Microsoftname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'also contributed. Thad Beier together with Seth Katz and the Inventor team at Silicon Graphics created the cover image. Kay Maitz of Silicon Graphics, Arthur Evans of Evans Technical Communications, and Susan Blau provided production assistance; Tanya Kucak copyedited the manual. Finally, this book wouldn't exist unless OpenGL did, for which all the members of the OpenGL team at Silicon Graphics, Inc., need to be thanked for their efforts: Momi Akeley, Allen Akin, Chris Frazier, Bill Glazier, Paul Ho, Simon Hui, Lesley Kalmin, Pierre Tardif, Jim Winget, and especially Wei Yen, in addition to the previously mentioned Kurt, Phil, Mark, Kipp, and Kevin. Many other Silicon Graphics employees, who are too numerous to mention, helped refine the definition and functionality of OpenGL. LBL="1"ID="60402"Introduction to OpenGLAs a software interface for graphics hardware, OpenGL's main purpose is to render two- and three-dimensional objects into a frame buffer. These objects are described as sequences of vertices (which define geometric objects) or pixels (which define images). OpenGL performs several processing steps on this data to convert it to pixels to form the final desired image in the frame buffer. This chapter presents a global view of how OpenGL works; it contains the following major sections:IDREF="32221" TYPE="TITLE""OpenGL Fundamentals" briefly explains basic OpenGL concepts, such as what a graphic primitive is and how OpenGL implements a client-server execution model.IDREF="27075" TYPE="TITLE""Basic OpenGL Operation" gives a high-level description of how OpenGL processes data and produces a corresponding image in the frame buffer.LBL="" HELPID=""ID="32221"OpenGL FundamentalsThis section explains some of the concepts inherent in OpenGL.LBL="" HELPID=""Primitives and CommandsOpenGL draws 
primitivesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'points, line segments, or polygonsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'subject to several selectable modes. You can control modes independently of each other; that is, setting one mode doesn't affect whether other modes are set (although many modes may interact to determine what eventually ends up in the frame buffer). Primitives are specified, modes are set, and other OpenGL operations are described by issuing commands in the form of function calls.Primitives are defined by a group of one or more 
vertices. A vertex defines a point, an endpoint of a line, or a corner of a polygon where two edges meet. Data (consisting of vertex coordinates, colors, normals, texture coordinates, and edge flags) is associated with a vertex, and each vertex and its associated data are processed independently, in order, and in the same way. The only exception to this rule is if the group of vertices must be 
clipped so that a particular primitive fits within a specified region; in this case, vertex data may be modified and new vertices created. The type of clipping depends on which primitive the group of vertices represents.Commands are always processed in the order in which they are received, although there may be an indeterminate delay before a command takes effect. This means that each primitive is drawn completely before any subsequent command takes effect. It also means that state-querying commands return data that's consistent with complete execution of all previously issued OpenGL commands.LBL="" HELPID=""Procedural versus DescriptiveOpenGL provides you with fairly direct control over the fundamental operations of two- and three-dimensional graphics. This includes specification of such parameters as transformation matrices, lighting equation coefficients, antialiasing methods, and pixel update operators. However, it doesn't provide you with a means for describing or modeling complex geometric objects. Thus, the OpenGL commands you issue specify how a certain result should be produced (what procedure should be followed) rather than what exactly that result should look like. That is, OpenGL is fundamentally procedural rather than descriptive. Because of this procedural nature, it helps to know how OpenGL worksname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the order in which it carries out its operations, for examplename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in order to fully understand how to use it.LBL="" HELPID=""Execution ModelThe model for interpretation of OpenGL commands is client-server. An application (the client) issues commands, which are interpreted and processed by OpenGL (the server). The server may or may not operate on the same computer as the client. In this sense, OpenGL is network-transparent. A server can maintain several GL 
contexts, each of which is an encapsulated GL state. A client can connect to any one of these contexts. The required network protocol can be implemented by augmenting an already existing protocol (such as that of the X Window System) or by using an independent protocol. No OpenGL commands are provided for obtaining user input. The effects of OpenGL commands on the frame buffer are ultimately controlled by the window system that allocates frame buffer resources. The window system determines which portions of the frame buffer OpenGL may access at any given time and communicates to OpenGL how those portions are structured. Therefore, there are no OpenGL commands to configure the frame buffer or initialize OpenGL. Frame buffer configuration is done outside of OpenGL in conjunction with the window system; OpenGL initialization takes place when the window system allocates a window for OpenGL rendering. (GLX, the X extension of the OpenGL interface, provides these capabilities, as described in IDREF="86751" TYPE="TITLE""OpenGL Extension to the X Window System.")LBL="" HELPID=""ID="27075"Basic OpenGL OperationThe figure shown below gives an abstract, high-level block diagram of how OpenGL processes data.  In the diagram, commands enter from the left and proceed through what can be thought of as a processing pipeline. Some commands specify geometric objects to be drawn, and others control how the objects are handled during the various processing stages. FILE="OpenGLOper.ps" POSITION="INLINE" SCALE="FALSE"LBL="1-1"Figure 1-1 
OpenGL Block DiagramAs shown by the first block in the diagram, rather than having all commands proceed immediately through the pipeline, you can choose to accumulate some of them in a 
display list for processing at a later time. The evaluator stage of processing provides an efficient means for approximating curve and surface geometry by evaluating polynomial commands of input values. During the next stage, per-vertex operations and primitive assembly, OpenGL processes geometric primitivesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'points, line segments, and polygons, all of which are described by vertices. Vertices are transformed and lit, and primitives are clipped to the viewport in preparation for the next stage.Rasterization produces a series of frame buffer addresses and associated values using a two-dimensional description of a point, line segment, or polygon. Each 
fragment so produced is fed into the last stage, per-fragment operations, which performs the final operations on the data before it's stored as pixels in the frame buffer. These operations include conditional updates to the frame buffer based on incoming and previously stored z-values (for z-buffering) and blending of incoming pixel colors with stored colors, as well as masking and other logical operations on pixel values.Input data can be in the form of pixels rather than vertices. Such data, which might describe an image for use in texture mapping, skips the first stage of processing described above and instead is processed as pixels, in the pixel operations stage. The result of this stage is either stored as texture memory, for use in the rasterization stage, or rasterized and the resulting fragments merged into the frame buffer just as if they were generated from geometric data.All elements of OpenGL state, including the contents of the texture memory and even of the frame buffer, can be obtained by an OpenGL application.ID="30564"LBL="2"ID="51876"Overview of Commands and RoutinesMany OpenGL commands pertain specifically to drawing objects such as points, lines, polygons, and bitmaps. Other commands control the way that some of this drawing occurs (such as those that enable antialiasing or texturing). Still other commands are specifically concerned with frame buffer manipulation. This chapter briefly describes how all the OpenGL commands work together to create the OpenGL processing pipeline. Brief overviews are also given of the routines comprising the OpenGL Utility Library (GLU) and the OpenGL extensions to the X Window System (GLX). This chapter has the following main sections:IDREF="57691" TYPE="TITLE""OpenGL Processing Pipeline" expands on the discussion in IDREF="60402" TYPE="TITLE"Chapter 1 by explaining how specific OpenGL commands control the processing of data.IDREF="23039" TYPE="TITLE""Additional OpenGL Commands" discusses several sets of OpenGL commands not covered in the previous section.IDREF="24847" TYPE="TITLE""OpenGL Utility Library" describes the GLU routines that are available.IDREF="86751" TYPE="TITLE""OpenGL Extension to the X Window System" describes the GLX routines.LBL="" HELPID=""ID="57691"OpenGL Processing PipelineNow that you have a general idea of how OpenGL works from IDREF="60402" TYPE="TITLE"Chapter 1, let's take a closer look at the stages in which data is actually processed and tie these stages to OpenGL commands. The figure shown on the next page is a more detailed block diagram of the OpenGL processing pipeline. For most of the pipeline, you can see three vertical arrows between the major stages. These arrows represent vertices and the two primary types of data that can be associated with vertices: color values and texture coordinates. Also note that vertices are assembled into primitives, then to fragments, and finally to pixels in the frame buffer. This progression is discussed in more detail in the following sections. As you continue reading, be aware that we've taken some liberties with command names. Many OpenGL commands are simple variations of each other, differing mostly in the data type of arguments; some commands differ in the number of related arguments and whether those arguments can be specified as a vector or whether they must be specified separately in a list. For example, if you use the glVertex2f() command, you need to supply 
x and 
y coordinates as 32-bit floating-point numbers; with glVertex3sv(), you must supply an array of three short (16-bit) integer values for 
x, 
y, and 
z. For simplicity, only the base name of the command is used in the discussion that follows, and an asterisk is included to indicate that there may be more to the actual command name than is being shown. For example, glVertex*() stands for all variations of the command you use to specify vertices. Also keep in mind that the effect of an OpenGL command may vary depending on whether certain modes are enabled. For example, you need to enable lighting if the lighting-related commands are to have the desired effect of producing a properly lit object. To enable a particular mode, you use the glEnable() command and supply the appropriate constant to identify the mode (for example, GL_LIGHTING). The following sections don't discuss specific modes, but you can refer to the reference page for glEnable() for a complete list of the modes that can be enabled. Modes are disabled with glDisable(). FILE="OpenGLPipeline.ps" POSITION="INLINE" SCALE="FALSE"LBL="2-1"Figure 2-1 
OpenGL PipelineLBL="" HELPID=""VerticesThis section relates the OpenGL commands that perform per-vertex operations to the processing stages shown in the figure on the previous page.LBL="" HELPID=""Input DataYou must provide several types of input data to the OpenGL pipeline:Verticesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Vertices describe the shape of the desired geometric object. To specify vertices, you use glVertex*() commands in conjunction with glBegin() and glEnd() to create a point, line, or polygon. You can also use glRect*() to describe an entire rectangle at once. Edge flagname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'By default, all edges of polygons are boundary edges. Use the glEdgeFlag*() command to explicitly set the edge flag. Current raster positionname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Specified with glRasterPos*(), the current raster position is used to determine raster coordinates for pixel and bitmap drawing operations. Current normalname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'A normal vector associated with a particular vertex determines how a surface at that vertex is oriented in three-dimensional space; this in turn affects how much light that particular vertex receives. Use glNormal*() to specify a normal vector. Current colorname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'The color of a vertex, together with the lighting conditions, determine the final, lit color. Color is specified with glColor*() if in RGBA mode or with glIndex*() if in color index mode. Current texture coordinatesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Specified with glTexCoord*(), texture coordinates determine the location in a texture map that should be associated with a vertex of an object.When glVertex*() is called, the resulting vertex inherits the current edge flag, normal, color, and texture coordinates. Therefore, glEdgeFlag*(), glNormal*(), glColor*(), and glTexCoord*() must be called before glVertex*() if they are to affect the resulting vertex. LBL="" HELPID=""Matrix TransformationsVertices and normals are transformed by the modelview and projection matrices before they're used to produce an image in the frame buffer. You can use commands such as glMatrixMode(), glMultMatrix(), glRotate(), glTranslate(), and glScale() to compose the desired transformations, or you can directly specify matrices with glLoadMatrix() and glLoadIdentity(). Use glPushMatrix() and glPopMatrix() to save and restore modelview and projection matrices on their respective stacks. LBL="" HELPID=""Lighting and ColoringIn addition to specifying colors and normal vectors, you may define the desired lighting conditions with glLight*() and glLightModel*(), and the desired material properties with glMaterial*(). Related commands you might use to control how lighting calculations are performed include glShadeModel(), glFrontFace(), and glColorMaterial(). LBL="" HELPID=""Generating Texture CoordinatesRather than explicitly supplying texture coordinates, you can have OpenGL generate them as a function of other vertex data. This is what the glTexGen*() command does. After the texture coordinates have been specified or generated, they are transformed by the texture matrix. This matrix is controlled with the same commands mentioned earlier for matrix transformations. LBL="" HELPID=""Primitive AssemblyOnce all these calculations have been performed, vertices are assembled into primitivesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'points, line segments, or polygonsname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'together with the relevant edge flag, color, and texture information for each vertex.LBL="" HELPID=""PrimitivesDuring the next stage of processing, primitives are converted to pixel fragments in several steps: primitives are clipped appropriately, whatever corresponding adjustments are necessary are made to the color and texture data, and the relevant coordinates are transformed to window coordinates. Finally, rasterization converts the clipped primitives to pixel fragments. LBL="" HELPID=""ClippingPoints, line segments, and polygons are handled slightly differently during clipping. Points are either retained in their original state (if they're inside the clip volume) or discarded (if they're outside). If portions of line segments or polygons are outside the clip volume, new vertices are generated at the clip points. For polygons, an entire edge may need to be constructed between such new vertices. For both line segments and polygons that are clipped, the edge flag, color, and texture information is assigned to all new vertices.Clipping actually happens in two steps: Application-specific clippingname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Immediately after primitives are assembled, they're clipped in eye coordinates as necessary for any arbitrary clipping planes you've defined for your application with glClipPlane(). (OpenGL requires support for at least six such application-specific clipping planes.)View volume clippingname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'Next, primitives are transformed by the projection matrix (into clip coordinates) and clipped by the corresponding viewing volume. This matrix can be controlled by the previously mentioned matrix transformation commands but is most typically specified by glFrustum() or glOrtho(). LBL="" HELPID=""Transforming to Window CoordinatesBefore clip coordinates can be converted to window coordinates, they are normalized by dividing by the value of 
w to yield normalized device coordinates. After that, the viewport transformation applied to these normalized coordinates produces window coordinates. You control the viewport, which determines the area of the on-screen window that displays an image, with glDepthRange() and glViewport(). LBL="" HELPID=""RasterizationRasterization is the process by which a primitive is converted to a two-dimensional image. Each point of this image contains such information as color, depth, and texture data. Together, a point and its associated information are called a fragment. The current raster position (as specified with glRasterPos*()) is used in various ways during this stage for pixel drawing and bitmaps. As discussed below, different issues arise when rasterizing the three different types of primitives; in addition, pixel rectangles and bitmaps need to be rasterized. Primitives. You control how primitives are rasterized with commands that allow you to choose dimensions and stipple patterns: glPointSize(), glLineWidth(), glLineStipple(), and glPolygonStipple(). Additionally, you can control how the front and back faces of polygons are rasterized with glCullFace(), glFrontFace(), and glPolygonMode(). Pixels. Several commands control pixel storage and transfer modes. The command glPixelStore*() controls the encoding of pixels in client memory, and glPixelTransfer*() and glPixelMap*() control how pixels are processed before being placed in the frame buffer. A pixel rectangle is specified with glDrawPixels(); its rasterization is controlled with glPixelZoom(). Bitmaps. Bitmaps are rectangles of zeros and ones specifying a particular pattern of fragments to be produced. Each of these fragments has the same associated data. A bitmap is specified using glBitmap().Texture Memory. Texturing maps a portion of a specified texture image onto each primitive when texturing is enabled. This mapping is accomplished by using the color of the texture image at the location indicated by a fragment's texture coordinates to modify the fragment's RGBA color. A texture image is specified using glTexImage2D() or glTexImage1D(). The commands glTexParameter*() and glTexEnv*() control how texture values are interpreted and applied to a fragment.Fog. You can have OpenGL blend a fog color with a rasterized fragment's post-texturing color using a blending factor that depends on the distance between the eyepoint and the fragment. Use glFog*() to specify the fog color and blending factor.LBL="" HELPID=""FragmentsOpenGL allows a fragment produced by rasterization to modify the corresponding pixel in the frame buffer only if it passes a series of tests. If it does pass, the fragment's data can be used directly to replace the existing frame buffer values, or it can be combined with existing data in the frame buffer, depending on the state of certain modes.LBL="" HELPID=""Pixel Ownership TestThe first test is to determine whether the pixel in the frame buffer corresponding to a particular fragment is owned by the current OpenGL context. If so, the fragment proceeds to the next test. If not, the window system determines whether the fragment is discarded or whether any further fragment operations will be performed with that fragment. This test allows the window system to control OpenGL's behavior when, for example, an OpenGL window is obscured.LBL="" HELPID=""Scissor TestWith the glScissor() command, you can specify an arbitrary screen-aligned rectangle outside of which fragments will be discarded.LBL="" HELPID=""Alpha TestThe alpha test (which is performed only in RGBA mode) discards a fragment depending on the outcome of a comparison between the fragment's alpha value and a constant reference value. The comparison command and reference value are specified with glAlphaFunc().LBL="" HELPID=""Stencil TestThe stencil test conditionally discards a fragment based on the outcome of a comparison between the value in the stencil buffer and a reference value. The command glStencilFunc() specifies the comparison command and the reference value. Whether the fragment passes or fails the stencil test, the value in the stencil buffer is modified according to the instructions specified with glStencilOp().LBL="" HELPID=""Depth Buffer TestThe depth buffer test discards a fragment if a depth comparison fails; glDepthFunc() specifies the comparison command. The result of the depth comparison also affects the stencil buffer update value if stenciling is enabled. LBL="" HELPID=""BlendingBlending combines a fragment's R, G, B, and A values with those stored in the frame buffer at the corresponding location. The blending, which is performed only in RGBA mode, depends on the alpha value of the fragment and that of the corresponding currently stored pixel; it might also depend on the RGB values. You control blending with glBlendFunc(), which allows you to indicate the source and destination blending factors.LBL="" HELPID=""DitheringIf dithering is enabled, a dithering algorithm is applied to the fragment's color or color index value. This algorithm depends only on the fragment's value and its 
x and 
y window coordinates. LBL="" HELPID=""Logical OperationsFinally, a logical operation can be applied between the fragment and the value stored at the corresponding location in the frame buffer; the result replaces the current frame buffer value. You choose the desired logical operation with glLogicOp(). Logical operations are performed only on color indices, never on RGBA values. LBL="" HELPID=""PixelsDuring the previous stage of the OpenGL pipeline, fragments are converted to pixels in the frame buffer. The frame buffer is actually organized into a set of logical buffersname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'the 
color, depth, stencil, and
 accumulation buffers. The color buffer itself consists of a 
front left, front right, back left, back right, and some number of 
auxiliary buffers. You can issue commands to control these buffers, and you can directly read or copy pixels from them. (Note that the particular OpenGL context you're using may not provide all of these buffers.)LBL="" HELPID=""Frame Buffer OperationsYou can select into which buffer color values are written with glDrawBuffer(). In addition, four different commands are used to mask the writing of bits to each of the logical frame buffers after all per-fragment operations have been performed: glIndexMask(), glColorMask(), glDepthMask(), and glStencilMask(). The operation of the accumulation buffer is controlled with glAccum(). Finally, glClear() sets every pixel in a specified subset of the buffers to the value specified with glClearColor(), glClearIndex(), glClearDepth(), glClearStencil(), or glClearAccum().LBL="" HELPID=""Reading or Copying PixelsYou can read pixels from the frame buffer into memory, encode them in various ways, and store the encoded result in memory with glReadPixels(). In addition, you can copy a rectangle of pixel values from one region of the frame buffer to another with glCopyPixels(). The command glReadBuffer() controls from which color buffer the pixels are read or copied. LBL="" HELPID=""ID="23039"Additional OpenGL CommandsThis section briefly describes special groups of commands that weren't explicitly shown as part of OpenGL's processing pipeline. These commands accomplish such diverse tasks as evaluating polynomials, using display lists, and obtaining the values of OpenGL state variables.LBL="" HELPID=""Using EvaluatorsOpenGL's evaluator commands allow you to use a polynomial mapping to produce vertices, normals, texture coordinates, and colors. These calculated values are then passed on to the pipeline as if they had been directly specified. The evaluator facility is also the basis for the NURBS (Non-Uniform Rational B-Spline) commands, which allow you to define curves and surfaces, as described later in this chapter under IDREF="24847" TYPE="TITLE""OpenGL Utility Library."The first step involved in using evaluators is to define the appropriate one- or two-dimensional polynomial mapping using glMap*(). The domain values for this map can then be specified and evaluated in one of two ways:By defining a series of evenly spaced domain values to be mapped using glMapGrid*() and then evaluating a rectangular subset of that grid with glEvalMesh*(). A single point of the grid can be evaluated using glEvalPoint*().By explicitly specifying a desired domain value as an argument to glEvalCoord*(), which evaluates the maps at that value. LBL="" HELPID=""ID="13521"Performing Selection and FeedbackSelection, feedback, and rendering are mutually exclusive modes of operation. Rendering is the normal, default mode during which fragments are produced by rasterization; in selection and feedback modes, no fragments are produced and therefore no frame buffer modification occurs. In selection mode, you can determine which primitives would be drawn into some region of a window; in feedback mode, information about primitives that would be rasterized is fed back to the application. You select among these three modes with glRenderMode(). LBL="" HELPID=""SelectionSelection works by returning the current contents of the name stack, which is an array of integer-valued names. You assign the names and build the name stack within the modeling code that specifies the geometry of objects you want to draw. Then, in selection mode, whenever a primitive intersects the clip volume, a selection hit occurs. The hit record, which is written into the selection array you've supplied with glSelectBuffer(), contains information about the contents of the name stack at the time of the hit. (Note that glSelectBuffer() needs to be called before OpenGL is put into selection mode with glRenderMode(). Also, the entire contents of the name stack isn't guaranteed to be returned until glRenderMode() is called to take OpenGL out of selection mode.)  You manipulate the name stack with glInitNames(), glLoadName(), glPushName(), and glPopName(). In addition, you might want to use an OpenGL Utility Library routine for selection, gluPickMatrix(), which is described later in this chapter under IDREF="24847" TYPE="TITLE""OpenGL Utility Library."LBL="" HELPID=""FeedbackIn feedback mode, each primitive that would be rasterized generates a block of values that is copied into the feedback array. You supply this array with glFeedbackBuffer(), which must be called before OpenGL is put into feedback mode. Each block of values begins with a code indicating the primitive type, followed by values that describe the primitive's vertices and associated data. Entries are also written for bitmaps and pixel rectangles. Values are not guaranteed to be written into the feedback array until glRenderMode() is called to take OpenGL out of feedback mode. You can use glPassThrough() to supply a marker that's returned in feedback mode as if it were a primitive. LBL="" HELPID=""Using Display ListsA display list is simply a group of OpenGL commands that has been stored for subsequent execution. The glNewList() command begins the creation of a display list, and glEndList() ends it. With few exceptions, OpenGL commands called between glNewList() and glEndList() are appended to the display list, and optionally executed as well. (The reference page for glNewList() lists the commands that can't be stored and executed from within a display list.) To trigger the execution of a list or set of lists, use glCallList() or glCallLists() and supply the identifying number of a particular list or lists. You can manage the indices used to identify display lists with glGenLists(), glListBase(), and glIsList(). Finally, you can delete a set of display lists with glDeleteLists(). LBL="" HELPID=""Managing Modes and ExecutionThe effect of many OpenGL commands depends on whether a particular mode is in effect. You use glEnable() and glDisable() to set such modes and glIsEnabled() to determine whether a particular mode is set.You can control the execution of previously issued OpenGL commands with glFinish(), which forces all such commands to complete, or glFlush(), which ensures that all such commands will be completed in a finite time. A particular implementation of OpenGL may allow certain behaviors to be controlled with hints, by using the glHint() command. Possible behaviors are the quality of color and texture coordinate interpolation, the accuracy of fog calculations, and the sampling quality of antialiased points, lines, or polygons.LBL="" HELPID=""Obtaining State InformationOpenGL maintains numerous state variables that affect the behavior of many commands. Some of these variables have specialized query commands:glGetLight()glGetMaterial()glGetClipPlane()glGetPolygonStipple()glGetTexEnv()glGetTexGen()glGetTexImage()glGetTexLevelParameter()glGetTexParameter()glGetMap()glGetPixelMap()The value of other state variables can be obtained with glGetBooleanv(), glGetDoublev(), glGetFloatv(), or glGetIntegerv(), as appropriate. The reference page for glGet*() explains how to use these commands. Other query commands you might want to use are glGetError(), glGetString(), and glIsEnabled(). (See IDREF="30708" TYPE="TITLE""Handling Errors" later in this chapter for more information about routines related to error handling.) Finally, you can save and restore sets of state variables with glPushAttrib() and glPopAttrib().LBL="" HELPID=""ID="24847"OpenGL Utility Library The OpenGL Utility Library (GLU) contains several groups of commands that complement the core OpenGL interface by providing support for auxiliary features. Since these utility routines make use of core OpenGL commands, any OpenGL implementation is guaranteed to support the utility routines. Note that the prefix for Utility Library routines is glu rather than gl. LBL="" HELPID=""Manipulating Images for Use in TexturingGLU provides image scaling and automatic mipmapping routines to simplify the specification of texture images. The routine gluScaleImage() scales a specified image to an accepted texture size; the resulting image can then be passed to OpenGL as a texture. The automatic mipmapping routines gluBuild1DMipmaps() and gluBuild2DMipmaps() create mipmapped texture images from a specified image and pass them to glTexImage1D() and glTexImage2D(), respectively.LBL="" HELPID=""Transforming CoordinatesSeveral commonly used matrix transformation routines are provided. You can set up a two-dimensional orthographic viewing region with gluOrtho2D(), a perspective viewing volume using gluPerspective(), or a viewing volume that's centered on a specified eyepoint with gluLookAt(). Each of these routines creates the desired matrix and applies it to the current matrix using glMultMatrix(). The gluPickMatrix() routine simplifies selection by creating a matrix that restricts drawing to a small region of the viewport. If you rerender the scene in selection mode after this matrix has been applied, all objects that would be drawn near the cursor will be selected and information about them stored in the selection buffer. See IDREF="13521" TYPE="TITLE""Performing Selection and Feedback" earlier in this chapter for more information about selection mode.If you need to determine where in the window an object is being drawn, use gluProject(), which converts specified coordinates from object coordinates to window coordinates; gluUnProject() performs the inverse conversion.LBL="" HELPID=""Polygon TessellationThe polygon tessellation routines triangulate a concave polygon with one or more contours. To use this GLU feature, first create a tessellation object with gluNewTess(), and define callback routines that will be used to process the triangles generated by the tessellator (with gluTessCallBack()). Then use gluBeginPolygon(), gluTessVertex(), gluNextContour(), and gluEndPolygon() to specify the concave polygon to be tessellated. Unneeded tessellation objects can be destroyed with gluDeleteTess().LBL="" HELPID=""Rendering Spheres, Cylinders, and DisksYou can render spheres, cylinders, and disks using the GLU quadric routines. To do this, create a quadric object with gluNewQuadric(). (To destroy this object when you're finished with it, use gluDeleteQuadric().) Then specify the desired rendering style, as listed below, with the appropriate routine (unless you're satisfied with the default values):Whether surface normals should be generated, and if so, whether there should be one normal per vertex or one normal per face: gluQuadricNormals()Whether texture coodinates should be generated: gluQuadricTexture()Which side of the quadric should be considered the outside and which the inside: gluQuadricOrientation()Whether the quadric should be drawn as a set of polygons, lines, or points: gluQuadricDrawStyle()After you've specified the rendering style, simply invoke the rendering routine for the desired type of quadric object: gluSphere(), gluCylinder(), gluDisk(), or gluPartialDisk(). If an error occurs during rendering, the error-handling routine you've specified with gluQuadricCallBack() is invoked.LBL="" HELPID=""NURBS Curves and SurfacesNURBS (Non-Uniform Rational B-Spline) curves and surfaces are converted to OpenGL evaluators by the routines described in this section. You can create and delete a NURBS object with gluNewNurbsRenderer() and gluDeleteNurbsRenderer(), and establish an error-handling routine with gluNurbsCallback(). You specify the desired curves and surfaces with different sets of routinesname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'gluBeginCurve(), gluNurbsCurve(), and gluEndCurve() for curves or gluBeginSurface(), gluNurbsSurface(), and gluEndSurface() for surfaces. You can also specify a trimming region, which defines a subset of the NURBS surface domain to be evaluated, thereby allowing you to create surfaces that have smooth boundaries or that contain holes. The trimming routines are gluBeginTrim(), gluPwlCurve(), gluNurbsCurve(), and gluEndTrim(). As with quadric objects, you can control how NURBS curves and surfaces are rendered:Whether a curve or surface should be discarded if its control polyhedron lies outside the current viewportWhat the maximum length should be (in pixels) of edges of polygons used to render curves and surfacesWhether the projection matrix, modelview matrix, and viewport should be taken from the OpenGL server or whether you'll supply them explictly with gluLoadSamplingMatrices()Use gluNurbsProperty() to set these properties, or use the default values. You can query a NURBS object about its rendering style with gluGetNurbsProperty().LBL="" HELPID=""ID="30708"Handling ErrorsThe routine gluErrorString() is provided for retrieving an error string that corresponds to an OpenGL or GLU error code. The currently defined OpenGL error codes are described in the glGetError() reference page. The GLU error codes are listed in the gluErrorString(), gluTessCallback(), gluQuadricCallback(), and gluNurbsCallback() reference pages. Errors generated by GLX routines are listed in the relevant reference pages for those routines. LBL="" HELPID=""ID="86751"OpenGL Extension to the X Window SystemIn the X Window System, OpenGL rendering is made available as an extension to X in the formal X sense: connection and authentication are accomplished with the normal X mechanisms. As with other X extensions, there is a defined network protocol for OpenGL's rendering commands encapsulated within the X byte stream. Since performance is critical in three-dimensional rendering, the OpenGL extension to X allows OpenGL to bypass the X server's involvement in data encoding, copying, and interpretation and instead render directly to the graphics pipeline. This section briefly discusses the routines defined as part of GLX; these routines have the prefix glX. You'll need to have some knowledge of X in order to fully understand the following and to use GLX successfully.LBL="" HELPID=""InitializationUse glXQueryExtension() and glXQueryVersion() to determine whether the GLX extension is defined for an X server, and if so, which version is bound in the server. The glXChooseVisual() routine returns a pointer to an XVisualInfo structure describing the visual that best meets the client's specified attributes. You can query a visual about its support of a particular OpenGL attribute with glXGetConfig().LBL="" HELPID=""Controlling RenderingSeveral GLX routines are provided for creating and managing an OpenGL rendering context. You can use such a context to render off-screen if you want. Routines are also provided for such tasks as synchronizing execution between the X and OpenGL streams, swapping front and back buffers, and using an X font.LBL="" HELPID=""Managing an OpenGL Rendering ContextAn OpenGL rendering context is created with glXCreateContext(). One of the arguments to this routine allows you to request a direct rendering context that bypasses the X server as described above. (Note that in order to do direct rendering, the X server connection must be local and the OpenGL implementation needs to support direct rendering.) You can determine whether a GLX context is direct with glXIsDirect().To make a rendering context current, use glXMakeCurrent(); glXGetCurrentContext() returns the current context. (You can also obtain the current drawable with glXGetCurrentDrawable().) Remember that only one context can be current for any thread at any one time. If you have multiple contexts, you can copy selected groups of OpenGL state variables from one context to another with glXCopyContext(). When you're finished with a particular context, destroy it with glXDestroyContext(). LBL="" HELPID=""Off-Screen RenderingTo render off-screen, first create an X Pixmap and then pass this as an argument to glXCreateGLXPixmap(). Once rendering is completed, you can destroy the association between the X and GLX Pixmaps with glXDestroyGLXPixmap(). (Off-screen rendering isn't guaranteed to be supported for direct renderers.) LBL="" HELPID=""Synchronizing ExecutionTo prevent X requests from executing until any outstanding OpenGL rendering is completed, call glXWaitGL(). Then, any previously issued OpenGL commands are guaranteed to be executed before any X rendering calls made after glXWaitGL(). Although the same result can be achieved with glFinish(), glXWaitGL() doesn't require a round trip to the server and thus is more efficient in cases where the client and server are on separate machines. To prevent an OpenGL command sequence from executing until any outstanding X requests are completed, use glXWaitX(). This routine guarantees that previously issued X rendering calls will be executed before any OpenGL calls made after glXWaitX().LBL="" HELPID=""Swapping BuffersFor drawables that are double-buffered, the front and back buffers can be exchanged by calling glXSwapBuffers(). An implicit glFlush() is done as part of this routine. LBL="" HELPID=""Using an X FontA shortcut for using X fonts in OpenGL is provided with the command glXUseXFont(). LBL="3"ID="67537"Summary of Commands and RoutinesThis chapter lists the prototypes for OpenGL, the OpenGL Utility Library, and the OpenGL extension to the X Window System. The prototypes are grouped functionally, as shown below: IDREF="96701" TYPE="TEXT"OpenGL CommandsIDREF="53415" TYPE="TITLE""Primitives"IDREF="19874" TYPE="TITLE""Coordinate Transformation"IDREF="34594" TYPE="TITLE""Coloring and Lighting"IDREF="90517" TYPE="TITLE""Clipping"IDREF="85566" TYPE="TITLE""Rasterization"IDREF="96454" TYPE="TITLE""Pixel Operations"IDREF="16542" TYPE="TITLE""Texture Mapping"IDREF="66317" TYPE="TITLE""Fog"IDREF="10484" TYPE="TITLE""Frame Buffer Operations"IDREF="70439" TYPE="TITLE""Evaluators"IDREF="71428" TYPE="TITLE""Selection and Feedback"IDREF="99736" TYPE="TITLE""Display Lists"IDREF="46859" TYPE="TITLE""Modes and Execution"IDREF="20865" TYPE="TITLE""State Queries"IDREF="21527" TYPE="TEXT"GLU RoutinesIDREF="33017" TYPE="TITLE""Texture Images"IDREF="67932" TYPE="TITLE""Coordinate Transformation"IDREF="91060" TYPE="TITLE""Polygon Tessellation"IDREF="73321" TYPE="TITLE""Quadric Objects"IDREF="70985" TYPE="TITLE""NURBS Curves and Surfaces"IDREF="12587" TYPE="TITLE""Error Handling"IDREF="47684" TYPE="TEXT"GLX RoutinesIDREF="85590" TYPE="TITLE""Initialization"IDREF="45964" TYPE="TITLE""Controlling Rendering"LBL="" HELPID=""NotationSince some of the OpenGL commands differ from each other only by the data type of the arguments they accept, certain conventions have been used to refer to these commands in a compact way:void glVertex2{sifd}{v} (TYPE x, TYPE y);In this example, the first set of braces encloses characters identifying the possible data types for the arguments listed as having data type TYPE. (The digit preceding the braces indicates how many arguments the command takes.) In this case, all the arguments have the placeholder TYPE, but in other situations some arguments may have an explicitly defined data type. The table shown below lists the set of possible data types, their corresponding characters, and the type definition OpenGL uses for referring to that data type. COLUMNS="4"LEFT="0" WIDTH="43"characterLEFT="50" WIDTH="104"data typeLEFT="160" WIDTH="74"C-language typeLEFT="240" WIDTH="125"OpenGL type definitionLEFT="0" WIDTH="43"bLEFT="50" WIDTH="104"8-bit integerLEFT="160" WIDTH="74"signed charLEFT="240" WIDTH="125"GLbyteLEFT="0" WIDTH="43"sLEFT="50" WIDTH="104"16-bit integerLEFT="160" WIDTH="74"shortLEFT="240" WIDTH="125"GLshortLEFT="0" WIDTH="43"iLEFT="50" WIDTH="104"32-bit integerLEFT="160" WIDTH="74"intLEFT="240" WIDTH="125"GLint, GLsizeiLEFT="0" WIDTH="43"fLEFT="50" WIDTH="104"32-bit floating-pointLEFT="160" WIDTH="74"floatLEFT="240" WIDTH="125"GLfloat, GLclampfLEFT="0" WIDTH="43"dLEFT="50" WIDTH="104"64-bit floating-pointLEFT="160" WIDTH="74"doubleLEFT="240" WIDTH="125"GLdouble, GLclampdLEFT="0" WIDTH="43"ubLEFT="50" WIDTH="104"8-bit unsigned integerLEFT="160" WIDTH="74"unsigned charLEFT="240" WIDTH="125"GLubyte, GLbooleanLEFT="0" WIDTH="43"usLEFT="50" WIDTH="104"16-bit unsigned integerLEFT="160" WIDTH="74"unsigned shortLEFT="240" WIDTH="125"GLushortLEFT="0" WIDTH="43"uiLEFT="50" WIDTH="104"32-bit unsigned integerLEFT="160" WIDTH="74"unsigned intLEFT="240" WIDTH="125"GLuint, GLenum, GLbitfieldLEFT="0" WIDTH="43"LEFT="50" WIDTH="104"LEFT="160" WIDTH="74"voidLEFT="240" WIDTH="125"GLvoidThe second set of braces, if present, contains a v for the vector form of the command. If you choose to use the vector form, all the TYPE arguments are collapsed into a single array. For example, here are the nonvector and vector forms of a command, using a 32-bit floating-point data type:void glVertex2f(GLfloat x, GLfloat y);void glVertex2fv(GLfloat v[2]);Where the use of the vector form is ambiguous, both the vector and nonvector forms are listed. Note that not all commands with multiple arguments have a vector form and that some commands have only a vector form, in which case the v isn't enclosed in braces.LBL="" HELPID=""ID="96701"OpenGL CommandsLBL="" HELPID=""ID="53415"PrimitivesSpecify vertices or rectangles:void glBegin (GLenum mode);void glEnd (void);void glVertex2{sifd}{v} (TYPE x, TYPE y);void glVertex3{sifd}{v} (TYPE x, TYPE y, TYPE z);void glVertex4{sifd}{v} (TYPE x, TYPE y, TYPE z, TYPE w);void glRect{sifd} (TYPE x1, TYPE y1, TYPE x2, TYPE y2);void glRect{sifd}v (const TYPE *v1, const TYPE *v2);Specify polygon edge treatment:void glEdgeFlag (GLboolean flag);void glEdgeFlagv (const GLboolean *flag);LBL="" HELPID=""ID="19874"Coordinate TransformationTransform the current matrix:void glRotate{fd} (TYPE angle, TYPE x, TYPE y, TYPE z);void glTranslate{fd} (TYPE x, TYPE y, TYPE z);void glScale{fd} (TYPE x, TYPE y, TYPE z);void glMultMatrix{fd} (const TYPE *m);void glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near, GLdouble far);void glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near, GLdouble far);Replace the current matrix:void glLoadMatrix{fd} (const TYPE *m);void glLoadIdentity (void);Manipulate the matrix stack:void glMatrixMode (GLenum mode);void glPushMatrix (void);void glPopMatrix (void);Specify the viewport:void glDepthRange (GLclampd near, GLclampd far);void glViewport (GLint x, GLint y, GLsizei width, GLsizei height);LBL="" HELPID=""ID="34594"Coloring and LightingSet the current color, color index, or normal vector:void glColor3{bsifd ubusui}{v} (TYPE red, TYPE green, TYPE blue);void glColor4{bsifd ubusui}{v} (TYPE red, TYPE green, TYPE blue, TYPE alpha);void glIndex{sifd}{v} (TYPE index);void glNormal3{bsifd}{v} (TYPE nx, TYPE ny, TYPE nz);Specify light source, material, or lighting model parameter values:void glLight{if}{v} (GLenum light, GLenum pname, TYPE param);void glMaterial{if}{v} (GLenum face, GLenum pname, TYPE param);void glLightModel{if}{v} (GLenum pname, TYPE param);Choose a shading model: void glShadeModel (GLenum mode);Specify which polygon orientation is front-facing:void glFrontFace (GLenum dir);Cause a material color to track the current color:void glColorMaterial (GLenum face, GLenum mode);Obtain light source or material parameter values:void glGetLight{if}v (GLenum light, GLenum pname, TYPE *params);void glGetMaterial{if}v (GLenum face, GLenum pname, TYPE *params);LBL="" HELPID=""ID="90517"ClippingSpecify a clipping plane:void glClipPlane (GLenum plane, const GLdouble *equation);Return clipping plane coefficients:void glGetClipPlane (GLenum plane, GLdouble *equation);LBL="" HELPID=""ID="85566"Rasterization Set the current raster position:void glRasterPos2{sifd}{v}(TYPE x, TYPE y);void glRasterPos3{sifd}{v}(TYPE x, TYPE y, TYPE z);void glRasterPos4{sifd}{v}(TYPE x, TYPE y, TYPE z, TYPE w);Specify a bitmap:void glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);Specify the dimensions of points or lines:void glPointSize (GLfloat size);void glLineWidth (GLfloat width);Specify or return a stipple pattern for lines or polygons:void glLineStipple (GLint factor, GLushort pattern);void glPolygonStipple (const GLubyte *mask);void glGetPolygonStipple (GLubyte *mask);Choose how polygons are rasterized:void glCullFace (GLenum mode);void glPolygonMode (GLenum face, GLenum mode);LBL="" HELPID=""ID="96454"Pixel OperationsSelect the source for pixel reads or copies:void glReadBuffer (GLenum mode);Read, write, and copy pixels:void glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);void glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);void glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);Specify or query how pixels are encoded or processed:void glPixelStore{if} (GLenum pname, TYPE param);void glPixelTransfer{if} (GLenum pname, TYPE param);void glPixelMap{f usui}v (GLenum map, GLint mapsize, const TYPE *values);void glGetPixelMap{f usui}v (GLenum map, TYPE *values);Control pixel rasterization:void glPixelZoom (GLfloat xfactor, GLfloat yfactor);LBL="" HELPID=""ID="16542"Texture MappingControl how a texture is applied to a fragment:void glTexParameter{if}{v} (GLenum target, GLenum pname, TYPE param);void glTexEnv{if}{v} (GLenum target, GLenum pname, TYPE param);Set the current texture coordinates:void glTexCoord1{sifd}{v} (TYPE s); void glTexCoord2{sifd}{v} (TYPE s, TYPE t);void glTexCoord3{sifd}{v} (TYPE s, TYPE t, TYPE r);void glTexCoord4{sifd}{v} (TYPE s, TYPE t, TYPE r, TYPE q);Control the generation of texture coordinates:void glTexGen{ifd}{v} (GLenum coord, GLenum pname, TYPE param);Specify a one- or two-dimensional texture image:void glTexImage1D (GLenum target, GLint level, GLint components, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);void glTexImage2D (GLenum target, GLint level, GLint components, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);Obtain texture-related parameter values:void glGetTexEnv{if}v (GLenum target, GLenum pname, TYPE *params);void glGetTexGen{ifd}v (GLenum coord, GLenum pname, TYPE *params);void glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);void glGetTexLevelParameter{if}v (GLenum target, GLint level, GLenum pname, TYPE *params);void glGetTexParameter{if}v (GLenum target, GLenum pname, TYPE *params);LBL="" HELPID=""ID="66317"FogSet fog parameters:void glFog{if}{v} (GLenum pname, TYPE param);LBL="" HELPID=""ID="10484"Frame Buffer OperationsControl per-fragment testing:void glScissor (GLint x, GLint y, GLsizei width, GLsizei height);void glAlphaFunc (GLenum func, GLclampf ref);void glStencilFunc (GLenum func, GLint ref, GLuint mask);void glStencilOp (GLenum fail, GLenum pass, GLenum zpass);void glDepthFunc (GLenum func);Combine fragment and frame buffer values:void glBlendFunc (GLenum sfactor, GLenum dfactor);void glLogicOp (GLenum opcode);Clear some or all buffers:void glClear (GLbitfield mask);Specify color, depth, and stencil values for clears:void glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);void glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);void glClearDepth (GLclampd depth);void glClearIndex (GLfloat c);void glClearStencil (GLint s);Control buffers enabled for writing:void glDrawBuffer (GLenum mode);void glIndexMask (GLuint mask);void glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);void glDepthMask (GLboolean flag);void glStencilMask (GLuint mask);Operate on the accumulation buffer:void glAccum (GLenum op, GLfloat value);LBL="" HELPID=""ID="70439"EvaluatorsDefine a one- or two-dimensional evaluator:void glMap1{fd} (GLenum target, TYPE u1, TYPE u2, GLint stride, GLint order, const TYPE *points);void glMap2{fd} (GLenum target, TYPE u1, TYPE u2, GLint ustride, GLint uorder, TYPE v1, TYPE v2, GLint vstride, GLint vorder, const TYPE *points);Generate and evaluate a series of map domain values:void glMapGrid1{fd} (GLint n, TYPE u1, TYPE u2);void glMapGrid2{fd} (GLint un, TYPE u1, TYPE u2, GLint vn, TYPE v1, TYPE v2);void glEvalMesh1 (GLenum mode, GLint i1, GLint i2);void glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);void glEvalPoint1 (GLint i);void glEvalPoint2 (GLint i, GLint j);Evaluate one- and two-dimensional maps at a specified domain coordinate:void glEvalCoord1{fd}{v} (TYPE u);void glEvalCoord2{fd}{v} (TYPE u, TYPE v);Obtain evaluator parameter values:void glGetMap{idf}v (GLenum target, GLenum query, TYPE *v);LBL="" HELPID=""ID="71428"Selection and FeedbackControl the mode and corresponding buffer:GLint glRenderMode (GLenum mode);void glSelectBuffer (GLsizei size, GLuint *buffer);void glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);Supply a token for feedback mode:void glPassThrough (GLfloat token);Control the name stack for selection:void glInitNames (void);void glLoadName (GLuint name);void glPushName (GLuint name);void glPopName (void);LBL="" HELPID=""ID="99736"Display ListsCreate or delete display lists:void glNewList (GLuint list, GLenum mode);void glEndList (void);void glDeleteLists (GLuint list, GLsizei range);Execute a display list or set of lists:void glCallList (GLuint list);void glCallLists (GLsizei n, GLenum type, const GLvoid *lists);Manage display-list indices:GLuint glGenLists (GLsizei range);GLboolean glIsList (GLuint list);void glListBase (GLuint base);LBL="" HELPID=""ID="46859"Modes and ExecutionEnable, disable, and query modes:void glEnable (GLenum cap);void glDisable (GLenum cap);GLboolean glIsEnabled (GLenum cap);Wait until all OpenGL commands have executed completely:void glFinish (void);Force all issued OpenGL commands to be executed:void glFlush (void);Specify hints for OpenGL operation:void glHint (GLenum target, GLenum mode);LBL="" HELPID=""ID="20865"State QueriesObtain information about an error or the current OpenGL connection:GLenum glGetError (void);const GLubyte * glGetString (GLenum name);Query state variables:void glGetBooleanv (GLenum pname, GLboolean *params);void glGetDoublev (GLenum pname, GLdouble *params);void glGetFloatv (GLenum pname, GLfloat *params);void glGetIntegerv (GLenum pname, GLint *params);Save and restore sets of state variables:void glPushAttrib (GLbitfield mask);void glPopAttrib (void);LBL="" HELPID=""ID="21527"GLU RoutinesLBL="" HELPID=""ID="33017"Texture ImagesMagnify or shrink an image:int gluScaleImage (GLenum format, GLint widthin, GLint heightin,GLenum typein, const void *datain, GLint widthout, GLint heightout, GLenum typeout, void *dataout);Generate mipmaps for an image:int gluBuild1DMipmaps (GLenum target, GLint components, GLint width, GLenum format, GLenum type, void *data);int gluBuild2DMipmaps (GLenum target, GLint components, GLint width, GLint height, GLenum format, GLenum type, void *data);LBL="" HELPID=""ID="67932"Coordinate TransformationCreate projection or viewing matrices:void gluOrtho2D (GLdouble left, GLdouble right, GLdouble bottom,GLdouble top);void gluPerspective (GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar);void gluPickMatrix (GLdouble x, GLdouble y, GLdouble width, GLdouble height, GLint viewport[4]);void gluLookAt (GLdouble eyex, GLdouble eyey, GLdouble eyez, GLdouble centerx, GLdouble centery, GLdouble centerz, GLdouble upx, GLdouble upy, GLdouble upz);Convert object coordinates to screen coordinates:int gluProject (GLdouble objx, GLdouble objy, GLdouble objz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *winx, GLdouble *winy, GLdouble *winz);int gluUnProject (GLdouble winx, GLdouble winy, GLdouble winz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *objx, GLdouble *objy, GLdouble *objz);LBL="" HELPID=""ID="91060"Polygon TessellationManage tessellation objects:GLUtriangulatorObj* gluNewTess (void);void gluTessCallback (GLUtriangulatorObj *tobj, GLenum which, void (*fn)());void gluDeleteTess (GLUtriangulatorObj *tobj);Describe the input polygon:void gluBeginPolygon (GLUtriangulatorObj *tobj);void gluEndPolygon (GLUtriangulatorObj *tobj);void gluNextContour (GLUtriangulatorObj *tobj, GLenum type);void gluTessVertex (GLUtriangulatorObj *tobj, GLdouble v[3], void *data);LBL="" HELPID=""ID="73321"Quadric ObjectsManage quadric objects:GLUquadricObj* gluNewQuadric (void);void gluDeleteQuadric (GLUquadricObj *state);void gluQuadricCallback (GLUquadricObj *qobj, GLenum which, void (*fn)());Control the rendering:void gluQuadricNormals (GLUquadricObj *quadObject, GLenum normals);void gluQuadricTexture (GLUquadricObj *quadObject, GLboolean textureCoords);void gluQuadricOrientation (GLUquadricObj *quadObject, GLenum orientation);void gluQuadricDrawStyle (GLUquadricObj *quadObject, GLenum drawStyle);Specify a quadric primitive:void gluCylinder (GLUquadricObj *qobj, GLdouble baseRadius,GLdouble topRadius, GLdouble height, GLint slices, GLint stacks);void gluDisk (GLUquadricObj *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops);void gluPartialDisk (GLUquadricObj *qobj, GLdouble innerRadius,GLdouble outerRadius, GLint slices, GLint loops, GLdouble startAngle, GLdouble sweepAngle);void gluSphere (GLUquadricObj *qobj, GLdouble radius, GLint slices,GLint stacks);LBL="" HELPID=""ID="70985"NURBS Curves and SurfacesManage a NURBS object:GLUnurbsObj* gluNewNurbsRenderer (void);void gluDeleteNurbsRenderer (GLUnurbsObj *nobj);void gluNurbsCallback (GLUnurbsObj *nobj, GLenum which, void (*fn)());Create a NURBS curve:void gluBeginCurve (GLUnurbsObj *nobj);void gluEndCurve (GLUnurbsObj *nobj);void gluNurbsCurve (GLUnurbsObj *nobj, GLint nknots, GLfloat *knot, GLint stride, GLfloat *ctlarray, GLint order, GLenum type);Create a NURBS surface:void gluBeginSurface (GLUnurbsObj *nobj);void gluEndSurface (GLUnurbsObj *nobj);void gluNurbsSurface (GLUnurbsObj *nobj, GLint uknot_count, GLfloat *uknot, GLint vknot_count, GLfloat *vknot, GLint u_stride, GLint v_stride, GLfloat *ctlarray, GLint sorder, GLint torder, GLenum type);Define a trimming region:void gluBeginTrim (GLUnurbsObj *nobj);void gluEndTrim (GLUnurbsObj *nobj);void gluPwlCurve (GLUnurbsObj *nobj, GLint count, GLfloat *array, GLint stride, GLenum type);Control NURBS rendering:void gluLoadSamplingMatrices (GLUnurbsObj *nobj, const GLfloat modelMatrix[16], const GLfloat projMatrix[16], const GLint viewport[4]);void gluNurbsProperty (GLUnurbsObj *nobj, GLenum property, GLfloat value);void gluGetNurbsProperty (GLUnurbsObj *nobj, GLenum property, GLfloat *value);LBL="" HELPID=""ID="12587"Error HandlingProduce an error string from an OpenGL error code:const GLubyte* gluErrorString (GLenum errorCode);LBL="" HELPID=""ID="47684"GLX RoutinesLBL="" HELPID=""ID="85590"InitializationDetermine whether the GLX extension is defined on the X server:Bool glXQueryExtension (Display *dpy, int *errorBase, int *eventBase);Bool glXQueryVersion (Display *dpy, int *major, int *minor);Obtain the desired visual:XVisualInfo* glXChooseVisual (Display *dpy, int screen, int *attribList);int glXGetConfig (Display *dpy, XVisualInfo *vis, int attrib, int *value);LBL="" HELPID=""ID="45964"Controlling RenderingManage or query an OpenGL rendering context:GLXContext glXCreateContext (Display *dpy, XVisualInfo *vis, GLXContext shareList, Bool direct);void glXDestroyContext (Display *dpy, GLXContext ctx);void glXCopyContext (Display *dpy, GLXContext src, GLXContext dst, GLuint mask);Bool glXIsDirect (Display *dpy, GLXContext ctx);Bool glXMakeCurrent (Display *dpy, GLXDrawable draw, GLXContext ctx);GLXContext glXGetCurrentContext (void);GLXDrawable glXGetCurrentDrawable (void);Perform off-screen rendering:GLXPixmap glXCreateGLXPixmap (Display *dpy, XVisualInfo *vis, Pixmap pixmap);void glXDestroyGLXPixmap (Display *dpy, GLXPixmap pix);Synchronize execution:void glXWaitGL (void);void glXWaitX (void);Exchange front and back buffers:void glXSwapBuffers (Display *dpy, Window window);Use an X font:void glXUseXFont (Font font, int first, int count, int listBase);LBL="4"ID="68318"Defined Constants and Associated CommandsThis chapter lists all the defined constants in OpenGL and their corresponding commands; these constants might indicate a parameter name, a value for a parameter, a mode, a query target, or a return value. The list is intended to be used as another index into the reference pages: if you remember the name of a constant, you can use this table to find out which functions use it, and then you can refer to the reference pages for those functions for more information. Note that all the constants listed can be used directly by the corresponding commands; the reference pages list additional, related commands that might be of interest. COLUMNS="2"LEFT="0" WIDTH="197"ConstantLEFT="205" WIDTH="150"Associated CommandsLEFT="0" WIDTH="197"GL_2D, GL_3D, GL_3D_COLOR, 
GL_COLOR_TEXTURE, 
GL_4D_COLOR_TEXTURELEFT="205" WIDTH="150"glFeedbackBuffer()LEFT="0" WIDTH="197"GL_2_BYTES, GL_3_BYTES, GL_4_BYTESLEFT="205" WIDTH="150"glCallLists()LEFT="0" WIDTH="197"GL_ACCUMLEFT="205" WIDTH="150"glAccum()LEFT="0" WIDTH="197"GL_ACCUM_ALPHA_BITS, 
GL_ACCUM_BLUE_BITSLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_ACCUM_BUFFER_BITLEFT="205" WIDTH="150"glClear(), glPushAttrib()LEFT="0" WIDTH="197"GL_ACCUM_CLEAR_VALUE, 
GL_ACCUM_GREEN_BITS, 
GL_ACCUM_RED_BITSLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_ADDLEFT="205" WIDTH="150"glAccum()LEFT="0" WIDTH="197"GL_ALL_ATTRIB_BITSLEFT="205" WIDTH="150"glPushAttrib()LEFT="0" WIDTH="197"GL_ALPHALEFT="205" WIDTH="150"glDrawPixels(), glReadPixels(), 
glTexImage1D(), glTexImage2D(), 
glGetTexImage()LEFT="0" WIDTH="197"GL_ALPHA_BIASLEFT="205" WIDTH="150"glPixelTransfer*(), glGet*()LEFT="0" WIDTH="197"GL_ALPHA_BITS LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_ALPHA_SCALELEFT="205" WIDTH="150"glPixelTransfer*(), glGet*()LEFT="0" WIDTH="197"GL_ALPHA_TESTLEFT="205" WIDTH="150"glEnable(), glIsEnabled(), glGet*()LEFT="0" WIDTH="197"GL_ALPHA_TEST_FUNC, 
GL_ALPHA_TEST_REFLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_ALWAYSLEFT="205" WIDTH="150"glAlphaFunc(), glDepthFunc(), 
glStencilFunc()LEFT="0" WIDTH="197"GL_AMBIENTLEFT="205" WIDTH="150"glLight*(), glGetLight*(), 
glMaterial*(), glGetMaterial*(), 
glColorMaterial()LEFT="0" WIDTH="197"GL_AMBIENT_AND_DIFFUSELEFT="205" WIDTH="150"glMaterial*(), glGetMaterial*(), 
glColorMaterial()LEFT="0" WIDTH="197"GL_AND, GL_AND_INVERTED, 
GL_AND_REVERSELEFT="205" WIDTH="150"glLogicOp()LEFT="0" WIDTH="197"GL_ATTRIB_STACK_DEPTH LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_AUTO_NORMALLEFT="205" WIDTH="150"glEnable(), glIsEnabled(), glGet*()LEFT="0" WIDTH="197"GL_AUX0 through GL_AUX3LEFT="205" WIDTH="150"glDrawBuffer(), glReadBuffer()LEFT="0" WIDTH="197"GL_AUX_BUFFERSLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_BACKLEFT="205" WIDTH="150"glColorMaterial(), glCullFace(), 
glDrawBuffer(), glReadBuffer(), 
glMaterial*(), glGetMaterial*(), 
glPolygonMode()LEFT="0" WIDTH="197"GL_BACK_LEFT, GL_BACK_RIGHTLEFT="205" WIDTH="150"glDrawBuffer(), glReadBuffer()LEFT="0" WIDTH="197"GL_BITMAPLEFT="205" WIDTH="150"glDrawPixels(), glReadPixels(), 
glTexImage1D(), glTexImage2D(), 
glGetTexImage()LEFT="0" WIDTH="197"GL_BITMAP_TOKENLEFT="205" WIDTH="150"glPassThrough()LEFT="0" WIDTH="197"GL_BLENDLEFT="205" WIDTH="150"glTexEnv*(), glGetTexEnv*(), 
glEnable(), glIsEnabled(), glGet*()LEFT="0" WIDTH="197"GL_BLEND_DST, GL_BLEND_SRCLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_BLUELEFT="205" WIDTH="150"glDrawPixels(), glReadPixels(), 
glTexImage1D(), glTexImage2D(), 
glGetTexImage()LEFT="0" WIDTH="197"GL_BLUE_BIASLEFT="205" WIDTH="150"glPixelTransfer*(), glGet*()LEFT="0" WIDTH="197"GL_BLUE_BITS LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_BLUE_SCALELEFT="205" WIDTH="150"glPixelTransfer*(), glGet*()LEFT="0" WIDTH="197"GL_BYTELEFT="205" WIDTH="150"glCallLists(), glDrawPixels(), 
glReadPixels(), glTexImage1D(), 
glTexImage2D(), glGetTexImage()LEFT="0" WIDTH="197"GL_CCWLEFT="205" WIDTH="150"glFrontFace()LEFT="0" WIDTH="197"GL_CLAMPLEFT="205" WIDTH="150"glTexParameter*()LEFT="0" WIDTH="197"GL_CLEARLEFT="205" WIDTH="150"glLogicOp()LEFT="0" WIDTH="197"GL_CLIP_PLANELEFT="205" WIDTH="150"glEnable(), glIsEnabled()LEFT="0" WIDTH="197"GL_CLIP_PLANE0 through GL_CLIP_PLANE5LEFT="205" WIDTH="150"glClipPlane(), glGetClipPlane(), 
glEnable(), glIsEnabled()LEFT="0" WIDTH="197"GL_COEFFLEFT="205" WIDTH="150"glGetMap*()LEFT="0" WIDTH="197"GL_COLORLEFT="205" WIDTH="150"glCopyPixels()LEFT="0" WIDTH="197"GL_COLOR_BUFFER_BITLEFT="205" WIDTH="150"glClear(), glPushAttrib()LEFT="0" WIDTH="197"GL_COLOR_CLEAR_VALUE LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_COLOR_INDEXLEFT="205" WIDTH="150"glDrawPixels(), glReadPixels(), 
glTexImage1D(), glTexImage2D(), 
glGetTexImage()LEFT="0" WIDTH="197"GL_COLOR_INDEXESLEFT="205" WIDTH="150"glMaterial*(), glGetMaterial*()LEFT="0" WIDTH="197"GL_COLOR_MATERIALLEFT="205" WIDTH="150"glEnable(), glIsEnabled(), glGet*()LEFT="0" WIDTH="197"GL_COLOR_MATERIAL_FACE, 
GL_COLOR_MATERIAL_PARAMETERLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_COLOR_WRITEMASK LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_COMPILE, 
GL_COMPILE_AND_EXECUTELEFT="205" WIDTH="150"glNewList()LEFT="0" WIDTH="197"GL_CONSTANT_ATTENUATIONLEFT="205" WIDTH="150"glLight*(), glGetLight*()LEFT="0" WIDTH="197"GL_COPY, GL_COPY_INVERTEDLEFT="205" WIDTH="150"glLogicOp()LEFT="0" WIDTH="197"GL_COPY_PIXEL_TOKENLEFT="205" WIDTH="150"glPassThrough()LEFT="0" WIDTH="197"GL_CULL_FACELEFT="205" WIDTH="150"glEnable(), glIsEnabled(), glGet*()LEFT="0" WIDTH="197"GL_CULL_FACE_MODE LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_CURRENT_BITLEFT="205" WIDTH="150"glPushAttrib()LEFT="0" WIDTH="197"GL_CURRENT_COLOR, 
GL_CURRENT_INDEX, 
GL_CURRENT_NORMAL, 
GL_CURRENT_RASTER_COLOR, 
GL_CURRENT_RASTER_INDEX, 
GL_CURRENT_RASTER_POSITION, 
GL_CURRENT_RASTER_POSITION_VALID, 
GL_CURRENT_RASTER_TEXTURE_COORDS,
GL_CURRENT_TEXTURE_COORDSLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_CWLEFT="205" WIDTH="150"glFrontFace()LEFT="0" WIDTH="197"GL_DECALLEFT="205" WIDTH="150"glTexEnv*(), glGetTexEnv*()LEFT="0" WIDTH="197"GL_DECRLEFT="205" WIDTH="150"glStencilOp()LEFT="0" WIDTH="197"GL_DEPTHLEFT="205" WIDTH="150"glCopyPixels()LEFT="0" WIDTH="197"GL_DEPTH_BIASLEFT="205" WIDTH="150"glPixelTransfer*(), glGet*()LEFT="0" WIDTH="197"GL_DEPTH_BITS LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_DEPTH_BUFFER_BITLEFT="205" WIDTH="150"glClear(), glPushAttrib()LEFT="0" WIDTH="197"GL_DEPTH_CLEAR_VALUE LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_DEPTH_COMPONENTLEFT="205" WIDTH="150"glDrawPixels(), glReadPixels(), 
glTexImage1D(), glTexImage2D(), 
glGetTexImage()LEFT="0" WIDTH="197"GL_DEPTH_FUNC LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_DEPTH_RANGELEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_DEPTH_SCALELEFT="205" WIDTH="150"glPixelTransfer*(), glGet*()LEFT="0" WIDTH="197"GL_DEPTH_TESTLEFT="205" WIDTH="150"glEnable(), glIsEnabled(), glGet*()LEFT="0" WIDTH="197"GL_DEPTH_WRITEMASK LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_DIFFUSELEFT="205" WIDTH="150"glLight*(), glGetLight*(), 
glMaterial*(), glGetMaterial*(), 
glColorMaterial()LEFT="0" WIDTH="197"GL_DITHERLEFT="205" WIDTH="150"glEnable(), glIsEnabled(), glGet*()LEFT="0" WIDTH="197"GL_DOMAINLEFT="205" WIDTH="150"glGetMap*()LEFT="0" WIDTH="197"GL_DONT_CARELEFT="205" WIDTH="150"glHint()LEFT="0" WIDTH="197"GL_DOUBLEBUFFER LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_DRAW_BUFFERLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_DRAW_PIXEL_TOKENLEFT="205" WIDTH="150"glPassThrough()LEFT="0" WIDTH="197"GL_DST_ALPHA, GL_DST_COLORLEFT="205" WIDTH="150"glBlendFunc()LEFT="0" WIDTH="197"GL_EDGE_FLAG LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_EMISSIONLEFT="205" WIDTH="150"glMaterial*(), glGetMaterial*(), 
glColorMaterial()LEFT="0" WIDTH="197"GL_ENABLE_BITLEFT="205" WIDTH="150"glPushAttrib()LEFT="0" WIDTH="197"GL_EQUALLEFT="205" WIDTH="150"glAlphaFunc(), glDepthFunc(), 
glStencilFunc()LEFT="0" WIDTH="197"GL_EQUIVLEFT="205" WIDTH="150"glLogicOp()LEFT="0" WIDTH="197"GL_EVAL_BITLEFT="205" WIDTH="150"glPushAttrib()LEFT="0" WIDTH="197"GL_EXP, GL_EXP2LEFT="205" WIDTH="150"glFog*()LEFT="0" WIDTH="197"GL_EXTENSIONSLEFT="205" WIDTH="150"glGetString()LEFT="0" WIDTH="197"GL_EYE_LINEARLEFT="205" WIDTH="150"glTexGen*(), glGetTexGen*()LEFT="0" WIDTH="197"GL_EYE_PLANELEFT="205" WIDTH="150"glTexGen*()LEFT="0" WIDTH="197"GL_FALSELEFT="205" WIDTH="150"glColorMask(), glGet*(), 
glIsEnabled(), glIsList()LEFT="0" WIDTH="197"GL_FASTESTLEFT="205" WIDTH="150"glHint()LEFT="0" WIDTH="197"GL_FEEDBACKLEFT="205" WIDTH="150"glRenderMode()LEFT="0" WIDTH="197"GL_FILLLEFT="205" WIDTH="150"glPolygonMode(), glEvalMesh2()LEFT="0" WIDTH="197"GL_FLATLEFT="205" WIDTH="150"glShadeModel()LEFT="0" WIDTH="197"GL_FLOATLEFT="205" WIDTH="150"glCallLists(), glDrawPixels(), 
glReadPixels(), glTexImage1D(), 
glTexImage2D(), glGetTexImage()LEFT="0" WIDTH="197"GL_FOGLEFT="205" WIDTH="150"glEnable(), glIsEnabled(), glGet*()LEFT="0" WIDTH="197"GL_FOG_BITLEFT="205" WIDTH="150"glPushAttrib()LEFT="0" WIDTH="197"GL_FOG_COLOR, GL_FOG_DENSITY, 
GL_FOG_ENDLEFT="205" WIDTH="150"glFog*(), glGet*()LEFT="0" WIDTH="197"GL_FOG_HINTLEFT="205" WIDTH="150"glHint()LEFT="0" WIDTH="197"GL_FOG_INDEX, GL_FOG_MODE, 
GL_FOG_STARTLEFT="205" WIDTH="150"glFog*(), glGet*()LEFT="0" WIDTH="197"GL_FRONTLEFT="205" WIDTH="150"glColorMaterial(), glCullFace(), 
glDrawBuffer(), glReadBuffer(), 
glMaterial*(), glGetMaterial*(), 
glPolygonMode()LEFT="0" WIDTH="197"GL_FRONT_AND_BACKLEFT="205" WIDTH="150"glColorMaterial(), glDrawBuffer(), 
glMaterial*(), glPolygonMode()LEFT="0" WIDTH="197"GL_FRONT_FACE LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_FRONT_LEFT, GL_FRONT_RIGHTLEFT="205" WIDTH="150"glDrawBuffer(), glReadBuffer()LEFT="0" WIDTH="197"GL_GEQUAL, GL_GREATERLEFT="205" WIDTH="150"glDepthFunc(), glAlphaFunc(), 
glStencilFunc()LEFT="0" WIDTH="197"GL_GREENLEFT="205" WIDTH="150"glDrawPixels(), glReadPixels(), 
glTexImage1D(), glTexImage2D(), 
glGetTexImage()LEFT="0" WIDTH="197"GL_GREEN_BIASLEFT="205" WIDTH="150"glPixelTransfer*(), glGet*()LEFT="0" WIDTH="197"GL_GREEN_BITS LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_GREEN_SCALELEFT="205" WIDTH="150"glPixelTransfer*(), glGet*()LEFT="0" WIDTH="197"GL_HINT_BITLEFT="205" WIDTH="150"glPushAttrib()LEFT="0" WIDTH="197"GL_INCRLEFT="205" WIDTH="150"glStencilOp()LEFT="0" WIDTH="197"GL_INDEX_BITS, GL_INDEX_CLEAR_VALUE, 
GL_INDEX_MODELEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_INDEX_OFFSET, GL_INDEX_SHIFTLEFT="205" WIDTH="150"glPixelTransfer*(), glGet*()LEFT="0" WIDTH="197"GL_INDEX_WRITEMASK LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_INTLEFT="205" WIDTH="150"glCallLists(), glDrawPixels(), 
glReadPixels(), glTexImage1D(), 
glTexImage2D(), glGetTexImage()LEFT="0" WIDTH="197"GL_INVALID_ENUM, 
GL_INVALID_OPERATION, 
GL_INVALID_VALUELEFT="205" WIDTH="150"glGetError()LEFT="0" WIDTH="197"GL_INVERTLEFT="205" WIDTH="150"glLogicOp(), glStencilOp()LEFT="0" WIDTH="197"GL_KEEPLEFT="205" WIDTH="150"glStencilOp()LEFT="0" WIDTH="197"GL_LEFTLEFT="205" WIDTH="150"glDrawBuffer(), glReadBuffer()LEFT="0" WIDTH="197"GL_LEQUAL, GL_LESSLEFT="205" WIDTH="150"glDepthFunc(), glAlphaFunc(), 
glStencilFunc()LEFT="0" WIDTH="197"GL_LIGHT0 through GL_LIGHT7LEFT="205" WIDTH="150"glLight*(), glGetLight*(), glEnable(), 
glIsEnabled()LEFT="0" WIDTH="197"GL_LIGHTINGLEFT="205" WIDTH="150"glEnable(), glIsEnabled(), glGet*()LEFT="0" WIDTH="197"GL_LIGHTING_BITLEFT="205" WIDTH="150"glPushAttrib()LEFT="0" WIDTH="197"GL_LIGHT_MODEL_AMBIENT, 
GL_LIGHT_MODEL_LOCAL_VIEWER, 
GL_LIGHT_MODEL_TWO_SIDELEFT="205" WIDTH="150"glLightModel*(), glGet*()LEFT="0" WIDTH="197"GL_LINELEFT="205" WIDTH="150"glPolygonMode(), glEvalMesh*()LEFT="0" WIDTH="197"GL_LINEARLEFT="205" WIDTH="150"glFog*(), glTexParameter*()LEFT="0" WIDTH="197"GL_LINEAR_ATTENUATIONLEFT="205" WIDTH="150"glLight*(), glGetLight*()LEFT="0" WIDTH="197"GL_LINEAR_MIPMAP_LINEAR, 
GL_LINEAR_MIPMAP_NEARESTLEFT="205" WIDTH="150"glTexParameter*()LEFT="0" WIDTH="197"GL_LINESLEFT="205" WIDTH="150"glBegin()LEFT="0" WIDTH="197"GL_LINE_BITLEFT="205" WIDTH="150"glPushAttrib()LEFT="0" WIDTH="197"GL_LINE_LOOPLEFT="205" WIDTH="150"glBegin()LEFT="0" WIDTH="197"GL_LINE_RESET_TOKENLEFT="205" WIDTH="150"glPassThrough()LEFT="0" WIDTH="197"GL_LINE_SMOOTHLEFT="205" WIDTH="150"glEnable(), glIsEnabled(), glGet*()LEFT="0" WIDTH="197"GL_LINE_SMOOTH_HINTLEFT="205" WIDTH="150"glHint(), glGet*()LEFT="0" WIDTH="197"GL_LINE_STIPPLELEFT="205" WIDTH="150"glEnable(), glIsEnabled(), glGet*()LEFT="0" WIDTH="197"GL_LINE_STIPPLE_PATTERN, 
GL_LINE_STIPPLE_REPEATLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_LINE_STRIPLEFT="205" WIDTH="150"glBegin()LEFT="0" WIDTH="197"GL_LINE_TOKENLEFT="205" WIDTH="150"glPassThrough()LEFT="0" WIDTH="197"GL_LINE_WIDTH, 
GL_LINE_WIDTH_GRANULARITY, 
GL_LINE_WIDTH_RANGELEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_LIST_BASELEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_LIST_BITLEFT="205" WIDTH="150"glPushAttrib()LEFT="0" WIDTH="197"GL_LIST_INDEX, GL_LIST_MODELEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_LOADLEFT="205" WIDTH="150"glAccum()LEFT="0" WIDTH="197"GL_LOGIC_OPLEFT="205" WIDTH="150"glEnable(), glIsEnabled(), glGet*()LEFT="0" WIDTH="197"GL_LOGIC_OP_MODE LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_LUMINANCE, GL_LUMINANCE_ALPHALEFT="205" WIDTH="150"glDrawPixels(), glReadPixels(), 
glTexImage1D(), glTexImage2D(), 
glGetTexImage()LEFT="0" WIDTH="197"GL_MAP1_COLOR_4LEFT="205" WIDTH="150"glMap1*(), glEnable(), glIsEnabled(), 
glGetMap*()LEFT="0" WIDTH="197"GL_MAP1_GRID_DOMAIN, 
GL_MAP1_GRID_SEGMENTSLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_MAP1_INDEX, GL_MAP1_NORMAL, 
GL_MAP1_TEXTURE_COORD_1 through 
GL_MAP1_TEXTURE_COORD_4, 
GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4LEFT="205" WIDTH="150"glMap1*(), glEnable(), glIsEnabled(), 
glGetMap*()LEFT="0" WIDTH="197"GL_MAP2_COLOR_4LEFT="205" WIDTH="150"glMap2*(), glEnable(), glIsEnabled(), 
glGet*()LEFT="0" WIDTH="197"GL_MAP2_GRID_DOMAINLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_MAP2_GRID_SEGMENTS LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_MAP2_INDEX, GL_MAP2_NORMAL, 
GL_MAP2_TEXTURE_COORD_1 through 
GL_MAP2_TEXTURE_COORD_4, 
GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4LEFT="205" WIDTH="150"glMap2*(), glEnable(), glIsEnabled(), 
glGet*()LEFT="0" WIDTH="197"GL_MAP_COLOR, GL_MAP_STENCILLEFT="205" WIDTH="150"glPixelTransfer*(), glGet*()LEFT="0" WIDTH="197"GL_MATRIX_MODELEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_MAX_ATTRIB_STACK_DEPTH, 
GL_MAX_CLIP_PLANES, 
GL_MAX_EVAL_ORDER, GL_MAX_LIGHTS, 
GL_MAX_LIST_NESTING, 
GL_MAX_MODELVIEW_STACK_DEPTH, 
GL_MAX_NAME_STACK_DEPTH, 
GL_MAX_PIXEL_MAP_TABLE, 
GL_MAX_PROJECTION_STACK_DEPTH, 
GL_MAX_TEXTURE_SIZE, 
GL_MAX_TEXTURE_STACK_DEPTH, 
GL_MAX_VIEWPORT_DIMSLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_MODELVIEWLEFT="205" WIDTH="150"glMatrixMode()LEFT="0" WIDTH="197"GL_MODELVIEW_MATRIX, 
GL_MODELVIEW_STACK_DEPTHLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_MODULATELEFT="205" WIDTH="150"glTexEnv*(), glGetTexEnv*()LEFT="0" WIDTH="197"GL_MULTLEFT="205" WIDTH="150"glAccum()LEFT="0" WIDTH="197"GL_NAME_STACK_DEPTHLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_NANDLEFT="205" WIDTH="150"glLogicOp()LEFT="0" WIDTH="197"GL_NEAREST, 
GL_NEAREST_MIPMAP_LINEAR, 
GL_NEAREST_MIPMAP_NEARESTLEFT="205" WIDTH="150"glTexParameter*()LEFT="0" WIDTH="197"GL_NEVERLEFT="205" WIDTH="150"glDepthFunc(), glAlphaFunc(), 
glStencilFunc()LEFT="0" WIDTH="197"GL_NICESTLEFT="205" WIDTH="150"glHint()LEFT="0" WIDTH="197"GL_NONELEFT="205" WIDTH="150"glDrawBuffer()LEFT="0" WIDTH="197"GL_NOOP, GL_NORLEFT="205" WIDTH="150"glLogicOp()LEFT="0" WIDTH="197"GL_NORMALIZELEFT="205" WIDTH="150"glEnable(), glIsEnabled(), glGet*()LEFT="0" WIDTH="197"GL_NOTEQUALLEFT="205" WIDTH="150"glDepthFunc(), glAlphaFunc(), 
glStencilFunc()LEFT="0" WIDTH="197"GL_NO_ERRORLEFT="205" WIDTH="150"glGetError()LEFT="0" WIDTH="197"GL_OBJECT_LINEARLEFT="205" WIDTH="150"glTexGen*(), glGetTexGen*()LEFT="0" WIDTH="197"GL_OBJECT_PLANELEFT="205" WIDTH="150"glTexGen*()LEFT="0" WIDTH="197"GL_ONE, GL_ONE_MINUS_DST_ALPHA, 
GL_ONE_MINUS_DST_COLOR, 
GL_ONE_MINUS_SRC_ALPHA, 
GL_ONE_MINUS_SRC_COLORLEFT="205" WIDTH="150"glBlendFunc()LEFT="0" WIDTH="197"GL_OR, GL_OR_INVERTED, 
GL_OR_REVERSELEFT="205" WIDTH="150"glLogicOp()LEFT="0" WIDTH="197"GL_ORDERLEFT="205" WIDTH="150"glGetMap*()LEFT="0" WIDTH="197"GL_OUT_OF_MEMORYLEFT="205" WIDTH="150"glGetError()LEFT="0" WIDTH="197"GL_PACK_ALIGNMENT, 
GL_PACK_LSB_FIRST, 
GL_PACK_ROW_LENGTH, 
GL_PACK_SKIP_PIXELS, 
GL_PACK_SKIP_ROWS, 
GL_PACK_SWAP_BYTESLEFT="205" WIDTH="150"glPixelStore*(), glGet*()LEFT="0" WIDTH="197"GL_PASS_THROUGH_TOKENLEFT="205" WIDTH="150"glPassThrough()LEFT="0" WIDTH="197"GL_PERSPECTIVE_CORRECTION_HINTLEFT="205" WIDTH="150"glHint(), glGet*()LEFT="0" WIDTH="197"GL_PIXEL_MAP_*_TO_*LEFT="205" WIDTH="150"glPixelMap*(), glGetPixelMap*()LEFT="0" WIDTH="197"GL_PIXEL_MAP_*_TO_*_SIZELEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_PIXEL_MODE_BITLEFT="205" WIDTH="150"glPushAttrib()LEFT="0" WIDTH="197"GL_POINTLEFT="205" WIDTH="150"glPolygonMode(), glEvalMesh*()LEFT="0" WIDTH="197"GL_POINTSLEFT="205" WIDTH="150"glBegin()LEFT="0" WIDTH="197"GL_POINT_BITLEFT="205" WIDTH="150"glPushAttrib()LEFT="0" WIDTH="197"GL_POINT_SIZE, 
GL_POINT_SIZE_GRANULARITY, 
GL_POINT_SIZE_RANGELEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_POINT_SMOOTHLEFT="205" WIDTH="150"glEnable(), glIsEnabled(), glGet*()LEFT="0" WIDTH="197"GL_POINT_SMOOTH_HINTLEFT="205" WIDTH="150"glHint(), glGet*()LEFT="0" WIDTH="197"GL_POINT_TOKENLEFT="205" WIDTH="150"glPassThrough()LEFT="0" WIDTH="197"GL_POLYGONLEFT="205" WIDTH="150"glBegin()LEFT="0" WIDTH="197"GL_POLYGON_BITLEFT="205" WIDTH="150"glPushAttrib()LEFT="0" WIDTH="197"GL_POLYGON_MODELEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_POLYGON_SMOOTHLEFT="205" WIDTH="150"glEnable(), glIsEnabled(), glGet*()LEFT="0" WIDTH="197"GL_POLYGON_SMOOTH_HINTLEFT="205" WIDTH="150"glHint(), glGet*()LEFT="0" WIDTH="197"GL_POLYGON_STIPPLELEFT="205" WIDTH="150"glEnable(), glIsEnabled(), glGet*()LEFT="0" WIDTH="197"GL_POLYGON_STIPPLE_BITLEFT="205" WIDTH="150"glPushAttrib()LEFT="0" WIDTH="197"GL_POLYGON_TOKENLEFT="205" WIDTH="150"glPassThrough()LEFT="0" WIDTH="197"GL_POSITIONLEFT="205" WIDTH="150"glLight*(), glGetLight*()LEFT="0" WIDTH="197"GL_PROJECTIONLEFT="205" WIDTH="150"glMatrixMode()LEFT="0" WIDTH="197"GL_PROJECTION_MATRIX, 
GL_PROJECTION_STACK_DEPTHLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_QLEFT="205" WIDTH="150"glTexGen*(), glGetTexGen*()LEFT="0" WIDTH="197"GL_QUADRATIC_ATTENUATIONLEFT="205" WIDTH="150"glLight*(), glGetLight*()LEFT="0" WIDTH="197"GL_QUADS, GL_QUAD_STRIPLEFT="205" WIDTH="150"glBegin()LEFT="0" WIDTH="197"GL_RLEFT="205" WIDTH="150"glTexGen*(), glGetTexGen*()LEFT="0" WIDTH="197"GL_READ_BUFFERLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_REDLEFT="205" WIDTH="150"glDrawPixels(), glReadPixels(), 
glTexImage1D(), glTexImage2D(), 
glGetTexImage()LEFT="0" WIDTH="197"GL_RED_BIASLEFT="205" WIDTH="150"glPixelTransfer*(), glGet*()LEFT="0" WIDTH="197"GL_RED_BITS LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_RED_SCALELEFT="205" WIDTH="150"glPixelTransfer*(), glGet*()LEFT="0" WIDTH="197"GL_RENDERLEFT="205" WIDTH="150"glRenderMode()LEFT="0" WIDTH="197"GL_RENDERERLEFT="205" WIDTH="150"glGetString()LEFT="0" WIDTH="197"GL_RENDER_MODELEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_REPEATLEFT="205" WIDTH="150"glTexParameter*()LEFT="0" WIDTH="197"GL_REPLACELEFT="205" WIDTH="150"glStencilOp()LEFT="0" WIDTH="197"GL_RETURNLEFT="205" WIDTH="150"glAccum()LEFT="0" WIDTH="197"GL_RGBLEFT="205" WIDTH="150"glDrawPixels(), glReadPixels(), 
glTexImage1D(), glTexImage2D(), 
glGetTexImage()LEFT="0" WIDTH="197"GL_RGBALEFT="205" WIDTH="150"glDrawPixels(), glReadPixels(), 
glTexImage1D(), glTexImage2D(), 
glGetTexImage()LEFT="0" WIDTH="197"GL_RGBA_MODE LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_RIGHTLEFT="205" WIDTH="150"glDrawBuffer(), glReadBuffer()LEFT="0" WIDTH="197"GL_SLEFT="205" WIDTH="150"glTexGen*(), glGetTexGen*()LEFT="0" WIDTH="197"GL_SCISSOR_BITLEFT="205" WIDTH="150"glPushAttrib()LEFT="0" WIDTH="197"GL_SCISSOR_BOXLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_SCISSOR_TESTLEFT="205" WIDTH="150"glEnable(), glIsEnabled(), glGet*()LEFT="0" WIDTH="197"GL_SELECTLEFT="205" WIDTH="150"glRenderMode()LEFT="0" WIDTH="197"GL_SETLEFT="205" WIDTH="150"glLogicOp()LEFT="0" WIDTH="197"GL_SHININESSLEFT="205" WIDTH="150"glMaterial*(), glGetMaterial*()LEFT="0" WIDTH="197"GL_SHADE_MODELLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_SHORTLEFT="205" WIDTH="150"glCallLists(), glDrawPixels(), 
glReadPixels(), glTexImage1D(), 
glTexImage2D(), glGetTexImage()LEFT="0" WIDTH="197"GL_SMOOTHLEFT="205" WIDTH="150"glShadeModel()LEFT="0" WIDTH="197"GL_SPECULARLEFT="205" WIDTH="150"glLight*(), glGetLight*(), 
glMaterial*(), glGetMaterial*(), 
glColorMaterial()LEFT="0" WIDTH="197"GL_SPHERE_MAPLEFT="205" WIDTH="150"glTexGen*(), glGetTexGen*()LEFT="0" WIDTH="197"GL_SPOT_CUTOFF, GL_SPOT_DIRECTION, 
GL_SPOT_EXPONENTLEFT="205" WIDTH="150"glLight*(), glGetLight*()LEFT="0" WIDTH="197"GL_SRC_ALPHA, 
GL_SRC_ALPHA_SATURATE, 
GL_SRC_COLORLEFT="205" WIDTH="150"glBlendFunc()LEFT="0" WIDTH="197"GL_STACK_OVERFLOW, 
GL_STACK_UNDERFLOWLEFT="205" WIDTH="150"glGetError()LEFT="0" WIDTH="197"GL_STENCILLEFT="205" WIDTH="150"glCopyPixels()LEFT="0" WIDTH="197"GL_STENCIL_BITSLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_STENCIL_BUFFER_BITLEFT="205" WIDTH="150"glClear(), glPushAttrib()LEFT="0" WIDTH="197"GL_STENCIL_INDEXLEFT="205" WIDTH="150"glDrawPixels(), glReadPixels(), 
glTexImage1D(), glTexImage2D(), 
glGetTexImage()LEFT="0" WIDTH="197"GL_STENCIL_CLEAR_VALUE, 
GL_STENCIL_FAIL, GL_STENCIL_FUNC, 
GL_STENCIL_PASS_DEPTH_FAIL, 
GL_STENCIL_PASS_DEPTH_PASS, 
GL_STENCIL_REFLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_STENCIL_TESTLEFT="205" WIDTH="150"glEnable(), glIsEnabled(), glGet*()LEFT="0" WIDTH="197"GL_STENCIL_VALUE_MASK, 
GL_STENCIL_WRITEMASKLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_STEREOLEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_SUBPIXEL_BITS LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_TLEFT="205" WIDTH="150"glTexGen*(), glGetTexGen*()LEFT="0" WIDTH="197"GL_TEXTURELEFT="205" WIDTH="150"glMatrixMode()LEFT="0" WIDTH="197"GL_TEXTURE_1DLEFT="205" WIDTH="150"glTexImage1D(), glGetTexImage(), 
glTexParameter*(), 
glGetTexParameter*(), 
glGetTexLevelParameter*(), 
glEnable(), glIsEnabled(), glGet*()LEFT="0" WIDTH="197"GL_TEXTURE_2DLEFT="205" WIDTH="150"glTexImage2D(), glGetTexImage(), 
glTexParameter*(), 
glGetTexParameter*(), 
glGetTexLevelParameter*(), 
glEnable(), glIsEnabled(), glGet*()LEFT="0" WIDTH="197"GL_TEXTURE_BITLEFT="205" WIDTH="150"glPushAttrib()LEFT="0" WIDTH="197"GL_TEXTURE_BORDER LEFT="205" WIDTH="150"glGetTexParameter*(), 
glGetTexLevelParameter*()LEFT="0" WIDTH="197"GL_TEXTURE_BORDER_COLORLEFT="205" WIDTH="150"glTexParameter*(), 
glGetTexParameter*(), 
glGetTexLevelParameter*()LEFT="0" WIDTH="197"GL_TEXTURE_COMPONENTS LEFT="205" WIDTH="150"glGetTexParameter*(), 
glGetTexLevelParameter*()LEFT="0" WIDTH="197"GL_TEXTURE_ENV, 
GL_TEXTURE_ENV_COLOR, 
GL_TEXTURE_ENV_MODELEFT="205" WIDTH="150"glTexEnv*(), glGetTexEnv*()LEFT="0" WIDTH="197"GL_TEXTURE_GEN_MODELEFT="205" WIDTH="150"glTexGen*()LEFT="0" WIDTH="197"GL_TEXTURE_GEN_Q, 
GL_TEXTURE_GEN_R, GL_TEXTURE_GEN_S, 
GL_TEXTURE_GEN_TLEFT="205" WIDTH="150"glEnable(), glIsEnabled(), glGet*()LEFT="0" WIDTH="197"GL_TEXTURE_HEIGHT LEFT="205" WIDTH="150"glGetTexParameter*(), 
glGetTexLevelParameter*()LEFT="0" WIDTH="197"GL_TEXTURE_MAG_FILTER LEFT="205" WIDTH="150"glTexParameter*(), 
glGetTexParameter*(), 
glGetTexLevelParameter*()LEFT="0" WIDTH="197"GL_TEXTURE_MATRIX LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_TEXTURE_MIN_FILTER LEFT="205" WIDTH="150"glTexParameter*(), 
glGetTexParameter*(), 
glGetTexLevelParameter*()LEFT="0" WIDTH="197"GL_TEXTURE_STACK_DEPTH LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_TEXTURE_WIDTH LEFT="205" WIDTH="150"glGetTexParameter*(), 
glGetTexLevelParameter*()LEFT="0" WIDTH="197"GL_TEXTURE_WRAP_S, 
GL_TEXTURE_WRAP_TLEFT="205" WIDTH="150"glTexParameter*(), 
glGetTexParameter*(), 
glGetTexLevelParameter*()LEFT="0" WIDTH="197"GL_TRANSFORM_BITLEFT="205" WIDTH="150"glPushAttrib()LEFT="0" WIDTH="197"GL_TRIANGLES, GL_TRIANGLE_FAN, 
GL_TRIANGLE_STRIPLEFT="205" WIDTH="150"glBegin()LEFT="0" WIDTH="197"GL_TRUELEFT="205" WIDTH="150"glColorMask(), glGet*(), 
glIsEnabled(), glIsList()LEFT="0" WIDTH="197"GL_UNPACK_ALIGNMENT, 
GL_UNPACK_LSB_FIRST, 
GL_UNPACK_ROW_LENGTH, 
GL_UNPACK_SKIP_PIXELS, 
GL_UNPACK_SKIP_ROWS, 
GL_UNPACK_SWAP_BYTESLEFT="205" WIDTH="150"glPixelStore*(), glGet*()LEFT="0" WIDTH="197"GL_UNSIGNED_BYTE, GL_UNSIGNED_INT, 
GL_UNSIGNED_SHORTLEFT="205" WIDTH="150"glCallLists(), glDrawPixels(), 
glReadPixels(), glTexImage1D(), 
glTexImage2D(), glGetTexImage()LEFT="0" WIDTH="197"GL_VENDOR, GL_VERSIONLEFT="205" WIDTH="150"glGetString()LEFT="0" WIDTH="197"GL_VIEWPORT LEFT="205" WIDTH="150"glGet*()LEFT="0" WIDTH="197"GL_VIEWPORT_BITLEFT="205" WIDTH="150"glPushAttrib()LEFT="0" WIDTH="197"GL_XORLEFT="205" WIDTH="150"glLogicOp()LEFT="0" WIDTH="197"GL_ZEROLEFT="205" WIDTH="150"glBlendFunc(), glStencilOp()LEFT="0" WIDTH="197"GL_ZOOM_X, GL_ZOOM_YLEFT="205" WIDTH="150"glGet*()LBL="5"ID="14044"OpenGL Reference PagesThis chapter contains the reference pages, in alphabetical order, for all the OpenGL commands. Each reference page may describe more than one related command, as shown in the following list of pages. The OpenGL Utility Library routines and those comprising the OpenGL extension to the X Window System are described in the following chaptersLBL="" HELPID=""ID="20121"glAccumLBL="" HELPID=""NAMEglAccum - operate on the accumulation buffer  LBL="" HELPID=""C SPECIFICATIONvoid glAccum( GLenum op, GLfloat value ) LBL="" HELPID=""PARAMETERSopSpecifies the accumulation buffer operation.  Symbolic constants GL_ACCUM, GL_LOAD, GL_ADD, GL_MULT, and GL_RETURN are accepted.   valueSpecifies a floating-point value used in the accumulation buffer operation.  op determines how value is used.   LBL="" HELPID=""DESCRIPTIONThe accumulation buffer is an extended-range color buffer.  Images are not rendered into it.  Rather, images rendered into one of the color buffers are added to the contents of the accumulation buffer after rendering.  Effects such as antialiasing (of points, lines, and polygons), motion blur, and depth of field can be created by accumulating images generated with different transformation matrices.  Each pixel in the accumulation buffer consists of red, green, blue, and alpha values.  The number of bits per component in the accumulation buffer depends on the implementation. You can examine this number by calling glGetIntegerv four times, with arguments GL_ACCUM_RED_BITS, GL_ACCUM_GREEN_BITS, GL_ACCUM_BLUE_BITS, and GL_ACCUM_ALPHA_BITS, respectively.  Regardless of the number of bits per component, however, the range of values stored by each component is [-1, 1].  The accumulation buffer pixels are mapped one-to-one with frame buffer pixels.  glAccum operates on the accumulation buffer.  The first argument, op, is a symbolic constant that selects an accumulation buffer operation.  The second argument, value, is a floating-point value to be used in that operation.  Five operations are specified: GL_ACCUM, GL_LOAD, GL_ADD, GL_MULT, and GL_RETURN.  All accumulation buffer operations are limited to the area of the current scissor box and are applied identically to the red, green, blue, and alpha components of each pixel.  The contents of an accumulation buffer pixel component are undefined if the glAccum operation results in a value outside the range [-1,1].  The operations are as follows: GL_ACCUMObtains R, G, B, and A values from the buffer currently selected for reading (see IDREF="40151" TYPE="TITLE""glReadBuffer".) Each component value is divided by 2n - 1, where n is the number of bits allocated to each color component in the currently selected buffer.  The result is a floating-point value in the range [0,1], which is multiplied by value and added to the corresponding pixel component in the accumulation buffer, thereby updating the accumulation buffer.  GL_LOAD Similar to GL_ACCUM, except that the current value in the accumulation buffer is not used in the calculation of the new value.  That is, the R, G, B, and A values from the currently selected buffer are divided by  2n - 1, multiplied by value, and then stored in the corresponding accumulation buffer cell, overwriting the current value.  GL_ADD Adds value to each R, G, B, and A in the accumulation buffer.  GL_MULT Multiplies each R, G, B, and A in the accumulation buffer by value and returns the scaled component to its corresponding accumulation buffer location.  GL_RETURN Transfers accumulation buffer values to the color buffer or buffers currently selected for writing.  Each R, G, B, and A component is multiplied by value, then multiplied by  2n - 1, clamped to the range [0, 2n - 1 ], and stored in the corresponding display buffer cell.  The only fragment operations that are applied to this transfer are pixel ownership, scissor, dithering, and color writemasks.  The accumulation buffer is cleared by specifying R, G, B, and A values to set it to with the glClearAccum directive, and issuing a glClear command with the accumulation buffer enabled.  LBL="" HELPID=""NOTESOnly those pixels within the current scissor box are updated by any glAccum operation.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if op is not an accepted value.  GL_INVALID_OPERATION is generated if there is no accumulation buffer.  GL_INVALID_OPERATION is generated if glAccum is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_ACCUM_RED_BITSglGet with argument GL_ACCUM_GREEN_BITSglGet with argument GL_ACCUM_BLUE_BITSglGet with argument GL_ACCUM_ALPHA_BITSLBL="" HELPID=""SEE ALSOIDREF="11446" TYPE="TITLE""glBlendFunc", IDREF="38656" TYPE="TITLE""glClear", IDREF="22877" TYPE="TITLE""glClearAccum", IDREF="25030" TYPE="TITLE""glCopyPixels", IDREF="41087" TYPE="TITLE""glGet",IDREF="18729" TYPE="TITLE""glLogicOp",IDREF="39579" TYPE="TITLE""glPixelStore", IDREF="38440" TYPE="TITLE""glPixelTransfer", IDREF="40261" TYPE="TITLE""glReadPixels", IDREF="40151" TYPE="TITLE""glReadBuffer", IDREF="32335" TYPE="TITLE""glScissor", IDREF="36095" TYPE="TITLE""glStencilOp"LBL="" HELPID=""ID="19142"glAlphaFuncLBL="" HELPID=""NAMEglAlphaFunc - specify the alpha test function  LBL="" HELPID=""C SPECIFICATIONvoid glAlphaFunc( GLenum func, GLclampf ref ) LBL="" HELPID=""PARAMETERSfuncSpecifies the alpha comparison function.  Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted.  The default function is GL_ALWAYS.   refSpecifies the reference value that incoming alpha values are compared to.  This value is clamped to the range 0 through 1, where 0 represents the lowest possible alpha value and 1 the highest possible value.  The default reference is 0.   LBL="" HELPID=""DESCRIPTIONThe alpha test discards fragments depending on the outcome of a comparison between the incoming fragment's alpha value and a constant reference value.  glAlphaFunc specifies the reference and comparison function.  The comparison is performed only if alpha testing is enabled.  (See IDREF="40792" TYPE="TITLE""glEnable" and glDisable of GL_ALPHA_TEST.) func and ref specify the conditions under which the pixel is drawn.  The incoming alpha value is compared to ref using the function specified by func.  If the comparison passes, the incoming fragment is drawn, conditional on subsequent stencil and depth buffer tests.  If the comparison fails, no change is made to the frame buffer at that pixel location.  The comparison functions are as follows: GL_NEVERNever passes.  GL_LESSPasses if the incoming alpha value is less than the reference value.  GL_EQUALPasses if the incoming alpha value is equal to the reference value.  GL_LEQUALPasses if the incoming alpha value is less than or equal to the reference value.  GL_GREATER Passes if the incoming alpha value is greater than the reference value.  GL_NOTEQUALPasses if the incoming alpha value is not equal to the reference value.  GL_GEQUALPasses if the incoming alpha value is greater than or equal to the reference value.  GL_ALWAYSAlways passes.  glAlphaFunc operates on all pixel writes, including those resulting from the scan conversion of points, lines, polygons, and bitmaps, and from pixel draw and copy operations.  glAlphaFunc does not affect screen clear operations.  LBL="" HELPID=""NOTESAlpha testing is done only in RGBA mode.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if func is not an accepted value.  GL_INVALID_OPERATION is generated if glAlphaFunc is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_ALPHA_TEST_FUNCglGet with argument GL_ALPHA_TEST_REFglIsEnabled with argument GL_ALPHA_TESTLBL="" HELPID=""SEE ALSOIDREF="11446" TYPE="TITLE""glBlendFunc", IDREF="38656" TYPE="TITLE""glClear", IDREF="10076" TYPE="TITLE""glDepthFunc", IDREF="40792" TYPE="TITLE""glEnable", IDREF="19234" TYPE="TITLE""glStencilFunc"LBL="" HELPID=""ID="11415"glBeginLBL="" HELPID=""NAMEglBegin, glEnd - delimit the vertices of a primitive or a group of like primitives  LBL="" HELPID=""C SPECIFICATIONvoid glBegin( GLenum mode ) LBL="" HELPID=""PARAMETERSmodeSpecifies the primitive or primitives that will be created from vertices presented between glBegin and the subsequent glEnd.  Ten symbolic constants are accepted: GL_POINTS, GL_LINES, GL_LINE_STRIP, GL_LINE_LOOP, GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_QUADS, GL_QUAD_STRIP, and GL_POLYGON.  LBL="" HELPID=""C SPECIFICATIONvoid glEnd( void ) LBL="" HELPID=""DESCRIPTIONglBegin and glEnd delimit the vertices that define a primitive or a group of like primitives.  glBegin accepts a single argument that specifies which of ten ways the vertices are interpreted.  Taking n as an integer count starting at one, and N as the total number of vertices specified, the interpretations are as follows: GL_POINTSTreats each vertex as a single point.  Vertex n defines point n.  N points are drawn.  GL_LINESTreates each pair of vertices as an independent line segment.  Vertices 2n-1 and 2n define line n.  N/2 lines are drawn.  GL_LINE_STRIPDraws a connected group of line segments from the first vertex to the last.  Vertices n and n+1 define line n.  N-1 lines drawn. GL_LINE_LOOPDraws a connected group of line segments from the first vertex to the last, then back to the first.  Vertices n and n+1 define line n.  The last line, however, is defined by vertices N and 1.  N lines are drawn.  GL_TRIANGLESTreates each triplet of vertices as an independent triangle.  Vertices 3n-2, 3n-1, and 3n define triangle n.  N/3 triangles are drawn.  GL_TRIANGLE_STRIPDraws a connected group of triangles.  One triangle is defined for each vertex presented after the first two vertices.  For odd n, vertices n, n+1, and n+2 define triangle n.  For even n, vertices n+1, n, and n+2 define triangle n.  N-2 triangles are drawn.  GL_TRIANGLE_FANDraws a connected group of triangles.  One triangle is defined for each vertex presented after the first two vertices.  Vertices 1, n+1, and n+2 define triangle n.  N-2 triangles are drawn.  GL_QUADSTreats each group of four vertices as an independent quadrilateral.  Vertices 4n-3, 4n-2, 4n-1, and 4n define quadrilateral n.  N/4 quadrilaterals are drawn.  GL_QUAD_STRIPDraws a connected group of quadrilaterals.  One quadrilateral is defined for each pair of vertices presented after the first pair.  Vertices 2n-1, 2n, 2n+2, and 2n+1 define quadrilateral n.  N/2-1 quadrilaterals are drawn.  Note that the order in which vertices are used to construct a quadrilateral from strip data is different from that used with independent data.  GL_POLYGONDraws a single, convex polygon.  Vertices 1 through N define this polygon.  Only a subset of GL commands can be used between glBegin and glEnd.  The commands are glVertex, glColor, glIndex, glNormal, glTexCoord, glEvalCoord, glEvalPoint, glMaterial, and glEdgeFlag.  Also, it is acceptable to use glCallList or glCallLists to execute display lists that include only the preceding commands.  If any other GL command is called between glBegin and glEnd, the error flag is set and the command is ignored.  Regardless of the value chosen for mode, there is no limit to the number of vertices that can be defined between glBegin and glEnd.  Lines, triangles, quadrilaterals, and polygons that are incompletely specified are not drawn.  Incomplete specification results when either too few vertices are provided to specify even a single primitive or when an incorrect multiple of vertices is specified. The incomplete primitive is ignored; the rest are drawn.  The minimum specification of vertices for each primitive is as follows: 1 for a point, 2 for a line, 3 for a triangle, 4 for a quadrilateral, and 3 for a polygon.  Modes that require a certain multiple of vertices are GL_LINES (2), GL_TRIANGLES (3), GL_QUADS (4), and GL_QUAD_STRIP (2).  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if mode is set to an unaccepted value.  GL_INVALID_OPERATION is generated if a command other than glVertex, glColor, glIndex, glNormal, glTexCoord, glEvalCoord, glEvalPoint, glMaterial, glEdgeFlag, glCallList, or glCallLists is called between glBegin and the corresponding glEnd.  GL_INVALID_OPERATION is generated if glEnd is called before the corresponding glBegin is called, or if glBegin is called within a glBegin/glEnd sequence.  LBL="" HELPID=""SEE ALSOIDREF="37134" TYPE="TITLE""glCallList", IDREF="15751" TYPE="TITLE""glCallLists", IDREF="18325" TYPE="TITLE""glColor", IDREF="40044" TYPE="TITLE""glEdgeFlag", IDREF="41102" TYPE="TITLE""glEvalCoord", IDREF="14631" TYPE="TITLE""glEvalPoint", IDREF="14741" TYPE="TITLE""glIndex", IDREF="28170" TYPE="TITLE""glMaterial", IDREF="12825" TYPE="TITLE""glNormal", IDREF="31124" TYPE="TITLE""glTexCoord", IDREF="32860" TYPE="TITLE""glVertex"LBL="" HELPID=""ID="23412"glBitmapLBL="" HELPID=""NAMEglBitmap - draw a bitmap  LBL="" HELPID=""C SPECIFICATIONvoid glBitmap( GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap ) LBL="" HELPID=""PARAMETERSwidth, heightSpecify the pixel width and height of the bitmap image.xorig, yorigSpecify the location of the origin in the bitmap image.  The origin is measured from the lower left corner of the bitmap, with right and up being the positive axes.xmove, ymoveSpecify the x and y offsets to be added to the current raster position after the bitmap is drawn.bitmapSpecifies the address of the bitmap image.LBL="" HELPID=""DESCRIPTIONA bitmap is a binary image.  When drawn, the bitmap is positioned relative to the current raster position, and frame buffer pixels corresponding to ones in the bitmap are written using the current raster color or index.  Frame buffer pixels corresponding to zeros in the bitmap are not modified.  glBitmap takes seven arguments.  The first pair specify the width and height of the bitmap image.  The second pair specify the location of the bitmap origin relative to the lower left corner of the bitmap image.  The third pair of arguments specify x and y offsets to be added to the current raster position after the bitmap has been drawn.  The final argument is a pointer to the bitmap image itself.  The bitmap image is interpreted like image data for the glDrawPixels command, with width and height corresponding to the width and height arguments of that command, and with type set to GL_BITMAP and format set to GL_COLOR_INDEX.  Modes specified using glPixelStore affect the interpretation of bitmap image data; modes specified using glPixelTransfer do not.  If the current raster position is invalid, glBitmap is ignored.  Otherwise, the lower left corner of the bitmap image is positioned at the window coordinatesFILE="eq05_01.gif" POSITION="INLINE" SCALE="FALSE"where  ( xr , yr )  is the raster position and  ( xo , yo )  is the bitmap origin.  Fragments are then generated for each pixel corresponding to a one in the bitmap image.  These fragments are generated using the current raster z coordinate, color or color index, and current raster texture coordinates.  They are then treated just as if they had been generated by a point, line, or polygon, including texture mapping, fogging, and all per-fragment operations such as alpha and depth testing.  After the bitmap has been drawn, the x and y coordinates of the current raster position are offset by xmove and ymove.  No change is made to the z coordinate of the current raster position, or to the current raster color, index, or texture coordinates.  LBL="" HELPID=""ERRORSGL_INVALID_VALUE is generated if width or height is negative.  GL_INVALID_OPERATION is generated if glBitmap is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_CURRENT_RASTER_POSITIONglGet with argument GL_CURRENT_RASTER_COLORglGet with argument GL_CURRENT_RASTER_INDEXglGet with argument GL_CURRENT_RASTER_TEXTURE_COORDSglGet with argument GL_CURRENT_RASTER_POSITION_VALIDLBL="" HELPID=""SEE ALSOIDREF="41928" TYPE="TITLE""glDrawPixels", IDREF="40922" TYPE="TITLE""glRasterPos", IDREF="39579" TYPE="TITLE""glPixelStore", IDREF="38440" TYPE="TITLE""glPixelTransfer"LBL="" HELPID=""ID="11446"glBlendFuncLBL="" HELPID=""NAMEglBlendFunc - specify pixel arithmetic  LBL="" HELPID=""C SPECIFICATIONvoid glBlendFunc( GLenum sfactor, GLenum dfactor ) LBL="" HELPID=""PARAMETERSsfactorSpecifies how the red, green, blue, and alpha source-blending factors are computed.  Nine symbolic constants are accepted: GL_ZERO, GL_ONE, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, and GL_SRC_ALPHA_SATURATE.  dfactorSpecifies how the red, green, blue, and alpha destination blending factors are computed.  Eight symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, and GL_ONE_MINUS_DST_ALPHA.LBL="" HELPID=""DESCRIPTIONIn RGB mode, pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values).  By default, blending is disabled.  Use glEnable and glDisable with argument GL_BLEND to enable and disable blending.  glBlendFunc defines the operation of blending when it is enabled.  sfactor specifies which of nine methods is used to scale the source color components.  dfactor specifies which of eight methods is used to scale the destination color components.  The eleven possible methods are described in the table below.  Each method defines four scale factors, one each for red, green, blue, and alpha.  In the table and in subsequent equations, source and destination color components are referred to as (Rs , Gs , Bs , As ) and (Rd , Gd , Bd , Ad ).  They are understood to have integer values between zero and (kR , kG , kB , kA ), where FILE="eq05_02.gif" POSITION="INLINE" SCALE="FALSE"and (mR , mG , mB , mA ) is the number of red, green, blue, and alpha bitplanes.  Source and destination scale factors are referred to as (sR , sG , sB , sA ) and (dR , dG , dB , dA ).  The scale factors described in the table, denoted (fR , fG , fB , fA ), represent either source or destination factors.  All scale factors have range [0,1].  COLUMNS="2"LEFT="0" WIDTH="153"parameter LEFT="160" WIDTH="189"(fR ,  fG ,  fB ,  fA )LEFT="0" WIDTH="153"GL_ZEROLEFT="160" WIDTH="189"(0,  0,  0,  0 )LEFT="0" WIDTH="153"GL_ONELEFT="160" WIDTH="189"(1,  1,  1,  1 )LEFT="0" WIDTH="153"GL_SRC_COLORLEFT="160" WIDTH="189"(Rs / kR ,  Gs / kG ,  Bs / kB ,  As / kA )LEFT="0" WIDTH="153"GL_ONE_MINUS_SRC_COLORLEFT="160" WIDTH="189"(1,  1,  1,  1 )  -  (Rs / kR ,  Gs / kG ,  Bs / kB ,  As 
/ kA)LEFT="0" WIDTH="153"GL_DST_COLORLEFT="160" WIDTH="189"(Rd / kR ,  Gd / kG ,  Bd / kB ,  Ad / kA)LEFT="0" WIDTH="153"GL_ONE_MINUS_DST_COLORLEFT="160" WIDTH="189"(1,  1,  1,  1 )  -  (Rd / kR ,  Gd / kG ,  Bd / kB ,  Ad 
/ kA )LEFT="0" WIDTH="153"GL_SRC_ALPHALEFT="160" WIDTH="189"(As / kA ,  As / kA ,  As / kA ,  As / kA )LEFT="0" WIDTH="153"GL_ONE_MINUS_SRC_ALPHALEFT="160" WIDTH="189"(1,  1,  1,  1 )  -  (As / kA ,  As / kA ,  As / kA ,  As 
/ kA)LEFT="0" WIDTH="153"GL_DST_ALPHALEFT="160" WIDTH="189"(Ad / kA ,  Ad / kA ,  Ad / kA ,  Ad / kA)LEFT="0" WIDTH="153"GL_ONE_MINUS_DST_ALPHALEFT="160" WIDTH="189"(1,  1,  1,  1 )  -  (Ad / kA ,  Ad / kA ,  Ad / kA ,  
Ad / kA)LEFT="0" WIDTH="153"GL_SRC_ALPHA_SATURATELEFT="160" WIDTH="189"(i,  i,  i,  1 )In the table, i  =  min (As ,  kA - Ad )  /  kATo determine the blended RGBA values of a pixel when drawing in RGB mode, the system uses the following equations: Rd  =  min ( kR ,  Rs sR + Rd dR )Gd  =  min ( kG ,  Gs sG + Gd dG )Bd  =  min ( kB ,  Bs sB + Bd dB )Ad  =  min ( kA ,  As sA + Ad dA )Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates with imprecise integer color values.  However, a blend factor that should be equal to one is guaranteed not to modify its multiplicand, and a blend factor equal to zero reduces its multiplicand to zero.  Thus, for example, when sfactor is GL_SRC_ALPHA, dfactor is GL_ONE_MINUS_SRC_ALPHA, and As is equal to kA, the equations reduce to simple replacement: Rd  =  RsGd  =  GsBd  =  BsAd  =  AsLBL="" HELPID=""EXAMPLESTransparency is best implemented using blend function (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA) with primitives sorted from farthest to nearest.  Note that this transparency calculation does not require the presence of alpha bitplanes in the frame buffer.  Blend function (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA) is also useful for rendering antialiased points and lines in arbitrary order.  Polygon antialiasing is optimized using blend function (GL_SRC_ALPHA_SATURATE, GL_ONE) with polygons sorted from nearest to farthest.  (See the IDREF="40792" TYPE="TITLE""glEnable", glDisable reference page and the GL_POLYGON_SMOOTH argument for information on polygon antialiasing.) Destination alpha bitplanes, which must be present for this blend function to operate correctly, store the accumulated coverage. LBL="" HELPID=""NOTESIncoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 (KA), representing complete opacity, to 0.0 (0), representing completely transparency.  When more than one color buffer is enabled for drawing, blending is done separately for each enabled buffer, using for destination color the contents of that buffer.  (See IDREF="18132" TYPE="TITLE""glDrawBuffer".) Blending affects only RGB rendering.  It is ignored by color index renderers. LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if either sfactor or dfactor is not an accepted value.  GL_INVALID_OPERATION is generated if glBlendFunc is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_BLEND_SRCglGet with argument GL_BLEND_DSTglIsEnabled with argument GL_BLENDLBL="" HELPID=""SEE ALSOIDREF="19142" TYPE="TITLE""glAlphaFunc", IDREF="38656" TYPE="TITLE""glClear", IDREF="18132" TYPE="TITLE""glDrawBuffer", IDREF="40792" TYPE="TITLE""glEnable", IDREF="18729" TYPE="TITLE""glLogicOp", IDREF="19234" TYPE="TITLE""glStencilFunc"LBL="" HELPID=""ID="37134"glCallListLBL="" HELPID=""NAMEglCallList - execute a display list  LBL="" HELPID=""C SPECIFICATIONvoid glCallList( GLuint list ) LBL="" HELPID=""PARAMETERSlistSpecifies the integer name of the display list to be executed. LBL="" HELPID=""DESCRIPTIONglCallList causes the named display list to be executed.  The commands saved in the display list are executed in order, just as if they were called without using a display list.  If list has not been defined as a display list, glCallList is ignored.  glCallList can appear inside a display list.  To avoid the possibility of infinite recursion resulting from display lists calling one another, a limit is placed on the nesting level of display lists during display-list execution.  This limit is at least 64, and it depends on the implementation.  GL state is not saved and restored across a call to glCallList.  Thus, changes made to GL state during the execution of a display list remain after execution of the display list is completed.  Use glPushAttrib, glPopAttrib, glPushMatrix, and glPopMatrix to preserve GL state across glCallList calls.  LBL="" HELPID=""NOTESDisplay lists can be executed between a call to glBegin and the corresponding call to glEnd, as long as the display list includes only commands that are allowed in this interval.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_MAX_LIST_NESTINGglIsListLBL="" HELPID=""SEE ALSOIDREF="15751" TYPE="TITLE""glCallLists", IDREF="13566" TYPE="TITLE""glDeleteLists", IDREF="12827" TYPE="TITLE""glGenLists", IDREF="28073" TYPE="TITLE""glNewList", IDREF="12225" TYPE="TITLE""glPushAttrib", IDREF="41698" TYPE="TITLE""glPushMatrix"LBL="" HELPID=""ID="15751"glCallListsLBL="" HELPID=""NAMEglCallLists - execute a list of display lists  LBL="" HELPID=""C SPECIFICATIONvoid glCallLists( GLsizei n, GLenum type, const GLvoid *lists ) LBL="" HELPID=""PARAMETERSnSpecifies the number of display lists to be executed. typeSpecifies the type of values in lists.  Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, GL_2_BYTES, GL_3_BYTES, and GL_4_BYTES are accepted. listsSpecifies the address of an array of name offsets in the display list.  The pointer type is void because the offsets can be bytes, shorts, ints, or floats, depending on the value of type. LBL="" HELPID=""DESCRIPTIONglCallLists causes each display list in the list of names passed as lists to be executed.  As a result, the commands saved in each display list are executed in order, just as if they were called without using a display list.  Names of display lists that have not been defined are ignored.  glCallLists provides an efficient means for executing display lists.  n allows lists with various name formats to be accepted.  The formats are as follows: GL_BYTElists is treated as an array of signed bytes, each in the range -128 through 127.  GL_UNSIGNED_BYTElists is treated as an array of unsigned bytes, each in the range 0 through 255.  GL_SHORTlists is treated as an array of signed two-byte integers, each in the range -32768 through 32767.  GL_UNSIGNED_SHORTlists is treated as an array of unsigned two-byte integers, each in the range 0 through 65535.  GL_INTlists is treated as an array of signed four-byte integers.  GL_UNSIGNED_INTlists is treated as an array of unsigned four-byte integers.  GL_FLOATlists is treated as an array of four-byte floating-point values.  GL_2_BYTESlists is treated as an array of unsigned bytes.  Each pair of bytes specifies a single display-list name.  The value of the pair is computed as 256 times the unsigned value of the first byte plus the unsigned value of the second byte.  GL_3_BYTESlists is treated as an array of unsigned bytes.  Each triplet of bytes specifies a single display-list name.  The value of the triplet is computed as 65536 times the unsigned value of the first byte, plus 256 times the unsigned value of the second byte, plus the unsigned value of the third byte.  GL_4_BYTESlists is treated as an array of unsigned bytes.  Each quadruplet of bytes specifies a single display-list name.  The value of the quadruplet is computed as 16777216 times the unsigned value of the first byte, plus 65536 times the unsigned value of the second byte, plus 256 times the unsigned value of the third byte, plus the unsigned value of the fourth byte.  The list of display list names is not null-terminated.  Rather, n specifies how many names are to be taken from lists.  An additional level of indirection is made available with the glListBase command, which specifies an unsigned offset that is added to each display-list name specified in lists before that display list is executed.  glCallLists can appear inside a display list.  To avoid the possibility of infinite recursion resulting from display lists calling one another, a limit is placed on the nesting level of display lists during display-list execution.  This limit must be at least 64, and it depends on the implementation.  GL state is not saved and restored across a call to glCallLists.  Thus, changes made to GL state during the execution of the display lists remain after execution is completed.  Use glPushAttrib, glPopAttrib, glPushMatrix, and glPopMatrix to preserve GL state across glCallLists calls.  LBL="" HELPID=""NOTESDisplay lists can be executed between a call to glBegin and the corresponding call to glEnd, as long as the display list includes only commands that are allowed in this interval.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_LIST_BASEglGet with argument GL_MAX_LIST_NESTINGglIsListLBL="" HELPID=""SEE ALSOIDREF="37134" TYPE="TITLE""glCallList", IDREF="13566" TYPE="TITLE""glDeleteLists", IDREF="12827" TYPE="TITLE""glGenLists", IDREF="38449" TYPE="TITLE""glListBase", IDREF="28073" TYPE="TITLE""glNewList", IDREF="12225" TYPE="TITLE""glPushAttrib", IDREF="41698" TYPE="TITLE""glPushMatrix"LBL="" HELPID=""ID="38656"glClearLBL="" HELPID=""NAMEglClear - clear buffers within the viewport  LBL="" HELPID=""C SPECIFICATIONvoid glClear( GLbitfield mask ) LBL="" HELPID=""PARAMETERSmaskBitwise OR of masks that indicate the buffers to be cleared.  The four masks are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_ACCUM_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT. LBL="" HELPID=""DESCRIPTIONglClear sets the bitplane area of the window to values previously selected by glClearColor, glClearIndex, glClearDepth, glClearStencil, and glClearAccum.  Multiple color buffers can be cleared simultaneously by selecting more than one buffer at a time using glDrawBuffer.  The pixel ownership test, the scissor test, dithering, and the buffer writemasks affect the operation of glClear.  The scissor box bounds the cleared region.  Alpha function, blend function, logical operation, stenciling, texture mapping, and z-buffering are ignored by glClear.  glClear takes a single argument that is the bitwise OR of several values indicating which buffer is to be cleared.  The values are as follows: GL_COLOR_BUFFER_BITIndicates the buffers currently enabled for color writing.  GL_DEPTH_BUFFER_BITIndicates the depth buffer.  GL_ACCUM_BUFFER_BITIndicates the accumulation buffer.  GL_STENCIL_BUFFER_BITIndicates the stencil buffer.  The value to which each buffer is cleared depends on the setting of the clear value for that buffer.  LBL="" HELPID=""NOTESIf a buffer is not present, then a glClear directed at that buffer has no effect.  LBL="" HELPID=""ERRORSGL_INVALID_VALUE is generated if any bit other than the four defined bits is set in mask.  GL_INVALID_OPERATION is generated if glClear is called between a call to  glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_ACCUM_CLEAR_VALUEglGet with argument GL_DEPTH_CLEAR_VALUEglGet with argument GL_INDEX_CLEAR_VALUEglGet with argument GL_COLOR_CLEAR_VALUEglGet with argument GL_STENCIL_CLEAR_VALUELBL="" HELPID=""SEE ALSOIDREF="22877" TYPE="TITLE""glClearAccum", IDREF="11098" TYPE="TITLE""glClearColor", IDREF="24334" TYPE="TITLE""glClearDepth", IDREF="26899" TYPE="TITLE""glClearIndex", IDREF="40853" TYPE="TITLE""glClearStencil", IDREF="18132" TYPE="TITLE""glDrawBuffer", IDREF="32335" TYPE="TITLE""glScissor"LBL="" HELPID=""ID="22877"glClearAccumLBL="" HELPID=""NAMEglClearAccum - specify clear values for the accumulation buffer  LBL="" HELPID=""C SPECIFICATIONvoid glClearAccum( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha ) LBL="" HELPID=""PARAMETERSred, green, blue, alphaSpecify the red, green, blue, and alpha values used when the accumulation buffer is cleared.  The default values are all zero. LBL="" HELPID=""DESCRIPTIONglClearAccum specifies the red, green, blue, and alpha values used by glClear to clear the accumulation buffer.  Values specified by glClearAccum are clamped to the range [-1,1].  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glClearAccum is called between a call to glBegin and the corresponding call to glEnd. LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_ACCUM_CLEAR_VALUELBL="" HELPID=""SEE ALSOIDREF="38656" TYPE="TITLE""glClear"LBL="" HELPID=""ID="11098"glClearColorLBL="" HELPID=""NAMEglClearColor - specify clear values for the color buffers  LBL="" HELPID=""C SPECIFICATIONvoid glClearColor( GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha ) LBL="" HELPID=""PARAMETERSred, green, blue, alphaSpecify the red, green, blue, and alpha values used when the color buffers are cleared.  The default values are all zero. LBL="" HELPID=""DESCRIPTIONglClearColor specifies the red, green, blue, and alpha values used by glClear to clear the color buffers.  Values specified by glClearColor are clamped to the range [0,1].  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glClearColor is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_COLOR_CLEAR_VALUELBL="" HELPID=""SEE ALSOIDREF="38656" TYPE="TITLE""glClear"LBL="" HELPID=""ID="24334"glClearDepthLBL="" HELPID=""NAMEglClearDepth - specify the clear value for the depth buffer  LBL="" HELPID=""C SPECIFICATIONvoid glClearDepth( GLclampd depth ) LBL="" HELPID=""PARAMETERSdepthSpecifies the depth value used when the depth buffer is cleared. LBL="" HELPID=""DESCRIPTIONglClearDepth specifies the depth value used by glClear to clear the depth buffer.  Values specified by glClearDepth are clamped to the range [0,1].  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glClearDepth is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_DEPTH_CLEAR_VALUELBL="" HELPID=""SEE ALSOIDREF="38656" TYPE="TITLE""glClear"LBL="" HELPID=""ID="26899"glClearIndexLBL="" HELPID=""NAMEglClearIndex - specify the clear value for the color index buffers  LBL="" HELPID=""C SPECIFICATIONvoid glClearIndex( GLfloat c ) LBL="" HELPID=""PARAMETERScSpecifies the index used when the color index buffers are cleared.  The default value is zero. LBL="" HELPID=""DESCRIPTIONglClearIndex specifies the index used by glClear to clear the color index buffers.  c is not clamped.  Rather, c is converted to a fixed-point value with unspecified precision to the right of the binary point.  The integer part of this value is then masked with 2m -1, where m is the number of bits in a color index stored in the frame buffer.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glClearIndex is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_INDEX_CLEAR_VALUEglGet with argument GL_INDEX_BITSLBL="" HELPID=""SEE ALSOIDREF="38656" TYPE="TITLE""glClear"LBL="" HELPID=""ID="40853"glClearStencilLBL="" HELPID=""NAMEglClearStencil - specify the clear value for the stencil buffer  LBL="" HELPID=""C SPECIFICATIONvoid glClearStencil( GLint s ) LBL="" HELPID=""PARAMETERSsSpecifies the index used when the stencil buffer is cleared.  The default value is zero. LBL="" HELPID=""DESCRIPTIONglClearStencil specifies the index used by glClear to clear the stencil buffer.  s is masked with 2m - 1, where m is the number of bits in the stencil buffer.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glClearStencil is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_STENCIL_CLEAR_VALUEglGet with argument GL_STENCIL_BITSLBL="" HELPID=""SEE ALSOIDREF="38656" TYPE="TITLE""glClear"LBL="" HELPID=""ID="15914"glClipPlaneLBL="" HELPID=""NAMEglClipPlane - specify a plane against which all geometry is clipped  LBL="" HELPID=""C SPECIFICATIONvoid glClipPlane( GLenum plane, const GLdouble *equation ) LBL="" HELPID=""PARAMETERSplaneSpecifies which clipping plane is being positioned.  Symbolic names of the form GL_CLIP_PLANEi, where i is an integer between 0 and GL_MAX_CLIP_PLANES -1, are accepted.  equationSpecifies the address of an array of four double-precision floating-point values.  These values are interpreted as a plane equation. LBL="" HELPID=""DESCRIPTIONGeometry is always clipped against the boundaries of a six-plane frustum in x, y, and z.  glClipPlane allows the specification of additional planes, not necessarily perpendicular to the x, y, or z axis, against which all geometry is clipped.  Up to GL_MAX_CLIP_PLANES planes can be specified, where GL_MAX_CLIP_PLANES is at least six in all implementations.  Because the resulting clipping region is the intersection of the defined half-spaces, it is always convex.  glClipPlane specifies a half-space using a four-component plane equation.  When glClipPlane is called, equation is transformed by the inverse of the modelview matrix and stored in the resulting eye coordinates.  Subsequent changes to the modelview matrix have no effect on the stored plane-equation components.  If the dot product of the eye coordinates of a vertex with the stored plane equation components is positive or zero, the vertex is in with respect to that clipping plane.  Otherwise, it is out.  Clipping planes are enabled and disabled with glEnable and glDisable, and called with the argument GL_CLIP_PLANEi, where i is the plane number.  By default, all clipping planes are defined as (0,0,0,0) in eye coordinates and are disabled.  LBL="" HELPID=""NOTESIt is always the case that GL_CLIP_PLANEi = GL_CLIP_PLANE0 + i.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if plane is not an accepted value.  GL_INVALID_OPERATION is generated if glClipPlane is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGetClipPlaneglIsEnabled with argument GL_CLIP_PLANEiLBL="" HELPID=""SEE ALSOIDREF="40792" TYPE="TITLE""glEnable"LBL="" HELPID=""ID="18325"glColorLBL="" HELPID=""NAMEglColor3b, glColor3d, glColor3f, glColor3i, glColor3s, glColor3ub, glColor3ui, glColor3us, glColor4b, glColor4d, glColor4f, glColor4i, glColor4s, glColor4ub, glColor4ui, glColor4us, glColor3bv, glColor3dv, glColor3fv, glColor3iv, glColor3sv, glColor3ubv, glColor3uiv, glColor3usv, glColor4bv, glColor4dv, glColor4fv, glColor4iv, glColor4sv, glColor4ubv, glColor4uiv, glColor4usv - set the current color  LBL="" HELPID=""C SPECIFICATIONvoid glColor3b( GLbyte red, GLbyte green, GLbyte blue ) void glColor3d( GLdouble red, GLdouble green, GLdouble blue ) void glColor3f( GLfloat red, GLfloat green, GLfloat blue ) void glColor3i( GLint red, GLint green, GLint blue ) void glColor3s( GLshort red, GLshort green, GLshort blue ) void glColor3ub( GLubyte red, GLubyte green, GLubyte blue ) void glColor3ui( GLuint red, GLuint green, GLuint blue ) void glColor3us( GLushort red, GLushort green, GLushort blue ) void glColor4b( GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha ) void glColor4d( GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha ) void glColor4f( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha ) void glColor4i( GLint red, GLint green, GLint blue, GLint alpha ) void glColor4s( GLshort red, GLshort green, GLshort blue, GLshort alpha ) void glColor4ub( GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha ) void glColor4ui( GLuint red, GLuint green, GLuint blue, GLuint alpha ) void glColor4us( GLushort red, GLushort green, GLushort blue, GLushort alpha ) LBL="" HELPID=""PARAMETERSred, green, blueSpecify new red, green, and blue values for the current color.  alphaSpecifies a new alpha value for the current color.  Included only in the four-argument glColor4 command.  LBL="" HELPID=""C SPECIFICATIONvoid glColor3bv( const GLbyte *v ) void glColor3dv( const GLdouble *v ) void glColor3fv( const GLfloat *v ) void glColor3iv( const GLint *v ) void glColor3sv( const GLshort *v ) void glColor3ubv( const GLubyte *v ) void glColor3uiv( const GLuint *v ) void glColor3usv( const GLushort *v ) void glColor4bv( const GLbyte *v ) void glColor4dv( const GLdouble *v ) void glColor4fv( const GLfloat *v ) void glColor4iv( const GLint *v ) void glColor4sv( const GLshort *v ) void glColor4ubv( const GLubyte *v ) void glColor4uiv( const GLuint *v ) void glColor4usv( const GLushort *v ) LBL="" HELPID=""PARAMETERSvSpecifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values. LBL="" HELPID=""DESCRIPTIONThe GL stores both a current single-valued color index and a current four-valued RGBA color.  glColor sets a new four-valued RGBA color.  glColor has two major variants: glColor3 and glColor4.  glColor3 variants specify new red, green, and blue values explicitly, and set the current alpha value to 1.0 implicitly.  glColor4 variants specify all four color components explicitly.  glColor3b, glColor4b, glColor3s, glColor4s, glColor3i, and glColor4i take three or four unsigned byte, short, or long integers as arguments.  When v is appended to the name, the color commands can take a pointer to an array of such values.  Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes.  Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and zero maps to 0.0 (zero intensity).  Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0.  Floating-point values are mapped directly.  Neither floating-point nor signed integer values are clamped to the range [0,1] before updating the current color.  However, color components are clamped to this range before they are interpolated or written into a color buffer.  LBL="" HELPID=""NOTESThe current color can be updated at any time.  In particular, glColor can be called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_CURRENT_COLORglGet with argument GL_RGBA_MODELBL="" HELPID=""SEE ALSOIDREF="14741" TYPE="TITLE""glIndex"LBL="" HELPID=""ID="42526"glColorMaskLBL="" HELPID=""NAMEglColorMask - enable and disable writing of frame buffer color components  LBL="" HELPID=""C SPECIFICATIONvoid glColorMask( GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha ) LBL="" HELPID=""PARAMETERSred, green, blue, alphaSpecify whether red, green, blue, and alpha can or cannot be written into the frame buffer.  The default values are all GL_TRUE, indicating that the color components can be written.  LBL="" HELPID=""DESCRIPTIONglColorMask specifies whether the individual color components in the frame buffer can or cannot be written.  If red is GL_FALSE, for example, no change is made to the red component of any pixel in any of the color buffers, regardless of the drawing operation attempted.  Changes to individual bits of components cannot be controlled.  Rather, changes are either enabled or disabled for entire color components.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glColorMask is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_COLOR_WRITEMASKglGet with argument GL_RGBA_MODELBL="" HELPID=""SEE ALSOIDREF="18325" TYPE="TITLE""glColor", IDREF="14741" TYPE="TITLE""glIndex", IDREF="31111" TYPE="TITLE""glIndexMask", IDREF="31383" TYPE="TITLE""glDepthMask", IDREF="13439" TYPE="TITLE""glStencilMask"LBL="" HELPID=""ID="37922"glColorMaterialLBL="" HELPID=""NAMEglColorMaterial - cause a material color to track the current color  LBL="" HELPID=""C SPECIFICATIONvoid glColorMaterial( GLenum face, GLenum mode ) LBL="" HELPID=""PARAMETERSfaceSpecifies whether front, back, or both front and back material parameters should track the current color.  Accepted values are GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.  The default value is GL_FRONT_AND_BACK.  modeSpecifies which of several material parameters track the current color.  Accepted values are GL_EMISSION, GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, and GL_AMBIENT_AND_DIFFUSE.  The default value is GL_AMBIENT_AND_DIFFUSE. LBL="" HELPID=""DESCRIPTIONglColorMaterial specifies which material parameters track the current color.  When GL_COLOR_MATERIAL is enabled, the material parameter or parameters specified by mode, of the material or materials specified by face, track the current color at all times.  GL_COLOR_MATERIAL is enabled and disabled using the commands glEnable and glDisable, called with GL_COLOR_MATERIAL as their argument.  By default, it is disabled.  LBL="" HELPID=""NOTESglColorMaterial allows a subset of material parameters to be changed for each vertex using only the glColor command, without calling glMaterial.  If only such a subset of parameters is to be specified for each vertex, glColorMaterial is preferred over calling glMaterial.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if face or mode is not an accepted value.  GL_INVALID_OPERATION is generated if glColorMaterial is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglIsEnabled with argument GL_COLOR_MATERIALglGet with argument GL_COLOR_MATERIAL_PARAMETERglGet with argument GL_COLOR_MATERIAL_FACELBL="" HELPID=""SEE ALSOIDREF="18325" TYPE="TITLE""glColor", IDREF="40792" TYPE="TITLE""glEnable", IDREF="37552" TYPE="TITLE""glLight", IDREF="19151" TYPE="TITLE""glLightModel", IDREF="28170" TYPE="TITLE""glMaterial"LBL="" HELPID=""ID="25030"glCopyPixelsLBL="" HELPID=""NAMEglCopyPixels - copy pixels in the frame buffer  LBL="" HELPID=""C SPECIFICATIONvoid glCopyPixels( GLint x, GLint y, GLsizei width, GLsizei height, GLenum type ) LBL="" HELPID=""PARAMETERSx, ySpecify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.  width, heightSpecify the dimensions of the rectangular region of pixels to be copied.  Both must be nonnegative.  typeSpecifies whether color values, depth values, or stencil values are to be copied.  Symbolic constants GL_COLOR, GL_DEPTH, and GL_STENCIL are accepted. LBL="" HELPID=""DESCRIPTIONglCopyPixels copies a screen-aligned rectangle of pixels from the specified frame buffer location to a region relative to the current raster position.  Its operation is well defined only if the entire pixel source region is within the exposed portion of the window.  Results of copies from outside the window, or from regions of the window that are not exposed, are hardware dependent and undefined.  x and y specify the window coordinates of the lower left corner of the rectangular region to be copied.  width and height specify the dimensions of the rectangular region to be copied.  Both width and height must not be negative.  Several parameters control the processing of the pixel data while it is being copied.  These parameters are set with three commands: glPixelTransfer, glPixelMap, and glPixelZoom.  This reference page describes the effects on glCopyPixels of most, but not all, of the parameters specified by these three commands.  glCopyPixels copies values from each pixel with the lower left-hand corner at (x + i, y + j) for 0name='le' font=symbol charset=fontspecific code=163 
	TeX='\leq ' descr='[le]'i<width  and 0name='le' font=symbol charset=fontspecific code=163 
	TeX='\leq ' descr='[le]'j<height.  This pixel is said to be the ith pixel in the jth row.  Pixels are copied in row order from the lowest to the highest row, left to right in each row.  type specifies whether color, depth, or stencil data is to be copied.  The details of the transfer for each data type are as follows: GL_COLORIndices or RGBA colors are read from the buffer currently specified as the read source buffer (see IDREF="40151" TYPE="TITLE""glReadBuffer".) If the GL is in color index mode, each index that is read from this buffer is converted to a fixed-point format with an unspecified number of bits to the right of the binary point.  Each index is then shifted left by GL_INDEX_SHIFT bits, and added to GL_INDEX_OFFSET.  If GL_INDEX_SHIFT is negative, the shift is to the right.  In either case, zero bits fill otherwise unspecified bit locations in the result.  If GL_MAP_COLOR is true, the index is replaced with the value that it references in lookup table GL_PIXEL_MAP_I_TO_I.  Whether the lookup replacement of the index is done or not, the integer part of the index is then ANDed with 2b -1, where b is the number of bits in a color index buffer.  If the GL is in RGBA mode, the red, green, blue, and alpha components of each pixel that is read are converted to an internal floating-point format with unspecified precision.  The conversion maps the largest representable component value to 1.0, and component value zero to 0.0.  The resulting floating-point color values are then multiplied by GL_c_SCALE and added to GL_c_BIAS, where c is RED, GREEN, BLUE, and ALPHA for the respective color components.  The results are clamped to the range [0,1].  If GL_MAP_COLOR is true, each color component is scaled by the size of lookup table GL_PIXEL_MAP_c_TO_c, then replaced by the value that it references in that table.  c is R, G, B, or A, respectively.  The resulting indices or RGBA colors are then converted to fragments by attaching the current raster position z coordinate and texture coordinates to each pixel, then assigning window coordinates (xr + i , yr + j), where (xr , yr) is the current raster position, and the pixel was the ith pixel in the jth row.  These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons.  Texture mapping, fog, and all the fragment operations are applied before the fragments are written to the frame buffer.  GL_DEPTHDepth values are read from the depth buffer and converted directly to an internal floating-point format with unspecified precision.  The resulting floating-point depth value is then multiplied by GL_DEPTH_SCALE and added to GL_DEPTH_BIAS.  The result is clamped to the range [0,1].  The resulting depth components are then converted to fragments by attaching the current raster position color or color index and texture coordinates to each pixel, then assigning window coordinates (xr + i , yr + j), where (xr , yr) is the current raster position, and the pixel was the ith pixel in the jth row.  These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons.  Texture mapping, fog, and all the fragment operations are applied before the fragments are written to the frame buffer.  GL_STENCILStencil indices are read from the stencil buffer and converted to an internal fixed-point format with an unspecified number of bits to the right of the binary point.  Each fixed-point index is then shifted left by GL_INDEX_SHIFT bits, and added to GL_INDEX_OFFSET.  If GL_INDEX_SHIFT is negative, the shift is to the right.  In either case, zero bits fill otherwise unspecified bit locations in the result.  If GL_MAP_STENCIL is true, the index is replaced with the value that it references in lookup table GL_PIXEL_MAP_S_TO_S.  Whether the lookup replacement of the index is done or not, the integer part of the index is then ANDed with 2b -1, where b is the number of bits in the stencil buffer.  The resulting stencil indices are then written to the stencil buffer such that the index read from the ith location of the jth row is written to location (xr + i , yr + j), where (xr , yr) is the current raster position.  Only the pixel ownership test, the scissor test, and the stencil writemask affect these writes.  The rasterization described thus far assumes pixel zoom factors of 1.0.  If glPixelZoom is used to change the x and y pixel zoom factors, pixels are converted to fragments as follows.  If (xr, yr) is the current raster position, and a given pixel is in the ith location in the jth row of the source pixel rectangle, then fragments are generated for pixels whose centers are in the rectangle with corners at (xr + zoomx i, yr + zoomy j)  and (xr + zoomx (i + 1), yr + zoomy ( j + 1 )) where zoomx is the value of GL_ZOOM_X and zoomy is the value of GL_ZOOM_Y.  LBL="" HELPID=""EXAMPLESTo copy the color pixel in the lower left corner of the window to the current raster position, use glCopyPixels(0, 0, 1, 1, GL_COLOR);LBL="" HELPID=""NOTESModes specified by glPixelStore have no effect on the operation of glCopyPixels.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if type is not an accepted value.  GL_INVALID_VALUE is generated if either width or height is negative.  GL_INVALID_OPERATION is generated if type is GL_DEPTH and there is no depth buffer.  GL_INVALID_OPERATION is generated if type is GL_STENCIL and there is no stencil buffer.  GL_INVALID_OPERATION is generated if glCopyPixels is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_CURRENT_RASTER_POSITIONglGet with argument GL_CURRENT_RASTER_POSITION_VALIDLBL="" HELPID=""SEE ALSOIDREF="10076" TYPE="TITLE""glDepthFunc", IDREF="18132" TYPE="TITLE""glDrawBuffer", IDREF="41928" TYPE="TITLE""glDrawPixels", IDREF="34580" TYPE="TITLE""glPixelMap", IDREF="38440" TYPE="TITLE""glPixelTransfer", IDREF="20047" TYPE="TITLE""glPixelZoom", IDREF="40922" TYPE="TITLE""glRasterPos", IDREF="40151" TYPE="TITLE""glReadBuffer", IDREF="40261" TYPE="TITLE""glReadPixels", IDREF="19234" TYPE="TITLE""glStencilFunc"LBL="" HELPID=""ID="41183"glCullFaceLBL="" HELPID=""NAMEglCullFace - specify whether front- or back-facing facets can be culled  LBL="" HELPID=""C SPECIFICATIONvoid glCullFace( GLenum mode ) LBL="" HELPID=""PARAMETERSmodeSpecifies whether front- or back-facing facets are candidates for culling.  Symbolic constants GL_FRONT and GL_BACK are accepted.  The default value is GL_BACK.  LBL="" HELPID=""DESCRIPTIONglCullFace specifies whether front- or back-facing facets are culled (as specified by mode) when facet culling is enabled.  Facet culling is enabled and disabled using the glEnable and glDisable commands with the argument GL_CULL_FACE.  Facets include triangles, quadrilaterals, polygons, and rectangles.  glFrontFace specifies which of the clockwise and counterclockwise facets are front-facing and back-facing.  See IDREF="27863" TYPE="TITLE""glFrontFace". LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if mode is not an accepted value.  GL_INVALID_OPERATION is generated if glCullFace is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglIsEnabled with argument GL_CULL_FACEglGet with argument GL_CULL_FACE_MODELBL="" HELPID=""SEE ALSOIDREF="40792" TYPE="TITLE""glEnable", IDREF="27863" TYPE="TITLE""glFrontFace"LBL="" HELPID=""ID="13566"glDeleteListsLBL="" HELPID=""NAMEglDeleteLists - delete a contiguous group of display lists  LBL="" HELPID=""C SPECIFICATIONvoid glDeleteLists( GLuint list, GLsizei range ) LBL="" HELPID=""PARAMETERSlistSpecifies the integer name of the first display list to delete.  rangeSpecifies the number of display lists to delete. LBL="" HELPID=""DESCRIPTIONglDeleteLists causes a contiguous group of display lists to be deleted.  list is the name of the first display list to be deleted, and range is the number of display lists to delete.  All display lists d with listname='le' font=symbol charset=fontspecific code=163 
	TeX='\leq ' descr='[le]' dname='le' font=symbol charset=fontspecific code=163 
	TeX='\leq ' descr='[le]'list + range - 1 are deleted.  All storage locations allocated to the specified display lists are freed, and the names are available for reuse at a later time.  Names within the range that do not have an associated display list are ignored.  If range is zero, nothing happens.  LBL="" HELPID=""ERRORSGL_INVALID_VALUE is generated if range is negative.  GL_INVALID_OPERATION is generated if glDeleteLists is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""SEE ALSOIDREF="37134" TYPE="TITLE""glCallList", IDREF="15751" TYPE="TITLE""glCallLists", IDREF="12827" TYPE="TITLE""glGenLists", IDREF="41026" TYPE="TITLE""glIsList", IDREF="28073" TYPE="TITLE""glNewList"LBL="" HELPID=""ID="10076"glDepthFuncLBL="" HELPID=""NAMEglDepthFunc - specify the value used for depth buffer comparisons  LBL="" HELPID=""C SPECIFICATIONvoid glDepthFunc( GLenum func ) LBL="" HELPID=""PARAMETERSfuncSpecifies the depth comparison function.  Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted.  The default value is GL_LESS. LBL="" HELPID=""DESCRIPTIONglDepthFunc specifies the function used to compare each incoming pixel z value with the z value present in the depth buffer.  The comparison is performed only if depth testing is enabled.  (See IDREF="40792" TYPE="TITLE""glEnable" and glDisable of GL_DEPTH_TEST.) func specifies the conditions under which the pixel will be drawn.  The comparison functions are as follows: GL_NEVERNever passes.  GL_LESSPasses if the incoming z value is less than the stored z value.  GL_EQUALPasses if the incoming z value is equal to the stored z value.  GL_LEQUALPasses if the incoming z value is less than or equal to the stored z value.  GL_GREATER Passes if the incoming z value is greater than the stored z value.  GL_NOTEQUALPasses if the incoming z value is not equal to the stored z value.  GL_GEQUALPasses if the incoming z value is greater than or equal to the stored z value.  GL_ALWAYSAlways passes.  The default value of func is GL_LESS.  Initially, depth testing is disabled.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if func is not an accepted value.  GL_INVALID_OPERATION is generated if glDepthFunc is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_DEPTH_FUNCglIsEnabled with argument GL_DEPTH_TESTLBL="" HELPID=""SEE ALSOIDREF="22828" TYPE="TITLE""glDepthRange", IDREF="40792" TYPE="TITLE""glEnable"LBL="" HELPID=""ID="31383"glDepthMaskLBL="" HELPID=""NAMEglDepthMask - enable or disable writing into the depth buffer  LBL="" HELPID=""C SPECIFICATIONvoid glDepthMask( GLboolean flag ) LBL="" HELPID=""PARAMETERSflagSpecifies whether the depth buffer is enabled for writing.  If flag is zero, depth buffer writing is disabled.  Otherwise, it is enabled.  Initially, depth buffer writing is enabled. LBL="" HELPID=""DESCRIPTIONglDepthMask specifies whether the depth buffer is enabled for writing.  If flag is zero, depth buffer writing is disabled.  Otherwise, it is enabled.  Initially, depth buffer writing is enabled.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glDepthMask is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_DEPTH_WRITEMASKLBL="" HELPID=""SEE ALSOIDREF="42526" TYPE="TITLE""glColorMask", IDREF="10076" TYPE="TITLE""glDepthFunc", IDREF="22828" TYPE="TITLE""glDepthRange", IDREF="31111" TYPE="TITLE""glIndexMask", IDREF="13439" TYPE="TITLE""glStencilMask"LBL="" HELPID=""ID="22828"glDepthRangeLBL="" HELPID=""NAMEglDepthRange - specify the mapping of z values from normalized device coordinates to window coordinates  LBL="" HELPID=""C SPECIFICATIONvoid glDepthRange( GLclampd near, GLclampd far ) LBL="" HELPID=""PARAMETERSnearSpecifies the mapping of the near clipping plane to window coordinates.  The default value is 0.  farSpecifies the mapping of the far clipping plane to window coordinates.  The default value is 1. LBL="" HELPID=""DESCRIPTIONAfter clipping and division by w, z coordinates range from -1.0 to 1.0, corresponding to the near and far clipping planes.  glDepthRange specifies a linear mapping of the normalized z coordinates in this range to window z coordinates.  Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range from 0.0 through 1.0 (like color components).  Thus, the values accepted by glDepthRange are both clamped to this range before they are accepted.  The default mapping of 0,1 maps the near plane to 0 and the far plane to 1.  With this mapping, the depth buffer range is fully utilized.  LBL="" HELPID=""NOTESIt is not necessary that near be less than far.  Reverse mappings such as 1,0 are acceptable.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glDepthRange is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_DEPTH_RANGELBL="" HELPID=""SEE ALSOIDREF="10076" TYPE="TITLE""glDepthFunc", IDREF="17575" TYPE="TITLE""glViewport"LBL="" HELPID=""ID="18132"glDrawBufferLBL="" HELPID=""NAMEglDrawBuffer - specify which color buffers are to be drawn into  LBL="" HELPID=""C SPECIFICATIONvoid glDrawBuffer( GLenum mode ) LBL="" HELPID=""PARAMETERSmodeSpecifies up to four color buffers to be drawn into.  Symbolic constants GL_NONE, GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, GL_FRONT_AND_BACK, and GL_AUXi, where i is between 0 and GL_AUX_BUFFERS -1, are accepted (GL_AUX_BUFFERS is not the upper limit; use glGet to query the number of available aux buffers.) The default value is GL_FRONT for single-buffered contexts, and GL_BACK for double-buffered contexts. LBL="" HELPID=""DESCRIPTIONWhen colors are written to the frame buffer, they are written into the color buffers specified by glDrawBuffer.  The specifications are as follows: GL_NONENo color buffers are written.  GL_FRONT_LEFTOnly the front left color buffer is written.  GL_FRONT_RIGHTOnly the front right color buffer is written.  GL_BACK_LEFTOnly the back left color buffer is written.  GL_BACK_RIGHTOnly the back right color buffer is written.  GL_FRONTOnly the front left and front right color buffers are written.  If there is no front right color buffer, only the front left color buffer is written.  GL_BACKOnly the back left and back right color buffers are written.  If there is no back right color buffer, only the back left color buffer is written.  GL_LEFTOnly the front left and back left color buffers are written.  If there is no back left color buffer, only the front left color buffer is written.  GL_RIGHTOnly the front right and back right color buffers are written.  If there is no back right color buffer, only the front right color buffer is written.  GL_FRONT_AND_BACKAll the front and back color buffers (front left, front right, back left, back right) are written.  If there are no back color buffers, only the front left and front right color buffers are written.  If there are no right color buffers, only the front left and back left color buffers are written.  If there are no right or back color buffers, only the front left color buffer is written.  GL_AUXiOnly auxiliary color buffer i is written.  If more than one color buffer is selected for drawing, then blending or logical operations are computed and applied independently for each color buffer and can produce different results in each buffer.  Monoscopic contexts include only left buffers, and stereoscopic contexts include both left and right buffers.  Likewise, single-buffered contexts include only front buffers, and double-buffered contexts include both front and back buffers.  The context is selected at GL initialization.  LBL="" HELPID=""NOTESIt is always the case that GL_AUXi = GL_AUX0 + i.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if mode is not an accepted value.  GL_INVALID_OPERATION is generated if none of the buffers indicated by mode exists.  GL_INVALID_OPERATION is generated if glDrawBuffer is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_DRAW_BUFFERglGet with argument GL_AUX_BUFFERSLBL="" HELPID=""SEE ALSOIDREF="11446" TYPE="TITLE""glBlendFunc", IDREF="42526" TYPE="TITLE""glColorMask", IDREF="31111" TYPE="TITLE""glIndexMask", IDREF="18729" TYPE="TITLE""glLogicOp", glReadSourceLBL="" HELPID=""ID="41928"glDrawPixelsLBL="" HELPID=""NAMEglDrawPixels - write a block of pixels to the frame buffer  LBL="" HELPID=""C SPECIFICATIONvoid glDrawPixels( GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels ) LBL="" HELPID=""PARAMETERSwidth, heightSpecify the dimensions of the pixel rectangle that will be written into the frame buffer.  formatSpecifies the format of the pixel data.  Symbolic constants GL_COLOR_INDEX, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_RGBA, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_LUMINANCE, and GL_LUMINANCE_ALPHA are accepted.  typeSpecifies the data type for pixels.  Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, and GL_FLOAT are accepted.  pixelsSpecifies a pointer to the pixel data. LBL="" HELPID=""DESCRIPTIONglDrawPixels reads pixel data from memory and writes it into the frame buffer relative to the current raster position.  Use glRasterPos to set the current raster position, and use glGet with argument GL_CURRENT_RASTER_POSITION to query the raster position.  Several parameters define the encoding of pixel data in memory and control the processing of the pixel data before it is placed in the frame buffer.  These parameters are set with four commands: glPixelStore, glPixelTransfer, glPixelMap, and glPixelZoom.  This reference page describes the effects on glDrawPixels of many, but not all, of the parameters specified by these four commands.  Data is read from pixels as a sequence of signed or unsigned bytes, signed or unsigned shorts, signed or unsigned integers, or single-precision floating-point values, depending on type.  Each of these bytes, shorts, integers, or floating-point values is interpreted as one color or depth component, or one index, depending on format.  Indices are always treated individually.  Color components are treated as groups of one, two, three, or four values, again based on format.  Both individual indices and groups of components are referred to as pixels.  If type is GL_BITMAP, the data must be unsigned bytes, and format must be either GL_COLOR_INDEX or GL_STENCIL_INDEX.  Each unsigned byte is treated as eight 1-bit pixels, with bit ordering determined by GL_UNPACK_LSB_FIRST (see IDREF="39579" TYPE="TITLE""glPixelStore".)widthxheight pixels are read from memory, starting at location pixels.  By default, these pixels are taken from adjacent memory locations, except that after all width pixels are read, the read pointer is advanced to the next four-byte boundary.  The four-byte row alignment is specified by glPixelStore with argument GL_UNPACK_ALIGNMENT, and it can be set to one, two, four, or eight bytes.  Other pixel store parameters specify different read pointer advancements, both before the first pixel is read, and after all width pixels are read.  Refer to the glPixelStore reference page for details on these options.  The widthxheight pixels that are read from memory are each operated on in the same way, based on the values of several parameters specified by glPixelTransfer and glPixelMap.  The details of these operations, as well as the target buffer into which the pixels are drawn, are specific to the format of the pixels, as specified by format.  format can assume one of eleven symbolic values: GL_COLOR_INDEXEach pixel is a single value, a color index.  It is converted to fixed-point format, with an unspecified number of bits to the right of the binary point, regardless of the memory data type.  Floating-point values convert to true fixed-point values.  Signed and unsigned integer data is converted with all fraction bits set to zero.  Bitmap data convert to either 0.0 or 1.0.  Each fixed-point index is then shifted left by GL_INDEX_SHIFT bits and added to GL_INDEX_OFFSET.  If GL_INDEX_SHIFT is negative, the shift is to the right.  In either case, zero bits fill otherwise unspecified bit locations in the result.  If the GL is in RGBA mode, the resulting index is converted to an RGBA pixel using the GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, and GL_PIXEL_MAP_I_TO_A tables.  If the GL is in color index mode, and if GL_MAP_COLOR is true, the index is replaced with the value that it references in lookup table GL_PIXEL_MAP_I_TO_I.  Whether the lookup replacement of the index is done or not, the integer part of the index is then ANDed with 2b -1, where b is the number of bits in a color index buffer.  The resulting indices or RGBA colors are then converted to fragments by attaching the current raster position z coordinate and texture coordinates to each pixel, then assigning x and y window coordinates to the nth fragment such that FILE="eq05_03.gif" POSITION="INLINE" SCALE="FALSE"where (xr , yr) is the current raster position.  These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons.  Texture mapping, fog, and all the fragment operations are applied before the fragments are written to the frame buffer.  GL_STENCIL_INDEXEach pixel is a single value, a stencil index.  It is converted to fixed-point format, with an unspecified number of bits to the right of the binary point, regardless of the memory data type.  Floating-point values convert to true fixed-point values.  Signed and unsigned integer data is converted with all fraction bits set to zero.  Bitmap data convert to either 0.0 or 1.0.  Each fixed-point index is then shifted left by GL_INDEX_SHIFT bits, and added to GL_INDEX_OFFSET.  If GL_INDEX_SHIFT is negative, the shift is to the right.  In either case, zero bits fill otherwise unspecified bit locations in the result.  If GL_MAP_STENCIL is true, the index is replaced with the value that it references in lookup table GL_PIXEL_MAP_S_TO_S.  Whether the lookup replacement of the index is done or not, the integer part of the index is then ANDed with 2b -1, where b is the number of bits in the stencil buffer.  The resulting stencil indices are then written to the stencil buffer such that the nth index is written to location FILE="eq05_03.gif" POSITION="INLINE" SCALE="FALSE"where (xr , yr) is the current raster position.  Only the pixel ownership test, the scissor test, and the stencil writemask affect these writes.  GL_DEPTH_COMPONENTEach pixel is a single-depth component.  Floating-point data is converted directly to an internal floating-point format with unspecified precision.  Signed integer data is mapped linearly to the internal floating-point format such that the most positive representable integer value maps to 1.0, and the most negative representable value maps to -1.0.  Unsigned integer data is mapped similarly: the largest integer value maps to 1.0, and zero maps to 0.0.  The resulting floating-point depth value is then multiplied by GL_DEPTH_SCALE and added to GL_DEPTH_BIAS.  The result is clamped to the range [0,1].  The resulting depth components are then converted to fragments by attaching the current raster position color or color index and texture coordinates to each pixel, then assigning x and y window coordinates to the nth fragment such that FILE="eq05_03.gif" POSITION="INLINE" SCALE="FALSE"where (xr , yr) is the current raster position.  These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons.  Texture mapping, fog, and all the fragment operations are applied before the fragments are written to the frame buffer.  GL_RGBAEach pixel is a four-component group: red first, followed by green, followed by blue, followed by alpha.  Floating-point values are converted directly to an internal floating-point format with unspecified precision.  Signed integer values are mapped linearly to the internal floating-point format such that the most positive representable integer value maps to 1.0, and the most negative representable value maps to -1.0.  Unsigned integer data is mapped similarly: the largest integer value maps to 1.0, and zero maps to 0.0.  The resulting floating-point color values are then multiplied by GL_c_SCALE and added to GL_c_BIAS, where c is RED, GREEN, BLUE, and ALPHA for the respective color components.  The results are clamped to the range [0,1].  If GL_MAP_COLOR is true, each color component is scaled by the size of lookup table GL_PIXEL_MAP_c_TO_c, then replaced by the value that it references in that table.  c is R, G, B, or A, respectively.  The resulting RGBA colors are then converted to fragments by attaching the current raster position z coordinate and texture coordinates to each pixel, then assigning x and y window coordinates to the nth fragment such thatFILE="eq05_03.gif" POSITION="INLINE" SCALE="FALSE"where (xr , yr) is the current raster position.  These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons.  Texture mapping, fog, and all the fragment operations are applied before the fragments are written to the frame buffer.  GL_REDEach pixel is a single red component.  This component is converted to the internal floating-point format in the same way as the red component of an RGBA pixel is, then it is converted to an RGBA pixel with green and blue set to 0.0, and alpha set to 1.0.  After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.  GL_GREENEach pixel is a single green component.  This component is converted to the internal floating-point format in the same way as the green component of an RGBA pixel is, then it is converted to an RGBA pixel with red and blue set to 0.0, and alpha set to 1.0.  After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.  GL_BLUEEach pixel is a single blue component.  This component is converted to the internal floating-point format in the same way as the blue component of an RGBA pixel is, then it is converted to an RGBA pixel with red and green set to 0.0, and alpha set to 1.0.  After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.  GL_ALPHAEach pixel is a single alpha component.  This component is converted to the internal floating-point format in the same way as the alpha component of an RGBA pixel is, then it is converted to an RGBA pixel with red, green, and blue set to 0.0.  After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.  GL_RGBEach pixel is a three-component group: red first, followed by green, followed by blue.  Each component is converted to the internal floating-point format in the same way as the red, green, and blue components of an RGBA pixel are.  The color triple is converted to an RGBA pixel with alpha set to 1.0.  After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.  GL_LUMINANCEEach pixel is a single luminance component.  This component is converted to the internal floating-point format in the same way as the red component of an RGBA pixel is, then it is converted to an RGBA pixel with red, green, and blue set to the converted luminance value, and alpha set to 1.0.  After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.  GL_LUMINANCE_ALPHAEach pixel is a two-component group: luminance first, followed by alpha.  The two components are converted to the internal floating-point format in the same way as the red component of an RGBA pixel is, then they are converted to an RGBA pixel with red, green, and blue set to the converted luminance value, and alpha set to the converted alpha value.  After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.  The following table summarizes the meaning of the valid constants for the type parameter: COLUMNS="2"LEFT="0" WIDTH="180"typeLEFT="185" WIDTH="180"corresponding typeLEFT="0" WIDTH="180"GL_UNSIGNED_BYTELEFT="185" WIDTH="180"unsigned 8-bit integerLEFT="0" WIDTH="180"GL_BYTE LEFT="185" WIDTH="180"signed 8-bit integerLEFT="0" WIDTH="180"GL_BITMAPLEFT="185" WIDTH="180"single bits in unsigned 8-bit integersLEFT="0" WIDTH="180"GL_UNSIGNED_SHORTLEFT="185" WIDTH="180"unsigned 16-bit integerLEFT="0" WIDTH="180"GL_SHORTLEFT="185" WIDTH="180"signed 16-bit integerLEFT="0" WIDTH="180"GL_UNSIGNED_INTLEFT="185" WIDTH="180"unsigned 32-bit integerLEFT="0" WIDTH="180"GL_INTLEFT="185" WIDTH="180"32-bit integerLEFT="0" WIDTH="180"GL_FLOAT LEFT="185" WIDTH="180"single-precision floating-point The rasterization described thus far assumes pixel zoom factors of 1.0.  If glPixelZoom is used to change the x and y pixel zoom factors, pixels are converted to fragments as follows.  If (xr, yr) is the current raster position, and a given pixel is in the nth column and mth row of the pixel rectangle, then fragments are generated for pixels whose centers are in the rectangle with corners at (xr + zoomx n, yr + zoomy m) (xr + zoomx (n + 1), yr + zoomy ( m + 1 )) where zoomx is the value of GL_ZOOM_X and zoomy is the value of GL_ZOOM_Y.  LBL="" HELPID=""ERRORSGL_INVALID_VALUE is generated if either width or height is negative.  GL_INVALID_ENUM is generated if format or type is not one of the accepted values.  GL_INVALID_OPERATION is generated if format is GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_RGBA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA, and the GL is in color index mode.  GL_INVALID_ENUM is generated if type is GL_BITMAP and format is not either GL_COLOR_INDEX or GL_STENCIL_INDEX.  GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and there is no stencil buffer.  GL_INVALID_OPERATION is generated if glDrawPixels is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_CURRENT_RASTER_POSITIONglGet with argument GL_CURRENT_RASTER_POSITION_VALIDLBL="" HELPID=""SEE ALSOIDREF="19142" TYPE="TITLE""glAlphaFunc", IDREF="11446" TYPE="TITLE""glBlendFunc", IDREF="25030" TYPE="TITLE""glCopyPixels", IDREF="10076" TYPE="TITLE""glDepthFunc", IDREF="18729" TYPE="TITLE""glLogicOp", IDREF="34580" TYPE="TITLE""glPixelMap", IDREF="39579" TYPE="TITLE""glPixelStore", IDREF="38440" TYPE="TITLE""glPixelTransfer", IDREF="20047" TYPE="TITLE""glPixelZoom", IDREF="40922" TYPE="TITLE""glRasterPos", IDREF="40261" TYPE="TITLE""glReadPixels", IDREF="32335" TYPE="TITLE""glScissor", IDREF="19234" TYPE="TITLE""glStencilFunc"LBL="" HELPID=""ID="40044"glEdgeFlagLBL="" HELPID=""NAMEglEdgeFlag, glEdgeFlagv - flag edges as either boundary or nonboundary  LBL="" HELPID=""C SPECIFICATIONvoid glEdgeFlag( GLboolean flag ) LBL="" HELPID=""PARAMETERSflagSpecifies the current edge flag value, either true or false. LBL="" HELPID=""C SPECIFICATIONvoid glEdgeFlagv( const GLboolean *flag ) LBL="" HELPID=""PARAMETERSflagSpecifies a pointer to an array that contains a single Boolean element, which replaces the current edge flag value. LBL="" HELPID=""DESCRIPTIONEach vertex of a polygon, separate triangle, or separate quadrilateral specified between a glBegin/glEnd pair is marked as the start of either a boundary or nonboundary edge.  If the current edge flag is true when the vertex is specified, the vertex is marked as the start of a boundary edge.  Otherwise, the vertex is marked as the start of a nonboundary edge.  glEdgeFlag sets the edge flag to true if flag is nonzero, false otherwise.  The vertices of connected triangles and connected quadrilaterals are always marked as boundary, regardless of the value of the edge flag.  Boundary and nonboundary edge flags on vertices are significant only if GL_POLYGON_MODE is set to GL_POINT or GL_LINE.  See IDREF="14059" TYPE="TITLE""glPolygonMode".Initially, the edge flag bit is true.  LBL="" HELPID=""NOTESThe current edge flag can be updated at any time.  In particular, glEdgeFlag can be called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_EDGE_FLAGLBL="" HELPID=""SEE ALSOIDREF="11415" TYPE="TITLE""glBegin", IDREF="14059" TYPE="TITLE""glPolygonMode"LBL="" HELPID=""ID="40792"glEnableLBL="" HELPID=""NAMEglEnable, glDisable - enable or disable GL capabilities  LBL="" HELPID=""C SPECIFICATIONvoid glEnable( GLenum cap ) LBL="" HELPID=""PARAMETERScapSpecifies a symbolic constant indicating a GL capability.  LBL="" HELPID=""C SPECIFICATIONvoid glDisable( GLenum cap ) LBL="" HELPID=""PARAMETERScapSpecifies a symbolic constant indicating a GL capability.  LBL="" HELPID=""DESCRIPTIONglEnable and glDisable enable and disable various capabilities.  Use glIsEnabled or glGet to determine the current setting of any capability.  Both glEnable and glDisable take a single argument, cap, which can assume one of the following values: GL_ALPHA_TESTIf enabled, do alpha testing. See IDREF="19142" TYPE="TITLE""glAlphaFunc".GL_AUTO_NORMALIf enabled, compute surface normal vectors analytically when either GL_MAP2_VERTEX_3 or GL_MAP2_VERTEX_4 is used to generate vertices.  See IDREF="26755" TYPE="TITLE""glMap2".GL_BLENDIf enabled, blend the incoming RGBA color values with the values in the color buffers.  See IDREF="11446" TYPE="TITLE""glBlendFunc".GL_CLIP_PLANEiIf enabled, clip geometry against user-defined clipping plane i.  See IDREF="15914" TYPE="TITLE""glClipPlane". GL_COLOR_MATERIALIf enabled, have one or more material parameters track the current color.  See IDREF="37922" TYPE="TITLE""glColorMaterial".GL_CULL_FACEIf enabled, cull polygons based on their winding in window coordinates.  See IDREF="41183" TYPE="TITLE""glCullFace". GL_DEPTH_TESTIf enabled, do depth comparisons and update the depth buffer.  See IDREF="10076" TYPE="TITLE""glDepthFunc" and  IDREF="22828" TYPE="TITLE""glDepthRange".GL_DITHER If enabled, dither color components or indices before they are written to the color buffer.  GL_FOGIf enabled, blend a fog color into the posttexturing color.  See IDREF="21607" TYPE="TITLE""glFog".GL_LIGHTiIf enabled, include light i in the evaluation of the lighting equation.  See IDREF="19151" TYPE="TITLE""glLightModel" and IDREF="37552" TYPE="TITLE""glLight".GL_LIGHTINGIf enabled, use the current lighting parameters to compute the vertex color or index.  Otherwise, simply associate the current color or index with each vertex.  See IDREF="28170" TYPE="TITLE""glMaterial", IDREF="19151" TYPE="TITLE""glLightModel" and IDREF="37552" TYPE="TITLE""glLight".GL_LINE_SMOOTHIf enabled, draw lines with correct filtering.  Otherwise, draw aliased lines.  See IDREF="23427" TYPE="TITLE""glLineWidth".GL_LINE_STIPPLEIf enabled, use the current line stipple pattern when drawing lines.  See IDREF="37959" TYPE="TITLE""glLineStipple".GL_LOGIC_OPIf enabled, apply the currently selected logical operation to the incoming and color buffer indices.  See IDREF="18729" TYPE="TITLE""glLogicOp".GL_MAP1_COLOR_4If enabled, calls to glEvalCoord1, glEvalMesh1, and glEvalPoint1 will generate RGBA values.  See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_INDEXIf enabled, calls to glEvalCoord1, glEvalMesh1, and glEvalPoint1 will generate color indices.  See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_NORMALIf enabled, calls to glEvalCoord1, glEvalMesh1, and glEvalPoint1 will generate normals.  See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_TEXTURE_COORD_1If enabled, calls to glEvalCoord1, glEvalMesh1, and glEvalPoint1 will generate s texture coordinates.  See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_TEXTURE_COORD_2If enabled, calls to glEvalCoord1, glEvalMesh1, and glEvalPoint1 will generate s and t texture coordinates.  See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_TEXTURE_COORD_3If enabled, calls to glEvalCoord1, glEvalMesh1, and glEvalPoint1 will generate s, t, and r texture coordinates.  See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_TEXTURE_COORD_4If enabled, calls to glEvalCoord1, glEvalMesh1, and glEvalPoint1 will generate s, t, r, and q texture coordinates.  See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_VERTEX_3If enabled, calls to glEvalCoord1, glEvalMesh1, and glEvalPoint1 will generate will generate x, y, and z vertex coordinates.  See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_VERTEX_4If enabled, calls to glEvalCoord1, glEvalMesh1, and glEvalPoint1 will generate homogeneous x, y, z, and w vertex coordinates.  See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP2_COLOR_4If enabled, calls to glEvalCoord2, glEvalMesh2, and glEvalPoint2 will generate RGBA values.  See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_INDEXIf enabled, calls to glEvalCoord2, glEvalMesh2, and glEvalPoint2 will generate color indices.  See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_NORMALIf enabled, calls to glEvalCoord2, glEvalMesh2, and glEvalPoint2 will generate normals.  See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_TEXTURE_COORD_1If enabled, calls to glEvalCoord2, glEvalMesh2, and glEvalPoint2 will generate s texture coordinates.  See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_TEXTURE_COORD_2If enabled, calls to glEvalCoord2, glEvalMesh2, and glEvalPoint2 will generate s and t texture coordinates.  See IDREF="26755" TYPE="TITLE""glMap2"GL_MAP2_TEXTURE_COORD_3If enabled, calls to glEvalCoord2, glEvalMesh2, and glEvalPoint2 will generate s, t, and r texture coordinates.  See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_TEXTURE_COORD_4If enabled, calls to glEvalCoord2, glEvalMesh2, and glEvalPoint2 will generate s, t, r, and q texture coordinates.  See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_VERTEX_3If enabled, calls to glEvalCoord2, glEvalMesh2, and glEvalPoint2 will generate will generate x, y, and z vertex coordinates.  See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_VERTEX_4If enabled, calls to glEvalCoord2, glEvalMesh2, and glEvalPoint2 will generate homogeneous x, y, z, and w vertex coordinates.  See IDREF="26755" TYPE="TITLE""glMap2".GL_NORMALIZEIf enabled, normal vectors specified with glNormal are scaled to unit length after transformation.  See IDREF="12825" TYPE="TITLE""glNormal".GL_POINT_SMOOTHIf enabled, draw points with proper filtering.  Otherwise, draw aliased points.  See IDREF="29287" TYPE="TITLE""glPointSize".GL_POLYGON_SMOOTHIf enabled, draw polygons with proper filtering.  Otherwise, draw aliased polygons.  See IDREF="14059" TYPE="TITLE""glPolygonMode".GL_POLYGON_STIPPLEIf enabled, use the current polygon stipple pattern when rendering polygons.  See IDREF="13142" TYPE="TITLE""glPolygonStipple".GL_SCISSOR_TESTIf enabled, discard fragments that are outside the scissor rectangle.  See IDREF="32335" TYPE="TITLE""glScissor".GL_STENCIL_TESTIf enabled, do stencil testing and update the stencil buffer.  See IDREF="19234" TYPE="TITLE""glStencilFunc" and IDREF="36095" TYPE="TITLE""glStencilOp".GL_TEXTURE_1DIf enabled, one-dimensional texturing is performed (unless two-dimensional texturing is also enabled).  See IDREF="40965" TYPE="TITLE""glTexImage1D".GL_TEXTURE_2DIf enabled, two-dimensional texturing is performed.  See IDREF="38642" TYPE="TITLE""glTexImage2D".GL_TEXTURE_GEN_QIf enabled, the q texture coordinate is computed using the texture generation function defined with glTexGen.  Otherwise, the current q texture coordinate is used.  See IDREF="24845" TYPE="TITLE""glTexGen".GL_TEXTURE_GEN_RIf enabled, the r texture coordinate is computed using the texture generation function defined with glTexGen.  Otherwise, the current r texture coordinate is used.  See IDREF="24845" TYPE="TITLE""glTexGen". GL_TEXTURE_GEN_SIf enabled, the s texture coordinate is computed using the texture generation function defined with glTexGen.  Otherwise, the current s texture coordinate is used.  See IDREF="24845" TYPE="TITLE""glTexGen".GL_TEXTURE_GEN_TIf enabled, the t texture coordinate is computed using the texture generation function defined with glTexGen.  Otherwise, the current t texture coordinate is used.  See IDREF="24845" TYPE="TITLE""glTexGen".LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if cap is not one of the values listed above.  GL_INVALID_OPERATION is generated if glEnable is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""SEE ALSOIDREF="19142" TYPE="TITLE""glAlphaFunc", IDREF="11446" TYPE="TITLE""glBlendFunc", IDREF="15914" TYPE="TITLE""glClipPlane", IDREF="37922" TYPE="TITLE""glColorMaterial", IDREF="41183" TYPE="TITLE""glCullFace", IDREF="10076" TYPE="TITLE""glDepthFunc", IDREF="22828" TYPE="TITLE""glDepthRange", IDREF="21607" TYPE="TITLE""glFog", IDREF="41087" TYPE="TITLE""glGet", IDREF="31512" TYPE="TITLE""glIsEnabled", IDREF="37552" TYPE="TITLE""glLight", IDREF="19151" TYPE="TITLE""glLightModel", IDREF="23427" TYPE="TITLE""glLineWidth", IDREF="37959" TYPE="TITLE""glLineStipple", IDREF="18729" TYPE="TITLE""glLogicOp", IDREF="42533" TYPE="TITLE""glMap1", IDREF="26755" TYPE="TITLE""glMap2", IDREF="28170" TYPE="TITLE""glMaterial", IDREF="12825" TYPE="TITLE""glNormal", IDREF="29287" TYPE="TITLE""glPointSize", IDREF="14059" TYPE="TITLE""glPolygonMode", IDREF="13142" TYPE="TITLE""glPolygonStipple", IDREF="32335" TYPE="TITLE""glScissor", IDREF="19234" TYPE="TITLE""glStencilFunc", IDREF="36095" TYPE="TITLE""glStencilOp", IDREF="24845" TYPE="TITLE""glTexGen", IDREF="40965" TYPE="TITLE""glTexImage1D", IDREF="38642" TYPE="TITLE""glTexImage2D"LBL="" HELPID=""ID="41102"glEvalCoordLBL="" HELPID=""NAMEglEvalCoord1d, glEvalCoord1f, glEvalCoord2d, glEvalCoord2f, glEvalCoord1dv, glEvalCoord1fv, glEvalCoord2dv, glEvalCoord2fv - evaluate enabled one- and two-dimensional maps  LBL="" HELPID=""C SPECIFICATIONvoid glEvalCoord1d( GLdouble u ) void glEvalCoord1f( GLfloat u ) void glEvalCoord2d( GLdouble u, GLdouble v ) void glEvalCoord2f( GLfloat u, GLfloat v ) LBL="" HELPID=""PARAMETERSuSpecifies a value that is the domain coordinate u to the basis function defined in a previous glMap1 or glMap2 command.  vSpecifies a value that is the domain coordinate v to the basis function defined in a previous glMap2 command.  This argument is not present in an glEvalCoord1 command.  LBL="" HELPID=""C SPECIFICATIONvoid glEvalCoord1dv( const GLdouble *u ) void glEvalCoord1fv( const GLfloat *u ) void glEvalCoord2dv( const GLdouble *u ) void glEvalCoord2fv( const GLfloat *u ) LBL="" HELPID=""PARAMETERSuSpecifies a pointer to an array containing either one or two domain coordinates.  The first coordinate is u.  The second coordinate is v, which is present only in glEvalCoord2 versions.  LBL="" HELPID=""DESCRIPTIONglEvalCoord1 evaluates enabled one-dimensional maps at argument u.  glEvalCoord2 does the same for two-dimensional maps using two domain values, u and v.  Maps are defined with glMap1 and glMap2 and enabled and disabled with glEnable and glDisable.  When one of the glEvalCoord commands is issued, all currently enabled maps of the indicated dimension are evaluated.  Then, for each enabled map, it is as if the corresponding GL command was issued with the computed value.  That is, if GL_MAP1_INDEX or GL_MAP2_INDEX is enabled, a glIndex command is simulated.  If GL_MAP1_COLOR_4 or GL_MAP2_COLOR_4 is enabled, a glColor command is simulated.  If GL_MAP1_NORMAL or GL_MAP2_NORMAL is enabled, a normal vector is produced, and if any of GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, or GL_MAP2_TEXTURE_COORD_4 is enabled, then an appropriate glTexCoord command is simulated.  The GL uses evaluated values instead of current values for those evaluations that are enabled, and current values otherwise, for color, color index, normal, and texture coordinates.  However, the evaluated values do not update the current values.  Thus, if glVertex commands are interspersed with glEvalCoord commands, the color, normal, and texture coordinates associated with the glVertex commands are not affected by the values generated by the glEvalCoord commands, but rather only by the most recent glColor, glIndex, glNormal, and glTexCoord commands.  No commands are issued for maps that are not enabled.  If more than one texture evaluation is enabled for a particular dimension (for example, GL_MAP2_TEXTURE_COORD_1 and GL_MAP2_TEXTURE_COORD_2), then only the evaluation of the map that produces the larger number of coordinates (in this case, GL_MAP2_TEXTURE_COORD_2) is carried out.  GL_MAP1_VERTEX_4 overrides GL_MAP1_VERTEX_3, and GL_MAP2_VERTEX_4 overrides GL_MAP2_VERTEX_3, in the same manner.  If neither a three- nor four-component vertex map is enabled for the specified dimension, the glEvalCoord command is ignored.  If automatic normal generation is enabled, by calling glEnable with argument GL_AUTO_NORMAL, glEvalCoord2 generates surface normals analytically, regardless of the contents or enabling of the GL_MAP2_NORMAL map.  LetFILE="eq0501.gif" POSITION="INLINE" SCALE="FALSE"Then the generated normal n  is FILE="eq0502.gif" POSITION="INLINE" SCALE="FALSE"If automatic normal generation is disabled, the corresponding normal map GL_MAP2_NORMAL, if enabled, is used to produce a normal.  If neither automatic normal generation nor a normal map is enabled, no normal is generated for glEvalCoord2 commands.  LBL="" HELPID=""ASSOCIATED GETSglIsEnabled with argument GL_MAP1_VERTEX_3glIsEnabled with argument GL_MAP1_VERTEX_4glIsEnabled with argument GL_MAP1_INDEXglIsEnabled with argument GL_MAP1_COLOR_4glIsEnabled with argument GL_MAP1_NORMALglIsEnabled with argument GL_MAP1_TEXTURE_COORD_1glIsEnabled with argument GL_MAP1_TEXTURE_COORD_2glIsEnabled with argument GL_MAP1_TEXTURE_COORD_3glIsEnabled with argument GL_MAP1_TEXTURE_COORD_4glIsEnabled with argument GL_MAP2_VERTEX_3glIsEnabled with argument GL_MAP2_VERTEX_4glIsEnabled with argument GL_MAP2_INDEXglIsEnabled with argument GL_MAP2_COLOR_4glIsEnabled with argument GL_MAP2_NORMALglIsEnabled with argument GL_MAP2_TEXTURE_COORD_1glIsEnabled with argument GL_MAP2_TEXTURE_COORD_2glIsEnabled with argument GL_MAP2_TEXTURE_COORD_3glIsEnabled with argument GL_MAP2_TEXTURE_COORD_4glIsEnabled with argument GL_AUTO_NORMALglGetMapLBL="" HELPID=""SEE ALSOIDREF="11415" TYPE="TITLE""glBegin", IDREF="18325" TYPE="TITLE""glColor", IDREF="40792" TYPE="TITLE""glEnable", IDREF="14117" TYPE="TITLE""glEvalMesh", IDREF="14631" TYPE="TITLE""glEvalPoint", IDREF="14741" TYPE="TITLE""glIndex", IDREF="42533" TYPE="TITLE""glMap1", IDREF="26755" TYPE="TITLE""glMap2", IDREF="15455" TYPE="TITLE""glMapGrid", IDREF="12825" TYPE="TITLE""glNormal", IDREF="31124" TYPE="TITLE""glTexCoord", IDREF="32860" TYPE="TITLE""glVertex"LBL="" HELPID=""ID="14117"glEvalMeshLBL="" HELPID=""NAMEglEvalMesh1, glEvalMesh2 - compute a one- or two-dimensional grid of points or lines  LBL="" HELPID=""C SPECIFICATIONvoid glEvalMesh1( GLenum mode, GLint i1, GLint i2 ) LBL="" HELPID=""PARAMETERSmodeIn glEvalMesh1, specifies whether to compute a one-dimensional mesh of points or lines.  Symbolic constants GL_POINT and GL_LINE are accepted.  i1, i2Specify the first and last integer values for grid domain variable i.  LBL="" HELPID=""C SPECIFICATIONvoid glEvalMesh2( GLenum mode, GLint i1, Lint i2, GLint j1, GLint j2 ) LBL="" HELPID=""PARAMETERSmodeIn glEvalMesh2, specifies whether to compute a two-dimensional mesh of points, lines, or polygons.  Symbolic constants GL_POINT, GL_LINE, and GL_FILL are accepted.  i1, i2Specify the first and last integer values for grid domain variable i.  j1, j2Specify the first and last integer values for grid domain variable j. LBL="" HELPID=""DESCRIPTIONglMapGrid and glEvalMesh are used in tandem to efficiently generate and evaluate a series of evenly spaced map domain values.  glEvalMesh steps through the integer domain of a one- or two-dimensional grid, whose range is the domain of the evaluation maps specified by glMap1 and glMap2.  mode determines whether the resulting vertices are connected as points, lines, or filled polygons.  In the one-dimensional case, glEvalMesh1, the mesh is generated as if the following code fragment were executed: glBegin(type);
for (i = i1; i  <= i2; i += 1) 
  glEvalCoord1(i ∑name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'u  +  u1)
glEnd();where name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'u  =  (u2 - u1 ) / nand n, u1, and u2 are the arguments to the most recent glMapGrid1 command.  type is GL_POINTS if mode is GL_POINT, or GL_LINES if mode is GL_LINE.  The one absolute numeric requirement is that if i = n, then the value computed from i ∑name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'u  +  u1 is exactly u2.  In the two-dimensional case, glEvalMesh2, let name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'u = (u2 - u1 )/nname='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'v = (v2 - v1 )/m, where n, u1, u2, m, v1, and v2 are the arguments to the most recent glMapGrid2 command.  Then, if mode is GL_FILL, the glEvalMesh2 command is equivalent to: for (j = j1;  j  < j2; j += 1) {
    glBegin(GL_QUAD_STRIP);
    for (i = i1; i  <= i2; i += 1) {
        glEvalCoord2(i ∑name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'u  +  u1, j ∑name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'v  +  v1);
        glEvalCoord2(i ∑name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'u  +  u1, (j+1) ∑name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'v  +  v1);
    }
    glEnd();
}If mode is GL_LINE, then a call to glEvalMesh2 is equivalent to: for (j = j1;  j  <= j2; j += 1) {
    glBegin(GL_LINE_STRIP);
    for (i = i1; i  <= i2; i += 1)
        glEvalCoord2(i ∑name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'u  +  u1, j ∑name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'v  +  v1);
    glEnd();
}
for (i = i1;  i  <= i2; i += 1) {
    glBegin(GL_LINE_STRIP);
    for (j = j1; j  <= j1; j += 1)
        glEvalCoord2(i ∑name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'u  +  u1, j ∑name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'v  +  v1);
    glEnd();
}And finally, if mode is GL_POINT, then a call to glEvalMesh2 is equivalent to: glBegin(GL_POINTS);
for (j = j1;  j  <= j2; j += 1) {
    for (i = i1; i  <= i2; i += 1) {
        glEvalCoord2(i ∑name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'u  +  u1, j ∑name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'v  +  v1);
    }
}
glEnd();In all three cases, the only absolute numeric requirements are that if i = n, then the value computed from i ∑name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'u  +  u1 is exactly u2, and if j = m, then the value computed from j ∑name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'v  +  v1 is exactly v2.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if mode is not an accepted value.  GL_INVALID_OPERATION is generated if glEvalMesh is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_MAP1_GRID_DOMAINglGet with argument GL_MAP2_GRID_DOMAINglGet with argument GL_MAP1_GRID_SEGMENTSglGet with argument GL_MAP2_GRID_SEGMENTSLBL="" HELPID=""SEE ALSOIDREF="11415" TYPE="TITLE""glBegin", IDREF="41102" TYPE="TITLE""glEvalCoord", IDREF="14631" TYPE="TITLE""glEvalPoint", IDREF="42533" TYPE="TITLE""glMap1", IDREF="26755" TYPE="TITLE""glMap2", IDREF="15455" TYPE="TITLE""glMapGrid"LBL="" HELPID=""ID="14631"glEvalPointLBL="" HELPID=""NAMEglEvalPoint1, glEvalPoint2 - generate and evaluate a single point in a mesh  LBL="" HELPID=""C SPECIFICATIONvoid glEvalPoint1( GLint i ) void glEvalPoint2( GLint i, GLint j ) LBL="" HELPID=""PARAMETERSiSpecifies the integer value for grid domain variable i.  jSpecifies the integer value for grid domain variable j (glEvalPoint2 only).  LBL="" HELPID=""DESCRIPTIONglMapGrid and glEvalMesh are used in tandem to efficiently generate and evaluate a series of evenly spaced map domain values.  glEvalPoint can be used to evaluate a single grid point in the same gridspace that is traversed by glEvalMesh.  Calling glEvalPoint1 is equivalent to calling glEvalCoord1(i ∑name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'u  +  u1);where name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'u  =  (u2 - u1 ) / nand n, u1, and u2 are the arguments to the most recent glMapGrid1 command.  The one absolute numeric requirement is that if i = n, then the value computed from i ∑name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'u  +  u1 is exactly u2.  In the two-dimensional case, glEvalPoint2, let name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'u = (u2 - u1 )/nname='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'v = (v2 - v1 )/mwhere n, u1, u2, m, v1, and v2 are the arguments to the most recent glMapGrid2 command.  Then the glEvalPoint2 command is equivalent to calling glEvalCoord2(i ∑name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'u  +  u1, j ∑name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'v  +  v1);The only absolute numeric requirements are that if i = n, then the value computed from i ∑name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'u  +  u1 is exactly u2, and if j = m, then the value computed from j ∑name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'v  +  v1 is exactly v2.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_MAP1_GRID_DOMAINglGet with argument GL_MAP2_GRID_DOMAINglGet with argument GL_MAP1_GRID_SEGMENTSglGet with argument GL_MAP2_GRID_SEGMENTSLBL="" HELPID=""SEE ALSOIDREF="41102" TYPE="TITLE""glEvalCoord", IDREF="14117" TYPE="TITLE""glEvalMesh", IDREF="42533" TYPE="TITLE""glMap1", IDREF="26755" TYPE="TITLE""glMap2", IDREF="15455" TYPE="TITLE""glMapGrid"LBL="" HELPID=""ID="22322"glFeedbackBufferLBL="" HELPID=""NAMEglFeedbackBuffer - controls feedback mode  LBL="" HELPID=""C SPECIFICATIONvoid glFeedbackBuffer( GLsizei size, GLenum type, GLfloat *buffer ) LBL="" HELPID=""PARAMETERSsizeSpecifies the maximum number of values that can be written into buffer.  type Specifies a symbolic constant that describes the information that will be returned for each vertex.  GL_2D, GL_3D, GL_3D_COLOR, GL_3D_COLOR_TEXTURE, and GL_4D_COLOR_TEXTURE are accepted.  bufferReturns the feedback data.   LBL="" HELPID=""DESCRIPTIONThe glFeedbackBuffer function controls feedback.  Feedback, like selection, is a GL mode.  The mode is selected by calling glRenderMode with GL_FEEDBACK.  When the GL is in feedback mode, no pixels are produced by rasterization.  Instead, information about primitives that would have been rasterized is fed back to the application using the GL.  glFeedbackBuffer has three arguments: buffer is a pointer to an array of floating-point values into which feedback information is placed.  size indicates the size of the array.  type is a symbolic constant describing the information that is fed back for each vertex.  glFeedbackBuffer must be issued before feedback mode is enabled (by calling glRenderMode with argument GL_FEEDBACK).  Setting GL_FEEDBACK without establishing the feedback buffer, or calling glFeedbackBuffer while the GL is in feedback mode, is an error.  The GL is taken out of feedback mode by calling glRenderMode with a parameter value other than GL_FEEDBACK.  When this is done while the GL is in feedback mode, glRenderMode returns the number of entries placed in the feedback array.  The returned value never exceeds size.  If the feedback data required more room than was available in buffer, glRenderMode returns a negative value.  While in feedback mode, each primitive that would be rasterized generates a block of values that get copied into the feedback array.  If doing so would cause the number of entries to exceed the maximum, the block is partially written so as to fill the array (if there is any room left at all), and an overflow flag is set.  Each block begins with a code indicating the primitive type, followed by values that describe the primitive's vertices and associated data.  Entries are also written for bitmaps and pixel rectangles.  Feedback occurs after polygon culling and glPolyMode interpretation of polygons has taken place, so polygons that are culled are not returned in the feedback buffer.  It can also occur after polygons with more than three edges are broken up into triangles, if the GL implementation renders polygons by performing this decomposition.  The glPassThrough command can be used to insert a marker into the feedback buffer.  See IDREF="24204" TYPE="TITLE""glPassThrough".Following is the grammar for the blocks of values written into the feedback buffer.  Each primitive is indicated with a unique identifying value followed by some number of vertices.  Polygon entries include an integer value indicating how many vertices follow.  A vertex is fed back as some number of floating-point values, as determined by type.  Colors are fed back as four values in RGBA mode and one value in color index mode.  feedbackList <-- feedbackItem feedbackList | feedbackItem feedbackItem <-- point | lineSegment | polygon | bitmap | pixelRectangle | passThru point <-- GL_POINT_TOKEN vertex lineSegment <-- GL_LINE_TOKEN vertex vertex | GL_LINE_RESET_TOKEN vertex vertex polygon <-- GL_POLYGON_TOKEN n polySpec polySpec <-- polySpec vertex | vertex vertex vertex bitmap <-- GL_BITMAP_TOKEN vertex pixelRectangle <-- GL_DRAW_PIXEL_TOKEN vertex | GL_COPY_PIXEL_TOKEN vertex passThru <-- GL_PASS_THROUGH_TOKEN value vertex <-- 2d | 3d | 3dColor | 3dColorTexture | 4dColorTexture 2d <-- value value 3d <-- value value value 3dColor  <-- value value value color 3dColorTexture <-- value value value color tex 4dColorTexture <-- value value value value color tex color <-- rgba | index rgba <-- value value value value index <-- value tex <-- value value value value value is a floating-point number, and n is a floating-point integer giving the number of vertices in the polygon.  GL_POINT_TOKEN, GL_LINE_TOKEN, GL_LINE_RESET_TOKEN, GL_POLYGON_TOKEN, GL_BITMAP_TOKEN, GL_DRAW_PIXEL_TOKEN, GL_COPY_PIXEL_TOKEN and GL_PASS_THROUGH_TOKEN are symbolic floating-point constants.  GL_LINE_RESET_TOKEN is returned whenever the line stipple pattern is reset.  The data returned as a vertex depends on the feedback type.  The following table gives the correspondence between type and the number of values per vertex.  k is 1 in color index mode and 4 in RGBA mode.  COLUMNS="5"LEFT="0" WIDTH="72"typeLEFT="80" WIDTH="72"coordinatesLEFT="160" WIDTH="72"colorLEFT="240" WIDTH="72"textureLEFT="320" WIDTH="72"total number of 
valuesLEFT="0" WIDTH="72"GL_2DLEFT="80" WIDTH="72"x, yLEFT="160" WIDTH="72"LEFT="240" WIDTH="72"LEFT="320" WIDTH="72"2LEFT="0" WIDTH="72"GL_3DLEFT="80" WIDTH="72"x, y, zLEFT="160" WIDTH="72"LEFT="240" WIDTH="72"LEFT="320" WIDTH="72"3LEFT="0" WIDTH="72"GL_3D_COLO
RLEFT="80" WIDTH="72"x, y, zLEFT="160" WIDTH="72"kLEFT="240" WIDTH="72"LEFT="320" WIDTH="72"3 + kLEFT="0" WIDTH="72"GL_3D_COLO
R_TEXTURELEFT="80" WIDTH="72"x, y, z,LEFT="160" WIDTH="72"kLEFT="240" WIDTH="72"4LEFT="320" WIDTH="72"7 + kLEFT="0" WIDTH="72"GL_4D_COLO
R_TEXTURELEFT="80" WIDTH="72"x, y, z, wLEFT="160" WIDTH="72"kLEFT="240" WIDTH="72"4LEFT="320" WIDTH="72"8 + kFeedback vertex coordinates are in window coordinates, except w, which is in clip coordinates.  Feedback colors are lighted, if lighting is enabled.  Feedback texture coordinates are generated, if texture coordinate generation is enabled.  They are always transformed by the texture matrix.  LBL="" HELPID=""NOTESglFeedbackBuffer, when used in a display list, is not compiled into the display list but rather is executed immediately.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if type is not an accepted value.  GL_INVALID_VALUE is generated if size is negative.  GL_INVALID_OPERATION is generated if glFeedbackBuffer is called while the render mode is GL_FEEDBACK, or if glRenderMode is called with argument GL_FEEDBACK before glFeedbackBuffer is called at least once.  GL_INVALID_OPERATION is generated if glFeedbackBuffer is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_RENDER_MODELBL="" HELPID=""SEE ALSOIDREF="11415" TYPE="TITLE""glBegin", IDREF="37959" TYPE="TITLE""glLineStipple", IDREF="24204" TYPE="TITLE""glPassThrough", IDREF="14059" TYPE="TITLE""glPolygonMode", IDREF="35248" TYPE="TITLE""glRenderMode", IDREF="35181" TYPE="TITLE""glSelectBuffer"LBL="" HELPID=""ID="21959"glFinishLBL="" HELPID=""NAMEglFinish - block until all GL execution is complete  LBL="" HELPID=""C SPECIFICATIONvoid glFinish( void ) LBL="" HELPID=""DESCRIPTIONglFinish does not return until the effects of all previously called GL commands are complete.  Such effects include all changes to GL state, all changes to connection state, and all changes to the frame buffer contents.  LBL="" HELPID=""NOTESglFinish requires a round trip to the server.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glFinish is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""SEE ALSOIDREF="38698" TYPE="TITLE""glFlush", IDREF="37102" TYPE="TITLE""glXWaitGL", IDREF="18364" TYPE="TITLE""glXWaitX"LBL="" HELPID=""ID="38698"glFlushLBL="" HELPID=""NAMEglFlush - force execution of GL commands in finite time  LBL="" HELPID=""C SPECIFICATIONvoid glFlush( void )LBL="" HELPID=""DESCRIPTIONDifferent GL implementations buffer commands in several different locations, including network buffers and the graphics accelerator itself.  glFlush empties all of these buffers, causing all issued commands to be executed as quickly as they are accepted by the actual rendering engine.  Though this execution may not be completed in any particular time period, it does complete in finite time.  Because any GL program might be executed over a network, or on an accelerator that buffers commands, all programs should call glFlush whenever they count on having all of their previously issued commands completed.  For example, call glFlush before waiting for user input that depends on the generated image.  LBL="" HELPID=""NOTESglFlush can return at any time.  It does not wait until the execution of all previously issued OpenGL commands is complete.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glFlush is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""SEE ALSOIDREF="21959" TYPE="TITLE""glFinish"LBL="" HELPID=""ID="21607"glFogLBL="" HELPID=""NAMEglFogf, glFogi, glFogfv, glFogiv - specify fog parameters  LBL="" HELPID=""C SPECIFICATIONvoid glFogf( GLenum pname, GLfloat param ) void glFogi( GLenum pname, GLint param ) LBL="" HELPID=""PARAMETERSpnameSpecifies a single-valued fog parameter.  GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, and GL_FOG_INDEX are accepted.  paramSpecifies the value that pname will be set to.  LBL="" HELPID=""C SPECIFICATIONvoid glFogfv( GLenum pname, const GLfloat *params ) void glFogiv( GLenum pname, const GLint *params ) LBL="" HELPID=""PARAMETERSpnameSpecifies a fog parameter.  GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COLOR are accepted.  paramsSpecifies the value or values to be assigned to pname.  GL_FOG_COLOR requires an array of four values.  All other parameters accept an array containing only a single value.  LBL="" HELPID=""DESCRIPTIONFog is enabled and disabled with glEnable and glDisable using the argument GL_FOG.  While enabled, fog affects rasterized geometry, bitmaps, and pixel blocks, but not buffer clear operations.  glFog assigns the value or values in params to the fog parameter specified by pname.  The accepted values for pname are as follows: GL_FOG_MODEparams is a single integer or floating-point value that specifies the equation to be used to compute the fog blend factor, f.  Three symbolic constants are accepted: GL_LINEAR, GL_EXP, and GL_EXP2.  The equations corresponding to these symbolic constants are defined below.  The default fog mode is GL_EXP.  GL_FOG_DENSITYparams is a single integer or floating-point value that specifies density, the fog density used in both exponential fog equations.  Only nonnegative densities are accepted.  The default fog density is 1.0.  GL_FOG_STARTparams is a single integer or floating-point value that specifies start, the near distance used in the linear fog equation.  The default near distance is 0.0.  GL_FOG_ENDparams is a single integer or floating-point value that specifies end, the far distance used in the linear fog equation.  The default far distance is 1.0.  GL_FOG_INDEXparams is a single integer or floating-point value that specifies if, the fog color index.  The default fog index is 0.0.  GL_FOG_COLORparams contains four integer or floating-point values that specify Cf, the fog color.  Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0.  Floating-point values are mapped directly.  After conversion, all color components are clamped to the range [0,1].  The default fog color is (0,0,0,0).  Fog blends a fog color with each rasterized pixel fragment's posttexturing color using a blending factor f.  Factor f is computed in one of three ways, depending on the fog mode.  Let z be the distance in eye coordinates from the origin to the fragment being fogged.  The equation for GL_LINEAR fog isFILE="eq0503.gif" POSITION="INLINE" SCALE="FALSE"The equation for GL_EXP fog isFILE="eq0599.gif" POSITION="INLINE" SCALE="FALSE"The equation for GL_EXP2 fog isFILE="eq0504.gif" POSITION="INLINE" SCALE="FALSE"Regardless of the fog mode, f is clamped to the range [0,1] after it is computed.  Then, if the GL is in RGBA color mode, the fragment's color Cr is replaced byCr'=fCr+(1-f)CfIn color index mode, the fragment's color index ir is replaced byir'=ir+(1-f)ifLBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if pname is not an accepted value, or if pname is GL_FOG_MODE and params is not an accepted value.  GL_INVALID_VALUE is generated if pname is GL_FOG_DENSITY and params is negative.  GL_INVALID_OPERATION is generated if glFog is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglIsEnabled with argument GL_FOGglGet with argument GL_FOG_COLORglGet with argument GL_FOG_INDEXglGet with argument GL_FOG_DENSITYglGet with argument GL_FOG_STARTglGet with argument GL_FOG_ENDglGet with argument GL_FOG_MODELBL="" HELPID=""SEE ALSOIDREF="40792" TYPE="TITLE""glEnable"LBL="" HELPID=""ID="27863"glFrontFaceLBL="" HELPID=""NAMEglFrontFace - define front- and back-facing polygons  LBL="" HELPID=""C SPECIFICATIONvoid glFrontFace( GLenum mode ) LBL="" HELPID=""PARAMETERSmodeSpecifies the orientation of front-facing polygons.  GL_CW and GL_CCW are accepted.  The default value is GL_CCW.   LBL="" HELPID=""DESCRIPTIONIn a scene composed entirely of opaque closed surfaces, back-facing polygons are never visible.  Eliminating these invisible polygons has the obvious benefit of speeding up the rendering of the image.  Elimination of back-facing polygons is enabled and disabled with glEnable and glDisable using argument GL_CULL_FACE.  The projection of a polygon to window coordinates is said to have clockwise winding if an imaginary object following the path from its first vertex, its second vertex, and so on, to its last vertex, and finally back to its first vertex, moves in a clockwise direction about the interior of the polygon.  The polygon's winding is said to be counterclockwise if the imaginary object following the same path moves in a counterclockwise direction about the interior of the polygon.  glFrontFace specifies whether polygons with clockwise winding in window coordinates, or counterclockwise winding in window coordinates, are taken to be front-facing.  Passing GL_CCW to mode selects counterclockwise polygons as front-facing; GL_CW selects clockwise polygons as front-facing.  By default, counterclockwise polygons are taken to be front-facing.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if mode is not an accepted value.  GL_INVALID_OPERATION is generated if glFrontFace is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_FRONT_FACELBL="" HELPID=""SEE ALSOIDREF="41183" TYPE="TITLE""glCullFace", IDREF="19151" TYPE="TITLE""glLightModel"LBL="" HELPID=""ID="13747"glFrustumLBL="" HELPID=""NAMEglFrustum - multiply the current matrix by a perspective matrix  LBL="" HELPID=""C SPECIFICATIONvoid glFrustum( GLdouble left, GLdouble right, GLdouble bottom,         GLdouble top, GLdouble near, GLdouble far ) LBL="" HELPID=""PARAMETERSleft, rightSpecify the coordinates for the left and right vertical clipping planes.  bottom, topSpecify the coordinates for the bottom and top horizontal clipping planes.  near, farSpecify the distances to the near and far depth clipping planes.  Both distances must be positive.   LBL="" HELPID=""DESCRIPTIONglFrustum describes a perspective matrix that produces a perspective projection.  (left, bottom, -near) and (right, top,  -near) specify the points on the near clipping plane that are mapped to the lower left and upper right corners of the window, respectively, assuming that the eye is located at (0, 0, 0).  -far specifies the location of the far clipping plane.  Both near and far must be positive.  The corresponding matrix is FILE="eq0505.gif" POSITION="INLINE" SCALE="FALSE"The current matrix is multiplied by this matrix with the result replacing the current matrix.  That is, if M is the current matrix and F is the frustum perspective matrix, then M is replaced with MF.  Use glPushMatrix and glPopMatrix to save and restore the current matrix stack.  LBL="" HELPID=""NOTESDepth buffer precision is affected by the values specified for near and far.  The greater the ratio of far to near is, the less effective the depth buffer will be at distinguishing between surfaces that are near each other.  If FILE="eq0506.gif" POSITION="INLINE" SCALE="FALSE"roughly log2 r bits of depth buffer precision are lost.  Because r approaches infinity as near approaches zero, near must never be set to zero.  LBL="" HELPID=""ERRORSGL_INVALID_VALUE is generated if near or far is not positive.  GL_INVALID_OPERATION is generated if glFrustum is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_MATRIX_MODEglGet with argument GL_MODELVIEW_MATRIXglGet with argument GL_PROJECTION_MATRIXglGet with argument GL_TEXTURE_MATRIXLBL="" HELPID=""SEE ALSOIDREF="30307" TYPE="TITLE""glOrtho", IDREF="33637" TYPE="TITLE""glMatrixMode", IDREF="17230" TYPE="TITLE""glMultMatrix", IDREF="41698" TYPE="TITLE""glPushMatrix", IDREF="17575" TYPE="TITLE""glViewport"LBL="" HELPID=""ID="12827"glGenListsLBL="" HELPID=""NAMEglGenLists - generate a contiguous set of empty display lists  LBL="" HELPID=""C SPECIFICATIONGLuint glGenLists( GLsizei range ) LBL="" HELPID=""PARAMETERSrangeSpecifies the number of contiguous empty display lists to be generated.   LBL="" HELPID=""DESCRIPTIONglGenLists has one argument, range.  It returns an integer n such that range contiguous empty display lists, named n, n+1, ..., n+range -1, are created.  If range is zero, if there is no group of range contiguous names available, or if any error is generated, no display lists are generated, and zero is returned.  LBL="" HELPID=""ERRORSGL_INVALID_VALUE is generated if range is negative.  GL_INVALID_OPERATION is generated if glGenLists is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglIsListLBL="" HELPID=""SEE ALSOIDREF="37134" TYPE="TITLE""glCallList", IDREF="15751" TYPE="TITLE""glCallLists", IDREF="13566" TYPE="TITLE""glDeleteLists", IDREF="28073" TYPE="TITLE""glNewList"LBL="" HELPID=""ID="41087"glGetLBL="" HELPID=""NAMEglGetBooleanv, glGetDoublev, glGetFloatv, glGetIntegerv - return the value or values of a selected parameter  LBL="" HELPID=""C SPECIFICATIONvoid glGetBooleanv( GLenum pname, GLboolean *params ) void glGetDoublev( GLenum pname, GLdouble *params ) void glGetFloatv( GLenum pname, GLfloat *params ) void glGetIntegerv( GLenum pname, GLint *params ) LBL="" HELPID=""PARAMETERSpnameSpecifies the parameter value to be returned.  The symbolic constants in the list below are accepted.  paramsReturns the value or values of the specified parameter.  LBL="" HELPID=""DESCRIPTIONThese four commands return values for simple state variables in GL.  pname is a symbolic constant indicating the state variable to be returned, and params is a pointer to an array of the indicated type in which to place the returned data.  Type conversion is performed if params has a different type than the state variable value being requested.  If glGetBooleanv is called, a floating-point or integer value is converted to GL_FALSE if and only if it is zero.  Otherwise, it is converted to GL_TRUE.  If glGetIntegerv is called, Boolean values are returned as GL_TRUE or GL_FALSE, and most floating-point values are rounded to the nearest integer value.  Floating-point colors and normals, however, are returned with a linear mapping that maps 1.0 to the most positive representable integer value, and -1.0 to the most negative representable integer value.  If glGetFloatv or glGetDoublev is called, Boolean values are returned as GL_TRUE or GL_FALSE, and integer values are converted to floating-point values.  The following symbolic constants are accepted by pname: GL_ACCUM_ALPHA_BITSparams returns one value, the number of alpha bitplanes in the accumulation buffer.  GL_ACCUM_BLUE_BITSparams returns one value, the number of blue bitplanes in the accumulation buffer.  GL_ACCUM_CLEAR_VALUEparams returns four values: the red, green, blue, and alpha values used to clear the accumulation buffer.  Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value.  See IDREF="22877" TYPE="TITLE""glClearAccum".GL_ACCUM_GREEN_BITSparams returns one value, the number of green bitplanes in the accumulation buffer.  GL_ACCUM_RED_BITSparams returns one value, the number of red bitplanes in the accumulation buffer.  GL_ALPHA_BIASparams returns one value, the alpha bias factor used during pixel transfers.  See IDREF="38440" TYPE="TITLE""glPixelTransfer".GL_ALPHA_BITSparams returns one value, the number of alpha bitplanes in each color buffer.  GL_ALPHA_SCALEparams returns one value, the alpha scale factor used during pixel transfers.  See IDREF="38440" TYPE="TITLE""glPixelTransfer".GL_ALPHA_TESTparams returns a single Boolean value indicating whether alpha testing of fragments is enabled.  See IDREF="19142" TYPE="TITLE""glAlphaFunc".GL_ALPHA_TEST_FUNCparams returns one value, the symbolic name of the alpha test function.  See IDREF="19142" TYPE="TITLE""glAlphaFunc".GL_ALPHA_TEST_REFparams returns one value, the reference value for the alpha test.  See IDREF="19142" TYPE="TITLE""glAlphaFunc". An integer value, if requested, is linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value.  GL_ATTRIB_STACK_DEPTHparams returns one value, the depth of the attribute stack.  If the stack is empty, zero is returned.  See IDREF="12225" TYPE="TITLE""glPushAttrib".GL_AUTO_NORMALparams returns a single Boolean value indicating whether 2-D map evaluation automatically generates surface normals.  See IDREF="26755" TYPE="TITLE""glMap2".GL_AUX_BUFFERSparams returns one value, the number of auxiliary color buffers.  GL_BLENDparams returns a single Boolean value indicating whether blending is enabled.  See IDREF="11446" TYPE="TITLE""glBlendFunc".GL_BLEND_DSTparams returns one value, the symbolic constant identifying the destination blend function.  See IDREF="11446" TYPE="TITLE""glBlendFunc".GL_BLEND_SRCparams returns one value, the symbolic constant identifying the source blend function.  See IDREF="11446" TYPE="TITLE""glBlendFunc".GL_BLUE_BIASparams returns one value, the blue bias factor used during pixel transfers.  See IDREF="38440" TYPE="TITLE""glPixelTransfer".GL_BLUE_BITSparams returns one value, the number of blue bitplanes in each color buffer.  GL_BLUE_SCALEparams returns one value, the blue scale factor used during pixel transfers.  See IDREF="38440" TYPE="TITLE""glPixelTransfer".GL_CLIP_PLANEiparams returns a single Boolean value indicating whether the specified clipping plane is enabled.  See IDREF="15914" TYPE="TITLE""glClipPlane".GL_COLOR_CLEAR_VALUEparams returns four values: the red, green, blue, and alpha values used to clear the color buffers.  Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value.  See IDREF="11098" TYPE="TITLE""glClearColor".GL_COLOR_MATERIALparams returns a single Boolean value indicating whether one or more material parameters are tracking the current color.  See IDREF="37922" TYPE="TITLE""glColorMaterial".GL_COLOR_MATERIAL_FACEparams returns one value, a symbolic constant indicating which materials have a parameter that is tracking the current color.  See IDREF="37922" TYPE="TITLE""glColorMaterial"GL_COLOR_MATERIAL_PARAMETERparams returns one value, a symbolic constant indicating which material parameters are tracking the current color.  See IDREF="37922" TYPE="TITLE""glColorMaterial".GL_COLOR_WRITEMASKparams returns four Boolean values: the red, green, blue, and alpha write enables for the color buffers.  See IDREF="42526" TYPE="TITLE""glColorMask".GL_CULL_FACEparams returns a single Boolean value indicating whether polygon culling is enabled.  See IDREF="41183" TYPE="TITLE""glCullFace".GL_CULL_FACE_MODEparams returns one value, a symbolic constant indicating which polygon faces are to be culled.  See IDREF="41183" TYPE="TITLE""glCullFace".GL_CURRENT_COLORparams returns four values: the red, green, blue, and alpha values of the current color.  Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value.  See IDREF="18325" TYPE="TITLE""glColor".GL_CURRENT_INDEXparams returns one value, the current color index.  See IDREF="14741" TYPE="TITLE""glIndex".GL_CURRENT_NORMALparams returns three values: the x, y, and z values of the current normal.  Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value.  See IDREF="12825" TYPE="TITLE""glNormal".GL_CURRENT_RASTER_COLORparams returns four values: the red, green, blue, and alpha values of the current raster position.  Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value.  See IDREF="40922" TYPE="TITLE""glRasterPos".GL_CURRENT_RASTER_DISTANCEparams returns one value, the distance from the eye to the current raster position.  See IDREF="40922" TYPE="TITLE""glRasterPos".GL_CURRENT_RASTER_INDEXparams returns one value, the color index of the current raster position.  See IDREF="40922" TYPE="TITLE""glRasterPos".GL_CURRENT_RASTER_POSITIONparams returns four values: the x, y, z, and w components of the current raster position.  x, y, and z are in window coordinates, and w is in clip coordinates.  See IDREF="40922" TYPE="TITLE""glRasterPos".GL_CURRENT_RASTER_TEXTURE_COORDSparams returns four values: the s, t, r, and q current raster texture coordinates.  See IDREF="40922" TYPE="TITLE""glRasterPos" and IDREF="31124" TYPE="TITLE""glTexCoord".GL_CURRENT_RASTER_POSITION_VALIDparams returns a single Boolean value indicating whether the current raster position is valid.  See IDREF="40922" TYPE="TITLE""glRasterPos".GL_CURRENT_TEXTURE_COORDSparams returns four values: the s, t, r, and q current texture coordinates.  See IDREF="31124" TYPE="TITLE""glTexCoord".GL_DEPTH_BIASparams returns one value, the depth bias factor used during pixel transfers.  See IDREF="38440" TYPE="TITLE""glPixelTransfer".GL_DEPTH_BITSparams returns one value, the number of bitplanes in the depth buffer.  GL_DEPTH_CLEAR_VALUEparams returns one value, the value that is used to clear the depth buffer.  Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value.  See IDREF="24334" TYPE="TITLE""glClearDepth".GL_DEPTH_FUNCparams returns one value, the symbolic constant that indicates the depth comparison function.  See IDREF="10076" TYPE="TITLE""glDepthFunc".GL_DEPTH_RANGEparams returns two values: the near and far mapping limits for the depth buffer.  Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value.  See IDREF="22828" TYPE="TITLE""glDepthRange".GL_DEPTH_SCALEparams returns one value, the depth scale factor used during pixel transfers.  See IDREF="38440" TYPE="TITLE""glPixelTransfer".GL_DEPTH_TESTparams returns a single Boolean value indicating whether depth testing of fragments is enabled.  See IDREF="10076" TYPE="TITLE""glDepthFunc" and IDREF="22828" TYPE="TITLE""glDepthRange".GL_DEPTH_WRITEMASKparams returns a single Boolean value indicating if the depth buffer is enabled for writing.  See IDREF="31383" TYPE="TITLE""glDepthMask".GL_DITHERparams returns a single Boolean value indicating whether dithering of fragment colors and indices is enabled.  GL_DOUBLEBUFFERparams returns a single Boolean value indicating whether double buffering is supported.  GL_DRAW_BUFFERparams returns one value, a symbolic constant indicating which buffers are being drawn to.  See IDREF="18132" TYPE="TITLE""glDrawBuffer".GL_EDGE_FLAGparams returns a single Boolean value indication whether the current edge flag is true or false.  See IDREF="40044" TYPE="TITLE""glEdgeFlag".GL_FOGparams returns a single Boolean value indicating whether fogging is enabled.  See IDREF="21607" TYPE="TITLE""glFog".GL_FOG_COLORparams returns four values: the red, green, blue, and alpha components of the fog color.  Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value.  See IDREF="21607" TYPE="TITLE""glFog".GL_FOG_DENSITYparams returns one value, the fog density parameter.  See IDREF="21607" TYPE="TITLE""glFog".GL_FOG_ENDparams returns one value, the end factor for the linear fog equation.  See IDREF="21607" TYPE="TITLE""glFog".GL_FOG_HINTparams returns one value, a symbolic constant indicating the mode of the fog hint.  See IDREF="37118" TYPE="TITLE""glHint".GL_FOG_INDEXparams returns one value, the fog color index.  See IDREF="21607" TYPE="TITLE""glFog".GL_FOG_MODEparams returns one value, a symbolic constant indicating which fog equation is selected.  See IDREF="21607" TYPE="TITLE""glFog".GL_FOG_STARTparams returns one value, the start factor for the linear fog equation.  See IDREF="21607" TYPE="TITLE""glFog".GL_FRONT_FACEparams returns one value, a symbolic constant indicating whether clockwise or counterclockwise polygon winding is treated as front-facing.  See IDREF="27863" TYPE="TITLE""glFrontFace".GL_GREEN_BIASparams returns one value, the green bias factor used during pixel transfers.  GL_GREEN_BITSparams returns one value, the number of green bitplanes in each color buffer.  GL_GREEN_SCALEparams returns one value, the green scale factor used during pixel transfers.  See IDREF="38440" TYPE="TITLE""glPixelTransfer".GL_INDEX_BITSparams returns one value, the number of bitplanes in each color index buffer.  GL_INDEX_CLEAR_VALUEparams returns one value, the color index used to clear the color index buffers.  See IDREF="26899" TYPE="TITLE""glClearIndex".GL_INDEX_MODEparams returns a single Boolean value indicating whether the GL is in color index mode (true) or RGBA mode (false).  GL_INDEX_OFFSETparams returns one value, the offset added to color and stencil indices during pixel transfers.  See IDREF="38440" TYPE="TITLE""glPixelTransfer".GL_INDEX_SHIFTparams returns one value, the amount that color and stencil indices are shifted during pixel transfers. See IDREF="38440" TYPE="TITLE""glPixelTransfer".GL_INDEX_WRITEMASKparams returns one value, a mask indicating which bitplanes of each color index buffer can be written.  See IDREF="31111" TYPE="TITLE""glIndexMask".GL_LIGHTiparams returns a single Boolean value indicating whether the specified light is enabled.  See IDREF="37552" TYPE="TITLE""glLight" and IDREF="19151" TYPE="TITLE""glLightModel".GL_LIGHTINGparams returns a single Boolean value indicating whether lighting is enabled.  See IDREF="19151" TYPE="TITLE""glLightModel".GL_LIGHT_MODEL_AMBIENTparams returns four values: the red, green, blue, and alpha components of the ambient intensity of the entire scene.  Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value.  See IDREF="19151" TYPE="TITLE""glLightModel".GL_LIGHT_MODEL_LOCAL_VIEWERparams returns a single Boolean value indicating whether specular reflection calculations treat the viewer as being local to the scene.  See IDREF="19151" TYPE="TITLE""glLightModel".GL_LIGHT_MODEL_TWO_SIDEparams returns a single Boolean value indicating whether separate materials are used to compute lighting for front- and back-facing polygons.  See IDREF="19151" TYPE="TITLE""glLightModel".GL_LINE_SMOOTHparams returns a single Boolean value indicating whether antialiasing of lines is enabled.  See IDREF="23427" TYPE="TITLE""glLineWidth".GL_LINE_SMOOTH_HINTparams returns one value, a symbolic constant indicating the mode of the line antialiasing hint.  See IDREF="37118" TYPE="TITLE""glHint".GL_LINE_STIPPLEparams returns a single Boolean value indicating whether stippling of lines is enabled.  See IDREF="37959" TYPE="TITLE""glLineStipple".GL_LINE_STIPPLE_PATTERNparams returns one value, the 16-bit line stipple pattern.  See IDREF="37959" TYPE="TITLE""glLineStipple".GL_LINE_STIPPLE_REPEATparams returns one value, the line stipple repeat factor.  See IDREF="37959" TYPE="TITLE""glLineStipple".GL_LINE_WIDTHparams returns one value, the line width as specified with glLineWidth.  GL_LINE_WIDTH_GRANULARITYparams returns one value, the width difference between adjacent supported widths for antialiased lines.  See IDREF="23427" TYPE="TITLE""glLineWidth".GL_LINE_WIDTH_RANGEparams returns two values: the smallest and largest supported widths for antialiased lines.  See IDREF="23427" TYPE="TITLE""glLineWidth".GL_LIST_BASEparams returns one value, the base offset added to all names in arrays presented to glCallLists.  See IDREF="38449" TYPE="TITLE""glListBase".GL_LIST_INDEXparams returns one value, the name of the display list currently under construction.  Zero is returned if no display list is currently under construction.  See IDREF="28073" TYPE="TITLE""glNewList".GL_LIST_MODEparams returns one value, a symbolic constant indicating the construction mode of the display list currently being constructed.  See IDREF="28073" TYPE="TITLE""glNewList".GL_LOGIC_OPparams returns a single Boolean value indicating whether fragment indexes are merged into the framebuffer using a logical operation.  See IDREF="18729" TYPE="TITLE""glLogicOp".GL_LOGIC_OP_MODEparams returns one value, a symbolic constant indicating the selected logic operational mode.  See IDREF="18729" TYPE="TITLE""glLogicOp".GL_MAP1_COLOR_4params returns a single Boolean value indicating whether 1D evaluation generates colors.  See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_GRID_DOMAINparams returns two values: the endpoints of the 1-D map's grid domain.  See IDREF="15455" TYPE="TITLE""glMapGrid".GL_MAP1_GRID_SEGMENTSparams returns one value, the number of partitions in the 1-D map's grid domain.  See IDREF="15455" TYPE="TITLE""glMapGrid".GL_MAP1_INDEXparams returns a single Boolean value indicating whether 1D evaluation generates color indices.  See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_NORMALparams returns a single Boolean value indicating whether 1D evaluation generates normals.  See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_TEXTURE_COORD_1params returns a single Boolean value indicating whether 1D evaluation generates 1D texture coordinates.  See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_TEXTURE_COORD_2params returns a single Boolean value indicating whether 1D evaluation generates 2D texture coordinates.  See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_TEXTURE_COORD_3params returns a single Boolean value indicating whether 1D evaluation generates 3D texture coordinates.  See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_TEXTURE_COORD_4params returns a single Boolean value indicating whether 1D evaluation generates 4D texture coordinates.  See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_VERTEX_3params returns a single Boolean value indicating whether 1D evaluation generates 3D vertex coordinates.  See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_VERTEX_4params returns a single Boolean value indicating whether 1D evaluation generates 4D vertex coordinates.  See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP2_COLOR_4params returns a single Boolean value indicating whether 2D evaluation generates colors.  See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_GRID_DOMAINparams returns four values: the endpoints of the 2-D map's i and j grid domains.  See IDREF="15455" TYPE="TITLE""glMapGrid".GL_MAP2_GRID_SEGMENTSparams returns two values: the number of partitions in the 2-D map's i and j grid domains.  See IDREF="15455" TYPE="TITLE""glMapGrid".GL_MAP2_INDEXparams returns a single Boolean value indicating whether 2D evaluation generates color indices.  See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_NORMALparams returns a single Boolean value indicating whether 2D evaluation generates normals.  See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_TEXTURE_COORD_1params returns a single Boolean value indicating whether 2D evaluation generates 1D texture coordinates.  See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_TEXTURE_COORD_2params returns a single Boolean value indicating whether 2D evaluation generates 2D texture coordinates.  See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_TEXTURE_COORD_3params returns a single Boolean value indicating whether 2D evaluation generates 3D texture coordinates.  See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_TEXTURE_COORD_4params returns a single Boolean value indicating whether 2D evaluation generates 4D texture coordinates.  See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_VERTEX_3params returns a single Boolean value indicating whether 2D evaluation generates 3D vertex coordinates.  See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_VERTEX_4params returns a single Boolean value indicating whether 2D evaluation generates 4D vertex coordinates.  See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP_COLORparams returns a single Boolean value indicating if colors and color indices are to be replaced by table lookup during pixel transfers.  See IDREF="38440" TYPE="TITLE""glPixelTransfer".GL_MAP_STENCILparams returns a single Boolean value indicating if stencil indices are to be replaced by table lookup during pixel transfers.  See IDREF="38440" TYPE="TITLE""glPixelTransfer".GL_MATRIX_MODEparams returns one value, a symbolic constant indicating which matrix stack is currently the target of all matrix operations.  See IDREF="33637" TYPE="TITLE""glMatrixMode".GL_MAX_ATTRIB_STACK_DEPTHparams returns one value, the maximum supported depth of the attribute stack.  See IDREF="12225" TYPE="TITLE""glPushAttrib".GL_MAX_CLIP_PLANESparams returns one value, the maximum number of application-defined clipping planes.  See IDREF="15914" TYPE="TITLE""glClipPlane".GL_MAX_EVAL_ORDERparams returns one value, the maximum equation order supported by 1-D and 2-D evaluators.  See IDREF="42533" TYPE="TITLE""glMap1" and IDREF="26755" TYPE="TITLE""glMap2".GL_MAX_LIGHTSparams returns one value, the maximum number of lights.  See IDREF="37552" TYPE="TITLE""glLight".GL_MAX_LIST_NESTINGparams returns one value, the maximum recursion depth allowed during display-list traversal.  See IDREF="37134" TYPE="TITLE""glCallList".GL_MAX_MODELVIEW_STACK_DEPTHparams returns one value, the maximum supported depth of the modelview matrix stack.  See IDREF="41698" TYPE="TITLE""glPushMatrix".GL_MAX_NAME_STACK_DEPTHparams returns one value, the maximum supported depth of the selection name stack.  See IDREF="32163" TYPE="TITLE""glPushName".GL_MAX_PIXEL_MAP_TABLEparams returns one value, the maximum supported size of a glPixelMap lookup table.  See IDREF="34580" TYPE="TITLE""glPixelMap".GL_MAX_PROJECTION_STACK_DEPTHparams returns one value, the maximum supported depth of the projection matrix stack.  See IDREF="41698" TYPE="TITLE""glPushMatrix".GL_MAX_TEXTURE_SIZEparams returns one value, the maximum width or height of any texture image (without borders).  See IDREF="40965" TYPE="TITLE""glTexImage1D" and IDREF="38642" TYPE="TITLE""glTexImage2D".GL_MAX_TEXTURE_STACK_DEPTHparams returns one value, the maximum supported depth of the texture matrix stack.  See IDREF="41698" TYPE="TITLE""glPushMatrix".GL_MAX_VIEWPORT_DIMSparams returns two values: the maximum supported width and height of the viewport.  See IDREF="17575" TYPE="TITLE""glViewport".GL_MODELVIEW_MATRIXparams returns sixteen values: the modelview matrix on the top of the modelview matrix stack.  See IDREF="41698" TYPE="TITLE""glPushMatrix".GL_MODELVIEW_STACK_DEPTHparams returns one value, the number of matrices on the modelview matrix stack.  See IDREF="41698" TYPE="TITLE""glPushMatrix".GL_NAME_STACK_DEPTHparams returns one value, the number of names on the selection name stack.  See IDREF="41698" TYPE="TITLE""glPushMatrix".GL_NORMALIZEparams returns a single Boolean value indicating whether normals are automatically scaled to unit length after they have been transformed to eye coordinates.  See IDREF="12825" TYPE="TITLE""glNormal".GL_PACK_ALIGNMENTparams returns one value, the byte alignment used for writing pixel data to memory.  See IDREF="39579" TYPE="TITLE""glPixelStore".GL_PACK_LSB_FIRSTparams returns a single Boolean value indicating whether single-bit pixels being written to memory are written first to the least significant bit of each unsigned byte.  See IDREF="39579" TYPE="TITLE""glPixelStore".GL_PACK_ROW_LENGTHparams returns one value, the row length used for writing pixel data to memory.  See IDREF="39579" TYPE="TITLE""glPixelStore".GL_PACK_SKIP_PIXELSparams returns one value, the number of pixel locations skipped before the first pixel is written into memory.  See IDREF="39579" TYPE="TITLE""glPixelStore".GL_PACK_SKIP_ROWSparams returns one value, the number of rows of pixel locations skipped before the first pixel is written into memory.  See IDREF="39579" TYPE="TITLE""glPixelStore".GL_PACK_SWAP_BYTESparams returns a single Boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped before being written to memory.  See IDREF="39579" TYPE="TITLE""glPixelStore"GL_PERSPECTIVE_CORRECTION_HINTparams returns one value, a symbolic constant indicating the mode of the perspective correction hint.  See IDREF="37118" TYPE="TITLE""glHint".GL_PIXEL_MAP_A_TO_A_SIZEparams returns one value, the size of the alpha-to-alpha pixel translation table.  See IDREF="34580" TYPE="TITLE""glPixelMap".GL_PIXEL_MAP_B_TO_B_SIZEparams returns one value, the size of the blue-to-blue pixel translation table.  See IDREF="34580" TYPE="TITLE""glPixelMap".GL_PIXEL_MAP_G_TO_G_SIZEparams returns one value, the size of the green-to-green pixel translation table.  See IDREF="34580" TYPE="TITLE""glPixelMap".GL_PIXEL_MAP_I_TO_A_SIZEparams returns one value, the size of the index-to-alpha pixel translation table.  See IDREF="34580" TYPE="TITLE""glPixelMap".GL_PIXEL_MAP_I_TO_B_SIZEparams returns one value, the size of the index-to-blue pixel translation table.  See IDREF="34580" TYPE="TITLE""glPixelMap".GL_PIXEL_MAP_I_TO_G_SIZEparams returns one value, the size of the index-to-green pixel translation table.  See IDREF="34580" TYPE="TITLE""glPixelMap".GL_PIXEL_MAP_I_TO_I_SIZEparams returns one value, the size of the index-to-index pixel translation table.  See IDREF="34580" TYPE="TITLE""glPixelMap".GL_PIXEL_MAP_I_TO_R_SIZEparams returns one value, the size of the index-to-red pixel translation table.  See IDREF="34580" TYPE="TITLE""glPixelMap"GL_PIXEL_MAP_R_TO_R_SIZEparams returns one value, the size of the red-to-red pixel translation table.  See IDREF="34580" TYPE="TITLE""glPixelMap".GL_PIXEL_MAP_S_TO_S_SIZEparams returns one value, the size of the stencil-to-stencil pixel translation table.  See IDREF="34580" TYPE="TITLE""glPixelMap".GL_POINT_SIZEparams returns one value, the point size as specified by glPointSize.  GL_POINT_SIZE_GRANULARITYparams returns one value, the size difference between adjacent supported sizes for antialiased points.  See IDREF="29287" TYPE="TITLE""glPointSize".GL_POINT_SIZE_RANGEparams returns two values: the smallest and largest supported sizes for antialiased points.  See IDREF="29287" TYPE="TITLE""glPointSize".GL_POINT_SMOOTHparams returns a single Boolean value indicating whether antialiasing of points is enabled.  See IDREF="29287" TYPE="TITLE""glPointSize".GL_POINT_SMOOTH_HINTparams returns one value, a symbolic constant indicating the mode of the point antialiasing hint.  See IDREF="37118" TYPE="TITLE""glHint".GL_POLYGON_MODEparams returns two values: symbolic constants indicating whether front-facing and back-facing polygons are rasterized as points, lines, or filled polygons.  See IDREF="14059" TYPE="TITLE""glPolygonMode".GL_POLYGON_SMOOTHparams returns a single Boolean value indicating whether antialiasing of polygons is enabled.  See IDREF="14059" TYPE="TITLE""glPolygonMode".GL_POLYGON_SMOOTH_HINTparams returns one value, a symbolic constant indicating the mode of the polygon antialiasing hint.  See IDREF="37118" TYPE="TITLE""glHint".GL_POLYGON_STIPPLEparams returns a single Boolean value indicating whether stippling of polygons is enabled.  See IDREF="13142" TYPE="TITLE""glPolygonStipple".GL_PROJECTION_MATRIXparams returns sixteen values: the projection matrix on the top of the projection matrix stack.  See IDREF="41698" TYPE="TITLE""glPushMatrix".GL_PROJECTION_STACK_DEPTHparams returns one value, the number of matrices on the projection matrix stack.  See IDREF="41698" TYPE="TITLE""glPushMatrix".GL_READ_BUFFERparams returns one value, a symbolic constant indicating which color buffer is selected for reading.  See IDREF="40261" TYPE="TITLE""glReadPixels" and IDREF="20121" TYPE="TITLE""glAccum".  GL_RED_BIASparams returns one value, the red bias factor used during pixel transfers.  GL_RED_BITSparams returns one value, the number of red bitplanes in each color buffer.  GL_RED_SCALEparams returns one value, the red scale factor used during pixel transfers.  See IDREF="38440" TYPE="TITLE""glPixelTransfer".GL_RENDER_MODEparams returns one value, a symbolic constant indicating whether the GL is in render, select, or feedback mode.  See IDREF="35248" TYPE="TITLE""glRenderMode".GL_RGBA_MODEparams returns a single Boolean value indicating whether the GL is in RGBA mode (true) or color index mode (false).  See IDREF="18325" TYPE="TITLE""glColor".GL_SCISSOR_BOXparams returns four values: the x and y window coordinates of the scissor box, follow by its width and height.  See IDREF="32335" TYPE="TITLE""glScissor".GL_SCISSOR_TESTparams returns a single Boolean value indicating whether scissoring is enabled.  See IDREF="32335" TYPE="TITLE""glScissor".GL_SHADE_MODELparams returns one value, a symbolic constant indicating whether the shading mode is flat or smooth.  See IDREF="11560" TYPE="TITLE""glShadeModel".GL_STENCIL_BITSparams returns one value, the number of bitplanes in the stencil buffer.  GL_STENCIL_CLEAR_VALUEparams returns one value, the index to which the stencil bitplanes are cleared.  See IDREF="40853" TYPE="TITLE""glClearStencil".GL_STENCIL_FAILparams returns one value, a symbolic constant indicating what action is taken when the stencil test fails.  See IDREF="36095" TYPE="TITLE""glStencilOp".GL_STENCIL_FUNCparams returns one value, a symbolic constant indicating what function is used to compare the stencil reference value with the stencil buffer value.  See IDREF="19234" TYPE="TITLE""glStencilFunc".GL_STENCIL_PASS_DEPTH_FAILparams returns one value, a symbolic constant indicating what action is taken when the stencil test passes, but the depth test fails.  See IDREF="36095" TYPE="TITLE""glStencilOp".GL_STENCIL_PASS_DEPTH_PASSparams returns one value, a symbolic constant indicating what action is taken when the stencil test passes and the depth test passes.  See IDREF="36095" TYPE="TITLE""glStencilOp".GL_STENCIL_REFparams returns one value, the reference value that is compared with the contents of the stencil buffer.  See IDREF="19234" TYPE="TITLE""glStencilFunc".GL_STENCIL_TESTparams returns a single Boolean value indicating whether stencil testing of fragments is enabled.  See IDREF="19234" TYPE="TITLE""glStencilFunc" and IDREF="36095" TYPE="TITLE""glStencilOp".GL_STENCIL_VALUE_MASKparams returns one value, the mask that is used to mask both the stencil reference value and the stencil buffer value before they are compared.  See IDREF="19234" TYPE="TITLE""glStencilFunc".GL_STENCIL_WRITEMASKparams returns one value, the mask that controls writing of the stencil bitplanes.  See IDREF="13439" TYPE="TITLE""glStencilMask".GL_STEREOparams returns a single Boolean value indicating whether stereo buffers (left and right) are supported.  GL_SUBPIXEL_BITSparams returns one value, an estimate of the number of bits of subpixel resolution that are used to position rasterized geometry in window coordinates.  GL_TEXTURE_1Dparams returns a single Boolean value indicating whether 1D texture mapping is enabled.  See IDREF="40965" TYPE="TITLE""glTexImage1D".GL_TEXTURE_2Dparams returns a single Boolean value indicating whether 2D texture mapping is enabled.  See IDREF="38642" TYPE="TITLE""glTexImage2D".GL_TEXTURE_ENV_COLORparams returns four values: the red, green, blue, and alpha values of the texture environment color.  Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value.  See IDREF="35740" TYPE="TITLE""glTexEnv".GL_TEXTURE_ENV_MODEparams returns one value, a symbolic constant indicating what texture environment function is currently selected.  See IDREF="35740" TYPE="TITLE""glTexEnv".  GL_TEXTURE_GEN_Sparams returns a single Boolean value indicating whether automatic generation of the S texture coordinate is enabled.  See IDREF="24845" TYPE="TITLE""glTexGen".  GL_TEXTURE_GEN_Tparams returns a single Boolean value indicating whether automatic generation of the T texture coordinate is enabled.  See IDREF="24845" TYPE="TITLE""glTexGen".GL_TEXTURE_GEN_Rparams returns a single Boolean value indicating whether automatic generation of the R texture coordinate is enabled.  See IDREF="24845" TYPE="TITLE""glTexGen".  GL_TEXTURE_GEN_Qparams returns a single Boolean value indicating whether automatic generation of the Q texture coordinate is enabled.  See IDREF="24845" TYPE="TITLE""glTexGen".  GL_TEXTURE_MATRIXparams returns sixteen values: the texture matrix on the top of the texture matrix stack.  See IDREF="41698" TYPE="TITLE""glPushMatrix".  GL_TEXTURE_STACK_DEPTHparams returns one value, the number of matrices on the texture matrix stack.  See IDREF="41698" TYPE="TITLE""glPushMatrix".  GL_UNPACK_ALIGNMENTparams returns one value, the byte alignment used for reading pixel data from memory.  See IDREF="39579" TYPE="TITLE""glPixelStore".  GL_UNPACK_LSB_FIRSTparams returns a single Boolean value indicating whether single-bit pixels being read from memory are read first from the least significant bit of each unsigned byte.  See IDREF="39579" TYPE="TITLE""glPixelStore".  GL_UNPACK_ROW_LENGTHparams returns one value, the row length used for reading pixel data from memory.  See IDREF="39579" TYPE="TITLE""glPixelStore".  GL_UNPACK_SKIP_PIXELSparams returns one value, the number of pixel locations skipped before the first pixel is read from memory.  See IDREF="39579" TYPE="TITLE""glPixelStore".  GL_UNPACK_SKIP_ROWSparams returns one value, the number of rows of pixel locations skipped before the first pixel is read from memory.  See IDREF="39579" TYPE="TITLE""glPixelStore".  GL_UNPACK_SWAP_BYTESparams returns a single Boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped after being read from memory.  See IDREF="39579" TYPE="TITLE""glPixelStore".  GL_VIEWPORTparams returns four values: the x and y window coordinates of the viewport, follow by its width and height.  See IDREF="17575" TYPE="TITLE""glViewport".  GL_ZOOM_Xparams returns one value, the x pixel zoom factor.  See IDREF="20047" TYPE="TITLE""glPixelZoom".  GL_ZOOM_Yparams returns one value, the y pixel zoom factor.  See IDREF="20047" TYPE="TITLE""glPixelZoom".  Many of the Boolean parameters can also be queried more easily using glIsEnabled.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if pname is not an accepted value.  GL_INVALID_OPERATION is generated if glGet is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""SEE ALSOIDREF="29256" TYPE="TITLE""glGetClipPlane", IDREF="19875" TYPE="TITLE""glGetError", IDREF="31252" TYPE="TITLE""glGetLight", IDREF="41449" TYPE="TITLE""glGetMap", IDREF="10464" TYPE="TITLE""glGetMaterial", IDREF="18120" TYPE="TITLE""glGetPixelMap", IDREF="35350" TYPE="TITLE""glGetPolygonStipple", IDREF="35022" TYPE="TITLE""glGetString", IDREF="37804" TYPE="TITLE""glGetTexEnv", IDREF="31539" TYPE="TITLE""glGetTexGen", IDREF="38063" TYPE="TITLE""glGetTexImage", IDREF="24244" TYPE="TITLE""glGetTexLevelParameter", IDREF="26919" TYPE="TITLE""glGetTexParameter", IDREF="31512" TYPE="TITLE""glIsEnabled"LBL="" HELPID=""ID="29256"glGetClipPlaneLBL="" HELPID=""NAMEglGetClipPlane - return the coefficients of the specified clipping plane  LBL="" HELPID=""C SPECIFICATIONvoid glGetClipPlane( GLenum plane, GLdouble *equation ) LBL="" HELPID=""PARAMETERSplaneSpecifies a clipping plane.  The number of clipping planes depends on the implementation, but at least six clipping planes are supported.  They are identified by symbolic names of the form GL_CLIP_PLANEi where 0 name='le' font=symbol charset=fontspecific code=163 
	TeX='\leq ' descr='[le]' i < GL_MAX_CLIP_PLANES.  equationReturns four double-precision values that are the coefficients of the plane equation of plane in eye coordinates.   LBL="" HELPID=""DESCRIPTIONglGetClipPlane returns in equation the four coefficients of the plane equation for plane.  LBL="" HELPID=""NOTESIt is always the case that GL_CLIP_PLANEi = GL_CLIP_PLANE0 + i.  If an error is generated, no change is made to the contents of equation.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if plane is not an accepted value.  GL_INVALID_OPERATION is generated if glGetClipPlane is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""SEE ALSOIDREF="15914" TYPE="TITLE""glClipPlane"LBL="" HELPID=""ID="19875"glGetErrorLBL="" HELPID=""NAMEglGetError - return error information  LBL="" HELPID=""C SPECIFICATIONGLenum glGetError( void ) LBL="" HELPID=""DESCRIPTIONglGetError returns the value of the error flag.  Each detectable error is assigned a numeric code and symbolic name.  When an error occurs, the error flag is set to the appropriate error code value.  No other errors are recorded until glGetError is called, the error code is returned, and the flag is reset to GL_NO_ERROR.  If a call to glGetError returns GL_NO_ERROR, there has been no detectable error since the last call to glGetError, or since the GL was initialized.  To allow for distributed implementations, there may be several error flags.  If any single error flag has recorded an error, the value of that flag is returned and that flag is reset to GL_NO_ERROR when glGetError is called.  If more than one flag has recorded an error, glGetError returns and clears an arbitrary error flag value.  Thus, glGetError should always be called in a loop, until it returns GL_NO_ERROR, if all error flags are to be reset.  Initially, all error flags are set to GL_NO_ERROR.  The currently defined errors are as follows: GL_NO_ERRORNo error has been recorded.  The value of this symbolic constant is guaranteed to be zero.  GL_INVALID_ENUMAn unacceptable value is specified for an enumerated argument.  The offending command is ignored, having no side effect other than to set the error flag.  GL_INVALID_VALUEA numeric argument is out of range.  The offending command is ignored, having no side effect other than to set the error flag.  GL_INVALID_OPERATIONThe specified operation is not allowed in the current state.  The offending command is ignored, having no side effect other than to set the error flag.  GL_STACK_OVERFLOWThis command would cause a stack overflow.  The offending command is ignored, having no side effect other than to set the error flag.  GL_STACK_UNDERFLOWThis command would cause a stack underflow.  The offending command is ignored, having no side effect other than to set the error flag.  GL_OUT_OF_MEMORYThere is not enough memory left to execute the command.  The state of the GL is undefined, except for the state of the error flags, after this error is recorded.  When an error flag is set, results of a GL operation are undefined only if GL_OUT_OF_MEMORY has occurred.  In all other cases, the command generating the error is ignored and has no effect on the GL state or frame buffer contents.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glGetError is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ID="31252"glGetLightLBL="" HELPID=""NAMEglGetLightfv, glGetLightiv - return light source parameter values  LBL="" HELPID=""C SPECIFICATIONvoid glGetLightfv( GLenum light, GLenum pname, GLfloat *params ) void glGetLightiv( GLenum light, GLenum pname, GLint *params ) LBL="" HELPID=""PARAMETERSlightSpecifies a light source.  The number of possible lights depends on the implementation, but at least eight lights are supported.  They are identified by symbolic names of the form GL_LIGHTi where 0 name='le' font=symbol charset=fontspecific code=163 
	TeX='\leq ' descr='[le]' i < GL_MAX_LIGHTS.  pnameSpecifies a light source parameter for light.  Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION , and GL_QUADRATIC_ATTENUATION.  paramsReturns the requested data.   LBL="" HELPID=""DESCRIPTIONglGetLight returns in params the value or values of a light source parameter.  light names the light and is a symbolic name of the form GL_LIGHTi for 0name='le' font=symbol charset=fontspecific code=163 
	TeX='\leq ' descr='[le]'i<GL_MAX_LIGHTS, where GL_MAX_LIGHTS is an implementation dependent constant that is greater than or equal to eight.  pname specifies one of ten light source parameters, again by symbolic name.  The parameters are as follows: GL_AMBIENTparams returns four integer or floating-point values representing the ambient intensity of the light source.  Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value.  If the internal value is outside the range [-1,1], the corresponding integer return value is undefined.  GL_DIFFUSEparams returns four integer or floating-point values representing the diffuse intensity of the light source.  Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value.  If the internal value is outside the range [-1,1], the corresponding integer return value is undefined.  GL_SPECULARparams returns four integer or floating-point values representing the specular intensity of the light source.  Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value.  If the internal value is outside the range [-1,1], the corresponding integer return value is undefined.  GL_POSITIONparams returns four integer or floating-point values representing the position of the light source.  Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer value.  The returned values are those maintained in eye coordinates.  They will not be equal to the values specified using glLight, unless the modelview matrix was identity at the time glLight was called.  GL_SPOT_DIRECTIONparams returns three integer or floating-point values representing the direction of the light source.  Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer value.  The returned values are those maintained in eye coordinates.  They will not be equal to the values specified using glLight, unless the modelview matrix was identity at the time glLight was called.  Although spot direction is normalized before being used in the lighting equation, the returned values are the transformed versions of the specified values prior to normalization.  GL_SPOT_EXPONENTparams returns a single integer or floating-point value representing the spot exponent of the light.  An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer.  GL_SPOT_CUTOFFparams returns a single integer or floating-point value representing the spot cutoff angle of the light.  An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer.  GL_CONSTANT_ATTENUATIONparams returns a single integer or floating-point value representing the constant (not distance related) attenuation of the light.  An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer.  GL_LINEAR_ATTENUATION params returns a single integer or floating-point value representing the linear attenuation of the light.  An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer.  GL_QUADRATIC_ATTENUATIONparams returns a single integer or floating-point value representing the quadratic attenuation of the light.  An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer.  LBL="" HELPID=""NOTESIt is always the case that GL_LIGHTi = GL_LIGHT0 + i.  If an error is generated, no change is made to the contents of params.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if light or pname is not an accepted value.  GL_INVALID_OPERATION is generated if glGetLight is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""SEE ALSOIDREF="37552" TYPE="TITLE""glLight"LBL="" HELPID=""ID="41449"glGetMapLBL="" HELPID=""NAMEglGetMapdv, glGetMapfv, glGetMapiv - return evaluator parameters  LBL="" HELPID=""C SPECIFICATIONvoid glGetMapdv( GLenum target, GLenum query, GLdouble *v ) void glGetMapfv( GLenum target, GLenum query, GLfloat *v ) void glGetMapiv( GLenum target, GLenum query, GLint *v ) LBL="" HELPID=""PARAMETERStargetSpecifies the symbolic name of a map.  Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4 , GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4.  querySpecifies which parameter to return.  Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted.  vReturns the requested data.   LBL="" HELPID=""DESCRIPTIONglMap1 and glMap2 define evaluators.  glGetMap returns evaluator parameters.  target chooses a map, query selects a specific parameter, and v points to storage where the values will be returned.  The acceptable values for the target parameter are described in the glMap1 and  glMap2 reference pages.  query can assume the following values: GL_COEFFv returns the control points for the evaluator function.  One-dimensional evaluators return order control points, and two-dimensional evaluators return uorder name='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]' vorder control points.  Each control point consists of one, two, three, or four integer, single-precision floating-point, or double-precision floating-point values, depending on the type of the evaluator.  Two-dimensional control points are returned in row-major order, incrementing the uorder index quickly, and the vorder index after each row.  Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.  GL_ORDERv returns the order of the evaluator function.  One-dimensional evaluators return a single value, order.  Two-dimensional evaluators return two values, uorder and vorder.  GL_DOMAINv returns the linear u and v mapping parameters.  One-dimensional evaluators return two values, u1 and u2, as specified by glMap1.  Two-dimensional evaluators return four values (u1, u2, v1, and v2) as specified by glMap2.  Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.  LBL="" HELPID=""NOTESIf an error is generated, no change is made to the contents of v.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if either target or query is not an accepted value.  GL_INVALID_OPERATION is generated if glGetMap is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""SEE ALSOIDREF="41102" TYPE="TITLE""glEvalCoord", IDREF="42533" TYPE="TITLE""glMap1", IDREF="26755" TYPE="TITLE""glMap2"LBL="" HELPID=""ID="10464"glGetMaterialLBL="" HELPID=""NAMEglGetMaterialfv, glGetMaterialiv - return material parameters  LBL="" HELPID=""C SPECIFICATIONvoid glGetMaterialfv( GLenum face, GLenum pname, GLfloat *params ) void glGetMaterialiv( GLenum face, GLenum pname, GLint *params ) LBL="" HELPID=""PARAMETERSfaceSpecifies which of the two materials is being queried.  GL_FRONT or GL_BACK are accepted, representing the front and back materials, respectively.  pnameSpecifies the material parameter to return.  GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION, GL_SHININESS, and GL_COLOR_INDEXES are accepted.  paramsReturns the requested data.  LBL="" HELPID=""DESCRIPTIONglGetMaterial returns in params the value or values of parameter pname of material face.  Six parameters are defined: GL_AMBIENTparams returns four integer or floating-point values representing the ambient reflectance of the material.  Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value.  If the internal value is outside the range [-1,1], the corresponding integer return value is undefined.  GL_DIFFUSEparams returns four integer or floating-point values representing the diffuse reflectance of the material.  Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value.  If the internal value is outside the range [-1,1], the corresponding integer return value is undefined.  GL_SPECULARparams returns four integer or floating-point values representing the specular reflectance of the material.  Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value.  If the internal value is outside the range [-1,1], the corresponding integer return value is undefined.  GL_EMISSIONparams returns four integer or floating-point values representing the emitted light intensity of the material.  Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and -1.0 maps to the most negative representable integer value.  If the internal value is outside the range [-1,1], the corresponding integer return value is undefined.  GL_SHININESSparams returns one integer or floating-point value representing the specular exponent of the material.  Integer values, when requested, are computed by rounding the internal floating-point value to the nearest integer value.  GL_COLOR_INDEXESparams returns three integer or floating-point values representing the ambient, diffuse, and specular indices of the material.  These indices are used only for color index lighting.  (The other parameters are all used only for RGBA lighting.) Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.  LBL="" HELPID=""NOTESIf an error is generated, no change is made to the contents of params.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if face or pname is not an accepted value.  GL_INVALID_OPERATION is generated if glGetMaterial is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""SEE ALSOIDREF="28170" TYPE="TITLE""glMaterial"LBL="" HELPID=""ID="18120"glGetPixelMapLBL="" HELPID=""NAMEglGetPixelMapfv, glGetPixelMapuiv, glGetPixelMapusv - return the specified pixel map  LBL="" HELPID=""C SPECIFICATIONvoid glGetPixelMapfv( GLenum map, GLfloat *values ) void glGetPixelMapuiv( GLenum map, GLuint *values ) void glGetPixelMapusv( GLenum map, GLushort *values ) LBL="" HELPID=""PARAMETERSmapSpecifies the name of the pixel map to return.  Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A.  valuesReturns the pixel map contents.   LBL="" HELPID=""DESCRIPTIONPlease see the IDREF="34580" TYPE="TITLE""glPixelMap" reference page for a description of the acceptable values for the map parameter.  glGetPixelMap returns in values the contents of the pixel map specified in map.  Pixel maps are used during the execution of glReadPixels, glDrawPixels, glCopyPixels, glTexImage1D, and glTexImage2D to map color indices, stencil indices, color components, and depth components to other values.  Unsigned integer values, if requested, are linearly mapped from the internal fixed or floating-point representation such that 1.0 maps to the largest representable integer value, and 0.0 maps to zero.  Return unsigned integer values are undefined if the map value was not in the range [0,1].  To determine the required size of map, call glGet with the appropriate symbolic constant.  LBL="" HELPID=""NOTESIf an error is generated, no change is made to the contents of values.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if map is not an accepted value.  GL_INVALID_OPERATION is generated if glGetPixelMap is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_PIXEL_MAP_I_TO_I_SIZEglGet with argument GL_PIXEL_MAP_S_TO_S_SIZEglGet with argument GL_PIXEL_MAP_I_TO_R_SIZEglGet with argument GL_PIXEL_MAP_I_TO_G_SIZEglGet with argument GL_PIXEL_MAP_I_TO_B_SIZEglGet with argument GL_PIXEL_MAP_I_TO_A_SIZEglGet with argument GL_PIXEL_MAP_R_TO_R_SIZEglGet with argument GL_PIXEL_MAP_G_TO_G_SIZEglGet with argument GL_PIXEL_MAP_B_TO_B_SIZEglGet with argument GL_PIXEL_MAP_A_TO_A_SIZEglGet with argument GL_MAX_PIXEL_MAP_TABLELBL="" HELPID=""SEE ALSOIDREF="25030" TYPE="TITLE""glCopyPixels", IDREF="41928" TYPE="TITLE""glDrawPixels", IDREF="34580" TYPE="TITLE""glPixelMap", IDREF="38440" TYPE="TITLE""glPixelTransfer", IDREF="40261" TYPE="TITLE""glReadPixels", IDREF="40965" TYPE="TITLE""glTexImage1D", IDREF="38642" TYPE="TITLE""glTexImage2D"LBL="" HELPID=""ID="35350"glGetPolygonStippleLBL="" HELPID=""NAMEglGetPolygonStipple - return the polygon stipple pattern  LBL="" HELPID=""C SPECIFICATIONvoid glGetPolygonStipple( GLubyte *mask ) LBL="" HELPID=""PARAMETERSmaskReturns the stipple pattern.  LBL="" HELPID=""DESCRIPTIONglGetPolygonStipple returns to mask a 32name='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]'32 polygon stipple pattern.  The pattern is packed into memory as if glReadPixels with both height and width of 32, type of GL_BITMAP, and format of GL_COLOR_INDEX were called, and the stipple pattern were stored in an internal 32name='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]'32 color index buffer.  Unlike glReadPixels, however, pixel transfer operations (shift, offset, pixel map) are not applied to the returned stipple image.  LBL="" HELPID=""NOTESIf an error is generated, no change is made to the contents of mask.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glGetPolygonStipple is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""SEE ALSOIDREF="39579" TYPE="TITLE""glPixelStore", IDREF="38440" TYPE="TITLE""glPixelTransfer", IDREF="13142" TYPE="TITLE""glPolygonStipple", IDREF="40261" TYPE="TITLE""glReadPixels"LBL="" HELPID=""ID="35022"glGetStringLBL="" HELPID=""NAMEglGetString - returns a string describing the current GL connection  LBL="" HELPID=""C SPECIFICATIONconst GLubyte * glGetString( GLenum name ) LBL="" HELPID=""PARAMETERSnameSpecifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_EXTENSIONS.  LBL="" HELPID=""DESCRIPTIONglGetString returns a pointer to a static string describing some aspect of the current GL connection.  name can be one of the following: GL_VENDORReturns the company responsible for this GL implementation.  This name does not change from release to release.  GL_RENDERERReturns the name of the renderer.  This name is typically specific to a particular configuration of a hardware platform.  It does not change from release to release.  GL_VERSIONReturns a version or release number.  GL_EXTENSIONSReturns a space-separated list of supported extensions to GL.  Because GL does not include queries for the performance characteristics of an implementation, it is expected that some applications will be written to recognize known platforms and will modify their GL usage based on known performance characteristics of these platforms.  Strings GL_VENDOR and GL_RENDERER together uniquely specify a platform, and will not change from release to release.  They should be used by such platform recognition algorithms.  The format and contents of the string that glGetString returns depend on the implementation, except that extension names will not include space characters and will be separated by space characters in the GL_EXTENSIONS string, and that all strings are null-terminated.  LBL="" HELPID=""NOTESIf an error is generated, glGetString returns zero.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if name is not an accepted value.  GL_INVALID_OPERATION is generated if glGetString is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ID="37804"glGetTexEnvLBL="" HELPID=""NAMEglGetTexEnvfv, glGetTexEnviv - return texture environment parameters  LBL="" HELPID=""C SPECIFICATIONvoid glGetTexEnvfv( GLenum target, GLenum pname, GLfloat *params ) void glGetTexEnviv( GLenum target, GLenum pname, GLint *params ) LBL="" HELPID=""PARAMETERStargetSpecifies a texture environment.  Must be GL_TEXTURE_ENV.  pnameSpecifies the symbolic name of a texture environment parameter.  Accepted values are GL_TEXTURE_ENV_MODE and GL_TEXTURE_ENV_COLOR.  paramsReturns the requested data.   LBL="" HELPID=""DESCRIPTIONglGetTexEnv returns in params selected values of a texture environment that was specified with glTexEnv.  target specifies a texture environment.  Currently, only one texture environment is defined and supported: GL_TEXTURE_ENV.  pname names a specific texture environment parameter.  The two parameters are as follows: GL_TEXTURE_ENV_MODEparams returns the single-valued texture environment mode, a symbolic constant.  GL_TEXTURE_ENV_COLORparams returns four integer or floating-point values that are the texture environment color.  Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer, and -1.0 maps to the most negative representable integer.  LBL="" HELPID=""NOTESIf an error is generated, no change is made to the contents of params.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if target or pname is not an accepted value.  GL_INVALID_OPERATION is generated if glGetTexEnv is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""SEE ALSOIDREF="35740" TYPE="TITLE""glTexEnv"LBL="" HELPID=""ID="31539"glGetTexGenLBL="" HELPID=""NAMEglGetTexGendv, glGetTexGenfv, glGetTexGeniv - return texture coordinate generation parameters  LBL="" HELPID=""C SPECIFICATIONvoid glGetTexGendv( GLenum coord, GLenum pname, GLdouble *params ) void glGetTexGenfv( GLenum coord, GLenum pname, GLfloat *params ) void glGetTexGeniv( GLenum coord, GLenum pname, GLint *params ) LBL="" HELPID=""PARAMETERScoordSpecifies a texture coordinate.  Must be GL_S, GL_T, GL_R, or GL_Q.  pnameSpecifies the symbolic name of the value(s) to be returned.  Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.  paramsReturns the requested data.   LBL="" HELPID=""DESCRIPTIONglGetTexGen returns in params selected parameters of a texture coordinate generation function that was specified using glTexGen.  coord names one of the (s ,t ,r ,q) texture coordinates, using the symbolic constant GL_S, GL_T, GL_R, or GL_Q.  pname specifies one of three symbolic names: GL_TEXTURE_GEN_MODEparams returns the single-valued texture generation function, a symbolic constant.  GL_OBJECT_PLANEparams returns the four plane equation coefficients that specify object linear-coordinate generation.  Integer values, when requested, are mapped directly from the internal floating-point representation.  GL_EYE_PLANEparams returns the four plane equation coefficients that specify eye linear-coordinate generation.  Integer values, when requested, are mapped directly from the internal floating-point representation.  The returned values are those maintained in eye coordinates.  They are not equal to the values specified using glTexGen, unless the modelview matrix was identity at the time glTexGen was called.  LBL="" HELPID=""NOTESIf an error is generated, no change is made to the contents of params.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if coord or pname is not an accepted value.  GL_INVALID_OPERATION is generated if glGetTexGen is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""SEE ALSOIDREF="24845" TYPE="TITLE""glTexGen"LBL="" HELPID=""ID="38063"glGetTexImageLBL="" HELPID=""NAMEglGetTexImage - return a texture image  LBL="" HELPID=""C SPECIFICATIONvoid glGetTexImage( GLenum target, GLint level, GLenum format,         GLenum type, GLvoid *pixels ) LBL="" HELPID=""PARAMETERStargetSpecifies which texture is to be obtained.  GL_TEXTURE_1D and GL_TEXTURE_2D are accepted.  levelSpecifies the level-of-detail number of the desired image.  Level 0 is the base image level.  Level n is the nth mipmap reduction image.  formatSpecifies a pixel format for the returned data.  The supported formats are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_RGBA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.  typeSpecifies a pixel type for the returned data.  The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, and GL_FLOAT.  pixelsReturns the texture image.  Should be a pointer to an array of the type specified by type.   LBL="" HELPID=""DESCRIPTIONglGetTexImage returns a texture image into pixels.  target specifies whether the desired texture image is one specified by glTexImage1D (GL_TEXTURE_1D) or by glTexImage2D (GL_TEXTURE_2D).  level specifies the level-of-detail number of the desired image.  format and type specify the format and type of the desired image array.  Please see the reference pages IDREF="40965" TYPE="TITLE""glTexImage1D" and IDREF="41928" TYPE="TITLE""glDrawPixels" for a description of the acceptable values for the format and type parameters, respectively.  Operation of glGetTexImage is best understood by considering the selected internal four-component texture image to be an RGBA color buffer the size of the image.  The semantics of glGetTexImage are then identical to those of glReadPixels called with the same format and type, with x and y set to zero, width set to the width of the texture image (including border if one was specified), and height set to one for 1-D images, or to the height of the texture image (including border if one was specified) for 2-D images.  Because the internal texture image is an RGBA image, pixel formats GL_COLOR_INDEX, GL_STENCIL_INDEX, and GL_DEPTH_COMPONENT are not accepted, and pixel type GL_BITMAP is not accepted.  If the selected texture image does not contain four components, the following mappings are applied.  Single-component textures are treated as RGBA buffers with red set to the single-component value, and green, blue, and alpha set to zero.  Two-component textures are treated as RGBA buffers with red set to the value of component zero, alpha set to the value of component one, and green and blue set to zero.  Finally, three-component textures are treated as RGBA buffers with red set to component zero, green set to component one, blue set to component two, and alpha set to zero.  To determine the required size of pixels, use glGetTexLevelParameter to ascertain the dimensions of the internal texture image, then scale the required number of pixels by the storage required for each pixel, based on format and type.  Be sure to take the pixel storage parameters into account, especially GL_PACK_ALIGNMENT.  LBL="" HELPID=""NOTESIf an error is generated, no change is made to the contents of pixels.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if target, format, or type is not an accepted value.  GL_INVALID_VALUE is generated if level is less than zero or greater than log2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE.  GL_INVALID_OPERATION is generated if glGetTexImage is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGetTexLevelParameter with argument GL_TEXTURE_WIDTHglGetTexLevelParameter with argument GL_TEXTURE_HEIGHTglGetTexLevelParameter with argument GL_TEXTURE_BORDERglGetTexLevelParameter with argument GL_TEXTURE_COMPONENTSglGet with arguments GL_PACK_ALIGNMENT and others LBL="" HELPID=""SEE ALSOIDREF="41928" TYPE="TITLE""glDrawPixels", IDREF="40261" TYPE="TITLE""glReadPixels", IDREF="40965" TYPE="TITLE""glTexImage1D", IDREF="38642" TYPE="TITLE""glTexImage2D"LBL="" HELPID=""ID="24244"glGetTexLevelParameterLBL="" HELPID=""NAMEglGetTexLevelParameterfv, glGetTexLevelParameteriv - return texture parameter values for a specific level of detail  LBL="" HELPID=""C SPECIFICATIONvoid glGetTexLevelParameterfv( GLenum target, GLint level, GLenum pname, GLfloat *params ) void glGetTexLevelParameteriv( GLenum target, GLint level, GLenum pname, GLint *params ) LBL="" HELPID=""PARAMETERStargetSpecifies the symbolic name of the target texture, either GL_TEXTURE_1D or GL_TEXTURE_2D.  levelSpecifies the level-of-detail number of the desired image.  Level 0 is the base image level.  Level n is the nth mipmap reduction image.  pnameSpecifies the symbolic name of a texture parameter.  GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_COMPONENTS, and GL_TEXTURE_BORDER are accepted.  paramsReturns the requested data.   LBL="" HELPID=""DESCRIPTIONglGetTexLevelParameter returns in params texture parameter values for a specific level-of-detail value, specified as level.  target defines the target texture, either GL_TEXTURE_1D or GL_TEXTURE_2D, to specify one- or two-dimensional texturing.  pname specifies the texture parameter whose value or values will be returned.  The accepted parameter names are as follows: GL_TEXTURE_WIDTHparams returns a single value, the width of the texture image.  This value includes the border of the texture image.  GL_TEXTURE_HEIGHTparams returns a single value, the height of the texture image.  This value includes the border of the texture image.  GL_TEXTURE_COMPONENTSparams returns a single value, the number of components in the texture image.  GL_TEXTURE_BORDERparams returns a single value, the width in pixels of the border of the texture image.  LBL="" HELPID=""NOTESIf an error is generated, no change is made to the contents of params.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if target or pname is not an accepted value.  GL_INVALID_VALUE is generated if level is less than zero or greater than log2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE.  GL_INVALID_OPERATION is generated if glGetTexLevelParameter is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""SEE ALSOIDREF="26919" TYPE="TITLE""glGetTexParameter", IDREF="40965" TYPE="TITLE""glTexImage1D", IDREF="38642" TYPE="TITLE""glTexImage2D", IDREF="19578" TYPE="TITLE""glTexParameter"LBL="" HELPID=""ID="26919"glGetTexParameterLBL="" HELPID=""NAMEglGetTexParameterfv, glGetTexParameteriv - return texture parameter values  LBL="" HELPID=""C SPECIFICATIONvoid glGetTexParameterfv( GLenum target, GLenum pname, GLfloat *params )void glGetTexParameteriv( GLenum target, GLenum pname, GLint *params ) LBL="" HELPID=""PARAMETERStargetSpecifies the symbolic name of the target texture.  GL_TEXTURE_1D and GL_TEXTURE_2D are accepted.  pnameSpecifies the symbolic name of a texture parameter.  GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_BORDER_COLOR are accepted.  paramsReturns the texture parameters.   LBL="" HELPID=""DESCRIPTIONglGetTexParameter returns in params the value or values of the texture parameter specified as pname.  target defines the target texture, either GL_TEXTURE_1D or GL_TEXTURE_2D, to specify one- or two-dimensional texturing.  pname accepts the same symbols as glTexParameter, with the same interpretations: GL_TEXTURE_MAG_FILTERReturns the single-valued texture magnification filter, a symbolic constant.  GL_TEXTURE_MIN_FILTERReturns the single-valued texture minification filter, a symbolic constant.  GL_TEXTURE_WRAP_SReturns the single-valued wrapping function for texture coordinate s, a symbolic constant.  GL_TEXTURE_WRAP_TReturns the single-valued wrapping function for texture coordinate t, a symbolic constant.  GL_TEXTURE_BORDER_COLORReturns four integer or floating-point numbers that comprise the RGBA color of the texture border.  Floating-point values are returned in the range [0,1].  Integer values are returned as a linear mapping of the internal floating-point representation such that 1.0 maps to the most positive representable integer and -1.0 maps to the most negative representable integer.  LBL="" HELPID=""NOTESIf an error is generated, no change is made to the contents of params.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if target or pname is not an accepted value.  GL_INVALID_OPERATION is generated if glGetTexParameter is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""SEE ALSOIDREF="19578" TYPE="TITLE""glTexParameter"LBL="" HELPID=""ID="37118"glHintLBL="" HELPID=""NAMEglHint - specify implementation-specific hints  LBL="" HELPID=""C SPECIFICATIONvoid glHint( GLenum target, GLenum mode ) LBL="" HELPID=""PARAMETERStargetSpecifies a symbolic constant indicating the behavior to be controlled.  GL_FOG_HINT,      GL_LINE_SMOOTH_HINT, GL_PERSPECTIVE_CORRECTION_HINT, GL_POINT_SMOOTH_HINT, and GL_POLYGON_SMOOTH_HINT are accepted.  modeSpecifies a symbolic constant indicating the desired behavior.  GL_FASTEST, GL_NICEST, and GL_DONT_CARE are accepted.  LBL="" HELPID=""DESCRIPTIONCertain aspects of GL behavior, when there is room for interpretation, can be controlled with hints.  A hint is specified with two arguments.  target is a symbolic constant indicating the behavior to be controlled, and mode is another symbolic constant indicating the desired behavior.  mode can be one of the following: GL_FASTESTThe most efficient option should be chosen.  GL_NICESTThe most correct, or highest quality, option should be chosen.  GL_DONT_CAREThe client doesn't have a preference.  Though the implementation aspects that can be hinted are well defined, the interpretation of the hints depends on the implementation.  The hint aspects that can be specified with target, along with suggested semantics, are as follows: GL_FOG_HINTIndicates the accuracy of fog calculation.  If per-pixel fog calculation is not efficiently supported by the GL implementation, hinting GL_DONT_CARE or GL_FASTEST can result in per-vertex calculation of fog effects.  GL_LINE_SMOOTH_HINTIndicates the sampling quality of antialiased lines.  Hinting GL_NICEST can result in more pixel fragments being generated during rasterization, if a larger filter function is applied.  GL_PERSPECTIVE_CORRECTION_HINTIndicates the quality of color and texture coordinate interpolation.  If perspective-corrected parameter interpolation is not efficiently supported by the GL implementation, hinting GL_DONT_CARE or GL_FASTEST can result in simple linear interpolation of colors and/or texture coordinates.  GL_POINT_SMOOTH_HINTIndicates the sampling quality of antialiased points.  Hinting GL_NICEST can result in more pixel fragments being generated during rasterization, if a larger filter function is applied.  GL_POLYGON_SMOOTH_HINTIndicates the sampling quality of antialiased polygons.  Hinting GL_NICEST can result in more pixel fragments being generated during rasterization, if a larger filter function is applied.  LBL="" HELPID=""NOTESThe interpretation of hints depends on the implementation.  glHint can be ignored.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if either target or mode is not an accepted value.  GL_INVALID_OPERATION is generated if glHint is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ID="14741"glIndexLBL="" HELPID=""NAMEglIndexd, glIndexf, glIndexi, glIndexs, glIndexdv, glIndexfv, glIndexiv, glIndexsv - set the current color index   LBL="" HELPID=""C SPECIFICATIONvoid glIndexd( GLdouble c ) void glIndexf( GLfloat c ) void glIndexi( GLint c ) void glIndexs( GLshort c ) LBL="" HELPID=""PARAMETERScSpecifies the new value for the current color index.   LBL="" HELPID=""C SPECIFICATIONvoid glIndexdv( const GLdouble *c ) void glIndexfv( const GLfloat *c ) void glIndexiv( const GLint *c ) void glIndexsv( const GLshort *c ) LBL="" HELPID=""PARAMETERScSpecifies a pointer to a one-element array that contains the new value for the current color index.   LBL="" HELPID=""DESCRIPTIONglIndex updates the current (single-valued) color index.  It takes one argument: the new value for the current color index.  The current index is stored as a floating-point value.  Integer values are converted directly to floating-point values, with no special mapping.  Index values outside the representable range of the color index buffer are not clamped.  However, before an index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format.  Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame buffer are masked out.  LBL="" HELPID=""NOTESThe current index can be updated at any time.  In particular, glIndex can be called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_CURRENT_INDEXLBL="" HELPID=""SEE ALSOIDREF="18325" TYPE="TITLE""glColor"LBL="" HELPID=""ID="31111"glIndexMaskLBL="" HELPID=""NAMEglIndexMask - control the writing of individual bits in the color index buffers  LBL="" HELPID=""C SPECIFICATIONvoid glIndexMask( GLuint mask ) LBL="" HELPID=""PARAMETERSmaskSpecifies a bit mask to enable and disable the writing of individual bits in the color index buffers.  Initially, the mask is all ones.   LBL="" HELPID=""DESCRIPTIONglIndexMask controls the writing of individual bits in the color index buffers.  The least significant n bits of mask, where n is the number of bits in a color index buffer, specify a mask.  Wherever a one appears in the mask, the corresponding bit in the color index buffer (or buffers) is made writable.  Where a zero appears, the bit is write-protected.  This mask is used only in color index mode, and it affects only the buffers currently selected for writing (see IDREF="18132" TYPE="TITLE""glDrawBuffer".) Initially, all bits are enabled for writing.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glIndexMask is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_INDEX_WRITEMASKLBL="" HELPID=""SEE ALSOIDREF="42526" TYPE="TITLE""glColorMask", IDREF="31383" TYPE="TITLE""glDepthMask", IDREF="18132" TYPE="TITLE""glDrawBuffer", IDREF="14741" TYPE="TITLE""glIndex", IDREF="13439" TYPE="TITLE""glStencilMask"LBL="" HELPID=""ID="40021"glInitNamesLBL="" HELPID=""NAMEglInitNames - initialize the name stack  LBL="" HELPID=""C SPECIFICATIONvoid glInitNames( void ) LBL="" HELPID=""DESCRIPTIONThe name stack is used during selection mode to allow sets of rendering commands to be uniquely identified.  It consists of an ordered set of unsigned integers.  glInitNames causes the name stack to be initialized to its default empty state.  The name stack is always empty while the render mode is not GL_SELECT.  Calls to glInitNames while the render mode is not GL_SELECT are ignored.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glInitNames is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_NAME_STACK_DEPTHglGet with argument GL_MAX_NAME_STACK_DEPTHLBL="" HELPID=""SEE ALSOIDREF="42477" TYPE="TITLE""glLoadName", IDREF="32163" TYPE="TITLE""glPushName", IDREF="35248" TYPE="TITLE""glRenderMode", IDREF="35181" TYPE="TITLE""glSelectBuffer"LBL="" HELPID=""ID="31512"glIsEnabledLBL="" HELPID=""NAMEglIsEnabled - test whether a capability is enabled  LBL="" HELPID=""C SPECIFICATIONGLboolean glIsEnabled( GLenum cap ) LBL="" HELPID=""PARAMETERScapSpecifies a symbolic constant indicating a GL capability.  LBL="" HELPID=""DESCRIPTIONglIsEnabled returns GL_TRUE if cap is an enabled capability and returns GL_FALSE otherwise.  The following capabilities are accepted for cap:  GL_ALPHA_TESTSee IDREF="19142" TYPE="TITLE""glAlphaFunc".GL_AUTO_NORMALSee IDREF="41102" TYPE="TITLE""glEvalCoord".GL_BLENDSee IDREF="11446" TYPE="TITLE""glBlendFunc".GL_CLIP_PLANEiSee IDREF="15914" TYPE="TITLE""glClipPlane".GL_COLOR_MATERIAL See IDREF="37922" TYPE="TITLE""glColorMaterial".GL_CULL_FACESee IDREF="41183" TYPE="TITLE""glCullFace".GL_DEPTH_TEST See IDREF="10076" TYPE="TITLE""glDepthFunc" and IDREF="22828" TYPE="TITLE""glDepthRange".GL_DITHER See IDREF="40792" TYPE="TITLE""glEnable".GL_FOGSee IDREF="21607" TYPE="TITLE""glFog".GL_LIGHTi See IDREF="19151" TYPE="TITLE""glLightModel" and IDREF="37552" TYPE="TITLE""glLight".GL_LIGHTINGSee IDREF="28170" TYPE="TITLE""glMaterial", IDREF="19151" TYPE="TITLE""glLightModel", and IDREF="37552" TYPE="TITLE""glLight".GL_LINE_SMOOTHSee IDREF="23427" TYPE="TITLE""glLineWidth".GL_LINE_STIPPLESee IDREF="37959" TYPE="TITLE""glLineStipple".GL_LOGIC_OPSee IDREF="18729" TYPE="TITLE""glLogicOp".GL_MAP1_COLOR_4See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_INDEXSee IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_NORMALSee IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_TEXTURE_COORD_1See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_TEXTURE_COORD_2See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_TEXTURE_COORD_3See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_TEXTURE_COORD_4See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_VERTEX_3See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP1_VERTEX_4See IDREF="42533" TYPE="TITLE""glMap1".GL_MAP2_COLOR_4See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_INDEXSee IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_NORMALSee IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_TEXTURE_COORD_1See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_TEXTURE_COORD_2See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_TEXTURE_COORD_3See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_TEXTURE_COORD_4See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_VERTEX_3See IDREF="26755" TYPE="TITLE""glMap2".GL_MAP2_VERTEX_4See IDREF="26755" TYPE="TITLE""glMap2".GL_NORMALIZESee IDREF="12825" TYPE="TITLE""glNormal".GL_POINT_SMOOTHSee IDREF="29287" TYPE="TITLE""glPointSize".GL_POLYGON_SMOOTHSee IDREF="14059" TYPE="TITLE""glPolygonMode".GL_POLYGON_STIPPLESee IDREF="13142" TYPE="TITLE""glPolygonStipple".GL_SCISSOR_TESTSee IDREF="32335" TYPE="TITLE""glScissor".GL_STENCIL_TESTSee IDREF="19234" TYPE="TITLE""glStencilFunc" and IDREF="36095" TYPE="TITLE""glStencilOp".GL_TEXTURE_1DSee IDREF="40965" TYPE="TITLE""glTexImage1D".GL_TEXTURE_2DSee IDREF="38642" TYPE="TITLE""glTexImage2D".GL_TEXTURE_GEN_QSee IDREF="24845" TYPE="TITLE""glTexGen".GL_TEXTURE_GEN_RSee IDREF="24845" TYPE="TITLE""glTexGen".GL_TEXTURE_GEN_SSee IDREF="24845" TYPE="TITLE""glTexGen".GL_TEXTURE_GEN_TSee IDREF="24845" TYPE="TITLE""glTexGen".LBL="" HELPID=""NOTESIf an error is generated, glIsEnabled returns zero.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if cap is not an accepted value.  GL_INVALID_OPERATION is generated if glIsEnabled is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""SEE ALSOIDREF="40792" TYPE="TITLE""glEnable"LBL="" HELPID=""ID="41026"glIsListLBL="" HELPID=""NAMEglIsList - test for display-list existence  LBL="" HELPID=""C SPECIFICATIONGLboolean glIsList( GLuint list ) LBL="" HELPID=""PARAMETERSlistSpecifies a potential display-list name.   LBL="" HELPID=""DESCRIPTIONglIsList returns GL_TRUE if list is the name of a display list and returns GL_FALSE otherwise.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glIsList is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""SEE ALSOIDREF="37134" TYPE="TITLE""glCallList", IDREF="15751" TYPE="TITLE""glCallLists", IDREF="13566" TYPE="TITLE""glDeleteLists", IDREF="12827" TYPE="TITLE""glGenLists", IDREF="28073" TYPE="TITLE""glNewList"LBL="" HELPID=""ID="37552"glLightLBL="" HELPID=""NAMEglLightf, glLighti, glLightfv, glLightiv - set light source parameters  LBL="" HELPID=""C SPECIFICATIONvoid glLightf( GLenum light, GLenum pname, GLfloat param ) void glLighti( GLenum light, GLenum pname, GLint param ) LBL="" HELPID=""PARAMETERSlightSpecifies a light.  The number of lights is depends on the implementation, but at least eight lights are supported.  They are identified by symbolic names of the form GL_LIGHTi where 0 name='le' font=symbol charset=fontspecific code=163 
	TeX='\leq ' descr='[le]' i < GL_MAX_LIGHTS.  pnameSpecifies a single-valued light source parameter for light.  GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION , and GL_QUADRATIC_ATTENUATION are accepted.  paramSpecifies the value that parameter pname of light source light will be set to.  LBL="" HELPID=""C SPECIFICATIONvoid glLightfv( GLenum light, GLenum pname, const GLfloat *params ) void glLightiv( GLenum light, GLenum pname, const GLint *params ) LBL="" HELPID=""PARAMETERSlightSpecifies a light.  The number of lights depends on the implementation, but at least eight lights are supported.  They are identified by symbolic names of the form GL_LIGHTi where 0 name='le' font=symbol charset=fontspecific code=163 
	TeX='\leq ' descr='[le]' i < GL_MAX_LIGHTS.  pnameSpecifies a light source parameter for light.  GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.  paramsSpecifies a pointer to the value or values that parameter pname of light source light will be set to.   LBL="" HELPID=""DESCRIPTIONglLight sets the values of individual light source parameters.  light names the light and is a symbolic name of the form GL_LIGHTi, where 0 name='le' font=symbol charset=fontspecific code=163 
	TeX='\leq ' descr='[le]' i < GL_MAX_LIGHTS.  pname specifies one of ten light source parameters, again by symbolic name.  params is either a single value or a pointer to an array that contains the new values.  Lighting calculation is enabled and disabled using glEnable and glDisable with argument GL_LIGHTING.  When lighting is enabled, light sources that are enabled contribute to the lighting calculation.  Light source i is enabled and disabled using glEnable and glDisable with argument GL_LIGHTi.  The ten light parameters are as follows: GL_AMBIENT params contains four integer or floating-point values that specify the ambient RGBA intensity of the light.  Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0.  Floating-point values are mapped directly.  Neither integer nor floating-point values are clamped.  The default ambient light intensity is (0.0, 0.0, 0.0, 1.0).  GL_DIFFUSE params contains four integer or floating-point values that specify the diffuse RGBA intensity of the light.  Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0.  Floating-point values are mapped directly.  Neither integer nor floating-point values are clamped.  The default diffuse intensity is (0.0, 0.0, 0.0, 1.0) for all lights other than light zero.  The default diffuse intensity of light zero is (1.0, 1.0, 1.0, 1.0).  GL_SPECULAR params contains four integer or floating-point values that specify the specular RGBA intensity of the light.  Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0.  Floating-point values are mapped directly.  Neither integer nor floating-point values are clamped.  The default specular intensity is (0.0, 0.0, 0.0, 1.0) for all lights other than light zero.  The default specular intensity of light zero is (1.0, 1.0, 1.0, 1.0).  GL_POSITION params contains four integer or floating-point values that specify the position of the light in homogeneous object coordinates.  Both integer and floating-point values are mapped directly.  Neither integer nor floating-point values are clamped.  The position is transformed by the modelview matrix when glLight is called (just as if it were a point), and it is stored in eye coordinates.  If the w component of the position is 0.0, the light is treated as a directional source.  Diffuse and specular lighting calculations take the light's direction, but not its actual position, into account, and attenuation is disabled.  Otherwise, diffuse and specular lighting calculations are based on the actual location of the light in eye coordinates, and attenuation is enabled.  The default position is (0,0,1,0); thus, the default light source is directional, parallel to, and in the direction of the -z axis.  GL_SPOT_DIRECTIONparams contains three integer or floating-point values that specify the direction of the light in homogeneous object coordinates.  Both integer and floating-point values are mapped directly.  Neither integer nor floating-point values are clamped.  The spot direction is transformed by the inverse of the modelview matrix when glLight is called (just as it it were a normal), and it is stored in eye coordinates.  It is significant only when GL_SPOT_CUTOFF is not 180, which it is by default.  The default direction is (0,0,-1).  GL_SPOT_EXPONENTparams is a single integer or floating-point value that specifies the intensity distribution of the light.  Integer and floating-point values are mapped directly.  Only values in the range [0,128] are accepted.  Effective light intensity is attenuated by the cosine of the angle between the direction of the light and the direction from the light to the vertex being lighted, raised to the power of the spot exponent.  Thus, higher spot exponents result in a more focused light source, regardless of the spot cutoff angle (see next paragraph).  The default spot exponent is 0, resulting in uniform light distribution.  GL_SPOT_CUTOFFparams is a single integer or floating-point value that specifies the maximum spread angle of a light source.  Integer and floating-point values are mapped directly.  Only values in the range [0,90], and the special value 180, are accepted.  If the angle between the direction of the light and the direction from the light to the vertex being lighted is greater than the spot cutoff angle, the light is completely masked.  Otherwise, its intensity is controlled by the spot exponent and the attenuation factors.  The default spot cutoff is 180, resulting in uniform light distribution.  GL_CONSTANT_ATTENUATIONGL_LINEAR_ATTENUATION GL_QUADRATIC_ATTENUATIONparams is a single integer or floating-point value that specifies one of the three light attenuation factors.  Integer and floating-point values are mapped directly.  Only nonnegative values are accepted.  If the light is positional, rather than directional, its intensity is attenuated by the reciprocal of the sum of: the constant factor, the linear factor times the distance between the light and the vertex being lighted, and the quadratic factor times the square of the same distance.  The default attenuation factors are (1,0,0), resulting in no attenuation.   LBL="" HELPID=""NOTESIt is always the case that GL_LIGHTi = GL_LIGHT0 + i.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if either light or pname is not an accepted value.  GL_INVALID_VALUE is generated if a spot exponent value is specified outside the range [0,128], or if spot cutoff is specified outside the range [0,90] (except for the special value 180), or if a negative attenuation factor is specified.  GL_INVALID_OPERATION is generated if glLight is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGetLightglIsEnabled with argument GL_LIGHTINGLBL="" HELPID=""SEE ALSOIDREF="37922" TYPE="TITLE""glColorMaterial", IDREF="19151" TYPE="TITLE""glLightModel", IDREF="28170" TYPE="TITLE""glMaterial"LBL="" HELPID=""ID="19151"glLightModelLBL="" HELPID=""NAMEglLightModelf, glLightModeli, glLightModelfv, glLightModeliv - set the lighting model parameters  LBL="" HELPID=""C SPECIFICATIONvoid glLightModelf( GLenum pname, GLfloat param ) void glLightModeli( GLenum pname, GLint param ) LBL="" HELPID=""PARAMETERSpnameSpecifies a single-valued lighting model parameter.  GL_LIGHT_MODEL_LOCAL_VIEWER and GL_LIGHT_MODEL_TWO_SIDE are accepted.  paramSpecifies the value that param will be set to.  LBL="" HELPID=""C SPECIFICATIONvoid glLightModelfv( GLenum pname, const GLfloat *params ) void glLightModeliv( GLenum pname, const GLint *params ) LBL="" HELPID=""PARAMETERSpnameSpecifies a lighting model parameter.  GL_LIGHT_MODEL_AMBIENT, GL_LIGHT_MODEL_LOCAL_VIEWER, and GL_LIGHT_MODEL_TWO_SIDE are accepted.  paramsSpecifies a pointer to the value or values that params will be set to.   LBL="" HELPID=""DESCRIPTIONglLightModel sets the lighting model parameter.  pname names a parameter and params gives the new value.  There are three lighting model parameters: GL_LIGHT_MODEL_AMBIENT params contains four integer or floating-point values that specify the ambient RGBA intensity of the entire scene.  Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0.  Floating-point values are mapped directly.  Neither integer nor floating-point values are clamped.  The default ambient scene intensity is (0.2, 0.2, 0.2, 1.0).  GL_LIGHT_MODEL_LOCAL_VIEWER params is a single integer or floating-point value that specifies how specular reflection angles are computed.  If params is 0 (or 0.0), specular reflection angles take the view direction to be parallel to and in the direction of the -z axis, regardless of the location of the vertex in eye coordinates.  Otherwise specular reflections are computed from the origin of the eye coordinate system.  The default is 0.  GL_LIGHT_MODEL_TWO_SIDE params is a single integer or floating-point value that specifies whether one- or two-sided lighting calculations are done for polygons.  It has no effect on the lighting calculations for points, lines, or bitmaps.  If params is 0 (or 0.0), one-sided lighting is specified, and only the front material parameters are used in the lighting equation.  Otherwise, two-sided lighting is specified.  In this case, vertices of back-facing polygons are lighted using the back material parameters, and have their normals reversed before the lighting equation is evaluated.  Vertices of front-facing polygons are always lighted using the front material parameters, with no change to their normals.  The default is 0.  In RGBA mode, the lighted color of a vertex is the sum of the material emission intensity, the product of the material ambient reflectance and the lighting model full-scene ambient intensity, and the contribution of each enabled light source.  Each light source contributes the sum of three terms: ambient, diffuse, and specular.  The ambient light source contribution is the product of the material ambient reflectance and the light's ambient intensity.  The diffuse light source contribution is the product of the material diffuse reflectance, the light's diffuse intensity, and the dot product of the vertex's normal with the normalized vector from the vertex to the light source.  The specular light source contribution is the product of the material specular reflectance, the light's specular intensity, and the dot product of the normalized vertex-to-eye and vertex-to-light vectors, raised to the power of the shininess of the material.  All three light source contributions are attenuated equally based on the distance from the vertex to the light source and on light source direction, spread exponent, and spread cutoff angle.  All dot products are replaced with zero if they evaluate to a negative value.  The alpha component of the resulting lighted color is set to the alpha value of the material diffuse reflectance.  In color index mode, the value of the lighted index of a vertex ranges from the ambient to the specular values passed to glMaterial using GL_COLOR_INDEXES.  Diffuse and specular coefficients, computed with a (.30, .59, .11) weighting of the lights' colors, the shininess of the material, and the same reflection and attenuation equations as in the RGBA case, determine how much above ambient the resulting index is.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if pname is not an accepted value.  GL_INVALID_OPERATION is generated if glLightModel is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_LIGHT_MODEL_AMBIENTglGet with argument GL_LIGHT_MODEL_LOCAL_VIEWERglGet with argument GL_LIGHT_MODEL_TWO_SIDEglIsEnabled with argument GL_LIGHTINGLBL="" HELPID=""SEE ALSOIDREF="37552" TYPE="TITLE""glLight", IDREF="28170" TYPE="TITLE""glMaterial"LBL="" HELPID=""ID="37959"glLineStippleLBL="" HELPID=""NAMEglLineStipple - specify the line stipple pattern  LBL="" HELPID=""C SPECIFICATIONvoid glLineStipple( GLint factor, GLushort pattern ) LBL="" HELPID=""PARAMETERSfactorSpecifies a multiplier for each bit in the line stipple pattern.  If factor is 3, for example, each bit in the pattern will be used three times before the next bit in the pattern is used.  factor is clamped to the range [1, 255] and defaults to one.  patternSpecifies a 16-bit integer whose bit pattern determines which fragments of a line will be drawn when the line is rasterized.  Bit zero is used first, and the default pattern is all ones.   LBL="" HELPID=""DESCRIPTIONLine stippling masks out certain fragments produced by rasterization; those fragments will not be drawn.  The masking is achieved by using three parameters: the 16-bit line stipple pattern pattern, the repeat count factor, and an integer stipple counter s.  Counter s is reset to zero whenever glBegin is called, and before each line segment of a glBegin(GL_LINES)/glEnd sequence is generated.  It is incremented after each fragment of a unit width aliased line segment is generated, or after each i fragments of an i width line segment are generated.  The i fragments associated with count s are masked out if pattern bit (s factor) mod 16 is zero, otherwise these fragments are sent to the frame buffer.  Bit zero of pattern is the least significant bit.  Antialiased lines are treated as a sequence of 1 name='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]' width rectangles for purposes of stippling.  Rectangle s is rasterized or not based on the fragment rule described for aliased lines, counting rectangles rather than groups of fragments.  Line stippling is enabled or disabled using glEnable and glDisable with argument GL_LINE_STIPPLE.  When enabled, the line stipple pattern is applied as described above.  When disabled, it is as if the pattern were all ones.  Initially, line stippling is disabled.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glLineStipple is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_LINE_STIPPLE_PATTERNglGet with argument GL_LINE_STIPPLE_REPEATglIsEnabled with argument GL_LINE_STIPPLELBL="" HELPID=""SEE ALSOIDREF="23427" TYPE="TITLE""glLineWidth", IDREF="13142" TYPE="TITLE""glPolygonStipple"LBL="" HELPID=""ID="23427"glLineWidthLBL="" HELPID=""NAMEglLineWidth - specify the width of rasterized lines  LBL="" HELPID=""C SPECIFICATIONvoid glLineWidth( GLfloat width ) LBL="" HELPID=""PARAMETERSwidthSpecifies the width of rasterized lines.  The default is 1.0.   LBL="" HELPID=""DESCRIPTIONglLineWidth specifies the rasterized width of both aliased and antialiased lines.  Using a line width other than 1.0 has different effects, depending on whether line antialiasing is enabled.  Line antialiasing is controlled by calling glEnable and glDisable with argument GL_LINE_SMOOTH.  If line antialiasing is disabled, the actual width is determined by rounding the supplied width to the nearest integer.  (If the rounding results in the value 0, it is as if the line width were 1.) If  | name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'x |  name='ge' font=symbol charset=fontspecific code=179 
	TeX='\geq ' descr='[ge]' | name='Dgr' font=symbol charset=fontspecific code=68
	TeX='\Delta '   descr='[Dgr]'y |, i pixels are filled in each column that is rasterized, where i is the rounded value of width.  Otherwise, i pixels are filled in each row that is rasterized.  If antialiasing is enabled, line rasterization produces a fragment for each pixel square that intersects the region lying within the rectangle having width equal to the current line width, length equal to the actual length of the line, and centered on the mathematical line segment.  The coverage value for each fragment is the window coordinate area of the intersection of the rectangular region with the corresponding pixel square.  This value is saved and used in the final rasterization step.  Not all widths can be supported when line antialiasing is enabled.  If an unsupported width is requested, the nearest supported width is used.  Only width 1.0 is guaranteed to be supported; others depend on the implementation.  The range of supported widths and the size difference between supported widths within the range can be queried by calling glGet with arguments GL_LINE_WIDTH_RANGE and GL_LINE_WIDTH_GRANULARITY.  LBL="" HELPID=""NOTESThe line width specified by glLineWidth is always returned when GL_LINE_WIDTH is queried.  Clamping and rounding for aliased and antialiased lines have no effect on the specified value.  Non-antialiased line width may be clamped to an implementation-dependent maximum.  Although this maximum cannot be queried, it must be no less than the maximum value for antialiased lines, rounded to the nearest integer value.  LBL="" HELPID=""ERRORSGL_INVALID_VALUE is generated if width is less than or equal to zero.  GL_INVALID_OPERATION is generated if glLineWidth is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_LINE_WIDTHglGet with argument GL_LINE_WIDTH_RANGEglGet with argument GL_LINE_WIDTH_GRANULARITYglIsEnabled with argument GL_LINE_SMOOTHLBL="" HELPID=""SEE ALSOIDREF="40792" TYPE="TITLE""glEnable", glLineSmoothLBL="" HELPID=""ID="38449"glListBaseLBL="" HELPID=""NAMEglListBase - set the display-list base for glCallListsLBL="" HELPID=""C SPECIFICATIONvoid glListBase( GLuint base ) LBL="" HELPID=""PARAMETERSbaseSpecifies an integer offset that will be added to glCallLists offsets to generate display-list names.  Initial value is zero.   LBL="" HELPID=""DESCRIPTIONglCallLists specifies an array of offsets.  Display-list names are generated by adding base to each offset.  Names that reference valid display lists are executed; the others are ignored.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glListBase is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_LIST_BASELBL="" HELPID=""SEE ALSOIDREF="15751" TYPE="TITLE""glCallLists"LBL="" HELPID=""ID="15281"glLoadIdentityLBL="" HELPID=""NAMEglLoadIdentity - replace the current matrix with the identity matrix  LBL="" HELPID=""C SPECIFICATIONvoid glLoadIdentity( void ) LBL="" HELPID=""DESCRIPTIONglLoadIdentity replaces the current matrix with the identity matrix.  It is semantically equivalent to calling glLoadMatrix with the identity matrixFILE="eq0507.gif" POSITION="INLINE" SCALE="FALSE"but in some cases it is more efficient.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glLoadIdentity is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_MATRIX_MODEglGet with argument GL_MODELVIEW_MATRIXglGet with argument GL_PROJECTION_MATRIXglGet with argument GL_TEXTURE_MATRIXLBL="" HELPID=""SEE ALSOIDREF="21898" TYPE="TITLE""glLoadMatrix", IDREF="33637" TYPE="TITLE""glMatrixMode", IDREF="17230" TYPE="TITLE""glMultMatrix", IDREF="41698" TYPE="TITLE""glPushMatrix"LBL="" HELPID=""ID="21898"glLoadMatrixLBL="" HELPID=""NAMEglLoadMatrixd, glLoadMatrixf - replace the current matrix with an arbitrary matrix  LBL="" HELPID=""C SPECIFICATIONvoid glLoadMatrixd( const GLdouble *m ) void glLoadMatrixf( const GLfloat *m ) LBL="" HELPID=""PARAMETERSmSpecifies a pointer to a 4name='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]'4 matrix stored in column-major order as sixteen consecutive values.   LBL="" HELPID=""DESCRIPTIONglLoadMatrix replaces the current matrix with the one specified in m.  The current matrix is the projection matrix, modelview matrix, or texture matrix, determined by the current matrix mode (see IDREF="33637" TYPE="TITLE""glMatrixMode").  m points to a 4name='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]'4 matrix of single- or double-precision floating-point values stored in column-major order.  That is, the matrix is stored as follows:FILE="eq0508.gif" POSITION="INLINE" SCALE="FALSE"LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glLoadMatrix is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_MATRIX_MODEglGet with argument GL_MODELVIEW_MATRIXglGet with argument GL_PROJECTION_MATRIXglGet with argument GL_TEXTURE_MATRIXLBL="" HELPID=""SEE ALSOIDREF="15281" TYPE="TITLE""glLoadIdentity", IDREF="33637" TYPE="TITLE""glMatrixMode", IDREF="17230" TYPE="TITLE""glMultMatrix", IDREF="41698" TYPE="TITLE""glPushMatrix"LBL="" HELPID=""ID="42477"glLoadNameLBL="" HELPID=""NAMEglLoadName - load a name onto the name stack  LBL="" HELPID=""C SPECIFICATIONvoid glLoadName( GLuint name ) LBL="" HELPID=""PARAMETERSnameSpecifies a name that will replace the top value on the name stack.   LBL="" HELPID=""DESCRIPTIONThe name stack is used during selection mode to allow sets of rendering commands to be uniquely identified.  It consists of an ordered set of unsigned integers.  glLoadName causes name to replace the value on the top of the name stack, which is initially empty.  The name stack is always empty while the render mode is not GL_SELECT.  Calls to glLoadName while the render mode is not GL_SELECT are ignored.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glLoadName is called while the name stack is empty.  GL_INVALID_OPERATION is generated if glLoadName is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_NAME_STACK_DEPTHglGet with argument GL_MAX_NAME_STACK_DEPTHLBL="" HELPID=""SEE ALSOIDREF="40021" TYPE="TITLE""glInitNames", IDREF="32163" TYPE="TITLE""glPushName", IDREF="35248" TYPE="TITLE""glRenderMode", IDREF="35181" TYPE="TITLE""glSelectBuffer"LBL="" HELPID=""ID="18729"glLogicOpLBL="" HELPID=""NAMEglLogicOp - specify a logical pixel operation for color index rendering  LBL="" HELPID=""C SPECIFICATIONvoid glLogicOp( GLenum opcode ) LBL="" HELPID=""PARAMETERSopcodeSpecifies a symbolic constant that selects a logical operation.  The following symbols are accepted: GL_CLEAR, GL_SET, GL_COPY, GL_COPY_INVERTED, GL_NOOP, GL_INVERT, GL_AND, GL_NAND, GL_OR, GL_NOR, GL_XOR, GL_EQUIV, GL_AND_REVERSE, GL_AND_INVERTED, GL_OR_REVERSE, and GL_OR_INVERTED.  LBL="" HELPID=""DESCRIPTIONglLogicOp specifies a logical operation that, when enabled, is applied between the incoming color index and the color index at the corresponding location in the frame buffer.  The logical operation is enabled or disabled with glEnable and glDisable using the symbolic constant GL_LOGIC_OP.  opcode is a symbolic constant chosen from the list below.  In the explanation of the logical operations, s represents the incoming color index and d represents the index in the frame buffer.  Standard C-language operators are used.  As these bitwise operators suggest, the logical operation is applied independently to each bit pair of the source and destination indices.  COLUMNS="2"LEFT="0" WIDTH="180"opcode  LEFT="185" WIDTH="180"resulting valueLEFT="0" WIDTH="180"GL_CLEARLEFT="185" WIDTH="180"0LEFT="0" WIDTH="180"GL_SETLEFT="185" WIDTH="180"1LEFT="0" WIDTH="180"GL_COPYLEFT="185" WIDTH="180"sLEFT="0" WIDTH="180"GL_COPY_INVERTEDLEFT="185" WIDTH="180"!sLEFT="0" WIDTH="180"GL_NOOPLEFT="185" WIDTH="180"dLEFT="0" WIDTH="180"GL_INVERTLEFT="185" WIDTH="180"!dLEFT="0" WIDTH="180"GL_ANDLEFT="185" WIDTH="180"s & dLEFT="0" WIDTH="180"GL_NANDLEFT="185" WIDTH="180"!(s & d)LEFT="0" WIDTH="180"GL_ORLEFT="185" WIDTH="180"s | dLEFT="0" WIDTH="180"GL_NORLEFT="185" WIDTH="180"!(s | d)LEFT="0" WIDTH="180"GL_XORLEFT="185" WIDTH="180"s ^ dLEFT="0" WIDTH="180"GL_EQUIVLEFT="185" WIDTH="180"!(s ^ d)LEFT="0" WIDTH="180"GL_AND_REVERSELEFT="185" WIDTH="180"s & !dLEFT="0" WIDTH="180"GL_AND_INVERTEDLEFT="185" WIDTH="180"!s & dLEFT="0" WIDTH="180"GL_OR_REVERSELEFT="185" WIDTH="180"s | !dLEFT="0" WIDTH="180"GL_OR_INVERTEDLEFT="185" WIDTH="180"!s | dLBL="" HELPID=""NOTESLogical pixel operations are not applied to RGBA color buffers.  When more than one color index buffer is enabled for drawing, logical operations are done separately for each enabled buffer, using for the destination index the contents of that buffer (see IDREF="18132" TYPE="TITLE""glDrawBuffer").  opcode must be one of the sixteen accepted values.  Other values result in an error.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if opcode is not an accepted value.  GL_INVALID_OPERATION is generated if glLogicOp is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_LOGIC_OP_MODEglIsEnabled with argument GL_LOGIC_OPLBL="" HELPID=""SEE ALSOIDREF="19142" TYPE="TITLE""glAlphaFunc", IDREF="11446" TYPE="TITLE""glBlendFunc", IDREF="18132" TYPE="TITLE""glDrawBuffer", IDREF="40792" TYPE="TITLE""glEnable", IDREF="36095" TYPE="TITLE""glStencilOp"LBL="" HELPID=""ID="42533"glMap1LBL="" HELPID=""NAMEglMap1d, glMap1f - define a one-dimensional evaluator  LBL="" HELPID=""C SPECIFICATIONvoid glMap1d( GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points ) void glMap1f( GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points ) LBL="" HELPID=""PARAMETERStargetSpecifies the kind of values that are generated by the evaluator.  Symbolic constants GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP1_INDEX, GL_MAP1_COLOR_4, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, and GL_MAP1_TEXTURE_COORD_4 are accepted.  u1, u2Specify a linear mapping of u, as presented to glEvalCoord1, to u^, the variable that is evaluated by the equations specified by this command.  strideSpecifies the number of floats or doubles between the beginning of one control point and the beginning of the next one in the data structure referenced in points.  This allows control points to be embedded in arbitrary data structures.  The only constraint is that the values for a particular control point must occupy contiguous memory locations.  orderSpecifies the number of control points.  Must be positive.  pointsSpecifies a pointer to the array of control points.   LBL="" HELPID=""DESCRIPTIONEvaluators provide a way to use polynomial or rational polynomial mapping to produce vertices, normals, texture coordinates, and colors.  The values produced by an evaluator are sent to further stages of GL processing just as if they had been presented using glVertex, glNormal, glTexCoord, and glColor commands, except that the generated values do not update the current normal, texture coordinates, or color.  All polynomial or rational polynomial splines of any degree (up to the maximum degree supported by the GL implementation) can be described using evaluators.  These include almost all splines used in computer graphics, including B-splines, Bezier curves, Hermite splines, and so on.  Evaluators define curves based on Bernstein polynomials.  Define  p (˚ )  asFILE="eq0509.gif" POSITION="INLINE" SCALE="FALSE"where Ri is a control point and Bin ( u^ ) is the ith Bernstein polynomial of degree n (order = n + 1): FILE="eq0510.gif" POSITION="INLINE" SCALE="FALSE"Recall thatFILE="eq0511.gif" POSITION="INLINE" SCALE="FALSE"glMap1 is used to define the basis and to specify what kind of values are produced.  Once defined, a map can be enabled and disabled by calling glEnable and glDisable with the map name, one of the nine predefined values for target described below.  glEvalCoord1 evaluates the one-dimensional maps that are enabled.  When glEvalCoord1 presents a value u, the Bernstein functions are evaluated using u^, where FILE="eq0512.gif" POSITION="INLINE" SCALE="FALSE"target is a symbolic constant that indicates what kind of control points are provided in points, and what output is generated when the map is evaluated.  It can assume one of nine predefined values: GL_MAP1_VERTEX_3Each control point is three floating-point values representing x, y, and z.  Internal glVertex3 commands are generated when the map is evaluated.  GL_MAP1_VERTEX_4Each control point is four floating-point values representing x, y, z, and w.  Internal glVertex4 commands are generated when the map is evaluated.  GL_MAP1_INDEXEach control point is a single floating-point value representing a color index.  Internal glIndex commands are generated when the map is evaluated.  The current index is not updated with the value of these glIndex commands, however.  GL_MAP1_COLOR_4Each control point is four floating-point values representing red, green, blue, and alpha.  Internal glColor4 commands are generated when the map is evaluated.  The current color is not updated with the value of these glColor4 commands, however.  GL_MAP1_NORMALEach control point is three floating-point values representing the x, y, and z components of a normal vector.  Internal glNormal commands are generated when the map is evaluated.  The current normal is not updated with the value of these glNormal commands, however.  GL_MAP1_TEXTURE_COORD_1Each control point is a single floating-point value representing the s texture coordinate.  Internal glTexCoord1 commands are generated when the map is evaluated.  The current texture coordinates are not updated with the value of these glTexCoord commands, however.  GL_MAP1_TEXTURE_COORD_2Each control point is two floating-point values representing the s and t texture coordinates.  Internal glTexCoord2 commands are generated when the map is evaluated.  The current texture coordinates are not updated with the value of these glTexCoord commands, however.  GL_MAP1_TEXTURE_COORD_3Each control point is three floating-point values representing the s, t, and r texture coordinates.  Internal glTexCoord3 commands are generated when the map is evaluated.  The current texture coordinates are not updated with the value of these glTexCoord commands, however.  GL_MAP1_TEXTURE_COORD_4Each control point is four floating-point values representing the s, t, r, and q texture coordinates.  Internal glTexCoord4 commands are generated when the map is evaluated.  The current texture coordinates are not updated with the value of these glTexCoord commands, however.  stride, order, and points define the array addressing for accessing the control points.  points is the location of the first control point, which occupies one, two, three, or four contiguous memory locations, depending on which map is being defined.  order is the number of control points in the array.  stride tells how many float or double locations to advance the internal memory pointer to reach the next control point.  LBL="" HELPID=""NOTESAs is the case with all GL commands that accept pointers to data, it is as if the contents of points were copied by glMap1 before it returned.  Changes to the contents of points have no effect after glMap1 is called.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if target is not an accepted value.  GL_INVALID_VALUE is generated if u1 is equal to u2.  GL_INVALID_VALUE is generated if stride is less than the number of values in a control point.  GL_INVALID_VALUE is generated if order is less than one or greater than GL_MAX_EVAL_ORDER.  GL_INVALID_OPERATION is generated if glMap1 is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGetMapglGet with argument GL_MAX_EVAL_ORDERglIsEnabled with argument GL_MAP1_VERTEX_3glIsEnabled with argument GL_MAP1_VERTEX_4glIsEnabled with argument GL_MAP1_INDEXglIsEnabled with argument GL_MAP1_COLOR_4glIsEnabled with argument GL_MAP1_NORMALglIsEnabled with argument GL_MAP1_TEXTURE_COORD_1glIsEnabled with argument GL_MAP1_TEXTURE_COORD_2glIsEnabled with argument GL_MAP1_TEXTURE_COORD_3glIsEnabled with argument GL_MAP1_TEXTURE_COORD_4LBL="" HELPID=""SEE ALSOIDREF="11415" TYPE="TITLE""glBegin", IDREF="18325" TYPE="TITLE""glColor", IDREF="40792" TYPE="TITLE""glEnable", IDREF="41102" TYPE="TITLE""glEvalCoord", IDREF="14117" TYPE="TITLE""glEvalMesh", IDREF="14631" TYPE="TITLE""glEvalPoint", IDREF="26755" TYPE="TITLE""glMap2", IDREF="15455" TYPE="TITLE""glMapGrid", IDREF="12825" TYPE="TITLE""glNormal", IDREF="31124" TYPE="TITLE""glTexCoord", IDREF="32860" TYPE="TITLE""glVertex"LBL="" HELPID=""ID="26755"glMap2LBL="" HELPID=""NAMEglMap2d, glMap2f - define a two-dimensional evaluator  LBL="" HELPID=""C SPECIFICATIONvoid glMap2d( GLenum target, GLdouble u1, GLdouble u2, GLintustride, GLint uorder, GLdouble v1, GLdouble v2, GLnt vstride, GLint vorder, const GLdouble *points ) void glMap2f( GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points ) LBL="" HELPID=""PARAMETERStargetSpecifies the kind of values that are generated by the evaluator.  Symbolic constants GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4, GL_MAP2_INDEX, GL_MAP2_COLOR_4, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, and GL_MAP2_TEXTURE_COORD_4 are accepted.  u1, u2Specify a linear mapping of u, as presented to glEvalCoord2, to u^, one of the two variables that is evaluated by the equations specified by this command.  ustrideSpecifies the number of floats or doubles between the beginning of control point Rij and the beginning of control point R (i+1) j , where i and j are the u and v control point indices, respectively.  This allows control points to be embedded in arbitrary data structures.  The only constraint is that the values for a particular control point must occupy contiguous memory locations.  uorderSpecifies the dimension of the control point array in the u axis.  Must be positive.  v1, v2Specify a linear mapping of v, as presented to glEvalCoord2, to v^, one of the two variables that is evaluated by the equations specified by this command.  vstrideSpecifies the number of floats or doubles between the beginning of control point Rij and the beginning of control point R i (j+1) , where i and j are the u and v control point indices, respectively.  This allows control points to be embedded in arbitrary data structures.  The only constraint is that the values for a particular control point must occupy contiguous memory locations.  vorderSpecifies the dimension of the control point array in the v axis.  Must be positive.  pointsSpecifies a pointer to the array of control points.  LBL="" HELPID=""DESCRIPTIONEvaluators provide a way to use polynomial or rational polynomial mapping to produce vertices, normals, texture coordinates, and colors.  The values produced by an evaluator are sent on to further stages of GL processing just as if they had been presented using glVertex, glNormal, glTexCoord, and glColor commands, except that the generated values do not update the current normal, texture coordinates, or color.  All polynomial or rational polynomial splines of any degree (up to the maximum degree supported by the GL implementation) can be described using evaluators.  These include almost all surfaces used in computer graphics, including B-spline surfaces, NURBS surfaces, Bezier surfaces, and so on.  Evaluators define surfaces based on bivariate Bernstein polynomials.  DefineFILE="eq0513.gif" POSITION="INLINE" SCALE="FALSE"asFILE="eq0514.gif" POSITION="INLINE" SCALE="FALSE"where Rij is a control point, Bin ( u^) is the ith Bernstein polynomial of degree n (uorder = n + 1)FILE="eq0515.gif" POSITION="INLINE" SCALE="FALSE"and Bjm ( v^ ) is the jth Bernstein polynomial of degree m (vorder = m + 1)FILE="eq0516.gif" POSITION="INLINE" SCALE="FALSE"Recall thatFILE="eq0511.gif" POSITION="INLINE" SCALE="FALSE"glMap2 is used to define the basis and to specify what kind of values are produced.  Once defined, a map can be enabled and disabled by calling glEnable and glDisable with the map name, one of the nine predefined values for target, described below.  When glEvalCoord2 presents values u and v, the bivariate Bernstein polynomials are evaluated using u^ and v^, where FILE="eq0517.gif" POSITION="INLINE" SCALE="FALSE"FILE="eq0518.gif" POSITION="INLINE" SCALE="FALSE"target is a symbolic constant that indicates what kind of control points are provided in points, and what output is generated when the map is evaluated.  It can assume one of nine predefined values: GL_MAP2_VERTEX_3Each control point is three floating-point values representing x, y, and z.  Internal glVertex3 commands are generated when the map is evaluated.  GL_MAP2_VERTEX_4Each control point is four floating-point values representing x, y, z, and w.  Internal glVertex4 commands are generated when the map is evaluated.  GL_MAP2_INDEXEach control point is a single floating-point value representing a color index.  Internal glIndex commands are generated when the map is evaluated.  The current index is not updated with the value of these glIndex commands, however.  GL_MAP2_COLOR_4Each control point is four floating-point values representing red, green, blue, and alpha.  Internal glColor4 commands are generated when the map is evaluated.  The current color is not updated with the value of these glColor4 commands, however.  GL_MAP2_NORMALEach control point is three floating-point values representing the x, y, and z components of a normal vector.  Internal glNormal commands are generated when the map is evaluated.  The current normal is not updated with the value of these glNormal commands, however.  GL_MAP2_TEXTURE_COORD_1Each control point is a single floating-point value representing the s texture coordinate.  Internal glTexCoord1 commands are generated when the map is evaluated.  The current texture coordinates are not updated with the value of these glTexCoord commands, however.  GL_MAP2_TEXTURE_COORD_2Each control point is two floating-point values representing the s and t texture coordinates.  Internal glTexCoord2 commands are generated when the map is evaluated.  The current texture coordinates are not updated with the value of these glTexCoord commands, however.  GL_MAP2_TEXTURE_COORD_3Each control point is three floating-point values representing the s, t, and r texture coordinates.  Internal glTexCoord3 commands are generated when the map is evaluated.  The current texture coordinates are not updated with the value of these glTexCoord commands, however.  GL_MAP2_TEXTURE_COORD_4Each control point is four floating-point values representing the s, t, r, and q texture coordinates.  Internal glTexCoord4 commands are generated when the map is evaluated.  The current texture coordinates are not updated with the value of these glTexCoord commands, however.  ustride, uorder, vstride, vorder, and points define the array addressing for accessing the control points.  points is the location of the first control point, which occupies one, two, three, or four contiguous memory locations, depending on which map is being defined.  There are  uorder name='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]' vorder  control points in the array.  ustride tells how many float or double locations are skipped to advance the internal memory pointer from control point  Ri j  to control point R(i+1) j .  vstride tells how many float or double locations are skipped to advance the internal memory pointer from control point  Ri j  to control point Ri (j+1)  .   LBL="" HELPID=""NOTESAs is the case with all GL commands that accept pointers to data, it is as if the contents of points were copied by glMap2 before it returned.  Changes to the contents of points have no effect after glMap2 is called.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if target is not an accepted value.  GL_INVALID_VALUE is generated if u1 is equal to u2, or if v1 is equal to v2.  GL_INVALID_VALUE is generated if either ustride or vstride is less than the number of values in a control point.  GL_INVALID_VALUE is generated if either uorder or vorder is less than one or greater than GL_MAX_EVAL_ORDER.  GL_INVALID_OPERATION is generated if glMap2 is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGetMapglGet with argument GL_MAX_EVAL_ORDERglIsEnabled with argument GL_MAP2_VERTEX_3glIsEnabled with argument GL_MAP2_VERTEX_4glIsEnabled with argument GL_MAP2_INDEXglIsEnabled with argument GL_MAP2_COLOR_4glIsEnabled with argument GL_MAP2_NORMALglIsEnabled with argument GL_MAP2_TEXTURE_COORD_1glIsEnabled with argument GL_MAP2_TEXTURE_COORD_2glIsEnabled with argument GL_MAP2_TEXTURE_COORD_3glIsEnabled with argument GL_MAP2_TEXTURE_COORD_4LBL="" HELPID=""SEE ALSOIDREF="11415" TYPE="TITLE""glBegin", IDREF="18325" TYPE="TITLE""glColor", IDREF="40792" TYPE="TITLE""glEnable", IDREF="41102" TYPE="TITLE""glEvalCoord", IDREF="14117" TYPE="TITLE""glEvalMesh", IDREF="14631" TYPE="TITLE""glEvalPoint", IDREF="42533" TYPE="TITLE""glMap1", IDREF="15455" TYPE="TITLE""glMapGrid", IDREF="12825" TYPE="TITLE""glNormal", IDREF="31124" TYPE="TITLE""glTexCoord", IDREF="32860" TYPE="TITLE""glVertex"LBL="" HELPID=""ID="15455"glMapGridLBL="" HELPID=""NAMEglMapGrid1d, glMapGrid1f, glMapGrid2d, glMapGrid2f - define a one- or two-dimensional mesh  LBL="" HELPID=""C SPECIFICATIONvoid glMapGrid1d( GLint un, GLdouble u1, GLdouble u2 ) void glMapGrid1f( GLint un, GLfloat u1, GLfloat u2 ) void glMapGrid2d( GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2 ) void glMapGrid2f( GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1,         GLfloat v2 ) LBL="" HELPID=""PARAMETERSunSpecifies the number of partitions in the grid range interval [u1, u2].  Must be positive.  u1, u2Specify the mappings for integer grid domain values i=0 and i=un.  vnSpecifies the number of partitions in the grid range interval [v1, v2] (glMapGrid2 only).  v1, v2Specify the mappings for integer grid domain values j=0 and j=vn (glMapGrid2 only).   LBL="" HELPID=""DESCRIPTIONglMapGrid and glEvalMesh are used in tandem to efficiently generate and evaluate a series of evenly spaced map domain values.  glEvalMesh steps through the integer domain of a one- or two-dimensional grid, whose range is the domain of the evaluation maps specified by glMap1 and glMap2.  glMapGrid1 and glMapGrid2 specify the linear grid mappings between the i (or i and j) integer grid coordinates, to the u (or u and v) floating-point evaluation map coordinates.  See IDREF="42533" TYPE="TITLE""glMap1" and IDREF="26755" TYPE="TITLE""glMap2" for details of how u and v coordinates are evaluated.  glMapGrid1 specifies a single linear mapping such that integer grid coordinate 0 maps exactly to u1, and integer grid coordinate un maps exactly to u2.  All other integer grid coordinates i are mapped such thatu=i(u2-u1)/un+u1glMapGrid2 specifies two such linear mappings.  One maps integer grid coordinate i=0 exactly to u1, and integer grid coordinate i=un exactly to u2.  The other maps integer grid coordinate j=0 exactly to v1, and integer grid coordinate j=vn exactly to v2.  Other integer grid coordinates i and j are mapped such that u=i(u2-u1)/un+u1v=j(v2-v1)/vn+v1The mappings specified by glMapGrid are used identically by glEvalMesh and glEvalPoint.  LBL="" HELPID=""ERRORSGL_INVALID_VALUE is generated if either un or vn is not positive.  GL_INVALID_OPERATION is generated if glMapGrid is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_MAP1_GRID_DOMAINglGet with argument GL_MAP2_GRID_DOMAINglGet with argument GL_MAP1_GRID_SEGMENTSglGet with argument GL_MAP2_GRID_SEGMENTSLBL="" HELPID=""SEE ALSOIDREF="41102" TYPE="TITLE""glEvalCoord", IDREF="14117" TYPE="TITLE""glEvalMesh", IDREF="14631" TYPE="TITLE""glEvalPoint", IDREF="42533" TYPE="TITLE""glMap1", IDREF="26755" TYPE="TITLE""glMap2"LBL="" HELPID=""ID="28170"glMaterialLBL="" HELPID=""NAMEglMaterialf, glMateriali, glMaterialfv, glMaterialiv - specify material parameters for the lighting model  LBL="" HELPID=""C SPECIFICATIONvoid glMaterialf( GLenum face, GLenum pname, GLfloat param ) void glMateriali( GLenum face, GLenum pname, GLint param ) LBL="" HELPID=""PARAMETERSfaceSpecifies which face or faces are being updated.  Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK.  pnameSpecifies the single-valued material parameter of the face or faces that is being updated.  Must be GL_SHININESS.  paramSpecifies the value that parameter GL_SHININESS will be set to.  LBL="" HELPID=""C SPECIFICATIONvoid glMaterialfv( GLenum face, GLenum pname, const GLfloat *params ) void glMaterialiv( GLenum face, GLenum pname, const GLint *params ) LBL="" HELPID=""PARAMETERSfaceSpecifies which face or faces are being updated.  Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK.  pnameSpecifies the material parameter of the face or faces that is being updated.  Must be one of GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION, GL_SHININESS, GL_AMBIENT_AND_DIFFUSE,  or GL_COLOR_INDEXES.  paramsSpecifies a pointer to the value or values that pname will be set to.   LBL="" HELPID=""DESCRIPTIONglMaterial assigns values to material parameters.  There are two matched sets of material parameters.  One, the front-facing set, is used to shade points, lines, bitmaps, and all polygons (when two-sided lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled).  The other set, back-facing, is used to shade back-facing polygons only when two-sided lighting is enabled.  Refer to the glLightModel reference page for details concerning one- and two-sided lighting calculations.  glMaterial takes three arguments.  The first, face, specifies whether the GL_FRONT materials, the GL_BACK materials, or both GL_FRONT_AND_BACK materials will be modified.  The second, pname, specifies which of several parameters in one or both sets will be modified.  The third, params, specifies what value or values will be assigned to the specified parameter.  Material parameters are used in the lighting equation that is optionally applied to each vertex.  The equation is discussed in the glLightModel reference page.  The parameters that can be specified using glMaterial, and their interpretations by the lighting equation, are as follows: GL_AMBIENT params contains four integer or floating-point values that specify the ambient RGBA reflectance of the material.  Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0.  Floating-point values are mapped directly.  Neither integer nor floating-point values are clamped.  The default ambient reflectance for both front- and back-facing materials is (0.2, 0.2, 0.2, 1.0).  GL_DIFFUSE params contains four integer or floating-point values that specify the diffuse RGBA reflectance of the material.  Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0.  Floating-point values are mapped directly.  Neither integer nor floating-point values are clamped.  The default diffuse reflectance for both front- and back-facing materials is (0.8, 0.8, 0.8, 1.0).  GL_SPECULAR params contains four integer or floating-point values that specify the specular RGBA reflectance of the material.  Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0.  Floating-point values are mapped directly.  Neither integer nor floating-point values are clamped.  The default specular reflectance for both front- and back-facing materials is (0.0, 0.0, 0.0, 1.0).  GL_EMISSION params contains four integer or floating-point values that specify the RGBA emitted light intensity of the material.  Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0.  Floating-point values are mapped directly.  Neither integer nor floating-point values are clamped.  The default emission intensity for both front- and back-facing materials is (0.0, 0.0, 0.0, 1.0).  GL_SHININESS params is a single integer or floating-point value that specifies the RGBA specular exponent of the material.  Integer and floating-point values are mapped directly.  Only values in the range [0,128] are accepted.  The default specular exponent for both front- and back-facing materials is 0.  GL_AMBIENT_AND_DIFFUSEEquivalent to calling glMaterial twice with the same parameter values, once with GL_AMBIENT and once with GL_DIFFUSE.  GL_COLOR_INDEXESparams contains three integer or floating-point values specifying the color indices for ambient, diffuse, and specular lighting.  These three values, and GL_SHININESS, are the only material values used by the color index mode lighting equation.  Refer to the glLightModel reference page for a discussion of color index lighting.  LBL="" HELPID=""NOTESThe material parameters can be updated at any time.  In particular, glMaterial can be called between a call to glBegin and the corresponding call to glEnd.  If only a single material parameter is to be changed per vertex, however, glColorMaterial is preferred over glMaterial (see IDREF="37922" TYPE="TITLE""glColorMaterial").  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if either face or pname is not an accepted value.  GL_INVALID_VALUE is generated if a specular exponent outside the range [0,128] is specified.  LBL="" HELPID=""ASSOCIATED GETSglGetMaterialLBL="" HELPID=""SEE ALSOIDREF="37922" TYPE="TITLE""glColorMaterial", IDREF="37552" TYPE="TITLE""glLight", IDREF="19151" TYPE="TITLE""glLightModel"LBL="" HELPID=""ID="33637"glMatrixModeLBL="" HELPID=""NAMEglMatrixMode - specify which matrix is the current matrix  LBL="" HELPID=""C SPECIFICATIONvoid glMatrixMode( GLenum mode ) LBL="" HELPID=""PARAMETERSmodeSpecifies which matrix stack is the target for subsequent matrix operations.  Three values are accepted: GL_MODELVIEW, GL_PROJECTION, and GL_TEXTURE.   LBL="" HELPID=""DESCRIPTIONglMatrixMode sets the current matrix mode.  mode can assume one of three values: GL_MODELVIEWApplies subsequent matrix operations to the modelview matrix stack.  GL_PROJECTIONApplies subsequent matrix operations to the projection matrix stack.  GL_TEXTUREApplies subsequent matrix operations to the texture matrix stack.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if mode is not an accepted value.  GL_INVALID_OPERATION is generated if glMatrixMode is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_MATRIX_MODELBL="" HELPID=""SEE ALSOIDREF="21898" TYPE="TITLE""glLoadMatrix", IDREF="33637" TYPE="TITLE""glMatrixMode", IDREF="41698" TYPE="TITLE""glPushMatrix"LBL="" HELPID=""ID="17230"glMultMatrixLBL="" HELPID=""NAMEglMultMatrixd, glMultMatrixf - multiply the current matrix by an arbitrary matrix  LBL="" HELPID=""C SPECIFICATIONvoid glMultMatrixd( const GLdouble *m ) void glMultMatrixf( const GLfloat *m ) LBL="" HELPID=""PARAMETERSmSpecifies a pointer a to 4name='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]'4 matrix stored in column-major order as sixteen consecutive values.   LBL="" HELPID=""DESCRIPTIONglMultMatrix multiplies the current matrix with the one specified in m.  That is, if M is the current matrix and T is the matrix passed to glMultMatrix, then M is replaced with MT.  The current matrix is the projection matrix, modelview matrix, or texture matrix, determined by the current matrix mode (see IDREF="33637" TYPE="TITLE""glMatrixMode").  m points to a 4name='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]'4 matrix of single- or double-precision floating-point values stored in column-major order.  That is, the matrix is stored asFILE="eq0508.gif" POSITION="INLINE" SCALE="FALSE"LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glMultMatrix is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_MATRIX_MODEglGet with argument GL_MODELVIEW_MATRIXglGet with argument GL_PROJECTION_MATRIXglGet with argument GL_TEXTURE_MATRIXLBL="" HELPID=""SEE ALSOIDREF="33637" TYPE="TITLE""glMatrixMode", IDREF="15281" TYPE="TITLE""glLoadIdentity", IDREF="21898" TYPE="TITLE""glLoadMatrix", IDREF="41698" TYPE="TITLE""glPushMatrix"LBL="" HELPID=""ID="28073"glNewListLBL="" HELPID=""NAMEglNewList, glEndList - create or replace a display list  LBL="" HELPID=""C SPECIFICATIONvoid glNewList( GLuint list, GLenum mode ) LBL="" HELPID=""PARAMETERSlistSpecifies the display list name.  modeSpecifies the compilation mode, which can be GL_COMPILE or GL_COMPILE_AND_EXECUTE.  LBL="" HELPID=""C SPECIFICATIONvoid glEndList( void ) LBL="" HELPID=""DESCRIPTIONDisplay lists are groups of GL commands that have been stored for subsequent execution.  The display lists are created with glNewList.  All subsequent commands are placed in the display list, in the order issued, until glEndList is called.  glNewList has two arguments.  The first argument, list, is a positive integer that becomes the unique name for the display list.  Names can be created and reserved with glGenLists and tested for uniqueness with glIsList.  The second argument, mode, is a symbolic constant that can assume one of two values: GL_COMPILECommands are merely compiled.  GL_COMPILE_AND_EXECUTECommands are executed as they are compiled into the display list.  Certain commands are not compiled into the display list, but are executed immediately, regardless of the display-list mode.  These commands are glIsList, glGenLists, glDeleteLists, glFeedbackBuffer, glSelectBuffer, glRenderMode, glReadPixels, glPixelStore, glFlush, glFinish, glIsEnabled, and all of the glGet routines.  When glEndList is encountered, the display-list definition is completed by associating the list with the unique name list (specified in the glNewList command).  If a display list with name list already exists, it is replaced only when glEndList is called.  LBL="" HELPID=""NOTESglCallList and glCallLists can be entered into display lists.  The commands in the display list or lists executed by glCallList or glCallLists are not included in the display list being created, even if the list creation mode is GL_COMPILE_AND_EXECUTE.  LBL="" HELPID=""ERRORSGL_INVALID_VALUE is generated if list is zero.  GL_INVALID_ENUM is generated if mode is not an accepted value.  GL_INVALID_OPERATION is generated if glEndList is called without a preceding glNewList, or if glNewList is called while a display list is being defined.  GL_INVALID_OPERATION is generated if glNewList is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglIsListLBL="" HELPID=""SEE ALSOIDREF="37134" TYPE="TITLE""glCallList", IDREF="15751" TYPE="TITLE""glCallLists", IDREF="13566" TYPE="TITLE""glDeleteLists", IDREF="12827" TYPE="TITLE""glGenLists"LBL="" HELPID=""ID="12825"glNormalLBL="" HELPID=""NAMEglNormal3b, glNormal3d, glNormal3f, glNormal3i, glNormal3s, glNormal3bv, glNormal3dv, glNormal3fv, glNormal3iv, glNormal3sv - set the current normal vector   LBL="" HELPID=""C SPECIFICATIONvoid glNormal3b( GLbyte nx, GLbyte ny, GLbyte nz )void glNormal3d( GLdouble nx, GLdouble ny, GLdouble nz )void glNormal3f( GLfloat nx, GLfloat ny, GLfloat nz )void glNormal3i( GLint nx, GLint ny, GLint nz )void glNormal3s( GLshort nx, GLshort ny, GLshort nz ) LBL="" HELPID=""PARAMETERSnx, ny, nzSpecify the x, y, and z coordinates of the new current normal.  The initial value of the current normal is (0,0,1).   LBL="" HELPID=""C SPECIFICATIONvoid glNormal3bv( const GLbyte *v )void glNormal3dv( const GLdouble *v )void glNormal3fv( const GLfloat *v )void glNormal3iv( const GLint *v )void glNormal3sv( const GLshort *v ) LBL="" HELPID=""PARAMETERSvSpecifies a pointer to an array of three elements: the x, y, and z coordinates of the new current normal.   LBL="" HELPID=""DESCRIPTIONThe current normal is set to the given coordinates whenever glNormal is issued.  Byte, short, or integer arguments are converted to floating-point format with a linear mapping that maps the most positive representable integer value to 1.0, and the most negative representable integer value to -1.0.  Normals specified with glNormal need not have unit length.  If normalization is enabled, then normals specified with glNormal are normalized after transformation.  Normalization is controlled using glEnable and glDisable with the argument GL_NORMALIZE.  By default, normalization is disabled.  LBL="" HELPID=""NOTESThe current normal can be updated at any time.  In particular, glNormal can be called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_CURRENT_NORMALglIsEnable with argument GL_NORMALIZELBL="" HELPID=""SEE ALSOIDREF="11415" TYPE="TITLE""glBegin", IDREF="18325" TYPE="TITLE""glColor", IDREF="14741" TYPE="TITLE""glIndex", IDREF="31124" TYPE="TITLE""glTexCoord", IDREF="32860" TYPE="TITLE""glVertex"LBL="" HELPID=""ID="30307"glOrthoLBL="" HELPID=""NAMEglOrtho - multiply the current matrix by an orthographic matrix  LBL="" HELPID=""C SPECIFICATIONvoid glOrtho( GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near, GLdouble far ) LBL="" HELPID=""PARAMETERSleft, rightSpecify the coordinates for the left and right vertical clipping planes.  bottom, topSpecify the coordinates for the bottom and top horizontal clipping planes.  near, farSpecify the distances to the nearer and farther depth clipping planes.  These distances are negative if the plane is to be behind the viewer.   LBL="" HELPID=""DESCRIPTIONglOrtho describes a perspective matrix that produces a parallel projection.  (left, bottom,  -near) and (right, top,  -near) specify the points on the near clipping plane that are mapped to the lower left and upper right corners of the window, respectively, assuming that the eye is located at (0, 0, 0).  -far specifies the location of the far clipping plane.  Both near and far can be either positive or negative.  The corresponding matrix is  FILE="eq0519.gif" POSITION="INLINE" SCALE="FALSE"whereFILE="eq0520.gif" POSITION="INLINE" SCALE="FALSE"The current matrix is multiplied by this matrix with the result replacing the current matrix.  That is, if M is the current matrix and O is the ortho matrix, then M is replaced with MO.  Use glPushMatrix and glPopMatrix to save and restore the current matrix stack.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glOrtho is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_MATRIX_MODEglGet with argument GL_MODELVIEW_MATRIXglGet with argument GL_PROJECTION_MATRIXglGet with argument GL_TEXTURE_MATRIXLBL="" HELPID=""SEE ALSOIDREF="13747" TYPE="TITLE""glFrustum", IDREF="33637" TYPE="TITLE""glMatrixMode", IDREF="17230" TYPE="TITLE""glMultMatrix", IDREF="41698" TYPE="TITLE""glPushMatrix", IDREF="17575" TYPE="TITLE""glViewport"LBL="" HELPID=""ID="24204"glPassThroughLBL="" HELPID=""NAMEglPassThrough - place a marker in the feedback buffer   LBL="" HELPID=""C SPECIFICATIONvoid glPassThrough( GLfloat token ) LBL="" HELPID=""PARAMETERStokenSpecifies a marker value to be placed in the feedback buffer following a GL_PASS_THROUGH_TOKEN.   LBL="" HELPID=""DESCRIPTIONFeedback is a GL render mode.  The mode is selected by calling glRenderMode with GL_FEEDBACK.  When the GL is in feedback mode, no pixels are produced by rasterization.  Instead, information about primitives that would have been rasterized is fed back to the application using the GL.  See IDREF="22322" TYPE="TITLE""glFeedbackBuffer" for a description of the feedback buffer and the values in it.  glPassThrough inserts a user-defined marker in the feedback buffer when it is executed in feedback mode.  token is returned as if it were a primitive; it is indicated with its own unique identifying value: GL_PASS_THROUGH_TOKEN.  The order of glPassThrough commands with respect to the specification of graphics primitives is maintained.  LBL="" HELPID=""NOTESglPassThrough is ignored if the GL is not in feedback mode.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glPassThrough is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_RENDER_MODELBL="" HELPID=""SEE ALSOIDREF="22322" TYPE="TITLE""glFeedbackBuffer", IDREF="35248" TYPE="TITLE""glRenderMode"LBL="" HELPID=""ID="34580"glPixelMapLBL="" HELPID=""NAMEglPixelMapfv, glPixelMapuiv, glPixelMapusv - set up pixel transfer maps  LBL="" HELPID=""C SPECIFICATIONvoid glPixelMapfv( GLenum map, GLint mapsize, const GLfloat *values ) void glPixelMapuiv( GLenum map, GLint mapsize, const GLuint *values )void glPixelMapusv( GLenum map, GLint mapsize, const GLushort *values ) LBL="" HELPID=""PARAMETERSmapSpecifies a symbolic map name.  Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A.  mapsizeSpecifies the size of the map being defined.  valuesSpecifies an array of mapsize values.   LBL="" HELPID=""DESCRIPTIONglPixelMap sets up translation tables, or maps, used by glDrawPixels, glReadPixels, glCopyPixels, glTexImage1D, and glTexImage2D.  Use of these maps is described completely in the glPixelTransfer reference page, and partly in the reference pages for the pixel and texture image commands.  Only the specification of the maps is described in this reference page.  map is a symbolic map name, indicating one of ten maps to set.  mapsize specifies the number of entries in the map, and values is a pointer to an array of mapsize map values.  The ten maps are as follows: GL_PIXEL_MAP_I_TO_IMaps color indices to color indices.  GL_PIXEL_MAP_S_TO_SMaps stencil indices to stencil indices.  GL_PIXEL_MAP_I_TO_RMaps color indices to red components.  GL_PIXEL_MAP_I_TO_GMaps color indices to green components.  GL_PIXEL_MAP_I_TO_BMaps color indices to blue components.  GL_PIXEL_MAP_I_TO_AMaps color indices to alpha components.  GL_PIXEL_MAP_R_TO_RMaps red components to red components.  GL_PIXEL_MAP_G_TO_GMaps green components to green components.  GL_PIXEL_MAP_B_TO_BMaps blue components to blue components.  GL_PIXEL_MAP_A_TO_AMaps alpha components to alpha components.  The entries in a map can be specified as single-precision floating-point numbers, unsigned short integers, or unsigned long integers.  Maps that store color component values (all but GL_PIXEL_MAP_I_TO_I and GL_PIXEL_MAP_S_TO_S) retain their values in floating-point format, with unspecified mantissa and exponent sizes.  Floating-point values specified by glPixelMapfv are converted directly to the internal floating-point format of these maps, then clamped to the range [0,1].  Unsigned integer values specified by glPixelMapusv and glPixelMapuiv are converted linearly such that the largest representable integer maps to 1.0, and zero maps to 0.0.  Maps that store indices, GL_PIXEL_MAP_I_TO_I and GL_PIXEL_MAP_S_TO_S, retain their values in fixed-point format, with an unspecified number of bits to the right of the binary point.  Floating-point values specified by glPixelMapfv are converted directly to the internal fixed-point format of these maps.  Unsigned integer values specified by glPixelMapusv and glPixelMapuiv specify integer values, with all zeros to the right of the binary point.  The table below shows the initial sizes and values for each of the maps.  Maps that are indexed by either color or stencil indices must have mapsize = 2n for some n or results are undefined.  The maximum allowable size for each map depends on the implementation and can be determined by calling glGet with argument GL_MAX_PIXEL_MAP_TABLE.  The single maximum applies to all maps, and it is at least 32.  COLUMNS="5"LEFT="0" WIDTH="135"mapLEFT="140" WIDTH="72"lookup indexLEFT="220" WIDTH="72"lookup valueLEFT="300" WIDTH="54"initial sizeLEFT="360" WIDTH="54"initial valueLEFT="0" WIDTH="135"GL_PIXEL_MAP_I_TO_ILEFT="140" WIDTH="72"color indexLEFT="220" WIDTH="72"color indexLEFT="300" WIDTH="54"1LEFT="360" WIDTH="54"0.0LEFT="0" WIDTH="135"GL_PIXEL_MAP_S_TO_SLEFT="140" WIDTH="72"stencil index LEFT="220" WIDTH="72"stencil index LEFT="300" WIDTH="54"1LEFT="360" WIDTH="54"0LEFT="0" WIDTH="135"GL_PIXEL_MAP_I_TO_RLEFT="140" WIDTH="72"color index LEFT="220" WIDTH="72"RLEFT="300" WIDTH="54"1LEFT="360" WIDTH="54"0.0LEFT="0" WIDTH="135"GL_PIXEL_MAP_I_TO_GLEFT="140" WIDTH="72"color index LEFT="220" WIDTH="72"GLEFT="300" WIDTH="54"1LEFT="360" WIDTH="54"0.0LEFT="0" WIDTH="135"GL_PIXEL_MAP_I_TO_BLEFT="140" WIDTH="72"color indexLEFT="220" WIDTH="72"BLEFT="300" WIDTH="54"1LEFT="360" WIDTH="54"0.0LEFT="0" WIDTH="135"GL_PIXEL_MAP_I_TO_ALEFT="140" WIDTH="72"color indexLEFT="220" WIDTH="72"ALEFT="300" WIDTH="54"1LEFT="360" WIDTH="54"0.0LEFT="0" WIDTH="135"GL_PIXEL_MAP_R_TO_RLEFT="140" WIDTH="72"RLEFT="220" WIDTH="72"RLEFT="300" WIDTH="54"1LEFT="360" WIDTH="54"0.0LEFT="0" WIDTH="135"GL_PIXEL_MAP_G_TO_GLEFT="140" WIDTH="72"GLEFT="220" WIDTH="72"GLEFT="300" WIDTH="54"1LEFT="360" WIDTH="54"0.0LEFT="0" WIDTH="135"GL_PIXEL_MAP_B_TO_BLEFT="140" WIDTH="72"BLEFT="220" WIDTH="72"BLEFT="300" WIDTH="54"1LEFT="360" WIDTH="54"0.0LEFT="0" WIDTH="135"GL_PIXEL_MAP_A_TO_ALEFT="140" WIDTH="72"ALEFT="220" WIDTH="72"ALEFT="300" WIDTH="54"1LEFT="360" WIDTH="54"0.0LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if map is not an accepted value.  GL_INVALID_VALUE is generated if mapsize is negative or larger than GL_MAX_PIXEL_MAP_TABLE.  GL_INVALID_VALUE is generated if map is GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, or GL_PIXEL_MAP_I_TO_A, and mapsize is not a power of two.  GL_INVALID_OPERATION is generated if glPixelMap is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGetPixelMapglGet with argument GL_PIXEL_MAP_I_TO_I_SIZEglGet with argument GL_PIXEL_MAP_S_TO_S_SIZEglGet with argument GL_PIXEL_MAP_I_TO_R_SIZEglGet with argument GL_PIXEL_MAP_I_TO_G_SIZEglGet with argument GL_PIXEL_MAP_I_TO_B_SIZEglGet with argument GL_PIXEL_MAP_I_TO_A_SIZEglGet with argument GL_PIXEL_MAP_R_TO_R_SIZEglGet with argument GL_PIXEL_MAP_G_TO_G_SIZEglGet with argument GL_PIXEL_MAP_B_TO_B_SIZEglGet with argument GL_PIXEL_MAP_A_TO_A_SIZEglGet with argument GL_MAX_PIXEL_MAP_TABLELBL="" HELPID=""SEE ALSOIDREF="25030" TYPE="TITLE""glCopyPixels", IDREF="41928" TYPE="TITLE""glDrawPixels", IDREF="39579" TYPE="TITLE""glPixelStore", IDREF="38440" TYPE="TITLE""glPixelTransfer", IDREF="40261" TYPE="TITLE""glReadPixels", IDREF="40965" TYPE="TITLE""glTexImage1D", IDREF="38642" TYPE="TITLE""glTexImage2D"LBL="" HELPID=""ID="39579"glPixelStoreLBL="" HELPID=""NAMEglPixelStoref, glPixelStorei - set pixel storage modes  LBL="" HELPID=""C SPECIFICATIONvoid glPixelStoref( GLenum pname, GLfloat param ) void glPixelStorei( GLenum pname, GLint param ) LBL="" HELPID=""PARAMETERSpnameSpecifies the symbolic name of the parameter to be set.  Six values affect the packing of pixel data into memory: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, and GL_PACK_ALIGNMENT.  Six more affect the unpacking of pixel data from memory: GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, and GL_UNPACK_ALIGNMENT.  paramSpecifies the value that pname is set to.   LBL="" HELPID=""DESCRIPTIONglPixelStore sets pixel storage modes that affect the operation of subsequent glDrawPixels and glReadPixels as well as the unpacking of polygon stipple patterns (see IDREF="13142" TYPE="TITLE""glPolygonStipple"), bitmaps (see IDREF="23412" TYPE="TITLE""glBitmap"), and texture patterns (see IDREF="40965" TYPE="TITLE""glTexImage1D" and IDREF="38642" TYPE="TITLE""glTexImage2D").  pname is a symbolic constant indicating the parameter to be set, and param is the new value.  Six of the twelve storage parameters affect how pixel data is returned to client memory, and are therefore significant only for glReadPixels commands.  They are as follows: GL_PACK_SWAP_BYTESIf true, byte ordering for multibyte color components, depth components, color indices, or stencil indices is reversed.  That is, if a four-byte component is made up of bytes b0, b1, b2, b3, it is stored in memory as b3, b2, b1, b0 if GL_PACK_SWAP_BYTES is true.  GL_PACK_SWAP_BYTES has no effect on the memory order of components within a pixel, only on the order of bytes within components or indices.  For example, the three components of a GL_RGB format pixel are always stored with red first, green second, and blue third, regardless of the value of GL_PACK_SWAP_BYTES.  GL_PACK_LSB_FIRSTIf true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one.  This parameter is significant for bitmap data only.  GL_PACK_ROW_LENGTHIf greater than zero, GL_PACK_ROW_LENGTH defines the number of pixels in a row.  If the first pixel of a row is placed at location p in memory, then the location of the first pixel of the next row is obtained by skippingFILE="eq05_04.gif" POSITION="INLINE" SCALE="FALSE"components or indices, where n is the number of components or indices in a pixel, l is the number of pixels in a row (GL_PACK_ROW_LENGTH if it is greater than zero, the width argument to the pixel routine otherwise), a is the value of GL_PACK_ALIGNMENT, and s is the size, in bytes, of a single component (if  a < s, then it is as if a = s).  In the case of 1-bit values, the location of the next row is obtained by skipping FILE="eq05_05.gif" POSITION="INLINE" SCALE="FALSE"components or indices.  The word component in this description refers to the nonindex values red, green, blue, alpha, and depth.  Storage format GL_RGB, for example, has three components per pixel: first red, then green, and finally blue.  GL_PACK_SKIP_PIXELS and GL_PACK_SKIP_ROWSThese values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated simply by incrementing the pointer passed to glReadPixels.  Setting GL_PACK_SKIP_PIXELS to i is equivalent to incrementing the pointer by i n components or indices, where n is the number of components or indices in each pixel.  Setting GL_PACK_SKIP_ROWS to j is equivalent to incrementing the pointer by j k components or indices, where k is the number of components or indices per row, as computed above in the GL_PACK_ROW_LENGTH section.  GL_PACK_ALIGNMENTSpecifies the alignment requirements for the start of each pixel row in memory.  The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word alignment), and 8 (rows start on double-word boundaries).  The other six of the twelve storage parameters affect how pixel data is read from client memory.  These values are significant for glDrawPixels, glTexImage1D, glTexImage2D, glBitmap, and glPolygonStipple.  They are as follows: GL_UNPACK_SWAP_BYTESIf true, byte ordering for multibyte color components, depth components, color indices, or stencil indices is reversed.  That is, if a four-byte component is made up of bytes b0, b1, b2, b3, it is taken from memory as b3, b2, b1, b0 if GL_UNPACK_SWAP_BYTES is true.  GL_UNPACK_SWAP_BYTES has no effect on the memory order of components within a pixel, only on the order of bytes within components or indices.  For example, the three components of a GL_RGB format pixel are always stored with red first, green second, and blue third, regardless of the value of GL_UNPACK_SWAP_BYTES.  GL_UNPACK_LSB_FIRSTIf true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one.  This is significant for bitmap data only.  GL_UNPACK_ROW_LENGTHIf greater than zero, GL_UNPACK_ROW_LENGTH defines the number of pixels in a row.  If the first pixel of a row is placed at location p in memory, then the location of the first pixel of the next row is obtained by skipping FILE="eq05_04.gif" POSITION="INLINE" SCALE="FALSE"components or indices, where n is the number of components or indices in a pixel, l is the number of pixels in a row (GL_UNPACK_ROW_LENGTH if it is greater than zero, the width argument to the pixel routine otherwise), a is the value of GL_UNPACK_ALIGNMENT, and s is the size, in bytes, of a single component (if  a < s, then it is as if a = s).  In the case of 1-bit values, the location of the next row is obtained by skipping FILE="eq05_05.gif" POSITION="INLINE" SCALE="FALSE"components or indices.  The word component in this description refers to the nonindex values red, green, blue, alpha, and depth.  Storage format GL_RGB, for example, has three components per pixel: first red, then green, and finally blue.  GL_UNPACK_SKIP_PIXELS and GL_UNPACK_SKIP_ROWSThese values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated simply by incrementing the pointer passed to glDrawPixels, glTexImage1D, glTexImage2D, glBitmap, or glPolygonStipple.  Setting GL_UNPACK_SKIP_PIXELS to i is equivalent to incrementing the pointer by i n components or indices, where n is the number of components or indices in each pixel.  Setting GL_UNPACK_SKIP_ROWS to j is equivalent to incrementing the pointer by j k components or indices, where k is the number of components or indices per row, as computed above in the GL_UNPACK_ROW_LENGTH section.  GL_UNPACK_ALIGNMENTSpecifies the alignment requirements for the start of each pixel row in memory.  The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word alignment), and 8 (rows start on double-word boundaries).  The following table gives the type, initial value, and range of valid values for each of the storage parameters that can be set with glPixelStore.  COLUMNS="4"LEFT="0" WIDTH="144"pnameLEFT="150" WIDTH="63"typeLEFT="220" WIDTH="63"initial valueLEFT="290" WIDTH="72"valid rangeLEFT="0" WIDTH="144"GL_PACK_SWAP_BYTESLEFT="150" WIDTH="63"BooleanLEFT="220" WIDTH="63"falseLEFT="290" WIDTH="72"true or falseLEFT="0" WIDTH="144"GL_PACK_LSB_FIRSTLEFT="150" WIDTH="63"BooleanLEFT="220" WIDTH="63"falseLEFT="290" WIDTH="72"true or falseLEFT="0" WIDTH="144"GL_PACK_ROW_LENGTHLEFT="150" WIDTH="63"integerLEFT="220" WIDTH="63"0LEFT="290" WIDTH="72"[0,name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]')LEFT="0" WIDTH="144"GL_PACK_SKIP_ROWSLEFT="150" WIDTH="63"integerLEFT="220" WIDTH="63"0LEFT="290" WIDTH="72"[0,name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]')LEFT="0" WIDTH="144"GL_PACK_SKIP_PIXELSLEFT="150" WIDTH="63"integerLEFT="220" WIDTH="63"0LEFT="290" WIDTH="72"[0,name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]')LEFT="0" WIDTH="144"GL_PACK_ALIGNMENTLEFT="150" WIDTH="63"integerLEFT="220" WIDTH="63"4LEFT="290" WIDTH="72"1, 2, 4, or 8LEFT="0" WIDTH="144"GL_UNPACK_SWAP_BYTESLEFT="150" WIDTH="63"BooleanLEFT="220" WIDTH="63"falseLEFT="290" WIDTH="72"true or falseLEFT="0" WIDTH="144"GL_UNPACK_LSB_FIRSTLEFT="150" WIDTH="63"BooleanLEFT="220" WIDTH="63"falseLEFT="290" WIDTH="72"true or falseLEFT="0" WIDTH="144"GL_UNPACK_ROW_LENGTHLEFT="150" WIDTH="63"integerLEFT="220" WIDTH="63"0LEFT="290" WIDTH="72"[0,name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]')LEFT="0" WIDTH="144"GL_UNPACK_SKIP_ROWSLEFT="150" WIDTH="63"integerLEFT="220" WIDTH="63"0LEFT="290" WIDTH="72"[0,name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]')LEFT="0" WIDTH="144"GL_UNPACK_SKIP_PIXELSLEFT="150" WIDTH="63"integerLEFT="220" WIDTH="63"0LEFT="290" WIDTH="72"[0,name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]')LEFT="0" WIDTH="144"GL_UNPACK_ALIGNMENTLEFT="150" WIDTH="63"integerLEFT="220" WIDTH="63"4LEFT="290" WIDTH="72"1, 2, 4, or 8glPixelStoref can be used to set any pixel store parameter.  If the parameter type is Boolean, then if param is 0.0, the parameter is false; otherwise it is set to true.  If pname is a integer type parameter, param is rounded to the nearest integer.  Likewise, glPixelStorei can also be used to set any of the pixel store parameters.  Boolean parameters are set to false if param is 0 and true otherwise.  param is converted to floating point before being assigned to real-valued parameters.  LBL="" HELPID=""NOTESThe pixel storage modes in effect when glDrawPixels, glReadPixels, glTexImage1D, glTexImage2D, glBitmap, or glPolygonStipple is placed in a display list control the interpretation of memory data.  The pixel storage modes in effect when a display list is executed are not significant.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if pname is not an accepted value.  GL_INVALID_VALUE is generated if a negative row length, pixel skip, or row skip value is specified, or if alignment is specified as other than 1, 2, 4, or 8.  GL_INVALID_OPERATION is generated if glPixelStore is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_PACK_SWAP_BYTESglGet with argument GL_PACK_LSB_FIRSTglGet with argument GL_PACK_ROW_LENGTHglGet with argument GL_PACK_SKIP_ROWSglGet with argument GL_PACK_SKIP_PIXELSglGet with argument GL_PACK_ALIGNMENTglGet with argument GL_UNPACK_SWAP_BYTESglGet with argument GL_UNPACK_LSB_FIRSTglGet with argument GL_UNPACK_ROW_LENGTHglGet with argument GL_UNPACK_SKIP_ROWSglGet with argument GL_UNPACK_SKIP_PIXELSglGet with argument GL_UNPACK_ALIGNMENTLBL="" HELPID=""SEE ALSOIDREF="23412" TYPE="TITLE""glBitmap", IDREF="41928" TYPE="TITLE""glDrawPixels", IDREF="34580" TYPE="TITLE""glPixelMap", IDREF="38440" TYPE="TITLE""glPixelTransfer", IDREF="20047" TYPE="TITLE""glPixelZoom", IDREF="13142" TYPE="TITLE""glPolygonStipple", IDREF="40261" TYPE="TITLE""glReadPixels", IDREF="40965" TYPE="TITLE""glTexImage1D", IDREF="38642" TYPE="TITLE""glTexImage2D"LBL="" HELPID=""ID="38440"glPixelTransferLBL="" HELPID=""NAMEglPixelTransferf, glPixelTransferi - set pixel transfer modes  LBL="" HELPID=""C SPECIFICATIONvoid glPixelTransferf( GLenum pname, GLfloat param )void glPixelTransferi( GLenum pname, GLint param ) LBL="" HELPID=""PARAMETERSpnameSpecifies the symbolic name of the pixel transfer parameter to be set.  Must be one of the following: GL_MAP_COLOR, GL_MAP_STENCIL, GL_INDEX_SHIFT, GL_INDEX_OFFSET, GL_RED_SCALE, GL_RED_BIAS, GL_GREEN_SCALE, GL_GREEN_BIAS, GL_BLUE_SCALE, GL_BLUE_BIAS, GL_ALPHA_SCALE, GL_ALPHA_BIAS, GL_DEPTH_SCALE, or GL_DEPTH_BIAS.  paramSpecifies the value that pname is set to.   LBL="" HELPID=""DESCRIPTIONglPixelTransfer sets pixel transfer modes that affect the operation of subsequent glDrawPixels, glReadPixels, glCopyPixels, glTexImage1D, and glTexImage2D commands.  The algorithms that are specified by pixel transfer modes operate on pixels after they are read from the frame buffer (glReadPixels and glCopyPixels) or unpacked from client memory (glDrawPixels, glTexImage1D, and glTexImage2D).  Pixel transfer operations happen in the same order, and in the same manner, regardless of the command that resulted in the pixel operation.  Pixel storage modes (see IDREF="39579" TYPE="TITLE""glPixelStore") control the unpacking of pixels being read from client memory, and the packing of pixels being written back into client memory.  Pixel transfer operations handle four fundamental pixel types: color, color index, depth, and stencil.  Color pixels are made up of four floating-point values with unspecified mantissa and exponent sizes, scaled such that 0.0 represents zero intensity and 1.0 represents full intensity.  Color indices comprise a single fixed-point value, with unspecified precision to the right of the binary point.  Depth pixels comprise a single floating-point value, with unspecified mantissa and exponent sizes, scaled such that 0.0 represents the minimum depth buffer value, and 1.0 represents the maximum depth buffer value.  Finally, stencil pixels comprise a single fixed-point value, with unspecified precision to the right of the binary point.  The pixel transfer operations performed on the four basic pixel types are as follows: ColorEach of the four color components is multiplied by a scale factor, then added to a bias factor.  That is, the red component is multiplied by GL_RED_SCALE, then added to GL_RED_BIAS; the green component is multiplied by GL_GREEN_SCALE, then added to GL_GREEN_BIAS; the blue component is multiplied by GL_BLUE_SCALE, then added to GL_BLUE_BIAS; and the alpha component is multiplied by GL_ALPHA_SCALE, then added to GL_ALPHA_BIAS.  After all four color components are scaled and biased, each is clamped to the range [0,1].  All color scale and bias values are specified with glPixelTransfer.  If GL_MAP_COLOR is true, each color component is scaled by the size of the corresponding color-to-color map, then replaced by the contents of that map indexed by the scaled component.  That is, the red component is scaled by GL_PIXEL_MAP_R_TO_R_SIZE, then replaced by the contents of GL_PIXEL_MAP_R_TO_R indexed by itself.  The green component is scaled by GL_PIXEL_MAP_G_TO_G_SIZE, then replaced by the contents of GL_PIXEL_MAP_G_TO_G indexed by itself.  The blue component is scaled by GL_PIXEL_MAP_B_TO_B_SIZE, then replaced by the contents of GL_PIXEL_MAP_B_TO_B indexed by itself.  And the alpha component is scaled by GL_PIXEL_MAP_A_TO_A_SIZE, then replaced by the contents of GL_PIXEL_MAP_A_TO_A indexed by itself.  All components taken from the maps are then clamped to the range [0,1].  GL_MAP_COLOR is specified with glPixelTransfer.  The contents of the various maps are specified with glPixelMap.  Color indexEach color index is shifted left by GL_INDEX_SHIFT bits, filling with zeros any bits beyond the number of fraction bits carried by the fixed-point index.  If GL_INDEX_SHIFT is negative, the shift is to the right, again zero filled.  Then GL_INDEX_OFFSET is added to the index.  GL_INDEX_SHIFT and GL_INDEX_OFFSET are specified with glPixelTransfer.  From this point, operation diverges depending on the required format of the resulting pixels.  If the resulting pixels are to be written to a color index buffer, or if they are being read back to client memory in GL_COLOR_INDEX format, the pixels continue to be treated as indices.  If GL_MAP_COLOR is true, each index is masked by 2n  -  1, where n is GL_PIXEL_MAP_I_TO_I_SIZE, then replaced by the contents of GL_PIXEL_MAP_I_TO_I indexed by the masked value.  GL_MAP_COLOR is specified with glPixelTransfer.  The contents of the index map are specified with glPixelMap.  If the resulting pixels are to be written to an RGBA color buffer, or if they are being read back to client memory in a format other than GL_COLOR_INDEX, the pixels are converted from indices to colors by referencing the four maps GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, and GL_PIXEL_MAP_I_TO_A.  Before being dereferenced, the index is masked by 2n  -  1, where n is GL_PIXEL_MAP_I_TO_R_SIZE for the red map, GL_PIXEL_MAP_I_TO_G_SIZE for the green map, GL_PIXEL_MAP_I_TO_B_SIZE for the blue map, and GL_PIXEL_MAP_I_TO_A_SIZE for the alpha map.  All components taken from the maps are then clamped to the range [0,1].  The contents of the four maps are specified with glPixelMap.  DepthEach depth value is multiplied by GL_DEPTH_SCALE, added to GL_DEPTH_BIAS, then clamped to the range [0,1].  StencilEach index is shifted GL_INDEX_SHIFT bits just as a color index is, then added to GL_INDEX_OFFSET.  If GL_MAP_STENCIL is true, each index is masked by 2n  -  1, where n is GL_PIXEL_MAP_S_TO_S_SIZE, then replaced by the contents of GL_PIXEL_MAP_S_TO_S indexed by the masked value.  The following table gives the type, initial value, and range of valid values for each of the pixel transfer parameters that are set with glPixelTransfer.  COLUMNS="4"LEFT="0" WIDTH="108"pnameLEFT="115" WIDTH="90"typeLEFT="210" WIDTH="72"initial valueLEFT="290" WIDTH="90"valid rangeLEFT="0" WIDTH="108"GL_MAP_COLORLEFT="115" WIDTH="90"BooleanLEFT="210" WIDTH="72"falseLEFT="290" WIDTH="90"true/falseLEFT="0" WIDTH="108"GL_MAP_STENCILLEFT="115" WIDTH="90"BooleanLEFT="210" WIDTH="72"falseLEFT="290" WIDTH="90"true/falseLEFT="0" WIDTH="108"GL_INDEX_SHIFTLEFT="115" WIDTH="90"integerLEFT="210" WIDTH="72"0LEFT="290" WIDTH="90"(-name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]',name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]')LEFT="0" WIDTH="108"GL_INDEX_OFFSETLEFT="115" WIDTH="90"integerLEFT="210" WIDTH="72"0LEFT="290" WIDTH="90"(-name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]',name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]')LEFT="0" WIDTH="108"GL_RED_SCALELEFT="115" WIDTH="90"floatLEFT="210" WIDTH="72"1.0LEFT="290" WIDTH="90"(-name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]',name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]')LEFT="0" WIDTH="108"GL_GREEN_SCALELEFT="115" WIDTH="90"floatLEFT="210" WIDTH="72"1.0LEFT="290" WIDTH="90"(-name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]',name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]')LEFT="0" WIDTH="108"GL_BLUE_SCALELEFT="115" WIDTH="90"floatLEFT="210" WIDTH="72"1.0LEFT="290" WIDTH="90"(-name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]',name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]')LEFT="0" WIDTH="108"GL_ALPHA_SCALELEFT="115" WIDTH="90"floatLEFT="210" WIDTH="72"1.0LEFT="290" WIDTH="90"(-name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]',name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]')LEFT="0" WIDTH="108"GL_DEPTH_SCALELEFT="115" WIDTH="90"floatLEFT="210" WIDTH="72"1.0LEFT="290" WIDTH="90"(-name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]',name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]')LEFT="0" WIDTH="108"GL_RED_BIASLEFT="115" WIDTH="90"floatLEFT="210" WIDTH="72"0.0LEFT="290" WIDTH="90"(-name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]',name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]')LEFT="0" WIDTH="108"GL_GREEN_BIASLEFT="115" WIDTH="90"floatLEFT="210" WIDTH="72"0.0LEFT="290" WIDTH="90"(-name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]',name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]')LEFT="0" WIDTH="108"GL_BLUE_BIASLEFT="115" WIDTH="90"floatLEFT="210" WIDTH="72"0.0LEFT="290" WIDTH="90"(-name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]',name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]')LEFT="0" WIDTH="108"GL_ALPHA_BIASLEFT="115" WIDTH="90"floatLEFT="210" WIDTH="72"0.0LEFT="290" WIDTH="90"(-name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]',name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]')LEFT="0" WIDTH="108"GL_DEPTH_BIASLEFT="115" WIDTH="90"floatLEFT="210" WIDTH="72"0.0LEFT="290" WIDTH="90"(-name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]',name='infin' font=symbol charset=fontspecific code=165 
	TeX='\infty ' descr='[infin]')glPixelTransferf can be used to set any pixel transfer parameter.  If the parameter type is Boolean, 0.0 implies false and any other value implies true.  If pname is an integer parameter, param is rounded to the nearest integer.  Likewise, glPixelTransferi can also be used to set any of the pixel transfer parameters.  Boolean parameters are set to false if param is 0 and true otherwise.  param is converted to floating point before being assigned to real-valued parameters.  LBL="" HELPID=""NOTESIf a glDrawPixels, glReadPixels, glCopyPixels, glTexImage1D, or glTexImage2D command is placed in a display list (see IDREF="28073" TYPE="TITLE""glNewList" and IDREF="37134" TYPE="TITLE""glCallList"), the pixel transfer mode settings in effect when the display list is executed are the ones that are used.  They may be different from the settings when the command was compiled into the display list.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if pname is not an accepted value.  GL_INVALID_OPERATION is generated if glPixelTransfer is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_MAP_COLORglGet with argument GL_MAP_STENCILglGet with argument GL_INDEX_SHIFTglGet with argument GL_INDEX_OFFSETglGet with argument GL_RED_SCALEglGet with argument GL_RED_BIASglGet with argument GL_GREEN_SCALEglGet with argument GL_GREEN_BIASglGet with argument GL_BLUE_SCALEglGet with argument GL_BLUE_BIASglGet with argument GL_ALPHA_SCALEglGet with argument GL_ALPHA_BIASglGet with argument GL_DEPTH_SCALEglGet with argument GL_DEPTH_BIASLBL="" HELPID=""SEE ALSOIDREF="37134" TYPE="TITLE""glCallList", IDREF="25030" TYPE="TITLE""glCopyPixels", IDREF="41928" TYPE="TITLE""glDrawPixels", IDREF="28073" TYPE="TITLE""glNewList", IDREF="34580" TYPE="TITLE""glPixelMap", IDREF="39579" TYPE="TITLE""glPixelStore", IDREF="20047" TYPE="TITLE""glPixelZoom", IDREF="40261" TYPE="TITLE""glReadPixels", IDREF="40965" TYPE="TITLE""glTexImage1D", IDREF="38642" TYPE="TITLE""glTexImage2D"LBL="" HELPID=""ID="20047"glPixelZoomLBL="" HELPID=""NAMEglPixelZoom - specify the pixel zoom factors  LBL="" HELPID=""C SPECIFICATIONvoid glPixelZoom( GLfloat xfactor, GLfloat yfactor ) LBL="" HELPID=""PARAMETERSxfactor, yfactorSpecify the x and y zoom factors for pixel write operations.  LBL="" HELPID=""DESCRIPTIONglPixelZoom specifies values for the x and y zoom factors.  During the execution of glDrawPixels or glCopyPixels, if (xr, yr) is the current raster position, and a given element is in the nth row and mth column of the pixel rectangle, then pixels whose centers are in the rectangle with corners at (xr  +  n ∑xfactor, yr  +  m ∑yfactor) (xr  +  (n+1) ∑xfactor, yr  +  (m+1) ∑yfactor) are candidates for replacement.  Any pixel whose center lies on the bottom or left edge of this rectangular region is also modified.  Pixel zoom factors are not limited to positive values.  Negative zoom factors reflect the resulting image about the current raster position.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glPixelZoom is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_ZOOM_XglGet with argument GL_ZOOM_YLBL="" HELPID=""SEE ALSOIDREF="25030" TYPE="TITLE""glCopyPixels", IDREF="41928" TYPE="TITLE""glDrawPixels"LBL="" HELPID=""ID="29287"glPointSizeLBL="" HELPID=""NAMEglPointSize - specify the diameter of rasterized points  LBL="" HELPID=""C SPECIFICATIONvoid glPointSize( GLfloat size ) LBL="" HELPID=""PARAMETERSsizeSpecifies the diameter of rasterized points.  The default is 1.0.   LBL="" HELPID=""DESCRIPTIONglPointSize specifies the rasterized diameter of both aliased and antialiased points.  Using a point size other than 1.0 has different effects, depending on whether point antialiasing is enabled.  Point antialiasing is controlled by calling glEnable and glDisable with argument GL_POINT_SMOOTH.  If point antialiasing is disabled, the actual size is determined by rounding the supplied size to the nearest integer.  (If the rounding results in the value 0, it is as if the point size were 1.) If the rounded size is odd, then the center point ( x ,  y ) of the pixel fragment that represents the point is computed as FILE="eq05_06.gif" POSITION="INLINE" SCALE="FALSE"where w subscripts indicate window coordinates.  All pixels that lie within the square grid of the rounded size centered at ( x ,  y ) make up the fragment.  If the size is even, the center point is FILE="eq05_07.gif" POSITION="INLINE" SCALE="FALSE"and the rasterized fragment's centers are the half-integer window coordinates within the square of the rounded size centered at ( x ,  y ).  All pixel fragments produced in rasterizing a nonantialiased point are assigned the same associated data, that of the vertex corresponding to the point.  If antialiasing is enabled, then point rasterization produces a fragment for each pixel square that intersects the region lying within the circle having diameter equal to the current point size and centered at the point's ( xw ,  yw ).  The coverage value for each fragment is the window coordinate area of the intersection of the circular region with the corresponding pixel square.  This value is saved and used in the final rasterization step.  The data associated with each fragment is the data associated with the point being rasterized.  Not all sizes are supported when point antialiasing is enabled.  If an unsupported size is requested, the nearest supported size is used.  Only size 1.0 is guaranteed to be supported; others depend on the implementation.  The range of supported sizes and the size difference between supported sizes within the range can be queried by calling glGet with arguments GL_POINT_SIZE_RANGE and GL_POINT_SIZE_GRANULARITY.  LBL="" HELPID=""NOTESThe point size specified by glPointSize is always returned when GL_POINT_SIZE is queried.  Clamping and rounding for aliased and antialiased points have no effect on the specified value.  Non-antialiased point size may be clamped to an implementation-dependent maximum.  Although this maximum cannot be queried, it must be no less than the maximum value for antialiased points, rounded to the nearest integer value.  LBL="" HELPID=""ERRORSGL_INVALID_VALUE is generated if size is less than or equal to zero.  GL_INVALID_OPERATION is generated if glPointSize is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_POINT_SIZEglGet with argument GL_POINT_SIZE_RANGEglGet with argument GL_POINT_SIZE_GRANULARITYglIsEnabled with argument GL_POINT_SMOOTHLBL="" HELPID=""SEE ALSOIDREF="40792" TYPE="TITLE""glEnable", glPointSmoothLBL="" HELPID=""ID="14059"glPolygonModeLBL="" HELPID=""NAMEglPolygonMode - select a polygon rasterization mode  LBL="" HELPID=""C SPECIFICATIONvoid glPolygonMode( GLenum face, GLenum mode ) LBL="" HELPID=""PARAMETERSfaceSpecifies the polygons that mode applies to.  Must be GL_FRONT for front-facing polygons, GL_BACK for back-facing polygons, or GL_FRONT_AND_BACK for front- and back-facing polygons.  modeSpecifies the way polygons will be rasterized.  Accepted values are GL_POINT, GL_LINE, and GL_FILL.  The default is GL_FILL for both front- and back-facing polygons.   LBL="" HELPID=""DESCRIPTIONglPolygonMode controls the interpretation of polygons for rasterization.  face describes which polygons mode applies to: front-facing polygons (GL_FRONT), back-facing polygons (GL_BACK), or both (GL_FRONT_AND_BACK).  The polygon mode affects only the final rasterization of polygons.  In particular, a polygon's vertices are lit and the polygon is clipped and possibly culled before these modes are applied.  Three modes are defined and can be specified in mode: GL_POINTPolygon vertices that are marked as the start of a boundary edge are drawn as points.  Point attributes such as GL_POINT_SIZE and GL_POINT_SMOOTH control the rasterization of the points.  Polygon rasterization attributes other than GL_POLYGON_MODE have no effect.  GL_LINEBoundary edges of the polygon are drawn as line segments.  They are treated as connected line segments for line stippling; the line stipple counter and pattern are not reset between segments (see IDREF="37959" TYPE="TITLE""glLineStipple").  Line attributes such as GL_LINE_WIDTH and GL_LINE_SMOOTH control the rasterization of the lines.  Polygon rasterization attributes other than GL_POLYGON_MODE have no effect.  GL_FILLThe interior of the polygon is filled.  Polygon attributes such as GL_POLYGON_STIPPLE and GL_POLYGON_SMOOTH control the rasterization of the polygon.  LBL="" HELPID=""EXAMPLESTo draw a surface with filled back-facing polygons and outlined front-facing polygons, call glPolygonMode(GL_FRONT, GL_LINE);LBL="" HELPID=""NOTESVertices are marked as boundary or nonboundary with an edge flag.  Edge flags are generated internally by the GL when it decomposes polygons, and they can be set explicitly using glEdgeFlag.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if either face or mode is not an accepted value.  GL_INVALID_OPERATION is generated if glPolygonMode is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_POLYGON_MODELBL="" HELPID=""SEE ALSOIDREF="11415" TYPE="TITLE""glBegin", IDREF="40044" TYPE="TITLE""glEdgeFlag", IDREF="37959" TYPE="TITLE""glLineStipple", IDREF="23427" TYPE="TITLE""glLineWidth", IDREF="29287" TYPE="TITLE""glPointSize", IDREF="13142" TYPE="TITLE""glPolygonStipple"LBL="" HELPID=""ID="13142"glPolygonStippleLBL="" HELPID=""NAMEglPolygonStipple - set the polygon stippling pattern  LBL="" HELPID=""C SPECIFICATIONvoid glPolygonStipple( const GLubyte *mask ) LBL="" HELPID=""PARAMETERSmaskSpecifies a pointer to a 32name='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]'32 stipple pattern that will be unpacked from memory in the same way that glDrawPixels unpacks pixels.   LBL="" HELPID=""DESCRIPTIONPolygon stippling, like line stippling (see IDREF="37959" TYPE="TITLE""glLineStipple"), masks out certain fragments produced by rasterization, creating a pattern.  Stippling is independent of polygon antialiasing.  mask is a pointer to a 32name='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]'32 stipple pattern that is stored in memory just like the pixel data supplied to a glDrawPixels with height and width both equal to 32, a pixel format of GL_COLOR_INDEX, and data type of GL_BITMAP.  That is, the stipple pattern is represented as a 32name='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]'32 array of 1-bit color indices packed in unsigned bytes.  glPixelStore parameters like GL_UNPACK_SWAP_BYTES and GL_UNPACK_LSB_FIRST affect the assembling of the bits into a stipple pattern.  Pixel transfer operations (shift, offset, pixel map) are not applied to the stipple image, however.  Polygon stippling is enabled and disabled with glEnable and glDisable, using argument GL_POLYGON_STIPPLE.  If enabled, a rasterized polygon fragment with window coordinates xw and yw is sent to the next stage of the GL if and only if the (xw  mod 32)th bit in the (yw  mod 32)th row of the stipple pattern is one.  When polygon stippling is disabled, it is as if the stipple pattern were all ones.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glPolygonStipple is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGetPolygonStippleglIsEnabled with argument GL_POLYGON_STIPPLELBL="" HELPID=""SEE ALSOIDREF="41928" TYPE="TITLE""glDrawPixels", IDREF="37959" TYPE="TITLE""glLineStipple", IDREF="39579" TYPE="TITLE""glPixelStore", IDREF="38440" TYPE="TITLE""glPixelTransfer"LBL="" HELPID=""ID="12225"glPushAttribLBL="" HELPID=""NAMEglPushAttrib, glPopAttrib - push and pop the attribute stack  LBL="" HELPID=""C SPECIFICATIONvoid glPushAttrib( GLbitfield mask ) LBL="" HELPID=""PARAMETERSmaskSpecifies a mask that indicates which attributes to save.  Values for mask are listed in the table below.  LBL="" HELPID=""C SPECIFICATIONvoid glPopAttrib( void ) LBL="" HELPID=""DESCRIPTIONglPushAttrib takes one argument, a mask that indicates which groups of state variables to save on the attribute stack.  Symbolic constants are used to set bits in the mask.  mask is typically constructed by ORing several of these constants together.  The special mask GL_ALL_ATTRIB_BITS can be used to save all stackable states.  The symbolic mask constants and their associated GL state are as follows (the second column lists which attributes are saved): GL_ACCUM_BUFFER_BITAccumulation buffer clear valueGL_COLOR_BUFFER_BIT GL_ALPHA_TEST enable bitAlpha test function and reference valueGL_BLEND enable bitBlending source and destination functionsGL_DITHER enable bitGL_DRAW_BUFFER settingGL_LOGIC_OP enable bitLogic op functionColor mode and index mode clear valuesColor mode and index mode writemasksGL_CURRENT_BITCurrent RGBA colorCurrent color indexCurrent normal vectorCurrent texture coordinatesCurrent raster positionGL_CURRENT_RASTER_POSITION_VALID flagRGBA color associated with current raster positionColor index associated with current raster positionTexture coordinates associated with current raster positionGL_EDGE_FLAG flagGL_DEPTH_BUFFER_BIT GL_DEPTH_TEST enable bitDepth buffer test functionDepth buffer clear valueGL_DEPTH_WRITEMASK enable bitGL_ENABLE_BIT GL_ALPHA_TEST flagGL_AUTO_NORMAL flagGL_BLEND flagEnable bits for the user-definable clipping planesGL_COLOR_MATERIALGL_CULL_FACE flagGL_DEPTH_TEST flagGL_DITHER flagGL_FOG flagGL_LIGHTi where 0  <= i<GL_MAX_LIGHTSGL_LIGHTING flagGL_LINE_SMOOTH flagGL_LINE_STIPPLE flagGL_LOGIC_OP flagGL_MAP1_x where x is a map typeGL_MAP2_x where x is a map typeGL_NORMALIZE flagGL_POINT_SMOOTH flagGL_POLYGON_SMOOTH flagGL_POLYGON_STIPPLE flagGL_SCISSOR_TEST flagGL_STENCIL_TEST flagGL_TEXTURE_1D flagGL_TEXTURE_2D flagFlags GL_TEXTURE_GEN_x where x is S, T, R, or QGL_EVAL_BITGL_MAP1_x enable bits, where x is a map typeGL_MAP2_x enable bits, where x is a map type1-D grid endpoints and divisions2-D grid endpoints and divisionsGL_AUTO_NORMAL enable bitGL_FOG_BITGL_FOG enable flagFog colorFog densityLinear fog startLinear fog endFog indexGL_FOG_MODE valueGL_HINT_BITGL_PERSPECTIVE_CORRECTION_HINT settingGL_POINT_SMOOTH_HINT settingGL_LINE_SMOOTH_HINT settingGL_POLYGON_SMOOTH_HINT settingGL_FOG_HINT settingGL_LIGHTING_BITGL_COLOR_MATERIAL enable bitGL_COLOR_MATERIAL_FACE valueColor material parameters that are tracking the current colorAmbient scene colorGL_LIGHT_MODEL_LOCAL_VIEWER valueGL_LIGHT_MODEL_TWO_SIDE settingGL_LIGHTING enable bitEnable bit for each lightAmbient, diffuse, and specular intensity for each lightDirection, position, exponent, and cutoff angle for each lightConstant, linear, and quadratic attenuation factors for each lightAmbient, diffuse, specular, and emissive color for each materialAmbient, diffuse, and specular color indices for each materialSpecular exponent for each materialGL_SHADE_MODEL settingGL_LINE_BITGL_LINE_SMOOTH flagGL_LINE_STIPPLE enable bitLine stipple pattern and repeat counterLine widthGL_LIST_BITGL_LIST_BASE settingGL_PIXEL_MODE_BITGL_RED_BIAS and GL_RED_SCALE settingsGL_GREEN_BIAS and GL_GREEN_SCALE valuesGL_BLUE_BIAS and GL_BLUE_SCALEGL_ALPHA_BIAS and GL_ALPHA_SCALEGL_DEPTH_BIAS and GL_DEPTH_SCALEGL_INDEX_OFFSET and GL_INDEX_SHIFT valuesGL_MAP_COLOR and GL_MAP_STENCIL flagsGL_ZOOM_X and GL_ZOOM_Y factorsGL_READ_BUFFER settingGL_x where x is a pixal map table nameGL_x SIZE where x is a pixal map table nameGL_POINT_BIT GL_POINT_SMOOTH flagPoint sizeGL_POLYGON_BIT GL_CULL_FACE enable bitGL_CULL_FACE_MODE valueGL_FRONT_FACE indicatorGL_POLYGON_MODE settingGL_POLYGON_SMOOTH flagGL_POLYGON_STIPPLE enable bitGL_POLYGON_STIPPLE_BIT Polygon stipple imageGL_SCISSOR_BIT GL_SCISSOR_TEST flagScissor boxGL_STENCIL_BUFFER_BITGL_STENCIL_TEST enable bitStencil function and reference valueStencil value maskStencil fail, pass, and depth buffer pass actionsStencil buffer clear valueStencil buffer writemaskGL_TEXTURE_BITEnable bits for the four texture coordinatesBorder color for each texture imageMinification function for each texture imageMagnification function for each texture imageTexture coordinates and wrap mode for each texture imageColor and mode for each texture environmentEnable bits GL_TEXTURE_GEN_x, x is S, T, R, and QGL_TEXTURE_GEN_MODE setting for S, T, R, and QglTexGen plane equations for S, T, R, and QGL_TRANSFORM_BITCoefficients of the six clipping planesEnable bits for the user-definable clipping planesGL_MATRIX_MODE valueGL_NORMALIZE flagGL_VIEWPORT_BITDepth range (near and far)Viewport origin and extentglPopAttrib restores the values of the state variables saved with the last glPushAttrib command. Those not saved are left unchanged.  It is an error to push attributes onto a full stack, or to pop attributes off an empty stack.  In either case, the error flag is set and no other change is made to GL state.  Initially, the attribute stack is empty.  LBL="" HELPID=""NOTESNot all values for GL state can be saved on the attribute stack.  For example, pixel pack and unpack state, render mode state, and select and feedback state cannot be saved.  The depth of the attribute stack depends on the implementation, but it must be at least 16.  LBL="" HELPID=""ERRORSGL_STACK_OVERFLOW is generated if glPushAttrib is called while the attribute stack is full.  GL_STACK_UNDERFLOW is generated if glPopAttrib is called while the attribute stack is empty.  GL_INVALID_OPERATION is generated if glPushAttrib is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETS glGet with argument GL_ATTRIB_STACK_DEPTH.glGet with argument GL_MAX_ATTRIB_STACK_DEPTH.  LBL="" HELPID=""SEE ALSOIDREF="41087" TYPE="TITLE""glGet", IDREF="29256" TYPE="TITLE""glGetClipPlane", IDREF="19875" TYPE="TITLE""glGetError", IDREF="31252" TYPE="TITLE""glGetLight", IDREF="41449" TYPE="TITLE""glGetMap", IDREF="10464" TYPE="TITLE""glGetMaterial", IDREF="18120" TYPE="TITLE""glGetPixelMap", IDREF="35350" TYPE="TITLE""glGetPolygonStipple", IDREF="35022" TYPE="TITLE""glGetString", IDREF="37804" TYPE="TITLE""glGetTexEnv", IDREF="31539" TYPE="TITLE""glGetTexGen", IDREF="38063" TYPE="TITLE""glGetTexImage", IDREF="24244" TYPE="TITLE""glGetTexLevelParameter", IDREF="26919" TYPE="TITLE""glGetTexParameter", IDREF="31512" TYPE="TITLE""glIsEnabled"LBL="" HELPID=""ID="41698"glPushMatrixLBL="" HELPID=""NAMEglPushMatrix, glPopMatrix - push and pop the current matrix stack  LBL="" HELPID=""C SPECIFICATIONvoid glPushMatrix( void ) LBL="" HELPID=""C SPECIFICATIONvoid glPopMatrix( void ) LBL="" HELPID=""DESCRIPTIONThere is a stack of matrices for each of the matrix modes.  In GL_MODELVIEW mode, the stack depth is at least 32.  In the other two modes, GL_PROJECTION and GL_TEXTURE, the depth is at least 2.  The current matrix in any mode is the matrix on the top of the stack for that mode.  glPushMatrix pushes the current matrix stack down by one, duplicating the current matrix.  That is, after a glPushMatrix call, the matrix on the top of the stack is identical to the one below it.  glPopMatrix pops the current matrix stack, replacing the current matrix with the one below it on the stack.  Initially, each of the stacks contains one matrix, an identity matrix.  It is an error to push a full matrix stack, or to pop a matrix stack that contains only a single matrix.  In either case, the error flag is set and no other change is made to GL state.  LBL="" HELPID=""ERRORSGL_STACK_OVERFLOW is generated if glPushMatrix is called while the current matrix stack is full.  GL_STACK_UNDERFLOW is generated if glPopMatrix is called while the current matrix stack contains only a single matrix.  GL_INVALID_OPERATION is generated if glPushMatrix is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_MATRIX_MODEglGet with argument GL_MODELVIEW_MATRIXglGet with argument GL_PROJECTION_MATRIXglGet with argument GL_TEXTURE_MATRIXglGet with argument GL_MODELVIEW_STACK_DEPTHglGet with argument GL_PROJECTION_STACK_DEPTHglGet with argument GL_TEXTURE_STACK_DEPTHglGet with argument GL_MAX_MODELVIEW_STACK_DEPTHglGet with argument GL_MAX_PROJECTION_STACK_DEPTHglGet with argument GL_MAX_TEXTURE_STACK_DEPTHLBL="" HELPID=""SEE ALSOIDREF="13747" TYPE="TITLE""glFrustum", IDREF="15281" TYPE="TITLE""glLoadIdentity", IDREF="21898" TYPE="TITLE""glLoadMatrix", IDREF="33637" TYPE="TITLE""glMatrixMode", IDREF="17230" TYPE="TITLE""glMultMatrix", IDREF="30307" TYPE="TITLE""glOrtho", IDREF="24094" TYPE="TITLE""glRotate", IDREF="32024" TYPE="TITLE""glScale", IDREF="35419" TYPE="TITLE""glTranslate", IDREF="17575" TYPE="TITLE""glViewport"LBL="" HELPID=""ID="32163"glPushNameLBL="" HELPID=""NAMEglPushName, glPopName - push and pop the name stack  LBL="" HELPID=""C SPECIFICATIONvoid glPushName( GLuint name ) LBL="" HELPID=""PARAMETERSnameSpecifies a name that will be pushed onto the name stack.  LBL="" HELPID=""C SPECIFICATIONvoid glPopName( void ) LBL="" HELPID=""DESCRIPTIONThe name stack is used during selection mode to allow sets of rendering commands to be uniquely identified.  It consists of an ordered set of unsigned integers.  glPushName causes name to be pushed onto the name stack, which is initially empty.  glPopName pops one name off the top of the stack.  It is an error to push a name onto a full stack, or to pop a name off an empty stack.  It is also an error to manipulate the name stack between a call to glBegin and the corresponding call to glEnd.  In any of these cases, the error flag is set and no other change is made to GL state.  The name stack is always empty while the render mode is not GL_SELECT.  Calls to glPushName or glPopName while the render mode is not GL_SELECT are ignored.  LBL="" HELPID=""ERRORSGL_STACK_OVERFLOW is generated if glPushName is called while the name stack is full.  GL_STACK_UNDERFLOW is generated if glPopName is called while the name stack is empty.  GL_INVALID_OPERATION is generated if glPushName or glPopName is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_NAME_STACK_DEPTHglGet with argument GL_MAX_NAME_STACK_DEPTHLBL="" HELPID=""SEE ALSOIDREF="40021" TYPE="TITLE""glInitNames", IDREF="42477" TYPE="TITLE""glLoadName", IDREF="35248" TYPE="TITLE""glRenderMode", IDREF="35181" TYPE="TITLE""glSelectBuffer"LBL="" HELPID=""ID="40922"glRasterPosLBL="" HELPID=""NAMEglRasterPos2d, glRasterPos2f, glRasterPos2i, glRasterPos2s, glRasterPos3d, glRasterPos3f, glRasterPos3i, glRasterPos3s, glRasterPos4d, glRasterPos4f, glRasterPos4i, glRasterPos4s, glRasterPos2dv, glRasterPos2fv, glRasterPos2iv, glRasterPos2sv, glRasterPos3dv, glRasterPos3fv, glRasterPos3iv, glRasterPos3sv, glRasterPos4dv, glRasterPos4fv, glRasterPos4iv, glRasterPos4sv - specify the raster position for pixel operations  LBL="" HELPID=""C SPECIFICATIONvoid glRasterPos2d( GLdouble x, GLdouble y ) void glRasterPos2f( GLfloat x, GLfloat y )void glRasterPos2i( GLint x, GLint y )void glRasterPos2s( GLshort x, GLshort y )void glRasterPos3d( GLdouble x, GLdouble y, Ldouble z )void glRasterPos3f( GLfloat x, GLfloat y, GLfloat z )void glRasterPos3i( GLint x, GLint y, GLint z )void glRasterPos3s( GLshort x, GLshort y, GLshort z )void glRasterPos4d( GLdouble x, GLdouble y, GLdouble z, GLdouble w )void glRasterPos4f( GLfloat x, GLfloat y, GLfloat z, GLfloat w ) void glRasterPos4i( GLint x, GLint y, GLint z, GLint w )void glRasterPos4s( GLshort x, GLshort y GLshort z, GLshort w ) LBL="" HELPID=""PARAMETERSx, y, z, wSpecify the x, y, z, and w object coordinates (if present) for the raster position.  LBL="" HELPID=""C SPECIFICATIONvoid glRasterPos2dv( const GLdouble *v )void glRasterPos2fv( const GLfloat *v )void glRasterPos2iv( const GLint *v )void glRasterPos2sv( const GLshort *v )void glRasterPos3dv( const GLdouble *v )void glRasterPos3fv( const GLfloat *v )void glRasterPos3iv( const GLint *v )void glRasterPos3sv( const GLshort *v )void glRasterPos4dv( const GLdouble *v )void glRasterPos4fv( const GLfloat *v )void glRasterPos4iv( const GLint *v )void glRasterPos4sv( const GLshort *v ) vSpecifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w coordinates, respectively.   LBL="" HELPID=""DESCRIPTIONThe GL maintains a 3-D position in window coordinates.  This position, called the raster position, is maintained with subpixel accuracy.  It is used to position pixel and bitmap write operations.  See IDREF="23412" TYPE="TITLE""glBitmap", IDREF="41928" TYPE="TITLE""glDrawPixels", and IDREF="25030" TYPE="TITLE""glCopyPixels".  The current raster position consists of three window coordinates (x, y, z), a clip coordinate w value, an eye coordinate distance, a valid bit, and associated color data and texture coordinates.  The w coordinate is a clip coordinate, because w is not projected to window coordinates.  glRasterPos4 specifies object coordinates x, y, z, and w explicitly.  glRasterPos3 specifies object coordinate x, y, and z explicitly, while w is implicitly set to one.  glRasterPos2 uses the argument values for x and y while implicitly setting z and w to zero and one.  The object coordinates presented by glRasterPos are treated just like those of a glVertex command: They are transformed by the current modelview and projection matrices and passed to the clipping stage.  If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the GL_CURRENT_RASTER_POSITION_VALID flag is set.  If the vertex is culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.  The current raster position also includes some associated color data and texture coordinates.  If lighting is enabled, then GL_CURRENT_RASTER_COLOR, in RGBA mode, or the GL_CURRENT_RASTER_INDEX, in color index mode, is set to the color produced by the lighting calculation (see IDREF="37552" TYPE="TITLE""glLight", IDREF="19151" TYPE="TITLE""glLightModel", and IDREF="11560" TYPE="TITLE""glShadeModel").  If lighting is disabled, current color (in RGBA mode, state variable GL_CURRENT_COLOR) or color index (in color index mode, state variable GL_CURRENT_INDEX) is used to update the current raster color.  Likewise, GL_CURRENT_RASTER_TEXTURE_COORDS is updated as a function of GL_CURRENT_TEXTURE_COORDS, based on the texture matrix and the texture generation functions (see IDREF="24845" TYPE="TITLE""glTexGen").  Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces GL_CURRENT_RASTER_DISTANCE.  Initially, the current raster position is (0,0,0,1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1,1,1,1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1).  In RGBA mode, GL_CURRENT_RASTER_INDEX is always 1; in color index mode, the current raster RGBA color always maintains its initial value.  LBL="" HELPID=""NOTESThe raster position is modified both by glRasterPos and by glBitmap.  When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to GL state).  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glRasterPos is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_CURRENT_RASTER_POSITIONglGet with argument GL_CURRENT_RASTER_POSITION_VALIDglGet with argument GL_CURRENT_RASTER_DISTANCEglGet with argument GL_CURRENT_RASTER_COLORglGet with argument GL_CURRENT_RASTER_INDEXglGet with argument GL_CURRENT_RASTER_TEXTURE_COORDSLBL="" HELPID=""SEE ALSOIDREF="23412" TYPE="TITLE""glBitmap", IDREF="25030" TYPE="TITLE""glCopyPixels", IDREF="41928" TYPE="TITLE""glDrawPixels", IDREF="37552" TYPE="TITLE""glLight", IDREF="19151" TYPE="TITLE""glLightModel", IDREF="11560" TYPE="TITLE""glShadeModel", IDREF="31124" TYPE="TITLE""glTexCoord", IDREF="24845" TYPE="TITLE""glTexGen", IDREF="32860" TYPE="TITLE""glVertex"LBL="" HELPID=""ID="40151"glReadBufferLBL="" HELPID=""NAMEglReadBuffer - select a color buffer source for pixels  LBL="" HELPID=""C SPECIFICATIONvoid glReadBuffer( GLenum mode ) LBL="" HELPID=""PARAMETERSmodeSpecifies a color buffer.  Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_AUXi, where i is between 0 and GL_AUX_BUFFERS -1.   LBL="" HELPID=""DESCRIPTIONglReadBuffer specifies a color buffer as the source for subsequent glReadPixels and glCopyPixels commands.  mode accepts one of twelve or more predefined values.  (GL_AUX0 through GL_AUX3 are always defined.) In a fully configured system, GL_FRONT, GL_LEFT, and GL_FRONT_LEFT all name the front left buffer, GL_FRONT_RIGHT and GL_RIGHT name the front right buffer, and GL_BACK_LEFT and GL_BACK name the back left buffer.  Nonstereo configurations have only a left buffer, or a front left and a back left buffer if double-buffered.  Single-buffered configurations have only a front buffer, or a front left and a front right buffer if stereo.  It is an error to specify a nonexistent buffer to glReadBuffer.  By default, mode is GL_FRONT in single-buffered configurations, and GL_BACK in double-buffered configurations.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if mode is not one of the twelve (or more) accepted values.  GL_INVALID_OPERATION is generated if mode specifies a buffer that does not exist.  GL_INVALID_OPERATION is generated if glReadBuffer is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_READ_BUFFERLBL="" HELPID=""SEE ALSOIDREF="25030" TYPE="TITLE""glCopyPixels", IDREF="18132" TYPE="TITLE""glDrawBuffer", IDREF="40261" TYPE="TITLE""glReadPixels"LBL="" HELPID=""ID="40261"glReadPixelsLBL="" HELPID=""NAMEglReadPixels - read a block of pixels from the frame buffer  LBL="" HELPID=""C SPECIFICATIONvoid glReadPixels( GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels ) LBL="" HELPID=""PARAMETERSx, ySpecify the window coordinates of the first pixel that is read from the frame buffer.  This location is the lower left corner of a rectangular block of pixels.  width, heightSpecify the dimensions of the pixel rectangle.  width and height of one correspond to a single pixel.  formatSpecifies the format of the pixel data.  The following symbolic values are accepted: GL_COLOR_INDEX, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_RGBA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.  typeSpecifies the data type of the pixel data.  Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, or GL_FLOAT.  pixelsReturns the pixel data.  LBL="" HELPID=""DESCRIPTIONglReadPixels returns pixel data from the frame buffer, starting with the pixel whose lower left corner is at location (x, y), into client memory starting at location pixels.  Several parameters control the processing of the pixel data before it is placed into client memory.  These parameters are set with three commands: glPixelStore, glPixelTransfer, and glPixelMap.  This reference page describes the effects on glReadPixels of most, but not all of the parameters specified by these three commands.  glReadPixels returns values from each pixel with lower left-hand corner at (x + i, y + j) for 0name='le' font=symbol charset=fontspecific code=163 
	TeX='\leq ' descr='[le]'i<width  and 0name='le' font=symbol charset=fontspecific code=163 
	TeX='\leq ' descr='[le]'j<height.  This pixel is said to be the ith pixel in the jth row.  Pixels are returned in row order from the lowest to the highest row, left to right in each row.  format specifies the format for the returned pixel values.  Accepted values for format are as follows: GL_COLOR_INDEXColor indices are read from the color buffer selected by glReadBuffer.  Each index is converted to fixed point, shifted left or right depending on the value and sign of GL_INDEX_SHIFT, and added to GL_INDEX_OFFSET.  If GL_MAP_COLOR is GL_TRUE, indices are replaced by their mappings in the table GL_PIXEL_MAP_I_TO_I.  GL_STENCIL_INDEXStencil values are read from the stencil buffer.  Each index is converted to fixed point, shifted left or right depending on the value and sign of GL_INDEX_SHIFT, and added to GL_INDEX_OFFSET.  If GL_MAP_STENCIL is GL_TRUE, indices are replaced by their mappings in the table GL_PIXEL_MAP_S_TO_S.  GL_DEPTH_COMPONENTDepth values are read from the depth buffer.  Each component is converted to floating point such that the minimum depth value maps to 0.0 and the maximum value maps to 1.0.  Each component is then multiplied by GL_DEPTH_SCALE, added to GL_DEPTH_BIAS, and finally clamped to the range [0,1].  GL_REDGL_GREENGL_BLUEGL_ALPHAGL_RGBGL_RGBAGL_LUMINANCEGL_LUMINANCE_ALPHAProcessing differs depending on whether color buffers store color indices or RGBA color components.  If color indices are stored, they are read from the color buffer selected by glReadBuffer.  Each index is converted to fixed point, shifted left or right depending on the value and sign of GL_INDEX_SHIFT, and added to GL_INDEX_OFFSET.  Indices are then replaced by the red, green, blue, and alpha values obtained by indexing the GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, and GL_PIXEL_MAP_I_TO_A tables.  If RGBA color components are stored in the color buffers, they are read from the color buffer selected by glReadBuffer.  Each color component is converted to floating point such that zero intensity maps to 0.0 and full intensity maps to 1.0.  Each component is then multiplied by GL_c_SCALE and added to GL_c_BIAS, where c is GL_RED, GL_GREEN, GL_BLUE, and GL_ALPHA.  Each component is clamped to the range [0,1].  Finally, if GL_MAP_COLOR is GL_TRUE, each color component c is replaced by its mapping in the table GL_PIXEL_MAP_c_TO_c, where c again is GL_RED, GL_GREEN, GL_BLUE, and GL_ALPHA.  Each component is scaled to the size its corresponding table before the lookup is performed.  Finally, unneeded data is discarded.  For example, GL_RED discards the green, blue, and alpha components, while GL_RGB discards only the alpha component.  GL_LUMINANCE computes a single component value as the sum of the red, green, and blue components, and GL_LUMINANCE_ALPHA does the same, while keeping alpha as a second value.  The shift, scale, bias, and lookup factors described above are all specified by glPixelTransfer.  The lookup table contents themselves are specified by glPixelMap.  The final step involves converting the indices or components to the proper format, as specified by type.  If format is GL_COLOR_INDEX or GL_STENCIL_INDEX and type is not GL_FLOAT, each index is masked with the mask value given in the following table.  If type is GL_FLOAT, then each integer index is converted to single-precision floating-point format.  If format is GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_RGBA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA and type is not GL_FLOAT, each component is multiplied by the multiplier shown in the following table.  If type is GL_FLOAT, then each component is passed as is (or converted to the client's single-precision floating-point format if it is different from the one used by the GL).  COLUMNS="3"LEFT="0" WIDTH="120"typeLEFT="125" WIDTH="120"index maskLEFT="250" WIDTH="120"component conversionLEFT="0" WIDTH="120"GL_UNSIGNED_BYTELEFT="125" WIDTH="120"28 - 1LEFT="250" WIDTH="120"(28 - 1)  cLEFT="0" WIDTH="120"GL_BYTELEFT="125" WIDTH="120"27 - 1LEFT="250" WIDTH="120"[(27 - 1) c - 1] / 2LEFT="0" WIDTH="120"GL_BITMAPLEFT="125" WIDTH="120"1LEFT="250" WIDTH="120"1LEFT="0" WIDTH="120"GL_UNSIGNED_SHORTLEFT="125" WIDTH="120"216 - 1LEFT="250" WIDTH="120"(216 - 1) cLEFT="0" WIDTH="120"GL_SHORTLEFT="125" WIDTH="120"215 - 1LEFT="250" WIDTH="120"[(215 - 1) c - 1] / 2LEFT="0" WIDTH="120"GL_UNSIGNED_INTLEFT="125" WIDTH="120"232 - 1LEFT="250" WIDTH="120"(232 - 1) cLEFT="0" WIDTH="120"GL_INTLEFT="125" WIDTH="120"231 - 1LEFT="250" WIDTH="120"[(231 - 1) c - 1] / 2LEFT="0" WIDTH="120"GL_FLOATLEFT="125" WIDTH="120"noneLEFT="250" WIDTH="120"cReturn values are placed in memory as follows.  If format is GL_COLOR_INDEX, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, or GL_LUMINANCE, a single value is returned and the data for the ith pixel in the jth row is placed in location (j) width + i.  GL_RGB returns three values, GL_RGBA returns four values, and GL_LUMINANCE_ALPHA returns two values for each pixel, with all values corresponding to a single pixel occupying contiguous space in pixels.  Storage parameters set by glPixelStore, such as GL_PACK_SWAP_BYTES and GL_PACK_LSB_FIRST, affect the way that data is written into memory.  See IDREF="39579" TYPE="TITLE""glPixelStore" for a description.  LBL="" HELPID=""NOTESValues for pixels that lie outside the window connected to the current GL context are undefined.  If an error is generated, no change is made to the contents of pixels.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if format or type is not an accepted value.  GL_INVALID_VALUE is generated if either width or height is negative.  GL_INVALID_OPERATION is generated if format is GL_COLOR_INDEX and the color buffers store RGBA color components.  GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and there is no stencil buffer.  GL_INVALID_OPERATION is generated if format is GL_DEPTH_COMPONENT and there is no depth buffer.  GL_INVALID_OPERATION is generated if glReadPixels is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_INDEX_MODELBL="" HELPID=""SEE ALSOIDREF="25030" TYPE="TITLE""glCopyPixels", IDREF="41928" TYPE="TITLE""glDrawPixels", IDREF="34580" TYPE="TITLE""glPixelMap", IDREF="39579" TYPE="TITLE""glPixelStore", IDREF="38440" TYPE="TITLE""glPixelTransfer", IDREF="40151" TYPE="TITLE""glReadBuffer"LBL="" HELPID=""ID="24843"glRectLBL="" HELPID=""NAMEglRectd, glRectf, glRecti, glRects, glRectdv, glRectfv, glRectiv, glRectsv - draw a rectangle  LBL="" HELPID=""C SPECIFICATIONvoid glRectd( GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2 )void glRectf( GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2 )void glRecti( GLint x1, GLint y1, GLint x2, GLint y2 )void glRects( GLshort x1, GLshort y1, GLshort x2, GLshort y2 )LBL="" HELPID=""PARAMETERSx1, y1Specify one vertex of a rectangle.  x2, y2Specify the opposite vertex of the rectangle.  LBL="" HELPID=""C SPECIFICATIONvoid glRectdv( const GLdouble *v1, const GLdouble *v2 )void glRectfv( const GLfloat *v1, const GLfloat *v2 )void glRectiv( const GLint *v1, const GLint *v2 ) void glRectsv( const GLshort *v1, const GLshort *v2 ) LBL="" HELPID=""PARAMETERSv1Specifies a pointer to one vertex of a rectangle.  v2Specifies a pointer to the opposite vertex of the rectangle.  LBL="" HELPID=""DESCRIPTIONglRect supports efficient specification of rectangles as two corner points.  Each rectangle command takes four arguments, organized either as two consecutive pairs of (x,y) coordinates, or as two pointers to arrays, each containing an (x,y) pair.  The resulting rectangle is defined in the z=0 plane.  glRect(x1, y1, x2, y2) is exactly equivalent to the following sequence: glBegin(GL_POLYGON);
glVertex2(x1, y1);
glVertex2(x2, y1);
glVertex2(x2, y2);
glVertex2(x1, y2);
glEnd();Note that if the second vertex is above and to the right of the first vertex, the rectangle is constructed with a counterclockwise winding.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glRect is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""SEE ALSOIDREF="11415" TYPE="TITLE""glBegin", IDREF="32860" TYPE="TITLE""glVertex"LBL="" HELPID=""ID="35248"glRenderModeLBL="" HELPID=""NAMEglRenderMode - set rasterization mode  LBL="" HELPID=""C SPECIFICATIONGLint glRenderMode( GLenum mode ) LBL="" HELPID=""PARAMETERSmodeSpecifies the rasterization mode.  Three values are accepted: GL_RENDER, GL_SELECT, and GL_FEEDBACK.  The default value is GL_RENDER.   LBL="" HELPID=""DESCRIPTIONglRenderMode sets the rasterization mode.  It takes one argument, mode, which can assume one of three predefined values: GL_RENDERRender mode. Primitives are rasterized, producing pixel fragments, which are written into the frame buffer.  This is the normal mode and also the default mode.  GL_SELECT Selection mode.  No pixel fragments are produced, and no change to the frame buffer contents is made.  Instead, a record of the names of primitives that would have been drawn if the render mode was GL_RENDER is returned in a select buffer, which must be created (see IDREF="35181" TYPE="TITLE""glSelectBuffer") before selection mode is entered.  GL_FEEDBACKFeedback mode.  No pixel fragments are produced, and no change to the frame buffer contents is made.  Instead, the coordinates and attributes of vertices that would have been drawn had the render mode been GL_RENDER is returned in a feedback buffer, which must be created (see IDREF="22322" TYPE="TITLE""glFeedbackBuffer") before feedback mode is entered.  The return value of glRenderMode is determined by the render mode at the time glRenderMode is called, rather than by mode.  The values returned for the three render modes are as follows: GL_RENDERZero.  GL_SELECTThe number of hit records transferred to the select buffer.  GL_FEEDBACKThe number of values (not vertices) transferred to the feedback buffer.  Refer to the glSelectBuffer and glFeedbackBuffer reference pages for more details concerning selection and feedback operation.  LBL="" HELPID=""NOTESIf an error is generated, glRenderMode returns zero regardless of the current render mode.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if mode is not one of the three accepted values.  GL_INVALID_OPERATION is generated if glSelectBuffer is called while the render mode is GL_SELECT, or if glRenderMode is called with argument GL_SELECT before glSelectBuffer is called at least once.  GL_INVALID_OPERATION is generated if glFeedbackBuffer is called while the render mode is GL_FEEDBACK, or if glRenderMode is called with argument GL_FEEDBACK before glFeedbackBuffer is called at least once.  GL_INVALID_OPERATION is generated if glRenderMode is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_RENDER_MODELBL="" HELPID=""SEE ALSOIDREF="22322" TYPE="TITLE""glFeedbackBuffer", IDREF="40021" TYPE="TITLE""glInitNames", IDREF="42477" TYPE="TITLE""glLoadName", IDREF="24204" TYPE="TITLE""glPassThrough", IDREF="32163" TYPE="TITLE""glPushName", IDREF="35181" TYPE="TITLE""glSelectBuffer"LBL="" HELPID=""ID="24094"glRotateLBL="" HELPID=""NAMEglRotated, glRotatef - multiply the current matrix by a rotation matrix  LBL="" HELPID=""C SPECIFICATIONvoid glRotated( GLdouble angle, GLdouble x, GLdouble y, GLdouble z ) void glRotatef( GLfloat angle, GLfloat x, GLfloat y, GLfloat z ) LBL="" HELPID=""PARAMETERSangleSpecifies the angle of rotation, in degrees.  x, y, zSpecify the x, y, and z coordinates of a vector, respectively.  LBL="" HELPID=""DESCRIPTIONglRotate computes a matrix that performs a counterclockwise rotation of angle degrees about the vector from the origin through the point (x, y, z).  The current matrix (see IDREF="33637" TYPE="TITLE""glMatrixMode") is multiplied by this rotation matrix, with the product replacing the current matrix.  That is, if M is the current matrix and R is the translation matrix, then M is replaced with MR.  If the matrix mode is either GL_MODELVIEW or GL_PROJECTION, all objects drawn after glRotate is called are rotated.  Use glPushMatrix and glPopMatrix to save and restore the unrotated coordinate system.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glRotate is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_MATRIX_MODEglGet with argument GL_MODELVIEW_MATRIXglGet with argument GL_PROJECTION_MATRIXglGet with argument GL_TEXTURE_MATRIXLBL="" HELPID=""SEE ALSOIDREF="33637" TYPE="TITLE""glMatrixMode", IDREF="17230" TYPE="TITLE""glMultMatrix", IDREF="41698" TYPE="TITLE""glPushMatrix", IDREF="32024" TYPE="TITLE""glScale", IDREF="35419" TYPE="TITLE""glTranslate"LBL="" HELPID=""ID="32024"glScaleLBL="" HELPID=""NAMEglScaled, glScalef - multiply the current matrix by a general scaling matrix  LBL="" HELPID=""C SPECIFICATIONvoid glScaled( GLdouble x, GLdouble y, GLdouble z ) void glScalef( GLfloat x, GLfloat y, GLfloat z ) LBL="" HELPID=""PARAMETERSx, y, zSpecify scale factors along the x, y, and z axes, respectively.  LBL="" HELPID=""DESCRIPTIONglScale produces a general scaling along the x, y, and z axes.  The three arguments indicate the desired scale factors along each of the three axes.  The resulting matrix isFILE="eq0521.gif" POSITION="INLINE" SCALE="FALSE"The current matrix (see IDREF="33637" TYPE="TITLE""glMatrixMode") is multiplied by this scale matrix, with the product replacing the current matrix.  That is, if M is the current matrix and S is the scale matrix, then M is replaced with MS.  If the matrix mode is either GL_MODELVIEW or GL_PROJECTION, all objects drawn after glScale is called are scaled.  Use glPushMatrix and glPopMatrix to save and restore the unscaled coordinate system.  LBL="" HELPID=""NOTESIf scale factors other than 1.0 are applied to the modelview matrix and lighting is enabled, automatic normalization of normals should probably also be enabled (glEnable and glDisable with argument GL_NORMALIZE).  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glScale is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_MATRIX_MODEglGet with argument GL_MODELVIEW_MATRIXglGet with argument GL_PROJECTION_MATRIXglGet with argument GL_TEXTURE_MATRIXLBL="" HELPID=""SEE ALSOIDREF="33637" TYPE="TITLE""glMatrixMode", IDREF="17230" TYPE="TITLE""glMultMatrix", IDREF="41698" TYPE="TITLE""glPushMatrix", IDREF="24094" TYPE="TITLE""glRotate", IDREF="35419" TYPE="TITLE""glTranslate"LBL="" HELPID=""ID="32335"glScissorLBL="" HELPID=""NAMEglScissor - define the scissor box  LBL="" HELPID=""C SPECIFICATIONvoid glScissor( GLint x, GLint y, GLsizei width, GLsizei height ) LBL="" HELPID=""PARAMETERSx, y Specify the lower left corner of the scissor box.  Initially (0,0).  width, heightSpecify the width and height of the scissor box.  When a GL context is first attached to a window, width and height are set to the dimensions of that window.   LBL="" HELPID=""DESCRIPTIONThe glScissor routine defines a rectangle, called the scissor box, in window coordinates.  The first two arguments, x and y, specify the lower left corner of the box.  width and height specify the width and height of the box.  The scissor test is enabled and disabled using glEnable and glDisable with argument GL_SCISSOR_TEST.  While the scissor test is enabled, only pixels that lie within the scissor box can be modified by drawing commands.  Window coordinates have integer values at the shared corners of frame buffer pixels, so glScissor(0,0,1,1) allows only the lower left pixel in the window to be modified, and glScissor(0,0,0,0) disallows modification to all pixels in the window.  When the scissor test is disabled, it is as though the scissor box includes the entire window.  LBL="" HELPID=""ERRORSGL_INVALID_VALUE is generated if either width or height is negative.  GL_INVALID_OPERATION is generated if glScissor is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_SCISSOR_BOXglIsEnabled with argument GL_SCISSOR_TESTLBL="" HELPID=""SEE ALSOIDREF="40792" TYPE="TITLE""glEnable", IDREF="17575" TYPE="TITLE""glViewport"LBL="" HELPID=""ID="35181"glSelectBufferLBL="" HELPID=""NAMEglSelectBuffer - establish a buffer for selection mode values  LBL="" HELPID=""C SPECIFICATIONvoid glSelectBuffer( GLsizei size, GLuint *buffer ) LBL="" HELPID=""PARAMETERSsizeSpecifies the size of buffer.  bufferReturns the selection data.   LBL="" HELPID=""DESCRIPTIONglSelectBuffer has two arguments: buffer is a pointer to an array of unsigned integers, and size indicates the size of the array.  buffer returns values from the name stack (see IDREF="40021" TYPE="TITLE""glInitNames", IDREF="42477" TYPE="TITLE""glLoadName", IDREF="32163" TYPE="TITLE""glPushName") when the rendering mode is GL_SELECT (see IDREF="35248" TYPE="TITLE""glRenderMode").  glSelectBuffer must be issued before selection mode is enabled, and it must not be issued while the rendering mode is GL_SELECT.  Selection is used by a programmer to determine which primitives are drawn into some region of a window.  The region is defined by the current modelview and perspective matrices.  In selection mode, no pixel fragments are produced from rasterization.  Instead, if a primitive intersects the clipping volume defined by the viewing frustum and the user-defined clipping planes, this primitive causes a selection hit.  (With polygons, no hit occurs if the polygon is culled.) When a change is made to the name stack, or when glRenderMode is called, a hit record is copied to buffer if any hits have occurred since the last such event (name stack change or glRenderMode call).  The hit record consists of the number of names in the name stack at the time of the event, followed by the minimum and maximum depth values of all vertices that hit since the previous event, followed by the name stack contents, bottom name first.  Returned depth values are mapped such that the largest unsigned integer value corresponds to window coordinate depth 1.0, and zero corresponds to window coordinate depth 0.0.  An internal index into buffer is reset to zero whenever selection mode is entered.  Each time a hit record is copied into buffer, the index is incremented to point to the cell just past the end of the block of names - that is, to the next available cell.  If the hit record is larger than the number of remaining locations in buffer, as much data as can fit is copied, and the overflow flag is set.  If the name stack is empty when a hit record is copied, that record consists of zero followed by the minimum and maximum depth values.  Selection mode is exited by calling glRenderMode with an argument other than GL_SELECT.  Whenever glRenderMode is called while the render mode is GL_SELECT, it returns the number of hit records copied to buffer, resets the overflow flag and the selection buffer pointer, and initializes the name stack to be empty.  If the overflow bit was set when glRenderMode was called, a negative hit record count is returned.  LBL="" HELPID=""NOTESThe contents of buffer are undefined until glRenderMode is called with an argument other than GL_SELECT. glBegin/glEnd primitives and calls to glRasterPos can result in hits.  LBL="" HELPID=""ERRORSGL_INVALID_VALUE is generated if size is negative.  GL_INVALID_OPERATION is generated if glSelectBuffer is called while the render mode is GL_SELECT, or if glRenderMode is called with argument GL_SELECT before glSelectBuffer is called at least once.  GL_INVALID_OPERATION is generated if glSelectBuffer is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_NAME_STACK_DEPTHLBL="" HELPID=""SEE ALSOIDREF="22322" TYPE="TITLE""glFeedbackBuffer", IDREF="40021" TYPE="TITLE""glInitNames", IDREF="42477" TYPE="TITLE""glLoadName", IDREF="32163" TYPE="TITLE""glPushName", IDREF="35248" TYPE="TITLE""glRenderMode"LBL="" HELPID=""ID="11560"glShadeModelLBL="" HELPID=""NAMEglShadeModel - select flat or smooth shading  LBL="" HELPID=""C SPECIFICATIONvoid glShadeModel( GLenum mode ) LBL="" HELPID=""PARAMETERSmodeSpecifies a symbolic value representing a shading technique.  Accepted values are GL_FLAT and GL_SMOOTH.  The default is GL_SMOOTH.   LBL="" HELPID=""DESCRIPTIONGL primitives can have either flat or smooth shading.  Smooth shading, the default, causes the computed colors of vertices to be interpolated as the primitive is rasterized, typically assigning different colors to each resulting pixel fragment.  Flat shading selects the computed color of just one vertex and assigns it to all the pixel fragments generated by rasterizing a single primitive.  In either case, the computed color of a vertex is the result of lighting, if lighting is enabled, or it is the current color at the time the vertex was specified, if lighting is disabled.  Flat and smooth shading are indistinguishable for points.  Counting vertices and primitives from one starting when glBegin is issued, each flat-shaded line segment i is given the computed color of vertex i + 1, its second vertex.  Counting similarly from one, each flat-shaded polygon is given the computed color of the vertex listed in the following table.  This is the last vertex to specify the polygon in all cases except single polygons, where the first vertex specifies the flat-shaded color.  COLUMNS="2"LEFT="0" WIDTH="180"primitive type of polygon i     LEFT="185" WIDTH="180"vertexLEFT="0" WIDTH="180"Single polygon ( i name='equiv' font=symbol charset=fontspecific code=186
			descr='[equiv]'1)     LEFT="185" WIDTH="180"1LEFT="0" WIDTH="180"Triangle strip  LEFT="185" WIDTH="180"i + 2LEFT="0" WIDTH="180"Triangle fan    LEFT="185" WIDTH="180"i + 2LEFT="0" WIDTH="180"Independent triangle    LEFT="185" WIDTH="180"3iLEFT="0" WIDTH="180"Quad strip      LEFT="185" WIDTH="180"2i + 2LEFT="0" WIDTH="180"Independent quad        LEFT="185" WIDTH="180"4i Flat and smooth shading are specified by glShadeModel with mode set to GL_FLAT and GL_SMOOTH, respectively.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if mode is any value other than GL_FLAT or GL_SMOOTH.  GL_INVALID_OPERATION is generated if glShadeModel is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_SHADE_MODELLBL="" HELPID=""SEE ALSOIDREF="11415" TYPE="TITLE""glBegin", IDREF="18325" TYPE="TITLE""glColor", IDREF="37552" TYPE="TITLE""glLight", IDREF="19151" TYPE="TITLE""glLightModel"LBL="" HELPID=""ID="19234"glStencilFuncLBL="" HELPID=""NAMEglStencilFunc - set function and reference value for stencil testing  LBL="" HELPID=""C SPECIFICATIONvoid glStencilFunc( GLenum func, GLint ref, GLuint mask ) LBL="" HELPID=""PARAMETERSfuncSpecifies the test function.  Eight tokens are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS.  refSpecifies the reference value for the stencil test.  ref is clamped to the range [0,2n - 1], where n is the number of bitplanes in the stencil buffer.  maskSpecifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done.   LBL="" HELPID=""DESCRIPTIONStenciling, like z-buffering, enables and disables drawing on a per-pixel basis.  You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen.  Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.  The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the reference value and the value in the stencil buffer.  The test is enabled by glEnable and glDisable with argument GL_STENCIL.  Actions taken based on the outcome of the stencil test are specified with glStencilOp.  func is a symbolic constant that determines the stencil comparison function.  It accepts one of eight values, shown below.  ref is an integer reference value that is used in the stencil comparison.  It is clamped to the range [0,2n - 1], where n is the number of bitplanes in the stencil buffer.  mask is bitwise ANDed with both the reference value and the stored stencil value, with the ANDed values participating in the comparison.  If stencil represents the value stored in the corresponding stencil buffer location, the following list shows the effect of each comparison function that can be specified by func.  Only if the comparison succeeds is the pixel passed through to the next stage in the rasterization process (see IDREF="36095" TYPE="TITLE""glStencilOp").  All tests treat stencil values as unsigned integers in the range [0,2n - 1], where n is the number of bitplanes in the stencil buffer.  Here are the values accepted by func: GL_NEVERAlways fails.  GL_LESSPasses if ( ref & mask )  < ( stencil & mask ).  GL_LEQUALPasses if ( ref & mask ) name='le' font=symbol charset=fontspecific code=163 
	TeX='\leq ' descr='[le]' ( stencil & mask ).  GL_GREATERPasses if ( ref & mask ) > ( stencil & mask ).  GL_GEQUALPasses if ( ref & mask ) name='ge' font=symbol charset=fontspecific code=179 
	TeX='\geq ' descr='[ge]' ( stencil & mask ).  GL_EQUALPasses if ( ref & mask ) = ( stencil & mask ).  GL_NOTEQUALPasses if ( ref & mask ) name='ne' font=symbol charset=fontspecific code=185 
	TeX='\ne ' descr='[ne]' ( stencil & mask ).  GL_ALWAYSAlways passes.  LBL="" HELPID=""NOTESInitially, the stencil test is disabled.  If there is no stencil buffer, no stencil modification can occur and it is as if the stencil test always passes.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if func is not one of the eight accepted values.  GL_INVALID_OPERATION is generated if glStencilFunc is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_STENCIL_FUNCglGet with argument GL_STENCIL_VALUE_MASKglGet with argument GL_STENCIL_REFglGet with argument GL_STENCIL_BITSglIsEnabled with argument GL_STENCIL_TESTLBL="" HELPID=""SEE ALSOIDREF="19142" TYPE="TITLE""glAlphaFunc", IDREF="11446" TYPE="TITLE""glBlendFunc", IDREF="10076" TYPE="TITLE""glDepthFunc", IDREF="40792" TYPE="TITLE""glEnable", IDREF="31512" TYPE="TITLE""glIsEnabled", IDREF="18729" TYPE="TITLE""glLogicOp", IDREF="36095" TYPE="TITLE""glStencilOp"LBL="" HELPID=""ID="13439"glStencilMaskLBL="" HELPID=""NAMEglStencilMask - control the writing of individual bits in the stencil planes  LBL="" HELPID=""C SPECIFICATIONvoid glStencilMask( GLuint mask ) LBL="" HELPID=""PARAMETERSmaskSpecifies a bit mask to enable and disable writing of individual bits in the stencil planes.  Initially, the mask is all ones.  LBL="" HELPID=""DESCRIPTIONglStencilMask controls the writing of individual bits in the stencil planes.  The least significant n bits of mask, where n is the number of bits in the stencil buffer, specify a mask.  Wherever a one appears in the mask, the corresponding bit in the stencil buffer is made writable.  Where a zero appears, the bit is write-protected.  Initially, all bits are enabled for writing.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glStencilMask is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_STENCIL_WRITEMASKglGet with argument GL_STENCIL_BITSLBL="" HELPID=""SEE ALSOIDREF="42526" TYPE="TITLE""glColorMask", IDREF="31383" TYPE="TITLE""glDepthMask", IDREF="31111" TYPE="TITLE""glIndexMask", IDREF="19234" TYPE="TITLE""glStencilFunc", IDREF="36095" TYPE="TITLE""glStencilOp"LBL="" HELPID=""ID="36095"glStencilOpLBL="" HELPID=""NAMEglStencilOp - set stencil test actions  LBL="" HELPID=""C SPECIFICATIONvoid glStencilOp( GLenum fail, GLenum zfail, GLenum zpass ) LBL="" HELPID=""PARAMETERSfailSpecifies the action to take when the stencil test fails.  Six symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_DECR, and GL_INVERT.  zfailSpecifies stencil action when the stencil test passes, but the depth test fails.  zfail accepts the same symbolic constants as fail.  zpassSpecifies stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled.  zpass accepts the same symbolic constants as fail.   LBL="" HELPID=""DESCRIPTIONStenciling, like z-buffering, enables and disables drawing on a per-pixel basis.  You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen.  Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.  The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the value in the stencil buffer and a reference value.  The test is enabled with glEnable and glDisable calls with argument GL_STENCIL, and controlled with glStencilFunc.  glStencilOp takes three arguments that indicate what happens to the stored stencil value while stenciling is enabled.  If the stencil test fails, no change is made to the pixel's color or depth buffers, and fail specifies what happens to the stencil buffer contents.  The six possible actions are as follows: GL_KEEPKeeps the current value.  GL_ZEROSets the stencil buffer value to zero.  GL_REPLACESets the stencil buffer value to ref, as specified by glStencilFunc.  GL_INCRIncrements the current stencil buffer value.  Clamps to the maximum representable unsigned value.  GL_DECRDecrements the current stencil buffer value.  Clamps to zero.  GL_INVERTBitwise inverts the current stencil buffer value.  Stencil buffer values are treated as unsigned integers.  When incremented and decremented, values are clamped to 0 and 2n - 1, where n is the value returned by querying GL_STENCIL_BITS.  The other two arguments to glStencilOp specify stencil buffer actions should subsequent depth buffer tests succeed (zpass) or fail (zfail).  (See IDREF="10076" TYPE="TITLE""glDepthFunc".) They are specified using the same six symbolic constants as fail.  Note that zfail is ignored when there is no depth buffer, or when the depth buffer is not enabled.  In these cases, fail and zpass specify stencil action when the stencil test fails and passes, respectively.  LBL="" HELPID=""NOTESInitially the stencil test is disabled.  If there is no stencil buffer, no stencil modification can occur and it is as if the stencil tests always pass, regardless of any call to glStencilOp.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated if fail, zfail, or zpass is any value other than the six defined constant values.  GL_INVALID_OPERATION is generated if glStencilOp is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_STENCIL_FAILglGet with argument GL_STENCIL_PASS_DEPTH_PASSglGet with argument GL_STENCIL_PASS_DEPTH_FAILglGet with argument GL_STENCIL_BITSglIsEnabled with argument GL_STENCIL_TESTLBL="" HELPID=""SEE ALSOIDREF="19142" TYPE="TITLE""glAlphaFunc", IDREF="11446" TYPE="TITLE""glBlendFunc", IDREF="10076" TYPE="TITLE""glDepthFunc", IDREF="40792" TYPE="TITLE""glEnable", IDREF="18729" TYPE="TITLE""glLogicOp", IDREF="19234" TYPE="TITLE""glStencilFunc"LBL="" HELPID=""ID="31124"glTexCoordLBL="" HELPID=""NAMEglTexCoord1d, glTexCoord1f, glTexCoord1i, glTexCoord1s, glTexCoord2d, glTexCoord2f, glTexCoord2i, glTexCoord2s, glTexCoord3d, glTexCoord3f, glTexCoord3i, glTexCoord3s, glTexCoord4d, glTexCoord4f, glTexCoord4i, glTexCoord4s, glTexCoord1dv, glTexCoord1fv, glTexCoord1iv, glTexCoord1sv, glTexCoord2dv, glTexCoord2fv, glTexCoord2iv, glTexCoord2sv, glTexCoord3dv, glTexCoord3fv, glTexCoord3iv, glTexCoord3sv, glTexCoord4dv, glTexCoord4fv, glTexCoord4iv, glTexCoord4sv - set the current texture coordinates  LBL="" HELPID=""C SPECIFICATIONvoid glTexCoord1d( GLdouble s )void glTexCoord1f( GLfloat s )void glTexCoord1i( GLint s )void glTexCoord1s( GLshort s ) void glTexCoord2d( GLdouble s, GLdouble t )void glTexCoord2f( GLfloat s, GLfloat t )void glTexCoord2i( GLint s, GLint t )void glTexCoord2s( GLshort s, GLshort t )void glTexCoord3d( GLdouble s, GLdouble t, GLdouble r )void glTexCoord3f( GLfloat s, GLfloat t, GLfloat r )void glTexCoord3i( GLint s, GLint t, GLint r )void glTexCoord3s( GLshort s, GLshort t, GLshort r )void glTexCoord4d( GLdouble s, GLdouble t, GLdouble r, GLdouble q )void glTexCoord4f( GLfloat s, GLfloat t, GLfloat r, GLfloat q )void glTexCoord4i( GLint s, GLint t, GLint r, GLint q )void glTexCoord4s( GLshort s, GLshort t GLshort r, GLshort q ) LBL="" HELPID=""PARAMETERSs, t, r, qSpecify s, t, r, and q  texture coordinates.  Not all parameters are present in all forms of the command.  LBL="" HELPID=""C SPECIFICATIONvoid glTexCoord1dv( const GLdouble *v )void glTexCoord1fv( const GLfloat *v )void glTexCoord1iv( const GLint *v )void glTexCoord1sv( const GLshort *v )void glTexCoord2dv( const GLdouble *v )void glTexCoord2fv( const GLfloat *v )void glTexCoord2iv( const GLint *v )void glTexCoord2sv( const GLshort *v )void glTexCoord3dv( const GLdouble *v )void glTexCoord3fv( const GLfloat *v )void glTexCoord3iv( const GLint *v )void glTexCoord3sv( const GLshort *v )void glTexCoord4dv( const GLdouble *v )void glTexCoord4fv( const GLfloat *v )void glTexCoord4iv( const GLint *v )void glTexCoord4sv( const GLshort *v ) LBL="" HELPID=""PARAMETERSvSpecifies a pointer to an array of one, two, three, or four elements, which in turn specify the s, t, r, and q texture coordinates.  LBL="" HELPID=""DESCRIPTIONThe current texture coordinates are part of the data that is associated with polygon vertices.  They are set with glTexCoord.  glTexCoord specifies texture coordinates in one, two, three, or four dimensions.  glTexCoord1 sets the current texture coordinates to (s, 0, 0, 1); a call to glTexCoord2 sets them to (s, t, 0, 1).  Similarly, glTexCoord3 specifies the texture coordinates as (s, t, r, 1), and glTexCoord4 defines all four components explicitly as (s, t, r, q).  LBL="" HELPID=""NOTESThe current texture coordinates can be updated at any time.  In particular, glTexCoord can be called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_CURRENT_TEXTURE_COORDSLBL="" HELPID=""SEE ALSOIDREF="32860" TYPE="TITLE""glVertex"LBL="" HELPID=""ID="35740"glTexEnvLBL="" HELPID=""NAMEglTexEnvf, glTexEnvi, glTexEnvfv, glTexEnviv - set texture environment parameters  LBL="" HELPID=""C SPECIFICATIONvoid glTexEnvf( GLenum target, GLenum pname, GLfloat param )void glTexEnvi( GLenum target, GLenum pname, GLint param ) LBL="" HELPID=""PARAMETERStargetSpecifies a texture environment.  Must be GL_TEXTURE_ENV.  pnameSpecifies the symbolic name of a single-valued texture environment parameter.  Must be GL_TEXTURE_ENV_MODE.  paramSpecifies a single symbolic constant, one of GL_MODULATE, GL_DECAL, or GL_BLEND.  LBL="" HELPID=""C SPECIFICATIONvoid glTexEnvfv( GLenum target, GLenum pname, const GLfloat *params )void glTexEnviv( GLenum target, GLenum pname, const GLint *params ) LBL="" HELPID=""PARAMETERStargetSpecifies a texture environment.  Must be GL_TEXTURE_ENV.  pnameSpecifies the symbolic name of a texture environment parameter.  Accepted values are GL_TEXTURE_ENV_MODE and GL_TEXTURE_ENV_COLOR.  paramsSpecifies a pointer to an array of parameters: either a single symbolic constant or an RGBA color.   LBL="" HELPID=""DESCRIPTIONA texture environment specifies how texture values are interpreted when a fragment is textured.  target must be GL_TEXTURE_ENV.  pname can be either GL_TEXTURE_ENV_MODE or GL_TEXTURE_ENV_COLOR.  If pname is GL_TEXTURE_ENV_MODE, then params is (or points to) the symbolic name of a texture function.  Three texture functions are defined: GL_MODULATE, GL_DECAL, and GL_BLENDA texture function acts on the fragment to be textured using the texture image value that applies to the fragment (see IDREF="19578" TYPE="TITLE""glTexParameter") and produces an RGBA color for that fragment.  The following table shows how the RGBA color is produced for each of the three texture functions that can be chosen.  C is a triple of color values (RGB) and A is the associated alpha value.  RGBA values extracted from a texture image are in the range [0,1].  The subscript f refers to the incoming fragment, the subscript t to the texture image, the subscript c to the texture environment color, and subscript v indicates a value produced by the texture function.  A texture image can have up to four components per texture element (see IDREF="40965" TYPE="TITLE""glTexImage1D" and IDREF="38642" TYPE="TITLE""glTexImage2D").  In a one-component image, Lt indicates that single component.  A two-component image uses Lt and At.  A three-component image has only a color value, Ct.  A four-component image has both a color value Ct and an alpha value At.  COLUMNS="4"LEFT="0" WIDTH="63"Number of 
componentsLEFT="70" WIDTH="81"texture function
GL_MODULATELEFT="160" WIDTH="99"texture function
GL_DECALLEFT="265" WIDTH="90"texture function
GL_BLENDLEFT="0" WIDTH="63"1LEFT="70" WIDTH="81"Cv = Lt CfAv = AfLEFT="160" WIDTH="99"undefinedLEFT="265" WIDTH="90"Cv = ( 1 - Lt ) Cf + Lt CcAv = AfLEFT="0" WIDTH="63"2LEFT="70" WIDTH="81"Cv = Lt CfAv = At AfLEFT="160" WIDTH="99"undefinedLEFT="265" WIDTH="90"Cv = ( 1 - Lt ) Cf + Lt CcAv = At AfLEFT="0" WIDTH="63"3LEFT="70" WIDTH="81"Cv = Ct CfAv = AfLEFT="160" WIDTH="99"Cv = CtAv = AfLEFT="265" WIDTH="90"undefinedLEFT="0" WIDTH="63"4LEFT="70" WIDTH="81"Cv = Ct
Av = At AfLEFT="160" WIDTH="99"Cv = ( 1 - At ) Cf + At CtAv = AfLEFT="265" WIDTH="90"undefinedIf pname is GL_TEXTURE_ENV_COLOR, params is a pointer to an array that holds an RGBA color consisting of four values.  Integer color components are interpreted linearly such that the most positive integer maps to 1.0, and the most negative integer maps to -1.0.  The values are clamped to the range [0,1] when they are specified.  Cc takes these four values.  GL_TEXTURE_ENV_MODE defaults to GL_MODULATE and GL_TEXTURE_ENV_COLOR defaults to (0,0,0,0).  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated when target or pname is not one of the accepted defined values, or when params should have a defined constant value (based on the value of pname) and does not.  GL_INVALID_OPERATION is generated if glTexEnv is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGetTexEnvLBL="" HELPID=""SEE ALSOIDREF="40965" TYPE="TITLE""glTexImage1D", IDREF="38642" TYPE="TITLE""glTexImage2D", IDREF="19578" TYPE="TITLE""glTexParameter"LBL="" HELPID=""ID="24845"glTexGenLBL="" HELPID=""NAMEglTexGend, glTexGenf, glTexGeni, glTexGendv, glTexGenfv, glTexGeniv - control the generation of texture coordinates  LBL="" HELPID=""C SPECIFICATIONvoid glTexGend( GLenum coord, GLenum pname, GLdouble param )void glTexGenf( GLenum coord, GLenum pname, GLfloat param )void glTexGeni( GLenum coord, GLenum pname, GLint param ) LBL="" HELPID=""PARAMETERScoordSpecifies a texture coordinate.  Must be one of the following: GL_S, GL_T, GL_R, or GL_Q.  pnameSpecifies the symbolic name of the texture-coordinate generation function.  Must be GL_TEXTURE_GEN_MODE.  paramSpecifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, or GL_SPHERE_MAP.  LBL="" HELPID=""C SPECIFICATIONvoid glTexGendv( GLenum coord, GLenum pname, const GLdouble *params )void glTexGenfv( GLenum coord, GLenum pname, const GLfloat *params )void glTexGeniv( GLenum coord, GLenum pname, const GLint *params ) LBL="" HELPID=""PARAMETERScoordSpecifies a texture coordinate.  Must be one of the following: GL_S, GL_T, GL_R, or GL_Q.  pnameSpecifies the symbolic name of the texture-coordinate generation function or function parameters.  Must be GL_TEXTURE_GEN_MODE, GL_OBJECT_PLANE, or GL_EYE_PLANE.  paramsSpecifies a pointer to an array of texture generation parameters.  If pname is GL_TEXTURE_GEN_MODE, then the array must contain a single symbolic constant, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, or GL_SPHERE_MAP.  Otherwise, params holds the coefficients for the texture-coordinate generation function specified by pname.   LBL="" HELPID=""DESCRIPTIONglTexGen selects a texture-coordinate generation function or supplies coefficients for one of the functions.  coord names one of the (s,t,r,q) texture coordinates, and it must be one of these symbols: GL_S, GL_T, GL_R, or GL_Q.  pname must be one of three symbolic constants: GL_TEXTURE_GEN_MODE, GL_OBJECT_PLANE, or GL_EYE_PLANE.  If pname is GL_TEXTURE_GEN_MODE, then params chooses a mode, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, or GL_SPHERE_MAP.  If pname is either GL_OBJECT_PLANE or GL_EYE_PLANE, params contains coefficients for the corresponding texture generation function.  If the texture generation function is GL_OBJECT_LINEAR, the functiong = p1 xo + p2 yo + p3 zo + p4 wois used, where g is the value computed for the coordinate named in coord, p1, p2, p3, and p4 are the four values supplied in params, and xo, yo, zo, and wo are the object coordinates of the vertex.  This function can be used to texture-map terrain using sea level as a reference plane (defined by p1, p2, p3, and p4).  The altitude of a terrain vertex is computed by the GL_OBJECT_LINEAR coordinate generation function as its distance from sea level; that altitude is used to index the texture image to map white snow onto peaks and green grass onto foothills, for example.  If the texture generation function is GL_EYE_LINEAR, the functiong = p1' xe + p2' ye + p3' ze + p4' weis used, where( p1' p2' p3' p4' ) = ( p1 p2 p3 p4 )  M-1and xe, ye, ze, and we are the eye coordinates of the vertex, p1, p2, p3, and p4 are the values supplied in params, and M is the modelview matrix when glTexGen is invoked.  If M is poorly conditioned or singular, texture coordinates generated by the resulting function may be inaccurate or undefined.  Note that the values in params define a reference plane in eye coordinates.  The modelview matrix that is applied to them may not be the same one in effect when the polygon vertices are transformed.  This function establishes a field of texture coordinates that can produce dynamic contour lines on moving objects.  If pname is GL_SPHERE_MAP and  coord is either GL_S or GL_T, s and t texture coordinates are generated as follows.  Let u be the unit vector pointing from the origin to the polygon vertex (in eye coordinates).  Let n prime be the current normal, after transformation to eye coordinates.  Let f  =  ( fx  fy  fz )T be the reflection vector such thatf  =  u  -  2 n' n' T u Finally, letFILE="eq0522.gif" POSITION="INLINE" SCALE="FALSE"Then the values assigned to the s and t texture coordinates areFILE="eq0523.gif" POSITION="INLINE" SCALE="FALSE"FILE="eq0524.gif" POSITION="INLINE" SCALE="FALSE"A texture-coordinate generation function is enabled or disabled using glEnable or glDisable with one of the symbolic texture-coordinate names (GL_TEXTURE_GEN_S, GL_TEXTURE_GEN_T, GL_TEXTURE_GEN_R, or GL_TEXTURE_GEN_Q) as the argument.  When enabled, the specified texture coordinate is computed according to the generating function associated with that coordinate.  When disabled, subsequent vertices take the specified texture coordinate from the current set of texture coordinates.  Initially, all texture generation functions are set to GL_EYE_LINEAR and are disabled.  Both s plane equations are (1,0,0,0), both t plane equations are (0,1,0,0), and all r and q plane equations are (0,0,0,0).  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated when coord or pname is not an accepted defined value, or when pname is GL_TEXTURE_GEN_MODE and params is not an accepted defined value.  GL_INVALID_ENUM is generated when pname is GL_TEXTURE_GEN_MODE, params is GL_SPHERE_MAP, and coord is either GL_R or GL_Q.  GL_INVALID_OPERATION is generated if glTexGen is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGetTexGenglIsEnabled with argument GL_TEXTURE_GEN_SglIsEnabled with argument GL_TEXTURE_GEN_TglIsEnabled with argument GL_TEXTURE_GEN_RglIsEnabled with argument GL_TEXTURE_GEN_QLBL="" HELPID=""SEE ALSOIDREF="35740" TYPE="TITLE""glTexEnv", IDREF="40965" TYPE="TITLE""glTexImage1D", IDREF="38642" TYPE="TITLE""glTexImage2D", IDREF="19578" TYPE="TITLE""glTexParameter"LBL="" HELPID=""ID="40965"glTexImage1DLBL="" HELPID=""NAMEglTexImage1D - specify a one-dimensional texture image  LBL="" HELPID=""C SPECIFICATIONvoid glTexImage1D( GLenum target, GLint level, GLint components, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels ) LBL="" HELPID=""PARAMETERStargetSpecifies the target texture.  Must be GL_TEXTURE_1D.  levelSpecifies the level-of-detail number.  Level 0 is the base image level.  Level n is the nth mipmap reduction image.  componentsSpecifies the number of color components in the texture.  Must be 1, 2, 3, or 4.  widthSpecifies the width of the texture image.  Must be 2n + 2 ( border ) for some integer n.  The height of the texture image is 1.  borderSpecifies the width of the border.  Must be either 0 or 1.  formatSpecifies the format of the pixel data.  The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_RGBA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.  typeSpecifies the data type of the pixel data.  The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, and GL_FLOAT.  pixelsSpecifies a pointer to the image data in memory.   LBL="" HELPID=""DESCRIPTIONTexturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled.  One-dimensional texturing is enabled and disabled using glEnable and glDisable with argument GL_TEXTURE_1D.  Texture images are defined with glTexImage1D.  The arguments describe the parameters of the texture image, such as width, width of the border, level-of-detail number (see IDREF="19578" TYPE="TITLE""glTexParameter"), and number of color components provided.  The last three arguments describe the way the image is represented in memory, and they are identical to the pixel formats used for glDrawPixels.  Data is read from pixels as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on type.  These values are grouped into sets of one, two, three, or four values, depending on format, to form elements.  If type is GL_BITMAP, the data is considered as a string of unsigned bytes (and format must be GL_COLOR_INDEX).  Each data byte is treated as eight 1-bit elements, with bit ordering determined by GL_UNPACK_LSB_FIRST (see IDREF="39579" TYPE="TITLE""glPixelStore").  format determines the composition of each element in pixels.  It can assume one of nine symbolic values: GL_COLOR_INDEXEach element is a single value, a color index.  It is converted to fixed point (with an unspecified number of zero bits to the right of the binary point), shifted left or right depending on the value and sign of GL_INDEX_SHIFT, and added to GL_INDEX_OFFSET (see IDREF="38440" TYPE="TITLE""glPixelTransfer").  The resulting index is converted to a set of color components using the GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, and GL_PIXEL_MAP_I_TO_A tables, and clamped to the range [0,1].  GL_REDEach element is a single red component.  It is converted to floating point and assembled into an RGBA element by attaching 0.0 for green and blue, and 1.0 for alpha.  Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see IDREF="38440" TYPE="TITLE""glPixelTransfer").  GL_GREENEach element is a single green component.  It is converted to floating point and assembled into an RGBA element by attaching 0.0 for red and blue, and 1.0 for alpha.  Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see IDREF="38440" TYPE="TITLE""glPixelTransfer").  GL_BLUEEach element is a single blue component.  It is converted to floating point and assembled into an RGBA element by attaching 0.0 for red and green, and 1.0 for alpha.  Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see IDREF="38440" TYPE="TITLE""glPixelTransfer").  GL_ALPHAEach element is a single red component.  It is converted to floating point and assembled into an RGBA element by attaching 0.0 for red, green, and blue.  Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see IDREF="38440" TYPE="TITLE""glPixelTransfer").  GL_RGBEach element is an RGB triple.  It is converted to floating point and assembled into an RGBA element by attaching 1.0 for alpha.  Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see IDREF="38440" TYPE="TITLE""glPixelTransfer").  GL_RGBAEach element is a complete RGBA element.  It is converted to floating point.  Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see IDREF="38440" TYPE="TITLE""glPixelTransfer").  GL_LUMINANCEEach element is a single luminance value.  It is converted to floating point, then assembled into an RGBA element by replicating the luminance value three times for red, green, and blue and attaching 1.0 for alpha.  Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see IDREF="38440" TYPE="TITLE""glPixelTransfer").  GL_LUMINANCE_ALPHAEach element is a luminance/alpha pair.  It is converted to floating point, then assembled into an RGBA element by replicating the luminance value three times for red, green, and blue.  Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see IDREF="38440" TYPE="TITLE""glPixelTransfer").  A texture image can have up to four components per texture element, depending on components.  A one-component texture image uses only the red component of the RGBA color extracted from pixels.  A two-component image uses the R and A values.  A three-component image uses the R, G, and B values.  A four-component image uses all of the RGBA components.  LBL="" HELPID=""NOTESTexturing has no effect in color index mode.  The texture image can be represented by the same data formats as the pixels in a glDrawPixels command, except that GL_STENCIL_INDEX and GL_DEPTH_COMPONENT cannot be used.  glPixelStore and glPixelTransfer modes affect texture images in exactly the way they affect glDrawPixels.  A texture image with zero width indicates the null texture.  If the null texture is specified for level-of-detail 0, it is as if texturing were disabled.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated when target is not GL_TEXTURE_1D.  GL_INVALID_ENUM is generated when format is not an accepted format constant.  Format constants other than GL_STENCIL_INDEX and GL_DEPTH_COMPONENT are accepted.  GL_INVALID_ENUM is generated when type is not a type constant.  GL_INVALID_ENUM is generated if type is GL_BITMAP and format is not GL_COLOR_INDEX.  GL_INVALID_VALUE is generated if level is less than zero or greater than log2max, where max is the returned value of GL_MAX_TEXTURE_SIZE.  GL_INVALID_VALUE is generated if components is not 1, 2, 3, or 4.  GL_INVALID_VALUE is generated if width is less than zero or greater than 2 + GL_MAX_TEXTURE_SIZE, or if it cannot be represented as 2n + 2(border) for some integer value of n.  GL_INVALID_VALUE is generated if border is not 0 or 1.  GL_INVALID_OPERATION is generated if glTexImage1D is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGetTexImageglIsEnabled with argument GL_TEXTURE_1DLBL="" HELPID=""SEE ALSOIDREF="41928" TYPE="TITLE""glDrawPixels", IDREF="21607" TYPE="TITLE""glFog", IDREF="39579" TYPE="TITLE""glPixelStore", IDREF="38440" TYPE="TITLE""glPixelTransfer", IDREF="35740" TYPE="TITLE""glTexEnv", IDREF="24845" TYPE="TITLE""glTexGen", IDREF="38642" TYPE="TITLE""glTexImage2D", IDREF="19578" TYPE="TITLE""glTexParameter"LBL="" HELPID=""ID="38642"glTexImage2DLBL="" HELPID=""NAMEglTexImage2D - specify a two-dimensional texture image  LBL="" HELPID=""C SPECIFICATIONvoid glTexImage2D( GLenum target, GLint level, GLint components, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels ) LBL="" HELPID=""PARAMETERStargetSpecifies the target texture.  Must be GL_TEXTURE_2D.  levelSpecifies the level-of-detail number.  Level 0 is the base image level.  Level n is the nth mipmap reduction image.  componentsSpecifies the number of color components in the texture.  Must be 1, 2, 3, or 4.  widthSpecifies the width of the texture image.  Must be 2n + 2 ( border ) for some integer n.  heightSpecifies the height of the texture image.  Must be 2m + 2 ( border ) for some integer m.  borderSpecifies the width of the border.  Must be either 0 or 1.  formatSpecifies the format of the pixel data.  The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_RGBA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.  typeSpecifies the data type of the pixel data.  The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, and GL_FLOAT.  pixelsSpecifies a pointer to the image data in memory.   LBL="" HELPID=""DESCRIPTIONTexturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled.  Two-dimensional texturing is enabled and disabled using glEnable and glDisable with argument GL_TEXTURE_2D.  Texture images are defined with glTexImage2D.  The arguments describe the parameters of the texture image, such as height, width, width of the border, level-of-detail number (see IDREF="19578" TYPE="TITLE""glTexParameter"), and number of color components provided.  The last three arguments describe the way the image is represented in memory, and they are identical to the pixel formats used for glDrawPixels.  Data is read from pixels as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on type.  These values are grouped into sets of one, two, three, or four values, depending on format, to form elements.  If type is GL_BITMAP, the data is considered as a string of unsigned bytes (and format must be GL_COLOR_INDEX).  Each data byte is treated as eight 1-bit elements, with bit ordering determined by GL_UNPACK_LSB_FIRST (see IDREF="39579" TYPE="TITLE""glPixelStore").  format determines the composition of each element in pixels.  It can assume one of nine symbolic values: GL_COLOR_INDEXEach element is a single value, a color index.  It is converted to fixed point (with an unspecified number of zero bits to the right of the binary point), shifted left or right depending on the value and sign of GL_INDEX_SHIFT, and added to GL_INDEX_OFFSET (see IDREF="38440" TYPE="TITLE""glPixelTransfer").  The resulting index is converted to a set of color components using the GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, and GL_PIXEL_MAP_I_TO_A tables, and clamped to the range [0,1].  GL_REDEach element is a single red component.  It is converted to floating point and assembled into an RGBA element by attaching 0.0 for green and blue, and 1.0 for alpha.  Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see IDREF="38440" TYPE="TITLE""glPixelTransfer").  GL_GREENEach element is a single green component.  It is converted to floating point and assembled into an RGBA element by attaching 0.0 for red and blue, and 1.0 for alpha.  Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see IDREF="38440" TYPE="TITLE""glPixelTransfer").  GL_BLUEEach element is a single blue component.  It is converted to floating point and assembled into an RGBA element by attaching 0.0 for red and green, and 1.0 for alpha.  Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see IDREF="38440" TYPE="TITLE""glPixelTransfer").  GL_ALPHAEach element is a single red component.  It is converted to floating point and assembled into an RGBA element by attaching 0.0 for red, green, and blue.  Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see IDREF="38440" TYPE="TITLE""glPixelTransfer").  GL_RGBEach element is an RGB triple.  It is converted to floating point and assembled into an RGBA element by attaching 1.0 for alpha.  Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see IDREF="38440" TYPE="TITLE""glPixelTransfer").  GL_RGBAEach element is a complete RGBA element.  It is converted to floating point.  Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see IDREF="38440" TYPE="TITLE""glPixelTransfer").  GL_LUMINANCEEach element is a single luminance value.  It is converted to floating point, then assembled into an RGBA element by replicating the luminance value three times for red, green, and blue and attaching 1.0 for alpha.  Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see IDREF="38440" TYPE="TITLE""glPixelTransfer").  GL_LUMINANCE_ALPHAEach element is a luminance/alpha pair.  It is converted to floating point, then assembled into an RGBA element by replicating the luminance value three times for red, green, and blue.  Each component is then multiplied by the signed scale factor GL_c_SCALE, added to the signed bias GL_c_BIAS, and clamped to the range [0,1] (see IDREF="38440" TYPE="TITLE""glPixelTransfer").  Please refer to the glDrawPixels reference page for a description of the acceptable values for the type parameter.  A texture image can have up to four components per texture element, depending on components.  A one-component texture image uses only the red component of the RGBA color extracted from pixels.  A two-component image uses the R and A values.  A three-component image uses the R, G, and B values.  A four-component image uses all of the RGBA components.  LBL="" HELPID=""NOTESTexturing has no effect in color index mode.  The texture image can be represented by the same data formats as the pixels in a glDrawPixels command, except that GL_STENCIL_INDEX and GL_DEPTH_COMPONENT cannot be used.  glPixelStore and glPixelTransfer modes affect texture images in exactly the way they affect glDrawPixels.  A texture image with zero height or width indicates the null texture.  If the null texture is specified for level-of-detail 0, it is as if texturing were disabled.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated when target is not GL_TEXTURE_2D.  GL_INVALID_ENUM is generated when format is not an accepted format constant.  Format constants other than GL_STENCIL_INDEX and GL_DEPTH_COMPONENT are accepted.  GL_INVALID_ENUM is generated when type is not a type constant.  GL_INVALID_ENUM is generated if type is GL_BITMAP and format is not GL_COLOR_INDEX.  GL_INVALID_VALUE is generated if level is less than zero or greater than log2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE.  GL_INVALID_VALUE is generated if components is not 1, 2, 3, or 4.  GL_INVALID_VALUE is generated if width or height is less than zero or greater than 2 + GL_MAX_TEXTURE_SIZE, or if either cannot be represented as 2k + 2(border) for some integer value of k.  GL_INVALID_VALUE is generated if border is not 0 or 1.  GL_INVALID_OPERATION is generated if glTexImage2D is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGetTexImageglIsEnabled with argument GL_TEXTURE_2DLBL="" HELPID=""SEE ALSOIDREF="41928" TYPE="TITLE""glDrawPixels", IDREF="21607" TYPE="TITLE""glFog", IDREF="39579" TYPE="TITLE""glPixelStore", IDREF="38440" TYPE="TITLE""glPixelTransfer", IDREF="35740" TYPE="TITLE""glTexEnv", IDREF="24845" TYPE="TITLE""glTexGen", IDREF="40965" TYPE="TITLE""glTexImage1D", IDREF="19578" TYPE="TITLE""glTexParameter"LBL="" HELPID=""ID="19578"glTexParameterLBL="" HELPID=""NAMEglTexParameterf, glTexParameteri, glTexParameterfv, glTexParameteriv - set texture parameters  LBL="" HELPID=""C SPECIFICATIONvoid glTexParameterf( GLenum target, GLenum pname, GLfloat param )void glTexParameteri( GLenum target, GLenum pname, GLint param ) LBL="" HELPID=""PARAMETERStargetSpecifies the target texture, which must be either GL_TEXTURE_1D or GL_TEXTURE_2D.  pnameSpecifies the symbolic name of a single-valued texture parameter.  pname can be one of the following: GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_WRAP_S, or GL_TEXTURE_WRAP_T.  paramSpecifies the value of pname.  LBL="" HELPID=""C SPECIFICATIONvoid glTexParameterfv( GLenum target, GLenum pname, const GLfloat *params ) void glTexParameteriv( GLenum target, GLenum pname, const GLint *params ) LBL="" HELPID=""PARAMETERStargetSpecifies the target texture, which must be either GL_TEXTURE_1D or GL_TEXTURE_2D.  pnameSpecifies the symbolic name of a texture parameter.  pname can be one of the following: GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_TEXTURE_BORDER_COLOR.  paramsSpecifies a pointer to an array where the value or values of pname are stored.   LBL="" HELPID=""DESCRIPTIONTexture mapping is a technique that applies an image onto an object's surface as if the image were a decal or cellophane shrink-wrap.  The image is created in texture space, with an (s, t) coordinate system.  A texture is a one- or two-dimensional image and a set of parameters that determine how samples are derived from the image.  glTexParameter assigns the value or values in params to the texture parameter specified as pname.  target defines the target texture, either GL_TEXTURE_1D or GL_TEXTURE_2D.  The following symbols are accepted in pname: GL_TEXTURE_MIN_FILTERThe texture minifying function is used whenever the pixel being textured maps to an area greater than one texture element.  There are six defined minifying functions.  Two of them use the nearest one or nearest four texture elements to compute the texture value.  The other four use mipmaps.  A mipmap is an ordered set of arrays representing the same image at progressively lower resolutions.  If the texture has dimensions 2nname='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]'2m there are  max ( n, m ) + 1  mipmaps.  The first mipmap is the original texture, with dimensions 2nname='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]'2m.  Each subsequent mipmap has dimensions 2 k - 1name='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]'2 l - 1  where 2kname='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]'2l are the dimensions of the previous mipmap, until either k = 0 or l=0.  At that point, subsequent mipmaps have dimension  1name='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]'2 l - 1   or  2 k - 1name='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]'1  until the final mipmap, which has dimension 1name='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]'1.  Mipmaps are defined using glTexImage1D or glTexImage2D with the level-of-detail argument indicating the order of the mipmaps.  Level 0 is the original texture; level  max ( n, m )  is the final 1name='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]'1 mipmap.  params supplies a function for minifying the texture as one of the following: GL_NEARESTReturns the value of the texture element that is nearest (in Manhattan distance) to the center of the pixel being textured.  GL_LINEARReturns the weighted average of the four texture elements that are closest to the center of the pixel being textured.  These can include border texture elements, depending on the values of GL_TEXTURE_WRAP_S and GL_TEXTURE_WRAP_T, and on the exact mapping.  GL_NEAREST_MIPMAP_NEARESTChooses the mipmap that most closely matches the size of the pixel being textured and uses the GL_NEAREST criterion (the texture element nearest to the center of the pixel) to produce a texture value.  GL_LINEAR_MIPMAP_NEARESTChooses the mipmap that most closely matches the size of the pixel being textured and uses the GL_LINEAR criterion (a weighted average of the four texture elements that are closest to the center of the pixel) to produce a texture value.  GL_NEAREST_MIPMAP_LINEARChooses the two mipmaps that most closely match the size of the pixel being textured and uses the GL_NEAREST criterion (the texture element nearest to the center of the pixel) to produce a texture value from each mipmap.  The final texture value is a weighted average of those two values.  GL_LINEAR_MIPMAP_LINEARChooses the two mipmaps that most closely match the size of the pixel being textured and uses the GL_LINEAR criterion (a weighted average of the four texture elements that are closest to the center of the pixel) to produce a texture value from each mipmap.  The final texture value is a weighted average of those two values.   As more texture elements are sampled in the minification process, fewer aliasing artifacts will be apparent.  While the GL_NEAREST and GL_LINEAR minification functions can be faster than the other four, they sample only one or four texture elements to determine the texture value of the pixel being rendered and can produce moire patterns or ragged transitions.  The default value of GL_TEXTURE_MIN_FILTER is GL_NEAREST_MIPMAP_LINEAR.  GL_TEXTURE_MAG_FILTERThe texture magnification function is used when the pixel being textured maps to an area less than or equal to one texture element.  It sets the texture magnification function to either of the following: GL_NEARESTReturns the value of the texture element that is nearest (in Manhattan distance) to the center of the pixel being textured.  GL_LINEAR Returns the weighted average of the four texture elements that are closest to the center of the pixel being textured.  These can include border texture elements, depending on the values of GL_TEXTURE_WRAP_S and GL_TEXTURE_WRAP_T, and on the exact mapping.   GL_NEAREST is generally faster than GL_LINEAR, but it can produce textured images with sharper edges because the transition between texture elements is not as smooth.  The default value of GL_TEXTURE_MAG_FILTER is GL_LINEAR.   GL_TEXTURE_WRAP_SSets the wrap parameter for texture coordinate s to either GL_CLAMP or GL_REPEAT.  GL_CLAMP causes s coordinates to be clamped to the range [0,1] and is useful for preventing wrapping artifacts when mapping a single image onto an object.  GL_REPEAT causes the integer part of the s coordinate to be ignored; the GL uses only the fractional part, thereby creating a repeating pattern.  Border texture elements are accessed only if wrapping is set to GL_CLAMP.  Initially, GL_TEXTURE_WRAP_S is set to GL_REPEAT.   GL_TEXTURE_WRAP_TSets the wrap parameter for texture coordinate t to either GL_CLAMP or GL_REPEAT.  See the discussion under GL_TEXTURE_WRAP_S.  Initially, GL_TEXTURE_WRAP_T is set to GL_REPEAT.  GL_TEXTURE_BORDER_COLORSets a border color.  params contains four values that comprise the RGBA color of the texture border.  Integer color components are interpreted linearly such that the most positive integer maps to 1.0, and the most negative integer maps to -1.0.  The values are clamped to the range [0,1] when they are specified.  Initially, the border color is (0, 0, 0, 0).  LBL="" HELPID=""NOTESSuppose texturing is enabled (by calling glEnable with argument GL_TEXTURE_1D or GL_TEXTURE_2D) and GL_TEXTURE_MIN_FILTER is set to one of the functions that requires a mipmap.  If either the dimensions of the texture images currently defined (with previous calls to glTexImage1D or glTexImage2D) do not follow the proper sequence for mipmaps (described above), or there are fewer texture images defined than are needed, or the set of texture images have differing numbers of texture components, then it is as if texture mapping were disabled.  Linear filtering accesses the four nearest texture elements only in 2-D textures.  In 1-D textures, linear filtering accesses the two nearest texture elements.  LBL="" HELPID=""ERRORSGL_INVALID_ENUM is generated when target or pname is not one of the accepted defined values, or when params should have a defined constant value (based on the value of pname) and does not.  GL_INVALID_OPERATION is generated if glTexParameter is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGetTexParameterglGetTexLevelParameterLBL="" HELPID=""SEE ALSOIDREF="35740" TYPE="TITLE""glTexEnv", IDREF="40965" TYPE="TITLE""glTexImage1D", IDREF="38642" TYPE="TITLE""glTexImage2D", IDREF="24845" TYPE="TITLE""glTexGen"LBL="" HELPID=""ID="35419"glTranslateLBL="" HELPID=""NAMEglTranslated, glTranslatef - multiply the current matrix by a translation matrix  LBL="" HELPID=""C SPECIFICATIONvoid glTranslated( GLdouble x, GLdouble y, GLdouble z )void glTranslatef( GLfloat x, GLfloat y, GLfloat z ) LBL="" HELPID=""PARAMETERSx, y, zSpecify the x, y, and z coordinates of a translation vector.   LBL="" HELPID=""DESCRIPTIONglTranslate moves the coordinate system origin to the point specified by (x,y,z).  The translation vector is used to compute a 4name='times' font=symbol charset=fontspecific code=180
	TeX='\times ' descr='[times]'4 translation matrix:FILE="eq0525.gif" POSITION="INLINE" SCALE="FALSE"The current matrix (see IDREF="33637" TYPE="TITLE""glMatrixMode") is multiplied by this translation matrix, with the product replacing the current matrix.  That is, if M is the current matrix and T is the translation matrix, then M is replaced with MT.  If the matrix mode is either GL_MODELVIEW or GL_PROJECTION, all objects drawn after glTranslate is called are translated.  Use glPushMatrix and glPopMatrix to save and restore the untranslated coordinate system.  LBL="" HELPID=""ERRORSGL_INVALID_OPERATION is generated if glTranslate is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_MATRIX_MODEglGet with argument GL_MODELVIEW_MATRIXglGet with argument GL_PROJECTION_MATRIXglGet with argument GL_TEXTURE_MATRIXLBL="" HELPID=""SEE ALSOIDREF="33637" TYPE="TITLE""glMatrixMode", IDREF="17230" TYPE="TITLE""glMultMatrix", IDREF="41698" TYPE="TITLE""glPushMatrix", IDREF="24094" TYPE="TITLE""glRotate", IDREF="32024" TYPE="TITLE""glScale"LBL="" HELPID=""ID="32860"glVertexLBL="" HELPID=""NAMEglVertex2d, glVertex2f, glVertex2i, glVertex2s, glVertex3d, glVertex3f, glVertex3i, glVertex3s, glVertex4d, glVertex4f, glVertex4i, glVertex4s, glVertex2dv, glVertex2fv, glVertex2iv, glVertex2sv, glVertex3dv, glVertex3fv, glVertex3iv, glVertex3sv, glVertex4dv, glVertex4fv, glVertex4iv, glVertex4sv - specify a vertex  LBL="" HELPID=""C SPECIFICATIONvoid glVertex2d( GLdouble x, GLdouble y )void glVertex2f( GLfloat x, GLfloat y ) void glVertex2i( GLint x, GLint y )void glVertex2s( GLshort x, GLshort y )void glVertex3d( GLdouble x, GLdouble y, GLdouble z )void glVertex3f( GLfloat x, GLfloat y, GLfloat z ) void glVertex3i( GLint x, GLint y, GLint z ) void glVertex3s( GLshort x, GLshort y, GLshort z )void glVertex4d( GLdouble x, GLdouble y, GLdouble z, GLdouble w )void glVertex4f( GLfloat x, GLfloat y, GLfloat z, GLfloat w )void glVertex4i( GLint x, GLint y, GLint z, GLint w )void glVertex4s( GLshort x, GLshort y, GLshort z, GLshort w ) LBL="" HELPID=""PARAMETERSx, y, z, wSpecify x, y, z, and w coordinates of a vertex.  Not all parameters are present in all forms of the command.  LBL="" HELPID=""C SPECIFICATIONvoid glVertex2dv( const GLdouble *v )void glVertex2fv( const GLfloat *v )void glVertex2iv( const GLint *v ) void glVertex2sv( const GLshort *v )void glVertex3dv( const GLdouble *v )void glVertex3fv( const GLfloat *v )void glVertex3iv( const GLint *v )void glVertex3sv( const GLshort *v )void glVertex4dv( const GLdouble *v )void glVertex4fv( const GLfloat *v )void glVertex4iv( const GLint *v )void glVertex4sv( const GLshort *v ) LBL="" HELPID=""PARAMETERSvSpecifies a pointer to an array of two, three, or four elements.  The elements of a two-element array are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.  LBL="" HELPID=""DESCRIPTIONglVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.  The current color, normal, and texture coordinates are associated with the vertex when glVertex is called.  When only x and y are specified, z defaults to 0.0 and w defaults to 1.0.  When x, y, and z are specified, w defaults to 1.0.  LBL="" HELPID=""NOTESInvoking glVertex outside of a glBegin/glEnd pair results in undefined behavior.  LBL="" HELPID=""SEE ALSOIDREF="11415" TYPE="TITLE""glBegin", IDREF="37134" TYPE="TITLE""glCallList", IDREF="18325" TYPE="TITLE""glColor", IDREF="40044" TYPE="TITLE""glEdgeFlag", IDREF="41102" TYPE="TITLE""glEvalCoord", IDREF="14741" TYPE="TITLE""glIndex", IDREF="28170" TYPE="TITLE""glMaterial", IDREF="12825" TYPE="TITLE""glNormal", IDREF="24843" TYPE="TITLE""glRect", IDREF="31124" TYPE="TITLE""glTexCoord"LBL="" HELPID=""ID="17575"glViewportLBL="" HELPID=""NAMEglViewport - set the viewport  LBL="" HELPID=""C SPECIFICATIONvoid glViewport( GLint x, GLint y, GLsizei width, GLsizei height ) LBL="" HELPID=""PARAMETERSx, ySpecify the lower left corner of the viewport rectangle, in pixels.  The default is (0,0).  width, heightSpecify the width and height, respectively, of the viewport.  When a GL context is first attached to a window, width and height are set to the dimensions of that window.  LBL="" HELPID=""DESCRIPTIONglViewport specifies the affine transformation of x and y from normalized device coordinates to window coordinates.  Let (xnd, ynd) be normalized device coordinates.  Then the window coordinates (xw, yw) are computed as follows:FILE="eq0526.gif" POSITION="INLINE" SCALE="FALSE"FILE="eq0527.gif" POSITION="INLINE" SCALE="FALSE"Viewport width and height are silently clamped to a range that depends on the implementation.  This range is queried by calling glGet with argument GL_MAX_VIEWPORT_DIMS.  LBL="" HELPID=""ERRORSGL_INVALID_VALUE is generated if either width or height is negative.  GL_INVALID_OPERATION is generated if glViewport is called between a call to glBegin and the corresponding call to glEnd.  LBL="" HELPID=""ASSOCIATED GETSglGet with argument GL_VIEWPORTglGet with argument GL_MAX_VIEWPORT_DIMSLBL="" HELPID=""SEE ALSOIDREF="22828" TYPE="TITLE""glDepthRange"LBL="6"ID="10211"GLU Reference PagesThis chapter contains the reference pages, in alphabetical order, for all the routines comprising the OpenGL Utility Library (GLU). LBL="" HELPID=""ID="31679"gluBeginCurveLBL="" HELPID=""NAMEgluBeginCurve, gluEndCurve - delimit a NURBS curve definition  LBL="" HELPID=""C SPECIFICATIONvoid gluBeginCurve( GLUnurbsObj *nobj ) void gluEndCurve( GLUnurbsObj *nobj )LBL="" HELPID=""PARAMETERSnobjSpecifies the NURBS object (created with gluNewNurbsRenderer).   LBL="" HELPID=""DESCRIPTIONUse gluBeginCurve to mark the beginning of a NURBS curve definition.  After calling gluBeginCurve, make one or more calls to gluNurbsCurve to define the attributes of the curve.  Exactly one of the calls to gluNurbsCurve must have a curve type of GL_MAP1_VERTEX_3 or GL_MAP1_VERTEX_4.  To mark the end of the NURBS curve definition, call gluEndCurve.  OpenGL evaluators are used to render the NURBS curve as a series of line segments.  Evaluator state is preserved during rendering with glPushAttrib(GL_EVAL_BIT) and glPopAttrib().  See the IDREF="12225" TYPE="TITLE""glPushAttrib" reference page for details on exactly what state these calls preserve.   LBL="" HELPID=""EXAMPLEThe following commands render a textured NURBS curve with normals; texture coordinates and normals are also specified as NURBS curves:  gluBeginCurve(nobj);
   gluNurbsCurve(nobj, ..., GL_MAP1_TEXTURE_COORD_2);
   gluNurbsCurve(nobj, ..., GL_MAP1_NORMAL);
   gluNurbsCurve(nobj, ..., GL_MAP1_VERTEX_4);
gluEndCurve(nobj);LBL="" HELPID=""SEE ALSOIDREF="23137" TYPE="TITLE""gluBeginSurface", IDREF="36073" TYPE="TITLE""gluBeginTrim", IDREF="19636" TYPE="TITLE""gluNewNurbsRenderer", IDREF="21275" TYPE="TITLE""gluNurbsCurve", glPopAttrib, IDREF="12225" TYPE="TITLE""glPushAttrib"LBL="" HELPID=""ID="27257"gluBeginPolygonLBL="" HELPID=""NAMEgluBeginPolygon, gluEndPolygon - delimit a polygon description  LBL="" HELPID=""C SPECIFICATIONvoid gluBeginPolygon( GLUtriangulatorObj *tobj ) void gluEndPolygon( GLUtriangulatorObj *tobj ) LBL="" HELPID=""PARAMETERStobjSpecifies the tessellation object (created with gluNewTess).   LBL="" HELPID=""DESCRIPTIONgluBeginPolygon and gluEndPolygon delimit the definition of a nonconvex polygon.  To define such a polygon, first call gluBeginPolygon.  Then define the contours of the polygon by calling gluTessVertex for each vertex and gluNextContour to start each new contour.  Finally, call gluEndPolygon to signal the end of the definition.  See the IDREF="19130" TYPE="TITLE""gluTessVertex" and IDREF="28369" TYPE="TITLE""gluNextContour" reference pages for more details.  Once gluEndPolygon is called, the polygon is tessellated, and the resulting triangles are described through callbacks.  See IDREF="40802" TYPE="TITLE""gluTessCallback" for descriptions of the callback functions.   LBL="" HELPID=""EXAMPLEA quadrilateral with a triangular hole in it can be described like this:  gluBeginPolygon(tobj);
   gluTessVertex(tobj, v1, v1);
   gluTessVertex(tobj, v2, v2);
   gluTessVertex(tobj, v3, v3);
   gluTessVertex(tobj, v4, v4);
gluNextContour(tobj, GLU_INTERIOR);
   gluTessVertex(tobj, v5, v5);
   gluTessVertex(tobj, v6, v6);
   gluTessVertex(tobj, v7, v7);
gluEndPolygon(tobj);LBL="" HELPID=""SEE ALSOIDREF="15905" TYPE="TITLE""gluNewTess", IDREF="28369" TYPE="TITLE""gluNextContour", IDREF="40802" TYPE="TITLE""gluTessCallback", IDREF="19130" TYPE="TITLE""gluTessVertex"LBL="" HELPID=""ID="23137"gluBeginSurfaceLBL="" HELPID=""NAMEgluBeginSurface, gluEndSurface - delimit a NURBS surface definition  LBL="" HELPID=""C SPECIFICATIONvoid gluBeginSurface( GLUnurbsObj *nobj ) void gluEndSurface( GLUnurbsObj *nobj ) LBL="" HELPID=""PARAMETERSnobjSpecifies the NURBS object (created with gluNewNurbsRenderer).   LBL="" HELPID=""DESCRIPTIONUse gluBeginSurface to mark the beginning of a NURBS surface definition.  After calling gluBeginSurface, make one or more calls to gluNurbsSurface to define the attributes of the surface.  Exactly one of these calls to gluNurbsSurface must have a surface type of GL_MAP2_VERTEX_3 or GL_MAP2_VERTEX_4.  To mark the end of the NURBS surface definition, call gluEndSurface.  Trimming of NURBS surfaces is supported with gluBeginTrim, gluPwlCurve, gluNurbsCurve, and gluEndTrim.  Refer to the gluBeginTrim reference page for details.  OpenGL evaluators are used to render the NURBS surface as a set of polygons.  Evaluator state is preserved during rendering with glPushAttrib(GL_EVAL_BIT) and glPopAttrib().  See the IDREF="12225" TYPE="TITLE""glPushAttrib" reference page for details on exactly what state these calls preserve.   LBL="" HELPID=""EXAMPLEThe following commands render a textured NURBS surface with normals; the texture coordinates and normals are also described as NURBS surfaces:  gluBeginSurface(nobj);
   gluNurbsSurface(nobj, ..., GL_MAP2_TEXTURE_COORD_2);
   gluNurbsSurface(nobj, ..., GL_MAP2_NORMAL);
   gluNurbsSurface(nobj, ..., GL_MAP2_VERTEX_4);
gluEndSurface(nobj);LBL="" HELPID=""SEE ALSOIDREF="31679" TYPE="TITLE""gluBeginCurve", IDREF="36073" TYPE="TITLE""gluBeginTrim", IDREF="19636" TYPE="TITLE""gluNewNurbsRenderer", IDREF="21275" TYPE="TITLE""gluNurbsCurve", IDREF="13247" TYPE="TITLE""gluNurbsSurface", IDREF="15842" TYPE="TITLE""gluPwlCurve"LBL="" HELPID=""ID="36073"gluBeginTrimLBL="" HELPID=""NAMEgluBeginTrim, gluEndTrim - delimit a NURBS trimming loop definition  LBL="" HELPID=""C SPECIFICATIONvoid gluBeginTrim( GLUnurbsObj *nobj ) void gluEndTrim( GLUnurbsObj *nobj ) LBL="" HELPID=""PARAMETERSnobjSpecifies the NURBS object (created with gluNewNurbsRenderer).   LBL="" HELPID=""DESCRIPTIONUse gluBeginTrim to mark the beginning of a trimming loop, and gluEndTrim to mark the end of a trimming loop.  A trimming loop is a set of oriented curve segments (forming a closed curve) that define boundaries of a NURBS surface.  You include these trimming loops in the definition of a NURBS surface, between calls to gluBeginSurface and gluEndSurface.  The definition for a NURBS surface can contain many trimming loops.  For example, if you wrote a definition for a NURBS surface that resembled a rectangle with a hole punched out, the definition would contain two trimming loops.  One loop would define the outer edge of the rectangle;  the other would define the hole punched out of the rectangle.  The definitions of each of these trimming loops would be bracketed by a gluBeginTrim/gluEndTrim pair.  The definition of a single closed trimming loop can consist of multiple curve segments, each described as a piecewise linear curve (see IDREF="15842" TYPE="TITLE""gluPwlCurve") or as a single NURBS curve (see IDREF="21275" TYPE="TITLE""gluNurbsCurve"), or as a combination of both in any order.  The only library calls that can appear in a trimming loop definition (between the calls to gluBeginTrim and gluEndTrim) are gluPwlCurve and gluNurbsCurve.  The area of the NURBS surface that is displayed is the region in the domain to the left of the trimming curve as the curve parameter increases.  Thus, the retained region of the NURBS surface is inside a counterclockwise trimming loop and outside a clockwise trimming loop.  For the rectangle mentioned earlier, the trimming loop for the outer edge of the rectangle runs counterclockwise, while the trimming loop for the punched-out hole runs clockwise.  If you use more than one curve to define a single trimming loop, the curve segments must form a closed loop (that is, the endpoint of each curve must be the starting point of the next curve, and the endpoint of the final curve must be the starting point of the first curve).  If the endpoints of the curve are sufficiently close together but not exactly coincident, they will be coerced to match.  If the endpoints are not sufficiently close, an error results (see IDREF="15103" TYPE="TITLE""gluNurbsCallback").  If a trimming loop definition contains multiple curves, the direction of the curves must be consistent (that is, the inside must be to the left of all of the curves).  Nested trimming loops are legal as long as the curve orientations alternate correctly.  Trimming curves cannot be self-intersecting, nor can they intersect one another (or an error results).  If no trimming information is given for a NURBS surface, the entire surface is drawn.   LBL="" HELPID=""EXAMPLEThis code fragment defines a trimming loop that consists of one piecewise linear curve, and two NURBS curves:  gluBeginTrim(nobj);
   gluPwlCurve(..., GLU_MAP1_TRIM_2);
   gluNurbsCurve(..., GLU_MAP1_TRIM_2);
   gluNurbsCurve(..., GLU_MAP1_TRIM_3);
gluEndTrim(nobj);LBL="" HELPID=""SEE ALSOIDREF="23137" TYPE="TITLE""gluBeginSurface", IDREF="19636" TYPE="TITLE""gluNewNurbsRenderer", IDREF="15103" TYPE="TITLE""gluNurbsCallback", IDREF="21275" TYPE="TITLE""gluNurbsCurve", IDREF="15842" TYPE="TITLE""gluPwlCurve"LBL="" HELPID=""ID="40858"gluBuild1DMipmapsLBL="" HELPID=""NAMEgluBuild1DMipmaps - create 1-D mipmaps  LBL="" HELPID=""C SPECIFICATIONint gluBuild1DMipmaps( GLenum target, GLint components, GLint width, GLenum format, GLenum type, void *data ) LBL="" HELPID=""PARAMETERStargetSpecifies the target texture. Must be GL_TEXTURE_1D.  componentsSpecifies the number of color components in the texture.  Must be 1, 2, 3, or 4.  widthSpecifies the width of the texture image.  formatSpecifies the format of the pixel data.  Must be one of GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_RGBA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.  typeSpecifies the data type for data.  Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, or GL_FLOAT.  dataSpecifies a pointer to the image data in memory.    LBL="" HELPID=""DESCRIPTIONgluBuild1DMipmaps obtains the input image and generates all mipmap images (using gluScaleImage) so that the input image can be used as a mipmapped texture image.  glTexImage1D is then called to load each of the images.  If the width of the input image is not a power of two, then the image is scaled to the nearest power of two before the mipmaps are generated.  A return value of zero indicates success.  Otherwise, a GLU error code is returned (see IDREF="39754" TYPE="TITLE""gluErrorString").  Please refer to the glTexImage1D reference page for a description of the acceptable values for the format parameter. See the IDREF="41928" TYPE="TITLE""glDrawPixels" reference page for a description of the acceptable values for the type parameter.  LBL="" HELPID=""SEE ALSOIDREF="40965" TYPE="TITLE""glTexImage1D", IDREF="13556" TYPE="TITLE""gluBuild2DMipmaps", IDREF="39754" TYPE="TITLE""gluErrorString", IDREF="13316" TYPE="TITLE""gluScaleImage"LBL="" HELPID=""ID="13556"gluBuild2DMipmapsLBL="" HELPID=""NAMEgluBuild2DMipmaps - create 2-D mipmaps  LBL="" HELPID=""C SPECIFICATIONint gluBuild2DMipmaps( GLenum target, GLint components, GLint width, GLint height, GLenum format, GLenum type, void *data ) LBL="" HELPID=""PARAMETERStargetSpecifies the target texture.  Must be GL_TEXTURE_2D.  componentsSpecifies the number of color components in the texture.  Must be 1, 2, 3, or 4.  width, heightSpecifies the width and height, respectively, of the texture image.  formatSpecifies the format of the pixel data.  Must be one of: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_RGBA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.  typeSpecifies the data type for data.  Must be one of: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, or GL_FLOAT.  dataSpecifies a pointer to the image data in memory.    LBL="" HELPID=""DESCRIPTIONgluBuild2DMipmaps obtains the input image and generates all mipmap images (using gluScaleImage) so that the input image can be used as a mipmapped texture image.  glTexImage2D is then called to load each of the images.  If the dimensions of the input image are not powers of two, then the image is scaled so that both the width and height are powers of two before the mipmaps are generated.  A return value of 0 indicates success. Otherwise, a GLU error code is returned (see IDREF="39754" TYPE="TITLE""gluErrorString").  Please refer to the glTexImage1D reference page for a description of the acceptable values for the format parameter. See the IDREF="41928" TYPE="TITLE""glDrawPixels" reference page for a description of the acceptable values for the type parameter.  LBL="" HELPID=""SEE ALSOIDREF="41928" TYPE="TITLE""glDrawPixels", IDREF="40965" TYPE="TITLE""glTexImage1D", IDREF="38642" TYPE="TITLE""glTexImage2D", IDREF="40858" TYPE="TITLE""gluBuild1DMipmaps", IDREF="39754" TYPE="TITLE""gluErrorString", IDREF="13316" TYPE="TITLE""gluScaleImage"LBL="" HELPID=""ID="38149"gluCylinderLBL="" HELPID=""NAMEgluCylinder - draw a cylinder  LBL="" HELPID=""C SPECIFICATIONvoid gluCylinder( GLUquadricObj *qobj, GLdouble baseRadius, GLdouble topRadius, GLdouble height, GLint slices, GLint stacks ) LBL="" HELPID=""PARAMETERSqobjSpecifies the quadrics object (created with gluNewQuadric).  baseRadiusSpecifies the radius of the cylinder at z = 0.  topRadiusSpecifies the radius of the cylinder at z = height.  heightSpecifies the height of the cylinder.  slicesSpecifies the number of subdivisions around the z axis.  stacksSpecifies the number of subdivisions along the z axis.   LBL="" HELPID=""DESCRIPTIONgluCylinder draws a cylinder oriented along the z axis.  The base of the cylinder is placed at  z = 0, and the top at  z = height .  Like a sphere, a cylinder is subdivided around the z axis into slices, and along the z axis into stacks.  Note that if topRadius is set to zero, then this routine will generate a cone.  If the orientation is set to GLU_OUTSIDE (with gluQuadricOrientation), then any generated normals point away from the z axis.  Otherwise, they point toward the z axis.  If texturing is turned on (with gluQuadricTexture), then texture coordinates are generated so that t ranges linearly from 0.0 at z = 0 to 1.0 at z = height, and s ranges from 0.0 at the +y axis, to 0.25 at the +x axis, to 0.5 at the -y axis, to 0.75 at the -x axis, and back to 1.0 at the +y axis.   LBL="" HELPID=""SEE ALSOIDREF="31674" TYPE="TITLE""gluDisk", IDREF="16164" TYPE="TITLE""gluNewQuadric", IDREF="36923" TYPE="TITLE""gluPartialDisk", IDREF="41701" TYPE="TITLE""gluQuadricTexture", IDREF="37189" TYPE="TITLE""gluSphere"LBL="" HELPID=""ID="26595"gluDeleteNurbsRendererLBL="" HELPID=""NAMEgluDeleteNurbsRenderer - destroy a NURBS object  LBL="" HELPID=""C SPECIFICATIONvoid gluDeleteNurbsRenderer( GLUnurbsObj *nobj ) LBL="" HELPID=""PARAMETERSnobjSpecifies the NURBS object to be destroyed (created with gluNewNurbsRenderer).   LBL="" HELPID=""DESCRIPTIONgluDeleteNurbsRenderer destroys the NURBS object and frees any memory used by it.  Once gluDeleteNurbsRenderer has been called, nobj cannot be used again.   LBL="" HELPID=""SEE ALSOIDREF="19636" TYPE="TITLE""gluNewNurbsRenderer"LBL="" HELPID=""ID="23875"gluDeleteQuadricLBL="" HELPID=""NAMEgluDeleteQuadric - destroy a quadrics object  LBL="" HELPID=""C SPECIFICATIONvoid gluDeleteQuadric( GLUquadricObj *state ) LBL="" HELPID=""PARAMETERSstateSpecifies the quadrics object to be destroyed (created with gluNewQuadric).   LBL="" HELPID=""DESCRIPTIONgluDeleteQuadric destroys the quadrics object and frees any memory used by it.  Once gluDeleteQuadric has been called, state cannot be used again.   LBL="" HELPID=""SEE ALSOIDREF="16164" TYPE="TITLE""gluNewQuadric"LBL="" HELPID=""ID="21923"gluDeleteTessLBL="" HELPID=""NAMEgluDeleteTess - destroy a tessellation object  LBL="" HELPID=""C SPECIFICATIONvoid gluDeleteTess( GLUtriangulatorObj *tobj ) LBL="" HELPID=""PARAMETERStobjSpecifies the tessellation object to destroy (created with gluNewTess).   LBL="" HELPID=""DESCRIPTIONgluDeleteTess destroys the indicated tessellation object and frees any memory that it used.   LBL="" HELPID=""SEE ALSOIDREF="27257" TYPE="TITLE""gluBeginPolygon", IDREF="15905" TYPE="TITLE""gluNewTess", IDREF="40802" TYPE="TITLE""gluTessCallback"LBL="" HELPID=""ID="31674"gluDiskLBL="" HELPID=""NAMEgluDisk - draw a disk  LBL="" HELPID=""C SPECIFICATIONvoid gluDisk( GLUquadricObj *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops ) LBL="" HELPID=""PARAMETERSqobjSpecifies the quadrics object (created with gluNewQuadric).  innerRadiusSpecifies the inner radius of the disk (may be 0).  outerRadiusSpecifies the outer radius of the disk.  slicesSpecifies the number of subdivisions around the z axis.  loopsSpecifies the number of concentric rings about the origin into which the disk is subdivided.   LBL="" HELPID=""DESCRIPTIONgluDisk renders a disk on the z = 0  plane.  The disk has a radius of outerRadius, and contains a concentric circular hole with a radius of innerRadius.  If innerRadius is 0, then no hole is generated.  The disk is subdivided around the z axis into slices (like pizza slices), and also about the z axis into rings (as specified by slices and loops, respectively).  With respect to orientation, the +z side of the disk is considered to be "outside" (see IDREF="27542" TYPE="TITLE""gluQuadricOrientation").  This means that if the orientation is set to GLU_OUTSIDE, then any normals generated point along the +z axis.  Otherwise, they point along the -z axis.  If texturing is turned on (with gluQuadricTexture), texture coordinates are generated linearly such that where  r = outerRadius , the value at (r, 0, 0) is (1, 0.5), at (0, r, 0) it is (0.5, 1), at (-r, 0, 0) it is (0, 0.5), and at (0, -r, 0) it is (0.5, 0).   LBL="" HELPID=""SEE ALSOIDREF="38149" TYPE="TITLE""gluCylinder", IDREF="16164" TYPE="TITLE""gluNewQuadric", IDREF="36923" TYPE="TITLE""gluPartialDisk", IDREF="27542" TYPE="TITLE""gluQuadricOrientation", IDREF="41701" TYPE="TITLE""gluQuadricTexture", IDREF="37189" TYPE="TITLE""gluSphere"LBL="" HELPID=""ID="39754"gluErrorStringLBL="" HELPID=""NAMEgluErrorString - produce an error string from an OpenGL or GLU error code  LBL="" HELPID=""C SPECIFICATIONconst GLubyte* gluErrorString( GLenum errorCode ) LBL="" HELPID=""PARAMETERSerrorCodeSpecifies an OpenGL or GLU error code.   LBL="" HELPID=""DESCRIPTIONgluErrorString produces an error string from an OpenGL or GLU error code.  The string is in an ISO Latin 1 format.  For example, gluErrorString(GL_OUT_OF_MEMORY) returns the string out of memory.  The standard GLU error codes are GLU_INVALID_ENUM, GLU_INVALID_VALUE, and GLU_OUT_OF_MEMORY.  Certain other GLU functions can return specialized error codes through callbacks.  Refer to the glGetError reference page for the list of OpenGL error codes.   LBL="" HELPID=""SEE ALSOIDREF="19875" TYPE="TITLE""glGetError", IDREF="15103" TYPE="TITLE""gluNurbsCallback", IDREF="22928" TYPE="TITLE""gluQuadricCallback", IDREF="40802" TYPE="TITLE""gluTessCallback"LBL="" HELPID=""ID="25268"gluGetNurbsPropertyLBL="" HELPID=""NAMEgluGetNurbsProperty - get a NURBS property  LBL="" HELPID=""C SPECIFICATIONvoid gluGetNurbsProperty( GLUnurbsObj *nobj, GLenum property, GLfloat *value ) LBL="" HELPID=""PARAMETERSnobjSpecifies the NURBS object (created with gluNewNurbsRenderer).  propertySpecifies the property whose value is to be fetched.  Valid values are GLU_CULLING, GLU_SAMPLING_TOLERANCE, GLU_DISPLAY_MODE, and GLU_AUTO_LOAD_MATRIX.  valueSpecifies a pointer to the location into which the value of the named property is written.   LBL="" HELPID=""DESCRIPTIONgluGetNurbsProperty is used to retrieve properties stored in a NURBS object.  These properties affect the way that NURBS curves and surfaces are rendered.  Please refer to the gluNurbsProperty reference page for information about what the properties are and what they do.   LBL="" HELPID=""SEE ALSOIDREF="19636" TYPE="TITLE""gluNewNurbsRenderer", IDREF="13274" TYPE="TITLE""gluNurbsProperty"LBL="" HELPID=""ID="34501"gluLoadSamplingMatricesLBL="" HELPID=""NAMEgluLoadSamplingMatrices - load NURBS sampling and culling matrices  LBL="" HELPID=""C SPECIFICATIONvoid gluLoadSamplingMatrices( GLUnurbsObj *nobj, const GLfloat modelMatrix[16], const GLfloat projMatrix[16], const GLint viewport[4]); ) LBL="" HELPID=""PARAMETERSnobjSpecifies the NURBS object (created with gluNewNurbsRenderer).  modelMatrixSpecifies a modelview matrix (as from a glGetFloatv call).  projMatrixSpecifies a projection matrix (as from a glGetFloatv call).  viewport;Specifies a viewport (as from a glGetIntegerv call).   LBL="" HELPID=""DESCRIPTIONgluLoadSamplingMatrices uses modelMatrix, projMatrix, and viewport; to recompute the sampling and culling matrices stored in nobj.  The sampling matrix determines how finely a NURBS curve or surface must be tessellated to satisfy the sampling tolerance (as determined by the GLU_SAMPLING_TOLERANCE property).  The culling matrix is used in deciding if a NURBS curve or surface should be culled before rendering (when the GLU_CULLING property is turned on).  gluLoadSamplingMatrices is necessary only if the GLU_AUTO_LOAD_MATRIX property is turned off (see IDREF="13274" TYPE="TITLE""gluNurbsProperty").  Although it can be convenient to leave the GLU_AUTO_LOAD_MATRIX property turned on, there can be a performance penalty for doing so.  (A round trip to the OpenGL server is needed to fetch the current values of the modelview matrix, projection matrix, and viewport.)  LBL="" HELPID=""SEE ALSOIDREF="25268" TYPE="TITLE""gluGetNurbsProperty", IDREF="19636" TYPE="TITLE""gluNewNurbsRenderer", IDREF="13274" TYPE="TITLE""gluNurbsProperty"LBL="" HELPID=""gluLookAtLBL="" HELPID=""NAMEgluLookAt - define a viewing transformation  LBL="" HELPID=""C SPECIFICATIONvoid gluLookAt( GLdouble eyex, GLdouble eyey, GLdouble eyez, GLdouble centerx, GLdouble centery, GLdouble centerz, GLdouble upx, GLdouble upy, GLdouble upz ) LBL="" HELPID=""PARAMETERSeyex, eyey, eyezSpecifies the position of the eye point.  centerx, centery, centerzSpecifies the position of the reference point.  upx, upy, upzSpecifies the direction of the up vector.   LBL="" HELPID=""DESCRIPTIONgluLookAt creates a viewing matrix derived from an eye point, a reference point indicating the center of the scene, and an up vector.  The matrix maps the reference point to the negative z axis and the eye point to the origin, so that, when a typical projection matrix is used, the center of the scene maps to the center of the viewport.  Similarly, the direction described by the up vector projected onto the viewing plane is mapped to the positive y axis so that it points upward in the viewport.  The up vector must not be parallel to the line of sight from the eye to the reference point.  The matrix generated by gluLookAt postmultiplies the current matrix.   LBL="" HELPID=""SEE ALSOIDREF="13747" TYPE="TITLE""glFrustum", IDREF="25199" TYPE="TITLE""gluPerspective"LBL="" HELPID=""ID="19636"gluNewNurbsRendererLBL="" HELPID=""NAMEgluNewNurbsRenderer - create a NURBS object  LBL="" HELPID=""C SPECIFICATIONGLUnurbsObj* gluNewNurbsRenderer( void )LBL="" HELPID=""DESCRIPTIONgluNewNurbsRenderer creates and returns a pointer to a new NURBS object.  This object must be referred to when calling NURBS rendering and control functions.  A return value of zero means that there is not enough memory to allocate the object.   LBL="" HELPID=""SEE ALSOIDREF="31679" TYPE="TITLE""gluBeginCurve", IDREF="23137" TYPE="TITLE""gluBeginSurface", IDREF="36073" TYPE="TITLE""gluBeginTrim", IDREF="26595" TYPE="TITLE""gluDeleteNurbsRenderer", IDREF="15103" TYPE="TITLE""gluNurbsCallback", IDREF="13274" TYPE="TITLE""gluNurbsProperty"LBL="" HELPID=""ID="16164"gluNewQuadricLBL="" HELPID=""NAMEgluNewQuadric - create a quadrics object  LBL="" HELPID=""C SPECIFICATIONGLUquadricObj* gluNewQuadric( void )LBL="" HELPID=""DESCRIPTIONgluNewQuadric creates and returns a pointer to a new quadrics object.  This object must be referred to when calling quadrics rendering and control functions.  A return value of zero means that there is not enough memory to allocate the object.   LBL="" HELPID=""SEE ALSOIDREF="38149" TYPE="TITLE""gluCylinder", IDREF="23875" TYPE="TITLE""gluDeleteQuadric", IDREF="31674" TYPE="TITLE""gluDisk", IDREF="36923" TYPE="TITLE""gluPartialDisk", IDREF="22928" TYPE="TITLE""gluQuadricCallback", IDREF="19545" TYPE="TITLE""gluQuadricDrawStyle", IDREF="12320" TYPE="TITLE""gluQuadricNormals", IDREF="27542" TYPE="TITLE""gluQuadricOrientation", IDREF="41701" TYPE="TITLE""gluQuadricTexture", IDREF="37189" TYPE="TITLE""gluSphere"LBL="" HELPID=""ID="15905"gluNewTessLBL="" HELPID=""NAMEgluNewTess - create a tessellation object  LBL="" HELPID=""C SPECIFICATIONGLUtriangulatorObj* gluNewTess( void ) LBL="" HELPID=""DESCRIPTIONgluNewTess creates and returns a pointer to a new tessellation object.  This object must be referred to when calling tessellation functions.  A return value of zero means that there is not enough memory to allocate the object.   LBL="" HELPID=""SEE ALSOIDREF="27257" TYPE="TITLE""gluBeginPolygon", IDREF="21923" TYPE="TITLE""gluDeleteTess", IDREF="40802" TYPE="TITLE""gluTessCallback"LBL="" HELPID=""ID="28369"gluNextContourLBL="" HELPID=""NAMEgluNextContour - mark the beginning of another contour  LBL="" HELPID=""C SPECIFICATIONvoid gluNextContour( GLUtriangulatorObj *tobj, GLenum type )LBL="" HELPID=""PARAMETERStobjSpecifies the tessellation object (created with gluNewTess).  typeSpecifies the type of the contour being defined.  Valid values are GLU_EXTERIOR, GLU_INTERIOR, GLU_UNKNOWN, GLU_CCW, and GLU_CW.   LBL="" HELPID=""DESCRIPTIONgluNextContour is used in describing polygons with multiple contours.  After the first contour has been described through a series of gluTessVertex calls, a gluNextContour call indicates that the previous contour is complete and that the next contour is about to begin.  Another series of gluTessVertex calls is then used to describe the new contour.  This process can be repeated until all contours have been described.  type defines what type of contour follows.  The legal contour types are as follows: GLU_EXTERIORAn exterior contour defines an exterior boundary of the polygon.  GLU_INTERIORAn interior contour defines an interior boundary of the polygon (such as a hole).  GLU_UNKNOWNAn unknown contour is analyzed by the library to determine if it is interior or exterior.  GLU_CCW, GLU_CWThe first GLU_CCW or GLU_CW contour defined is considered to be exterior.  All other contours are considered to be exterior if they are oriented in the same direction (clockwise or counterclockwise) as the first contour, and interior if they are not.   If one contour is of type GLU_CCW or GLU_CW, then all contours must be of the same type (if they are not, then all GLU_CCW and GLU_CW contours will be changed to GLU_UNKNOWN).   Note that there is no real difference between the GLU_CCW and GLU_CW contour types.  gluNextContour can be called before the first contour is described to define the type of the first contour.  If gluNextContour is not called before the first contour, then the first contour is marked GLU_EXTERIOR.   LBL="" HELPID=""EXAMPLEA quadrilateral with a triangular hole in it can be described as follows:  gluBeginPolygon(tobj);
   gluTessVertex(tobj, v1, v1);
   gluTessVertex(tobj, v2, v2);
   gluTessVertex(tobj, v3, v3);
   gluTessVertex(tobj, v4, v4);
gluNextContour(tobj, GLU_INTERIOR);
   gluTessVertex(tobj, v5, v5);
   gluTessVertex(tobj, v6, v6);
   gluTessVertex(tobj, v7, v7);
gluEndPolygon(tobj);LBL="" HELPID=""SEE ALSOIDREF="27257" TYPE="TITLE""gluBeginPolygon", IDREF="15905" TYPE="TITLE""gluNewTess", IDREF="40802" TYPE="TITLE""gluTessCallback", IDREF="19130" TYPE="TITLE""gluTessVertex"LBL="" HELPID=""ID="15103"gluNurbsCallbackLBL="" HELPID=""NAMEgluNurbsCallback - define a callback for a NURBS object  LBL="" HELPID=""C SPECIFICATIONvoid gluNurbsCallback( GLUnurbsObj *nobj, GLenum which, void (*fn)( )LBL="" HELPID=""PARAMETERSnobjSpecifies the NURBS object (created with gluNewNurbsRenderer).  whichSpecifies the callback being defined.  The only valid value is GLU_ERROR.  fnSpecifies the function that the callback calls.   LBL="" HELPID=""DESCRIPTIONgluNurbsCallback is used to define a callback to be used by a NURBS object.  If the specified callback is already defined, then it is replaced.  If fn is NULL, then any existing callback is erased.  The one legal callback is GLU_ERROR: GLU_ERRORThe error function is called when an error is encountered.  Its single argument is of type GLenum, and it indicates the specific error that occurred.  There are 37 errors unique to NURBS named GLU_NURBS_ERROR1 through GLU_NURBS_ERROR37.  Character strings describing these errors can be retrieved with gluErrorString.   LBL="" HELPID=""SEE ALSOIDREF="39754" TYPE="TITLE""gluErrorString", IDREF="19636" TYPE="TITLE""gluNewNurbsRenderer"LBL="" HELPID=""ID="21275"gluNurbsCurveLBL="" HELPID=""NAMEgluNurbsCurve - define the shape of a NURBS curve  LBL="" HELPID=""C SPECIFICATIONvoid gluNurbsCurve( GLUnurbsObj *nobj, GLint nknots, GLfloat *knot, GLint stride, GLfloat *ctlarray, GLint order, GLenum type ) LBL="" HELPID=""PARAMETERSnobjSpecifies the NURBS object (created with gluNewNurbsRenderer).  nknotsSpecifies the number of knots in knot.  nknots equals the number of control points plus the order.  knotSpecifies an array of nknots nondecreasing knot values.  strideSpecifies the offset (as a number of single-precision floating-point values) between successive curve control points.  ctlarraySpecifies a pointer to an array of control points.  The coordinates must agree with type, specified below.  orderSpecifies the order of the NURBS curve.  order equals degree + 1, hence a cubic curve has an order of 4.  typeSpecifies the type of the curve.  If this curve is defined within a gluBeginCurve/gluEndCurve pair, then the type can be any of the valid one-dimensional evaluator types (such as GL_MAP1_VERTEX_3 or GL_MAP1_COLOR_4).  Between a gluBeginTrim/gluEndTrim pair, the only valid types are GLU_MAP1_TRIM_2 and GLU_MAP1_TRIM_3.   LBL="" HELPID=""DESCRIPTIONUse gluNurbsCurve to describe a NURBS curve.  When gluNurbsCurve appears between a gluBeginCurve/gluEndCurve pair, it is used to describe a curve to be rendered.  Positional, texture, and color coordinates are associated by presenting each as a separate gluNurbsCurve between a gluBeginCurve/gluEndCurve pair.  No more than one call to gluNurbsCurve for each of color, position, and texture data can be made within a single gluBeginCurve/gluEndCurve pair.  Exactly one call must be made to describe the position of the curve (a type of GL_MAP1_VERTEX_3 or GL_MAP1_VERTEX_4).  When gluNurbsCurve appears between a gluBeginTrim/gluEndTrim pair, it is used to describe a trimming curve on a NURBS surface.  If type is GLU_MAP1_TRIM_2, then it describes a curve in two-dimensional (u and v) parameter space.  If it is GLU_MAP1_TRIM_3, then it describes a curve in two-dimensional homogeneous (u, v, and w) parameter space.  See the IDREF="36073" TYPE="TITLE""gluBeginTrim" reference page for more discussion about trimming curves.   LBL="" HELPID=""EXAMPLEThe following commands render a textured NURBS curve with normals:  gluBeginCurve(nobj);
   gluNurbsCurve(nobj, ..., GL_MAP1_TEXTURE_COORD_2);
   gluNurbsCurve(nobj, ..., GL_MAP1_NORMAL);
   gluNurbsCurve(nobj, ..., GL_MAP1_VERTEX_4);
gluEndCurve(nobj);LBL="" HELPID=""SEE ALSOIDREF="31679" TYPE="TITLE""gluBeginCurve", IDREF="36073" TYPE="TITLE""gluBeginTrim", IDREF="19636" TYPE="TITLE""gluNewNurbsRenderer", IDREF="15842" TYPE="TITLE""gluPwlCurve"LBL="" HELPID=""ID="13274"gluNurbsPropertyLBL="" HELPID=""NAMEgluNurbsProperty - set a NURBS property  LBL="" HELPID=""C SPECIFICATIONvoid gluNurbsProperty( GLUnurbsObj *nobj, GLenum property, GLfloat value )LBL="" HELPID=""PARAMETERSnobjSpecifies the NURBS object (created with gluNewNurbsRenderer).  propertySpecifies the property to be set.  Valid values are GLU_SAMPLING_TOLERANCE, GLU_DISPLAY_MODE, GLU_CULLING, and GLU_AUTO_LOAD_MATRIX.  valueSpecifies the value to which to set the indicated property.   LBL="" HELPID=""DESCRIPTIONgluNurbsProperty is used to control properties stored in a NURBS object.  These properties affect the way that a NURBS curve is rendered.  The legal values for property are as follows: GLU_SAMPLING_TOLERANCEvalue specifies the maximum length, in pixels, of line segments or edges of polygons used to render NURBS curves or surfaces.  The NURBS code is conservative when rendering a curve or surface, so the actual length can be somewhat shorter.  The default value is 50.0 pixels.  GLU_DISPLAY_MODEvalue defines how a NURBS surface should be rendered.  value can be set to GLU_FILL, GLU_OUTLINE_POLYGON, or GLU_OUTLINE_PATCH.  When set to GLU_FILL, the surface is rendered as a set of polygons.  GLU_OUTLINE_POLYGON instructs the NURBS library to draw only the outlines of the polygons created by tessellation.  GLU_OUTLINE_PATCH causes just the outlines of patches and trim curves defined by the user to be drawn.  The default value is GLU_FILL.  GLU_CULLINGvalue is a Boolean value that, when set to GL_TRUE, indicates that a NURBS curve should be discarded prior to tessellation if its control points lie outside the current viewport.  The default is GL_FALSE (because a NURBS curve cannot fall entirely within the convex hull of its control points).  GLU_AUTO_LOAD_MATRIXvalue is a Boolean value.  When set to GL_TRUE, the NURBS code downloads the projection matrix, the modelview matrix, and the viewport from the OpenGL server to compute sampling and culling matrices for each NURBS curve that is rendered.  Sampling and culling matrices are required to determine the tesselation of a NURBS surface into line segments or polygons and to cull a NURBS surface if it lies outside of the viewport.  If this mode is set to GL_FALSE, then the user needs to provide a projection matrix, a modelview matrix, and a viewport for the NURBS renderer to use to construct sampling and culling matrices.  This can be done with the gluLoadSamplingMatrices function.  The default for this mode is GL_TRUE.  Changing this mode from GL_TRUE to GL_FALSE does not affect the sampling and culling matrices until gluLoadSamplingMatrices is called.   LBL="" HELPID=""SEE ALSOIDREF="25268" TYPE="TITLE""gluGetNurbsProperty", IDREF="34501" TYPE="TITLE""gluLoadSamplingMatrices", IDREF="19636" TYPE="TITLE""gluNewNurbsRenderer"LBL="" HELPID=""ID="13247"gluNurbsSurfaceLBL="" HELPID=""NAMEgluNurbsSurface - define the shape of a NURBS surface  LBL="" HELPID=""C SPECIFICATIONvoid gluNurbsSurface( GLUnurbsObj *nobj, GLint sknot_count, GLfloat *sknot, GLint tknot_count, GLfloat *tknot, GLint s_stride, GLint t_stride, GLfloat *ctlarray, GLint sorder, GLint torder, GLenum type ) LBL="" HELPID=""PARAMETERSnobjSpecifies the NURBS object (created with gluNewNurbsRenderer).  sknot_countSpecifies the number of knots in the parametric u direction.  sknotSpecifies an array of sknot_count nondecreasing knot values in the parametric u direction.  tknot_countSpecifies the number of knots in the parametric v direction.  tknotSpecifies an array of tknot_count nondecreasing knot values in the parametric v direction.  s_strideSpecifies the offset (as a number of  single-precision floating point values) between successive control points in the parametric u direction in ctlarray.  t_strideSpecifies the offset (in single-precision floating-point values) between successive control points in the parametric v direction in ctlarray.  ctlarraySpecifies an array containing control points for the NURBS surface.  The offsets between successive control points in the parametric u  and v directions are given by s_stride and t_stride.  sorderSpecifies the order of the NURBS surface in the parametric u direction.  The order is one more than the degree, hence a surface that is cubic in u has a u order of 4.  torderSpecifies the order of the NURBS surface in the parametric v direction.  The order is one more than the degree, hence a surface that is cubic in v has a v order of 4.  typeSpecifies type of the surface.  type can be any of the valid two-dimensional evaluator types (such as GL_MAP2_VERTEX_3 or GL_MAP2_COLOR_4).   LBL="" HELPID=""DESCRIPTIONUse gluNurbsSurface within a NURBS (Non-Uniform Rational B-Spline) surface definition to describe the shape of a NURBS surface (before any trimming).  To mark the beginning of a NURBS surface definition, use the gluBeginSurface command.  To mark the end of a NURBS surface definition, use the gluEndSurface command.  Call gluNurbsSurface within a NURBS surface definition only.  Positional, texture, and color coordinates are associated with a surface by presenting each as a separate gluNurbsSurface between a gluBeginSurface/gluEndSurface pair.  No more than one call to gluNurbsSurface for each of color, position, and texture data can be made within a single gluBeginSurface/gluEndSurface pair.  Exactly one call must be made to describe the position of the surface (a type of GL_MAP2_VERTEX_3 or GL_MAP2_VERTEX_4).  A NURBS surface can be trimmed by using the commands gluNurbsCurve and gluPwlCurve between calls to gluBeginTrim and gluEndTrim.  Note that a gluNurbsSurface with sknot_count knots in the u direction and tknot_count knots in the v direction with orders sorder and torder must have (sknot_count - sorder) x (tknot_count - torder) control points.   LBL="" HELPID=""EXAMPLEThe following commands render a textured NURBS surface with normals; the texture coordinates and normals are also NURBS surfaces:  gluBeginSurface(nobj);
   gluNurbsSurface(nobj, ..., GL_MAP2_TEXTURE_COORD_2);
   gluNurbsSurface(nobj, ..., GL_MAP2_NORMAL);
   gluNurbsSurface(nobj, ..., GL_MAP2_VERTEX_4);
gluEndSurface(nobj);LBL="" HELPID=""SEE ALSOIDREF="23137" TYPE="TITLE""gluBeginSurface", IDREF="36073" TYPE="TITLE""gluBeginTrim", IDREF="19636" TYPE="TITLE""gluNewNurbsRenderer", IDREF="21275" TYPE="TITLE""gluNurbsCurve", IDREF="15842" TYPE="TITLE""gluPwlCurve"LBL="" HELPID=""ID="19207"gluOrtho2DLBL="" HELPID=""NAMEgluOrtho2D - define a 2-D orthographic projection matrix  LBL="" HELPID=""C SPECIFICATIONvoid gluOrtho2D( GLdouble left, GLdouble right, GLdouble bottom, GLdouble top ) LBL="" HELPID=""PARAMETERSleft, rightSpecify the coordinates for the left and right vertical clipping planes.  bottom, topSpecify the coordinates for the bottom and top horizontal clipping planes.   LBL="" HELPID=""DESCRIPTIONgluOrtho2D sets up a two-dimensional orthographic viewing region.  This is equivalent to calling glOrtho with  near = -1  and  far = 1 .   LBL="" HELPID=""SEE ALSOIDREF="30307" TYPE="TITLE""glOrtho", IDREF="25199" TYPE="TITLE""gluPerspective"LBL="" HELPID=""ID="36923"gluPartialDiskLBL="" HELPID=""NAMEgluPartialDisk - draw an arc of a disk  LBL="" HELPID=""C SPECIFICATIONvoid gluPartialDisk( GLUquadricObj *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops, GLdouble startAngle, GLdouble sweepAngle ) LBL="" HELPID=""PARAMETERSqobjSpecifies a quadrics object (created with gluNewQuadric).  innerRadiusSpecifies the inner radius of the partial disk (can be zero).  outerRadiusSpecifies the outer radius of the partial disk.  slicesSpecfies the number of subdivisions around the z axis.  loopsSpecifies the number of concentric rings about the origin into which the partial disk is subdivided.  startAngleSpecifies the starting angle, in degrees, of the disk portion.  sweepAngleSpecifies the sweep angle, in degrees, of the disk portion.   LBL="" HELPID=""DESCRIPTIONgluPartialDisk renders a partial disk on the  z = 0  plane.  A partial disk is similar to a full disk, except that only the subset of the disk from startAngle through startAngle + sweepAngle is included (where 0 degrees is along the +yaxis, 90 degrees along the +x axis, 180 along the -y axis, and 270 along the -x axis).  The partial disk has a radius of outerRadius, and contains a concentric circular hole with a radius of innerRadius.  If innerRadius is zero, then no hole is generated.  The partial disk is subdivided around the z axis into slices (like pizza slices), and also about the z axis into rings (as specified by slices and loops, respectively).  With respect to orientation, the +z side of the partial disk is considered to be outside (see IDREF="27542" TYPE="TITLE""gluQuadricOrientation").  This means that if the orientation is set to GLU_OUTSIDE, then any normals generated point along the +z axis.  Otherwise, they point along the -z axis.  If texturing is turned on (with gluQuadricTexture), texture coordinates are generated linearly such that where  r = outerRadius , the value at (r, 0, 0) is (1, 0.5), at (0, r, 0) it is (0.5, 1), at (-r, 0, 0) it is (0, 0.5), and at (0, -r, 0) it is (0.5, 0).   LBL="" HELPID=""SEE ALSOIDREF="38149" TYPE="TITLE""gluCylinder", IDREF="31674" TYPE="TITLE""gluDisk", IDREF="16164" TYPE="TITLE""gluNewQuadric", IDREF="27542" TYPE="TITLE""gluQuadricOrientation", IDREF="41701" TYPE="TITLE""gluQuadricTexture", IDREF="37189" TYPE="TITLE""gluSphere"LBL="" HELPID=""ID="25199"gluPerspectiveLBL="" HELPID=""NAMEgluPerspective - set up a perspective projection matrix  LBL="" HELPID=""C SPECIFICATIONvoid gluPerspective( GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar ) LBL="" HELPID=""PARAMETERSfovySpecifies the field of view angle, in degrees, in the y direction.  aspectSpecifies the aspect ratio that determines the field of view in the x direction.  The aspect ratio is the ratio of x (width) to y (height).  zNearSpecifies the distance from the viewer to the near clipping plane (always positive).  zFarSpecifies the distance from the viewer to the far clipping plane (always positive).   LBL="" HELPID=""DESCRIPTIONgluPerspective specifies a viewing frustum into the world coordinate system.  In general, the aspect ratio in gluPerspective should match the aspect ratio of the associated viewport.  For example,  aspect = 2.0  means the viewer's angle of view is twice as wide in x as it is in y.  If the viewport is twice as wide as it is tall, it displays the image without distortion.  The matrix generated by gluPerspective is multipled by the current matrix, just as if glMultMatrix were called with the generated matrix.  To load the perspective matrix onto the current matrix stack instead, precede the call to gluPerspective with a call to glLoadIdentity.   LBL="" HELPID=""SEE ALSOIDREF="13747" TYPE="TITLE""glFrustum", IDREF="15281" TYPE="TITLE""glLoadIdentity", IDREF="17230" TYPE="TITLE""glMultMatrix", IDREF="19207" TYPE="TITLE""gluOrtho2D"LBL="" HELPID=""gluPickMatrixLBL="" HELPID=""NAMEgluPickMatrix - define a picking region  LBL="" HELPID=""C SPECIFICATIONvoid gluPickMatrix( GLdouble x, GLdouble y, GLdouble width, GLdouble height, GLint viewport[4] ) LBL="" HELPID=""PARAMETERSx, ySpecify the center of a picking region in window coordinates.  width, heightSpecify the width and height, respectively, of the picking region in window coordinates.  viewportSpecifies the current viewport (as from a glGetIntegerv call).   LBL="" HELPID=""DESCRIPTIONgluPickMatrix creates a projection matrix that can be used to restrict drawing to a small region of the viewport.  This is typically useful to determine what objects are being drawn near the cursor.  Use gluPickMatrix to restrict drawing to a small region around the cursor.  Then, enter selection mode (with glRenderMode and rerender the scene.  All primitives that would have been drawn near the cursor are identified and stored in the selection buffer.  The matrix created by gluPickMatrix is multiplied by the current matrix just as if glMultMatrix is called with the generated matrix.  To effectively use the generated pick matrix for picking, first call glLoadIdentity to load an identity matrix onto the perspective matrix stack.  Then call gluPickMatrix, and finally, call a command (such as gluPerspective) to multiply the perspective matrix by the pick matrix.  When using gluPickMatrix to pick NURBS, be careful to turn off the NURBS property GLU_AUTO_LOAD_MATRIX.  If GLU_AUTO_LOAD_MATRIX is not turned off, then any NURBS surface rendered is subdivided differently with the pick matrix than the way it was subdivided without the pick matrix.   LBL="" HELPID=""EXAMPLEWhen rendering a scene as follows:  glMatrixMode(GL_PROJECTION);
glLoadIdentity();
gluPerspective(...);
glMatrixMode(GL_MODELVIEW);
/* Draw the scene */a portion of the viewport can be selected as a pick region like this:  glMatrixMode(GL_PROJECTION);
glLoadIdentity();
gluPickMatrix(x, y, width, height, viewport);
gluPerspective(...);
glMatrixMode(GL_MODELVIEW);
/* Draw the scene */LBL="" HELPID=""SEE ALSOIDREF="41087" TYPE="TITLE""glGet", IDREF="15281" TYPE="TITLE""glLoadIdentity", IDREF="17230" TYPE="TITLE""glMultMatrix", IDREF="35248" TYPE="TITLE""glRenderMode", IDREF="25199" TYPE="TITLE""gluPerspective"LBL="" HELPID=""ID="28992"gluProjectLBL="" HELPID=""NAMEgluProject - map object coordinates to window coordinates  LBL="" HELPID=""C SPECIFICATIONint gluProject( GLdouble objx, GLdouble objy, GLdouble objz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *winx, GLdouble *winy, GLdouble *winz ) LBL="" HELPID=""PARAMETERSobjx, objy, objzSpecify the object coordinates.  modelMatrixSpecifies the current modelview matrix (as from a glGetDoublev call).  projMatrixSpecifies the current projection matrix (as from a glGetDoublev call).  viewportSpecifies the current viewport (as from a glGetIntegerv call).  winx, winy, winzReturn the computed window coordinates.   LBL="" HELPID=""DESCRIPTIONgluProject transforms the specified object coordinates into window coordinates using modelMatrix, projMatrix, and viewport.  The result is stored in winx, winy, and winz.  A return value of GL_TRUE indicates success, and GL_FALSE indicates failure.   LBL="" HELPID=""SEE ALSOIDREF="41087" TYPE="TITLE""glGet", IDREF="12101" TYPE="TITLE""gluUnProject"LBL="" HELPID=""ID="15842"gluPwlCurveLBL="" HELPID=""NAMEgluPwlCurve - describe a piecewise linear NURBS trimming curve  LBL="" HELPID=""C SPECIFICATIONvoid gluPwlCurve( GLUnurbsObj *nobj, GLint count, GLfloat *array, GLint stride, GLenum type ) LBL="" HELPID=""PARAMETERSnobjSpecifies the NURBS object (created with gluNewNurbsRenderer).  countSpecifies the number of points on the curve.  arraySpecifies an array containing the curve points.  strideSpecifies the offset (a number of single-precision floating-point values) between points on the curve.  typeSpecifies the type of curve.  Must be either GLU_MAP1_TRIM_2 or GLU_MAP1_TRIM_3.   LBL="" HELPID=""DESCRIPTIONgluPwlCurve describes a piecewise linear trimming curve for a NURBS surface.  A piecewise linear curve consists of a list of coordinates of points in the parameter space for the NURBS surface to be trimmed.  These points are connected with line segments to form a curve.  If the curve is an approximation to a real curve, the points should be close enough that the resulting path appears curved at the resolution used in the application.  If type is GLU_MAP1_TRIM_2, then it describes a curve in two-dimensional (u and v) parameter space.  If it is GLU_MAP1_TRIM_3, then it describes a curve in two-dimensional homogeneous (u, v, and w) parameter space.  Please refer to the gluBeginTrim reference page for more information about trimming curves.   LBL="" HELPID=""SEE ALSOIDREF="31679" TYPE="TITLE""gluBeginCurve", IDREF="36073" TYPE="TITLE""gluBeginTrim", IDREF="19636" TYPE="TITLE""gluNewNurbsRenderer", IDREF="21275" TYPE="TITLE""gluNurbsCurve"LBL="" HELPID=""ID="22928"gluQuadricCallbackLBL="" HELPID=""NAMEgluQuadricCallback - define a callback for a quadrics object  LBL="" HELPID=""C SPECIFICATIONvoid gluQuadricCallback( GLUquadricObj *qobj, GLenum which, void (*fn)( ) LBL="" HELPID=""PARAMETERSqobjSpecifies the quadrics object (created with gluNewQuadric).  whichSpecifies the callback being defined.  The only valid value is GLU_ERROR.  fnSpecifies the function to be called.   LBL="" HELPID=""DESCRIPTIONgluQuadricCallback is used to define a new callback to be used by a quadrics object.  If the specified callback is already defined, then it is replaced.  If fn is NULL, then any existing callback is erased.  The one legal callback is GLU_ERROR: GLU_ERRORThe function is called when an error is encountered.  Its single argument is of type GLenum, and it indicates the specific error that occurred.  Character strings describing these errors can be retrieved with the gluErrorString call.   LBL="" HELPID=""SEE ALSOIDREF="39754" TYPE="TITLE""gluErrorString", IDREF="16164" TYPE="TITLE""gluNewQuadric"LBL="" HELPID=""ID="19545"gluQuadricDrawStyleLBL="" HELPID=""NAMEgluQuadricDrawStyle - specify the draw style desired for quadrics  LBL="" HELPID=""C SPECIFICATIONvoid gluQuadricDrawStyle( GLUquadricObj *quadObject, GLenum drawStyle ) LBL="" HELPID=""PARAMETERSquadObjectSpecifies the quadrics object (created with gluNewQuadric).  drawStyleSpecifies the desired draw style.  Valid values are GLU_FILL, GLU_LINE, GLU_SILHOUETTE, and GLU_POINT.   LBL="" HELPID=""DESCRIPTIONgluQuadricDrawStyle specifies the draw style for quadrics rendered with quadObject.  The legal values are as follows: GLU_FILLQuadrics are rendered with polygon primitives.  The polygons are drawn in a counterclockwise fashion with respect to their normals (as defined with gluQuadricOrientation).  GLU_LINEQuadrics are rendered as a set of lines.  GLU_SILHOUETTEQuadrics are rendered as a set of lines, except that edges separating coplanar faces will not be drawn.  GLU_POINTQuadrics are rendered as a set of points.   LBL="" HELPID=""SEE ALSOIDREF="16164" TYPE="TITLE""gluNewQuadric", IDREF="12320" TYPE="TITLE""gluQuadricNormals", IDREF="27542" TYPE="TITLE""gluQuadricOrientation", IDREF="41701" TYPE="TITLE""gluQuadricTexture"LBL="" HELPID=""ID="12320"gluQuadricNormalsLBL="" HELPID=""NAMEgluQuadricNormals - specify what kind of normals are desired for quadrics  LBL="" HELPID=""C SPECIFICATIONvoid gluQuadricNormals( GLUquadricObj *quadObject, GLenum normals ) LBL="" HELPID=""PARAMETERSquadObjectSpecifes the quadrics object (created with gluNewQuadric).  normalsSpecifies the desired type of normals.  Valid values are GLU_NONE, GLU_FLAT, and GLU_SMOOTH.   LBL="" HELPID=""DESCRIPTIONgluQuadricNormals specifies what kind of normals are desired for quadrics rendered with quadObject.  The legal values are as follows: GLU_NONENo normals are generated.  GLU_FLATOne normal is generated for every facet of a quadric.  GLU_SMOOTHOne normal is generated for every vertex of a quadric.  This is the default.   LBL="" HELPID=""SEE ALSOIDREF="16164" TYPE="TITLE""gluNewQuadric", IDREF="19545" TYPE="TITLE""gluQuadricDrawStyle", IDREF="27542" TYPE="TITLE""gluQuadricOrientation", IDREF="41701" TYPE="TITLE""gluQuadricTexture"LBL="" HELPID=""ID="27542"gluQuadricOrientationLBL="" HELPID=""NAMEgluQuadricOrientation - specify inside/outside orientation for quadrics  LBL="" HELPID=""C SPECIFICATIONvoid gluQuadricOrientation( GLUquadricObj *quadObject, GLenum orientation ) LBL="" HELPID=""PARAMETERSquadObjectSpecifies the quadrics object (created with gluNewQuadric).  orientationSpecifies the desired orientation.  Valid values are GLU_OUTSIDE and GLU_INSIDE.   LBL="" HELPID=""DESCRIPTIONgluQuadricOrientation specifies what kind of orientation is desired for quadrics rendered with quadObject.  The orientation values are as follows: GLU_OUTSIDE Quadrics are drawn with normals pointing outward.  GLU_INSIDE Normals point inward.  The default is GLU_OUTSIDE.  Note that the interpretation of outward and inward depends on the quadric being drawn.   LBL="" HELPID=""SEE ALSOIDREF="16164" TYPE="TITLE""gluNewQuadric", IDREF="19545" TYPE="TITLE""gluQuadricDrawStyle", IDREF="12320" TYPE="TITLE""gluQuadricNormals", IDREF="41701" TYPE="TITLE""gluQuadricTexture"LBL="" HELPID=""ID="41701"gluQuadricTextureLBL="" HELPID=""NAMEgluQuadricTexture - specify if texturing is desired for quadrics  LBL="" HELPID=""C SPECIFICATIONvoid gluQuadricTexture( GLUquadricObj *quadObject, GLboolean textureCoords ) LBL="" HELPID=""PARAMETERSquadObjectSpecifies the quadrics object (created with gluNewQuadric).  textureCoordsSpecifies a flag indicating if texture coordinates should be generated.   LBL="" HELPID=""DESCRIPTIONgluQuadricTexture specifies if texture coordinates should be generated for quadrics rendered with quadObject.  If the value of textureCoords is GL_TRUE, then texture coordinates are generated, and if textureCoords is GL_FALSE, they are not.  The default is GL_FALSE.  The manner in which texture coordinates are generated depends upon the specific quadric rendered.   LBL="" HELPID=""SEE ALSOIDREF="16164" TYPE="TITLE""gluNewQuadric", IDREF="19545" TYPE="TITLE""gluQuadricDrawStyle", IDREF="12320" TYPE="TITLE""gluQuadricNormals", IDREF="27542" TYPE="TITLE""gluQuadricOrientation"LBL="" HELPID=""ID="13316"gluScaleImageLBL="" HELPID=""NAMEgluScaleImage - scale an image to an arbitrary size  LBL="" HELPID=""C SPECIFICATIONint gluScaleImage( GLenum format, GLint widthin, GLint heightin, GLenum typein, const void *datain, GLint widthout, GLint heightout, GLenum typeout, void *dataout ) LBL="" HELPID=""PARAMETERSformatSpecifies the format of the pixel data.  The following symbolic values are valid: GL_COLOR_INDEX, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_RGBA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.  widthin, heightinSpecify the width and height, respectively, of the source image that is scaled.  typeinSpecifies the data type for datain. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, or GL_FLOAT.  datainSpecifies a pointer to the source image.  widthout, heightoutSpecify the width and height, respectively, of the destination image.  typeoutSpecifies the data type for dataout. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, or GL_FLOAT.  dataoutSpecifies a pointer to the destination image.   LBL="" HELPID=""DESCRIPTIONgluScaleImage scales a pixel image using the appropriate pixel store modes to unpack data from the source image and pack data into the destination image.  When shrinking an image, gluScaleImage uses a box filter to sample the source image and create pixels for the destination image.  When magnifying an image, the pixels from the source image are linearly interpolated to create the destination image.  A return value of zero indicates success, otherwise a GLU error code is returned indicating what the problem was (see IDREF="39754" TYPE="TITLE""gluErrorString").  Please refer to the glReadPixels reference page for a description of the acceptable values for the format, typein, and typeout parameters.   LBL="" HELPID=""SEE ALSOIDREF="41928" TYPE="TITLE""glDrawPixels", IDREF="40261" TYPE="TITLE""glReadPixels", IDREF="40858" TYPE="TITLE""gluBuild1DMipmaps", IDREF="13556" TYPE="TITLE""gluBuild2DMipmaps", IDREF="39754" TYPE="TITLE""gluErrorString"LBL="" HELPID=""ID="37189"gluSphereLBL="" HELPID=""NAMEgluSphere - draw a sphere  LBL="" HELPID=""C SPECIFICATIONvoid gluSphere( GLUquadricObj *qobj, GLdouble radius, GLint slices, GLint stacks ) LBL="" HELPID=""PARAMETERSqobjSpecifies the quadrics object (created with gluNewQuadric).  radiusSpecifies the radius of the sphere.  slicesSpecifies the number of subdivisions around the z axis (similar to lines of longitude).  stacksSpecifies the number of subdivisions along the z axis (similar to lines of latitude).   LBL="" HELPID=""DESCRIPTIONgluSphere draws a sphere of the given radius centered around the origin.  The sphere is subdivided around the z axis into slices and along the z axis into stacks (similar to lines of longitude and latitude).  If the orientation is set to GLU_OUTSIDE (with gluQuadricOrientation), then any normals generated point away from the center of the sphere.  Otherwise, they point toward the center of the sphere.  If texturing is turned on (with gluQuadricTexture), then texture coordinates are generated so that t ranges from 0.0 at  z = -radius  to 1.0 at  z = radius  (t increases linearly along longitudinal lines), and s ranges from 0.0 at the +y axis, to 0.25 at the +x axis, to 0.5 at the -y axis, to 0.75 at the -x axis, and back to 1.0 at the +y axis.   LBL="" HELPID=""SEE ALSOIDREF="38149" TYPE="TITLE""gluCylinder", IDREF="31674" TYPE="TITLE""gluDisk", IDREF="16164" TYPE="TITLE""gluNewQuadric", IDREF="36923" TYPE="TITLE""gluPartialDisk", IDREF="27542" TYPE="TITLE""gluQuadricOrientation", IDREF="41701" TYPE="TITLE""gluQuadricTexture"LBL="" HELPID=""ID="40802"gluTessCallbackLBL="" HELPID=""NAMEgluTessCallback - define a callback for a tessellation object  LBL="" HELPID=""C SPECIFICATIONvoid gluTessCallback( GLUtriangulatorObj *tobj, GLenum which, void (*fn)( ) LBL="" HELPID=""PARAMETERStobjSpecifies the tessellation object (created with gluNewTess).  whichSpecifies the callback being defined.  The following values are valid: GLU_BEGIN, GLU_EDGE_FLAG, GLU_VERTEX, GLU_END, and GLU_ERROR.  fnSpecifies the function to be called.   LBL="" HELPID=""DESCRIPTIONgluTessCallback is used to indicate a callback to be used by a tessellation object.  If the specified callback is already defined, then it is replaced.  If fn is NULL, then the existing callback is erased.  These callbacks are used by the tessellation object to describe how a polygon specified by the user is broken into triangles.  The legal callbacks are as follows: GLU_BEGINThe begin callback is invoked like glBegin to indicate the start of a (triangle) primitive.  The function takes a single argument of type GLenum that is either GL_TRIANGLE_FAN, GL_TRIANGLE_STRIP, or GL_TRIANGLES.  GLU_EDGE_FLAGThe edge flag callback is similar to glEdgeFlag.  The function takes a single Boolean flag that indicates which edges of the created triangles were part of the original polygon defined by the user, and which were created by the tessellation process.  If the flag is GL_TRUE, then each vertex that follows begins an edge that was part of the original polygon.  If the flag is GL_FALSE, then each vertex that follows begins an edge that was generated by the tessellator.  The edge flag callback (if defined) is invoked before the first vertex callback is made.  Since triangle fans and triangle strips do not support edge flags, the begin callback is not called with GL_TRIANGLE_FAN or GL_TRIANGLE_STRIP if an edge flag callback is provided.  Instead, the fans and strips are converted to independent triangles.  GLU_VERTEXThe vertex callback is invoked between the begin and end callbacks.  It is similar to glVertex, and it defines the vertices of the triangles created by the tessellation process.  The function takes a pointer as its only argument.  This pointer is identical to the opaque pointer provided by the user when the vertex was described (see IDREF="19130" TYPE="TITLE""gluTessVertex").  GLU_ENDThe end callback serves the same purpose as glEnd. It indicates the end of a primitive and it takes no arguments.  GLU_ERRORThe error callback is called when an error is encountered.  The one argument is of type GLenum, and it indicates the specific error that occurred.  There are eight errors unique to polygon tessellation, named GLU_TESS_ERROR1 through GLU_TESS_ERROR8.  Character strings describing these errors can be retrieved with the gluErrorString call.   LBL="" HELPID=""EXAMPLEPolygons tessellated can be rendered directly like this:  gluTessCallback(tobj, GLU_BEGIN, glBegin);
gluTessCallback(tobj, GLU_VERTEX, glVertex3dv);
gluTessCallback(tobj, GLU_END, glEnd);
gluBeginPolygon(tobj);
   gluTessVertex(tobj, v, v);
   ...
gluEndPolygon(tobj);Typically, the tessellated polygon should be stored in a display list so that it does not need to be retessellated every time it is rendered.   LBL="" HELPID=""SEE ALSOIDREF="11415" TYPE="TITLE""glBegin", IDREF="40044" TYPE="TITLE""glEdgeFlag", IDREF="32860" TYPE="TITLE""glVertex", IDREF="21923" TYPE="TITLE""gluDeleteTess", IDREF="39754" TYPE="TITLE""gluErrorString", IDREF="15905" TYPE="TITLE""gluNewTess", IDREF="19130" TYPE="TITLE""gluTessVertex"LBL="" HELPID=""ID="19130"gluTessVertexLBL="" HELPID=""NAMEgluTessVertex - specify a vertex on a polygon  LBL="" HELPID=""C SPECIFICATIONvoid gluTessVertex( GLUtriangulatorObj *tobj, GLdouble v[3], void *data ) LBL="" HELPID=""PARAMETERStobjSpecifies the tessellation object (created with gluNewTess).  vSpecifies the location of the vertex.  dataSpecifies an opaque pointer passed back to the user with the vertex callback (as specified by gluTessCallback).   LBL="" HELPID=""DESCRIPTIONgluTessVertex describes a vertex on a polygon that the user is defining.  Successive gluTessVertex calls describe a closed contour.  For example, if the user wants to describe a quadrilateral, then gluTessVertex should be called four times.  gluTessVertex can only be called between gluBeginPolygon and gluEndPolygon.  data normally points to a structure containing the vertex location, as well as other per-vertex attributes such as color and normal.  This pointer is passed back to the user through the GLU_VERTEX callback after tessellation (see the IDREF="40802" TYPE="TITLE""gluTessCallback" reference page).    LBL="" HELPID=""EXAMPLEA quadrilateral with a triangular hole in it can be described as follows:  gluBeginPolygon(tobj);
   gluTessVertex(tobj, v1, v1);
   gluTessVertex(tobj, v2, v2);
   gluTessVertex(tobj, v3, v3);
   gluTessVertex(tobj, v4, v4);
gluNextContour(tobj, GLU_INTERIOR);
   gluTessVertex(tobj, v5, v5);
   gluTessVertex(tobj, v6, v6);
   gluTessVertex(tobj, v7, v7);
gluEndPolygon(tobj);LBL="" HELPID=""SEE ALSOIDREF="27257" TYPE="TITLE""gluBeginPolygon", IDREF="15905" TYPE="TITLE""gluNewTess", IDREF="28369" TYPE="TITLE""gluNextContour", IDREF="40802" TYPE="TITLE""gluTessCallback"LBL="" HELPID=""ID="12101"gluUnProjectLBL="" HELPID=""NAMEgluUnProject - map window coordinates to object coordinates  LBL="" HELPID=""C SPECIFICATIONint gluUnProject( GLdouble winx, GLdouble winy, GLdouble winz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *objx, GLdouble *objy, GLdouble *objz ) LBL="" HELPID=""PARAMETERSwinx, winy, winzSpecify the window coordinates to be mapped.  modelMatrixSpecifies the modelview matrix (as from a glGetDoublev call).  projMatrixSpecifies the projection matrix (as from a glGetDoublev call).  viewportSpecifies the viewport (as from a glGetIntegerv call).  objx, objy, objzReturns the computed object coordinates.   LBL="" HELPID=""DESCRIPTIONgluUnProject maps the specified window coordinates into object coordinates using modelMatrix, projMatrix, and viewport.  The result is stored in objx, objy, and objz.  A return value of GL_TRUE indicates success, and GL_FALSE indicates failure.   LBL="" HELPID=""SEE ALSOIDREF="41087" TYPE="TITLE""glGet", IDREF="28992" TYPE="TITLE""gluProject"LBL="7"ID="45928"GLX Reference PagesThis chapter contains the reference pages, in alphabetical order, for all the routines comprising the OpenGL extension to X (GLX). Note that there is a glXIntro page, which gives an overview of OpenGL in the X Window System; you might want to start with this page. LBL="" HELPID=""ID="12682"glXChooseVisualLBL="" HELPID=""NAMEglXChooseVisual - return a visual that matches specified attributes  LBL="" HELPID=""C SPECIFICATIONXVisualInfo* glXChooseVisual( Display *dpy, int screen, int *attribList ) LBL="" HELPID=""PARAMETERSdpySpecifies the connection to the X server.   screenSpecifies the screen number.   attribListSpecifies a list of Boolean attributes and integer attribute/value pairs.  The last attribute must be None.   LBL="" HELPID=""DESCRIPTIONglXChooseVisual returns a pointer to an XVisualInfo structure describing the visual that best meets a minimum specification.  The Boolean GLX attributes of the visual that is returned will match the specified values, and the integer GLX attributes will meet or exceed the specified minimum values.  If all other attributes are equivalent, then TrueColor and PseudoColor visuals have priority over DirectColor and StaticColor visuals, respectively.  If no conforming visual exists, NULL is returned.  To free the data returned by this function, use XFree.  All Boolean GLX attributes default to False except GLX_USE_GL, which defaults to True.  All integer GLX attributes default to zero.  Default specifications are superseded by attributes included in attribList.  Boolean attributes included in attribList are understood to be True.  Integer attributes are followed immediately by the corresponding desired or minimum value.  The list must be terminated with None.  The interpretations of the various GLX visual attributes are as follows: GLX_USE_GLIgnored.  Only visuals that can be rendered with GLX are considered.  GLX_BUFFER_SIZEMust be followed by a nonnegative integer that indicates the desired color index buffer size.  The smallest index buffer of at least the specified size is preferred.  Ignored if GLX_RGBA is asserted.  GLX_LEVELMust be followed by an integer buffer-level specification.  This specification is honored exactly.  Buffer level zero corresponds to the default frame buffer of the display.  Buffer level one is the first overlay frame buffer, level two the second overlay frame buffer, and so on.  Negative buffer levels correspond to underlay frame buffers.  GLX_RGBAIf present, only TrueColor and DirectColor visuals are considered.  Otherwise, only PseudoColor and StaticColor visuals are considered.  GLX_DOUBLEBUFFERIf present, only double-buffered visuals are considered.  Otherwise, only single-buffered visuals are considered.  GLX_STEREOIf present, only stereo visuals are considered.  Otherwise, only monoscopic visuals are considered.  GLX_AUX_BUFFERSMust be followed by a nonnegative integer that indicates the desired number of auxiliary buffers.  Visuals with the smallest number of auxiliary buffers that meets or exceeds the specified number are preferred.  GLX_RED_SIZEMust be followed by a nonnegative minimum size specification.  If this value is zero, the smallest available red buffer is preferred.  Otherwise, the largest available red buffer of at least the minimum size is preferred.  GLX_GREEN_SIZEMust be followed by a nonnegative minimum size specification.  If this value is zero, the smallest available green buffer is preferred.  Otherwise, the largest available green buffer of at least the minimum size is preferred.  GLX_BLUE_SIZEMust be followed by a nonnegative minimum size specification.  If this value is zero, the smallest available blue buffer is preferred.  Otherwise, the largest available blue buffer of at least the minimum size is preferred.  GLX_ALPHA_SIZEMust be followed by a nonnegative minimum size specification.  If this value is zero, the smallest available alpha buffer is preferred.  Otherwise, the largest available alpha buffer of at least the minimum size is preferred.  GLX_DEPTH_SIZEMust be followed by a nonnegative minimum size specification.  If this value is zero, visuals with no depth buffer are preferred.  Otherwise, the largest available depth buffer of at least the minimum size is preferred.  GLX_STENCIL_SIZEMust be followed by a nonnegative integer that indicates the desired number of stencil bitplanes.  The smallest stencil buffer of at least the specified size is preferred.  If the desired value is zero, visuals with no stencil buffer are preferred.  GLX_ACCUM_RED_SIZEMust be followed by a nonnegative minimum size specification.  If this value is zero, visuals with no red accumulation buffer are preferred.  Otherwise, the largest possible red accumulation buffer of at least the minimum size is preferred.  GLX_ACCUM_GREEN_SIZEMust be followed by a nonnegative minimum size specification.  If this value is zero, visuals with no green accumulation buffer are preferred.  Otherwise, the largest possible green accumulation buffer of at least the minimum size is preferred.  GLX_ACCUM_BLUE_SIZEMust be followed by a nonnegative minimum size specification.  If this value is zero, visuals with no blue accumulation buffer are preferred.  Otherwise, the largest possible blue accumulation buffer of at least the minimum size is preferred.  GLX_ACCUM_ALPHA_SIZEMust be followed by a nonnegative minimum size specification.  If this value is zero, visuals with no alpha accumulation buffer are preferred.  Otherwise, the largest possible alpha accumulation buffer of at least the minimum size is preferred.   LBL="" HELPID=""EXAMPLESattribList ={GLX_RGBA, GLX_RED_SIZE, 4, GLX_GREEN_SIZE, 4, GLX_BLUE_SIZE, 4, None}; Specifies a single-buffered RGB visual in the normal frame buffer, not an overlay or underlay buffer.  The returned visual supports at least four bits each of red, green, and blue, and possibly no bits of alpha.  It does not support color index mode, double-buffering, or stereo display.  It may or may not have one or more auxiliary color buffers, a depth buffer, a stencil buffer, or an accumulation buffer.    LBL="" HELPID=""NOTESXVisualInfo is defined in Xutil.h. It is a structure that includes visual, visualID, screen, and depth elements.  glXChooseVisual is implemented as a client-side utility using only XGetVisualInfo and glXGetConfig.  Calls to these two routines can be used to implement selection algorithms other than the generic one implemented by glXChooseVisual.  GLX implementers are strongly discouraged, but not proscribed, from changing the selection algorithm used by glXChooseVisual.  Therefore, selections may change from release to release of the client-side library.  There is no direct filter for picking only visuals that support GLXPixmaps.  GLXPixmaps are supported for visuals whose GLX_BUFFER_SIZE.  is one of the Pixmap depths supported by the X server.   LBL="" HELPID=""ERRORSNULL is returned if an undefined GLX attribute is encountered in attribList.   LBL="" HELPID=""SEE ALSOIDREF="28362" TYPE="TITLE""glXCreateContext", IDREF="20394" TYPE="TITLE""glXGetConfig"LBL="" HELPID=""ID="20649"glXCopyContextLBL="" HELPID=""NAMEglXCopyContext - copy state from one rendering context to another  LBL="" HELPID=""C SPECIFICATIONvoid glXCopyContext( Display *dpy, GLXContext src, GLXContext dst, GLuint mask ) LBL="" HELPID=""PARAMETERSdpySpecifies the connection to the X server.   srcSpecifies the source context.   dstSpecifies the destination context.   maskSpecifies which portions of src state are to be copied to dst.   LBL="" HELPID=""DESCRIPTIONglXCopyContext copies selected groups of state variables from src to dst.  mask indicates which groups of state variables are to be copied.  mask contains the bitwise OR of the same symbolic names that are passed to the OpenGL command glPushAttrib.  The single symbolic constant GL_ALL_ATTRIB_BITS can be used to copy the maximum possible portion of rendering state.  The copy can be done only if the renderers named by src and dst share an address space.  Two rendering contexts share an address space if both are nondirect using the same server, or if both are direct and owned by a single process.  Note that in the nondirect case it is not necessary for the calling threads to share an address space, only for their related rendering contexts to share an address space.  Not all values for OpenGL state can be copied.  For example, pixel pack and unpack state, render mode state, and select and feedback state are not copied.  The state that can be copied is exactly the state that is manipulated by OpenGL command glPushAttrib.  An implicit glFlush is done by glXCopyContext if src is the current context for the calling thread.  If src is not the current context for the thread issuing the request, then the state of the src context is undefined.   LBL="" HELPID=""NOTESTwo rendering contexts share an address space if both are nondirect using the same server, or if both are direct and owned by a single process.  A process is a single execution environment, implemented in a single address space, consisting of one or more threads.  A thread is one of a set of subprocesses that share a single address space, but maintain separate program counters, stack spaces, and other related global data.  A thread that is the only member of its subprocess group is equivalent to a process.   LBL="" HELPID=""ERRORSBadMatch is generated if rendering contexts src and dst do not share an address space or were not created with respect to the same screen.  BadAccess is generated if dst is current to any thread (including the calling thread) at the time glXCopyContext is called.  GLXBadCurrentWindow is generated if src is the current context and the current drawable is a window that is no longer valid.  GLX_Bad_Context is generated if either src or dst is not a valid GLX context.  BadValue is generated if undefined mask bits are specified.   LBL="" HELPID=""SEE ALSOIDREF="12225" TYPE="TITLE""glPushAttrib", IDREF="28362" TYPE="TITLE""glXCreateContext", IDREF="35153" TYPE="TITLE""glXIsDirect"LBL="" HELPID=""ID="28362"glXCreateContextLBL="" HELPID=""NAMEglXCreateContext - create a new GLX rendering context  LBL="" HELPID=""C SPECIFICATIONGLXContext glXCreateContext( Display *dpy, XVisualInfo *vis, GLXContext shareList, Bool direct ) LBL="" HELPID=""PARAMETERSdpySpecifies the connection to the X server.   visSpecifies the visual that defines the frame buffer resources available to the rendering context.  It is a pointer to an XVisualInfo structure, not a visual ID or a pointer to a Visual.   shareListSpecifies the context with which to share display lists.  NULL indicates that no sharing is to take place.   directSpecifies whether rendering is to be done with a direct connection to the graphics system if possible (True) or through the X server (False).   LBL="" HELPID=""DESCRIPTIONglXCreateContext creates a GLX rendering context and returns its handle.  This context can be used to render into both windows and GLX pixmaps.  If glXCreateContext fails to create a rendering context, NULL is returned.  If direct is True, then a direct rendering context is created if the implementation supports direct rendering and the connection is to an X server that is local.  If direct is False, then a rendering context that renders through the X server is always created.  Direct rendering provides a performance advantage in some implementations.  However, direct rendering contexts cannot be shared outside a single process, and they cannot be used to render to GLX pixmaps.  If shareList is not NULL, then all display-list indexes and definitions are shared by context shareList and by the newly created context.  An arbitrary number of contexts can share a single display-list space.  However, all rendering contexts that share a single display-list space must themselves exist in the same address space.  Two rendering contexts share an address space if both are nondirect using the same server, or if both are direct and owned by a single process.  Note that in the nondirect case, it is not necessary for the calling threads to share an address space, only for their related rendering contexts to share an address space.   LBL="" HELPID=""NOTESXVisualInfo is defined in Xutil.h. It is a structure that includes visual, visualID, screen, and depth elements.  A process is a single execution environment, implemented in a single address space, consisting of one or more threads.  A thread is one of a set of subprocesses that share a single address space, but maintain separate program counters, stack spaces, and other related global data.  A thread that is the only member of its subprocess group is equivalent to a process.   LBL="" HELPID=""ERRORSNULL is returned if execution fails on the client side.  BadMatch is generated if the context to be created would not share the address space or the screen of the context specified by shareList.  BadValue is generated if vis is not a valid visual (e.g., if the GLX implementation does not support it).  GLX_Bad_Context is generated if shareList is not a GLX context and is not NULL.  BadAlloc is generated if the server does not have enough resources to allocate the new context.   LBL="" HELPID=""SEE ALSOIDREF="16440" TYPE="TITLE""glXDestroyContext", IDREF="20394" TYPE="TITLE""glXGetConfig", IDREF="35153" TYPE="TITLE""glXIsDirect", IDREF="17886" TYPE="TITLE""glXMakeCurrent"LBL="" HELPID=""ID="29709"glXCreateGLXPixmapLBL="" HELPID=""NAMEglXCreateGLXPixmap - create an off-screen GLX rendering area  LBL="" HELPID=""C SPECIFICATIONGLXPixmap glXCreateGLXPixmap( Display *dpy, XVisualInfo *vis, Pixmap pixmap ) LBL="" HELPID=""PARAMETERSdpySpecifies the connection to the X server.   visSpecifies the visual that defines the structure of the rendering area.  It is a pointer to an XVisualInfo structure, not a visual ID or a pointer to a Visual.   pixmapSpecifies the X pixmap that will be used as the front left color buffer of the off-screen rendering area.   LBL="" HELPID=""DESCRIPTIONglXCreateGLXPixmap creates an off-screen rendering area and returns its XID.  Any GLX rendering context that was created with respect to vis can be used to render into this off-screen area.  Use glXMakeCurrent to associate the rendering area with a GLX rendering context.  The X pixmap identified by pixmap is used as the front left buffer of the resulting off-screen rendering area.  All other buffers specified by vis, including color buffers other than the front left buffer, are created without externally visible names.  GLX pixmaps with double-buffering are supported.  However, glXSwapBuffers is ignored by these pixmaps.  Direct rendering contexts cannot be used to render into GLX pixmaps.   LBL="" HELPID=""NOTESXVisualInfo is defined in Xutil.h. It is a structure that includes visual, visualID, screen, and depth elements.   LBL="" HELPID=""ERRORSBadMatch is generated if the depth of pixmap does not match the GLX_BUFFER_SIZE value of vis, or if pixmap was not created with respect to the same screen as vis.  BadValue is generated if vis is not a valid XVisualInfo pointer (e.g., if the GLX implementation does not support this visual).  BadPixmap is generated if pixmap is not a valid pixmap.  BadAlloc is generated if the server cannot allocate the GLX pixmap.   LBL="" HELPID=""SEE ALSOIDREF="28362" TYPE="TITLE""glXCreateContext", IDREF="35153" TYPE="TITLE""glXIsDirect", IDREF="17886" TYPE="TITLE""glXMakeCurrent"LBL="" HELPID=""ID="16440"glXDestroyContextLBL="" HELPID=""NAMEglXDestroyContext - destroy a GLX context  LBL="" HELPID=""C SPECIFICATIONvoid glXDestroyContext( Display *dpy, GLXContext ctx ) LBL="" HELPID=""PARAMETERSdpySpecifies the connection to the X server.   ctxSpecifies the GLX context to be destroyed.   LBL="" HELPID=""DESCRIPTIONIf GLX rendering context ctx is not current to any thread, glXDestroyContext destroys it immediately.  Otherwise, ctx is destroyed when it becomes not current to any thread.  In either case, the resource ID referenced by ctx is freed immediately.   LBL="" HELPID=""ERRORSGLX_Bad_Context is generated if ctx is not a valid GLX context.   LBL="" HELPID=""SEE ALSOIDREF="28362" TYPE="TITLE""glXCreateContext", IDREF="17886" TYPE="TITLE""glXMakeCurrent"LBL="" HELPID=""glXDestroyGLXPixmapLBL="" HELPID=""NAMEglXDestroyGLXPixmap - destroy a GLX pixmap  LBL="" HELPID=""C SPECIFICATIONvoid glXDestroyGLXPixmap( Display *dpy, GLXPixmap pix ) LBL="" HELPID=""PARAMETERSdpySpecifies the connection to the X server.   pixSpecifies the GLX pixmap to be destroyed.   LBL="" HELPID=""DESCRIPTIONIf GLX pixmap pix is not current to any client, glXDestroyGLXPixmap destroys it immediately.  Otherwise, pix is destroyed when it becomes not current to any client.  In either case, the resource ID is freed immediately.   LBL="" HELPID=""ERRORSGLX_Bad_Pixmap is generated if pix is not a valid GLX pixmap.   LBL="" HELPID=""SEE ALSOIDREF="29709" TYPE="TITLE""glXCreateGLXPixmap", IDREF="17886" TYPE="TITLE""glXMakeCurrent"LBL="" HELPID=""ID="20394"glXGetConfigLBL="" HELPID=""NAMEglXGetConfig - return information about GLX visuals  LBL="" HELPID=""C SPECIFICATIONint glXGetConfig( Display *dpy, XVisualInfo *vis, int attrib, int *value ) LBL="" HELPID=""PARAMETERSdpySpecifies the connection to the X server.   visSpecifies the visual to be queried.  It is a pointer to an XVisualInfo structure, not a visual ID or a pointer to a Visual.   attribSpecifies the visual attribute to be returned.   valueReturns the requested value.   LBL="" HELPID=""DESCRIPTIONglXGetConfig sets value to the attrib value of windows or GLX pixmaps created with respect to vis.  glXGetConfig returns an error code if it fails for any reason.  Otherwise, zero is returned.  attrib is one of the following: GLX_USE_GLTrue if OpenGL rendering is supported by this visual, False otherwise.  GLX_BUFFER_SIZENumber of bits per color buffer.  For RGBA visuals, GLX_BUFFER_SIZE is the sum of GLX_RED_SIZE, GLX_GREEN_SIZE, GLX_BLUE_SIZE, and GLX_ALPHA_SIZE.  For color index visuals, GLX_BUFFER_SIZE is the size of the color indexes.  GLX_LEVELFrame buffer level of the visual.  Level zero is the default frame buffer.  Positive levels correspond to frame buffers that overlay the default buffer, and negative levels correspond to frame buffers that underlay the default buffer.  GLX_RGBATrue if color buffers store red, green, blue, and alpha values, False if they store color indexes.  GLX_DOUBLEBUFFERTrue if color buffers exist in front/back pairs that can be swapped, False otherwise.  GLX_STEREOTrue if color buffers exist in left/right pairs, False otherwise.  GLX_AUX_BUFFERSNumber of auxiliary color buffers that are available.  Zero indicates that no auxiliary color buffers exist.  GLX_RED_SIZENumber of bits of red stored in each color buffer.  Undefined if GLX_RGBA is False.  GLX_GREEN_SIZENumber of bits of green stored in each color buffer.  Undefined if GLX_RGBA is False.  GLX_BLUE_SIZENumber of bits of blue stored in each color buffer.  Undefined if GLX_RGBA is False.  GLX_ALPHA_SIZENumber of bits of alpha stored in each color buffer.  Undefined if GLX_RGB is False.  GLX_DEPTH_SIZENumber of bits in the depth buffer.  GLX_STENCIL_SIZENumber of bits in the stencil buffer.  GLX_ACCUM_RED_SIZENumber of bits of red stored in the accumulation buffer.  GLX_ACCUM_GREEN_SIZENumber of bits of green stored in the accumulation buffer.  GLX_ACCUM_BLUE_SIZENumber of bits of blue stored in the accumulation buffer.  GLX_ACCUM_ALPHA_SIZENumber of bits of alpha stored in the accumulation buffer.  The X protocol allows a single visual ID to be instantiated with different numbers of bits per pixel.  Windows or GLX pixmaps that will be rendered with OpenGL, however, must be instantiated with a color buffer depth of GLX_BUFFER_SIZE.  Although a GLX implementation can export many visuals that support OpenGL rendering, it must support at least two.  One is an RGBA visual with at least one color buffer, a stencil buffer of at least 1 bit, a depth buffer of at least 12 bits, and an accumulation buffer.  Alpha bitplanes are optional in this visual.  However, its color buffer size must be as great as that of the deepest TrueColor, DirectColor, PseudoColor, or StaticColor visual supported on level zero, and it must itself be made available on level zero.  The other required visual is a color index one with at least one color buffer, a stencil buffer of at least 1 bit, and a depth buffer of at least 12 bits.  This visual must have as many color bitplanes as the deepest PseudoColor or StaticColor visual supported on level zero, and it must itself be made available on level zero.  Applications are best written to select the visual that most closely meets their requirements.  Creating windows or GLX pixmaps with unnecessary buffers can result in reduced rendering performance as well as poor resource allocation.   LBL="" HELPID=""NOTESXVisualInfo is defined in Xutil.h. It is a structure that includes visual, visualID, screen, and depth elements.   LBL="" HELPID=""ERRORSGLX_NO_EXTENSION is returned if dpy does not support the GLX extension.   GLX_BAD_SCREEN is returned if the screen of vis does not correspond to a screen.   GLX_BAD_ATTRIB is returned if attrib is not a valid GLX attribute.   GLX_BAD_VISUAL is returned if vis doesn't support GLX and an attribute other than GLX_USE_GL is requested.   LBL="" HELPID=""SEE ALSOIDREF="12682" TYPE="TITLE""glXChooseVisual", IDREF="28362" TYPE="TITLE""glXCreateContext"LBL="" HELPID=""glXGetCurrentContextLBL="" HELPID=""NAMEglXGetCurrentContext - return the current context  LBL="" HELPID=""C SPECIFICATIONGLXContext glXGetCurrentContext( void ) LBL="" HELPID=""DESCRIPTIONglXGetCurrentContext returns the current context, as specified by glXMakeCurrent.  If there is no current context, NULL is returned.   glXGetCurrentContext returns client-side information.  It does not make a round trip to the server.   LBL="" HELPID=""SEE ALSOIDREF="28362" TYPE="TITLE""glXCreateContext", IDREF="17886" TYPE="TITLE""glXMakeCurrent"LBL="" HELPID=""glXGetCurrentDrawableLBL="" HELPID=""NAMEglXGetCurrentDrawable - return the current drawable  LBL="" HELPID=""C SPECIFICATIONGLXDrawable glXGetCurrentDrawable( void ) LBL="" HELPID=""DESCRIPTIONglXGetCurrentDrawable returns the current drawable, as specified by glXMakeCurrent.  If there is no current drawable, None is returned.   glXGetCurrentDrawable returns client-side information.  It does not make a round trip to the server.   LBL="" HELPID=""SEE ALSOIDREF="29709" TYPE="TITLE""glXCreateGLXPixmap", IDREF="17886" TYPE="TITLE""glXMakeCurrent"LBL="" HELPID=""glXIntroLBL="" HELPID=""NAMEglXIntro - Introduction to OpenGL in the X window system   LBL="" HELPID=""OVERVIEWOpenGL is a high-performance 3-D-oriented renderer.  It is available in the X window system through the GLX extension.  Use glXQueryExtension and glXQueryVersion to establish whether the GLX extension is supported by an X server, and if so, what version is supported.   GLX extended servers make a subset of their visuals available for OpenGL rendering.  Drawables created with these visuals can also be rendered using the core X renderer and with the renderer of any other X extension that is compatible with all core X visuals.   GLX extends drawables with several buffers other than the standard color buffer.  These buffers include back and auxiliary color buffers, a depth buffer, a stencil buffer, and a color accumulation buffer.  Some or all are included in each X visual that supports OpenGL.   To render using OpenGL into an X drawable, you must first choose a visual that defines the required OpenGL buffers.  glXChooseVisual can be used to simplify selecting a compatible visual.  If more control of the selection process is required, use XGetVisualInfo and glXGetConfig to select among all the available visuals.   Use the selected visual to create both a GLX context and an X drawable.  GLX contexts are created with glXCreateContext, and drawables are created with either XCreateWindow or glXCreateGLXPixmap.  Finally, bind the context and the drawable together using glXMakeCurrent.  This context/drawable pair becomes the current context and current drawable, and it is used by all OpenGL commands until glXMakeCurrent is called with different arguments.   Both core X and OpenGL commands can be used to operate on the current drawable.  The X and OpenGL command streams are not synchronized, however, except at explicitly created boundaries generated by calling glXWaitGL, glXWaitX, XSync, and glFlush.   LBL="" HELPID=""EXAMPLESBelow is the minimum code required to create an RGBA-format, OpenGL-compatible X window and clear it to yellow.  The code is correct, but it does not include any error checking.  Return values dpy, vi, cx, cmap, and win should all be tested.  #include  <GL/glx.h>
#include  <GL/gl.h>
#include  <unistd.h>
static int attributeList[] = { GLX_RGBA, None };
static Bool WaitForNotify(Display *d, XEvent *e, char *arg) {
    return (e->type == MapNotify) && (e->xmap.window == (Window)arg);
}
int main(int argc, char **argv) {
    Display *dpy;
    XVisualInfo *vi;
    Colormap cmap;
    XSetWindowAttributes swa;
    Window win;
    GLXContext cx;
    XEvent event;
    /* get a connection */
    dpy = XOpenDisplay(0);
    /* get an appropriate visual */
    vi = glXChooseVisual(dpy, DefaultScreen(dpy), attributeList);
    /* create a GLX context */
    cx = glXCreateContext(dpy, vi, 0, GL_FALSE);
    /* create a color map */
    cmap = XCreateColormap(dpy, RootWindow(dpy, vi->screen),
     vi->visual, AllocNone);
    /* create a window */
    swa.colormap = cmap;
    swa.border_pixel = 0;
    swa.event_mask = StructureNotifyMask;
    win = XCreateWindow(dpy, RootWindow(dpy, vi->screen), 0, 0, 100, 100,
                        0, vi->depth, InputOutput, vi->visual,
                        CWBorderPixel|CWColormap|CWEventMask, &swa);
    XMapWindow(dpy, win);
    XIfEvent(dpy, &event, WaitForNotify, (char*)win);
    /* connect the context to the window */
    glXMakeCurrent(dpy, win, cx);
    /* clear the buffer */
    glClearColor(1,1,0,1);
    glClear(GL_COLOR_BUFFER_BIT);
    glFlush();
    /* wait a while */
    sleep(10);
}LBL="" HELPID=""NOTESA color map must be created and passed to XCreateWindow.  See the example code above.A GLX context must be created and attached to an X drawable before OpenGL commands can be executed.  OpenGL commands issued while no context/drawable pair is current are ignored.Exposure events indicate that all buffers associated with the specified window may be damaged and should be repainted.  Although certain buffers of some visuals on some systems may never require repainting (the depth buffer, for example), it is incorrect to code assuming that these buffers will not be damaged.GLX commands manipulate XVisualInfo structures rather than pointers to visuals or visual IDs.  XVisualInfo structures contain visual, visualID, screen, and depth elements, as well as other X-specific information.   LBL="" HELPID=""SEE ALSOIDREF="21959" TYPE="TITLE""glFinish", IDREF="38698" TYPE="TITLE""glFlush", IDREF="12682" TYPE="TITLE""glXChooseVisual", IDREF="20649" TYPE="TITLE""glXCopyContext", IDREF="28362" TYPE="TITLE""glXCreateContext", IDREF="29709" TYPE="TITLE""glXCreateGLXPixmap", IDREF="16440" TYPE="TITLE""glXDestroyContext", IDREF="20394" TYPE="TITLE""glXGetConfig", IDREF="35153" TYPE="TITLE""glXIsDirect", IDREF="17886" TYPE="TITLE""glXMakeCurrent", IDREF="40311" TYPE="TITLE""glXQueryExtension", IDREF="26048" TYPE="TITLE""glXQueryVersion", IDREF="14650" TYPE="TITLE""glXSwapBuffers", IDREF="20603" TYPE="TITLE""glXUseXFont", IDREF="37102" TYPE="TITLE""glXWaitGL", IDREF="18364" TYPE="TITLE""glXWaitX", XCreateColormap, XCreateWindow, XSyncLBL="" HELPID=""ID="35153"glXIsDirectLBL="" HELPID=""NAMEglXIsDirect - indicate whether direct rendering is enabled  LBL="" HELPID=""C SPECIFICATIONBool glXIsDirect( Display *dpy, GLXContext ctx ) LBL="" HELPID=""PARAMETERSdpySpecifies the connection to the X server.   ctxSpecifies the GLX context that is being queried.   LBL="" HELPID=""DESCRIPTIONglXIsDirect returns True if ctx is a direct rendering context, False otherwise.  Direct rendering contexts pass rendering commands directly from the calling process's address space to the rendering system, bypassing the X server.  Nondirect rendering contexts pass all rendering commands to the X server.   LBL="" HELPID=""ERRORSGLX_Bad_Context is generated if ctx is not a valid GLX context.   LBL="" HELPID=""SEE ALSOIDREF="28362" TYPE="TITLE""glXCreateContext"LBL="" HELPID=""ID="17886"glXMakeCurrentLBL="" HELPID=""NAMEglXMakeCurrent - attach a GLX context to a window or a GLX pixmap  LBL="" HELPID=""C SPECIFICATIONBool glXMakeCurrent( Display *dpy, GLXDrawable drawable, GLXContext ctx ) LBL="" HELPID=""PARAMETERSdpySpecifies the connection to the X server.   drawableSpecifies a GLX drawable.  Must be either an X window ID or a GLX pixmap ID.   ctxSpecifies a GLX rendering context that is to be attached to drawable.   LBL="" HELPID=""DESCRIPTIONglXMakeCurrent does two things: It makes ctx the current GLX rendering context of the calling thread, replacing the previously current context if there was one, and it attaches ctx to a GLX drawable, either a window or a GLX pixmap.  As a result of these two actions, subsequent OpenGL rendering calls use rendering context ctx to modify GLX drawable drawable.  Because glXMakeCurrent always replaces the current rendering context with ctx, there can be only one current context per thread.  Pending commands to the previous context, if any, are flushed before it is released.  The first time ctx is made current to any thread, its viewport is set to the full size of drawable.  Subsequent calls by any thread to glXMakeCurrent with ctx have no effect on its viewport.  To release the current context without assigning a new one, call glXMakeCurrent with drawable and ctx set to None and NULL respectively.  glXMakeCurrent returns True if it is successful, False otherwise.  If False is returned, the previously current rendering context and drawable (if any) remain unchanged.    LBL="" HELPID=""NOTESA process is a single-execution environment, implemented in a single address space, consisting of one or more threads.  A thread is one of a set of subprocesses that share a single address space, but maintain separate program counters, stack spaces, and other related global data.  A thread that is the only member of its subprocess group is equivalent to a process.   LBL="" HELPID=""ERRORSBadMatch is generated if drawable was not created with the same X screen and visual as ctx.  It is also generated if drawable is None and ctx is not None.  BadAccess is generated if ctx was current to another thread at the time glXMakeCurrent was called.  GLX_Bad_Drawable is generated if drawable is not a valid GLX drawable.  GLX_Bad_Context is generated if ctx is not a valid GLX context.  GLX_Bad_Context_State is generated if the rendering context current to the calling thread has OpenGL renderer state GL_FEEDBACK or GL_SELECT.  GLX_Bad_Current_Window is generated if there are pending OpenGL commands for the previous context and the current drawable is a window that is no longer valid.  BadAlloc may be generated if the server has delayed allocation of ancillary buffers until glXMakeCurrent is called, only to find that it has insufficient resources to complete the allocation.   LBL="" HELPID=""SEE ALSOIDREF="28362" TYPE="TITLE""glXCreateContext", IDREF="29709" TYPE="TITLE""glXCreateGLXPixmap"LBL="" HELPID=""ID="40311"glXQueryExtensionLBL="" HELPID=""NAMEglXQueryExtension - indicate whether the GLX extension is supported  LBL="" HELPID=""C SPECIFICATIONBool glXQueryExtension( Display *dpy, int *errorBase, int *eventBase ) LBL="" HELPID=""PARAMETERSdpySpecifies the connection to the X server.   errorBaseReturns the base error code of the GLX server extension.   eventBaseReturns the base event code of the GLX server extension.   LBL="" HELPID=""DESCRIPTIONglXQueryExtension returns True if the X server of connection dpy supports the GLX extension, False otherwise.  If True is returned, then errorBase and eventBase return the error base and event base of the GLX extension.  Otherwise, errorBase and eventBase are unchanged.  errorBase and eventBase do not return values if they are specified as NULL.   LBL="" HELPID=""NOTESeventBase is included for future extensions.  GLX does not currently define any events.   LBL="" HELPID=""SEE ALSOIDREF="26048" TYPE="TITLE""glXQueryVersion"LBL="" HELPID=""ID="26048"glXQueryVersionLBL="" HELPID=""NAMEglXQueryVersion - return the version numbers of the GLX extension  LBL="" HELPID=""C SPECIFICATIONBool glXQueryVersion( Display *dpy, int *major, int *minor ) LBL="" HELPID=""PARAMETERSdpySpecifies the connection to the X server.   majorReturns the major version number of the GLX server extension.   minorReturns the minor version number of the GLX server extension.   LBL="" HELPID=""DESCRIPTIONglXQueryVersion returns the major and minor version numbers of the GLX extension implemented by the server associated with connection dpy.  Implementations with the same major version number are upward compatible, meaning that the implementation with the higher minor number is a superset of the version with the lower minor number.  major and minor do not return values if they are specified as NULL.   LBL="" HELPID=""ERRORSglXQueryVersion returns False if it fails, True otherwise.  major and minor are not updated when False is returned.   LBL="" HELPID=""SEE ALSOIDREF="40311" TYPE="TITLE""glXQueryExtension"LBL="" HELPID=""ID="14650"glXSwapBuffersLBL="" HELPID=""NAMEglXSwapBuffers - make back buffer visible  LBL="" HELPID=""C SPECIFICATIONvoid glXSwapBuffers( Display *dpy, GLXDrawable drawable ) LBL="" HELPID=""PARAMETERSdpySpecifies the connection to the X server.   drawableSpecifies the window whose buffers are to be swapped.   LBL="" HELPID=""DESCRIPTIONglXSwapBuffers promotes the contents of the back buffer of drawable to become the contents of the front buffer of drawable.  The contents of the back buffer then become undefined.  The update typically takes place during the vertical retrace of the monitor, rather than immediately after glXSwapBuffers is called.  All GLX rendering contexts share the same notion of which are front buffers and which are back buffers.  An implicit glFlush is done by glXSwapBuffers before it returns.  Subsequent OpenGL commands can be issued immediately after calling glXSwapBuffers, but are not executed until the buffer exchange is completed.  If drawable was not created with respect to a double-buffered visual, glXSwapBuffers has no effect, and no error is generated.   LBL="" HELPID=""NOTESSynchronization of multiple GLX contexts rendering to the same double-buffered window is the responsibility of the clients.  The X Synchronization Extension can be used to facilitate such cooperation.   LBL="" HELPID=""ERRORSGLX_Bad_Drawable is generated if drawable is not a valid GLX drawable.  GLX_Bad_Current_Window is generated if dpy and drawable are respectively the display and drawable associated with the current context of the calling thread, and drawable identifies a window that is no longer valid.   LBL="" HELPID=""SEE ALSOIDREF="38698" TYPE="TITLE""glFlush"LBL="" HELPID=""ID="20603"glXUseXFontLBL="" HELPID=""NAMEglXUseXFont - create bitmap display lists from an X font  LBL="" HELPID=""C SPECIFICATIONvoid glXUseXFont( Font font, int first, int count, int listBase ) LBL="" HELPID=""PARAMETERSfontSpecifies the font from which character glyphs are to be taken.   firstSpecifies the index of the first glyph to be taken.   countSpecifies the number of glyphs to be taken.   listBaseSpecifies the index of the first display list to be generated.   LBL="" HELPID=""DESCRIPTIONglXUseXFont generates count display lists, named listBase through listBase + count - 1, each containing a single glBitmap command.  The parameters of the glBitmap command of display list listBase + i are derived from glyph first + i.  Bitmap parameters xorig, yorig, width, and height are computed from font metrics as descent-1, -lbearing,rbearing-lbearing, and ascent+descent, respectively.  xmove is taken from the glyph's width metric, and ymove is set to zero.  Finally, the glyph's image is converted to the appropriate format for glBitmap.  Using glXUseXFont may be more efficient than accessing the X font and generating the display lists explicitly, both because the display lists are created on the server without requiring a round trip of the glyph data, and because the server may choose to delay the creation of each bitmap until it is accessed.  Empty display lists are created for all glyphs that are requested and are not defined in font.  glXUseXFont is ignored if there is no current GLX context.   LBL="" HELPID=""ERRORSBadFont is generated if font is not a valid font.  GLX_Bad_Context_State is generated if the current GLX context is in display-list construction mode.  GLX_Bad_Current_Window is generated if the drawable associated with the current context of the calling thread is a window, and that window is no longer valid.   LBL="" HELPID=""SEE ALSOIDREF="23412" TYPE="TITLE""glBitmap", IDREF="17886" TYPE="TITLE""glXMakeCurrent"LBL="" HELPID=""ID="37102"glXWaitGLLBL="" HELPID=""NAMEglXWaitGL - complete GL execution prior to subsequent X calls  LBL="" HELPID=""C SPECIFICATIONvoid glXWaitGL( void ) LBL="" HELPID=""DESCRIPTIONOpenGL rendering calls made prior to glXWaitGL are guaranteed to be executed before X rendering calls made after glXWaitGL.  Although this same result can be achieved using glFinish, glXWaitGL does not require a round trip to the server, and it is therefore more efficient in cases where client and server are on separate machines.  glXWaitGL is ignored if there is no current GLX context.   LBL="" HELPID=""NOTESglXWaitGL may or may not flush the X stream.   LBL="" HELPID=""ERRORSGLX_Bad_Current_Window is generated if the drawable associated with the current context of the calling thread is a window, and that window is no longer valid.   LBL="" HELPID=""SEE ALSOIDREF="21959" TYPE="TITLE""glFinish", IDREF="38698" TYPE="TITLE""glFlush", IDREF="18364" TYPE="TITLE""glXWaitX", XSyncLBL="" HELPID=""ID="18364"glXWaitXLBL="" HELPID=""NAMEglXWaitX - complete X execution prior to subsequent OpenGL calls  LBL="" HELPID=""C SPECIFICATIONvoid glXWaitX( void ) LBL="" HELPID=""DESCRIPTIONX rendering calls made prior to glXWaitX are guaranteed to be executed before OpenGL rendering calls made after glXWaitX.  Although this same result can be achieved using XSync, glXWaitX does not require a round trip to the server, and it is therefore more efficient in cases where client and server are on separate machines.  glXWaitX is ignored if there is no current GLX context.   LBL="" HELPID=""NOTESglXWaitX may or may not flush the OpenGL stream.   LBL="" HELPID=""ERRORSGLX_Bad_Current_Window is generated if the drawable associated with the current context of the calling thread is a window, and that window is no longer valid.   LBL="" HELPID=""SEE ALSOIDREF="21959" TYPE="TITLE""glFinish", IDREF="38698" TYPE="TITLE""glFlush", IDREF="37102" TYPE="TITLE""glXWaitGL", XSync