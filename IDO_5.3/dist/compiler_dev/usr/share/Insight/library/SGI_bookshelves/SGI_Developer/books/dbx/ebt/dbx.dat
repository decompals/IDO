#EDIR DATA#
LANG=Cdbx User's GuideDocument Number  008-0906-090CONTRIBUTORSWritten by Wendy Ferguson and Ken JonesEdited by Christina CaryProduction by Gloria Ackley, Kay Maitz, and Lorrie WilliamsEngineering contributions by Dave Anderson and Ray Milkey© Copyright 1994, Silicon Graphics, Inc.name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]' All Rights ReservedThis document contains proprietary and confidential information of Silicon Graphics, Inc. The contents of this document may not be disclosed to third parties, copied, or duplicated in any form, in whole or in part, without the prior written permission of Silicon Graphics, Inc.RESTRICTED RIGHTS LEGENDUse, duplication, or disclosure of the technical data contained in this document by the Government is subject to restrictions as set forth in subdivision (c) (1) (ii) of the Rights in Technical Data and Computer Software clause at DFARS 52.227-7013 and/or in similar or successor clauses in the FAR, or in the DOD or NASA FAR Supplement. Unpublished rights reserved under the Copyright Laws of the United States. Contractor/manufacturer is Silicon Graphics, Inc., 2011 N. Shoreline Blvd., Mountain View, CA 94043-1389.Silicon Graphics and IRIS are registered trademarks and IRIX is a trademark of Silicon Graphics, Inc.About This GuideThis guide explains how to use the source level debugger, dbx. You can use dbx to debug programs in C, C++, Fortran77, and assembly language.LBL="" HELPID=""What This Guide ContainsThis guide describes the features of dbx and provides simple examples of how to use dbx to debug programs. Specifically, this guide includes:IDREF="27706" TYPE="TITLE"Chapter 1, "Getting Started With dbx," introduces some basic dbx commands and offers some tips about how to approach a debugging session.IDREF="88264" TYPE="TITLE"Chapter 2, "Running dbx," explains how to run dbx and perform basic dbx control functions.IDREF="93044" TYPE="TITLE"Chapter 3, "Examining Source Files," explains how to examine source files under dbx.IDREF="64712" TYPE="TITLE"Chapter 4, "Controlling dbx," describes features of dbx that affect its operation while debugging a program.IDREF="80179" TYPE="TITLE"Chapter 5, "Examining and Changing Data," describes how to examine and change data in your program while running it under dbx.IDREF="91063" TYPE="TITLE"Chapter 6, "Controlling Program Execution," describes how to use the dbx commands that control execution of your program.IDREF="33796" TYPE="TITLE"Chapter 7, "Debugging Machine Language Code," explains how to debug machine language code.IDREF="42908" TYPE="TITLE"Chapter 8, "Multiple Process Debugging," explains multiprocess debugging procedures.IDREF="74957" TYPE="TITLE"Appendix A, "dbx Commands," lists and describes all dbx commands.IDREF="56444" TYPE="TITLE"Appendix B, "Predefined Aliases," lists and describes all predefined dbx aliases.IDREF="80540" TYPE="TITLE"Appendix C, "Predefined dbx Variables," lists and describes all predefined dbx variables.LBL="" HELPID=""What You Should Know Before Reading This GuideThis manual is written for programmers, and assumes that you are familiar with general debugging techniques.LBL="" HELPID=""Suggestions for Further ReadingThis dbx User's Guide is part of the IRIS Developer Option (IDO), which provides you with the software and documentation that you need to write applications for Silicon Graphics platforms. A few IDO online and printed manuals that may be of interest to you are listed below. Programming on Silicon Graphics Systems:An Overview provides information about the IRIX programming environment and tools available for application programming. Topics covered include IRIX operating system, compilers, user interface and developer tools, and application libraries.Compiling and Performance Tuning Guide describes the compiler system and programming tools and interfaces, and explains how to improve program performance.Topics in IRIX Programming presents information about internationalizing an application, working with fonts, file and record locking, and inter-process communication.C Language Reference Manual covers the syntax and semantics of the C programming language as implemented on the IRIX operating system.Silicon Graphics offers software options to assist in software development. The CASEVision/Workshop option provides the WorkShop toolset: Debugger, Static Analyzer, Performance Analyzer, Tester, and Build Manager. You can order a printed manual from Silicon Graphics by calling SGI Direct at 1-800-800-SGI1 (800-7441). Outside the U.S. and Canada, contact your local sales office or distributor.Silicon Graphics also provides manuals online. To read an online manual after installing it, type insight or double-click the InSight icon. It's easy to print sections and chapters of the online manuals from InSight. LBL="" HELPID=""Conventions Used in This GuideThe conventions used in this manual help make information easy to access and understand. The following list describes the conventions and how they are used:Command names, including dbx commands, appear in italics. For example:The edit command lets you edit files from within dbx.Examples, shell prompts, and information displayed on the screen appear in a typewriter font. For example:Process 946: [6] trace count in mainExamples of what you enter are in boldface typewriter font. This example illustrates entering edit soar.c in response to a (dbx) prompt:(dbx) edit soar.cCommand arguments you replace with actual values appear in italics. In this example, you replace name with the name of an alias:alias nameOptional arguments are enclosed in square brackets ([ ... ]). In the following example, you can provide one or more directory names as arguments to the command:use [ dir ... ]Mutually exclusive arguments to a command are enclosed in braces ({ ... }) and separated by a pipe character (|). In the first example below, you can provide either an activation level or a procedure name as an argument to the command. In the second example, because the argument choices are enclosed in square brackets, you can use either the call or return argument, or omit an argument to the command:func { activation_level | procedure }
syscall catch [{ call | return }]File and directory names appear in italics. For example:You can put any dbx command in the .dbxinit file.New terms appear in italics. For example:Each procedure on the stack defines an activation level.LBL="1"ID="27706"Getting Started With dbxYou can use dbx to trace problems in a program at the source code level, rather than at the machine code level. ID="01.start1"dbx enables you to control a program's execution, symbolically monitoring program control flow, variables, and memory locations. You can also use dbx to trace the logic and flow of control to acquaint yourself with a program written by someone else.This chapter introduces some basic dbx commands and discusses some tips about how to approach a debugging session. Specifically, this chapter covers:IDREF="89331" TYPE="TITLE""Examining Core Dumps to Determine Cause of Failure"IDREF="84992" TYPE="TITLE""Debugging Your Programs"IDREF="30965" TYPE="TITLE""Studying a New Program"IDREF="85965" TYPE="TITLE""Avoiding Common Pitfalls"LBL="" HELPID=""ID="89331"Examining Core Dumps to Determine Cause of FailureEven if your program compiles successfully, it still can crash when you try to run it. When a program crashes, it generates a terminating signal that instructs the system to write out to a ID="01.start2"ID="01.start3"core file. The core file is the memory image of the program at the time it crashed.You can examine the core file with dbx to determine at what point your program crashed. To determine the point of failure, follow these steps:If the core file is not in the current directory, specify the pathname of the core file on the dbx command line.NoteIf the source code for the program is on a different machine or the source was moved, provide dbx with the pathname to search for source code (also see IDREF="35657" TYPE="TITLE""Specifying Source Directories"). Invoke ID="01.start4"dbx for the failed program as described in IDREF="67611" TYPE="TITLE""Invoking dbx".dbx automatically reads in the local core file.Perform a stack trace using the ID="01.start5"whereID="01.start6" command (described in IDREF="50445" TYPE="TITLE""Examining the Stack") to locate the failure point.For example, suppose you examine the core file for a program called test. Suppose the stack trace appears as follows:(dbx) where
>  0 foo2(i = 5) ["/usr/tmp/test.c":44, 0x1000109c]
   1 foo(i = 4) ["/usr/tmp/test.c":38, 0x1000105c]
   2 main(argc = 1, argv = 0xffffffad78) ["/usr/tmp/test.c":55, 0x10001104]
   3 __start() ["/shamu/crt1text.s":137, 0x10000ee4]In this case, test crashed at line 44 of the source file test.c. The program crashed while executing the function foo2. foo2 was called from line 38 in the function foo, which was in turn called from line 55 in the function main. You can use the other features of dbx to examine values of program variables and otherwise investigate why test crashed.If you use dbx to debug code that wasn't compiled using the ID="01.start7"­g option, local variables are invisible to dbx, and source lines may appear to jump around as a result of various optimizations. If the code is stripped of its debugging information, ID="01.start8"dbx displays very little information. LBL="" HELPID=""ID="84992"Debugging Your ProgramsDebugging a program consists primarily of stopping your program under certain conditions and then examining the state of the program stack and the values stored in program variables.ID="01.start9"You stop execution of your program by setting ID="01.start10"breakpoints in your program. Breakpoints can be ID="01.start11"unconditional, in which case they always stop your program when encountered, or ID="01.start12"conditional, in which case they stop your program only if a test condition that you specify is true. (See IDREF="23865" TYPE="TITLE""Setting Breakpoints" for more information.)To use breakpoints to debug your program, examine your program carefully to determine where problems are likely to occur, and set breakpoints in these problem areas. If your program crashes, first determine which line causes it to crash, then set a breakpoint just before that line.You can use several dbx commands to trace a variable's value. Here's a simple method for tracing a program variable:Use the stopID="01.start13" command (see IDREF="23865" TYPE="TITLE""Setting Breakpoints") to set breakpoints in the program at locations where you want to examine the state of the program stack or the values stored in program variables.ID="01.start14"Use the runID="01.start15" or rerunID="01.start16" command (described in IDREF="23899" TYPE="TITLE""Running Your Program") to run your program under dbx. The program stops at the first breakpoint that it encounters during execution.Examine the program variable as described in ID="01.start17"IDREF="85784" TYPE="TITLE""Displaying the Value of a Variable". Examine the program stack as described in ID="01.start18"IDREF="50445" TYPE="TITLE""Examining the Stack".Use the cont command (see IDREF="31983" TYPE="TITLE""Continuing Execution After a Breakpoint") to continue execution past a breakpoint. However, you cannot continue execution past a line that crashes the program.ID="01.start19"LBL="" HELPID=""ID="30965"Studying a New ProgramUseID="01.start20" dbx to examine the flow of control in a program. When studying the flow of control within a program, use the dbx commands stop, run/rerun, printID="01.start21", nextID="01.start22", stepID="01.start23", and cont. To study a new program:Use the stop command to set breakpoints in the program. When you execute the program under dbx, it stops execution at the breakpoints.If you want to review every line in the program, set a breakpoint on the first executable line. If you don't want to look at each line, set breakpoints just before the sections you intend to review.Use the run and rerun commands to run the program under dbx. The program stops at the first breakpoint.Use the printID="01.start24" command to print the value of a program variable at a breakpoint.ID="01.start25"Use the step, next, or cont command to continue past a breakpoint and execute the rest of the program.step executes the next line of the program. If the next line is a procedure call, ID="01.start26"step steps down into the procedure. step is described in IDREF="33387" TYPE="TITLE""Stepping Using the step Command".next executes the next line; if it is a procedure, next executes it but does not step down into it. next is described in IDREF="24643" TYPE="TITLE""Stepping Using the next Command".cont resumes execution of the program past a breakpoint and does not stop until it reaches the next breakpoint or the end of the program. cont is explained in IDREF="31983" TYPE="TITLE""Continuing Execution After a Breakpoint".Another tool that you can use to follow the execution of your program is the traceID="01.start27" command (described in IDREF="19256" TYPE="TITLE""Tracing Program Execution"). With it you can examine:values of variables at specific points in your program or whenever variables change valueID="01.start28"parameters passed to and values returned from functionsID="01.start29"line numbers as they are executedID="01.start30"LBL="" HELPID=""ID="85965"Avoiding Common PitfallsYou may encounter some problems when you debug a program. Common problems and their solutions are listed below.ID="01.start31"If ID="01.start32"dbx does not display variables, recompile the program with the ID="01.start33"­g compiler option. Note that in some cases, this may cause the problem to go away, or its symptoms to change.If the debugger's listing seems confused, try separating the lines of source code into logical units. The debugger may get confused if more than one source statement occurs on the same line.ID="01.start34"If the debugger's executable version of the code doesn't match the source, recompile the source code. The code displayed in the debugger is identical to the executable version of the code.ID="01.start35"If code appears to be missing, it may be contained in an include file or a macro. The debugger treats macros as single lines. To debug a macro, expand the macro in the source code.ID="01.start36"ID="01.start37"ID="01.start38"ID="01.start39"ID="01.start40"LBL="2"ID="88264"Running dbxThis chapter explains how to run dbxname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'specifically, it covers:IDREF="97214" TYPE="TITLE""Compiling a Program for Debugging Under dbx"IDREF="68536" TYPE="TITLE""Compiling and Linking Programs With Dynamic Shared Objects"IDREF="67611" TYPE="TITLE""Invoking dbx" from a shellIDREF="23899" TYPE="TITLE""Running Your Program"IDREF="87665" TYPE="TITLE""Automatically Executing Commands on Startup"IDREF="92439" TYPE="TITLE""Using Online Help"IDREF="79140" TYPE="TITLE""Entering Multiple Commands on a Single Line"IDREF="94741" TYPE="TITLE""Spanning a Command Across Multiple Lines"IDREF="38587" TYPE="TITLE""Invoking a Shell" from dbxIDREF="10584" TYPE="TITLE""Quitting dbx"LBL="" HELPID=""ID="97214"Compiling a Program for Debugging Under dbxBefore using ID="02.run1"dbx to debug a program, compile the program using the ID="02.run2"­g option (for example, cc ­g). The ­g option includes additional debugging information in your program object so that dbx can list local variables and find source lines.If you use dbx to debug code that was not compiled using the ­g option, local variables are invisible to dbx, and source lines may appear to jump around oddly as a result of various optimizations. It is more difficult to debug code without reliable references to lines of source code.LBL="" HELPID=""ID="68536"Compiling and Linking Programs With Dynamic Shared ObjectsThis section summarizes a few things you need to know if you compile and link your program with Dynamic Shared Objects (DSOs). A DSO is a relocatable shared library. By linking with a DSO, you keep your program size small and use memory efficiently. ID="02.run3"If you compile and link with DSOs, dbx automatically notices their use in the program and picks up the relevant debugging information. The dbx command ID="02.run4"listobj shows any DSOs in a process. The dbx command ID="02.run5"whichobj lists all DSOs in which the named variable is present.See IDREF="23899" TYPE="TITLE""Running Your Program" for more description of the differences between programs compiled and linked with DSOs and programs compiled and linked with non-shared libraries. See also the dbx help section on hint_dso for more information on dbx and DSOs. For more information on DSOs, see "Using Dynamic Shared Objects" in the Compiling and Performance Tuning Guide. LBL="" HELPID=""ID="67611"Invoking dbxThis section describes how to invoke dbx and includes:IDREF="16626" TYPE="TITLE""dbx Options"IDREF="89350" TYPE="TITLE""Specifying Object and Core Files"IDREF="14382" TYPE="TITLE""The dbx Prompt"IDREF="83396" TYPE="TITLE""Specifying Files with dbx Commands"To invoke ID="02.run6"dbx from the shell command line, type dbx. The syntax is:dbx [options] [object_file [corefile]]LBL="" HELPID=""ID="16626"dbx OptionsIDREF="38456" TYPE="TABLE"Table 2-1 lists options you can give to dbx. These options are described in detail later in this chapter.COLUMNS="2"LBL="2-1"Table 2-1 ID="38456" dbx Command-Line OptionsLEFT="0" WIDTH="81"OptionLEFT="90" WIDTH="243"DescriptionLEFT="0" WIDTH="81"ID="02.run7"­IdirLEFT="90" WIDTH="243"Tells dbx to look in the specified directory (in addition to the 
current directory and the object file's directory) for source 
files. To specify multiple directories, use a separate ID="02.run8"­I for 
each. If no directory is specified when you invoke dbx, it 
looks for source files in the current directory and in the 
object file's directory. From dbx, changes the directories 
searched for source files with the ID="02.run9"use and ID="02.run10"dir commands.LEFT="0" WIDTH="81"ID="02.run11"­cfile LEFT="90" WIDTH="243"Selects a command file other than ID="02.run12".dbxinit to execute on 
starting dbx. For information on .dbxinit, see IDREF="87665" TYPE="TITLE""Automatically 
Executing Commands on Startup."LEFT="0" WIDTH="81"ID="02.run13"­enumLEFT="90" WIDTH="243"Chooses a large size for the evaluation stack (as large as you 
want). The default stack size is 20,000 bytes. ID="02.run14"num = number 
of bytes. If you see the message toolargetoevaluate, 
rerun dbx suppling a value greater than 20,000. LEFT="0" WIDTH="81"ID="02.run15"­kLEFT="90" WIDTH="243"Turns on kernel debugging. When debugging a running 
system, specify ID="02.run16"/dev/kmem as the core file.LEFT="0" WIDTH="81"ID="02.run17"­iLEFT="90" WIDTH="243"Uses interactive mode. This option prompts for source even 
when it reads from a file and treats data in a file as if it comes 
from a terminal (stdin). This option does not treat "#" 
characters as comments in a file. ID="02.run18"LEFT="0" WIDTH="81"ID="02.run19"­ppidLEFT="90" WIDTH="243"Debugs the process specified by the pid number.LEFT="0" WIDTH="81"ID="02.run20"­PnameLEFT="90" WIDTH="243"Debugs the running process with the specified ID="02.run21"name (name as 
described in the ps(1) reference page).LEFT="0" WIDTH="81"ID="02.run22"­rprogram [arg]LEFT="90" WIDTH="243"Runs the named program upon entering ID="02.run23"dbx, using the 
specified arguments. The .dbxinit file (if any) is read and 
executed after executing the object_file. You cannot specify a 
core file with ­r.LBL="" HELPID=""ID="89350"Specifying Object and Core FilesThe object_file is the name of the executable object file that you want to debug. It provides both the code that ID="02.run24"dbx executes and the symbol table that provides variable and procedure names and maps executable code to its corresponding source code in source files.A corefileID="02.run25" is produced when a program exits abnormally and produces a core dump. dbx allows you to provide the name of a core file that it uses as "the contents of memory" for the program that you specify. If you provide a core file, dbx lists the point of program failure. You can then perform stack traces and examine variable values to determine why a program crashed. However, you cannot force the program to execute past the line that caused it to crash.If you don't specify a corefile, dbx examines the current directory for a file named core. If it finds core, and if core seems (based on data in the core file) to be a core dump of the program you specified, dbx acts as if you had specified core as the core file.You can specify object and core files either as arguments when you invoke ID="02.run26"ID="02.run27"dbx or as commands that you enter at the dbx prompt.LBL="" HELPID=""ID="14382"The dbx PromptOnce dbx starts, it displays the prompt:ID="02.run28"(dbx) To change this prompt, change the value of the dbxID="02.run29"$prompt variable. IDREF="78540" TYPE="TITLE""Setting dbx Variables" describes how to set dbx variables.LBL="" HELPID=""ID="83396"Specifying Files with dbx CommandsThe ID="02.run30"givenfile and ID="02.run31"corefiledbx commands allow you to set the object file and the core file, respectively, while dbx is running.givenfileID="02.run32" [file]If you provide a filename, dbx kills the currently running processes and loads the executable code and debugging information found in file.If you do not provide a filename, dbx displays the name of the program that it is currently debugging without changing it.corefileID="02.run33" [file]If you provide a filename, dbx uses the program data stored in the core dump file.If you do not provide a filename, dbx displays the name of the current core file without changing it.LBL="" HELPID=""ID="23899"Running Your ProgramYou can start your program under ID="02.run34"dbx using the ID="02.run35"run or ID="02.run36"rerun command.runID="02.run37" run-arguments The run command starts your program and passes to it any arguments that you provide. The run command uses your shell (the program named in the SHELL environment variable or /bin/sh if an environment variable does not exist) to process a run command. The shell syntax allowed in your shell is allowed on the run command line. All shell processing is accepted, such as expansion and substitution of * and ? in filenames. Redirection of the program's standard input and standard output, and/or standard error is also done by the shell. In other words, the ID="02.run38"ID="02.run39"ID="02.run40"run command does exactly what typing target run-arguments at the shell prompt does. You can specify target either on dbx invocation or in a prior givenfile command. dbx passes ./target as argv[0] to target when you specify it as a relative pathname. A run command must appear on a line by itself and cannot be followed by another dbx command separated by a semi-colon (;). Terminate the command line with a return (new-line). Note that you cannot include a run command in the command list of a when command.rerunID="02.run41" [run-arguments]The ID="02.run42"rerun command, without any arguments, repeats the last run command if applicable. Otherwise rerun is equivalent to the run command without any arguments.The sort command takes an input file and produces a sorted output file; you can specify input and output files either through command-line arguments or file redirection. For example, from the command line you can enter:% sort -i input -o output
% sort < input2 > output2If you are debugging the sort program, the equivalent dbx commands are:(dbx) run -i input -o output
(dbx) run < input2 > output2If you execute these run commands in the order presented, you can repeat the last run command by using the rerun command:(dbx) rerunLBL="" HELPID=""ID="87665"Automatically Executing Commands on StartupYou can use an editor to create a ID="02.run43".dbxinit command file. This file contains various dbx commands that automatically execute when you invoke dbx. You can put any dbx command in the .dbxinit file. If a command requires input, the system prompts you for it when you invoke dbx.On invocation, dbx looks for a .dbxinit file in the current directory. If the current directory does not contain a .dbxinit file, dbx looks for one in your home directory. (This assumes that you have set the IRIX system ID="02.run44"HOME environment variable.)LBL="" HELPID=""ID="92439"Using Online HelpThe ID="02.run45"dbx command ID="02.run46"help has several options:helpshows the supported dbx commandshelp keywordshows information pertaining to the given keyword, such as alias, help, most_used, quit, playback, record, and so onhelp allshows the entire dbx help fileWhen you type help all, dbx displays the file using the command name given by the dbxID="02.run47"$pager variable. The dbx help file is large and can be difficult to read even if you use a simple paging program like more(1). You can set the $pager variable to a text editor like vi(1) or to your favorite editor. For example, just add the following command in your .dbxinit file:set $pager = viWhen the above entry is in your .dbxinit file, dbx displays the help file in vi. You can then use the editor's search commands to look through the help file quickly. Quit the editor to return to dbx.LBL="" HELPID=""ID="79140"Entering Multiple Commands on a Single LineYou can use a semicolon (ID="02.run48";) as a separator to include multiple commands on the same command line. This is useful with commands such as when (described in IDREF="89878" TYPE="TITLE""Writing Conditional Commands") as it allows you to include multiple commands in the command block. For example:(dbx) when at "myfile.c":37 {print a ; where ; print b}LBL="" HELPID=""ID="94741"Spanning a Command Across Multiple LinesYou can use a backslash (ID="02.run49"\) at the end of a line of input to indicate that the command is continued on the next line. This can be convenient when entering complex commands such as an alias definition (aliases are discussed in IDREF="37216" TYPE="TITLE""Creating and Removing dbx Aliases"). For example:(dbx) alias foll "print *(struct list *)$p ; \
set $p = (int)((struct list *)($p))->next"HintYou can also use the hed command for creating and modifying commands. IDREF="59470" TYPE="TITLE""The History Editor" has details on this command.LBL="" HELPID=""ID="38587"Invoking a ShellTo invoke a subshell, enter ID="02.run50"sh at the dbx prompt, or enter sh and a shell command at the dbx prompt. After invoking a subshell, type exit or <Ctrl-d> to return to dbx.The syntax for the sh command is:shID="02.run51"Invoke a subshell.sh commandExecute the specified shell command. ID="02.run52"dbx interprets the rest of the line as a command to pass to the spawned shell process, unless you enclose the command in double-quotes or you terminate your shell command with a semicolon (;).For example, to spawn a subshell, enter:(dbx) sh
% To display the end of the file datafile, enter:(dbx) sh tail datafileLBL="" HELPID=""ID="10584"Quitting dbxTo end a ID="02.run53"dbx debugging session, enter the ID="02.run54"quit command at the dbx prompt:(dbx) quitLBL="3"ID="93044"Examining Source FilesThis chapter explains how to examine source files under dbx. It describes:IDREF="35657" TYPE="TITLE""Specifying Source Directories"IDREF="41684" TYPE="TITLE""Changing Source Files"IDREF="59599" TYPE="TITLE""Listing Source Code"IDREF="91727" TYPE="TITLE""Searching Through Source Code"IDREF="33324" TYPE="TITLE""Calling an Editor"LBL="" HELPID=""ID="35657"Specifying Source DirectoriesBased on the information contained in an object file's symbol table, dbx determines from which source files the program was compiled and prints portions of these files as appropriate.ID="03.examin1"Object files compiled with ID="03.examin2"ID="03.examin3"­g record the absolute path names to the source files. Each time dbx needs a source file, it first searches the absolute path for the source file. If the source file is not present (or if the object file was not compiled with ­g), dbx checks its own list of directories for source files.By default, the dbx directory list contains only the current directory (from which you invoked ID="03.examin4"dbx) and the object file's directory (if it is different from the current directory). Each time dbx searches this list, it searches all directories in the list in the order in which they appear until it finds the file with the specified name.LBL="" HELPID=""Specifying Source Directories With ArgumentsYou can specify additional source directories when you invoke ID="03.examin5"dbx with the ID="03.examin6"­I option. To specify multiple directories, use a separate ­I for each.For example, consider debugging a program called look in /usr/local/bin, the source for which resides in /usr/local/src/look.c. To debug this program, you can invoke dbx from the /usr/local/bin directory by entering:% dbx -I /usr/local/src lookLBL="" HELPID=""Specifying Source Directories With dbx CommandsThe ID="03.examin7"dir and ID="03.examin8"use commands allow you to specify a source directory list while dbx is running.dirID="03.examin9" [dir ...]If you provide one or more directories, ID="03.examin10"dbx adds those directories to the end of the source directory list. If you do not provide any directories, dbx displays the current source directory list.use ID="03.examin11"[dir ...]If you provide one or more directories, ID="03.examin12"dbx replaces the source directory list with the directories that you provide.If you do not provide any options, dbx displays the current source directory list.NoteBoth the dir and use commands recognize absolute and relative pathnames (for example, ../src); however, they do not recognize C shell tilde (~) syntax (for example, ~kim/src) or environment variables (for example, $HOME/src).LBL="" HELPID=""Examples of dir and useLet's debug the look program in /usr/local/bin. Recall that the source resides in /usr/local/src/look.c. If you invoke dbx from the /usr/local/bin directory without specifying /usr/local/src as a source directory, it will not initially appear in the directory list:(dbx) dir
.However, you can add /usr/local/src with the dir command by entering:(dbx) dir /usr/local/src
(dbx) dir
. /usr/local/srcIf you use the use command instead, the current directory is no longer contained in the source directory list:(dbx) use /usr/local/src
(dbx) use
/usr/local/srcLBL="" HELPID=""Using Path RemappingFiles compiled with ID="03.examin13"­g have full pathnames to source files. If you're debugging a program that was compiled somewhere else and you want to specify a new path to the sources, use path remapping. Just substitute one pattern for another pattern to remap the path so dbx can find the source file.dir ID="03.examin14"pattern1:pattern2The ID="03.examin15"dir (or use) command allows you to remap directories and specify a new path to the source. dbx substitutes pattern2 for pattern1.For example, a compiled program's source is /x/y/z/kk.c. The source was moved to /x/y/zzz/kk/kk.c. Specify the dir (or use) command to remap the path:(dbx) dir /z/:/zzz/kk/The new path is /x/y/zzz/kk/kk.c where /z/ is replaced by the path specified after the colon.LBL="" HELPID=""ID="41684"Changing Source FilesThe ID="03.examin16"file command changes the current source file to a file that you specify. The new file becomes the current source file, on which you can search, list, and perform other operations. For example, to set the current source file to ID="03.examin17"ID="03.examin18""Examining the Stack" on page 54procedure.c, enter:(dbx) file procedure.cNoteIf your program is large, typically you store the source code in multiple files. dbx automatically selects the proper source file for the section of code that you are examining. Thus, many dbx commands reset the current source file as a side effect. For example, when you move up and down activation levels in the stack using the up and down commands, dbx changes the current source file to whatever file contains the source for the procedure (see IDREF="50445" TYPE="TITLE""Examining the Stack" for more information on activation levels).If you enter the file command without any arguments, dbx prints the current source file:(dbx) file
procedure.cYou can also change the current source file by typing:(dbx) funcprocedureYou can use the tag command to search the tag file for procedure:(dbx) tag procedureThe tag command finds C preprocessor macros if they have arguments (funcprocedure cannot). For more information about the tag file, see ctags(1).LBL="" HELPID=""ID="59599"Listing Source CodeThe list command displays lines of source code. The dbx variable ID="03.examin19"$listwindow defines the number of lines dbx lists by default. The list command uses the active frame and line of the current source file unless overridden by a file command. Any execution of the program overrides the file command by establishing a new current source file. The syntax for the list command is:listID="03.examin20"Lists ID="03.examin21"$listwindow lines beginning at the current line (or list the line of the current pc if the current line is unknown or not set). list expLists ID="03.examin22"$listwindow lines starting with the line number given by the expression exp. The expression can be any valid expression that evaluates to an integer value as described in IDREF="25993" TYPE="TITLE""Using Expressions".list exp1:exp2Lists exp2 lines, beginning at line exp1.list exp1,exp2Lists all source between line exp1 and line exp2 inclusive.list funcLists $listwindow lines starting at procedure func.list func,expLists all source between func and exp, inclusive.list func:expLists exp lines, beginning at func.A > symbol prints to the left of the line that is the current line. A * symbol prints to the left of the line of the current pc location. For example, to list lines 20­35 of a file, enter:(dbx) list 20,35In response to this command, dbx displays lines 20 through 35 and sets the current line to 36.To list 15 lines starting with line 75, enter:(dbx) list 75:15In response to this command, dbx displays lines 75 through 89 and sets the current line to 90.LBL="" HELPID=""ID="91727"Searching Through Source CodeUse the forward slash (ID="03.examin23"/ID="03.examin24") and question mark (?ID="03.examin25") commands to search through the current file for regular expressions in source code. For a description of regular expressions, see the ed(1) reference page.The search commands have the following syntax:ID="03.examin26"/[reg_exp]Search forward through the current file from the current line for the regular expression reg_exp. If dbx reaches the end of the file without finding the regular expression, it wraps around to the beginning of the file. dbx prints the first source line containing a match of the search expression.If you don't supply a regular expression, dbx searches forward based on the last regular expression searched.ID="03.examin27"?[reg_exp]Search backward through the current file from the current line for the regular expression reg_exp. If dbx reaches the beginning of the file without finding the regular expression, it wraps around to the end of the file. dbx prints the first source line containing a match of the search expression.If you don't supply a regular expression, dbx searches backward based on the last regular expression searched.For example, to search forward for the next occurrence of the string "errno," enter:(dbx) /errnoTo search backward for the previous occurrence of either "img" or "Img," enter:(dbx) ?[iI]mgLBL="" HELPID=""ID="33324"Calling an EditorThe ID="03.examin28"edit command lets you edit files from within ID="03.examin29"dbx:editID="03.examin30"The edit command invokes an editor (vi by default) on the current source file. If you set the dbx variable ID="03.examin31"$editor to the name of an editor, the edit command invokes that editor. If you do not set the $editor, dbx checks the environment variable ID="03.examin32"EDITOR and, if set, invokes that editor. When you exit the editor, you return to the dbx prompt.edit fileThe edit command invokes the editor on the given file. edit procedureThe edit command invokes the editor on the file that contains the source for the given procedure. For example, to edit a file named soar.c from within dbx, type:(dbx) edit soar.cThe edit command is also useful for editing dbx script files. See IDREF="60766" TYPE="TITLE""Executing dbx Scripts" for more information on script files.LBL="4"ID="64712"Controlling dbxThis chapter describes features of dbx that affect its operation while debugging a program. Specifically, this chapter covers:IDREF="88718" TYPE="TITLE""Creating and Removing dbx Variables"IDREF="82250" TYPE="TITLE""Using the History Feature and the History Editor"IDREF="37216" TYPE="TITLE""Creating and Removing dbx Aliases"IDREF="43528" TYPE="TITLE""Recording and Playing Back dbx Input and Output"IDREF="60766" TYPE="TITLE""Executing dbx Scripts"LBL="" HELPID=""ID="88718"Creating and Removing dbx Variablesdbx allows you to define variables that you can use within ID="04.cntrl1"dbx to store values. These variables exist entirely in dbx; they are not part of your program. You can use dbx variables for a variety of purposes while debugging. For example, you can use dbx variables as temporary storage, counters, or pointers that you use to step through arrays.dbx also provides many predefined variables that control how various ID="04.cntrl2"dbx commands function. IDREF="80540" TYPE="TITLE"Appendix C, "Predefined dbx Variables" provides a complete list of predefined dbx variables and their purposes.A dbx variable does not have a fixed type. You can assign a dbx variable any type of value, even if it already has a value of a different type. However, a variable predefined by dbx does have a fixed predefined type.You can use almost any name for dbx variables. A good practice to follow is to use a dollar sign ($) as the first character of all dbx variables to prevent conflicts with most program variable names. All of dbx's predefined variables begin with a dollar sign.The commands described in this section apply only to the manipulations of dbx variables, not program variables. IDREF="50911" TYPE="TITLE""Displaying and Changing Program Variables" describes how to manipulate program variables.LBL="" HELPID=""ID="78540"Setting dbx VariablesThe ID="04.cntrl3"ID="04.cntrl4"set command sets a dbx variable to a given value, defining the variable if it does not exist:setID="04.cntrl5" var = expDefine (or redefine) the specified ID="04.cntrl6"dbx variable, setting its value to that of the expression you provide.You can display the value of a variable with the ID="04.cntrl7"print command. For example:(dbx) set $k = 1
(dbx) print $k
1
(dbx) set $k = $k +23
(dbx) print $k
24
(dbx) print $k / 11
2In the above example, dbx performs an integer division because both the variable $k and the constant 11 are integers. If you assign a floating point value to $k and evaluate the expression again, dbx performs a floating point division:(dbx) set $k = 24.0
(dbx) print $k
24.0
(dbx) print $k / 11
2.1818181818181817NoteWe recommend that you begin a dbx variable with a $ to avoid confusion with a program variable. A dbx variable without a leading $ hides any program variable that has the same name. The only way to see the program variable is to remove the dbx variable with an unset command.LBL="" HELPID=""Listing dbx VariablesIf you enter the ID="04.cntrl8"ID="04.cntrl9"set command without providing any arguments, dbx displays (in alphabetical order) a list of all currently defined dbx variables, including predefined variables. Partial output looks like this:(dbx) set
$addrfmt        "0x%x"
$addrfmt64      "0x%llx"
$assignverify   1
$casesense      2
$ctypenames     1
$curevent       3
$curline        44
$curpc          268439708
...
$stacktracelimit        1024
$stdc           0
$stepintoall    0
$tagfile        "tags"LBL="" HELPID=""Removing VariablesThe ID="04.cntrl10"ID="04.cntrl11"unset command removes a dbx variable. For example, to delete the variable $k, enter:(dbx) unset $kLBL="" HELPID=""ID="82250"Using the History Feature and the History EditorThe dbx history feature is similar to the C shell's history feature in that it allows you to repeat commands that you have entered previously. However, unlike the C shell's history feature, ID="04.cntrl12"ID="04.cntrl13"dbx does not allow you to execute a history command anywhere except the beginning of a line. Also, dbx does not support history substitution of command arguments such as the C shell !$ argument.LBL="" HELPID=""Examining the History Listdbx stores all commands that you enter in the history list. The value of the ID="04.cntrl14"dbx variable $lines determines how many commands are stored in the history list. The default value is 100.Display the history list with the ID="04.cntrl15"ID="04.cntrl16"history command. For example, after setting a breakpoint, running a program, and examining some variables, your history list might look something like this:(dbx) history
  1     set $prompt = "(dbx)"
  2     set $page=0
  3     set $pimode=1
  4     stop in main
  5     historyLBL="" HELPID=""Repeating CommandsYou can execute any of the commands contained in the history list. Each history command begins with an exclamation point (ID="04.cntrl17"ID="04.cntrl18"!):ID="04.cntrl19"!!Repeats the previous command. If the value of the dbx variable ID="04.cntrl20"$repeatmode is set to 1, then entering a carriage return at an empty line is equivalent to executing !!. By default, $repeatmode is set to 0.ID="04.cntrl21"!stringRepeats the most recent command that starts with the specified string.ID="04.cntrl22"!integerRepeats the command associated with the specified integer in the history list.ID="04.cntrl23"!-integerRepeats the command that occurred integer times before the most recent command. Entering !-1 executes the previous command, !-2 the command before that, and so forth.You can use the !! command to facilitate single-stepping through your program. (Single-stepping is described in IDREF="31135" TYPE="TITLE""Stepping Through Your Program".) The following illustrates using the next command to execute 5 lines of source code and then using the !! command to repeat the next command. For example:(dbx) next 5
Process 22545 (test) stopped at [main:60 ,0x10001150]
  60  total += j;
(dbx) !!
(!! = next 5)
Process 22545 (test) stopped at [main:65 ,0x100011a0]
  65  printf("i = %d, j = %d, total = %d\n",i,j,total);Another convenient way to repeat a commonly used command is with !string. For example, suppose that you occasionally print the values of certain variables using the printf command while running your program under dbx. (The printf command is described in IDREF="17137" TYPE="TITLE""Printing Expressions".) In this case, as long as you do not enter any command beginning with "pr" after you enter the printf command, you can repeat the printf command by entering !pr. For example:(dbx) printf "i = %d, j = %d, total = %d\n", i, j, total
i = 4, j = 25, total = 1
  ...
(dbx) !pr
i = 12, j = 272, total = 529Using !integer, you can repeat any command in the history list. If you want to repeat the printf command, but you have entered a subsequent print command, examine the history list and then explicitly repeat the printf command using its reference number. For example:(dbx) history
  1     set $prompt = "(dbx)"
  2     set $page=0
  ...
  45    printf "i = %d, j = %d, total = %d\n", i, j, total
  46    next
  ...
  49    print j
  ...
  53    history
(dbx) !45
(!45 = printf "i = %d, j = %d, total = %d\n", i, j, total)
i = 9, j = 43, total = 1084LBL="" HELPID=""ID="59470"The History EditorThe history editor, ID="04.cntrl24"ID="04.cntrl25"hed, lets you use your favorite editor on any or all of the commands in the current dbx history list. When you enter the ID="04.cntrl26"hed command, dbx copies all or part of the history list into a temporary file that you can edit. When you quit the editor, any commands left in this temporary file are automatically executed by dbx.If you have set the dbx variable ID="04.cntrl27"$editor to the name of an editor, the hed command invokes that editor. If you have not set the dbx variable $editor, dbx checks whether you have set the environment variable ID="04.cntrl28"EDITOR and, if so, invokes that editor. If you have not set either the dbx variable or the environment variable, dbx invokes the vi editor.The syntax for the hed commands is:hedID="04.cntrl29"Edits only the last line of the history list (the last command executed).hed num1Edits line num1 in the history list.hedID="04.cntrl30" num1,num2Edits the lines in the history list from num1 through num2.hed allID="04.cntrl31"Edits the entire history list.By default, dbx doesn't display the commands that it executes as a result of the hed command (the dbx variable $pimode is set to 0). If ID="04.cntrl32"$pimode is set to 1, dbx displays the commands as it executes them. See $pimode in IDREF="80540" TYPE="TITLE"Appendix C, "Predefined dbx Variables" for more information.LBL="" HELPID=""ID="37216"Creating and Removing dbx AliasesYou can create dbx aliases for debugger commands. Use these aliases as you would any other ID="04.cntrl33"dbx command. When dbx encounters an alias, it expands the alias using the definition you provided.dbx has a group of predefined aliases that you can modify or delete. These aliases are listed and described in ID="04.cntrl34"IDREF="56444" TYPE="TITLE"Appendix B, "Predefined Aliases."If you find that you often create the same aliases in your debugging sessions, you can include their definitions in your .dbxinit file so that they are automatically defined for you. See IDREF="87665" TYPE="TITLE""Automatically Executing Commands on Startup" for more information on the .dbxinit file.LBL="" HELPID=""Listing AliasesYou can display the definition of aliases using the ID="04.cntrl35"ID="04.cntrl36"alias command:aliasID="04.cntrl37"Lists all existing aliases.aliasID="04.cntrl38" nameLists the alias definition for name.For example, to display the definitions of the predefined aliases "l" and "bp," enter:(dbx) alias l
"list"
(dbx) alias bp
"stop in"LBL="" HELPID=""Creating Command AliasesYou can use the ID="04.cntrl39"ID="04.cntrl40"alias command to define new aliases:aliasID="04.cntrl41" name commandDefines ID="04.cntrl42"name as an alias for command.aliasID="04.cntrl43" name "string"Defines ID="04.cntrl44"name as an alias for string. With this form of the alias command, you can provide command arguments in the alias definition.aliasID="04.cntrl45" name(arg1 [, ... argN]) "string"Defines ID="04.cntrl46"name as an alias for string. arg1 through argN are arguments to the alias, appearing in the string definition. When you use the alias, you must provide values for the arguments, which dbx then substitutes in string.The simplest form of an alias is to redefine a dbx command with a short alias. Many of the predefined dbx aliases fall into this category: "a" is an alias for the assign command, "s" is an alias for the step command. When you use one of these aliases, dbx simply replaces it with the command for which it is an alias. Any arguments that you include on the command line are passed to the command.For example, if you to create "gf" as an alias for the givenfile command, enter:(dbx) alias gf givenfile
(dbx) alias gf
"givenfile"
(dbx) gf
Current givenfile is test
(dbx) gf test2
Process 22545 (test) terminated
Executable /usr/var/tmp/dbx_examples/test2
(dbx) gf
Current givenfile is test2More complex alias definitions require more than the name of a command. In these cases, you must enclose the entire alias definition string in double quotation marks. For example, you can define a brief alias to print the value of a variable that you commonly examine. Note that you must use the escape character (\) to include the double quotation marks as part of the alias definition. For example:(dbx) alias pa "print \"a =\", a"
(dbx) alias pa
"print "a =", a"
(dbx) pa
a = 3You can also define an alias so that you can pass arguments to it, much in the same way that you can provide arguments in a C language macro definition. When you use the alias, you must include the arguments. dbx then substitutes the values that you provide in the alias definition.To illustrate this, consider the following alias definition:(dbx) alias p(arg1, arg2, arg3, arg4) "print '|arg1|arg2|arg3|arg4|'"
(dbx) alias p
(arg1, arg2, arg3, arg4)"print '|arg1|arg2|arg3|arg4|'"The "p" alias takes four arguments and prints them surrounded by vertical bars (|). For example:(dbx) p(1,2,3,4)
|1|2|3|4|
(dbx) p( first, second, 3rd,4)
| first| second| 3rd|4|In the previous example, dbx retains any spaces that you enter when calling an alias.You can also omit arguments when calling an alias as long as you include the commas as argument separators in the alias call:(dbx) p(a,,b,c)
|a||b|c|
(dbx) p(,first missing, preceding space,)
||first missing| preceding space||
(dbx) delete
deleteLBL="" HELPID=""Removing Command AliasesThe ID="04.cntrl47"ID="04.cntrl48"unalias command removes the alias you provide as an argument. For example, to remove the "pa" alias defined in the previous section, enter:(dbx) unalias paYou can remove any of the predefined dbx aliases; however, these aliases are restored the next time you start dbx.LBL="" HELPID=""Alias ExampleAn easy way to follow linked lists is to use aliases and casts. This example shows how to construct an alias that follows a simple linked list with members defined by the following structure:ID="04.cntrl49"ID="04.cntrl50"struct list { struct list *next; int value; };In this example, a dbx variable called $p is used as a pointer to a member of the linked list. You can define an alias called "foll" to print the contents of the list member to which $p currently points and then advance to the next list member. Because the command is too long to fit onto one line, this example uses the backslash character (\) to continue the command on a second line:(dbx) alias foll "print *(struct list *)$p ; \
set $p = (long)((struct list *)($p))->next"Casting $p to an integer type when following the link (the second assignment in the alias) is essential. If omitted, dbx may leave the $p reference symbolic and if so, goes into an infinite loop. (Type Ctrl-c to interrupt dbx if it gets into the infinite loop.)Before using this alias, you must set $p to point at the first list member. In this example, assume that the program variable top points to the first list member. Then you can use the "foll" alias to follow the linked list, printing the contents of each member as you proceed:(dbx) set $p = top
(dbx) foll
struct list {
    next = 0x7fffc71c
    value = 57
} 
(dbx) foll
struct list {
    next = 0x7fffc724
    value = 3
} 
(dbx) foll
struct list {
    next = 0x7fffc72c
    value = 12
}LBL="" HELPID=""ID="43528"Recording and Playing Back dbx Input and Outputdbx allows you to play back your input and record ID="04.cntrl51"ID="04.cntrl52"dbx's output. ID="04.cntrl53"ID="04.cntrl54"dbx saves the information that you capture in files, which allows you to create command scripts that you can use in subsequent dbx sessions.LBL="" HELPID=""Recording InputUse the ID="04.cntrl55"record input command to start an input recording session. Once you start an input recording session, all commands to dbx are copied to the specified file. If the specified file already exists, dbx appends the input to the existing file. You can start and run as many simultaneous dbx input recording sessions as you need.Each recording session is assigned a number when you begin it. Use this number to reference the recording session with the unrecord command described in IDREF="30241" TYPE="TITLE""Ending a Recording Session".After you end the input recording session, use the command file with the ID="04.cntrl56"playbackinput or pi commands to execute again all the commands saved to the file. See IDREF="38563" TYPE="TITLE""Playing Back Input".For example, to save the recorded input in a file called script, enter:(dbx) record input script
[4] record input script (0 lines)If you do not specify a file to record input, dbx creates a temporary dbx file in the /tmp directory. The name of the temporary file is stored in the dbx variable ID="04.cntrl57"$defaultin. You can display the temporary filename using the print command:(dbx) print $defaultinBecause the dbx temporary files are deleted at the end of the dbx session, use the temporary file to repeat previously executed dbx commands in the current debugging session only. If you need a command file for use in subsequent dbx sessions, you must specify the filename when you invoke record input. If the specified file exists, the new input is appended to the file.LBL="" HELPID=""ID="30241"Ending a Recording SessionTo end input or output recording sessions, use the ID="04.cntrl58"ID="04.cntrl59"unrecord command.unrecordID="04.cntrl60" session1 [, session2 ...]Turns off the specified recording session(s) and closes the file(s) involved.ID="04.cntrl61"unrecord allTurns off all recording sessions and closes all files involved.For example, to stop recording session 4, enter the dbx command:(dbx) unrecord 4To stop all recording sessions, enter:(dbx) unrecord allThe dbxID="04.cntrl62"status command does not report on recording sessions. To see whether or not any active recording sessions exist, use the record command described in IDREF="22428" TYPE="TITLE""Examining the Record State".LBL="" HELPID=""ID="38563"Playing Back InputUse ID="04.cntrl63"playback input to execute commands that you recorded with the ID="04.cntrl64"record input command. Two aliases exist for playback input: ID="04.cntrl65"pi and ID="04.cntrl66"source.) If you don't specify a filename, dbx uses the current temporary file that it created for the record input command. If you set the dbx variable ID="04.cntrl67"$pimode to nonzero, the commands are printed out as they are played back. By default, $pimode is set to zero.LBL="" HELPID=""Recording OutputUse the ID="04.cntrl68"ID="04.cntrl69"record output command to start output recording sessions within dbx. During an output recording session, dbx copies its screen output to a file. If the specified file already exists, dbx appends to the existing file. You can start and run as many simultaneous dbx output recording sessions as you need.By default, the commands you enter are not copied to the output file; however, if you set the dbx variable ID="04.cntrl70"$rimode to a nonzero value, dbx also copies the commands you enter.Each recording session is assigned a number when you begin it. Use this number to reference the recording session with the unrecord command described in IDREF="30241" TYPE="TITLE""Ending a Recording Session".The record output command is very useful when the screen output is too large for a single screen (for example, printing a large structure). Within dbx, you can use the playback output command (described in IDREF="95547" TYPE="TITLE""Playing Back Output") to look at the recorded information. After quitting dbx, you can review the output file using any IRIX system text viewing command (such as vi(1)).For example, to record the dbx output in a file called gaffa, enter:(dbx) record output gaffaTo record both the commands and the output, enter:(dbx) set $rimode=1
(dbx) record output gaffaIf you omit the filename, dbx saves the recorded output in a temporary file in /tmp. The temporary file is deleted at the end of the dbx session. To save output for use after the dbx session, you must specify the filename when giving the record output command. The name of the temporary file is stored in the dbx variable ID="04.cntrl71"$defaultout. To display the temporary filename, type:(dbx) print $defaultoutLBL="" HELPID=""ID="95547"Playing Back OutputThe playback output command displays output saved with the record output command. This command works the same as the cat(1) command. If you don't specify a filename, dbx uses the current temporary file created for the record output command.For example, to display the output stored in the file script, enter:(dbx) playback output scriptLBL="" HELPID=""ID="22428"Examining the Record StateThe ID="04.cntrl72"record command displays all ID="04.cntrl73"record input and record output sessions currently active. For example:(dbx) record
[4] record input /usr/demo/script (12 lines)
[5] record output /tmp/dbxoXa17992 (5 lines)LBL="" HELPID=""ID="60766"Executing dbx ScriptsYou can create ID="04.cntrl74"dbx command scripts using an external editor and then execute these scripts using the ID="04.cntrl75"pi or ID="04.cntrl76"playback input command. This is a convenient method for creating and executing automated test scripts.You can include comments in your command scripts by using a single pound sign (ID="04.cntrl77"#) to introduce a comment. To include a ID="04.cntrl78"ID="04.cntrl79"# operator (described in IDREF="90268" TYPE="TITLE""Operators") in a dbx script, use two pound signs (for example, ##27). When dbx sees a pound sign in a script file, it interprets all characters between the pound sign and the end of the current line as a comment.LBL="5"ID="80179"Examining and Changing DataThis chapter describes how to examine and change data in your program while running it under dbx. Topics covered include:IDREF="25993" TYPE="TITLE""Using Expressions"IDREF="17137" TYPE="TITLE""Printing Expressions"IDREF="18732" TYPE="TITLE""Using Data Types and Type Coercion (Casts)"IDREF="50911" TYPE="TITLE""Displaying and Changing Program Variables"IDREF="18664" TYPE="TITLE""Determining the Scope of Variables"IDREF="84723" TYPE="TITLE""Displaying Type Declarations"IDREF="50445" TYPE="TITLE""Examining the Stack"IDREF="81639" TYPE="TITLE""Using Interactive Function Calls"IDREF="65271" TYPE="TITLE""C++ Considerations"LBL="" HELPID=""ID="25993"Using ExpressionsMany dbx commands accept one or more expressions as arguments. Expressions can consist of constants, ID="05.change1"dbx variables, program variables, and operators. This section discusses operators and constants. ID="05.change2"ID="05.change3"IDREF="88718" TYPE="TITLE""Creating and Removing dbx Variables" describes dbx variables, and IDREF="50911" TYPE="TITLE""Displaying and Changing Program Variables" describes program variables.LBL="" HELPID=""ID="90268"OperatorsIn general, dbx recognizes most expression operators from C, Fortran 77, and Pascal. dbx also provides some of its own operators. Operators follow the C language precedence. You can also use parentheses to explicitly determine the order of evaluation.ID="05.change4"IDREF="53353" TYPE="TABLE"Table 5-1 lists the operators provided by dbx.COLUMNS="2"LBL="5-1"Table 5-1 ID="53353"dbx Language Independent Operators LEFT="0" WIDTH="54"OperatorLEFT="60" WIDTH="252"DescriptionLEFT="0" WIDTH="54"notLEFT="60" WIDTH="252"Unary operator returning false if the operand is trueLEFT="0" WIDTH="54"orLEFT="60" WIDTH="252"Binary logical operator returning true if either operand is 
nonzeroLEFT="0" WIDTH="54"xorLEFT="60" WIDTH="252"Binary operator returning the exclusive-OR of its operandsLEFT="0" WIDTH="54"/LEFT="60" WIDTH="252"Binary division operator (you can also use "//" for division)LEFT="0" WIDTH="54"divLEFT="60" WIDTH="252"Binary operator that coerces its operands to integers before 
dividingLEFT="0" WIDTH="54"modLEFT="60" WIDTH="252"Binary operator returning op1 modulo op2. This is equivalent 
to the C "%" operatorLEFT="0" WIDTH="54"#expLEFT="60" WIDTH="252"Unary operator returning the address of source line specified 
by expLEFT="0" WIDTH="54""file"#expLEFT="60" WIDTH="252"Unary operator returning the address of source line specified 
by exp in the file specified by fileLEFT="0" WIDTH="54"proc #expLEFT="60" WIDTH="252"Unary operator returning the address of source line specified 
by exp in the file containing the procedure procThe ID="05.change5"# operator takes the line number specified by the expression that follows it and returns the address of that source line. If you precede the # operator with a filename enclosed in quotation marks, the # operator returns the address of the line number in the file you specify. If you precede the # operator with the name of a procedure, dbx identifies the source file that contains the procedure and returns the address of the line number in that file.For example, to print the address of line 27 in the current source file, enter:(dbx) print #27To print the address of line 27 in the source file foo.c (assuming that foo.c contains source that was used to compile the current object file), enter:(dbx) print "foo.c" #27To print the address of line 27 in the source file containing the procedure bar (assuming that bar is a function in the current object file), enter:(dbx) print bar #27NoteA pound sign (ID="05.change6"#) introduces a comment in a ID="05.change7"dbx script file. When dbx sees a pound sign in a script file, it interprets all characters between the pound sign and the end of the current line as a comment. See IDREF="60766" TYPE="TITLE""Executing dbx Scripts" for more information on dbx script files. To include the ID="05.change8"# operator in a dbx script, use two pound signs (for example, ##27).IDREF="76162" TYPE="TABLE"Table 5-2 lists the C language operators recognized by dbx.COLUMNS="2"LBL="5-2"Table 5-2 ID="76162"C Language Operators Recognized by dbx LEFT="0" WIDTH="50"TypeLEFT="55" WIDTH="270"OperatorsLEFT="0" WIDTH="50"UnaryLEFT="55" WIDTH="270"!   &   +   -   *   sizeof()LEFT="0" WIDTH="50"BinaryLEFT="55" WIDTH="270"%   <<   >>   ==   <=   >=   !=   < >   &   &&   |   ||   +   -   *   /   [ ]   ->   .ID="05.change9"NoteC does not allow you to use the sizeof operator on bit fields. However, dbx allows you to enter expressions using the sizeof operator on bit fields; in these cases, dbx returns the number of bytes in the data type of bit fields (such as int or unsigned int). The C language  "^" exclusive-OR operator is not supported. Use the dbx "xor" operator instead.IDREF="89237" TYPE="TABLE"Table 5-3 lists the Pascal operatorsID="05.change10"recognized by dbx.COLUMNS="2"LBL="5-3"Table 5-3 ID="89237"Pascal Operators Recognized by dbx LEFT="0" WIDTH="50"TypeLEFT="55" WIDTH="270"OperatorsLEFT="0" WIDTH="50"UnaryLEFT="55" WIDTH="270"not   ^    +    -LEFT="0" WIDTH="50"BinaryLEFT="55" WIDTH="270"mod   =    <=    >=    <>    <    >   and    or    +    -    *   /    div    [ ]IDREF="97740" TYPE="TABLE"Table 5-4 lists the Fortran 77 language operators recognized by ID="05.change11"dbx. Note that dbx does not recognize Fortran logical operators (such as .or. and .TRUE.).COLUMNS="2"LBL="5-4"Table 5-4 ID="97740"Fortran 77 Operators Recognized by dbx LEFT="0" WIDTH="50"TypeLEFT="55" WIDTH="171"OperatorsLEFT="0" WIDTH="50"UnaryLEFT="55" WIDTH="171"+    -LEFT="0" WIDTH="50"BinaryLEFT="55" WIDTH="171"+    -    *   /NoteFortran array subscripting must use "[]" not "()". For example, if x is a two-dimension Fortran array, print x(1,2) won't work; however, printx[1,2] will work. If an array is defined as a Fortran array, refer to it with the standard Fortran subscript ordering.LBL="" HELPID=""ConstantsYou can use both numeric and string constants under ID="05.change12"ID="05.change13"dbx.NoteExpressions cannot contain constants defined by ID="05.change14"#define declarations to the C preprocessor.ID="05.change15"LBL="" HELPID=""Numeric ConstantsIn numeric expressions, you can use any valid integer or floating point constants. By default, dbx assumes that numeric constants are in decimal. You can set the default input base to octal by setting the ID="05.change16"ID="05.change17"ID="05.change18"ID="05.change19"dbx variable ID="05.change20"$octin to a nonzero value. You can set the default input base to hexadecimal by setting the ID="05.change21"dbx variable ID="05.change22"$hexin to a nonzero value. If you set both $octin and $hexin to nonzero values, $hexin takes precedence.You can override the default input type by prefixing "0x" to indicate a hexadecimal constant, or "0t" to indicate a decimal constant. For example, "0t23" is decimal 23 (which equals hexadecimal 0x17), and "0x2A" is hexadecimal 2A (which equals decimal 42).By default, ID="05.change23"dbx prints the value of numeric expressions in decimal. You can set the default output base to octal by setting the ID="05.change24"ID="05.change25"dbx variable ID="05.change26"$octints to a nonzero value. You can set the default output base to hexadecimal by setting the ID="05.change27"dbx variable ID="05.change28"$hexints to a nonzero value. If you set both $octints and $hexints to nonzero values, $hexints takes precedence.LBL="" HELPID=""String ConstantsMost dbx expressions cannot include string constants. The ID="05.change29"print and printf commands are two of the dbx commands that accept string constants as arguments. You can also use the ID="05.change30"set command to assign a string value to a dbx variable.Otherwise, string constants are useful only as arguments to functions that you call interactively. See IDREF="81639" TYPE="TITLE""Using Interactive Function Calls" for information on interactive function calls.ID="05.change31"You can use either the double-quote character (") or the single-quote character (') to quote strings in dbx.In general, dbx recognizes the following escape sequences in quoted strings (following the standard C language usage):ID="05.change32"\\ \n \r \f \b \t \' \" \aLBL="" HELPID=""ID="17137"Printing Expressionsdbx provides the following commands for printing values of expressions:ID="05.change33"printID="05.change34" [exp1 [, exp2, ...] ] Prints the value(s) of the specified expression(s).printd ID="05.change35"[exp1 [, exp2, ... ] ]Prints the value(s) of the specified expression(s) in decimal. (ID="05.change36"pd is an alias for printd. See IDREF="88718" TYPE="TITLE""Creating and Removing dbx Variables" for more information about dbx aliases.)printo ID="05.change37"[exp1 [, exp2, ... ] ]Prints the value(s) of the specified expression(s) in octal. (ID="05.change38"po is an alias for printo.) printx ID="05.change39"[exp1 [, exp2, ... ] ]Prints the value(s) of the specified expression(s) in hexadecimal. (ID="05.change40"px is an alias for printx.) The variable types are listed in IDREF="60970" TYPE="TABLE"Table 5-5.COLUMNS="3"LBL="5-5"Table 5-5 ID="60970"Variable TypesLEFT="0" WIDTH="113"TypeLEFT="120" WIDTH="113"Variable NameLEFT="240" WIDTH="113"ValueLEFT="0" WIDTH="113"signed charLEFT="120" WIDTH="113"scLEFT="240" WIDTH="113"0xffLEFT="0" WIDTH="113"unsigned charLEFT="120" WIDTH="113"uscLEFT="240" WIDTH="113"0xffLEFT="0" WIDTH="113"signed shortLEFT="120" WIDTH="113"sshLEFT="240" WIDTH="113"0xffffLEFT="0" WIDTH="113"unsigned shortLEFT="120" WIDTH="113"ushLEFT="240" WIDTH="113"0xffffExamples include:(dbx) pd sc
-1
(dbx) pd ssh 
-1
(dbx) px sc 
0xff 
(dbx) px ssh
0xffff
(dbx) pd usc
255
(dbx) pd ush
65535dbx always prints the bits in the appropriate type. pd is an exception; it expands signed types with sign extension so the decimal value looks correct. Another example:(dbx) print sc, usc
'\377' '\377'If $hexchars is set, this command displays '0xff' `0xff'. (This is a change from releases previous to IRIX 5.2. Previously, the px, po cases on signed short expanded to 32 bits, so px sc printed 0xffffffff.)If the printed data type is pointer, dbx uses the format specified in the $addrfmt or $addrfmt64 predefined dbx variable ($addrfmt64 is used on only 64-bit processes).printfID="05.change41" string [, exp1 [, exp2, ... ] ] Print the value(s) of the specified expression(s) in the format specified by the string, ID="05.change42"string. The printf command supports all formats of the IRIX printf command except "%s." For a list of formats, see the printf(3S) reference page.LBL="" HELPID=""ID="18732"Using Data Types and Type Coercion (Casts)You can use data types for type conversion (casting) by including the name of the data type in parentheses before the expression you want to cast. For example, to convert a character into an integer, use ID="05.change43"ID="05.change44"(int) to cast the value:(dbx) print (int) 'b'
98To convert an integer into a character, use (char) to cast the value:(dbx) print (char) 67
'C'This is standard C language type casting.LBL="" HELPID=""ID="50911"Displaying and Changing Program VariablesYou can use the value of program variables in ID="05.change45"dbx expressions. You can also change the value of program variables while running your program under dbx control.LBL="" HELPID=""ID="90553"Qualifying Variable NamesYou can use the same name for different variables multiple times in the same program. For example, you can use a temporary counter named "i" in many different functions.ID="05.change46"During program execution, this potential ambiguity presents no problem. The scope of each variable is local; space is allocated for it when the function is called and freed when the function returns.ID="05.change47"Under dbx, however, you need to be able to distinguish between different variables that may have the same name. To do so, you can qualify a reference to a variable to specify its scope.dbx qualifies variables with the file (also called module), the procedure, a block, or a structure. You can manually specify the full scope of a variable by separating scopes with periods. For example, in the expression:mrx.main.ii is the variable name, main is a procedure in which it appears, and mrx is the source file (omitting the file extension) in which the procedure is defined.To illustrate, consider a C program called test that contains a function compare. In this example, the variable i is declared in both the main procedure and the compare function:int compare ( int );

main( argc, argv )

int argc;
char **argv;
{
   int i;
...
}

int compare ( arg1, arg2 )
{
   int i;
...
}To trace the value of the i that appears in the function compare, enter:(dbx) trace test.compare.iTo print the value of the i that appears in the procedure main, enter:(dbx) print test.main.iA leading dot (a period at the beginning of the identifier) tells dbx that the first qualifier is not a module (file).The leading dot is useful when a file and a procedure have the same name. For instance, suppose mrx.c contains a function called mrx. Further, suppose that mrx.c contains a global variable called mi and a local variable, also called mi. To refer to the global variable, use the qualified form .mrx.mi, and to refer to the local variable, use the qualified form mrx.mrx.mi.LBL="" HELPID=""Variable ScopeYou can access the value of a variable only while it is in scope. The variable is in scope only if the block or procedure with which it is associated is active.ID="05.change48"After you start your program, whenever your program executes a block or procedure that contains variables, your program allocates space for those variables and they "come into scope." You may access the values of those variables as long as the block or procedure is active. Once the block or procedure ends, the space for those variables is deallocated and you may no longer access their values.LBL="" HELPID=""ID="85784"Displaying the Value of a VariableYou can display the value of a program variable using the ID="05.change49"ID="05.change50"print, ID="05.change51"printd, ID="05.change52"printf, ID="05.change53"printo, and ID="05.change54"printx commands and the ID="05.change55"pd, ID="05.change56"po, and ID="05.change57"px aliases described in IDREF="17137" TYPE="TITLE""Printing Expressions". For example, to print the value of the program variable total, enter:(dbx) print total
235The print command also displays arrays, structures, and other complex data structures. For example, if message is a character array (a string), dbx prints the string:(dbx) print message
"Press <Return> to continue."As a more complex example, consider a simple linked list stored as an array of elements, each element consisting of a pointer to the next element and an integer value. If the array is named list, print the entire array by entering:(dbx) print arraydbx prints the value of each element in the array:{
    [0] struct list {
        next = (nil)
        value = 1034
    }
    [1] struct list {
        next = 0x10012258
        value = 1031
    }
    [2] struct list {
        next = 0x10012270
        value = 1028
    }
    [3] struct list {
        next = 0x10012288
        value = 1025
    }
    [4] struct list {
        next = 0x100122a0
        value = 1022
    }
    [5] struct list {
        next = 0x100122b8
        value = 1019
    }
...
}To print an individual element, enter a command such as:(dbx) print array[5]
struct list {
    next = 0x100122b8
    value = 1019
}No simple method exists for examining a portion of an array with the ID="05.change58"print command. However, if your array consists of simple elements such as integers or floating point values, you can directly examine the contents of memory using the /ID="05.change59" (examine forward) command described in IDREF="51451" TYPE="TITLE""Examining Memory and Disassembling Code".Suppose a single-precision floating point array is named float_vals. To see the six consecutive elements beginning with the fifth element, enter:(dbx) &float_vals[4] / 6f
10012018:  0.25000000000000000 0.20000000298023224 0.16666699945926666
0.14280000329017639
10012028:  0.12500000000000000 0.11111100018024445LBL="" HELPID=""Changing the Value of a VariableThe ID="05.change60"ID="05.change61"assign command changes the value of existing program variables. You can also use the assign command to change the value of machine registers, as described in IDREF="34959" TYPE="TITLE""Changing Register Values".The syntax of the assign command is:assignID="05.change62" variable = expressionAssigns the value of expression to the program variable, variable.For example:(dbx) assign x = 27
27
(dbx) assign y = 37.5
37.5If you receive an incompatible types error when you try to assign a value to a pointer, use casts to make the assignment work. For example if next is a pointer to a structure of type "element," you can assign next a null pointer by entering:(dbx) assign *(int *) (&next) = 0
0
(dbx) assign next = 0
(nil)
(dbx) assign next = (struct list*) 0;
(nil)In this example, nil denotes that the value of the pointer is 0; nil is similar to NULL in the C language.LBL="" HELPID=""Conflicts Between Variable Names and KeywordsWhen naming variables in your program, avoid using any ID="05.change63"dbx keywords. If you have a variable with the same name as a dbx keyword and you attempt to use that variable in a dbx command, dbx reports a syntax error.If you do have a program variable with the same name as a dbx command, you can force dbx to treat it as a variable by enclosing the variable in parentheses. For example, if you try to print the value of a variable named in by entering the following command, dbx displays an error.(dbx) print inprint in
      ^ syntax error
Suggestion: in is a dbx keyword; a revised command is in history.
Type !16 or !! to execute: print (in)The correct way to display the value of input is to enter:(dbx) print (in)
34dbx keywords include:all    not
and    or
at     pgrp
div    pid
if     sizeof
in     to
mod    xorBy default, dbx treats as keywords the following C type keywords:signed     struct
unsigned   union
short      enum
long       double
int        float
charHowever, if your program is not written in C or C++, you may wish to disable these keywords. The ID="05.change64"dbx variable ID="05.change65"$ctypenames determines whether or not C type keywords are treated as dbx keywords. If $ctypenames is set to 1 (the default), then C type keywords are treated as dbx keywords; if $ctypenames is set to 0, they are not.LBL="" HELPID=""Case Sensitivity in Variable NamesWhether or not ID="05.change66"dbx is case sensitive when it evaluates program variable names depends on the value of the dbx variable ID="05.change67"$casesense.If $casesense is 2 (the default), then the language in which the variable was defined is taken into account (for example, C and C++ are case sensitive while Pascal and Fortran are not). If $casesense is 1, case is always checked. If $casesense is 0, case is always ignored. Note that file (module) names are always case sensitive since they represent UNIX filenames.LBL="" HELPID=""ID="18664"Determining the Scope of VariablesThe ID="05.change68"ID="05.change69"which command allows you to determine the scope of variables. This command is useful for programs that have multiple variables with the same name occurring in different scopes.The which command prints the fully qualified name of the active version of a specified variable. For example, to determine the scope of the variable i, enter:(dbx) which i
.foo.foo2.iIn the example above, the variable i that is currently active is local to the procedure foo2 that appears in the module foo (corresponding to the file foo.c in a C language program).LBL="" HELPID=""ID="84723"Displaying Type DeclarationsThe ID="05.change70"ID="05.change71"whatis command displays the type declaration for a specified variable or procedure in your program. For example, to display the type declaration for the variable i, enter:(dbx) whatis i
int i;The following example illustrates the output of whatis for an array of structures:(dbx) whatis array
struct list {
    struct list* next;
    int value;
} array[12];When you provide a procedure name to whatis, dbx reports the type of the value returned by the procedure and the types of all arguments to the procedure:(dbx) whatis foo
int foo(i)
int i;
(dbx) whatis main
int main(argc, argv)
int argc;
char** argv;LBL="" HELPID=""ID="50445"Examining the StackEach time your program executes a procedure, the information about where in the program the call was made from is saved on a stack. The stack also contains arguments to the procedure and all of the procedure's local variables. Each procedure on the stack defines an ID="05.change72"ID="05.change73"activation level. Activation levels can also consist of blocks that define local variables within procedures.The activation level determines the scope of many ID="05.change74"dbx commands and expressions. For example, unless you qualify a variable, as described in ID="05.change75"IDREF="90553" TYPE="TITLE""Qualifying Variable Names"dbx assumes that variables you reference are local to the current activation level.The most recently called procedure or block is numbered 0. The next active procedure (the one that called the current procedure) is numbered 1. The last activation level is always the main program block.LBL="" HELPID=""Printing Stack TracesThe ID="05.change76"ID="05.change77"where command prints stack traces. Stack traces show the current activation levels (procedures) of a program.For example, consider the following stack trace for a program called test:(dbx) where
>  0 foo2(i = 5) ["/usr/var/tmp/dbx_examples/test.c":44, 0x1000109c]
   1 foo(i = 4) ["/usr/var/tmp/dbx_examples/test.c":38, 0x1000105c]
   2 main(argc = 1, argv = 0xffffffad78) ["/usr/var/tmp/dbx_examples/test.c":55, 0x10001104]
   3 __start() ["/shamu/lib/libc/libc_64/crt1text.s":137, 0x10000ee4]This program has four activation levels. The most recent, a call of the procedure foo2, is numbered 0. The currently selected activation level is 0, indicated by the ">" character.The stack trace also reports that foo2 was passed one argument: the value 5 was assigned to the local variable i. The trace indicates that the program was stopped at line 44 of the file test.c, which translates to machine address 0x1000109c.The stack trace reports similar information for the next two activation levels in this example. You can see that the function foo called foo2 from line 38 in test.c. In turn, foo was called by main at line 55 of the file test.c. Finally, the run-time start-up level was called at line 137 from the file ctrltext.s.If you compile with ID="05.change78"­g0 or with no ­g option, limited symbols are reported. In cases such as this, where detailed symbolic information is not available, the four hexadecimal values returned represent dbx's guess that the function has four integer arguments. The following example illustrates such a case:(dbx) where
>  0 fooexample(0x300000000, 0x4000000ff, 0x5000000ff, 0x0) ["/usr/var/tmp/dbx_examples/test3.c":10, 0x10000cf8]
   1 main(0x3, 0x4, 0x5, 0x0) ["/usr/var/tmp/dbx_examples/test3.c":5, 0x10000cbc]
   2 __start() ["/shamu/lib/libc/libc_64/csu/crt1text.s":137, 0x10000c64]
(dbx) quit
Process 22582 terminated
int fooexample(int,int,int);
int main()
{
       fooexample(3,4,5);
       return 0;
}
int fooexample(int i, int j, int k)
{
       int x = i + j + 3*k;
       return x;
}The examples below show register values from code compiled without a  ID="05.change79"­g option. MIPS1 or MIPS2 code using the 32-bit ABI (for example, on an Indy):(dbx) where
> 0 subr1(0x3, 0x7fffaf14, 0x7fffaf1c, 0x0) ["t.c":3, 0x4009ec]
  1 test(0x3, 0x7fffaf14, 0x7fffaf1c, 0x0) ["t.c":8, 0x400a10]
  2 main(0x1, 0x7fffaf14, 0x7fffaf1c, 0x0) ["t.c":13, 0x400a48]
  3 __start() ["crt1text.s":133, 0x40099c]There are four hexadecimal values displayed in most lines of the code above since the 32-bit MIPS ABI has four integer argument passing registers. No user-useful registers are passed to __start().MIPS3 or MIPS4 code using the 64-bit ABI (for example, on a Power Challenge):(dbx) where
> 0 subr1(0x3, 0xffffffaed8, 0xffffffaee8, 0x0, 0x2f, 0x10, 0x0, 0xfbd82a0) ["/usr/people/doc/debug/t.c":3, 0x10000c9c]
  1 test(0x3, 0xffffffaed8, 0xffffffaee8, 0x0, 0x2f, 0x10, 0x0, 0xfbd82a0) ["/usr/people/doc/debug/t.c":9, 0x10000ce8]
  2 main(0x1000000ff, 0xffffffaed8, 0xffffffaee8, 0x0, 0x2f, 0x10, 0x0, 0xfbd82a0) ["/usr/people/doc/debug/t.c":14, 0x10000d2c]
  3 __start() ["/shamu/redwood2/work/irix/lib/libc/libc_64/csu/crt1text.s":137, 0x10000c70]There are eight hexadecimal values displayed in most lines of the code above since the 64-bit MIPS ABI has eight integer argument passing registers. No user-useful registers are passed to __start().The values listed as arguments are the integer argument-passing register values. Typically, only the 0 entry of the stack has those argument values correct. Correctness is not guaranteed because the code generator can overwrite the values, using the registers as temporary variables.The debugger reports the integer argument-passing registers because this information may be of some value.For example, for the code samples above, the following code calls subr1():int test(void)
{
     subr1(3);
}This code displays 0x3 as the argument register value. The other registers listed for subr1 contain arbitrary data.LBL="" HELPID=""ID="88379"Moving Within the StackThe ID="05.change80"up and ID="05.change81"down commands move up and down the activation levels in the stack. These commands are useful when examining a call from one level to another. You can also move up and down the activation stack with the ID="05.change82"ID="05.change83"func command described in IDREF="82062" TYPE="TITLE""Moving to a Specified Procedure".The up and down commands have the following syntax:up [num] Moves up the specified number of activation levels in the stack. The default is one level.down [num] Moves down the specified number of activation levels in the stack. The default is one level.When you change activation levels, your scope changes. For example, unless you qualify a variable, as described in ID="05.change84"IDREF="90553" TYPE="TITLE""Qualifying Variable Names", dbx assumes that variables you reference are local to the current activation level. Also, dbx changes the current source file to the file containing the procedure's source.ID="05.change85"Consider examining the stack trace for a program called test4 and moving up in the activation stack:(dbx) where
>  0 foo2(i = 5) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]
   1 foo(i = 4) ["/usr/var/tmp/dbx_examples/foo.c":40, 0x100011d4]
   2 main(argc = 1, argv = 0xffffffad78) ["/usr/var/tmp/dbx_examples/test4.c":25, 0x10000fa0]
   3 __start() ["/shamu/lib/libc/libc_64/csu/crt1text.s":137, 0x10000f34]
(dbx) print i
5
(dbx) up 
foo:  40  r = foo2(i+1);The current activation level is now the procedure foo. As indicated in the output, the variable i receives the argument passed to foo and is therefore local to foo. The variable i at this activation level is different from the variable i in the foo2 activation level. You can reference the currently active i as "i"; whereas you must qualify the reference to the i in foo2:(dbx) print i
4
(dbx) print foo2.i
<symbol not found>Moving up one more activation level brings you to the main procedure:(dbx) up
main:  25  j = foo(j);
(dbx) file
/usr/var/tmp/dbx_examples/test4.cIn this example, the source for main is in test4.c, whereas the source for foo and foo2 is in foo.c; therefore, dbx changes the current source file when you move up to the main activation level.dbx resets the source file when you return to the foo2 activation level:(dbx) down 2
foo2:  46  printf("foo2 arg is %d\n",i);
(dbx) file
/usr/var/tmp/dbx_examples/foo.cLBL="" HELPID=""ID="82062"Moving to a Specified ProcedureThe ID="05.change86"func command moves you up or down the activation stack. You can specify the new activation level by providing either a procedure name or an activation level number.ID="05.change87"The syntax for the func command is:funcID="05.change88" {activation_level | procedure} Changes the current activation level. If you specify an activation level by number, dbx changes to that activation level. If you specify a procedure, dbx changes to the activation level of that procedure. If you specify a procedure name and that procedure has called itself recursively, dbx changes to the most recently called instance of that procedure.funcID="05.change89" Displays the name of the procedure corresponding to the current activation level.When you change your activation level, your scope changes. For example, unless you qualify a variable as described in ID="05.change90"IDREF="90553" TYPE="TITLE""Qualifying Variable Names", dbx assumes that variables you reference are local to the current activation level. Also, dbx changes the current source file to the one containing the procedure's source and the current line to the first line of the procedure.You can also give the func command the name of a procedure that is not on the activation stack, even when your program is not executing. In this case, dbx has no corresponding activation level to make current. However, dbx still changes the current source file to the one containing the procedure's source and the current line to the first line of the procedure.For example, consider the following activation stack:(dbx) where
>  0 foo2(i = 5) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]
   1 foo(i = 4) ["/usr/var/tmp/dbx_examples/foo.c":40, 0x100011d4]
   2 main(argc = 1, argv = 0xffffffad78) ["/usr/var/tmp/dbx_examples/test4.c":25, 0x10000fa0]
   3 __start() ["/shamu/lib/libc/libc_64/csu/crt1text.s":137, 0x10000f34]In this case, you can go to the main activation stack by entering:(dbx) func main
main:  25  j = foo(j);This command changes the current activation level to "2" and changes the current source file to test4.c.If you use the func command to go to a function that is not on the activation stack, dbx changes only the current source file to the one containing the procedure's source and the current line to the first line of the procedure:(dbx) func bar
   3  {
(dbx) file
/usr/var/tmp/dbx_examples/bar.cLBL="" HELPID=""Printing Activation Level InformationThe ID="05.change91"dump command prints information about the variables in an activation level:ID="05.change92"dumpID="05.change93" Prints information about the variables in the current procedure.dumpID="05.change94" procedure Prints information about the variables in the specified procedure. The procedure must be active. Starts searching for procedure at the current activation level as set by the up or down command. (See IDREF="88379" TYPE="TITLE""Moving Within the Stack" for more information about the up and down commands.)dump .ID="05.change95" Prints information about the variables in all procedures in all activation levels.For example, executing dump while in a function called foo2 appears as:(dbx) dump
foo2(i = 5) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]To examine the information for the procedure main, enter:(dbx) dump main
main(argc = 1, argv = 0xffffffad78) ["/usr/var/tmp/dbx_examples/test4.c":25,
0x10000fa0]
j = 4
i = 12
r = <expression or syntax error>
a = 0
total = 0To perform a complete dump of the program's active variables, enter:(dbx) dump .
>  0 foo2(i = 5) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]
   1 foo(i = 4) ["/usr/var/tmp/dbx_examples/foo.c":40, 0x100011d4]
r = 0
   2 main(argc = 1, argv = 0xffffffad78) ["/usr/var/tmp/dbx_examples/test4.c":25, 0x10000fa0]
j = 4
i = 12
r = <bad operand>
a = 0
total = 0LBL="" HELPID=""ID="81639"Using Interactive Function CallsYou can interactively call a function in your program from ID="05.change96"dbx.If the function returns a value, you can use that function in a normal dbx expression. For example, consider a function prime defined in your program that accepts an integer value as an argument, and returns 1 if the value is prime and 0 if it is not. You can call this function interactively and print the results by entering a command such as:(dbx) print prime(7)
1LBL="" HELPID=""Using ccallIf your function does not return a value, or if you want to execute a function primarily for its side effects, you can execute the function interactively with the dbx command ccall:ccallID="05.change97" func(arg1, arg2, ... , argn) This command calls a function with the given arguments. Regardless of the language the function was written in, the call is interpreted as if it were written in C, and normal C calling conventions are used.ID="05.change98"NoteStructure and union arguments to a function, and structure and union returns from a function, are not supported.Functions called interactively honor breakpoints. Thus you can debug a function by setting breakpoints and then calling it interactively. If you perform a stack trace using the where command while stopped in a routine executed interactively, dbx displays only those activation levels created by your interactive function call. The activation levels for your active program are effectively invisible. For example, a stack trace looks like this during an interactive function call:(dbx) where
>  0 foo2(i = 9) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]
   1 foo(i = 8) ["/usr/var/tmp/dbx_examples/foo.c":40, 0x100011d4]

===== interactive function call =====

   2 foo2(i = 5) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]
   3 foo(i = 4) ["/usr/var/tmp/dbx_examples/foo.c":40, 0x100011d4]
   4 main(argc = 1, argv = 0xffffffad78) ["/usr/var/tmp/dbx_examples/test4.c":25, 0x10000fa0]
   5 __start() ["/shamu/lib/libc/libc_64/csu/crt1text.s":137, 0x10000f34]If you stop execution of an interactively called function, you are responsible for eventually "unstacking" the call and returning from the function call. To unstack a call, you can complete the call using ID="05.change99"ID="05.change100"dbx commands such as cont, resume, next, or step as many times as necessary. If you run or rerun your program, dbx automatically unstacks all interactive function calls.LBL="" HELPID=""Using clearcallsAnother way to unstack an interactive function call is to execute the ID="05.change101"ID="05.change102"clearcalls command, which clears all stopped interactive calls. (dbx) clearcallsWhen stopped or faulted within one or more nested interactive calls, the clearcalls command removes these calls from the stack and returns the program to its regular callstack. This command is useful when a segmentation fault, infinite loop, or other fatal error is encountered within the interactive call.When stopped in an interactive call, the call stack displayed by where shows the following line at the end of each stack of interactive call instantiation. ==== interactive function call ====For example, if the procedure foo() is interactively called from main(), you see the following stack:>  0 foo2(i = 9) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]
   1 foo(i = 8) ["/usr/var/tmp/dbx_examples/foo.c":40, 0x100011d4]

===== interactive function call =====

   2 foo2(i = 5) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]
   3 foo(i = 4) ["/usr/var/tmp/dbx_examples/foo.c":40, 0x100011d4]
   4 main(argc = 1, argv = 0xffffffad78) ["/usr/var/tmp/dbx_examples/test4.c":25, 0x10000fa0]
   5 __start() ["/shamu/lib/libc/libc_64/csu/crt1text.s":137, 0x10000f34]LBL="" HELPID=""Nesting Interactive Function CallsYou can also nest interactive function calls. In other words, if you have one or more breakpoints in a function, and you call that function repeatedly, each interactive call is stacked on top of the previous call. Breakpoints in a function affect all nesting levels, so you cannot have different breakpoints at different nesting levels.ID="05.change103"ID="05.change104"The where command shows the entire stack trace from which you can determine the nesting depth. The following example has two nesting levels.(dbx) where
>  0 foo2(i = 17) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]
   1 foo(i = 16) ["/usr/var/tmp/src/dbx_examples/foo.c":40, 0x100011d4]

===== interactive function call =====

   2 foo2(i = 9) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]
   3 foo(i = 8) ["/usr/var/tmp/dbx_examples/foo.c":40, 0x100011d4]

===== interactive function call =====

   4 foo2(i = 5) ["/usr/var/tmp/dbx_examples/foo.c":46, 0x10001214]
   5 foo(i = 4) ["/usr/var/tmp/dbx_examples/foo.c":40, 0x100011d4]
   6 main(argc = 1, argv = 0xffffffad78) ["/usr/var/tmp/src/dbx_examples/test4.c":25, 0x10000fa0]
   7 __start() ["/shamu/lib/libc/libc_64/csu/crt1text.s":137, 0x10000f34]To set a conditional breakpoint, for example, type:(dbx) stop in foo if j == 7
Process     0: [3] stop in foo if j==7If j is not within the scope of foo, then you will receive an error message if you attempt to call foo interactively. To prevent this, disable or delete any such breakpoints, conditional commands, or traces before executing the interactive function call.LBL="" HELPID=""ID="65271"C++ ConsiderationsDebugging a program written in C++ is somewhat different from debugging programs written in other languages. This section describes these differences.ID="05.change105"LBL="" HELPID=""Accessing C++ Member VariablesTypically you use standard C++ syntax to access member variables of objects. For example, if the string ID="05.change106"_name is a member variable of the object myWindow, you can print its value by entering:(dbx) print myWindow._name
0x1001dc1c = "MenuWindow" To display a static member variable for a C++ class, you must specify the variable with the class qualifier. For example, to print the value of the static member variable ID="05.change107"costPerShare of the class CoOp, enter:(dbx) print CoOp::costPerShare
25.0LBL="" HELPID=""Referring to C++ FunctionsFor the purpose of dbx debugging, functions in C++ programs fall into three general categories:Member functionsID="05.change108"Refers to member functions using the syntax classname::functionname. For example, refers to the member function foo in the class Window as Window::foo.Global C++ functionsID="05.change109"Refers to global functions using the syntax ::functionname. For example, refers to the global function foo as ::foo.Non-C++ functionsID="05.change110"Refers to non-C++ functions using the syntax functionname. For example, refers to the function printf as printf.A restriction to keep in mind when using dbx with C++ is that you cannot distinguish between overloaded functions. For example, consider two functions:ID="05.change111"print(int);
print(float);The following command sets a breakpoint in both functions:(dbx) stop in ::printThe following contrived example illustrates various possibilities:#include <stdio.h> 
class foo {
   int n; 
   public:
   foo() {n = 0;}
   foo(int x);
   int bar();
   int bar(int); 
};

int foo:: bar() 
{
   return n; 
}

int foo:: bar(int x) 
{
   return n + x; 
}

foo::foo(int x) 
{
   n = x; 
}

int square(int x) 
{
   return x*x; 
}

main() 
{ 
   foo a; 
   foo b = 11; 
   int x = a.bar(); 
   int y = b.bar(x) + square(x);  
   printf("y = %d\n", y); 
} If you enter:(dbx) stop in foo::foodbx stops execution in the constructor for the variable b; dbx may stop in the constructor for the variable a (the ability to stop in an inline function may not yet be fully implemented).If you enter:(dbx) stop in foo::bardbx stops execution both when a.bar is called and when b.bar is called, because dbx is unable to distinguish between the overloaded functions.To stop in square, enter:(dbx) stop in ::squareTo stop in printf (a C function), enter:(dbx) stop in printfLBL="6"ID="91063"Controlling Program ExecutionA program typically runs until it exits or encounters an unrecoverable error. You can use dbx, however, to stop a program under various conditions, step through your program line by line, stop execution on receiving a signal, and execute conditional commands based on your program's status.This chapter covers:IDREF="23865" TYPE="TITLE""Setting Breakpoints"IDREF="31983" TYPE="TITLE""Continuing Execution After a Breakpoint"IDREF="19256" TYPE="TITLE""Tracing Program Execution"IDREF="89878" TYPE="TITLE""Writing Conditional Commands"IDREF="14485" TYPE="TITLE""Managing Breakpoints, Traces, and Conditional Commands"IDREF="25866" TYPE="TITLE""Using Signal Processing"IDREF="93296" TYPE="TITLE""Stopping at System Calls"IDREF="31135" TYPE="TITLE""Stepping Through Your Program"IDREF="28904" TYPE="TITLE""Starting at a Specified Line"LBL="" HELPID=""ID="23865"Setting BreakpointsBreakpointsID="06.exec1" allow you to stop execution of your program. Breakpoints can be unconditionalID="06.exec2", in which case they always stop your program, or ID="06.exec3"conditional, in which case they stop your program only if a test condition that you specify is true.NoteAll breakpoints halt program execution before executing the line on which they are set. Therefore, if you want to examine the effects of a line of code, you should set the breakpoint on the line of code following the one whose effects you want to study.Each breakpoint is assigned a number when you create it. Use this number to reference a breakpoint in the various commands provided for manipulating breakpoints (for example, ID="06.exec4"disable, ID="06.exec5"enable, and ID="06.exec6"delete, all described in IDREF="14485" TYPE="TITLE""Managing Breakpoints, Traces, and Conditional Commands").LBL="" HELPID=""Setting Unconditional BreakpointsTo set an unconditional breakpoint, you simply specify the point at which you want to stop program execution, using one of the following forms of the ID="06.exec7"stop command:stop atID="06.exec8"Sets a breakpoint at the current source line.stop atID="06.exec9" lineSets a breakpoint at the specified source line in the current source file.stop inID="06.exec10" procedure Sets a breakpoint to stop execution upon entering the specified procedure.stop at file:lineSets a breakpoint in the specified file at the specified line.CautionIf your program has multiple source files, be sure to set the breakpoint in the correct file. To do so, you can explicitly set the source file using dbx's file command (see IDREF="41684" TYPE="TITLE""Changing Source Files"), or you can use the func command to go to a source file containing a specified function (see IDREF="82062" TYPE="TITLE""Moving to a Specified Procedure").LBL="" HELPID=""Setting Conditional BreakpointsAn unconditional breakpoint is the simplest type of breakpoint; your program stops every time it reaches a specified place. On the other hand, a ID="06.exec11"conditional breakpoint stops your program only if a condition that you specify is true. The two conditions that you can test are:Has the value of a variable or other memory location changed?Is a test expression true?LBL="" HELPID=""Stopping If a Variable or Memory Location Has ChangedBy including a ID="06.exec12"variable clause in your stop command, you can cause dbx to stop if the value of a variable or the contents of a memory location has changed.If you provide only a variable name in your variable clause, the breakpoint stops your program if the value of the variable has changed since the last time dbx checked it. If instead of a variable name, you provide an expression of type pointer, dbx checks the data pointed to. If the data pointed to is a structure, dbx checks that structure. If you provide an expression that's not of type pointer, dbx evaluates the expression and uses the result as an address in memory. The breakpoint stops your program if the contents of the memory location (32 bits) has changed since the last time dbx checked it.The points at which dbx checks the value of a variable or memory location depend on the command that you use to set the breakpoint:stopID="06.exec13" [expression|variable] Inspects the value before executing each source line. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address). For example, consider the command:ID="06.exec14"stop (struct s*) 0x12345678This command checks the contents of the structure located at 0x12345678.stop ID="06.exec15"[expression|variable] at line Inspects the value at the given source line. Stops if the value has changed. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).ID="06.exec16"stopID="06.exec17" [expression|variable] in procedure Inspects the value at every source line within a given procedure. Stops if the value has changed. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).ID="06.exec18"LBL="" HELPID=""Using Fast WatchpointsYou can use fast watchpoints with the stop command. A fast watchpoint watches a specified variable or memory address without severely impacting the performance of the program being debugged. In previous versions of dbx, the debugger had to single-step the process being debugged and check if the value of a variable had changed after each instruction. With fast watchpoints, the debugger uses a hardware virtual memory write protect mechanism to allow the program to run freely until the variable being watched changes. The program being debugged stops only when the virtual memory page containing the variable is written to. If the value of the variable being watched does not changed, dbx continues the execution of the process. If a write modifies a watched variable, dbx notifies you of the change.Consider a small program that contains a global variable called global:stop globalThis command causes the program to stop if the value of the variable global changes. The program runs virtually at full speed until global gets assigned a new value. Similarly, consider the command:stop 0x100100This command stops when the 32- bit integer residing at address 0x100100 is modified, and runs at nearly full speed until the value changes. This form of the stop command is useful for watching the contents of anonymous memory, such as the memory returned by malloc().dbx still needs to use the single-step approach if the stop command contains an expression to watch, such as in stop if global == 1. The performance of the debugged program can be greatly enhanced by including a variable to watch in the stop command. For example, the previous stop command can be expressed equivalently as stop global if global == 1. This instructs the debugger to check only the expression global == 1 if the value of global changes. For situations where the expression does not depend upon a particular variable getting modified such as stop if global == x * 3, the single-step approach is the only way to achieve the desired behavior.LBL="" HELPID=""ID="71997"Stopping If a Test Expression Is TrueBy including a test clause in your ID="06.exec19"stop command, you can cause dbx to stop if the value of an expression is true. You can use any valid numerical expression as a test. If the result of the expression is nonzero, the expression is true and the test is successful.The point at which dbx evaluates the test expression depends on the command that you use to set the breakpoint:stopID="06.exec20" if expressionEvaluates the expression before executing each source line. Note that execution is very slow if you choose this type of conditional breakpoint.ID="06.exec21"stop at line if expressionEvaluates the expression at the given line.stop in procedure if expressionEvaluates the expression at every source line within a given procedure.LBL="" HELPID=""Conditional Breakpoints Combining Variable and Test ClausesYou can create conditional breakpoints that combine both variable and test clauses. In these cases, the overall test evaluates to true only if both clauses are true.ID="06.exec22"ID="06.exec23"The following forms of the stop command combine both the variable and test clauses:stop [expression1|variable] if expression2 Tests both conditions before executing each source line. Stops if both conditions are true. If ID="06.exec24"expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stop [expression1|variable] at line if expression2 Tests both conditions at the given source line. Stops if both conditions are true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stop [expression1|variable] in procedure if expression2 Tests both conditions at every source line within a given procedure. Stops if both conditions are true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).LBL="" HELPID=""ID="31983"Continuing Execution After a BreakpointThe ID="06.exec25"cont command allows you to continue execution after any type of breakpoint. In its simplest form, program execution continues until the end of the program or until another breakpoint is reached. You can also tell ID="06.exec26"dbx to continue your program until it reaches a given line or procedure; this is similar to setting a temporary, "one-shot" breakpoint and then continuing.The syntax of the cont command is:contContinues execution with the current line.cont {at | to} lineSets a temporary breakpoint at the specified source line, then resumes execution with the current line. When your program reaches the breakpoint at line, dbx stops your program and deletes the temporary breakpoint. The keywords at and to are equivalent.cont in procedureSets a temporary breakpoint to stop execution upon entering the specified procedure, then resumes execution with the current line. When your program reaches the breakpoint in procedure, dbx stops your program and deletes the temporary breakpoint.If your program stopped because dbx caught a signal intended for your program, then dbx will send that signal to your program when you continue execution. You can also explicitly send a signal to your program when you continue execution. Sending signals to your program upon continuation is discussed in ID="06.exec27"IDREF="62814" TYPE="TITLE""Continuing After Catching a Signal".When you debug multiprocess programs, the ID="06.exec28"ID="06.exec29"resume command can be more helpful than the cont command. Refer to IDREF="87200" TYPE="TITLE""Resuming a Suspended Process" for more information about the resume command.LBL="" HELPID=""ID="19256"Tracing Program ExecutionThe trace command allows you to observe the progress of your program as it executes. With it, you can print:values of variables at specific points in your program or whenever variables change valueparameters passed to and values returned from functionsEach trace is assigned a number when you create it. Use this number to reference the trace in the various commands provided for manipulating traces (for example, ID="06.exec30"disable, ID="06.exec31"enable, and ID="06.exec32"delete, all described in IDREF="14485" TYPE="TITLE""Managing Breakpoints, Traces, and Conditional Commands").The syntax of the trace command is:traceID="06.exec33" variableWhenever the specified variable changes, ID="06.exec34"dbx prints the old and new values of that variable.traceID="06.exec35" procedurePrints the values of the parameters passed to the specified procedure whenever your program calls it. Upon return, ID="06.exec36"dbx prints the return value.traceID="06.exec37" [expression|variable] at lineWhenever your program reaches the specified line, dbx prints the value of the variable if its value has changed. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).ID="06.exec38"traceID="06.exec39" [expression|variable] in procedure Whenever the variable changes within the procedure, dbx prints the old and new values of that variable. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).trace [expression1|variable] at line if expression2 Prints the value of the variable (if changed) whenever your program reaches the specified line and the given expression is true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).trace [expression1|variable] in procedure if expression2 Whenever the variable changes within the procedure that you specify, dbx prints the old and new values of that variable, if the given expression is true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).To examine the parameters passed to and values returned from a function, you can trace that function. For example, if the function name is foo, set the trace by entering:(dbx) trace fooWhen you execute your program, dbx prints the values of the parameters passed to foo whenever your program calls it. Upon return from foo, dbx prints the return value:(dbx) run
[3] calling foo(text = 0x10000484 = "Processing...\n", i = 4) from function main
[4] foo returning -1 from fooIn the example shown above, foo receives two parameters: a character string variable named text containing the value "Processing...\n" and an integer variable named i containing the value 4. The trace also indicates that foo returns a value of -1.You can also examine a variable as it changes values. For example, you can monitor the value of a string variable named curarg as you use it to process an argument list. To set the trace, enter:(dbx) trace curarg
Process 2395: [6] trace .test.main.curarg in mainWhen you set a trace on a variable, examine the confirmation that dbx prints. If you use the same variable name in multiple functions in your program, dbx may not set the trace on the variable that you want. If dbx sets the trace on an incorrect variable, delete the trace and set a new trace using a qualified variable format as described in ID="06.exec40"IDREF="90553" TYPE="TITLE""Qualifying Variable Names". For more information on deleting traces, see IDREF="99674" TYPE="TITLE""Deleting Breakpoints, Traces, and Conditional Commands".So, in this example, if you use the variable curarg in both main and a function called arg_process, and you want to trace the curarg in arg_process, first delete this trace and then set a new trace:(dbx) delete 6
(dbx) trace arg_process.curarg
Process 2395: [7] trace .test.arg_process.curarg in arg_processWhen you execute your program, whenever curarg changes, dbx prints its old and new values:(dbx) run
[7] curarg changed before [arg_process: line 53]:
                new value = (nil);
[7] curarg changed before [arg_process: line 86]:
                old value = 0;
                new value = 0x7fffc7e5 = "-i";
[7] curarg changed before [arg_process: line 86]:
                old value = 2147469285;
                new value = 0x7fffc7eb = "names.out";
[7] curarg changed before [arg_process: line 86]:
                old value = 2147469291;
                new value = 0x7fffc7f5 = "names.in";LBL="" HELPID=""ID="89878"Writing Conditional CommandsA conditional command created with the ID="06.exec41"when command is similar to a breakpoint set with the stop command, except that rather than stopping when certain conditions are met, dbx executes a list of commands. The command list can consist of any dbx commands, separated by semicolons if you include more than one command in the command list. Additionally, you can use the keyword ID="06.exec42"stop in the command list to stop execution, just like a breakpoint.Each conditional command is assigned a number when you create it. You use this number to reference the conditional command in the various commands provided for manipulating conditional commands (for example, disable, enable, and delete, all described in IDREF="14485" TYPE="TITLE""Managing Breakpoints, Traces, and Conditional Commands").The syntax of the when command is:whenID="06.exec43" [expression|variable] {command-list} Inspects the value before executing each source line. If it has changed, executes the command list. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).ID="06.exec44"when [expression|variable] at line {command-list} Inspects the value at the given source line. If it has changed, executes the command list. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).when [expression|variable] in procedure {command-list} Inspects the value at every source line within a given procedure. If it has changed, executes the command list. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).when if expression {command-list}Evaluates the expression before executing each source line. If it is true, executes the command list. Note that execution is slow if you choose this type of conditional command execution.ID="06.exec45"when at line if expression {command-list}Evaluates the expression at the given line. If it is true, executes the command list.when in procedure if expression {command-list}Evaluates the expression at every source line within a given procedure. If it is true, executes the command list.when [expression1|variable] if expression2 {command-list} Checks if the value of the variable has changed. If it has changed and the expression is true, executes the command list. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).when [expression1|variable] at line if expression2 {command-list} Checks if the value of the variable has changed each time the line is executed. If the value has changed and the expression is true, executes the command list. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).when [expression1|variable] in procedure if expression2 {command-list} Checks if the value of variable has changed at each source line of the given procedure. If the value has changed and the expression is true, executes the command list. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).LBL="" HELPID=""ID="14485"Managing Breakpoints, Traces, and Conditional Commandsdbx provides commands that allow you to disable, enable, delete, and examine the status of the breakpoints, traces, and conditional commands that you set in your programs.Each breakpoint, trace, and conditional command is assigned a number when you create it. Use these numbers as identifiers in the various commands provided for manipulating these debugging controls.LBL="" HELPID=""ID="58446"Listing Breakpoints, Traces, and Conditional CommandsThe ID="06.exec46"status command lists all of the breakpoints, traces, and conditional commands that you have set and indicates whether they are enabled or disabled.ID="06.exec47"ID="06.exec48"ID="06.exec49"For example, consider executing the following commands while debugging a program called test:(dbx) stop in foo
Process     0: [3] stop in foo
(dbx) r
Process 22631 (test) started
[3] Process 22631 (test) stopped at [foo:38 ,0x10001050]
  38  r = foo2(i+1);
(dbx) trace total
Process 22631: [4] trace total in foo
(dbx) when at 60 {print i,j }
Process 22631: [5] when at "/usr/var/tmp/dbx_examples/test.c":60 { print i, j }If you enter status, you see the following:(dbx) status
Process 22631: [3] stop in foo
Process 22631: [4] trace total in foo
Process 22631: [5] when at "/usr/var/tmp/dbx_examples/test.c":60 { print i, j }LBL="" HELPID=""ID="84268"Disabling Breakpoints, Traces, and Conditional CommandsThe ID="06.exec50"disable command allows you to temporarily disable a breakpoint, trace, or conditional command so that it is inoperative and has no effect on program execution. dbx remembers all information about a disabled breakpoint, trace, or conditional command, and you may enable it using the enable command described in IDREF="14318" TYPE="TITLE""Enabling Breakpoints, Traces, and Conditional Commands".The syntax of the disable command is:disable item [, item ... ]Disables the specified breakpoint(s), trace(s), or conditional command(s). This command has no effect if the item you specify is already disabled.ID="06.exec51"ID="06.exec52"ID="06.exec53"For example, to disable the conditional command set in IDREF="58446" TYPE="TITLE""Listing Breakpoints, Traces, and Conditional Commands" enter:(dbx) disable 4If you enter status, you see the following:(dbx) status
Process 22631: [3] stop in foo
Process 22631: [4] (disabled) trace total in foo
Process 22631: [5] when at "/usr/var/tmp/dbx_examples/test.c":60 { print i, jLBL="" HELPID=""ID="14318"Enabling Breakpoints, Traces, and Conditional CommandsThe enable command reverses the effects of a disable command: The breakpoint, trace, or conditional command that you specify is enabled and once again affects the execution of your program. The syntax of the enable command is:enableID="06.exec54" item [, item ...]Enables the specified breakpoint(s), trace(s), or conditional command(s).ID="06.exec55"ID="06.exec56"ID="06.exec57"For example, to enable the conditional command disabled in IDREF="84268" TYPE="TITLE""Disabling Breakpoints, Traces, and Conditional Commands" enter:(dbx) enable 4Executing the status command shows that the condition command is now enabled:(dbx) status
Process 22631: [3] stop in foo
Process 22631: [4] trace total in foo
Process 22631: [5] when at "/usr/var/tmp/dbx_examples/test.c":60 { print i, jLBL="" HELPID=""ID="99674"Deleting Breakpoints, Traces, and Conditional CommandsThe ID="06.exec58"delete command allows you to delete breakpoints, traces, and conditional commands:deleteID="06.exec59" {item [, item ...] | all}Deletes the item or items specified. If you use the keyword all instead of listing individual items, dbx deletes all breakpoints, traces, and conditional commands.ID="06.exec60"ID="06.exec61"ID="06.exec62"For example, to delete the breakpoint and trace set in IDREF="58446" TYPE="TITLE""Listing Breakpoints, Traces, and Conditional Commands" enter:(dbx) delete 3, 4If you enter status, you see the following:(dbx) status
Process 22631: [5] when at "/usr/var/tmp/dbx_examples/test.c":60 { print i, j }To delete all breakpoints, traces, and conditional commands, enter:(dbx) delete allLBL="" HELPID=""ID="25866"Using Signal Processingdbx can detect any signals sent to your program while it is running and, at your option, stop the program.LBL="" HELPID=""Catching and Ignoring SignalsWith the catch command, you can instruct dbx to stop your program when it receives any specified signal. The ID="06.exec63"ignore command undoes the effects of a catch command. The catch and ignore commands have the following syntax:catch {signal | all}Instructs ID="06.exec64"dbx to stop your program whenever it receives the specified signal. If you use the keyword all rather than giving a specific signal, dbx catches all signals.ignoreID="06.exec65" {signal | all}Instructs ID="06.exec66"dbx to ignore the specified signal. All ignored signals are passed to your program normally. If you use the keyword all rather than giving a specific signal, dbx ignores all signals.catchPrints a list of all signals caught.ID="06.exec67"ignoreID="06.exec68"Prints a list of all signals ignored.ID="06.exec69"You can use the signal names and numbers as listed in the signal(2) reference page. You can also abbreviate the signal names by omitting the "SIG" portion of the name. You can use uppercase or lowercase for the signal names.NoteBecause "int" (in lowercase) is a dbx keyword, you cannot use it as an abbreviation for the SIGINT signal. You must use uppercase ("INT"), the full signal name ("SIGINT" or "sigint"), or the signal number ("2"). SIGINT is the only signal name with such a restriction.If you instruct dbx to catch a signal, whenever that signal is directed to your program, dbx intercepts it and stops your program. Your program does not see this signal until you continue your program with the cont command. If your program did not declare a signal handler for a signal, your program does not see the signal when dbx continues it.If you issue a SIGINT signal at the keyboard (usually by pressing <Ctrl-C>) while you are running an application under dbx, what happens depends on the circumstances:If the process is in the same IRIX process group as dbx, the interrupt signal is sent to both dbx and the process. Both dbx and the process stop running. You are left at the dbx command line.If the process was added with addproc, dbx ­P, or dbx ­p, it is not in the same IRIX process group as dbx. In this case, the signal interrupt is sent to dbx but not to the process. dbx stops running, but the process continues to run. Use the showproc command to see whether the process is still running. Then use the suspend command to stop the process. LBL="" HELPID=""ID="62814"Continuing After Catching a SignalThe ID="06.exec70"cont command allows you to continue execution after catching a signal. You can also use the cont command to specify a different signal to send to your program than the one that dbx caught. Using the same syntax, you can also send a signal to your program when you continue, even if your program did not stop because of a caught signal.Use the following forms of the cont command when handling signals. In each case, if you do not provide a signal, but your program stopped because dbx caught a signal intended for your program, then dbx sends that signal to your program when you continue execution:cont [signal]Continues execution with the current line and sends the specified signal to your program.ID="06.exec71"cont [signal] {at | to} lineSets a temporary breakpoint at the specified source line, then resumes execution with the current line and sends the specified signal to your program.ID="06.exec72"cont [signal] in procedureSets a temporary breakpoint to stop execution upon entering the specified procedure, then resumes execution with the current line and sends the specified signal to your program.For example, if your program stopped because dbx caught a SIGINT signal, dbx will automatically send that signal to your program, if you enter:(dbx) contSuppose you have a procedure called alarm_handler to handle an alarm signal sent to your program. If you want to test this procedure by single-stepping through it, you can execute the following command:(dbx) cont SIGALRM in alarm_handlerThis sets a temporary breakpoint to stop your program upon entering alarm_handler, continues execution of your program, and sends a SIGALRM signal to your program. Your program then enters the alarm_handler procedure and stops. You can then single-step through the procedure and observe execution.Debugging a program that attempts to catch signals can be awkward if you also catch the signal in dbx. For example, if your program wants to catch SIGFPEs and you issue the command:(dbx) catch sigfpeThen, after dbx catches the signal, you must execute the command:(dbx) ignore sigfpeThis prevents dbx from catching the signal again when you resume execution of your program.If you want to catch further instances of that signal in your program, you must regain dbx control (the best way is to set a breakpoint before executing the cont) to re-execute the catch sigfpe command.LBL="" HELPID=""ID="93296"Stopping at System CallsBecause system calls are part of the operating system and their source is generally not available for debugging purposes, you cannot set breakpoints in system calls using the same method that you use for your program's procedures. Instead, dbx provides the ID="06.exec73"syscall command to allow you to stop your program when it executes system calls. With the syscall command you can catch (breakpoint) system calls either at the entry to the system call or at the return from the system call.The syntax of the syscall command is:syscall catchID="06.exec74" {call | return} {system_call | all}Sets a breakpoint to stop execution upon entering (ID="06.exec75"call) or returning from (return) the specified system call. Note that you can set dbx to catch both the call and the return of a system call.If you use the keyword all rather than giving a specific system call, dbx catches all system calls.syscall ignoreID="06.exec76" {call | return} {system_call | all}Clears the breakpoint to stop execution upon entering (ID="06.exec77"call) or returning from (return) the specified system call.If you use the keyword all rather than giving a specific system call, dbx clears the breakpoints to stop execution upon entering (call) or returning from (return) all system calls.syscall catch [{call | return}]Prints a list of all system calls caught upon entry (ID="06.exec78"call) or return (return). If you provide neither the call nor return keyword, dbx lists all system calls that are caught.syscall ignore [{call | return}]Prints a list of all system calls not caught upon entry (ID="06.exec79"call) or return (return). If you provide neither the call nor return keyword, dbx lists all system calls that are ignored.syscallPrints a summary of the catch and ignore status of all system calls. The summary is divided into four sections: 1) caught at call, 2) caught at return, 3) ignored at call, and 4) ignored at return.NoteThe ID="06.exec80"fork and ID="06.exec81"sproc system calls are treated specially as they invoke new processes. The returns from these system calls are controlled by the dbx variables ID="06.exec82"$promptonfork and ID="06.exec83"$mp_program, not by syscall. This is discussed in IDREF="61470" TYPE="TITLE""Handling fork System Calls" and IDREF="59516" TYPE="TITLE""Handling sproc System Calls and Process Group Debugging".The ID="06.exec84"execv and ID="06.exec85"execve system calls are treated specially as they change a process into a new program. For more information, see IDREF="10836" TYPE="TITLE""Handling exec System Calls".The system calls are listed in /usr/include/sys.s. dbx ignores the case of the system call names in all syscall commands; therefore, you can use uppercase or lowercase in these commands.A particularly useful setting is:(dbx) syscall catch call exitThis stops your program upon entry to ID="06.exec86"exit. With your program stopped, you can do a stack trace before the termination to see why exit was called.LBL="" HELPID=""ID="31135"Stepping Through Your ProgramSteppingID="06.exec87" is a process of executing your program for a fixed number of lines and then automatically returning control to dbx. dbx provides two commands for stepping through lines of code: ID="06.exec88"step and ID="06.exec89"next.For both step and next, dbx counts only those source lines that actually contain code; for the purposes of stepping, dbx ignores blank lines and lines consisting solely of comments.The next and step commands differ in their treatment of procedure calls. When step encounters a procedure call, it usually "steps into" the procedure and continues stepping through the procedure (counting each line of source). On the other hand, when next encounters a procedure call, it "steps over" the procedurename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'executing it without stopping but not counting lines in the procedurename='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'and continues stepping through the current procedure.The following code fragment illustrates the difference between step and next: 55  foo( arg1, arg2 )
 56  int arg1, arg2;
 57  {
 58        if ( arg1 < arg2 ) {
 ...       ...
 78        return( 0 );
 79  }
 ...
211  x = foo( i, j );
212  y = 2 * x;In this example, if at line 211 you execute a step command to advance one line, dbx allows the process to proceed to line 58 (the first code line of the foo procedure). However, if you execute a next command, dbx executes line 211name='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'calling fooname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'and advances the process to line 212.LBL="" HELPID=""ID="33387"Stepping Using the step CommandThe format of the step command is:stepID="06.exec90" [integer]Executes the specified number of lines of source code, stepping into procedures. If you do not provide an argument, step executes one line. If step encounters any breakpoints, it immediately stops execution.By default, step steps into only those procedures that are compiled with the debugging option ID="06.exec91"­g. Note that this does not include standard library routines because they are not compiled using debugging options.ID="06.exec92"You can modify this behavior, even force dbx to step into procedures not compiled with full debugging information, by changing the value of the dbx variable $stepintoall. IDREF="66599" TYPE="TABLE"Table 6-1 summarizes how the value of ID="06.exec93"$stepintoall affects dbx's treatment of the step command.COLUMNS="2"LBL="6-1"Table 6-1 ID="66599"Effect of $stepintoall Variable on the step CommandLEFT="0" WIDTH="63"$stepintoall 
valueLEFT="70" WIDTH="261"Effect on step CommandLEFT="0" WIDTH="63"0 (default)LEFT="70" WIDTH="261"step steps into only those procedures that are compiled with the 
debugging option ­g. step steps over all other procedures.LEFT="0" WIDTH="63"1 or 2LEFT="70" WIDTH="261"step steps into all procedures.  Note that when you debug a 
source file compiled without symbols or compiled with 
optimization, the line numbers may sometimes jump erratically.Also note that if dbx cannot locate a source file, then it cannot 
display source lines as you step through a procedure.LBL="" HELPID=""ID="24643"Stepping Using the next CommandThe format of the next command is:nextID="06.exec94" [integer]Executes the specified number of lines of source code, stepping over procedures. If you do not provide an argument, next executes one line. If next encounters any breakpoints, even in procedures that it steps over, it immediately stops execution.LBL="" HELPID=""Using the return CommandIf you step into a procedure and then decide you don't want to step through the rest of it, use ID="06.exec95"return to finish executing the procedure and return to the calling procedure.The format of the return command is:returnID="06.exec96"Continues execution until control returns to the procedure that invoked the return command. return procContinues execution until control returns to the named procedure. Execution continues, unless stopped by a breakpoint, until the latest invocation of the procedure named by proc at the time the command was issued is reached. Execution doesn't stop at subsequent invocations of the same procedure. The search for the frame to return to starts with the previous frame, because the current frame is skipped in looking for a frame whose name matches proc. If execution is stopped for any reason, this command is cancelled. LBL="" HELPID=""ID="28904"Starting at a Specified LineWhen you continue your program, you typically do so at the place where it stopped using the ID="06.exec97"cont command. However, you can also force your program to continue at a different address by using the goto command:gotoID="06.exec98" lineBegins execution at the specified line. You may not use the goto command to resume execution with a line outside of the current procedure.LBL="7"ID="33796"Debugging Machine Language CodeThis chapter explains how to debug machine language code by:IDREF="88998" TYPE="TITLE""Examining and Changing Register Values"IDREF="51451" TYPE="TITLE""Examining Memory and Disassembling Code"IDREF="64338" TYPE="TITLE""Setting Machine-Level Breakpoints"IDREF="37993" TYPE="TITLE""Continuing Execution After a Machine-Level Breakpoint"IDREF="81564" TYPE="TITLE""Tracing Execution at the Machine Level"IDREF="94164" TYPE="TITLE""Writing Conditional Commands at the Machine Level"IDREF="53669" TYPE="TITLE""Stepping Through Machine Code"LBL="" HELPID=""ID="88998"Examining and Changing Register ValuesUsing dbx, you can examine and change the hardware registers during execution of your program. ID="07.mach1"IDREF="39923" TYPE="TABLE"Table 7-1 lists the machine form of the register names and the alternate software names as defined in the include file ID="07.mach2"regdef.h.COLUMNS="3"LBL="7-1"Table 7-1 ID="39923"Hardware Registers and AliasesLEFT="0" WIDTH="72"RegisterLEFT="80" WIDTH="72"Software NameLEFT="160" WIDTH="180"DescriptionLEFT="0" WIDTH="72"$r0LEFT="80" WIDTH="72"$zeroLEFT="160" WIDTH="180"Always 0LEFT="0" WIDTH="72"$r1LEFT="80" WIDTH="72"$atLEFT="160" WIDTH="180"Reserved for assemblerLEFT="0" WIDTH="72"$r2... $r3LEFT="80" WIDTH="72"$v0... $v1LEFT="160" WIDTH="180"Expression evaluations, function return 
values, static linksLEFT="0" WIDTH="72"$r4... $r7LEFT="80" WIDTH="72"$a0... $a3LEFT="160" WIDTH="180"ArgumentsLEFT="0" WIDTH="72"$r8... $r11LEFT="80" WIDTH="72"$t0... $t7$a4... $a7,$ta0... $ta3LEFT="160" WIDTH="180"Temporaries (32 bit)Arguments (64 bit)LEFT="0" WIDTH="72"$r12... $r15LEFT="80" WIDTH="72"$t4... $t7, $t0... $t3$ta0... $ta3LEFT="160" WIDTH="180"Temporaries (32 bit)Temporaries (64 bit)LEFT="0" WIDTH="72"$r16... $r23LEFT="80" WIDTH="72"$s0... $s7LEFT="160" WIDTH="180"Saved across procedure callsLEFT="0" WIDTH="72"$r24... $r25LEFT="80" WIDTH="72"$t8... $t9LEFT="160" WIDTH="180"TemporariesLEFT="0" WIDTH="72"$r26... $r27LEFT="80" WIDTH="72"$k0... $k1LEFT="160" WIDTH="180"Reserved for kernelLEFT="0" WIDTH="72"$r28LEFT="80" WIDTH="72"$gpLEFT="160" WIDTH="180"Global pointerLEFT="0" WIDTH="72"$r29LEFT="80" WIDTH="72"$spLEFT="160" WIDTH="180"Stack pointerLEFT="0" WIDTH="72"$r30LEFT="80" WIDTH="72"$s8LEFT="160" WIDTH="180"Saved across procedure callsLEFT="0" WIDTH="72"$r31LEFT="80" WIDTH="72"$raLEFT="160" WIDTH="180"Return addressLEFT="0" WIDTH="72"$mmhiLEFT="80" WIDTH="72"LEFT="160" WIDTH="180"Most significant multiply/divide result 
registerLEFT="0" WIDTH="72"$mmloLEFT="80" WIDTH="72"LEFT="160" WIDTH="180"Least significant multiply/divide result 
registerLEFT="0" WIDTH="72"$fcsrLEFT="80" WIDTH="72"LEFT="160" WIDTH="180"Floating point control and status registerLEFT="0" WIDTH="72"$feirLEFT="80" WIDTH="72"LEFT="160" WIDTH="180"Floating point exception instruction registerLEFT="0" WIDTH="72"$causeLEFT="80" WIDTH="72"LEFT="160" WIDTH="180"Exception cause registerLEFT="0" WIDTH="72"$d0, $d2, ... $d30$d0, $d2, ... $d31LEFT="80" WIDTH="72"LEFT="160" WIDTH="180"Double precision floating point registers(32 bit)(64 bit)LEFT="0" WIDTH="72"$f0, $f2, ... $f30$f0, $f1, ... $f31LEFT="80" WIDTH="72"LEFT="160" WIDTH="180"Single precision floating point registers(32 bit)(64 bit)For registers with alternate names, the dbx variable ID="07.mach3"$regstyle controls which name is displayed when you disassemble code (as described in ID="07.mach4"IDREF="51451" TYPE="TITLE""Examining Memory and Disassembling Code"). If $regstyle is set to 0, then dbx uses the alternate form of the register name (for example, "zero" instead of "r0," and "t1" instead of "r9"); if $regstyle is anything other than 0, the machine names are used ("r0" through "r31").LBL="" HELPID=""Printing Register ValuesUse the ID="07.mach5"printregs command to print the values stored in all registers.ID="07.mach6"The base in which the register values are displayed depends on the values of the dbx variables ID="07.mach7"$octints and ID="07.mach8"$hexints. By default, dbx prints the register values in decimal. You can set the output base to octal by setting the ID="07.mach9"dbx variable $octints to a nonzero value. You can set the output base to hexadecimal by setting the ID="07.mach10"dbx variable $hexints to a nonzero value. If you set both $octints and $hexints to nonzero values, $hexints takes precedence.To examine the register values in hexadecimal, enter the following:(dbx) set $hexints = 1
(dbx) printregs
r0/zero=0x0     r1/at=0x19050
r2/v0=0x8       r3/v1=0x100120e0
r4/a0=0x4       r5/a1=0xffffffad78
r6/a2=0xffffffad88      r7/a3=0x0
r8/a4=0x10      r9/a5=0x20
r10/a6=0x0      r11/a7=0xfbd5990
r12/t0=0x0      r13/t1=0x0
r14/t2=0x65     r15/t3=0x0
r16/s0=0x1      r17/s1=0xffffffad78
r18/s2=0xffffffad88     r19/s3=0xffffffaf70
r20/s4=0x0      r21/s5=0x0
r22/s6=0x0      r23/s7=0x0
r24/t8=0x0      r25/t9=0x10001034
r26/k0=0x0      r27/k1=0x20
r28/gp=0x1001a084       r29/sp=0xffffffaca0
r30/s8=0x0      r31/ra=0x1000110c

mdhi=0x0        mdlo=0xe0
cause=0x24      pc=0x10001050
fpcsr=0x0
f0=0.0000000e+00        f1=0.0000000e+00        f2=0.0000000e+00
f3=0.0000000e+00        f4=0.0000000e+00        f5=0.0000000e+00
f6=0.0000000e+00        f7=0.0000000e+00        f8=0.0000000e+00
f9=0.0000000e+00        f10=0.0000000e+00       f11=0.0000000e+00
f12=0.0000000e+00       f13=0.0000000e+00       f14=0.0000000e+00
f15=0.0000000e+00       f16=0.0000000e+00       f17=0.0000000e+00
f18=0.0000000e+00       f19=0.0000000e+00       f20=0.0000000e+00
f21=0.0000000e+00       f22=0.0000000e+00       f23=0.0000000e+00
f24=0.0000000e+00       f25=0.0000000e+00       f26=0.0000000e+00
f27=0.0000000e+00       f28=0.0000000e+00       f29=0.0000000e+00
f30=0.0000000e+00       f31=0.0000000e+00
d0=0.000000000000000e+00        d1=0.000000000000000e+00
d2=0.000000000000000e+00        d3=0.000000000000000e+00
d4=0.000000000000000e+00        d5=0.000000000000000e+00
d6=0.000000000000000e+00        d7=0.000000000000000e+00
d8=0.000000000000000e+00        d9=0.000000000000000e+00
d10=0.000000000000000e+00       d11=0.000000000000000e+00
d12=0.000000000000000e+00       d13=0.000000000000000e+00
d14=0.000000000000000e+00       d15=0.000000000000000e+00
d16=0.000000000000000e+00       d17=0.000000000000000e+00
d18=0.000000000000000e+00       d19=0.000000000000000e+00
d20=0.000000000000000e+00       d21=0.000000000000000e+00
d22=0.000000000000000e+00       d23=0.000000000000000e+00
d24=0.000000000000000e+00       d25=0.000000000000000e+00
d26=0.000000000000000e+00       d27=0.000000000000000e+00
d28=0.000000000000000e+00       d29=0.000000000000000e+00
d30=0.000000000000000e+00       d31=0.000000000000000e+00(Note that there are twice as many floating point registers with 64-bit programs.) You can also use the value of a single register in an expression by typing the name of the register preceded by a dollar sign ($). ID="07.mach11"For example, to print the current value of the program counter (the pc register), enter:(dbx) printx $pc
0x10001050LBL="" HELPID=""ID="34959"Changing Register ValuesIn the same way you change the values of program variables, you can use the ID="07.mach12"assign command to change the value of registers:assignID="07.mach13" register = expressionAssigns the value of ID="07.mach14"expression to register. You must precede the name of the register with a dollar sign ($).For example:(dbx) assign $f0 = 3.14159
3.1415899999999999
(dbx) assign $t3 = 0x5a
0x5aBy default, the ID="07.mach15"assignregister command changes the register value in the current activation level, which is a typical operation. To force the hardware register to be updated regardless of the current activation level, use the $ set $framereg command. ID="07.mach16"LBL="" HELPID=""ID="51451"Examining Memory and Disassembling CodeThe forward slash (/) and question mark (?) commands allow you to examine the contents of memory. Depending on the format you specify, you can display the values as numbers, characters, or disassembled machine code. Note that all common forms of address are supported. Some unusual expressions may not be accepted unless enclosed in parentheses, as in (address)/count format.The commands for examining memory have the following syntax:address ID="07.mach17"/ count formatPrints the contents of the specified address, or disassembles the code for the instruction at the specified address. Repeat for a total of ID="07.mach18"ID="07.mach19"count addresses in increasing addressname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in other words, an "examine forward" command. The format codes are listed in IDREF="54646" TYPE="TABLE"Table 7-2.address ID="07.mach20"? count formatPrints the contents of the specified address or, disassembles the code for the instruction at the specified address. Repeat for a total of ID="07.mach21"ID="07.mach22"count addresses in decreasing addressname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in other words, an "examine backward" command. The format codes are listed in IDREF="54646" TYPE="TABLE"Table 7-2.address / count L value maskExamines ID="07.mach23"count 32-bit words in increasing addresses; prints those 32-bit words which, when ORed with mask, equals value. This command searches memory for specific patterns../Repeats the previous examine command with increasing address. .?Repeats the previous examine command with decreasing address.COLUMNS="2"LBL="7-2"Table 7-2 ID="54646"Memory Display Format CodesLEFT="0" WIDTH="72"Format CodeLEFT="80" WIDTH="216"Displays Memory in the FormatLEFT="0" WIDTH="72"iLEFT="80" WIDTH="216"print machine instructions (disassemble)LEFT="0" WIDTH="72"dLEFT="80" WIDTH="216"print a 16-bit word in signed decimalID="07.mach24"LEFT="0" WIDTH="72"DLEFT="80" WIDTH="216"print a 32-bit word in signed decimalID="07.mach25"LEFT="0" WIDTH="72"ddLEFT="80" WIDTH="216"print a 64-bit word in signed decimalID="07.mach26"LEFT="0" WIDTH="72"oLEFT="80" WIDTH="216"print a 16-bit word in octalLEFT="0" WIDTH="72"OLEFT="80" WIDTH="216"print a 32-bit word in octalID="07.mach27"LEFT="0" WIDTH="72"ooLEFT="80" WIDTH="216"print a 64-bit word in octalLEFT="0" WIDTH="72"xLEFT="80" WIDTH="216"print a 16-bit word in hexadecimalLEFT="0" WIDTH="72"XLEFT="80" WIDTH="216"print a 32-bit word in hexadecimalID="07.mach28"LEFT="0" WIDTH="72"xxLEFT="80" WIDTH="216"print a 64-bit word in hexadecimalLEFT="0" WIDTH="72"vLEFT="80" WIDTH="216"print a 16-bit word in unsigned decimalLEFT="0" WIDTH="72"VLEFT="80" WIDTH="216"print a 32-bit word in unsigned decimalLEFT="0" WIDTH="72"vvLEFT="80" WIDTH="216"print a 64-bit word in unsigned decimalLEFT="0" WIDTH="72"LLEFT="80" WIDTH="216"like X but use with val mask LEFT="0" WIDTH="72"bLEFT="80" WIDTH="216"print a byte in octalID="07.mach29"LEFT="0" WIDTH="72"cLEFT="80" WIDTH="216"print a byte as character LEFT="0" WIDTH="72"sLEFT="80" WIDTH="216"print a string of characters that ends in a null byte LEFT="0" WIDTH="72"fLEFT="80" WIDTH="216"print a single-precision real number LEFT="0" WIDTH="72"gLEFT="80" WIDTH="216"print a double-precision real numberFor example, to display 10 disassembled machine instructions starting at the current address of the program counter, enter:(dbx) $pc/10i
*[main:26, 0x400290]    sw      zero,28(sp)
 [main:27, 0x400294]    sw      zero,24(sp)
 [main:29, 0x400298]    lw      t1,28(sp)
 [main:29, 0x40029c]    lw      t2,32(sp)
 [main:29, 0x4002a0]    nop
 [main:29, 0x4002a4]    slt     at,t1,t2
 [main:29, 0x4002a8]    beq     at,zero,0x4002ec
 [main:29, 0x4002ac]    nop
 [main:31, 0x4002b0]    lw      t3,28(sp)
 [main:31, 0x4002b4]    nopTo disassemble another 10 lines, enter:(dbx) ./
 [main:31, 0x4002b8]    addiu   t4,t3,1
 [main:31, 0x4002bc]    sw      t4,28(sp)
 [main:32, 0x4002c0]    lw      t5,24(sp)
 [main:32, 0x4002c4]    lw      t6,28(sp)
 [main:32, 0x4002c8]    nop
 [main:32, 0x4002cc]    addu    t7,t5,t6
 [main:32, 0x4002d0]    sw      t7,24(sp)
 [main:33, 0x4002d4]    lw      t8,28(sp)
 [main:33, 0x4002d8]    lw      t9,32(sp)
 [main:33, 0x4002dc]    nopTo examine ten 32-bit words starting at address 0x7fffc754, and print those whose least significant byte is hexadecimal 0x19, enter:(dbx) 0x7fffc754 / 10 L 0x19 0xff
7fffc758:  00000019Consider a single-precision floating point array named array. You can examine the six consecutive elements, beginning with the fifth element, by entering:(dbx) &array[4] / 6f
7fffc748:  0.2500000 0.2000000 0.1666667 0.1428571
7fffc758:  0.1250000 0.1111111LBL="" HELPID=""ID="64338"Setting Machine-Level Breakpointsdbx allows you to set breakpoints while debugging machine code just as you can while debugging source code. You set breakpoints at the machine code level using the ID="07.mach30"ID="07.mach31"stopi command.The conditional and unconditional versions of the stopi commands work in the same way as the stop command described in IDREF="23865" TYPE="TITLE""Setting Breakpoints" with these exceptions:The stopi command checks its breakpoint conditions on a machine-instruction level instead of a source-code level.The stopi at command requires an address rather than a line number.Each breakpoint is assigned a number when you create it. Use this number to reference the breakpoint in the various commands provided for manipulating breakpoints (for example, ID="07.mach32"disable, ID="07.mach33"enable, and ID="07.mach34"delete, all described in IDREF="14485" TYPE="TITLE""Managing Breakpoints, Traces, and Conditional Commands").LBL="" HELPID=""Syntax of the stopi CommandThe syntax of the stopi command is:stopi atID="07.mach35"Sets an unconditional breakpoint at the current instruction.ID="07.mach36"stopi atID="07.mach37" addressSets an unconditional breakpoint at the specified address.ID="07.mach38"stopi in procedureSets an unconditional breakpoint to stop execution upon entering the specified procedure.stopi [expression|variable] Inspects the value before executing each machine instruction and stops if the value has changed. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).ID="07.mach39"stopi [expression|variable] at address Inspects the value when the program is at the given address and stops if the value has changed (for machine-level debugging). If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).ID="07.mach40"stopi [expression|variable] in procedure Inspects the value at every machine instruction within a given procedure and stops if the value has changed. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stopi if expressionEvaluates the expression before executing each instruction and stops if the expression is true. Note that execution is very slow if you choose this type of conditional breakpoint.stopi at address if expressionEvaluates the expression at the given address and stops if the expression is true.stopi in procedure if expressionEvaluates the expression at every instruction within a given procedure and stops if the expression is true.stopi [expression1|variable] if expression2 Tests both conditions before executing each machine instruction. Stops if both conditions are true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stopi [expression1|variable] at address if expression2 Tests both conditions at the given address (for machine-level debugging). Stops if both conditions are true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stopi [expression1|variable] in procedure if expression2 Tests the expression each time that the given variable changes within the given procedure. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).NoteWhen you stop execution because of a machine-level breakpoint set by one of the stopi in commands, a ID="07.mach41"where command at the point of stop may yield an incorrect stack trace. This is because the stack for the function is not completely set up until several machine instructions have been executed. dbx attempts to account for this, but is sometimes unsuccessful.LBL="" HELPID=""ID="54393"Linking With DSOsIf you link with a DSO, be careful when you use the stopi at command. For example, suppose you enter:dbx()stopi at functionxThe breakpoint at functionx is hit only if the gp_prolog instruction is executed. (gp_prolog is a short sequence of instructions at the beginning of the routine.) To avoid this problem, use the stopi in command:dbx()stopi in functionxIf you really want to use stopi at, a safe alternative is to disassemble functionx and put the breakpoint after the gp_prolog. For more information on gp_prolog, see the MIPSpro Assembly Language Programmer's Guide.The tracei at, wheni at, and conti at commands described in the following sections also follow this pattern. Use their "in" versions to ensure that the function breakpoint is hit.LBL="" HELPID=""ID="37993"Continuing Execution After a Machine-Level BreakpointThe ID="07.mach42"conti command continues executing assembly code after a breakpoint. As with the ID="07.mach43"ID="07.mach44"cont command, if your program stops because dbx catches a signal intended for your program, then dbx sends that signal to your program when you continue execution. You can also explicitly send a signal to your program when you continue execution. Signal processing and sending signals to your program is discussed in ID="07.mach45"IDREF="25866" TYPE="TITLE""Using Signal Processing".The syntax of the conti command is:contiID="07.mach46" [signal]Continues execution with the current instruction.contiID="07.mach47" [signal] {at | to} addressSets a temporary breakpoint at the specified address, then resumes execution with the current instruction. When your program reaches the breakpoint at address, dbx stops your program and deletes the temporary breakpoint.contiID="07.mach48" [signal] in procedureSets a temporary breakpoint to stop execution upon entering the specified procedure, then resumes execution with the current instruction. When your program reaches the breakpoint in procedure, dbx stops your program and deletes the temporary breakpoint.See also IDREF="54393" TYPE="TITLE""Linking With DSOs" for a description on using the conti in and conti at commands with DSOs.LBL="" HELPID=""ID="81564"Tracing Execution at the Machine LevelThe ID="07.mach49"tracei command allows you to observe the progress of your program while debugging machine code, just as you can with the trace command while debugging source code. The tracei command traces in units of machine instructions instead of in lines of code.Each trace is assigned a number when you create it. Use this number to reference the breakpoint in the various commands provided for manipulating breakpoints (for example, ID="07.mach50"disable, ID="07.mach51"enable, and ID="07.mach52"delete, all described in IDREF="14485" TYPE="TITLE""Managing Breakpoints, Traces, and Conditional Commands").The syntax of the tracei command is:traceiID="07.mach53" [expression|variable] Whenever the specified variable changes, ID="07.mach54"dbx prints the old and new values of that variable. (For machine-level debugging.) Note that execution is very slow if you choose this type of trace.If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).traceiID="07.mach55" procedureThis command is equivalent to entering traceprocedure. dbx prints the values of the parameters passed to the specified procedure whenever your program calls it. Upon return, dbx prints the return value.traceiID="07.mach56" [expression|variable] at address Prints the value of the variable whenever your program reaches the specified address. (For machine-level debugging.) If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).ID="07.mach57"traceiID="07.mach58" [expression|variable] in procedure Whenever the variable changes within the procedure that you specify, ID="07.mach59"dbx prints the old and new values of that variable. (For machine-level debugging.) If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).traceiID="07.mach60" [expression1|variable] at address if expression2 Prints the value of the variable whenever your program reaches the specified address and the given expression is true. (For machine-level debugging.) If ID="07.mach61"expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).traceiID="07.mach62" [expression1|variable] in procedure if expression2 Whenever the variable changes within the procedure that you specify, ID="07.mach63"dbx prints the old and new values of that variable, if the given expression is true. (For machine-level debugging.) If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).See also IDREF="54393" TYPE="TITLE""Linking With DSOs" for a description on using the tracei in and tracei at commands with DSOs.LBL="" HELPID=""ID="94164"Writing Conditional Commands at the Machine LevelUse the ID="07.mach64"wheni command to write conditional commands for use in debugging machine code. The wheni command works in the same way as the when command described in IDREF="89878" TYPE="TITLE""Writing Conditional Commands". The command list is a list of dbx commands, separated by semicolons. When the specified conditions are met, the command list is executed. If one of the commands in the list is stop (with no operands), then the process stops when the command list is executed.wheni ifID="07.mach65" expression {command-list}Evaluates the expression before executing each machine instruction. If the expression is true, executes the command list.wheni at address if expression {command-list}Evaluates the expression at the given address. If the expression is true, executes the command list. wheni in procedure if expression {command-list}Evaluates the expression in the given procedure. If the expression is true, executes the command list. wheniID="07.mach66" variable at address if expression {command-list}Tests both conditions at the given address. If the conditions are true, executes the command list. (For machine-level debugging.) If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).wheni variable in procedure if expression {command-list}Tests both conditions at every machine instruction within a given procedure. If they are true, executes the command list.See also IDREF="54393" TYPE="TITLE""Linking With DSOs" for a description on using the wheni in and wheni at commands with DSOs.LBL="" HELPID=""ID="53669"Stepping Through Machine CodeThe ID="07.mach67"ID="07.mach68"stepi and ID="07.mach69"nexti commands allow you to step through machine code in much the same way as you can with the step and next commands while debugging source code. The step and next commands step in units of machine instructions instead of in lines of code.The formats of the nexti and stepi commands are:nextiID="07.mach70" [integer]Executes the specified number of machine instructions, stepping over procedures. If you do not provide an argument, nexti executes one instruction. If nexti encounters any breakpoints, even in procedures that it steps over, it immediately stops execution.stepiID="07.mach71"Single steps one machine instruction, stepping into procedures (as called by jal and jalr). If stepi encounters any breakpoints, it immediately stops execution.stepiID="07.mach72" [n]Executes the specified number of machine instructions, stepping into procedures (as called by jal and jalr). The values of the dbx variable ID="07.mach73"$stepintoall affects the stepi and nexti commands just as they do the step and next commands. See IDREF="31135" TYPE="TITLE""Stepping Through Your Program" for a discussion of these variables.For the stepj command, dbx determines the next jump by reading through the instructions until it finds a jump or jal machine instruction. Because it ignores conditional branches, it does not necessarily follow the sequence of the program's execution to find the "next" jump. This means that it may not stop where you expect.LBL="8"ID="42908"Multiple Process DebuggingThis chapter explains multiprocess debugging procedures, including:ID="08.multiple1"IDREF="12529" TYPE="TITLE""Listing Available Processes"IDREF="45986" TYPE="TITLE""Adding a Process to the Process Pool"IDREF="89656" TYPE="TITLE""Deleting a Process From the Process Pool"IDREF="16095" TYPE="TITLE""Selecting a Process"IDREF="38426" TYPE="TITLE""Suspending a Process"IDREF="87200" TYPE="TITLE""Resuming a Suspended Process"IDREF="12702" TYPE="TITLE""Waiting for a Resumed Process"IDREF="82112" TYPE="TITLE""Waiting for Any Running Process"IDREF="68796" TYPE="TITLE""Killing a Process"IDREF="61470" TYPE="TITLE""Handling fork System Calls"IDREF="10836" TYPE="TITLE""Handling exec System Calls"IDREF="59516" TYPE="TITLE""Handling sproc System Calls and Process Group Debugging"LBL="" HELPID=""Processesdbx supports debugging multiprocess applications, including processes spawned with either the ID="08.multiple2"fork(2) or ID="08.multiple3"sproc(2) system calls. You can attach child processes automatically to dbx. You also can perform process control operations on a single process or on all processes in a group.dbx provides commands specifically for seizing, stopping, and debugging currently running processes. When dbx seizes a process, it adds it to a pool of processes available for debugging. Once you select a process from the pool of available processes, you can use all the ID="08.multiple4"dbx commands normally available.Once you are finished with the process, you can terminate it, return it to the pool, or return it to the operating system.LBL="" HELPID=""Using the pid ClauseMany ID="08.multiple5"dbx commands allow you to append the clause ID="08.multiple6"pidpid (where pid is a numeric process ID or a debugger variable holding a process ID). Using the pidpid clause means you can apply a command to any process in the process pool even though it is not the active process.For example, to set a breakpoint at line 97 of the process whose ID is 12745, enter:(dbx) stop at 97 pid 12745
Process 12745: [3] stop at "/usr/demo/test.c":97Commands that accept the pidpid clause include:active        edit        resume         wait
addproc       file        return         whatis
assign        func        showpoc        when, when[i]
catch         goto        status         where
cont, cont[i] ignore      step, step[i}  whereis
delete        kill        stop, stop[i]  which
delproc       next        suspend
directory     print       trace, trace[i]
down          printf      up
dump          printregs   useLBL="" HELPID=""Using the pgrp ClauseMany dbx commands allow the pgrp clause as a way to apply a command to several processes. For information, see IDREF="59516" TYPE="TITLE""Handling sproc System Calls and Process Group Debugging".LBL="" HELPID=""Using ScriptsAdditionally, dbx provides two variables that you can use when writing scripts to debug multiprocess programs:ID="08.multiple7"$lastchild Always set to the process ID of the last child process created by a fork or sproc.ID="08.multiple8"$pid0 Always set to the process ID of the process started by the run command.See the dbx online help file section on hint_mp_debug for sample multiprocessing debugging scripts.LBL="" HELPID=""ID="12529"Listing Available ProcessesUse the showproc command to list the available processes:showprocID="08.multiple9"Shows processes already in the ID="08.multiple10"dbx process pool or processes that dbx can control. Without any arguments, dbx lists the processes it already controls. showproc allID="08.multiple11"Lists all the processes it controls as well as all those processes it could control but that are not yet added to the process pool.showprocID="08.multiple12" pidShows the status of the process ID.ID="08.multiple13"For example, to display all processes in the process pool, enter:(dbx) showproc
Process 12711 (test) Trace/BPT trap [main:14 ,0x40028c]
Process 12712 (test) Trace/BPT trap [main:18 ,0x4002b4]To display only process 12712, enter:(dbx) showproc 12712
Process 12712 (test) Trace/BPT trap [main:18 ,0x4002b4]To display all processes that dbx can control, enter:(dbx) showproc all
Process 12711 (test) Trace/BPT trap [main:14 ,0x40028c]
Process 12055 (tcsh)
Process 12006 (clock)
Process 12054 (tcsh)
Process 12673 (zipxgizmo)
Process 12672 (zip)
Process 11974 (4Dwm)
Process 12712 (test) Trace/BPT trap [main:18 ,0x4002b4]
Process 12708 (dbx)
Process 12034 (xlock)LBL="" HELPID=""ID="45986"Adding a Process to the Process PoolThe ID="08.multiple14"ID="08.multiple15"addproc command adds one or more specified processes to the dbx process pool. This allows you to debug a program that is already running. The syntax of the addproc command is:addprocpid [ ... ]addprocvarFor example:(dbx) addproc 12924
Reading symbolic information of Process 12924 . . .
Process 12924 (loop_test) added to pool
Process 12924 (loop_test) runningEquivalently, you can enter either of the following:(dbx) set $foo = 12924
(dbx) addproc $fooLBL="" HELPID=""ID="89656"Deleting a Process From the Process PoolThe ID="08.multiple16"ID="08.multiple17"delproc command removes a process or variable from the process pool, freeing it from dbx control. When you delete a process from the process pool, dbx automatically returns the process to normal operation. The syntax of the delproc command is:delprocpid [ ... ]delprocvarFor example:(dbx) delproc 12924
Process 12924 (loop_test) deleted from poolEquivalently, you can enter either of the following:(dbx) set $foo = 12924
(dbx) delproc $fooLBL="" HELPID=""ID="16095"Selecting a ProcessThe dbx command has the ability to control multiple processes. However, dbx commands (by default) apply to only one process at a time, the active process. To select a process from the process pool to be the active process, use the active command:activeID="08.multiple18" [pid]Selects a process, ID="08.multiple19"pid, from dbx process pool as the active process. If you do not provide a process ID, dbx prints the currently active process ID.ID="08.multiple20"For example, to determine which process is currently active, enter:(dbx) active
Process 12976 (test1) is activeTo then select process 12977 as the active process, enter:(dbx) active 12977
Process 12977 (test1) after fork [.fork.fork:15 +0x8,0x4005e8]LBL="" HELPID=""ID="38426"Suspending a ProcessThe suspend command allows you to stop a process in the dbx process pool:suspendID="08.multiple21" Suspends the active process if it is running. If it is not running, this command does nothing.ID="08.multiple22"suspend allID="08.multiple23"Suspends all the processes.ID="08.multiple24"suspend pid ID="08.multiple25"pid Suspends the process ID="08.multiple26"pid if it is in the dbx process pool. If it is not running, this command does nothing.suspend ID="08.multiple27"pgrp Suspends all the processes in the ID="08.multiple28"pgrp.For example, to stop the active process, enter:(dbx) suspend
Process 12987 (loop_test) requested stop [main:10 +0x8,0x400244]
  10  i = i % 10;Then to stop process 12988, enter:(dbx) suspend pid 12988
Process 12988 (test3) requested stop [main:29 +0x4,0x400424]
  10  j = k / 10.0;LBL="" HELPID=""ID="87200"Resuming a Suspended ProcessTo resume execution of a suspended dbx controlled process, you can use either the ID="08.multiple29"cont command or the resume command. If you use cont, you do not return to the dbx command interpreter until the program encounters an event (for example, a breakpoint). On the other hand, the resume command returns immediately to the dbx command interpreter.The syntax of the resume command is:resumeID="08.multiple30" Resumes execution of the program, and returns immediately to the ID="08.multiple31"dbx command interpreter.resumeID="08.multiple32" [signal]Resumes execution of the process, sending it the specified signal, and returns immediately to the ID="08.multiple33"ID="08.multiple34"dbx command interpreter.Because the resume command returns you to the dbx command interpreter after restarting the process, it is more useful than using the cont command when you're debugging multiple processes. With resume, you are free to select and debug a process while another process is running.If any resumed process modifies the terminal modes (for example if it uses curses(3X)), dbx can't correctly control the modes. Intercept programs using curses by typing dbx ­p (or dbx ­P).For example, if you are debugging multiple processes and want to resume the active process, enter:(dbx) resumedbx restarts the active process and returns the dbx prompt. You can then continue debugging, for example by switching to another process.To resume all the processes in pgrp 2 and send a SIGINT signal to the process when dbx resumes, enter:(dbx) resume SIGINT 2LBL="" HELPID=""ID="12702"Waiting for a Resumed ProcessTo wait for a process to stop for an event (such as a breakpoint), use the wait command. This is useful after a resume command. Also refer to the description of the ID="08.multiple35"waitall command, described in IDREF="82112" TYPE="TITLE""Waiting for Any Running Process".The syntax of the wait command is:waitID="08.multiple36" Waits for the active process to stop for an event.ID="08.multiple37"wait pid ID="08.multiple38"pid Waits for the process ID="08.multiple39"pid to stop for an event.For example, assume that you want to wait until process 14280 stops, perhaps at a breakpoint you have set. To do so, enter:(dbx) wait pid 14280After you enter this command, dbx waits until process 14280 stops, at which point it displays the dbx prompt.LBL="" HELPID=""ID="82112"Waiting for Any Running ProcessTo wait for any process currently running to breakpoint or stop for any reason, use the ID="08.multiple40"ID="08.multiple41"waitall command. It causes dbx to wait until a running process in the process list stops, at which point it returns you to the dbx command interpreter.NoteWhen you return to the dbx command interpreter after a waitall command, dbx does not make the process that stopped the active process. You must use the active command to change the active process.For example, to wait until one of your processes under dbx control stops, enter:(dbx) waitallAfter you enter this command, dbx waits until a process stops, at which point it indicates which process stopped and displays the dbx prompt. For example:Process 14281 (loop_test) Terminated [main:10 +0x8,0x400244]
  10  i = i % 10;
(dbx)LBL="" HELPID=""ID="68796"Killing a ProcessTo kill a process in the process pool while running dbx, use the kill command:killID="08.multiple42" Kills the active process. ID="08.multiple43"killID="08.multiple44" pid [ ... ]Kills the specified process(es).ID="08.multiple45"For example, to kill process 14257, enter:(dbx) kill 14257
Process 14257 (fork_test) terminated
Process 14257 (fork_test) deleted from poolLBL="" HELPID=""ID="61470"Handling fork System CallsWhen a program executes a ID="08.multiple46"fork system call and starts another process, dbx allows you to add that process to the process pool. (See also IDREF="93296" TYPE="TITLE""Stopping at System Calls".)The dbx variable ID="08.multiple47"$promptonfork determines how dbx treats forks. IDREF="43416" TYPE="TABLE"Table 8-1 summarizes its effects.COLUMNS="2"LBL="8-1"Table 8-1 ID="43416"How the $promptonfork Variable Affects dbx's Treatment of ForksLEFT="0" WIDTH="72"ID="08.multiple48"$promptonfork 
ValueLEFT="80" WIDTH="261"Effect on dbx's Treatment of ForksLEFT="0" WIDTH="72"0 (default)LEFT="80" WIDTH="261"dbx does not add the child process to the process pool. Both the 
child process and the parent process continue to run.LEFT="0" WIDTH="72"1LEFT="80" WIDTH="261"dbx stops the parent process and asks if you want to add the child 
process to the process pool. If you answer yes, then dbx adds the 
child process to the pool and stops the child process; if you 
answer no, dbx allows the child process to run and does not place 
it in the process pool.LEFT="0" WIDTH="72"2LEFT="80" WIDTH="261"dbx automatically stops both the parent and child processes and 
adds the child process to the process pool.NoteIDREF="59516" TYPE="TITLE""Handling sproc System Calls and Process Group Debugging" provides additional information on debugging multiprocessing programs; some of the material in that section can apply also to programs that use the fork system call.Consider a program named fork that contains these lines:main(argc, argv)
int argc;
char *argv;
{
   int pid;
   if ((pid = fork()) == -1)
      perror("fork");
   else if (pid == 0)
      printf("child\n");
   else { printf("parent\n");
}If you set $promptonfork to 1 and run the program, dbx prompts you whether it should add the child process to the process pool:(dbx) set $promptonfork = 1
(dbx) run
Process 22661 (fork) started
Process 22662 (fork) has executed the "fork" system call

Add child to process pool (n if no)?y
Process 22662 (fork) added to pool
Process 22662 (fork) stopped on sysexit fork [_fork:28 ,0x40643a4]
Process 22661 (fork) stopped on sysexit fork [_fork:28 ,0x40643a4]
         Source (of /shamu/lib/libc/libc_64/proc/fork.s) not available for Process 22661LBL="" HELPID=""ID="10836"Handling exec System CallsThe ID="08.multiple49"exec system call executes another program. During an exec, the first program gives up its process number to the program it executes. When a program using DSOs executes an exec() call, dbx runs the new program to main. When a program linked with a non-shared library executes an exec() call, dbx reads the symbolic information for the new program and then stops program execution. In either case, you can continue by entering a cont or resume command.For example, consider the programs exec1.c and exec2.c:/* exec1.c */
main()
{
   printf("in exec1\n");
   /* Invoke the "exec2" program */

   execl("exec2", "exec2", 0);

   /* We'll only get here if execl() fails */

   perror("execl");
}
/* exec2.c */
main()
{
   printf("in exec2\n");
}You can enter cont to continue executing exec2. For example:(dbx) cont
in exec2
Process 14409 (exec2) finishedLBL="" HELPID=""ID="59516"Handling sproc System Calls and Process Group DebuggingThe process group facility allows a group of processes to be operated on simultaneously by a single ID="08.multiple50"dbx command. This is more convenient to use when dealing with processes created with the ID="08.multiple51"sproc system call than issuing individual resume, suspend, or breakpoint setting commands. This facility was created to deal more conveniently with parallel programs created, for example, by the Power Fortran Accelerator (PFA).ID="08.multiple52"ID="08.multiple53"The dbx variable ID="08.multiple54"$mp_program determines how dbx treats ID="08.multiple55"sproc system calls. IDREF="92131" TYPE="TABLE"Table 8-2 summarizes its effects.COLUMNS="2"LBL="8-2"Table 8-2 ID="92131"How the $mp_program Variable Affects dbx's Treatment of sprocsLEFT="0" WIDTH="72"$mp_program 
ValueLEFT="80" WIDTH="261"Effect on dbx's Treatment of sprocLEFT="0" WIDTH="72"0 (default)LEFT="80" WIDTH="261"dbx treats calls to sproc in the same way as it treats calls to ID="08.multiple56"fork.LEFT="0" WIDTH="72"1LEFT="80" WIDTH="261"Child processes created by calls to sproc are allowed to run; they 
block on multiprocessor synchronization code emitted by mp 
Fortran or C code. When you set $mp_program to 1, multiprocess 
Fortran or C code is easier to debug.Whenever a process executes a sproc, if dbx adds the child to the process pool, dbx also adds the parent and child to the ID="08.multiple57"group list. The group list is simply a list of processes. If you set the dbx variable ID="08.multiple58"$groupforktoo to 1, then forked processes are added to the group list automatically just as sproced processes are. (By default, $groupforktoo is 0.)You can explicitly add one or more processes to the group list with the ID="08.multiple59"ID="08.multiple60"addpgrp command (you can add only processes in the process pool to the group list):addpgrppid [ ... ]You can remove processes from the group list with the ID="08.multiple61"ID="08.multiple62"delpgrp command:delpgrppid [ ... ]The ID="08.multiple63"ID="08.multiple64"showpgrp command displays information about the group list. The showpgrp command shows the process group numbers and all the stop, trace, or when events in each. These events are created by stop[i], when[i] ... pgrp (which create multiple stop, trace, or when events) and by deletepgrp commands, which delete them.The following example shows the output of the showpgrp command with two processes in the group list:(dbx) showpgrp
2 processes in group:
 14559 14558Once you add processes to the group list (by adding the keyword pgrpID="08.multiple65" to the end of certain dbx commands), you can apply that command to all processes in the group. The commands to which you can append pgrp are: delete, next[i], resume, stop[i], status, suspend, trace[i], and when[i].The breakpoints and traces set by the ID="08.multiple66"ID="08.multiple67"stop[i], trace[i], and when commands, when used with the pgrp keyword, are also added to the ID="08.multiple68"group history. This group history is displayed as a numbered list when you execute showpgrp.For example, to delete the history entry 7 for the process group, enter:delete 7 pgrpThus, you can delete breakpoints from multiple processes with a single command.Breakpoints set on the process group are recorded both in the group and in each process. Deleting breakpoints individually (even if set by a group command) is allowed.For example, the following command sets a breakpoint at line 10 in all processes in the group list:(dbx) stop at 10 pgrp
Process 14558: [6] stop at "/usr/demo/pgrp_test.c":10
Process 14559: [7] stop at "/usr/demo/pgrp_test.c":10If you now enter a status command, only those breakpoints associated with the active process are displayed:(dbx) status
Process 14559: [7] {pgrp 269011340} stop at "/usr/demo/pgrp_test.c":10By appending the keyword pgrp, you can display the breakpoints for all processes in the group list:(dbx) status pgrp
Process 14558: [6] {pgrp 269011276} stop at "/usr/demo/pgrp_test.c":10
Process 14559: [7] {pgrp 269011340} stop at "/usr/demo/pgrp_test.c":10Use the showpgrp command to display the group history:(dbx) showpgrp
2 processes in group:
 14559 14558
Group history number: 10
        Process 14558 Process 14558: [6] stop at "/usr/demo/pgrp_test.c":10
        Process 14559 Process 14559: [7] stop at "/usr/demo/pgrp_test.c":10You can delete the breakpoints in both processes by deleting the associated group history entry. For example, enter:(dbx) delete 10 pgrp
(dbx) showpgrp
2 processes in group:
 14559 14558LBL="A"ID="74957"dbx CommandsAll dbx commands are listed below along with a brief description. For more information about a command, refer to its description in the main text of this guide.;ID="apA.cmd1" Use the semicolon (;) as a separator to include multiple commands on the same command line.\ID="apA.cmd2" Use the backslash (\) at the end of a line of input to dbx to indicate that the command is continued on the next line../ID="apA.cmd3" Repeats the previous examine command by incrementing the address.ID="apA.cmd4"/[reg_exp] Searches forward through the current source file from the current line for the regular expression ID="apA.cmd5"ID="apA.cmd6"reg_exp. If dbx reaches the end of the file without finding the regular expression, it wraps around to the beginning of the file. dbx prints the first source line containing a match of the search expression.If you do not supply reg_exp, dbx searches forward, based on the last regular expression you searched for..?ID="apA.cmd7" Repeats the previous examine command by decrementing the address.ID="apA.cmd8"?[reg_exp] Searches backward through the current source file from the current line for the regular expression ID="apA.cmd9"ID="apA.cmd10"reg_exp. If dbx reaches the beginning of the file without finding the regular expression, it wraps around to the end of the file. dbx prints the first source line containing a match of the search expression.If you do not supply a regular expression, dbx searches backward, based on the last regular expression you searched for.!!ID="apA.cmd11" Repeats the previous command. If the value of the ID="apA.cmd12"dbx variable ID="apA.cmd13"$repeatmode is set to 1, then entering a carriage return at an empty line is equivalent to executing !!. By default, $repeatmode is set to 0.ID="apA.cmd14"!string Repeats the most recent command that starts with the specified ID="apA.cmd15"string.ID="apA.cmd16"!integer Repeats the command associated with the specified ID="apA.cmd17"integer in the history list.ID="apA.cmd18"!-integer Repeats the command that occurred ID="apA.cmd19"integer times before the most recent command. Entering !-1 executes the previous command, !-2 the command before that, and so forth.activeID="apA.cmd20" [pid] Selects a process, ID="apA.cmd21"pid, from dbx process pool as the active process. If you do not provide a process ID, dbx prints the currently active process ID.ID="apA.cmd22"addpgrpID="apA.cmd23" pid [ ... ]Adds the process IDs specified to the group list. Only processes in the process pool can be added to the group list.ID="apA.cmd24"addprocID="apA.cmd25" pid [ ... ]Adds the specified process(es) to the pool of ID="apA.cmd26"dbx controlled processes.ID="apA.cmd27"address ID="apA.cmd28"/ count format Prints the contents of the specified address or disassembles the code for the machine instruction at the specified address. Repeats for a total of ID="apA.cmd29"ID="apA.cmd30"count addresses in increasing addressname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in other words, an examine forward command. The format codes are listed in IDREF="54646" TYPE="TABLE"Table 7-2.address ID="apA.cmd31"? count format Prints the contents of the specified address or disassembles the code for the machine instruction at the specified address. Repeats for a total of ID="apA.cmd32"ID="apA.cmd33"count addresses in decreasing addressname='mdash' font=symbol charset=fontspecific code=190 
			descr='[mdash]'in other words, an "examine backward" command. The format codes are listed in IDREF="54646" TYPE="TABLE"Table 7-2.address ID="apA.cmd34"/ count L value mask Examines ID="apA.cmd35"count 32-bit words in increasing address and print those 32-bit words which, when ORed with mask, equal value. This command searches memory for specific patterns.alias Lists all existing aliases.ID="apA.cmd36"aliasID="apA.cmd37" name Lists the alias definition for ID="apA.cmd38"name.alias name command Defines ID="apA.cmd39"name as an alias for command.alias name "string" Defines ID="apA.cmd40"name as an alias for string. With this form of the alias command, you can provide command arguments in the alias definition.alias name(arg1 [, ... argN]) "string" Defines ID="apA.cmd41"name as an alias for string. arg1 through argN are arguments to the alias, appearing in the string definition. When you use the alias, you must provide values for the arguments, which dbx then substitutes in string.assignID="apA.cmd42" register = expression Assigns the value of ID="apA.cmd43"expression to register. You must precede the name of the register with a dollar sign ($).assignID="apA.cmd44" variable = expression Assigns the value of ID="apA.cmd45"expression to the program variable, variable.catchID="apA.cmd46" Prints a list of all signals caught.ID="apA.cmd47"catchID="apA.cmd48" {signal | all} Instructs ID="apA.cmd49"dbx to stop your program whenever it receives the specified signal. If you use the keyword all rather than giving a specific signal, dbx catches all signals.ccallID="apA.cmd50" func(arg1, arg2, ... , argn) Calls a function with the given arguments.ID="apA.cmd51"clearcallsID="apA.cmd52" Clears all stopped interactive calls.ID="apA.cmd53"contID="apA.cmd54" Continues execution with the current line.cont {at | to} line Sets a temporary breakpoint at the specified source line, then resumes execution with the current line. When your program reaches the breakpoint at line, dbx stops your program and deletes the temporary breakpoint. The keywords at and to are equivalent.cont in procedure Sets a temporary breakpoint to stop execution upon entering the specified procedure, then resumes execution with the current line. When your program reaches the breakpoint in procedure, dbx stops your program and deletes the temporary breakpoint.cont [signal] Continues execution with the current line and sends the specified signal to your program. If you do not provide a signal, but your program stopped because dbx caught a signal intended for your program, then dbx sends that signal to your program when you continue execution.cont [signal] {at | to} line Sets a temporary breakpoint at the specified source line, then resumes execution with the current line and sends the specified signal to your program. If you do not provide a signal, but your program stopped because dbx caught a signal intended for your program, then dbx sends that signal to your program when you continue execution.cont [signal] in procedure Sets a temporary breakpoint to stop execution upon entering the specified procedure, then resumes execution with the current line and sends the specified signal to your program. If you do not provide a signal, but your program stopped because dbx caught a signal intended for your program, then dbx sends that signal to your program when you continue execution.contiID="apA.cmd55" [signal] Continues execution with the current machine instruction. If you specify a signal, dbx sends the signal to your program. If you do not provide a signal, but your program stopped because dbx caught a signal intended for your program, then dbx sends that signal to your program when you continue execution.conti [signal] {at | to} address Sets a temporary breakpoint at the specified address, then resumes execution with the current machine instruction. When your program reaches the breakpoint at address, dbx stops your program and deletes the temporary breakpoint.If you specify a signal, then dbx sends the signal to your program. If you do not provide a signal, but your program stopped because dbx caught a signal intended for your program, then dbx sends that signal to your program when you continue execution.conti [signal] in procedure Sets a temporary breakpoint to stop execution upon entering the specified procedure, then resumes execution with the current machine instruction. When your program reaches the breakpoint in procedure, dbx stops your program and deletes the temporary breakpoint.If you specify a signal, then dbx sends the signal to your program. If you do not provide a signal, but your program stopped because dbx caught a signal intended for your program, then dbx sends that signal to your program when you continue execution.corefileID="apA.cmd56" [file]If you provide a filename, ID="apA.cmd57"dbx uses the program data stored in the core dump file.If you do not provide a filename, dbx displays the name of the current core file.deleteID="apA.cmd58" {item [, item ...] | all} Deletes the item(s) specified. If you use the keyword all instead of listing individual items, dbx deletes all breakpoints, traces, and conditional commands.ID="apA.cmd59"ID="apA.cmd60"ID="apA.cmd61"delpgrpID="apA.cmd62" pid [ ... ]Deletes the process IDs specified from the group list.ID="apA.cmd63"delprocID="apA.cmd64" pid [ ... ]Deletes the specified process(es) from the pool of ID="apA.cmd65"dbx controlled processes.dirID="apA.cmd66" [dir ...] If you provide one or more directories, ID="apA.cmd67"dbx adds those directories to the end of the source directory list.If you do not provide any directories, dbx displays the current source directory list.disableID="apA.cmd68" item [, item ... ] Disables the item(s) listed. The specified breakpoint(s), trace(s), or conditional command(s) no longer affect program execution. This command has no effect if the item you specify is already disabled.ID="apA.cmd69"ID="apA.cmd70"ID="apA.cmd71"downID="apA.cmd72" [num] Moves down the specified number of activation levels in the stack. The default is one level.ID="apA.cmd73"dumpID="apA.cmd74" Prints information about the variables in the current procedure. dump procedure Prints information about the variables in the specified procedure. The procedure must be active.ID="apA.cmd75"dump . Prints information about the variables in all procedures currently active.ID="apA.cmd76"editID="apA.cmd77" [file | procedure] Edits a file. If you set the ID="apA.cmd78"dbx variable ID="apA.cmd79"$editor to the name of an editor, the edit command invokes that editor on the source file. If you do not set the dbx variable $editor, dbx checks whether you have set the environment variable ID="apA.cmd80"EDITOR and, if so, invokes that editor. If you do not set either the dbx variable or the environment variable, dbx invokes the vi editor. When you exit the editor, you return to the dbx prompt.If you supply a filename, edit invokes the editor on that file. If you supply the name of a procedure, edit invokes the editor on the file that contains the source for that procedure. If you do not supply a filename or a procedure name, edit invokes the editor on the current source file.editID="apA.cmd81"pid pid Edits the process ID ID="apA.cmd82"pid clause.enableID="apA.cmd83" item [, item ... ] Enables the item(s) specified. This command activates the specified breakpoint(s), trace(s), or conditional command(s), reversing the effects of a ID="apA.cmd84"ID="apA.cmd85"ID="apA.cmd86"disable command, so that they affect program execution.fileID="apA.cmd87" [file] Changes the current source file to ID="apA.cmd88"ID="apA.cmd89"file. The new file becomes the current source file, on which you can search, list, and perform other operations.funcID="apA.cmd90" Displays the name of the procedure corresponding to the current activation level.func {activation_level | procedure} Changes the current activation level. If you specify an activation level by number, ID="apA.cmd91"dbx changes to that activation level. If you specify procedure, dbx changes to the activation level of that procedure. If you specify a procedure name and that procedure has called itself recursively, dbx changes to the most recently called instance of that procedure. If you specify procedure, dbx changes the current source file to be that procedure, even if the procedure is not active.givenfileID="apA.cmd92" [file] If you provide a filename, ID="apA.cmd93"dbx kills the currently running processes and loads the executable code and debugging information found in file.If you do not provide a filename, dbx displays the name of the program that it is currently debugging.gotoID="apA.cmd94" line Begins execution at the specified line. You may not use the goto command to resume execution with a line outside of the current procedure.hedID="apA.cmd95" Edits only the last line of the history list (the last command executed).ID="apA.cmd96"hedID="apA.cmd97" num1 Edits line ID="apA.cmd98"num1 in the history list.hed num1,num2 Edits the lines in the history list from ID="apA.cmd99"num1 to num2.hed all Edits the entire history list.ID="apA.cmd100"helpID="apA.cmd101" Shows the list of available help sections.ID="apA.cmd102"help allDisplays the entire dbx help file. dbx displays the file using the command name given by the dbxID="apA.cmd103"$pager variable. The dbx help file is large and can be difficult to use if you use a simple paging program like more(1). A useful technique is to set the $pager variable to a text editor like vi(1).help helpExplains how to display the help file in your favorite editor.help sectionShows this help section. dbx displays the file using the command name given by the dbxID="apA.cmd104"$pager variable. (By default, it uses more.) A useful technique is to set the $pager variable to a text editor like vi(1).historyID="apA.cmd105" Prints the commands in the history list.ignoreID="apA.cmd106" Prints a list of all signals ignored.ID="apA.cmd107"ignore {signal | all} Instructs ID="apA.cmd108"dbx to ignore the specified signal. All ignored signals are passed to your program normally. If you use the keyword all rather than giving a specific signal, dbx ignores all signals.ID="apA.cmd109"kill Kills the active process. ID="apA.cmd110"kill pid ... Kills the active process(es) whose PIDs are specified.ID="apA.cmd111"ID="apA.cmd112"list Lists ID="apA.cmd113"$listwindow lines beginning at the current line.list exp Lists ID="apA.cmd114"$listwindow lines starting with the line number given by the expression exp. The expression may be any valid expression that evaluates to an integer value.list exp1:exp2 Lists exp2 lines, beginning at line exp1.list exp1,exp2 Lists all source between line exp1 and line exp2 inclusive.list func Lists ID="apA.cmd115"$listwindow lines starting at procedure func.list func:exp Lists exp2 lines, beginning at func.list func,exp Lists all source between func and exp, inclusive.listobjID="apA.cmd116"Lists dynamic shared objects being used. The base application is first in the list.nextID="apA.cmd117" [n] Executes the specified number of lines of source code, stepping over procedures. If you do not provide an argument, ID="apA.cmd118"next executes one line. If next encounters any breakpoints, even in procedures that it steps over, it immediately stops execution.nextiID="apA.cmd119" [n] Executes the specified number of machine instructions, stepping over procedures. If you do not provide an argument, nexti executes one line. If nexti encounters any breakpoints, even in procedures which it steps over, it immediately stops execution.playback inputID="apA.cmd120" [file] Executes the commands from ID="apA.cmd121"file. The default file is the current temporary file created for the record input command. If the dbx variable ID="apA.cmd122"$pimode is nonzero, the commands are printed out as they are played back.playback outputID="apA.cmd123" [file] Prints the commands from ID="apA.cmd124"file. The default file is the current temporary file created for the record output command.printID="apA.cmd125" [exp1 [, exp2, ... ] ] Prints the value(s) of the specified expression(s).ID="apA.cmd126"printd ID="apA.cmd127"[exp1 [, exp2, ... ] ]Prints the value(s) of the specified expression(s) in decimal.printfID="apA.cmd128" string [, exp1 [, exp2, ... ] ] Prints the value(s) of the specified expression(s) in the format specified by the string, ID="apA.cmd129"string. The printf command supports all formats except "%s". For a list of formats, see the printf(3S) reference page.printo ID="apA.cmd130"[exp1 [, exp2, ... ] ]Prints the value(s) of the specified expression(s) in octal.printregsID="apA.cmd131" Prints all register values.ID="apA.cmd132"printx ID="apA.cmd133"[exp1 [, exp2, ... ] ]Prints the value(s) of the specified expression(s) in hexadecimal. quitID="apA.cmd134" Quits ID="apA.cmd135"dbx.recordID="apA.cmd136" Displays the current input and output recording sessions.ID="apA.cmd137"record inputID="apA.cmd138" [file] Records everything you type to ID="apA.cmd139"dbx in file. The default file is a temporary dbx file in the /tmp directory. The name of the temporary file is stored in the dbx variable ID="apA.cmd140"$defaultin.record outputID="apA.cmd141" [file] Records all ID="apA.cmd142"dbx output in file. The default file is a temporary dbx file in the /tmp directory. The name of the temporary file is stored in the dbx variable ID="apA.cmd143"$defaultout. If the dbx variable ID="apA.cmd144"$rimode is nonzero, dbx also records the commands you enter.rerunID="apA.cmd145" run-argumentsWithout any arguments, repeats the last ID="apA.cmd146"run command, if applicable. Otherwise, rerun is equivalent to the run command without any arguments.resumeID="apA.cmd147" Resumes execution of the program, and returns immediately to the ID="apA.cmd148"dbx command interpreter.resume [signal]Resumes execution of the process, sending it the specified signal, and returns immediately to the ID="apA.cmd149"ID="apA.cmd150"dbx command interpreter.returnID="apA.cmd151"Continues execution until control returns to the next procedure on the stack.return proc Continues execution until control returns to the named procedure.runID="apA.cmd152" run-arguments Starts your program and passes to it any arguments that you provide. All shell processing is accepted, such as unglobbing of * and ? in filenames. Redirection of the program's standard input and standard output, and/or standard error is also done by the shell. In other words, the ID="apA.cmd153"ID="apA.cmd154"ID="apA.cmd155"ID="apA.cmd156"run command does exactly what typing target run-arguments does. You can specify a target, either on dbx invocation or in a prior givenfile command. dbx passes ./target as argv[0] to target when you specify it as a relative pathname. You can specify target either on dbx invocation or in a prior givenfile command. dbx passes ./target as argv[0] to target when you specify it as a relative pathname.A run command must appear on a line by itself and cannot be followed by another dbx command. Terminate the command line with a return (new-line). Note that you cannot include a run command in the command list of a when command.setID="apA.cmd157" Displays a list of predefined and user defined variables.ID="apA.cmd158"set var = exp Defines (or redefines) the specified ID="apA.cmd159"dbx variable, setting its value to that of the expression you provide.shID="apA.cmd160" Invokes a subshell. To return to ID="apA.cmd161"dbx from the subshell, enter exit at the command line, or otherwise terminate the subshell.sh com Executes the specified shell command. ID="apA.cmd162"dbx interprets the remainder of the line as a command to pass to the spawned shell process, unless you enclose the command in double-quotes or you terminate your shell command with a semicolon (;).showpgrpID="apA.cmd163" Shows the group process list and the group history.ID="apA.cmd164"showprocID="apA.cmd165" [pid | all] Shows processes already in the ID="apA.cmd166"dbx process pool or processes that dbx can control. If you provide no arguments, dbx lists the processes it already controls. If you provide a pid, dbx displays the status of the specified process. If you use argument "all," dbx lists all the processes it controls as well as all those processes it could control but that are not yet added to the process pool.ID="apA.cmd167"source [file] Executes dbx commands from file.statusID="apA.cmd168" Displays all breakpoints, traces, and conditional commands.ID="apA.cmd169"ID="apA.cmd170"ID="apA.cmd171"stepID="apA.cmd172" [n] Executes the specified number of lines of source code, stepping into procedures. If you do not provide an argument, ID="apA.cmd173"step executes one line. If step encounters any breakpoints, it immediately stops execution.stepiID="apA.cmd174"Single steps one machine instruction, stepping into procedures (as called by jal and jalr). If stepi encounters any breakpoints, it immediately stops execution.stepi [n]Executes the specified number of machine instructions, stepping into procedures (as called by jal and jalr). stop atID="apA.cmd175" Set a breakpoint at the current source line.ID="apA.cmd176"stop at line Sets a breakpoint at the specified source line.stop expression Inspects the expression. If the expression is type pointer, checks the data being pointed at. Otherwise, checks the 32 bits at the address given by the expression.stop in procedure Sets a breakpoint to stop execution upon entering the specified procedure.ID="apA.cmd177"stop [expression|variable] Inspects the value before executing each source line. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).ID="apA.cmd178"stop [expression|variable] at line Inspects the value at the given source line. Stops if the value has changed. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stop [expression|variable] in procedure Inspects the value at every source line within a given procedure. Stops if the value has changed. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stop if expression Evaluates the expression before executing each source line. Stops if the expression is true.stop at line if expression Evaluates the expression at the given source line. Stops if the expression is true.stop in procedure if expression Evaluates the expression at every source line within a given procedure. Stops if the expression is true.stop [expression1|variable] if expression2 Tests both conditions before executing each source line. Stops if both conditions are true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stop [expression1|variable] at line if expression2 Tests both conditions at the given source line. Stops if both conditions are true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stop [expression1|variable] in procedure if expression2 Tests both conditions at every source line within a given procedure. Stops if both conditions are true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stopi atID="apA.cmd179" Sets an unconditional breakpoint at the current machine instruction.ID="apA.cmd180"stopi at address Sets an unconditional breakpoint at the specified address (for machine-level debugging).ID="apA.cmd181"stopi in procedure Sets an unconditional breakpoint to stop execution upon entering the specified procedure (for machine-level debugging).stopi [expression|variable] Inspects the value before executing each machine instruction and stops if the value has changed. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stopi [expression|variable] at address Inspects the value when the program is at the given address and stops if the value has changed (for machine-level debugging). If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stopi [expression|variable] in procedure Inspects the value at every machine instruction within a given procedure and stops if the value has changed. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stopi if expression Evaluates the expression before executing each machine instruction and stops if the expression is true.stopi at address if expression Evaluates the expression at the given address and stops if the expression is true (for machine-level debugging).stopi in procedure if expression Evaluates the expression at every machine instruction within a given procedure and stops if the expression is true.stopi [expression1|variable] if expression2 Tests both conditions before executing each machine instruction. Stops if both conditions are true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stopi [expression1|variable] at address if expression2 Tests both conditions at the given address (for machine-level debugging). Stops if both conditions are true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).stopi [expression1|variable] in procedure if expression2 Tests the expression each time that the given variable changes within the given procedure. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).suspendID="apA.cmd182" Suspends the active process if it is running. If it is not running, this command does nothing. If you use the keyword all, suspends all active processes.suspend pgrp Suspends all the processes in ID="apA.cmd183"pgrp.suspend pid ID="apA.cmd184"pid Suspends the process pid if it is in the dbx process pool. If it is not running, this command does nothing.syscallID="apA.cmd185" Prints a summary of the catch and ignore status of all system calls. The summary is divided into four sections: 1) caught at call, 2) caught at return, 3) ignored at call, and 4) ignored at return.syscall catch [{call | return}] Prints a list of all system calls caught upon entry (ID="apA.cmd186"call) or return (return). If you provide neither the call nor return keyword, dbx lists all system calls that are caught.syscall ignore [{call | return}]Prints a list of all system calls not caught upon entry (ID="apA.cmd187"call) or return (return). If you provide neither the call nor return keyword, dbx lists all system calls that are ignored.syscall catch {call | return} {system_call | all}Sets a breakpoint to stop execution upon entering (ID="apA.cmd188"call) or returning from (return) the specified system call. Note that you can set dbx to catch both the call and the return of a system call.If you use the keyword all rather than giving a specific system call, dbx catches all system calls.syscall ignore {call | return} {system_call | all} Clears the breakpoint to stop execution upon entering (ID="apA.cmd189"call) or returning from (return) the specified system call.If you use the keyword all rather than giving a specific system call, dbx clears the breakpoints to stop execution upon entering (call) or returning from (return) all system calls.ID="apA.cmd190"tag procedureSearches the tag file for the given procedure.traceID="apA.cmd191" variable Whenever the specified variable changes, ID="apA.cmd192"dbx prints the old and new values of that variable.traceID="apA.cmd193" procedurePrints the values of the parameters passed to the specified procedure whenever your program calls it. Upon return, ID="apA.cmd194"dbx prints the return value.trace [expression|variable] at lineWhenever your program reaches the specified line, dbx prints the value of the variable if its value has changed. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).ID="apA.cmd195"trace [expression|variable] in procedure Whenever the variable changes within the procedure, ID="apA.cmd196"dbx prints the old and new values of that variable. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).trace [expression1|variable] at line if expression2 Prints the value of the variable (if changed) whenever your program reaches the specified line and the given expression is true. If ID="apA.cmd197"expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).trace [expression1|variable] in procedure if expression2 Whenever the variable changes within the procedure that you specify, ID="apA.cmd198"dbx prints the old and new values of that variable, if the given expression is true. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).traceiID="apA.cmd199" [expression|variable] Whenever the specified variable changes, ID="apA.cmd200"dbx prints the old and new values of that variable. (For machine-level debugging.) If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).tracei procedure This command is equivalent to entering ID="apA.cmd201"traceprocedure. (For machine-level debugging.)tracei [expression|variable] at address Prints the value of the variable whenever your program reaches the specified address. (For machine-level debugging.) If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).ID="apA.cmd202"tracei [expression|variable] in procedure Whenever the variable changes within the procedure that you specify, ID="apA.cmd203"dbx prints the old and new values of that variable. (For machine-level debugging.) If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).tracei [expression1|variable] at address if expression2 Prints the value of the variable whenever your program reaches the specified address and the given expression is true. (For machine-level debugging.) If ID="apA.cmd204"expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).tracei [expression1|variable] in procedure if expression2 Whenever the variable changes within the procedure that you specify, ID="apA.cmd205"dbx prints the old and new values of that variable, if the given expression is true. (For machine-level debugging.) If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).unaliasID="apA.cmd206" alias Removes the specified alias.ID="apA.cmd207"unrecordID="apA.cmd208" session1 [, session2 ... ] Turns off the specified recording session(s) and closes the file(s) involved.ID="apA.cmd209"unrecord allID="apA.cmd210" Turns off all recording sessions and closes all files involved.ID="apA.cmd211"unsetID="apA.cmd212" var Removes the specified ID="apA.cmd213"dbx variable.upID="apA.cmd214" [num] Moves up the specified number of activation levels in the stack. The default is one level.ID="apA.cmd215"useID="apA.cmd216" [dir ...]If you provide one or more directories, ID="apA.cmd217"dbx replaces the source directory list with the directories that you provide.If you do not provide any directories, dbx displays the current source directory list.waitID="apA.cmd218" Waits for the active process to stop for an event.ID="apA.cmd219"wait pid pid Waits for the process ID="apA.cmd220"pid to stop for an event.waitallID="apA.cmd221" Waits for any process currently running to breakpoint or stop for any reason.ID="apA.cmd222"whatisID="apA.cmd223" variable Prints the type declaration for the specified variable or procedure.ID="apA.cmd224"whenID="apA.cmd225" [expression|variable] {command-list} Inspects the value before executing each source line. If it has changed, executes the command list. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).ID="apA.cmd226"when [expression|variable] at line {command-list} Inspects the value at the given source line. If it has changed, executes the command list. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).when [expression|variable] in procedure {command-list} Inspects the value at every source line within a given procedure. If it has changed, executes the command list. If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).when if expression {command-list} Evaluates the expression before executing each source line. If it is true, executes the command list.when at line if expression {command-list} Evaluates the expression at the given source line. If it is true, executes the command list.ID="apA.cmd227"when in procedure if expression {command-list} Evaluates the expression at every source line within a given procedure. If it is true, executes the command list.when [expression1|variable] if expression2 {command-list} Checks if the value of the variable has changed. If it has changed and the expression is true, executes the command list. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).when [expression1|variable] at line if expression2 {command-list} Checks if the value of the variable has changed each time the line is executed. If the value has changed and the expression is true, executes the command list. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).when [expression1|variable] in procedure if expression2 {command-list} Checks if the value of variable has changed at each source line of the given procedure. If the value has changed and the expression is true, executes the command list. If expression1 is of type pointer, look at the data pointed to and watch until it changes. If expression1 is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).wheni ifID="apA.cmd228" expression {command-list}Evaluates the expression before executing each machine instruction. If the expression is true, executes the command list.wheni at address if expression {command-list}Evaluates the expression at the given address. If the expression is true, executes the command list. (For machine-level debugging.)wheni in procedure if expression {command-list}Evaluates the expression in the given procedure. If the expression is true, executes the command list. (For machine-level debugging.)wheni variable at address if expression {command-list}Tests both conditions at the given address. If the conditions are true, executes the command list. (For machine-level debugging.) If the expression is of type pointer, look at the data pointed to and watch until it changes. If the expression is not of type pointer, look at the 32 bits at that address (assume the expression evaluates to an address).wheni variable in procedure if expression {command-list}Tests both conditions at every machine instruction within a given procedure. If they are true, executes the command list.whereID="apA.cmd229" Print a stack trace.ID="apA.cmd230"whichID="apA.cmd231" variable Prints the fully qualified name of the active version of the specified variable.ID="apA.cmd232"whichobjID="apA.cmd233" variableLists the dynamic shared objects that contain the named variable.LBL="B"ID="56444"Predefined AliasesIDREF="69697" TYPE="TABLE"Table B-1 lists all predefined ID="apB.alias1"dbx aliases. You can override any predefined alias by redefining it with theID="apB.alias2"alias command or by removing it with the ID="apB.alias3"unalias command.COLUMNS="3"LBL="B-1"Table B-1 ID="69697"Predefined AliasesLEFT="0" WIDTH="54"AliasLEFT="60" WIDTH="99"DefinitionLEFT="165" WIDTH="189"DescriptionLEFT="0" WIDTH="54"aID="apB.alias4"LEFT="60" WIDTH="99"assignLEFT="165" WIDTH="189"Assigns the specified expression to the 
specified program variable or register.LEFT="0" WIDTH="54"bID="apB.alias5"LEFT="60" WIDTH="99"stop atLEFT="165" WIDTH="189"Sets a breakpoint at the specified line.LEFT="0" WIDTH="54"bpID="apB.alias6"LEFT="60" WIDTH="99"stop inLEFT="165" WIDTH="189"Sets a breakpoint in the specified procedure.LEFT="0" WIDTH="54"cID="apB.alias7"LEFT="60" WIDTH="99"contLEFT="165" WIDTH="189"Continues program execution after a 
breakpoint.LEFT="0" WIDTH="54"dID="apB.alias8"LEFT="60" WIDTH="99"deleteLEFT="165" WIDTH="189"Deletes the specified item from the status list.LEFT="0" WIDTH="54"dirID="apB.alias9"LEFT="60" WIDTH="99"directoryLEFT="165" WIDTH="189"Displays the current source directory list. If 
you specify one or more directories, those 
directories are added to the end of the source 
directory list.LEFT="0" WIDTH="54"eID="apB.alias10"LEFT="60" WIDTH="99"fileLEFT="165" WIDTH="189"Displays the name of the currently selected 
source file. If you specify a file, this command 
makes the specified file the currently selected 
source file.LEFT="0" WIDTH="54"fID="apB.alias11"LEFT="60" WIDTH="99"funcLEFT="165" WIDTH="189"Moves to the specified procedure (activation 
level) on the stack. If you specify no procedure 
or expression, dbx prints the current activation 
level.LEFT="0" WIDTH="54"gID="apB.alias12"LEFT="60" WIDTH="99"gotoLEFT="165" WIDTH="189"Goes to the specified source line.LEFT="0" WIDTH="54"hID="apB.alias13"LEFT="60" WIDTH="99"historyLEFT="165" WIDTH="189"Lists all the items currently in the history list.LEFT="0" WIDTH="54"jID="apB.alias14"LEFT="60" WIDTH="99"statusLEFT="165" WIDTH="189"Lists all the currently set stop,trace, and when 
commands.LEFT="0" WIDTH="54"lID="apB.alias15"LEFT="60" WIDTH="99"listLEFT="165" WIDTH="189"Lists the next $listwindow lines of source code 
beginning at the current line.LEFT="0" WIDTH="54"liID="apB.alias16"LEFT="60" WIDTH="99"$curpc/10i; \set $curpc=$curpc+40LEFT="165" WIDTH="189"Lists the next 40 bytes of machine instructions 
(approximately 10 instructions).LEFT="0" WIDTH="54"nID="apB.alias17"LEFT="60" WIDTH="99"nextLEFT="165" WIDTH="189"Executes the specified number of lines of 
source code, stepping over procedures. If you 
do not provide an argument, dbx executes only 
one line.LEFT="0" WIDTH="54"niID="apB.alias18"LEFT="60" WIDTH="99"nextiLEFT="165" WIDTH="189"Executes the specified number of lines of 
machine code, stepping over procedures. If 
you do not provide an argument, dbx executes 
only one instruction.LEFT="0" WIDTH="54"pID="apB.alias19"LEFT="60" WIDTH="99"printLEFT="165" WIDTH="189"Prints the value of the specified variable or 
expression.LEFT="0" WIDTH="54"pdID="apB.alias20"LEFT="60" WIDTH="99"printdLEFT="165" WIDTH="189"Prints the value of the specified variable in 
decimal.LEFT="0" WIDTH="54"piID="apB.alias21"LEFT="60" WIDTH="99"playback inputLEFT="165" WIDTH="189"Replays dbx commands saved in the specified 
file. If you do not specify a file, dbx uses the 
temporary file specified by $defaultin.LEFT="0" WIDTH="54"poID="apB.alias22"LEFT="60" WIDTH="99"printoLEFT="165" WIDTH="189"Prints the value of the specified variable or 
expression in octal.LEFT="0" WIDTH="54"prID="apB.alias23"LEFT="60" WIDTH="99"printregsLEFT="165" WIDTH="189"Prints values contained in all registers.LEFT="0" WIDTH="54"pxID="apB.alias24"LEFT="60" WIDTH="99"printxLEFT="165" WIDTH="189"Prints the value of the specified variable or 
expression in hexadecimal.LEFT="0" WIDTH="54"qID="apB.alias25"LEFT="60" WIDTH="99"quitLEFT="165" WIDTH="189"Quits dbx.LEFT="0" WIDTH="54"rID="apB.alias26"LEFT="60" WIDTH="99"rerunLEFT="165" WIDTH="189"Runs the program again using the arguments 
specified for the last run command executed.LEFT="0" WIDTH="54"riID="apB.alias27"LEFT="60" WIDTH="99"record inputLEFT="165" WIDTH="189"Records to the specified file all the input you 
give to dbx. If you do not specify a file, dbx 
creates a temporary file. The name of the file is 
specified by $defaultin.LEFT="0" WIDTH="54"roID="apB.alias28"LEFT="60" WIDTH="99"record outputLEFT="165" WIDTH="189"Records all dbx output to the specified file. If 
no file is specified, records output to a 
temporary file. The name of the file is specified 
by $defaultout.LEFT="0" WIDTH="54"sID="apB.alias29"LEFT="60" WIDTH="99"stepLEFT="165" WIDTH="189"Executes the specified number of lines of 
source code, stepping into procedures. If you 
do not provide an argument, dbx executes only 
one line.LEFT="0" WIDTH="54"SID="apB.alias30"LEFT="60" WIDTH="99"nextLEFT="165" WIDTH="189"Executes the specified number of lines of 
source code, stepping over procedures. If you 
do not provide an argument, dbx executes only 
one line.LEFT="0" WIDTH="54"siID="apB.alias31"LEFT="60" WIDTH="99"stepiLEFT="165" WIDTH="189"Executes the specified number of lines of 
machine code, stepping into procedures. If 
you do not provide an argument, dbx executes 
only one instruction.LEFT="0" WIDTH="54"SiID="apB.alias32"LEFT="60" WIDTH="99"nextiLEFT="165" WIDTH="189"Executes the specified number of lines of 
machine code, stepping over procedures. If 
you do not provide an argument, dbx executes 
only one instruction.LEFT="0" WIDTH="54"sourceID="apB.alias33"LEFT="60" WIDTH="99"playback input (pi)LEFT="165" WIDTH="189"Replays dbx commands saved in the specified 
file. If no file is specified, dbx uses the 
temporary file specified by $defaultin.LEFT="0" WIDTH="54"tID="apB.alias34"LEFT="60" WIDTH="99"whereLEFT="165" WIDTH="189"Does a stack trace to show the current 
activation levels.LEFT="0" WIDTH="54"uID="apB.alias35"LEFT="60" WIDTH="99"list $curline-9:10LEFT="165" WIDTH="189"Lists a window of source code showing the 
nine lines before the current code line and the 
current code line. This command does not 
change the current code line.LEFT="0" WIDTH="54"wID="apB.alias36"LEFT="60" WIDTH="99"list $curline-5:10LEFT="165" WIDTH="189"Lists a window of source code around the 
current line. This command shows the four 
lines before the current code line, the current 
code line, and five lines after the current code 
line. This command does not change the 
current code line.LEFT="0" WIDTH="54"WID="apB.alias37"LEFT="60" WIDTH="99"list $curline-10:20LEFT="165" WIDTH="189"Lists a window of source code around the 
current line. This command shows the nine 
lines before the current code line, the current 
code line, and 10 lines after the current code 
line. This command does not change the 
current code line.LEFT="0" WIDTH="54"wiID="apB.alias38"LEFT="60" WIDTH="99"$curpc-20/10iLEFT="165" WIDTH="189"Lists a window of assembly code around the 
program counter.LBL="C"ID="80540"Predefined dbx VariablesID="apC.vars1"ID="apC.vars2"ID="apC.vars3"ID="apC.vars4"ID="apC.vars5"ID="apC.vars6"ID="apC.vars7"ID="apC.vars8"ID="apC.vars9"ID="apC.vars10"ID="apC.vars11"Predefined dbx variables are listed in ID="apC.vars12"IDREF="59961" TYPE="TABLE"Table C-1. The predefined variable names begin with "$" so that they do not conflict with variable, command, or alias names.COLUMNS="3"LBL="C-1"Table C-1 ID="59961"Predefined dbx VariablesLEFT="0" WIDTH="108"VariableLEFT="115" WIDTH="39"DefaultLEFT="160" WIDTH="187"DescriptionLEFT="0" WIDTH="108"ID="apC.vars13"$addrfmtLEFT="115" WIDTH="39""0x%x"LEFT="160" WIDTH="187"Specifies the format for addresses. This can be 
set to any format valid for the C language 
printf(3S) function.LEFT="0" WIDTH="108"ID="apC.vars14"$addrfmt64LEFT="115" WIDTH="39""0x%x"LEFT="160" WIDTH="187"Specifies the format for 64-bit addresses. This 
can be set to any format valid for the C 
language printf(3S) function.LEFT="0" WIDTH="108"$assignverifyID="apC.vars15"LEFT="115" WIDTH="39"LEFT="160" WIDTH="187"Prints the new value of a variable after an 
assign.LEFT="0" WIDTH="108"ID="apC.vars16"$casesenseLEFT="115" WIDTH="39"2LEFT="160" WIDTH="187"If 0, symbol names are case sensitive. If 1, 
symbol names are not case sensitive. If 2, the 
case sensitivity of symbol names depends on 
the case sensitivity of the language in which 
the symbol was defined.ID="apC.vars17"LEFT="0" WIDTH="108"ID="apC.vars18"$ctypenamesLEFT="115" WIDTH="39"1LEFT="160" WIDTH="187"If 1, the words "unsigned," "short," "long," 
"int," "char," "struct," "union," and "enum" 
are keywords usable only in type casts. If 0, 
"struct," "union," and "enum" are ordinary 
words with no predefined meaning (in C 
modules, the others are still known as C 
types).ID="apC.vars19"LEFT="0" WIDTH="108"ID="apC.vars20"$cureventLEFT="115" WIDTH="39"LEFT="160" WIDTH="187"The last event number as seen by the status 
command.LEFT="0" WIDTH="108"ID="apC.vars21"$curlineLEFT="115" WIDTH="39"LEFT="160" WIDTH="187"The current line in the source code being 
executed.LEFT="0" WIDTH="108"ID="apC.vars22"$curpcLEFT="115" WIDTH="39"LEFT="160" WIDTH="187"The current program counter.LEFT="0" WIDTH="108"ID="apC.vars23"$cursrclineLEFT="115" WIDTH="39"LEFT="160" WIDTH="187"The current source listing line plus one.LEFT="0" WIDTH="108"$debugrldID="apC.vars24"LEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"If the value is 1, dbx allows you to set traps in 
rld code, so you can debug bugs in run-time 
initialization of C++ global variables and the 
like.LEFT="0" WIDTH="108"ID="apC.vars25"$defaultinLEFT="115" WIDTH="39"LEFT="160" WIDTH="187"The name of the file that dbx uses when the 
ID="apC.vars26"record input or the playback input command is 
executed with no argument.LEFT="0" WIDTH="108"ID="apC.vars27"$defaultoutLEFT="115" WIDTH="39"LEFT="160" WIDTH="187"The name of the file that dbx uses when the 
record output or the playback output command 
is executed with no argument.LEFT="0" WIDTH="108"ID="apC.vars28"$editorLEFT="115" WIDTH="39"viLEFT="160" WIDTH="187"The name of the editor to invoke (with the ID="apC.vars29"edit 
command). Default value is set to the value of 
the EDITOR environment variable. If EDITOR 
missing, it defaults to vi.LEFT="0" WIDTH="108"$fp_preciseID="apC.vars30"LEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"(Systems with floating-point precise mode 
only.) A nonzero value specifies that the run 
command instructs the operating system to 
run the program in floating-point precise 
mode (a nondebug mode). The debugged 
process performs SGI_SET_FP_PRECISE and 
SGI_SET_FP_PRESERVE syssgi system calls.LEFT="0" WIDTH="108"$frameregID="apC.vars31"LEFT="115" WIDTH="39"1LEFT="160" WIDTH="187"If 1, all references to registers are to the 
registers of the current activation level. If 0, all 
references are to the hardware registers (the 
registers of activation level 0).LEFT="0" WIDTH="108"ID="apC.vars32"$groupforktooLEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"If 0, adds only processes created with the 
sproc(2) system call to the process group list 
automatically. If 1, then adds processes 
created with either the fork(2) or sproc system 
calls to process group list.LEFT="0" WIDTH="108"ID="apC.vars33"$hexcharsLEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"If nonzero, outputs characters in hexadecimal, 
using C format "%x". This affects char type 
variables, including those in structures. It 
does not affect arrays of characters, which are 
printed using the "%.*s" format.LEFT="0" WIDTH="108"$hexdoublesID="apC.vars34"LEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"If nonzero, float and double values print as 
normal, with a trailing output of hex 
ffffffff and hexffffffff 00000000, 
respectively. These are hex representations of 
the bits of the float and double.LEFT="0" WIDTH="108"ID="apC.vars35"$hexinLEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"If nonzero, input constants are assumed to be 
in hexadecimal. This overrides $octin.LEFT="0" WIDTH="108"ID="apC.vars36"$hexintsLEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"If nonzero, outputs integers in hexadecimal 
format. This overrides $octints.LEFT="0" WIDTH="108"ID="apC.vars37"$hexstringsLEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"If nonzero, outputs strings and arrays in 
hexadecimal. For character arrays, if nonzero, 
the null byte is not taken as a terminator. 
Instead, prints the entire array (or $maxlen 
values, whichever is less). If 0, then a null byte 
in a C or C++ character array is taken as the 
end of the array (the length of the array and 
$maxstrlen can terminate the array printing 
before a null byte is found). LEFT="0" WIDTH="108"$historyeventID="apC.vars38"LEFT="115" WIDTH="39"LEFT="160" WIDTH="187"The current history line number.LEFT="0" WIDTH="108"ID="apC.vars39"$lastchildLEFT="115" WIDTH="39"LEFT="160" WIDTH="187"The process ID of the last child process created 
by a fork or sproc system call.LEFT="0" WIDTH="108"ID="apC.vars40"$linesLEFT="115" WIDTH="39"100LEFT="160" WIDTH="187"The number of lines in the history list.LEFT="0" WIDTH="108"ID="apC.vars41"$listwindowLEFT="115" WIDTH="39"10LEFT="160" WIDTH="187"Specifies how many lines the list command 
lists.LEFT="0" WIDTH="108"ID="apC.vars42"$maxstrlenLEFT="115" WIDTH="39"128LEFT="160" WIDTH="187"Maximum length printed for zero-terminated 
char strings and arrays. Prints char arrays for 
array-length, $maxstrlen bytes, or up to a null 
byte, whichever comes first (see $hexstrings).LEFT="0" WIDTH="108"ID="apC.vars43"$mp_programLEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"If 0, dbx treats calls to sproc in the same way as 
it treats calls to fork. If 1, child processes 
created by calls to sproc are allowed to run; 
they block on multiprocessor synchronization 
code emitted by mp Fortran code. When you 
set $mp_program to 1, mp Fortran code is 
easier to debug.LEFT="0" WIDTH="108"ID="apC.vars44"$neweventLEFT="115" WIDTH="39"LEFT="160" WIDTH="187"After every command creating an event, this 
variable is set to the event's number. The 
$newevent variable is useful in writing scripts 
that do not use hard-coded event numbers.LEFT="0" WIDTH="108"$newpgrpeventID="apC.vars45"LEFT="115" WIDTH="39"LEFT="160" WIDTH="187"Displays the value of the latest pgrp event 
created by stop[i], trace[i], and when[i]... pgrp. 
Useful when writing scripts that then do deletepgrp#pgrp with a symbolic (dbx variable) 
pgrp#.LEFT="0" WIDTH="108"ID="apC.vars46"$octinLEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"If nonzero, assumes input constants are in 
octal (ID="apC.vars47"ID="apC.vars48"$hexin overrides $octin). LEFT="0" WIDTH="108"ID="apC.vars49"$octintsLEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"If nonzero, outputs integers in octal format 
(ID="apC.vars50"ID="apC.vars51"$hexints takes precedence).LEFT="0" WIDTH="108"ID="apC.vars52"$pageLEFT="115" WIDTH="39"1LEFT="160" WIDTH="187"Specifies whether or not to page when dbx 
output scrolls information off the current 
screen. A nonzero value turns on paging; a 0 
turns it off.LEFT="0" WIDTH="108"ID="apC.vars53"$pagerLEFT="115" WIDTH="39"moreLEFT="160" WIDTH="187"The name of the program used to display output from ID="apC.vars54"dbx.LEFT="0" WIDTH="108"ID="apC.vars55"$pagewidthLEFT="115" WIDTH="39"80LEFT="160" WIDTH="187"The width of the window in characters 
(assumes a fixed-width font). Used by dbx to 
calculate how many screen lines are output. 
dbx never inserts newlines; the window 
software wraps the lines.LEFT="0" WIDTH="108"ID="apC.vars56"$pagewindowLEFT="115" WIDTH="39"23LEFT="160" WIDTH="187"Specifies how many lines print when 
information is longer than one screen. This 
can be changed to match the number of lines 
on any terminal. If set to 0, 1 is used.LEFT="0" WIDTH="108"$pendingtrapsID="apC.vars57"LEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"Uses no pending traps. If nonzero, allows 
traps that cannot be satisfied immediately to 
pend until they can be satisfied. This is useful 
for debugging programs that use dlopen() to 
load symbols as it allows setting breakpoints 
before the dlopen() call. Similar to $debugrld, 
but $pendingtraps does not allow setting 
breakpoints in rld. When set to nonzero, 
mistyped procedure names cause a pending 
trap to be set. LEFT="0" WIDTH="108"$piaddtohistID="apC.vars58"LEFT="115" WIDTH="39"1LEFT="160" WIDTH="187"If 1, adds commands read from files using the 
ID="apC.vars59"playback input command to the command 
history. If 0, does not add the commands to the 
history.LEFT="0" WIDTH="108"ID="apC.vars60"$pidLEFT="115" WIDTH="39"LEFT="160" WIDTH="187"The current process for kernel debugging (-k).LEFT="0" WIDTH="108"ID="apC.vars61"$pid0LEFT="115" WIDTH="39"LEFT="160" WIDTH="187"Set by dbx to the process ID of the running 
process (also called the object file).LEFT="0" WIDTH="108"ID="apC.vars62"$pimodeLEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"If 1, dbx prints the commands read from files 
using theID="apC.vars63"playback input command. If 0, dbx 
does not print the commands. In either case, 
dbx prints the output resulting from such 
commands.LEFT="0" WIDTH="108"ID="apC.vars64"$printdataLEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"Used when disassembling. If 1, prints register 
contents alongside disassembled instructions. 
If 0, just prints disassembled instructions.LEFT="0" WIDTH="108"$printwhilestepID="apC.vars65"LEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"If 0, prints only the next line to be executed. If 
nonzero, prints each line that is executed 
while it single steps.LEFT="0" WIDTH="108"ID="apC.vars66"$printwideLEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"If 0, prints arrays one element per line. If 
nonzero, prints arrays compactly (wide).LEFT="0" WIDTH="108"$procaddrID="apC.vars67"LEFT="115" WIDTH="39"LEFT="160" WIDTH="187"This variable applies only if you invoke dbx 
with the -k option (that is, it is not available 
unless you are doing kernel debugging). 
Whenever ID="apC.vars68"$pid is set, dbx sets $procaddr to the 
address of the process table entry for that 
process.LEFT="0" WIDTH="108"ID="apC.vars69"$promptLEFT="115" WIDTH="39"dbxLEFT="160" WIDTH="187"The prompt for ID="apC.vars70"dbx.LEFT="0" WIDTH="108"ID="apC.vars71"$promptonforkLEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"If 0, dbx does not add the child process to the 
process pool. Both the child process and the 
parent process continue to run.If 1, dbx stops the parent process and asks if 
you want to add the child process to the 
process pool. If you answer yes, then dbx adds 
the child process to the pool and stops the 
child process; if you answer no, dbx allows the 
child process to run and does not place it in 
the process pool.If 2, dbx automatically stops both the parent 
and child processes and adds the child 
process to the process pool.LEFT="0" WIDTH="108"ID="apC.vars72"$regstyleLEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"If 0, dbx uses the alternate form of the register 
name (for example, "zero" instead of "r0" and 
"t1" instead of "r9"). If nonzero, ID="apC.vars73"dbx uses the 
machine name ("r0" through "r31").LEFT="0" WIDTH="108"ID="apC.vars74"$repeatmodeLEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"If nonzero, entering a null line (entering a 
newline on an empty line) repeats the last 
command. If 0, ID="apC.vars75"dbx performs no action.LEFT="0" WIDTH="108"ID="apC.vars76"$rimodeLEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"If 1, dbx records commands you enter in 
addition to output when using the recordoutput command. If 0, dbx does not copy the 
commands.LEFT="0" WIDTH="108"ID="apC.vars77"$showbreakaddrsLEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"If nonzero, show the address of each 
breakpoint placed in the code each time it is 
placed. Removal of the breakpoints is not 
shown. If multiple breakpoints are placed at 
one location, only one of the placements is 
shown. Since breakpoints are frequently 
placed and removed by dbx, the volume of 
output can be annoying when tracing.LEFT="0" WIDTH="108"$stacktracelimitID="apC.vars78"LEFT="115" WIDTH="39"LEFT="160" WIDTH="187"Limits to the depth of the stack trace.LEFT="0" WIDTH="108"$stepintoallLEFT="115" WIDTH="39"0LEFT="160" WIDTH="187"If 0, ID="apC.vars79"step steps into only those procedures that 
are compiled with the debugging option -g. 
step steps over all other procedures.If 1 or 2, step steps into all procedures. Note 
that when you debug a source file compiled 
without symbols or compiled with 
optimization, the line numbers may 
sometimes jump erratically.Also note that if dbx cannot locate a source file, 
then it cannot display source lines as you step 
through a procedure.LEFT="0" WIDTH="108"ID="apC.vars80"$tagfileLEFT="115" WIDTH="39"tagsLEFT="160" WIDTH="187"The name of a file of tags, as created by 
ctags(1). Used by the tag command.# charactersIDREF="02.run18"dbx OptionsIDREF="05.change6"OperatorsIDREF="04.cntrl77"Executing dbx Scripts#define declarationsIDREF="05.change14"Constants// (division) operatorIDREF="05.change10"OperatorsIDREF="05.change9"OperatorsIDREF="05.change11"Operators16-bit wordIDREF="07.mach24"Examining Memory and Disassembling Code32-bit wordIDREF="07.mach25"Examining Memory and Disassembling Code64-bit wordIDREF="07.mach26"Examining Memory and Disassembling Code; (command separator)IDREF="apA.cmd1"dbx CommandsIDREF="02.run48"Entering Multiple Commands on a Single Line\\ (command continuation)IDREF="apA.cmd2"dbx CommandsIDREF="02.run49"Spanning a Command Across Multiple Linesactivation levelsIDREF="05.change73"Examining the StackchangingIDREF="apA.cmd91"dbx CommandsIDREF="05.change87"Moving to a Specified ProcedurecurrentIDREF="07.mach15"Changing Register Valuesmoving downIDREF="05.change83"Moving Within the StackIDREF="apA.cmd73"dbx Commandsmoving upIDREF="apA.cmd215"dbx CommandsIDREF="05.change82"Moving Within the Stackprinting informationIDREF="05.change92"Printing Activation Level InformationIDREF="apA.cmd75"dbx CommandsIDREF="apA.cmd76"dbx Commandsregisters andIDREF="07.mach15"Changing Register Valuesactive processwait forIDREF="apA.cmd219"dbx CommandsIDREF="08.multiple37"Waiting for a Resumed Processadd processes to process poolIDREF="08.multiple14"Adding a Process to the Process PoolIDREF="apA.cmd26"dbx Commandsadding processes to the process group listIDREF="08.multiple59"Handling sproc System Calls and Process Group DebuggingIDREF="apA.cmd24"dbx CommandsIDREF="08.multiple57"Handling sproc System Calls and Process Group Debuggingaddress of line numbersIDREF="05.change5"OperatorsIDREF="05.change8"OperatorsIDREF="04.cntrl79"Executing dbx ScriptsaliasesIDREF="04.cntrl33"Creating and Removing dbx AliasescreatingIDREF="04.cntrl46"Creating Command AliasesIDREF="apA.cmd40"dbx CommandsIDREF="04.cntrl42"Creating Command AliasesIDREF="apA.cmd41"dbx CommandsIDREF="04.cntrl39"Creating Command AliasesIDREF="04.cntrl44"Creating Command AliasesIDREF="apA.cmd39"dbx CommandsdeletingIDREF="apA.cmd207"dbx CommandsIDREF="04.cntrl47"Removing Command AliasesdisplayingIDREF="04.cntrl35"Listing AliasesIDREF="apA.cmd38"dbx CommandsIDREF="apA.cmd36"dbx Commandspredefined. See predefined dbx aliasesIDREF="apB.alias1"Predefined AliasesIDREF="04.cntrl34"Creating and Removing dbx AliasesarraysexaminingIDREF="05.change58"Displaying the Value of a VariablebreakpointsIDREF="01.start10"Debugging Your ProgramsIDREF="06.exec1"Setting Breakpointsand interactive function callsIDREF="05.change104"Nesting Interactive Function CallsconditionalIDREF="06.exec3"Setting BreakpointsIDREF="01.start12"Debugging Your Programscontinuing afterIDREF="07.mach43"Continuing Execution After a Machine-Level BreakpointIDREF="06.exec26"Continuing Execution After a BreakpointIDREF="01.start19"Debugging Your ProgramsdisablingIDREF="apA.cmd69"dbx CommandsIDREF="06.exec51"Disabling Breakpoints, Traces, and Conditional CommandsenablingIDREF="apA.cmd84"dbx CommandsIDREF="06.exec55"Enabling Breakpoints, Traces, and Conditional Commandsmachine-levelIDREF="07.mach36"Syntax of the stopi CommandIDREF="apA.cmd180"dbx CommandsIDREF="07.mach30"Setting Machine-Level BreakpointsIDREF="apA.cmd181"dbx CommandsIDREF="07.mach38"Syntax of the stopi Commandprocess groupsIDREF="08.multiple66"Handling sproc System Calls and Process Group DebuggingsettingIDREF="06.exec11"Setting Conditional BreakpointsIDREF="apA.cmd177"dbx CommandsIDREF="01.start14"Debugging Your ProgramsIDREF="apA.cmd176"dbx CommandsIDREF="06.exec7"Setting Unconditional BreakpointsstatusIDREF="06.exec47"Listing Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd169"dbx Commandstest clauseIDREF="06.exec19"Stopping If a Test Expression Is TrueIDREF="06.exec23"Conditional Breakpoints Combining Variable and Test ClausesIDREF="06.exec21"Stopping If a Test Expression Is TrueunconditionalIDREF="01.start11"Debugging Your ProgramsIDREF="06.exec2"Setting Breakpointsvariable clauseIDREF="06.exec16"Stopping If a Variable or Memory Location Has ChangedIDREF="06.exec24"Conditional Breakpoints Combining Variable and Test ClausesIDREF="06.exec18"Stopping If a Variable or Memory Location Has ChangedIDREF="06.exec14"Stopping If a Variable or Memory Location Has ChangedIDREF="07.mach39"Syntax of the stopi CommandIDREF="apA.cmd178"dbx CommandsIDREF="06.exec22"Conditional Breakpoints Combining Variable and Test ClausesIDREF="07.mach40"Syntax of the stopi CommandIDREF="06.exec12"Stopping If a Variable or Memory Location Has ChangedC keyword conflictsIDREF="apC.vars19"Predefined dbx Variables    IDREF="05.change64"Conflicts Between Variable Names and KeywordsC preprocessorIDREF="05.change15"ConstantsC++considerationsIDREF="05.change105"C++ Considerationsglobal functionsIDREF="05.change109"Referring to C++ Functionsmember functionsIDREF="05.change108"Referring to C++ Functionsmember variablesIDREF="05.change106"Accessing C++ Member Variablesnon-C++ functionsIDREF="05.change110"Referring to C++ Functionsoverloaded functionsIDREF="05.change111"Referring to C++ Functionsstatic member variablesIDREF="05.change107"Accessing C++ Member Variablescase sensitivity of program variable namesIDREF="apC.vars17"Predefined dbx Variables    IDREF="05.change66"Case Sensitivity in Variable NamescastsIDREF="04.cntrl49"Alias Examplecatching signalsIDREF="06.exec64"Catching and Ignoring SignalsIDREF="apA.cmd49"dbx Commandscatching system callsIDREF="apA.cmd188"dbx CommandsIDREF="06.exec75"Stopping at System Callschanging program variable valuesIDREF="apA.cmd45"dbx CommandsIDREF="05.change60"Changing the Value of a Variablecode missingIDREF="01.start39"Avoiding Common Pitfalls/ commandIDREF="apA.cmd28"dbx CommandsIDREF="07.mach17"Examining Memory and Disassembling CodeIDREF="03.examin26"Searching Through Source CodeIDREF="apA.cmd34"dbx CommandsIDREF="apA.cmd3"dbx CommandsIDREF="03.examin24"Searching Through Source CodeIDREF="apA.cmd4"dbx CommandsIDREF="05.change59"Displaying the Value of a Variable commands!!IDREF="apA.cmd11"dbx CommandsIDREF="04.cntrl19"Repeating Commands!-integerIDREF="04.cntrl23"Repeating CommandsIDREF="apA.cmd18"dbx Commands!integerIDREF="04.cntrl22"Repeating CommandsIDREF="apA.cmd16"dbx Commands!stringIDREF="04.cntrl21"Repeating CommandsIDREF="apA.cmd14"dbx Commands/IDREF="05.change59"Displaying the Value of a VariableIDREF="03.examin24"Searching Through Source CodeIDREF="apA.cmd28"dbx CommandsIDREF="03.examin26"Searching Through Source CodeIDREF="apA.cmd34"dbx CommandsIDREF="07.mach17"Examining Memory and Disassembling CodeIDREF="apA.cmd3"dbx CommandsIDREF="apA.cmd4"dbx Commands?IDREF="07.mach20"Examining Memory and Disassembling CodeIDREF="apA.cmd8"dbx CommandsIDREF="03.examin27"Searching Through Source CodeIDREF="03.examin25"Searching Through Source CodeIDREF="apA.cmd7"dbx CommandsIDREF="apA.cmd31"dbx CommandsnextIDREF="01.start22"Studying a New ProgramprintIDREF="01.start21"Studying a New ProgramIDREF="01.start24"Studying a New ProgramrerunIDREF="01.start16"Debugging Your ProgramsrunIDREF="01.start15"Debugging Your ProgramsstepIDREF="01.start23"Studying a New ProgramstopIDREF="01.start13"Debugging Your ProgramstraceIDREF="01.start27"Studying a New ProgramwhereIDREF="01.start6"Examining Core Dumps to Determine Cause of Failurecommand continuationIDREF="apA.cmd2"dbx CommandsIDREF="02.run49"Spanning a Command Across Multiple Linescommand scriptscommentsIDREF="04.cntrl78"Executing dbx ScriptsIDREF="05.change7"Operatorscommand separator (;)IDREF="apA.cmd1"dbx CommandsIDREF="02.run48"Entering Multiple Commands on a Single Line!! commandIDREF="04.cntrl19"Repeating CommandsIDREF="apA.cmd11"dbx Commands!-integer commandIDREF="04.cntrl23"Repeating CommandsIDREF="apA.cmd18"dbx Commands!integer commandIDREF="apA.cmd16"dbx CommandsIDREF="04.cntrl22"Repeating Commands!string commandIDREF="04.cntrl21"Repeating CommandsIDREF="apA.cmd14"dbx Commands? commandIDREF="apA.cmd31"dbx CommandsIDREF="apA.cmd7"dbx CommandsIDREF="apA.cmd8"dbx CommandsIDREF="07.mach20"Examining Memory and Disassembling CodeIDREF="03.examin25"Searching Through Source CodeIDREF="03.examin27"Searching Through Source Codeactive commandIDREF="apA.cmd20"dbx CommandsIDREF="08.multiple18"Selecting a Processaddpgrp commandIDREF="apA.cmd23"dbx CommandsIDREF="08.multiple60"Handling sproc System Calls and Process Group Debuggingaddproc commandIDREF="08.multiple15"Adding a Process to the Process PoolIDREF="apA.cmd25"dbx Commandsalias commandIDREF="apA.cmd37"dbx CommandsIDREF="04.cntrl37"Listing AliasesIDREF="04.cntrl36"Listing AliasesIDREF="04.cntrl43"Creating Command AliasesIDREF="04.cntrl40"Creating Command AliasesIDREF="04.cntrl38"Listing AliasesIDREF="apA.cmd27"dbx CommandsIDREF="04.cntrl45"Creating Command AliasesIDREF="apB.alias2"Predefined AliasesIDREF="04.cntrl41"Creating Command Aliasesassign commandIDREF="07.mach13"Changing Register ValuesIDREF="apA.cmd44"dbx CommandsIDREF="05.change61"Changing the Value of a VariableIDREF="07.mach12"Changing Register ValuesIDREF="apA.cmd42"dbx CommandsIDREF="05.change62"Changing the Value of a Variablecatch commandIDREF="apA.cmd48"dbx CommandsIDREF="apA.cmd46"dbx Commandsccall commandIDREF="05.change97"Using ccallIDREF="apA.cmd50"dbx Commandsclearcalls commandIDREF="05.change102"Using clearcallsIDREF="apA.cmd52"dbx Commandscont commandIDREF="06.exec97"Starting at a Specified LineIDREF="apA.cmd54"dbx CommandsIDREF="07.mach44"Continuing Execution After a Machine-Level BreakpointIDREF="08.multiple29"Resuming a Suspended ProcessIDREF="06.exec70"Continuing After Catching a SignalIDREF="06.exec25"Continuing Execution After a Breakpointconti commandIDREF="07.mach47"Continuing Execution After a Machine-Level BreakpointIDREF="07.mach46"Continuing Execution After a Machine-Level BreakpointIDREF="07.mach48"Continuing Execution After a Machine-Level BreakpointIDREF="07.mach42"Continuing Execution After a Machine-Level BreakpointIDREF="apA.cmd55"dbx Commandscorefile commandIDREF="apA.cmd56"dbx CommandsIDREF="02.run33"Specifying Files with dbx CommandsIDREF="02.run31"Specifying Files with dbx Commandsdbx aliases. See aliasesIDREF="04.cntrl33"Creating and Removing dbx Aliasesdbx variablesIDREF="04.cntrl1"Creating and Removing dbx VariablesIDREF="05.change1"Using ExpressionslistingIDREF="04.cntrl8"Listing dbx VariablesIDREF="apA.cmd158"dbx Commandspredefined. See predefined dbx variablesIDREF="04.cntrl2"Creating and Removing dbx VariablesremovingIDREF="apA.cmd213"dbx CommandsIDREF="04.cntrl10"Removing VariablessettingIDREF="04.cntrl3"Setting dbx VariablesIDREF="apA.cmd159"dbx CommandsIDREF="04.cntrl6"Setting dbx Variablesdelete commandIDREF="07.mach34"Setting Machine-Level BreakpointsIDREF="07.mach52"Tracing Execution at the Machine LevelIDREF="06.exec32"Tracing Program ExecutionIDREF="06.exec59"Deleting Breakpoints, Traces, and Conditional CommandsIDREF="06.exec6"Setting BreakpointsIDREF="06.exec58"Deleting Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd58"dbx Commandsdelpgrp commandIDREF="08.multiple62"Handling sproc System Calls and Process Group DebuggingIDREF="apA.cmd62"dbx Commandsdelproc commandIDREF="08.multiple17"Deleting a Process From the Process PoolIDREF="apA.cmd64"dbx Commandsdir commandIDREF="02.run10"dbx OptionsIDREF="03.examin14"Using Path RemappingIDREF="03.examin9"Specifying Source Directories With dbx CommandsIDREF="apA.cmd66"dbx CommandsIDREF="03.examin7"Specifying Source Directories With dbx Commandsdisable commandIDREF="06.exec30"Tracing Program ExecutionIDREF="06.exec50"Disabling Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd68"dbx CommandsIDREF="06.exec4"Setting BreakpointsIDREF="07.mach32"Setting Machine-Level BreakpointsIDREF="07.mach50"Tracing Execution at the Machine Leveldown commandIDREF="05.change81"Moving Within the StackIDREF="apA.cmd72"dbx Commandsdump commandIDREF="05.change95"Printing Activation Level InformationIDREF="05.change91"Printing Activation Level InformationIDREF="05.change94"Printing Activation Level InformationIDREF="apA.cmd74"dbx CommandsIDREF="05.change93"Printing Activation Level Informationedit commandIDREF="03.examin30"Calling an EditorIDREF="apA.cmd77"dbx CommandsIDREF="03.examin28"Calling an EditorIDREF="apC.vars29"Predefined dbx Variables    IDREF="apA.cmd81"dbx Commandsenable commandIDREF="06.exec31"Tracing Program ExecutionIDREF="06.exec54"Enabling Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd83"dbx CommandsIDREF="06.exec5"Setting BreakpointsIDREF="07.mach51"Tracing Execution at the Machine LevelIDREF="07.mach33"Setting Machine-Level Breakpointsfile commandIDREF="03.examin16"Changing Source FilesIDREF="apA.cmd87"dbx Commandsfunc commandIDREF="05.change86"Moving to a Specified ProcedureIDREF="05.change89"Moving to a Specified ProcedureIDREF="05.change88"Moving to a Specified ProcedureIDREF="apA.cmd90"dbx Commandsgivenfile commandIDREF="apA.cmd92"dbx CommandsIDREF="02.run30"Specifying Files with dbx CommandsIDREF="02.run32"Specifying Files with dbx Commandsgoto commandIDREF="06.exec98"Starting at a Specified LineIDREF="apA.cmd94"dbx Commandshed commandIDREF="04.cntrl29"The History EditorIDREF="apA.cmd97"dbx CommandsIDREF="04.cntrl31"The History EditorIDREF="apA.cmd95"dbx CommandsIDREF="04.cntrl25"The History EditorIDREF="04.cntrl30"The History Editorhelp commandIDREF="02.run46"Using Online HelpIDREF="apA.cmd101"dbx Commandshistory commandIDREF="04.cntrl16"Examining the History ListIDREF="apA.cmd105"dbx Commandsignore commandIDREF="06.exec65"Catching and Ignoring SignalsIDREF="apA.cmd106"dbx CommandsIDREF="06.exec63"Catching and Ignoring SignalsIDREF="06.exec68"Catching and Ignoring Signalskill commandIDREF="08.multiple42"Killing a ProcessIDREF="08.multiple44"Killing a ProcessIDREF="apA.cmd109"dbx Commandslist commandIDREF="apA.cmd112"dbx CommandsIDREF="03.examin20"Listing Source Codelistobj commandIDREF="apA.cmd116"dbx CommandsIDREF="02.run4"Compiling and Linking Programs With Dynamic Shared Objectsnext commandIDREF="apA.cmd117"dbx CommandsIDREF="06.exec89"Stepping Through Your ProgramIDREF="01.start22"Studying a New ProgramIDREF="06.exec94"Stepping Using the next Commandnexti commandIDREF="07.mach70"Stepping Through Machine CodeIDREF="apA.cmd119"dbx CommandsIDREF="07.mach69"Stepping Through Machine CodepdIDREF="05.change36"Printing ExpressionsIDREF="05.change55"Displaying the Value of a Variablepi commandIDREF="04.cntrl65"Playing Back Inputplayback input commandIDREF="apC.vars7"Predefined dbx Variables    IDREF="apA.cmd120"dbx CommandsIDREF="apC.vars59"Predefined dbx Variables    IDREF="04.cntrl76"Executing dbx ScriptsIDREF="04.cntrl56"Recording InputIDREF="apC.vars63"Predefined dbx Variables    playback output commandIDREF="apC.vars6"Predefined dbx Variables    IDREF="apA.cmd123"dbx CommandspoIDREF="05.change56"Displaying the Value of a VariableIDREF="05.change38"Printing Expressionsprint commandIDREF="01.start24"Studying a New ProgramIDREF="apA.cmd125"dbx CommandsIDREF="05.change50"Displaying the Value of a VariableIDREF="04.cntrl7"Setting dbx VariablesIDREF="05.change34"Printing ExpressionsIDREF="01.start21"Studying a New Programprintd commandIDREF="05.change35"Printing ExpressionsIDREF="05.change51"Displaying the Value of a VariableIDREF="apA.cmd127"dbx Commandsprintf commandIDREF="05.change41"Printing ExpressionsIDREF="apA.cmd128"dbx CommandsIDREF="05.change52"Displaying the Value of a Variableprinto commandIDREF="05.change37"Printing ExpressionsIDREF="05.change53"Displaying the Value of a VariableIDREF="apA.cmd130"dbx Commandsprintregs commandIDREF="apA.cmd131"dbx CommandsIDREF="07.mach5"Printing Register Valuesprintx commandIDREF="05.change39"Printing ExpressionsIDREF="05.change54"Displaying the Value of a VariableIDREF="apA.cmd133"dbx CommandspxIDREF="05.change40"Printing ExpressionsIDREF="05.change57"Displaying the Value of a Variablequit commandIDREF="apA.cmd134"dbx CommandsIDREF="02.run54"Quitting dbxrecord input commandIDREF="04.cntrl55"Recording InputIDREF="04.cntrl64"Playing Back InputIDREF="apC.vars26"Predefined dbx Variables    IDREF="apA.cmd138"dbx Commandsrecord output commandIDREF="04.cntrl69"Recording OutputIDREF="apC.vars1"Predefined dbx Variables    IDREF="apA.cmd141"dbx Commandsrecord commandIDREF="04.cntrl72"Examining the Record StateIDREF="apA.cmd136"dbx Commandsrerun commandIDREF="02.run41"Running Your ProgramIDREF="01.start16"Debugging Your ProgramsIDREF="02.run36"Running Your ProgramIDREF="apA.cmd145"dbx Commandsresume commandIDREF="08.multiple30"Resuming a Suspended ProcessIDREF="06.exec29"Continuing Execution After a BreakpointIDREF="apA.cmd147"dbx CommandsIDREF="08.multiple32"Resuming a Suspended Processreturn commandIDREF="apA.cmd151"dbx CommandsIDREF="06.exec96"Using the return CommandIDREF="06.exec95"Using the return Commandrun commandIDREF="02.run35"Running Your ProgramIDREF="apA.cmd152"dbx CommandsIDREF="02.run37"Running Your ProgramIDREF="01.start15"Debugging Your Programsset commandIDREF="05.change30"String ConstantsIDREF="04.cntrl9"Listing dbx VariablesIDREF="04.cntrl4"Setting dbx VariablesIDREF="apA.cmd157"dbx CommandsIDREF="04.cntrl5"Setting dbx Variablessh commandIDREF="apA.cmd160"dbx CommandsIDREF="02.run51"Invoking a Shellshowpgrp commandIDREF="apA.cmd163"dbx CommandsIDREF="08.multiple64"Handling sproc System Calls and Process Group Debuggingshowproc commandIDREF="apA.cmd165"dbx CommandsIDREF="08.multiple9"Listing Available ProcessesIDREF="08.multiple12"Listing Available ProcessesIDREF="08.multiple11"Listing Available ProcessessourceIDREF="apB.alias33"Predefined AliasesIDREF="apA.cmd167"dbx Commandsstatus commandIDREF="04.cntrl62"Ending a Recording SessionIDREF="apA.cmd168"dbx CommandsIDREF="06.exec46"Listing Breakpoints, Traces, and Conditional Commandsstep commandIDREF="06.exec90"Stepping Using the step CommandIDREF="01.start23"Studying a New ProgramIDREF="apA.cmd172"dbx CommandsIDREF="06.exec88"Stepping Through Your Programstepi commandIDREF="07.mach72"Stepping Through Machine CodeIDREF="apA.cmd174"dbx CommandsIDREF="07.mach71"Stepping Through Machine CodeIDREF="07.mach68"Stepping Through Machine Codestop commandIDREF="06.exec15"Stopping If a Variable or Memory Location Has ChangedIDREF="06.exec8"Setting Unconditional BreakpointsIDREF="apA.cmd175"dbx CommandsIDREF="06.exec10"Setting Unconditional BreakpointsIDREF="06.exec17"Stopping If a Variable or Memory Location Has ChangedIDREF="06.exec13"Stopping If a Variable or Memory Location Has ChangedIDREF="01.start13"Debugging Your ProgramsIDREF="06.exec9"Setting Unconditional BreakpointsIDREF="06.exec20"Stopping If a Test Expression Is Truestopi commandIDREF="07.mach31"Setting Machine-Level BreakpointsIDREF="apA.cmd179"dbx CommandsIDREF="07.mach35"Syntax of the stopi CommandIDREF="07.mach37"Syntax of the stopi Commandsuspend commandIDREF="08.multiple27"Suspending a ProcessIDREF="apA.cmd184"dbx CommandsIDREF="08.multiple23"Suspending a ProcessIDREF="apA.cmd182"dbx CommandsIDREF="08.multiple21"Suspending a ProcessIDREF="08.multiple25"Suspending a Processsyscall commandIDREF="06.exec73"Stopping at System CallsIDREF="apA.cmd185"dbx CommandsIDREF="06.exec74"Stopping at System CallsIDREF="06.exec76"Stopping at System Callstag commandIDREF="apA.cmd190"dbx Commandstrace commandIDREF="01.start27"Studying a New ProgramIDREF="06.exec39"Tracing Program ExecutionIDREF="06.exec33"Tracing Program ExecutionIDREF="apA.cmd191"dbx CommandsIDREF="06.exec37"Tracing Program ExecutionIDREF="06.exec35"Tracing Program ExecutionIDREF="apA.cmd193"dbx Commandstracei commandIDREF="07.mach53"Tracing Execution at the Machine LevelIDREF="07.mach55"Tracing Execution at the Machine LevelIDREF="07.mach62"Tracing Execution at the Machine LevelIDREF="07.mach58"Tracing Execution at the Machine LevelIDREF="07.mach49"Tracing Execution at the Machine LevelIDREF="07.mach56"Tracing Execution at the Machine LevelIDREF="apA.cmd199"dbx CommandsIDREF="07.mach60"Tracing Execution at the Machine Levelunalias commandIDREF="04.cntrl48"Removing Command AliasesIDREF="apB.alias3"Predefined AliasesIDREF="apA.cmd206"dbx Commandsunrecord commandIDREF="04.cntrl59"Ending a Recording SessionIDREF="04.cntrl60"Ending a Recording SessionIDREF="apA.cmd208"dbx CommandsIDREF="apA.cmd210"dbx Commandsunset commandIDREF="04.cntrl11"Removing VariablesIDREF="apA.cmd212"dbx Commandsup commandIDREF="apA.cmd214"dbx CommandsIDREF="05.change80"Moving Within the Stackuse commandIDREF="apA.cmd216"dbx CommandsIDREF="03.examin11"Specifying Source Directories With dbx CommandsIDREF="02.run9"dbx OptionsIDREF="03.examin8"Specifying Source Directories With dbx CommandsWIDREF="apB.alias37"Predefined Aliaseswait commandIDREF="apA.cmd218"dbx CommandsIDREF="08.multiple36"Waiting for a Resumed ProcessIDREF="08.multiple38"Waiting for a Resumed Processwaitall commandIDREF="apA.cmd221"dbx CommandsIDREF="08.multiple35"Waiting for a Resumed ProcessIDREF="08.multiple41"Waiting for Any Running Processwhatis commandIDREF="05.change71"Displaying Type DeclarationsIDREF="apA.cmd223"dbx Commandswhen commandIDREF="06.exec43"Writing Conditional CommandsIDREF="apA.cmd225"dbx Commandswheni commandIDREF="07.mach66"Writing Conditional Commands at the Machine LevelIDREF="apA.cmd228"dbx CommandsIDREF="07.mach65"Writing Conditional Commands at the Machine LevelIDREF="07.mach64"Writing Conditional Commands at the Machine Levelwhere commandIDREF="01.start6"Examining Core Dumps to Determine Cause of FailureIDREF="05.change77"Printing Stack TracesIDREF="07.mach41"Syntax of the stopi CommandIDREF="apA.cmd229"dbx Commandswhich commandIDREF="apA.cmd231"dbx CommandsIDREF="05.change69"Determining the Scope of Variableswhichobj commandIDREF="apA.cmd233"dbx CommandsIDREF="02.run5"Compiling and Linking Programs With Dynamic Shared ObjectscommandsactiveIDREF="08.multiple18"Selecting a ProcessIDREF="apA.cmd20"dbx CommandsaddpgrpIDREF="apA.cmd23"dbx CommandsIDREF="08.multiple60"Handling sproc System Calls and Process Group DebuggingaddprocIDREF="apA.cmd25"dbx CommandsIDREF="08.multiple15"Adding a Process to the Process PoolaliasIDREF="04.cntrl43"Creating Command AliasesIDREF="04.cntrl38"Listing AliasesIDREF="04.cntrl45"Creating Command AliasesIDREF="apB.alias2"Predefined AliasesIDREF="04.cntrl36"Listing AliasesIDREF="04.cntrl40"Creating Command AliasesIDREF="apA.cmd27"dbx CommandsIDREF="04.cntrl41"Creating Command AliasesIDREF="apA.cmd37"dbx CommandsIDREF="04.cntrl37"Listing AliasesassignIDREF="apA.cmd42"dbx CommandsIDREF="05.change62"Changing the Value of a VariableIDREF="apA.cmd44"dbx CommandsIDREF="05.change61"Changing the Value of a VariableIDREF="07.mach12"Changing Register ValuesIDREF="07.mach13"Changing Register ValuescatchIDREF="apA.cmd46"dbx CommandsIDREF="apA.cmd48"dbx CommandsccallIDREF="05.change97"Using ccallIDREF="apA.cmd50"dbx CommandsclearcallsIDREF="apA.cmd52"dbx CommandsIDREF="05.change102"Using clearcallscontIDREF="06.exec25"Continuing Execution After a BreakpointIDREF="07.mach44"Continuing Execution After a Machine-Level BreakpointIDREF="08.multiple29"Resuming a Suspended ProcessIDREF="apA.cmd54"dbx CommandsIDREF="06.exec97"Starting at a Specified LineIDREF="06.exec70"Continuing After Catching a SignalcontiIDREF="apA.cmd55"dbx CommandsIDREF="07.mach42"Continuing Execution After a Machine-Level BreakpointIDREF="07.mach46"Continuing Execution After a Machine-Level BreakpointIDREF="07.mach47"Continuing Execution After a Machine-Level BreakpointIDREF="07.mach48"Continuing Execution After a Machine-Level BreakpointcorefileIDREF="apA.cmd56"dbx CommandsIDREF="02.run33"Specifying Files with dbx CommandsIDREF="02.run31"Specifying Files with dbx CommandsdeleteIDREF="07.mach34"Setting Machine-Level BreakpointsIDREF="06.exec6"Setting BreakpointsIDREF="06.exec32"Tracing Program ExecutionIDREF="06.exec58"Deleting Breakpoints, Traces, and Conditional CommandsIDREF="07.mach52"Tracing Execution at the Machine LevelIDREF="06.exec59"Deleting Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd58"dbx CommandsdelpgrpIDREF="08.multiple62"Handling sproc System Calls and Process Group DebuggingIDREF="apA.cmd62"dbx CommandsdelprocIDREF="apA.cmd64"dbx CommandsIDREF="08.multiple17"Deleting a Process From the Process PooldirIDREF="02.run10"dbx OptionsIDREF="03.examin9"Specifying Source Directories With dbx CommandsIDREF="apA.cmd66"dbx CommandsIDREF="03.examin14"Using Path RemappingIDREF="03.examin7"Specifying Source Directories With dbx CommandsdisableIDREF="06.exec50"Disabling Breakpoints, Traces, and Conditional CommandsIDREF="06.exec30"Tracing Program ExecutionIDREF="06.exec4"Setting BreakpointsIDREF="07.mach32"Setting Machine-Level BreakpointsIDREF="07.mach50"Tracing Execution at the Machine LevelIDREF="apA.cmd68"dbx CommandsdownIDREF="05.change81"Moving Within the StackIDREF="apA.cmd72"dbx CommandsdumpIDREF="05.change91"Printing Activation Level InformationIDREF="05.change93"Printing Activation Level InformationIDREF="05.change94"Printing Activation Level InformationIDREF="05.change95"Printing Activation Level InformationIDREF="apA.cmd74"dbx CommandseditIDREF="apA.cmd81"dbx CommandsIDREF="apC.vars29"Predefined dbx Variables    IDREF="03.examin28"Calling an EditorIDREF="03.examin30"Calling an EditorIDREF="apA.cmd77"dbx CommandsenableIDREF="apA.cmd83"dbx CommandsIDREF="06.exec31"Tracing Program ExecutionIDREF="06.exec5"Setting BreakpointsIDREF="07.mach51"Tracing Execution at the Machine LevelIDREF="07.mach33"Setting Machine-Level BreakpointsIDREF="06.exec54"Enabling Breakpoints, Traces, and Conditional CommandsfileIDREF="apA.cmd87"dbx CommandsIDREF="03.examin16"Changing Source FilesfuncIDREF="05.change89"Moving to a Specified ProcedureIDREF="apA.cmd90"dbx CommandsIDREF="05.change86"Moving to a Specified ProcedureIDREF="05.change88"Moving to a Specified ProceduregivenfileIDREF="02.run32"Specifying Files with dbx CommandsIDREF="apA.cmd92"dbx CommandsIDREF="02.run30"Specifying Files with dbx CommandsgotoIDREF="06.exec98"Starting at a Specified LineIDREF="apA.cmd94"dbx CommandshedIDREF="04.cntrl31"The History EditorIDREF="04.cntrl25"The History EditorIDREF="apA.cmd95"dbx CommandsIDREF="04.cntrl29"The History EditorIDREF="04.cntrl30"The History EditorIDREF="apA.cmd97"dbx CommandshelpIDREF="apA.cmd101"dbx CommandsIDREF="02.run46"Using Online HelphistoryIDREF="04.cntrl16"Examining the History ListIDREF="apA.cmd105"dbx CommandsignoreIDREF="apA.cmd106"dbx CommandsIDREF="06.exec63"Catching and Ignoring SignalsIDREF="06.exec65"Catching and Ignoring SignalsIDREF="06.exec68"Catching and Ignoring SignalskillIDREF="08.multiple44"Killing a ProcessIDREF="08.multiple42"Killing a ProcessIDREF="apA.cmd109"dbx CommandslistIDREF="03.examin20"Listing Source CodeIDREF="apA.cmd112"dbx CommandslistobjIDREF="apA.cmd116"dbx CommandsIDREF="02.run4"Compiling and Linking Programs With Dynamic Shared ObjectsnextIDREF="06.exec94"Stepping Using the next CommandIDREF="06.exec89"Stepping Through Your ProgramIDREF="apA.cmd117"dbx CommandsnextiIDREF="07.mach70"Stepping Through Machine CodeIDREF="apA.cmd119"dbx CommandsIDREF="07.mach69"Stepping Through Machine Codeplayback inputIDREF="apA.cmd120"dbx CommandsIDREF="apC.vars63"Predefined dbx Variables    IDREF="apC.vars7"Predefined dbx Variables    IDREF="04.cntrl56"Recording InputIDREF="04.cntrl76"Executing dbx ScriptsIDREF="apC.vars59"Predefined dbx Variables    playback outputIDREF="apA.cmd123"dbx CommandsIDREF="apC.vars6"Predefined dbx Variables    printIDREF="apA.cmd125"dbx CommandsIDREF="05.change34"Printing ExpressionsIDREF="05.change50"Displaying the Value of a VariableIDREF="04.cntrl7"Setting dbx VariablesprintdIDREF="05.change51"Displaying the Value of a VariableIDREF="05.change35"Printing ExpressionsIDREF="apA.cmd127"dbx CommandsprintfIDREF="apA.cmd128"dbx CommandsIDREF="05.change41"Printing ExpressionsIDREF="05.change52"Displaying the Value of a VariableprintoIDREF="apA.cmd130"dbx CommandsIDREF="05.change53"Displaying the Value of a VariableIDREF="05.change37"Printing ExpressionsprintregsIDREF="07.mach5"Printing Register ValuesIDREF="apA.cmd131"dbx CommandsprintxIDREF="05.change54"Displaying the Value of a VariableIDREF="apA.cmd133"dbx CommandsIDREF="05.change39"Printing ExpressionsquitIDREF="02.run54"Quitting dbxIDREF="apA.cmd134"dbx Commandsrecord inputIDREF="04.cntrl55"Recording InputIDREF="04.cntrl64"Playing Back InputIDREF="apA.cmd138"dbx CommandsIDREF="apC.vars26"Predefined dbx Variables    record outputIDREF="apC.vars1"Predefined dbx Variables    IDREF="apA.cmd141"dbx CommandsIDREF="04.cntrl69"Recording OutputrecordIDREF="04.cntrl72"Examining the Record StateIDREF="apA.cmd136"dbx CommandsrerunIDREF="02.run41"Running Your ProgramIDREF="02.run36"Running Your ProgramIDREF="apA.cmd145"dbx CommandsresumeIDREF="06.exec29"Continuing Execution After a BreakpointIDREF="apA.cmd147"dbx CommandsIDREF="08.multiple30"Resuming a Suspended ProcessIDREF="08.multiple32"Resuming a Suspended ProcessreturnIDREF="06.exec95"Using the return CommandIDREF="apA.cmd151"dbx CommandsIDREF="06.exec96"Using the return CommandrunIDREF="02.run35"Running Your ProgramIDREF="02.run37"Running Your ProgramIDREF="apA.cmd152"dbx CommandssetIDREF="04.cntrl9"Listing dbx VariablesIDREF="04.cntrl4"Setting dbx VariablesIDREF="apA.cmd157"dbx CommandsIDREF="04.cntrl5"Setting dbx VariablesIDREF="05.change30"String ConstantsshIDREF="apA.cmd160"dbx CommandsIDREF="02.run51"Invoking a ShellshowpgrpIDREF="08.multiple64"Handling sproc System Calls and Process Group DebuggingIDREF="apA.cmd163"dbx CommandsshowprocIDREF="08.multiple9"Listing Available ProcessesIDREF="08.multiple11"Listing Available ProcessesIDREF="apA.cmd165"dbx CommandsIDREF="08.multiple12"Listing Available ProcessesstatusIDREF="apA.cmd168"dbx CommandsIDREF="04.cntrl62"Ending a Recording SessionIDREF="06.exec46"Listing Breakpoints, Traces, and Conditional CommandsstepIDREF="apA.cmd172"dbx CommandsIDREF="06.exec88"Stepping Through Your ProgramIDREF="06.exec90"Stepping Using the step CommandstepiIDREF="07.mach68"Stepping Through Machine CodeIDREF="apA.cmd174"dbx CommandsIDREF="07.mach71"Stepping Through Machine CodeIDREF="07.mach72"Stepping Through Machine CodestopIDREF="06.exec10"Setting Unconditional BreakpointsIDREF="06.exec13"Stopping If a Variable or Memory Location Has ChangedIDREF="apA.cmd175"dbx CommandsIDREF="06.exec20"Stopping If a Test Expression Is TrueIDREF="06.exec8"Setting Unconditional BreakpointsIDREF="06.exec15"Stopping If a Variable or Memory Location Has ChangedIDREF="06.exec9"Setting Unconditional BreakpointsIDREF="06.exec17"Stopping If a Variable or Memory Location Has ChangedstopiIDREF="apA.cmd179"dbx CommandsIDREF="07.mach35"Syntax of the stopi CommandIDREF="07.mach31"Setting Machine-Level BreakpointsIDREF="07.mach37"Syntax of the stopi CommandsuspendIDREF="08.multiple21"Suspending a ProcessIDREF="08.multiple23"Suspending a ProcessIDREF="apA.cmd184"dbx CommandsIDREF="08.multiple27"Suspending a ProcessIDREF="08.multiple25"Suspending a ProcessIDREF="apA.cmd182"dbx CommandssyscallIDREF="06.exec74"Stopping at System CallsIDREF="apA.cmd185"dbx CommandsIDREF="06.exec73"Stopping at System CallsIDREF="06.exec76"Stopping at System CallstagIDREF="apA.cmd190"dbx CommandstraceIDREF="06.exec37"Tracing Program ExecutionIDREF="apA.cmd191"dbx CommandsIDREF="06.exec35"Tracing Program ExecutionIDREF="apA.cmd193"dbx CommandsIDREF="06.exec39"Tracing Program ExecutionIDREF="06.exec33"Tracing Program ExecutiontraceiIDREF="07.mach55"Tracing Execution at the Machine LevelIDREF="07.mach62"Tracing Execution at the Machine LevelIDREF="07.mach56"Tracing Execution at the Machine LevelIDREF="apA.cmd199"dbx CommandsIDREF="07.mach53"Tracing Execution at the Machine LevelIDREF="07.mach58"Tracing Execution at the Machine LevelIDREF="07.mach49"Tracing Execution at the Machine LevelIDREF="07.mach60"Tracing Execution at the Machine LevelunaliasIDREF="apB.alias3"Predefined AliasesIDREF="04.cntrl48"Removing Command AliasesIDREF="apA.cmd206"dbx CommandsunrecordIDREF="04.cntrl59"Ending a Recording SessionIDREF="apA.cmd210"dbx CommandsIDREF="apA.cmd208"dbx CommandsIDREF="04.cntrl60"Ending a Recording SessionunsetIDREF="apA.cmd212"dbx CommandsIDREF="04.cntrl11"Removing VariablesupIDREF="apA.cmd214"dbx CommandsIDREF="05.change80"Moving Within the StackuseIDREF="02.run9"dbx OptionsIDREF="03.examin8"Specifying Source Directories With dbx CommandsIDREF="03.examin11"Specifying Source Directories With dbx CommandsIDREF="apA.cmd216"dbx CommandswaitIDREF="08.multiple38"Waiting for a Resumed ProcessIDREF="08.multiple36"Waiting for a Resumed ProcessIDREF="apA.cmd218"dbx CommandswaitallIDREF="08.multiple35"Waiting for a Resumed ProcessIDREF="apA.cmd221"dbx CommandsIDREF="08.multiple41"Waiting for Any Running ProcesswhatisIDREF="05.change71"Displaying Type DeclarationsIDREF="apA.cmd223"dbx CommandswhenIDREF="apA.cmd225"dbx CommandsIDREF="06.exec43"Writing Conditional CommandswheniIDREF="07.mach64"Writing Conditional Commands at the Machine LevelIDREF="07.mach65"Writing Conditional Commands at the Machine LevelIDREF="07.mach66"Writing Conditional Commands at the Machine LevelIDREF="apA.cmd228"dbx CommandswhereIDREF="05.change77"Printing Stack TracesIDREF="apA.cmd229"dbx CommandsIDREF="07.mach41"Syntax of the stopi CommandwhichIDREF="05.change69"Determining the Scope of VariablesIDREF="apA.cmd231"dbx CommandswhichobjIDREF="apA.cmd233"dbx CommandsIDREF="02.run5"Compiling and Linking Programs With Dynamic Shared Objectsassign registerIDREF="07.mach16"Changing Register Valuessearch backward (?)IDREF="03.examin27"Searching Through Source CodeIDREF="03.examin25"Searching Through Source CodeIDREF="apA.cmd8"dbx Commandssearch forward (/)IDREF="03.examin24"Searching Through Source CodeIDREF="apA.cmd4"dbx CommandsIDREF="03.examin26"Searching Through Source Codecomments, command scriptsIDREF="05.change7"OperatorsIDREF="04.cntrl78"Executing dbx Scriptscommon pitfallsIDREF="01.start31"Avoiding Common Pitfallscompiling a program for dbx debuggingIDREF="02.run1"Compiling a Program for Debugging Under dbxconditional breakpointsIDREF="06.exec3"Setting BreakpointsIDREF="01.start12"Debugging Your ProgramssettingIDREF="06.exec11"Setting Conditional Breakpointstest clauseIDREF="06.exec23"Conditional Breakpoints Combining Variable and Test ClausesIDREF="06.exec21"Stopping If a Test Expression Is TrueIDREF="06.exec19"Stopping If a Test Expression Is Truevariable clauseIDREF="apA.cmd178"dbx CommandsIDREF="07.mach39"Syntax of the stopi CommandIDREF="07.mach40"Syntax of the stopi CommandIDREF="06.exec12"Stopping If a Variable or Memory Location Has ChangedIDREF="06.exec14"Stopping If a Variable or Memory Location Has ChangedIDREF="06.exec16"Stopping If a Variable or Memory Location Has ChangedIDREF="06.exec18"Stopping If a Variable or Memory Location Has ChangedIDREF="06.exec22"Conditional Breakpoints Combining Variable and Test ClausesIDREF="06.exec24"Conditional Breakpoints Combining Variable and Test Clausesconditional commandsdeletingIDREF="apA.cmd61"dbx CommandsIDREF="06.exec62"Deleting Breakpoints, Traces, and Conditional CommandsIDREF="06.exec60"Deleting Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd59"dbx CommandsdisablingIDREF="06.exec53"Disabling Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd71"dbx CommandsenablingIDREF="apA.cmd86"dbx CommandsIDREF="06.exec57"Enabling Breakpoints, Traces, and Conditional Commandsstop keywordIDREF="06.exec42"Writing Conditional CommandssettingIDREF="06.exec41"Writing Conditional CommandsstatusIDREF="apA.cmd171"dbx CommandsIDREF="06.exec49"Listing Breakpoints, Traces, and Conditional Commandstest clauseIDREF="06.exec45"Writing Conditional CommandsIDREF="apA.cmd227"dbx Commandsvariable clauseIDREF="06.exec44"Writing Conditional CommandsIDREF="apA.cmd226"dbx Commandsconflicts between program variable names and C keywordsIDREF="05.change64"Conflicts Between Variable Names and KeywordsIDREF="apC.vars19"Predefined dbx Variables    conflicts between program variable names and keywordsIDREF="05.change63"Conflicts Between Variable Names and KeywordsconstantsnumericIDREF="05.change16"Numeric ConstantsIDREF="05.change12"ConstantsstringIDREF="05.change29"String ConstantsIDREF="05.change13"Constantscontinuing after a breakpointIDREF="01.start19"Debugging Your ProgramsIDREF="06.exec26"Continuing Execution After a BreakpointIDREF="07.mach43"Continuing Execution After a Machine-Level Breakpointcontinuing after catching signalsIDREF="06.exec72"Continuing After Catching a SignalIDREF="06.exec71"Continuing After Catching a Signalcore dumpIDREF="01.start2"Examining Core Dumps to Determine Cause of FailureIDREF="02.run25"Specifying Object and Core Filescore filesIDREF="01.start3"Examining Core Dumps to Determine Cause of FailurespecifyingIDREF="apA.cmd57"dbx CommandsIDREF="02.run27"Specifying Object and Core Filescrashes, diagnosingIDREF="01.start2"Examining Core Dumps to Determine Cause of Failurecreating aliasesIDREF="apA.cmd39"dbx CommandsIDREF="apA.cmd40"dbx CommandsIDREF="apA.cmd41"dbx CommandsIDREF="04.cntrl46"Creating Command AliasesIDREF="04.cntrl39"Creating Command AliasesIDREF="04.cntrl42"Creating Command AliasesIDREF="04.cntrl44"Creating Command Aliasescurrent directoryIDREF="03.examin4"Specifying Source Directoriescurrent source fileIDREF="03.examin18"Changing Source FilesIDREF="05.change85"Moving Within the StackIDREF="apA.cmd89"dbx CommandsIDREF="apA.cmd6"dbx CommandsIDREF="apA.cmd10"dbx Commandsdebugging a programIDREF="01.start9"Debugging Your Programs Fortran multiprocess programsIDREF="08.multiple53"Handling sproc System Calls and Process Group Debuggingmultiprocess application. See multiprocess debuggingIDREF="08.multiple1"Multiple Process Debuggingdebugging C++ programsIDREF="05.change105"C++ Considerationsrunning processesIDREF="02.run21"dbx Optionsdecimal inputIDREF="05.change17"Numeric Constantsdecimal outputIDREF="05.change24"Numeric Constantsdefault input baseIDREF="05.change18"Numeric Constantsdefault output baseIDREF="05.change23"Numeric Constantsdelete processes from process poolIDREF="apA.cmd65"dbx CommandsIDREF="08.multiple16"Deleting a Process From the Process Pooldeleting aliasesIDREF="apA.cmd207"dbx CommandsIDREF="04.cntrl47"Removing Command Aliasesconditional commandsIDREF="06.exec60"Deleting Breakpoints, Traces, and Conditional CommandsIDREF="06.exec62"Deleting Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd61"dbx CommandsIDREF="apA.cmd59"dbx Commands processes from the process group listIDREF="apA.cmd63"dbx Commandsprocesses from the process group listIDREF="08.multiple61"Handling sproc System Calls and Process Group DebuggingtracingIDREF="06.exec61"Deleting Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd60"dbx Commandsdetermining scope of program variablesIDREF="05.change68"Determining the Scope of VariablesIDREF="apA.cmd232"dbx CommandsdisablingbreakpointsIDREF="06.exec51"Disabling Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd69"dbx Commandsconditional commandsIDREF="apA.cmd71"dbx CommandsIDREF="06.exec53"Disabling Breakpoints, Traces, and Conditional CommandstracingIDREF="apA.cmd70"dbx CommandsIDREF="06.exec52"Disabling Breakpoints, Traces, and Conditional Commandsdisassemble codeIDREF="apA.cmd30"dbx CommandsIDREF="07.mach22"Examining Memory and Disassembling CodeIDREF="07.mach4"Examining and Changing Register ValuesIDREF="apA.cmd33"dbx CommandsIDREF="07.mach19"Examining Memory and Disassembling Codedisplayactive process in process poolIDREF="apA.cmd22"dbx CommandsIDREF="08.multiple20"Selecting a Processprocesses in process poolIDREF="08.multiple10"Listing Available ProcessesIDREF="08.multiple13"Listing Available ProcessesIDREF="apA.cmd166"dbx Commandsdisplaying aliasesIDREF="apA.cmd36"dbx CommandsIDREF="apA.cmd38"dbx CommandsIDREF="04.cntrl35"Listing Aliasesdisplaying caught signalsIDREF="apA.cmd47"dbx CommandsIDREF="06.exec67"Catching and Ignoring Signalsdisplaying caught system callsIDREF="apA.cmd186"dbx CommandsIDREF="06.exec78"Stopping at System Callsdisplaying ignored signalsIDREF="apA.cmd107"dbx CommandsIDREF="06.exec69"Catching and Ignoring Signalsdisplaying ignored system callsIDREF="apA.cmd187"dbx CommandsIDREF="06.exec79"Stopping at System Callsdisplaying recording sessionsIDREF="04.cntrl73"Examining the Record StateIDREF="apA.cmd137"dbx Commandsdisplaying register valuesIDREF="05.change79"Printing Stack TracesDSOsIDREF="02.run3"Compiling and Linking Programs With Dynamic Shared Objectsedit history listIDREF="apA.cmd98"dbx CommandsIDREF="apA.cmd96"dbx CommandsIDREF="apA.cmd99"dbx CommandsIDREF="04.cntrl26"The History EditorIDREF="apA.cmd100"dbx Commandsediting filesIDREF="apA.cmd78"dbx CommandsIDREF="03.examin29"Calling an EditorIDREF="apA.cmd82"dbx CommandsenablingbreakpointsIDREF="06.exec55"Enabling Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd84"dbx Commandsconditional commandsIDREF="apA.cmd86"dbx CommandsIDREF="06.exec57"Enabling Breakpoints, Traces, and Conditional CommandstracingIDREF="apA.cmd85"dbx CommandsIDREF="06.exec56"Enabling Breakpoints, Traces, and Conditional Commandsending recordingIDREF="04.cntrl61"Ending a Recording SessionIDREF="apA.cmd209"dbx CommandsIDREF="04.cntrl58"Ending a Recording SessionIDREF="apA.cmd211"dbx Commandsenvironment variablesEDITORIDREF="03.examin32"Calling an EditorIDREF="04.cntrl28"The History EditorIDREF="apA.cmd80"dbx CommandsIDREF="apC.vars3"Predefined dbx Variables    HOMEIDREF="02.run44"Automatically Executing Commands on Startupevaluation stack, increasingIDREF="02.run14"dbx Optionsexamining a new programIDREF="01.start20"Studying a New Programexamining arraysIDREF="05.change58"Displaying the Value of a Variableexamining core dumpsIDREF="01.start2"Examining Core Dumps to Determine Cause of Failureexamining program variablesIDREF="01.start17"Debugging Your ProgramsIDREF="01.start25"Studying a New Programexamining stackIDREF="01.start18"Debugging Your Programsexecuting a shell commandIDREF="02.run52"Invoking a ShellIDREF="apA.cmd162"dbx CommandsexpressionsprintingIDREF="05.change33"Printing ExpressionsIDREF="apA.cmd126"dbx Commandsprinting formattedIDREF="05.change42"Printing ExpressionsIDREF="apA.cmd129"dbx Commands.dbxinit fileIDREF="02.run43"Automatically Executing Commands on StartupIDREF="02.run12"dbx OptionsFortranmultiprocess debuggingIDREF="08.multiple53"Handling sproc System Calls and Process Group Debuggingfunction calls, interactiveIDREF="05.change101"Using clearcallsIDREF="apA.cmd51"dbx CommandsIDREF="05.change98"Using ccallIDREF="apA.cmd53"dbx CommandsIDREF="05.change96"Using Interactive Function CallsIDREF="05.change99"Using ccallexecIDREF="08.multiple49"Handling exec System CallsexecvIDREF="06.exec84"Stopping at System CallsexecveIDREF="06.exec85"Stopping at System CallsexitIDREF="06.exec86"Stopping at System CallsforkIDREF="08.multiple2"ProcessesIDREF="08.multiple56"Handling sproc System Calls and Process Group DebuggingIDREF="apC.vars10"Predefined dbx Variables    IDREF="08.multiple46"Handling fork System CallsIDREF="apC.vars8"Predefined dbx Variables    IDREF="06.exec80"Stopping at System CallssprocIDREF="08.multiple3"ProcessesIDREF="apC.vars9"Predefined dbx Variables    IDREF="08.multiple55"Handling sproc System Calls and Process Group DebuggingIDREF="06.exec81"Stopping at System CallsIDREF="apC.vars11"Predefined dbx Variables    IDREF="08.multiple51"Handling sproc System Calls and Process Group Debugginggroup historyIDREF="08.multiple68"Handling sproc System Calls and Process Group DebugginghelpIDREF="apA.cmd102"dbx CommandsIDREF="02.run45"Using Online HelpIDREF="apC.vars54"Predefined dbx Variables    hexadecimal inputIDREF="05.change21"Numeric ConstantsIDREF="apC.vars2"Predefined dbx Variables    hexadecimal outputIDREF="05.change27"Numeric ConstantsIDREF="apC.vars5"Predefined dbx Variables    IDREF="07.mach10"Printing Register Valueshistory editorIDREF="04.cntrl24"The History Editorhistory featureIDREF="04.cntrl12"Using the History Feature and the History Editorhistory listIDREF="04.cntrl18"Repeating CommandsIDREF="04.cntrl14"Examining the History ListeditingIDREF="04.cntrl26"The History EditorIDREF="apA.cmd96"dbx CommandsIDREF="apA.cmd98"dbx CommandsIDREF="apA.cmd99"dbx CommandsIDREF="apA.cmd100"dbx CommandsprintIDREF="04.cntrl15"Examining the History Listignoring signalsIDREF="06.exec66"Catching and Ignoring SignalsIDREF="apA.cmd108"dbx Commandsignoring system callsIDREF="06.exec77"Stopping at System CallsIDREF="apA.cmd189"dbx Commandsinclude filesIDREF="01.start36"Avoiding Common Pitfallsinputplaying backIDREF="04.cntrl63"Playing Back InputIDREF="04.cntrl51"Recording and Playing Back dbx Input and OutputIDREF="apA.cmd121"dbx CommandsrecordingIDREF="apA.cmd139"dbx CommandsIDREF="04.cntrl52"Recording and Playing Back dbx Input and Outputinput basedecimalIDREF="05.change17"Numeric ConstantshexadecimalIDREF="05.change21"Numeric ConstantsIDREF="apC.vars2"Predefined dbx Variables    octalIDREF="apC.vars47"Predefined dbx Variables    IDREF="05.change19"Numeric Constantsinteractive function callsIDREF="05.change31"String ConstantsIDREF="05.change96"Using Interactive Function CallsbreakpointsIDREF="05.change104"Nesting Interactive Function CallscallingIDREF="05.change98"Using ccallIDREF="apA.cmd51"dbx CommandsclearingIDREF="05.change99"Using ccallIDREF="05.change101"Using clearcallsIDREF="apA.cmd53"dbx CommandsnestingIDREF="05.change103"Nesting Interactive Function CallsunstackingIDREF="05.change100"Using ccallinvoking dbxIDREF="01.start4"Examining Core Dumps to Determine Cause of FailureIDREF="02.run6"Invoking dbxinvoking a shellIDREF="02.run50"Invoking a ShellIDREF="apA.cmd161"dbx Commands-c flagIDREF="02.run11"dbx Options-e flagIDREF="02.run13"dbx Options-g flagIDREF="06.exec92"Stepping Using the step CommandIDREF="05.change78"Printing Stack TracesIDREF="02.run2"Compiling a Program for Debugging Under dbxIDREF="01.start33"Avoiding Common PitfallsIDREF="01.start7"Examining Core Dumps to Determine Cause of FailureIDREF="03.examin3"Specifying Source DirectoriesIDREF="06.exec91"Stepping Using the step Command-I flagIDREF="03.examin6"Specifying Source Directories With ArgumentsIDREF="02.run7"dbx OptionsIDREF="02.run17"dbx Options-k flagIDREF="02.run15"dbx Options-p flagIDREF="02.run19"dbx OptionsIDREF="02.run20"dbx Options-r flagIDREF="02.run22"dbx Optionsassign to register commandIDREF="07.mach15"Changing Register Valuesdbx command scriptsIDREF="04.cntrl74"Executing dbx Scripts invokingIDREF="02.run6"Invoking dbxinvokingIDREF="01.start4"Examining Core Dumps to Determine Cause of Failure-c flagIDREF="02.run11"dbx Options-e flagIDREF="02.run13"dbx Options-I flagIDREF="02.run7"dbx OptionsIDREF="02.run17"dbx OptionsIDREF="03.examin6"Specifying Source Directories With Arguments-k flagIDREF="02.run15"dbx Options-p flagIDREF="02.run19"dbx OptionsIDREF="02.run20"dbx Options-r flagIDREF="02.run22"dbx Options quittingIDREF="02.run53"Quitting dbxIDREF="apA.cmd135"dbx CommandsdiraliasIDREF="apB.alias9"Predefined Aliasespath remappingIDREF="03.examin13"Using Path Remappingsource commandIDREF="04.cntrl66"Playing Back Inputkernel debuggingIDREF="02.run16"dbx Optionskill active processIDREF="apA.cmd110"dbx CommandsIDREF="08.multiple43"Killing a Processkill process in process poolIDREF="apA.cmd111"dbx CommandsIDREF="08.multiple45"Killing a Processline numbers, addressIDREF="05.change8"OperatorsIDREF="05.change5"OperatorsIDREF="04.cntrl79"Executing dbx Scriptslinked listIDREF="04.cntrl50"Alias Examplelisting dbx variablesIDREF="apA.cmd158"dbx CommandsIDREF="04.cntrl8"Listing dbx Variablesmachine-level breakpointsIDREF="07.mach36"Syntax of the stopi CommandIDREF="apA.cmd180"dbx CommandsIDREF="apA.cmd181"dbx CommandsIDREF="07.mach38"Syntax of the stopi CommandIDREF="07.mach30"Setting Machine-Level Breakpointsmachine-level debuggingIDREF="01.start1"Getting Started With dbxmachine-level single-steppingIDREF="07.mach67"Stepping Through Machine CodemacrosIDREF="01.start38"Avoiding Common Pitfallsmapping pathnamesIDREF="03.examin13"Using Path Remappingmemoryprint contentsIDREF="07.mach18"Examining Memory and Disassembling CodeIDREF="apA.cmd29"dbx Commandsmemory, print contentsIDREF="07.mach23"Examining Memory and Disassembling CodeIDREF="apA.cmd32"dbx CommandsIDREF="07.mach21"Examining Memory and Disassembling CodeIDREF="apA.cmd35"dbx Commandsmissing codeIDREF="01.start37"Avoiding Common PitfallsIDREF="01.start40"Avoiding Common Pitfallsmp FortranIDREF="apC.vars4"Predefined dbx Variables    IDREF="08.multiple52"Handling sproc System Calls and Process Group Debuggingmultiprocess debuggingIDREF="08.multiple1"Multiple Process Debuggingmultiprocess programsIDREF="06.exec28"Continuing Execution After a Breakpointnesting interactive function callsIDREF="05.change103"Nesting Interactive Function Callsnumeric constantsIDREF="05.change16"Numeric ConstantsIDREF="05.change12"Constantsobject filesIDREF="03.examin2"Specifying Source DirectoriesspecifyingIDREF="apA.cmd93"dbx CommandsIDREF="02.run24"Specifying Object and Core FilesIDREF="02.run26"Specifying Object and Core Filesoctal inputIDREF="05.change19"Numeric ConstantsIDREF="apC.vars47"Predefined dbx Variables    octal outputIDREF="07.mach9"Printing Register ValuesIDREF="05.change25"Numeric ConstantsIDREF="apC.vars50"Predefined dbx Variables    on-line helpIDREF="02.run45"Using Online HelpIDREF="apC.vars54"Predefined dbx Variables    IDREF="apA.cmd102"dbx CommandsoperatorsIDREF="05.change3"Using Expressions# operatorIDREF="05.change8"OperatorsIDREF="04.cntrl79"Executing dbx ScriptsIDREF="05.change5"Operators// (division)IDREF="05.change11"OperatorsIDREF="05.change9"OperatorsIDREF="05.change10"OperatorsprecedenceIDREF="05.change4"Operatorsoutputplaying backIDREF="04.cntrl54"Recording and Playing Back dbx Input and OutputIDREF="apA.cmd124"dbx CommandsrecordingIDREF="04.cntrl53"Recording and Playing Back dbx Input and OutputIDREF="apA.cmd142"dbx CommandsIDREF="04.cntrl68"Recording Outputoutput basedecimalIDREF="05.change24"Numeric ConstantshexadecimalIDREF="05.change27"Numeric ConstantsIDREF="apC.vars5"Predefined dbx Variables    IDREF="07.mach10"Printing Register ValuesoctalIDREF="07.mach9"Printing Register ValuesIDREF="05.change25"Numeric ConstantsIDREF="apC.vars50"Predefined dbx Variables    overloaded C++ functionsIDREF="05.change111"Referring to C++ Functionspath remappingIDREF="03.examin13"Using Path RemappingpathnamesIDREF="03.examin13"Using Path Remappingpgrp clauseIDREF="08.multiple65"Handling sproc System Calls and Process Group Debuggingpid clauseIDREF="08.multiple6"Using the pid Clauseplaying back inputIDREF="apA.cmd121"dbx CommandsIDREF="04.cntrl51"Recording and Playing Back dbx Input and OutputIDREF="04.cntrl63"Playing Back Inputplaying back outputIDREF="apA.cmd124"dbx CommandsIDREF="04.cntrl54"Recording and Playing Back dbx Input and Outputprecedence, operatorsIDREF="05.change4"Operatorspredefined dbx variables$newpgrpeventIDREF="apC.vars45"Predefined dbx Variables    predefined dbx aliasesIDREF="04.cntrl34"Creating and Removing dbx AliasesIDREF="apB.alias1"Predefined AliasesaIDREF="apB.alias4"Predefined AliasesbIDREF="apB.alias5"Predefined AliasesbpIDREF="apB.alias6"Predefined AliasescIDREF="apB.alias7"Predefined AliasesdIDREF="apB.alias8"Predefined AliasesdirIDREF="apB.alias9"Predefined AliaseseIDREF="apB.alias10"Predefined AliasesfIDREF="apB.alias11"Predefined AliasesgIDREF="apB.alias12"Predefined AliaseshIDREF="apB.alias13"Predefined AliasesjIDREF="apB.alias14"Predefined AliaseslIDREF="apB.alias15"Predefined AliasesliIDREF="apB.alias16"Predefined AliasesnIDREF="apB.alias17"Predefined AliasesniIDREF="apB.alias18"Predefined AliasespIDREF="apB.alias19"Predefined AliasespdIDREF="05.change36"Printing ExpressionsIDREF="05.change55"Displaying the Value of a VariableIDREF="apB.alias20"Predefined AliasespiIDREF="apB.alias21"Predefined AliasesIDREF="04.cntrl75"Executing dbx ScriptsIDREF="04.cntrl65"Playing Back InputpoIDREF="05.change38"Printing ExpressionsIDREF="apB.alias22"Predefined AliasesIDREF="05.change56"Displaying the Value of a VariableprIDREF="apB.alias23"Predefined AliasespxIDREF="05.change40"Printing ExpressionsIDREF="05.change57"Displaying the Value of a VariableIDREF="apB.alias24"Predefined AliasesqIDREF="apB.alias25"Predefined AliasesrIDREF="apB.alias26"Predefined AliasesriIDREF="apB.alias27"Predefined AliasesroIDREF="apB.alias28"Predefined AliasessIDREF="apB.alias29"Predefined AliasesIDREF="apB.alias30"Predefined AliasessiIDREF="apB.alias31"Predefined AliasesIDREF="apB.alias32"Predefined AliasessourceIDREF="apB.alias33"Predefined AliasesIDREF="apA.cmd167"dbx CommandstIDREF="apB.alias34"Predefined AliasesuIDREF="apB.alias35"Predefined AliasesWIDREF="apB.alias37"Predefined AliasesIDREF="apB.alias36"Predefined AliaseswiIDREF="apB.alias38"Predefined Aliasespredefined dbx variablesIDREF="apC.vars12"Predefined dbx Variables    IDREF="04.cntrl2"Creating and Removing dbx Variables$addrfmt64IDREF="apC.vars14"Predefined dbx Variables    $addrfmtIDREF="apC.vars13"Predefined dbx Variables    $assignverifyIDREF="apC.vars15"Predefined dbx Variables    $casesenseIDREF="05.change67"Case Sensitivity in Variable NamesIDREF="apC.vars16"Predefined dbx Variables    $ctypenamesIDREF="apC.vars18"Predefined dbx Variables    IDREF="05.change65"Conflicts Between Variable Names and Keywords$cureventIDREF="apC.vars20"Predefined dbx Variables    $curlineIDREF="apC.vars21"Predefined dbx Variables    $curpcIDREF="apC.vars22"Predefined dbx Variables    $cursrclineIDREF="apC.vars23"Predefined dbx Variables    $debugrldIDREF="apC.vars24"Predefined dbx Variables    $defaultinIDREF="apA.cmd140"dbx CommandsIDREF="04.cntrl57"Recording InputIDREF="apC.vars25"Predefined dbx Variables    $defaultoutIDREF="04.cntrl71"Recording OutputIDREF="apC.vars27"Predefined dbx Variables    IDREF="apA.cmd143"dbx Commands$editorIDREF="apC.vars28"Predefined dbx Variables    IDREF="apA.cmd79"dbx CommandsIDREF="03.examin31"Calling an EditorIDREF="04.cntrl27"The History Editor$fp_preciseIDREF="apC.vars30"Predefined dbx Variables    $frameregIDREF="07.mach15"Changing Register ValuesIDREF="apC.vars31"Predefined dbx Variables    $groupforktooIDREF="08.multiple58"Handling sproc System Calls and Process Group DebuggingIDREF="apC.vars32"Predefined dbx Variables    $hexcharsIDREF="apC.vars57"Predefined dbx Variables    IDREF="apC.vars33"Predefined dbx Variables    $hexdoublesIDREF="apC.vars34"Predefined dbx Variables    $hexinIDREF="apC.vars48"Predefined dbx Variables    IDREF="05.change22"Numeric ConstantsIDREF="apC.vars35"Predefined dbx Variables    $hexintsIDREF="07.mach8"Printing Register ValuesIDREF="apC.vars51"Predefined dbx Variables    IDREF="apC.vars36"Predefined dbx Variables    IDREF="05.change28"Numeric Constants$hexstringsIDREF="apC.vars37"Predefined dbx Variables    $historyeventIDREF="apC.vars38"Predefined dbx Variables    $lastchildIDREF="apC.vars39"Predefined dbx Variables    IDREF="08.multiple7"Using Scripts$linesIDREF="apC.vars40"Predefined dbx Variables    $listwindowIDREF="03.examin19"Listing Source CodeIDREF="apA.cmd114"dbx CommandsIDREF="03.examin22"Listing Source CodeIDREF="apA.cmd115"dbx CommandsIDREF="03.examin21"Listing Source CodeIDREF="apA.cmd113"dbx CommandsIDREF="apC.vars41"Predefined dbx Variables    $maxstrlenIDREF="apC.vars42"Predefined dbx Variables    $mp_programIDREF="08.multiple54"Handling sproc System Calls and Process Group DebuggingIDREF="06.exec83"Stopping at System CallsIDREF="apC.vars43"Predefined dbx Variables    $neweventIDREF="apC.vars44"Predefined dbx Variables    $octinIDREF="apC.vars46"Predefined dbx Variables    IDREF="05.change20"Numeric Constants$octintsIDREF="07.mach7"Printing Register ValuesIDREF="apC.vars49"Predefined dbx Variables    IDREF="05.change26"Numeric Constants$pageIDREF="apC.vars52"Predefined dbx Variables    $pagerIDREF="apA.cmd104"dbx CommandsIDREF="apA.cmd103"dbx CommandsIDREF="apC.vars53"Predefined dbx Variables    IDREF="02.run47"Using Online Help$pagewidthIDREF="apC.vars55"Predefined dbx Variables    $pagewindowIDREF="apC.vars56"Predefined dbx Variables    $piaddtohistIDREF="apC.vars58"Predefined dbx Variables    $pid0IDREF="apC.vars61"Predefined dbx Variables    IDREF="08.multiple8"Using Scripts$pidIDREF="apC.vars68"Predefined dbx Variables    IDREF="apC.vars60"Predefined dbx Variables    $pimodeIDREF="04.cntrl67"Playing Back InputIDREF="apC.vars62"Predefined dbx Variables    IDREF="04.cntrl32"The History EditorIDREF="apA.cmd122"dbx Commands$printdataIDREF="apC.vars64"Predefined dbx Variables    $printwhilestepIDREF="apC.vars65"Predefined dbx Variables    $printwideIDREF="apC.vars66"Predefined dbx Variables    $procaddrIDREF="apC.vars67"Predefined dbx Variables    $promptIDREF="apC.vars69"Predefined dbx Variables    IDREF="02.run29"The dbx Prompt$promptonforkIDREF="08.multiple48"Handling fork System CallsIDREF="apC.vars71"Predefined dbx Variables    IDREF="08.multiple47"Handling fork System CallsIDREF="06.exec82"Stopping at System Calls$regstyleIDREF="07.mach3"Examining and Changing Register ValuesIDREF="apC.vars72"Predefined dbx Variables    $repeatmodeIDREF="apA.cmd13"dbx CommandsIDREF="04.cntrl20"Repeating CommandsIDREF="apC.vars74"Predefined dbx Variables    $rimodeIDREF="04.cntrl70"Recording OutputIDREF="apA.cmd144"dbx CommandsIDREF="apC.vars76"Predefined dbx Variables    $showbreakaddrsIDREF="apC.vars77"Predefined dbx Variables    $stacktracelimitIDREF="apC.vars78"Predefined dbx Variables    $stepintoallIDREF="apC.vars79"Predefined dbx Variables    IDREF="06.exec93"Stepping Using the step CommandIDREF="07.mach73"Stepping Through Machine Code$tagfileIDREF="apC.vars80"Predefined dbx Variables    printbyte in octalIDREF="07.mach29"Examining Memory and Disassembling Codeword in decimalIDREF="07.mach25"Examining Memory and Disassembling Codeword in hexadecimalIDREF="07.mach28"Examining Memory and Disassembling Codeword in octalIDREF="07.mach27"Examining Memory and Disassembling Codeprint history listIDREF="04.cntrl15"Examining the History Listprint memory contentsIDREF="07.mach18"Examining Memory and Disassembling CodeIDREF="07.mach21"Examining Memory and Disassembling CodeIDREF="apA.cmd29"dbx CommandsIDREF="apA.cmd32"dbx CommandsIDREF="apA.cmd35"dbx CommandsIDREF="07.mach23"Examining Memory and Disassembling Codeprinting expressionsIDREF="apA.cmd126"dbx CommandsIDREF="05.change33"Printing Expressionsprinting formatted expressionsIDREF="05.change42"Printing ExpressionsIDREF="apA.cmd129"dbx Commandsprinting program variablesIDREF="05.change49"Displaying the Value of a Variableprinting register valuesIDREF="05.change79"Printing Stack Tracesproblemsconfused listingIDREF="01.start34"Avoiding Common Pitfallsinclude filesIDREF="01.start36"Avoiding Common PitfallsmacrosIDREF="01.start38"Avoiding Common Pitfallssource and code do not matchIDREF="01.start35"Avoiding Common Pitfallsvariables do not displayIDREF="01.start32"Avoiding Common Pitfallsprocedures, tracingIDREF="01.start29"Studying a New Programprocess group listadding processesIDREF="08.multiple59"Handling sproc System Calls and Process Group DebuggingIDREF="08.multiple57"Handling sproc System Calls and Process Group DebuggingIDREF="apA.cmd24"dbx Commandsdeleting processesIDREF="08.multiple61"Handling sproc System Calls and Process Group DebuggingIDREF="apA.cmd63"dbx Commandsshowing processesIDREF="08.multiple63"Handling sproc System Calls and Process Group DebuggingIDREF="apA.cmd164"dbx Commandsprocess groupsIDREF="08.multiple50"Handling sproc System Calls and Process Group DebuggingbreakpointsIDREF="08.multiple66"Handling sproc System Calls and Process Group Debugginggroup historyIDREF="08.multiple68"Handling sproc System Calls and Process Group DebuggingtracingIDREF="08.multiple67"Handling sproc System Calls and Process Group Debuggingprocess identification number (PID)IDREF="08.multiple5"Using the pid Clauseprocess poolIDREF="08.multiple4"Processesadd processesIDREF="08.multiple14"Adding a Process to the Process PoolIDREF="apA.cmd26"dbx Commandsdelete processesIDREF="08.multiple16"Deleting a Process From the Process PoolIDREF="apA.cmd65"dbx Commandsdisplay active processIDREF="apA.cmd22"dbx CommandsIDREF="08.multiple20"Selecting a Processdisplay processesIDREF="apA.cmd166"dbx CommandsIDREF="08.multiple13"Listing Available ProcessesIDREF="08.multiple10"Listing Available Processeskill active processIDREF="08.multiple43"Killing a ProcessIDREF="apA.cmd110"dbx Commandskill processesIDREF="apA.cmd111"dbx CommandsIDREF="08.multiple45"Killing a Processresume active processIDREF="08.multiple31"Resuming a Suspended ProcessIDREF="apA.cmd149"dbx CommandsIDREF="08.multiple33"Resuming a Suspended ProcessIDREF="apA.cmd148"dbx Commandsselect active processIDREF="08.multiple19"Selecting a ProcessIDREF="apA.cmd21"dbx Commandssuspend active processIDREF="08.multiple22"Suspending a Processsuspend processesIDREF="apA.cmd183"dbx CommandsIDREF="08.multiple24"Suspending a ProcessIDREF="08.multiple28"Suspending a ProcessIDREF="08.multiple26"Suspending a Processprocesseswait forIDREF="08.multiple40"Waiting for Any Running ProcessIDREF="apA.cmd222"dbx CommandsIDREF="08.multiple39"Waiting for a Resumed ProcessIDREF="apA.cmd219"dbx CommandsIDREF="08.multiple37"Waiting for a Resumed ProcessIDREF="apA.cmd220"dbx Commandsprogram stack. See stackIDREF="05.change72"Examining the Stack program variables. See variables, programIDREF="05.change2"Using ExpressionsIDREF="05.change45"Displaying and Changing Program Variablesprogram variables. See variables, programIDREF="01.start17"Debugging Your ProgramspromptIDREF="apC.vars70"Predefined dbx Variables    IDREF="02.run28"The dbx Promptqualifying program variable namesIDREF="06.exec40"Tracing Program ExecutionIDREF="05.change46"Qualifying Variable NamesIDREF="05.change75"Examining the Stackquitting dbxIDREF="apA.cmd135"dbx CommandsIDREF="02.run53"Quitting dbxrecording inputIDREF="apA.cmd139"dbx CommandsIDREF="04.cntrl52"Recording and Playing Back dbx Input and Outputrecording outputIDREF="04.cntrl68"Recording OutputIDREF="apA.cmd142"dbx CommandsIDREF="04.cntrl53"Recording and Playing Back dbx Input and Outputrecording, displaying sessionsIDREF="apA.cmd137"dbx CommandsIDREF="04.cntrl73"Examining the Record Staterecording, endingIDREF="04.cntrl61"Ending a Recording SessionIDREF="04.cntrl58"Ending a Recording SessionIDREF="apA.cmd209"dbx CommandsIDREF="apA.cmd211"dbx Commandsregister namesIDREF="07.mach2"Examining and Changing Register ValuesIDREF="apC.vars73"Predefined dbx Variables    registersIDREF="07.mach1"Examining and Changing Register Valueschanging valuesIDREF="07.mach14"Changing Register ValuesIDREF="apA.cmd43"dbx Commandsdisplaying valuesIDREF="05.change79"Printing Stack Tracesprinting valuesIDREF="apA.cmd132"dbx CommandsIDREF="05.change79"Printing Stack TracesIDREF="07.mach6"Printing Register Valuesusing values in expressionsIDREF="07.mach11"Printing Register Valuesremoving dbx variablesIDREF="04.cntrl10"Removing VariablesIDREF="apA.cmd213"dbx Commandsrepeating commandsIDREF="apA.cmd12"dbx CommandsIDREF="04.cntrl13"Using the History Feature and the History EditorIDREF="apA.cmd15"dbx CommandsIDREF="apA.cmd17"dbx CommandsIDREF="apC.vars75"Predefined dbx Variables    IDREF="apA.cmd19"dbx CommandsIDREF="04.cntrl17"Repeating Commandsresume active processIDREF="08.multiple31"Resuming a Suspended ProcessIDREF="apA.cmd148"dbx CommandsIDREF="apA.cmd149"dbx CommandsIDREF="08.multiple33"Resuming a Suspended Processrunning process, wait forIDREF="apA.cmd222"dbx CommandsIDREF="08.multiple40"Waiting for Any Running Processrunning programsIDREF="02.run42"Running Your ProgramIDREF="apA.cmd153"dbx CommandsIDREF="02.run34"Running Your ProgramIDREF="apA.cmd146"dbx CommandsIDREF="02.run23"dbx Optionsscope of program variablesIDREF="05.change90"Moving to a Specified ProcedureIDREF="05.change48"Variable ScopeIDREF="05.change84"Moving Within the StackIDREF="05.change74"Examining the StackscriptsIDREF="04.cntrl74"Executing dbx Scriptssearch backward (?) commandIDREF="apA.cmd8"dbx CommandsIDREF="03.examin27"Searching Through Source CodeIDREF="03.examin25"Searching Through Source Codesearch forward (/) commandIDREF="03.examin26"Searching Through Source CodeIDREF="apA.cmd4"dbx CommandsIDREF="03.examin24"Searching Through Source Codesearching source codeIDREF="03.examin23"Searching Through Source CodeIDREF="apA.cmd9"dbx CommandsIDREF="apA.cmd5"dbx Commandsselect active process from process poolIDREF="apA.cmd21"dbx CommandsIDREF="08.multiple19"Selecting a Processsending signalsIDREF="08.multiple34"Resuming a Suspended ProcessIDREF="06.exec27"Continuing Execution After a BreakpointIDREF="apA.cmd150"dbx CommandsIDREF="07.mach45"Continuing Execution After a Machine-Level Breakpointsetting dbx variablesIDREF="04.cntrl3"Setting dbx VariablesIDREF="04.cntrl6"Setting dbx VariablesIDREF="apA.cmd159"dbx Commandssetting breakpointsIDREF="01.start14"Debugging Your Programssetting conditional breakpointsIDREF="06.exec11"Setting Conditional Breakpointssetting conditional commandsIDREF="06.exec41"Writing Conditional Commandssetting unconditional breakpointsIDREF="apA.cmd176"dbx CommandsIDREF="06.exec7"Setting Unconditional BreakpointsIDREF="apA.cmd177"dbx Commandsshell command, executingIDREF="apA.cmd162"dbx CommandsIDREF="02.run52"Invoking a Shellshell, invoking from dbxIDREF="apA.cmd161"dbx CommandsIDREF="02.run50"Invoking a Shellshowing processes in the process group listIDREF="08.multiple63"Handling sproc System Calls and Process Group DebuggingIDREF="apA.cmd164"dbx CommandssignalscatchingIDREF="06.exec64"Catching and Ignoring SignalsIDREF="apA.cmd49"dbx Commandscontinuing after catchingIDREF="06.exec72"Continuing After Catching a SignalIDREF="06.exec71"Continuing After Catching a Signaldisplaying caughtIDREF="06.exec67"Catching and Ignoring SignalsIDREF="apA.cmd47"dbx Commandsdisplaying ignoredIDREF="apA.cmd107"dbx CommandsIDREF="06.exec69"Catching and Ignoring SignalsignoringIDREF="06.exec66"Catching and Ignoring SignalsIDREF="apA.cmd108"dbx CommandssendingIDREF="apA.cmd150"dbx CommandsIDREF="06.exec27"Continuing Execution After a BreakpointIDREF="08.multiple34"Resuming a Suspended ProcessIDREF="07.mach45"Continuing Execution After a Machine-Level Breakpointsingle-steppingIDREF="01.start26"Studying a New ProgramIDREF="apA.cmd173"dbx CommandsIDREF="apA.cmd118"dbx CommandsIDREF="06.exec87"Stepping Through Your Programsingle-stepping at the machine-code levelIDREF="07.mach67"Stepping Through Machine Codesource codesearchingIDREF="apA.cmd5"dbx CommandsIDREF="apA.cmd9"dbx CommandsIDREF="03.examin23"Searching Through Source Codesource directoriesspecifyingIDREF="03.examin10"Specifying Source Directories With dbx CommandsIDREF="apA.cmd67"dbx CommandsIDREF="apA.cmd217"dbx CommandsIDREF="03.examin15"Using Path RemappingIDREF="03.examin5"Specifying Source Directories With ArgumentsIDREF="03.examin12"Specifying Source Directories With dbx Commandssource filesIDREF="03.examin1"Specifying Source DirectorieseditingIDREF="03.examin29"Calling an EditorIDREF="apA.cmd78"dbx CommandsIDREF="apA.cmd82"dbx CommandsdbxIDREF="03.examin13"Using Path RemappinglocatingIDREF="03.examin13"Using Path RemappingspecifyingIDREF="03.examin5"Specifying Source Directories With ArgumentsIDREF="03.examin10"Specifying Source Directories With dbx CommandsIDREF="apA.cmd67"dbx CommandsIDREF="03.examin12"Specifying Source Directories With dbx CommandsIDREF="02.run8"dbx OptionsIDREF="03.examin15"Using Path RemappingIDREF="03.examin17"Changing Source FilesIDREF="apA.cmd88"dbx CommandsIDREF="apA.cmd217"dbx Commandssource lines, tracingIDREF="01.start30"Studying a New ProgramstackexaminingIDREF="05.change72"Examining the StackIDREF="01.start18"Debugging Your ProgramsIDREF="05.change79"Printing Stack TracesprintingIDREF="05.change79"Printing Stack TracestraceIDREF="apA.cmd230"dbx CommandsIDREF="05.change76"Printing Stack TracesIDREF="01.start5"Examining Core Dumps to Determine Cause of Failurestandard errorIDREF="apA.cmd156"dbx CommandsIDREF="02.run40"Running Your Programstandard inputIDREF="02.run38"Running Your ProgramIDREF="apA.cmd154"dbx Commandsstandard outputIDREF="apA.cmd155"dbx CommandsIDREF="02.run39"Running Your Programstring constantsIDREF="05.change13"ConstantsIDREF="05.change29"String Constantsescape sequencesIDREF="05.change32"String Constantsstripped symbol tableIDREF="01.start8"Examining Core Dumps to Determine Cause of Failuresuspend active processIDREF="08.multiple22"Suspending a Processsuspend process in process poolIDREF="08.multiple28"Suspending a ProcessIDREF="08.multiple24"Suspending a ProcessIDREF="08.multiple26"Suspending a ProcessIDREF="apA.cmd183"dbx Commandssymbol tablestrippedIDREF="01.start8"Examining Core Dumps to Determine Cause of Failuresystem callscatchingIDREF="06.exec75"Stopping at System CallsIDREF="apA.cmd188"dbx Commandsdisplaying caughtIDREF="apA.cmd186"dbx CommandsIDREF="06.exec78"Stopping at System Callsdisplaying ignoredIDREF="06.exec79"Stopping at System CallsIDREF="apA.cmd187"dbx CommandsexecIDREF="08.multiple49"Handling exec System CallsexecvIDREF="06.exec84"Stopping at System CallsexecveIDREF="06.exec85"Stopping at System CallsexitIDREF="06.exec86"Stopping at System CallsforkIDREF="apC.vars10"Predefined dbx Variables    IDREF="08.multiple2"ProcessesIDREF="08.multiple56"Handling sproc System Calls and Process Group DebuggingIDREF="08.multiple46"Handling fork System CallsIDREF="apC.vars8"Predefined dbx Variables    IDREF="06.exec80"Stopping at System CallssprocIDREF="apC.vars9"Predefined dbx Variables    IDREF="apC.vars11"Predefined dbx Variables    IDREF="08.multiple51"Handling sproc System Calls and Process Group DebuggingIDREF="08.multiple3"ProcessesIDREF="08.multiple55"Handling sproc System Calls and Process Group DebuggingIDREF="06.exec81"Stopping at System CallsignoringIDREF="apA.cmd189"dbx CommandsIDREF="06.exec77"Stopping at System CallstracingdeletingIDREF="apA.cmd60"dbx CommandsIDREF="06.exec61"Deleting Breakpoints, Traces, and Conditional CommandsdisablingIDREF="06.exec52"Disabling Breakpoints, Traces, and Conditional CommandsIDREF="apA.cmd70"dbx CommandsenablingIDREF="apA.cmd85"dbx CommandsIDREF="06.exec56"Enabling Breakpoints, Traces, and Conditional CommandsproceduresIDREF="apA.cmd201"dbx CommandsIDREF="apA.cmd194"dbx CommandsIDREF="01.start29"Studying a New ProgramIDREF="06.exec36"Tracing Program Executionprocess groupsIDREF="08.multiple67"Handling sproc System Calls and Process Group Debuggingsource linesIDREF="01.start30"Studying a New ProgramstatusIDREF="apA.cmd170"dbx CommandsIDREF="06.exec48"Listing Breakpoints, Traces, and Conditional CommandsvariablesIDREF="07.mach57"Tracing Execution at the Machine LevelIDREF="07.mach59"Tracing Execution at the Machine LevelIDREF="07.mach61"Tracing Execution at the Machine LevelIDREF="07.mach63"Tracing Execution at the Machine LevelIDREF="06.exec34"Tracing Program ExecutionIDREF="apA.cmd192"dbx CommandsIDREF="apA.cmd195"dbx CommandsIDREF="apA.cmd196"dbx CommandsIDREF="apA.cmd197"dbx CommandsIDREF="apA.cmd198"dbx CommandsIDREF="apA.cmd200"dbx CommandsIDREF="apA.cmd202"dbx CommandsIDREF="apA.cmd203"dbx CommandsIDREF="apA.cmd204"dbx CommandsIDREF="apA.cmd205"dbx CommandsIDREF="06.exec38"Tracing Program ExecutionIDREF="01.start28"Studying a New ProgramIDREF="07.mach54"Tracing Execution at the Machine LeveltroubleshootingIDREF="01.start31"Avoiding Common Pitfallstype castingIDREF="05.change44"Using Data Types and Type Coercion (Casts)type conversionIDREF="05.change43"Using Data Types and Type Coercion (Casts)type declarations of program variable namesIDREF="apA.cmd224"dbx CommandsIDREF="05.change70"Displaying Type Declarationsunconditional breakpointsIDREF="01.start11"Debugging Your ProgramsIDREF="06.exec2"Setting BreakpointssettingIDREF="06.exec7"Setting Unconditional BreakpointsIDREF="apA.cmd176"dbx CommandsIDREF="apA.cmd177"dbx Commandsunstacking interactive function callsIDREF="05.change100"Using ccallusepath remappingIDREF="03.examin13"Using Path Remapping$addrfmt64IDREF="apC.vars14"Predefined dbx Variables    $addrfmtIDREF="apC.vars13"Predefined dbx Variables    $assignverifyIDREF="apC.vars15"Predefined dbx Variables    $casesenseIDREF="05.change67"Case Sensitivity in Variable NamesIDREF="apC.vars16"Predefined dbx Variables    $ctypenamesIDREF="05.change65"Conflicts Between Variable Names and KeywordsIDREF="apC.vars18"Predefined dbx Variables    $cureventIDREF="apC.vars20"Predefined dbx Variables    $curlineIDREF="apC.vars21"Predefined dbx Variables    $curpcIDREF="apC.vars22"Predefined dbx Variables    $cursrclineIDREF="apC.vars23"Predefined dbx Variables    $debugrldIDREF="apC.vars24"Predefined dbx Variables    $defaultinIDREF="apA.cmd140"dbx CommandsIDREF="04.cntrl57"Recording InputIDREF="apC.vars25"Predefined dbx Variables    $defaultoutIDREF="apC.vars27"Predefined dbx Variables    IDREF="04.cntrl71"Recording OutputIDREF="apA.cmd143"dbx Commands$editorIDREF="apA.cmd79"dbx CommandsIDREF="04.cntrl27"The History EditorIDREF="03.examin31"Calling an EditorIDREF="apC.vars28"Predefined dbx Variables    $fp_preciseIDREF="apC.vars30"Predefined dbx Variables    $frameregIDREF="apC.vars31"Predefined dbx Variables    $groupforktooIDREF="apC.vars32"Predefined dbx Variables    IDREF="08.multiple58"Handling sproc System Calls and Process Group Debugging$hexcharsIDREF="apC.vars57"Predefined dbx Variables    IDREF="apC.vars33"Predefined dbx Variables    $hexdoublesIDREF="apC.vars34"Predefined dbx Variables    $hexinIDREF="apC.vars48"Predefined dbx Variables    IDREF="apC.vars35"Predefined dbx Variables    IDREF="05.change22"Numeric Constants$hexintsIDREF="05.change28"Numeric ConstantsIDREF="07.mach8"Printing Register ValuesIDREF="apC.vars51"Predefined dbx Variables    IDREF="apC.vars36"Predefined dbx Variables    $hexstringsIDREF="apC.vars37"Predefined dbx Variables    $historyeventIDREF="apC.vars38"Predefined dbx Variables    $lastchildIDREF="apC.vars39"Predefined dbx Variables    IDREF="08.multiple7"Using Scripts$linesIDREF="apC.vars40"Predefined dbx Variables    $listwindowIDREF="03.examin22"Listing Source CodeIDREF="03.examin19"Listing Source CodeIDREF="apA.cmd113"dbx CommandsIDREF="apA.cmd114"dbx CommandsIDREF="apC.vars41"Predefined dbx Variables    IDREF="apA.cmd115"dbx CommandsIDREF="03.examin21"Listing Source Code$maxstrlenIDREF="apC.vars42"Predefined dbx Variables    $mp_programIDREF="06.exec83"Stopping at System CallsIDREF="08.multiple54"Handling sproc System Calls and Process Group DebuggingIDREF="apC.vars43"Predefined dbx Variables    $neweventIDREF="apC.vars44"Predefined dbx Variables    $newpgrpeventIDREF="apC.vars45"Predefined dbx Variables    $octinIDREF="05.change20"Numeric ConstantsIDREF="apC.vars46"Predefined dbx Variables    $octintsIDREF="07.mach7"Printing Register ValuesIDREF="05.change26"Numeric ConstantsIDREF="apC.vars49"Predefined dbx Variables    $pageIDREF="apC.vars52"Predefined dbx Variables    $pagerIDREF="apC.vars53"Predefined dbx Variables    IDREF="apA.cmd104"dbx CommandsIDREF="02.run47"Using Online HelpIDREF="apA.cmd103"dbx Commands$pagewidthIDREF="apC.vars55"Predefined dbx Variables    $pagewindowIDREF="apC.vars56"Predefined dbx Variables    $piaddtohistIDREF="apC.vars58"Predefined dbx Variables    $pid0IDREF="apC.vars61"Predefined dbx Variables    IDREF="08.multiple8"Using Scripts$pidIDREF="apC.vars68"Predefined dbx Variables    IDREF="apC.vars60"Predefined dbx Variables    $pimodeIDREF="apC.vars62"Predefined dbx Variables    IDREF="04.cntrl67"Playing Back InputIDREF="apA.cmd122"dbx CommandsIDREF="04.cntrl32"The History Editor$printdataIDREF="apC.vars64"Predefined dbx Variables    $printwhilestepIDREF="apC.vars65"Predefined dbx Variables    $printwideIDREF="apC.vars66"Predefined dbx Variables    $procaddrIDREF="apC.vars67"Predefined dbx Variables    $promptIDREF="02.run29"The dbx PromptIDREF="apC.vars69"Predefined dbx Variables    $promptonforkIDREF="apC.vars71"Predefined dbx Variables    IDREF="08.multiple47"Handling fork System CallsIDREF="08.multiple48"Handling fork System CallsIDREF="06.exec82"Stopping at System Calls$regstyleIDREF="07.mach3"Examining and Changing Register ValuesIDREF="apC.vars72"Predefined dbx Variables    $repeatmodeIDREF="apC.vars74"Predefined dbx Variables    IDREF="04.cntrl20"Repeating CommandsIDREF="apA.cmd13"dbx Commands$rimodeIDREF="04.cntrl70"Recording OutputIDREF="apC.vars76"Predefined dbx Variables    IDREF="apA.cmd144"dbx Commands$showbreakaddrsIDREF="apC.vars77"Predefined dbx Variables    $stacktracelimitIDREF="apC.vars78"Predefined dbx Variables    $stepintoallIDREF="06.exec93"Stepping Using the step CommandIDREF="07.mach73"Stepping Through Machine CodeIDREF="apC.vars79"Predefined dbx Variables    $tagfileIDREF="apC.vars80"Predefined dbx Variables    EDITOR environment variableIDREF="04.cntrl28"The History EditorIDREF="03.examin32"Calling an EditorIDREF="apC.vars3"Predefined dbx Variables    IDREF="apA.cmd80"dbx CommandsHOME environment variableIDREF="02.run44"Automatically Executing Commands on Startupvariablesdbx. See dbx variablesIDREF="05.change1"Using ExpressionsIDREF="04.cntrl1"Creating and Removing dbx Variablesdo not displayIDREF="01.start32"Avoiding Common Pitfallsvariables, predefined dbx. See predefined dbx variablesIDREF="apC.vars12"Predefined dbx Variables    variables, programIDREF="05.change2"Using ExpressionsIDREF="05.change45"Displaying and Changing Program Variablescase sensitivityIDREF="05.change66"Case Sensitivity in Variable NamesIDREF="apC.vars17"Predefined dbx Variables    changing valuesIDREF="apA.cmd45"dbx CommandsIDREF="05.change60"Changing the Value of a Variabledetermining scopeIDREF="05.change68"Determining the Scope of VariablesIDREF="apA.cmd232"dbx CommandsexaminingIDREF="01.start25"Studying a New ProgramIDREF="01.start17"Debugging Your Programsexamining arraysIDREF="05.change58"Displaying the Value of a Variablenames and C keyword conflictsIDREF="05.change64"Conflicts Between Variable Names and KeywordsIDREF="apC.vars19"Predefined dbx Variables    names and keyword conflictsIDREF="05.change63"Conflicts Between Variable Names and KeywordsprintingIDREF="05.change49"Displaying the Value of a Variablequalifying variable namesIDREF="05.change75"Examining the StackIDREF="06.exec40"Tracing Program ExecutionIDREF="05.change46"Qualifying Variable NamesscopeIDREF="05.change84"Moving Within the StackIDREF="05.change90"Moving to a Specified ProcedureIDREF="05.change48"Variable ScopeIDREF="05.change47"Qualifying Variable NamesIDREF="05.change74"Examining the StacktracingIDREF="01.start28"Studying a New Programtype declarationsIDREF="apA.cmd224"dbx CommandsIDREF="05.change70"Displaying Type Declarationswait for active processIDREF="apA.cmd219"dbx CommandsIDREF="08.multiple37"Waiting for a Resumed Processwait for processIDREF="08.multiple39"Waiting for a Resumed ProcessIDREF="apA.cmd220"dbx Commandswait for running processIDREF="apA.cmd222"dbx CommandsIDREF="08.multiple40"Waiting for Any Running Process